<html>
<head><meta charset="utf-8"><title>Deutsch-Jozsa · quantum computing · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/index.html">quantum computing</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html">Deutsch-Jozsa</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="169640026"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/169640026" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#169640026">(Jul 04 2019 at 11:23)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span> I simplified <code>is_balanced</code>. Indeed, one should be able to prove <code>is_balanced_inter</code> and <code>is_balanced_union</code>. It should not be necessary to embed these two lemmas in the definition <code>is_balanced</code>.<br>
Please see my PR.</p>



<a name="169641771"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/169641771" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#169641771">(Jul 04 2019 at 11:53)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span>  I replaced the name <code>deutsch_jozsa</code> with <code>jozsa</code> which is shorter <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span>  and I made all the changes accordingly.</p>



<a name="169734378"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/169734378" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#169734378">(Jul 05 2019 at 20:33)</a>:</h4>
<p>I just completed the proof of the lemma <code>is_balanced_union</code> (see PR).</p>



<a name="169737148"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/169737148" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#169737148">(Jul 05 2019 at 21:37)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span>  What is the purpose of <code>[case_names ge 1 step]</code> in <code>ind_from_1</code> ? I'm not sure since if I remove it, the rest of the code still works.</p>



<a name="169737423"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/169737423" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#169737423">(Jul 05 2019 at 21:43)</a>:</h4>
<p>If you use the induction rule it gives you a name for the cases, i.e.<br>
proof (induction n rule: ind_from_1)<br>
  case ge <br>
  show ?case <br>
next<br>
  case 1<br>
...<br>
This is good if the induction rule is very unusual and hard to understand. E.g. if you have strange base cases or something.</p>
<p>I didn't used it in the code as I found it sufficiently understandable without the case name and will probably remove it.  I am just working on tidying up the code a bit, a lot of it is provisional as I tried out a lot today to find the best way of defining stuff.</p>



<a name="169737704"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/169737704" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#169737704">(Jul 05 2019 at 21:50)</a>:</h4>
<p>It's nice that you renamed the cases thanks to <code>[case_names ge 1 step]</code>. Otherwise <code>case 1</code>, <code>case 2</code> and <code>case (3 n)</code> that one sees are not very telling.</p>



<a name="170437848"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170437848" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170437848">(Jul 09 2019 at 09:36)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span>  What were your motivations to change <code>const</code> ?</p>



<a name="170438113"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170438113" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170438113">(Jul 09 2019 at 09:40)</a>:</h4>
<p>I wanted to add an assumption to the locale jozsa that ensures that each function is either constant or balanced. For this is_const and is_balanced have to be defined before the locale specification since assumptions cannot be added to locale afterwards. However, I am still not at a point where I need to use is_const or is_balanced at all so I kept that issue for later.</p>



<a name="170438956"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170438956" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170438956">(Jul 09 2019 at 09:54)</a>:</h4>
<p>Ok, I see. The assumption in the locale <code>jozsa</code> that <code>f</code> is either constant or balanced is fine, and even needed, since in a Deutsch's problem Bob promises Alice that he will use a fonction that is either constant or balanced.<br>
But, given how <code>const</code> is defined (with a parameter <code>n</code> for the domain of <code>f</code>) this definition and also <code>is_balanced</code> should be in a dedicated locale with <code>jozsa</code> as a sublocale.<br>
I will do it.</p>



<a name="170439186"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170439186" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170439186">(Jul 09 2019 at 09:58)</a>:</h4>
<p>Do you agree ?</p>



<a name="170439679"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170439679" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170439679">(Jul 09 2019 at 10:06)</a>:</h4>
<p>Yes I had that thought too.  I think I even wrote it in a commentary  or something so I think it's a good idea</p>



<a name="170441424"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170441424" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170441424">(Jul 09 2019 at 10:35)</a>:</h4>
<p>PR submitted.</p>



<a name="170531309"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170531309" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170531309">(Jul 10 2019 at 10:59)</a>:</h4>
<p>Does someone have an idea how a matrix representation of the result of taking n times the tensor product of H would look like?</p>



<a name="170560398"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170560398" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170560398">(Jul 10 2019 at 17:16)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span>  I assume that you want the matrix representation of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> H^{\otimes n}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊗</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> wrt the computational basis. For <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">i,j\leq 2^n </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>, it's given by</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><msup><mn>2</mn><mi>n</mi></msup></msqrt></mfrac><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mrow><mi>j</mi><mi mathvariant="normal">.</mi><mi>i</mi></mrow></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">H^{\otimes n}(i,j) = \frac{1}{\sqrt{2^n}} (-1)^{j.i},</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊗</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25144em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.2027799999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.590392em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mord mtight">.</span><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi mathvariant="normal">.</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">j.i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">.</span><span class="mord mathdefault">i</span></span></span></span> denotes the <strong>bitwise</strong> inner product of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>j</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|j\rangle</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">⟩</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|i\rangle</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mclose">⟩</span></span></span></span>.</p>



<a name="170561273"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170561273" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170561273">(Jul 10 2019 at 17:27)</a>:</h4>
<p>Thanks a lot :)</p>



<a name="170564534"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170564534" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170564534">(Jul 10 2019 at 18:03)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span> Two additional remarks. First, the inner product  <code>inner_prod</code> is defined in <code>Quantum.thy</code> and denoted <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⟨</mo><mi>i</mi><mi mathvariant="normal">∣</mi><mi>j</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle i|j\rangle</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">⟩</span></span></span></span>. Second, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|i\rangle </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mclose">⟩</span></span></span></span> (the ith element of the computational basis ) is just <code>unit_vec 2^n i</code>.</p>



<a name="170574914"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170574914" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170574914">(Jul 10 2019 at 20:04)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span>  It makes sense to introduce the abbreviation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">.</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">i.j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⟨</mo><mrow><mtext>u</mtext><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>e</mi><mi>c</mi></mrow><mtext>  </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext>  </mtext><mi>i</mi><mi mathvariant="normal">∣</mi><mrow><mtext>u</mtext><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>e</mi><mi>c</mi></mrow><mtext>  </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext>  </mtext><mi>j</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle {\text unit\_vec}\;2^n\;i|{\text unit\_vec}\;2^n\;j\rangle</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord text"><span class="mord">u</span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord"><span class="mord text"><span class="mord">u</span></span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">⟩</span></span></span></span> if you plan to use it heavily.</p>



<a name="170613707"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170613707" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170613707">(Jul 11 2019 at 08:42)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span> I plan to work on your theory. What is the next thing I should tackle ?</p>



<a name="170613901"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170613901" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170613901">(Jul 11 2019 at 08:45)</a>:</h4>
<p>I am still trying to understand the matrix representation of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">H^{\otimes n}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊗</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>. I would be happy if you could explain it to me again. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⟨</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>i</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>j</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle unit\_vec ~2^n~ i| unit\_vec~ 2^n~ j \rangle </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">⟨</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">⟩</span></span></span></span> is 1 if i=j and 0 otw. right? But e.g. for n=1, i.e. just the usual Hadamard gate the element at position i=0 and j=0 should be positive not negative. I found a solution for which I convert decimals into binaries which is not a nice thing to express the gate with.</p>



<a name="170614056"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170614056" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170614056">(Jul 11 2019 at 08:47)</a>:</h4>
<p>Besides that I was sometimes unsure about design choices, I made comments in the code in that case. I finished everything up to the last application of the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊕</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">H^{\oplus n}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊕</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> gate (and of course the measurement following after that). I might need to restructure some things though depending on this last bit (regarding the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\ge 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> issue outside of the locale).</p>



<a name="170615280"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170615280" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170615280">(Jul 11 2019 at 09:05)</a>:</h4>
<blockquote>
<p>I am still trying to understand the matrix representation of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">H^{\otimes n}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊗</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>. I would be happy if you could explain it to me again. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⟨</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>i</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>j</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle unit\_vec ~2^n~ i| unit\_vec~ 2^n~ j \rangle </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">⟨</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord mathdefault">i</span><span class="mord">∣</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mspace nobreak"> </span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace nobreak"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">⟩</span></span></span></span> is 1 if i=j and 0 otw. right? </p>
</blockquote>
<p>correct</p>
<blockquote>
<p>But e.g. for n=1, i.e. just the usual Hadamard gate the element at position i=0 and j=0 should be positive not negative.</p>
</blockquote>
<p>The formula is correct, but <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi mathvariant="normal">.</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">j.i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">.</span><span class="mord mathdefault">i</span></span></span></span> is the bitwise inner product of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>i</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|i\rangle</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">i</span><span class="mclose">⟩</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>j</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|j\rangle</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">⟩</span></span></span></span>.</p>



<a name="170616623"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170616623" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170616623">(Jul 11 2019 at 09:27)</a>:</h4>
<p>So, it's not the <code>inner_prod</code> in <code>Quantum.thy</code>.  I will edit my previous post.<br>
For instance, the bitwise inner product of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mn>00</mn><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">|00\rangle</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">⟩</span></span></span></span> with itself is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, not <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>.</p>



<a name="170616976"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170616976" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170616976">(Jul 11 2019 at 09:32)</a>:</h4>
<p>Then, I guess this is what I have done so far :( Convert i and j into binary numbers, pad them with 0's (depending on the way you define them) and multiply them bitwise. This makes everything very hard to prove. I really hoped that there was a better way.</p>



<a name="170617723"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170617723" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170617723">(Jul 11 2019 at 09:43)</a>:</h4>
<p>Given <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">0 \leq i&lt;2^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>, we need its binary representation, then we will be able to define the bitwise inner product of any two unit vectors of dimension <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>.</p>



<a name="170620674"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170620674" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170620674">(Jul 11 2019 at 10:25)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span>  Does it seem reasonable ? After that , everything should be easy to prove. I will write a theory <code>Binary_Nat.thy</code>and push it into my master branch for you to use it. Is it ok ?</p>



<a name="170620991"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170620991" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170620991">(Jul 11 2019 at 10:30)</a>:</h4>
<p><span class="user-mention" data-user-id="228778">@Anthony Bordg</span>  I already did that but in a rather specific way. It would probably be good to have it more general so I would be glad if you could do that.</p>



<a name="170637470"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170637470" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170637470">(Jul 11 2019 at 14:22)</a>:</h4>
<p><span class="user-mention" data-user-id="228778">@Anthony Bordg</span>  did you already start? My approach seems to be rather inefficient, the proof that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊕</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">H^{\oplus n}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">⊕</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> equals this new representation takes forever and is rather ugly. I basically just converted the decimals with the usual method (divide and mod by 2). The output is a nat list containing 0's and 1's. Then, I wrote another function, taking two of these lists and add 1 to the result if both lists have a 1 at the same entry. Is there a better way?</p>



<a name="170642397"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170642397" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170642397">(Jul 11 2019 at 15:11)</a>:</h4>
<blockquote>
<p><span class="user-mention silent" data-user-id="228778">Anthony Bordg</span>  did you already start? </p>
</blockquote>
<p>Yes, I started but it's not ready yet. <span aria-label="working on it" class="emoji emoji-1f6e0" role="img" title="working on it">:working_on_it:</span></p>



<a name="170884585"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170884585" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170884585">(Jul 15 2019 at 11:36)</a>:</h4>
<p><code>Binary_Nat.thy</code> (see my master branch) is almost completely done, but one <code>sorry</code> remains inside the last proof (the proof of <code>bin_rep_eq</code>). The step is quite obvious, since the terms in the sum cancel except the first and the last ones, but I have a hard time making it clear to Isabelle. To help I think one needs to use <code>of_nat</code>, but even so the proof remains problematic. <br>
Do you have any suggestion to help Isabelle ?</p>



<a name="170885289"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170885289" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yijun He <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170885289">(Jul 15 2019 at 11:50)</a>:</h4>
<p>Is there a way to separate the sum <code>\&lt;Sum&gt;i&lt;n. m mod 2^(n-i) - m mod 2^(n-1-i)</code>into the difference of two sums?</p>



<a name="170885568"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170885568" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yijun He <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170885568">(Jul 15 2019 at 11:54)</a>:</h4>
<p>We will then obtain <code>\&lt;Sum&gt;i&lt;n. m mod 2^(n-i) - \&lt;Sum&gt;i&lt;n. m mod 2^(n-1-i)</code>. Then we can take out the first and last terms, giving <code>\&lt;Sum&gt;i\&lt;in&gt;{1..&lt;n}. m mod 2^(n-i) - \&lt;Sum&gt;i\&lt;in&gt;{0..&lt;n-1}. m mod 2^(n-1-i)</code>. These two sums should cancel out by a lemma <code>sum_diff</code>.</p>



<a name="170886497"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170886497" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170886497">(Jul 15 2019 at 12:09)</a>:</h4>
<p>I will try it.</p>



<a name="170886622"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170886622" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Yijun He <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170886622">(Jul 15 2019 at 12:11)</a>:</h4>
<p>Also the <code>sum_diff</code> is the lemma in <code>Basics.thy</code>, and importing the theory will cause some proofs in <code>Binary_Nat.thy</code> to fail, but they can easily be fixed.</p>



<a name="170931296"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170931296" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170931296">(Jul 15 2019 at 21:01)</a>:</h4>
<p><span class="user-mention" data-user-id="228785">@Yijun He</span> By the way I realize that <code>sum_diff</code> it's a misnomer , it should be called something like <code>sum_of_index_diff</code>. I will fix the name.</p>



<a name="170931585"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/170931585" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#170931585">(Jul 15 2019 at 21:04)</a>:</h4>
<p><span class="user-mention" data-user-id="228785">@Yijun He</span> The relevant lemma is <code>sum_subtractf</code> in <code>Groups_Big.thy</code>.</p>



<a name="171060994"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171060994" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171060994">(Jul 17 2019 at 09:08)</a>:</h4>
<p>But now the definition for the bitwise inner product I build upon bin_rep and all proofs built on that are not working anymore. Is there no other solution? It is a nat list after all.  Adding <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m \ge 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> does not instantly help but I will try to adapt the proofs in another way to the new def of bin_rep :)</p>



<a name="171064207"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171064207" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171064207">(Jul 17 2019 at 10:05)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span> Ok, I will try to help.</p>



<a name="171064606"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171064606" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171064606">(Jul 17 2019 at 10:13)</a>:</h4>
<p>Thanks, I am already halfway through. I just did a new commit, maybe I should have defined  bitwise_inner_product or Hn differently (I had that nat first in Hn and not in bitwise_inner_product)?</p>



<a name="171067411"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171067411" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171067411">(Jul 17 2019 at 11:00)</a>:</h4>
<p>I finished except for one small lemma :)</p>



<a name="171067950"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171067950" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171067950">(Jul 17 2019 at 11:08)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span>  I'm currently having a look at it. The first thing which is not very clear for me is the order of the three arguments. The natural order is <code>bitwise_inner_product n i j</code>, but with your notation it seems that the order is <code>bitwise_inner_product i n j</code>. Is it correct ?</p>



<a name="171068349"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171068349" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171068349">(Jul 17 2019 at 11:16)</a>:</h4>
<p>Yes please also see the comment I left about that. If we want to use the notation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><msub><mo>⋅</mo><mi>n</mi></msub><mi>j</mi></mrow><annotation encoding="application/x-tex">i ⋅_n j </annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⋅</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> the order of the argument is fixed as i n j otherwise it can easily be changed to i n j.</p>



<a name="171068521"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171068521" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171068521">(Jul 17 2019 at 11:19)</a>:</h4>
<p>Since its not possible to write <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><msub><mo>⋅</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>j</mi></mrow><annotation encoding="application/x-tex">i⋅_{n+1} j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8678509999999999em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin"><span class="mbin">⋅</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>, maybe this should be discarded after all anyway</p>



<a name="171068569"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171068569" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171068569">(Jul 17 2019 at 11:20)</a>:</h4>
<p>Ok, after the lunch I will make a few changes. In the meantime please continue with your proofs.</p>



<a name="171423152"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171423152" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171423152">(Jul 22 2019 at 11:43)</a>:</h4>
<p>I pushed the measurement outline</p>



<a name="171434667"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171434667" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171434667">(Jul 22 2019 at 14:22)</a>:</h4>
<p>Thanks Hanna. I will have a look as soon as possible, but first I need to work a little bit more on the quantum Fourier transform.</p>



<a name="171677188"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171677188" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171677188">(Jul 25 2019 at 09:48)</a>:</h4>
<p>I finished the Deutsch-Jozsa algorithm <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span> Except from that (optional?) proof we talked about earlier everything is done. But I still need to tidy everything up a bit.</p>



<a name="171677323"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/171677323" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#171677323">(Jul 25 2019 at 09:50)</a>:</h4>
<p>Congrats! <span aria-label="tada" class="emoji emoji-1f389" role="img" title="tada">:tada:</span></p>



<a name="172298672"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172298672" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172298672">(Aug 02 2019 at 10:36)</a>:</h4>
<p>Is all the type-information in <code>is_balanced</code> needed ?</p>



<a name="172298831"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172298831" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172298831">(Aug 02 2019 at 10:40)</a>:</h4>
<p>It was but actually it might not be needed anymore (or at least not that many type annotations)</p>



<a name="172299458"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172299458" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172299458">(Aug 02 2019 at 10:56)</a>:</h4>
<p>Is not <code>ind_from_1</code> a particular case of <code>nat_induct_at_least</code> ?</p>



<a name="172300463"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172300463" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172300463">(Aug 02 2019 at 11:18)</a>:</h4>
<p>It might be useful though.</p>



<a name="172301930"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172301930" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172301930">(Aug 02 2019 at 11:48)</a>:</h4>
<p>I would say that <code>Uf_mult_without_empty_summands_sum_even</code> is easier to read than <code>Uf_mult_without_empty_summands_sum_even'</code>.<br>
I removed the braces since there are not needed.</p>



<a name="172303307"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172303307" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172303307">(Aug 02 2019 at 12:15)</a>:</h4>
<p>I will change <code>Uf_mult_without_empty_summands_sum_even</code> accordingly after you finish looking over the file</p>



<a name="172303373"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172303373" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172303373">(Aug 02 2019 at 12:16)</a>:</h4>
<blockquote>
<p>Is not <code>ind_from_1</code> a particular case of <code>nat_induct_at_least</code> ?</p>
</blockquote>
<p>I didn't noticed that. I looked it up in the internet and there it was suggested to write a customary induction rule. It might be better to use the existing one, i.e.  <code>nat_induct_at_least</code></p>



<a name="172325459"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172325459" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172325459">(Aug 02 2019 at 17:11)</a>:</h4>
<p>For <code>bin_rep_geq_0</code> note that there is a very simple proof, namely <code>using assms by simp</code>. Actually, this lemma is probably not even necessary.</p>



<a name="172328998"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172328998" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172328998">(Aug 02 2019 at 17:58)</a>:</h4>
<p>From <code> H_tensor_n_is_tensor_of_H</code> one can factor out a lemma, namely <code>H^⇩⊗ 1 = H</code>.</p>



<a name="172401124"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172401124" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172401124">(Aug 03 2019 at 10:26)</a>:</h4>
<p>In <code>sum_every_odd_summand_is_zero</code>, <code>A</code> is an odd choice of notation for a function.</p>



<a name="172403042"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172403042" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172403042">(Aug 03 2019 at 11:29)</a>:</h4>
<p>Sry I was thinking about matrix entries and A is often used to denote an arbitrary matrix. But with the degree of generality the lemma has in its final version (not much to do with matrices anymore) it is better to replace it with another notation.</p>



<a name="172403115"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172403115" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172403115">(Aug 03 2019 at 11:31)</a>:</h4>
<blockquote>
<p>For <code>bin_rep_geq_0</code> note that there is a very simple proof, namely <code>using assms by simp</code>. Actually, this lemma is probably not even necessary.</p>
</blockquote>
<p>Same might be the case for H_values_right_bottom and H_values</p>



<a name="172403211"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172403211" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172403211">(Aug 03 2019 at 11:34)</a>:</h4>
<blockquote>
<blockquote>
<p>Is not <code>ind_from_1</code> a particular case of <code>nat_induct_at_least</code> ?</p>
</blockquote>
<p>I didn't noticed that. I looked it up in the internet and there it was suggested to write a customary induction rule. It might be better to use the existing one, i.e.  <code>nat_induct_at_least</code></p>
</blockquote>
<p>All the proofs using <code>ind_from_1</code> have been rewritten with <code>nat_induct_at_least</code>.</p>



<a name="172408358"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172408358" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172408358">(Aug 03 2019 at 14:20)</a>:</h4>
<p>To help the reader or maintainer, if there are multiple assumptions then one should specify the exact subset of assumptions needed to prove a given fact. For instance, to prove the first fact in the proof of <code>U⇩f_mult_without_empty_summands_even</code>, one should use <code>assms(1,2,4)</code> instead of <code>assms</code>.</p>



<a name="172408629"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172408629" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172408629">(Aug 03 2019 at 14:28)</a>:</h4>
<p>In an intricate formalization one should use <code>show ?thesis</code> whenever possible to declutter the code.</p>



<a name="172409673"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172409673" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172409673">(Aug 03 2019 at 15:01)</a>:</h4>
<p>The proof <code>U⇩f_mult_without_empty_summands_sum_odd</code> has been rewritten in the same style than <code>U⇩f_mult_without_empty_summands_sum_even</code>.</p>



<a name="172412709"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172412709" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172412709">(Aug 03 2019 at 16:38)</a>:</h4>
<p>A simpler name for <code>index_tensor_mat_vec2_i_smaller_row_B</code> would be indeed welcome. <br>
What about <code>index_tensor_mat_with_vec2</code> ? <br>
From the formula it's already clear that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mtext>dim_row</mtext><mtext> </mtext><mi>B</mi></mrow><annotation encoding="application/x-tex">i &lt; \text{dim\_row}\,B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord">dim_row</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>, so one does not need to "embed" this condition into the name. <br>
Ok, I see that a confusion would be possible with <code>index_tensor_mat_vec2_i_greater_row_B</code> which also needs a new name.<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="172412891"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172412891" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172412891">(Aug 03 2019 at 16:44)</a>:</h4>
<p>I was thinking about that too (thats why I suggested that name in the comment), but there is also a lemma called <code>index_tensor_mat_vec2_i_greater_row_B</code>, if you rename <code>index_tensor_mat_vec2_i_smaller_row_B</code> to <code>index_tensor_mat_with_vec2</code>  how would you name that lemma?</p>



<a name="172412914"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172412914" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172412914">(Aug 03 2019 at 16:45)</a>:</h4>
<p>Maybe we could put them together to one lemma with two goals and then name it <code>index_tensor_mat_with_vec2</code>?</p>



<a name="172412962"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172412962" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172412962">(Aug 03 2019 at 16:46)</a>:</h4>
<p>Since thematically they are closely related.</p>



<a name="172413262"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172413262" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172413262">(Aug 03 2019 at 16:54)</a>:</h4>
<blockquote>
<p>Yes maybe we could put them together to one lemma with two goals and then name it <code>index_tensor_mat_with_vec2</code>?</p>
</blockquote>
<p>It's a possible solution. <br>
I hesitate between <code>index_tensor_mat_with_vec2</code>  and <code>index_tensor_mat_with_vec2_row_cond</code>. The name matters only to us, since these two lemmas are too ad hoc to be useful for someone else.</p>



<a name="172413412"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172413412" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172413412">(Aug 03 2019 at 16:58)</a>:</h4>
<p>But in any case, it's worth emphasizing that <code>i</code> and <code>B</code> should not be into the name, since i and B are completely arbitrary, they are mere notations, one could choose <code>k</code> and <code>C</code> or whatever.</p>



<a name="172413701"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172413701" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172413701">(Aug 03 2019 at 17:06)</a>:</h4>
<p>Since the two lemmas don't share the same assumptions, it's not easy to merge them into a single lemma.</p>



<a name="172413796"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172413796" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172413796">(Aug 03 2019 at 17:09)</a>:</h4>
<p>I can simply use <code>index_tensor_mat_with_vec2_row_cond</code> and <code>index_tensor_mat_with_vec2_row_cond_bis</code> which are not great but not bad either.</p>



<a name="172414215"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172414215" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172414215">(Aug 03 2019 at 17:22)</a>:</h4>
<p>What is the problem with:</p>
<div class="codehilite"><pre><span></span>lemma index_tensor_mat_vec2:
  fixes A B:: &quot;complex Matrix.mat&quot; and i:: &quot;nat&quot;
  assumes &quot;i &lt; (dim_row A) * (dim_row B)&quot;
      and &quot;0 &lt; (dim_col A) * (dim_col B)&quot;
      and &quot;dim_row A = 2&quot;
      and &quot;dim_col A = 1&quot;
  shows &quot;i &lt; dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (0, 0)) * (B $$ (i,0))&quot;
    and &quot;i ≥ dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (1, 0)) * (B $$ ( i -dim_row B,0))&quot;
proof-
  show &quot;i &lt; dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (0, 0)) * (B $$ (i,0))&quot;
    using index_tensor_mat assms by auto
next
  show  &quot;i ≥ dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (1, 0)) * (B $$ ( i -dim_row B,0))&quot;
  proof
    assume a0: &quot;i ≥ dim_row B&quot;
    have &quot;(A ⨂ B) $$ (i,0) = A $$ (i div (dim_row B), 0) * B $$ (i mod (dim_row B),0)&quot;
      using assms index_tensor_mat[of A &quot;dim_row A&quot; &quot;dim_col A&quot; B &quot;dim_row B&quot; &quot;dim_col B&quot; i 0]
      by auto
    moreover have &quot;i div (dim_row B) = 1&quot;
      using assms a0
      by simp
    then have &quot;i mod (dim_row B) = i - (dim_row B)&quot;
      by (simp add: modulo_nat_def)
    ultimately show &quot;(A ⨂ B) $$ (i, 0) = (A  $$ (1, 0)) * (B $$ ( i -dim_row B,0))&quot;
      by (simp add: ‹i div dim_row B = 1›)
  qed
qed
</pre></div>


<p>that the assumptions in the first case became stronger?</p>



<a name="172414378"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172414378" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172414378">(Aug 03 2019 at 17:27)</a>:</h4>
<p>Since the first lemma is not needed it could also be deleted (although it feels nicer/more complete to have both cases) and the second could get the short name</p>



<a name="172414553"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172414553" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172414553">(Aug 03 2019 at 17:33)</a>:</h4>
<blockquote>
<p>Since the first lemma is not needed it could also be deleted (although it feels nicer/more complete to have both cases) and the second could get the short name</p>
</blockquote>
<p>Do you mean the first lemma is not used ? If so, it should be deleted.</p>



<a name="172414619"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172414619" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172414619">(Aug 03 2019 at 17:35)</a>:</h4>
<p>One should write <code>assms(1) assms(2) assms(4)</code> for instance as <code>assms(1,2,4)</code> for conciseness.</p>



<a name="172414669"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172414669" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172414669">(Aug 03 2019 at 17:36)</a>:</h4>
<p>No since its proof is very easy it is not.</p>



<a name="172443060"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443060" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443060">(Aug 04 2019 at 09:57)</a>:</h4>
<p>The abbreviations <code>zero</code>, <code>one</code> and the lemmas <code>ket_zero_is_state</code>, <code>ket_one_is_state</code> are duplicates of  those in <code>Deutsch.thy</code>. Idem with <code>H_on_ket_zero_is_state</code>.</p>



<a name="172443191"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443191" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443191">(Aug 04 2019 at 10:01)</a>:</h4>
<p>The lemma <code>ψ⇩1⇩0_values</code> does not need the third assumption.</p>



<a name="172443347"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443347" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443347">(Aug 04 2019 at 10:06)</a>:</h4>
<p>The theory does not import Deutsch.thy</p>



<a name="172443408"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443408" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443408">(Aug 04 2019 at 10:08)</a>:</h4>
<blockquote>
<p>The theory does not import Deutsch.thy</p>
</blockquote>
<p>It does now <span aria-label="slight smile" class="emoji emoji-1f642" role="img" title="slight smile">:slight_smile:</span></p>



<a name="172443409"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443409" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443409">(Aug 04 2019 at 10:08)</a>:</h4>
<p>Of course it could though. Should Grover do it too?</p>



<a name="172443421"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443421" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443421">(Aug 04 2019 at 10:09)</a>:</h4>
<p>I feel for Deutsch and Deutsch-Jozsa it is more reasonable than for Grover</p>



<a name="172443424"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443424" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443424">(Aug 04 2019 at 10:09)</a>:</h4>
<p>Sry for typos I am on my phone</p>



<a name="172443425"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172443425" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172443425">(Aug 04 2019 at 10:09)</a>:</h4>
<blockquote>
<p>But in any case, it's worth emphasizing that <code>i</code> and <code>B</code> should not be into the name, since i and B are completely arbitrary, they are mere notations, one could choose <code>k</code> and <code>C</code> or whatever.</p>
</blockquote>
<p>Same problem with <code>ψ⇩1⇩0_tensor_n</code> for instance. I will simply name it <code>ψ⇩1⇩0_tensor</code>.</p>



<a name="172444990"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172444990" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172444990">(Aug 04 2019 at 11:01)</a>:</h4>
<p>The lemma <code>bin_rep_geq_0</code> is not required.</p>



<a name="172445230"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172445230" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172445230">(Aug 04 2019 at 11:07)</a>:</h4>
<p>There is a lot of places where the assumption <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\geq 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> is not needed.</p>



<a name="172446454"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172446454" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172446454">(Aug 04 2019 at 11:46)</a>:</h4>
<p>The lemma <code>bin_rep_index_0</code> has been generalised.</p>



<a name="172494903"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172494903" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172494903">(Aug 05 2019 at 10:52)</a>:</h4>
<p>A lot of parentheses can be removed to declutter the code.</p>



<a name="172495019"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172495019" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172495019">(Aug 05 2019 at 10:55)</a>:</h4>
<p>In the lemma <code>bitwise_inner_prod_fst_el_0</code> only the first assumption is required. In the same way, the third assumption in <code>bitwise_inner_prod_fst_el_is_1</code> is not necessary.</p>



<a name="172495803"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172495803" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172495803">(Aug 05 2019 at 11:10)</a>:</h4>
<p>The lemma <code>i_div_value_1</code> is not used anywhere, I removed it.</p>



<a name="172497967"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172497967" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172497967">(Aug 05 2019 at 11:50)</a>:</h4>
<p>When the same fact is proven twice for two different variables that play symmetric roles, then one can merge them into a single fact.<br>
For instance, in <code>bitwise_inner_prod_fst_el_is_1</code> one can replace </p>
<div class="codehilite"><pre><span></span>moreover have &quot;k∈{0..n} ⟶ bin_rep (Suc n) i ! (k+1) = bin_rep n (i mod 2^n) ! k&quot; for k
    using bin_rep_def by(metis Suc_eq_plus1 bin_rep_aux.simps(2) bin_rep_aux_neq_nil butlast.simps(2) nth_Cons_Suc)
moreover have &quot;k∈{0..n} ⟶ bin_rep (Suc n) j ! (k+1) = bin_rep n (j mod 2^n) ! k&quot; for k
    using bin_rep_def by(metis Suc_eq_plus1 bin_rep_aux.simps(2) bin_rep_aux_neq_nil butlast.simps(2) nth_Cons_Suc)
</pre></div>


<p>with</p>
<div class="codehilite"><pre><span></span>moreover have &quot;k∈{0..n} ⟶ bin_rep (Suc n) i ! (k+1) = bin_rep n (i mod 2^n) ! k
∧ bin_rep (Suc n) j ! (k+1) = bin_rep n (j mod 2^n) ! k&quot; for k
    using bin_rep_def by(metis Suc_eq_plus1 bin_rep_aux.simps(2) bin_rep_aux_neq_nil butlast.simps(2) nth_Cons_Suc)
</pre></div>



<a name="172498529"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172498529" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172498529">(Aug 05 2019 at 12:01)</a>:</h4>
<p>The declarations <code>declare [[show_types]]</code> may be useful in the process of formalization, but they should be removed before submitting a PR.</p>



<a name="172498691"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172498691" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172498691">(Aug 05 2019 at 12:05)</a>:</h4>
<blockquote>
<p>The declarations <code>declare [[show_types]]</code> may be useful in the process of formalization, but they should be removed before submitting a PR.</p>
</blockquote>
<p>Please see my message about that.</p>



<a name="172509595"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172509595" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172509595">(Aug 05 2019 at 14:40)</a>:</h4>
<p>Note that when <code>i</code> has type <code>nat</code>, then the assumption <code>i ≥ 0</code> is useless.</p>



<a name="172515762"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172515762" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172515762">(Aug 05 2019 at 16:03)</a>:</h4>
<p><code>for k</code> being part of a statement, it should be on the same line with the statement itself.</p>



<a name="172573904"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172573904" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172573904">(Aug 06 2019 at 09:44)</a>:</h4>
<p>Regarding your comment about renaming the lemma <code>sqrt_2_to_n_times_sqrt_2_n_plus_one</code>, this lemma is really ad hoc, so the name does not matter and it won't be used outside the theory. So, what about <code>aux_comp</code> (which stands for <em>auxiliary computation</em>) ?</p>



<a name="172579229"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172579229" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172579229">(Aug 06 2019 at 11:18)</a>:</h4>
<p>Would be already much better than the current name. But aux_comp could mean anything. Maybe sqrt_2_aux_comp or something that has sqrt in its name?</p>



<a name="172593728"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172593728" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172593728">(Aug 06 2019 at 14:30)</a>:</h4>
<blockquote>
<p>Would be already much better than the current name. But aux_comp could mean anything. Maybe sqrt_2_aux_comp or something that has sqrt in its name?</p>
</blockquote>
<p>Ok, <code>aux_comp_with_sqrt2</code> sounds good.</p>



<a name="172596224"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172596224" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172596224">(Aug 06 2019 at 14:57)</a>:</h4>
<p>Given the fact that it's a trivial result, it does not deserve a structured proof.<br>
So, I have replaced </p>
<div class="codehilite"><pre><span></span>lemma sqrt_2_to_n_times_sqrt_2_n_plus_one [simp]:
  shows &quot;2^n/(sqrt(2)^n * sqrt(2)^(n+1)) = 1/sqrt 2&quot;
 proof(induction n)
  show &quot;2^0/(sqrt(2)^0 * sqrt(2)^(0+1)) = 1/sqrt 2&quot; by simp
next
  fix n
  assume IH: &quot;2^n/(sqrt(2)^n * sqrt(2)^(n+1)) = 1/sqrt 2&quot;
  have &quot;sqrt 2 ^ Suc n * sqrt 2 ^ (Suc n + 1) = sqrt(2)^n * sqrt(2)^(n+1) * sqrt(2)^2&quot;
    by simp
  then have &quot;2^Suc n /(sqrt 2 ^ Suc n * sqrt 2 ^ (Suc n + 1)) = (2 ^ n * 2) /(sqrt(2)^n * sqrt(2)^(n+1) * sqrt(2)^2)&quot;
    by (metis power_Suc semiring_normalization_rules(7))
  then show &quot;2 ^ Suc n /(sqrt 2 ^ Suc n * sqrt 2 ^ (Suc n + 1)) = 1/sqrt 2&quot;
    using IH by auto
qed
</pre></div>


<p>with</p>
<div class="codehilite"><pre><span></span>lemma aux_comp_with_sqrt2:
  shows &quot;(sqrt 2)^n * (sqrt 2)^n = 2^n&quot;
  by (smt power_mult_distrib real_sqrt_mult_self)

lemma aux_comp_with_sqrt2_bis [simp]:
  shows &quot;2^n/(sqrt(2)^n * sqrt(2)^(n+1)) = 1/sqrt 2&quot;
  using aux_comp_with_sqrt2 by (simp add: mult.left_commute)
</pre></div>


<p>Note that smt proofs are fine, see Gerwin's <a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00128.html" target="_blank" title="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00128.html">answer</a>.</p>



<a name="172596796"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172596796" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172596796">(Aug 06 2019 at 15:02)</a>:</h4>
<p>One can read</p>
<div class="codehilite"><pre><span></span>lemma sum_n_summands_one_or_minus:
  fixes F:: &quot;nat ⇒ nat&quot; (*I renamed this because f suggested that it was jozsa&#39;s f function but it might also be f(k)+1*)
    and A::&quot;nat set&quot;
  assumes &quot;finite A&quot;
  shows &quot;(∑ k ∈ A. (-1)^(F(k))) ≤ card A &quot;
  and &quot;(∑ k ∈ A. (-1)^(F(k))) ≥ -card A &quot;
</pre></div>


<p>, but it's better to stick to mathematical practice and choose <code>g</code> instead if <code>f</code> is not available for the reason you mentioned. Usually, capitals are not used for functions.<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="172597153"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172597153" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172597153">(Aug 06 2019 at 15:06)</a>:</h4>
<blockquote>
<p>Note that smt proofs are fine, see Gerwin's answer.</p>
</blockquote>
<p>Good to know that it changed. There might be other proofs with can be shortened by smt I replaced some of the smts with structured proofs because of the entry in the style guide about it.</p>



<a name="172597488"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172597488" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172597488">(Aug 06 2019 at 15:10)</a>:</h4>
<blockquote>
<p>but it's better to stick to mathematical practice and choose g instead if f is not available for the reason you mentioned.</p>
</blockquote>
<p>Usually, capitals are not used for functions.<br>
Great thanks that fully answers my question. I think I choose F to resemble f(k) (since the function is only used for f(k) and f(k)+1)</p>



<a name="172599518"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172599518" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172599518">(Aug 06 2019 at 15:32)</a>:</h4>
<p>In the same spirit, I have replaced</p>
<div class="codehilite"><pre><span></span>lemma sum_n_summands_one_or_minus:
  fixes g:: &quot;nat ⇒ nat&quot; and A:: &quot;nat set&quot;
  assumes &quot;finite A&quot;
  shows &quot;(∑k∈A. (-1)^(g k)) ≤ card A&quot; and &quot;(∑k∈A. (-1)^(g k)) ≥ -card A&quot;
proof-
  have f0: &quot;k ∈ A⟶ (-(1::int))^(g(k)) = 1 ∨  (-(1::int))^(g(k)) = -1&quot; for k::nat
    by (metis neg_one_even_power neg_one_odd_power)
      (*This was proposed by sledgehammer(with different variables) I added it to avoid smt. Should it stay?
        If yes it might be possible to replace second smt*)
  obtain G :: &quot;int ⇒ (nat ⇒ int) ⇒ nat set ⇒ nat&quot; where
    &quot;∀A F i. sum F A ≤ int (card A) * i ∨ ¬ F (G i F A) ≤ i ∧ G i F A ∈ A&quot;
    by (meson sum_bounded_above)
  then show &quot;(∑ k::nat ∈ A. (-1)^(F(k))) ≤ card A &quot;
     using f0
   by (metis (no_types) mult.right_neutral negative_zle of_nat_1 order_refl)
next
  have &quot;k ∈ A⟶ (-(1::nat))^(F(k)) = 1 ∨  (-(1::nat))^(F(k)) = -1&quot; for k
    by (metis int_ops(2) neg_one_even_power neg_one_odd_power)
  then show  &quot;(∑ k ∈ A. (-1)^(F(k))) ≥ -card A &quot;
    using assms
    by (smt card_eq_sum of_nat_1 of_nat_sum sum_mono sum_negf)
qed
</pre></div>


<p>with </p>
<div class="codehilite"><pre><span></span>lemma aux_ineq_with_card:
  fixes g:: &quot;nat ⇒ nat&quot; and A:: &quot;nat set&quot;
  assumes &quot;finite A&quot;
  shows &quot;(∑k∈A. (-1)^(g k)) ≤ card A&quot; and &quot;(∑k∈A. (-1)^(g k)) ≥ -card A&quot;
   apply (smt assms neg_one_even_power neg_one_odd_power card_eq_sum of_nat_1 of_nat_sum sum_mono)
  apply (smt assms neg_one_even_power neg_one_odd_power card_eq_sum of_nat_1 of_nat_sum sum_mono sum_negf).
</pre></div>


<p>Note the change in the name. One does not need to find a clever name. Indeed, since these proofs are somewhat handled automatically, nobody will use it in another formalization, they will just run Sledgehammer instead.</p>



<a name="172601550"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172601550" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172601550">(Aug 06 2019 at 15:55)</a>:</h4>
<p><code>const_has_max_value</code> was renamed <code>aux_comp_with_cmod</code>.</p>



<a name="172602381"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172602381" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172602381">(Aug 06 2019 at 16:04)</a>:</h4>
<p><code>cmod_smaller_n</code> was renamed <code>cmod_less</code>. The former name had the problem already pointed out about arbitrary notations that should not find their way into names. Also, note that there are well established conventions in Isabelle/HOL, in particular <em>less</em> in names is common for a statement involving <code>&lt;</code>.</p>



<a name="172605351"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172605351" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172605351">(Aug 06 2019 at 16:38)</a>:</h4>
<p>The following example in <code>Deutsch-Jozsa.thy</code> is a good case study:</p>
<div class="codehilite"><pre><span></span>lemma sum_divide_distrib_cmod:
  fixes n:: nat and g:: &quot;nat ⇒ int&quot; and a:: real
  shows &quot;(cmod(complex_of_real(∑k&lt;n. g k / a)))⇧2 = (cmod (∑k&lt;n. g k) / a)⇧2&quot;
proof-
  have &quot;(complex_of_real(∑k::nat&lt;n. (g k) / a)) = (∑k::nat&lt;n. (g k) / a)&quot; by blast
  then have &quot;(cmod(complex_of_real(∑k::nat&lt;n. (g k) / a)))⇧2 = (cmod((∑k::nat&lt;n. (g k) / a)))⇧2&quot;
    by blast
  moreover have &quot;(∑k::nat&lt;n. (g k) / a) = (∑k::nat&lt;n. (g k))/ a&quot;
    by (simp add: sum_divide_distrib)
  ultimately show &quot;(cmod(complex_of_real(∑k::nat&lt;n. (g k) / a)))⇧2 = (cmod (∑k::nat&lt;n. (g k)) / a)⇧2&quot;
    by (metis norm_of_real of_real_of_int_eq power2_abs power_divide)
qed
</pre></div>


<p>Actually, if one runs Sledgehammer, then it finds a proof, namely</p>
<div class="codehilite"><pre><span></span> by (metis cmod_square_real of_int_sum of_real_of_int_eq power_divide sum_divide_distrib)
</pre></div>


<p>which is perfectly fine, since the result being trivial one does not want a structured proof in that case. Also, since the proof is handled automatically, there is no need for a clever name, instead of reusing this lemma in the future people will prove it again (automatically, for free). Hence, one does not run out of clever names and avoid a headache with the choice of the name.<br>
It simply becomes </p>
<div class="codehilite"><pre><span></span>lemma aux_comp_sum_divide_cmod:
  fixes n:: nat and g:: &quot;nat ⇒ int&quot; and a:: real
  shows &quot;(cmod(complex_of_real(∑k&lt;n. g k / a)))⇧2 = (cmod (∑k&lt;n. g k) / a)⇧2&quot;
  by (metis cmod_square_real of_int_sum of_real_of_int_eq power_divide sum_divide_distrib)
</pre></div>


<p>and the prefix <em>aux_comp</em> is a way to  signal the thoughts above.<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="172606117"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172606117" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172606117">(Aug 06 2019 at 16:48)</a>:</h4>
<p><code>add_limits_max_value</code> is useless, one can simply run <code>by simp</code> instead where this lemma is used.</p>



<a name="172751550"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172751550" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172751550">(Aug 08 2019 at 09:46)</a>:</h4>
<p>For a reason already explained the name <code>prob_first_n_qubits_0</code> is not satisfying. What about <code>prob_fst_qubits_0</code> ?</p>



<a name="172751830"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172751830" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172751830">(Aug 08 2019 at 09:53)</a>:</h4>
<p>But is in general reasonable to use such a definition?</p>



<a name="172751909"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172751909" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172751909">(Aug 08 2019 at 09:54)</a>:</h4>
<p>Why does the prefix <code>meas</code> appear in <code>meas_fst_n_qubits_zero_remaining_indices</code> while there is no measure in the statement of this lemma ?<br>
Something like <code>indices_with_fst_qubits_0</code> might be better.</p>



<a name="172751930"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172751930" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172751930">(Aug 08 2019 at 09:55)</a>:</h4>
<blockquote>
<p>But is in general reasonable to use such a definition?</p>
</blockquote>
<p>I'm going to investigate this question.</p>



<a name="172753010"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172753010" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172753010">(Aug 08 2019 at 10:20)</a>:</h4>
<p><code>indices_with_fst_qubits_0</code> is fine. The meas appears since the lemma shows what the remaining indices are in the case that the first n qubits are measured and are all 0.</p>



<a name="172753596"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172753596" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172753596">(Aug 08 2019 at 10:32)</a>:</h4>
<p><em>tensor_n</em> appears a lot in names, for instance in <code>hadamard_gate_tensor_n_times_ψ⇩2_is_ψ⇩3</code>, with the usual problem. <br>
<em>iter_tensor</em> is a good alternative (iter stands for iterated), for instance  it gives <code>hadamard_gate_iter_tensor_times_ψ⇩2_is_ψ⇩3</code>, or even better in that case <code>iter_tensor_of_H_times_ψ⇩2_is_ψ⇩3</code>. <br>
H is fine here, since given the context it's meaningful in itself and there is absolutely no ambiguity that it stands for the Hadamard gate.</p>



<a name="172770623"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172770623" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172770623">(Aug 08 2019 at 14:39)</a>:</h4>
<blockquote>
<blockquote>
<p>But is in general reasonable to use such a definition?</p>
</blockquote>
<p>I'm going to investigate this question.</p>
</blockquote>
<p>In the second comment below <code>text ‹Measurement›</code> it's written that <code>prob_fst_qubits_0 n v</code> is equal to </p>
<div class="codehilite"><pre><span></span>∏i∈{0..n} . prob0 (n+1) v i)
</pre></div>


<p>(assuming that v is a state of an n+1-qubits system). But, actually it's equal to <br>
something more complicated involving <code>post_meas0</code>. It's certainly the origin of the trouble.<br>
Also, one should prove it for any state v, not only for jozsa_algo, since the proof will be more general and actually simpler.<br>
Otherwise, this approach is perfectly reasonable.<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="172771485"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172771485" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172771485">(Aug 08 2019 at 14:47)</a>:</h4>
<p>Great there might be a generalized version in the comment below. It could solve the issue but actually I think I considered that and increased n in the counterpart as well :/ It might be just a remnant of a proof attempt in the comment.</p>



<a name="172777386"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172777386" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172777386">(Aug 08 2019 at 15:54)</a>:</h4>
<p><code>not_const_cannot_have_max_value1</code> was renamed <code>max_value_of_not_const_less</code>.</p>



<a name="172800650"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/172800650" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#172800650">(Aug 08 2019 at 20:28)</a>:</h4>
<blockquote>
<p>Great there might be a generalized version in the comment below. It could solve the issue but actually I think I considered that and increased n in the counterpart as well :/ It might be just a remnant of a proof attempt in the comment.</p>
</blockquote>
<p>I'm trying to complete the proof.<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="173122564"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173122564" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173122564">(Aug 13 2019 at 15:15)</a>:</h4>
<p>I simplified <code>prob_fst_qubits_0</code> as well by removing the condition <code>state (n+1) v</code>.</p>



<a name="173153921"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173153921" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173153921">(Aug 13 2019 at 21:37)</a>:</h4>
<blockquote>
<p>For a reason already explained the name <code>prob_first_n_qubits_0</code> is not satisfying. What about <code>prob_fst_qubits_0</code> ?</p>
</blockquote>
<p>I did not realize until this evening that the notations introduced in <code>Deutsch-Jozsa</code> are not coherent with the ones in <code>Quantum.thy</code>. One should replace <code>prob_fst_qubits_0</code> with <code>prob0_fst_qubits</code>.<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="173200815"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173200815" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173200815">(Aug 14 2019 at 13:11)</a>:</h4>
<p>When you wrote <code>text ‹General lemmata needed for the probability proofs›</code>, do you mean general lemmata to compute probabilities ?<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="173201564"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173201564" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173201564">(Aug 14 2019 at 13:20)</a>:</h4>
<p>Yes, they concern the probability that the first n qubits are 0.</p>



<a name="173201847"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173201847" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173201847">(Aug 14 2019 at 13:23)</a>:</h4>
<blockquote>
<p>I did not realize until this evening that the notations introduced in <code>Deutsch-Jozsa</code> are not coherent with the ones in <code>Quantum.thy</code>. One should replace <code>prob_fst_qubits_0</code> with <code>prob0_fst_qubits</code>.<br>
<span class="user-mention silent" data-user-id="228787">Hanna Lachnitt</span></p>
</blockquote>
<p>Yes thats fine. I put the 0 in the name to match the notation in Quantum, but put it in the end because I didn't wanted it to sound as if its only about one qubit from the fst n ones. But it gets pretty clear from the name</p>



<a name="173205025"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173205025" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173205025">(Aug 14 2019 at 13:57)</a>:</h4>
<p>It's picky but often after the command <code>using</code> there is useless stuff  that could be removed. It's confusing if one tries to read the proofs to understand them, since there is a lot of useless stuff.<br>
One example:</p>
<div class="codehilite"><pre><span></span>have &quot;k &lt; 2^n⟶((1 div 2) ⋅⇘n⇙  k) = 0&quot; for k::nat
    using bitwise_inner_prod_with_zero by simp
</pre></div>


<p>instead of</p>
<div class="codehilite"><pre><span></span>have &quot;k &lt; 2^n⟶((1 div 2) ⋅⇘n⇙  k) = 0&quot; for k::nat
    using bin_rep_def bin_rep_aux_def bitwise_inner_prod_def bitwise_inner_prod_with_zero by simp
</pre></div>


<p>A second example:</p>
<div class="codehilite"><pre><span></span>moreover have &quot;(cmod(jozsa_algo $$ (1,0)))⇧2
               = (cmod (∑k&lt;(2::nat)^n. (-1)^(f k+ 1 + ((1 div 2) ⋅⇘n⇙  k))/(sqrt(2)^n * sqrt(2)^(n+1))))⇧2&quot;
      using  ψ⇩3_dim by auto
</pre></div>


<p>instead of</p>
<div class="codehilite"><pre><span></span>moreover have &quot;(cmod(jozsa_algo $$ (1,0)))⇧2
               = (cmod (∑k&lt;(2::nat)^n. (-1)^(f k+ 1 + ((1 div 2) ⋅⇘n⇙  k))/(sqrt(2)^n * sqrt(2)^(n+1))))⇧2&quot;
      using jozsa_algo_result const_def assms ψ⇩3_values ψ⇩3_dim by auto
</pre></div>


<p>Please clean your proofs when you are done and get rid of useless definitions and lemmas after <code>using</code>.<br>
<span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span></p>



<a name="173207777"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173207777" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173207777">(Aug 14 2019 at 14:27)</a>:</h4>
<p>It's even more picky, but sometimes there is an irregular use of white spaces. For example, one finds <code>∑k &lt; 2^n</code> or <code>∑k&lt;2^n</code> or <code>∑ k &lt; 2 ^ n</code>. <br>
If LaTeX is so pleasing to the eye, it's due in part to standardized spaces.<br>
For example, I find</p>
<div class="codehilite"><pre><span></span>shows &quot;∀A B. A∩B={}∧ A∪B=C⟶(∑k::nat ∈ C. g k) = (∑ k::nat ∈ A. g k) + (∑ k::nat ∈ B. g k)&quot;
</pre></div>


<p>less pleasing than</p>
<div class="codehilite"><pre><span></span>shows &quot;∀A B. A ∩ B = {} ∧ A ∪ B = C ⟶ (∑k∈C. g k) = (∑k∈A. g k) + (∑k∈B. g k)&quot;
</pre></div>


<p>Another example:</p>
<div class="codehilite"><pre><span></span>and &quot;jozsa_algo_eval = 0 ⟷ is_balanced &quot;
</pre></div>


<p>there is no white space after the first quotation mark but there is one before the second.</p>



<a name="173213762"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173213762" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173213762">(Aug 14 2019 at 15:33)</a>:</h4>
<p>Note that instead of writing <code>∀x∈{i::nat. i &lt; 2^n}. g x = 0</code> one can write <code>∀x&lt; 2^n. g x = 0</code>.</p>



<a name="173229468"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173229468" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173229468">(Aug 14 2019 at 18:33)</a>:</h4>
<p>Regarding your comment about possibly generalizing the lemmas involving <code>f k</code> and <code>f k + 1</code>, we could indeed write one general lemma and see the current lemmas as two different instances, but I'm not sure it's worth the trouble.</p>



<a name="173494314"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173494314" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173494314">(Aug 18 2019 at 17:05)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span> <br>
I managed to prove the following lemma:</p>
<div class="codehilite"><pre><span></span>lemma prob0_fst_qubits_eq: (* To move in Measurement.thy *)
  fixes n:: nat
  shows &quot;prob0_fst_qubits n v = (cmod(v $$ (0,0)))⇧2 + (cmod(v $$ (1,0)))⇧2&quot;
proof-
  have &quot;prob0_fst_qubits n v = (∑j∈{k| k::nat. (k&lt;2^(n+1)) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)}. (cmod(v $$ (j,0)))⇧2)&quot;
    using prob0_fst_qubits_def by simp
  moreover have &quot;… = (∑j∈{0,1}. (cmod(v $$ (j,0)))⇧2)&quot;
    using prob0_fst_qubits_index by simp
  finally show ?thesis by simp
qed
</pre></div>



<a name="173494373"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173494373" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173494373">(Aug 18 2019 at 17:07)</a>:</h4>
<p>The prerequisites are as follow:</p>
<div class="codehilite"><pre><span></span>lemma select_index_div_2: (* To move in Measurement.thy *)
  fixes n i j::&quot;nat&quot;
  assumes &quot;i &lt; 2^(n+1)&quot; and &quot;j&lt;n&quot;
  shows &quot;select_index n j (i div 2) = select_index (n+1) j i&quot;
proof-
  have &quot;2^(n-Suc j) ≤ i div 2 mod 2^(n-j) ⟹ 2^(n-j) ≤ i mod 2^(n+1-j)&quot;
  proof-
    define a::nat where a0:&quot;a = i div 2 mod 2^(n-j)&quot;
    assume &quot;2^(n-Suc j) ≤ a&quot;
    then have &quot;2*a + i mod 2 ≥ 2^(n-(Suc j)+1)&quot; by simp
    then have f0:&quot;2*a + i mod 2 ≥ 2^(n-j)&quot;
      by (metis Suc_diff_Suc Suc_eq_plus1 assms(2))
    have &quot;a &lt; 2^(n-j)&quot; using a0 by simp
    then have &quot;2*a + i mod 2 &lt; 2*2^(n-j)&quot; by linarith
    then have &quot;2*a + i mod 2 &lt; 2^(n-j+1)&quot; by simp
    then have f1:&quot;2*a + i mod 2 &lt; 2^(n+1-j)&quot;
      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))
    have &quot;i = 2*(a + 2^(n-j)*(i div 2 div 2^(n-j))) + i mod 2&quot; using a0 by simp
    then have &quot;i = 2*a + i mod 2 + 2^(n-j+1)*(i div 2 div 2^(n-j))&quot; by simp
    then have &quot;i = 2*a + i mod 2 + 2^(n+1-j)*(i div 2 div 2^(n-j))&quot;
      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))
    then have &quot;i mod 2^(n+1-j) = 2*a + i mod 2&quot;
      using f1 by (metis mod_if mod_mult_self2)
    then show &quot;2^(n-j) ≤ i mod 2^(n+1-j)&quot;
      using f0 by simp
  qed
  moreover have &quot;2^(n-j) ≤ i mod 2^(n+1-j) ⟹ 2^(n-Suc j) ≤ i div 2 mod 2^(n-j)&quot;
  proof-
    define a::nat where a0:&quot;a = i div 2 mod 2^(n-j)&quot;
    assume a1:&quot;2^(n-j) ≤ i mod 2^(n+1-j)&quot;
    have f0:&quot;2^(n-j) = 2^(n-Suc j+1)&quot;
      by (metis Suc_diff_Suc Suc_eq_plus1 assms(2))
    have &quot;a &lt; 2^(n-j)&quot; using a0 by simp
    then have &quot;2*a + i mod 2 &lt; 2*2^(n-j)&quot; by linarith
    then have &quot;2*a + i mod 2 &lt; 2^(n-j+1)&quot; by simp
    then have f1:&quot;2*a + i mod 2 &lt; 2^(n+1-j)&quot;
      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))
    have &quot;i = 2*(a + 2^(n-j)*(i div 2 div 2^(n-j))) + i mod 2&quot; using a0 by simp
    then have &quot;i = 2*a + i mod 2 + 2^(n-j+1)*(i div 2 div 2^(n-j))&quot; by simp
    then have &quot;i = 2*a + i mod 2 + 2^(n+1-j)*(i div 2 div 2^(n-j))&quot;
      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))
    then have &quot;i mod 2^(n+1-j) = 2*a + i mod 2&quot;
      using f1 by (metis mod_if mod_mult_self2)
    then have &quot;2*a + i mod 2 ≥ 2^(n-j)&quot;
      using a1 by simp
    then have &quot;(2*a + i mod 2) div 2 ≥ (2^(n-j)) div 2&quot;
      using div_le_mono by blast
    then show &quot;2^(n-Suc j) ≤ a&quot; by (simp add: f0)
  qed
  ultimately show ?thesis
    using select_index_def assms by auto
qed

lemma select_index_suc_even: (* To move in Measurement.thy *)
  fixes n k i:: nat
  assumes &quot;k &lt; 2^n&quot; and &quot;select_index n i k&quot;
  shows &quot;select_index (Suc n) i (2*k)&quot;
proof-
  have &quot;select_index n i k = select_index n i (2*k div 2)&quot; by simp
  moreover have &quot;… = select_index (Suc n) i (2*k)&quot;
  proof-
    have &quot;i &lt; n&quot; using assms(2) select_index_def
      by (metis (no_types, hide_lams) Suc_eq_plus1 assms(1) calculation diff_diff_left diff_le_self
diff_self_eq_0 div_by_1 le_0_eq le_eq_less_or_eq less_imp_diff_less mod_div_trivial mult.left_neutral mult_eq_0_iff mult_le_mono1 not_less plus_1_eq_Suc power_0 semiring_normalization_rules(7))
    thus ?thesis
      using select_index_div_2 assms(1) select_index_def by(metis Suc_1 Suc_eq_plus1 Suc_mult_less_cancel1 power_Suc)
  qed
  ultimately show &quot;select_index (Suc n) i (2*k)&quot;
    using assms(2) by simp
qed

lemma select_index_suc_odd:
  fixes n k i:: nat
  assumes &quot;k ≤ 2^n -1&quot; and &quot;select_index n i k&quot;
  shows &quot;select_index (Suc n) i (2*k+1)&quot;
proof-
  have &quot;((2*k+1) mod 2^(Suc n - i) ≥ 2^(n - i)) =
(((2*k+1) div 2) mod 2^(n - i) ≥ 2^(n-1-i))&quot;
  proof-
    have &quot;2*k+1 &lt; 2^(n + 1)&quot;
      using assms(1)
      by (smt Suc_1 Suc_eq_plus1 Suc_le_lessD Suc_le_mono add_Suc_right distrib_left_numeral le_add_diff_inverse mult_le_mono2 nat_mult_1_right one_le_numeral one_le_power plus_1_eq_Suc power_add power_one_right)
    moreover have &quot;i &lt; n&quot;
      using assms(2) select_index_def
      by (metis (no_types, hide_lams) add_cancel_left_left add_diff_inverse_nat diff_le_self div_by_1 le_antisym less_le_trans less_one mod_div_trivial not_le power_0)
    ultimately show ?thesis
      using select_index_div_2[of &quot;2*k+1&quot; &quot;n&quot; i] select_index_def
      by (metis Nat.le_diff_conv2 Suc_eq_plus1 Suc_leI assms(2) diff_Suc_1 less_imp_le less_power_add_imp_div_less one_le_numeral one_le_power power_one_right)
  qed
  moreover have &quot;… = (k mod 2^(n - i) ≥ 2^(n-1-i))&quot; by simp
  ultimately show ?thesis
  proof-
    have &quot;i ≤ Suc n -1&quot; using assms(2) select_index_def by auto
    moreover have &quot;2*k+1 ≤ 2^(Suc n)-1&quot;
      using assms(1) by (smt Suc_diff_1 Suc_eq_plus1 add_diff_cancel_right&#39; diff_Suc_diff_eq2 diff_diff_left diff_is_0_eq diff_mult_distrib2 le_add2 mult_2 mult_Suc_right plus_1_eq_Suc pos2 power_Suc zero_less_power)
    ultimately show ?thesis
      using select_index_def
      by (metis ‹(2 ^ (n - 1 - i) ≤ (2 * k + 1) div 2 mod 2 ^ (n - i)) = (2 ^ (n - 1 - i) ≤ k mod 2 ^ (n - i))› ‹(2 ^ (n - i) ≤ (2 * k + 1) mod 2 ^ (Suc n - i)) = (2 ^ (n - 1 - i) ≤ (2 * k + 1) div 2 mod 2 ^ (n - i))› assms(2) diff_Suc_1)
  qed
qed

lemma aux_range:
  fixes k:: nat
  assumes &quot;k &lt; 2^(Suc n + 1)&quot; and &quot;k ≥ 2&quot;
  shows &quot;k = 2 ∨ k = 3 ∨ (∃l. l≥2 ∧ l≤2^(n+1)-1 ∧ (k = 2*l ∨ k = 2*l + 1))&quot;
proof(rule disjCI)
  assume &quot;¬ (k = 3 ∨ (∃l≥2. l ≤ 2^(n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1)))&quot;
  have &quot;k &gt; 3 ⟶ (∃l≥2. l ≤ 2^(n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1))&quot;
  proof
    assume asm:&quot;k &gt; 3&quot;
    have &quot;even k ∨ odd k&quot; by simp
    then obtain l where &quot;k = 2*l ∨ k = 2*l+1&quot; by (meson evenE oddE)
    moreover have &quot;l ≥ 2&quot;
      using asm calculation by linarith
    moreover have &quot;l ≤ 2^(n+1) - 1&quot;
      using assms(1) by (metis Suc_diff_1 Suc_eq_plus1 calculation(1) dvd_triv_left even_Suc_div_two less_Suc_eq_le less_power_add_imp_div_less nonzero_mult_div_cancel_left pos2 power_one_right zero_less_power zero_neq_numeral)
    ultimately show &quot;∃l≥2. l ≤ 2^(n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1)&quot; by auto
  qed
  then have &quot;k ≤ 2&quot;
    using ‹¬ (k = 3 ∨ (∃l≥2. l ≤ 2 ^ (n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1)))› less_Suc_eq_le by auto
  thus &quot;k = 2&quot;
    using assms(2) by simp
qed

lemma select_index_with_1: (* To move in Measurement.thy *)
  fixes n:: nat
  assumes &quot;n ≥ 1&quot;
  shows &quot;∀k. k &lt; 2^(n+1) ⟶ k ≥ 2 ⟶ (∃i&lt;n. select_index (n+1) i k)&quot;
  using assms
proof(rule nat_induct_at_least)
  show &quot;∀k&lt; 2^(1+1). 2 ≤ k ⟶ (∃i&lt;1. select_index (1+1) i k)&quot;
  proof-
    have &quot;select_index 2 0 2 = True&quot;
      using select_index_def by simp
    moreover have &quot;select_index 2 0 3&quot;
      using select_index_def by simp
    ultimately show ?thesis
      by (metis Suc_leI add_Suc_shift le_eq_less_or_eq mult_2 not_less one_add_one one_plus_numeral
plus_1_eq_Suc power.simps(2) power_one_right semiring_norm(3) zero_less_one_class.zero_less_one)
  qed
next
  show &quot;⋀n. 1 ≤ n ⟹
         ∀k &lt; 2^(n+1). 2 ≤ k ⟶ (∃i&lt;n. select_index (n+1) i k) ⟹
         ∀k &lt; 2^(Suc n + 1). 2 ≤ k ⟶ (∃i&lt;Suc n. select_index (Suc n +1) i k)&quot;
  proof-
    fix n:: nat
    assume asm:&quot;n ≥ 1&quot; and IH:&quot;∀k &lt; 2^(n+1). 2 ≤ k ⟶ (∃i&lt;n. select_index (n+1) i k)&quot;
    have &quot;select_index (Suc n + 1) n 2&quot;
    proof-
      have &quot;select_index (Suc n) n 1&quot;
        using select_index_def by(smt Suc_1 Suc_diff_Suc Suc_lessI add_diff_cancel_right&#39; diff_Suc_1
diff_commute diff_zero le_eq_less_or_eq less_Suc_eq_le nat.simps(3) nat_power_eq_Suc_0_iff
one_mod_two_eq_one plus_1_eq_Suc power_one_right zero_less_power)
      thus ?thesis
        using select_index_suc_even by (metis Suc_eq_plus1 less_numeral_extra(4) mult_2 not_less_less_Suc_eq one_add_one one_less_power zero_less_Suc)
    qed
    moreover have &quot;select_index (Suc n + 1) n 3&quot;
    proof-
      have &quot;select_index (Suc n) n 1&quot;
        using select_index_def by(smt Suc_1 Suc_diff_Suc Suc_lessI add_diff_cancel_right&#39; diff_Suc_1
diff_commute diff_zero le_eq_less_or_eq less_Suc_eq_le nat.simps(3) nat_power_eq_Suc_0_iff
one_mod_two_eq_one plus_1_eq_Suc power_one_right zero_less_power)
      thus ?thesis
        using select_index_suc_odd by (metis One_nat_def Suc_eq_plus1 mult_2 numeral_3_eq_3 select_index_def)
    qed
    moreover have &quot;∃i&lt;Suc n. select_index (Suc n +1) i (2*k)&quot; if &quot;k ≥ 2&quot; and &quot;k ≤ 2^(n + 1)-1&quot; for k:: nat
    proof-
      obtain i where &quot;i&lt;n&quot; and &quot;select_index (n+1) i k&quot;
        using IH by(metis One_nat_def Suc_diff_Suc ‹2 ≤ k› ‹k ≤ 2 ^ (n + 1) - 1› diff_zero le_imp_less_Suc pos2 zero_less_power)
      then have &quot;select_index (Suc n +1) i (2*k)&quot;
        using select_index_suc_even
        by (metis One_nat_def Suc_diff_Suc add.commute diff_zero le_imp_less_Suc plus_1_eq_Suc pos2 that(2) zero_less_power)
      thus ?thesis
        using ‹i &lt; n› less_SucI by blast
    qed
    moreover have &quot;∃i&lt;Suc n. select_index (Suc n +1) i (2*k +1)&quot; if &quot;k ≥ 2&quot; and &quot;k ≤ 2^(n + 1)-1&quot; for k:: nat
    proof-
      obtain i where &quot;i&lt;n&quot; and &quot;select_index (n+1) i k&quot;
        using IH by(metis One_nat_def Suc_diff_Suc ‹2 ≤ k› ‹k ≤ 2 ^ (n + 1) - 1› diff_zero le_imp_less_Suc pos2 zero_less_power)
      then have &quot;select_index (Suc n +1) i (2*k+1)&quot;
        using select_index_suc_odd that(2) by simp
      thus ?thesis
        using ‹i &lt; n› less_SucI by blast
    qed
    ultimately show &quot;∀k&lt; 2^(Suc n + 1). 2 ≤ k ⟶ (∃i&lt;Suc n. select_index (Suc n +1) i k)&quot;
      using aux_range by (metis lessI)
  qed
qed
</pre></div>



<a name="173494425"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173494425" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173494425">(Aug 18 2019 at 17:08)</a>:</h4>
<p>and </p>
<div class="codehilite"><pre><span></span>lemma prob0_fst_qubits_index: (* To move in Measurement.thy *)
  fixes n:: nat and v:: &quot;complex Matrix.mat&quot;
  shows &quot;{k| k::nat. (k&lt;2^(n+1)) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)} = {0,1}&quot;
proof(induct n)
  case 0
  show &quot;{k |k. k &lt; 2^(0+1) ∧ (∀i∈{0..&lt;0}. ¬ select_index (0+1) i k)} = {0,1}&quot; by auto
next
  case (Suc n)
  show &quot;⋀n. {k |k. k &lt; 2^(n+1) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)} = {0,1} ⟹
         {k |k. k &lt; 2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n + 1) i k)} =
         {0, 1}&quot;
  proof-
    fix n
    assume IH: &quot;{k |k. k &lt; 2^(n+1) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)} = {0,1}&quot;
    then have &quot;{0,1} ⊆ {k |k. k &lt; 2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n + 1) i k)}&quot;
    proof-
      have &quot;k &lt; 2^(n+1) ⟶ k &lt; 2^(Suc n + 1)&quot; for k::nat by simp
      moreover have &quot;(∀i∈{0..&lt;n}. ¬ select_index (n+1) i 0) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i 1)&quot;
        using IH by auto
      then have &quot;(∀i∈{0..&lt;n}. ¬ select_index (Suc n +1) i 0) ∧ (∀i∈{0..&lt;n}. ¬ select_index (Suc n +1) i 1)&quot;
        using select_index_suc_odd[of 0 &quot;n+1&quot;] Suc_eq_plus1
        by (smt One_nat_def Suc_1 add_Suc_shift add_diff_cancel_right&#39; atLeastLessThan_iff diff_diff_cancel
le_eq_less_or_eq less_Suc_eq linorder_not_le mod_less nat_power_eq_Suc_0_iff select_index_def zero_less_power)
      moreover have &quot;select_index (Suc n + 1) n 0 = False&quot; using select_index_def by simp
      moreover have &quot;select_index (Suc n + 1) n 1 = False&quot; using select_index_def by simp
      ultimately show ?thesis
        by (smt One_nat_def Suc_1 Suc_eq_plus1 Suc_lessI atLeast0_lessThan_Suc empty_iff insertE
mem_Collect_eq nat.simps(1) nat_power_eq_Suc_0_iff pos2 subsetI zero_less_power)
    qed
    moreover have &quot;{k |k. k &lt; 2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n + 1) i k)} ⊆ {0,1}&quot;
    proof-
      have &quot;∀k&lt;2^(Suc n +1). k ≥ 2 ⟶ (∃i&lt;Suc n. ¬ select_index (Suc n +1) i k = False)&quot;
        using select_index_with_1[of &quot;Suc n&quot;] by (metis Suc_eq_plus1 add.commute le_add1)
      thus ?thesis by auto
    qed
    ultimately show &quot;{k |k. k&lt;2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n +1) i k)} = {0,1}&quot; by auto
  qed
qed
</pre></div>



<a name="173494489"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173494489" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173494489">(Aug 18 2019 at 17:10)</a>:</h4>
<p>Now, one can introduce the following, more general, machinery:</p>
<div class="codehilite"><pre><span></span>(* Below in iter_post_meas0, the firt argument n corresponds to the number of qubits of the system
, and the second argument m corresponds to the number of qubits that have been measured. *)

primrec iter_post_meas0:: &quot;nat ⇒ nat ⇒ complex Matrix.mat ⇒ complex Matrix.mat&quot; where (* To move in Quantum.thy or better in a new file Measurement.thy *)
  &quot;iter_post_meas0 n 0 v = v&quot;
| &quot;iter_post_meas0 n (Suc m) v = post_meas0 n (iter_post_meas0 n m v) m&quot;

(* iter_prob0 outputs the probability that successive measurements of the first m qubits
give m zeros. *)

definition iter_prob0:: &quot;nat ⇒ nat ⇒ complex Matrix.mat ⇒ real&quot; where (* idem *)
  &quot;iter_prob0 n m v = (∏i∈{k|k::nat. k ≤ m-1}. prob0 n (iter_post_meas0 n i v) i)&quot;
</pre></div>



<a name="173494515"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173494515" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173494515">(Aug 18 2019 at 17:11)</a>:</h4>
<p>But, it remains elusive to prove the following lemma:</p>
<div class="codehilite"><pre><span></span>lemma iter_prob0_eq: (* To do *)
  fixes n:: nat and v:: &quot;complex Matrix.mat&quot;
  assumes &quot;n ≥ 1&quot;
  shows &quot;iter_prob0 (Suc n) n v = prob0_fst_qubits n v&quot; sorry
</pre></div>


<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span> <span class="user-mention" data-user-id="228785">@Yijun He</span></p>



<a name="173502824"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173502824" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173502824">(Aug 18 2019 at 21:36)</a>:</h4>
<p>I will try to prove it tomorrow :)</p>



<a name="173528924"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173528924" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173528924">(Aug 19 2019 at 09:27)</a>:</h4>
<blockquote>
<p>Note that instead of writing <code>∀x∈{i::nat. i &lt; 2^n}. g x = 0</code> one can write <code>∀x&lt; 2^n. g x = 0</code>.</p>
</blockquote>
<p>This also applies to iter_prob0, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>:</mo><mo>:</mo><mi>n</mi><mi>a</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>k</mi><mo>≤</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">i\in \{k|k::nat. k\le m-1\}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> can be writen as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≤</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i\le m-1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">i &lt; m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></p>



<a name="173664424"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173664424" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173664424">(Aug 20 2019 at 14:45)</a>:</h4>
<p>Further clean-up would be possible, especially more comments, but for now it's enough.<br>
It only remains to move a few things in different theories.</p>



<a name="173671040"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173671040" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173671040">(Aug 20 2019 at 16:04)</a>:</h4>
<p><span class="user-mention" data-user-id="228787">@Hanna Lachnitt</span> Do you plan to use the bitwise inner product in another formalization ? If so, It should be moved to Quantum.thy.</p>



<a name="173671247"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173671247" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173671247">(Aug 20 2019 at 16:07)</a>:</h4>
<p>If we want to do Simon's algorithm at some point (period finding) it would be useful. But right now I don't see any other application.</p>



<a name="173672310"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173672310" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173672310">(Aug 20 2019 at 16:21)</a>:</h4>
<p>Maybe it will also be useful for the QFT ?<br>
If you agree, I will move it in Quantum.thy.</p>



<a name="173676582"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173676582" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173676582">(Aug 20 2019 at 17:14)</a>:</h4>
<p>I got rid of all the things related to measurements. They are now part of  <code>Measurement.thy</code>.</p>



<a name="173681406"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173681406" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173681406">(Aug 20 2019 at 18:10)</a>:</h4>
<blockquote>
<p>Maybe it will also be useful for the QFT ?<br>
If you agree, I will move it in Quantum.thy.</p>
</blockquote>
<p>I moved your contribution on the bitwise inner product and the associated lemmas in a dedicated subsection of <code>Quantum.thy</code>.</p>



<a name="173801294"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173801294" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173801294">(Aug 21 2019 at 14:52)</a>:</h4>
<p>Thanks could you add me as an author please?</p>



<a name="173805921"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173805921" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Anthony Bordg <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173805921">(Aug 21 2019 at 15:41)</a>:</h4>
<blockquote>
<p>Thanks could you add me as an author please?</p>
</blockquote>
<p>It's already done. In front of the subsection on the bitwise inner product, which was imported from <code>Deutsch-Jozsa.thy</code> to <code>Quantum.thy</code>, I added immediately a comment with the authorship of this subsection.</p>



<a name="173808587"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/202968-quantum%20computing/topic/Deutsch-Jozsa/near/173808587" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hanna Lachnitt <a href="http://isabelle.systems/zulip-archive/stream/202968-quantum-computing/topic/Deutsch-Jozsa.html#173808587">(Aug 21 2019 at 16:08)</a>:</h4>
<p>Thanks a lot :)</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>