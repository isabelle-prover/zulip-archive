<html>
<head><meta charset="utf-8"><title>Using ML to Automatically Dualize · Isabelle/ML · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/index.html">Isabelle/ML</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/topic/Using.20ML.20to.20Automatically.20Dualize.html">Using ML to Automatically Dualize</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="553931266"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/211483-Isabelle/ML/topic/Using%20ML%20to%20Automatically%20Dualize/near/553931266" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> George Chemmala <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/topic/Using.20ML.20to.20Automatically.20Dualize.html#553931266">(Nov 05 2025 at 18:13)</a>:</h4>
<p>I'm part of a group working on proving lemmas in projective geometry. There is a duality between points and lines, so ideally we could write a lemma and our ML function would automatically convert the lemma into the duel projective space.</p>
<p>I'm familiar with something like this in Lean with groups, but wasn't sure if this was also possible in Isabelle</p>
<div class="codehilite" data-code-language="Lean4"><pre><span></span><code><span class="kd">@[</span><span class="n">to_additive</span><span class="kd">]</span>
<span class="kn">class</span><span class="w"> </span><span class="n">Monoid</span><span class="w"> </span><span class="o">(</span><span class="n">α</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="o">)</span><span class="w"> </span><span class="kn">extends</span><span class="w"> </span><span class="n">Semigroup</span><span class="w"> </span><span class="n">α</span><span class="o">,</span><span class="w"> </span><span class="n">MulOneClass</span><span class="w"> </span><span class="n">α</span>
<span class="kn">attribute</span><span class="w"> </span><span class="o">[</span><span class="n">to_additive</span><span class="w"> </span><span class="n">existing</span><span class="o">]</span><span class="w"> </span><span class="n">Monoid</span><span class="bp">.</span><span class="n">toMulOneClass</span>

<span class="kn">class</span><span class="w"> </span><span class="n">AddGroup</span><span class="w"> </span><span class="o">(</span><span class="n">G</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="o">)</span><span class="w"> </span><span class="kn">extends</span><span class="w"> </span><span class="n">AddMonoid</span><span class="w"> </span><span class="n">G</span><span class="o">,</span><span class="w"> </span><span class="n">Neg</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="kn">where</span>
<span class="w">  </span><span class="sd">/-- -a + a = 0 -/</span>
<span class="w">  </span><span class="n">neg_add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">,</span><span class="w"> </span><span class="bp">-</span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="sd">/-- a + -a = 0 -/</span>
<span class="w">  </span><span class="n">add_neg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">+</span><span class="w"> </span><span class="bp">-</span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">0</span>

<span class="kd">@[</span><span class="n">to_additive</span><span class="kd">]</span>
<span class="kn">class</span><span class="w"> </span><span class="n">Group</span><span class="w"> </span><span class="o">(</span><span class="n">G</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="o">)</span><span class="w"> </span><span class="kn">extends</span><span class="w"> </span><span class="n">Monoid</span><span class="w"> </span><span class="n">G</span><span class="o">,</span><span class="w"> </span><span class="n">Inv</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="kn">where</span>
<span class="w">  </span><span class="sd">/-- a⁻¹ * a = 1 -/</span>
<span class="w">  </span><span class="n">inv_mul</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="bp">⁻¹</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="sd">/-- a * a⁻¹ = 1 -/</span>
<span class="w">  </span><span class="n">mul_inv</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="bp">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="bp">*</span><span class="w"> </span><span class="n">a</span><span class="bp">⁻¹</span><span class="w"> </span><span class="bp">=</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>



<a name="555646081"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/211483-Isabelle/ML/topic/Using%20ML%20to%20Automatically%20Dualize/near/555646081" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/topic/Using.20ML.20to.20Automatically.20Dualize.html#555646081">(Nov 14 2025 at 17:51)</a>:</h4>
<p>Usually I think you'd use the transfer package for that sort of thing. But I am not comfortable enough with it to give more specific advice.</p>



<a name="556948207"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/211483-Isabelle/ML/topic/Using%20ML%20to%20Automatically%20Dualize/near/556948207" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> George Chemmala <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/topic/Using.20ML.20to.20Automatically.20Dualize.html#556948207">(Nov 17 2025 at 23:14)</a>:</h4>
<p>Sorry for the late reply - a little green to Zulip but I will look into this - thanks!</p>



<a name="557881960"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/211483-Isabelle/ML/topic/Using%20ML%20to%20Automatically%20Dualize/near/557881960" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/topic/Using.20ML.20to.20Automatically.20Dualize.html#557881960">(Nov 18 2025 at 09:49)</a>:</h4>
<p>The basic idea is that you define some kind of correspondence relation between all the relevant functions and predicates (usually some kind of homomorphism or isomorphism) and then prove so called "transfer rules" for all the functions and predicates you care about. These essentially just state that the functions/predicate respect the correspondence relation (or are compatible with it).</p>
<p>Then you could generally define something like a <code>group_homomorphism</code> or <code>group_isomorphism</code> locale that fixes two groups and a function or relation between them. If you do a function and want isomorphism, you then have to define the relation from that as something like <code>rel x y = (y = f x)</code>. Then you prove the transfer rules for all your group-theoretic functions and concepts, e.g. <code>mul</code>, <code>inv</code>, <code>1</code>, <code>order</code>. And then you can instantiate that locale for addition and multiplication and use the transfer package to transfer all the results.</p>
<p>For the <code>group</code> case, the better solution would of course be to just define a generic <code>group</code> locale and then instantiate that for addition and multiplication separately.</p>
<p>In case of duality, you can do an interpretation or sublocale in your geometry stating that there is an isomorphism between the locale and its dual, and then get all the theorems that way.</p>
<p>In fact, you can do that even without the transfer package. You can just do a sublocale or interpretation inside your geometry locale, proving that the dual geometry is also a geometry. Then you get all the theorems resulting from that for your dual geometric. The problem is that the theorems you get from will of course be phrased in terms of concepts regarding the dual geometry, and you then still have to do some work to relate them to the same concepts of your original geometry. That's where <code>transfer</code> can help you. But if it's not that many theorems or if it relating the concepts of the dual geometry to the original one is easy anyway then you can also get by without using <code>transfer</code>.</p>
<p>This is all documented e.g. in Ondřej Kunčar's PhD thesis: <a href="https://www21.in.tum.de/~kuncar/documents/kuncar-phdthesis.pdf">https://www21.in.tum.de/~kuncar/documents/kuncar-phdthesis.pdf</a></p>
<p>Note that the transfer package does have some drawbacks, e.g. proving transfer rules for recursive functions can be painful, and it does not support conditional transfer rules. This is a problem if you e.g. define the inverse of a group as <code>inv x = (SOME y. x * y = 1)</code>. Then <code>y</code> may well be undefined if <code>x</code> is not in the carrier of the group and you will not be able to prove a transfer rule for <code>inv</code> (or rather the natural transfer rule for it would have the precondition <code>x ∈ carrier</code>. I vaguely recall that <span class="user-mention" data-user-id="233154">@Kevin Kappelmann</span> is working on some new tool that can do that sort of thing. But you can often also get away with just defining your concept in a way that does have a nice transfer rule, e.g. <code>inv x = (SOME y. if x ∈ carrier then x * y = 1 else y = 1)</code>.</p>



<a name="558939595"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/211483-Isabelle/ML/topic/Using%20ML%20to%20Automatically%20Dualize/near/558939595" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> George Chemmala <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/topic/Using.20ML.20to.20Automatically.20Dualize.html#558939595">(Nov 24 2025 at 02:07)</a>:</h4>
<p>Is there a limit to how many sublocales you can make? e.g. a subsublocale?</p>



<a name="560086429"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/211483-Isabelle/ML/topic/Using%20ML%20to%20Automatically%20Dualize/near/560086429" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chelsea Edmonds <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle.2FML/topic/Using.20ML.20to.20Automatically.20Dualize.html#560086429">(Nov 25 2025 at 07:48)</a>:</h4>
<p>I'm yet to run into any limits for sublocales with all the work I've done (both in terms of sublocale inheritance tree depth and breadth). Where you have to be careful is when you get circular dependencies (often still possible, but needs to be done very carefully to avoid an infinite loop in the sublocale declaration proof).</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>