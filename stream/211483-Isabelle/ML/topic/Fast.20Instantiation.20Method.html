<html>
<head><meta charset="utf-8"><title>Fast Instantiation Method · Isabelle/ML · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle/ML/index.html">Isabelle/ML</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle/ML/topic/Fast.20Instantiation.20Method.html">Fast Instantiation Method</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="209871451"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/211483-Isabelle/ML/topic/Fast%20Instantiation%20Method/near/209871451" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mathias Fleury <a href="http://isabelle.systems/zulip-archive/stream/211483-Isabelle/ML/topic/Fast.20Instantiation.20Method.html#209871451">(Sep 12 2020 at 08:39)</a>:</h4>
<p>I have an unusual use case: I check the proofs generated by the SMT solver veriT (so once I have pushed my work, there will be a <code>veriT_smt</code> and an <code>smt</code> tactic). There is one rule that appears very often, namely <code>?P ≠ ?Q ∨ ¬ ?P ∨ ?Q</code> with some (potentially large) P and Q. </p>
<p>What is the fastest way to convert the term to a theorem? I have tried various things and never managed to get below 10ms (on my computer), but replaying such steps is so trivial that I find 10ms already too much.</p>
<p>Here is a real example if you want to play with it:</p>
<div class="spoiler-block"><div class="spoiler-header">

</div><div class="spoiler-content" aria-hidden="true">

<p>If you don't have imported List.thy, uncomment Nil and cons at the top:</p>
<div class="codehilite"><pre><span></span><code>context
  fixes piecewise_C1 :: &quot;(&#39;real :: {one,zero,ord} ⇒ &#39;a :: {one,zero,ord}) ⇒ &#39;real set ⇒ bool&quot;  and
     joinpaths :: &quot;(&#39;real ⇒ &#39;a) ⇒ (&#39;real ⇒ &#39;a) ⇒ &#39;real ⇒ &#39;a&quot; (* and
     cons :: ‹&#39;a ⇒ &#39;b ⇒ &#39;b› and
     Nil :: ‹&#39;b› *)
begin
notation piecewise_C1 (infixr &quot;piecewise&#39;_C1&#39;_differentiable&#39;_on&quot; 50)
notation joinpaths (infixr &quot;+++&quot; 75)
(* notation cons (infixr &quot;#&quot; 75)
notation Nil (&quot;[]&quot; 80) *)


lemma XX:
 ‹((∀veriT_vr2 veriT_vr3.
              (veriT_vr2 = rec_join veriT_vr3 ∧
               ([] = veriT_vr3 ∧ (λuu. 0) = veriT_vr2 ⟶ False) ∧
               (∀veriT_vr4.
                   veriT_vr3 = veriT_vr4 # [] ∧
                   veriT_vr2 = coeff_cube_to_path veriT_vr4 ⟶
                   False) ∧
               (∀veriT_vr4 veriT_vr5 veriT_vr6.
                   veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                   veriT_vr2 =
                   coeff_cube_to_path veriT_vr4 +++
                   rec_join (veriT_vr5 # veriT_vr6) ⟶
                   False) ⟶
               False) =
              (rec_join veriT_vr3 = rec_join veriT_vr3 ∧
               ([] = veriT_vr3 ∧ (λuu. 0) = rec_join veriT_vr3 ⟶
                False) ∧
               (∀veriT_vr4.
                   veriT_vr3 = veriT_vr4 # [] ∧
                   rec_join veriT_vr3 = coeff_cube_to_path veriT_vr4 ⟶
                   False) ∧
               (∀veriT_vr4 veriT_vr5 veriT_vr6.
                   veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                   rec_join veriT_vr3 =
                   coeff_cube_to_path veriT_vr4 +++
                   rec_join (veriT_vr5 # veriT_vr6) ⟶
                   False) ⟶
               False)) ∧
          (∀veriT_vr3.
              rec_join veriT_vr3 = rec_join veriT_vr3 ∧
              ([] = veriT_vr3 ∧ (λuu. 0) = rec_join veriT_vr3 ⟶ False) ∧
              (∀veriT_vr4.
                  veriT_vr3 = veriT_vr4 # [] ∧
                  rec_join veriT_vr3 = coeff_cube_to_path veriT_vr4 ⟶
                  False) ∧
              (∀veriT_vr4 veriT_vr5 veriT_vr6.
                  veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                  rec_join veriT_vr3 =
                  coeff_cube_to_path veriT_vr4 +++
                  rec_join (veriT_vr5 # veriT_vr6) ⟶
                  False) ⟶
              False) ≠
          (∀veriT_vr3.
              rec_join veriT_vr3 = rec_join veriT_vr3 ∧
              ([] = veriT_vr3 ∧ (λuu. 0) = rec_join veriT_vr3 ⟶ False) ∧
              (∀veriT_vr4.
                  veriT_vr3 = veriT_vr4  # [] ∧
                  rec_join veriT_vr3 = coeff_cube_to_path veriT_vr4 ⟶
                  False) ∧
              (∀veriT_vr4 veriT_vr5 veriT_vr6.
                  veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                  rec_join veriT_vr3 =
                  coeff_cube_to_path veriT_vr4 +++
                  rec_join (veriT_vr5 # veriT_vr6) ⟶
                  False) ⟶
              False)) ≠
         False ∨
         ¬ ((∀veriT_vr2 veriT_vr3.
                 (veriT_vr2 = rec_join veriT_vr3 ∧
                  ([] = veriT_vr3 ∧ (λuu. 0) = veriT_vr2 ⟶ False) ∧
                  (∀veriT_vr4.
                      veriT_vr3 = veriT_vr4  # [] ∧
                      veriT_vr2 = coeff_cube_to_path veriT_vr4 ⟶
                      False) ∧
                  (∀veriT_vr4 veriT_vr5 veriT_vr6.
                      veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                      veriT_vr2 =
                      coeff_cube_to_path veriT_vr4 +++
                      rec_join (veriT_vr5 # veriT_vr6) ⟶
                      False) ⟶
                  False) =
                 (rec_join veriT_vr3 = rec_join veriT_vr3 ∧
                  ([] = veriT_vr3 ∧ (λuu. 0) = rec_join veriT_vr3 ⟶
                   False) ∧
                  (∀veriT_vr4.
                      veriT_vr3 = veriT_vr4  # [] ∧
                      rec_join veriT_vr3 = coeff_cube_to_path veriT_vr4 ⟶
                      False) ∧
                  (∀veriT_vr4 veriT_vr5 veriT_vr6.
                      veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                      rec_join veriT_vr3 =
                      coeff_cube_to_path veriT_vr4 +++
                      rec_join (veriT_vr5 # veriT_vr6) ⟶
                      False) ⟶
                  False)) ∧
             (∀veriT_vr3.
                 rec_join veriT_vr3 = rec_join veriT_vr3 ∧
                 ([] = veriT_vr3 ∧ (λuu. 0) = rec_join veriT_vr3 ⟶
                  False) ∧
                 (∀veriT_vr4.
                     veriT_vr3 = veriT_vr4  # [] ∧
                     rec_join veriT_vr3 = coeff_cube_to_path veriT_vr4 ⟶
                     False) ∧
                 (∀veriT_vr4 veriT_vr5 veriT_vr6.
                     veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                     rec_join veriT_vr3 =
                     coeff_cube_to_path veriT_vr4 +++
                     rec_join (veriT_vr5 # veriT_vr6) ⟶
                     False) ⟶
                 False) ≠
             (∀veriT_vr3.
                 rec_join veriT_vr3 = rec_join veriT_vr3 ∧
                 ([] = veriT_vr3 ∧ (λuu. 0) = rec_join veriT_vr3 ⟶
                  False) ∧
                 (∀veriT_vr4.
                     veriT_vr3 = veriT_vr4 # [] ∧
                     rec_join veriT_vr3 = coeff_cube_to_path veriT_vr4 ⟶
                     False) ∧
                 (∀veriT_vr4 veriT_vr5 veriT_vr6.
                     veriT_vr3 = veriT_vr4 # veriT_vr5 # veriT_vr6 ∧
                     rec_join veriT_vr3 =
                     coeff_cube_to_path veriT_vr4 +++
                     rec_join (veriT_vr5 # veriT_vr6) ⟶
                     False) ⟶
                 False)) ∨
         False ›
  sorry

ML ‹
val X = Thm.prop_of @{thm XX}
val thm = @{lemma ‹⋀a b. (a ≠ b) ∨ ¬a ∨ b› by blast+}
fun chrono&#39; f  n =
  if n = 0 then []
  else
  let val start = Timing.start ()
     val _ = f @{context}
     val total = Time.toMilliseconds (#elapsed (Timing.result start))
   in total :: chrono&#39; f (n-1) end
fun chrono f =
  let val n = 10000 in
    fold (curry (op +)) (chrono&#39; f  n) n
  end
›


 ML &quot;ML_Heap.share_common_data ()&quot;
(*If you like tactics, try it here by replacing match_tac*)
ML ‹chrono (fn _ =&gt;  SMT_Replay_Methods.prove @{context} X
     (fn ctxt =&gt; (match_tac ctxt [thm])))›


ML &quot;ML_Heap.share_common_data ()&quot;
  ML ‹
chrono (fn ctxt =&gt; SMT_Replay_Methods.match_instantiate ctxt X  thm)›
 ML &quot;ML_Heap.share_common_data ()&quot;

(*find P and Q and instantiate them directly*)
ML ‹
let
  fun f  ((* Const (&quot;HOL.Trueprop&quot;, _) *) _ $
      ((* Const (&quot;HOL.disj&quot;, _) *) _ $
         ((* Const (&quot;HOL.Not&quot;,_) *) _ $
           ((* Const (&quot;HOL.eq&quot;, _)  *) _$ t1 $ t2)) $ _ ))
    ctxt = Thm.instantiate ([], [(((&quot;Q&quot;, 0), @{typ bool}), Thm.cterm_of ctxt t2), (((&quot;P&quot;, 0), @{typ bool}), Thm.cterm_of ctxt t1)])
in
chrono (f @{context} X)
end›


 ML &quot;ML_Heap.share_common_data ()&quot;
(*fastest solution*)
ML ‹
chrono (fn ctxt =&gt; SMT_Replay_Methods.match_instantiate ctxt X thm)›

end
</code></pre></div>


</div></div>



<hr><p>Last updated: Jul 15 2022 at 23:21 UTC</p>
</html>