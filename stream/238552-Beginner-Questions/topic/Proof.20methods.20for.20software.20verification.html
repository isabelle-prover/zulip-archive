<html>
<head><meta charset="utf-8"><title>Proof methods for software verification · Beginner Questions · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/index.html">Beginner Questions</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html">Proof methods for software verification</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="213541471"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213541471" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213541471">(Oct 16 2020 at 10:15)</a>:</h4>
<p>Hello everyone,</p>
<p>I'm working in the field of software verification and try to use Isabelle to prove the equivalence between two formulas. I tried three lemmas and have some questions as follows:</p>
<ol>
<li>
<p>lemma test1: "(P 0 ⟶ ~P 1) ∧ (P 1 ⟶ ~P 0)  ⟹ ~P 0∨~P 1"<br>
  apply(auto)<br>
  done<br>
It worked perfectly as I want.</p>
</li>
<li>
<p>lemma test2: "(P 0 --&gt; (~P 1 &amp; ~P 2)) &amp; (P 1 --&gt; (~P 0 &amp; ~P 2)) &amp; (P 2 --&gt; (~P 1 &amp; ~P 0))<br>
==&gt; ((~P 1 &amp; ~P 2) | (~P 0 &amp; ~P 2) | (~P 1 &amp; ~P 0))"<br>
  apply(auto)<br>
  done<br>
When I added one more predicate "P 2", it run until out of memory. I don't think that the lemma is big enough unprovable like this.</p>
</li>
<li>
<p>lemma test3: "⋀i∈I.(P i ⟶ (⋀j∈I-{i}. ¬P j)) ⟹ ⋁i∈I.(⋀j∈I-{i}. ¬P j)"<br>
  apply (auto)<br>
  done<br>
I tested a generic case and the Isabelle showed that "Failed to apply proof method". I tried to add "apply (induction)" and the result is "Failed to finish proof". So I guess the problem is about applying the right proof method, right? Then, I tried some other like "simp" or "rules" but they didn't work.</p>
</li>
</ol>
<p>P.s: the symbol "bigvee" and "bigwedge" are redefined as follows (<span class="user-mention" data-user-id="233198">@Mathias Fleury</span> re-defined it)<br>
<a href="/user_uploads/14278/iyqQNX41jywBf1-1f7f3p5N0/Screenshot-2020-10-16-at-12.13.52.png">Screenshot-2020-10-16-at-12.13.52.png</a> <br>
Could you explain those questions, please? Thank you very much.</p>
<div class="message_inline_image"><a href="/user_uploads/14278/iyqQNX41jywBf1-1f7f3p5N0/Screenshot-2020-10-16-at-12.13.52.png" title="Screenshot-2020-10-16-at-12.13.52.png"><img src="/user_uploads/14278/iyqQNX41jywBf1-1f7f3p5N0/Screenshot-2020-10-16-at-12.13.52.png"></a></div>



<a name="213542523"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213542523" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213542523">(Oct 16 2020 at 10:29)</a>:</h4>
<p>As for 2, <code>auto</code> is not always the best way to go. In this particular case, it seems that the simplifier loops (no idea why). More specialised methods for logic/set theory like <code>blast</code> and <code>metis</code> and <code>smt</code> solve this almost instantly. There are also more obscure ones (<code>argo</code>, <code>sat</code>, <code>satx</code>) that do a good job here.</p>
<p>As for the bigvee thing, please post the actual source could and not just a screenshot. It's a lot of text to copy from a screenshot by hand. I don't really understand what the advantage of <code>bigvee</code> and <code>bigwedge</code> are over <code>Bex</code> and <code>Ball</code>, i.e. <code>∃x∈A. P x</code> instead of <code>⋁x∈A. P x</code>.</p>



<a name="213542782"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213542782" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lukas Stevens <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213542782">(Oct 16 2020 at 10:32)</a>:</h4>
<p>Zulip uses markdown as markup so you can use triple backticks for code like this:</p>
<div class="codehilite"><pre><span></span><code>f x = x
</code></pre></div>



<a name="213542802"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213542802" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213542802">(Oct 16 2020 at 10:33)</a>:</h4>
<p>Also, I don't think 3 holds if <code>I</code> is the empty set. The following can easily be proven by blast:</p>
<div class="codehilite"><pre><span></span><code>∀i∈I. P i ⟶ (∀j∈I-{i}. ¬P j) ⟹ I ≠ {} ⟹ ∃i∈I. ∀j∈I-{i}. ¬P j
</code></pre></div>



<a name="213542837"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213542837" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213542837">(Oct 16 2020 at 10:33)</a>:</h4>
<p>This is the source code:</p>
<div class="codehilite"><pre><span></span><code>theory test1
imports Main
begin

context comm_monoid_add (*commutative monoid with addition*)
begin
sublocale bigvee: comm_monoid_set HOL.disj False
  defines bigvee = bigvee.F and bigvee&#39; = bigvee.G
  by standard auto

abbreviation bigvee&#39;&#39; :: ‹bool set ⇒ bool› (&quot;⋁&quot;)
  where &quot;⋁ ≡ bigvee (λx. x)&quot;

sublocale bigwedge: comm_monoid_set HOL.conj True
  defines bigwedge = bigwedge.F and bigwedge&#39; = bigwedge.G
  by standard auto

abbreviation bigwedge&#39;&#39; :: ‹bool set ⇒ bool› (&quot;⋀&quot;)
  where &quot;⋀ ≡ bigwedge (λx. x)&quot;

end
syntax (*Define pattern of bigwedge and bigvee*)
  &quot;_bigwedge&quot; :: &quot;pttrn ⇒ &#39;a set ⇒ &#39;b ⇒ &#39;b::comm_monoid_add&quot;  (&quot;(2⋀(_/∈_)./ _)&quot; [0, 51, 10] 10)
translations ― ‹Beware of argument permutation!›
  &quot;⋀i∈A. b&quot; ⇌ &quot;CONST bigwedge (λi. b) A&quot;

syntax
  &quot;_bigvee&quot; :: &quot;pttrn ⇒ &#39;a set ⇒ &#39;b ⇒ &#39;b::comm_monoid_add&quot;  (&quot;(2⋁(_/∈_)./ _)&quot; [0, 51, 10] 10)
translations ― ‹Beware of argument permutation!› (*translation between parse rules or print rules*)
  &quot;⋁i∈A. b&quot; ⇌ &quot;CONST bigvee (λi. b) A&quot;
(*CONST ensures that the given identifier is treated as constant term*)

instantiation bool :: comm_monoid_add
begin
definition zero_bool where
[simp]: ‹zero_bool = False›
definition plus_bool where
[simp]: ‹plus_bool = (∨)›
instance
  by standard auto
end
thm bigvee_def
thm bigwedge_def

(*meaningful name*)
definition J :: &quot;nat set&quot; where
&quot;J = {n . n &gt; 0}&quot;
definition U :: &quot;nat set&quot; where
&quot;U = {n . n &gt; 0}&quot;
definition T :: &quot;nat set&quot; where
&quot;T = {n . n &gt; 0}&quot;
definition I :: &quot;nat set&quot; where
&quot;I = {n . n &gt; 0}&quot;
definition V :: &quot;nat set&quot; where
&quot;V = {n . n &gt; 0}&quot;
definition K :: &quot;nat set&quot; where
&quot;K = {n . n &gt; 0}&quot;
definition H :: &quot;nat set&quot; where
&quot;H = {n . n &gt; 0}&quot;
definition L :: &quot;nat set&quot; where
&quot;L = {n . n &gt; 0}&quot;
definition B :: &quot;nat set&quot; where
  &quot;B = {1, 2, 3, 4}&quot;

lemma ‹finite A ⟹ (⋁i∈A. f i) ⟷ (∃i ∈ A. f i)›
  apply (induction rule: finite_induct)
  apply (auto simp: )
  done

lemma ‹finite A ⟹ (⋀i∈A. f i) ⟷ A = {} ∨ (∀i ∈ A. f i)›
  apply (induction rule: finite_induct)
  apply (auto simp: )
  done

lemma ‹infinite A ⟹ (⋀i∈A. f i) ⟷ True›
  by auto

lemma test0:
  ‹(⋀j∈J. ⋀u∈U. ⋀t∈T. ⋀l∈L. ⋀l⇩1∈L-{l}. ¬P j u t l⇩1) ∨
   (⋁i∈I. ⋁v∈V. ⋀k∈K. ⋁h∈H. Q i v k h) ⟹
   (⋁i∈I. ⋁v∈V. ⋀k∈K. ⋁h∈H. Q i v k h) ∨ (⋀j∈J. ⋀u∈U. ⋀t∈T. ⋀l⇩1∈-{l}. ¬P j u t l⇩1)›
  apply auto
  done

lemma &quot;∀ x. P x ⟶ P x&quot;
apply (auto)
  done

lemma test1: &quot;(P 0 ⟶ ~P 1) ∧ (P 1 ⟶ ~P 0)  ⟹ ~P 0∨~P 1&quot;
  apply(auto)
  done

(*
lemma test2: &quot;(P 0 --&gt; (~P 1 &amp; ~P 2)) &amp; (P 1 --&gt; (~P 0 &amp; ~P 2)) &amp; (P 2 --&gt; (~P 1 &amp; ~P 0))
==&gt; ((~P 1 &amp; ~P 2) | (~P 0 &amp; ~P 2) | (~P 1 &amp; ~P 0))&quot;
  apply(auto)
  done *)

lemma test3: &quot;⋀i∈I.(P i ⟶ (⋀j∈I-{i}. ¬P j)) ⟹ ⋁i∈I.(⋀j∈I-{i}. ¬P j)&quot;
  apply (induction)
  apply (auto)
  done
</code></pre></div>



<a name="213542930"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213542930" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213542930">(Oct 16 2020 at 10:34)</a>:</h4>
<p>If you want to do induction, you should specify what you want to do induction over.</p>



<a name="213543007"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213543007" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213543007">(Oct 16 2020 at 10:35)</a>:</h4>
<p>I defined the set B with 4 elements and used it but the 3rd lemma returned the same result.</p>



<a name="213543248"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213543248" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213543248">(Oct 16 2020 at 10:38)</a>:</h4>
<p>Also note that <code>bigwedge</code> over an infinite set is always true and <code>bigvee</code> over an infinite set is always false. So 3 is trivially false because <code>I</code> is infinite.</p>



<a name="213543280"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213543280" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213543280">(Oct 16 2020 at 10:38)</a>:</h4>
<p>I think you really want to use <code>∀x∈I</code> etc.</p>



<a name="213543307"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213543307" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213543307">(Oct 16 2020 at 10:39)</a>:</h4>
<p>then you don't need induction either, it's straightforward set theory and <code>blast</code> can do it (as long as you feed in the fact that <code>I ≠ {}</code>).</p>



<a name="213543730"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213543730" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213543730">(Oct 16 2020 at 10:44)</a>:</h4>
<p>So if I have </p>
<div class="codehilite"><pre><span></span><code>I = {1, 2, 3, 4}
</code></pre></div>


<p>I can use this directly, right?</p>
<div class="codehilite"><pre><span></span><code>∀i∈I.⋀P i = P 1 ∧ P 2 ∧ P 3 ∧ P 4
∀i∈I.⋁P i = P 1 ∨ P 2 ∨ P 3 ∨ P 4
</code></pre></div>



<a name="213545444"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213545444" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213545444">(Oct 16 2020 at 11:05)</a>:</h4>
<p>You probably mean</p>
<div class="codehilite"><pre><span></span><code>(∀i∈I. P i) = P 1 ∧ P 2 ∧ P 3 ∧ P 4
(∃i∈I. P i) = P 1 ∨ P 2 ∨ P 3 ∨ P 4
</code></pre></div>


<p>right?</p>
<p>In that case: Yes. You just have to unfold the definition of <code>I</code> and then it simplifies to that.</p>



<a name="213546533"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213546533" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213546533">(Oct 16 2020 at 11:18)</a>:</h4>
<p>(deleted)</p>



<a name="213547617"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213547617" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213547617">(Oct 16 2020 at 11:31)</a>:</h4>
<p><span class="user-mention silent" data-user-id="232736">Manuel Eberl</span> <a href="#narrow/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification/near/213542802">said</a>:</p>
<blockquote>
<p>Also, I don't think 3 holds if <code>I</code> is the empty set. The following can easily be proven by blast:</p>
<div class="codehilite"><pre><span></span><code>∀i∈I. P i ⟶ (∀j∈I-{i}. ¬P j) ⟹ I ≠ {} ⟹ ∃i∈I. ∀j∈I-{i}. ¬P j
</code></pre></div>


</blockquote>
<p>Thank you. I tried this with <code>blast</code> and it worked.<br>
I also tried that:</p>
<ol>
<li>I define set I = {1, 2, 3, 4}</li>
</ol>
<div class="codehilite"><pre><span></span><code>definition I :: &quot;nat set&quot; where
  &quot;I = {1, 2, 3, 4}&quot;
</code></pre></div>


<ol start="2">
<li>Then,  I write the lemma but remove the part <code>I ≠ {} </code></li>
</ol>
<div class="codehilite"><pre><span></span><code>lemma test3: &quot;∀i∈I. P i ⟶ (∀j∈I-{i}. ¬P j) ⟹ ∃i∈I. ∀j∈I-{i}. ¬P j&quot;
  apply (blast)
  done
</code></pre></div>


<p>It's failed to prove. So <code>I ≠ {} </code>seems mandatory despite we define set I or not, right?</p>



<a name="213548994"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213548994" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213548994">(Oct 16 2020 at 11:47)</a>:</h4>
<p><code>blast</code> doesn't know how you defined the set.  You can e.g. unfold the definition like this:</p>
<div class="codehilite"><pre><span></span><code>lemma test3: &quot;∀i∈I. P i ⟶ (∀j∈I-{i}. ¬P j) ⟹ ∃i∈I. ∀j∈I-{i}. ¬P j&quot;
  unfolding I_def by blast
</code></pre></div>


<p>Or you can prove that <code>I</code> is nonempty first and then supply that fact to blast:</p>
<div class="codehilite"><pre><span></span><code>lemma I_not_empty: &quot;I ≠ {}&quot;
  by (auto simp: I_def)

lemma test3: &quot;∀i∈I. P i ⟶ (∀j∈I-{i}. ¬P j) ⟹ ∃i∈I. ∀j∈I-{i}. ¬P j&quot;
  using I_not_empty by blast
</code></pre></div>



<a name="213549978"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213549978" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213549978">(Oct 16 2020 at 11:58)</a>:</h4>
<p>Wow, that's awesome. Thank you very much.</p>



<a name="213551883"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213551883" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213551883">(Oct 16 2020 at 12:17)</a>:</h4>
<p>If you want to learn Isabelle systematically, I suggest you work through the first half of the ‘Concrete Semantics’ books. It's online for free: <a href="http://www.concrete-semantics.org/">http://www.concrete-semantics.org/</a></p>



<a name="213552579"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213552579" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213552579">(Oct 16 2020 at 12:24)</a>:</h4>
<p>Thank you for your suggestion. After putting my lemma and choosing to prove them using <code>metis</code>, the <code>metis</code> is highlighted in purple (and my computer's fans are running so hard). Do you know the meaning of this color? (I just know that red for error). <a href="/user_uploads/14278/us188qQszth-oJMFItzzS055/Screenshot-2020-10-16-at-14.19.08.png">Screenshot-2020-10-16-at-14.19.08.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/14278/us188qQszth-oJMFItzzS055/Screenshot-2020-10-16-at-14.19.08.png" title="Screenshot-2020-10-16-at-14.19.08.png"><img src="/user_uploads/14278/us188qQszth-oJMFItzzS055/Screenshot-2020-10-16-at-14.19.08.png"></a></div>



<a name="213553445"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213553445" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213553445">(Oct 16 2020 at 12:32)</a>:</h4>
<p>It means that the command is still running. Metis might not be good enough to do something this big. Other methods might be. If you paste the full example in here, I can have a look at it.</p>



<a name="213553768"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213553768" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213553768">(Oct 16 2020 at 12:36)</a>:</h4>
<p>Here you are. I tried blast first but it couldn't prove. Thus, I changed to metis.</p>
<div class="codehilite"><pre><span></span><code>theory MyMaths
  imports Main
begin
definition xor :: &quot;bool ⇒ bool ⇒ bool&quot; where
&quot;xor A B ≡ (A &amp; ~B) | (~A &amp; B)&quot;

definition J :: &quot;nat set&quot; where
&quot;J = {n . n &gt; 0}&quot;
definition U :: &quot;nat set&quot; where
&quot;U = {n . n &gt; 0}&quot;
definition T :: &quot;nat set&quot; where
&quot;T = {n . n &gt; 0}&quot;
definition I :: &quot;nat set&quot; where
&quot;I = {n . n &gt; 0}&quot;
definition V :: &quot;nat set&quot; where
&quot;V = {n . n &gt; 0}&quot;
definition K :: &quot;nat set&quot; where
&quot;K = {n . n &gt; 0}&quot;
definition H :: &quot;nat set&quot; where
&quot;H = {n . n &gt; 0}&quot;
definition L :: &quot;nat set&quot; where
&quot;L = {n . n &gt; 0}&quot;


lemma &quot;((∀l∈L.∀j∈J.∀u∈U.∀t∈T. ¬P j u t l) ∨ (∃h∈H.∃i∈I.∃v∈V.∀k∈K. (Q i v k h ∧ (∀h⇩1∈H-{h}. ¬Q i v k h⇩1))))
∧ (∃l∈L.∃h∈H.((∀j∈J.∀u∈U.∀t∈T.∀l⇩1∈L-{l}. ¬P j u t l⇩1) ∧ (∃i∈I.∃v∈V.∀k∈K.∀h⇩1∈H-{h}. ¬Q i v k h⇩1)))
⟹ (∃h∈H.((∀l∈L.∀j∈J.∀u∈U.∀t∈T. ¬P j u t l) ∧ (∀i∈I.∀v∈V.∀k∈K.∀h⇩1∈H-{h}.¬Q i v k h⇩1)))
∨ (∃l∈L.∃h∈H.(∀j∈J.∀u∈U.∀t∈T.∀l⇩1∈L-{l}. ¬P j u t l⇩1) ∧ (∃i∈I.∃v∈V.∀k∈K.(Q i v k h ∧ (∀h⇩1∈H-{h}. ¬Q i v k h⇩1))))&quot;
  unfolding I_def and V_def and K_def and H_def and J_def and U_def and T_def and L_def
  using [[simp_trace]]
  by metis

end
</code></pre></div>



<a name="213565052"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213565052" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213565052">(Oct 16 2020 at 14:12)</a>:</h4>
<p>Okay, now you're back to infinite sets again. That means things like SAT solvers cannot be used. The definitions of your sets don't really make the problem any easier either, so I don't think unfolding helps.</p>



<a name="213565580"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213565580" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213565580">(Oct 16 2020 at 14:16)</a>:</h4>
<p>Normally, I would say to tackle something like this with an SMT solver like Z3 or CVC4, but it seems this is too difficult for them.</p>



<a name="213565622"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213565622" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213565622">(Oct 16 2020 at 14:16)</a>:</h4>
<p>(then again, I am not sure if this holds in the first place)</p>



<a name="213567250"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213567250" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213567250">(Oct 16 2020 at 14:28)</a>:</h4>
<p>For two particular values of <code>P</code> and <code>Q</code>, I was able to prove the negation of your goal, so apparently it doesn't hold:</p>
<div class="codehilite"><pre><span></span><code>definition &quot;P = (λa b c d. False)&quot;
definition &quot;Q = (λa b c d. a ≠ 1 ∧ (b = 1 ∧ c = 1 ∧ d = 1 ∨ b ≠ 1 ∧ c = 1 ∧ d ≠ 1))&quot;

lemma &quot;¬(((∀l∈L.∀j∈J.∀u∈U.∀t∈T. ¬P j u t l) ∨ (∃h∈H.∃i∈I.∃v∈V.∀k∈K. (Q i v k h ∧ (∀h⇩1∈H-{h}. ¬Q i v k h⇩1))))
∧ (∃l∈L.∃h∈H.((∀j∈J.∀u∈U.∀t∈T.∀l⇩1∈L-{l}. ¬P j u t l⇩1) ∧ (∃i∈I.∃v∈V.∀k∈K.∀h⇩1∈H-{h}. ¬Q i v k h⇩1)))
⟶ (∃h∈H.((∀l∈L.∀j∈J.∀u∈U.∀t∈T. ¬P j u t l) ∧ (∀i∈I.∀v∈V.∀k∈K.∀h⇩1∈H-{h}.¬Q i v k h⇩1)))
∨ (∃l∈L.∃h∈H.(∀j∈J.∀u∈U.∀t∈T.∀l⇩1∈L-{l}. ¬P j u t l⇩1) ∧ (∃i∈I.∃v∈V.∀k∈K.(Q i v k h ∧ (∀h⇩1∈H-{h}. ¬Q i v k h⇩1)))))&quot;
  unfolding I_def and V_def and K_def and H_def and J_def and U_def and T_def and L_def P_def Q_def
  apply auto
  apply (rule exI[of _ 2])
  apply auto
  subgoal for h
    apply (rule bexI[of _ &quot;h + 2&quot;])
     apply auto
    done
</code></pre></div>


<p>The proof isn't pretty, but it gets the point across. I found that particular counterexample for <code>P</code> and <code>Q</code> using the <code>nitpick</code> command.</p>



<a name="213569596"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213569596" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213569596">(Oct 16 2020 at 14:44)</a>:</h4>
<p>I might make something wrong when typing the formulas. I'll check it again.<br>
To make sure that they're not infinite sets. I re-defined as follows (each set has 99 elements): </p>
<div class="codehilite"><pre><span></span><code>definition J :: &quot;nat set&quot; where
&quot;J = {n . n &lt; 100}&quot;
definition U :: &quot;nat set&quot; where
&quot;U = {n . n &lt; 100}&quot;
definition T :: &quot;nat set&quot; where
&quot;T = {n . n &lt; 100}&quot;
definition I :: &quot;nat set&quot; where
&quot;I = {n . n &lt; 100}&quot;
definition V :: &quot;nat set&quot; where
&quot;V = {n . n &lt; 100}&quot;
definition K :: &quot;nat set&quot; where
&quot;K = {n . n &lt; 100}&quot;
definition H :: &quot;nat set&quot; where
&quot;H = {n . n &lt; 100}&quot;
definition L :: &quot;nat set&quot; where
&quot;L = {n . n &lt; 100}&quot;
</code></pre></div>



<a name="213570600"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213570600" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213570600">(Oct 16 2020 at 14:51)</a>:</h4>
<p>Nope.</p>
<div class="codehilite"><pre><span></span><code>definition J :: &quot;nat set&quot; where
&quot;J = {n . n &lt; 100}&quot;
definition U :: &quot;nat set&quot; where
&quot;U = {n . n &lt; 100}&quot;
definition T :: &quot;nat set&quot; where
&quot;T = {n . n &lt; 100}&quot;
definition I :: &quot;nat set&quot; where
&quot;I = {n . n &lt; 100}&quot;
definition V :: &quot;nat set&quot; where
&quot;V = {n . n &lt; 100}&quot;
definition K :: &quot;nat set&quot; where
&quot;K = {n . n &lt; 100}&quot;
definition H :: &quot;nat set&quot; where
&quot;H = {n . n &lt; 100}&quot;
definition L :: &quot;nat set&quot; where
&quot;L = {n . n &lt; 100}&quot;

definition &quot;P = (λa b c d. False)&quot;
definition &quot;Q = (λa b c d. a ≠ 1 ∧ (b = 1 ∧ c = 1 ∧ d = 1 ∨ b ≠ 1 ∧ c = 1 ∧ d ≠ 1))&quot;

lemma *: &quot;(∃x∈A - B. R x) ⟷ (∃x. x ∈ A ∧ x ∉ B ∧ R x)&quot;
         &quot;(∀x∈A - B. R x) ⟷ (∀x. x ∉ A ∨ x ∈ B ∨ R x)&quot;
  by auto

lemma &quot;¬(((∀l∈L.∀j∈J.∀u∈U.∀t∈T. ¬P j u t l) ∨ (∃h∈H.∃i∈I.∃v∈V.∀k∈K. (Q i v k h ∧ (∀h⇩1∈H-{h}. ¬Q i v k h⇩1))))
∧ (∃l∈L.∃h∈H.((∀j∈J.∀u∈U.∀t∈T.∀l⇩1∈L-{l}. ¬P j u t l⇩1) ∧ (∃i∈I.∃v∈V.∀k∈K.∀h⇩1∈H-{h}. ¬Q i v k h⇩1)))
⟶ (∃h∈H.((∀l∈L.∀j∈J.∀u∈U.∀t∈T. ¬P j u t l) ∧ (∀i∈I.∀v∈V.∀k∈K.∀h⇩1∈H-{h}.¬Q i v k h⇩1)))
∨ (∃l∈L.∃h∈H.(∀j∈J.∀u∈U.∀t∈T.∀l⇩1∈L-{l}. ¬P j u t l⇩1) ∧ (∃i∈I.∃v∈V.∀k∈K.(Q i v k h ∧ (∀h⇩1∈H-{h}. ¬Q i v k h⇩1)))))&quot;
  unfolding I_def and V_def and K_def and H_def and J_def and U_def and T_def and L_def P_def Q_def
  apply (auto simp: *)
     apply presburger+
  done
</code></pre></div>



<a name="213570755"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213570755" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213570755">(Oct 16 2020 at 14:52)</a>:</h4>
<p>(<code>presburger</code> is a decision procedure for Presburger logic, i.e. linear arithmetic on integers plus quantifiers. It has pretty terrible performance, but in this case, it works pretty well.)</p>



<a name="213572904"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213572904" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213572904">(Oct 16 2020 at 15:10)</a>:</h4>
<p>Can you explain why did you define P and Q like this?</p>
<div class="codehilite"><pre><span></span><code>definition &quot;P = (λa b c d. False)&quot;
definition &quot;Q = (λa b c d. a ≠ 1 ∧ (b = 1 ∧ c = 1 ∧ d = 1 ∨ b ≠ 1 ∧ c = 1 ∧ d ≠ 1))&quot;
</code></pre></div>



<a name="213573004"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213573004" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213573004">(Oct 16 2020 at 15:10)</a>:</h4>
<p>Because it leads to a counterexample?</p>



<a name="213573063"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213573063" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213573063">(Oct 16 2020 at 15:11)</a>:</h4>
<p>The way you stated your lemma, <code>P</code> and <code>Q</code> were free variables, i.e. you claimed that it holds for all values of <code>P</code> and <code>Q</code>. I showed that there are two particular values for which it does not hold.</p>



<a name="213573346"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213573346" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213573346">(Oct 16 2020 at 15:12)</a>:</h4>
<p>But when you applied presburger+, it's solved, right?</p>



<a name="213573726"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213573726" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213573726">(Oct 16 2020 at 15:14)</a>:</h4>
<p>Ah, when I remove your definition of P and Q, it's unsolvable.</p>



<a name="213573754"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213573754" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213573754">(Oct 16 2020 at 15:14)</a>:</h4>
<p>I proved the <em>negation</em> of your lemma.</p>



<a name="213573881"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213573881" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213573881">(Oct 16 2020 at 15:15)</a>:</h4>
<p>If we call the statement of your lemma <code>foo(P,Q)</code>, you essentially claimed <code>∀P Q. foo(P,Q)</code>. I showed <code>∃P Q. ¬foo(P,Q)</code>.</p>



<a name="213574033"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213574033" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213574033">(Oct 16 2020 at 15:16)</a>:</h4>
<p>Yes, I see. So the problem is the correctness of my lemma, not the definition.</p>



<a name="213731803"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213731803" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213731803">(Oct 18 2020 at 23:37)</a>:</h4>
<blockquote>
<p>The proof isn't pretty, but it gets the point across. I found that particular counterexample for P and Q using the <code>nitpick</code> command.</p>
</blockquote>
<p>Hi Manuel, how can you generate the definition of P and Q using the <code>nitpick</code> command? When I used this command, it showed hundreds of lines like this <a href="/user_uploads/14278/33bS7koDnprQcgMQ5yH6SW2v/Screenshot-2020-10-19-at-01.36.04.png">Screenshot-2020-10-19-at-01.36.04.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/14278/33bS7koDnprQcgMQ5yH6SW2v/Screenshot-2020-10-19-at-01.36.04.png" title="Screenshot-2020-10-19-at-01.36.04.png"><img src="/user_uploads/14278/33bS7koDnprQcgMQ5yH6SW2v/Screenshot-2020-10-19-at-01.36.04.png"></a></div>



<a name="213750536"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213750536" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213750536">(Oct 19 2020 at 07:23)</a>:</h4>
<p>I did it for the variant with <code>{n. n &gt; 0}</code>. Or rather, I think I even did it for the variant where all the sets where <code>UNIV</code> (which I think should be equivalent).</p>



<a name="213773159"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213773159" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213773159">(Oct 19 2020 at 11:45)</a>:</h4>
<p>I set up the variant with <code>{n. n&gt;0}</code> and the result is shown as follows:<br>
<a href="/user_uploads/14278/yOUlRu7UchAgnlaa6uOva90k/Screenshot-2020-10-19-at-13.43.18.png">Screenshot-2020-10-19-at-13.43.18.png</a> <br>
<a href="/user_uploads/14278/ATVnzs31Pje9yFe08EXrjBGd/Screenshot-2020-10-19-at-13.43.48.png">Screenshot-2020-10-19-at-13.43.48.png</a> <br>
How did you generate the definition of P and Q from them?</p>
<div class="message_inline_image"><a href="/user_uploads/14278/yOUlRu7UchAgnlaa6uOva90k/Screenshot-2020-10-19-at-13.43.18.png" title="Screenshot-2020-10-19-at-13.43.18.png"><img src="/user_uploads/14278/yOUlRu7UchAgnlaa6uOva90k/Screenshot-2020-10-19-at-13.43.18.png"></a></div><div class="message_inline_image"><a href="/user_uploads/14278/ATVnzs31Pje9yFe08EXrjBGd/Screenshot-2020-10-19-at-13.43.48.png" title="Screenshot-2020-10-19-at-13.43.48.png"><img src="/user_uploads/14278/ATVnzs31Pje9yFe08EXrjBGd/Screenshot-2020-10-19-at-13.43.48.png"></a></div><div class="codehilite"><pre><span></span><code>definition &quot;P = (λa b c d. False)&quot;
definition &quot;Q = (λa b c d. a ≠ 1 ∧ (b = 1 ∧ c = 1 ∧ d = 1 ∨ b ≠ 1 ∧ c = 1 ∧ d ≠ 1))&quot;
</code></pre></div>



<a name="213801860"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213801860" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213801860">(Oct 19 2020 at 15:19)</a>:</h4>
<p>This is perhaps a bit tricky to read. If you look at the first one, you see that it's a predicate P a b c d that is defined to be false for all a, b, c, d ≤ 2 and unspecified everywhere else. So I went ahead and just defined it to be false everywhere.</p>



<a name="213801931"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213801931" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213801931">(Oct 19 2020 at 15:19)</a>:</h4>
<p>For Q you just have to see for which combinations of the values 0,1,2 for a,b,c,d it is true and then write down a definition that does exactly that</p>



<a name="213851122"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213851122" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213851122">(Oct 19 2020 at 21:52)</a>:</h4>
<p>Thank you :D. I have another question is that I'm testing my formulas with a small case. My code to setup is:</p>
<div class="codehilite"><pre><span></span><code>theory prog_2
  imports Main
begin
(*P*)
definition J :: &quot;nat set&quot; where
&quot;J = {0}&quot;
definition U :: &quot;nat set&quot; where
&quot;U = {0}&quot;
definition T :: &quot;nat set&quot; where
&quot;T = {0}&quot;
definition L :: &quot;nat set&quot; where
&quot;L = {0, 1}&quot;

(*Q*)
definition I :: &quot;nat set&quot; where
&quot;I = {0, 1}&quot;
definition V :: &quot;nat set&quot; where
&quot;V = {0}&quot;
definition K :: &quot;nat set&quot; where
&quot;K = {0}&quot;
definition H :: &quot;nat set&quot; where
&quot;H = {0, 1}&quot;
(*test*)
value &quot;∃l∈L.∃h∈H.(∀j∈J.∀u∈U.(∀t∈T. P j u t l ⟶ (∃i∈I.∃v∈V.∀k∈K. Q i v k h)))&quot;
end
</code></pre></div>


<p>The result is:</p>
<div class="codehilite"><pre><span></span><code>  (P 0 0 0 0 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 0)
∨ (P 0 0 0 0 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 1)
∨ (P 0 0 0 1 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 0)
∨ (P 0 0 0 1 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 1)
</code></pre></div>


<p>But my expected output is:</p>
<div class="codehilite"><pre><span></span><code>  (P 0 0 0 0 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 0)
∨ (P 0 0 0 0 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 1)
∨ (P 0 0 0 0 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 0)
∨ (P 0 0 0 0 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 1)
∨ (P 0 0 0 1 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 0)
∨ (P 0 0 0 1 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 1)
∨ (P 0 0 0 1 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 0)
∨ (P 0 0 0 1 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 1)
</code></pre></div>


<p>I know that because I put <code>∃h∈H</code> out of the first open bracket, so the result has the same value at the <code>h</code> position. I tried to move <code>∃h∈H</code> inside or use another variable like h1 but the result is not what I expected. Do you have any suggestion?</p>



<a name="213890001"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213890001" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213890001">(Oct 20 2020 at 08:46)</a>:</h4>
<p>My solution is that I added the formula for the different <code>h</code> like this</p>
<div class="codehilite"><pre><span></span><code>value &quot;∃l∈L.∃h∈H.(∀j∈J.∀u∈U.(∀t∈T. P j u t l ⟶ (∃i∈I.∃v∈V.∀k∈K.∃h1∈H-{h}. Q i v k h1))
∨ (∀t∈T. P j u t l ⟶ (∃i∈I.∃v∈V.∀k∈K. Q i v k h)))&quot;
</code></pre></div>


<p>It works. It seems not the smart way, though.<br>
UPDATE: It DOESN'T works. It duplicated the result :D</p>



<a name="213890989"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213890989" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mathias Fleury <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213890989">(Oct 20 2020 at 08:56)</a>:</h4>
<p>I think that you are confusing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\forall \exists</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord">∃</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\exists\forall</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span><span class="mord">∀</span></span></span></span>. You version is equivalent to putting the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∃</span></span></span></span> inside the implication symbol:</p>
<div class="codehilite"><pre><span></span><code>lemma &quot;(∃l∈L. (∀j∈J. ∀u∈U. (∀t∈T. (P j u t l ⟶ (∃h∈H. ∃i∈I.∃v∈V.∀k∈K. Q i v k h))))) ⟷
(∃l∈L.∃h∈H.(∀j∈J.∀u∈U.(∀t∈T. P j u t l ⟶ (∃i∈I.∃v∈V.∀k∈K.∃h1∈H-{h}. Q i v k h1))
∨ (∀t∈T. P j u t l ⟶ (∃i∈I.∃v∈V.∀k∈K. Q i v k h))))&quot;
  unfolding L_def I_def J_def V_def H_def T_def K_def
  apply auto
  done
</code></pre></div>



<a name="213894182"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Proof%20methods%20for%20software%20verification/near/213894182" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Trinh Le Khanh <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Proof.20methods.20for.20software.20verification.html#213894182">(Oct 20 2020 at 09:29)</a>:</h4>
<blockquote>
<p>I think that you are confusing \forall \exists∀∃ and \exists\forall∃∀. You version is equivalent to putting the \exists∃ inside the implication symbol</p>
</blockquote>
<p>Thank you. I know that but this is a small piece of my code. I need something like</p>
<div class="codehilite"><pre><span></span><code>((P 0 0 0 0 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 0) ∧ ¬(all the others))
∨ ((P 0 0 0 0 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 1) ∧ ¬(all the others))
∨ ((P 0 0 0 0 ⟶ Q 0 0 0 0 ∨ Q 1 0 0 1) ∧ ¬(all the others))
∨ ((P 0 0 0 0 ⟶ Q 0 0 0 1 ∨ Q 1 0 0 0) ∧ ¬(all the others))
</code></pre></div>


<p>So if I put the \exists inside, it looks like:</p>
<div class="codehilite"><pre><span></span><code>((P 0 0 0 0 ⟶ (Q 0 0 0 0 ∨ Q 1 0 0 0) ∨ Q 0 0 0 1 ∨ Q 1 0 0 1) ∧ ¬(all the others))
</code></pre></div>


<p>The two things are different.</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>