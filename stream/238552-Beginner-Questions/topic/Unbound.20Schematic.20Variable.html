<html>
<head><meta charset="utf-8"><title>Unbound Schematic Variable Â· Beginner Questions Â· Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/index.html">Beginner Questions</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html">Unbound Schematic Variable</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="236357790"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236357790" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ahmed B <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236357790">(Apr 27 2021 at 15:23)</a>:</h4>
<p>I am attempting to prove the strong normalisation of combinatory logic. I have run into an unexpected "Unbound Schematic Variable <code>?thesis</code>" error. The code is below (I have attempted to minimise as far as possible and am using Isabelle 2020). Most likely missing something obvious as I am pretty new to Isabelle. The error occurs in the last <code>sorried</code> proof at both instance of <code>?thesis</code>.</p>
<div class="codehilite"><pre><span></span><code>section â€¹Strong_Normalisationâ€º

theory Strong_Normalisation
  imports Main
  abbrevs &quot;âŸ¶w&quot; = &quot;âŸ¶â‡©w&quot;
      and &quot;â†’p&quot; = &quot;â†’â‡©p&quot;
      and &quot;âŸ¶b&quot; = &quot;âŸ¶â‡©Î²&quot;
begin

(* definition of types for combinatory terms *)

datatype tp = is_At:  TAtt &quot;nat&quot; | TArr &quot;tp&quot; &quot;tp&quot; (infixr &quot;â†’â‡©p&quot; 200)

abbreviation is_Arr :: &quot;tp â‡’ bool&quot; where
  &quot;is_Arr Ï„ â‰¡ Â¬ (is_At Ï„)&quot;

(* head of a combinatory term *)

datatype (plugins del: size) hd =
  is_Var: Var (var: string)(type: tp) (&quot;_:_&quot; [100,100] 100)
| is_S : S (type: tp)  (&quot;S:_&quot; 100)
| is_K : K (type: tp)  (&quot;K:_&quot; 100)
| is_Sym: Sym (sym: string)(type: tp) (&quot;_:_&quot; [100,100] 100)

abbreviation is_Comb :: &quot; hd â‡’ bool&quot; where
  &quot;is_Comb Î¶ â‰¡ (is_S Î¶) âˆ¨  (is_K Î¶)&quot;

subsection â€¹Termsâ€º

consts head0 :: &#39;a

(* combinatory term *)

datatype  tm =
  is_Hd: Hd &quot;hd&quot;
| App (&quot;fun&quot;:  &quot;tm&quot;) (arg: &quot; tm&quot;)
where
  &quot;head (App s _) = head0 s&quot;
| &quot;fun (Hd Î¶) = Hd Î¶&quot;
| &quot;arg (Hd Î¶) = Hd Î¶&quot;

overloading head0 â‰¡ &quot;head0 :: tm â‡’ hd&quot;
begin

primrec head0 :: &quot;tm â‡’ hd&quot; where
  &quot;head0 (Hd Î¶) = Î¶&quot;
| &quot;head0 (App s _) = head0 s&quot;

end

subsection â€¹Definition of types and combinatorsâ€º

fun args :: &quot;tm â‡’ tm list&quot; where
  &quot;args (Hd _) = []&quot;
| &quot;args (App s t) = args s @ [t]&quot;

(* type of head symbol *)
definition type_hd :: &quot;hd â‡’ tp&quot; where
  &quot;type_hd t = type(t)&quot;

(* type of term *)
fun type :: &quot;tm â‡’ tp&quot; where
&quot;type (Hd h) = type_hd h&quot; |
&quot;type (App s t) = (case (type s) of
                    TAtt Ï„ â‡’ TAtt Ï„ |
                    (Î± â†’â‡©p Î³) â‡’ Î³)&quot;

fun size_tp :: &quot;tp â‡’ nat&quot; where
 &quot;size_tp (TAtt Ï„) = 0&quot; |
 &quot;size_tp (Î± â†’â‡©p Î³) = 1 + size_tp Î± + size_tp Î³&quot;

(* inductive predicate that holds if term is well-typed *)
inductive typed :: &quot;tm â‡’ bool&quot; where
&quot;typed (Hd (Var _ _))&quot; |
&quot;typed (Hd (Sym _ _))&quot; |
&quot;typed (Hd (K (Ïƒ â†’â‡©p Î³ â†’â‡©p Ïƒ)))&quot; |
&quot;typed (Hd (S ((Ïƒ â†’â‡©p Ï„ â†’â‡©p Î³) â†’â‡©p (Ïƒ â†’â‡©p Ï„) â†’â‡©p Ïƒ â†’â‡©p Î³)))&quot; |
&quot;typed t1 âŸ¹ (type t1 = (Ïƒ â†’â‡©p Î³)) âŸ¹ typed t2 âŸ¹ (type t1 = Ïƒ) âŸ¹ typed (App t1 t2)&quot;


(* inductive definition of combinatory (weak) reduction *)
inductive
  weak_reduce :: &quot;tm â‡’ tm â‡’ bool&quot; (&quot; _ âŸ¶â‡©w _&quot; [80,80] 80)
where
  w1[intro!]: &quot;t1 âŸ¶â‡©w t2 âŸ¹ App t1 t âŸ¶â‡©w App t2 t&quot;
| w2[intro!]: &quot;t1 âŸ¶â‡©w t2 âŸ¹ App t t1 âŸ¶â‡©w App t t2&quot;
| w4[intro!]: &quot;App (App (Hd (K _)) t1) t2 âŸ¶â‡©w t1&quot;
| w7[intro!]: &quot;App (App (App (Hd (S _)) t1) t2 ) t3 âŸ¶â‡©w App (App t1 t3) (App t2 t3)&quot;

inductive
 weak_star :: &quot;tm â‡’ tm â‡’ nat â‡’ bool&quot;  (&quot; _ âŸ¶â‡©w* _ _&quot; [80,80] 80)
where
 ws1[intro!] : &quot;t âŸ¶â‡©w* t 0&quot;
|ws2[intro!] : &quot;âŸ¦(t âŸ¶â‡©w t&#39;); (t&#39; âŸ¶â‡©w* t&#39;&#39; n)âŸ§ âŸ¹ (t âŸ¶â‡©w* t&#39;&#39; (n+1))&quot;

definition normal_form :: &quot;tm â‡’ bool&quot; where
 &quot;normal_form t1 = (âˆ€ x. Â¬(t1 âŸ¶â‡©w x))&quot;

definition normalizable :: &quot;tm â‡’ bool&quot; where
 &quot;normalizable t1 = (âˆƒ x n. ((t1 âŸ¶â‡©w* x n) âˆ§ (normal_form x)))&quot;

definition bounded_sn :: &quot;nat â‡’ tm â‡’ bool&quot; where
  &quot;bounded_sn n t1 âŸ· (âˆ€m. âˆ€ t. (t1 âŸ¶â‡©w* t m) âŸ¶ m â‰¤ n)&quot;

definition sn :: &quot;tm â‡’ bool&quot; where
 &quot;sn t1 = (âˆƒn. bounded_sn n t1)&quot;

function sc :: &quot;tm â‡’ bool&quot; where
 &quot;sc t1 = (case (type t1) of
            TAtt Ï„ â‡’ sn t1 |
            (Î± â†’â‡©p Î³) â‡’ (âˆ€ t2. (type t2 = Î±) âŸ¶ (sc t2 âŸ¶  sc (App t1 t2) ) ))&quot;
  by auto
  termination
    by (relation &quot;measure (Î»(t). size_tp (type t))&quot;) auto

lemma a3_10 :
  fixes Ï„ :: &quot;tp&quot; and
        t :: &quot;tm&quot;
  assumes &quot;typed t&quot; and
          &quot;type t = Ï„&quot; and
          &quot; Â¬ (is_Comb (head t))&quot;
  shows  &quot;âˆ€s âˆˆ (set (args t)). sn s âŸ¹ sc t&quot; and
         &quot;sc t âŸ¹ sn t&quot;
  using assms
proof(induction &quot;size_tp Ï„&quot;)
  case 0
  then show ?thesis sorry
next
  case (Suc x)
  then show ?thesis sorry
qed
</code></pre></div>



<a name="236358507"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236358507" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236358507">(Apr 27 2021 at 15:27)</a>:</h4>
<p><code>?thesis</code> is the last explicitly stated goal; you can't normally use that in an induction anyway because the induction changes the goal. You should use <code>?case</code> instead.</p>
<p>The reason why <code>?case</code> does not work here either is probably because each of the two cases has two goals. I guess the <code>induction</code>method does not define <code>?case</code> when there is more than one. You can either write down the goals in <code>show</code> explicitly, or you could change your lemma statement so that you use HOL implication and connect the two goals with a HOL conjunction (i.e. <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>âˆ§</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">âˆ§</span></span></span></span>) so that you only have one goal.</p>



<a name="236359497"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236359497" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ahmed B <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236359497">(Apr 27 2021 at 15:31)</a>:</h4>
<p>Thanks for your swift response!</p>



<a name="236362273"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236362273" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mathias Fleury <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236362273">(Apr 27 2021 at 15:48)</a>:</h4>
<p>Other solution:<br>
(I don't understand why the <code>next</code> between the cases are necessaryâ€¦)</p>
<div class="codehilite"><pre><span></span><code>proof(induction &quot;size_tp Ï„&quot;)
  case 0
  case 1
  show ?case
    sorry
next
  case 0
  case 2
  show ?case
    sorry
next
  case (Suc x)
  case 1
  show ?case
    sorry
next
  case (Suc x)
  case 2
  show ?case
    sorry
qed
</code></pre></div>



<a name="236362469"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236362469" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236362469">(Apr 27 2021 at 15:50)</a>:</h4>
<p>What!?! ðŸ¤¯</p>



<a name="236362596"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236362596" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Manuel Eberl <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236362596">(Apr 27 2021 at 15:50)</a>:</h4>
<p>TIL</p>



<a name="236367571"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236367571" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mathias Fleury <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236367571">(Apr 27 2021 at 16:22)</a>:</h4>
<p>The slight problem with this idiom is that I have never seen any documentation on it. So I don't really know if I should search longer or of it accidentally works.</p>



<a name="236367610"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unbound%20Schematic%20Variable/near/236367610" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Mathias Fleury <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unbound.20Schematic.20Variable.html#236367610">(Apr 27 2021 at 16:22)</a>:</h4>
<p>(I think I stumbled by accident on itâ€¦)</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>