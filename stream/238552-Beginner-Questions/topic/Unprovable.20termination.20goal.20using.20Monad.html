<html>
<head><meta charset="utf-8"><title>Unprovable termination goal using Monad · Beginner Questions · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/index.html">Beginner Questions</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unprovable.20termination.20goal.20using.20Monad.html">Unprovable termination goal using Monad</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="350202898"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unprovable%20termination%20goal%20using%20Monad/near/350202898" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jakob Schulz <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unprovable.20termination.20goal.20using.20Monad.html#350202898">(Apr 15 2023 at 18:32)</a>:</h4>
<p>Hi :) I am using the time monad from <code>Root_Balanced_Tree.Time_Monad</code>, and having trouble with proving termination for one function. The following is a minimal example:</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="k">theory</span><span class="w"> </span><span class="n">Scratch</span>
<span class="w">  </span><span class="kp">imports</span><span class="w"> </span><span class="n">Root_Balanced_Tree.Time_Monad</span>
<span class="k">begin</span>

<span class="k">fun</span><span class="w"> </span><span class="n">drop_tm</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">"nat ⇒ 'a list ⇒ 'a list tm"</span><span class="w"> </span><span class="kp">where</span>
<span class="s">"drop_tm n [] =1 return []"</span>
<span class="o">|</span><span class="w"> </span><span class="s">"drop_tm n (x # xs) =1 (case n of 0 ⇒ return (x # xs) | Suc m ⇒</span>
<span class="s">    do {</span>
<span class="s">      r ← drop_tm m xs;</span>
<span class="s">      return r</span>
<span class="s">    })"</span>

<span class="kn">function</span><span class="w"> </span><span class="o">(</span><span class="n">sequential</span><span class="o">)</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">::</span><span class="w"> </span><span class="s">"'a list ⇒ 'a list list tm"</span><span class="w"> </span><span class="kp">where</span>
<span class="s">"test [] = return []"</span>
<span class="o">|</span><span class="w"> </span><span class="s">"test xs = do {</span>
<span class="s">    s ← drop_tm 1 xs;</span>
<span class="s">    r ← (test s);</span>
<span class="s">    return r</span>
<span class="s">  }"</span>
<span class="w">  </span><span class="k">by</span><span class="w"> </span><span class="n">pat_completeness</span><span class="w"> </span><span class="n">auto</span>
<span class="kn">termination</span>
<span class="w">  </span><span class="kp">apply</span><span class="w"> </span><span class="o">(</span><span class="n">relation</span><span class="w"> </span><span class="s">"measure length"</span><span class="o">)</span>
<span class="w">  </span><span class="n">subgoal</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
<span class="w">  </span><span class="n">subgoal</span><span class="w"> </span><span class="kp">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">cases</span><span class="w"> </span><span class="n">xs;</span><span class="w"> </span><span class="n">simp</span><span class="o">)</span>
<span class="w">  </span><span class="k">done</span>

<span class="k">end</span>
</code></pre></div>
<p>The termination proof fails, because the second subgoal generated by <code>apply (relation "measure length")</code> is unsolvable.  If I rewrite the <code>test</code>-function to</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="o">|</span><span class="w"> </span><span class="s">"test xs = do {</span>
<span class="s">    s ← drop_tm 1 xs;</span>
<span class="s">    r ← (test (val (drop_tm 1 xs)));</span>
<span class="s">    return r</span>
<span class="s">  }"</span>
</code></pre></div>
<p>(i.e. just change <code>s</code> to <code>val (drop_tm 1 xs)</code>) then the termination-proof succeeds flawlessly. What's going on here?</p>



<a name="350602064"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner%20Questions/topic/Unprovable%20termination%20goal%20using%20Monad/near/350602064" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jakob Schulz <a href="http://isabelle.systems/zulip-archive/stream/238552-Beginner-Questions/topic/Unprovable.20termination.20goal.20using.20Monad.html#350602064">(Apr 17 2023 at 19:42)</a>:</h4>
<p><span class="user-mention" data-user-id="431446">@Emin Karayel</span> was able to solve this problem :) For future reference: the trick was to prove the following congruence rule:</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="kn">lemma</span><span class="w"> </span><span class="n">bind_tm_cong</span><span class="o">[</span><span class="n">fundef_cong</span><span class="o">]:</span>
<span class="w">  </span><span class="kp">assumes</span><span class="w"> </span><span class="s">"f1 = f2"</span>
<span class="w">  </span><span class="kp">assumes</span><span class="w"> </span><span class="s">"g1 (val f1) = g2 (val f2)"</span>
<span class="w">  </span><span class="kp">shows</span><span class="w"> </span><span class="s">"f1 ⤜ g1 = f2 ⤜ g2"</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">assms</span><span class="w"> </span><span class="k">unfolding</span><span class="w"> </span><span class="n">bind_tm_def</span>
<span class="w">  </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">cases</span><span class="w"> </span><span class="n">f1;cases</span><span class="w"> </span><span class="n">f2</span><span class="o">)</span><span class="w"> </span><span class="n">auto</span>
</code></pre></div>
<p>After declaring this lemma as <code>fundef_cong</code>(see section 10 of <a href="https://isabelle.in.tum.de/doc/functions.pdf">https://isabelle.in.tum.de/doc/functions.pdf</a>), the termination proof succeeds.</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>