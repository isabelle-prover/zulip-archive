<html>
<head><meta charset="utf-8"><title>[isabelle] Exporting proof terms out of Isabelle · Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Exporting.20proof.20terms.20out.20of.20Isabelle.html">[isabelle] Exporting proof terms out of Isabelle</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="316077655"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Exporting%20proof%20terms%20out%20of%20Isabelle/near/316077655" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Exporting.20proof.20terms.20out.20of.20Isabelle.html#316077655">(Dec 15 2022 at 16:03)</a>:</h4>
<p>From: Frédéric Blanqui &lt;<a href="mailto:frederic.blanqui@inria.fr">frederic.blanqui@inria.fr</a>&gt;<br>
Dear all,</p>
<p>I am very pleased to announce that one can now export all the proofs of <br>
the Isabelle/HOL library (that is up to Complex_Main) to the Dedukti and <br>
Lambdapi languages, using the Isabelle component <br>
<a href="https://github.com/Deducteam/isabelle_dedukti">https://github.com/Deducteam/isabelle_dedukti</a>.</p>
<p>This allows cross-checking of Isabelle developments. There are also <br>
ongoing works for translating Dedukti files to other systems like Coq, <br>
Lean, PVS or Agda.</p>
<p>Generating the proof terms takes about 47 minutes to Isabelle on my laptop.<br>
The translation to Dedukti or Lambdapi takes about 26 minutes.<br>
The verification of all the generated Dedukti files (4.5 Go) takes about <br>
3 minutes with kocheck -j 7.</p>
<p>This currently works with Isabelle-2021-1 only. We hope to update it to <br>
Isabelle-2022 in the coming months. Help is very welcome!</p>
<p>This is the result of several contributors: Makarius Wenzel, Michael <br>
Färber, Yann Leray, Akihisa Yamada, Jérémy Dubut, that I want to thank <br>
very much.</p>
<p>Best regards,</p>
<p>Frédéric Blanqui.</p>
<p>Useful links:</p>
<p>Isabelle_Dedukti: <a href="https://github.com/Deducteam/isabelle_dedukti">https://github.com/Deducteam/isabelle_dedukti</a></p>
<p>Dedukti: <a href="https://github.com/Deducteam/dedukti">https://github.com/Deducteam/dedukti</a></p>
<p>Lambdapi: <a href="https://github.com/Deducteam/lambdapi">https://github.com/Deducteam/lambdapi</a></p>
<p>Kocheck: <a href="https://github.com/01mf02/kontroli-rs">https://github.com/01mf02/kontroli-rs</a></p>



<a name="316689011"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Exporting%20proof%20terms%20out%20of%20Isabelle/near/316689011" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Exporting.20proof.20terms.20out.20of.20Isabelle.html#316689011">(Dec 19 2022 at 08:36)</a>:</h4>
<p>From: Nicolas Méric &lt;<a href="mailto:nicolas.meric@lri.fr">nicolas.meric@lri.fr</a>&gt;<br>
Dear Frédéric,</p>
<p>I looked at the code of the exporter, and I do not understand the<br>
initialization of the build options<br>
(<a href="https://github.com/Deducteam/isabelle_dedukti/blob/0f25057f268c13c9c6e6699512370442a71d5ff6/src/exporter.scala#L30">https://github.com/Deducteam/isabelle_dedukti/blob/0f25057f268c13c9c6e6699512370442a71d5ff6/src/exporter.scala#L30</a>).</p>
<p>I thought that setting the record_proofs session option to 2 had the same<br>
meaning as enabling the export_standard_proofs option, but in the code<br>
Makarius chose, for both cases, that is if export_standard_proofs is set or<br>
not, to have the record_proofs option set to 2.</p>
<p>Do you know why he did that?</p>
<p>I quickly looked at the sources of Isabelle, and both export_standard_proofs<br>
and record_proofs=2 seem to set Proofterm.proofs to 2.</p>
<p>Best regards,</p>
<p>Nicolas Méric</p>



<a name="318063693"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Exporting%20proof%20terms%20out%20of%20Isabelle/near/318063693" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Exporting.20proof.20terms.20out.20of.20Isabelle.html#318063693">(Dec 27 2022 at 09:59)</a>:</h4>
<p>From: Dominique Unruh &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
Dear Frédéric,</p>
<p>I have done some proofterm exporting myself (to Lean, work-in-progress), <br>
and I was wondering whether your exporting relates one issue that I <br>
encountered.</p>
<p>In Isabelle (or maybe specifically Isabelle/HOL), definitions are <br>
outside the trusted kernel. When a definition (e.g., *definition "a = <br>
1"*) is encountered, an axiom is simply added (in this case *a::'a::one <br>
= 1*). It is possible to even give several definitions for the same <br>
constant on different types (i.e., we could end up with axioms *a::nat = <br>
1* and <em>a::int = 2</em> at the same time). This is used under the hood in <br>
the type-class mechanism, and can also be accessed directly.</p>
<p>The question is how to handle definitions when exporting proofterms. One <br>
obvious solution is to simply treat definitions like any other axiom, <br>
and simply add them in the exported theory as axioms. However, this <br>
seems to defeat the purpose of external checking of Isabelle proofs <br>
(i.e., when we do not trust the Isabelle implementation). Namely, there <br>
is no guarantee that these axioms will be consistent. (I am aware that <br>
there are proofs that the Isabelle/HOL definitional framework with <br>
typeclasses that these axiomatizations are a conservative extension but <br>
that does not guarantee that the Isabelle implementation does it <br>
correctly, and in my understanding, the point of external checking is <br>
not to trust the existing implementation.)</p>
<p>The second obvious idea would be to replace definitional axioms by <br>
proper definitions. That is, in the target logic, we would have <br>
something that says that <em>a</em> is basically an abbreviation for <em>1</em>. <br>
However, this would need a target logic with overloading or with type <br>
equality checks. (For example, if I translate the example above into a <br>
definition, I would have to write something like *a ('a) := if 'a=nat <br>
then 1::nat else if 'a=int then 2::int else undefined*<em>('a)</em>. (Here I am <br>
writing the type variables as arguments to <em>a</em> and <em>undefined</em> as an <br>
explicit argument <em>('a)</em> for clarity.) If I want to use those <br>
definitions in exported proofs, I will have to use facts like *nat != <br>
int* which are probably unprovable in many logics and might be unsound <br>
in logics that have provable parametricity.</p>
<p>The third idea (which I am using in my approach) is to process the <br>
proofs to get rid of all the overloading first (after all, it's a <br>
conservative extension). For example, in the above example, we end up <br>
with definition <em>a_nat := 1</em> and <em>a_int := 2</em> and then all theorems need <br>
to be rewritten to use one or the other, or, if the theorem is stated at <br>
a larger type, take an all-quantified argument <em>a</em> and be proven for all <br>
<em>a</em>. Doing this in practice isn't straightforward, but it seems to work <br>
(work-in-progress!).</p>
<p>So I wonder how you deal with this difficulty in your formalization. Do <br>
you export definitions as trusted axioms or do you use a different approach?</p>
<p>Best wishes,<br>
Dominique.</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>