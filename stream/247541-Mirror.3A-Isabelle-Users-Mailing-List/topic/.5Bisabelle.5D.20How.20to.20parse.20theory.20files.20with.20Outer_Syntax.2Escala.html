<html>
<head><meta charset="utf-8"><title>[isabelle] How to parse theory files with Outer_Syntax.scala · Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20How.20to.20parse.20theory.20files.20with.20Outer_Syntax.2Escala.html">[isabelle] How to parse theory files with Outer_Syntax.scala</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="496486643"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20How%20to%20parse%20theory%20files%20with%20Outer_Syntax.scala/near/496486643" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lacramioara Astefanoaei <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20How.20to.20parse.20theory.20files.20with.20Outer_Syntax.2Escala.html#496486643">(Jan 29 2025 at 07:41)</a>:</h4>
<p>Hello,</p>
<p>I have a question about parsing theory files. I've searched the chat but i haven't found the answer i was looking for, hence my message. </p>
<p>I need to split theory files into specs and proofs: so definitions go to one file and lemmas with their proofs in another. Makarius pointed me towards <code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some (incomplete) code running on simple theories such as the Fibonacci example presented in the code generation doc.<br>
I would just like to see if the approach is "right": i currently match on <code>span.name</code> and i wonder if i should match instead on <code>span.kind</code>. <br>
I also wonder if i should include keywords such as "::", ":", ".", "(", ")", "[code]" in Outer_Syntax and, if there is a unique way to classify keywords (like mapping ":" to "thy_goal" when creating <code>thy_syntax</code>). </p>
<p>For reference, the code i have is below.</p>
<p>Thank you,</p>
<p>Lacramioara  </p>
<div class="codehilite" data-code-language="Scala"><pre><span></span><code><span class="k">package</span><span class="w"> </span><span class="n">isabelle</span>
<span class="k">object</span><span class="w"> </span><span class="nc">Test_Thy_Parser</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">is_definition</span><span class="p">(</span><span class="n">span</span><span class="p">:</span><span class="w"> </span><span class="nc">Command_Span</span><span class="p">.</span><span class="nc">Span</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">span</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s">"theory"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"imports"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"begin"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"end"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"definition"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"fun"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"datatype"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"::"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">is_proof</span><span class="p">(</span><span class="n">span</span><span class="p">:</span><span class="w"> </span><span class="nc">Command_Span</span><span class="p">.</span><span class="nc">Span</span><span class="p">):</span><span class="w"> </span><span class="nc">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">span</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="s">"theorem"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"lemma"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"qed"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"proof"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"by"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"("</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">")"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">":"</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s">"[code]"</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">true</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="nf">write_spans</span><span class="p">(</span><span class="n">path</span><span class="p">:</span><span class="w"> </span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">spans</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">Command_Span</span><span class="p">.</span><span class="nc">Span</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nc">StringBuilder</span><span class="p">()</span>
<span class="w">    </span><span class="n">spans</span><span class="p">.</span><span class="n">zipWithIndex</span><span class="p">.</span><span class="n">foreach</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">span</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">      </span><span class="n">content</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">span</span><span class="p">.</span><span class="n">content</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">_</span><span class="p">.</span><span class="n">source</span><span class="p">).</span><span class="n">mkString</span><span class="p">(</span><span class="s">" "</span><span class="p">))</span>
<span class="w">      </span><span class="n">spans</span><span class="p">.</span><span class="n">lift</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">).</span><span class="n">foreach</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">nextSpan</span><span class="w"> </span><span class="o">=&gt;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nc">Set</span><span class="p">(</span><span class="s">"::"</span><span class="p">,</span><span class="w"> </span><span class="s">":"</span><span class="p">,</span><span class="w"> </span><span class="s">"("</span><span class="p">,</span><span class="w"> </span><span class="s">")"</span><span class="p">,</span><span class="w"> </span><span class="s">"[code]"</span><span class="p">,</span><span class="w"> </span><span class="s">"by"</span><span class="p">).</span><span class="n">contains</span><span class="p">(</span><span class="n">nextSpan</span><span class="p">.</span><span class="n">name</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">content</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"\n\n"</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nextSpan</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"[code]"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">content</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">" "</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nextSpan</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"by"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">content</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"\n "</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nc">File</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">content</span><span class="p">.</span><span class="n">toString</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="nc">String</span><span class="p">]):</span><span class="w"> </span><span class="nc">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">println</span><span class="p">(</span><span class="s">"Usage: isabelle scala -e 'split_isa_spec_proofs.scala' &lt;theory_file.thy&gt;"</span><span class="p">)</span>
<span class="w">      </span><span class="n">sys</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">thy_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Path</span><span class="p">.</span><span class="n">explode</span><span class="p">(</span><span class="n">args</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">thy_file</span><span class="p">.</span><span class="n">is_file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">println</span><span class="p">(</span><span class="s">s"Error: File not found - </span><span class="si">${</span><span class="n">thy_file</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="w">      </span><span class="n">sys</span><span class="p">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Setup syntax with common theory keywords</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">thy_syntax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Outer_Syntax</span><span class="p">.</span><span class="n">empty</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"::"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_defn"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"theory"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_begin"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"imports"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_decl"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"begin"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_begin"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"fun"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_defn"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"datatype"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_defn"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"definition"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_defn"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">":"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_goal"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"("</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_goal"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">")"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_goal"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"lemma"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_goal"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"[code]"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_goal"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"theorem"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_goal"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"proof"</span><span class="p">,</span><span class="w"> </span><span class="s">"proof"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"by"</span><span class="p">,</span><span class="w"> </span><span class="s">"proof"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"qed"</span><span class="p">,</span><span class="w"> </span><span class="s">"proof"</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="w">      </span><span class="p">(</span><span class="s">"end"</span><span class="p">,</span><span class="w"> </span><span class="s">"thy_end"</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Read and parse theory content</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">theory_content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">File</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">thy_file</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">spans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thy_syntax</span><span class="p">.</span><span class="n">parse_spans</span><span class="p">(</span><span class="n">theory_content</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Separate definitions and proofs</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">definitions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spans</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">is_definition</span><span class="p">)</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">proofs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spans</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">is_proof</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Generate output files</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">base_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thy_file</span><span class="p">.</span><span class="n">expand</span><span class="p">.</span><span class="n">implode</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">def_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Path</span><span class="p">.</span><span class="n">explode</span><span class="p">(</span><span class="n">base_path</span><span class="p">.</span><span class="n">replaceAll</span><span class="p">(</span><span class="s">"\\.thy$"</span><span class="p">,</span><span class="w"> </span><span class="s">"_definitions.thy"</span><span class="p">))</span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">proof_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Path</span><span class="p">.</span><span class="n">explode</span><span class="p">(</span><span class="n">base_path</span><span class="p">.</span><span class="n">replaceAll</span><span class="p">(</span><span class="s">"\\.thy$"</span><span class="p">,</span><span class="w"> </span><span class="s">"_proofs.thy"</span><span class="p">))</span>
<span class="w">    </span><span class="n">write_spans</span><span class="p">(</span><span class="n">def_path</span><span class="p">,</span><span class="w"> </span><span class="n">definitions</span><span class="p">)</span>
<span class="w">    </span><span class="n">write_spans</span><span class="p">(</span><span class="n">proof_path</span><span class="p">,</span><span class="w"> </span><span class="n">proofs</span><span class="p">)</span>
<span class="p">}}</span>
</code></pre></div>



<a name="496994181"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20How%20to%20parse%20theory%20files%20with%20Outer_Syntax.scala/near/496994181" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20How.20to.20parse.20theory.20files.20with.20Outer_Syntax.2Escala.html#496994181">(Jan 31 2025 at 12:15)</a>:</h4>
<p>From: lacramioara &lt;<a href="mailto:lacramioara.astefanoaei@gmail.com">lacramioara.astefanoaei@gmail.com</a>&gt;<br>
Hello,</p>
<p>I have posted the above on the zulip chat but i'm reposting here in case<br>
someone in this audience has advice.</p>
<p>My question is about parsing theory files. I've searched the zulip chat but i<br>
haven't found the answer i was looking for, hence my message.</p>
<p>I need to split theory files into specs and proofs: definitions go to one file<br>
and lemmas with their proofs in another. Makarius pointed me towards<br>
<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some (incomplete)<br>
code running on simple theories such as the Fibonacci example presented in the<br>
code generation doc.</p>
<p>What is not clear to me is if there is a "right" way to construct the mapping<br>
for the keywords to be added to Outer_Syntax.empty: apparently, i do not need<br>
to include "imports" so i was wondering if there is a way to get rid of<br>
enumerating all the tokens that might appear in theory files. I would also<br>
like to see if my understanding is correct in that i can choose the mapping as<br>
it best suits my needs. For instance, i classify "lemma" as having kind<br>
"PRF_GOAL" just as a way to make it appear in <code>Keyword.proof</code>. Would this be<br>
something not inline with the underlying philosophy of Isabelle/Scala?</p>
<p>For reference, the code i have is below.</p>
<p>Thank you,<br>
Lacramioara </p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="n">package</span><span class="w"> </span><span class="n">isabelle</span>

<span class="n">object</span><span class="w"> </span><span class="n">Test_Thy_Parser</span><span class="w"> </span><span class="ow">{</span>

<span class="w">  </span><span class="n">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="n">is_definition</span><span class="o">(</span><span class="n">span</span><span class="o">:</span><span class="w"> </span><span class="n">Command_Span.Span</span><span class="o">,</span><span class="w"> </span><span class="kp">keywords</span><span class="o">:</span>
<span class="n">Keyword.Keywords</span><span class="o">):</span><span class="w"> </span><span class="n">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">{</span>
<span class="w">    </span><span class="kp">keywords</span><span class="ow">.</span><span class="n">kinds.get</span><span class="o">(</span><span class="n">span.name</span><span class="o">)</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="ow">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="n">Some</span><span class="o">(</span><span class="n">kind</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">Keyword.theory_defn.contains</span><span class="o">(</span><span class="n">kind</span><span class="o">)</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="n">None</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">false</span>
<span class="w">    </span><span class="ow">}</span>
<span class="w">  </span><span class="ow">}</span>

<span class="w">  </span><span class="n">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="n">is_proof</span><span class="o">(</span><span class="n">span</span><span class="o">:</span><span class="w"> </span><span class="n">Command_Span.Span</span><span class="o">,</span><span class="w"> </span><span class="kp">keywords</span><span class="o">:</span><span class="w"> </span><span class="n">Keyword.Keywords</span><span class="o">):</span>
<span class="n">Boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">{</span>
<span class="w">    </span><span class="kp">keywords</span><span class="ow">.</span><span class="n">kinds.get</span><span class="o">(</span><span class="n">span.name</span><span class="o">)</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="ow">{</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="n">Some</span><span class="o">(</span><span class="n">kind</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">Keyword.proof.contains</span><span class="o">(</span><span class="n">kind</span><span class="o">)</span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="n">None</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">false</span>
<span class="w">    </span><span class="ow">}</span>
<span class="w">  </span><span class="ow">}</span>

<span class="w">  </span><span class="n">private</span><span class="w"> </span><span class="k">def</span><span class="w"> </span><span class="n">write_spans</span><span class="o">(</span><span class="n">path</span><span class="o">:</span><span class="w"> </span><span class="n">Path</span><span class="o">,</span><span class="w"> </span><span class="n">spans</span><span class="o">:</span><span class="w"> </span><span class="n">List</span><span class="o">[</span><span class="n">Command_Span.Span</span><span class="o">]):</span><span class="w"> </span><span class="n">Unit</span><span class="w"> </span><span class="o">=</span>
<span class="ow">{</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">StringBuilder</span><span class="o">()</span>
<span class="w">    </span><span class="n">spans.zipWithIndex.foreach</span><span class="w"> </span><span class="ow">{</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="o">(</span><span class="n">span</span><span class="o">,</span><span class="w"> </span><span class="n">index</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span>
<span class="w">      </span><span class="n">content.append</span><span class="o">(</span><span class="n">span.content.map</span><span class="o">(_</span><span class="ow">.</span><span class="n">source</span><span class="o">)</span><span class="ow">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span>
<span class="w">      </span><span class="n">spans.lift</span><span class="o">(</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="o">)</span><span class="ow">.</span><span class="n">foreach</span><span class="w"> </span><span class="ow">{</span><span class="w"> </span><span class="n">nextSpan</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span>
<span class="w">        </span><span class="kp">if</span><span class="w"> </span><span class="o">(!</span><span class="n">Set</span><span class="o">(</span><span class="s">"("</span><span class="o">,</span><span class="w"> </span><span class="s">")"</span><span class="o">,</span><span class="w"> </span><span class="s">"[code]"</span><span class="o">,</span><span class="w"> </span><span class="s">"by"</span><span class="o">)</span><span class="ow">.</span><span class="n">contains</span><span class="o">(</span><span class="n">nextSpan.name</span><span class="o">))</span><span class="w"> </span><span class="ow">{</span>
<span class="w">          </span><span class="n">content.append</span><span class="o">(</span><span class="s">"\n\n"</span><span class="o">)</span>
<span class="w">        </span><span class="ow">}</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="kp">if</span><span class="w"> </span><span class="o">(</span><span class="n">nextSpan.name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"[code]"</span><span class="o">)</span><span class="w"> </span><span class="ow">{</span>
<span class="w">          </span><span class="n">content.append</span><span class="o">(</span><span class="s">" "</span><span class="o">)</span>
<span class="w">        </span><span class="ow">}</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="kp">if</span><span class="w"> </span><span class="o">(</span><span class="n">nextSpan.name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">"by"</span><span class="o">)</span><span class="w"> </span><span class="ow">{</span>
<span class="w">          </span><span class="n">content.append</span><span class="o">(</span><span class="s">"\n "</span><span class="o">)</span>
<span class="w">        </span><span class="ow">}</span>
<span class="w">      </span><span class="ow">}</span>
<span class="w">    </span><span class="ow">}</span>
<span class="w">    </span><span class="n">File.write</span><span class="o">(</span><span class="n">path</span><span class="o">,</span><span class="w"> </span><span class="n">content.toString</span><span class="o">)</span>
<span class="w">  </span><span class="ow">}</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="n">Array</span><span class="o">[</span><span class="n">String</span><span class="o">]):</span><span class="w"> </span><span class="n">Unit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">{</span>
<span class="w">    </span><span class="kp">if</span><span class="w"> </span><span class="o">(</span><span class="n">args.length</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">1</span><span class="o">)</span><span class="w"> </span><span class="ow">{</span>
<span class="w">      </span><span class="n">println</span><span class="o">(</span><span class="s">"Usage: isabelle scala -e 'split_isa_spec_proofs.scala'</span>
<span class="s">&lt;theory_file.thy&gt;"</span><span class="o">)</span>
<span class="w">      </span><span class="n">sys.exit</span><span class="o">(</span><span class="n">1</span><span class="o">)</span>
<span class="w">    </span><span class="ow">}</span>

<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">thy_file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Path.explode</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">0</span><span class="o">))</span>
<span class="w">    </span><span class="kp">if</span><span class="w"> </span><span class="o">(!</span><span class="n">thy_file.is_file</span><span class="o">)</span><span class="w"> </span><span class="ow">{</span>
<span class="w">      </span><span class="n">println</span><span class="o">(</span><span class="n">s"Error</span><span class="o">:</span><span class="w"> </span><span class="n">File</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">$</span><span class="ow">{</span><span class="n">thy_file</span><span class="ow">}</span><span class="s">")</span>
<span class="s">      sys.exit(1)</span>
<span class="s">    }</span>

<span class="s">    type Keywords = List[(String, Keyword.Spec)]</span>

<span class="s">    val thy_keywords : Keywords = List(("</span><span class="n">%"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"("</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">")"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">","</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"::"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">":"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"."</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"="</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"and"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">()),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"begin"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.QUASI_COMMAND</span><span class="o">)),</span>
<span class="w">      </span><span class="n">//</span><span class="o">(</span><span class="s">"imports"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.QUASI_COMMAND</span><span class="o">)),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"text"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.DOCUMENT_BODY</span><span class="o">)),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"fun"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.THY_DEFN</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="o">(</span><span class="s">"fun"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"datatype"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.THY_DEFN</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span>
<span class="n">List</span><span class="o">(</span><span class="s">"datatype"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"definition"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.THY_DEFN</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span>
<span class="n">List</span><span class="o">(</span><span class="s">"definition"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"theory"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.THY_DEFN</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span>
<span class="n">List</span><span class="o">(</span><span class="s">"theory"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"proof"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.PRF_GOAL</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="o">(</span><span class="s">"proof"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"lemma"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.PRF_GOAL</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="o">(</span><span class="s">"lemma"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"qed"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.QED</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="o">(</span><span class="s">"qed"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"by"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.PRF_ASM_GOAL</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="o">(</span><span class="s">"by"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"next"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.NEXT_BLOCK</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="o">(</span><span class="s">"next"</span><span class="o">))),</span>
<span class="w">      </span><span class="o">(</span><span class="s">"end"</span><span class="o">,</span><span class="w"> </span><span class="n">Keyword.Spec</span><span class="o">(</span><span class="n">kind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Keyword.THY_DEFN</span><span class="o">,</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="o">(</span><span class="s">"end"</span><span class="o">)))</span>
<span class="w">      </span><span class="o">)</span>

<span class="w">    </span><span class="n">//</span><span class="w"> </span><span class="n">Setup</span><span class="w"> </span><span class="k">syntax</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">common</span><span class="w"> </span><span class="k">theory</span><span class="w"> </span><span class="kp">keywords</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">thy_syntax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Outer_Syntax.empty.add_keywords</span><span class="o">(</span><span class="n">thy_keywords</span><span class="o">)</span>

<span class="w">    </span><span class="n">//</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="kp">and</span><span class="w"> </span><span class="n">parse</span><span class="w"> </span><span class="k">theory</span><span class="w"> </span><span class="n">content</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">theory_content</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">File.read</span><span class="o">(</span><span class="n">thy_file</span><span class="o">)</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">spans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thy_syntax.parse_spans</span><span class="o">(</span><span class="n">theory_content</span><span class="o">)</span>


<span class="w">    </span><span class="n">print</span><span class="o">(</span><span class="n">thy_syntax.keywords</span><span class="o">)</span>
<span class="w">    </span><span class="n">//</span><span class="w"> </span><span class="n">Separate</span><span class="w"> </span><span class="n">definitions</span><span class="w"> </span><span class="kp">and</span><span class="w"> </span><span class="n">proofs</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">definitions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spans.filter</span><span class="o">(</span><span class="n">span</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">is_definition</span><span class="o">(</span><span class="n">span</span><span class="o">,</span>
<span class="n">thy_syntax.keywords</span><span class="o">))</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">proofs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spans.filter</span><span class="o">(</span><span class="n">span</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">is_proof</span><span class="o">(</span><span class="n">span</span><span class="o">,</span><span class="w"> </span><span class="n">thy_syntax.keywords</span><span class="o">))</span>

<span class="w">    </span><span class="n">//</span><span class="w"> </span><span class="n">Generate</span><span class="w"> </span><span class="kp">output</span><span class="w"> </span><span class="n">files</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">base_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thy_file.expand.implode</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">def_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Path.explode</span><span class="o">(</span><span class="n">base_path.replaceAll</span><span class="o">(</span><span class="s">"\\.thy$"</span><span class="o">,</span>
<span class="s">"_definitions.thy"</span><span class="o">))</span>
<span class="w">    </span><span class="n">val</span><span class="w"> </span><span class="n">proof_path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Path.explode</span><span class="o">(</span><span class="n">base_path.replaceAll</span><span class="o">(</span><span class="s">"\\.thy$"</span><span class="o">,</span>
<span class="s">"_proofs.thy"</span><span class="o">))</span>

<span class="w">    </span><span class="n">write_spans</span><span class="o">(</span><span class="n">def_path</span><span class="o">,</span><span class="w"> </span><span class="n">definitions</span><span class="o">)</span>
<span class="w">    </span><span class="n">write_spans</span><span class="o">(</span><span class="n">proof_path</span><span class="o">,</span><span class="w"> </span><span class="n">proofs</span><span class="o">)</span>

<span class="w">    </span><span class="n">//</span><span class="w"> </span><span class="n">Report</span><span class="w"> </span><span class="n">results</span>
<span class="w">    </span><span class="n">println</span><span class="o">(</span><span class="n">s"\nProcessed</span><span class="w"> </span><span class="k">theory</span><span class="w"> </span><span class="kp">file</span><span class="o">:</span><span class="w"> </span><span class="n">$</span><span class="ow">{</span><span class="n">thy_file</span><span class="ow">}</span><span class="s">")</span>
<span class="s">    println("</span><span class="n">Generated</span><span class="w"> </span><span class="n">files</span><span class="o">:</span><span class="s">")</span>
<span class="s">    println(s"</span><span class="w">  </span><span class="n">Definitions</span><span class="o">:</span><span class="w"> </span><span class="n">$</span><span class="ow">{</span><span class="n">def_path</span><span class="ow">}</span><span class="s">")</span>
<span class="s">    println(s"</span><span class="w">  </span><span class="n">Proofs</span><span class="o">:</span><span class="w"> </span><span class="n">$</span><span class="ow">{</span><span class="n">proof_path</span><span class="ow">}</span><span class="s">")</span>
<span class="s">    println(s"</span><span class="n">\nFound</span><span class="w"> </span><span class="n">$</span><span class="ow">{</span><span class="n">definitions.length</span><span class="ow">}</span><span class="w"> </span><span class="n">definitions</span><span class="w"> </span><span class="kp">and</span><span class="w"> </span><span class="n">$</span><span class="ow">{</span><span class="n">proofs.length</span><span class="ow">}</span>
<span class="n">proofs"</span><span class="o">)</span>
<span class="w">  </span><span class="ow">}</span>
<span class="ow">}</span>
</code></pre></div>



<a name="497013915"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20How%20to%20parse%20theory%20files%20with%20Outer_Syntax.scala/near/497013915" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20How.20to.20parse.20theory.20files.20with.20Outer_Syntax.2Escala.html#497013915">(Jan 31 2025 at 14:03)</a>:</h4>
<p>From: Fabian Huch &lt;<a href="mailto:huch@in.tum.de">huch@in.tum.de</a>&gt;</p>
<p>On 1/31/25 13:14, lacramioara wrote:</p>
<blockquote>
<p>I need to split theory files into specs and proofs: definitions go to one file<br>
and lemmas with their proofs in another. Makarius pointed me towards<br>
<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some (incomplete)<br>
code running on simple theories such as the Fibonacci example presented in the<br>
code generation doc.</p>
<p>What is not clear to me is if there is a "right" way to construct the mapping<br>
for the keywords to be added to Outer_Syntax.empty: apparently, i do not need<br>
to include "imports" so i was wondering if there is a way to get rid of<br>
enumerating all the tokens that might appear in theory files.</p>
</blockquote>
<p>Keywords and their kinds are specified by the theories themselves (the <br>
'keywords' specification in the beginning, cf. <br>
<a href="https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords">https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords</a>); to parse <br>
a theory file, you have to read all theory headers (in the imports <br>
graph) first and collect the outer syntax.</p>
<blockquote>
<p>I would also<br>
like to see if my understanding is correct in that i can choose the mapping as<br>
it best suits my needs. For instance, i classify "lemma" as having kind<br>
"PRF_GOAL" just as a way to make it appear in <code>Keyword.proof</code>. Would this be<br>
something not inline with the underlying philosophy of Isabelle/Scala?</p>
</blockquote>
<p>This would be like interpreting verbs as nouns as you are reading a <br>
text. I doubt that this is what you want to achieve, but you could do it.</p>
<p>Fabian</p>



<a name="497147351"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20How%20to%20parse%20theory%20files%20with%20Outer_Syntax.scala/near/497147351" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20How.20to.20parse.20theory.20files.20with.20Outer_Syntax.2Escala.html#497147351">(Feb 01 2025 at 09:15)</a>:</h4>
<p>From: Lacramioara Astefanoaei &lt;<a href="mailto:lacramioara.astefanoaei@gmail.com">lacramioara.astefanoaei@gmail.com</a>&gt;<br>
On Fri, 31 Jan 2025 at 15:03, Fabian Huch &lt;<a href="mailto:huch@in.tum.de">huch@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>On 1/31/25 13:14, lacramioara wrote:</p>
<blockquote>
<p>I need to split theory files into specs and proofs: definitions go to<br>
one file<br>
and lemmas with their proofs in another. Makarius pointed me towards<br>
<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some<br>
(incomplete)<br>
code running on simple theories such as the Fibonacci example presented<br>
in the<br>
code generation doc.</p>
<p>What is not clear to me is if there is a "right" way to construct the<br>
mapping<br>
for the keywords to be added to Outer_Syntax.empty: apparently, i do not<br>
need<br>
to include "imports" so i was wondering if there is a way to get rid of<br>
enumerating all the tokens that might appear in theory files.</p>
</blockquote>
<p>Keywords and their kinds are specified by the theories themselves (the<br>
'keywords' specification in the beginning, cf.<br>
<a href="https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords">https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords</a>); to parse<br>
a theory file, you have to read all theory headers (in the imports<br>
graph) first and collect the outer syntax.</p>
</blockquote>
<p>Thank you for the pointer. I read there</p>
<blockquote>
<p>*Both minor keywords and major keywords of the Isar command language need<br>
to be specified, in order to make parsing of proof documents work properly.<br>
*</p>
<p>which answers my question that there is no shortcut. (I still wonder why<br>
the parsing works in my case without me having to explicitly add the<br>
"imports" keyword.)</p>
</blockquote>
<blockquote>
<blockquote>
<p>I would also<br>
like to see if my understanding is correct in that i can choose the<br>
mapping as<br>
it best suits my needs. For instance, i classify "lemma" as having kind<br>
"PRF_GOAL" just as a way to make it appear in <code>Keyword.proof</code>. Would<br>
this be<br>
something not inline with the underlying philosophy of Isabelle/Scala?</p>
</blockquote>
<p>This would be like interpreting verbs as nouns as you are reading a<br>
text. I doubt that this is what you want to achieve, but you could do it.<br>
</p>
</blockquote>
<p>For the moment, the code i have achieves what i want in that it separates<br>
definitions from lemmas and their proofs. I understand from your comparison<br>
that "lemma" shouldn't have kind "PRF_GOAL". What was somewhat implicit in<br>
my question was: where could one find the "right" kinds for keywords, as i<br>
did not find this information in the docs, while in the code the only<br>
relevant piece i found was <code>src/Pure/Thy/thy_header.scala</code>. I see now that<br>
i can find examples of associatiations (keyword, kind) in what is generated<br>
by <code>isabelle dump</code>. For instance, i see in the markup file for a toy<br>
theory: <code>accepted command_span name=lemma kind=thy_goal_stmt</code>.</p>
<p>If i do a <code>pdfgrep -r "thy_goal_stmt" doc/</code> i find no results, so i<br>
conclude that to get this information about the "right" mapping i just have<br>
to extract it from the output of dump.</p>
<p>Thank you for taking the time to respond,<br>
Lacramioara</p>
<blockquote>
<p>Fabian</p>
</blockquote>



<a name="497437532"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20How%20to%20parse%20theory%20files%20with%20Outer_Syntax.scala/near/497437532" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20How.20to.20parse.20theory.20files.20with.20Outer_Syntax.2Escala.html#497437532">(Feb 03 2025 at 13:38)</a>:</h4>
<p>From: Lacramioara Astefanoaei &lt;<a href="mailto:lacramioara.astefanoaei@gmail.com">lacramioara.astefanoaei@gmail.com</a>&gt;<br>
On Mon, 3 Feb 2025 at 10:31, Fabian Huch &lt;<a href="mailto:huch@in.tum.de">huch@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>On 2/1/25 10:15, Lacramioara Astefanoaei wrote:</p>
<p>On Fri, 31 Jan 2025 at 15:03, Fabian Huch &lt;<a href="mailto:huch@in.tum.de">huch@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>On 1/31/25 13:14, lacramioara wrote:</p>
<blockquote>
<p>I need to split theory files into specs and proofs: definitions go to<br>
one file<br>
and lemmas with their proofs in another. Makarius pointed me towards<br>
<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some<br>
(incomplete)<br>
code running on simple theories such as the Fibonacci example presented<br>
in the<br>
code generation doc.</p>
<p>What is not clear to me is if there is a "right" way to construct the<br>
mapping<br>
for the keywords to be added to Outer_Syntax.empty: apparently, i do<br>
not need<br>
to include "imports" so i was wondering if there is a way to get rid of<br>
enumerating all the tokens that might appear in theory files.</p>
</blockquote>
<p>Keywords and their kinds are specified by the theories themselves (the<br>
'keywords' specification in the beginning, cf.<br>
<a href="https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords">https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords</a>); to parse<br>
a theory file, you have to read all theory headers (in the imports<br>
graph) first and collect the outer syntax.</p>
</blockquote>
<p>Thank you for the pointer. I read there</p>
<blockquote>
<p>*Both minor keywords and major keywords of the Isar command language need<br>
to be specified, in order to make parsing of proof documents work properly.<br>
*</p>
<p>which answers my question that there is no shortcut. (I still wonder why<br>
the parsing works in my case without me having to explicitly add the<br>
"imports" keyword.)</p>
</blockquote>
<p>The imports keyword is part of Pure and not part of the user-space, so it<br>
is always part of the outer syntax.<br>
</p>
</blockquote>
<p>I see, thank you!</p>
<blockquote>
<blockquote>
<blockquote>
<p>I would also<br>
like to see if my understanding is correct in that i can choose the<br>
mapping as<br>
it best suits my needs. For instance, i classify "lemma" as having kind<br>
"PRF_GOAL" just as a way to make it appear in <code>Keyword.proof</code>. Would<br>
this be<br>
something not inline with the underlying philosophy of Isabelle/Scala?</p>
</blockquote>
<p>This would be like interpreting verbs as nouns as you are reading a<br>
text. I doubt that this is what you want to achieve, but you could do it.<br>
</p>
</blockquote>
<p>For the moment, the code i have achieves what i want in that it separates<br>
definitions from lemmas and their proofs. I understand from your comparison<br>
that "lemma" shouldn't have kind "PRF_GOAL". What was somewhat implicit in<br>
my question was: where could one find the "right" kinds for keywords, as i<br>
did not find this information in the docs, while in the code the only<br>
relevant piece i found was <code>src/Pure/Thy/thy_header.scala</code>. I see now that<br>
i can find examples of associatiations (keyword, kind) in what is generated<br>
by <code>isabelle dump</code>. For instance, i see in the markup file for a toy<br>
theory: <code>accepted command_span name=lemma kind=thy_goal_stmt</code>.</p>
<p>If i do a <code>pdfgrep -r "thy_goal_stmt" doc/</code> i find no results, so i<br>
conclude that to get this information about the "right" mapping i just have<br>
to extract it from the output of dump.</p>
<p>I am not sure if keyword kinds are explicitly documented anywhere;<br>
however, I find the categories in Pure/Isar/keyword.scala very helpful to<br>
understand them.</p>
<p>You are right. (I was reusing the functionalities from <code>Keyword.scala</code> in<br>
my code, following the suggestions from Makarius.)<br>
What i was missing was the mappings (span_name, span_kind) which, in the<br>
end, i extracted from the YXML files generated by <code>isabelle dump</code>. These<br>
mappings do exist, i've just found them in <code>src/Pure/Pure.thy</code> (previously,<br>
i overlooked them as i was searching in scala files.). It would be amazing<br>
if i could figure out how <code>Pure.thy</code> is used so that the mappings appear in<br>
YXML files.</p>
</blockquote>
<blockquote>
<p>Also note Tools/Find_Facts/src/thy_blocks.scala, which uses the keyword<br>
kinds to parse the block structure of a theory.</p>
<p>Thank you, yes, the code i have is a bit more verbose but basically works<br>
like your <code>span.is_of_kind(Keyword.&lt;x&gt;)</code>.</p>
</blockquote>
<blockquote>
<p>Fabian<br>
</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>