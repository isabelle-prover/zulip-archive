<html>
<head><meta charset="utf-8"><title>[isabelle] Proved False using normalization by evaluation · Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html">[isabelle] Proved False using normalization by evaluation</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="500932137"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/500932137" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#500932137">(Feb 20 2025 at 17:18)</a>:</h4>
<p>From: Kevin Kappelmann &lt;<a href="mailto:kevin.kappelmann@tum.de">kevin.kappelmann@tum.de</a>&gt;<br>
Dear list,</p>
<p>I just proved False using the normalization method in Isabelle/HOL, see <br>
below. It seems like TYPE(T) arguments are generalized(?) to TYPE(?'a) <br>
arguments when running the method (even when dropping the code equation <br>
for the constant to be normalized).</p>
<p>Is this a known problem and is there anything I can do to stop the <br>
normalizer from tinkering with TYPE(T) arguments?</p>
<p>Background: I used normalization by evaluation to work on a large data <br>
structure in an Isabelle/HOL proof for which the performance of the <br>
simplifier is insufficient.</p>
<p>Best wishes,</p>
<p>Kevin</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="k">theory</span><span class="w"> </span><span class="n">Scratch</span>
<span class="w">   </span><span class="kp">imports</span>
<span class="w">     </span><span class="n">Main</span>
<span class="k">begin</span>

<span class="k">definition</span><span class="w"> </span><span class="o">[</span><span class="n">code</span><span class="w"> </span><span class="n">del</span><span class="o">]:</span><span class="w"> </span><span class="s">"test ≡ card (UNIV :: 'a set) = 1"</span>

<span class="c">(*TYPE(unit) changes to TYPE('a) even though [code del] is used for test*)</span>
<span class="kt">value</span><span class="w"> </span><span class="o">[</span><span class="n">nbe</span><span class="o">]</span><span class="w"> </span><span class="s">"test TYPE(unit)"</span>

<span class="kn">lemma</span><span class="w"> </span><span class="n">oh_oh</span><span class="o">:</span><span class="w"> </span><span class="s">"test TYPE(unit) = test TYPE(bool)"</span>
<span class="w">   </span><span class="kp">apply</span><span class="w"> </span><span class="n">normalization</span>
<span class="w">   </span><span class="k">done</span>

<span class="kn">theorem</span><span class="w"> </span><span class="s">"False"</span>
<span class="k">proof</span><span class="w"> </span><span class="o">-</span>
<span class="w">   </span><span class="k">have</span><span class="w"> </span><span class="s">"test TYPE(unit) = True"</span><span class="w"> </span><span class="k">unfolding</span><span class="w"> </span><span class="n">test_def</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
<span class="w">   </span><span class="k">moreover</span><span class="w"> </span><span class="k">have</span><span class="w"> </span><span class="s">"test TYPE(unit) = False"</span><span class="w"> </span><span class="k">unfolding</span><span class="w"> </span><span class="n">oh_oh</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="o">(</span><span class="n">simp</span><span class="w"> </span><span class="n">add</span><span class="o">:</span>
<span class="n">test_def</span><span class="o">)</span>
<span class="w">   </span><span class="k">ultimately</span><span class="w"> </span><span class="k">show</span><span class="w"> </span><span class="n">False</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">simp</span>
<span class="k">qed</span>


<span class="k">end</span>
</code></pre></div>



<a name="500937079"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/500937079" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#500937079">(Feb 20 2025 at 17:45)</a>:</h4>
<p>From: Stepan Holub &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
Oops. Here is a direct illustration that "normalization" is contradictory:</p>
<p>lemma "card (UNIV :: 'a set) = card (UNIV :: 'b set)"<br>
   apply normalization ..</p>
<p>Stepan</p>
<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>
<blockquote>
<p>Dear list,</p>
<p>I just proved False using the normalization method in Isabelle/HOL, <br>
see below. It seems like TYPE(T) arguments are generalized(?) to <br>
TYPE(?'a) arguments when running the method (even when dropping the <br>
code equation for the constant to be normalized).</p>
<p>Is this a known problem and is there anything I can do to stop the <br>
normalizer from tinkering with TYPE(T) arguments?</p>
<p>Background: I used normalization by evaluation to work on a large data <br>
structure in an Isabelle/HOL proof for which the performance of the <br>
simplifier is insufficient.</p>
<p>Best wishes,</p>
<p>Kevin</p>
<p>```isabelle</p>
<p>theory Scratch<br>
  imports<br>
    Main<br>
begin</p>
<p>definition [code del]: "test ≡ card (UNIV :: 'a set) = 1"</p>
<p>(*TYPE(unit) changes to TYPE('a) even though [code del] is used for <br>
test*)<br>
value [nbe] "test TYPE(unit)"</p>
<p>lemma oh_oh: "test TYPE(unit) = test TYPE(bool)"<br>
  apply normalization<br>
  done</p>
<p>theorem "False"<br>
proof -<br>
  have "test TYPE(unit) = True" unfolding test_def by simp<br>
  moreover have "test TYPE(unit) = False" unfolding oh_oh by (simp <br>
add: test_def)<br>
  ultimately show False by simp<br>
qed</p>
<p>end</p>
<p>```</p>
</blockquote>



<a name="500940049"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/500940049" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#500940049">(Feb 20 2025 at 18:01)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:manuel@pruvisto.org">manuel@pruvisto.org</a>&gt;<br>
Just for the benefit of readers on this mailing list who are not <br>
familiar with the NBE method: this is <em>not</em> a proof method that goes <br>
through the Isabelle kernel. It is an oracle, and one with a significant <br>
trusted code base. Moreover, I think it is used much less than the code <br>
generator oracle (the "eval" method), so issues like this one can remain <br>
unnoticed for a long time.</p>
<p>So, although I do not think it was previously known that you could prove <br>
"False" with NBE, it is not very surprising either. And it does <em>not</em> <br>
mean that Isabelle as a system is broken.</p>
<p>Unfortunately, I don't know enough about the internals of NBE to really <br>
comment on this issue otherwise. I just wanted to make sure this was <br>
stated somewhere clearly on the mailing list.</p>
<p>Cheers,</p>
<p>Manuel</p>
<p>On 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing List) <br>
wrote:</p>
<blockquote>
<p>Oops. Here is a direct illustration that "normalization" is <br>
contradictory:</p>
<p>lemma "card (UNIV :: 'a set) = card (UNIV :: 'b set)"<br>
  apply normalization ..</p>
<p>Stepan</p>
<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>
<blockquote>
<p>Dear list,</p>
<p>I just proved False using the normalization method in Isabelle/HOL, <br>
see below. It seems like TYPE(T) arguments are generalized(?) to <br>
TYPE(?'a) arguments when running the method (even when dropping the <br>
code equation for the constant to be normalized).</p>
<p>Is this a known problem and is there anything I can do to stop the <br>
normalizer from tinkering with TYPE(T) arguments?</p>
<p>Background: I used normalization by evaluation to work on a large <br>
data structure in an Isabelle/HOL proof for which the performance of <br>
the simplifier is insufficient.</p>
<p>Best wishes,</p>
<p>Kevin</p>
<p>```isabelle</p>
<p>theory Scratch<br>
  imports<br>
    Main<br>
begin</p>
<p>definition [code del]: "test ≡ card (UNIV :: 'a set) = 1"</p>
<p>(*TYPE(unit) changes to TYPE('a) even though [code del] is used for <br>
test*)<br>
value [nbe] "test TYPE(unit)"</p>
<p>lemma oh_oh: "test TYPE(unit) = test TYPE(bool)"<br>
  apply normalization<br>
  done</p>
<p>theorem "False"<br>
proof -<br>
  have "test TYPE(unit) = True" unfolding test_def by simp<br>
  moreover have "test TYPE(unit) = False" unfolding oh_oh by (simp <br>
add: test_def)<br>
  ultimately show False by simp<br>
qed</p>
<p>end</p>
<p>```</p>
</blockquote>
</blockquote>



<a name="500953661"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/500953661" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#500953661">(Feb 20 2025 at 19:22)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
I went back to the paper we wrote about NBE 15 years ago <br>
<a href="https://www21.in.tum.de/~nipkow/pubs/jfp12.html">https://www21.in.tum.de/~nipkow/pubs/jfp12.html</a>. This is what it says about types:</p>
<div class="codehilite" data-code-language="Isabelle"><pre><span></span><code><span class="n">In</span><span class="w"> </span><span class="n">most</span><span class="w"> </span><span class="n">cases</span><span class="o">,</span><span class="w"> </span><span class="n">these</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">reconstructions</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">unique</span><span class="o">,</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">follows</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span>
<span class="kp">structure</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="n">terms</span><span class="w"> </span><span class="kp">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">simply</span><span class="o">-</span><span class="n">typed</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="n">calculus.</span><span class="w"> </span><span class="n">However</span><span class="o">,</span><span class="w"> </span><span class="kp">in</span><span class="w"> </span><span class="n">the</span>
<span class="n">presence</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">polymorphic</span><span class="w"> </span><span class="n">constants</span><span class="o">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">most</span><span class="w"> </span><span class="n">general</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">could</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">general</span>
<span class="n">than</span><span class="w"> </span><span class="n">intended.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">example</span><span class="o">,</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">polymorphic</span><span class="w"> </span><span class="kp">constant</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">“</span><span class="o">(</span><span class="n">’a</span><span class="w"> </span><span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">’a</span><span class="o">)</span>
<span class="o">=</span><span class="n">&gt;</span><span class="w"> </span><span class="n">bool”</span><span class="o">,</span><span class="w"> </span><span class="n">say</span><span class="w"> </span><span class="n">without</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">rewrite</span><span class="w"> </span><span class="n">rule.</span><span class="w"> </span><span class="n">Then</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">untyped</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="n">form</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">“f</span>
<span class="o">(</span><span class="n">λu</span><span class="o">::</span><span class="n">bool.</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="n">”</span><span class="w"> </span><span class="n">would</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">“f</span><span class="w"> </span><span class="o">(</span><span class="n">λu.</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="n">”</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">most</span><span class="w"> </span><span class="n">general</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">annotations</span><span class="w"> </span><span class="n">“f</span>
<span class="o">(</span><span class="n">λu</span><span class="o">::</span><span class="n">’a.</span><span class="w"> </span><span class="n">u</span><span class="o">)</span><span class="n">”.</span><span class="w"> </span><span class="n">To</span><span class="w"> </span><span class="n">avoid</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">widening</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">those</span><span class="w"> </span><span class="n">equations</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span>
<span class="n">considered</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">proved</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">normalisation</span><span class="w"> </span><span class="kp">where</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">typing</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="kp">is</span>
<span class="n">completely</span><span class="w"> </span><span class="n">determined</span><span class="o">,</span><span class="w"> </span><span class="n">i.e.</span><span class="w"> </span><span class="n">those</span><span class="w"> </span><span class="n">equations</span><span class="w"> </span><span class="kp">where</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">most</span><span class="w"> </span><span class="n">general</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="kp">for</span><span class="w"> </span><span class="n">the</span>
<span class="n">result</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">introduce</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">variables.</span><span class="w"> </span><span class="n">It</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">noted</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">this</span><span class="o">,</span>
<span class="kp">in</span><span class="w"> </span><span class="n">particular</span><span class="o">,</span><span class="w"> </span><span class="kp">is</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="kp">if</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">expression</span><span class="w"> </span><span class="n">evaluates</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">True.</span>
</code></pre></div>
<p>Looking at Kevin's example (where unit becomes 'a), maybe we didn't implement <br>
the check at the end correctly. Florian?</p>
<p>Tobias</p>
<p>On 20/02/2025 19:01, Manuel Eberl wrote:</p>
<blockquote>
<p>Just for the benefit of readers on this mailing list who are not familiar with <br>
the NBE method: this is <em>not</em> a proof method that goes through the Isabelle <br>
kernel. It is an oracle, and one with a significant trusted code base. Moreover, <br>
I think it is used much less than the code generator oracle (the "eval" method), <br>
so issues like this one can remain unnoticed for a long time.</p>
<p>So, although I do not think it was previously known that you could prove "False" <br>
with NBE, it is not very surprising either. And it does <em>not</em> mean that Isabelle <br>
as a system is broken.</p>
<p>Unfortunately, I don't know enough about the internals of NBE to really comment <br>
on this issue otherwise. I just wanted to make sure this was stated somewhere <br>
clearly on the mailing list.</p>
<p>Cheers,</p>
<p>Manuel</p>
<p>On 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>
<blockquote>
<p>Oops. Here is a direct illustration that "normalization" is contradictory:</p>
<p>lemma "card (UNIV :: 'a set) = card (UNIV :: 'b set)"<br>
  apply normalization ..</p>
<p>Stepan</p>
<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>
<blockquote>
<p>Dear list,</p>
<p>I just proved False using the normalization method in Isabelle/HOL, see <br>
below. It seems like TYPE(T) arguments are generalized(?) to TYPE(?'a) <br>
arguments when running the method (even when dropping the code equation for <br>
the constant to be normalized).</p>
<p>Is this a known problem and is there anything I can do to stop the normalizer <br>
from tinkering with TYPE(T) arguments?</p>
<p>Background: I used normalization by evaluation to work on a large data <br>
structure in an Isabelle/HOL proof for which the performance of the <br>
simplifier is insufficient.</p>
<p>Best wishes,</p>
<p>Kevin</p>
<p>```isabelle</p>
<p>theory Scratch<br>
  imports<br>
    Main<br>
begin</p>
<p>definition [code del]: "test ≡ card (UNIV :: 'a set) = 1"</p>
<p>(<em>TYPE(unit) changes to TYPE('a) even though [code del] is used for test</em>)<br>
value [nbe] "test TYPE(unit)"</p>
<p>lemma oh_oh: "test TYPE(unit) = test TYPE(bool)"<br>
  apply normalization<br>
  done</p>
<p>theorem "False"<br>
proof -<br>
  have "test TYPE(unit) = True" unfolding test_def by simp<br>
  moreover have "test TYPE(unit) = False" unfolding oh_oh by (simp add: <br>
test_def)<br>
  ultimately show False by simp<br>
qed</p>
<p>end</p>
<p>```</p>
</blockquote>
</blockquote>
</blockquote>
<p><a href="/user_uploads/14278/mk6opHn28nS2ANja9PQc68iZ/smime.p7s">smime.p7s</a></p>



<a name="500955315"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/500955315" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#500955315">(Feb 20 2025 at 19:32)</a>:</h4>
<p>From: Stepan Holub &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
Noting that UNIV is normalized to " List.coset []", one is tempted to <br>
suspect that the typing is careless in the most natural place to go <br>
wrong, namely with Nil.<br>
(sorry for meddling, out of curiosity, with something I know nothing about).</p>
<p>Stepan</p>
<p>On 20-Feb-25 8:21 PM, Tobias Nipkow wrote:</p>
<blockquote>
<p>I went back to the paper we wrote about NBE 15 years ago <br>
<a href="https://www21.in.tum.de/~nipkow/pubs/jfp12.html">https://www21.in.tum.de/~nipkow/pubs/jfp12.html</a>. This is what it says <br>
about types:</p>
<p><code>
In most cases, these type reconstructions are unique, as follows from 
the structure of normal terms in the simply-typed lambda calculus. 
However, in the presence of polymorphic constants, the most general 
type could be more general than intended. For example, let f be a 
polymorphic constant of type “(’a =&gt; ’a) =&gt; bool”, say without any 
rewrite rule. Then the untyped normal form of “f (λu::bool. u)” would 
be “f (λu. u)” with most general type annotations “f (λu::’a. u)”. To 
avoid such widening of types only those equations will be considered 
as being proved by normalisation where the typing of the result is 
completely determined, i.e. those equations where the most general 
type for the result does not introduce any new type variables. It 
should be noted that this, in particular, is always the case if an 
expression evaluates to True.
</code></p>
<p>Looking at Kevin's example (where unit becomes 'a), maybe we didn't <br>
implement the check at the end correctly. Florian?</p>
<p>Tobias</p>
<p>On 20/02/2025 19:01, Manuel Eberl wrote:</p>
<blockquote>
<p>Just for the benefit of readers on this mailing list who are not <br>
familiar with the NBE method: this is <em>not</em> a proof method that goes <br>
through the Isabelle kernel. It is an oracle, and one with a <br>
significant trusted code base. Moreover, I think it is used much less <br>
than the code generator oracle (the "eval" method), so issues like <br>
this one can remain unnoticed for a long time.</p>
<p>So, although I do not think it was previously known that you could <br>
prove "False" with NBE, it is not very surprising either. And it does <br>
<em>not</em> mean that Isabelle as a system is broken.</p>
<p>Unfortunately, I don't know enough about the internals of NBE to <br>
really comment on this issue otherwise. I just wanted to make sure <br>
this was stated somewhere clearly on the mailing list.</p>
<p>Cheers,</p>
<p>Manuel</p>
<p>On 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing <br>
List) wrote:</p>
<blockquote>
<p>Oops. Here is a direct illustration that "normalization" is <br>
contradictory:</p>
<p>lemma "card (UNIV :: 'a set) = card (UNIV :: 'b set)"<br>
  apply normalization ..</p>
<p>Stepan</p>
<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>
<blockquote>
<p>Dear list,</p>
<p>I just proved False using the normalization method in Isabelle/HOL, <br>
see below. It seems like TYPE(T) arguments are generalized(?) to <br>
TYPE(?'a) arguments when running the method (even when dropping the <br>
code equation for the constant to be normalized).</p>
<p>Is this a known problem and is there anything I can do to stop the <br>
normalizer from tinkering with TYPE(T) arguments?</p>
<p>Background: I used normalization by evaluation to work on a large <br>
data structure in an Isabelle/HOL proof for which the performance <br>
of the simplifier is insufficient.</p>
<p>Best wishes,</p>
<p>Kevin</p>
<p>```isabelle</p>
<p>theory Scratch<br>
  imports<br>
    Main<br>
begin</p>
<p>definition [code del]: "test ≡ card (UNIV :: 'a set) = 1"</p>
<p>(*TYPE(unit) changes to TYPE('a) even though [code del] is used for <br>
test*)<br>
value [nbe] "test TYPE(unit)"</p>
<p>lemma oh_oh: "test TYPE(unit) = test TYPE(bool)"<br>
  apply normalization<br>
  done</p>
<p>theorem "False"<br>
proof -<br>
  have "test TYPE(unit) = True" unfolding test_def by simp<br>
  moreover have "test TYPE(unit) = False" unfolding oh_oh by (simp <br>
add: test_def)<br>
  ultimately show False by simp<br>
qed</p>
<p>end</p>
<p>```</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>



<a name="500964044"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/500964044" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#500964044">(Feb 20 2025 at 20:31)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 20/02/2025 19:01, Manuel Eberl wrote:</p>
<blockquote>
<p>Just for the benefit of readers on this mailing list who are not familiar with <br>
the NBE method: this is <em>not</em> a proof method that goes through the Isabelle <br>
kernel. It is an oracle, and one with a significant trusted code base. <br>
Moreover, I think it is used much less than the code generator oracle (the <br>
"eval" method), so issues like this one can remain unnoticed for a long time.</p>
<p>So, although I do not think it was previously known that you could prove <br>
"False" with NBE, it is not very surprising either. And it does <em>not</em> mean <br>
that Isabelle as a system is broken.</p>
<p>Unfortunately, I don't know enough about the internals of NBE to really <br>
comment on this issue otherwise. I just wanted to make sure this was stated <br>
somewhere clearly on the mailing list.</p>
</blockquote>
<p>Yes, it is very important to be careful about wording of statements, <br>
especially in informal language.</p>
<p>The subject of this thread is wrong, because there is nothing formally proven <br>
here.</p>
<p>Side-remark: We did not get a report of genuine problems in the Isabelle <br>
inference kernel for so many years, that I begin to feel uneasy. In olden <br>
times, there used to be reports approx. every 2 years.</p>
<p>Makarius</p>



<a name="501047299"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501047299" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501047299">(Feb 21 2025 at 08:26)</a>:</h4>
<p>From: Stepan Holub &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;</p>
<blockquote>
<p>The subject of this thread is wrong, because there is nothing formally <br>
proven here.</p>
</blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it contains <br>
some (very few) instances of normalization method (at least one <br>
&lt;<a href="https://www.isa-afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|fact">https://www.isa-afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|fact</a>&gt; <br>
followed by "qed").</p>
<p>Therefore, indeed, Manuel's warning is very important. A casual reader <br>
can be excused for not being able to make these fine distinctions.</p>
<p>Stepan</p>
<p>On 20-Feb-25 9:31 PM, Makarius wrote:</p>
<blockquote>
<p>On 20/02/2025 19:01, Manuel Eberl wrote:</p>
<blockquote>
<p>Just for the benefit of readers on this mailing list who are not <br>
familiar with the NBE method: this is <em>not</em> a proof method that goes <br>
through the Isabelle kernel. It is an oracle, and one with a <br>
significant trusted code base. Moreover, I think it is used much less <br>
than the code generator oracle (the "eval" method), so issues like <br>
this one can remain unnoticed for a long time.</p>
<p>So, although I do not think it was previously known that you could <br>
prove "False" with NBE, it is not very surprising either. And it does <br>
<em>not</em> mean that Isabelle as a system is broken.</p>
<p>Unfortunately, I don't know enough about the internals of NBE to <br>
really comment on this issue otherwise. I just wanted to make sure <br>
this was stated somewhere clearly on the mailing list.</p>
</blockquote>
<p>Yes, it is very important to be careful about wording of statements, <br>
especially in informal language.</p>
<p>The subject of this thread is wrong, because there is nothing formally <br>
proven here.</p>
<p>Side-remark: We did not get a report of genuine problems in the <br>
Isabelle inference kernel for so many years, that I begin to feel <br>
uneasy. In olden times, there used to be reports approx. every 2 years.</p>
<p>Makarius</p>
</blockquote>



<a name="501060607"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501060607" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501060607">(Feb 21 2025 at 09:34)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 21/02/2025 09:25, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>
<blockquote>
<blockquote>
<p>The subject of this thread is wrong, because there is nothing formally <br>
proven here.</p>
</blockquote>
</blockquote>
<blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it contains some <br>
(very few) instances of normalization method (at least one &lt;<a href="https://www.isa-">https://www.isa-</a> <br>
<a href="http://afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|">afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|</a> <br>
fact&gt; followed by "qed").</p>
</blockquote>
<p>The AFP title is correct, because almost everything is formally proven. There <br>
can be exceptions, when people are doing odd experiments. Or there can be <br>
situations where it is appropriate to use tools without proper proofs.</p>
<p>One day we could render the formal status of results in HTML somehow, to make <br>
this more clear.</p>
<p>And note that "qed" in Isar should not be read as "this is formally proven".</p>
<blockquote>
<p>Therefore, indeed, Manuel's warning is very important. A casual reader can be <br>
excused for not being able to make these fine distinctions.</p>
</blockquote>
<p>Indeed. That was his attempt to undo the error in the original subject by Kevin.</p>
<p>Makarius</p>



<a name="501066604"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501066604" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501066604">(Feb 21 2025 at 10:03)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>
<blockquote>
<p>Here is a direct illustration that "normalization" is contradictory:</p>
<p>lemma "card (UNIV :: 'a set) = card (UNIV :: 'b set)"<br>
   apply normalization ..</p>
</blockquote>
<p>That is a good example. This is how to expose its implicit assumptions, in <br>
terms of the inference kernel:</p>
<p>lemma a: "card (UNIV :: 'a set) = card (UNIV :: 'b set)"<br>
   apply normalization ..</p>
<p>ML ‹Thm_Deps.all_oracles @{thms a}›</p>
<p>(*<br>
val it = [(("Code_Generator.triv_of_class", {}), NONE), <br>
(("Code_Generator.normalization_by_evaluation", {}), NONE)]:<br>
<a href="http://Proofterm.oracle">Proofterm.oracle</a> list<br>
*)</p>
<p>Makarius</p>



<a name="501068666"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501068666" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501068666">(Feb 21 2025 at 10:11)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;</p>
<blockquote>
<p>That is a good example. This is how to expose its implicit <br>
assumptions, in terms of the inference kernel:</p>
<p>lemma a: "card (UNIV :: 'a set) = card (UNIV :: 'b set)"<br>
  apply normalization ..</p>
<p>ML ‹Thm_Deps.all_oracles @{thms a}›</p>
<p>(*<br>
val it = [(("Code_Generator.triv_of_class", {}), NONE), <br>
(("Code_Generator.normalization_by_evaluation", {}), NONE)]:<br>
<a href="http://Proofterm.oracle">Proofterm.oracle</a> list<br>
*)</p>
</blockquote>
<p>There actually is the top-level command thm_oracles for that, too:</p>
<p>thm_oracles a</p>
<p>Prints:</p>
<p>oracles:<br>
     triv_of_class<br>
     normalization_by_evaluation</p>
<p>As oracles are tracked transitively, you can always do that to your <br>
final theorems, if you want to know on what they depend.</p>
<p>--</p>
<p>Peter</p>
<blockquote>
<p>Makarius</p>
</blockquote>



<a name="501071208"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501071208" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501071208">(Feb 21 2025 at 10:23)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:manuel@pruvisto.org">manuel@pruvisto.org</a>&gt;<br>
On 21/02/2025 10:33, Makarius wrote:</p>
<blockquote>
<blockquote>
<p>Therefore, indeed, Manuel's warning is very important. A casual <br>
reader can be excused for not being able to make these fine <br>
distinctions.</p>
</blockquote>
<p>Indeed. That was his attempt to undo the error in the original subject <br>
by Kevin.</p>
</blockquote>
<p>I would not go that far. I'm sure I have referred to things that I <br>
"proved" with eval, for example, as "proven". Without quotation marks. A <br>
reasonable argument can be made that oracles are evil and should not be <br>
used in formal proof at all (or otherwise one should not call it "formal <br>
proof" anymore). But I think some more nuance is appropriate and one has <br>
to look at the oracle in question.</p>
<p>I for one have sometimes wondered whether something like a "numeral <br>
addition and multiplication" oracle that can only prove theorems of the <br>
form "(a :: num) + b = c" and "(a :: num) * b = c" would be an <br>
interesting thing to have to speed up numerical computations without <br>
resorting to full-on reflection. The trusted code base would be tiny, <br>
and the soundness of Isabelle depends on trusting Poly/ML to be able to <br>
do arithmetic on integers already anyway. And I think it would be <br>
throwing out the baby with the bath water to say a proof using this <br>
oracle is no longer a proof.</p>
<p>Something like "eval" or "nbe" is of course much more involved and there <br>
are much greater dangers for introducing inconsistency (e.g. one can use <br>
"code_printing" to make eval "prove" just about anything).</p>



<a name="501077719"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501077719" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501077719">(Feb 21 2025 at 10:59)</a>:</h4>
<p>From: Roland Lutz &lt;<a href="mailto:rlutz@hedmen.org">rlutz@hedmen.org</a>&gt;<br>
On Fri, 21 Feb 2025, Stepan Holub wrote:</p>
<blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it contains <br>
some (very few) instances of normalization method (at least one followed <br>
by "qed").</p>
<p>Therefore, indeed, Manuel's warning is very important. A casual reader can<br>
be excused for not being able to make these fine distinctions.</p>
</blockquote>
<p>Isn't the actual underlying problem here the trust in oracles' results?</p>
<p>I get that it isn't straightforward to reconstruct a proof from, e.g., an <br>
SMT solver.  But the fact that Isabelle is used for formal proofs and <br>
wording like "qed" should mean that Isabelle "takes responsibility" for <br>
oracle results.  So this really <em>is</em> an Isabelle bug, whether for the <br>
actual bug or for the inclusion of the oracle, right?</p>
<p>Ideally, the result from an oracle should be a proofterm.  How unrealistic <br>
is it to implement this?  What places would need to be changed?</p>
<p>Roland</p>



<a name="501086047"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501086047" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501086047">(Feb 21 2025 at 11:47)</a>:</h4>
<p>From: Fabian Huch &lt;<a href="mailto:huch@in.tum.de">huch@in.tum.de</a>&gt;<br>
You seem to be confusing terminology here.</p>
<p>The concept of an oracle is that it must be trusted. SMT solvers are <br>
normally not trusted as oracles in Isabelle (and especially not in the <br>
AFP) -- e.g., sledgehammer reconstructs all its proofs unless you <br>
explicitly ask it not to.</p>
<p>It is not a surprise that using additional oracles in arbitrary ways <br>
will introduce inconsistencies -- you can also axiomatize "False", if <br>
you want.</p>
<p>Also Isabelle is an LCF-style system which eliminates the need for proof <br>
terms.</p>
<p>Fabian</p>
<p>On 2/21/25 11:38, Roland Lutz wrote:</p>
<blockquote>
<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>
<blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it <br>
contains some (very few) instances of normalization method (at least <br>
one followed by "qed").</p>
<p>Therefore, indeed, Manuel's warning is very important. A casual <br>
reader can<br>
be excused for not being able to make these fine distinctions.</p>
</blockquote>
<p>Isn't the actual underlying problem here the trust in oracles' results?</p>
<p>I get that it isn't straightforward to reconstruct a proof from, e.g., <br>
an SMT solver.  But the fact that Isabelle is used for formal proofs <br>
and wording like "qed" should mean that Isabelle "takes <br>
responsibility" for oracle results.  So this really <em>is</em> an Isabelle <br>
bug, whether for the actual bug or for the inclusion of the oracle, <br>
right?</p>
<p>Ideally, the result from an oracle should be a proofterm. How <br>
unrealistic is it to implement this?  What places would need to be <br>
changed?</p>
<p>Roland</p>
</blockquote>



<a name="501094521"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501094521" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501094521">(Feb 21 2025 at 12:33)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 21/02/2025 11:38, Roland Lutz wrote:</p>
<blockquote>
<p>I get that it isn't straightforward to reconstruct a proof from, e.g., an SMT <br>
solver.</p>
</blockquote>
<p>People have actually done that, and by default you get a proper proof for <br>
Isabelle "smt" invocations.</p>
<blockquote>
<p>So this really <em>is</em> an Isabelle bug, whether for the actual bug or for the <br>
inclusion of the oracle, right?</p>
</blockquote>
<p>The term "bug" is undefined in the Isabelle culture. I normally say <br>
"unexpected behaviour". In the majority of cases this is then a <br>
misunderstanding of how things work, rather than a problem in the implementation.</p>
<blockquote>
<p>Ideally, the result from an oracle should be a proofterm.  How unrealistic is <br>
it to implement this?  What places would need to be changed?</p>
</blockquote>
<p>Not necessarily a proofterm, but proper inferences in terms of the kernel. <br>
This is the normal way in the greater HOL community, and done properly most of <br>
the time.</p>
<p>An alternative is CakeML: these guys have managed to to bootstrap a formally <br>
proven stack of prover technology, such that things are fast and correct at <br>
the same time.</p>
<p>Makarius</p>



<a name="501109242"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501109242" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501109242">(Feb 21 2025 at 13:48)</a>:</h4>
<p>From: Dominic Mulligan &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
Following Peter's post about <code>thm_oracles</code>, is there a way of invoking<br>
<code>isabelle build</code> for a session so that it fails if any proof of a lemma<br>
appearing within that session invokes a method that does not pass through<br>
the kernel?</p>
<p>Thanks,<br>
Dom</p>
<p>On Fri, 21 Feb 2025 at 12:33, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>
<blockquote>
<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>
<blockquote>
<p>I get that it isn't straightforward to reconstruct a proof from, e.g.,<br>
an SMT<br>
solver.</p>
</blockquote>
<p>People have actually done that, and by default you get a proper proof for<br>
Isabelle "smt" invocations.</p>
<blockquote>
<p>So this really <em>is</em> an Isabelle bug, whether for the actual bug or for<br>
the<br>
inclusion of the oracle, right?</p>
</blockquote>
<p>The term "bug" is undefined in the Isabelle culture. I normally say<br>
"unexpected behaviour". In the majority of cases this is then a<br>
misunderstanding of how things work, rather than a problem in the<br>
implementation.</p>
<blockquote>
<p>Ideally, the result from an oracle should be a proofterm.  How<br>
unrealistic is<br>
it to implement this?  What places would need to be changed?</p>
</blockquote>
<p>Not necessarily a proofterm, but proper inferences in terms of the kernel.<br>
This is the normal way in the greater HOL community, and done properly<br>
most of<br>
the time.</p>
<p>An alternative is CakeML: these guys have managed to to bootstrap a<br>
formally<br>
proven stack of prover technology, such that things are fast and correct<br>
at<br>
the same time.</p>
<p>Makarius</p>
</blockquote>



<a name="501109692"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501109692" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501109692">(Feb 21 2025 at 13:51)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:manuel@pruvisto.org">manuel@pruvisto.org</a>&gt;<br>
Others have written good responses to this already, but let me just add <br>
this: Proof terms are not really something that is used very much in <br>
Isabelle. When you have an "oracle" in Isabelle that can easily be made <br>
to return a proof term (be it an Isabelle proof term or something more <br>
domain-specific, such as a SAT or SMT proof), the usual thing to do is <br>
to just "import" the proof term by plugging together Isabelle theorems <br>
(such that everything goes through the kernel). Or, better still, to <br>
just have the "oracle" plug Isabelle theorems together directly.</p>
<p>The "generate some proof object and then push it through the kernel" <br>
approach is taken e.g. by Isabelle's "smt" tactic, by various tools to <br>
import SAT proofs in e.g. the DRUP format, and I think there was a proof <br>
method for linear orders that does this as well (not sure whether it is <br>
in the AFP or the distribution).</p>
<p>The "plug theorems together directly" approach is taken e.g. by my <br>
real_asymp method for proving asymptotic properties like limits and "Big <br>
O" statements. This is in the Isabelle distribution. The advantage here <br>
is that you don't have to first compute a (possibly huge) proof object <br>
and then process it (a bit like deforestation). The disadvantage might <br>
be that plugging together Isabelle theorems tends to be expensive, so if <br>
you're doing a lot of exploration where it's not clear whether a branch <br>
of computation will actually lead to a result, this might not be the <br>
right approach.</p>
<p>But once you do any of that, it's not an oracle anymore (at least not in <br>
Isabelle terminology), but a proof method. An oracle is by definition <br>
trusted code that need not justify what it does to the Isabelle kernel. <br>
Consequently, one has to be very careful with these. Morally, I think a <br>
good argument can be made that oracles make sense for statements that, <br>
if you were to see a proof for them on paper or in a proof term, it <br>
would feel like a waste of space: straightforward computations that take <br>
a lot of time but where it is completely clear <em>how</em> to do them. I think <br>
that is how people in systems such as Coq would often use reflection.</p>
<p>Cheers,</p>
<p>Manuel</p>
<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>
<blockquote>
<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>
<blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it <br>
contains some (very few) instances of normalization method (at least <br>
one followed by "qed").</p>
<p>Therefore, indeed, Manuel's warning is very important. A casual <br>
reader can<br>
be excused for not being able to make these fine distinctions.</p>
</blockquote>
<p>Isn't the actual underlying problem here the trust in oracles' results?</p>
<p>I get that it isn't straightforward to reconstruct a proof from, e.g., <br>
an SMT solver.  But the fact that Isabelle is used for formal proofs <br>
and wording like "qed" should mean that Isabelle "takes <br>
responsibility" for oracle results.  So this really <em>is</em> an Isabelle <br>
bug, whether for the actual bug or for the inclusion of the oracle, <br>
right?</p>
<p>Ideally, the result from an oracle should be a proofterm.  How <br>
unrealistic is it to implement this?  What places would need to be <br>
changed?</p>
<p>Roland</p>
</blockquote>



<a name="501115759"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501115759" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501115759">(Feb 21 2025 at 14:20)</a>:</h4>
<p>From: Stepan Holub &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
Let me dare and ask a different, but related, and possibly naively basic <br>
question.</p>
<p>Is there a clear answer to a logician who wants to know what is the <br>
axiomatic system in which the theorem is proved if it "passes through <br>
the kernel"? When advertising Isabelle/HOL, I am often asked this <br>
question, and I confess I am never sure I have a satisfactory answer. <br>
The answer should be Pure + HOL. But I am afraid that to explain what <br>
that means /exactly/, one should either refer to the actual ML code <br>
(which is not satisfactory to the logician asking the question) or to <br>
provide quite some background literature, which will give only an <br>
approximate answer anyway.</p>
<p>Stepan</p>
<p>On 21-Feb-25 2:50 PM, Manuel Eberl wrote:</p>
<blockquote>
<p>Others have written good responses to this already, but let me just <br>
add this: Proof terms are not really something that is used very much <br>
in Isabelle. When you have an "oracle" in Isabelle that can easily be <br>
made to return a proof term (be it an Isabelle proof term or something <br>
more domain-specific, such as a SAT or SMT proof), the usual thing to <br>
do is to just "import" the proof term by plugging together Isabelle <br>
theorems (such that everything goes through the kernel). Or, better <br>
still, to just have the "oracle" plug Isabelle theorems together <br>
directly.</p>
<p>The "generate some proof object and then push it through the kernel" <br>
approach is taken e.g. by Isabelle's "smt" tactic, by various tools to <br>
import SAT proofs in e.g. the DRUP format, and I think there was a <br>
proof method for linear orders that does this as well (not sure <br>
whether it is in the AFP or the distribution).</p>
<p>The "plug theorems together directly" approach is taken e.g. by my <br>
real_asymp method for proving asymptotic properties like limits and <br>
"Big O" statements. This is in the Isabelle distribution. The <br>
advantage here is that you don't have to first compute a (possibly <br>
huge) proof object and then process it (a bit like deforestation). The <br>
disadvantage might be that plugging together Isabelle theorems tends <br>
to be expensive, so if you're doing a lot of exploration where it's <br>
not clear whether a branch of computation will actually lead to a <br>
result, this might not be the right approach.</p>
<p>But once you do any of that, it's not an oracle anymore (at least not <br>
in Isabelle terminology), but a proof method. An oracle is by <br>
definition trusted code that need not justify what it does to the <br>
Isabelle kernel. Consequently, one has to be very careful with these. <br>
Morally, I think a good argument can be made that oracles make sense <br>
for statements that, if you were to see a proof for them on paper or <br>
in a proof term, it would feel like a waste of space: straightforward <br>
computations that take a lot of time but where it is completely clear <br>
<em>how</em> to do them. I think that is how people in systems such as Coq <br>
would often use reflection.</p>
<p>Cheers,</p>
<p>Manuel</p>
<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>
<blockquote>
<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>
<blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it <br>
contains some (very few) instances of normalization method (at least <br>
one followed by "qed").</p>
<p>Therefore, indeed, Manuel's warning is very important. A casual <br>
reader can<br>
be excused for not being able to make these fine distinctions.</p>
</blockquote>
<p>Isn't the actual underlying problem here the trust in oracles' results?</p>
<p>I get that it isn't straightforward to reconstruct a proof from, <br>
e.g., an SMT solver.  But the fact that Isabelle is used for formal <br>
proofs and wording like "qed" should mean that Isabelle "takes <br>
responsibility" for oracle results.  So this really <em>is</em> an Isabelle <br>
bug, whether for the actual bug or for the inclusion of the oracle, <br>
right?</p>
<p>Ideally, the result from an oracle should be a proofterm.  How <br>
unrealistic is it to implement this?  What places would need to be <br>
changed?</p>
<p>Roland</p>
</blockquote>
</blockquote>



<a name="501131989"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501131989" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501131989">(Feb 21 2025 at 15:38)</a>:</h4>
<p>From: Fabian Huch &lt;<a href="mailto:huch@in.tum.de">huch@in.tum.de</a>&gt;<br>
Yes, you can look at the transitive dependencies of your theorem that <br>
are axioms (doable in a bit of Isabelle/ML programming). Your axiomatic <br>
system consists of those + the metalogic itself, which has been <br>
formalized e.g. by Simon Roßkopf and Tobias Nipkow [1] (their proof <br>
checker even verifies whether the extracted term is a proof for the <br>
theorem).</p>
<p>The trouble is that you are going to find a lot of axioms, e.g., every <br>
constant or type definition will add some. Those axioms are also added <br>
directly, without using the oracle mechanism. I'm not quite sure why <br>
(possibly performance reasons), because the latter would mean that it'd <br>
be sufficient to only look at a few oracles instead of a linearly <br>
growing set of axioms -- and we even have helpful tools such as the <br>
thm_oracles command.</p>
<p>Fabian</p>
<p>[1]: Roßkopf, S., Nipkow, T. A Formalization and Proof Checker for <br>
Isabelle’s Metalogic. /J Autom Reasoning/ <em>67</em>, 1 (2023). <br>
<a href="https://doi.org/10.1007/s10817-022-09648-w">https://doi.org/10.1007/s10817-022-09648-w</a></p>
<p>On 2/21/25 15:20, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>
<blockquote>
<p>Let me dare and ask a different, but related, and possibly naively <br>
basic question.</p>
<p>Is there a clear answer to a logician who wants to know what is the <br>
axiomatic system in which the theorem is proved if it "passes through <br>
the kernel"? When advertising Isabelle/HOL, I am often asked this <br>
question, and I confess I am never sure I have a satisfactory answer. <br>
The answer should be Pure + HOL. But I am afraid that to explain what <br>
that means /exactly/, one should either refer to the actual ML code <br>
(which is not satisfactory to the logician asking the question) or to <br>
provide quite some background literature, which will give only an <br>
approximate answer anyway.</p>
<p>Stepan</p>
<p>On 21-Feb-25 2:50 PM, Manuel Eberl wrote:</p>
<blockquote>
<p>Others have written good responses to this already, but let me just <br>
add this: Proof terms are not really something that is used very much <br>
in Isabelle. When you have an "oracle" in Isabelle that can easily be <br>
made to return a proof term (be it an Isabelle proof term or <br>
something more domain-specific, such as a SAT or SMT proof), the <br>
usual thing to do is to just "import" the proof term by plugging <br>
together Isabelle theorems (such that everything goes through the <br>
kernel). Or, better still, to just have the "oracle" plug Isabelle <br>
theorems together directly.</p>
<p>The "generate some proof object and then push it through the kernel" <br>
approach is taken e.g. by Isabelle's "smt" tactic, by various tools <br>
to import SAT proofs in e.g. the DRUP format, and I think there was a <br>
proof method for linear orders that does this as well (not sure <br>
whether it is in the AFP or the distribution).</p>
<p>The "plug theorems together directly" approach is taken e.g. by my <br>
real_asymp method for proving asymptotic properties like limits and <br>
"Big O" statements. This is in the Isabelle distribution. The <br>
advantage here is that you don't have to first compute a (possibly <br>
huge) proof object and then process it (a bit like deforestation). <br>
The disadvantage might be that plugging together Isabelle theorems <br>
tends to be expensive, so if you're doing a lot of exploration where <br>
it's not clear whether a branch of computation will actually lead to <br>
a result, this might not be the right approach.</p>
<p>But once you do any of that, it's not an oracle anymore (at least not <br>
in Isabelle terminology), but a proof method. An oracle is by <br>
definition trusted code that need not justify what it does to the <br>
Isabelle kernel. Consequently, one has to be very careful with these. <br>
Morally, I think a good argument can be made that oracles make sense <br>
for statements that, if you were to see a proof for them on paper or <br>
in a proof term, it would feel like a waste of space: straightforward <br>
computations that take a lot of time but where it is completely clear <br>
<em>how</em> to do them. I think that is how people in systems such as Coq <br>
would often use reflection.</p>
<p>Cheers,</p>
<p>Manuel</p>
<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>
<blockquote>
<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>
<blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it <br>
contains some (very few) instances of normalization method (at <br>
least one followed by "qed").</p>
<p>Therefore, indeed, Manuel's warning is very important. A casual <br>
reader can<br>
be excused for not being able to make these fine distinctions.</p>
</blockquote>
<p>Isn't the actual underlying problem here the trust in oracles' results?</p>
<p>I get that it isn't straightforward to reconstruct a proof from, <br>
e.g., an SMT solver.  But the fact that Isabelle is used for formal <br>
proofs and wording like "qed" should mean that Isabelle "takes <br>
responsibility" for oracle results.  So this really <em>is</em> an Isabelle <br>
bug, whether for the actual bug or for the inclusion of the oracle, <br>
right?</p>
<p>Ideally, the result from an oracle should be a proofterm.  How <br>
unrealistic is it to implement this?  What places would need to be <br>
changed?</p>
<p>Roland</p>
</blockquote>
</blockquote>
</blockquote>



<a name="501135085"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501135085" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501135085">(Feb 21 2025 at 15:53)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Stepan,</p>
<p>There is no simple precise answer.</p>
<p>Isabelle's meta-logic is clearly defined here:<br>
<a href="https://link.springer.com/article/10.1007/s10817-022-09648-w">https://link.springer.com/article/10.1007/s10817-022-09648-w</a><br>
It explains how propositions in Isabelle's term langage are combined (which is <br>
how you would expect an inference system to behave), includiung well-formedness, <br>
type class and overloading.</p>
<p>The above paper presents a proof checker that takes an Isabelle proof term and <br>
checks that the axioms of whatever theory you are in (which may be <br>
implicational, i.e. rules) have been plugged together correctly. The proof <br>
checker was verified (in HOL itself).</p>
<p>The Isabelle theory HOL is the result you obtain when you add a bunch of axioms <br>
that you can find in HOL.thy. It is meant to formalize<br>
A. Church, A formulation of the simple theory of types, Journal of Symbolic <br>
Logic 5 (1940) 56–68.<br>
but deviates in some aspects, esp the types. Same for all HOL-based systems.</p>
<p>In the end there is always some source could you would need to read or trust to <br>
make sure that what you see (as a user) is what you get (internally).</p>
<p>Tobias</p>
<p>On 21/02/2025 15:20, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>
<blockquote>
<p>Let me dare and ask a different, but related, and possibly naively basic question.</p>
<p>Is there a clear answer to a logician who wants to know what is the axiomatic <br>
system in which the theorem is proved if it "passes through the kernel"? When <br>
advertising Isabelle/HOL, I am often asked this question, and I confess I am <br>
never sure I have a satisfactory answer. The answer should be Pure + HOL. But I <br>
am afraid that to explain what that means /exactly/, one should either refer to <br>
the actual ML code (which is not satisfactory to the logician asking the <br>
question) or to provide quite some background literature, which will give only <br>
an approximate answer anyway.</p>
<p>Stepan</p>
<p>On 21-Feb-25 2:50 PM, Manuel Eberl wrote:</p>
<blockquote>
<p>Others have written good responses to this already, but let me just add this: <br>
Proof terms are not really something that is used very much in Isabelle. When <br>
you have an "oracle" in Isabelle that can easily be made to return a proof <br>
term (be it an Isabelle proof term or something more domain-specific, such as <br>
a SAT or SMT proof), the usual thing to do is to just "import" the proof term <br>
by plugging together Isabelle theorems (such that everything goes through the <br>
kernel). Or, better still, to just have the "oracle" plug Isabelle theorems <br>
together directly.</p>
<p>The "generate some proof object and then push it through the kernel" approach <br>
is taken e.g. by Isabelle's "smt" tactic, by various tools to import SAT <br>
proofs in e.g. the DRUP format, and I think there was a proof method for <br>
linear orders that does this as well (not sure whether it is in the AFP or the <br>
distribution).</p>
<p>The "plug theorems together directly" approach is taken e.g. by my real_asymp <br>
method for proving asymptotic properties like limits and "Big O" statements. <br>
This is in the Isabelle distribution. The advantage here is that you don't <br>
have to first compute a (possibly huge) proof object and then process it (a <br>
bit like deforestation). The disadvantage might be that plugging together <br>
Isabelle theorems tends to be expensive, so if you're doing a lot of <br>
exploration where it's not clear whether a branch of computation will actually <br>
lead to a result, this might not be the right approach.</p>
<p>But once you do any of that, it's not an oracle anymore (at least not in <br>
Isabelle terminology), but a proof method. An oracle is by definition trusted <br>
code that need not justify what it does to the Isabelle kernel. Consequently, <br>
one has to be very careful with these. Morally, I think a good argument can be <br>
made that oracles make sense for statements that, if you were to see a proof <br>
for them on paper or in a proof term, it would feel like a waste of space: <br>
straightforward computations that take a lot of time but where it is <br>
completely clear <em>how</em> to do them. I think that is how people in systems such <br>
as Coq would often use reflection.</p>
<p>Cheers,</p>
<p>Manuel</p>
<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>
<blockquote>
<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>
<blockquote>
<p>Strictly speaking, then, even the title "AFP" is wrong, as it contains some <br>
(very few) instances of normalization method (at least one followed by "qed").</p>
<p>Therefore, indeed, Manuel's warning is very important. A casual reader can<br>
be excused for not being able to make these fine distinctions.</p>
</blockquote>
<p>Isn't the actual underlying problem here the trust in oracles' results?</p>
<p>I get that it isn't straightforward to reconstruct a proof from, e.g., an SMT <br>
solver.  But the fact that Isabelle is used for formal proofs and wording <br>
like "qed" should mean that Isabelle "takes responsibility" for oracle <br>
results.  So this really <em>is</em> an Isabelle bug, whether for the actual bug or <br>
for the inclusion of the oracle, right?</p>
<p>Ideally, the result from an oracle should be a proofterm.  How unrealistic is <br>
it to implement this?  What places would need to be changed?</p>
<p>Roland</p>
</blockquote>
</blockquote>
</blockquote>
<p><a href="/user_uploads/14278/FWmi7TFYRHhhaOX_AwUydCcJ/smime.p7s">smime.p7s</a></p>



<a name="501141269"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501141269" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501141269">(Feb 21 2025 at 16:24)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 21/02/2025 14:50, Manuel Eberl wrote:</p>
<blockquote>
<p>But once you do any of that, it's not an oracle anymore (at least not in <br>
Isabelle terminology), but a proof method.</p>
</blockquote>
<p>Your explanation was all fine, only this bit needs refinement:</p>
<p>* "proof method" is goal refinement operation of the Isar proof language. <br>
Proof methods may appear as initial method in 'proof' or terminal method in <br>
'qed'; the Isar language is parametric over the method language, these may do <br>
whatever is technically possible, even non-sense.</p>
<p>* Above you could say "derived inference rule (of the kernel)".</p>
<p>Makarius</p>



<a name="501142887"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501142887" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501142887">(Feb 21 2025 at 16:33)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 21/02/2025 15:20, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>
<blockquote>
<p>Is there a clear answer to a logician who wants to know what is the axiomatic <br>
system in which the theorem is proved if it "passes through the kernel"? When <br>
advertising Isabelle/HOL, I am often asked this question, and I confess I am <br>
never sure I have a satisfactory answer. The answer should be Pure + HOL. But <br>
I am afraid that to explain what that means /exactly/, one should either refer <br>
to the actual ML code (which is not satisfactory to the logician asking the <br>
question) or to provide quite some background literature, which will give only <br>
an approximate answer anyway.</p>
</blockquote>
<p>There are many clear answers, but with some complexity involved in the <br>
explanations. I am not a aware of a single canonical answer that could be <br>
obtained without an effort.</p>
<p>When introducing Isabelle, I sometimes start with Pure and the Isar proof <br>
language, and eventually bootstrap HOL from that. Results of such exercises <br>
are available in src/Pure/Examples. Quite a lot can be done from basic <br>
principles, without a huge stack of addon proof tools getting involved. Thus <br>
the audience gets some sense how the formal game works.</p>
<p>An alternatively approach is to export everything as a huge collection of <br>
lambda terms. Despite many efforts in recent years, this is still not ready <br>
for prime time, but I would like to see this working eventually. For example, <br>
the Dedukti guys have volunteered to absorb whatever we throw at them, and <br>
make an independent integrity check of the theory content and the proof terms.</p>
<p>Makarius</p>



<a name="501144741"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501144741" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501144741">(Feb 21 2025 at 16:43)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 21/02/2025 14:48, Dominic Mulligan (via cl-isabelle-users Mailing List) wrote:</p>
<blockquote>
<p>Following Peter's post about <code>thm_oracles</code>, is there a way of invoking <br>
<code>isabelle build</code> for a session so that it fails if any proof of a lemma <br>
appearing within that session invokes a method that does not pass through the <br>
kernel?</p>
</blockquote>
<p>There are various possibilities to do that. The Isabelle/ML operation <br>
Build.add_hook allows to install a function that gets invoked at the end of <br>
the ML session build. E.g. Mirabelle is using that to inspect all intermediate <br>
goal states, to see how automatic tools like them.</p>
<p>You could use that to inspect the regular fact name space, to see if "bad" thm <br>
values are stored. (Tools could still hide their own evil thms in pockets that <br>
are invisible, and conjure up such bad results later.)</p>
<p>To "harden" regular Isabelle builds, I would use a slightly different <br>
approach: There is already "isabelle build -o export_theory". It could provide <br>
sufficient information to analyze the overall thm dependency graph later on, <br>
in Isabelle/Scala instead of Isabelle/ML. Isabelle/Scala has the advantage <br>
that it "oversees" the overall Isabelle/ML session. The Scala tool could cause <br>
an error, or display results nicely as a report in the HTML presentation, for <br>
example, to say clearly "how correct" which theorem is, meaning what are its <br>
extra dependencies on oracles, axioms, etc.</p>
<p>Makarius</p>



<a name="501160933"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/501160933" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#501160933">(Feb 21 2025 at 18:15)</a>:</h4>
<p>From: Frédéric Blanqui &lt;<a href="mailto:frederic.blanqui@inria.fr">frederic.blanqui@inria.fr</a>&gt;</p>
<p>Le 21/02/2025 à 17:32, Makarius a écrit :</p>
<blockquote>
<p>An alternatively approach is to export everything as a huge collection <br>
of lambda terms. Despite many efforts in recent years, this is still <br>
not ready for prime time, but I would like to see this working <br>
eventually. For example, the Dedukti guys have volunteered to absorb <br>
whatever we throw at them, and make an independent integrity check of <br>
the theory content and the proof terms. </p>
</blockquote>
<p>Hi. Indeed, <a href="https://github.com/Deducteam/isabelle_dedukti">https://github.com/Deducteam/isabelle_dedukti</a> is an Isabelle <br>
component that can convert Isabelle proof terms into Dedukti or Lambdapi <br>
files. Current Dedukti and Lambdapi checkers (dkcheck, kontroli and <br>
lambdapi) are quite fast, especially the first two. The main limitation <br>
currently is rather on the Isabelle side: the current proof export is <br>
quite slow. In the last Isabelle workshop (Tbilisi, 2024), Makarius gave <br>
a nice talk on proof export and his long-term project to improve it (see <br>
<a href="https://files.sketis.net/Isabelle_Workshop_2024/Isabelle_2024_paper_6.pdf">https://files.sketis.net/Isabelle_Workshop_2024/Isabelle_2024_paper_6.pdf</a>). <br>
Note that isabelle_dedukti does not handle oracles. The Dedukti or <br>
Lambdapi representation provides another interesting way to see what <br>
exactly is the logic implemented by Isabelle, and what is assumed by the <br>
kernel.</p>



<a name="512363375"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proved%20False%20using%20normalization%20by%20evaluation/near/512363375" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proved.20False.20using.20normalization.20by.20evaluation.html#512363375">(Apr 15 2025 at 16:19)</a>:</h4>
<p>From: Florian Haftmann &lt;<a href="mailto:florian.haftmann@cit.tum.de">florian.haftmann@cit.tum.de</a>&gt;<br>
See now</p>
<p><a href="https://isabelle.in.tum.de/repos/isabelle/rev/5601f5cce4c6">https://isabelle.in.tum.de/repos/isabelle/rev/5601f5cce4c6</a></p>
<p>for the final piece of a series of improvements in nbe.ML.</p>
<p>There were basically two things to put into shape:</p>
<ul>
<li>
<p>Low-level type inference during term reconstruction was restored using <br>
proof-context level type inference.</p>
</li>
<li>
<p>Constants carry explicit type arguments, hence the underapproximation <br>
for equality used for non-left-linear patterns can distinguish different <br>
type instances. As a side effect, type reconstruction of terms is <br>
complete now (although this never had been an issue an practice AFAIR).</p>
<p>Florian</p>
</li>
</ul>
<p><a href="/user_uploads/14278/6dRj2lH5yFDbI2xcK3nzBj2e/OpenPGP_0xA707172232CFA4E9.asc">OpenPGP_0xA707172232CFA4E9.asc</a><br>
<a href="/user_uploads/14278/Wl9wZGNT0jHzm0ZQz_EWIG_4/OpenPGP_signature.asc">OpenPGP_signature.asc</a></p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>