<html>
<head><meta charset="utf-8"><title>[isabelle] A formal model of IEEE-754 floating-point arit... · Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/index.html">Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html">[isabelle] A formal model of IEEE-754 floating-point arit...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="285255291"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285255291" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285255291">(Jun 07 2022 at 14:04)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
Dear floating-point enthusiasts,</p>
<p>As you may know, a formalization of IEEE-754 floating-point arithmetic<br>
in Isabelle/HOL is readily available from the AFP [1].</p>
<p>The type "('e, 'f) float" of floating-point values that is defined in<br>
this AFP entry is based on the bit-vector representation of floating-<br>
point values. Specifically, the type contains several bit-vector<br>
representations of the NaN ("Not-a-Number") value.</p>
<p>In contrast, SMT-LIB defines a floating-point theory [2] whose type of<br>
floating-point values contains exactly one NaN value. (According to<br>
SMT-LIB, this is "in agreement with Level 2 of IEEE 754-2008.")</p>
<p>This means that the two types are not isomorphic: we cannot (soundly)<br>
map Isabelle's floating-point type to SMT-LIB's if we want to benefit<br>
from the decision procedures for floating-point values that are<br>
available in SMT solvers.</p>
<p>To address this, it seems clear to me that one should define a<br>
floating-point type in Isabelle that corresponds to the SMT-LIB type,<br>
i.e. that formalizes floating-point values at specification level 2 of<br>
the IEEE standard.</p>
<p>My question then is: what to do with the current type of floating-point<br>
values? Should it be retained, or replaced with the new type?</p>
<p>The bit-vector notation for floating-point values is undoubtedly<br>
useful, but there is a many-to-one relationship between bit vectors and<br>
floating-point data at specification level 2, so a (non-injective)<br>
embedding function onto the new type would suffice to retain this<br>
notation. Is there much point in reasoning about floating-point<br>
operations at the representation level when a formalization of<br>
floating-point data at specification level 2 is available?</p>
<p>Best,<br>
Tjark</p>
<p>[1] <a href="https://www.isa-afp.org/entries/IEEE_Floating_Point.html">https://www.isa-afp.org/entries/IEEE_Floating_Point.html</a><br>
[2] <a href="https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml">https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml</a></p>
<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href="http://www.uu.se/om-uu/dataskydd-personuppgifter/">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>
<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href="http://www.uu.se/en/about-uu/data-protection-policy">http://www.uu.se/en/about-uu/data-protection-policy</a></p>



<a name="285261811"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285261811" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285261811">(Jun 07 2022 at 14:47)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
Hi Tjark,</p>
<p>when I worked with the AFP entry, I try to identify all NaNs anyway, as <br>
doing so makes proofs easier.</p>
<p>even for my formalization of LLVM floating point semantics, I currently <br>
do not support distinguishing NaNs, as their semantics seems to be <br>
implementation defined.</p>



<a name="285266082"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285266082" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285266082">(Jun 07 2022 at 15:13)</a>:</h4>
<p>From: Lennart Beringer &lt;<a href="mailto:eberinge@cs.princeton.edu">eberinge@cs.princeton.edu</a>&gt;<br>
Hi Tjark,</p>
<p>I notice that the dependency graph of modules at <a href="https://flocq.gitlabpages.inria.fr/">https://flocq.gitlabpages.inria.fr/</a><br>
has nodes IEEE754.Binary and BinarySingleNaN, the former importing the latter.<br>
I'm not a "floating point enthusiast" and haven't used Flocq much myself but<br>
maybe the relationship between the types defined in these modules is relevant for<br>
this discussion, and treatments of this aspect could be harmonized between <br>
different provers?</p>
<p>Best,</p>
<p>Lennart.</p>
<p>----- Forwarded Message -----<br>
From: "Tjark Weber" &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
To: "isabelle-users" &lt;<a href="mailto:isabelle-users@cl.cam.ac.uk">isabelle-users@cl.cam.ac.uk</a>&gt;<br>
Cc: <a href="mailto:ly271@cam.ac.uk">ly271@cam.ac.uk</a>, <a href="mailto:hellauer@in.tum.de">hellauer@in.tum.de</a>, <a href="mailto:fimmler@apple.com">fimmler@apple.com</a><br>
Sent: Tuesday, 7 June, 2022 10:03:34<br>
Subject: [isabelle] A formal model of IEEE-754 floating-point arithmetic: Specification level</p>
<p>Dear floating-point enthusiasts,</p>
<p>As you may know, a formalization of IEEE-754 floating-point arithmetic<br>
in Isabelle/HOL is readily available from the AFP [1].</p>
<p>The type "('e, 'f) float" of floating-point values that is defined in<br>
this AFP entry is based on the bit-vector representation of floating-<br>
point values. Specifically, the type contains several bit-vector<br>
representations of the NaN ("Not-a-Number") value.</p>
<p>In contrast, SMT-LIB defines a floating-point theory [2] whose type of<br>
floating-point values contains exactly one NaN value. (According to<br>
SMT-LIB, this is "in agreement with Level 2 of IEEE 754-2008.")</p>
<p>This means that the two types are not isomorphic: we cannot (soundly)<br>
map Isabelle's floating-point type to SMT-LIB's if we want to benefit<br>
from the decision procedures for floating-point values that are<br>
available in SMT solvers.</p>
<p>To address this, it seems clear to me that one should define a<br>
floating-point type in Isabelle that corresponds to the SMT-LIB type,<br>
i.e. that formalizes floating-point values at specification level 2 of<br>
the IEEE standard.</p>
<p>My question then is: what to do with the current type of floating-point<br>
values? Should it be retained, or replaced with the new type?</p>
<p>The bit-vector notation for floating-point values is undoubtedly<br>
useful, but there is a many-to-one relationship between bit vectors and<br>
floating-point data at specification level 2, so a (non-injective)<br>
embedding function onto the new type would suffice to retain this<br>
notation. Is there much point in reasoning about floating-point<br>
operations at the representation level when a formalization of<br>
floating-point data at specification level 2 is available?</p>
<p>Best,<br>
Tjark</p>
<p>[1] <a href="https://www.isa-afp.org/entries/IEEE_Floating_Point.html">https://www.isa-afp.org/entries/IEEE_Floating_Point.html</a><br>
[2] <a href="https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml">https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml</a></p>
<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href="http://www.uu.se/om-uu/dataskydd-personuppgifter/">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>
<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href="http://www.uu.se/en/about-uu/data-protection-policy">http://www.uu.se/en/about-uu/data-protection-policy</a></p>



<a name="285326536"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285326536" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285326536">(Jun 07 2022 at 23:18)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:kleing@unsw.edu.au">kleing@unsw.edu.au</a>&gt;<br>
Hi Tjark,</p>
<p>I would have thought that it's the only useful representation for implementation verification, because that is what implementations have to use. E.g. a C or assembly program operates on bit vector representations and will have to deal with the fact that multiple of these map to the abstract value NaN. </p>
<p>If you remove that, what semantics do you give to a program that manipulates bit vector representations of floating point values?</p>
<p>Cheers,<br>
Gerwin</p>



<a name="285326574"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285326574" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285326574">(Jun 07 2022 at 23:19)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:kleing@unsw.edu.au">kleing@unsw.edu.au</a>&gt;<br>
That sounds like an excellent idea to me.</p>
<p>Cheers,<br>
Gerwin</p>



<a name="285349286"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285349286" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285349286">(Jun 08 2022 at 06:13)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
If IEEE has two treatments of NaN, we should not trash the one we have but <br>
derive the other one as well, as the Coq library seems to (thanks, Lennart).</p>
<p>Tjark: I would encourage you to extend the AFP entry accordingly (in <br>
consultation with one of the authors or contributors, if they still reply...)</p>
<p>Tobias<br>
<a href="/user_uploads/14278/yh0YYYSIurVpWxFx2gI50dNm/smime.p7s">smime.p7s</a></p>



<a name="285357900"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285357900" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285357900">(Jun 08 2022 at 08:09)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
Note that the NaN is slightly over specified in the current entry. They use<br>
some_nan as the only value for NaN produced by operations, which allows you to<br>
prove that all NaN results from operations are equal.</p>
<p>Peter</p>



<a name="285370839"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285370839" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285370839">(Jun 08 2022 at 10:17)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
Gerwin,</p>
<p>I would think that the abstract ("level 2") semantics is sufficient to<br>
verify most code that uses floating points. Code that cares about the<br>
specific bit-vector representation of floating-point values should be<br>
relatively rare in comparison, but I acknowledge that it exists (for<br>
instance, you might want to verify an implementation of IEEE-754).</p>
<p>Best,<br>
Tjark</p>
<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href="http://www.uu.se/om-uu/dataskydd-personuppgifter/">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>
<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href="http://www.uu.se/en/about-uu/data-protection-policy">http://www.uu.se/en/about-uu/data-protection-policy</a></p>



<a name="285385569"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285385569" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285385569">(Jun 08 2022 at 12:51)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
Dear all,</p>
<p>Thank you for your input! I will try to summarize what I think are some<br>
key points from this discussion:</p>
<ol>
<li>
<p>Both the abstract ("level 2") specification of floating-point data<br>
and the bit-vector representation are potentially useful.</p>
</li>
<li>
<p>Flocq defines two kinds of (binary) floating-point types: one with a<br>
single NaN value, and one with multiple NaN values. The latter is based<br>
on the former.</p>
</li>
<li>
<p>The AFP entry currently only defines a floating-point type with<br>
multiple NaN values.</p>
</li>
<li>
<p>However, only one of these NaN values ("some_nan") is returned as<br>
the result of floating-point operations.¹ Flocq is more flexible in<br>
this regard: its floating-point operations are parameterized on<br>
functions that return a NaN result for NaN arguments.</p>
</li>
</ol>
<p>Perhaps the best way forward then is to add a new floating-point type<br>
with a single NaN value to the AFP entry, to define the floating-point<br>
operations (also) on this type, and to redefine the floating-point<br>
operations on the existing floating-point type in terms of the new type<br>
(much like in Flocq).</p>
<p>I hope to be able to make some progress in this direction in the near<br>
future. If anyone wants to contribute or has further input (especially<br>
authors/maintainers of the current AFP entry), please get in touch!</p>
<p>Best,<br>
Tjark</p>
<p>¹ This is arguably not conforming to the IEEE standard, which specifies<br>
that the result should be one of the input NaNs.</p>
<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href="http://www.uu.se/om-uu/dataskydd-personuppgifter/">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>
<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href="http://www.uu.se/en/about-uu/data-protection-policy">http://www.uu.se/en/about-uu/data-protection-policy</a></p>



<a name="285387714"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285387714" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285387714">(Jun 08 2022 at 13:06)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;</p>
<blockquote>
<p>I hope to be able to make some progress in this direction in the near<br>
future. If anyone wants to contribute or has further input (especially<br>
authors/maintainers of the current AFP entry), please get in touch!</p>
</blockquote>
<p>I have written an automated test suite, that tests the current floating <br>
point semantics against pre-defined operation+result vectors, currently <br>
drawn from IBM's FPGen testsuite (the publically available 32bit test <br>
vectors). Its core is an executable result checker, that currently works <br>
for +,-,*,div, fmadd, and sqrt.</p>
<p>While this is not very polished yet, it already can discover the bug in <br>
the formalization of fmadd (fixed in afp-devel).</p>
<p>I'm not sure how to best integrate this development though, as the AFP <br>
does not support the scripts + C programs etc that I used for the test runs.</p>



<a name="285465228"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285465228" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285465228">(Jun 08 2022 at 23:14)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:kleing@unsw.edu.au">kleing@unsw.edu.au</a>&gt;<br>
Hi Tjark,</p>
<p>I strongly disagree with the "rare" point, not because it is wrong, but because it is not an argument.</p>
<p>This is a common fallacy in program verification: if the semantics of a language allows specific (unwanted) behaviours, you cannot verify the program in a semantics that assumes these behaviours do not exist, no matter if used rarely or even never. Instead, you must use a semantics that has those behaviours (or at least can detect them) and prove their absence. So if you assume a unique representation of NaN in your formalisation, the formalisation is already disqualified for safety proofs in programs in languages that have direct access to the bit vector representation, because you cannot observe those failures.</p>
<p>There are multiple ways to deal with this of course -- instead of modelling all representations, you could have a semantics that explicitly fails as soon as there is an unwanted representation, but this would mean something like an option type into whatever is used for float. I doubt that this is what one would want (esp since this is what NaN neatly expresses anyway). You could also try to prove a language invariant that the representation is always valid, but this excludes languages like C and assembly. You could try to have that invariant as a program invariant, but then you still need to be able to distinguish valid from non-valid representations and you'll have a problem that is isomorphic to projecting to an option type (maybe nicer to deal with on the technical level).</p>
<p>I have not looked closely at the Flocq formalisation, but it sounds to me like the level 2 semantics is basically a quotient on the bitvector representation. It should be possible to transport most properties both ways across that quotient, so that you can have a level 1 semantics for the program, and use the level 2 semantics for verifying properties about it together with suitable transport theorems. The difficulties one encounters transporting properties across are exactly the parts where the level 2 semantics fails to observe failure in real implementations. It would be very nice to crystallise that out in an abstract way that is independent of specific programming languages.</p>
<p>This has similarities to using integers for program verification vs machine words (much smaller scope here, but still there): there are many properties that are perfectly preserved and useful if you verify a program with integer semantics, but if you only use integers you won't know. What the machine word type does is force you to acknowledge the limitations of the real program and deal with them. You can either reason about the more complex machine word type or you can reason about the integer type and suitably generate side conditions about overflow (assuming you manage to catch all cases). Both are fine. What is not fine is only using integers and saying that the property still holds because overflow is rare.</p>
<p>Cheers,<br>
Gerwin</p>



<a name="285468983"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285468983" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285468983">(Jun 09 2022 at 00:03)</a>:</h4>
<p>From: Matthew Fernandez &lt;<a href="mailto:matthew.fernandez@gmail.com">matthew.fernandez@gmail.com</a>&gt;<br>
I read Tjark’s comments to mean code that needs to distinguish differing NaN representations or to recover from a NaN result is rare. If so, I would say this is accurate, and using a single NaN representation seems sufficient. There’s a lot of floating point code that treats any NaN result as “give up.” In contrast, there’s only a much smaller amount of code that tries to distinguish different NaNs or cast back and forth between integer and floating point representations.</p>
<p>For the former code, a proof would simply give you nothing in the face of NaNs. I.e. you’d have to prove a NaN value never arose or add the absence of intermediate NaNs to your assumptions. Maybe I misunderstand you though, Gerwin.</p>



<a name="285471499"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285471499" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285471499">(Jun 09 2022 at 00:38)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
Gerwin,</p>
<p>On Wed, 2022-06-08 at 23:13 +0000, Gerwin Klein wrote:</p>
<blockquote>
<blockquote>
<p>On 8 Jun 2022, at 20:16, Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt; wrote:<br>
I would think that the abstract ("level 2") semantics is sufficient<br>
to verify most code that uses floating points. Code that cares<br>
about the specific bit-vector representation of floating-point<br>
values should be relatively rare in comparison, but I acknowledge<br>
that it exists (for instance, you might want to verify an<br>
implementation of IEEE-754).</p>
</blockquote>
<p>I strongly disagree with the "rare" point, not because it is wrong,<br>
but because it is not an argument.</p>
<p>This is a common fallacy in program verification: if the semantics of<br>
a language allows specific (unwanted) behaviours, you cannot verify<br>
the program in a semantics that assumes these behaviours do not<br>
exist, no matter if used rarely or even never. Instead, you must use<br>
a semantics that has those behaviours (or at least can detect them)<br>
and prove their absence. So if you assume a unique representation of<br>
NaN in your formalisation, the formalisation is already disqualified<br>
for safety proofs in programs in languages that have direct access to<br>
the bit vector representation, because you cannot observe those<br>
failures.</p>
</blockquote>
<p>I agree, but for programs that (are written in language fragments that)<br>
do not directly access the bit-vector representation of floating-point<br>
data, verification against the abstract ("level 2") semantics is sound.</p>
<p>Of course, one should not use that semantics to verify <em>arbitrary</em> C<br>
programs without further checks. In fact, one couldn't: level 2 does<br>
not specify the bit encoding of floating-point data. If we need to<br>
reason about the bit encoding, it would clearly be unsound to assume<br>
that NaN has only one encoding.</p>
<blockquote>
<p>This has similarities to using integers for program verification vs<br>
machine words (much smaller scope here, but still there): there are<br>
many properties that are perfectly preserved and useful if you verify<br>
a program with integer semantics, but if you only use integers you<br>
won't know. What the machine word type does is force you to<br>
acknowledge the limitations of the real program and deal with them.<br>
You can either reason about the more complex machine word type or you<br>
can reason about the integer type and suitably generate side<br>
conditions about overflow (assuming you manage to catch all cases).<br>
Both are fine. What is not fine is only using integers and saying<br>
that the property still holds because overflow is rare.</p>
</blockquote>
<p>I think a more apt comparison would be between bounded integers (that<br>
correctly model C arithmetic including overflow) and machine words.<br>
Machine-word semantics is needed for programs that apply bit operations<br>
to integer data; but bounded-integer semantics suffices to verify<br>
programs that only use arithmetic operations on integers. Neither<br>
semantics will ignore overflows.</p>
<p>Best,<br>
Tjark</p>
<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href="http://www.uu.se/om-uu/dataskydd-personuppgifter/">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>
<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href="http://www.uu.se/en/about-uu/data-protection-policy">http://www.uu.se/en/about-uu/data-protection-policy</a></p>



<a name="285507812"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285507812" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285507812">(Jun 09 2022 at 09:29)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:kleing@unsw.edu.au">kleing@unsw.edu.au</a>&gt;<br>
Hi Tjark,</p>
<blockquote>
<p>On 9 Jun 2022, at 10:37, Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt; wrote:</p>
<p>On Wed, 2022-06-08 at 23:13 +0000, Gerwin Klein wrote:</p>
<blockquote>
<p>On 8 Jun 2022, at 20:16, Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt; wrote:</p>
<blockquote>
<p>I would think that the abstract ("level 2") semantics is sufficient<br>
to verify most code that uses floating points. Code that cares<br>
about the specific bit-vector representation of floating-point<br>
values should be relatively rare in comparison, but I acknowledge<br>
that it exists (for instance, you might want to verify an<br>
implementation of IEEE-754).</p>
</blockquote>
<p>I strongly disagree with the "rare" point, not because it is wrong,<br>
but because it is not an argument.</p>
<p>This is a common fallacy in program verification: if the semantics of<br>
a language allows specific (unwanted) behaviours, you cannot verify<br>
the program in a semantics that assumes these behaviours do not<br>
exist, no matter if used rarely or even never. Instead, you must use<br>
a semantics that has those behaviours (or at least can detect them)<br>
and prove their absence. So if you assume a unique representation of<br>
NaN in your formalisation, the formalisation is already disqualified<br>
for safety proofs in programs in languages that have direct access to<br>
the bit vector representation, because you cannot observe those<br>
failures.</p>
</blockquote>
<p>I agree, but for programs that (are written in language fragments that)<br>
do not directly access the bit-vector representation of floating-point<br>
data, verification against the abstract ("level 2") semantics is sound.</p>
<p>Of course, one should not use that semantics to verify <em>arbitrary</em> C<br>
programs without further checks. In fact, one couldn't: level 2 does<br>
not specify the bit encoding of floating-point data. If we need to<br>
reason about the bit encoding, it would clearly be unsound to assume<br>
that NaN has only one encoding.</p>
</blockquote>
<p>Cool, I think we are in agreement then. My point was that if I'm verifying arbitrary C programs with type unsoundness etc  (which I do regularly) I don't know if I'm in a fragment for which level 2 is sound or not until I've done the verification. For that, level 1 is useful. Having both levels available would be even more useful, so I'm all for adding level 2, but I'm against removing level 1.</p>
<blockquote>
<blockquote>
<p>This has similarities to using integers for program verification vs<br>
machine words (much smaller scope here, but still there): there are<br>
many properties that are perfectly preserved and useful if you verify<br>
a program with integer semantics, but if you only use integers you<br>
won't know. What the machine word type does is force you to<br>
acknowledge the limitations of the real program and deal with them.<br>
You can either reason about the more complex machine word type or you<br>
can reason about the integer type and suitably generate side<br>
conditions about overflow (assuming you manage to catch all cases).<br>
Both are fine. What is not fine is only using integers and saying<br>
that the property still holds because overflow is rare.</p>
</blockquote>
<p>I think a more apt comparison would be between bounded integers (that<br>
correctly model C arithmetic including overflow) and machine words.<br>
Machine-word semantics is needed for programs that apply bit operations<br>
to integer data; but bounded-integer semantics suffices to verify<br>
programs that only use arithmetic operations on integers. Neither<br>
semantics will ignore overflows.</p>
</blockquote>
<p>I shouldn't have started that rabbit hole, but now that we're here I need to point out that bounded integers are exactly equivalent to machine words (in fact that is what the machine word representation can be derived from), so bounded integers don't work as analogy for the float problem. But I think we agree sufficiently that we don't need to search for a better analogy :-)</p>
<p>Cheers,<br>
Gerwin</p>



<a name="285511785"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285511785" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285511785">(Jun 09 2022 at 10:05)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:kleing@unsw.edu.au">kleing@unsw.edu.au</a>&gt;</p>
<blockquote>
<p>On 9 Jun 2022, at 10:02, Matthew Fernandez &lt;<a href="mailto:matthew.fernandez@gmail.com">matthew.fernandez@gmail.com</a>&gt; wrote:</p>
</blockquote>
<blockquote>
<p>I read Tjark’s comments to mean code that needs to distinguish differing NaN representations or to recover from a NaN result is rare.</p>
</blockquote>
<p>Agreed so far.</p>
<blockquote>
<p>If so, I would say this is accurate, and using a single NaN representation seems sufficient.</p>
</blockquote>
<p>I don't agree with the second part as stated (but possibly with what you meant). It'd certainly be possible to write a semantics that only has a single NaN value, but you'd basically be reconstructing the cases the level 1 semantics deals with when you are either projecting multiple representations into one abstract NaN or trying to exclude those representations before they are abstracted. Either way you have to be able to say that they either don't occur or if you allow them to occur, how they behave. The level 1 semantics makes that straightforward. The level 2 semantics doesn't (it basically assumes this has already happened, e.g. as a language invariant).</p>
<p>It's not like C programs don't screw with representations all the time. They will absolutely rely on things like zeroing a memory region being equivalent to the value 0 in float etc. If you want to be able to deal with that, you need to be able to deal with representations. You can forbid some etc, but you can't start the semantics with just abstract values.</p>
<blockquote>
<p>There’s a lot of floating point code that treats any NaN result as “give up.” In contrast, there’s only a much smaller amount of code that tries to distinguish different NaNs or cast back and forth between integer and floating point representations.</p>
</blockquote>
<p>Yes, I do agree that actually using them for computation is rare and I likely wouldn't be interested in verifying such programs. I could maybe see a NaN in/NaN out situation, but I'd mostly be interested in showing that a particular program doesn't produce NaN. I claim that for that purpose, you can't start with the level 2 semantics if the programming language doesn't implement it. You can end up there, but your basic program semantics has to do more and what it has to do is modelled nicely by level 1.</p>
<p>There is a lot of design space on how you could model all this, and I think I understand your point about proving that no NaN ever happens. I'd still say that a level 1 float representation fits extremely well for that. It can deal with NaN in expressions (so you don't have to generate side conditions for every sub-expression), it can deal with multiple representations of NaN for code that screws up representations in stupid ways, and I can easily state that I want none of these NaN representations to occur, because they are just values in the float type, not something extra.</p>
<p>(As added bonus, if you have multiple NaN, you don't have to work hard to make sure Isabelle doesn't produce reflexivity for NaN)</p>
<blockquote>
<p>For the former code, a proof would simply give you nothing in the face of NaNs. I.e. you’d have to prove a NaN value never arose or add the absence of intermediate NaNs to your assumptions.</p>
</blockquote>
<p>Demanding absence of NaN for every intermediate sub-expression is a lot of side conditions that you have to solve before you get to reason about what the program actually does. It'd be possible, but I don't think it'd be nice. </p>
<blockquote>
<p>Maybe I misunderstand you though, Gerwin.</p>
</blockquote>
<p>I think we're converging.</p>
<p>Cheers,<br>
Gerwin</p>



<a name="285518312"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285518312" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285518312">(Jun 09 2022 at 11:18)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
Gerwin,</p>
<p>This is justified by the fact that the floating-point operations in<br>
IEEE-754 treat (different representations of) NaN uniformly. Therefore,<br>
the level 2 semantics is simply a quotient of the more detailed bit-<br>
vector semantics.</p>
<p>Anyway, I think we are mostly in agreement (at least, I have no plans<br>
to remove the bit-vector semantics from the AFP entry). Just for the<br>
record (and to avoid potential confusion), I'd like to mention that<br>
what you are calling "level 1" semantics in this thread (i.e., the bit<br>
representation of floating-point data) is actually specification level<br>
4 in IEEE-754.</p>
<p>Best,<br>
Tjark</p>
<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href="http://www.uu.se/om-uu/dataskydd-personuppgifter/">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>
<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href="http://www.uu.se/en/about-uu/data-protection-policy">http://www.uu.se/en/about-uu/data-protection-policy</a></p>



<a name="285608761"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247541-Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20A%20formal%20model%20of%20IEEE-754%20floating-point%20arit.../near/285608761" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247541-Mirror:-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20A.20formal.20model.20of.20IEEE-754.20floating-point.20arit.2E.2E.2E.html#285608761">(Jun 09 2022 at 23:39)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:kleing@unsw.edu.au">kleing@unsw.edu.au</a>&gt;</p>
<blockquote>
<p>On 9 Jun 2022, at 21:18, Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt; wrote:</p>
<p>Gerwin,</p>
<p>On Thu, 2022-06-09 at 10:04 +0000, Gerwin Klein wrote:</p>
<blockquote>
<blockquote>
<p>If so, I would say this is accurate, and using a single NaN<br>
representation seems sufficient.</p>
</blockquote>
<p>I don't agree with the second part as stated (but possibly with what<br>
you meant). It'd certainly be possible to write a semantics that only<br>
has a single NaN value, but you'd basically be reconstructing the<br>
cases the level 1 semantics deals with when you are either projecting<br>
multiple representations into one abstract NaN or trying to exclude<br>
those representations before they are abstracted. Either way you have<br>
to be able to say that they either don't occur or if you allow them<br>
to occur, how they behave. The level 1 semantics makes that<br>
straightforward. The level 2 semantics doesn't (it basically assumes<br>
this has already happened, e.g. as a language invariant).</p>
</blockquote>
<p>This is justified by the fact that the floating-point operations in<br>
IEEE-754 treat (different representations of) NaN uniformly. Therefore,<br>
the level 2 semantics is simply a quotient of the more detailed bit-<br>
vector semantics.</p>
</blockquote>
<p>Yup, exactly.</p>
<blockquote>
<p>Anyway, I think we are mostly in agreement (at least, I have no plans<br>
to remove the bit-vector semantics from the AFP entry). Just for the<br>
record (and to avoid potential confusion), I'd like to mention that<br>
what you are calling "level 1" semantics in this thread (i.e., the bit<br>
representation of floating-point data) is actually specification level<br>
4 in IEEE-754.</p>
</blockquote>
<p>Thanks, yes, good point. I didn't actually look that up and just used 1 as the counter point.</p>
<p>Cheers,<br>
Gerwin</p>



<hr><p>Last updated: Jul 15 2022 at 23:21 UTC</p>
</html>