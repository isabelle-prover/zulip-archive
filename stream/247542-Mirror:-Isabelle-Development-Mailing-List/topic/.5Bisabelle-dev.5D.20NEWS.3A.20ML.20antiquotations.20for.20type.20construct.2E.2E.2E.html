<html>
<head><meta charset="utf-8"><title>[isabelle-dev] NEWS: ML antiquotations for type construct... · Mirror: Isabelle Development Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/index.html">Mirror: Isabelle Development Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html">[isabelle-dev] NEWS: ML antiquotations for type construct...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="254347902"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/254347902" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#254347902">(Sep 22 2021 at 10:50)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
<strong>* ML </strong>*</p>
<ul>
<li>ML antiquotations for type constructors and term constants:<p>\&lt;^Type&gt;‹c›<br>
  \&lt;^Type&gt;‹c T …›       ― ‹same with type arguments›<br>
  \&lt;^Type&gt;_fn‹c T …›    ― ‹fn abstraction, failure via exception TYPE›<br>
  \&lt;^Const&gt;‹c›<br>
  \&lt;^Const&gt;‹c T …›      ― ‹same with type arguments›<br>
  \&lt;^Const&gt;‹c for t …›  ― ‹same with term arguments›<br>
  \&lt;^Const_&gt;‹c …›       ― ‹same for patterns: case, let, fn›<br>
  \&lt;^Const&gt;_fn‹c T …›   ― ‹fn abstraction, failure via exception TERM›</p>
</li>
</ul>
<p>Examples in HOL:</p>
<p>val natT = \&lt;^Type&gt;‹nat›;<br>
  fun mk_funT (A, B) = \&lt;^Type&gt;‹fun A B›;<br>
  val dest_funT = fn \&lt;^Type&gt;‹fun A B› =&gt; (A, B);<br>
  fun mk_conj (A, B) = \&lt;^Const&gt;‹conj for A B›;<br>
  val dest_conj = fn \&lt;^Const_&gt;‹conj for A B› =&gt; (A, B);<br>
  fun mk_eq T (t, u) = \&lt;^Const&gt;‹HOL.eq T for t u›;<br>
  val dest_eq = fn \&lt;^Const_&gt;‹HOL.eq T for t u› =&gt; (T, (t, u));</p>
<p>This refers to Isabelle/4974c3697fee.</p>
<p>The question of how to represent outlines for type and term expressions<br>
adequately and robustly in Isabelle/ML has remained open for a long time.<br>
After 2007/2008, I always thought that we should use more concrete syntax<br>
(namely inner syntax).</p>
<p>After rethinking it thoroughly, the outcome is now as above. The key idea is<br>
to nest ML source inside antiquotations: this has become possible in recent<br>
antiquotations \&lt;^try&gt;‹expr› and \&lt;^can&gt;‹expr›.</p>
<p>The result looks a bit like enhanced S-expressions from the old LISP days:<br>
this fits perfectly well into the idea of antiquotations and nesting of<br>
sublanguages via cartouches --- instead of lots of silly parentheses.</p>
<p>Another motivation: the Const antiquotations already use "typargs", e.g. just<br>
one type T for overloaded "plus", instead of "T =&gt; T =&gt; T". When all<br>
Isabelle/ML have been upgraded to use that form, we may have a chance to trim<br>
down the redundant type information in datatype term for Const (within a few<br>
years).</p>
<p>This has the potential to speed-up term/type<br>
instantiation/matching/unification considerably: profiles always show a lot of<br>
activity on types, rather than actual term structure.</p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="254350344"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/254350344" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#254350344">(Sep 22 2021 at 11:16)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
Hi,<br>
nice that term handling from ML gets some attention now.Just as a<br>
remark, and maybe "feature request" of what I would like to see, I'm<br>
using the following antiquotations for several years now. They are in<br>
the AFP. <br>
<a href="https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html</a><br>
<a href="https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html</a></p>
<p>There is an antiquotation @{mpat} that generates a ML matching pattern<br>
from a term, and one @{mk_term} that constructs a term. mk_term also<br>
tries hard to infer types from the arguments (examples below). <br>
These are definitely not include-in-distribution quality yet, as they<br>
use a hack of identifying term-variables (?x) with ML variables.<br>
However, I use them a lot, and would like to ultimately see robust and<br>
clean means to efficiently match against and constructs complex terms<br>
from ML level in a readable way.<br>
--  Peter<br>
Examples to generate matching patterns from terms:<br>
  fun dest_pair_singleton @{mpat "{(?a,_)}"} = (a)<br>
    | dest_pair_singleton t = raise TERM ("dest_pair_singleton",[t])</p>
<p>fun dest_nat_pair_singleton @{mpat (typs) "{(?a::nat,?b::nat)}"} =<br>
(a,b)<br>
    | dest_nat_pair_singleton t = raise TERM<br>
("dest_nat_pair_singleton",[t])</p>
<p>fun dest_pair_singleton_T @{mpat (typs) "{(?a::_ ⇒<br>
?'v_Ta,?b::?'v_Tb)}"} = <br>
    ((a,Ta),(b,Tb))<br>
    | dest_pair_singleton_T t = raise TERM<br>
("dest_pair_singleton_T",[t])</p>
<p>fun dest_pair_lambda @{mpat "{(λa _ _. ?Ta, λb. ?Tb)}"} =<br>
(a,a_T,b,b_T,Ta,Tb)<br>
    | dest_pair_lambda t = raise TERM ("dest_pair_lambda",[t])</p>
<p>fun foo @{mpat "[?a,?b AS⇩s mpaq_Bound ?i,?c AS⇩p [?n]]"} = <br>
    (a,b,i,c,n)<br>
  | foo t = raise TERM ("foo",[t])</p>
<p>Examples to generate term templates:  fun mk_2elem_list a b = @{mk_term<br>
"[?a,?b]"}<br>
  fun mk_compr s P = @{mk_term "{ x∈?s. ?P x}"}</p>
<p>val test1 = mk_2elem_list @{term "1::nat"} @{term "2::nat"} |&gt;<br>
Thm.cterm_of @{context}<br>
  val test2 = mk_compr @{term "{1,2,3::nat}"} @{term "(&lt;) (2::nat)"} |&gt;<br>
Thm.cterm_of @{context}</p>
<p>val test3 = let <br>
    val x = Bound 0 <br>
    val env = [@{typ nat}]<br>
  in <br>
    @{mk_term env: "?x+?x"}<br>
  end</p>



<a name="254354783"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/254354783" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#254354783">(Sep 22 2021 at 11:59)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 22/09/2021 13:16, Peter Lammich wrote:</p>
<blockquote>
<p>Just as a remark, and maybe "feature request" of what I would like to see, I'm<br>
using the following antiquotations for several years now. They are in the AFP. <br>
<a href="https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html</a><br>
<a href="https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html</a></p>
<p>There is an antiquotation @{mpat} that generates a ML matching pattern from a<br>
term, and one @{mk_term} that constructs a term. <br>
mk_term also tries hard to infer types from the arguments (examples below). </p>
<p>These are definitely not include-in-distribution quality yet, as they use a<br>
hack of identifying term-variables (?x) with ML variables. However, I use them<br>
a lot, and would like to <br>
ultimately see robust and clean means to efficiently match against and<br>
constructs complex terms from ML level in a readable way.</p>
</blockquote>
<p>This looks like enormous complexity, with remaining open questions and<br>
problems. It is like an attempt to implement my postulates from many years<br>
ago, to connect inner syntax somehow to ML.</p>
<p>My current move deviates from that, returning to a more basic and more robust<br>
scheme. Recall these explanations:</p>
<blockquote>
<p>On Wed, 2021-09-22 at 12:50 +0200, Makarius wrote:</p>
<blockquote>
<p>The question of how to represent outlines for type and term expressions<br>
adequately and robustly in Isabelle/ML has remained open for a long time.<br>
After 2007/2008, I always thought that we should use more concrete syntax<br>
(namely inner syntax).</p>
<p>After rethinking it thoroughly, the outcome is now as above. The key idea is<br>
to nest ML source inside antiquotations: this has become possible in recent<br>
antiquotations \&lt;^try&gt;‹expr› and \&lt;^can&gt;‹expr›.</p>
<p>The result looks a bit like enhanced S-expressions from the old LISP days:<br>
this fits perfectly well into the idea of antiquotations and nesting of<br>
sublanguages via cartouches --- instead of lots of silly parentheses.</p>
</blockquote>
</blockquote>
<p>So my counter feature request: Can you upgrade your applications to the new ML<br>
antiquotations, and remove your attempt?</p>
<p>Looking briefly at actual uses of @{mpat} in AFP, most of them look very basic.</p>
<p>Here is an example at the upper end in complexity, translated into the new<br>
Type/Const/Const_ scheme:</p>
<p>ML ‹<br>
(*<br>
  fun constraints_of_goal i st =<br>
    case Logic.concl_of_goal (Thm.prop_of st) i of<br>
      @{mpat "Trueprop ((_,?a)∈_)"} =&gt; constraints_of_term a<br>
    | _ =&gt; raise THM ("constraints_of_goal",i,[st])<br>
*)</p>
<p>val constraints_of_term: term -&gt; (term * term) list = undefined;</p>
<p>fun constraints_of_goal i st =<br>
    case Logic.concl_of_goal (Thm.prop_of st) i of<br>
      \&lt;^Const_&gt;‹Trueprop for ‹\&lt;^Const_&gt;‹Set.member _ for ‹\&lt;^Const_&gt;‹Pair _
_ for _ a›› _››› =&gt;<br>
        constraints_of_term a<br>
    | _ =&gt; raise THM ("constraints_of_goal",i,[st])<br>
›</p>
<p>Most other uses will be even easier to rephrase.</p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="254356646"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/254356646" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#254356646">(Sep 22 2021 at 12:15)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;</p>
<blockquote>
<p>Here is an example at the upper end in complexity, translated into<br>
the new<br>
Type/Const/Const_ scheme:</p>
<p>ML ‹<br>
(*<br>
  fun constraints_of_goal i st =<br>
    case Logic.concl_of_goal (Thm.prop_of st) i of<br>
      @{mpat "Trueprop ((_,?a)∈_)"} =&gt; constraints_of_term a<br>
    | _ =&gt; raise THM ("constraints_of_goal",i,[st])<br>
*)</p>
<p>val constraints_of_term: term -&gt; (term * term) list = undefined;</p>
<p>fun constraints_of_goal i st =<br>
    case Logic.concl_of_goal (Thm.prop_of st) i of<br>
      \&lt;^Const_&gt;‹Trueprop for ‹\&lt;^Const_&gt;‹Set.member _ for<br>
‹\&lt;^Const_&gt;‹Pair _
_ for _ a›› _››› =&gt;<br>
        constraints_of_term a<br>
    | _ =&gt; raise THM ("constraints_of_goal",i,[st])<br>
›<br>
</p>
</blockquote>
<p>Unfortunately, the translation sacrifices quite some readability. In my<br>
latest developments (not yet in AFP), I'd use @{mprop "(_,?a)∈_"} for<br>
the above pattern, which is even more concise.</p>
<p>Btw, the upper end of complexity for term creation @{mk_term} is<br>
something like:</p>
<p>@{mk_term "Refine_Basic.bind$(RETURN$(COPY$?p))$?t'"}</p>
<p>which looks like a lot of effort to write down in plain ML, or with<br>
basic Const antiquotations. In particular, note that all types in the<br>
term need to be inferred from the types of ?p and ?t'.</p>



<a name="254389892"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/254389892" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#254389892">(Sep 22 2021 at 15:50)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Here is the direct correspondence to the new antiquotations:</p>
<p>theory Scratch<br>
  imports Refine_Imperative_HOL.Sepref_Rules Refine_Imperative_HOL.Sepref_Monadify<br>
begin</p>
<p>ML ‹<br>
  fn p =&gt; fn t' =&gt;<br>
    @{mk_term "Refine_Basic.bind$(RETURN$(COPY$?p))$?t'"}›</p>
<p>ML ‹<br>
  fn A =&gt; fn B =&gt; fn p =&gt; fn t' =&gt;<br>
    \&lt;^Const&gt;‹Refine_Basic.bind A B for<br>
      ‹\&lt;^Const&gt;‹RETURN A for ‹\&lt;^Const&gt;‹COPY A for p›››› t'›<br>
›</p>
<p>end</p>
<p>Of course, this needs to be viewed in Isabelle/jEdit, to make the \&lt;^Const&gt;<br>
symbol look nice.</p>
<p>Note that the explicit data-flow concerning the type parameters (for Type and<br>
Const likewise) is intentional: it is the key information without extra<br>
redundancy; it is provided statically from the program structure, instead of<br>
doing Term.fastype_of again at run-time (like your mk_term antiquotation).<br>
That operation is actually called "fastype_of", because re-checking the type<br>
of a term is very slow, but here a few extra checks are omitted compared to<br>
full Term.type_of (this works under the assumption that the term is well-typed).</p>
<p>If we do manage to brush-up our thinking and working with types and terms, we<br>
could get a somewhat smoother system within a few years. See also the thread<br>
on locale performance opened by Norber Schirmer<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2021-September/msg00034.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2021-September/msg00034.html</a></p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="255370011"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/255370011" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#255370011">(Sep 29 2021 at 09:43)</a>:</h4>
<p>From: Florian Haftmann &lt;<a href="mailto:florian.haftmann@informatik.tu-muenchen.de">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>
Excellent!</p>
<p>The abstraction form syntax is not so trivial to grasp, maybe one<br>
example coulde be added to the NEWS, e. g.</p>
<p>val dest_add_nat = \&lt;^Const_fn&gt;‹Groups.plus \&lt;^Type&gt;‹nat› for a b =&gt;<br>
‹(a, b)››</p>
<p>Florian<br>
<a href="/user_uploads/14278/MQdBamWAqWBJFGctkLzhm2o4/OpenPGP_signature">OpenPGP_signature</a></p>



<a name="255371820"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/255371820" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#255371820">(Sep 29 2021 at 09:58)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
In Isabelle/b9331caf92c3, I have updated the above examples using<br>
Type_fn/Const_fn (they were from an earlier stage, before these extra<br>
antiquotations).</p>
<p>Also note that in Isabelle/e585e5a906ba, I have tune the syntax to allow the<br>
\&lt;^Type&gt;‹nat› in your example stand on its own, without an extra cartouche<br>
around it.</p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="255374410"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/255374410" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#255374410">(Sep 29 2021 at 10:20)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Update for Isabelle/e585e5a906ba:</p>
<p>theory Scratch<br>
  imports Refine_Imperative_HOL.Sepref_Rules Refine_Imperative_HOL.Sepref_Monadify<br>
begin</p>
<p>ML ‹<br>
  fn p =&gt; fn t' =&gt;<br>
    @{mk_term "Refine_Basic.bind$(RETURN$(COPY$?p))$?t'"}›</p>
<p>ML ‹<br>
  fn A =&gt; fn B =&gt; fn p =&gt; fn t' =&gt;<br>
    \&lt;^Const&gt;‹Refine_Basic.bind A B for<br>
      \&lt;^Const&gt;‹RETURN A for \&lt;^Const&gt;‹COPY A for p›› t'›<br>
›</p>
<p>end</p>
<p>Thus it is a bit more concise and to the point: no extra nesting of cartouches.</p>
<p>Are there any remaining uses of your alternative antiquotations that are not<br>
covered properly by the new official scheme?</p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="255854524"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/255854524" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#255854524">(Oct 02 2021 at 08:51)</a>:</h4>
<p>From: Norbert Schirmer &lt;<a href="mailto:nschirmer@apple.com">nschirmer@apple.com</a>&gt;<br>
In AutoCorres there are also alternative antiquotations for matching and building terms, similar to the ones presented by Peter:<br>
<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy</a> &lt;<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy</a>&gt;<br>
<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy</a> &lt;<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy</a>&gt;<br>
<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy</a> &lt;<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy</a>&gt;<br>
<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy</a> &lt;<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy</a>&gt;</p>
<p>Also I see great potential for providing similar antiquotations also for cterms, offering the possibility to ‘match’ sub-cterms and build cterms from certified sub-cterms. In contrast to terms also the matching part will result in a matching function, as cterms are an abstract data type.</p>
<p>In my experience recertifying cterms in proof tools like simprocs or tactics can easily become a performance hot-spot when terms become large.</p>
<p>As taking apart and recombining cterms manually with functions like Thm.dest_comb / Thm.apply is quite verbose and hard to maintain it rarely is used in practise. Instead terms are decomposed by ML-matching, recombined and recertified. In the presence of your new antiquotations this idiom is likely to become even more attractive and commonplace. </p>
<p>Having antiquotations for cterms can be a powerful show-case for the potential of antiquotations, bringing together readability / conciseness as well as scalability.</p>
<p>Regards,<br>
Norbert</p>



<a name="257437799"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/257437799" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#257437799">(Oct 13 2021 at 21:05)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 02/10/2021 10:51, Norbert Schirmer wrote:</p>
<blockquote>
<p>In AutoCorres there are also alternative antiquotations for matching and<br>
building terms, similar to the ones presented by Peter:<br>
<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy</a><br>
<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy</a><br>
<a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy</a> &gt; <a href="https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy</a></p>
</blockquote>
<p>I have looked through this a bit, with the same questions in mind: What are<br>
the remaining uses of these @{mk_term} and @{term_pat} antiquotations? Would<br>
these antiquotations be introduced today, as replacement or improvement over<br>
the new \&lt;^Type&gt; and \&lt;^Const&gt; forms?</p>
<p>My impressions so far:</p>
<p>* @{term_pat} is potentially more relevant, but hardly used in that code<br>
base at all. Most applications are actually tests, to demonstrate what it is<br>
supposed to be. It could be very easily eliminated and simplified, using the<br>
new antiquotations from Isabelle2021-1.</p>
<p>* @{mk_term} has more actual applications, but about 30% very basic that<br>
could be done with the same amount of text with \&lt;^Type&gt; and \&lt;^Const&gt;; 30%<br>
involve relatively complex terms like this:</p>
<p>@{mk_term "ran (RangeMap.lookup_range_tree ?tree)" (tree)} tree_const<br>
  |&gt; Thm.cterm_of ctxt</p>
<p>It might be actually better to produce a closed @{cterm} with lambdas inside,<br>
and use cterm application in ML --- it would avoid rechecking the whole cterm.</p>
<p>Moreover, the antiquotation itself contains hidden Term.fastype_of: another<br>
relatively costly operation (for complex terms).</p>
<p>The whole point of the new \&lt;^Const&gt; antiquotation is to cultivate a view of<br>
Consts.typargs almost everywhere, with very little recomputation of types for<br>
subterms (no more Term.fastype_of).</p>
<p>This technique also has the potential to simplify the ML source complexity, at<br>
least in the most common cases. Sometimes there are tough situations seen in<br>
the wild, where ML operates in rather non-standard ways on terms, like working<br>
morally ill-typed constants.</p>
<blockquote>
<p>Also I see great potential for providing similar antiquotations also for<br>
cterms, offering the possibility to ‘match’ sub-cterms and build cterms from<br>
certified sub-cterms. In contrast to terms also the matching part will result<br>
in a matching function, as cterms are an abstract data type.</p>
<p>In my experience recertifying cterms in proof tools like simprocs or tactics<br>
can easily become a performance hot-spot when terms become large.</p>
</blockquote>
<p>That is a separate concern, independent of the question of concrete term<br>
syntax vs. abstract ML syntax.</p>
<p>We do waste a lot in frequent ctyp_of/cterm_of operations, but doing it<br>
differently is quite a lot of work.</p>
<p>Also note that the cterm destructors are not for free either. In particular,<br>
Thm.dest_abs needs to replace a de-Bruijn Bound by a fresh Free. Over the<br>
years I have fine-tuned this a lot, with measurable impact; the latest update<br>
is here:<br>
<a href="https://isabelle.sketis.net/repos/isabelle/annotate/21a20b990724/src/Pure/term.ML#l966">https://isabelle.sketis.net/repos/isabelle/annotate/21a20b990724/src/Pure/term.ML#l966</a></p>
<p>(Staring at this again, I immediately see further potential for improvement,<br>
like an explicit Name.context as argument, taken from the implicit<br>
Proof.context of the application.)</p>
<blockquote>
<p>As taking apart and recombining cterms manually with functions like<br>
Thm.dest_comb / Thm.apply is quite verbose and hard to maintain it rarely is<br>
used in practise. Instead terms are decomposed by ML-matching, recombined and<br>
recertified. In the presence of your new antiquotations this idiom is likely<br>
to become even more attractive and commonplace. </p>
</blockquote>
<p>The state-of-the art is to decompose the Thm.term_of view of cterms and<br>
re-certify. The cost for that is well-known, but could be trimmed down a bit<br>
by treating the types within terms more carefully (or by reducing them via<br>
Consts.typargs as hinted above).</p>
<blockquote>
<p>Having antiquotations for cterms can be a powerful show-case for the potential<br>
of antiquotations, bringing together readability / conciseness as well as<br>
scalability.</p>
</blockquote>
<p>This sounds like marketing-speak.</p>
<p>Note that too much complexity in ML antiquotations can degrade the robustness<br>
and maintainability of ML tools. For example, too much concrete syntax will<br>
lead to surprises after inevitable changes of abbreviations, translations etc.<br>
over the years / decades.</p>
<p>With \&lt;^Type&gt; / \&lt;^Const&gt; everything is clear and well-defined.</p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="257489379"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/257489379" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#257489379">(Oct 14 2021 at 07:07)</a>:</h4>
<p>From: Norbert Schirmer &lt;<a href="mailto:nschirmer@apple.com">nschirmer@apple.com</a>&gt;</p>
<blockquote>
<p>On 13. Oct 2021, at 23:05, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>
<p>My impressions so far:</p>
<ul>
<li>
<p>@{term_pat} is potentially more relevant, but hardly used in that code<br>
base at all. Most applications are actually tests, to demonstrate what it is<br>
supposed to be. It could be very easily eliminated and simplified, using the<br>
new antiquotations from Isabelle2021-1.</p>
</li>
<li>
<p>@{mk_term} has more actual applications, but about 30% very basic that<br>
could be done with the same amount of text with \&lt;^Type&gt; and \&lt;^Const&gt;; 30%<br>
involve relatively complex terms like this:</p>
</li>
</ul>
<p>@{mk_term "ran (RangeMap.lookup_range_tree ?tree)" (tree)} tree_const<br>
 |&gt; Thm.cterm_of ctxt</p>
<p>It might be actually better to produce a closed @{cterm} with lambdas inside,<br>
and use cterm application in ML --- it would avoid rechecking the whole cterm.</p>
<p>Moreover, the antiquotation itself contains hidden Term.fastype_of: another<br>
relatively costly operation (for complex terms).<br>
</p>
</blockquote>
<p>Meanwhile there are many more applications of the two antiquotations.<br>
We plan to release these extensions of the AutoCorres code-base following Isabelle2021-1.</p>
<blockquote>
<p>The whole point of the new \&lt;^Const&gt; antiquotation is to cultivate a view of<br>
Consts.typargs almost everywhere, with very little recomputation of types for<br>
subterms (no more Term.fastype_of).</p>
<p>You are right with the cost of Term.fastype_of. But many use-cases of<br>
@{mk_term} are situations where the term size is under control of the actual code. <br>
There is no additional user-space input coming in. E.g. think of something like the<br>
@{command record} where you have to generate lots of lemmas about <br>
field lookup / update etc. There something like @{mk_term} leads to very readable and compact code<br>
to generate the terms for the propositions.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Having antiquotations for cterms can be a powerful show-case for the potential<br>
of antiquotations, bringing together readability / conciseness as well as<br>
scalability.</p>
</blockquote>
<p>This sounds like marketing-speak.</p>
</blockquote>
<p>What I like about the application here is that the antiquation in a sense stretches the type-system of ML. <br>
What results in a sequence of combinator applications becomes an atomic entity.</p>
<blockquote>
<p>Note that too much complexity in ML antiquotations can degrade the robustness<br>
and maintainability of ML tools. For example, too much concrete syntax will<br>
lead to surprises after inevitable changes of abbreviations, translations etc.<br>
over the years / decades.</p>
<p>With \&lt;^Type&gt; / \&lt;^Const&gt; everything is clear and well-defined.</p>
<p>That is certainly true. The more syntax is involved the more can go wrong. But in my experience with these antiquotation so far this<br>
falls in the category of “benign” issues. Meaning that you will hit the problem quite early. In the best case<br>
already at compile time. Or if that does not work the problem manifests upon every and thus already the first actual usage of the antiquotation.<br>
In those situations the benefits of a readable and concise term overweight.</p>
</blockquote>
<p>Norbert</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="257493639"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/257493639" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#257493639">(Oct 14 2021 at 07:49)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
Hi all.</p>
<blockquote>
<blockquote>
<p>The whole point of the new \&lt;^Const&gt; antiquotation is to cultivate<br>
a view of<br>
Consts.typargs almost everywhere, with very little recomputation of<br>
types for<br>
subterms (no more Term.fastype_of).</p>
<p>You are right with the cost of Term.fastype_of. But many use-cases of<br>
@{mk_term} are situations where the term size is under control of the<br>
actual code. <br>
There is no additional user-space input coming in. E.g. think of<br>
something like the<br>
@{command record} where you have to generate lots of lemmas about <br>
field lookup / update etc. There something like @{mk_term} leads to<br>
very readable and compact code<br>
to generate the terms for the propositions.</p>
</blockquote>
</blockquote>
<p>I'm also, in many cases, in favour of clear and readable code over<br>
efficient and less readable. (That's the reason why we use functional<br>
programming for Isabelle, in first place!)</p>
<blockquote>
<blockquote>
<blockquote>
<p>Having antiquotations for cterms can be a powerful show-case for<br>
the potential<br>
of antiquotations, bringing together readability / conciseness as<br>
well as<br>
scalability.</p>
</blockquote>
<p>This sounds like marketing-speak.</p>
</blockquote>
<p>What I like about the application here is that the antiquation in a<br>
sense stretches the type-system of ML. <br>
What results in a sequence of combinator applications becomes an<br>
atomic entity.</p>
<blockquote>
<p>Note that too much complexity in ML antiquotations can degrade the<br>
robustness<br>
and maintainability of ML tools. For example, too much concrete<br>
syntax will<br>
lead to surprises after inevitable changes of abbreviations,<br>
translations etc.<br>
over the years / decades.</p>
<p>With \&lt;^Type&gt; / \&lt;^Const&gt; everything is clear and well-defined.</p>
<p>That is certainly true. The more syntax is involved the more can go<br>
wrong. But in my experience with these antiquotation so far this<br>
falls in the category of “benign” issues. Meaning that you will hit<br>
the problem quite early. In the best case<br>
already at compile time. Or if that does not work the problem<br>
manifests upon every and thus already the first actual usage of the<br>
antiquotation.<br>
In those situations the benefits of a readable and concise term<br>
overweight.</p>
</blockquote>
</blockquote>
<p>I agree here. </p>
<p>Me, personally, am not yet convinced to switch from the very consise<br>
and high-level mk_term / mpat to the still more verbose and low-level<br>
Type/Const. Obviously, I would like to improve these high-level<br>
concepts, but not at the cost of readability or conciseness, which is<br>
exactly what makes them so appealing.</p>
<p>Peter</p>
<blockquote>
<p>Norbert</p>
</blockquote>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="257495580"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/257495580" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#257495580">(Oct 14 2021 at 08:06)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
The new \&lt;^Type&gt; / \&lt;^Const&gt; antiquotations are designed to be both<br>
efficient in the runtime, and efficient in the source text (readable,<br>
maintainable).</p>
<p>As usual, it is just a matter to get used to a new way of thinking,<br>
which is actually closer to the old way of direct use of datatype<br>
constructors.</p>
<p>Moreover, the treatment of type arguments is much more concise: the term<br>
(patterns) are rather awkward in that respect: both in the text and at<br>
runtime (fastype_of).</p>
<p>This thread was mainly meant to figure out shortcomings that can be<br>
improved further: this often becomes apparent in concrete use, e.g.<br>
while converting an application to the new format.</p>
<p>(Doing that here and there, I did already see another are of reform,<br>
namely "instantiate" forms for thm, cterm, maybe even term.)</p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<a name="257497434"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/257497434" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#257497434">(Oct 14 2021 at 08:22)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
On Thu, 2021-10-14 at 10:06 +0200, Makarius wrote:</p>
<blockquote>
<p>On 14.10.21 09:49, Peter Lammich wrote:</p>
<blockquote>
<p>I'm also, in many cases, in favour of clear and readable code over<br>
efficient and less readable. (That's the reason why we use<br>
functional<br>
programming for Isabelle, in first place!)</p>
</blockquote>
<p>The new \&lt;^Type&gt; / \&lt;^Const&gt; antiquotations are designed to be both<br>
efficient in the runtime, and efficient in the source text (readable,<br>
maintainable).</p>
</blockquote>
<p>but they are clearly less concise than mk_term/pat, at least for some<br>
applications.</p>
<p>The usage of mk_term/pat, and the fact that it has been invented at<br>
least twice independently, indicates that there is some sweet spot<br>
here, which, at least for some use cases, allows a very concise<br>
notation.</p>
<p>This still has some problems in other cases (e.g., treatment of types).<br>
However, this should not be a reason for abandoning this promising<br>
find, but to try to understand it further: in what cases is use of<br>
mk_term/pat adequate, and in what cases do we have to fall back to the<br>
more low-level but robust/general Type/Const. Can we even have both:<br>
the benefit of concise treatment of type arguments AND the benefit of<br>
concise, high-level notation?</p>



<a name="257532419"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/247542-Mirror%3A%20Isabelle%20Development%20Mailing%20List/topic/%5Bisabelle-dev%5D%20NEWS%3A%20ML%20antiquotations%20for%20type%20construct.../near/257532419" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/247542-Mirror:-Isabelle-Development-Mailing-List/topic/.5Bisabelle-dev.5D.20NEWS.3A.20ML.20antiquotations.20for.20type.20construct.2E.2E.2E.html#257532419">(Oct 14 2021 at 13:15)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
All these attempts are rather fragile and incomplete. Over a long time, I used<br>
to tell the story myself, that we should use inner syntax for term patterns<br>
and it never quite worked out.</p>
<p>There are various dimensions in the problem that should not be collapsed:</p>
<p>* Patterns should be considered separately from expressions (but: the new<br>
\&lt;^Type&gt;/\&lt;^Const&gt; antiquotations are so elementary and close to ML that they<br>
can do both).</p>
<p>* Expressions can be easily used with concrete syntax, e.g. a version of<br>
@{term} / @{cterm} / @{thm} combined with instantiation (Thm.instantiate): I<br>
have started to think about that some weeks ago, and might manage to do<br>
something for the release. This will supersede earlier attempts like @{mk_term}.</p>
<p>* Genuine cterms are probably better treated like the core logic does, e.g.<br>
with Thm.match / Thm.first_order_match. Instead of raw decomposition of cterms<br>
(with awkward invention of frees for bounds), regular matching can treat<br>
binders directly.</p>
<p>Makarius</p>
<hr>
<p>isabelle-dev mailing list<br>
<a href="mailto:isabelle-dev@in.tum.de">isabelle-dev@in.tum.de</a><br>
<a href="https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>



<hr><p>Last updated: Jul 15 2022 at 23:21 UTC</p>
</html>