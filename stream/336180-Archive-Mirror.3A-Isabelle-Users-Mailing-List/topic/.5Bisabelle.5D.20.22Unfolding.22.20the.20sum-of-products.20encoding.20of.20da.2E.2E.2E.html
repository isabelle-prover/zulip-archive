<html>
<head><meta charset="utf-8"><title>[isabelle] &quot;Unfolding&quot; the sum-of-products encoding of da... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html">[isabelle] &quot;Unfolding&quot; the sum-of-products encoding of da...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294659147"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659147" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659147">(Aug 22 2022 at 11:54)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;<br>
Hallo,</p>
<p>I have been playing around with some analytic combinatorics lately,<br>
asking questions like ‘How many values are there of a given datatype<br>
with a certain size?’</p>
<p>For this, it is very convenient to view the definition of the algebraic<br>
datatype in terms of a (possibly recursive) sum of products. For<br>
instance, for binary trees, I have the following "encodings":</p>
<p>datatype 'a bintree = Leaf 'a | Node "'a bintree" "'a bintree"</p>
<p>primrec encode_bintree :: "'a bintree ⇒ 'a + 'a bintree × 'a bintree" where<br>
  "encode_bintree (Leaf x) = Inl x"<br>
| "encode_bintree (Node l r) = Inr (l, r)"</p>
<p>fun decode_bintree :: "'a + 'a bintree × 'a bintree ⇒ 'a bintree" where<br>
  "decode_bintree (Inl x) = Leaf x"<br>
| "decode_bintree (Inr (l, r)) = Node l r"</p>
<p>Essentially, I exploit the fact that ‘α bintree’ is a fixed point of<br>
'λα. α + (α bintree)²' and therefore ‘α bintree’ is isomorphic to ‘α + α<br>
bintree × α bintree’.</p>
<p>My question is now: is there an easy way to generate these encode/decode<br>
isomorphisms automatically and prove that they are inverses of one<br>
another? Is there perhaps a similar construction inside the internals of<br>
the datatype package already?</p>
<p>Cheers,</p>
<p>Manuel</p>



<a name="294659156"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659156" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659156">(Aug 22 2022 at 11:54)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Hi Manuel,</p>
<p>The BNF package internally generates such unfolding and folding constants. They are called <br>
ctor_&lt;typename&gt; and dtor_&lt;typename&gt;. Internally, it also proves that they are inverses of <br>
each other, but AFAIK these theorems are only made available if the attribute bnf_note_all <br>
is set at the declaration time of the datatype.</p>
<p>Hope this helps,<br>
Andreas</p>



<a name="294659183"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659183" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659183">(Aug 22 2022 at 11:54)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;<br>
Hi Manuel,</p>
<p>Andreas gave you the most important pointer. Since you seem to be envisioning an ML command for generating them automatically, I suspect you will want to access the ML interfaces of the BNF package directly, and not use "bnf_note_all" (which is mostly useful for debugging and/or for sketching BNF extensions).</p>
<p>The low-level theorems you'd need, e.g. "ctor_dtor", are stored in the BNF (co)datatype database:</p>
<p>ML {*<br>
    BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name bintree}<br>
    |&gt; the<br>
    |&gt; #fp_res<br>
    |&gt; #ctor_dtors<br>
    |&gt; hd<br>
    *}</p>
<p>You might find the code in "~~/src/HOL/Library/bnf_lfp_countable.ML" a useful source of inspiration. The "mk_encode_funs" function constructs a "to_nat" function for a datatype (LFP) from "to_nat" functions about the types on which it depends. If you find that of any interest, I can send you the (more readable) theory files that mock up the construction performed at the ML level.</p>
<p>Incidentally, I'm tempted to rename "ctor" to "in" and "dtor" to "out", in keeping with some of the literature, to avoid any confusion between the actual high-level constructors (called "ctr"s in the code and some theorems) and the low-level constructors. If anybody is against this renaming, please speak out now.</p>
<p>Jasmin</p>



<a name="294659223"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659223" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659223">(Aug 22 2022 at 11:55)</a>:</h4>
<p>From: Dmitriy Traytel &lt;<a href="mailto:traytel@inf.ethz.ch">traytel@inf.ethz.ch</a>&gt;<br>
I am against the renaming. Note that “in” is a keyword in ML and you would need to start decorating the identifiers in the ML code with “x”, “‘“ or “0”. Also in/out are much less symmetric than ctor/dtor. We have actual code that is parametric in the view (there the name xtor is used).</p>
<p>Dmitriy</p>



<a name="294659284"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659284" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659284">(Aug 22 2022 at 11:55)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;</p>
<blockquote>
<p>I am against the renaming. Note that “in” is a keyword in ML and you would need to start decorating the identifiers in the ML code with “x”, “‘“ or “0”.</p>
</blockquote>
<p>We have clashes with many other names, e.g. "rec" (a keyword, or a recursor), "map", "fold" (ML functions one does not want to shadow), even "in"... (Grep "recx", "mapx", "foldx", "inx".) Such clashes, and their crude fix with an "x", are not pretty, but they are a reasonable price to pay for having the right names at the Isar level.</p>
<p>But there is in fact a possible confusion at the ML level, which is much worse than the inelegant "inx": "in" is already used in the code for set membership (\&lt;in&gt;), e.g.</p>
<p>val inx = mk_in Asets sets T;</p>
<p>So maybe statu quo is best for now.</p>
<blockquote>
<p>Also in/out are much less symmetric than ctor/dtor. We have actual code that is parametric in the view (there the name xtor is used).</p>
</blockquote>
<p>"in/out" are semantically very symmetric. I invented "xtor" out of sheer desperation and would happily trade it against "inout" or "io" or even "thru".</p>
<p>Jasmin</p>



<a name="294659329"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659329" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659329">(Aug 22 2022 at 11:55)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;<br>
Thanks, that already looks like pretty much exactly what I want.</p>
<p>Another problem is that I need a kind of parameterised ‘size’ function, <br>
which simply adds together the size of all the contained objects while <br>
ignoring the structure of the datatype itself.</p>
<p>Essentially, for a datatype ‘α foo’ with a single type parameter, the <br>
behaviour should be something like</p>
<p>size_foo sz x = setsum sz (set_foo x)</p>
<p>Or, in other words: I would something that works like datatype's builtin <br>
size_foo, but without counting the structure of the datatype itself. <br>
(e.g. I would the size of ‘[0,0,0]’ to be 0, not 3)</p>
<p>How would I best go about doing something like this generically for <br>
datatypes with arbitrarily many type parameters? This is not a very <br>
urgent question; the above construction with set_foo works fine for one <br>
parameter and one parameter is all I currently need, but it would be <br>
nice to know.</p>
<p>Cheers,</p>
<p>Manuel</p>



<a name="294659347"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659347" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659347">(Aug 22 2022 at 11:55)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;</p>
<blockquote>
<p>size_foo sz x = setsum sz (set_foo x) <br>
Apologies, this is, of course, rubbish – multiple occurrences must, of <br>
course, be counted multiple times!</p>
</blockquote>



<a name="294659360"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659360" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659360">(Aug 22 2022 at 11:55)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Hi Manuel,</p>
<p>There is no generic construction like that at the moment in BNF, but it would be easy to <br>
define. Have you looked at how the existing size function works? For polymorphic types <br>
like 'a list, there is a more general function size_list which takes a size function for <br>
the type argument. The size_list function sums the given function over all elements of a <br>
list and then adds the list structure to it. So if you just want the sum over the <br>
elements, how about using list_size f xs - size xs? Alternatively, you can also copy the <br>
size plugin and change it to produce the function you need.</p>
<p>Of course, this only works for datatypes for which the size plugin can generate size <br>
functions. For example, I have not yet tried whether there is also a size function if the <br>
datatype contains finite sets and multisets.</p>
<p>Best,<br>
Andreas</p>



<a name="294659408"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659408" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659408">(Aug 22 2022 at 11:56)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;<br>
Andreas wrote:</p>
<blockquote>
<p>Of course, this only works for datatypes for which the size plugin can generate size functions. For example, I have not yet tried whether there is also a size function if the datatype contains finite sets and multisets.</p>
</blockquote>
<p>Interesting examples. These actually work, thanks to a hook in the "size" plugin:</p>
<p>HOL$ grep BNF_LFP_Size <em>/</em>thy<br>
Library/FSet.thy:BNF_LFP_Size.register_size_global @{type_name fset} @{const_name size_fset}<br>
Library/Multiset.thy:  BNF_LFP_Size.register_size_global @{type_name multiset} @{const_name size_multiset}</p>
<p>Jasmin</p>



<a name="294659437"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659437" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659437">(Aug 22 2022 at 11:56)</a>:</h4>
<p>From: Lars Hupel &lt;<a href="mailto:hupel@in.tum.de">hupel@in.tum.de</a>&gt;<br>
Hi Jasmin,</p>
<p>this is very nifty, thanks for the hint! Maybe at some point we can use<br>
this to support generic programming à la de Vries &amp; Löh<br>
(&lt;<a href="http://www.andres-loeh.de/TrueSumsOfProducts/TrueSumsOfProducts.pdf">http://www.andres-loeh.de/TrueSumsOfProducts/TrueSumsOfProducts.pdf</a>&gt;).</p>
<p>Cheers<br>
Lars</p>



<a name="294659473"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659473" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659473">(Aug 22 2022 at 11:56)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;</p>
<blockquote>
<p>So if you just want the sum over the elements, how about using <br>
list_size f xs - size xs?</p>
</blockquote>
<p>That's a great idea. It may not be the most elegant solution, but it<br>
sounds pretty foolproof. Thanks!</p>



<a name="294659496"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659496" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659496">(Aug 22 2022 at 11:56)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;<br>
Incidentally, for the record, this would have led to off-by-one bugs with the old datatype package. From "datatypes.pdf":</p>
<p>"The size function has a slightly different definition. The new function returns 1 instead of 0 for some nonrecursive constructors. This departure from the old behavior made it possible to implement size in terms of the generic function t.size_t."</p>
<p>In other words, the old package defined "size" and "size_list" (or rather, back then, "list_size") independently of each other, with some anomalies. IIRC, a constructor like "C 'a" used to count as 0 for "size" (instead of 1 now) and as "1 + f a" (where a is C's argument of type 'a) for "size_list". I thought this was crazy, but experience has shown that the old definition often gave better automation in termination proofs, as the IsaFoR developers discovered when porting their theories to the new package.</p>
<p>Jasmin</p>



<a name="294659516"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659516" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659516">(Aug 22 2022 at 11:56)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
On 18/11/2015 10:01, Jasmin Blanchette wrote:</p>
<blockquote>
<blockquote>
<p>On 18.11.2015, at 09:52, Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>So if you just want the sum over the elements, how about using<br>
list_size f xs - size xs?</p>
</blockquote>
<p>That's a great idea. It may not be the most elegant solution, but it<br>
sounds pretty foolproof.</p>
</blockquote>
<p>Incidentally, for the record, this would have led to off-by-one bugs with the old datatype package. From "datatypes.pdf":</p>
<p>"The size function has a slightly different definition. The new function returns 1 instead of 0 for some nonrecursive constructors. This departure from the old behavior made it possible to implement size in terms of the generic function t.size_t."</p>
</blockquote>
<p>When I read "some" I wondered what that means. Experimentally I found:</p>
<p>datatype t1 = A bool<br>
==&gt; size (A True) = 0</p>
<p>datatype 'a t2 = A 'a<br>
==&gt; size (A True) = 1</p>
<p>I understand why, but I am not convinced this difference in behaviour is <br>
beneficial for users of size.</p>
<blockquote>
<p>In other words, the old package defined "size" and "size_list" (or rather, back then, "list_size") independently of each other, with some anomalies. IIRC, a constructor like "C 'a" used to count as 0 for "size" (instead of 1 now) and as "1 + f a" (where a is C's argument of type 'a) for "size_list". I thought this was crazy, but experience has shown that the old definition often gave better automation in termination proofs, as the IsaFoR developers discovered when porting their theories to the new package.</p>
</blockquote>
<p>I could have told you that because that is one of the reasons for the old <br>
design. Experience, not only doctrine.</p>
<p>Tobias</p>
<blockquote>
<p>Jasmin</p>
<p><a href="/user_uploads/14278/9TH_BRhMbUqk6PPIoPIEK6Mv/smime.p7s">smime.p7s</a></p>
</blockquote>



<a name="294659533"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659533" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659533">(Aug 22 2022 at 11:56)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;</p>
<blockquote>
<p>When I read "some" I wondered what that means. Experimentally I found:</p>
<p>datatype t1 = A bool<br>
==&gt; size (A True) = 0</p>
<p>datatype 'a t2 = A 'a<br>
==&gt; size (A True) = 1</p>
<p>I understand why, but I am not convinced this difference in behaviour is beneficial for users of size.</p>
</blockquote>
<p>Beneficial as opposed to what? Returning 1 in both cases would be even less compatible (esp. for list), and returning 0 in both cases is -- well -- precisely the old behavior, which doesn't have the nice "foolproof" property mentioned by Andreas, and for which I can easily construct an example like yours above that exhibits an odd difference in behavior (which is even less regular and intelligible). And of course, the old way of doing things required two "primrec" definitions instead of one "primrec" and one simple "definition".</p>
<p>If I could go back in time, I'm still not sure if we would go for 100% compatibility with the old package or for the current scheme, but I would have brought it up for discussion on "isabelle-users". I suspect the outcome of the discussion would have been "don't fix it if it ain't broken".</p>
<blockquote>
<blockquote>
<p>In other words, the old package defined "size" and "size_list" (or rather, back then, "list_size") independently of each other, with some anomalies. IIRC, a constructor like "C 'a" used to count as 0 for "size" (instead of 1 now) and as "1 + f a" (where a is C's argument of type 'a) for "size_list". I thought this was crazy, but experience has shown that the old definition often gave better automation in termination proofs, as the IsaFoR developers discovered when porting their theories to the new package.</p>
</blockquote>
<p>I could have told you that because that is one of the reasons for the old design. Experience, not only doctrine.</p>
</blockquote>
<p>I believe you are mistaking lethargy for strategy.</p>
<p>If the old design had been documented in any way, it might have helped me understand it and replicate it. But not only it wasn't documented, the odd behavior looked so much like an oversight (in terms of both behavior and code) that it didn't cross my mind to ask around. Had I realized for one second that there might be a deeper reason for the behavior, I would have not hesitated to bring this up.</p>
<p>If there is a strong consensus in favor of restoring the old behavior, it wouldn't be terribly hard for me to change things to how they used to be. But from what I understand, the porting pains where not very big and are now behind us, and the new behavior is actually useful sometimes (cf. Andreas's solution and Manuel's "foolproof" comment).</p>
<p>Jasmin</p>



<a name="294659647"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659647" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659647">(Aug 22 2022 at 11:57)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
On 18/11/2015 11:56, Jasmin Blanchette wrote:</p>
<blockquote>
<blockquote>
<p>When I read "some" I wondered what that means. Experimentally I found:</p>
<p>datatype t1 = A bool<br>
==&gt; size (A True) = 0</p>
<p>datatype 'a t2 = A 'a<br>
==&gt; size (A True) = 1</p>
<p>I understand why, but I am not convinced this difference in behaviour is beneficial for users of size.</p>
</blockquote>
<p>Beneficial as opposed to what?</p>
</blockquote>
<p>Detrimental. In the above example an abstraction step now changes the behaviour <br>
of size.</p>
<blockquote>
<p>Returning 1 in both cases would be even less compatible (esp. for list), and returning 0 in both cases is -- well -- precisely the old behavior, which doesn't have the nice "foolproof" property mentioned by Andreas, and for which I can easily construct an example like yours above that exhibits an odd difference in behavior (which is even less regular and intelligible).</p>
</blockquote>
<p>I assume by "exhibits an odd difference in behavior" you mean some term <br>
involving both size and size_t? They were never claimed or intended to have a <br>
fixed relationship. You can of course view that as an advantage of the new <br>
definition of size.</p>
<blockquote>
<p>And of course, the old way of doing things required two "primrec" definitions instead of one "primrec" and one simple "definition".</p>
</blockquote>
<p>That is an implementation advantage.</p>
<p>The raison d'etre of the old size function were termination proofs and for those <br>
it works slightly better than the new schema. On the other hand there is the <br>
relationship to size_t that seems to be useful in at least one case. Hence I am <br>
not saying we must go back to the previous definitions. But your argument that <br>
this feature was not documented and seemed crazy to you and that thus you felt <br>
free to change it shows a cavalier attitude towards source code. Let me assume <br>
in your favour that the change had no negative effect in the distribution and <br>
the AFP and that the problems in IsaFor only showed up later.</p>
<p>Tobias</p>
<blockquote>
<p>If I could go back in time, I'm still not sure if we would go for 100% compatibility with the old package or for the current scheme, but I would have brought it up for discussion on "isabelle-users". I suspect the outcome of the discussion would have been "don't fix it if it ain't broken".</p>
<blockquote>
<blockquote>
<p>In other words, the old package defined "size" and "size_list" (or rather, back then, "list_size") independently of each other, with some anomalies. IIRC, a constructor like "C 'a" used to count as 0 for "size" (instead of 1 now) and as "1 + f a" (where a is C's argument of type 'a) for "size_list". I thought this was crazy, but experience has shown that the old definition often gave better automation in termination proofs, as the IsaFoR developers discovered when porting their theories to the new package.</p>
</blockquote>
<p>I could have told you that because that is one of the reasons for the old design. Experience, not only doctrine.</p>
</blockquote>
<p>I believe you are mistaking lethargy for strategy.</p>
<p>If the old design had been documented in any way, it might have helped me understand it and replicate it. But not only it wasn't documented, the odd behavior looked so much like an oversight (in terms of both behavior and code) that it didn't cross my mind to ask around. Had I realized for one second that there might be a deeper reason for the behavior, I would have not hesitated to bring this up.</p>
<p>If there is a strong consensus in favor of restoring the old behavior, it wouldn't be terribly hard for me to change things to how they used to be. But from what I understand, the porting pains where not very big and are now behind us, and the new behavior is actually useful sometimes (cf. Andreas's solution and Manuel's "foolproof" comment).</p>
<p>Jasmin</p>
<p><a href="/user_uploads/14278/AMVrMn9a2ugmUiPZ7eQ-USij/smime.p7s">smime.p7s</a></p>
</blockquote>



<a name="294659694"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659694" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659694">(Aug 22 2022 at 11:57)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;</p>
<blockquote>
<blockquote>
<p>Returning 1 in both cases would be even less compatible (esp. for list), and returning 0 in both cases is -- well -- precisely the old behavior, which doesn't have the nice "foolproof" property mentioned by Andreas, and for which I can easily construct an example like yours above that exhibits an odd difference in behavior (which is even less regular and intelligible).</p>
</blockquote>
<p>I assume by "exhibits an odd difference in behavior" you mean some term involving both size and size_t? They were never claimed or intended to have a fixed relationship.</p>
</blockquote>
<p>If you define type U by nesting through type T, the "size" function of U will depend on "size_T" -- hence there is a connection between the two. The lack of uniformity of the old definition is visible in examples such as</p>
<p>(* with Isabelle2014 *)</p>
<p>datatype 'a x = X 'a</p>
<p>thm x.size</p>
<p>datatype 'a y = Y "'a y x" | Y'</p>
<p>thm y.size</p>
<p>value "size (X Y')"       -- "returns 0"<br>
    value "size (Y (X Y'))"   -- "returns 2"</p>
<blockquote>
<p>But your argument that this feature was not documented and seemed crazy to you and that thus you felt free to change it shows a cavalier attitude towards source code.</p>
</blockquote>
<p>The tone of some of your emails reveals a cavalier attitude towards the people who work or worked for or with you. We have had instances of passive-aggressive emails from your part regarding minor points of datatypes (minor compared with the scale of the whole BNF entreprise), some of it on-list, some off-list. You will remember how this ended. Because you had the courage to apologize, you came out of the deal as an (even) greater man in my eyes than before.</p>
<p>I had reasons to believe this would be the first and last time we would be going into that loop, but alas the same nonconstructive pattern is arising again -- and again in connection with the datatypes.</p>
<p>I would greatly appreciate if you could keep your comments -- whether on-list or off-list -- to objective observations, as opposed to a procès d'intention. I don't know what I've done to you to deserve this; clearly, I must have done something to annoy you, but I doubt it has anything to do with the "size" function. I would appreciate if you could tell it to me frankly off-list rather than through insinuations on-list.</p>
<p>I'm in Nancy this week. You can also pick up the phone if you think this would be more helpful. The phone number is on my web page.</p>
<blockquote>
<p>Let me assume in your favour</p>
</blockquote>
<p>(No comment on this condescending phrase.)</p>
<blockquote>
<p>that the change had no negative effect in the distribution and the AFP</p>
</blockquote>
<p>It had one negative effect on one AFP entry (Fitting), which was nearly trivial to work around.</p>
<blockquote>
<p>and that the problems in IsaFor only showed up later.</p>
</blockquote>
<p>That's correct.</p>
<p>Jasmin</p>



<a name="294659715"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659715" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659715">(Aug 22 2022 at 11:57)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;</p>
<blockquote>
<p>But your argument that this feature was not documented and seemed crazy to you and that thus you felt free to change it shows a cavalier attitude towards source code.</p>
</blockquote>
<p>For the record: I did not change the source code. The code for the new package had to be rewritten from scratch (a few hundred lines), and we had to choose how to design it. Compatibility was a high concern, but I failed to realize that this apparently minor issue would have any impact at all on existing formalizations (failing to think that anything of the form "0 &lt;= ..." is trivial to prove), while leading to (in my eyes) a cleaner approach. Implementing the old approach wouldn't have been harder; but it just felt "uglier" and "wrong". Now I know better.</p>
<p>Overall, we managed to achieve very high levels of backward compatibility and actually pulled it off. The ongoing "Nominal2" vs. "Nominal" is reminder of how hard it is to subsume and replace an existing Isabelle package. We (I) have made bona fide errors along the way, but I think our record is remarkable and deserves more praise than criticism.</p>
<p>Jasmin</p>



<a name="294659725"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659725" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659725">(Aug 22 2022 at 11:57)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Definitely.  I am impressed how the BNF datatype upgrade went through, <br>
while the task was looking bigger and bigger as the years passed by.  One <br>
of the greatest engineering projects since Stonehenge!</p>
<p>Makarius</p>



<a name="294659850"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659850" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659850">(Aug 22 2022 at 11:58)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Dear Jasmin,</p>
<p>The only point I was trying to make is a very general one: In the absence of <br>
external documentation, the source code should be taken seriously or questioned <br>
but not just changed. I am sure we agree on this but in the light of the size <br>
discussion I felt it was worth reemphasizing on the list. No insult intended.</p>
<p>Tobias<br>
<a href="/user_uploads/14278/zvMOUGvkQJNFAzlz0liQW_Ft/smime.p7s">smime.p7s</a></p>



<a name="294659874"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659874" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659874">(Aug 22 2022 at 11:58)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:A.Popescu@mdx.ac.uk">A.Popescu@mdx.ac.uk</a>&gt;<br>
Jasmin wrote:</p>
<blockquote>
<blockquote>
<p>"in/out" are semantically very symmetric. I invented "xtor" out of sheer desperation and would happily trade it against "inout" or "io" or even "thru".</p>
</blockquote>
</blockquote>
<p>I don't have a strong position about these names. Just a historic note: These were initially called "fold" and "unfold," <br>
which I still think are the most accurate names. Of course, they clash with traditional combinator names, and this is why we renounced them.</p>
<p>All the best, <br>
  Andrei </p>
<p>-----Original Message-----<br>
From: Jasmin Blanchette [mailto:jasmin.blanchette@inria.fr] <br>
Sent: 17 November 2015 15:16<br>
To: Dmitriy Traytel<br>
Cc: Manuel Eberl; <a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>; Andrei Popescu<br>
Subject: Re: [isabelle] "Unfolding" the sum-of-products encoding of datatypes</p>
<blockquote>
<p>I am against the renaming. Note that “in” is a keyword in ML and you would need to start decorating the identifiers in the ML code with “x”, “‘“ or “0”.</p>
</blockquote>
<p>We have clashes with many other names, e.g. "rec" (a keyword, or a recursor), "map", "fold" (ML functions one does not want to shadow), even "in"... (Grep "recx", "mapx", "foldx", "inx".) Such clashes, and their crude fix with an "x", are not pretty, but they are a reasonable price to pay for having the right names at the Isar level.</p>
<p>But there is in fact a possible confusion at the ML level, which is much worse than the inelegant "inx": "in" is already used in the code for set membership (\&lt;in&gt;), e.g.</p>
<p>val inx = mk_in Asets sets T;</p>
<p>So maybe statu quo is best for now.</p>
<blockquote>
<p>Also in/out are much less symmetric than ctor/dtor. We have actual code that is parametric in the view (there the name xtor is used).</p>
</blockquote>
<p>"in/out" are semantically very symmetric. I invented "xtor" out of sheer desperation and would happily trade it against "inout" or "io" or even "thru".</p>
<p>Jasmin</p>



<a name="294659892"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%22Unfolding%22%20the%20sum-of-products%20encoding%20of%20da.../near/294659892" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.22Unfolding.22.20the.20sum-of-products.20encoding.20of.20da.2E.2E.2E.html#294659892">(Aug 22 2022 at 11:58)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Tobias already clarified what he was aiming at, but let me chime in to say that I also was impressed with how professionally the new BNF datatypes were introduced and with the prompt support I got from Jasmin and everyone involved to help iron out the few issues it raised in our proofs.</p>
<p>It does deserve praise, I don’t think anyone doubts that.</p>
<p>Cheers,<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>