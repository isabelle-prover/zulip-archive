<html>
<head><meta charset="utf-8"><title>[isabelle] (v2007) Strange lemmas generated by inductive_... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.28v2007.29.20Strange.20lemmas.20generated.20by.20inductive_.2E.2E.2E.html">[isabelle] (v2007) Strange lemmas generated by inductive_...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294053499"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%28v2007%29%20Strange%20lemmas%20generated%20by%20inductive_.../near/294053499" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.28v2007.29.20Strange.20lemmas.20generated.20by.20inductive_.2E.2E.2E.html#294053499">(Aug 18 2022 at 11:03)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:peter.lammich@uni-muenster.de">peter.lammich@uni-muenster.de</a>&gt;<br>
Hi all,</p>
<p>I was porting some code from v2005 to v2007. I encountered just few<br>
problems, I'll describe one of them here, perhaps someone knows if this<br>
behaviour is intended:</p>
<p>I have the following inductive set definitions:</p>
<p>text {* Transitive reflexive closure of labelled transition system *}<br>
inductive_set<br>
  trcl :: "('c<em>'a</em>'c) set \&lt;Rightarrow&gt; ('c<em>'a list</em>'c) set"<br>
  for t<br>
  where<br>
  empty[simp]: "(c,[],c) \&lt;in&gt; trcl t"<br>
  | cons[simp]: "\&lt;lbrakk&gt; (c,a,c') \&lt;in&gt; t; (c',w,c'') \&lt;in&gt; trcl t<br>
\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; (c,a#w,c'') \&lt;in&gt; trcl t"</p>
<p>inductive_set<br>
  foo :: "(('c<em>'c)</em>'a<em>('c</em>'c)) set"<br>
where<br>
  "((s,c),a,(s,c'))\&lt;in&gt;foo"</p>
<p>consts P :: "'a \&lt;Rightarrow&gt; bool"</p>
<p>inductive_set<br>
  bar :: "('c<em>'a list list</em>'c) set"<br>
  where<br>
  "\&lt;lbrakk&gt;((s,c),a,(s',c'))\&lt;in&gt;trcl foo; (s,w,s')\&lt;in&gt;bar\&lt;rbrakk&gt;<br>
\&lt;Longrightarrow&gt; (c,a#w,c')\&lt;in&gt;bar"</p>
<p>foo and bar are just some artifical definitions, the point seems to be,<br>
that the definition of bar contains trcl applied to an LTS over <em>pairs</em>,<br>
while trcl is defined over arbitrary states, not just pairs. The last<br>
definition of bar creates strange induction, intro and elim theorems:<br>
thm bar.intros<br>
(* \&lt;lbrakk&gt;((?s, ?c), ?a, ?s', ?c') \&lt;in&gt; trcl {((xa, x), xd, xc, xb).<br>
((xa, x), xd, xc, xb) \&lt;in&gt; foo}; (?s, ?w, ?s') \&lt;in&gt; bar\&lt;rbrakk&gt;<br>
\&lt;Longrightarrow&gt; (?c, ?a # ?w, ?c') \&lt;in&gt; bar*)</p>
<p>The expression "{((xa, x), xd, xc, xb). ((xa, x), xd, xc, xb) \&lt;in&gt;<br>
foo}" is obviously the same as just "foo", the simplifier knows that, too:</p>
<p>thm bar.intros[simplified]<br>
(* \&lt;lbrakk&gt;((?s, ?c), ?a, ?s', ?c') \&lt;in&gt; trcl foo; (?s, ?w, ?s') \&lt;in&gt;<br>
bar\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; (?c, ?a # ?w, ?c') \&lt;in&gt; bar *)</p>
<p>I would have expected the latter version of the theorems being generated<br>
(as the old inductive package of v2005 did). My current workaround is to<br>
use the simplified attribute or some<br>
    (simp)-steps where the altered definitions cause problems.</p>
<p>My question is: Is this the intended behaviour ? If yes: Why? And can I<br>
get it to generate the simplified lemmas?</p>
<p>regards and thanks in advance for any hints<br>
    Peter</p>



<a name="294053657"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%28v2007%29%20Strange%20lemmas%20generated%20by%20inductive_.../near/294053657" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.28v2007.29.20Strange.20lemmas.20generated.20by.20inductive_.2E.2E.2E.html#294053657">(Aug 18 2022 at 11:04)</a>:</h4>
<p>From: Stefan Berghofer &lt;<a href="mailto:berghofe@in.tum.de">berghofe@in.tum.de</a>&gt;<br>
Peter Lammich wrote:</p>
<blockquote>
<p>Hi all,</p>
<p>I was porting some code from v2005 to v2007. I encountered just few<br>
problems, I'll describe one of them here, perhaps someone knows if this<br>
behaviour is intended:</p>
<p>I have the following inductive set definitions: [...]</p>
<p>foo and bar are just some artifical definitions, the point seems to be,<br>
that the definition of bar contains trcl applied to an LTS over <em>pairs</em>,<br>
while trcl is defined over arbitrary states, not just pairs. The last<br>
definition of bar creates strange induction, intro and elim theorems:<br>
thm bar.intros<br>
(* \&lt;lbrakk&gt;((?s, ?c), ?a, ?s', ?c') \&lt;in&gt; trcl {((xa, x), xd, xc, xb).<br>
((xa, x), xd, xc, xb) \&lt;in&gt; foo}; (?s, ?w, ?s') \&lt;in&gt; bar\&lt;rbrakk&gt;<br>
\&lt;Longrightarrow&gt; (?c, ?a # ?w, ?c') \&lt;in&gt; bar*)</p>
</blockquote>
<p>Hi Peter,</p>
<p>in Isabelle 2007, inductive_set is just a wrapper for the inductive<br>
command, which now defines predicates rather than sets of n-tuples.<br>
This means that the introduction rules specified in an inductive_set<br>
definition are translated to predicate notation internally. Then,<br>
an inductive predicate is defined, and the resulting rules (introduction,<br>
elimination, and induction) are translated back to set notation. In<br>
order to translate a set of n-tuples to a predicate, its "arity" (i.e. the n)<br>
has to be inferred, which is done by inspecting the introduction rules.<br>
Unfortunately, due to the encoding of tuples in Isabelle/HOL, it is<br>
sometimes difficult to find out whether the user wanted to define a<br>
5-ary relation, or a 3-ary relation, whose first and third component is<br>
a pair. In your example, Isabelle infers that the argument t of trcl has<br>
arity 3, whereas the inferred arity for foo is 5. More precisely, the<br>
introduction rules for the predicate trclp corresponding to the set trcl are</p>
<p>trclp t c [] c<br>
   [| t c a c'; trclp t c' w c'' |] ==&gt; trclp t c (a # w) c''</p>
<p>and the introduction rule for the predicate foop corresponding to the<br>
set foo is</p>
<p>foop s c a s c'</p>
<p>Due to this arity mismatch, the conversion back to set notation is only<br>
done in an incomplete way, which leads to the abovementioned "strange"<br>
rules.</p>
<blockquote>
<p>The expression "{((xa, x), xd, xc, xb). ((xa, x), xd, xc, xb) \&lt;in&gt;<br>
foo}" is obviously the same as just "foo", the simplifier knows that, too:</p>
</blockquote>
<p>I'll try to add the required simplification rules to the conversion function<br>
in the development snapshot.<br>
Note that this problem would not have occurred if you had defined foo as follows:</p>
<p>inductive_set<br>
     foo :: "(('c<em>'c)</em>'a<em>('c</em>'c)) set"<br>
   where<br>
     "(sc,a,sc') : foo"</p>
<p>In this case, the arity inferred for foo is the same as the one inferred for<br>
the argument of trcl.</p>
<p>Greetings,<br>
Stefan</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>