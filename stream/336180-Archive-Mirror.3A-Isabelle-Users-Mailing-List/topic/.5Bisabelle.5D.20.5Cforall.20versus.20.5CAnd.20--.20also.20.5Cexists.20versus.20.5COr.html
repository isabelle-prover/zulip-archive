<html>
<head><meta charset="utf-8"><title>[isabelle] \forall versus \And -- also \exists versus \Or · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html">[isabelle] \forall versus \And -- also \exists versus \Or</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294634656"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%5Cforall%20versus%20%5CAnd%20--%20also%20%5Cexists%20versus%20%5COr/near/294634656" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html#294634656">(Aug 22 2022 at 09:14)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
These slightly odd "atomize" and "rulify" things are mainly for internal <br>
use of tools to make them work on regular rule statements given by the <br>
user. When you write statements yourself, you normally do it the way it <br>
works best for you from the start.  Then you don't need to apply <br>
atomize/rulify at all.</p>
<p>With a little bit of practice, it is easy to know what is best: usually an <br>
open rule-format that can be applied readily later on.</p>
<p>This practice is a bit like currying in functional programming: looks odd <br>
to totally new users, but is fairly natural after getting used to it.</p>
<p>Makarius</p>



<a name="294637941"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%5Cforall%20versus%20%5CAnd%20--%20also%20%5Cexists%20versus%20%5COr/near/294637941" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html#294637941">(Aug 22 2022 at 09:35)</a>:</h4>
<p>From: "W. Douglas Maurer" &lt;<a href="mailto:maurer@gwu.edu">maurer@gwu.edu</a>&gt;<br>
(1) I am having trouble understanding why Isar permits both \forall <br>
and \And, seeing that they appear to do exactly the same thing. I <br>
understand that \And is for the statement of a theorem or lemma, and <br>
is not supposed to be used in a proof. But what would happen if we <br>
used \forall in the statement of a lemma, rather than \And? How would <br>
this affect the rest of the proof?<br>
(2) Am I to understand that, just as \And is the universal quantifier <br>
at the meta-level, \Or is the existential quantifier at the <br>
meta-level? Certainly \Or x. P(x) appears to do the same thing as <br>
\exists x. P(x) . Further confusing me here is that a number of <br>
example Isar proof statements do use \exists instead of \Or, such as <br>
lemma assumes Pf: "\exists x. P(f x)" shows "\exists y. P y" (p. 10 <br>
of "A Tutorial Introduction To Structured Isar Proofs").<br>
(3) In Whats In Main, under Orderings, under Syntax, there is given <br>
some syntax for \forall and for \exists, such as \forall x \leq y. P <br>
\equiv \forall x. x \leq y --&gt; P . There are eight rules given here, <br>
four for \forall and four for \exists . Do these rules also work for <br>
\And and \Or ?<br>
(4) Am I understanding correctly that \And applied to the null set is <br>
True, while \Or applied to the null set is False?</p>



<a name="294637947"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%5Cforall%20versus%20%5CAnd%20--%20also%20%5Cexists%20versus%20%5COr/near/294637947" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html#294637947">(Aug 22 2022 at 09:35)</a>:</h4>
<p>From: Lars Noschinski &lt;<a href="mailto:noschinl@in.tum.de">noschinl@in.tum.de</a>&gt;<br>
On 07.04.2015 05:27, W. Douglas Maurer wrote:</p>
<blockquote>
<p>(1) I am having trouble understanding why Isar permits both \forall and<br>
\And, seeing that they appear to do exactly the same thing. I understand<br>
that \And is for the statement of a theorem or lemma, and is not<br>
supposed to be used in a proof. But what would happen if we used \forall<br>
in the statement of a lemma, rather than \And? How would this affect the<br>
rest of the proof?</p>
</blockquote>
<p>The short answer is: Isabelle cannot reason about the HOL quantifiers<br>
(and boolean connectives) directly, only by referring to their<br>
characterisation in terms of the Pure (ore meta) counterparts &lt;\And&gt; and<br>
\&lt;Longrightarrow&gt;.</p>
<p>So for lemmas you want to use into a proof (as opposed to maybe the<br>
final theorem of a large development, which should just read nice),<br>
you express it in terms of the meta operations as much as possible.<br>
Otherwise, you can expect a lot of manual fiddling around, bringing the<br>
theorem into a useful shape everytime you use it (although this depends<br>
on the tools you use: metis for example doesn't care at all).</p>
<p>Some background:</p>
<p>In a way, \&lt;And&gt; is an artifact of Isabelle's Design. Isabelle was<br>
designed as a generic theorem prover which one can use to formalise and<br>
reason in various logics.</p>
<p>As such, Isabelle's kernel knows how to reason about a few primitive<br>
constants, namely:</p>
<p>Pure.all :: ('a =&gt; prop) =&gt; prop (written as \&lt;And&gt;)<br>
  Pure.imp :: prop =&gt; prop =&gt; prop (written as \&lt;Longrightarrow&gt;)</p>
<p>We can use this logical framework (also refered to as Isabelle/Pure)<br>
to formalise a logic (e.g. HOL) by declaring new constants and adding<br>
rules (made from the primitive constants) as axioms (this is called an<br>
"object logic" in Isabelle's notation). So implementing a new logic in<br>
Isabelle does not involve writing code or changing the kernel, but just<br>
writing a few rules in the logical framework.</p>
<p>Now, Isabelle/HOL has its own variants of the above operators,</p>
<p>HOL.All :: ('a =&gt; bool) =&gt; bool (written as \&lt;forall&gt;)<br>
  HOL.implies :: bool =&gt; bool =&gt; bool (written as \&lt;longrightarrow&gt;)</p>
<p>Note the different types and that bool and prop are not isomorphic (as<br>
Isabelle/Pure does not have the law of the exluced middle).</p>
<blockquote>
<p>(2) Am I to understand that, just as \And is the universal quantifier at<br>
the meta-level, \Or is the existential quantifier at the meta-level?</p>
</blockquote>
<p>There is no existential quantifier at the meta level. I'm not sure,<br>
where \&lt;Or&gt; comes from (I don't have a current Isabelle at hand, at the<br>
moment), but \&lt;exists&gt; is the common way to write an existential in<br>
Isabell/HOL.</p>
<blockquote>
<p>(3) In Whats In Main, under Orderings, under Syntax, there is given some<br>
syntax for \forall and for \exists, such as \forall x \leq y. P \equiv<br>
\forall x. x \leq y --&gt; P . There are eight rules given here, four for<br>
\forall and four for \exists . Do these rules also work for \And and \Or ?</p>
</blockquote>
<p>There is no such syntax for \&lt;And&gt;.</p>
<blockquote>
<p>(4) Am I understanding correctly that \And applied to the null set is<br>
True, while \Or applied to the null set is False?</p>
</blockquote>
<p>As HOL types are never empty, \&lt;And&gt; can never be applied "to the null<br>
set". If you talk about "\&lt;forall&gt; x \&lt;in&gt; S. P x", yes, this is true if<br>
S is empty.</p>
<p>-- Lars</p>



<a name="294637970"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%5Cforall%20versus%20%5CAnd%20--%20also%20%5Cexists%20versus%20%5COr/near/294637970" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html#294637970">(Aug 22 2022 at 09:35)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
You should not think of !! as the same as ALL, and ==&gt; as the same as<br>
--&gt; etc.</p>
<p>Just a few notes on this, to overcome common misunderstandings.</p>
<ul>
<li>
<p>Isabelle/Pure is minimal higher-order logic with connectives !! and ==&gt;<br>
   used to describe natural deduction rules declaratively.  The<br>
   Isabelle/Isar proof languages uses the same rule format to produce<br>
   structured proofs.  These concepts are integral to Isabelle, and big<br>
   assets of its approach; schematic variables also belong here.</p>
</li>
<li>
<p>Isabelle/HOL is full higher-order logic with the whole zoo of<br>
   connectives (ALL, EX, --&gt;, &lt;--&gt;, ~ etc.) and much more, to work with<br>
   applications.  HOL statements may occur in Pure rules naturally.</p>
</li>
<li>
<p>The view of Pure as "meta-logic" and HOL as "object-logic" is OK in the<br>
   historical understanding of Isabelle as "logical framework" to declare<br>
   other logics, but it has little practical relevance today.</p>
</li>
<li>
<p>The view of Pure as "rule framework for structured reasoning" is very<br>
   relevant today.  It is the canonical way how I usually explain that to<br>
   beginners.</p>
<p>Makarius</p>
</li>
</ul>



<a name="294638138"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%5Cforall%20versus%20%5CAnd%20--%20also%20%5Cexists%20versus%20%5COr/near/294638138" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html#294638138">(Aug 22 2022 at 09:36)</a>:</h4>
<p>From: Andrew Gacek &lt;<a href="mailto:andrew.gacek@gmail.com">andrew.gacek@gmail.com</a>&gt;<br>
How do schematic variables relate to \And quantified variables? I know<br>
that sometimes I need to use 'case' and sometimes 'case_tac' for<br>
example, but it's not clear to me why I can't freely move a variable<br>
from being \And quantified to being schematic and vice-versa.</p>
<p>-Andrew</p>



<a name="294638150"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%5Cforall%20versus%20%5CAnd%20--%20also%20%5Cexists%20versus%20%5COr/near/294638150" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html#294638150">(Aug 22 2022 at 09:36)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Tue, 7 Apr 2015, Andrew Gacek wrote:</p>
<blockquote>
<p>How do schematic variables relate to \And quantified variables?</p>
</blockquote>
<p>The Pure quantifier !!x. B x provides a local context to B x inside the <br>
language of propositions. When you positively establish !!x. B x as a <br>
fact, the system puts it into a standard form B ?x with schematic x. There <br>
is normally no choice here: if facts with outermost !!x. B x persist, <br>
something is usually wrong somewhere.</p>
<p>Negatively, on the assumption side, the !! quantier is not optional, <br>
according to how the logic works.</p>
<blockquote>
<p>but it's not clear to me why I can't freely move a variable <br>
from being \And quantified to being schematic and vice-versa.</p>
</blockquote>
<p>To develop an intuition about quantifier scoping rules, I recommend to <br>
prove or disprove propositions involving ALL and --&gt; in FOL or HOL (!) and <br>
let "blast" or "iprover" or something else work on that.  Then you <br>
transfer the results mentally to !! and ==&gt; in Pure.</p>
<blockquote>
<p>I know that sometimes I need to use 'case' and sometimes 'case_tac' for <br>
example</p>
</blockquote>
<p>That is a slightly different situation.  If you have a subgoal with local <br>
!! quantification, these goal parameters are not part of the proof <br>
context, so you can't refer to them directly.</p>
<p>Nonetheless case_tac and friends do that unofficially, and until <br>
Isabelle2014 in a rather messy way. In Isabelle2015 this will be much <br>
better, with extra colors to indicate the hidden goal scope that is <br>
involved here.</p>
<p>As part of the Eisbach project, these old dark corners of the system have <br>
become a bit lighter, and we might even get rid of rule_tac, case_tac etc. <br>
eventually. They are stemming from very ancient times, before the proof <br>
context was fully understood.</p>
<p>Makarius</p>



<a name="294638174"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20%5Cforall%20versus%20%5CAnd%20--%20also%20%5Cexists%20versus%20%5COr/near/294638174" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20.5Cforall.20versus.20.5CAnd.20--.20also.20.5Cexists.20versus.20.5COr.html#294638174">(Aug 22 2022 at 09:36)</a>:</h4>
<p>From: "W. Douglas Maurer" &lt;<a href="mailto:maurer@gwu.edu">maurer@gwu.edu</a>&gt;<br>
It looks as though you can always use lemma atomize_all to go back <br>
and forth between !! (that is, \And) and ALL, so you can use <br>
whichever one you need:<br>
lemma atomize_all [atomize]: (!!x. P x) == Trueprop (ALL x. P x )<br>
proof assume !!x. P x then show ALL x. P x ..<br>
next assume ALL x. P x then show !!x. P x by (rule allE) qed<br>
(section 2.2.17 of "Isabelle/HOL --- Higher-Order Logic")</p>
<p>-Douglas</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>