<html>
<head><meta charset="utf-8"><title>[isabelle] 1 year fellowship for a doctoral researcher on... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.201.20year.20fellowship.20for.20a.20doctoral.20researcher.20on.2E.2E.2E.html">[isabelle] 1 year fellowship for a doctoral researcher on...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294064666"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%201%20year%20fellowship%20for%20a%20doctoral%20researcher%20on.../near/294064666" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.201.20year.20fellowship.20for.20a.20doctoral.20researcher.20on.2E.2E.2E.html#294064666">(Aug 18 2022 at 12:17)</a>:</h4>
<p>From: Wim Vanhoof &lt;<a href="mailto:wva@info.fundp.ac.be">wva@info.fundp.ac.be</a>&gt;<br>
(apologies for multiple postings)</p>
<hr>
<p>The University of Namur, Belgium, is seeking a young researcher<br>
(no PhD) for a 1 year research project entitled</p>
<p>"Automatic program analysis for refactoring logic programs".</p>
<p>A short description follows. Interested candidates should send their CV <br>
before September 15, 2008 to Wim Vanhoof (<a href="mailto:wva@info.fundp.ac.be">wva@info.fundp.ac.be</a>).</p>
<hr>
<p>Program refactoring [3] is the process of systematically changing the <br>
structure of a<br>
program without changing its semantics. The goal of refactoring is to <br>
improve the design<br>
of the code after it has been written, in order to facilitate <br>
maintenance (including further<br>
development) of the software. Emerged from the OO and XP communities, <br>
program<br>
refactoring has recently gained attention in the fields of functional <br>
[8] and logic<br>
programming [11]. Within the software engineering community, the process of<br>
refactoring is considered important and has been identified as central <br>
to software<br>
development and maintenance [3].</p>
<p>At the basis of the refactoring process is a catalogue of available <br>
source-to-source<br>
transformations - the so-called refactorings. For each refactoring, a <br>
set of conditions is<br>
specified under which the transformation is correct in the sense that it <br>
preserves the<br>
semantics of the program. The activity of refactoring consists then in <br>
repeatedly searching<br>
through the source code, looking for a code fragment of which the design <br>
could be<br>
improved by a particular refactoring from the catalogue. The refactoring <br>
is subsequently<br>
applied, and the whole process is repeated. Although each transformation <br>
can have an<br>
impact (positive or negative) on the performance of the program, the <br>
primary aim of each<br>
transformation is to improve the readability and maintainability of the <br>
code.<br>
Even if refactoring is basically a manual process that is performed by <br>
the programmer, the<br>
need for automation is recognized due to the time-consuming and <br>
error-prone nature of<br>
the refactoring activity [3, 8, 10]. Although tools do exist that aid <br>
the developer with<br>
performing a particular refactoring on a selected fragment of source <br>
code - an example<br>
being the Refactoring Browser that was developed for Smalltalk [10] - <br>
identifying where<br>
to perform (a particular) refactoring in the code remains essentially a <br>
non-trivial, creative<br>
and therefore manual process.</p>
<p>Although a substantial number of different refactorings has been <br>
identified in the<br>
literature, the primary indication for where to perform refactoring <br>
seems to be the<br>
presence of duplicated code [3]. The notion of duplicated code is not <br>
limited to literally<br>
copied code, but refers to fragments of code that have the same <br>
input/output behaviour.<br>
The goal of refactoring is then to transform the source code in such a <br>
way that the<br>
duplication is removed. This generally requires to extract the <br>
duplicated input/output<br>
behaviour into a new subroutine (be it a method, function or predicate), <br>
which may<br>
require a generalisation of the concerned code fragments and a possible <br>
reorganisation of<br>
the code as a whole [3, 11].</p>
<p>Code duplication can be caused by a number of reasons. First of all, <br>
unfamiliarity of the<br>
developer with the existing code body may result in reimplementation of <br>
routines that<br>
already exist in the application under development. Second, the “copy <br>
and paste”<br>
technique is commonly used when the existing functionality has to be <br>
slightly adapted.<br>
Even if in this case one usually does not end up literally duplicating <br>
input/output<br>
behaviour, the changes introduced by adaptation are usually relatively <br>
minor and a<br>
generalization of the original and the adapted fragments could be often <br>
proposed. Finally,<br>
code duplication might result from a polyvariant program analysis.</p>
<p>The problem of deciding whether two code fragments implement the same <br>
functionality is<br>
well-known to be undecidable. Nevertheless, automatic program analysis <br>
techniques have<br>
been developed, notably in the context of imperative and object-oriented <br>
languages, that<br>
are capable to detect such equivalence under particular circumstances <br>
and within a certain<br>
error margin, e.g. [1, 5, 6, 7, 9]. Also related is the work on <br>
plagiarism detection for<br>
programs written in such languages, e.g. [4, 14, 13].</p>
<p>In this project, we will investigate the automatic detection of <br>
duplicated code in<br>
declarative programming languages, in particular logic programming <br>
languages such as<br>
Prolog and Mercury. Declarative languages allow the developer to program <br>
at a much<br>
higher level of abstraction than it is the case with most imperative <br>
languages. In a<br>
declarative language, one describes properties of the desired solution <br>
rather than the<br>
actual algorithm that should be used to find the solution.</p>
<p>We aim to develop an analysis that allows to find, without user <br>
intervention, duplicated<br>
code fragments into a logic program and we will study if and how the <br>
results of this<br>
analysis can be used to drive a number of refactorings to remove the <br>
unwanted<br>
duplication from the program. These refactorings include predicate <br>
extraction (replacing<br>
duplicated code fragments by a call to a newly defined predicate), the <br>
removal of<br>
predicates implementing the same relation as another predicate and the <br>
generalization of<br>
duplicated code fragments into calls to newly generated higher-order <br>
predicate [11, 12].<br>
The development of such a duplicated code analysis for logic programs, <br>
and its<br>
integration with refactoring, presents some interesting research <br>
opportunities. Firstly, the<br>
declarative nature of logic programs makes it not straightforward to <br>
adapt the methods<br>
developed in an imperative (or object-oriented) setting. Secondly, the <br>
fact that logic<br>
programs have a small and formally well-defined semantics and use an <br>
explicit symbolic<br>
data representation makes the use of advanced analyses possible. <br>
Therefore it might well<br>
be possible to obtain more fine-grained results than is the case for <br>
imperative languages.<br>
Finally, it might be worthwhile to investigate how the developed <br>
analysis could be used in<br>
the context of plagiarism detection for logic programs.</p>
<p>References</p>
<hr>
<p>[1] B. S. Baker. On finding duplication and near-duplication in large <br>
software systems. In Proc. Second<br>
IEEE Working Conference on Reverse Engineering, pages 86-95, July 1995.<br>
[2] F. Degrave and W. Vanhoof. Towards a normal form for Mercury <br>
programs. In A. King, ed. LOPSTR<br>
2007, volume 4915 of Lecture notes in computer science, pages 43-58. <br>
Springer-Verlag, 2007.<br>
[3] M. Fowler, K. Beck, J. Brant, W. Opdyke, and D. Roberts. Refactoring <br>
: Improving the Design of<br>
Existing Code. Object Technology Series. Addison-Wesley, 1999.<br>
[4] S. Horwitz. Identifying the semantic and textual differences between <br>
two versions of a program. ACM<br>
SIGPLAN Notices, 25(6) :234-245, 1990.<br>
[5] T. Kamiya, S. Kusumoto, and K. Inoue. Ccfinder : A multilinguistic <br>
token-based code clone detection<br>
system for large scale source code. IEEE Trans. Software Eng., 28(7): <br>
654-670, 2002.<br>
[6] R. Komondoor and S. Horwitz. Using slicing to identify duplication <br>
in source code. In Static Analysis<br>
Symposium, pages 40-56, 2001.<br>
[7] K. Kontogiannis, R. de Mori, E. Merlo, M. Galler, and M. Bernstein. <br>
Pattern matching for clone and<br>
concept detection. Autom. Softw. Eng., 3(1/2) :77-108, 1996.<br>
[8] H. Li, C. Reinke, and S. Thompson. Tool support for refactoring <br>
functional programs. In J. Jeuring,<br>
editor, ACM SIGPLAN 2003 Haskell Workshop. ACM 2003.<br>
[9] J. Mayrand, C. Leblanc, and E. Merlo. Experiment on the automatic <br>
detection of function clones in a<br>
software system using metrics. In Intl. Conf. on Software Maintenance, <br>
pages 244-253, 1996.<br>
[10] D. Roberts, J. Brant, and R. E. Johnson. A refactoring tool for <br>
Smalltalk. Theory and Practice of Object<br>
Systems (TAPOS), 3(4) :253-263, 1997.<br>
[11] A. Serebrenik, T. Schrijvers and B. Demoen. Improving Prolog <br>
programs: Refactoring for Prolog.<br>
Theory and practice of logic programming (Accepted) 2008.<br>
[12] W. Vanhoof. Searching semantically equivalent code fragments in <br>
logic programs. In S. Etalle, editor,<br>
LOPSTR 2004, volume 3573 of Lecture notes in computer science, pages <br>
1-18. Springer-Verlag, 2005.<br>
[13] J. Winstead and D. Evans. Towards differential program analysis. In <br>
Proceedings of the 2003<br>
Workshop on Dynamic Analysis, 2003.<br>
[14] W. Yang. Identifying syntactic differences between two programs. <br>
Software Practice and Experience,<br>
21(7): 739-755, 1991.</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>