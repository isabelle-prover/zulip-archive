<html>
<head><meta charset="utf-8"><title>[isabelle] 2 new AFP entries · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html">[isabelle] 2 new AFP entries</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294151858"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%202%20new%20AFP%20entries/near/294151858" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html#294151858">(Aug 18 2022 at 19:06)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:gerwin.klein@nicta.com.au">gerwin.klein@nicta.com.au</a>&gt;<br>
[http://afp.sourceforge.net/entries/Refine_Monadic.shtml]<br>
Refinement for Monadic Programs<br>
by Peter Lammich</p>
<p>Abstract:<br>
We provide a framework for program and data refinement in Isabelle/HOL. The framework is based on a nondeterminism-monad with assertions, i.e., the monad carries a set of results or an assertion failure. Recursion is expressed by fixed points. For convenience, we also provide while and foreach combinators.</p>
<p>The framework provides tools to automatize canonical tasks, such as verification condition generation, finding appropriate data refinement relations, and refine an executable program to a form that is accepted by the Isabelle/HOL code generator.</p>
<p>This submission comes with a collection of examples and a user-guide, illustrating the usage of the framework.</p>
<p>[http://afp.sourceforge.net/entries/Dijkstra_Shortest_Path.shtml]<br>
Dijkstra's Shortest Path Algorithm<br>
by Benedikt Nordhoff and Peter Lammich</p>
<p>Abstract:<br>
We implement and prove correct Dijkstra's algorithm for the single source shortest path problem, conceived in 1956 by E. Dijkstra. The algorithm is implemented using the data refinement framework for monadic, nondeterministic programs. An efficient implementation is derived using data structures from the Isabelle Collection Framework.</p>
<p>Cheers,<br>
Gerwin</p>



<a name="294255212"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%202%20new%20AFP%20entries/near/294255212" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html#294255212">(Aug 19 2022 at 12:32)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Two new AFP entries are available from [http://afp.sf.net]:</p>
<p>Gödel's Incompleteness Theorems<br>
by Larry Paulson</p>
<p>Gödel's two incompleteness theorems are formalised, following a careful presentation by Swierczkowski, in the theory of hereditarily finite sets. This represents the first ever machine-assisted proof of the second incompleteness theorem. Compared with traditional formalisations using Peano arithmetic (see e.g. Boolos), coding is simpler, with no need to formalise the notion of multiplication (let alone that of a prime number) in the formalised calculus upon which the theorem is based. However, other technical problems had to be solved in order to complete the argument.</p>
<p>The Hereditarily Finite Sets<br>
by Larry Paulson</p>
<p>The theory of hereditarily finite sets is formalised, following the development of Swierczkowski. An HF set is a finite collection of other HF sets; they enjoy an induction principle and satisfy all the axioms of ZF set theory apart from the axiom of infinity, which is negated. All constructions that are possible in ZF set theory (Cartesian products, disjoint sums, natural numbers, functions) without using infinite sets are possible here. The definition of addition for the HF sets follows Kirby. This development forms the foundation for the Isabelle proof of Gödel's incompleteness theorems, which has been formalised separately.</p>
<p>Enjoy,<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294278636"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%202%20new%20AFP%20entries/near/294278636" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html#294278636">(Aug 19 2022 at 14:33)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Transitive closure according to Roy-Floyd-Warshall<br>
by Makarius Wenzel</p>
<p>This formulation of the Roy-Floyd-Warshall algorithm for the<br>
transitive closure bypasses matrices and arrays, but uses a more direct<br>
mathematical model with adjacency functions for immediate predecessors and<br>
successors. This can be implemented efficiently in functional programming<br>
languages and is particularly adequate for sparse relations.</p>
<p>[http://afp.sf.net/entries/Roy_Floyd_Warshall.shtml]</p>
<p>Noninterference Security in Communicating Sequential Processes<br>
by Pasquale Noce</p>
<p>An extension of classical noninterference security for deterministic<br>
state machines, as introduced by Goguen and Meseguer and elegantly<br>
formalized by Rushby, to nondeterministic systems should satisfy two<br>
fundamental requirements: it should be based on a mathematically precise<br>
theory of nondeterminism, and should be equivalent to (or at least not<br>
weaker than) the classical notion in the degenerate deterministic case.</p>
<p>This paper proposes a definition of noninterference security applying<br>
to Hoare's Communicating Sequential Processes (CSP) in the general case of<br>
a possibly intransitive noninterference policy, and proves the<br>
equivalence of this security property to classical noninterference<br>
security for processes representing deterministic state machines.</p>
<p>Furthermore, McCullough's generalized noninterference security is shown<br>
to be weaker than both the proposed notion of CSP noninterference security<br>
for a generic process, and classical noninterference security for processes<br>
representing deterministic state machines. This renders CSP noninterference<br>
security preferable as an extension of classical noninterference security<br>
to nondeterministic systems.</p>
<p>[http://afp.sf.net/entries/Noninterference_CSP.shtml]</p>
<p>Enjoy!<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294634432"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%202%20new%20AFP%20entries/near/294634432" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html#294634432">(Aug 22 2022 at 09:12)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Relaxing Safely: Verified On-the-Fly Garbage Collection for x86-TSO<br>
by Peter Gammie, Tony Hosking, and Kai Engelhardt</p>
<p>Abstract:<br>
  We use ConcurrentIMP to model Schism, a state-of-the-art real-time<br>
  garbage collection scheme for weak memory, and show that it is safe<br>
  on x86-TSO.</p>
<p>This development accompanies the PLDI 2015 paper of the same name.</p>
<p><a href="http://afp.sf.net/entries/ConcurrentGC.shtml">http://afp.sf.net/entries/ConcurrentGC.shtml</a></p>
<p>Concurrent IMP<br>
by Peter Gammie</p>
<p>Abstract:<br>
  ConcurrentIMP extends the small imperative language IMP with control<br>
  non-determinism and constructs for synchronous message passing.</p>
<p><a href="http://afp.sf.net/entries/ConcurrentIMP.shtml">http://afp.sf.net/entries/ConcurrentIMP.shtml</a></p>
<p>Enjoy!<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294675419"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%202%20new%20AFP%20entries/near/294675419" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html#294675419">(Aug 22 2022 at 13:26)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Two new entries are available at <a href="http://isa-afp.org/">http://isa-afp.org/</a></p>
<p>POSIX Lexing with Derivatives of Regular Expressions<br>
by Fahad Ausaf, Roy Dyckhoff, and Christian Urban</p>
<p>Brzozowski introduced the notion of derivatives for regular<br>
expressions. They can be used for a very simple regular expression<br>
matching algorithm. Sulzmann and Lu cleverly extended this algorithm<br>
in order to deal with POSIX matching, which is the underlying<br>
disambiguation strategy for regular expressions needed in lexers. In<br>
this entry we give our inductive definition of what a POSIX value is<br>
and show (i) that such a value is unique (for given regular expression<br>
and string being matched) and (ii) that Sulzmann and Lu's<br>
algorithm always generates such a value (provided that the regular<br>
expression matches the string). We also prove the correctness of an<br>
optimised version of the POSIX matching algorithm.</p>
<p>Cardinality of Equivalence Relations<br>
by Lukas Bulwahn</p>
<p>This entry provides formulae for counting the number of equivalence<br>
relations and partial equivalence relations over a finite carrier set<br>
with given cardinality.  To count the number of equivalence relations,<br>
we provide bijections between equivalence relations and set<br>
partitions, and then transfer the main results of the two AFP entries,<br>
Cardinality of Set Partitions and Spivey's Generalized Recurrence<br>
for Bell Numbers, to theorems on equivalence relations. To count the<br>
number of partial equivalence relations, we observe that counting<br>
partial equivalence relations over a set A is equivalent to counting<br>
all equivalence relations over all subsets of the set A. From this<br>
observation and the results on equivalence relations, we show that the<br>
cardinality of partial equivalence relations over a finite set of<br>
cardinality n is equal to the n+1-th Bell number.</p>
<p>Enjoy!<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294675909"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%202%20new%20AFP%20entries/near/294675909" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html#294675909">(Aug 22 2022 at 13:28)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Two new entries are available from <a href="https://isa-afp.org">https://isa-afp.org</a> :</p>
<p>Category Theory with Adjunctions and Limits<br>
by Eugene W. Stark</p>
<p>This article attempts to develop a usable framework for doing category theory in Isabelle/HOL. Our point of view, which to some extent differs from that of the previous AFP articles on the subject, is to try to explore how category theory can be done efficaciously within HOL, rather than trying to match exactly the way things are done using a traditional approach. To this end, we define the notion of category in an "object-free" style, in which a category is represented by a single partial composition operation on arrows. This way of defining categories provides some advantages in the context of HOL, including the ability to avoid the use of records and the possibility of defining functors and natural transformations simply as certain functions on arrows, rather than as composite objects. We define various constructions associated with the basic notions, including: dual category, product category, functor category, discrete category, free category, functor composition, and horizontal and vertical composite of natural transformations. A "set category" locale is defined that axiomatizes the notion "category of all sets at a type and all functions between them," and a fairly extensive set of properties of set categories is derived from the locale assumptions. The notion of a set category is used to prove the Yoneda Lemma in a general setting of a category equipped with a "hom embedding," which maps arrows of the category to the "universe" of the set category. We also give a treatment of adjunctions, defining adjunctions via left and right adjoint functors, natural bijections between hom-sets, and unit and counit natural transformations, and showing the equivalence of these definitions. We also develop the theory of limits, including representations of functors, diagrams and cones, and diagonal functors. We show that right adjoint functors preserve limits, and that limits can be constructed via products and equalizers. We characterize the conditions under which limits exist in a set category. We also examine the case of limits in a functor category, ultimately culminating in a proof that the Yoneda embedding preserves limits.</p>
<p>Cardinality of Multisets<br>
by Lukas Bulwahn</p>
<p>This entry provides three lemmas to count the number of multisets of a given size and finite carrier set. The first lemma provides a cardinality formula assuming that the multiset's elements are chosen from the given carrier set. The latter two lemmas provide formulas assuming that the multiset's elements also cover the given carrier set, i.e., each element of the carrier set occurs in the multiset at least once.</p>
<p>The proof of the first lemma uses the argument of the recurrence relation for counting multisets. The proof of the second lemma is straightforward, and the proof of the third lemma is easily obtained using the first cardinality lemma. A challenge for the formalization is the derivation of the required induction rule, which is a special combination of the induction rules for finite sets and natural numbers. The induction rule is derived by defining a suitable inductive predicate and transforming the predicate's induction rule.</p>
<p>Enjoy!</p>
<p>Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294691279"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%202%20new%20AFP%20entries/near/294691279" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.202.20new.20AFP.20entries.html#294691279">(Aug 22 2022 at 14:17)</a>:</h4>
<p>From: <a href="mailto:Gerwin.Klein@data61.csiro.au">Gerwin.Klein@data61.csiro.au</a><br>
There are two new entries available in the AFP:</p>
<p>Source Coding Theorem<br>
by Quentin Hibon and Lawrence Paulson</p>
<p>This document contains a proof of the necessary condition on the code<br>
  rate of a source code, namely that this code rate is bounded by the<br>
  entropy of the source. This represents one half of Shannon's source<br>
  coding theorem, which is itself an equivalence.</p>
<p><a href="https://www.isa-afp.org/entries/Source_Coding_Theorem.shtml">https://www.isa-afp.org/entries/Source_Coding_Theorem.shtml</a></p>
<p>A formal model for the SPARCv8 ISA and a proof of non-interference for the LEON3 processor<br>
by Zhe Hou, David Sanan, Alwen Tiu, and Yang Liu</p>
<p>We formalise the SPARCv8 instruction set architecture (ISA) which is<br>
  used in processors such as LEON3. Our formalisation can be specialised<br>
  to any SPARCv8 CPU, here we use LEON3 as a running example. Our model<br>
  covers the operational semantics for all the instructions in the<br>
  integer unit of the SPARCv8 architecture and it supports Isabelle code<br>
  export, which effectively turns the Isabelle model into a SPARCv8 CPU<br>
  simulator. We prove the language-based non-interference property for<br>
  the LEON3 processor.  Our model is based on deterministic monad, which<br>
  is a modified version of the non-deterministic monad from NICTA/l4v.</p>
<p><a href="https://www.isa-afp.org/entries/SPARCv8.shtml">https://www.isa-afp.org/entries/SPARCv8.shtml</a></p>
<p>Enjoy!<br>
Gerwin</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>