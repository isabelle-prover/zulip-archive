<html>
<head><meta charset="utf-8"><title>[isabelle] AFM09 Program and Abstracts · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20AFM09.20Program.20and.20Abstracts.html">[isabelle] AFM09 Program and Abstracts</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294078620"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20AFM09%20Program%20and%20Abstracts/near/294078620" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20AFM09.20Program.20and.20Abstracts.html#294078620">(Aug 18 2022 at 13:38)</a>:</h4>
<p>From: Sam Owre &lt;<a href="mailto:owre@csl.sri.com">owre@csl.sri.com</a>&gt;<br>
Fourth Workshop on Automated Formal Methods<br>
       (<a href="http://fm.csl.sri.com/afm09">http://fm.csl.sri.com/afm09</a>)<br>
       In association with CAV 2009 (<a href="http://www-cav2009.imag.fr/">http://www-cav2009.imag.fr/</a>)<br>
         June 27, 2009<br>
         Grenoble, France</p>
<p>9:00   :  Empty (SPIN has invited talk by Joseph Sifakis;<br>
                 RV has invited talk by Sriram Rajamani)</p>
<p>10:30  :  Alwyn Goodloe, Corina Pasareanu, David Bushnell and Paul Miner.<br>
          A Test Generation Framework for Distributed Fault-Tolerant<br>
          Algorithms<br>
10:55  :  Luca Chiarabini.<br>
          Automatic Synthesis of an Efficient Algorithm for the<br>
      Similarity of Strings Problem<br>
11:20  :  Anduo Wang and Boon Thau Loo.<br>
          Formalizing Meta-Routing in PVS<br>
11:45  :  Hassen Saidi<br>
          Challenges in analyzing binary programs (Invited tutorial)</p>
<p>12:30  :  Lunch</p>
<p>2:00   :  Susanne Graf<br>
          Contracts for the component-based design of embedded and<br>
          distributed systems (Invited tutorial)<br>
2:45   :  Bernhard Steffen<br>
          Continuous Model.Driven Engineering -<br>
        Formal Methods at the Application  (Invited tutorial)<br>
3:30   :  Coffee<br>
4:00   :  Ilya Lopatkin, Daniel Plagge, Alexei Iliasov, Michael Leuschel and<br>
             Alexander Romanovsky.<br>
      SAL, Kodkod, and BDDs for Validation of B Models<br>
4:25   :  Silvio Ghilardi and Silvio Ranise<br>
          Model-Checking Modulo Theories at Work: The integration of Yices<br>
          in MCMT<br>
4:50   :  Jean-Francois Couchot, Alain Giorgetti and Nicolas Stouls<br>
          Graph-based Reduction of Program Verification Conditions<br>
5:15   :  Jean-Francois Filliatre<br>
          Why - an intermediate language for deductive program verification<br>
        (Invited tutorial)<br>
6:00   :  Close of Workshop</p>
<p>Abstracts<br>
Title: Challenges in analyzing binary programs<br>
Speaker: Hassen Saidi (SRI Computer Science Laboratory)</p>
<p>Abstract: Program analysis is an enough challenging task<br>
when source code is available. It is even more challenging when<br>
neither the source code nor debug information is present.  The<br>
analysis task is further hindered when the available<br>
binary code has been obfuscated to prevent the analysis from being<br>
carried out.  In this presentation, we review the main challenges when<br>
analyzing binary programs and explore techniques for recovery of<br>
information that allows program understanding and<br>
reverse-engineering. We illustrate these techniques on the Conficker<br>
worm that has plagued the Internet in the past few months.</p>
<p>Title: Contracts for the component-based design of embedded and distributed<br>
       systems <br>
Speaker: Susanne Graf</p>
<p>Abstract: Distributed, real-time and embedded systems usually multiple<br>
layers from the high-level functional layers down to the interaction with<br>
hardware. The design of such systems leads to complex hierachical<br>
architectures with components subject to multiple constraints.  The BIP<br>
composition operators allow specifying complex multi-party interactions<br>
between components in a hierarchical fashion, and by separating component<br>
behaviour and interaction between components. It is expressive enough to<br>
describe the interaction of a set of peers so as to abstract lower layers as<br>
composition operator represented by a set of connectors and their<br>
interactions.  We define a notion of contract associated with components<br>
which strictly separates an expectation which it may have on the<br>
environment, called &lt;&lt;assumption&gt;&gt;, and a &lt;&lt;promise&gt;&gt; which is behaviour of<br>
the component under consideration that the environment may take for granted<br>
as long as it respects the component's expectation. Contrary to most notions<br>
of contracts, it does not express the assumptions directly on the<br>
component's interface but as a constraint on it's peers to which it is<br>
connected by a rich connectors as in BIP.  We do not intend contracts to be<br>
used for compositional verification but rather for compositional design and<br>
independent implementation of components. Assumptions allow simplifying<br>
component implementations by relying on properties ensured by the<br>
environment. An interesting of our kind of contracts is to allow expressing<br>
also assumptions which need not to be expressible on the component's<br>
interface. This means that the component interfaces need not to be<br>
"artificially" enriched with analysis related attributes. Moreover,<br>
knowledge about peers and about lower layers is clearly separated, and<br>
specifications of lower layers, represented by a set of connectors, may be<br>
refined independently of components.  So far, we have shown that this<br>
general contract framework is indeed a generalisation of all existing<br>
notions of interface specifications or contracts that we have studied and<br>
proposed some general methodology. Here, we propose also a set of useful<br>
concepts which can be used to actually express contracts for components<br>
which must comply to safey and progress constraints.</p>
<p>Title: Continuous Model.Driven Engineering - Formal Methods at the<br>
       Application Level <br>
Speaker: Bernhard Steffen</p>
<p>Abstract: Agility is a must, in particular for business-critical<br>
applications.  Complex systems and processes must be continuously updated in<br>
order to meet the ever changing market conditions. Continuous Model Driven<br>
Engineering addresses this need by by continuously involving the<br>
customer/application expert throughout the whole systems? life cycle<br>
including maintenance and evolution. Conceptually, it is based on the One<br>
Thing Approach (OTA), which combines the simplicity of the waterfall<br>
development paradigm with a maximum of agility. The key to OTA is to view<br>
the whole development process simply as a complex hierarchical and<br>
interactive decision process, where each stakeholder, including the<br>
application expert, is allowed to continuously place his/her decisions in<br>
term of constraints. Thus semantically, at any time, the state of the<br>
development or evolution process can simply be regarded as the current set<br>
of constraints, and each development or evolution step can be regarded<br>
simply as a transformation of this very constraint set. This approach,<br>
conceptually, allows one 1) to monitor globally and at any time the<br>
consistency of the development or evolution process simply via constraint<br>
checking, and 2) to impose a kind of decision hierarchy by mapping areas of<br>
ompetencies to roles of individuals, in order to identify required actions<br>
in case of constraint violation. The essence and power of this approach,<br>
which is technically supported by the jABC development and execution<br>
framework, will be illustrated along real life application scenarios.</p>
<p>Title: Why - an intermediate language for deductive program verification<br>
Speaker: Jean Christophe Filliatre</p>
<p>Abstract: This tutorial is an introduction to the Why tool, an intermediate<br>
language for deductive program verification. The purpose of the Why tool is<br>
two-fold: first, it computes weakest preconditions for a small alias-free<br>
programming language, which is designed to be the target of other<br>
verification tools for languages such as C or Java; second, it translates<br>
verification conditions into the native languages of several existing<br>
theorem provers, either automatic such as Simplify, Alt-Ergo, Yices, Z3,<br>
etc. or interactive such as Coq, PVS, Isabelle, etc. Why is currently used<br>
in several verification frameworks such as Caduceus, Krakatoa, or Frama-C.</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>