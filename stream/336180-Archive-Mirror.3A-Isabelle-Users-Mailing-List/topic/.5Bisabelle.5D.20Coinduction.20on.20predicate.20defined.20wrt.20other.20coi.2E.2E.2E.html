<html>
<head><meta charset="utf-8"><title>[isabelle] Coinduction on predicate defined wrt other coi... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Coinduction.20on.20predicate.20defined.20wrt.20other.20coi.2E.2E.2E.html">[isabelle] Coinduction on predicate defined wrt other coi...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294733748"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Coinduction%20on%20predicate%20defined%20wrt%20other%20coi.../near/294733748" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Coinduction.20on.20predicate.20defined.20wrt.20other.20coi.2E.2E.2E.html#294733748">(Aug 22 2022 at 17:24)</a>:</h4>
<p>From: "C.A. Watt" &lt;<a href="mailto:caw77@cam.ac.uk">caw77@cam.ac.uk</a>&gt;<br>
Hi Andreas</p>
<p>Thanks for your detailed answer! It was a steep learning curve, but I <br>
now have the proofs I want. The secret ingredient was the function using <br>
Hilbert choice in the style of the JinjaThreads Runs_into_Runs_table.</p>
<p>Thanks again for your help!</p>
<p>Best wishes<br>
Conrad</p>



<a name="294736474"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Coinduction%20on%20predicate%20defined%20wrt%20other%20coi.../near/294736474" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Coinduction.20on.20predicate.20defined.20wrt.20other.20coi.2E.2E.2E.html#294736474">(Aug 22 2022 at 17:39)</a>:</h4>
<p>From: "C.A. Watt" &lt;<a href="mailto:caw77@cam.ac.uk">caw77@cam.ac.uk</a>&gt;<br>
Hello</p>
<p>I've been attempting some coinductive proofs, and I've hit a situation <br>
where I'm not sure to proceed. Any help would be greatly appreciated. <br>
I've tried to make the situation as abstract as possible in the attached <br>
theory file.</p>
<p>In this setting, I have a predicate P defined in terms of two <br>
coinductive predicates. I would like to be able to perform coinduction <br>
on it. I can define a variant of P, P_co, directly as a coinduction, <br>
effectively unfolding the two underlying predicates simultaneously, and <br>
this allows me to prove everything I want to coinductively.</p>
<p>In other areas of my proof, I would strongly prefer to use P's <br>
representation. I want to either derive a coinduction rule for P so that <br>
I no longer need P_co, or to prove that P_co implies P, whichever is <br>
easier. However I've not been able to complete either proof.</p>
<p>I imagine this has some relation to the discussion/solutions presented <br>
below, but I've not been able to follow through the connection myself.<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-November/msg00045.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-November/msg00045.html</a><br>
<a href="https://isabelle.in.tum.de/dist/Isabelle2017/doc/corec.pdf">https://isabelle.in.tum.de/dist/Isabelle2017/doc/corec.pdf</a></p>
<p>Thanks in advance for any comments or suggestions. I'm new to <br>
coinduction in Isabelle (and in general), so apologies if there is <br>
something fundamental that I've missed.</p>
<p>Best wishes<br>
Conrad Watt<br>
<a href="/user_uploads/14278/M35M64Odx6scmau-0bhIaIL0/Test_Coinduction.thy">Test_Coinduction.thy</a></p>



<a name="294736487"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Coinduction%20on%20predicate%20defined%20wrt%20other%20coi.../near/294736487" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Coinduction.20on.20predicate.20defined.20wrt.20other.20coi.2E.2E.2E.html#294736487">(Aug 22 2022 at 17:39)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt;<br>
Dear Conrad,</p>
<p>Let me first summarize how I understand your abstract example. transition describes a <br>
transition system between states, and state_abs is an abstraction function on states. <br>
abs_equiv is a relation on abstract states (possibly an equivalence relation).</p>
<p>The relation abs_trace associates with a start state all complete runs of the transition <br>
system starting in this state, as a sequence of abstracted states. P is then the relation <br>
composition of the abs_trace relation with the lifted abs_equiv relation.</p>
<p>All the functions and predicates in here are "primitively corecursive" in that they only <br>
peel off one constructor at a time. So you don't need coinduction upto friends here. I'd <br>
recommend to actually split the abs_trace definition into two. (Warning: I haven't worked <br>
out the following in detail; it's just a sketch.)</p>
<ol>
<li>
<p>Define a relation "trace" from states to complete runs of concrete states. Then prove that</p>
<p>trace s l' ==&gt; EX l. abs_trace s l &amp; l = lmap state_abs l'</p>
</li>
</ol>
<p>and</p>
<p>abs_trace s l ==&gt; EX l'. trace s l' &amp; l = lmap state_abs l'</p>
<p>For the second implication, you want to define a primitively recursive function that <br>
construct a concrete run from an abstract run using Hilbert choice. In my AFP entry <br>
JinjaThreads, the theory LTS provides a bunch of examples in a similar context, e.g., the <br>
lemma Runs_into_Runs_table.</p>
<ol start="2">
<li>
<p>The property l = lmap state_abs l' is equivalent to saying "llist_all2 (BNF_Def.Grp <br>
UNIV state_abs) l l'". So we have</p>
<p>P s l ==&gt;<br>
 EX l'. trace s l' &amp;<br>
   (llist_all2 (BNF_Def.Grp UNIV state_abs) OO llist_all2 abs_equiv) l l'</p>
</li>
</ol>
<p>and vice versa.</p>
<ol start="3">
<li>
<p>Now, the crucial bit is the lemma llist.rel_Grp. With that, you can transform</p>
<p>llist_all2 (BNF_Def.Grp UNIV state_abs) OO llist_all2 abs_equiv</p>
</li>
</ol>
<p>into</p>
<p>llist_all2 (BNF_Def.Grp UNIV state_abs OO abs_equiv)</p>
<p>i.e., the equivalence closure of the abstraction function. With that characterisation, you <br>
should be able to prove a suitable coinduction rule for starting from trace's.</p>
<p>As I mentioned earlier, my theory LTS in JinjaThreads does many such hops (except for the <br>
llist.rel_Grp part), so you may go and look for some inspiration there.</p>
<p>Hope this helps,<br>
Andreas</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>