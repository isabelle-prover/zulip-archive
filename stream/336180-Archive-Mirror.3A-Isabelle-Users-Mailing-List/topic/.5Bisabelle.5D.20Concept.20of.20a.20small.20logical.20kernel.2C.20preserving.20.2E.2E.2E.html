<html>
<head><meta charset="utf-8"><title>[isabelle] Concept of a small logical kernel, preserving ... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Concept.20of.20a.20small.20logical.20kernel.2C.20preserving.20.2E.2E.2E.html">[isabelle] Concept of a small logical kernel, preserving ...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294713816"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Concept%20of%20a%20small%20logical%20kernel%2C%20preserving%20.../near/294713816" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Concept.20of.20a.20small.20logical.20kernel.2C.20preserving.20.2E.2E.2E.html#294713816">(Aug 22 2022 at 15:44)</a>:</h4>
<p>From: Ken Kubota &lt;<a href="mailto:mail@kenkubota.de">mail@kenkubota.de</a>&gt;<br>
In this discussion on the Isabelle mailing list, I am missing the question<br>
of the correctness of the small logical kernel that should guarantee<br>
the correctness of the whole system.</p>
<p>Currently, the arguments presented so far seem to open up a false alternative<br>
between logically correct (reliable) but small theorem provers (e.g., HOL Zero),<br>
and large and practical but less reliable provers (e.g., Isabelle/HOL):</p>
<blockquote>
<p>The other big provers (e.g. Coq) are similar in this respect. […]<br>
HOL-Zero is a notable exception in targeting a market of potentially<br>
malicious (ab-)users, but it is not a "big prover".<br>
According to this idea, any reliable prover/checker must be small,<br>
and any practical (and hence, large) prover isn't reliable.<br>
But the concept of a small logical kernel that guarantees<br>
the correctness of the whole system states exactly the opposite,<br>
i.e., no matter how large and practical the software is, it remains reliable.</p>
</blockquote>
<p>This concept is given up in arguments like</p>
<blockquote>
<p>We do not have to work on the basis that "X has been proved, therefore X is true", but rather "We have been given a proof of X; Is it credible?" <br>
which even seems to rhetorically downplay a desirable must-have (correctness)<br>
as an annoying impediment to get rid of ("do not have to work on the basis").<br>
In particular, transferring the responsibility for providing reliability (correctness)<br>
from (verifying) the small logical kernel to either examining specific parts of<br>
the formalized proof or estimating the credibility of the supplying person is questionable,<br>
as even the best mathematicians from time to time fail at complex proofs:<br>
Then we can look at any part of this proof where we have doubts. […]</p>
</blockquote>
<blockquote>
<p>The effort we choose to invest in this would depend on how important X is and how much we distrust the person who supplied the proof.</p>
</blockquote>
<p>I do not see any alternative to providing a correct small logical kernel.</p>
<p>Preserving logical dependencies is part of (has to be guaranteed by) the logical kernel.<br>
For this reason, I consider the following phenomenon as highly problematic<br>
(and even as a failure of the logical kernel):</p>
<blockquote>
<blockquote>
<p>found this originally, but you can hide the ‘taint’ of a theorem by<br>
going through a type class instantiation:<br>
If a conditional can be stripped off so easily, it might be possible to obtain from<br>
different conditionals two contradictory theorems, and hence, an inconsistency.<br>
In a related discussion about this question on the Metamath mailing list I argued<br>
in favor of introducing all non-logical axioms as conditionals (hence, Q0 and R0 have only five axioms)<br>
in order to make the dependency explicit:<br>
Third, the dependency is made explicit. If "the software tracks<br>
axiom usage, as Metamath does", the task of tracking dependencies<br>
is moved from the logic to the software, which I already, in another<br>
context, criticized at Kunčar/Popescu's approach (which is<br>
nevertheless legitimate as an auxiliary approach).<br>
[…] Andrews' exercise X5308 […] stated and <br>
formalized on pp. 151 ff. of<br>
<a href="http://www.owlofminerva.net/files/formulae.pdf">http://www.owlofminerva.net/files/formulae.pdf</a><br>
is taken as an example where the dependency of the theorem<br>
is make explicit, assuming the form<br>
  AC =&gt; theorem<br>
since the (non-logical) Axiom of Choice was<br>
introduced as a conditional, not as an axiom.</p>
</blockquote>
</blockquote>
<p><a href="https://groups.google.com/d/msg/metamath/WwKPkCGoZkg/VSAVebXPCQAJ">https://groups.google.com/d/msg/metamath/WwKPkCGoZkg/VSAVebXPCQAJ</a><br>
Norman Megill presented a similar example:</p>
<blockquote>
<p>It is certainly possible to prefix every theorem with "ZFC -&gt;"</p>
</blockquote>
<p><a href="https://groups.google.com/d/msg/metamath/WwKPkCGoZkg/nvmXHUffCQAJ">https://groups.google.com/d/msg/metamath/WwKPkCGoZkg/nvmXHUffCQAJ</a><br>
I agree with Norman Megill that in certain practical contexts constantly displaying<br>
the same conditional prefix may be redundant, but this is a question of the user interface<br>
(which could, for example, replace the default prefix – e.g., "ZFC -&gt;" – by a star "*"), but not a<br>
matter relevant for the logical kernel, where this dependency should be made explicit.</p>
<p>As mentioned earlier, the Isabelle concept of axiomatic type classes as described and discussed in <br>
<a href="https://www4.in.tum.de/~wenzelm/papers/axclass-TPHOLs97.pdf">https://www4.in.tum.de/~wenzelm/papers/axclass-TPHOLs97.pdf</a><br>
and introduced in</p>
<blockquote>
<p>Prover-powered type classes were introduced by Nipkow and Snelting [28] in Isabelle/HOL<br>
and by Sozeau and Oury [32] in Coq—they additionally feature verifiability<br>
of the type-class conditions upon instantiation: a type T is accepted as a member<br>
of the semigroup class only if associativity can be proved for its + operation.</p>
</blockquote>
<p><a href="http://www21.in.tum.de/~kuncar/documents/kuncar-popescu-itp2015.pdf">http://www21.in.tum.de/~kuncar/documents/kuncar-popescu-itp2015.pdf</a> (p. 3)<br>
is considered as a preliminary solution by me, since the same fact can be expressed <br>
very naturally with the means of type abstraction (as suggested by Mike Gordon, see first quote at<br>
<a href="http://owlofminerva.net/kubota/software-implementation-of-the-mathematical-logic-r0-available-for-download/">http://owlofminerva.net/kubota/software-implementation-of-the-mathematical-logic-r0-available-for-download/</a><br>
) and as argued and demonstrated at pp. 12, 362, 420 of<br>
<a href="http://www.owlofminerva.net/files/formulae.pdf">http://www.owlofminerva.net/files/formulae.pdf</a><br>
Here, the fact that (o,XOR) is a group, formalized as<br>
    Grp o XOR<br>
(p. 420) can be stated only after proving the three group axioms for (o,XOR),<br>
and only after that, a general proof on groups (Uniqueness of the Group Identity Element, pp. 362 ff.) <br>
can be instantiated (transferred) to the specific XOR group without having to carry out the proof again<br>
(Uniqueness of the Group Identity Element of the XOR Group, pp. 420 ff.).</p>
<p>Coq is not suited for a comparison. It is very expressive (e.g., it has dependent types),<br>
but there is profound criticism raised by Freek Wiedijk and John Harrison (and Josef Urban),<br>
see section 3 of<br>
<a href="http://doi.org/10.4444/100.111">http://doi.org/10.4444/100.111</a><br>
and for an example the rule on top of p. 54 at<br>
<a href="http://www.cl.cam.ac.uk/~jrh13/papers/joerg.pdf">http://www.cl.cam.ac.uk/~jrh13/papers/joerg.pdf</a><br>
which is very far from a natural expression of formal logic and mathematics.</p>
<p>The Isabelle documentation is discussed quite often.</p>
<blockquote>
<p>Extensive documentation is available.<br>
<a href="http://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-ar.pdf">http://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-ar.pdf</a> (p. 3)<br>
The problem remains open: How can true expertise about how Isabelle<br>
really works be reconstructed? We've seen a slow and steady decline in<br>
the past 10 years, and myself writing hundreds of pages of documentation<br>
helped only very little.</p>
</blockquote>
<p>It is always claimed that the Isabelle documentation is ample, but unfortunately,<br>
it is not logically structured, which makes the extent of the documentation<br>
rather a disadvantage than an advantage.<br>
For comparison, the HOL/HOL4 documentation provides a precise and quick introduction,<br>
which allowed me to fully comprehend the logic, install the software and<br>
carry out proofs very quickly. It has, as one would expect, a separate logic part<br>
(Part III: The HOL Logic [Gordon and Melham, 1993, pp. 191–232]), available online at<br>
<a href="http://freefr.dl.sourceforge.net/project/hol/hol/kananaskis-11/kananaskis-11-logic.pdf">http://freefr.dl.sourceforge.net/project/hol/hol/kananaskis-11/kananaskis-11-logic.pdf</a><br>
and a very good guidebook which allows one to inspect the details of the system:<br>
<a href="https://hol-theorem-prover.org/guidebook/">https://hol-theorem-prover.org/guidebook/</a><br>
I already made suggestions for improvements earlier:</p>
<blockquote>
<p>Although of course Isabelle/HOL is a very good piece of software, this precision is currently missing in my opinion.<br>
The extension from classical HOL to Gordon's HOL can be found in section 11.7 (p. 261), as well as the<br>
(single) extension from Gordon's HOL to Isabelle/HOL ("Isabelle/HOL goes beyond Gordon-style HOL<br>
by admitting overloaded constant definitions") within a document of 13 chapters and 330 pages,<br>
which makes it practically impossible to identify and locate important features and extensions of the core logic<br>
within a reasonable amount of time:<br>
<a href="http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf</a></p>
</blockquote>
<p><a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-October/msg00050.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-October/msg00050.html</a><br>
Essential information on the logic is hidden somewhere between many technical details,<br>
and at the first glance I can't even see a reason for why the extension of the HOL logic is<br>
described in the Isar reference, and not in the Isabelle/HOL reference.<br>
With the HOL/HOL4 documentation, I was able to understand the logic and study<br>
the details of the proof technology within 24 hours (see example files attached),<br>
but with the Isabelle/HOL documentation, even after many months the details<br>
are obscure. Moreover, the concept of a small logical kernel should be reflected<br>
in the documentation by a separate logic part, as in the HOL/HOL4 documentation.<br>
The Isabelle/HOL documentation currently doesn't conform to this clear standard<br>
established by the original HOL system.</p>
<p>The emails quoted are attached below.<br>
The full discussion is available at<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/date.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/date.html</a></p>
<hr>
<p>Ken Kubota<br>
<a href="http://doi.org/10.4444/100">http://doi.org/10.4444/100</a></p>
<blockquote>
<p>Am 08.07.2017 um 20:59 schrieb Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;:</p>
<p>To protect against malicious intentions would turn Isabelle into a form of security software. But the guarantees we get from the latter are quite different from what we get from a formal proof. Ultimately security claims depend upon trusting a lot of complicated mechanisms, such as certificate authorities and cryptosystems. We are not a lot better off than when a model checker comes back with nothing.</p>
<p>However, we work with formal proofs, which can be examined, even interactively. We do not have to work on the basis that "X has been proved, therefore X is true", but rather "We have been given a proof of X; Is it credible?" Then we can look at any part of this proof where we have doubts. A devious user has many ways to try to fool us, but it's not so easy if he has to supply the full source code and we insist on legibility throughout. The effort we choose to invest in this would depend on how important X is and how much we distrust the person who supplied the proof.</p>
<p>Larry Paulson</p>
<p>On 8 Jul 2017, at 18:12, scott constable &lt;<a href="mailto:sdconsta@syr.edu">sdconsta@syr.edu</a>&gt; wrote:</p>
<blockquote>
<p>Isabelle does not protect against malicious intentions. It would require<br>
a quite different system to do that, one that you won't like to <br>
[message truncated]</p>
</blockquote>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>