<html>
<head><meta charset="utf-8"><title>[isabelle] Defining Union Types · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html">[isabelle] Defining Union Types</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294139507"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139507" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139507">(Aug 18 2022 at 17:56)</a>:</h4>
<p>From: Alfio Martini &lt;<a href="mailto:alfio.martini@acm.org">alfio.martini@acm.org</a>&gt;<br>
Dear Isabelle Users,</p>
<p>Do we have in Isabelle something like a union (sum) type constructor with<br>
the corresponding injections?<br>
I went through the tutorial and did not  find use or reference to it. If<br>
there is, can anyone point to an application<br>
or a written example of  this?</p>
<p>I assume there must be a simple way to do it.</p>
<p>Many thanks!</p>



<a name="294139513"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139513" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139513">(Aug 18 2022 at 17:56)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:brianh@cs.pdx.edu">brianh@cs.pdx.edu</a>&gt;<br>
Hello Alfio,</p>
<p>Yes, there is a sum type 'a + 'b, which has constructors Inl :: 'a =&gt;<br>
'a + 'b and Inr :: 'b =&gt; 'a + 'b.</p>
<p>I am a bit surprised that this type is mentioned nowhere in the<br>
tutorial. However it is documented in "What's in Main", which is found<br>
on the Isabelle documentation page:</p>
<p><a href="http://isabelle.in.tum.de/documentation.html">http://isabelle.in.tum.de/documentation.html</a></p>
<p>Inl and Inr are used in lots of places in the example theories that<br>
come with the distribution; just use grep.</p>
<ul>
<li>Brian</li>
</ul>



<a name="294139525"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139525" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139525">(Aug 18 2022 at 17:56)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
It is written "+" and defined in theory Sum_Type, which is part of Main.<br>
It is hardly advertised because in most cases it is nicer to define your<br>
own special datatype.</p>
<p>Tobias</p>



<a name="294139537"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139537" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139537">(Aug 18 2022 at 17:56)</a>:</h4>
<p>From: Christian Sternagel &lt;<a href="mailto:christian.sternagel@uibk.ac.at">christian.sternagel@uibk.ac.at</a>&gt;<br>
Talking of the sum type... I think it would be good to have it more <br>
easily accessible. Currently, e.g., I have to write "Sum_Type.Projr" to <br>
get the right projection. As far as I can see it is mainly for internal <br>
use of some packages. But something like Haskell's Either would be <br>
useful for the library (together with a bunch of useful functions and <br>
lemmas).</p>
<p>cheers</p>
<p>chris</p>



<a name="294139645"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139645" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139645">(Aug 18 2022 at 17:56)</a>:</h4>
<p>From: Alfio Martini &lt;<a href="mailto:alfio.martini@acm.org">alfio.martini@acm.org</a>&gt;<br>
Thank you all for the quick replies!</p>
<p>Cheers</p>



<a name="294139655"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139655" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139655">(Aug 18 2022 at 17:57)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Before we define a new type we should rather make the existing one more<br>
usable. But what is really needed? Haskell does not offer Projl/r at all<br>
but lefts, rights and paritionEithers.</p>
<p>Tobias</p>



<a name="294139680"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139680" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139680">(Aug 18 2022 at 17:57)</a>:</h4>
<p>From: Christian Sternagel &lt;<a href="mailto:christian.sternagel@uibk.ac.at">christian.sternagel@uibk.ac.at</a>&gt;<br>
On 07/26/2011 10:13 PM, Tobias Nipkow wrote:</p>
<blockquote>
<p>Before we define a new type we should rather make the existing one more<br>
usable.<br>
Yes indeed. That's what I meant.</p>
</blockquote>
<blockquote>
<p>But what is really needed? Haskell does not offer Projl/r at all<br>
but lefts, rights and paritionEithers.<br>
In IsaFoR we use Sum_Type.Projr and Sum_Type.Projl. It would just feel <br>
"more official" if you didn't have to use the cumbersome prefix.</p>
</blockquote>
<p>A not entirely related idea is the setup of an (executable) error monad <br>
using "+" (which is used heavily in IsaFoR for example).</p>
<p>To this end I once tried to setup such a monad to use for partial <br>
functions (I was heading towards a parsec-like parser combinator <br>
library; side remark: there are not many deep properties I wanted to <br>
proof about this combinators, but it is just nice to be able to write <br>
also your parser in Isabelle when you use code generation) but  failed <br>
to complete since different error cases (i.e., Inl's containing <br>
different error messages) are not equal. Maybe this could be generalized <br>
using some equivalence relation?</p>
<p>cheers</p>
<p>chris</p>
<blockquote>
<p>Tobias</p>
<p>Am 26/07/2011 09:03, schrieb Christian Sternagel:</p>
<blockquote>
<p>Talking of the sum type... I think it would be good to have it more<br>
easily accessible. Currently, e.g., I have to write "Sum_Type.Projr" to<br>
get the right projection. As far as I can see it is mainly for internal<br>
use of some packages. But something like Haskell's Either would be<br>
useful for the library (together with a bunch of useful functions and<br>
lemmas).</p>
<p>cheers</p>
<p>chris</p>
</blockquote>
<p>On 07/26/2011 07:42 AM, Tobias Nipkow wrote:</p>
<blockquote>
<blockquote>
<p>It is written "+" and defined in theory Sum_Type, which is part of Main.<br>
It is hardly advertised because in most cases it is nicer to define your<br>
own special datatype.</p>
<p>Tobias<br>
</p>
</blockquote>
<p>Am 26/07/2011 03:57, schrieb Alfio Martini:</p>
<blockquote>
<blockquote>
<p>Dear Isabelle Users,</p>
<p>Do we have in Isabelle something like a union (sum) type constructor<br>
with<br>
the corresponding injections?<br>
I went through the tutorial and did not  find use or reference to it. If<br>
there is, can anyone point to an application<br>
or a written example of  this?</p>
<p>I assume there must be a simple way to do it.</p>
<p>Many thanks!</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>



<a name="294139706"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139706" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139706">(Aug 18 2022 at 17:57)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@kit.edu">andreas.lochbihler@kit.edu</a>&gt;</p>
<blockquote>
<blockquote>
<p>But what is really needed? Haskell does not offer Projl/r at all<br>
but lefts, rights and paritionEithers.<br>
In IsaFoR we use Sum_Type.Projr and Sum_Type.Projl. It would just feel "more<br>
official" if you didn't have to use the cumbersome prefix.<br>
Sum_Type.Projr and Sum_Type.Projl are the destructor view on datatypes, which <br>
are necessarily partial. But most formalisations in Isabelle follow the <br>
constructor view and use case expressions for destruction, for which there is a <br>
reasonable setup (simp rules, split rules, etc.). For example,<br>
(Sum_Type.Projl x) is (almost) equivalent to (case x of Inl y =&gt; y) and<br>
(Sum_Type.Projr x) to (case x of Inr y =&gt; y).</p>
</blockquote>
</blockquote>
<blockquote>
<p>A not entirely related idea is the setup of an (executable) error monad using<br>
"+" (which is used heavily in IsaFoR for example).<br>
I would recommend not to use sum types for such things, but introduce a new type <br>
with an error element. This has the advantage that split rules and the like can <br>
be applied more precisely. If sum types are used for other notions in a <br>
formalisation, too, the general simplification and split rules might slow break <br>
down proof automation because they also apply to the other parts.</p>
</blockquote>
<blockquote>
<p>To this end I once tried to setup such a monad to use for partial functions (I<br>
was heading towards a parsec-like parser combinator library; side remark: there<br>
are not many deep properties I wanted to proof about this combinators, but it is<br>
just nice to be able to write also your parser in Isabelle when you use code<br>
generation) but failed to complete since different error cases (i.e., Inl's<br>
containing different error messages) are not equal. Maybe this could be<br>
generalized using some equivalence relation?<br>
I suppose that the error messages are irrelevant to the proofs, so they need not <br>
be part of the logic. If the error monad is a type constructor of its own <br>
(rather than a sum type), you can identify all error cases in the logic and <br>
handle the error messages in the code generator only. Here's the idea:</p>
</blockquote>
<p>datatype 'a err = Error | OK 'a</p>
<p>definition Raise_error :: "String.literal =&gt; 'a err"<br>
where "Raise_error msg = Error"</p>
<p>code_datatype Raise_error OK</p>
<p>In the logic, all errors are the same "Error" value, but the generated code uses <br>
Raise_error as constructor which also stores the error message. Hence, the <br>
logical problem with different error messages no longer occurs.</p>
<p>Andreas</p>
<blockquote>
<p>cheers</p>
<p>chris</p>
<blockquote>
<p>Tobias<br>
</p>
</blockquote>
<p>Am 26/07/2011 09:03, schrieb Christian Sternagel:</p>
<blockquote>
<blockquote>
<p>Talking of the sum type... I think it would be good to have it more<br>
easily accessible. Currently, e.g., I have to write "Sum_Type.Projr" to<br>
get the right projection. As far as I can see it is mainly for internal<br>
use of some packages. But something like Haskell's Either would be<br>
useful for the library (together with a bunch of useful functions and<br>
lemmas).</p>
<p>cheers</p>
<p>chris</p>
</blockquote>
<p>On 07/26/2011 07:42 AM, Tobias Nipkow wrote:</p>
<blockquote>
<blockquote>
<p>It is written "+" and defined in theory Sum_Type, which is part of Main.<br>
It is hardly advertised because in most cases it is nicer to define your<br>
own special datatype.</p>
<p>Tobias<br>
</p>
</blockquote>
<p>Am 26/07/2011 03:57, schrieb Alfio Martini:</p>
<blockquote>
<blockquote>
<p>Dear Isabelle Users,</p>
<p>Do we have in Isabelle something like a union (sum) type constructor<br>
with<br>
the corresponding injections?<br>
I went through the tutorial and did not find use or reference to it. If<br>
there is, can anyone point to an application<br>
or a written example of this?</p>
<p>I assume there must be a simple way to do it.</p>
<p>Many thanks!</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>



<a name="294139729"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139729" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139729">(Aug 18 2022 at 17:57)</a>:</h4>
<p>From: Christian Sternagel &lt;<a href="mailto:christian.sternagel@uibk.ac.at">christian.sternagel@uibk.ac.at</a>&gt;<br>
On 07/27/2011 02:31 PM, Andreas Lochbihler wrote:</p>
<blockquote>
<blockquote>
<blockquote>
<p>But what is really needed? Haskell does not offer Projl/r at all<br>
but lefts, rights and paritionEithers.<br>
In IsaFoR we use Sum_Type.Projr and Sum_Type.Projl. It would just feel<br>
"more<br>
official" if you didn't have to use the cumbersome prefix.<br>
Sum_Type.Projr and Sum_Type.Projl are the destructor view on datatypes,<br>
which are necessarily partial. But most formalisations in Isabelle<br>
follow the constructor view and use case expressions for destruction,<br>
for which there is a reasonable setup (simp rules, split rules, etc.).<br>
For example,<br>
(Sum_Type.Projl x) is (almost) equivalent to (case x of Inl y =&gt; y) and<br>
(Sum_Type.Projr x) to (case x of Inr y =&gt; y).</p>
</blockquote>
</blockquote>
<blockquote>
<p>A not entirely related idea is the setup of an (executable) error<br>
monad using<br>
"+" (which is used heavily in IsaFoR for example).<br>
I would recommend not to use sum types for such things, but introduce a<br>
new type with an error element. This has the advantage that split rules<br>
and the like can be applied more precisely. If sum types are used for<br>
other notions in a formalisation, too, the general simplification and<br>
split rules might slow break down proof automation because they also<br>
apply to the other parts.</p>
</blockquote>
<blockquote>
<p>To this end I once tried to setup such a monad to use for partial<br>
functions (I<br>
was heading towards a parsec-like parser combinator library; side<br>
remark: there<br>
are not many deep properties I wanted to proof about this combinators,<br>
but it is<br>
just nice to be able to write also your parser in Isabelle when you<br>
use code<br>
generation) but failed to complete since different error cases (i.e.,<br>
Inl's<br>
containing different error messages) are not equal. Maybe this could be<br>
generalized using some equivalence relation?<br>
I suppose that the error messages are irrelevant to the proofs, so they<br>
need not be part of the logic. If the error monad is a type constructor<br>
of its own (rather than a sum type), you can identify all error cases in<br>
the logic and handle the error messages in the code generator only.<br>
Here's the idea:</p>
</blockquote>
<p>datatype 'a err = Error | OK 'a</p>
<p>definition Raise_error :: "String.literal =&gt; 'a err"<br>
where "Raise_error msg = Error"</p>
<p>code_datatype Raise_error OK</p>
<p>In the logic, all errors are the same "Error" value, but the generated<br>
code uses Raise_error as constructor which also stores the error<br>
message. Hence, the logical problem with different error messages no<br>
longer occurs.<br>
This looks nice. However, we do compose error messages incrementally <br>
(i.e., add more precise information to errors at different places). I do <br>
not immediately see how this could be achieved with a single error <br>
constructor. Any hints?</p>
</blockquote>
<p>cheers</p>
<p>chris</p>
<blockquote>
<p>Andreas</p>
<blockquote>
<p>cheers</p>
<p>chris</p>
<blockquote>
<p>Tobias<br>
</p>
</blockquote>
<p>Am 26/07/2011 09:03, schrieb Christian Sternagel:</p>
<blockquote>
<blockquote>
<p>Talking of the sum type... I think it would be good to have it more<br>
easily accessible. Currently, e.g., I have to write "Sum_Type.Projr" to<br>
get the right projection. As far as I can see it is mainly for internal<br>
use of some packages. But something like Haskell's Either would be<br>
useful for the library (together with a bunch of useful functions and<br>
lemmas).</p>
<p>cheers</p>
<p>chris</p>
</blockquote>
<p>On 07/26/2011 07:42 AM, Tobias Nipkow wrote:</p>
<blockquote>
<blockquote>
<p>It is written "+" and defined in theory Sum_Type, which is part of<br>
Main.<br>
It is hardly advertised because in most cases it is nicer to define<br>
your<br>
own special datatype.</p>
<p>Tobias<br>
</p>
</blockquote>
<p>Am 26/07/2011 03:57, schrieb Alfio Martini:</p>
<blockquote>
<blockquote>
<p>Dear Isabelle Users,</p>
<p>Do we have in Isabelle something like a union (sum) type constructor<br>
with<br>
the corresponding injections?<br>
I went through the tutorial and did not find use or reference to<br>
it. If<br>
there is, can anyone point to an application<br>
or a written example of this?</p>
<p>I assume there must be a simple way to do it.</p>
<p>Many thanks!</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>



<a name="294139741"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Defining%20Union%20Types/near/294139741" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Defining.20Union.20Types.html#294139741">(Aug 18 2022 at 17:57)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@kit.edu">andreas.lochbihler@kit.edu</a>&gt;<br>
Dear Christian,</p>
<p>In code equations, you can "pattern-match" on the pseudo-constructor <br>
Raise_error. If you need more structured types than String.literal, the <br>
following with phantom type variables should work for you:</p>
<p>datatype ('a, 'b) err = Error | OK 'b</p>
<p>definition Raise_error :: "'a =&gt; ('a, 'b) err"<br>
where [simp]: "Raise_error msg = Error"</p>
<p>code_datatype Raise_error OK</p>
<p>primrec more_info :: "('a, 'b) err =&gt; ('a * String.literal, 'b) err"<br>
where<br>
   "more_info Error = Error"<br>
| [code]: "more_info (OK b) = (OK b)"</p>
<p>lemma more_info_Raise_error [code]:<br>
   "more_info (Raise_error a) = Raise_error (a, STR ''info'')"<br>
by simp</p>
<p>Cheers,<br>
Andreas</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>