<html>
<head><meta charset="utf-8"><title>[isabelle] Equality for set-based reasoning using the str... ¬∑ Archive Mirror: Isabelle Users Mailing List ¬∑ Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html">[isabelle] Equality for set-based reasoning using the str...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294826007"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294826007" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294826007">(Aug 23 2022 at 08:47)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt;<br>
Dear Mikhail,</p>
<blockquote>
<p>Nonetheless, I am not certain whether/how it resolves the most fundamental<br>
issue. Many constants require some form of the totality of the relation as<br>
a prerequisite for the possibility of a transfer rule to be established,<br>
e.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc methods<br>
to avoid having to deal with the transfer of such constants (e.g. by<br>
converting the statements of the theorems to the form that uses Ball/Bex,<br>
while partially relying on tailor-made automation to achieve this).<br>
However, I wonder whether there exists a more native solution (after all,<br>
the premises should always carry sufficient information for the transfer to<br>
succeed).</p>
<p>All/Ex and friends are a thorny issue when it comes to transfer. Essentially, transfer <br>
looks at the syntactic structure of the term, decomposes it into atoms and tries to prove <br>
the transferring rule by composing the transfer rules for each following the rules for the <br>
connectives of the terms (application and abstractions). In particular, properties <br>
emerging from the interplay of different constants in the term are not taken into account.</p>
</blockquote>
<p>The following example illustrates this issue. The following three statements are logically <br>
equivalent:</p>
<p>(1) Ball A P<br>
(2) !x. x : A --&gt; P x<br>
(3) !!x. x : A ==&gt; P x</p>
<p>For transfer, (1) is the most suitable one because the interplay of quantification, <br>
membership and implication is captured in one constant Ball. This interplay is captured in <br>
Ball's transfer rule, which does not make any assumptions on the relation on the elements.</p>
<p>However, we often write statements of form (3) because they play well with Pure's natural <br>
deduction, and terms of form (2) are generated by various packages and methods (e.g., <br>
atomize -- and transfer also rewrites (3) into (2) as a preparatory step).</p>
<p>So, if you state your example lemma as follows, everything should work without the need <br>
for bi-totality.</p>
<p>lemma [rule_format]:<br>
   includes lifting_syntax<br>
   assumes [transfer_rule]: "monoid_eq' C F G"<br>
   shows "!a ‚àà carrier G. !b ‚àà carrier G. a ‚äó‚áòF‚áô b = a ‚äó‚áòG‚áô b"</p>
<p>Some preprocessing can get you a long way in this direction. Unfortunately, I haven't <br>
found a one-size-fits-all solution for these problems (and I don't believe that such a <br>
thing exists in general). Given Isabelle's interactive nature, a promising approach is to <br>
identify recurring patterns and then automate these patterns accordingly.</p>
<blockquote>
<p>As a side remark, I tried to explain the issue that is described in the<br>
previous paragraph of this email in the last two paragraphs of my previous<br>
email. However, having re-read them, I realized that I missed the point<br>
almost completely: please ignore the last two paragraphs of my previous<br>
email. Nonetheless, the example before the last paragraph is still relevant:</p>
<p>lemma carrier_transfer[transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(monoid_eq' C ===&gt; rel_set (eq_onp C)) carrier carrier"<br>
   unfolding monoid_eq'_def monoid_eq_def  eq_onp_def rel_set_def<br>
   using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>
   by blast</p>
<p>lemma [transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(eq_onp C ===&gt; eq_onp C ===&gt; (=)) (=) (=)"<br>
   unfolding eq_onp_def by auto<br>
Instead of this rule, you want to tell transfer that eq_onp relations are bi-unique. The <br>
rule is missing from the library, but it's in one of my AFP entries:</p>
</blockquote>
<p><a href="https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D">https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D</a></p>
<blockquote>
<p>lemma [transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(eq_onp C ===&gt; rel_set (eq_onp C) ===&gt; (=)) (‚àà) (‚àà)"<br>
   unfolding eq_onp_def rel_set_def by auto</p>
</blockquote>
<p>This should also be solved by declaring bi_unique_eq_onp as [transfer_rule].</p>
<blockquote>
<p>lemma<br>
   includes lifting_syntax<br>
   assumes [transfer_rule]: "monoid_eq' C F G"<br>
   shows "a ‚àà carrier G ‚üπ b ‚àà carrier G ‚üπ a ‚äó‚áòG‚áô b = a ‚äó‚áòG‚áô b"<br>
   apply transfer<br>
   (<em>Transfer.Rel ((eq_onp C ===&gt; (=)) ===&gt; (=)) ?aa25 transfer_forall</em>)<br>
   oops</p>
<p>Lastly, please accept my apologies for asking so many questions on this<br>
topic lately. The reason for this is that I am trying to be careful to<br>
ensure that the framework for transfer is designed in a more-or-less<br>
canonical manner, as I believe that it has a potential for being<br>
generalized to arbitrary partial equivalence relations on set-based<br>
structures defined using records (or similar). Naturally, I will share it<br>
under the terms of a BSD license when/if it will reach a certain state of<br>
generality and maturity.</p>
</blockquote>
<p>No need to apologize. I'm happy to chat about these things.</p>
<p>Best,<br>
Andreas</p>



<a name="294826086"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294826086" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294826086">(Aug 23 2022 at 08:48)</a>:</h4>
<p>From: Mikhail Chekhov &lt;<a href="mailto:mikhail.chekhov.w@gmail.com">mikhail.chekhov.w@gmail.com</a>&gt;<br>
Dear Andreas Lochbihler/All,</p>
<p>Thank you for your reply. I will allow myself to provide several concluding<br>
remarks in an attempt to close this issue.</p>
<p>Nonetheless, I am not certain whether/how it resolves the most fundamental</p>
<p>issue. Many constants require some form of the totality of the relation as</p>
<p>a prerequisite for the possibility of a transfer rule to be established,</p>
<p>e.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc methods</p>
<p>to avoid having to deal with the transfer of such constants (e.g. by</p>
<p>converting the statements of the theorems to the form that uses Ball/Bex,</p>
<p>while partially relying on tailor-made automation to achieve this).</p>
<p>However, I wonder whether there exists a more native solution (after all,</p>
<p>the premises should always carry sufficient information for the transfer to</p>
<p>succeed).</p>
<p>All/Ex and friends are a thorny issue when it comes to transfer.</p>
<blockquote>
<p>Essentially, transfer<br>
looks at the syntactic structure of the term, decomposes it into atoms and<br>
tries to prove<br>
the transferring rule by composing the transfer rules for each following<br>
the rules for the<br>
connectives of the terms (application and abstractions). In particular,<br>
properties<br>
emerging from the interplay of different constants in the term are not<br>
taken into account.</p>
</blockquote>
<blockquote>
<p>...<br>
</p>
</blockquote>
<p>So, if you state your example lemma as follows, everything should work</p>
<blockquote>
<p>without the need<br>
for bi-totality.<br>
lemma [rule_format]:<br>
   includes lifting_syntax<br>
   assumes [transfer_rule]: "monoid_eq' C F G"<br>
   shows "!a ‚àà carrier G. !b ‚àà carrier G. a ‚äó‚áòF‚áô b = a ‚äó‚áòG‚áô b"</p>
</blockquote>
<p>Thank you for the detailed explanation. Nevertheless, I have to mention<br>
that I am, to a certain degree, familiar with the algorithm that is used by<br>
the Isabelle's transfer tool. Therefore, of course, instead of "for the<br>
transfer to succeed" I should have written "for a transfer-like algorithm<br>
to succeed". In any case, I believe that this was the intended meaning of<br>
the last sentence of the first quoted paragraph above. Also, in the same<br>
paragraph, I mentioned that I was already able to partially automate the<br>
process of the conversion of the goals of the form "!!a b. a ‚àà carrier G ‚üπ<br>
b ‚àà carrier G ‚üπ a ‚äó‚áòG‚áô b = a ‚äó‚áòG‚áô b" to the form "!a ‚àà carrier G. !b ‚àà<br>
carrier G. a ‚äó‚áòF‚áô b = a ‚äó‚áòG‚áô b" at the time of writing. However, such<br>
automation only works in very simple cases (by now, I have already<br>
encountered a use case where my methodology fails). Nonetheless, based on<br>
what I have experimented with, it felt like it should be possible to devise<br>
a transfer-like algorithm that would work almost always even if the<br>
totality cannot be guaranteed (i.e. the transfer needs to be established<br>
between two subsets).</p>
<blockquote>
<p>Some preprocessing can get you a long way in this direction.<br>
Unfortunately, I haven't<br>
found a one-size-fits-all solution for these problems (and I don't believe<br>
that such a<br>
thing exists in general). Given Isabelle's interactive nature, a promising<br>
approach is to<br>
identify recurring patterns and then automate these patterns accordingly.<br>
</p>
</blockquote>
<p>I am slightly disappointed. However, at least, that what you have stated<br>
gives me confidence that the problem that I have encountered is far from<br>
being trivial and, currently, there is no canonical solution that would<br>
make it possible to fully automate the transfer of results between two<br>
arbitrary subsets. Nonetheless, it feels like this limitation is a dramatic<br>
gap in the capabilities of the transfer tool (of course, I am aware that<br>
this use case has never been advertised as one of the target applications<br>
of the tool).</p>
<blockquote>
<p>Instead of this rule, you want to tell transfer that eq_onp relations are<br>
bi-unique. The<br>
rule is missing from the library, but it's in one of my AFP entries:</p>
<p>Undeniably, I can be slightly reckless when writing code for forums/mailing<br>
lists: most certainly, this was not a copy of my working version of the<br>
code :). Thank you for pointing out this flaw.</p>
</blockquote>
<hr>
<p>Having tried every solution that was mentioned in this thread, I decided to<br>
use an explicit relation in favor of the solutions based on undefined.<br>
Nonetheless, I decided not to rely on transfer. Without an algorithm that<br>
is capable of handling the "interplay of quantification, membership and<br>
implication" in a completely automated manner, unfortunately, in my view<br>
(and taking into account my reasonably contrived use cases), it seems to be<br>
more natural to continue without transfer than having to rely on "patchy"<br>
solutions. Quite frankly, I found that a combination of locale<br>
interpretation + additional rules for the classical reasoners + specialized<br>
simpset in the form of a collection of named_theorems works reasonably well<br>
in practice. While, from time to time, I have to use additional Isar code<br>
to handle the equality, most proofs of the related steps look like this:<br>
"(auto simp: eq_simps)", where eq_simps contains theorems of the form "x ‚àà<br>
carrier F ‚üπ y ‚àà carrier F ‚üπ x ‚äó‚áòG‚áô y = x ‚äó‚áòF‚áô y". Naturally, I also<br>
maintain an additional set of introduction rules for the classical<br>
reasoner.</p>
<p>Having said this, it would be very interesting to understand whether it<br>
could be possible to develop a general transfer-like algorithm that could<br>
work without the requirement of the totality of the involved relations,<br>
inferring the information about the membership directly from the<br>
premises/assumptions (perhaps, augmented with some additional<br>
infrastructure). I believe that this could be useful in practice not only<br>
for my particular use case (i.e. equality) but also in many other similar<br>
cases (e.g. consider the problem of the transfer of the results across an<br>
arbitrary isomorphism between two set-based structures).</p>
<p>Kind Regards,<br>
Mikhail Chekhov</p>
<p>On Wed, Apr 22, 2020 at 8:24 AM Andreas Lochbihler &lt;<br>
<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt; wrote:</p>
<blockquote>
<p>Dear Mikhail,</p>
<blockquote>
<p>Nonetheless, I am not certain whether/how it resolves the most<br>
fundamental<br>
issue. Many constants require some form of the totality of the relation<br>
as<br>
a prerequisite for the possibility of a transfer rule to be established,<br>
e.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc<br>
methods<br>
to avoid having to deal with the transfer of such constants (e.g. by<br>
converting the statements of the theorems to the form that uses Ball/Bex,<br>
while partially relying on tailor-made automation to achieve this).<br>
However, I wonder whether there exists a more native solution (after all,<br>
the premises should always carry sufficient information for the transfer<br>
to<br>
succeed).</p>
<p>All/Ex and friends are a thorny issue when it comes to transfer.<br>
Essentially, transfer<br>
looks at the syntactic structure of the term, decomposes it into atoms and<br>
tries to prove<br>
the transferring rule by composing the transfer rules for each following<br>
the rules for the<br>
connectives of the terms (application and abstractions). In particular,<br>
properties<br>
emerging from the interplay of different constants in the term are not<br>
taken into account.</p>
</blockquote>
<p>The following example illustrates this issue. The following three<br>
statements are logically<br>
equivalent:</p>
<p>(1) Ball A P<br>
(2) !x. x : A --&gt; P x<br>
(3) !!x. x : A ==&gt; P x</p>
<p>For transfer, (1) is the most suitable one because the interplay of<br>
quantification,<br>
membership and implication is captured in one constant Ball. This<br>
interplay is captured in<br>
Ball's transfer rule, which does not make any assumptions on the relation<br>
on the elements.</p>
<p>However, we often write statements of form (3) because they play well with<br>
Pure's natural<br>
deduction, and terms of form (2) are generated by various packages and<br>
methods (e.g.,<br>
atomize -- and transfer also rewrites (3) into (2) as a preparatory step).</p>
<p>So, if you state your example lemma as follows, everything should work<br>
without the need<br>
for bi-totality.</p>
<p>lemma [rule_format]:<br>
   includes lifting_syntax<br>
   assumes [transfer_rule]: "monoid_eq' C F G"<br>
   shows "!a ‚àà carrier G. !b ‚àà carrier G. a ‚äó‚áòF‚áô b = a ‚äó‚áòG‚áô b"</p>
<p>Some preprocessing can get you a long way in this direction.<br>
Unfortunately, I haven't<br>
found a one-size-fits-all solution for these problems (and I don't believe<br>
that such a<br>
thing exists in general). Given Isabelle's interactive nature, a promising<br>
approach is to<br>
identify recurring patterns and then automate these patterns accordingly.</p>
<blockquote>
<p>As a side remark, I tried to explain the issue that is described in the<br>
previous paragraph of this email in the last two paragraphs of my<br>
previous<br>
email. However, having re-read them, I realized that I missed the point<br>
almost completely: please ignore the last two paragraphs of my previous<br>
email. Nonetheless, the example before the last paragraph is still<br>
relevant:</p>
<p>lemma carrier_transfer[transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(monoid_eq' C ===&gt; rel_set (eq_onp C)) carrier carrier"<br>
   unfolding monoid_eq'_def monoid_eq_def  eq_onp_def rel_set_def<br>
   using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>
   by blast</p>
<p>lemma [transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(eq_onp C ===&gt; eq_onp C ===&gt; (=)) (=) (=)"<br>
   unfolding eq_onp_def by auto<br>
Instead of this rule, you want to tell transfer that eq_onp relations are<br>
bi-unique. The<br>
rule is missing from the library, but it's in one of my AFP entries:</p>
</blockquote>
<p><a href="https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D">https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D</a></p>
<blockquote>
<p>lemma [transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(eq_onp C ===&gt; rel_set (eq_onp C) ===&gt; (=)) (‚àà) (‚àà)"<br>
   unfolding eq_onp_def rel_set_def by auto</p>
</blockquote>
<p>This should also be solved by declaring bi_unique_eq_onp as<br>
[transfer_rule].</p>
<blockquote>
<p>lemma<br>
   includes lifting_syntax<br>
   assumes [transfer_rule]: "monoid_eq' C F G"</p>
<p>[message truncated]</p>
</blockquote>
</blockquote>



<a name="294827288"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294827288" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294827288">(Aug 23 2022 at 08:57)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt;<br>
Dear Mikhail,</p>
<p>I'm not surprised that option 2 creates a lot of effort because you change the locale <br>
specification. With option 1, you essentially get congruence rules of the form</p>
<p>monoid_eq F G ==&gt; x : carrier G ==&gt; <a href="http://monoid.foo">monoid.foo</a> F x = <a href="http://monoid.foo">monoid.foo</a> G x</p>
<p>for all derived concepts that are defined in monoid. Reasoning with such congruence rules <br>
can become cumbersome because the simplifier is not really able to reason with them <br>
natively. Moreover, you need a separate interpretation of monoid_eq for every pair of <br>
monoids you consider. If there are many, the number of interpretations grow quadratically <br>
in the worst case.</p>
<p>Defining the partial quotient as a type is not really feasible because type definitions <br>
must not depend on values in Isabelle/HOL, so you'd have to do the construction for every <br>
fixed monoid separately.</p>
<p>There are two further options that I want to mention. First, you can define a <br>
normalization function normalize :: 'a monoid =&gt; 'a =&gt; 'a via</p>
<p>normalize F x = (if x : carrier F then x else undefined)</p>
<p>and then lift it to a normalization function on monoid:</p>
<p>normalize_monoid :: 'a monoid =&gt; 'a monoid</p>
<p>that restricts the monoid operation to the carrier and sets it to undefined everywhere <br>
else. You can then prove</p>
<p>monoid F ==&gt; normalize_monoid F</p>
<p>and for all operations <a href="http://monoid.foo">monoid.foo</a> defined on monoids equations such as the following:</p>
<p>"x : carrier F ==&gt; <a href="http://monoid.foo">monoid.foo</a> F x = <a href="http://monoid.foo">monoid.foo</a> (normalize_monoid F) x"</p>
<p>If you equip these equations with an assumption<br>
   "NO_MATCH (normalize_monoid G) F"<br>
then you can even use them as simp rules without looping.</p>
<p>So whenever you need to exploit the equality of monoids, you can add those equations to <br>
the simpset and switch all involved monoids F to "normalize_monoid F". And for these <br>
normalized monoids, you actually get the equality "normalize_monoid F = normalize_monoid G".</p>
<p>A few caveats of this approach:</p>
<ol>
<li>
<p>This only pays of if you have equalities between many monoids. If there are just two or <br>
three, it's probably not worth the effort.</p>
</li>
<li>
<p>Going from F to normalize_monoid F works well for declarative proofs where you <br>
explicitly state the equality and then have simp transfer both sides. It does not work <br>
well with exploratory proof styles where you interactively develop the proof like with an <br>
apply script.</p>
</li>
<li>
<p>The rewriting to normalize_monoid is limited to what simp can do. For example, <br>
replacements under higher-order operators like fold will not work in general because simp <br>
cannot solve the side conditions _ : carrier _, even if you supply congruence rules.</p>
</li>
</ol>
<p>The second approach is to use transfer. You can use your monoid_eq as a the relator for <br>
monoids and then prove appropriate transfer rules for all the operations on monoids. You <br>
should then be able to move from one monoid to the other by declaring the suitable <br>
monoid_eq fact as [transfer_rule] and let transfer do the rest. That's probably what I <br>
would go for.</p>
<p>Best,<br>
Andreas</p>



<a name="294827294"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294827294" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294827294">(Aug 23 2022 at 08:58)</a>:</h4>
<p>From: Mikhail Chekhov &lt;<a href="mailto:mikhail.chekhov.w@gmail.com">mikhail.chekhov.w@gmail.com</a>&gt;<br>
Dear Andreas Lochbihler/All,</p>
<p>Thank you for your reply. It contains very useful advice. However, I will<br>
allow myself to provide several comments and make an attempt to clarify one<br>
part of your answer that I may not have understood.</p>
<p>Defining the partial quotient as a type is not really feasible because type</p>
<blockquote>
<p>definitions<br>
must not depend on values in Isabelle/HOL, so you'd have to do the<br>
construction for every<br>
fixed monoid separately.</p>
</blockquote>
<p>Of course, you are right, but I omitted an important detail from my<br>
question: I specialize all structures to one particular type. Therefore, I<br>
was able to define a partial quotient type. Nonetheless, such an approach<br>
results in a substantial amount of duplication (moreover, there are other,<br>
more fundamental, complications) and I do not consider it to be the most<br>
practical solution.</p>
<p>...</p>
<blockquote>
<p>Reasoning with such congruence rules<br>
can become cumbersome because the simplifier is not really able to reason<br>
with them<br>
natively. Moreover, you need a separate interpretation of monoid_eq for<br>
every pair of<br>
monoids you consider. If there are many, the number of interpretations<br>
grow quadratically<br>
in the worst case.<br>
...<br>
The second approach is to use transfer. You can use your monoid_eq as a<br>
the relator for<br>
monoids and then prove appropriate transfer rules for all the operations<br>
on monoids. You<br>
should then be able to move from one monoid to the other by declaring the<br>
suitable<br>
monoid_eq fact as [transfer_rule] and let transfer do the rest. That's<br>
probably what I<br>
would go for.</p>
</blockquote>
<p>If I understood what is stated in your answer correctly, the second<br>
solution that you suggested is not entirely different from the first<br>
approach that I proposed in my question. Naturally, I never suggested that<br>
one should rely on the simplifier/congruence rules exclusively. Indeed, I<br>
rely predominantly on the capabilities of the transfer package to transfer<br>
the results across the members of a given equivalence class (however, I<br>
only mentioned it in passing in the last paragraph of the question and your<br>
answer gave me additional ideas for improvement of my own framework for<br>
transfer). Nonetheless, given what you have stated, I am still not certain<br>
if I am using transfer in the best possible manner. For example, consider<br>
the following framework,</p>
<p>locale monoid_eq = monoid G + monoid F for G F +<br>
   assumes monoid_eq_carrier: "carrier G = carrier F"<br>
     and monoid_eq_mult:<br>
      "x ‚àà carrier G ‚üπ y ‚àà carrier G ‚üπ x ‚äó‚áòG‚áô y = x ‚äó‚áòF‚áô y"<br>
     and monoid_eq_one: "ùü≠‚áòG‚áô = ùü≠‚áòF‚áô"</p>
<p>definition monoid_eq_rel ::<br>
  "('a, 'b) monoid_scheme ‚áí ('a, 'c) monoid_scheme ‚áí 'a ‚áí 'a ‚áí bool"<br>
  where (*redundancy for symmetry :) *) "monoid_eq_rel F G a b =<br>
    (a = b ‚àß a ‚àà carrier F ‚àß b ‚àà carrier G ‚àß monoid_eq F G)"</p>
<p>lemma eq_transfer[transfer_rule]:<br>
  includes lifting_syntax<br>
  shows "(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (=) (=)"<br>
  unfolding monoid_eq_rel_def<br>
  by (intro rel_funI) auto</p>
<p>lemma carrier_transfer[transfer_rule]:<br>
  includes lifting_syntax<br>
  shows "(monoid_eq ===&gt; (=)) carrier carrier"<br>
  unfolding monoid_eq_def<br>
  using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>
  by blast</p>
<p>lemma mult_transfer[transfer_rule]:<br>
  includes lifting_syntax<br>
  shows "(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (mult F) (mult<br>
G)"<br>
proof(intro rel_funI)<br>
  fix x y x' y'<br>
  assume prems: "monoid_eq_rel F G x y" "monoid_eq_rel F G x' y'"<br>
  then have myrel:<br>
    "x = y" "x' = y'"<br>
    "x ‚àà carrier F" "y ‚àà carrier G"<br>
    "x' ‚àà carrier F" "y' ‚àà carrier G"<br>
    "monoid_eq F G"<br>
    unfolding monoid_eq_rel_def by auto<br>
  interpret monoid_eq F G by (rule ‚Äπmonoid_eq F G‚Ä∫)<br>
  show "x ‚äó‚áòF‚áô x' = y ‚äó‚áòG‚áô y'" using myrel by (simp add: monoid_eq_mult)<br>
qed</p>
<p>lemma Ball_transfer[transfer_rule]:<br>
  includes lifting_syntax<br>
  assumes "monoid_eq F G"<br>
  shows "((monoid_eq_rel F G ===&gt; (=)) ===&gt; (=))<br>
    (Ball (carrier F)) (Ball (carrier G))"<br>
  unfolding Ball_def<br>
  apply(intro rel_funI, unfold rel_fun_def)<br>
  using assms by (metis monoid_eq.monoid_eq_carrier monoid_eq_rel_def)</p>
<p>Now, as you suggested, many results can be conveniently transferred, e.g.</p>
<p>lemma<br>
  includes lifting_syntax<br>
  assumes [transfer_rule]: "monoid_eq F G"<br>
  shows "‚àÄa‚ààcarrier G. ‚àÄb‚ààcarrier G. a ‚äó‚áòG‚áô b = a ‚äó‚áòG‚áô b"<br>
  apply transfer<br>
  (<em>‚àÄa‚ààcarrier F. ‚àÄb‚ààcarrier F. a ‚äó‚áòF‚áô b = a ‚äó‚áòF‚áô b</em>)<br>
  by simp</p>
<p>However, I am not certain if this exactly what you had in mind when you<br>
wrote your answer. Perhaps, the framework described above be improved<br>
further in some way? I guess, it would make sense to generalize it to<br>
arbitrary partial equivalences. Also, how would one deal with the transfer<br>
of Pure connectives? For example,</p>
<p>lemma<br>
  includes lifting_syntax<br>
  assumes [transfer_rule]: "monoid_eq F G"<br>
  shows "a ‚àà carrier G ‚üπ b ‚àà carrier G ‚üπ a ‚äó‚áòG‚áô b = a ‚äó‚áòG‚áô b"<br>
  apply transfer<br>
  (<em>((monoid_eq_rel ?F24 G ===&gt; (=)) ===&gt; (=)) ?aa23 transfer_forall</em>)<br>
  by simp</p>
<p>I guess, this problem is also not specific to equality, but any partial<br>
equivalence relation (or, even more generally, any relation between two<br>
arbitrary subsets). I can see that one could automate atomization and<br>
introduction of Pure connectives before and after performing<br>
transfer, respectively. Nonetheless, I am curious whether there exists a<br>
more native solution.</p>
<p>Kind Regards,<br>
Mikhail Chekhov</p>
<p>On Sat, Apr 18, 2020 at 12:18 PM Andreas Lochbihler &lt;<br>
<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt; wrote:</p>
<blockquote>
<p>Dear Mikhail,</p>
<p>I'm not surprised that option 2 creates a lot of effort because you change<br>
the locale<br>
specification. With option 1, you essentially get congruence rules of the<br>
form</p>
<p>monoid_eq F G ==&gt; x : carrier G ==&gt; <a href="http://monoid.foo">monoid.foo</a> F x = <a href="http://monoid.foo">monoid.foo</a> G x</p>
<p>for all derived concepts that are defined in monoid. Reasoning with such<br>
congruence rules<br>
can become cumbersome because the simplifier is not really able to reason<br>
with them<br>
natively. Moreover, you need a separate interpretation of monoid_eq for<br>
every pair of<br>
monoids you consider. If there are many, the number of interpretations<br>
grow quadratically<br>
in the worst case.</p>
<p>Defining the partial quotient as a type is not really feasible because<br>
type definitions<br>
must not depend on values in Isabelle/HOL, so you'd have to do the<br>
construction for every<br>
fixed monoid separately.</p>
<p>There are two further options that I want to mention. First, you can<br>
define a<br>
normalization function normalize :: 'a monoid =&gt; 'a =&gt; 'a via</p>
<p>normalize F x = (if x : carrier F then x else undefined)</p>
<p>and then lift it to a normalization function on monoid:</p>
<p>normalize_monoid :: 'a monoid =&gt; 'a monoid</p>
<p>that restricts the monoid operation to the carrier and sets it to<br>
undefined everywhere<br>
else. You can then prove</p>
<p>monoid F ==&gt; normalize_monoid F</p>
<p>and for all operations <a href="http://monoid.foo">monoid.foo</a> defined on monoids equations such as the<br>
following:</p>
<p>"x : carrier F ==&gt; <a href="http://monoid.foo">monoid.foo</a> F x = <a href="http://monoid.foo">monoid.foo</a> (normalize_monoid F) x"</p>
<p>If you equip these equations with an assumption<br>
   "NO_MATCH (normalize_monoid G) F"<br>
then you can even use them as simp rules without looping.</p>
<p>So whenever you need to exploit the equality of monoids, you can add those<br>
equations to<br>
the simpset and switch all involved monoids F to "normalize_monoid F". And<br>
for these<br>
normalized monoids, you actually get the equality "normalize_monoid F =<br>
normalize_monoid G".</p>
<p>A few caveats of this approach:</p>
<ol>
<li>
<p>This only pays of if you have equalities between many monoids. If there<br>
are just two or<br>
three, it's probably not worth the effort.</p>
</li>
<li>
<p>Going from F to normalize_monoid F works well for declarative proofs<br>
where you<br>
explicitly state the equality and then have simp transfer both sides. It<br>
does not work<br>
well with exploratory proof styles where you interactively develop the<br>
proof like with an<br>
apply script.</p>
</li>
<li>
<p>The rewriting to normalize_monoid is limited to what simp can do. For<br>
example,<br>
replacements under higher-order operators like fold will not work in<br>
general because simp<br>
cannot solve the side conditions _ : carrier _, even if you supply<br>
congruence rules.</p>
</li>
</ol>
<p>The second approach is to use transfer. You can use your monoid_eq as a<br>
the relator for<br>
monoids and then prove appropriate transfer rules for all the operations<br>
on monoids. You<br>
should then be able to move from one monoid to the other by declaring the<br>
suitable<br>
monoid_eq fact as [transfer_rule] and let transfer do the rest. That's<br>
probably what I<br>
would go for.</p>
<p>Best,<br>
Andreas</p>
<p>On 17/04/2020 15:09, Mikhail Chekhov wrote:</p>
<blockquote>
<p>Dear All,</p>
<p>I have a technical question for those who are well versed in<br>
the formalizaton of applied mathematics in Isabelle/HOL using set-based<br>
reasoning in HOL-Algebra (or similar).</p>
<p>I am curious as to what is the canonical approach for dealing with the<br>
equality of algebraic structures (e.g. monoids). Suppose, a given monoid<br>
undergoes a sequence of transformations, the result of these<br>
transformations being an identical monoid (isomorphisms are not good<br>
enough).</p>
<p>I am aware of two different solutions, but I am not certain whether there<br>
exist (better) alternatives and which solution would be preferred/more<br>
canonical?</p>
<ol>
<li>(Partial) equivalence relation. For example,</li>
</ol>
<p>locale monoid_eq = monoid G + monoid F for G F +<br>
   assumes "carrier G = carrier F"<br>
     and "x ‚àà carrier G ‚üπ y ‚àà carrier G ‚üπ x ‚äó‚áòG‚áô y = x ‚äó‚áòF‚áô y"<br>
     and "ùü≠‚áòG‚áô = ùü≠‚áòF‚áô"</p>
<p>It should also be possible to define a partial quotient type based on<br>
monoid_eq. However, I can imagine that this could result in a substantial<br>
amount of boilerplate code (one would wish to transfer the entire<br>
HOL-Algebra to the new type(s)).</p>
<ol start="2">
<li>Augmentation of the monoid locale with an additional condition that<br>
mimics the restriction of the domain of the operation ‚äó to the carrier<br>
set<br>
via undefined. Once this is done, one can use the standard HOL's<br>
eq<br>
[message truncated]</li>
</ol>
</blockquote>
</blockquote>



<a name="294827344"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294827344" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294827344">(Aug 23 2022 at 08:58)</a>:</h4>
<p>From: Clemens Ballarin &lt;<a href="mailto:ballarin@in.tum.de">ballarin@in.tum.de</a>&gt;<br>
If you go for the "undefined" approach, you indeed need to do it <br>
systematically.</p>
<p>In my recent case study [1], for the required quotient constructions, I <br>
only needed to explicitly talk about undefinedness in definitions, not <br>
specifications.  With suitable lemmas on undefinedness I found that the <br>
simplifier's splitter was able to deal with the arising proof <br>
obligations mostly automatically.  I only needed a few of these lemmas, <br>
and you can find them by searching for "undefined" in the associated <br>
theory files [2].  The study contains a brief discussion on the topic in <br>
section 5.2.</p>
<p>Clemens</p>
<p>[1] <a href="http://dx.doi.org/10.1007/s10817-019-09537-9">http://dx.doi.org/10.1007/s10817-019-09537-9</a> (unofficial version at <br>
<a href="http://www21.in.tum.de/~ballarin/publications/jar2019.pdf">http://www21.in.tum.de/~ballarin/publications/jar2019.pdf</a>)<br>
[2] <br>
<a href="https://www.isa-afp.org/browser_info/current/AFP/Jacobson_Basic_Algebra/index.html">https://www.isa-afp.org/browser_info/current/AFP/Jacobson_Basic_Algebra/index.html</a></p>



<a name="294827348"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294827348" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294827348">(Aug 23 2022 at 08:58)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt;<br>
Dear Mikhail,</p>
<blockquote>
<p>If I understood what is stated in your answer correctly, the second solution that you <br>
suggested is not entirely different from the first approach that I proposed in my <br>
question. Naturally, I never suggested that one should rely on the simplifier/congruence <br>
rules exclusively. Indeed, I rely predominantly on the capabilities of the transfer <br>
package to transfer the results across the members of a given equivalence class (however, <br>
I only mentioned it in passing in the last paragraph of the question and your answer gave <br>
me additional ideas for improvement of my own framework for transfer).<br>
Oh sorry, I missed that your mentioning of transfer referred to the transfer method.</p>
</blockquote>
<blockquote>
<p>Nonetheless, given <br>
what you have stated, I am still not certain if I am using transfer in the best possible <br>
manner. For example, consider the following framework,</p>
<p>locale monoid_eq = monoid G + monoid F for G F +<br>
 ¬† ¬†assumes monoid_eq_carrier: "carrier G = carrier F"<br>
 ¬† ¬† ¬†and monoid_eq_mult:<br>
 ¬† ¬† ¬† "x ‚àà carrier G ‚üπ y ‚àà carrier G ‚üπ x ‚äó‚áòG‚áô y = x ‚äó‚áòF‚áô y"<br>
 ¬† ¬† ¬†and monoid_eq_one: "ùü≠‚áòG‚áô = ùü≠‚áòF‚áô"</p>
<p>definition monoid_eq_rel ::<br>
 ¬† "('a, 'b) monoid_scheme ‚áí ('a, 'c) monoid_scheme ‚áí 'a ‚áí 'a ‚áí bool"<br>
 ¬† where (*redundancy for symmetry :) *) "monoid_eq_rel F G a b =<br>
 ¬† ¬† (a = b ‚àß a ‚àà carrier F ‚àß b ‚àà carrier G ‚àß monoid_eq F G)"</p>
<p>lemma eq_transfer[transfer_rule]:<br>
 ¬† includes lifting_syntax<br>
 ¬† shows "(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (=) (=)"<br>
 ¬† unfolding monoid_eq_rel_def<br>
 ¬† by (intro rel_funI) auto</p>
<p>lemma carrier_transfer[transfer_rule]:<br>
 ¬† includes lifting_syntax<br>
 ¬† shows "(monoid_eq ===&gt; (=)) carrier carrier"<br>
 ¬† unfolding monoid_eq_def<br>
 ¬† using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>
 ¬† by blast</p>
<p>lemma mult_transfer[transfer_rule]:<br>
 ¬† includes lifting_syntax<br>
 ¬† shows "(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (mult F) (mult G)"</p>
</blockquote>
<p>Here you run into the problem that we don't have a dependent function relator (or more <br>
precisely, transfer does not support such a relator). So we cannot state this as a <br>
transfer rule of the form</p>
<p>"(monoid_eq ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult"</p>
<p>Fortunately, we only care here about whether elements are contained in a carrier. So how <br>
about defining a relator monoid_eq' by</p>
<p>monoid_eq' C F G = monoid_eq F G &amp; (C = %x. x : carrier G)</p>
<p>Now the carrier predicate C is explicit and we can refer to it in the rules:</p>
<p>"(monoid_eq' C ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult"</p>
<p>This has the advantage that we relate only atomic terms, which work better with transfer <br>
than composite terms like "mult F" and "mult G" as in your rule. You should not need <br>
monoid_rel_eq then either and it should work well with the standard transfer rules for <br>
library constants.</p>
<p>Best,<br>
Andreas</p>



<a name="294827354"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294827354" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294827354">(Aug 23 2022 at 08:58)</a>:</h4>
<p>From: Mikhail Chekhov &lt;<a href="mailto:mikhail.chekhov.w@gmail.com">mikhail.chekhov.w@gmail.com</a>&gt;<br>
Dear Andreas Lochbihler/All,</p>
<p>Once again, thank you for your reply.</p>
<blockquote>
<p>Oh sorry, I missed that your mentioning of transfer referred to the<br>
transfer method.</p>
<p>Most certainly, there is no need to apologize: I was the one who failed to<br>
pose the question in a comprehensive manner :).</p>
</blockquote>
<blockquote>
<p>Fortunately, we only care here about whether elements are contained in a<br>
carrier. So how<br>
about defining a relator monoid_eq' by<br>
   monoid_eq' C F G = monoid_eq F G &amp; (C = %x. x : carrier G)<br>
Now the carrier predicate C is explicit and we can refer to it in the<br>
rules:<br>
   "(monoid_eq' C ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult"</p>
<p>Thank you for your advice. Indeed, this is exactly what I was looking for.<br>
Unfortunately, I was unaware of this method and somehow I did not think of<br>
it when I started working on the framework for transfer.</p>
</blockquote>
<p>Nonetheless, I am not certain whether/how it resolves the most fundamental<br>
issue. Many constants require some form of the totality of the relation as<br>
a prerequisite for the possibility of a transfer rule to be established,<br>
e.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc methods<br>
to avoid having to deal with the transfer of such constants (e.g. by<br>
converting the statements of the theorems to the form that uses Ball/Bex,<br>
while partially relying on tailor-made automation to achieve this).<br>
However, I wonder whether there exists a more native solution (after all,<br>
the premises should always carry sufficient information for the transfer to<br>
succeed).</p>
<p>As a side remark, I tried to explain the issue that is described in the<br>
previous paragraph of this email in the last two paragraphs of my previous<br>
email. However, having re-read them, I realized that I missed the point<br>
almost completely: please ignore the last two paragraphs of my previous<br>
email. Nonetheless, the example before the last paragraph is still relevant:</p>
<p>lemma carrier_transfer[transfer_rule]:<br>
  includes lifting_syntax<br>
  shows "(monoid_eq' C ===&gt; rel_set (eq_onp C)) carrier carrier"<br>
  unfolding monoid_eq'_def monoid_eq_def  eq_onp_def rel_set_def<br>
  using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>
  by blast</p>
<p>lemma [transfer_rule]:<br>
  includes lifting_syntax<br>
  shows "(eq_onp C ===&gt; eq_onp C ===&gt; (=)) (=) (=)"<br>
  unfolding eq_onp_def by auto</p>
<p>lemma [transfer_rule]:<br>
  includes lifting_syntax<br>
  shows "(eq_onp C ===&gt; rel_set (eq_onp C) ===&gt; (=)) (‚àà) (‚àà)"<br>
  unfolding eq_onp_def rel_set_def by auto</p>
<p>lemma<br>
  includes lifting_syntax<br>
  assumes [transfer_rule]: "monoid_eq' C F G"<br>
  shows "a ‚àà carrier G ‚üπ b ‚àà carrier G ‚üπ a ‚äó‚áòG‚áô b = a ‚äó‚áòG‚áô b"<br>
  apply transfer<br>
  (<em>Transfer.Rel ((eq_onp C ===&gt; (=)) ===&gt; (=)) ?aa25 transfer_forall</em>)<br>
  oops</p>
<p>Lastly, please accept my apologies for asking so many questions on this<br>
topic lately. The reason for this is that I am trying to be careful to<br>
ensure that the framework for transfer is designed in a more-or-less<br>
canonical manner, as I believe that it has a potential for being<br>
generalized to arbitrary partial equivalence relations on set-based<br>
structures defined using records (or similar). Naturally, I will share it<br>
under the terms of a BSD license when/if it will reach a certain state of<br>
generality and maturity.</p>
<p>Kind Regards,<br>
Mikhail Chekhov</p>
<p>On Sun, Apr 19, 2020 at 7:10 PM Andreas Lochbihler &lt;<br>
<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt; wrote:</p>
<blockquote>
<p>Dear Mikhail,</p>
<blockquote>
<p>If I understood what is stated in your answer correctly, the second<br>
solution that you<br>
suggested is not entirely different from the first approach that I<br>
proposed in my<br>
question. Naturally, I never suggested that one should rely on the<br>
simplifier/congruence<br>
rules exclusively. Indeed, I rely predominantly on the capabilities of<br>
the transfer<br>
package to transfer the results across the members of a given<br>
equivalence class (however,<br>
I only mentioned it in passing in the last paragraph of the question and<br>
your answer gave<br>
me additional ideas for improvement of my own framework for transfer).<br>
Oh sorry, I missed that your mentioning of transfer referred to the<br>
transfer method.</p>
</blockquote>
<blockquote>
<p>Nonetheless, given<br>
what you have stated, I am still not certain if I am using transfer in<br>
the best possible<br>
manner. For example, consider the following framework,</p>
<p>locale monoid_eq = monoid G + monoid F for G F +<br>
    assumes monoid_eq_carrier: "carrier G = carrier F"<br>
      and monoid_eq_mult:<br>
       "x ‚àà carrier G ‚üπ y ‚àà carrier G ‚üπ x ‚äó‚áòG‚áô y = x ‚äó‚áòF‚áô y"<br>
      and monoid_eq_one: "ùü≠‚áòG‚áô = ùü≠‚áòF‚áô"</p>
<p>definition monoid_eq_rel ::<br>
   "('a, 'b) monoid_scheme ‚áí ('a, 'c) monoid_scheme ‚áí 'a ‚áí 'a ‚áí bool"<br>
   where (*redundancy for symmetry :) *) "monoid_eq_rel F G a b =<br>
     (a = b ‚àß a ‚àà carrier F ‚àß b ‚àà carrier G ‚àß monoid_eq F G)"</p>
<p>lemma eq_transfer[transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (=) (=)"<br>
   unfolding monoid_eq_rel_def<br>
   by (intro rel_funI) auto</p>
<p>lemma carrier_transfer[transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(monoid_eq ===&gt; (=)) carrier carrier"<br>
   unfolding monoid_eq_def<br>
   using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>
   by blast</p>
<p>lemma mult_transfer[transfer_rule]:<br>
   includes lifting_syntax<br>
   shows "(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (mult F)<br>
(mult G)"</p>
</blockquote>
<p>Here you run into the problem that we don't have a dependent function<br>
relator (or more<br>
precisely, transfer does not support such a relator). So we cannot state<br>
this as a<br>
transfer rule of the form</p>
<p>"(monoid_eq ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult"</p>
<p>Fortunately, we only care here about whether elements are contained in a<br>
carrier. So how<br>
about defining a relator monoid_eq' by</p>
<p>monoid_eq' C F G = monoid_eq F G &amp; (C = %x. x : carrier G)</p>
<p>Now the carrier predicate C is explicit and we can refer to it in the<br>
rules:</p>
<p>"(monoid_eq' C ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult"</p>
<p>This has the advantage that we relate only atomic terms, which work better<br>
with transfer<br>
than composite terms like "mult F" and "mult G" as in your rule. You<br>
should not need<br>
monoid_rel_eq then either and it should work well with the standard<br>
transfer rules for<br>
library constants.</p>
<p>Best,<br>
Andreas<br>
</p>
</blockquote>



<a name="294827374"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Equality%20for%20set-based%20reasoning%20using%20the%20str.../near/294827374" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Equality.20for.20set-based.20reasoning.20using.20the.20str.2E.2E.2E.html#294827374">(Aug 23 2022 at 08:58)</a>:</h4>
<p>From: Mikhail Chekhov &lt;<a href="mailto:mikhail.chekhov.w@gmail.com">mikhail.chekhov.w@gmail.com</a>&gt;<br>
Dear Clemens Ballarin/All,</p>
<p>Thank you for providing the references. Indeed, your work does provide an<br>
answer to one of my own old questions on the mailing list, i.e.<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00006.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00006.html</a><br>
.</p>
<p>I can hardly claim that my own use of proof automation in conjunction with<br>
'undefined' could not be improved. Nonetheless, there are other reasons why<br>
I am still inclined to prefer the use of an explicit equivalence relation<br>
in conjunction with transfer for my application.</p>
<p>Kind Regards,<br>
Mikhail Chekhov</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>