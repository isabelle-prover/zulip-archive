<html>
<head><meta charset="utf-8"><title>[isabelle] Evaluation of record expressions · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html">[isabelle] Evaluation of record expressions</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294250575"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294250575" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294250575">(Aug 19 2022 at 12:02)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
Hi Andrew, </p>
<p>Thank you for your kind answer, that's what I searched for. <br>
Regarding the first (and more important question) : the relation symbol can be treated as a "&lt;" relation. </p>
<p>Andrew Boyton &lt;<a href="mailto:Andrew.Boyton@nicta.com.au">Andrew.Boyton@nicta.com.au</a>&gt; schrieb:</p>



<a name="294250887"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294250887" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294250887">(Aug 19 2022 at 12:04)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
Is there nobody with a clue?</p>



<a name="294250914"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294250914" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294250914">(Aug 19 2022 at 12:04)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@gmail.com">jasmin.blanchette@gmail.com</a>&gt;<br>
Dear Michael,</p>
<p>No, we are all clueless. ;)</p>
<p>I presume you refer to the first question you posted some time ago. First of all, the theory snippet you pasted into your email cannot be parsed back by Isabelle (importing "Complex_Complex"). The parser chokes on "⊩". That makes it harder for us to help you.</p>
<p>Second, there is no silver bullet in Isabelle that will prove finite goals. (I'm taking your claim at face value; being unable to parse the formula you sent, I cannot infer the types and check finiteness.) The closest thing to it is Nitpick, but you would have to trust it as an oracle. See e.g. my paper [1] for an instance where we used Nitpick for exhaustive verification.</p>
<p>I presume that a properly set up "blast" or "auto" might be able to finish the job. Sometimes it's just a matter of adding a few intro, elim, or split rules; perhaps one of the experts could help you, once they are given a self-contained example.</p>
<p>Regards,</p>
<p>Jasmin</p>
<p>[1] <a href="http://www21.in.tum.de/~blanchet/ppdp2011-cpp-mem.pdf">http://www21.in.tum.de/~blanchet/ppdp2011-cpp-mem.pdf</a></p>



<a name="294250949"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294250949" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294250949">(Aug 19 2022 at 12:05)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
Dear Jasmin, </p>
<p>Indeed, that was my fault. I work with custom theories where this symbol is treated as "&lt;" (less relation) and I forgot to replace it. Hope you could somehow help me now. My goal is just to make isabelle split all possible cases as they are finite and then solve every case for itself. Thanks! </p>
<p>Regards <br>
Michael </p>
<p>Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@gmail.com">jasmin.blanchette@gmail.com</a>&gt; schrieb:</p>



<a name="294250985"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294250985" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294250985">(Aug 19 2022 at 12:05)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@gmail.com">jasmin.blanchette@gmail.com</a>&gt;<br>
Hi Michael,</p>
<p>I fail to see why your problem is finite. The pair of assumptions "forall s. ..." quantify over all states, of which there are infinitely many. I see some "if"s that could perhaps be split into separate cases, but they are under the scope of lambdas that bind again an infinite variable.</p>
<p>Also, some of your variables seem to have overly general types, e.g. "a" has type 'a. Indeed, Nitpick reports a "potentially spurious" counterexample that appears to be genuine.</p>
<p>Regards,</p>
<p>Jasmin</p>



<a name="294251007"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294251007" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294251007">(Aug 19 2022 at 12:05)</a>:</h4>
<p>From: Johannes Hölzl &lt;<a href="mailto:hoelzl@in.tum.de">hoelzl@in.tum.de</a>&gt;<br>
Am Dienstag, den 08.10.2013, 18:14 +0200 schrieb Michael Vu:</p>
<blockquote>
<p>Dear isabelle experts,</p>
<p>I am currently working with records and I'm trying to write a small automation tool for generating calculations. But I'm stuck at proving some simple expressions like this one:</p>
<p>record state =<br>
  t  :: real<br>
  c :: real</p>
<p>lemma weakly_bounded:<br>
"0 &lt; a ⟹<br>
    a &lt; 1 ⟹<br>
    0 &lt; b ⟹<br>
    b &lt; 1 ⟹<br>
    0 &lt; a + b - a * b ⟹<br>
    ∀s. t s = 0 ∨ t s = 1 ⟹<br>
    ∀s. c s = 0 ∨ c s = 1 ⟹<br>
    λs. (if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
        (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a /<br>
        (a + b -<br>
         a * b) ⊩ λs. (if c s ≠ 1 then 1 else 0) *
                      ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
                       (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b))"</p>
<p>I thought simp would be enough to evaluate this, but it seems not to be the case. So I am looking for a way to make isabelle automatically verify<br>
all possible states (the space is finite due to the conditions). I would appreciate every help.</p>
</blockquote>
<p>Is ⊩ point wise  less or equal? If yes, you first should<br>
unfold fun_le_def, then the splitter can operate on it. Also I don't<br>
think that the simplifier can deduce that the set of states is finite.</p>
<blockquote>
<p>And secondly I've another cosmetic question. Given following subgoals:</p>
<ol>
<li>0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 ≤ a</li>
<li>0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 ≤ 1 - b</li>
<li>0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 ≤ a</li>
<li>some complicated subgoal<br>
apply(simp) <br>
apply(simp)<br>
apply(simp) </li>
</ol>
<p>Is there any more elegant way other than to invoke simp 3 times? I also tried "auto" but it gets stuck on subgoal 4. </p>
</blockquote>
<p>You can use Isar to proof subgoal 4 first and subgoal 1, 2, 3 by the<br>
qed-command:</p>
<p>proof -<br>
  assumes "" then show "" ...<br>
qed simp_all</p>
<p>- Johannes</p>



<a name="294251067"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294251067" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294251067">(Aug 19 2022 at 12:05)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
Hello Johannes,</p>
<p>Yes, "⊩" basically means "≤".<br>
I tried to define a similar lemma:</p>
<p>lemma test_bounded:<br>
  "0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 &lt; a + b - a * b ⟹<br>
    ∀s. ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
        (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a /<br>
        (a + b -<br>
         a * b)) ≤ ((if c s ≠ 1 then 1 else 0) *
                      ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
                       (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b)))"<br>
  apply(rule allI)<br>
  apply(auto)</p>
<p>In this case the simplifier is able to split all possible cases, it's just the matter that it won't evaluate all expressions afterwards.<br>
So my question is if there's a way how i can deduce this test_bounded lemma from the first one I posted and then make Isabelle evaluate all<br>
cases. Thanks!</p>
<p>Michael</p>



<a name="294251086"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294251086" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294251086">(Aug 19 2022 at 12:05)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
I tried to define a similar lemma:</p>
<p>lemma test_bounded:<br>
  "0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 &lt; a + b - a * b ⟹<br>
    ∀s. ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
        (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a /<br>
        (a + b -<br>
         a * b)) ≤ ((if c s ≠ 1 then 1 else 0) *
                      ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
                       (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b)))"<br>
  apply(rule allI)<br>
  apply(auto)</p>
<p>In this case the simplifier is able to split all possible cases, it's just the matter that it won't evaluate all expressions afterwards.<br>
So my question is if there's a way how i can deduce this test_bounded lemma from the first one I posted and then make Isabelle evaluate all<br>
cases.<br>
Regarding the variables a and b: That's my fault again, happens when I try to cut a snippet from my code..You can assume that they are defined as ::real.</p>
<p>Michael</p>



<a name="294251179"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294251179" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294251179">(Aug 19 2022 at 12:06)</a>:</h4>
<p>From: Thomas Sewell &lt;<a href="mailto:thomas.sewell@nicta.com.au">thomas.sewell@nicta.com.au</a>&gt;<br>
Hey all.</p>
<p>I had a look at this on the assumption that this was somehow related to <br>
the record package.</p>
<p>Looking at this test lemma, it would seem that</p>
<p>a) it is false in the case where "t s = 1 &amp; c s = 1 &amp; a * 2 = 1 &amp; b * 2 = 1"<br>
b) it seems to have nothing to do with the record package<br>
c) nothing needs to be evaluated, instead, hypotheses need to be proven, <br>
which is hard when they're false.</p>
<p>You can see that the lemma is false via:<br>
   apply (rule allI)<br>
   apply (case_tac "t s = 1 &amp; c s = 1 &amp; a = 0.5 &amp; b = 0.5")<br>
    apply (elim conjE, simp only: )<br>
    apply (simp add: field_simps)</p>
<p>(the fact that all these tools are conservative means the original goal <br>
was false also)</p>
<p>I'm not exactly sure what you're looking for.</p>
<p>Good luck,<br>
     Thomas.</p>



<a name="294251458"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294251458" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294251458">(Aug 19 2022 at 12:08)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
Hello Thomas, hello all,</p>
<p>you're right, I really failed...Thanks for your counter example. Well the reason behind this is that i work with a custom package of theorems and used the wrong lemma which resulted in an unsolveable goal. So I'm really sorry.<br>
Anyway, I managed to correct this and now Isabelle outputs this subgoal:</p>
<p>0 &lt; (a::real) ⟹<br>
a &lt; 1 ⟹<br>
0 &lt; b ⟹<br>
b &lt; 1 ⟹<br>
0 &lt; a + b - a * b ⟹<br>
∀s. t s = 0 ∨ t s = 1 ⟹<br>
∀s. c s = 0 ∨ c s = 1 ⟹<br>
    (THE ba. isLub UNIV<br>
              (range (λs. (if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
                          (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b)))<br>
              ba)<br>
    ≤ (THE ba. isLub UNIV<br>
                (range (λs. (if c s ≠ 1 then 1 else 0) *
                            ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
                             (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b))))<br>
                ba)</p>
<p>The remaining functions are all defined in Set.thy/Lubs.thy and now I am stuck on how to prove this. This subgoal just shows that the upper bound of <br>
the first lambda function is less or equal than the upper bound of the second function. Any help would be appreciated. I hope I didn't forget anything this time. Thanks!</p>
<p>Michael</p>



<a name="294251473"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294251473" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294251473">(Aug 19 2022 at 12:08)</a>:</h4>
<p>From: Thomas Sewell &lt;<a href="mailto:thomas.sewell@nicta.com.au">thomas.sewell@nicta.com.au</a>&gt;<br>
Hey Michael.</p>
<p>Sorry about being short with you before. I wasn't actually annoyed by <br>
the previous question, just pointing out that it didn't quite make sense <br>
and there was probably a misunderstanding inherent in it somewhere.</p>
<p>It looks like you're closer to the right track. I note two things you <br>
might want to work on.</p>
<p>My first observation was that you probably want to hide the THE operator <br>
somehow. Using Hilbert choice semantically is fine (as long as you're OK <br>
with it), but the operator also happens to be syntactically difficult to <br>
grapple with.</p>
<p>In short, "THE x. isLub UNIV (range f) x" seems like a verbose <br>
description of the least upper bound of<br>
"range f". I wonder if there's an instantiation/proof anywhere that lets <br>
you show "(THE x. isLub UNIV (range f) x) = Sup (range f)".</p>
<p>I don't have an answer to that myself, I don't really know anything <br>
about reals in Isabelle. Maybe one of the calculus experts can comment?</p>
<p>The other problem is that you're assuming that "t s" is 0 or 1 for every <br>
s. That's never true. So your proof can be finished by:<br>
   apply (drule_tac x="some_value (| t := 0.5 |)" in spec)<br>
   apply simp<br>
   done</p>
<p>That's almost certainly not what you want. I guess you probably just <br>
want to constrain the s's considered in computing the ranges of the <br>
lambda functions, but you would do that by replace range f<br>
with f ` S instead.</p>
<p>Good luck,<br>
     Thomas.</p>



<a name="294252502"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294252502" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294252502">(Aug 19 2022 at 12:14)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
Hi Thomas, hi all,</p>
<p>Thank you for your answer. I am using some kind of "framework" so that expression is defined as followed:</p>
<p>definition bound_of :: "('a ⇒ 'b::complete) ⇒ 'b"<br>
where     "bound_of P ≡ THE b. isLub UNIV (P ` UNIV) b"</p>
<p>There are also some Lemmas regarding to "bound_of" but none which exactly fits my goal. But that makes it impossible for me to change it nor to fix the second problem because this is just a subgoal of another lemma and I just unfolded the definition. Or could you find any way to improve it?<br>
Any answers would be appreciated :)</p>
<p>Michael</p>



<a name="294252561"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294252561" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294252561">(Aug 19 2022 at 12:15)</a>:</h4>
<p>From: Thomas Sewell &lt;<a href="mailto:thomas.sewell@nicta.com.au">thomas.sewell@nicta.com.au</a>&gt;<br>
Hey Michael.</p>
<p>I've had a think about your bound_of definition and the interesting case <br>
you're using it in.</p>
<p>The only obvious thing I can prove about it is that it has the "obvious" <br>
value if you happen to know what the maximum is:</p>
<p>lemma bound_of_eq_max:<br>
   "[| ALL y. f y &lt;= f x |] ==&gt; bound_of f = f x"<br>
   apply (simp add: bound_of_def)<br>
   apply (rule the_equality)<br>
    apply (simp add: isLub_def leastP_def isUb_def setge_def setle_def)<br>
   apply (simp add: isLub_def leastP_def isUb_def setge_def setle_def)<br>
   apply (auto intro: antisym)<br>
   done</p>
<p>(I'm using the ASCII versions of syntax in case of transmission issues, <br>
however maybe Unicode has gotten better than this.)</p>
<p>It's not clear in your case that you'll know what the maximum value is, <br>
however. It might depend on a or b. What simplifies your case is that it <br>
looks like your lambda function is only interested in "t s = 0", "t s = <br>
1" etc. This made me think you could prove it was equal to a composition <br>
of functions:</p>
<p>record state =<br>
    t  :: real<br>
    c :: real</p>
<p>record state =<br>
    t  :: real<br>
    c :: real</p>
<p>lemma ts_01_etc_lemma:<br>
   "(%(x :: state). f (t x = 0) (t x = 1) (c x = 0) (c x = 1))<br>
     = (%(a, b). f (a = Some False) (a = Some True) (b = Some False) (b <br>
= Some True))<br>
         o (%x. ([0 |-&gt; False, 1 |-&gt; True] (t x), [0 |-&gt; False, 1 |-&gt; <br>
True] (c x)))"<br>
   by (simp add: o_def fun_eq_iff)</p>
<p>lemma fun_01_eq_surj:<br>
   "surj (%(x :: state). ([0 |-&gt; False, (1 :: real) |-&gt; True] (t x), [0 <br>
|-&gt; False, 1 |-&gt; True] (c x)))"<br>
   apply (rule_tac f="%x. (| t = (case x of (Some False, _) =&gt; 0 | (Some <br>
True, _) =&gt; 1 | (None, _) =&gt; 2),<br>
                             c = (case x of (_, Some False) =&gt; 0 | (_, <br>
Some True) =&gt; 1 | (_, None) =&gt; 2) |)" in surjI)<br>
   apply (simp split: sum.split prod.split option.split bool.split)<br>
   done</p>
<p>This is useful, because the bound of "g o f" ought to be the bound of g, <br>
assuming f is surjective.</p>
<p>lemma range_compose:<br>
   "surj g ==&gt; range (f o g) = range f"<br>
   by (metis image_compose)</p>
<p>lemma bound_of_compose:<br>
   "surj g ==&gt; bound_of (f o g) = bound_of f"<br>
   by (simp add: bound_of_def range_compose)</p>
<p>lemma bound_of_eq_by_compose:<br>
   "g = f o h ==&gt; surj h ==&gt; bound_of g = bound_of f"<br>
   by (simp add: bound_of_compose)</p>
<p>thm bound_of_eq_by_compose</p>
<p>Finally, computing the bound of the minimal function extracted in this <br>
way ought to be easier since it has a finite domain. I can use <br>
enumeration to expand it:</p>
<p>lemma fold_max_ge:<br>
   "(fold max xs y &gt;= (z :: 'a :: linorder)) = (y &gt;= z | (EX x : set xs. <br>
x &gt;= z))"<br>
   apply (induct xs arbitrary: y)<br>
    apply (auto simp: le_max_iff_disj)<br>
   done</p>
<p>lemma fold_max_le:<br>
   "(fold max xs y &lt;= (z :: 'a :: linorder)) = (y &lt;= z &amp; (ALL x : set <br>
xs. x &lt;= z))"<br>
   by (induct xs arbitrary: y, auto)</p>
<p>lemma bound_of_by_enum_vs:<br>
   "UNIV = set vs ==&gt;<br>
     bound_of f = fold max (map f vs) (f (hd vs))"<br>
   apply (simp add: bound_of_def)<br>
   apply (subgoal_tac "hd vs : set vs")<br>
    apply (erule ssubst)<br>
    apply (rule the_equality[OF _ antisym, rotated])<br>
      apply (simp_all add: isLub_def leastP_def isUb_def setge_def <br>
setle_def)<br>
     apply clarsimp<br>
     apply (drule spec, erule mp)<br>
     apply (auto simp: fold_max_le fold_max_ge)<br>
   done</p>
<p>lemmas bound_of_by_enum = bound_of_by_enum_vs[OF UNIV_enum]</p>
<p>thm trans[OF bound_of_eq_by_compose[OF ts_01_etc_lemma fun_01_eq_surj] <br>
bound_of_by_enum,<br>
     unfolded enum_prod_def enum_sum_def enum_option_def enum_bool_def, <br>
simplified]</p>
<p>It's a bit of a mess, but it looks like we can apply this to your kind <br>
of problem:</p>
<p>lemma "0 &lt; (a::real) ⟹<br>
a &lt; 1 ⟹<br>
0 &lt; b ⟹<br>
b &lt; 1 ⟹<br>
0 &lt; a + b - a * b ⟹<br>
     bound_of (λs :: state. (if t s = 0 ∧ c s = 0 then 1 else 0) + (if t <br>
s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
                           (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - <br>
b) * a / (a + b - a * b))<br>
     ≤ bound_of (λs :: state. (if c s ≠ 1 then 1 else 0) *
                             ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if <br>
t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>
                              (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 </p>
<ul>
<li>b) * a / (a + b - a * b)))"<br>
   apply (subst bound_of_eq_by_compose[OF ts_01_etc_lemma fun_01_eq_surj])+<br>
   apply (simp add: bound_of_by_enum enum_prod_def enum_sum_def <br>
enum_option_def enum_bool_def)<br>
   apply (simp add: max_def)<br>
   sorry</li>
</ul>
<p>This approach might be overspecialised, and you might have to use a <br>
bigger intermediate type, but <em>hopefully</em> you can throw away your <br>
records via this kind of reasoning, and maybe get a concrete result via <br>
enumeration.</p>
<p>Hope that helps. Happy hunting,<br>
     Thomas.</p>



<a name="294253933"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294253933" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294253933">(Aug 19 2022 at 12:24)</a>:</h4>
<p>From: Andrew Boyton &lt;<a href="mailto:Andrew.Boyton@nicta.com.au">Andrew.Boyton@nicta.com.au</a>&gt;<br>
To answer the simple question. Instead of</p>
<p>apply(simp)<br>
apply(simp)<br>
apply(simp)</p>
<p>you can go</p>
<p>apply(simp)+</p>
<p>or</p>
<p>apply(simp_all)</p>
<p>Strictly speaking, simp+ and simp_all have different semantics. simp_all works on all subgoals, where as simp+ works on the first subgoal, and if that discharges, it works on the second. Neither does exactly what the calling simp 3 times does, as they both try applying simp to the fourth goal. If you don't want that to happen, you can do the following</p>
<p>apply (simp+)[3]</p>
<p>which will limit simp+ to working on just three subgoals, but I suspect you don't need to.</p>
<p>Hope this helps.</p>
<p>Andrew</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294258300"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294258300" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294258300">(Aug 19 2022 at 12:50)</a>:</h4>
<p>From: Michael Vu &lt;<a href="mailto:michael.vu@rwth-aachen.de">michael.vu@rwth-aachen.de</a>&gt;<br>
Hey Thomas,</p>
<p>at first: many many thanks! That was quite a lot of information and very helpful. Sorry for my late answer, I had to take some time to understand the code and to discuss it with my supervisor. The idea is very interesting, I've never worked with enumerations before but it seems to be a good approach here. Anyway, it didn't completely work for me, I had some problems with the lemma "bound_of_by_enum_vs". It does not get proven by reaching the "done" statement:</p>
<p>goal (4 subgoals):</p>
<ol>
<li>⋀b y. hd vs ∈ set vs ⟹ ∀y∈set vs. f y ≤ b ⟹ y ∈ set vs ⟹ f y ≤ fold max (map f vs) (f (hd vs))</li>
<li>⋀b. hd vs ∈ set vs ⟹ ∀y∈set vs. f y ≤ b ⟹ ∀x. (∀y∈set vs. f y ≤ x) ⟶ b ≤ x ⟹ fold max (map f vs) (f (hd vs)) ≤ b</li>
<li>⋀y. hd vs ∈ set vs ⟹ y ∈ set vs ⟹ f y ≤ fold max (map f vs) (f (hd vs))</li>
<li>⋀x. hd vs ∈ set vs ⟹ ∀y∈set vs. f y ≤ x ⟹ fold max (map f vs) (f (hd vs)) ≤ x</li>
</ol>
<p>The approach is quite special but can be generalized for finite states, right? At first I thought that all problem classes I'm working with only have a finite number of states, but my supervisor showed me cases with infinite states. This should not work with enumerations should it? </p>
<p>Michael</p>



<a name="294258411"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Evaluation%20of%20record%20expressions/near/294258411" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Evaluation.20of.20record.20expressions.html#294258411">(Aug 19 2022 at 12:50)</a>:</h4>
<p>From: Thomas Sewell &lt;<a href="mailto:thomas.sewell@nicta.com.au">thomas.sewell@nicta.com.au</a>&gt;<br>
Hey Michael.</p>
<p>OK, two points. Firstly, this enumeration approach will only work for <br>
handling finitely many cases. I brought it up because your function <br>
happened to only care about finitely many valuations of "t x" and "c x". <br>
If it's more general than that, well, you'll need a different approach. <br>
And finding bounds of functions in general requires calculus or similar, <br>
which, of course, may be substantially more challenging. If you end up <br>
having to use Lagrange multipliers then, well, good luck to you.</p>
<p>Secondly, if one of the lemmas I typed didn't prove, it's probably <br>
because I typed it into a different version of Isabelle, but also <br>
possibly because I typed it in a context that contains a different set <br>
of simplification rules to yours.</p>
<p>What I typed seems to work in Isabelle-2013, in a context I built via<br>
"theory Scratch imports Lubs Real begin"</p>
<p>You might have to prove this theorem in the same context, or identify <br>
what's changed and fix it, or come up with a new proof of the same rule, <br>
or give us some more guidance as to how your context is built.</p>
<p>Good luck,<br>
     Thomas.</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>