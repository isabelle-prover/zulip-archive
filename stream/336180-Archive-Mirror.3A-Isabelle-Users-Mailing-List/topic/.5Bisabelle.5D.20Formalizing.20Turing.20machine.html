<html>
<head><meta charset="utf-8"><title>[isabelle] Formalizing Turing machine · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html">[isabelle] Formalizing Turing machine</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294084060"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294084060" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294084060">(Aug 18 2022 at 14:06)</a>:</h4>
<p>From: Wang Zirui &lt;<a href="mailto:zirui@nus.edu.sg">zirui@nus.edu.sg</a>&gt;<br>
Hi,</p>
<p>I'd like to formalize the definition of Turing machine. If possible,<br>
I'd like to do it without relying on ZFC. That is, I don't use sets,<br>
integers and so on.</p>
<p>Yes, in the definition of Turing machine we see sets, such as the set<br>
of states, but I think the use of set is convenient but not necessary.<br>
(Am I wrong?) So if you agree with me and think it's possible to go<br>
without sets, could you please outline how to define Turing machine?<br>
If you think this is impossible, can you give a proof?</p>
<p>Thanks.</p>
<p>Regards,<br>
Zirui Wang</p>



<a name="294084086"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294084086" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294084086">(Aug 18 2022 at 14:06)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Deac Zirui,</p>
<blockquote>
<p>I'd like to formalize the definition of Turing machine. If possible,<br>
I'd like to do it without relying on ZFC. That is, I don't use sets,<br>
integers and so on.</p>
</blockquote>
<p>There should be no problems with doing it in HOL. Note that HOL also has <br>
a notion of a set, although it is not quite the same as in ZFC.</p>
<blockquote>
<p>[...] So if you agree with me and think it's possible to go<br>
without sets, could you please outline how to define Turing machine?</p>
</blockquote>
<p>You may want to look at Tobias Nipkow's formalization of finite <br>
automata, which you can find in the AFP:</p>
<p><a href="http://afp.sourceforge.net/entries/Functional-Automata.shtml">http://afp.sourceforge.net/entries/Functional-Automata.shtml</a></p>
<p>It's not Turing Machines, but it may give you an idea...</p>
<p>Alex</p>



<a name="294084107"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294084107" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294084107">(Aug 18 2022 at 14:06)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Dear Zirui,</p>
<blockquote>
<p>The point of not relying on ZFC is because it's a strong theory. I<br>
don't want the definition of Turing machine to be based on a strong<br>
theory. I want it to be based on a theory that is as weak as possible.<br>
So it's best if it's based on nothing.</p>
</blockquote>
<p>Well, HOL is what people are typically using, and if you are new to <br>
Isabelle and are trying to use anything else, you are going to have a <br>
hard time, because other logics are much less developed in terms of tool <br>
support.</p>
<blockquote>
<p>Unfortunately HOL is at least as strong as ZFC because it has the idea<br>
of a set.</p>
</blockquote>
<p>HOL's notion of a set is much weaker, as sets are just identified with <br>
predicates over the respective type.</p>
<blockquote>
<p>My teacher Jain suggests that it might be possible to define<br>
Turing machine based on Peano Arithmetic, which is weaker than ZFC.<br>
And I'm going to try that.</p>
</blockquote>
<p>You can certainly try, and I think there should not be fundamental <br>
problems, but you will certainly suffer from the lack of tool support in <br>
your custom-made logic, as opposed to using something well-established.</p>
<p>If these foundational issues of taking the weakest logic possible are <br>
really the core of your interest, then you can try and go for Peano <br>
Arithmetic, but if your main interest is formalizing Turing Machines <br>
after all, then using anything but HOL is like cutting your left leg off <br>
before climbing a mountain.</p>
<blockquote>
<p>I don't understand the AFP formalization of automata as I read it.<br>
Does the author use the idea of sets, functions or numbers? If yes, he<br>
probably base the definition of automata on HOL or ZFC. But I want to<br>
base it on a weaker theory. Does the author do that?</p>
</blockquote>
<p>The formalization is based on HOL. If you have big trouble reading the <br>
formalization, this is probably an indication that you should learn some <br>
Isabelle basics first, e.g. by working through the Tutorial <br>
(<a href="http://isabelle.in.tum.de/dist/Isabelle/doc/tutorial.pdf">http://isabelle.in.tum.de/dist/Isabelle/doc/tutorial.pdf</a>)</p>
<p>Alex</p>



<a name="294084222"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294084222" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294084222">(Aug 18 2022 at 14:07)</a>:</h4>
<p>From: Wang Zirui &lt;<a href="mailto:zirui@nus.edu.sg">zirui@nus.edu.sg</a>&gt;<br>
Hi Alex,</p>
<p>The point of not relying on ZFC is because it's a strong theory. I<br>
don't want the definition of Turing machine to be based on a strong<br>
theory. I want it to be based on a theory that is as weak as possible.<br>
So it's best if it's based on nothing.</p>
<p>Unfortunately HOL is at least as strong as ZFC because it has the idea<br>
of a set. My teacher Jain suggests that it might be possible to define<br>
Turing machine based on Peano Arithmetic, which is weaker than ZFC.<br>
And I'm going to try that.</p>
<p>I don't understand the AFP formalization of automata as I read it.<br>
Does the author use the idea of sets, functions or numbers? If yes, he<br>
probably base the definition of automata on HOL or ZFC. But I want to<br>
base it on a weaker theory. Does the author do that?</p>
<p>Your suggestion of automata is certainly good as it has the same<br>
problem as Turing machines, but it's simpler.</p>
<p>Regards,<br>
Zirui</p>



<a name="294084247"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294084247" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294084247">(Aug 18 2022 at 14:07)</a>:</h4>
<p>From: Richard Waldinger &lt;<a href="mailto:waldinger@AI.SRI.COM">waldinger@AI.SRI.COM</a>&gt;<br>
didn't turing's original paper do a formalization? in some sort of  <br>
number theory, i forget which logic.</p>



<a name="294084287"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294084287" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294084287">(Aug 18 2022 at 14:07)</a>:</h4>
<p>From: Konrad Slind &lt;<a href="mailto:slind@cs.utah.edu">slind@cs.utah.edu</a>&gt;<br>
Hi,</p>
<p>Yes, you can define Turing machines in a very<br>
simple base theory. For example, you can use lists<br>
instead of sets because everything in a TM description<br>
has to be finite. So at least the preliminary theory<br>
of TMs can be done without higher order things like<br>
sets and functions. But going even a little bit into the<br>
theory, you will need to define computable functions etc.<br>
On the face of it, even the undecidability of the Halting<br>
Problem seems to need sets to state (i.e. the <em>set</em> of all<br>
halting TMs is undecidable).</p>
<p>I did some work on formalizing TMs in HOL-4 and the<br>
following definitions of the machines should be<br>
completely straightforward to turn into Isabelle/HOL syntax.<br>
Of course there is more to define, like machine configurations,<br>
executions, languages, etc. but I will omit those.</p>
<p>Also, doesn't the AFP include some computability theory<br>
already?</p>
<p>Cheers,<br>
Konrad.</p>
<p>(*---------------------------------------------------------------------- <br>
-----*)<br>
(* Turing machines, tape infinite in one  <br>
direction.                          *)<br>
(*---------------------------------------------------------------------- <br>
-----*)</p>
<p>Hol_datatype <code>dir = L | R</code>;</p>
<p>(*---------------------------------------------------------------------- <br>
-----*)<br>
(* Raw datatype of TMs. The only slightly odd thing may be that the  <br>
blank is *)<br>
(* explicitly included. Also, it turns out to facilitate the  <br>
definition of   *)<br>
(* executions if the initial value of the current cell is set to a  <br>
value.    *)<br>
(* Because having a "left-edge" marker simplifies many TM algorithms,  <br>
we set *)<br>
(* aside a particular "star" value for this  <br>
purpose.                         *)<br>
(*---------------------------------------------------------------------- <br>
-----*)</p>
<p>Hol_datatype<br>
<code>TM = &lt;| states     : 'state -&gt; bool ;
            inputsymbs : 'alpha -&gt; bool ;
            tapesymbs  : 'alpha -&gt; bool ;
            init       : 'state ;
            trans      : 'state -&gt; 'alpha -&gt; 'state # 'alpha # dir;
            accept     : 'state ;
            reject     : 'state ;
            blank      : 'alpha ;
            star       : 'alpha |&gt;</code>;<br>
(*---------------------------------------------------------------------- <br>
-----*)<br>
(* Predicate singling out the real Turing machines. Is in principle  <br>
an       *)<br>
(* executable thing, but we don't currently handle (bounded)  <br>
quantifiers.    *)<br>
(*---------------------------------------------------------------------- <br>
-----*)</p>
<p>val isTM_def =<br>
  Define<br>
<code>isTM (M : ('alpha,'state)TM) =
       FINITE M.states            /\
       FINITE M.inputsymbs        /\
       FINITE M.tapesymbs         /\
       M.blank IN M.tapesymbs     /\
       ~(M.blank IN M.inputsymbs) /\
       M.star IN M.inputsymbs     /\
       M.inputsymbs SUBSET M.tapesymbs /\
       M.accept IN M.states       /\
       M.reject IN M.states       /\
       ~(M.accept = M.reject)     /\
       M.init IN M.states         /\
       !a p q b d.
           a IN M.tapesymbs /\ p IN M.states /\ (M.trans p a = (q,b,d))
           ==&gt; q IN M.states /\ b IN M.tapesymbs</code>;</p>
<p>Cheers,<br>
Konrad.</p>



<a name="294084322"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294084322" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294084322">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Konrad Slind &lt;<a href="mailto:konrad.slind@gmail.com">konrad.slind@gmail.com</a>&gt;<br>
Hi Zirui,</p>
<p>TMs can be represented by bitstrings (or numbers).<br>
No sets. A TM evaluator can be written that takes<br>
in a bitstring, decodes it into a TM and an input,<br>
and simulates the execution of the TM on the input.<br>
That evaluator can itself be written out as a bitstring<br>
representing a TM. Any decent undergrad theory<br>
textbook will go into this in some amount of detail.<br>
So there is a certain portion of computability theory<br>
that is basic programming and can be formalized in<br>
a simple logic that doesn't formalize set theory.</p>
<p>On the other hand, much of computability is about<br>
infinite sets (not lists), some of which can be<br>
implemented by TMs and some which can't. Again,<br>
any undergrad theory text (or wikipedia) has<br>
plenty of detail.</p>
<p>Cheers,<br>
Konrad.</p>



<a name="294090595"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294090595" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294090595">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
You need to be much more specific about your research objectives and  <br>
about what you mean by set theory. Zermelo set theory is rather weak  <br>
(more or less equivalent to higher-order logic). ZF set theory is  <br>
considerably stronger, but there are set theories much stronger than  <br>
ZF. Then there is a question of the axiom of choice. Just to say "I  <br>
want to have nothing to do with the axioms of set theory" is not a  <br>
basis for a scientific discussion. People do choose to work in weak  <br>
formal systems, typically in order to investigate the power of those  <br>
systems.</p>
<p>Lawrence C Paulson<br>
Professor of Computational Logic<br>
Computer Laboratory, University of Cambridge<br>
15 JJ Thomson Avenue, Cambridge CB3 0FD, England<br>
Tel: +44(0)1223 334623    Fax: +44(0)1223 334678</p>



<a name="294090609"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294090609" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294090609">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:webertj@in.tum.de">webertj@in.tum.de</a>&gt;<br>
Turing machines are finite objects.  They can be encoded as numbers (via<br>
some Gödel numbering, cf.<br>
<a href="http://en.wikipedia.org/wiki/G%C3%B6del_number">http://en.wikipedia.org/wiki/G%C3%B6del_number</a>).</p>
<p>So depending on what you want to prove exactly, and provided that you<br>
don't want to speak about (infinite) sets of Turing machines, you may<br>
indeed be able to avoid set theory entirely, and merely work in (some<br>
fragment of) a theory of arithmetic (cf.<br>
<a href="http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/">http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/</a>,<br>
<a href="http://en.wikipedia.org/wiki/Robinson_arithmetic">http://en.wikipedia.org/wiki/Robinson_arithmetic</a>,<br>
<a href="http://en.wikipedia.org/wiki/Peano_arithmetic">http://en.wikipedia.org/wiki/Peano_arithmetic</a>).  Since your teacher<br>
suggested this in the first place, why not ask him to explain the<br>
details?</p>
<p>Note that finite lists (of numbers) can be encoded as numbers (again,<br>
via some Gödel numbering), so they are not "as high level as sets".</p>
<p>Also note that Alex was perfectly right when he wrote:<br>
| If these foundational issues of taking the weakest logic possible are <br>
| really the core of your interest, then you can try and go for Peano <br>
| Arithmetic, but if your main interest is formalizing Turing Machines <br>
| after all, then using anything but HOL is like cutting your left leg<br>
| off before climbing a mountain.</p>
<p>If you really want to restrict yourself to Peano arithmetic, I suspect<br>
that a formalization on paper (not using Isabelle) would already be<br>
enough of a challenge for a small student project.</p>
<p>Regards,<br>
Tjark</p>



<a name="294090647"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294090647" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294090647">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Wang Zirui &lt;<a href="mailto:zirui@nus.edu.sg">zirui@nus.edu.sg</a>&gt;<br>
Lawrence wrote:<br>
You need to be much more specific about your research objectives and<br>
about what you mean by set theory. Zermelo set theory is rather weak<br>
(more or less equivalent to higher-order logic). ZF set theory is<br>
considerably stronger, but there are set theories much stronger than<br>
ZF. Then there is a question of the axiom of choice. Just to say "I<br>
want to have nothing to do with the axioms of set theory" is not a<br>
basis for a scientific discussion. People do choose to work in weak<br>
formal systems, typically in order to investigate the power of those<br>
systems.</p>
<p>Based on ZFC you can define and derive much of mathematics, so I<br>
imagine that it's easy to define Turing machine from ZFC. The problem<br>
with this is that it's harder to do proofs in a strong theory.<br>
Therefore I want to define Turing machine in a weaker theory (with<br>
fewer axioms). Basically it would good to have the theory as weak as<br>
possible (because it facilitates proofs). But when the theory gets<br>
weaker, it also becomes less expressive. So I want the theory to be<br>
just strong enough to define Turing machines. I think that would be<br>
the ideal theory, because it can express the definition of Turing<br>
machine and it is weak enough to do certain proofs.</p>
<p>Zirui Wang</p>



<a name="294090663"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294090663" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294090663">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Wang Zirui &lt;<a href="mailto:zirui@nus.edu.sg">zirui@nus.edu.sg</a>&gt;</p>
<blockquote>
<p><a href="http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/">http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/</a>,</p>
</blockquote>
<p>I read a bit about proof theory. So if I want to prove from premises<br>
P_1, ..., P_k one can derive conclusion C and I used the induction<br>
principle (IND) in the proof, I'm actually showing that P_1, ..., P_k,<br>
IND entail C instead of just P_1, ..., P_k entail C. And usually for a<br>
problem whether Q_1, ..., Q_j entail D, we are actually showing Q_1,<br>
..., Q_j, ZFC entail D.</p>



<a name="294090695"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294090695" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294090695">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
You are quite right to be concerned about difficulty of proofs, but  <br>
there are many factors involved in this difficulty, and some weak  <br>
theories are much more difficult to use than stronger theories. If you  <br>
want to accomplish your project with the minimum of effort, you should  <br>
undoubtedly choose Isabelle/HOL. Not only is the logic easy-to-use;  <br>
the implementation provides lots of automation.</p>
<p>Larry Paulson</p>



<a name="294090719"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294090719" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294090719">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Wang Zirui &lt;<a href="mailto:zirui@nus.edu.sg">zirui@nus.edu.sg</a>&gt;<br>
OK, maybe it's a bad choice to start with formalizing Turing machine,<br>
which is a definition not a theorem. How about formalizing Cook's<br>
theorem, the Probabilistically Checkable Proof (PCP) theorem and the<br>
natural proof theorem? Yes, I'm very interested in formalizing<br>
theorems in computational complexity theory. Has anyone done this?</p>
<p>Zirui Wang</p>



<a name="294090760"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294090760" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294090760">(Aug 18 2022 at 14:08)</a>:</h4>
<p>From: Jens Doll &lt;<a href="mailto:jd@cococo.de">jd@cococo.de</a>&gt;<br>
Churchs' thesis says, that all computability can be expressed  by Turing <br>
machines. So you probably cannot bypass sets when defining a such a <br>
formalism. Mathematically spoken do groups, rings, (closed)  fields rely <br>
on sets in their definition. Also alphabets are sets. What do you have <br>
on mind?<br>
Jens<br>
<a href="/user_uploads/14278/EKMXaEPr4k9xDtmcP9dni5VY/jd.vcf">jd.vcf</a></p>



<a name="294091125"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294091125" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294091125">(Aug 18 2022 at 14:11)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:webertj@in.tum.de">webertj@in.tum.de</a>&gt;<br>
There is no need to talk about the "set of all halting TMs" to state<br>
undecidability of the halting problem.  Simply put, undecidability of<br>
the halting problem asserts that there is no Turing machine that decides<br>
whether an arbitrary Turing machine halts.  Stating this requires<br>
quantification over all Turing machines, but no set comprehension.  (Of<br>
course, you chose a deliberately careful wording in the first place, so<br>
I guess this was obvious to you.)</p>
<p>Maybe someone else can point out the precise theory required to prove<br>
undecidability of the halting problem?</p>
<p>Regards,<br>
Tjark</p>



<a name="294091885"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294091885" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294091885">(Aug 18 2022 at 14:15)</a>:</h4>
<p>From: Wang Zirui &lt;<a href="mailto:zirui@nus.edu.sg">zirui@nus.edu.sg</a>&gt;<br>
But think about lambda calculus. It is computationally as powerful as<br>
Turing machine. Following your line of reasoning, it should also rely<br>
on set in its definition. But I think it's simple enough to avoid the<br>
use of set.</p>
<p>Zirui</p>



<a name="294091905"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Formalizing%20Turing%20machine/near/294091905" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Formalizing.20Turing.20machine.html#294091905">(Aug 18 2022 at 14:15)</a>:</h4>
<p>From: Wang Zirui &lt;<a href="mailto:zirui@nus.edu.sg">zirui@nus.edu.sg</a>&gt;<br>
I'm sorry, but I'd like to repeat again that I'm not talking about<br>
programming tricks. So lists are as high level as sets, because you<br>
can implement sets by lists. Actually I don't mean sets in particular<br>
but rather <em>set theory</em>. I want to avoid the use of sets because I<br>
want to have nothing to do with the axioms of set theory. So lists<br>
probably also rely on the axioms of set theory, unless you can define<br>
it without the axioms of set theory. So let repeat my question: Can we<br>
define Turing machine without relying on the axioms of set theory? I<br>
think part of the misconception is because I'm posting this topic<br>
under Isabelle. Actually my question has nothing to do with Isabelle<br>
or HOL; I just imagined that people here might be good at formalizing<br>
concepts and proofs using rudimentary logic theory. Sorry for the<br>
misunderstanding.</p>
<p>Zirui</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>