<html>
<head><meta charset="utf-8"><title>[isabelle] I need a fixed mutable array · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html">[isabelle] I need a fixed mutable array</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294278977"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294278977" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294278977">(Aug 19 2022 at 14:35)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
HOL itself does not support mutable arrays. </p>
<p>However, there is Imperative_HOL, which has a heap monad supporting<br>
mutable arrays.</p>
<p>Then there is afp/Collections/Lib/Diff_Array, which provides an<br>
implementation of arrays that behaves purely functional, but is<br>
efficient if only the last version is accessed.</p>
<p>However, if you are not after <em>efficient</em> executability, but only<br>
looking for an abstract model of a memory, it makes no sense using the<br>
above types, as the efficiency comes at teh price of additional<br>
formalization overhead.</p>



<a name="294279004"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294279004" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294279004">(Aug 19 2022 at 14:35)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;<br>
Ramana,</p>
<p>Thanks for the suggestion. There's always more to say than anyone wants <br>
to read.</p>
<p>I'll say the same thing here that I'll say to Peter Lammich about the <br>
info he gave me. It's probably better that I didn't get this information <br>
from you before now. In particular, my finding this link from your tip:</p>
<p><a href="http://www.cl.cam.ac.uk/~acjf3/arm">www.cl.cam.ac.uk/~acjf3/arm</a></p>
<p>That would be about ARMv7. The ARM Cortex-A15 was the CPU I thought I <br>
was going to go with. Please see [1] and [2] below.</p>
<p>There's like three main factors in looking at CPUs: they need to be sold <br>
on a board that's affordable, they need to have a large following, and <br>
they need to have some lasting power.</p>
<p>The Sony Playstation 3 CPU looks great, and it's fairly cheap, but then <br>
the Sony PS4 is changing to an AMD CPU. That's a bad sign.</p>
<p>Basically, there's GPUs, ARM, and Intel i7. Part of my pursuit began <br>
with looking for processors that have 256-bit data registers, because I <br>
used to work in graphics image generators, which had 256-bit wide data <br>
busses.</p>
<p>It was there all the time with the i7, and even before for 128-bit, with <br>
SSE, SSE2, SSS3, SS3, SS4, and now it's there for 256-bit, with AVX <br>
extensions.</p>
<p>RISC and ARM sounds like it should be fast, but then I looked at [3], <br>
and it's not like they blow everyone away.</p>
<p>I think an i7 is hard to beat, with 4 cores and 8 threads, with a clock <br>
at 3 to 4 GHz.. Lots of people have them, and people don't have to do <br>
anything special to run them, unlike embedded processors, or external, <br>
single board Linux computers.</p>
<p>All these practical considerations have a big part in influencing what <br>
route I think I should go. ARM is good, but then there's all sorts of <br>
special things I have to do for, among other things, develop tools.</p>
<p>Regards,<br>
GB</p>
<p>[1] Samsung Exynos 5 Octa: <br>
<a href="http://www.samsung.com/global/business/semiconductor/minisite/Exynos/products5octa_5410.html">http://www.samsung.com/global/business/semiconductor/minisite/Exynos/products5octa_5410.html</a></p>
<p>[2] ODROID-X3: ARM Cortex-A15 / Cortex A7 / Samsung Exynos 5 Octa based <br>
computer for $169.<br>
<a href="http://hardkernel.com/main/products/prdt_info.php?g_code=G137510300620">http://hardkernel.com/main/products/prdt_info.php?g_code=G137510300620</a></p>
<p>[3] CoreMark integers tests: <a href="http://www.eembc.org/coremark/index.php">http://www.eembc.org/coremark/index.php</a> <br>
(sort by CoreMark/MHz)</p>
<p>[4] Brix with i7-4770R: <br>
<a href="http://www.amazon.com/BRIX-Pro-GB-BXI7-4770R-Desktop-Computer/dp/B00HX3OJSG/ref=sr_1_5?ie=UTF8&amp;qid=1402845781&amp;sr=8-5&amp;keywords=gigabyte+brix">http://www.amazon.com/BRIX-Pro-GB-BXI7-4770R-Desktop-Computer/dp/B00HX3OJSG/ref=sr_1_5?ie=UTF8&amp;qid=1402845781&amp;sr=8-5&amp;keywords=gigabyte+brix</a></p>



<a name="294279017"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294279017" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294279017">(Aug 19 2022 at 14:35)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;<br>
On 14-06-18 16:19, Peter Lammich wrote:</p>
<blockquote>
<p>On Di, 2014-06-17 at 10:56 -0500, Gottfried Barrow wrote:</p>
<blockquote>
<p>I did a few searches to find whether there are mutable arrays in<br>
Isabelle. It appears there's not, though I found a little info:<br>
However, there is Imperative_HOL, which has a heap monad supporting<br>
mutable arrays.</p>
</blockquote>
</blockquote>
<p>Peter,</p>
<p>Thanks for the info. I never consider using anything but Isabelle/HOL, <br>
since it has the biggest user base. Limitations can sometimes be a good <br>
thing, by forcing me to figure out how to do things different.</p>
<blockquote>
<p>Then there is afp/Collections/Lib/Diff_Array, which provides an<br>
implementation of arrays that behaves purely functional, but is<br>
efficient if only the last version is accessed.</p>
</blockquote>
<p>I searched on "array" at the AFP site before, but I didn't find that, <br>
since it's buried in the tar file. It's good that I didn't, but it's <br>
good to see it now, and see how they're implementing things with lists.</p>
<p>It might come in handy later, and the collections in general.</p>
<blockquote>
<p>However, if you are not after <em>efficient</em> executability, but only<br>
looking for an abstract model of a memory, it makes no sense using the<br>
above types, as the efficiency comes at teh price of additional<br>
formalization overhead.</p>
</blockquote>
<p>I just need something to give me a decent model for the use a subset of <br>
assembly language instructions, which involves reading and writing to <br>
memory.</p>
<p>List and nat, they're part of the foundation of HOL. They're used a lot, <br>
so there's a lot of development around them. Proof can be a scary <br>
thought, so I try to play it safe, and keep things simple with lists, <br>
when I can.</p>
<p>Regards,<br>
GB</p>



<a name="294279032"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294279032" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294279032">(Aug 19 2022 at 14:35)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;<br>
It would also be "they", but then "you" as the primary.</p>
<p>Thanks,<br>
GB</p>



<a name="294279063"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294279063" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294279063">(Aug 19 2022 at 14:35)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Hi Gottfried,</p>
<p>are you aware of the HOL/Word library? It gives you arbitrary fixed-size words. With that, memory would be something like</p>
<p>type_synonym mem = “64 word =&gt; 8 word”</p>
<p>If the purpose is to model and reason only, basic functions are as mutable as records. If you want to generate efficient code from it, then it might be better to go with implementations like Peter’s.</p>
<p>A formalisation of (very) basic machine language is explained in Section 8.1 of Concrete Semantics:<br>
<a href="http://www21.in.tum.de/~nipkow/Concrete-Semantics/">http://www21.in.tum.de/~nipkow/Concrete-Semantics/</a></p>
<p>Cheers,<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294279075"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294279075" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294279075">(Aug 19 2022 at 14:35)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;<br>
On 14-06-18 19:43, Gerwin Klein wrote:</p>
<blockquote>
<p>A formalisation of (very) basic machine language is explained in Section 8.1 of Concrete Semantics:<br>
<a href="http://www21.in.tum.de/~nipkow/Concrete-Semantics/">http://www21.in.tum.de/~nipkow/Concrete-Semantics/</a></p>
</blockquote>
<p>Gerwin,</p>
<p>Thanks again. That's short, but very useful. I kind of knew that my <br>
instruction set is one, big datatype, but it hadn't yet entered my mind <br>
what my execution function was going to be for the datatype, so seeing <br>
"iexec" is helpful.</p>
<p>Also, I'll be looking at the info about the program counter again, and <br>
other tips there.</p>
<blockquote>
<p>are you aware of the HOL/Word library? It gives you arbitrary fixed-size words. With that, memory would be something like</p>
<p>type_synonym mem = “64 word =&gt;  8 word”</p>
</blockquote>
<p>I've looked at that briefly now, and I start at section 3.1, where <br>
they're starting with num0 and num1. It would take me  a lot of work to <br>
work through the details, and I'm assuming, it's safe to assume, it's <br>
not what I need, where my assumption is based on my work with Num.num, <br>
which I really like.</p>
<p>For what I'm trying to do, everything is about trying to precisely model <br>
the specific registers of a particular CPU. With a CPU, the register set <br>
and size of registers is fixed, and there's nothing that complex about <br>
them, though how they're used may be complex. For 64-bit registers, you <br>
usually only have 8-bit, 16-bit, 32-bit, and 64-bit words. Also, my <br>
choice of bool for the bits is based on the fact that True and False are <br>
fundamental to HOL, which might become very useful to me.</p>
<p>Arbitrary will be important, if I can get to it, but arbitrary has to be <br>
implemented as it's implemented by the good math libraries, and the <br>
precise way that they use fixed sized registers. For arbitrary, the <br>
first place I'll look to see how arithmetic is done will the GnuMP <br>
library. I'll be asking, "What's special about the way they deal with <br>
registers, and assembly language instructions?"</p>
<p>There's another issue here. For pattern matching with "fun", it's <br>
important that a datatype use only 0-ary type constructors, like True <br>
and False. My awareness of this is a result of having been working with <br>
Num.num. What I've done is use Num.num as a template, and I've implement <br>
the functionality of Num.num  as a "bool list". For example, "[]" is 1, <br>
and [True,True] is 7. That allows me to pattern match in ways I <br>
otherwise couldn't pattern match.</p>
<p>Having spent a lot of time learning how Num.num works, I'm not very <br>
motivated to do it all again with Word, and I assume that doing things <br>
more straightforward will help me in some ways.</p>
<p>There always more. I'm talking prematurely, but suppose I need a sign <br>
bit for signed integers. I could do something like this for a 16-bit <br>
signed integer:</p>
<p>datatype d7T = d7C bool bool bool bool bool bool bool<br>
datatype d8uT = d8uC bool bool bool bool bool bool bool bool<br>
datatype d16sT = d16C bool d7T d8uT</p>
<blockquote>
<p>If the purpose is to model and reason only, basic functions are as mutable as records. If you want to generate efficient code from it, then it might be better to go with implementations like Peter’s.</p>
</blockquote>
<p>In times like these, a person like me would actually like to understand <br>
a phrase like "basic functions are as mutable as records", but I don't <br>
worry about understanding everything.</p>
<p>I'm actually liking what I stumbled onto, which is to generate a list of <br>
the CPU register and memory state for each instruction. That would get <br>
me a debugger by default. Compiled languages are bigger hassle to use, <br>
and with assembly language, it becomes more important to use GNU gdb, or <br>
some other IDE.</p>
<p>If I could get a state machine thing accurately modeling assembly <br>
language, then I could run it with a combination of Isabelle/HOL and ML, <br>
in Isabelle/jEdit. That would be nice.</p>
<p>Well, this is all premature.</p>
<p>Regards,<br>
GB</p>



<a name="294281596"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294281596" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294281596">(Aug 19 2022 at 14:49)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;<br>
Hi,</p>
<p>I did a few searches to find whether there are mutable arrays in <br>
Isabelle. It appears there's not, though I found a little info:</p>
<p><a href="https://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrayshttps://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrays">https://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrayshttps://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrays</a></p>
<p>I need to simulate the RAM of a cpu, and this is what I've done with a <br>
record and list:</p>
<p>record 'a marray = MList :: "'a list"</p>
<p>definition "array_size_512 = ( (| MList = replicate 0x100 (0::nat) |), <br>
0x100::nat )"</p>
<p>fun array_write :: "('a marray * nat) =&gt; nat =&gt; 'a =&gt; ('a marray * nat) <br>
option" where<br>
   "array_write (an_array, a_size) index data = (<br>
      if (index &gt;= a_size) then None<br>
      else Some (an_array(| MList := (MList an_array)[index := data] |), <br>
a_size)<br>
   )"</p>
<p>value "array_write array_size_512 3 1234"<br>
value "array_write array_size_512 0x100 1234"</p>
<p>I'm wondering if there's a better way to do that. Better efficiency <br>
would be good, but efficiency in Isabelle is not of utmost concern, <br>
since it will hopefully represent what will be done in assembly language.</p>
<p>I'm just getting started, but a partial record for a Intel 64-bit cpu <br>
might be something like this, where "Mem" is the fixed mutable array to <br>
represent RAM:</p>
<p>record cpu64 =<br>
   Ax :: nat<br>
   Bx :: nat<br>
   Mem :: "nat list"</p>
<p>definition cpu_mem256 :: "cpu64 * nat" where<br>
   "cpu_mem256 =<br>
   ( (| Ax = 0, Bx = 0, Mem = (replicate 0x100 (0::nat)) |), 0x100::nat )"</p>
<p>fun mem_write :: "(cpu64 * nat) =&gt; nat =&gt; nat =&gt; (cpu64 * nat) option" where<br>
   "mem_write (cpu, memsize) addr data = (<br>
      if (addr &gt;= memsize) then None<br>
      else Some (cpu(| Mem := (Mem cpu)[addr := data] |), memsize)<br>
   )"</p>
<p>This is the beginning of an attempt to tie into the SIMD instruction <br>
sets of the AMD and Intel microprocessors. The SIMD instructions use <br>
128-bit and 256-bit registers to do multiple operations at the same <br>
time. I include a lot of links below.</p>
<p>Thanks,<br>
GB</p>
<p>Wiki Pages</p>
<p><a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions</a><br>
<a href="http://en.wikipedia.org/wiki/SSE2">http://en.wikipedia.org/wiki/SSE2</a><br>
<a href="http://en.wikipedia.org/wiki/SSE3">http://en.wikipedia.org/wiki/SSE3</a><br>
<a href="http://en.wikipedia.org/wiki/SSSE3">http://en.wikipedia.org/wiki/SSSE3</a><br>
<a href="http://en.wikipedia.org/wiki/SSE4">http://en.wikipedia.org/wiki/SSE4</a><br>
<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">http://en.wikipedia.org/wiki/Advanced_Vector_Extensions</a></p>
<p>INTEL</p>
<p><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a><br>
<a href="https://software.intel.com/en-us/intel-isa-extensions">https://software.intel.com/en-us/intel-isa-extensions</a></p>
<p>AMD (See AMD64 Arch Programmer's Manuals under the manual heading)</p>
<p><a href="http://developer.amd.com/resources/documentation-articles/developer-guides-manuals/">http://developer.amd.com/resources/documentation-articles/developer-guides-manuals/</a></p>
<p>PRO ASSEMBLY LANGUAGE (chapter 17)</p>
<p><a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-Assembly-Language.productCd-0764579010,descCd-tableOfContents.html">http://www.wrox.com/WileyCDA/WroxTitle/Professional-Assembly-Language.productCd-0764579010,descCd-tableOfContents.html</a></p>
<p><a href="http://media.wiley.com/product_data/excerpt/10/07645790/0764579010-2.pdf">http://media.wiley.com/product_data/excerpt/10/07645790/0764579010-2.pdf</a></p>



<a name="294281621"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294281621" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294281621">(Aug 19 2022 at 14:49)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
Hi Gottfried,</p>
<p>most assembly formalisation don’t represent memory as an array, but as a function from address to value (usually byte or word). With that, read is just function application, store is function update. These are easier to reason about than arrays.</p>
<p>There are existing large formalisations of x86 out there that you might want to look at. E.g. the Cambridge model in HOL4, which is close to what you’d do in Isabelle, or the model of Ben Pierce’s group in Coq.</p>
<p>Cheers,<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294281721"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294281721" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294281721">(Aug 19 2022 at 14:49)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;<br>
A little feedback can go a long way towards getting me to the next step.</p>
<p>This all falls under a more general question: "How do I execute a list <br>
of instructions in Isabelle/HOL, like in a normal programming language?"</p>
<p>Even further: "How do I use GOTO in a functional programming language?"</p>
<p>That led, with some past information, to this thought (possibly wrong):</p>
<p>1) There is nothing mutable in Isabelle/HOL. Records only have the <br>
appearance of mutability. Consequently, for my case, a record adds <br>
needless complexity.</p>
<p>So, no mutability can lead to good things.</p>
<p>I include some source and attach some source. The idea behind it is to <br>
have a cpu datatype that holds the register and memory state. I execute <br>
a list of instructions, and it produces a list of states, not that I <br>
know anything about state machines, only that Ramon Zuniga used to <br>
implement them in programmable logic. I wonder what that guy's up to <br>
these days.</p>
<p>I did a trivial proof, to make sure I had a token proof to show, but the <br>
value wasn't trivial. There was a simple condition I needed, and it <br>
hadn't occurred to me that I needed it. Another example that shows that <br>
proofs are a good thing.</p>
<p>With no mutability, based on the basic idea, it seems I should be able <br>
to prove some complex things about executing a list of instructions.</p>
<p>Regards,<br>
GB</p>
<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>*)<br>
theory i140618a__mem_write_execute_state_list<br>
imports Complex_Main "~~/src/HOL/Library/Code_Target_Nat"<br>
begin</p>
<p>(<em>16-bit dataword and a little notation.</em>)</p>
<p>type_synonym b8T  = "bool * bool * bool * bool * bool * bool * bool * <br>
bool"<br>
   type_synonym b16T = "b8T * b8T"</p>
<p>notation (input)<br>
     False ("0\&lt;^sub&gt;B")<br>
   notation (input)<br>
     True ("1\&lt;^sub&gt;B")<br>
   abbreviation hex00 :: b8T ("00\&lt;cdot&gt;") where<br>
     "hex00 == <br>
(0\&lt;^sub&gt;B,0\&lt;^sub&gt;B,0\&lt;^sub&gt;B,0\&lt;^sub&gt;B,0\&lt;^sub&gt;B,0\&lt;^sub&gt;B,0\&lt;^sub&gt;B,0\&lt;^sub&gt;B)"<br>
   abbreviation hex55 :: b8T ("55\&lt;cdot&gt;") where<br>
     "hex55 == <br>
(0\&lt;^sub&gt;B,1\&lt;^sub&gt;B,0\&lt;^sub&gt;B,1\&lt;^sub&gt;B,0\&lt;^sub&gt;B,1\&lt;^sub&gt;B,0\&lt;^sub&gt;B,1\&lt;^sub&gt;B)"<br>
   abbreviation hexAA :: b8T ("AA\&lt;cdot&gt;") where<br>
     "hexAA == <br>
(1\&lt;^sub&gt;B,0\&lt;^sub&gt;B,1\&lt;^sub&gt;B,0\&lt;^sub&gt;B,1\&lt;^sub&gt;B,0\&lt;^sub&gt;B,1\&lt;^sub&gt;B,0\&lt;^sub&gt;B)"<br>
   abbreviation hex16 :: "b8T =&gt; b8T =&gt; b16T" where<br>
     "hex16 b1 b0 == (b1, b0)"<br>
     notation hex16 ("x\&lt;bar&gt;__" [1000, 1000] 1000)</p>
<p>(*Indexed, fixed size b16T list. The list idx won't always match the <br>
pair idx.*)</p>
<p>type_synonym idxed_flist = "(nat * b16T) list * nat"</p>
<p>primrec idx0s_app_flist :: "(nat * b16T) list \&lt;Rightarrow&gt; nat <br>
\&lt;Rightarrow&gt; (nat * b16T) list" where<br>
     "idx0s_app_flist nlist 0       = nlist"<br>
    |"idx0s_app_flist nlist (Suc n) = idx0s_app_flist <br>
((n,x\&lt;bar&gt;00\&lt;cdot&gt;00\&lt;cdot&gt;) # nlist) n"</p>
<p>definition create_idxed_flist :: "nat \&lt;Rightarrow&gt; idxed_flist" where<br>
     "create_idxed_flist lsize = (idx0s_app_flist [] lsize, lsize)"</p>
<p>value "create_idxed_flist 0x10"<br>
   value "length (fst (create_idxed_flist 0x10)) = 0x10"</p>
<p>(<em>The write function.</em>)</p>
<p>primrec write_idxed_flist :: "idxed_flist \&lt;Rightarrow&gt; nat <br>
\&lt;Rightarrow&gt; b16T \&lt;Rightarrow&gt; idxed_flist option"<br>
     where<br>
     "write_idxed_flist (flist, lsize) idx data = (<br>
        if (idx &gt;= lsize \&lt;or&gt; length flist \&lt;noteq&gt; lsize) then None<br>
        else Some (flist[idx := (idx, data)], lsize)<br>
     )"</p>
<p>(<em>Two sequential writes done manually.</em>)</p>
<p>value "write_idxed_flist<br>
     (the(write_idxed_flist (create_idxed_flist 0x10) 5 <br>
x\&lt;bar&gt;55\&lt;cdot&gt;55\&lt;cdot&gt;))<br>
     3 x\&lt;bar&gt;AA\&lt;cdot&gt;AA\&lt;cdot&gt;"</p>
<p>(<em>Automate execution of a list of writes, to generate a list of states.</em>)</p>
<p>fun execute_list :: "(idxed_flist option) list \&lt;Rightarrow&gt; (nat * <br>
b16T) list<br>
         \&lt;Rightarrow&gt; (idxed_flist option) list" where<br>
     "execute_list [] _ = []"<br>
    |"execute_list state_list [] = state_list"<br>
    |"execute_list [s] ((idx,data) # xs)<br>
        = execute_list ((write_idxed_flist (the s) idx data) # [s]) xs"<br>
    |"execute_list (s # ss) ((idx,data) # xs)<br>
        = execute_list ((write_idxed_flist (the s) idx data) # (s # ss)) xs"<br>
    (*Adding the third condition sped up the termination proof a lot. It <br>
probably<br>
      needs more conditions to speed it up more.*)</p>
<p>(*Execute a list of three instructions. The states are shown last to <br>
first.*)</p>
<p>abbreviation "three_write_list ==<br>
     [(5, x\&lt;bar&gt;55\&lt;cdot&gt;55\&lt;cdot&gt;), (3, x\&lt;bar&gt;AA\&lt;cdot&gt;AA\&lt;cdot&gt;), <br>
(0x10, x\&lt;bar&gt;55\&lt;cdot&gt;55\&lt;cdot&gt;)]"</p>
<p>value "execute_list [Some (create_idxed_flist 0xF)] three_write_list"</p>
<p>(*Prove something trivial. The value of proving this wasn't trivial. It <br>
showed<br>
   me I needed the condition "length flist \&lt;noteq&gt; lsize" in my <br>
function above.*)</p>
<p>lemma "idx &lt; lsize \&lt;and&gt; length flist = lsize<br>
     \&lt;Longrightarrow&gt; write_idxed_flist (flist, lsize) idx dw \&lt;noteq&gt; <br>
None"<br>
   by(simp)</p>
<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>
end<br>
<a href="/user_uploads/14278/PD5PiLNc3Rt02z4q_79YUZVO/i140618a__mem_write_execute_state_list.thy">i140618a__mem_write_execute_state_list.thy</a></p>



<a name="294281751"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20I%20need%20a%20fixed%20mutable%20array/near/294281751" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20I.20need.20a.20fixed.20mutable.20array.html#294281751">(Aug 19 2022 at 14:49)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
On Tue, Jun 17, 2014 at 11:54 PM, Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt; wrote:</p>
<blockquote>
<p>On 14-06-17 16:58, Gerwin Klein wrote:</p>
<blockquote>
<p>most assembly formalisation don’t represent memory as an array, but as a<br>
function from address to value (usually byte or word). With that, read is<br>
just function application, store is function update. These are easier to<br>
reason about than arrays.</p>
<p>Gerwin,</p>
</blockquote>
<p>I do actually have a set of word datatypes in mind. At the moment, this is<br>
what I'm thinking:</p>
<p>type_synonym b8T   = "bool * bool * bool * bool * bool * bool * bool *
bool"<br>
  type_synonym b16T  = "b8T * b8T"<br>
  type_synonym b32T  = "b16T * b16T"<br>
  type_synonym b64T  = "b32T * b32T"<br>
  type_synonym b128T = "b64T * b64T"<br>
  type_synonym b256T = "b128T * b128T"</p>
<p>If someone showed me specifically the memory representation you're talking<br>
about, along with some supplementary documentation and explanations, I<br>
could probably figure out in about 15 minutes to an hour whether trying to<br>
go that route would be within my ability.</p>
<p>There are existing large formalisations of x86 out there that you might</p>
<blockquote>
<p>want to look at. E.g. the Cambridge model in HOL4, which is close to what<br>
you’d do in Isabelle...<br>
</p>
</blockquote>
<p>Initially, I did have the idea to try and model things at the bit and<br>
opcode level, but I decided that's not doable. Lifetimes have an upper<br>
limit, and it's hard to produce something as it is.</p>
<p>I've started to compartmentalize more between programming and proving. I<br>
don't have to do proofs for all the functions, datatypes, and lines of<br>
logic I define in Isabelle/HOL, though proofs are desirable. Isabelle is<br>
useful just as a way to work with functions and datatypes at a higher<br>
level, to experiment with ideas.</p>
<p>My idea now is to take a very minimal model of an Intel cpu and implement<br>
pseudo-assembly language around that model, for the smallest number of<br>
instructions possible.</p>
<p>It seems it should be very simple. I move data in and out of registers,<br>
back and forth to memory, doing bit operations and arithmetic, and look at<br>
flags to make decisions. As far as proving, that wouldn't be simple at all.</p>
<p>I have to go with what I know, and I always learn something in the process<br>
anyway. The only mutable datatype I know about in Isabelle/HOL is a record,<br>
so it seems a mutable array would have to be something like I defined.</p>
<p>I did a few searches on the HOL4 model you mentioned, but my motivation is<br>
low to pursue that. It's got to be very complex and huge.<br>
</p>
</blockquote>
<p>I recommend looking at the other (non-x86) processor models in HOL4 too.<br>
Not all are complex and huge (though I guess that depends on your<br>
perspective).</p>
<blockquote>
<p>Thanks,<br>
GB</p>
</blockquote>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>