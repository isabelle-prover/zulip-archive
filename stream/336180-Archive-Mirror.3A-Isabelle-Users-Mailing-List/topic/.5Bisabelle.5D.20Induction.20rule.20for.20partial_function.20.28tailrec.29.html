<html>
<head><meta charset="utf-8"><title>[isabelle] Induction rule for partial_function (tailrec) · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Induction.20rule.20for.20partial_function.20.28tailrec.29.html">[isabelle] Induction rule for partial_function (tailrec)</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294236698"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Induction%20rule%20for%20partial_function%20%28tailrec%29/near/294236698" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Induction.20rule.20for.20partial_function.20.28tailrec.29.html#294236698">(Aug 19 2022 at 10:31)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Hi Alex,</p>
<p>Thanks for looking into this. Your rule is more or less the <br>
contrapositive to mine (in terms of "= undefined" and P). I proved your <br>
rule and it works for showing undefinedness in case of non-termination <br>
(there an introductory contrapos_np step, but that's all). Do you think <br>
this should be the default induction rule for (tailrec)? Currently, <br>
partial_function (tailrec) generates no induction rule at all. If so, I <br>
can adapt Partial_Function.thy accordingly.</p>
<p>Andreas</p>



<a name="294236768"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Induction%20rule%20for%20partial_function%20%28tailrec%29/near/294236768" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Induction.20rule.20for.20partial_function.20.28tailrec.29.html#294236768">(Aug 19 2022 at 10:31)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Hi Andreas,</p>
<p>Yes, go ahead! This rule should be the default.</p>
<p>Alex</p>



<a name="294238473"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Induction%20rule%20for%20partial_function%20%28tailrec%29/near/294238473" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Induction.20rule.20for.20partial_function.20.28tailrec.29.html#294238473">(Aug 19 2022 at 10:44)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Every now and then, I want to prove that a function that I have defined <br>
with partial_function (tailrec) is undefined when the recursion does not <br>
terminate. Unfortunately, partial_function (tailrec) does not generate <br>
an induction theorem for the functions. So I set out to prove my own <br>
generic induction rule (fixp_induct_tailrec_undefined in the attachment) <br>
similar to fixp_induct_option in Partial_Function.thy. If I manually <br>
instantiate it with the ..._def theorem of the partial function ..., <br>
everything works fine. However, when I register it as the induction <br>
theorem to be used for tailrec (like it is done for fixp_induct_option <br>
and option in Partial_Function.thy), I only get exceptions when using <br>
partial_function.</p>
<p>What's wrong with my induction theorem? How can I change it such that it <br>
works with partial_function?</p>
<p>Andreas<br>
<a href="/user_uploads/14278/BI530OGu_PxZmqxxSnm9LCDS/Scratch.thy">Scratch.thy</a></p>



<a name="294238859"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Induction%20rule%20for%20partial_function%20%28tailrec%29/near/294238859" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Induction.20rule.20for.20partial_function.20.28tailrec.29.html#294238859">(Aug 19 2022 at 10:47)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Hi Andreas,</p>
<p>partial_function currently expects induction rules whose conclusion is <br>
of the form "... ==&gt; P x y" where ... intuitively means "f x terminates <br>
and evaluates to y". In the option monad, this is simply "f x = Some y <br>
==&gt; P x y", but in the degenerate tailrec monad you would get something <br>
like "f x = y ==&gt; y ~= undefined ==&gt; P x y".</p>
<p>I just tried this and got the following rule accepted by partial_function.</p>
<p>lemma fixp_induct_tailrec_undefined:<br>
   fixes F :: "'c ⇒ 'c" and<br>
     U :: "'c ⇒ 'b ⇒ 'a" and<br>
     C :: "('b ⇒ 'a) ⇒ 'c" and<br>
     P :: "'b ⇒ 'a ⇒ bool" and<br>
     x :: "'b"<br>
   assumes mono: "⋀x. mono_tailrec (λf. U (F (C f)) x)"<br>
   assumes eq: "f ≡ C (ccpo.fixp (fun_lub (flat_lub undefined)) (fun_ord <br>
tailrec_ord) (λf. U (F (C f))))"<br>
   assumes inverse2: "⋀f. U (C f) = f"<br>
   assumes step: "⋀f x y. (⋀x y. U f x = y ⟹ y ≠ undefined ⟹ P x y) ⟹ U <br>
(F f) x = y ⟹ y ≠ undefined ⟹ P x y"<br>
   assumes result: "U f x = y"<br>
   assumes defined: "y ≠ undefined"<br>
   shows "P x y"<br>
   sorry</p>
<p>I believe this rule should be provable and sufficient for what you want.</p>
<p>I cannot say on the spot whether partial_function could be modified to <br>
accept rules like yours. The problem is the curry/uncurry translation, <br>
which must do some explicit instantiations and assumes a certain <br>
syntactic form.</p>
<p>Let me know when you make progress (or run into more problems).</p>
<p>Alex</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>