<html>
<head><meta charset="utf-8"><title>[isabelle] Isabelle Foundation &amp; Certification · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html">[isabelle] Isabelle Foundation &amp; Certification</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294652739"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294652739" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294652739">(Aug 22 2022 at 11:12)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Back to this thread after the initial round of discussion ...</p>
<p>First of all, I don't see much of a technical problem here, but mainly a <br>
social one.  A bit too many things not explicitly spelled out; a bit too <br>
many rumors and private mailing threads about "Isabelle/HOL is <br>
inconsistent", already since summer 2014.</p>
<p>For years we have tried to establish isabelle-dev (also isabelle-users) as <br>
a professional channel for open discussion about presumed problems, <br>
potential solutions, proposals for changes etc.  That works out half way, <br>
and needs more efforts.</p>
<p>On other mailing lists (e.g. Coq-club) I see routinely the discussion of <br>
genuine logical breakdowns without much excitement about it.  The Coq/HoTT <br>
implementation even seems to require patching Coq to disable critical <br>
checks, for the elite of users who really know what there are doing at the <br>
bleeding edge ...</p>
<p>The present thread is essentially about the paper "A Consistent Foundation <br>
for Isabelle/HOL" by O. Kuncar and A. Popescu, ITP 2015.</p>



<a name="294652849"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294652849" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294652849">(Aug 22 2022 at 11:13)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
Beyond the specific def/overloading issue, there is a more fundamental<br>
problem. Isabelle (and other proof assistants) have evolved in a social<br>
context where users typically act in good faith.</p>
<p>It is a fact that is neither widely advertised nor, as far as I can<br>
tell, well-understood outside a small community that Isabelle theories<br>
are not actually machine-checked proofs. (Sure, theories may contain<br>
proofs that can be checked by Isabelle. But if someone gives you an<br>
Isabelle theory and claims that it proves, e.g, FLT, there is no<br>
machine that could decide this claim for you.)</p>
<p>This can be addressed in various ways, of course. You give several<br>
pages of "methodological recommendations" in your white paper,<br>
essentially attempting to identify a safe subset of Isabelle/Isar. HOL<br>
Zero and proof terms are other approaches, with different drawbacks.</p>
<p>Surely satisfactory solutions will be developed eventually, when people<br>
perceive this problem as sufficiently important.</p>
<p>Best,<br>
Tjark</p>



<a name="294652934"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294652934" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294652934">(Aug 22 2022 at 11:14)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
The length of this dicussion puzzles me. Typedef can introduce inconsistencies, <br>
nobody wants this behaviour and nobody needs this behaviour. There is a <br>
perfectly clear way to rule out this whole class of unwanted behaviours: do not <br>
allow certain cycles. This solution, including code, has been on the table for a <br>
year now. By now not just mere users but also certification agencies are <br>
worried. This is a pressing issue and it is not rocket science.</p>
<p>Everything else is secondary. It is nice that Andrei's and Ondrej's paper <br>
establishes certain logical properties of their improved system, and it is <br>
interesting to discuss these properties, but the most important thing is the <br>
actual addition of a cycle check to the code.</p>
<p>Tobias<br>
<a href="/user_uploads/14278/pgAxg46SJ0cNhEBD0hsBggHM/smime.p7s">smime.p7s</a></p>



<a name="294652945"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294652945" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294652945">(Aug 22 2022 at 11:14)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
To get beyond the black-and-white of the Inconsistency Club vs. Consistency<br>
Club, here are some more shades and dimensions.</p>
<p>The subsequent classification of reliability and robustness of proof<br>
assistants follows the tradition of the "LCF-approach", which has two main<br>
ingredients:</p>
<p>(1) a programming language with strong type-safety properties (the<br>
   "meta-language" ML)</p>
<p>(2) an implementation of the logical core as abstract datatype thm<br>
   within ML</p>
<p>The key ML modules should be reasonable small, to make them obviously<br>
correct (whatever that means precisely). Arbitrary derived tools may be put<br>
on top of that, without breaking things: all inferences going through the<br>
thm module are "correct-by-construction".</p>
<p>Both ingredients of the LCF approach are equally important. E.g. a<br>
fully-formalized and proven implementation of the thm module that is exposed<br>
to an unsafe ML environment still leads to an unreliable system, if the user<br>
is able to poke around arbitrarily.</p>
<p>To better capture the "True LCF-nature" of proof assistants 35 years after<br>
LCF, lets consider qualities in following categories:</p>
<p>[small] overall size of critical code modules.</p>
<p>[ML] The implementation/extension language of the prover.</p>
<p>[thm] The actual inference kernel, to derive theorems within a given<br>
   theory.</p>
<p>[defs] additional guarantees for "definitional theories", whatever that<br>
   means precisely.</p>
<p>[context] treatment of formal context (theory or proof context with formal<br>
   declarations, additional tool data etc.).</p>
<p>[logic] well-understood (by experts) and easy to understand (by users).</p>
<p>[formalized] key aspects are formally specified or even proven (the logical<br>
   calculus, models of the prover, the actual prover implementation etc.).</p>
<p>The rating uses small natural numbers in unary notation: 0, +, ++, +++. More<br>
pluses mean somehow better. The scale is open-ended, but I will not go<br>
beyond +++ right now. 0 means neither good nor bad, just zero.</p>
<p>The results below are based on my own understanding of these systems -- I've<br>
studied sources of all of them. The architects and engineers of the<br>
mentioned systems are invited to improve on these estimates.</p>
<p><strong> LCF </strong></p>
<p>I only know the Cambridge LCF code base, by L. Paulson from around 1985.<br>
Original LCF is hard to get by -- M. Gordon once showed a stack of printed<br>
LISP + ML listings of it.</p>
<p>[small]      +++<br>
   [ML]         +++<br>
   [thm]        +++<br>
   [defs]       0<br>
   [context]    0<br>
   [logic]      ++<br>
   [formalized] 0</p>
<p>[small] + [ML] + [thm] define the game of "LCF-style proof assistant".<br>
Original ML is embedded into LISP, and there is no system access, no<br>
non-sense like mutable strings or funny holes in the type-system.</p>
<p>[defs] No definitions; the LCF logic is used axiomatically.</p>
<p>[context] management is implicit in ML; there is no way to switch contexts<br>
nor go back to older contexts.</p>
<p>[logic] LCF as a logic is theoretically nice and clean, but not so easy to<br>
understand for regular users.</p>
<p><strong> HOL88 </strong></p>
<p>HOL88 is like LCF, with the addition of checked definitional principles as<br>
part of the kernel. Thus it goes beyond the original "LCF-approach" in a<br>
significant way. Everything else is similar to LCF.</p>
<p>[small]      +++<br>
   [ML]         +++<br>
   [thm]        +++<br>
   [defs]       +++<br>
   [context]    0<br>
   [logic]      ++<br>
   [formalized] 0</p>
<p>[logic] Note that I don't give +++ for the logic here. The original "Simple<br>
Type Theory" is really nice and simple, especially in the exposition by W.<br>
Farmer, "The seven virtues of STT"<br>
<a href="http://www.sciencedirect.com/science/article/pii/S157086830700081X">http://www.sciencedirect.com/science/article/pii/S157086830700081X</a></p>
<p>In contrast, Gordon-HOL adds the important concepts of parametric<br>
polymorphism and typedefs, together with considerable complexity. A proof of<br>
degraded simplicity is the historic misunderstanding about extra type<br>
variables in the body of definitions that don't occur in the type of the<br>
defined term. (In Isabelle-jargon this is called "hidden polymorphism", and<br>
is causing horror and shudder to many veterans.)</p>
<p><strong> HOL4 </strong></p>
<p>HOL4 is the current incarnation of the HOL-line after HOL88, starting with<br>
HOL90. It uses a self-hosting SML platform, instead of ML inside LISP.</p>
<p>[small]      ++<br>
   [ML]         ++<br>
   [thm]        +++<br>
   [defs]       +++<br>
   [context]    0<br>
   [logic]      +++<br>
   [formalized] +</p>
<p>[small] less small than the pioneering implementations, but still within<br>
reason.</p>
<p>[ML] I am giving only ++, since HOL4 resides in the raw toplevel of a<br>
standalone SML implementation. This allows to do various system-level<br>
non-sense, e.g. use interrupt signals (CTRL-C on TTY) or threads to disrupt<br>
the internal state of some modules (which expect strictly sequentional<br>
execution).</p>
<p>[thm] + [defs] at its full height, especially after the formal treatment in<br>
<a href="http://www.cl.cam.ac.uk/~rk436/itp14.pdf">http://www.cl.cam.ac.uk/~rk436/itp14.pdf</a></p>
<p>[context] is implicit in the ML environment (hidden mutable references).<br>
Implementation not thread-safe; global assumption of sequentialism.<br>
Otherwise as in LCF.</p>
<p>[logic] I am giving +++ instead of ++ for HOL88, since the formal treatment<br>
has lead to various clarification of obscure details in the original book<br>
chapters by A. Pitts in the HOL88 book.</p>
<p>[formalized] See again <a href="http://www.cl.cam.ac.uk/~rk436/itp14.pdf">http://www.cl.cam.ac.uk/~rk436/itp14.pdf</a> and more<br>
recent ongoing work. Looking forward to see results applied to actual HOL4,<br>
or rather HOL5?</p>
<p><strong> HOL-Light </strong></p>
<p>This is the famous fork from the HOL family by John Harrison.</p>
<p>[small]      +++<br>
   [ML]         +<br>
   [thm]        +++<br>
   [defs]       +++<br>
   [context]    0<br>
   [logic]      ++<br>
   [formalized] +</p>
<p>[small] very small size of key modules.</p>
<p>[ML] HOL-Light uses OCaml instead of SML. OCaml is much less safe than SML,<br>
e.g. strings are mutable, ints overflow at unspecified word size without any<br>
exception, various other oddities and deviations from original ML make it<br>
hard to understand mathematically (e.g possibility for circular datatypes).<br>
Signals allow to inject arbitrary ML exceptions into user code, not just<br>
interrupts. (I am not taking Obj.magic non-sense into account here, since<br>
its absence can be easily detected by looking at the source.)</p>
<p>There is still one + instead of 0, since OCaml is safer than C/C++.</p>
<p>[thm], [defs], [context], [logic], [formalized] similar to HOL4.</p>
<p><strong> Isabelle/HOL </strong></p>
<p>Here "Isabelle/HOL" refers to the main product that end-users experience<br>
when downloading Isabelle. Its sophisticated architecture based on Isabelle<br>
as a framework for building logic-based tools needs to be kept in mind, when<br>
trying understand it thoroughly.</p>
<p>[small]      +<br>
   [ML]         +++<br>
   [thm]        ++<br>
   [defs]       +<br>
   [context]    +++<br>
   [logic]      +<br>
   [formalized] 0</p>
<p>[small] The assembly of Isabelle/ML modules is quite substantial just for<br>
Isabelle/Pure, and more is added in the Isabelle/HOL library. Nonetheless,<br>
there are certain principles of building up in stages to manage complexity.</p>
<p>[ML] extra-safe SML, since we do our own management of the ML compiler and<br>
ML environments, including proper treatment of signals and threads in the<br>
run-time system. Isabelle/ML could in principle do more to isolate user<br>
code from raw system access and other potential non-sense, but that would<br>
mean ++++.</p>
<p>[thm] roughly like in the HOL family, but extra features are hardwired into<br>
the inference kernel, such as higher-order unification or type-class<br>
inferences. It is also not immediately clear, which modules contribute to<br>
the thm implementation and which not.</p>
<p>[defs] constant definitions are fully checked (in Isabelle2014 and<br>
Isabelle2015). HOL typedefs are not fully unchecked and thus "axiomatic" in<br>
the terminology of Isabelle: users are responsible to refrain from non-sense<br>
with overloading involving type constructors.</p>
<p>[context] Type theory and Proof.context serve as immutable containers for<br>
logical reasoning, independently of implicit assumptions about time and<br>
space. This provides structural integrity that is not present in other<br>
LCF-style proof assistant. E.g. it is possible to reason in parallel in<br>
different contexts undisturbed. Going back ("undo") to older states is<br>
trivial: in fact the user is working simultaneous in many different<br>
contexts, when editing a theory document.</p>
<p>[logic] only one +, since type-classes add considerable complexity. The<br>
traditional idea is that this is just a front-end to plain HOL, with a<br>
hypotheticla dictionary-construction, or something else still to be<br>
discussed.</p>
<p>[formalized] Nothing substantial yet. I don't expect a verified Isabelle<br>
implementation anytime soon, due to the sheer size and complexity of<br>
critical modules. It would be nice to transfer results from other HOL<br>
groups, e.g. by exporting to an independent checker in CakeML, OpenTheory<br>
etc.</p>
<p><strong> Coq </strong></p>
<p>Coq is strictly speaking not an LCF-style nor HOL-style system, but G. Huet<br>
and L. Paulson were working together on Cambridge-LCF around 1985, and there<br>
are undeniable family traces.</p>
<p>[small]      +<br>
   [ML]         +++<br>
   [thm]        ++<br>
   [defs]       ++<br>
   [context]    +<br>
   [logic]      +<br>
   [formalized] +</p>
<p>[small] critical Coq modules are about as big as in Isabelle -- I usually<br>
estimate it to be slightly bigger than Isabelle, but this is open to<br>
discussion.</p>
<p>[ML] OCaml is used, but in a more sophisticated manner than in HOL-Light, to<br>
make up for the inherent weaknesses of the language. E.g. there are proper<br>
integers (not machine words) and proper strings (not mutable byte arrays).<br>
Coq also manages its own byte-code interpreter, and more.</p>
<p>[thm] Not an LCF-style abstract datatype, but separate checking, potentially<br>
by an external program. At the level of abstraction of these notes, it is<br>
difficult to relate this to the other systems.</p>
<p>[defs] Serious checking of definitions, with serious complexity built-in.</p>
<p>[context] Just one context for theory and proofs. More explicit than in<br>
classic HOL family, but less versatile than in Isabelle. Tool context is<br>
swapped in-and-out on a single global instance.  Not thread-safe.</p>
<p>[logic] True<br>
[message truncated]</p>



<a name="294652960"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294652960" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294652960">(Aug 22 2022 at 11:14)</a>:</h4>
<p>From: Freek Wiedijk &lt;<a href="mailto:freek@cs.ru.nl">freek@cs.ru.nl</a>&gt;<br>
Makarius:</p>
<p>I think the newest OCaml support immutable strings?<br>
And if in the kernel you would use nums instead of ints,<br>
then the second problems would be gone too?  (It would be<br>
interesting to know how much of a hassle this last change<br>
would be.  And maybe you only would need to go through<br>
nums when you actually calculate with ints in the kernel?<br>
Does this even happen, and if so, in which functions?)</p>
<p>Freek</p>



<a name="294652986"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294652986" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294652986">(Aug 22 2022 at 11:14)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Sun, 20 Sep 2015, Freek Wiedijk wrote:</p>
<blockquote>
<blockquote>
<p>OCaml is much less safe than SML, e.g. strings are mutable, ints <br>
overflow at unspecified word size without any exception,</p>
</blockquote>
<p>I think the newest OCaml support immutable strings?</p>
</blockquote>
<p>This would be very good news indeed.</p>
<blockquote>
<p>And if in the kernel you would use nums instead of ints, then the second <br>
problems would be gone too?</p>
</blockquote>
<p>The Coq guys are doing that.</p>
<p>In Poly/ML we have int = num by default -- at the bottom there is either <br>
the GMP library or an old custom-made implementation.  Both can fail in <br>
their own right, but it is better to have the idea of proper integers <br>
somehow implemented than unspecified machine word arithmetic.</p>
<p>In a discussion with J. Harrison on the HOL mailing list some years ago <br>
about proper integers in LCF-style kernels, we eventually agreed that the <br>
most robust approach would be to have just 64bit integers with explicit <br>
checking (overflow exception), and not bignums.</p>
<p>Note that ML code using infamous catch-all patterns "e1 handle _ =&gt; e2" <br>
would become erratic in situations of spurious overflow!  The Isabelle <br>
code base is clear of that (thanks to static checking and warnings in <br>
Poly/ML), but I still see it routinely in other provers.</p>
<blockquote>
<p>And maybe you only would need to go through nums when you actually <br>
calculate with ints in the kernel? Does this even happen, and if so, in <br>
which functions?</p>
</blockquote>
<p>SML allows in principle to work with fixed-size integers (with overflow <br>
exception) or unbounded integers side-by-side.  An ultra-safe kernel would <br>
use the former, and applications the latter.</p>
<p>We actually used to have such a situation in the past, not on our own <br>
choice, but due to SML/NJ imposing it on us.  It was very annoying to have <br>
limited int here, and bigint there (e.g. for computer-algebra <br>
applications).  Eventually, I made some efforts to collapse the zoo of int <br>
types just to one big int, and we have lived happily ever after.</p>
<p>Makarius</p>



<a name="294652999"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294652999" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294652999">(Aug 22 2022 at 11:14)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Thu, 17 Sep 2015, Ramana Kumar wrote:</p>
<blockquote>
<p>Yesterday, I showed my colleagues that it is possible to prove False in <br>
Isabelle2015 without any warnings or errors and without any use of <br>
axiomatization or oracles.</p>
</blockquote>
<p>This is a confusion produced by the paper: example 2 is in opposition to <br>
the axiomatic nature of "typedef" in all published versions of <br>
Isabelle/HOL.  See the documentation in the isar-ref manual -- it is <br>
usually up-to-date and authoritative, although sometimes a bit terse.</p>
<p>Of course, one could argue if it is a good idea to treat typedef like <br>
that. This would lead to the very start of a serious discussion -- one <br>
without rumors and unnecessary confusion caused by worrying about <br>
publicity or "bad press".</p>
<blockquote>
<p>The trick was, of course, Ondrej's example, but updated to use <br>
"overloading" rather than the deprecated "defs" keyword.</p>
</blockquote>
<p>Both are mostly the same.  The old "defs" command is declared legacy, <br>
since it complicates critical system interfaces.  It is a bit like MS-DOS, <br>
where you still have old CP/M system calls for no good reason, other than <br>
old customs.</p>
<blockquote>
<p>Many of them were surprised, and wanted to know why, when I said that a <br>
patch did exist, it has not been incorporated. I think rumours about <br>
"Isabelle developers" are unavoidable at that point.</p>
</blockquote>
<p>In the last 1.5 years, Ondrej has produced various interesting border <br>
cases. I incorporated changes quickly that where valid counter-examples of <br>
expected and documented behaviour -- he also helped in working out missing <br>
details.</p>
<p>The proposed changes of the present paper are genuine feature additions <br>
that go beyond the known and documented model of Isabelle/HOL.  This is <br>
why I reduced the priority to a reasonable level. And in fact, we are <br>
talking here about a few months latency of TODO-list pipeline -- things <br>
routinely take much longer than that.  Isabelle is not a research <br>
prototype that can be changed arbitrarily at a high rate.</p>
<p>The key question is how users, even power users, can get a more realistic <br>
feeling what the system can do and what not.  Maybe we should make a <br>
systematic collection of odd situations, like <br>
<a href="https://github.com/clarus/falso">https://github.com/clarus/falso</a> for Coq.</p>
<p>Many years ago, system failure happened occasionally in everyday use, so <br>
power users knew what to expect.  Actual breakdown is now so rare in real <br>
work that users think the system is unbreakable, and start spreading false<br>
claims to the outside world.</p>
<p>Makarius</p>



<a name="294653030"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653030" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653030">(Aug 22 2022 at 11:14)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
On 20/09/2015 16:02, Makarius wrote:</p>
<blockquote>
<p>On Thu, 17 Sep 2015, Ramana Kumar wrote:</p>
<blockquote>
<p>Yesterday, I showed my colleagues that it is possible to prove False in<br>
Isabelle2015 without any warnings or errors and without any use of<br>
axiomatization or oracles.</p>
</blockquote>
<p>This is a confusion produced by the paper: example 2 is in opposition to the<br>
axiomatic nature of "typedef" in all published versions of Isabelle/HOL.  See<br>
the documentation in the isar-ref manual -- it is usually up-to-date and<br>
authoritative, although sometimes a bit terse.</p>
<p>Of course, one could argue if it is a good idea to treat typedef like that. This<br>
would lead to the very start of a serious discussion</p>
</blockquote>
<p>I'm afraid that most of the people who have spoken up have looked at the issue <br>
in the light of example 2 and have already decided that this is a no-brainer. <br>
Their contributions were based on that conclusion. And in some cases also on <br>
Ondrej's experiments that showed that neither the distribution nor the AFP <br>
contains any such circularity, neither intentional nor accidental. Hence we have <br>
not heard any views asking for such circularities to be accepted. But maybe you <br>
want to convince us otherwise.</p>
<p>Tobias</p>
<blockquote>
<p>-- one without rumors and<br>
unnecessary confusion caused by worrying about publicity or "bad press".</p>
<blockquote>
<p>The trick was, of course, Ondrej's example, but updated to use "overloading"<br>
rather than the deprecated "defs" keyword.</p>
</blockquote>
<p>Both are mostly the same.  The old "defs" command is declared legacy, since it<br>
complicates critical system interfaces.  It is a bit like MS-DOS, where you<br>
still have old CP/M system calls for no good reason, other than old customs.</p>
<blockquote>
<p>Many of them were surprised, and wanted to know why, when I said that a patch<br>
did exist, it has not been incorporated. I think rumours about "Isabelle<br>
developers" are unavoidable at that point.</p>
</blockquote>
<p>In the last 1.5 years, Ondrej has produced various interesting border cases. I<br>
incorporated changes quickly that where valid counter-examples of expected and<br>
documented behaviour -- he also helped in working out missing details.</p>
<p>The proposed changes of the present paper are genuine feature additions that go<br>
beyond the known and documented model of Isabelle/HOL.  This is why I reduced<br>
the priority to a reasonable level. And in fact, we are talking here about a few<br>
months latency of TODO-list pipeline -- things routinely take much longer than<br>
that.  Isabelle is not a research prototype that can be changed arbitrarily at a<br>
high rate.</p>
<p>The key question is how users, even power users, can get a more realistic<br>
feeling what the system can do and what not.  Maybe we should make a systematic<br>
collection of odd situations, like <a href="https://github.com/clarus/falso">https://github.com/clarus/falso</a> for Coq.</p>
<p>Many years ago, system failure happened occasionally in everyday use, so power<br>
users knew what to expect.  Actual breakdown is now so rare in real work that<br>
users think the system is unbreakable, and start spreading false<br>
claims to the outside world.</p>
<p>Makarius</p>
<p><a href="/user_uploads/14278/kzBRSuz4sN-tgmdEYXxQjoXe/smime.p7s">smime.p7s</a></p>
</blockquote>



<a name="294653045"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653045" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653045">(Aug 22 2022 at 11:15)</a>:</h4>
<p>From: "\"Mark Adams\"" &lt;<a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a>&gt;<br>
Hi Makarius,</p>
<p>Wouldn't it be highly relevant to include HOL Zero in the systems you<br>
consider in your list?</p>
<p>Shouldn't you be considering pretty printing?  In most systems, you can<br>
create all sorts of confusing stuff by exploiting flaws, as we've already<br>
discussed in the past.</p>
<p>And the risk of a trojan horse inference kernel or pretty printer hasn't<br>
been considered.</p>
<p>But then I don't think you were attempting to be complete.</p>
<blockquote>
<p>Makarius:</p>
<blockquote>
<p>OCaml is much less safe than SML, e.g. strings are<br>
mutable</p>
</blockquote>
<p>Freek:<br>
I think the newest OCaml support immutable strings?</p>
</blockquote>
<p>Yes OCaml 4.02 does support immutable strings, but it's not yet considered<br>
to fully incorporated into the language proper.  Unless you do something<br>
specific, you're still using mutable strings.</p>
<p>Note that HOL Zero manages to avoid the problem by making copies of strings<br>
at the interface to the kernel.  There are 21 instances of this in the<br>
kernel.</p>
<blockquote>
<blockquote>
<p>Makarius:<br>
ints overflow at unspecified word size without<br>
any exception,</p>
</blockquote>
<p>Freek:<br>
And if in the kernel you would use nums instead of ints,<br>
then the second problems would be gone too?  (It would<br>
be interesting to know how much of a hassle this last<br>
change would be.  And maybe you only would need to<br>
go through nums when you actually calculate with ints in<br>
the kernel? Does this even happen, and if so, in which<br>
functions?)</p>
</blockquote>
<p>HOL Light 'new_basic_type_definition' uses 'length' which returns a possibly<br>
overflowing int.  So if the predicate in the supplied theorem had enough<br>
type variables (2^30 in a 32-bit OS) then the returned theorem would be<br>
wrong.  This is of course almost impossible to do in practice.</p>
<p>Note that HOL Zero avoids the risk entirely by using 'big_int' (which can be<br>
arbitrarily big).  This requires two utilities used in the kernel, that are<br>
implemented in 14 lines of code.</p>
<blockquote>
<blockquote>
<p>Makarius:<br>
.. various other oddities and deviations from original ML<br>
make it hard to understand mathematically (e.g possibility for<br>
circular datatypes).  Signals allow to inject arbitrary ML<br>
exceptions into user code, not just interrupts. (I am not taking<br>
Obj.magic non-sense into account here, since its absence<br>
can be easily detected by looking at the source.)</p>
</blockquote>
</blockquote>
<p>HOL Zero avoids these risks as far as I know.  But if you could find a way<br>
and demonstrate it, perhaps exploiting exception injection, you could earn<br>
yourself the $100 bounty..  HOL Zero avoids the Obj.magic problem by<br>
overwriting the module.</p>
<p>Note that it's not good enough to grep the source to look for Obj.magic -<br>
you can use obfuscated OCaml code to create an OCaml source code file<br>
containing an Obj.magic, and then read this into the OCaml session.</p>
<p>Mark.</p>



<a name="294653056"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653056" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653056">(Aug 22 2022 at 11:15)</a>:</h4>
<p>From: "\"Mark Adams\"" &lt;<a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a>&gt;<br>
I should mention that a lot of the issues and ideas mentioned in this thread<br>
are discussed in my recent paper:</p>
<p><a href="http://www.proof-technologies.com/flyspeck/qed_paper.pdf">www.proof-technologies.com/flyspeck/qed_paper.pdf</a></p>
<p>Mark.</p>
<p>on 19/9/15 10:39 AM, Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt; wrote:</p>



<a name="294653070"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653070" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653070">(Aug 22 2022 at 11:15)</a>:</h4>
<p>From: Chantal Keller &lt;<a href="mailto:chantal.keller@wanadoo.fr">chantal.keller@wanadoo.fr</a>&gt;<br>
Dear Ramana,</p>
<p>As far as I am aware, the more convincing attempt at checking proofs<br>
coming from provers of the HOL community is Holide<br>
&lt;<a href="https://who.rocq.inria.fr/Ali.Assaf/research/translating-hollight-dedukti-pxtp-2015.pdf">https://who.rocq.inria.fr/Ali.Assaf/research/translating-hollight-dedukti-pxtp-2015.pdf</a>&gt;.<br>
It is still costly though, both to produce proofs and check them, but<br>
this cost has been reduced a lot these last years compared to previous<br>
work. It is based on OpenTheory.</p>
<p>I do not know how it compares to the work David mentioned on seL4.</p>
<p>Best,<br>
Chantal.</p>



<a name="294653178"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653178" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653178">(Aug 22 2022 at 11:15)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
To elaborate, and to answer questions that I received via private<br>
email: The main difficulty here is that Isabelle theories are written<br>
in a rich and powerful language (that may contain, e.g., embedded ML<br>
code), to the point that the observable behavior of Isabelle when it<br>
checks (or more accurately, processes) the theory cannot be trusted.</p>
<p>Of course, other theorem provers with powerful proof languages also<br>
suffer from this problem.</p>
<p>Best,<br>
Tjark</p>



<a name="294653228"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653228" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653228">(Aug 22 2022 at 11:16)</a>:</h4>
<p>From: Larry Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
What we usually do to check a proof development is run “Isabelle build” and look at the output. Of course, Isabelle (and any system based on the LCF paradigm) allows arbitrary code execution. This should be borne in mind in connection with any idea that the use of a proof assistant eliminates the need to trust the person making the proof. None of us are developing software that has the remotest claim to satisfying any sort of security requirement.</p>
<p>Larry Paulson</p>



<a name="294653256"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653256" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653256">(Aug 22 2022 at 11:16)</a>:</h4>
<p>From: Buday Gergely &lt;<a href="mailto:gbuday@karolyrobert.hu">gbuday@karolyrobert.hu</a>&gt;<br>
Larry Paulson wrote:</p>
<p>Proof Carrying Code promised that the delivered code was accompanied by a proof that shows some security properties of the code. Its home page is outdated, does anybody know how far they went achieving this aim?</p>
<ul>
<li>Gergely</li>
</ul>



<a name="294653888"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653888" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653888">(Aug 22 2022 at 11:20)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
(Back to this still open thread.)</p>
<p>Last Monday I started to look at the actual sources and the patch that was <br>
mentioned in the paper, and learned a few more things that I will explain <br>
later, when writing up a full overview of my present understanding of it.</p>
<p>Since reading ML sources and changesets is always a constructive process for <br>
me, I've produced various changesets over several days (being off-list), <br>
leading up to 64a5bce1f498 with the following NEWS entry:</p>
<ul>
<li>The 'typedef' command has been upgraded from a partially checked<br>
"axiomatization", to a full definitional specification that takes the<br>
global collection of overloaded constant / type definitions into<br>
account. Type definitions with open dependencies on overloaded<br>
definitions need to be specified as "typedef (overloaded)". This<br>
provides extra robustness in theory construction. Rare INCOMPATIBILITY.</li>
</ul>
<p>As well as the following updated section in the isar-ref manual (formerly <br>
"Typedef axiomatization"):</p>
<p>section ‹Semantic subtype definitions \label{sec:hol-typedef}›</p>
<p>text ‹<br>
   \begin{matharray}{rcl}<br>
      @{command_def (HOL) "typedef"} &amp; : &amp; @{text "local_theory →<br>
    proof(prove)"} \\<br>
    \end{matharray}</p>
<p>A type definition identifies a new type with a non-empty subset of an<br>
    existing type. More precisely, the new type is defined by exhibiting an<br>
    existing type @{text τ}, a set @{text "A :: τ set"}, and proving @{prop<br>
    "∃x. x ∈ A"}. Thus @{text A} is a non-empty subset of @{text τ}, and<br>
    the new type denotes this subset. New functions are postulated that<br>
    establish an isomorphism between the new type and the subset. In<br>
    general, the type @{text τ} may involve type variables @{text "α⇩1, …,<br>
    α⇩n"} which means that the type definition produces a type constructor<br>
    @{text "(α⇩1, …, α⇩n) t"} depending on those type arguments.</p>
<p>@{rail ‹<br>
      @@{command (HOL) typedef} @{syntax "overloaded"}? abs_type '=' rep_set<br>
      ;<br>
      @{syntax_def "overloaded"}: ('(' @'overloaded' ')')<br>
      ;<br>
      abs_type: @{syntax typespec_sorts} @{syntax mixfix}?<br>
      ;<br>
      rep_set: @{syntax term} (@'morphisms' @{syntax name} @{syntax name})?<br>
    ›}</p>
<p>To understand the concept of type definition better, we need to recount<br>
    its somewhat complex history. The HOL logic goes back to the <code>Simple
    Theory of Types'' (STT) of A. Church @{cite "church40"}, which is
    further explained in the book by P. Andrews @{cite "andrews86"}. The
    overview article by W. Farmer @{cite "Farmer:2008"} points out the
    </code>seven virtues'' of this relatively simple family of logics. STT has<br>
    only ground types, without polymorphism and without type definitions.</p>
<p>\medskip M. Gordon @{cite "Gordon:1985:HOL"} augmented Church's STT by<br>
    adding schematic polymorphism (type variables and type constructors) and<br>
    a facility to introduce new types as semantic subtypes from existing<br>
    types. This genuine extension of the logic was explained semantically by<br>
    A. Pitts in the book of the original Cambridge HOL88 system @{cite<br>
    "pitts93"}. Type definitions work in this setting, because the general<br>
    model-theory of STT is restricted to models that ensure that the<br>
    universe of type interpretations is closed by forming subsets (via<br>
    predicates taken from the logic).</p>
<p>\medskip Isabelle/HOL goes beyond Gordon-style HOL by admitting<br>
    overloaded constant definitions @{cite "Wenzel:1997:TPHOL" and<br>
    "Haftmann-Wenzel:2006:classes"}, which are actually a concept of<br>
    Isabelle/Pure and do not depend on particular set-theoretic semantics of<br>
    HOL. Over many years, there was no formal checking of semantic type<br>
    definitions in Isabelle/HOL versus syntactic constant definitions in<br>
    Isabelle/Pure. So the @{command typedef} command was described as<br>
    ``axiomatic'' in the sense of \secref{sec:axiomatizations}, only with<br>
    some local checks of the given type and its representing set.</p>
<p>Recent clarification of overloading in the HOL logic proper @{cite<br>
    "Kuncar-Popescu:2015"} demonstrate how the dissimilar concepts of<br>
    constant definitions versus type definitions may be understood<br>
    uniformly. This requires an interpretation of Isabelle/HOL that<br>
    substantially reforms the set-theoretic model of A. Pitts @{cite<br>
    "pitts93"}, by taking a schematic view on polymorphism and interpreting<br>
    only ground types in the set-theoretic sense of HOL88. Moreover,<br>
    type-constructors may be explicitly overloaded, e.g.\ by making the<br>
    subset depend on type-class parameters (cf.\ \secref{sec:class}). This<br>
    is semantically like a dependent type: the meaning relies on the<br>
    operations provided by different type-class instances.</p>
<p>\begin{description}</p>
<p>\item @{command (HOL) "typedef"}~@{text "(α⇩1, …, α⇩n) t = A"} defines<br>
    a new type @{text "(α⇩1, …, α⇩n) t"} from the set @{text A} over an<br>
    existing type. The set @{text A} may contain type variables @{text<br>
    "α⇩1, …,α⇩n"}as specified on the LHS, but no term variables.<br>
    Non-emptiness of @{text A} needs to be proven on the spot, in order to<br>
    turn the internal conditional characterization into usable theorems.</p>
<p>The ``@{text "(overloaded)"}'' option allows the @{command "typedef"}<br>
    specification to depend on constants that are not (yet) specified and<br>
    thus left open as parameters, e.g.\ type-class parameters.</p>
<p>Within a local theory specification, the newly introduced type<br>
    constructor cannot depend on parameters or assumptions of the context:<br>
    this is syntactically impossible in HOL. The non-emptiness proof may<br>
    formally depend on local assumptions, but this has little practical<br>
    relevance.</p>
<p>For @{command (HOL) "typedef"}~@{text "t = A"} the newly introduced type<br>
    @{text t} is accompanied by a pair of morphisms to relate it to the<br>
    representing set over the old type.  By default, the injection from type<br>
    to set is called @{text Rep_t} and its inverse @{text Abs_t}: An<br>
    explicit @{keyword (HOL) "morphisms"} specification allows to provide<br>
    alternative names.</p>
<p>The logical characterization of @{command typedef} uses the predicate of<br>
    locale @{const type_definition} that is defined in Isabelle/HOL. Various<br>
    basic consequences of that are instantiated accordingly, re-using the<br>
    locale facts with names derived from the new type constructor. Thus the<br>
    generic theorem @{thm type_definition.Rep} is turned into the specific<br>
    @{text "Rep_t"}, for example.</p>
<p>Theorems @{thm type_definition.Rep}, @{thm type_definition.Rep_inverse},<br>
    and @{thm type_definition.Abs_inverse} provide the most basic<br>
    characterization as a corresponding injection/surjection pair (in both<br>
    directions).  The derived rules @{thm type_definition.Rep_inject} and<br>
    @{thm type_definition.Abs_inject} provide a more convenient version of<br>
    injectivity, suitable for automated proof tools (e.g.\ in declarations<br>
    involving @{attribute simp} or @{attribute iff}). Furthermore, the rules<br>
    @{thm type_definition.Rep_cases}~/ @{thm type_definition.Rep_induct},<br>
    and @{thm type_definition.Abs_cases}~/ @{thm type_definition.Abs_induct}<br>
    provide alternative views on surjectivity.  These rules are already<br>
    declared as set or type rules for the generic @{method cases} and<br>
    @{method induct} methods, respectively.</p>
<p>\end{description}</p>
<p>This may still require more polishing before the winter release of <br>
Isabelle2016, but there is time for that.</p>
<p>My impression is that part of the discussion so far was encumbered by anxiety <br>
that this add-on feature won't make it into the next release. Now that there is <br>
no more pressure in this respect, we can sort out remaining low-level and <br>
high-level problems in a relaxed manner.</p>
<p>In the next round I will comment more on the ITP paper and the notes on the <br>
original patch ...</p>
<p>Makarius</p>



<a name="294653909"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653909" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653909">(Aug 22 2022 at 11:20)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
Now Isabelle has a feature, which is (IMHO) essential for a theorem<br>
prover, and which many users (including me) deemed already present in<br>
older Isabelle's, and were surprised that it wasn't.</p>
<p>A leap ahead for Isabelle!</p>



<a name="294653915"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653915" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653915">(Aug 22 2022 at 11:20)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Now we are back to the actual social problems: Why do Isabelle power users <br>
have an inadequate idea what the system does and what not, despite the <br>
official documentation.</p>
<p>We need to work harder on this thread, to move forward.</p>
<p>Makarius</p>



<a name="294653929"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653929" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653929">(Aug 22 2022 at 11:20)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:A.Popescu@mdx.ac.uk">A.Popescu@mdx.ac.uk</a>&gt;<br>
Hi Makarius, </p>
<p>Many thanks for this great news! Declaring the Isabelle/HOL typedef to be definitional is well-justified and surely welcomed by the users.  <br>
This definitional status, achieved on a tricky foundational terrain in the presence of constant overloading, benefits from the previous work <br>
on taming overloading by yourself, Steven Obua  and Florian Haftmann (among others).  </p>
<p>I am looking forward to the relaxed discussion in front of us.     :-)  </p>
<p>All the best, <br>
   Andrei</p>



<a name="294653984"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294653984" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294653984">(Aug 22 2022 at 11:20)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Here is now my virtual review of the ITP paper behind this thread. It came <br>
out a bit longer than anticipated, although I included only half of the <br>
thoughts that came to me, while reading it 3 times.</p>
<p>Makarius</p>
<hr>
<p>Title: A Consistent Foundation for Isabelle/HOL<br>
Authors: Ondřej Kunčar, Andrei Popescu<br>
<a href="http://www21.in.tum.de/~kuncar/documents/kuncar-popescu-itp2015.pdf">http://www21.in.tum.de/~kuncar/documents/kuncar-popescu-itp2015.pdf</a></p>
<p>Overall evaluation: accept<br>
Reviewer's confidence: high</p>
<p>Review:</p>
<p>The paper revisits the question how overloaded definitions (of constants and<br>
type constructores) may be understood within the HOL logic. This work<br>
consists of three parts:</p>
<p>(1) Technical treatment of the HOL logic, with a notion of "definitional<br>
   theory" and its well-formedness, interpretation of this extended HOL logic<br>
   in a substantially reformed version of the original HOL88 interpretation<br>
   due to A. Pitts.</p>
<p>(2) A proposed change to the Isabelle2014 code base, to upgrade its<br>
   'typedef' mechanism to perform the additional well-formedness checks<br>
   described in the paper. The text refers to<br>
<a href="http://www21.in.tum.de/~kuncar/documents/patch.html">http://www21.in.tum.de/~kuncar/documents/patch.html</a> which provides some<br>
   changesets and one page of explanations how this fits into the setup of<br>
   the paper.</p>
<p>(3) General motivation and discussion of perceived problems of<br>
   Isabelle/HOL, which the paper sets out to resolve. This part is apt to<br>
   cause confusion in various ways, both to users and non-users of Isabelle.<br>
   The style of presentation considerably subtracts from this otherwise fine<br>
   paper.</p>
<p>Part (1)</p>
<hr>
<p>These are sections 3, 4, 5 in the paper. Section 5 is the main contribution.<br>
The classic HOL logic of HOL88 (due to M. Gordon and semantics by A. Pitts)<br>
is taken as starting point. There is a nice explanation in 4.3, why<br>
overloaded definitions of constants or types does not work out in the<br>
interpretation of A. Pitts (HOL88 book from 1993). Thus a new interpretation<br>
is introduced as follows:</p>
<p>* Types are not immediately interpreted away into sets, but preserved as<br>
   syntactic entities to keep sufficient structure that allows well-founded<br>
   recursion. The paper calls this "a natural syntactic-semantic blend, which<br>
   avoids stunt performance in set theory".</p>
<p>* Type interpretation starts out on ground types. Polymorphism is<br>
   interpreted only in the final stage, treating it as strictly schematic<br>
   over all ground interpretations.</p>
<p>* Models for ground interpretation are constructed in stages, following<br>
   the well-founded dependency relation of the given collection of<br>
   definitions. Here types and constants are interpreted simultaneously for<br>
   each stage, while in the HOL88 semantics by A. Pitts all types are<br>
   interpreted before all constants.</p>
<p>This model construction is fit together with other recent work by the first<br>
author [19], opening the perspective of fully checked definitional theories<br>
in Isabelle/HOL. More about this in part (2).</p>
<p>Taking the little space of a paper in LNCS proceedings into account, the<br>
technical treatment of the problem is worked out very carefully. Numerous<br>
fine points and additional side-conditions are included in the<br>
considerations.</p>
<p>Nonetheless, there is a potential for confusion due to slight deviation of<br>
terminology and concepts, compared to papers on the subject e.g. by<br>
Wenzel/Haftmann and the Isabelle documentation (isar-ref manual).</p>
<p>In particular: Section 3.4 defines a "definitional theory" as a set of<br>
overloaded definitions (for constants or types) such that certain <em>local</em><br>
syntactic conditions hold. Section 4.2 defines a "well-formed definitional<br>
theory" as a definitional theory with well-founded dependency relation as<br>
<em>global</em> condition. Section 4.5 establishes the main theorem that a<br>
well-formed definitional theory is consistent -- by demonstrating that it<br>
has a model in the above sense, and concluding that False cannot be derived<br>
in the inference system -- due to soundness of the interpretation.</p>
<p>In contrast, the specifications of a "definitional theory" of the paper<br>
would be called in the Isabelle documentation "unchecked definitions",<br>
"definitional axioms", or "axiomatizations", to emphasize the missing aspect<br>
of global well-formedness that this paper is mainly about. A "well-formed<br>
definitional theory" of the paper would be just called "definitional theory"<br>
in Isabelle terminology, and much stronger properties intended than just<br>
consistency. Instead of merely ensuring the existence of a model, the<br>
requirement is to preserve derivability of old propositions precisely, and<br>
allow to reduce new derivations of new propositions into old derivations by<br>
"expanding" definitions in some way. If and how this works depends on<br>
fine-points of the underlying definitional mechanisms: for overloaded<br>
constant definitions in Isabelle/Pure this works [13, 35], but for type<br>
definitions the situation is a-priori quite different, e.g. see [13] section<br>
4.3. The deeper reason for this are the distinctive categories of terms and<br>
types in HOL, and the lack of equational reasoning on types.</p>
<p>A suitable semantic treatment is required to re-unify the view on terms and<br>
types, as is done in the present paper. But this leads to weaker results.<br>
The paper does briefly mention "a suitable notion of conservativeness" as<br>
future work, but due to lack of further explanations, many readers will<br>
probably miss key point behind this.</p>
<p>There is another aspect of "consistency" versus "conservativity" that is<br>
easily missed in the paper. Section 3.5 states "Isabelle/HOL theory<br>
development proceeds by: 1 ... 2 ... 3 ...". The three kinds of operations<br>
ensure that every stage of theory development is "definitional" in the sense<br>
of the paper -- and "well-formedness" can be established later. But what<br>
happens when the user starts adding non-definitional axioms in between?<br>
Strictly speaking, the main result does not apply and the whole theory<br>
looses its good definitional properties.</p>
<p>In contrast, the traditional explanation of (constant) definitions in<br>
Isabelle is more modular in that respect: given an arbitrary base theory ---<br>
one that somehow makes sense to the user in a particular application, even<br>
after making unchecked axiomatizations --- definitions merely introduce<br>
names for existing entities and thus preserve the key properties of the base<br>
theory. This agnostic approach of "definitional theory extensions"<br>
(occording to Isabelle terminolgy) is particularly important from the<br>
perspective of the Isabelle/Pure framework, where the interpretation of<br>
object-logics is not yet known.</p>
<p>For HOL applications one might argue that genuine axiomatic extensions are<br>
not done in practice these days. Nonetheless some exotic applications like<br>
HOLZF (by Obua) do exist. Without stronger results under which conditions<br>
typedefs "make sense" or "are OK" (using words from the paper), such<br>
ambitious users would have to revisit the whole model theory of HOL again.</p>
<p>Part (2)</p>
<hr>
<p>The patch to Isabelle2014 is rather minimal: the existing infrastructure to<br>
check overloaded constant definitions (going back to Isabelle2007, and<br>
slightly improved by O. Kuncar [19] is generalized to cover type definitions<br>
as well. So Isabelle/Pure is upgraded to provide a general service for<br>
"definitional specification items" that are identified in the name space for<br>
constants or types, but without looking at actual content.</p>
<p>While the explanations for the patch states "the situation is from a<br>
technical (implementation) point view a little bit more complicated", the<br>
outcome is actually simpler than in the paper. Being forced to strip away<br>
accidental aspects of the HOL object-logic does occasionally have<br>
advantages.</p>
<p>For example, the delicate notion of "build-in types" vs. "non-built-in<br>
types" is absent in the implementation. The notes on the patch provide some<br>
explanations, why it works out nonetheless. It would be nice to see this<br>
refinement applied to the main work of part (1), to trim it further down to<br>
the very essence of symbolic specifications with schematic polymorphism and<br>
overloading.</p>
<p>The proposed change to Isabelle2014 is called "correction patch", as if<br>
something would be broken that is fixed by the change. This misunderstanding<br>
leads directly into the general discussion of this work below.</p>
<p>Part (3)</p>
<hr>
<p>These are sections 1 "Introduction", section 2 "Related Work", section 6<br>
"Conclusion", i.e. the important pieces that put the technical contribution<br>
into proper perspective. This is what most people read, and what attendants<br>
of a conference presentation who are busy with their e-mails or smart-phone<br>
usually take home. Unfortunately, the story being told here do not quite fit<br>
to Isabelle.</p>
<p>The misunderstanding already starts in the first paragraph, where<br>
Isabelle/HOL is included into the "umbrella term" of "HOL-based provers".<br>
HOL4, HOL-Light, ProofPower, HOL Zero are fine systems, but Isabelle/HOL is<br>
not as closely related to them as the "HOL" name might suggest. In many<br>
respects Isabelle is actually closer to Coq.</p>
<p>Technically, the key misunderstanding is the role of "the kernel" (in the<br>
words of the paper). HOL88 as the predecessor of all the other HOL systems<br>
pioneered an add-on to the original LCF kernel design to have checked<br>
definitions as primitive rules. In contrast, Isabelle is closer to LCF in<br>
separating logical inferences and a-priori unchecked (axiomatic) theory<br>
specifications: there is no notion of definitions in the inference kernel of<br>
Isabelle. Since this is a bit impractical for big applications, more and<br>
more checks on theory content have been added over the years (e.g. 2004,<br>
2005, 2007, 2010, 2014), but that process was never formally closed. And<br>
this is what the paper is actually about: complete emulation of HOL88-style<br>
definitions in Isabelle/HOL (by providing additional services in the<br>
Isabelle/Pure framework).</p>
<p>We can now revisit the critical examples in t<br>
[message truncated]</p>



<a name="294654008"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294654008" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294654008">(Aug 22 2022 at 11:21)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:a.popescu@mdx.ac.uk">a.popescu@mdx.ac.uk</a>&gt;<br>
Hi Makarius,</p>
<p>Many thanks for your comments, and for the acceptance decision which will make the rebuttal phase very relaxed.</p>
<p>I'll send the rebuttal comments tomorrow.</p>
<p>All the best,<br>
  Andrei</p>



<a name="294654187"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294654187" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294654187">(Aug 22 2022 at 11:22)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:a.popescu@mdx.ac.uk">a.popescu@mdx.ac.uk</a>&gt;<br>
Hi Makarius,</p>
<p>I thank you very much for looking at the technical contribution of the paper beyond matters of terminology and "attitude."<br>
I find your summary of our technical contribution to be excellent.</p>
<p>In order to discuss your comments concerning our "attitude," I would first like to state my own view<br>
on the situation, which is not entirely divergent from your view.</p>
<p>Isabelle/HOL is not a standard object logic of Isabelle/Pure, in the usual sense of object logics represented in a logical framework.<br>
The culprit is typedef, which is implemented in an ad hoc manner, and not as an object-logic judgment. This is necessary<br>
due to the nature of typedef. But this is already a warning that whatever guarantees one provides at the generic level of<br>
Isabelle/Pure may simply not be good enough for Isabelle/HOL.</p>
<p>By contrast, the constant definition mechanism from Isabelle/Pure is imported to Isabelle/HOL following a uniform<br>
"object-logic inside meta-logic" shallow embedding scheme. This scheme also applies, for example, to the representation of<br>
bindings and the function space.</p>
<p>In your ‘97 paper you prove the following very nice result:<br>
In Isabelle/Pure, under suitable orthogonality and well-foundedness conditions, the addition of overloaded<br>
constant definitions to any theory T is "meta-safe," in that it is syntactically conservative and<br>
anything provable in the extended theory can also be represented and proved in the original T in<br>
a canonical way, by “realizing” the new constants as terms in the old signature. This indeed is a very<br>
strong conservativity result, which also implies preservation of consistency. It  applies to the object logics<br>
of Isabelle/Pure, which can be regarded as theories. As you also remind us in your review, another pleasant<br>
feature of this result is T not needing to be a definitional theory.</p>
<p>But: Isabelle/HOL of course only partly benefits from this result. In fact, compared to Gordon-HOL,<br>
which offers model-theoretic safety<br>
for both constant and type definitions, I would say that in these conditions Isabelle/HOL would be<br>
only half-way safe, and quite non-democratically so. On the one hand, there is this luxurious (meta-)safety<br>
guarantee for constant definitions, and on the other hand there is <em>nothing</em> for typedef. Instead of stating this problem<br>
as a <em>pressing open problem</em> (already in ‘97), you had decided to introduce this oxymoron: "axiomatic typedef."<br>
Unfortunately, nobody (except perhaps for Florian who used to “joke” about typedef being axiomatic) has noticed this<br>
ideological move away from the tradition of the HOL systems.</p>
<p>(Here, I have a confession. When reading your paper, it simply did not cross my mind that you could have<br>
just abandoned typedef :-( and instead I came up with the following explanation: Your approach is to prove as<br>
much as you can in Isabelle/Pure for constants,<br>
namely, meta-safety, and in particular syntactic conservativity. Then you would move to the object level of Isabelle/HOL where<br>
typedef is model-theoretically safe, in particular syntactically conservative for definitional theories. Putting together these two<br>
properties, you would get consistency of definitional theories of Isabelle/HOL. As we know now,<br>
this almost works but not quite, since typedefs are allowed to depend on unresolved overloading.)</p>
<p>Next I comment on your review:</p>
<blockquote>
<blockquote>
<p>Technically, the key misunderstanding is the role of "the kernel" (in the<br>
words of the paper). HOL88 as the predecessor of all the other HOL systems<br>
pioneered an add-on to the original LCF kernel design to have checked<br>
definitions as primitive rules. In contrast, Isabelle is closer to LCF in<br>
separating logical inferences and a-priori unchecked (axiomatic) theory<br>
specifications: there is no notion of definitions in the inference kernel of Isabelle.</p>
</blockquote>
</blockquote>
<p>In the paper, we use the word "kernel" to mean "logic kernel" (as I hoped  would be clear from the paper's<br>
general context and from the usage of the phrase<br>
“logic kernel” for one of the two occurrences of the word).<br>
The logic kernel consists of the inference rules and the definitional mechanisms, regardless of where they<br>
are located in the implementation. A small logic kernel is an implementation-independent virtue of<br>
Isabelle/HOL as well as of all the Gordon-HOL systems.</p>
<blockquote>
<blockquote>
<p>Nonetheless, there is a potential for confusion due to slight deviation of<br>
terminology and concepts, compared to papers on the subject e.g. by<br>
Wenzel/Haftmann and the Isabelle documentation (isar-ref manual).<br>
...<br>
In contrast, the specifications of a "definitional theory" of the paper<br>
would be called in the Isabelle documentation "unchecked definitions",<br>
"definitional axioms", or "axiomatizations", to emphasize the missing aspect<br>
of global well-formedness that this paper is mainly about.</p>
</blockquote>
</blockquote>
<p>For the journal version, we will switch to the terminology from the Isabelle documentation.<br>
I believe "definitional axioms" is the most suggestive term here. And "axiomatizations" is too wide.</p>
<blockquote>
<blockquote>
<p>A "well-formed definitional theory" of the paper would be just called "definitional theory"<br>
in Isabelle terminology, and much stronger properties intended than just consistency.<br>
Instead of merely ensuring the existence of a model, the requirement is to preserve derivability of old propositions precisely, and<br>
allow to reduce new derivations of new propositions into old derivations by<br>
"expanding" definitions in some way. If and how this works depends on<br>
fine-points of the underlying definitional mechanisms: for overloaded<br>
constant definitions in Isabelle/Pure this works [13, 35], but for type<br>
definitions the situation is a-priori quite different, e.g. see [13] section 4.3.<br>
The deeper reason for this are the distinctive categories of terms and<br>
types in HOL, and the lack of equational reasoning on types.</p>
</blockquote>
</blockquote>
<p>Indeed, consistency is a crucial, but rather weak property. With a bit of extra care, we could have stated our result<br>
as more than consistency, namely, something similar to the preservation of standard models in the sense<br>
of Gordon-HOL (which you revisit in your '97 paper).</p>
<blockquote>
<blockquote>
<p>A suitable semantic treatment is required to re-unify the view on terms and<br>
types, as is done in the present paper. But this leads to weaker results.<br>
The paper does briefly mention "a suitable notion of conservativeness" as<br>
future work, but due to lack of further explanations, many readers will<br>
probably miss key point behind this.</p>
</blockquote>
</blockquote>
<p>We do cite your paper there, so the reader can look up the relevant notion. However, I think that for most of the interesting theories,<br>
typedef cannot be safe in any sense<br>
even remotely similar to what you prove for constant definitions. In fact, typedef cannot be proved to preserve consistency<br>
for non-definitional theories. This is shown by an example in your '97 paper, which I slightly generalize below:<br>
Given any finite consistent definitional theory T, we should always be able find a number N such that there exists a<br>
set-theoretic model of T where no type has precisely N elements. So T + "no type 'a has precisely N elements" is consistent,<br>
but defining a type with N elements makes it inconsistent.</p>
<blockquote>
<blockquote>
<p>There is another aspect of "consistency" versus "conservativity" that is<br>
easily missed in the paper. Section 3.5 states "Isabelle/HOL theory<br>
development proceeds by: 1 ... 2 ... 3 ...". The three kinds of operations<br>
ensure that every stage of theory development is "definitional" in the sense<br>
of the paper -- and "well-formedness" can be established later. But what<br>
happens when the user starts adding non-definitional axioms in between?<br>
Strictly speaking, the main result does not apply and the whole theory<br>
looses its good definitional properties.<br>
...<br>
For HOL applications one might argue that genuine axiomatic extensions are<br>
not done in practice these days.</p>
</blockquote>
</blockquote>
<p>You are right, our result is restricted to definitional theories.<br>
But typedef seems brittle in the face of amendments to the standard HOL model theory.<br>
And such amendments are easily possible if one steps outside definitional theories.</p>
<blockquote>
<blockquote>
<p>Nonetheless some exotic applications like<br>
HOLZF (by Obua) do exist. Without stronger results under which conditions<br>
typedefs "make sense" or "are OK" (using words from the paper), such<br>
ambitious users would have to revisit the whole model theory of HOL again.</p>
</blockquote>
</blockquote>
<p>IMO, Obua and other initiators of interesting experiments, besides forming an absolute minority of the users, are logical<br>
grown-ups who typically know what they are doing. And they are in plain wilderness in the first place, when proving consistency.</p>
<blockquote>
<blockquote>
<p>In contrast, the traditional explanation of (constant) definitions in<br>
Isabelle is more modular in that respect: given an arbitrary base theory ---<br>
one that somehow makes sense to the user in a particular application, even<br>
after making unchecked axiomatizations --- definitions merely introduce<br>
names for existing entities and thus preserve the key properties of the base<br>
theory. This agnostic approach of "definitional theory extensions"<br>
(occording to Isabelle terminolgy) is particularly important from the<br>
perspective of the Isabelle/Pure framework, where the interpretation of<br>
object-logics is not yet known.</p>
</blockquote>
</blockquote>
<p>Agreed. But I am happy that the less generic Isabelle/HOL typedef feature now receives some consideration as well.</p>
<blockquote>
<blockquote>
<p>For example, the delicate notion of "build-in types" vs. "non-built-in<br>
types" is absent in the implementation. The notes on the patch provide some<br>
explanations, why it works out nonetheless. It would be nice to see this<br>
refinement applied to the main work of part (1), to trim it further down to<br>
the very essence of symbolic specifications with schematic polymorphism and<br>
overload<br>
[message truncated]</p>
</blockquote>
</blockquote>



<a name="294654913"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294654913" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294654913">(Aug 22 2022 at 11:27)</a>:</h4>
<p>From: Burkhart Wolff &lt;<a href="mailto:Burkhart.Wolff@lri.fr">Burkhart.Wolff@lri.fr</a>&gt;<br>
Dear all, </p>
<p>with respect to the debate around the paper by Ondřej Kunčar and Andrei Popescu: A Consistent Foundation for Isabelle/HOL (ITP 2015) <br>
and the debate it created, I have the following remarks and informations to add:</p>
<p>1) To be not misunderstood: I find this publication helpful and, after the quite nonchalant <br>
    reactions of key members of the Isabelle Community, strictly speaking necessary.</p>
<p>2) This paper creates outside the Isabelle community more echo than people might think.<br>
    At the moment, I am as part of the EUROMILS project part of the team that attempts<br>
    to get a common criteria (CC EAL5) evaluation for PikeOS through, where the models<br>
    and proofs were done with Isabelle. I can tell that I had a lengthy debate with<br>
    Evaluators and (indirectly) BSI representatives which became aware about this paper.</p>
<p>And of course, there is the effect of a children's telephone game which distorts the <br>
    story hopelessly.</p>
<p>3) As part of the project, we wrote early a Recommandations-Whitepaper explaining the importance<br>
    of conservative extensions and trying to define something like a “safe subset” of Isabelle. <br>
    It is called:</p>
<p>"Using Isabelle/HOL in Certification Processes: A System Description and Mandatory Recommendations" </p>
<p>and is part one of the EUROMILS Deliverable <a href="http://www.euromils.eu/downloads/Deliverables/Y2/2015-EM-UsedFormalMethods-WhitePaper.pdf">http://www.euromils.eu/downloads/Deliverables/Y2/2015-EM-UsedFormalMethods-WhitePaper.pdf</a> &lt;<a href="http://www.euromils.eu/downloads/Deliverables/Y2/2015-EM-UsedFormalMethods-WhitePaper.pdf">http://www.euromils.eu/downloads/Deliverables/Y2/2015-EM-UsedFormalMethods-WhitePaper.pdf</a>&gt;,<br>
   (pp. 1 .. 39)<br>
    a paper that is submitted to the ANSI and the BSI as part of the Common Criteria Evaluation of the PikeOS operating system.<br>
    It may be that these Mandatory recommendations were reused in future projects of this kind.</p>
<p>In this paper, we ruled out the critical consts - defs combination as unsafe, and made sure that we did not use these constructs in<br>
    our entire theories (as well as axioms, etc. Restraining strictly to conservative extension and avoiding obfuscation).</p>
<p>4) I welcome to see more formally proved meta-theory of Isabelle’s specification constructs; the HOL4 community shows at the<br>
    moment impressive progresses in this direction. May be that other open issues could be addressed as well. </p>
<p>Best regards,</p>
<p>Burkhart</p>



<a name="294654965"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294654965" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294654965">(Aug 22 2022 at 11:27)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
In the replied-to mail, I see more arguments that we should add proper<br>
dependency checking to Isabelle/HOL as soon as possible.</p>
<p>As far as I know, there is a patch of Kunčar, which exists for more than<br>
half a year now, which</p>
<p>* ensures that consts/defs only produce conservative extensions<br>
  * Does not slow down Isabelle significantly<br>
  * Works with whole AFP and Isabelle-Library, i.e., is does not break<br>
existing formalizations by being too restrictive.</p>
<p>However, it seems to be rejected or not given high priority by some main<br>
Isabelle developers. </p>
<p>If we would have integrated this patch earlier, we could have said:<br>
There was an issue, but now it is fixed, and we even have a<br>
(pen-and-paper) proof that it is sound now. So, anyone who reads the<br>
paper would probably be happy, and the rumours spread would be somewhat<br>
like: "The old Isabelle versions are unsound, you should update to<br>
Isabelle-2015, this is provably sound now"</p>
<p>However, now we have: If you use overloading, you are basically on your<br>
own, and have to ensure consistency yourself. Rules how to ensure<br>
consistent definitions are not included in the Isabelle documentation.<br>
And the rumours about Isabelle unsoundness spread as described in the<br>
replied-to mail.</p>
<p>So if we want to use Isabelle as a device to get very high confidence in<br>
our proofs, any mechanism that allows you to prove False in some<br>
intransparent ways should be considered a severe malfunction of the<br>
system, and fixed as soon as possible. And tainting an essential<br>
mechanism as axiomatic (as the documentation of defs does) is not a<br>
solution, but makes the system essentially unusable for getting<br>
high-confidence theorems.</p>
<p>In my opinion, we should even think of a mode of operation that forbids<br>
to add any axioms beyond a certain default set of axioms (e.g. HOL),<br>
such that we can establish the guarantee: "Sound wrt. HOL", without<br>
manually inspecting all theory files for axiomatic declarations (see<br>
HOL-zero how to drive this idea to the extreme).</p>



<a name="294654985"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294654985" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294654985">(Aug 22 2022 at 11:27)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Wed, 16 Sep 2015, Peter Lammich wrote:</p>
<blockquote>
<p>As far as I know, there is a patch of Kunčar, which exists for more than<br>
half a year now, which<br>
 * ensures that consts/defs only produce conservative extensions<br>
 * Does not slow down Isabelle significantly<br>
 * Works with whole AFP and Isabelle-Library, i.e., is does not break<br>
existing formalizations by being too restrictive.</p>
<p>However, it seems to be rejected or not given high priority by some main<br>
Isabelle developers.</p>
</blockquote>
<p>Can you quote precisely who said what?  Otherwise we get into a situation <br>
of vague rumors and implicit accusations of unnamed people.</p>
<blockquote>
<p>If we would have integrated this patch earlier, we could have said:<br>
There was an issue, but now it is fixed, and we even have a<br>
(pen-and-paper) proof that it is sound now. So, anyone who reads the<br>
paper would probably be happy, and the rumours spread would be somewhat<br>
like: "The old Isabelle versions are unsound, you should update to<br>
Isabelle-2015, this is provably sound now"</p>
</blockquote>
<p>The last sentence is the opposite of what I am trying to point out on <br>
isabelle-users and on isabelle-dev for countless years. When there is an <br>
incident of some sort, and change might improve the situation or make it <br>
worse.  There is never a state where one could claim it to be "fixed".</p>
<p>Makarius</p>



<a name="294654999"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294654999" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294654999">(Aug 22 2022 at 11:27)</a>:</h4>
<p>From: Larry Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
I was under the impression that this patch had been adopted. I don’t believe that I saw any arguments against it.<br>
Larry</p>



<a name="294655051"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655051" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655051">(Aug 22 2022 at 11:28)</a>:</h4>
<p>From: Lars Noschinski &lt;<a href="mailto:noschinl@in.tum.de">noschinl@in.tum.de</a>&gt;<br>
We know that the current situation is bad -- at least, as long as one<br>
wants to treat definitions as conservative extensions, which many of us<br>
want to do. I understand there is a patch with a sound theory behind it,<br>
which prohibits unsound definitions, without breaking current applications.</p>
<p>We may never achieve perfectness, there may be other issues, there may<br>
be an even deeper change which would be even better. But I would expect<br>
a critical (under the above assumptions) hole to be closed, as soon as<br>
the problem is understood -- and not blocked on the vague notion that<br>
every change may break something.</p>
<p>-- Lars</p>



<a name="294655101"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655101" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655101">(Aug 22 2022 at 11:28)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;</p>
<blockquote>
<blockquote>
<p>However, it seems to be rejected or not given high priority by some main<br>
Isabelle developers.</p>
</blockquote>
<p>Can you quote precisely who said what?  Otherwise we get into a situation <br>
of vague rumors and implicit accusations of unnamed people.</p>
</blockquote>
<p>Unfortunately, there seems to be a lot of rumours, and these issues have<br>
never been discussed openly. Also my knowledge is partially based on<br>
rumours. Clear facts are the following:</p>
<p>In their paper [2], Popescu and Kuncar refer to a patch<br>
<a href="http://www21.in.tum.de/~kuncar/documents/patch.html">http://www21.in.tum.de/~kuncar/documents/patch.html</a><br>
and say: "it is currently evaluated at the Isabelle headquarters"</p>
<p>Since the paper was written about 6 month ago, and nothing has yet<br>
happened in this direction [in my opinion, the patch should be<br>
integrated as soon as possible, and Isabelle2015-1 released immediately!<br>
], I concluded what I said above.</p>
<blockquote>
<blockquote>
<p>If we would have integrated this patch earlier, we could have said:<br>
There was an issue, but now it is fixed, and we even have a<br>
(pen-and-paper) proof that it is sound now. So, anyone who reads the<br>
paper would probably be happy, and the rumours spread would be somewhat<br>
like: "The old Isabelle versions are unsound, you should update to<br>
Isabelle-2015, this is provably sound now"</p>
</blockquote>
<p>The last sentence is the opposite of what I am trying to point out on <br>
isabelle-users and on isabelle-dev for countless years. When there is an <br>
incident of some sort, and change might improve the situation or make it <br>
worse.  There is never a state where one could claim it to be "fixed".</p>
</blockquote>
<p>This generic and vague statement can be used as an argument against any<br>
change, and against any argumentation why the change is necessary.</p>
<p>Let me try anyway: Most users of Isabelle expect that they cannot prove<br>
False, unless they use some well-known unsafe methods, such as<br>
axiomatization and oracles. This is a primary design goal of Isabelle.<br>
This is supported, for example in [1], by the following statements:<br>
  "The logical core is implemented according to the well-known “LCF<br>
approach”"</p>
<p>"object-logics are specified by<br>
stating their characteristic rules as new axioms. Any later additions in<br>
application the-<br>
ories are usually restricted to definitional specifications, and the<br>
desired properties are<br>
being proven explicitly"</p>
<p>The fact that one actually can prove false by using "defs", which is<br>
commonly believed to be "definitional specification", is in strong<br>
contrast to this goal. So, any state in which <br>
  1) all of Isabelle and AFP still works<br>
  2) there are less possibilities to prove False in unexpected ways<br>
is arguably an improvement, as it conforms more to a primary design<br>
goal. Even if this improvement makes some aspects worse, one has to<br>
weigh up those disadvantages with the advantage of making the system<br>
more conforming to one of its primary design goals.</p>
<p>References:<br>
[1] Makarius Wenzel, Lawrence C. Paulson, Tobias Nipkow:<br>
  The Isabelle Framework. TPHOLs 2008: 33-38</p>
<p>[2] Ondrej Kuncar, Andrei Popescu:<br>
A Consistent Foundation for Isabelle/HOL. ITP 2015: 234-252</p>



<a name="294655107"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655107" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655107">(Aug 22 2022 at 11:28)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
On Mi, 2015-09-16 at 16:10 +0100, Larry Paulson wrote:</p>
<blockquote>
<p>I was under the impression that this patch had been adopted. I don’t believe that I saw any arguments against it.<br>
Larry</p>
</blockquote>
<p>If this should be true, we should make it as public as possible, to stop<br>
any rumours about Isabelle unsoundness. The best way would be to release<br>
Isabelle2015-1 immediately, even if it would only be (Isabelle2015 +<br>
patch), and not based on the current state of the repository.</p>



<a name="294655123"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655123" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655123">(Aug 22 2022 at 11:28)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:A.Popescu@mdx.ac.uk">A.Popescu@mdx.ac.uk</a>&gt;<br>
Dear All, </p>
<p>As far as I know, the integration of Ondra's solution patch is in Makarius's TODO list. Before doing the integration, Makarius wanted to see a mathematical justification for why our solution is sound. <br>
Now such a justification is provided in our ITP paper^[*], in conjunction with Ondra's CPP paper^[**]  -- it is not formal, but quite rigorous. So I see no major impediment to adopting our solution. Of course, it would be great if this were given a higher priority.  </p>
<p>Just for the record, please also note that inconsistencies are not so infrequent in proof assistants: some of the prominent cases of such "incidents" are collected in our ITP paper, under the heading "Inconsistency Club."</p>
<p>[*] <a href="http://www.eis.mdx.ac.uk/staffpages/andreipopescu/pdf/ITP2015.pdf">http://www.eis.mdx.ac.uk/staffpages/andreipopescu/pdf/ITP2015.pdf</a></p>
<p>[**] <a href="http://www4.in.tum.de/~kuncar/documents/kuncar-cpp2015.pdf">http://www4.in.tum.de/~kuncar/documents/kuncar-cpp2015.pdf</a> </p>
<p>All the best, <br>
   Andrei </p>
<hr>
<p>Please note that Middlesex University's preferred way of receiving all correspondence is via email in line with our Environmental Policy. All incoming post to Middlesex University is opened and scanned by our digital document handler, CDS, and then emailed to the recipient.</p>
<p>If you do not want your correspondence to Middlesex University processed in this way please email the recipient directly. Parcels, couriered items and recorded delivery items will not be opened or scanned by CDS.  There are items which are "exceptions" which will be opened by CDS but will not be scanned a full list of these can be obtained by contacting the University.</p>



<a name="294655135"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655135" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655135">(Aug 22 2022 at 11:28)</a>:</h4>
<p>From: Lars Noschinski &lt;<a href="mailto:noschinl@in.tum.de">noschinl@in.tum.de</a>&gt;<br>
As I understand it, there are/were two patches: One addressing a problem<br>
in the implementation of the cyclicity check and a second one adding<br>
dependencies on types as described in the ITP 2015 paper.</p>
<p>To my knowledge, only the first one has been adopted.</p>
<p>-- Lars</p>



<a name="294655143"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655143" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655143">(Aug 22 2022 at 11:28)</a>:</h4>
<p>From: Larry Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
I’d like to point out again that users need to take responsibility for their own definitions. I regularly see proofs that are valueless because they are based on incorrect definitions.  </p>
<p>To my mind, a soundness bug is when a valid expression or proof state is transformed into something wrong. The problem identified here are that Isabelle is failing to prohibit certain definitions that don’t make sense. There is no claim that Isabelle is doing anything wrong with these definitions. It’s hard to believe that a user could make such definitions accidentally.</p>
<p>It would be interesting to find out how these problems were identified: whether they were looked for out of curiosity, or whether on the other hand they manifested themselves in the course of an actual proof.</p>
<p>Larry Paulson</p>



<a name="294655156"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655156" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655156">(Aug 22 2022 at 11:28)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:a.popescu@mdx.ac.uk">a.popescu@mdx.ac.uk</a>&gt;<br>
Dear Larry, </p>
<p>You wrote: </p>
<blockquote>
<blockquote>
<p>I'd like to point out again that users need to take responsibility for their own definitions. I regularly see proofs that are valueless because they are based on incorrect definitions.  <br>
To my mind, a soundness bug is when a valid expression or proof state is transformed into something wrong. The problem identified here are that Isabelle is failing to prohibit certain definitions that don't <br>
make sense. There is no claim that Isabelle is doing anything wrong with these definitions. It's hard to believe that a user could make such definitions accidentally.</p>
</blockquote>
</blockquote>
<p>Your position here puzzles me now as much as it did the last time we talked about this. Let's forget about Isabelle/HOL for a second, and think of a logic L with axioms and deduction rules, but no definitions. <br>
Further, assume that L is known, or strongly believed to be consistent, in that it does not prove False. Now consider L_D, the logic L augmented with definitional mechanisms. This augmented logic should of course not prove False either! Writing meaningful definitions is the user's responsibility, but having the definitions consistent is the logic L_D's responsibility. Guaranteed consistency distinguishes definitions from arbitrary new axioms -- I learned this years ago from your papers and books.      </p>
<p>You wrote: </p>
<blockquote>
<blockquote>
<p>It would be interesting to find out how these problems were identified: whether they were looked for out of curiosity, or whether on the other hand they manifested themselves <br>
in the course of an actual proof.</p>
</blockquote>
</blockquote>
<p>Ondra discovered the typedef inconsistency, so he is the best person to answer this. </p>
<p>All the best, <br>
   Andrei </p>
<hr>
<p>Please note that Middlesex University's preferred way of receiving all correspondence is via email in line with our Environmental Policy. All incoming post to Middlesex University is opened and scanned by our digital document handler, CDS, and then emailed to the recipient.</p>
<p>If you do not want your correspondence to Middlesex University processed in this way please email the recipient directly. Parcels, couriered items and recorded delivery items will not be opened or scanned by CDS.  There are items which are "exceptions" which will be opened by CDS but will not be scanned a full list of these can be obtained by contacting the University.</p>



<a name="294655180"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655180" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655180">(Aug 22 2022 at 11:29)</a>:</h4>
<p>From: "\"Mark Adams\"" &lt;<a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a>&gt;<br>
I think there is an important distinction here between getting a definition<br>
wrong and making the logic inconsistent.  Of course a user can always<br>
accidentally make a wrong definition, and of course this is a big problem is<br>
usage of theorem provers, but this is a red herring.  Users rightly expect<br>
that it should not be possible for definitions to make the logic<br>
inconsistent.  This, surely, is one of the big selling points of using<br>
definitional facilities as opposed to just adding axioms - they are (or<br>
should be) fundamentally conservative.  And this is why it was so important<br>
to fix the bug in HOL's primitive constant definition facility in the late<br>
1980s, where type variables occurring in the RHS were allowed not to occur<br>
in the LHS.</p>
<p>Mark Adams.</p>
<p>on 16/9/15 5:25 PM, Larry Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt; wrote:</p>
<blockquote>
<p>I’d like to point out again that users need to take responsibility for<br>
their<br>
own definitions. I regularly see proofs that are valueless because they<br>
are<br>
based on incorrect definitions.</p>
<p>To my mind, a soundness bug is when a valid expression or proof state is<br>
transformed into something wrong. The problem identified here are that<br>
Isabelle is failing to prohibit certain definitions that don’t make sense.<br>
There is no claim that Isabelle is doing anything wrong with these<br>
definitions. It’s hard to believe that a user could make such definitions<br>
accidentally.</p>
<p>It would be interesting to find out how these problems were identified:<br>
whether they were looked for out of curiosity, or whether on the other<br>
hand<br>
they manifested themselves in the course of an actual proof.</p>
<p>Larry Paulson</p>
<p>On 16 Sep 2015, at 16:39, Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>On Mi, 2015-09-16 at 16:10 +0100, Larry Paulson wrote:</p>
<blockquote>
<p>I was under the impression that this patch had been adopted. I don’t<br>
believe that I saw any arguments against it.<br>
Larry</p>
</blockquote>
<p>If this should be true, we should make it as public as possible, to stop<br>
any rumours about Isabelle unsoundness. The best way would be to release<br>
Isabelle2015-1 immediately, even if it would only be (Isabelle2015 +<br>
patch), and not based on the current state of the repository.</p>
<p>--<br>
 Peter<br>
</p>
</blockquote>
</blockquote>



<a name="294655231"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655231" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655231">(Aug 22 2022 at 11:29)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
Let me add to this discussion, just because I happen to have been<br>
discussing it at Data61 yesterday too.</p>
<p>Yesterday, I showed my colleagues that it is possible to prove False in<br>
Isabelle2015 without any warnings or errors and without any use of<br>
axiomatization or oracles. The trick was, of course, Ondrej's example, but<br>
updated to use "overloading" rather than the deprecated "defs" keyword.<br>
Many of them were surprised, and wanted to know why, when I said that a<br>
patch did exist, it has not been incorporated. I think rumours about<br>
"Isabelle developers" are unavoidable at that point. We are also interested<br>
in the opinion of qualifiers and regulators of the tools we use, and<br>
Burkhart's original message is very interesting from that perspective.</p>
<p>My own opinion now: I would like the patch intended to make it impossible<br>
to prove False in Isabelle/HOL no matter what definitions one uses<br>
incorporated as soon as possible. I'm surprised that that is a contentious<br>
issue. I believe we have found the last of those problems now, because of<br>
Ondrej and Andrei's (on paper) consistency proof.</p>
<p>In the longer term, I am very interested in mechanising the consistency<br>
proof (as we have done for the basic HOL logic as used in HOL Light).<br>
Furthermore, if there is enough community interest, I would be interested<br>
in building a verified proof-checker for Isabelle/HOL. One crucial<br>
ingredient required from the Isabelle community here is the ability to<br>
export proofs in a low-level format (ideally OpenTheory, rather than some<br>
other new format), but I believe you're already quite close to that with<br>
the option to produce proof terms.</p>
<p>I think this story involving explicit proofs and small verified checkers is<br>
the ultimate one to sell to certification authorities, even while<br>
day-to-day we also want our big tools to be sound.</p>



<a name="294655235"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655235" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655235">(Aug 22 2022 at 11:29)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@inria.fr">jasmin.blanchette@inria.fr</a>&gt;<br>
Dear Larry, Andrei,</p>
<blockquote>
<p>Your position here puzzles me now as much as it did the last time we talked about this. Let's forget about Isabelle/HOL for a second, and think of a logic L with axioms and deduction rules, but no definitions. <br>
Further, assume that L is known, or strongly believed to be consistent, in that it does not prove False. Now consider L_D, the logic L augmented with definitional mechanisms. This augmented logic should of course not prove False either! Writing meaningful definitions is the user's responsibility, but having the definitions consistent is the logic L_D's responsibility. Guaranteed consistency distinguishes definitions from arbitrary new axioms -- I learned this years ago from your papers and books.</p>
</blockquote>
<p>I can only second this. After reading books like the Isabelle tutorial, which has Larry as a coauthor, I developed a certain understanding for what "definitional" and "foundational" means, and was for many years under the impression that there was a strong consensus in the proof assistant communities. In this context, I find Larry's comments rather puzzling. In fact, I agree with almost every single sentence he wrote, but</p>
<p>To my mind, a soundness bug is when a valid expression or proof state is transformed into something wrong.</p>
<p>violates the very notion of "definitional". At some point, we will have to make up our minds as to whether our definitions are definitions or just arbitrary axioms (and whether "typedef"s count as definition).</p>
<p>Mark's comments, which I just read, also neatly summarizes what I thought until recently was a consensus also shared by Larry.</p>
<p>Jasmin</p>



<a name="294655247"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655247" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655247">(Aug 22 2022 at 11:29)</a>:</h4>
<p>From: Holger Blasum &lt;<a href="mailto:hbl@sysgo.com">hbl@sysgo.com</a>&gt;<br>
Hello Larry, list,</p>
<p>I can give more detail for the case of EURO-MILS: We were made aware of <br>
"Isabelle Isar-Reference Manual (Version 2013-2, pp. 103): "It is at<br>
the discretion of the user to avoid malformed theory specifications!"[1]<br>
Hence first attempt was to rule out use of "consts"[2].<br>
This resulted in people even becoming more curious and playing <br>
with Kuncar/Popescu.<br>
Moreover, it has been pointed out that even if we rule out "consts" and "defs" in our theories then it is still used e.g. in HOL.thy[3] (probably without <br>
overloading, but it is hard to judge for me).</p>
<p>The task at hand is not only convincing ourselves (arguably when proving some <br>
property oneself one usually/sometimes gets a feeling for what is correct<br>
and what not) but also others (who have limited resources).</p>
<p>To give an example: in attached System_Is_Secure.thy the first <br>
derivation of "System_Is_Secure" (theorem System_Is_Secure_1) <br>
forces to make the assumptions of "A" and "~A" obvious. This makes <br>
it harder to cheat ourselves or others.</p>
<p>The second derivation of "System_Is_Secure" (theorem System_Is_Secure_2)<br>
hides the assumptions and could be more easy be overlooked.</p>
<p>My working understanding is (correct if that is wrong!) that fixing <br>
Isabelle would rule out hidden derivations such as System_Is_Secure_2.</p>
<p>[1] <a href="http://isabelle.in.tum.de/doc/isar-ref.pdf">http://isabelle.in.tum.de/doc/isar-ref.pdf</a> p 121 <br>
The (unchecked) option disables global dependency checks for this def-<br>
inition, which is occasionally useful for exotic overloading. It is at<br>
the discretion of the user to avoid malformed theory specifications!<br>
[2] <a href="http://www.euromils.eu/downloads/Deliverables/Y2/2015-EM-UsedFormalMethods-WhitePaper.pdf">http://www.euromils.eu/downloads/Deliverables/Y2/2015-EM-UsedFormalMethods-WhitePaper.pdf</a> Section 3.1 "Constants. The Isabelle consts command is not used."<br>
[3] <a href="http://afp.sourceforge.net/browser_info/current/HOL/HOL/HOL.html">http://afp.sourceforge.net/browser_info/current/HOL/HOL/HOL.html</a><br>
search for "defs"</p>
<p>---------(inlined: System_Is_Secure.thy, also attached)<br>
theory System_Is_Secure<br>
  imports Main<br>
  begin</p>
<p>consts A :: bool<br>
consts System_Is_Secure :: bool</p>
<p>(* formulation with explicit assumptions, easy for reviewer to spot that user made too strong assumptions *)<br>
theorem System_Is_Secure_1: <br>
  assumes "A" <br>
  and "~ A"  <br>
  shows System_Is_Secure<br>
proof-<br>
  from assms show ?thesis by simp<br>
qed</p>
<p>(* Kuncar/Popescu: A Consistent Foundation for Isabelle/HOL, ITP 2015 *)<br>
consts c :: bool<br>
typedef T = "{True, c}" by blast<br>
defs c_bool_def: "c::bool == ~ (ALL(x::T) y. x = y)"<br>
 lemma L: "(ALL(x::T) y. x = y) &lt;-&gt; c"<br>
using Rep_T Rep_T_inject Abs_T_inject by blast<br>
lemma MyFalse: False<br>
using L unfolding c_bool_def by auto</p>
<p>theorem MySystem_Is_Secure [simp]: System_Is_Secure<br>
using MyFalse by simp</p>
<p>(* formulation with implicit assumptions, not that easy for reviewer to spot that user made too strong assumptions *)<br>
theorem System_Is_Secure_2: System_Is_Secure by simp</p>
<p>end</p>
<p>best,</p>



<a name="294655259"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655259" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655259">(Aug 22 2022 at 11:29)</a>:</h4>
<p>From: Holger Blasum &lt;<a href="mailto:hbl@sysgo.com">hbl@sysgo.com</a>&gt;<br>
Same posting as parent, this time with attachment attached.<br>
<a href="/user_uploads/14278/TGqdSlkXSmxMgu5VxWO2He-N/System_Is_Secure.thy">System_Is_Secure.thy</a></p>



<a name="294655267"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655267" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655267">(Aug 22 2022 at 11:29)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
On 16/09/2015 17:48, Andrei Popescu wrote:</p>
<blockquote>
<p>Dear All,</p>
<p>As far as I know, the integration of Ondra's solution patch is in Makarius's TODO list. Before doing the integration, Makarius wanted to see a mathematical justification for why our solution is sound.<br>
Now such a justification is provided in our ITP paper^[*], in conjunction with Ondra's CPP paper^[**]  -- it is not formal, but quite rigorous. So I see no major impediment to adopting our solution.&gt;</p>
</blockquote>
<p>Let us hope you are right, although Makarius was dismissive of what you proved <br>
in earlier discussions and wanted a conservativity result.</p>
<p>Moreover, the check that Ondrej implemented is clearly necessary to ban these <br>
cicularities.</p>
<blockquote>
<p>Of course, it would be great if this were given a higher priority.</p>
</blockquote>
<p>That is the whole point. This is not a minor issue with fonts but concerns and <br>
endangers the very core of what we are doing.</p>
<p>Tobias</p>
<blockquote>
<p>Just for the record, please also note that inconsistencies are not so infrequent in proof assistants: some of the prominent cases of such "incidents" are collected in our ITP paper, under the heading "Inconsistency Club."</p>
<p>[*] <a href="http://www.eis.mdx.ac.uk/staffpages/andreipopescu/pdf/ITP2015.pdf">http://www.eis.mdx.ac.uk/staffpages/andreipopescu/pdf/ITP2015.pdf</a></p>
<p>[**] <a href="http://www4.in.tum.de/~kuncar/documents/kuncar-cpp2015.pdf">http://www4.in.tum.de/~kuncar/documents/kuncar-cpp2015.pdf</a></p>
<p>All the best,<br>
    Andrei</p>
<hr>
<p>Please note that Middlesex University's preferred way of receiving all correspondence is via email in line with our Environmental Policy. All incoming post to Middlesex University is opened and scanned by our digital document handler, CDS, and then emailed to the recipient.</p>
<p>If you do not want your correspondence to Middlesex University processed in this way please email the recipient directly. Parcels, couriered items and recorded delivery items will not be opened or scanned by CDS.  There are items which are "exceptions" which will be opened by CDS but will not be scanned a full list of these can be obtained by contacting the University.</p>
<p><a href="/user_uploads/14278/EU2LQZB1E-U78DWt_7-nAG86/smime.p7s">smime.p7s</a></p>
</blockquote>



<a name="294655294"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655294" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655294">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:tjark.weber@it.uu.se">tjark.weber@it.uu.se</a>&gt;<br>
Ramana,</p>
<p>Take a look at Stefan Berghofer's thesis. He already implemented a<br>
proof checker for his proof terms (albeit not verified).</p>
<p>The main issue, if I recall correctly, was that these proof terms could<br>
become huge.</p>
<p>Best,<br>
Tjark</p>



<a name="294655334"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655334" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655334">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
Thanks Tjark.</p>
<p>I am aware of Stefan's excellent work, and I'm sorry if I gave the<br>
impression that my proposal was novel in any sense. (Perhaps the part about<br>
verifying the checker is new, but that's just icing for the purposes of<br>
this discussion.)</p>
<p>My concern is whether the proof checker for proof terms is actually used or<br>
not. In an ideal world, I would think that for any substantial<br>
formalisation, the proof terms would be the bulk of the evidence provided<br>
to the certification authority or any other party interested to know why<br>
the claims being made are true, and those proof terms would be checked<br>
regularly (say twice a year) by a small checker if the formalisation is<br>
under continued development. Does anyone actually do that? Is scalability<br>
the only issue?</p>
<p>Apologies if this is veering too far from the original topic. I'm happy to<br>
continue discussion on another thread if desired.</p>



<a name="294655357"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655357" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655357">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
I feel like I should give a real example of what I think is consensus,<br>
and why the current state in Isabelle/HOL is not satisfactory:</p>
<p>If I manage to prove in Isabelle, e.g.,</p>
<p>theorem fermats_theorem: <br>
    "∀n::nat&gt;2. ¬(∃a::nat&gt;0. ∃b::nat&gt;0. ∃c::nat&gt;0. a^n + b^n = c^n)"</p>
<p>then, to believe that I really proved Fermat, one only has to check that<br>
the definitions of the natural number library really match the expected<br>
operations on naturals, and that my statement of the theorem really<br>
matches Fermat's theorem.</p>
<p>However, in current Isabelle, one has to check every single definition,<br>
even the unrelated ones, for consistency, to rule out, e.g., the<br>
following proof. Note that this proof, assuming Fermat really holds,<br>
does not even introduce inconsistency into the logic ... it's just a<br>
hidden axiomatization of Fermat:</p>
<p>(* Hide and obfuscate this stuff well, such that it is not too<br>
     easy to find for a human, but ensure that ATPs still find it<br>
  *)<br>
  definition "P ≡ <br>
      ∀n::nat&gt;2. ¬(∃a::nat&gt;0. ∃b::nat&gt;0. ∃c::nat&gt;0. a^n + b^n = c^n)"</p>
<p>consts c :: bool<br>
  typedef T = "{True,c}" by blast</p>
<p>lemma L: "(∀(x::T) y. x = y) ⟷ c"<br>
    using Rep_T Rep_T_inject Abs_T_inject by (cases c) force+</p>
<p>defs c_def: "c ≡ if (∀x::T. ∀y. x=y) then P else ¬P"</p>
<p>(* Place this main statement prominently in your theories, and hail<br>
    sledgehammer for being really powerful *)<br>
  theorem fermats_theorem: <br>
    "∀n::nat&gt;2. ¬(∃a::nat&gt;0. ∃b::nat&gt;0. ∃c::nat&gt;0. a^n + b^n = c^n)"<br>
    using L P_def c_def by presburger (* This proof was found by<br>
sledgehammer! *)</p>
<p>So, with sledgehammer becoming more powerful, and having the possibility<br>
of making inconsistent definitions, it's only a matter of time when<br>
sledgehammer finds some nice proof for you, which exploits, in some<br>
non-obvious ways, the inconsistency of completely unrelated definitions.</p>



<a name="294655375"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655375" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655375">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Larry Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Thanks for giving this example.</p>
<p>As people seem to have misunderstood my position, let me try again, because important points are being overlooked.</p>
<p>Of course I think that this circularity check ought to be made. I was under the impression that this patch had been made already. Nevertheless, I do not believe that it poses any immediate problem for users.</p>
<p>Over the whole of the 1990s, it was possible to introduce cyclic definitions in Isabelle, and this possibility was specifically mentioned in the documentation. To do this required making three separate steps: you had to introduce some A, then define some B in terms of A, and finally define A in terms of B. Anybody who thinks they are in danger of doing this accidentally really should be working in another field.  Certainly none of our existing users were affected when we tightened up our checks. Nobody had made this mistake.</p>
<p>The reason I keep stressing this point is that I regularly see work where the definitions don’t make any sense, even though they are noncircular. It is very easy to do. You verify some mechanism and you include some well-definedness predicate on states that can never be satisfied. Then you prove “WD(x) ==&gt; P(x)". Ph.D. supervisors and referees do to overlook such things, even when they are blatant. And then it is necessary to argue with the referees because “the proof has been checked by machine”.</p>
<p>I am sure that this type definition problem will be fixed in time for the next release. I’m not sure whether the other problem will be fixed.</p>
<p>Larry Paulson</p>



<a name="294655398"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655398" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655398">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
Dear Larry,</p>
<p>Thank you for the clarification. I agree that you are making an important<br>
point.</p>
<p>I’m not sure whether the other problem will be fixed.<br>
&gt;</p>
<p>One might be tempted to throw up hands and proclaim that the theorem prover<br>
cannot be expected to check that your definitions actually make sense; at<br>
best it can check that they are consistent. However, thinking about this<br>
problem just now, I realised that something similar to the existing<br>
AutoQuickcheck could be helpful: something that says "you seem to be trying<br>
to prove this the hard way, but it's actually very simple because your<br>
assumptions imply False!".</p>
<p>Ramana</p>



<a name="294655425"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655425" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655425">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
On 17/09/2015 13:56, Larry Paulson wrote:</p>
<blockquote>
<p>Thanks for giving this example.</p>
<p>As people seem to have misunderstood my position, let me try again, because important points are being overlooked.</p>
<p>Of course I think that this circularity check ought to be made. I was under the impression that this patch had been made already. Nevertheless, I do not believe that it poses any immediate problem for users.</p>
<p>Over the whole of the 1990s, it was possible to introduce cyclic definitions in Isabelle, and this possibility was specifically mentioned in the documentation. To do this required making three separate steps: you had to introduce some A, then define some B in terms of A, and finally define A in terms of B. Anybody who thinks they are in danger of doing this accidentally really should be working in another field.  Certainly none of our existing users were affected when we tightened up our checks. Nobody had made this mistake.</p>
<p>The reason I keep stressing this point is that I regularly see work where the definitions don’t make any sense, even though they are noncircular. It is very easy to do. You verify some mechanism and you include some well-definedness predicate on states that can never be satisfied. Then you prove “WD(x) ==&gt; P(x)". Ph.D. supervisors and referees do to overlook such things, even when they are blatant. And then it is necessary to argue with the referees because “the proof has been checked by machine”.</p>
</blockquote>
<p>In the model checking community this is known as the vacuity problem and it has <br>
received a certain amount of attention.</p>
<p>Tobias</p>
<blockquote>
<p>I am sure that this type definition problem will be fixed in time for the next release. I’m not sure whether the other problem will be fixed.</p>
<p>Larry Paulson</p>
<p>On 17 Sep 2015, at 07:14, Holger Blasum &lt;<a href="mailto:hbl@sysgo.com">hbl@sysgo.com</a>&gt; wrote:</p>
<blockquote>
<p>Hello Larry, list,<br>
</p>
</blockquote>
<p>On 09-16, Larry Paulson wrote:</p>
<blockquote>
<blockquote>
<p>It would be interesting to find out how these problems were identified: whether they were looked for out of curiosity, or whether on the other hand they manifested themselves in the course of an actual proof.</p>
</blockquote>
<p>I can give more detail for the case of EURO-MILS: We were made aware of<br>
"Isabelle Isar-Reference Manual (Version 2013-2, pp. 103): "It is at<br>
the discretion of the user to avoid malformed theory specifications!"[1]<br>
Hence first attempt was to rule out use of "consts"[2].<br>
This resulted in people even becoming more curious and playing<br>
with Kuncar/Popescu.</p>
</blockquote>
<p><a href="/user_uploads/14278/BvnhL6EMUPkMuk14NMgzMaqn/smime.p7s">smime.p7s</a></p>
</blockquote>



<a name="294655436"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655436" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655436">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Johannes Hölzl &lt;<a href="mailto:hoelzl@in.tum.de">hoelzl@in.tum.de</a>&gt;<br>
Am Donnerstag, den 17.09.2015, 12:56 +0100 schrieb Larry Paulson:<br>
[..]</p>
<blockquote>
<p>Over the whole of the 1990s, it was possible to introduce cyclic<br>
definitions in Isabelle, and this possibility was specifically<br>
mentioned in the documentation. To do this required making three<br>
separate steps: you had to introduce some A, then define some B in<br>
terms of A, and finally define A in terms of B. Anybody who thinks<br>
they are in danger of doing this accidentally really should be working<br>
in another field.  Certainly none of our existing users were affected<br>
when we tightened up our checks. Nobody had made this mistake.</p>
</blockquote>
<p>If such a circle happens in the _one_ theory file and is as obvious as<br>
this one, maybe the developer should be working in another field. But we<br>
get a bigger and bigger type class hierarchy and we started a couple of<br>
years ago to use type classes in type definitions. I work a lot with the<br>
type class hierarchy but some parts are still blurry to me. The last<br>
time Florian printed it out, it was a huge poster!</p>
<p>For large developments in Isabelle, one imports a lot of theories and<br>
uses a lot of automatic proof methods. What happens if my definitions<br>
are completely fine, but a freak combination of theories I import allows<br>
Sledgehammer to prove false?</p>
<ul>
<li>Johannes</li>
</ul>
<blockquote>
<p>The reason I keep stressing this point is that I regularly see work<br>
where the definitions don’t make any sense, even though they are<br>
noncircular. It is very easy to do. You verify some mechanism and you<br>
include some well-definedness predicate on states that can never be<br>
satisfied. Then you prove “WD(x) ==&gt; P(x)". Ph.D. supervisors and<br>
referees do to overlook such things, even when they are blatant. And<br>
then it is necessary to argue with the referees because “the proof has<br>
been checked by machine”.</p>
<p>I am sure that this type definition problem will be fixed in time for<br>
the next release. I’m not sure whether the other problem will be<br>
fixed.</p>
<p>Larry Paulson</p>
<p>On 17 Sep 2015, at 07:14, Holger Blasum &lt;<a href="mailto:hbl@sysgo.com">hbl@sysgo.com</a>&gt; wrote:</p>
<blockquote>
<p>Hello Larry, list,<br>
</p>
</blockquote>
<p>On 09-16, Larry Paulson wrote:</p>
<blockquote>
<blockquote>
<p>It would be interesting to find out how these problems were<br>
identified: whether they were looked for out of curiosity, or whether<br>
on the other hand they manifested themselves in the course of an<br>
actual proof.</p>
</blockquote>
<p>I can give more detail for the case of EURO-MILS: We were made aware<br>
of <br>
"Isabelle Isar-Reference Manual (Version 2013-2, pp. 103): "It is at<br>
the discretion of the user to avoid malformed theory<br>
specifications!"[1]<br>
Hence first attempt was to rule out use of "consts"[2].<br>
This resulted in people even becoming more curious and playing <br>
with Kuncar/Popescu.</p>
</blockquote>
</blockquote>



<a name="294655448"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655448" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655448">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Burkhart Wolff &lt;<a href="mailto:Burkhart.Wolff@lri.fr">Burkhart.Wolff@lri.fr</a>&gt;<br>
Dear Larry,</p>
<p>I respectfully disagree.<br>
It poses an immediate problem for users who have to argue in front of<br>
certification authorities why using Isabelle may guarantee absolute certainty<br>
(within a given frame of an underlying logic and model). And this might be an<br>
important business case for the entire community.</p>
<p>Why Isabelle, if I could also apply Bachblütentherapie to improve software quality ? </p>
<p>If a definition makes SENSE (that is, in my view, indeed users responsibility) is just <br>
another issue than that it makes an underlying theory inconsistent, which should<br>
be Isabelle’s responsibility if methodologically correctly used.</p>
<p>By the way, I support the proposal earlier made in this thread to have a<br>
“safe_use_flag” which restricts a session to constructs that we have reasons<br>
to believe that they are conservative.</p>
<p>Best</p>
<p>bu</p>



<a name="294655460"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655460" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655460">(Aug 22 2022 at 11:30)</a>:</h4>
<p>From: Larry Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Sledgehammer is also useful here, because generally you get to see exactly which facts have been used to prove the theorem. Sometimes you may see a fact being used there doesn’t appear to be relevant. It’s always worth checking to see what is going on.</p>
<p>Larry</p>



<a name="294655478"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655478" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655478">(Aug 22 2022 at 11:31)</a>:</h4>
<p>From: Lars Noschinski &lt;<a href="mailto:noschinl@in.tum.de">noschinl@in.tum.de</a>&gt;<br>
I am not aware of anyone doing that. As far as I can tell, we only ever<br>
build Main with proof terms, and even that breaks frequently (by hitting<br>
some resource limit).</p>
<p>-- Lars</p>



<a name="294655502"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655502" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655502">(Aug 22 2022 at 11:31)</a>:</h4>
<p>From: David Cock &lt;<a href="mailto:david.cock@inf.ethz.ch">david.cock@inf.ethz.ch</a>&gt;<br>
We tried it once on seL4.  We ran out of memory (192GB, from memory) <br>
<em>very</em> quickly.  It's currently impractical.  A streaming approach might <br>
be better i.e. have the proof checker run simultaneously with Isabelle, <br>
and check every step taken by the kernel as it's made, without ever <br>
having to actually construct the whole proof term.</p>
<p>David</p>



<a name="294655507"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655507" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655507">(Aug 22 2022 at 11:31)</a>:</h4>
<p>From: Larry Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Dear Burkhart,</p>
<p>I sympathise with you, but you go too far.</p>
<p>We do want tools such as Isabelle to be trusted by regulators and authorities. and so we do need to address every issue of this sort that comes along. Nevertheless, we should not be guaranteeing absolute certainty to anybody. If we oversell what is achievable, we risk a backlash.</p>
<p>It is true that it is now realistic to imagine fully verified proof checkers, the compilation to machine code also verified, running on a verified operating system and on verified hardware. Nevertheless, all of this involves using verification technology to verify itself. And there are innumerable other ways in which errors can creep in. Your “within a given model” is a huge qualification on "absolute certainty".</p>
<p>Avra Cohn’s 1989 essay on the subject remains topical:</p>
<p><a href="http://www.cl.cam.ac.uk/~mjcg/papers/AvraProofPaper.pdf">http://www.cl.cam.ac.uk/~mjcg/papers/AvraProofPaper.pdf</a><br>
<a href="http://link.springer.com/article/10.1007%2FBF00243000">http://link.springer.com/article/10.1007%2FBF00243000</a></p>
<p>There are any number of papers that report some of the gains that can be realised using verification tools, without making unrealistic promises.</p>
<p>Larry</p>



<a name="294655526"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294655526" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294655526">(Aug 22 2022 at 11:31)</a>:</h4>
<p>From: Burkhart Wolff &lt;<a href="mailto:Burkhart.Wolff@lri.fr">Burkhart.Wolff@lri.fr</a>&gt;<br>
Dear Larry,</p>
<p>I was talking here about </p>
<ul>
<li>(relative) consistency of the logic</li>
<li>and it's safe extension schemes.<br>
Short term goal: an agreement on the safe core (I e : kernel PLUS extension schemes) and on the methodological issues.</li>
</ul>
<p>Formal proofs for that are challenging, but nowadays perfectly feasible. </p>
<p>I was NOT talking about implementation correctness of Isabelle "as is", I am perfectly aware <br>
Of the quite monstrous proof task and the principle limits of such an approach (it's always going to be based on models ... Of the machine,<br>
The compiler, etc.)</p>
<p>Still, On the long run, relative<br>
Solutions along this line of research <br>
will and should come even for implementation correctness of Isabelle.</p>
<p>Bu</p>
<p>Von meinem iPhone gesendet</p>



<a name="294657237"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294657237" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294657237">(Aug 22 2022 at 11:42)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
This is an important point that is rarely explored systematically.  From <br>
my own experience in the past 10-15 years:</p>
<p>* "synthetic problems" of the first kind are encountered about 2 times<br>
     per year; typical changes are ff75ed08b3fb (2001) or ccbf9379e355<br>
     (2015)</p>
<p>* "practical problems", i.e. those encountered in actual applications<br>
     are encountered every 2-3 years</p>
<p>What happens all the time are misunderstandings by users about concrete <br>
syntax or concrete syntax that is actually wrong.  Nobody is worried about <br>
that as a custom.</p>
<p>Makarius</p>



<a name="294657245"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294657245" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294657245">(Aug 22 2022 at 11:42)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Here is the missing entry:</p>
<p><strong> HOL Zero </strong></p>
<p>Minimalistic re-implementation of HOL, designed with trustworthiness as <br>
its top priority.</p>
<p>[small]      +++<br>
   [ML]         ++<br>
   [thm]        +++<br>
   [defs]       +++<br>
   [context]    0<br>
   [logic]      ++<br>
   [formalized] 0</p>
<p>[ML] Unlike HOL-Light there are explicit provisions to avoid unsafe <br>
aspects of OCaml. Architectural weaknesses remain, since user ML scripts <br>
operate directly on the OCaml toplevel.</p>
<p>[small], [thm], [defs], [context], [logic] similar to HOL Light.</p>
<p>I.e. it is mostly like HOL Light, but [ML] gets ++ (like HOL4 with its SML <br>
basis), because extra care is taken to avoid weaknesses of OCaml.</p>
<p>A fully managed ML environment as in Isabelle would get +++.</p>
<p>Makarius</p>



<a name="294657255"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294657255" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294657255">(Aug 22 2022 at 11:42)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Indeed.  All of this mostly talks about the "logical core", whatever its <br>
internal structure is precisely.</p>
<p>Around the core there are many more aspects, where users can do non-sense, <br>
or the system could be wrong.</p>
<p>Makarius</p>



<a name="294657262"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294657262" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294657262">(Aug 22 2022 at 11:42)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
That is definitely interesting work.  I had some discussions about it with <br>
Ali Assaf in October 2013, IIRC.</p>
<p>What is also remarkable in the above paper: the "HOL family" only covers <br>
the actual HOL systems, while Isabelle/HOL falls into the category of <br>
"other systems" (like Coq, Nuprl).</p>
<p>Thus the HOL family proper is defined as the systems with full <br>
import/export wrt. OpenTheory.</p>
<p>Makarius</p>



<a name="294657274"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20Foundation%20%26%20Certification/near/294657274" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20Foundation.20.26.20Certification.html#294657274">(Aug 22 2022 at 11:42)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Interesting paper.  Here are some notes, after skimming through it.</p>
<ul>
<li>
<p>The term "LCF approach" is used in the tradition of HOL88 to include<br>
   definitional principles, but LCF (and Isabelle) did not have that from<br>
   the outset.  For papers that talk about trustworthyness of provers, the<br>
   distinction of [thm] vs. [theory] -- according to my earlier<br>
   categorization -- to avoid great confusion.</p>
</li>
<li>
<p>Concerning ML (SML or OCaml) as "system implementation language" and<br>
   weaknesses coming from exposing that to the user: LCF did not have this<br>
   problem, the LISP core was clearly separated from ML.  The HOL family<br>
   after HOL88 collapsed everything to one ML toplevel.  Isabelle is closer<br>
   to original LCF by running user-code in a managed Isabelle/ML<br>
   environment that is not the same as the underlying SML.</p>
</li>
<li>
<p>Isabelle does not have "proof scripts". The proper terminology is "proof<br>
   texts" or "proof documents". The point is that there is more structural<br>
   integrity enforced by the system, on some controlled language that is<br>
   not just the implementation language of the prover.</p>
</li>
<li>
<p>"Allow uncontrolled adaption to the way formulae are displayed": cf.<br>
   check/uncheck phases in Isabelle, which admit arbitrary non-sense on<br>
   input and output of terms, without any formal barriers.  These are<br>
   official programming interfaces, not back-doors.</p>
</li>
<li>
<p>3.2.1 interesting notes about HOL Light, including a special<br>
   (non-)treatment of typedefs as implicit pre-requisites to proven<br>
   theorems.  Such a formal record of dependencies (or "proof digest"  in<br>
   Isabelle terminology) was excluded from the discussion so far.  The<br>
   question is how "holes" in the reasoning are tracked (non-definitional<br>
   axioms, oracles).  I think that HOL4 is doing this most thoroughly.<br>
   Isabelle only half-thoroughly.</p>
</li>
</ul>
<p>I liked the general approach to port formalizations to other systems for <br>
independent checking.  I think the main weakness of the bigger systems <br>
(Coq, Isabelle) is that they have grown into large islands of their own, <br>
islands that could be mistaken as continents.  It would be exceedingly <br>
nice to see full OpenTheory connectivity for Isabelle/HOL, although the <br>
addition of overloaded type constructors to the standard portfolio has <br>
moved us one more step away from it.</p>
<p>Makarius</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>