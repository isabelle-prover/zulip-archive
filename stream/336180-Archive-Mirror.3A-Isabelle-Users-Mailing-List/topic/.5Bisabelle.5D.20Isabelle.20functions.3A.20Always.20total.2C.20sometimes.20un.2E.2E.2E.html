<html>
<head><meta charset="utf-8"><title>[isabelle] Isabelle functions: Always total, sometimes un... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html">[isabelle] Isabelle functions: Always total, sometimes un...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294721339"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721339" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721339">(Aug 22 2022 at 16:15)</a>:</h4>
<p>From: Joachim Breitner &lt;<a href="mailto:joachim@cis.upenn.edu">joachim@cis.upenn.edu</a>&gt;<br>
Hi,</p>
<p>based on repeated discussions and confusion when interacting with<br>
functional programmers and type-theory based theorem prover users, I<br>
wrote a blog post explaining how functions in Isabelle are different<br>
than functions in Haskell/Coq/etc, and what the deal is about<br>
undefined:</p>
<p><a href="http://www.joachim-breitner.de/blog/732">http://www.joachim-breitner.de/blog/732</a></p>
<p>Please let me know if I say something wrong that should not be said<br>
like that on the Internet. Otherwise, feel free to share when you have<br>
trouble explaining these things to someone.</p>
<p>Regards,<br>
Joachim<br>
<a href="/user_uploads/14278/4buKNY7XI1rJ7nzSqGJUchWc/signature.asc">signature.asc</a></p>



<a name="294721359"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721359" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721359">(Aug 22 2022 at 16:15)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:A.Popescu@mdx.ac.uk">A.Popescu@mdx.ac.uk</a>&gt;<br>
Hi Joachim,</p>
<p>Many people will probably agree with you when you declare</p>
<blockquote>
<blockquote>
<p>Isabelle functions do not compute (unlike, say, Coq functions)</p>
</blockquote>
</blockquote>
<p>However, I think stopping at this declaration means giving up too easily on what Isabelle/HOL (and HOL in general) have to offer w.r.t. certified programming.</p>
<p>True, you can get non-computable behavior for the specifications of functions. But rather than saying that you cannot program in HOL, I would rather say that</p>
<p>the traditional machinery developed in HOL-based provers includes a functional programming language, but currently does not (bother to) clearly single it out, as a subset</p>
<p>of what can be specified. (Of course, singling that out would mean committing to intensional, extra-logical aspects -- which is always necessary when connecting logic with programming -- likewise, the termination property of a function written in Coq  does not dwell in the Coq logic.)</p>
<p>To see my point, consider the same OCaml program in the following two scenarios:</p>
<p>1) generated from an Isabelle/HOL function</p>
<p>2) extracted from a Coq function</p>
<p>Say you prove something about the source functions in each of these provers. Is the fact proved in Coq more relevant for the OCaml program than that proved in Isabelle?</p>
<p>The answer is: No, provided some minimal precautions are taken about the specification and the code extraction setup. One can of course go into a discussion about the partial correctness restriction stemming from the additional flexibility of Isabelle/HOL's code generator (discussed by Haftmann and Nipkow), but this can be alleviated by removing that flexibility. Btw, for adequacy, both Coq and Isabelle would need to carefully consider that one reasons in a total logic about a program written in a "partial" environment, and rely on a form of "moral correctness" result (<a href="http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html">http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html</a>).</p>
<p>Andrei</p>



<a name="294721377"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721377" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721377">(Aug 22 2022 at 16:15)</a>:</h4>
<p>From: Joachim Breitner &lt;<a href="mailto:joachim@cis.upenn.edu">joachim@cis.upenn.edu</a>&gt;<br>
Hi,</p>
<p>Am Donnerstag, den 12.10.2017, 19:40 +0000 schrieb Andrei Popescu:</p>
<blockquote>
<p>Many people will probably agree with you when you declare</p>
<blockquote>
<blockquote>
<p>Isabelle functions do not compute (unlike, say, Coq functions)</p>
</blockquote>
</blockquote>
<p>However, I think stopping at this declaration means giving up too<br>
easily on what Isabelle/HOL (and HOL in general) have to offer w.r.t.<br>
certified programming.</p>
</blockquote>
<p>Good point. I should add  section</p>
<h3>You can still compute with Isabelle functions</h3>
<blockquote>
<p>Say you prove something about the source functions in each of these<br>
provers. Is the fact proved in Coq more relevant for the OCaml<br>
program than that proved in Isabelle?</p>
<p>The answer is: No, provided some minimal precautions are taken about<br>
the specification and the code extraction setup. One can of course go<br>
into a discussion about the partial correctness restriction stemming<br>
from the additional flexibility of Isabelle/HOL's code generator<br>
(discussed by Haftmann and Nipkow), but this can be alleviated by<br>
removing that flexibility.</p>
</blockquote>
<p>How can you achieve that?</p>
<p>Coq users stress the point that when you extract from Coq to Haskell,<br>
you know it terminates. And similarly, when you translate Haskell to<br>
Coq, and Coq accepts it, then this is in a way a termination proof of<br>
the Haskell code.</p>
<p>Can we say the same for Isabelle code extraction?</p>
<p>(I guess we can say the same for Haskabelle translation from Haskell to<br>
Coq, because <code>fun</code> requires well-founded recursion.)</p>
<p>Greetings,<br>
Joachim<br>
<a href="/user_uploads/14278/WhsXzZi4r0dmYcIzNJHleCPc/signature.asc">signature.asc</a></p>



<a name="294721392"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721392" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721392">(Aug 22 2022 at 16:15)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
I generally like it. Yes, HOL is first and foremost classical<br>
mathematics; the functional specifications give an appearance of<br>
functional programming, without restricting it to a computational<br>
world-view. The "programming" in HOL is good enough for most applications.</p>
<p>BTW, if you take the literal meaning of the word "undefined", it means<br>
"not defined". So it fits well into your story. People who think of<br>
"undefined" as "halt and catch fire" instruction are wrong :-)</p>
<p>Minor note: some ASCII =&gt; have sneaked in, but you appear to use Unicode<br>
rendering of Isabelle symbols uniformly.</p>
<p>Makarius<br>
<a href="/user_uploads/14278/JhJc5qkD6mNRwc4FU55zuLYi/signature.asc">signature.asc</a></p>



<a name="294721426"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721426" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721426">(Aug 22 2022 at 16:16)</a>:</h4>
<p>From: Andrei Popescu &lt;<a href="mailto:A.Popescu@mdx.ac.uk">A.Popescu@mdx.ac.uk</a>&gt;<br>
Hi Joachim,</p>
<p>See £££ below..</p>
<hr>
<p>From: <a href="mailto:cl-isabelle-users-bounces@lists.cam.ac.uk">cl-isabelle-users-bounces@lists.cam.ac.uk</a> &lt;<a href="mailto:cl-isabelle-users-bounces@lists.cam.ac.uk">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; on behalf of Joachim Breitner &lt;<a href="mailto:joachim@cis.upenn.edu">joachim@cis.upenn.edu</a>&gt;<br>
Sent: 12 October 2017 20:57<br>
To: <a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a><br>
Subject: Re: [isabelle] Isabelle functions: Always total, sometimes undefined</p>
<p>Hi,</p>
<p>Am Donnerstag, den 12.10.2017, 19:40 +0000 schrieb Andrei Popescu:</p>
<blockquote>
<p>Many people will probably agree with you when you declare</p>
<blockquote>
<blockquote>
<p>Isabelle functions do not compute (unlike, say, Coq functions)</p>
</blockquote>
</blockquote>
<p>However, I think stopping at this declaration means giving up too<br>
easily on what Isabelle/HOL (and HOL in general) have to offer w.r.t.<br>
certified programming.</p>
</blockquote>
<p>Good point. I should add  section</p>
<h3>You can still compute with Isabelle functions</h3>
<blockquote>
<p>Say you prove something about the source functions in each of these<br>
provers. Is the fact proved in Coq more relevant for the OCaml<br>
program than that proved in Isabelle?</p>
<p>The answer is: No, provided some minimal precautions are taken about<br>
the specification and the code extraction setup. One can of course go<br>
into a discussion about the partial correctness restriction stemming<br>
from the additional flexibility of Isabelle/HOL's code generator<br>
(discussed by Haftmann and Nipkow), but this can be alleviated by<br>
removing that flexibility.</p>
</blockquote>
<p>How can you achieve that?</p>
<p>£££ E.g., refraining from using that flexibility.  :- )</p>
<p>Coq users stress the point that when you extract from Coq to Haskell,<br>
you know it terminates. And similarly, when you translate Haskell to<br>
Coq, and Coq accepts it, then this is in a way a termination proof of<br>
the Haskell code.</p>
<p>Can we say the same for Isabelle code extraction?</p>
<p>(I guess we can say the same for Haskabelle translation from Haskell to<br>
Coq, because <code>fun</code> requires well-founded recursion.)</p>
<p>£££ We could achieve that, in principle, if we went through the trouble of automatically tracking executable specifications. In practice, I believe this is not such a big issue,: we can make sure this is the case by inspecting the definitions. Staying executable is easy -- the hard part is proving properties of the functions....</p>
<p>Andrei</p>
<p>-</p>



<a name="294721459"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721459" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721459">(Aug 22 2022 at 16:16)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Hi Joachim,</p>
<p>Just two pointers on this.</p>
<ol>
<li>
<p>CakeML has a linkup from HOL4 function definitions to their deeply embedded CakeML <br>
semantics. This linkup is used for code generation and ensures that the generated code <br>
terminates.</p>
</li>
<li>
<p>Lars Hupel has been working on a link from Isabelle/HOL functions to CakeML's <br>
semantics, using similar ideas. He is also able to generate CakeML code out of <br>
Isabelle/HOL function definitions. I'm not sure, though, whether he has also shown that <br>
all generated programs terminate. But the theory would definitely allow you to track that <br>
fairly easily. He has a draft paper on his homepage:</p>
</li>
</ol>
<p><a href="https://www21.in.tum.de/~hupel/pub/isabelle-cakeml.pdf">https://www21.in.tum.de/~hupel/pub/isabelle-cakeml.pdf</a></p>
<p>Andreas</p>



<a name="294721477"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721477" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721477">(Aug 22 2022 at 16:16)</a>:</h4>
<p>From: Lars Hupel &lt;<a href="mailto:hupel@in.tum.de">hupel@in.tum.de</a>&gt;<br>
I only show that all the functions that I compile terminate (a side<br>
effect of the dictionary construction), but I haven't show total<br>
correctness of the resulting CakeML program.</p>
<p>Cheers<br>
Lars</p>



<a name="294721494"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721494" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721494">(Aug 22 2022 at 16:16)</a>:</h4>
<p>From: Joachim Breitner &lt;<a href="mailto:joachim@cis.upenn.edu">joachim@cis.upenn.edu</a>&gt;<br>
Hi,</p>
<p>you have a deep embedding of the extracted code equations, right? So<br>
you could state termination, and (at least in theory) prove it in<br>
Isabelle, couldn’t you?</p>
<p>Joachim<br>
<a href="/user_uploads/14278/9d1Z7_aKgdv2vCZxp4l7s7yH/signature.asc">signature.asc</a></p>



<a name="294721518"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721518" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721518">(Aug 22 2022 at 16:16)</a>:</h4>
<p>From: Lars Hupel &lt;<a href="mailto:hupel@in.tum.de">hupel@in.tum.de</a>&gt;<br>
The initial semantics (plain HO term rewriting) has no notion of<br>
evaluation order or normal forms.</p>
<p>Instead one would need to define an alternative semantics that<br>
prescribes an evaluation order and prove its correctness wrt original<br>
semantics, or run my compiler to CakeML (which does precisely that).</p>
<p>Cheers<br>
Lars</p>



<a name="294721887"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721887" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721887">(Aug 22 2022 at 16:18)</a>:</h4>
<p>From: Florian Haftmann &lt;<a href="mailto:florian.haftmann@informatik.tu-muenchen.de">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>
Hi Joachim,</p>
<blockquote>
<p>based on repeated discussions and confusion when interacting with&gt; functional programmers and type-theory based theorem prover users, I&gt;<br>
wrote a blog post explaining how functions in Isabelle are different&gt;<br>
than functions in Haskell/Coq/etc, and what the deal is about&gt;<br>
undefined:&gt; &gt; <a href="http://www.joachim-breitner.de/blog/732">http://www.joachim-breitner.de/blog/732</a>&gt; &gt; Please let me<br>
know if I say something wrong that should not be said&gt; like that on the<br>
Internet. Otherwise, feel free to share when you have&gt; trouble<br>
explaining these things to someone.<br>
thanks for that blog post, which does indeed cover the essence of the<br>
relationship of Isabelle/HOL and functional programming.</p>
</blockquote>
<p>Let me add some remarks:</p>
<p>a) Terminology</p>
<p>You are mixing Isabelle and Isabelle/HOL quite freely.  IMHO it should<br>
read Isabelle/HOL throughout.</p>
<p>b) Section »Not all function specifications are ok«</p>
<p>Notation »S« stands beside »Suc«.  You might want to consolidate that.</p>
<p>c) Section »You can still compute with Isabelle functions«</p>
<p>You might want to add the key idea of the “moral reasoning” foundation:<br>
interpret HOL equations as a <em>shallow embedding</em> of corresponding programs.</p>
<p>The approach still has its advantages, e.g. you get datatype abstraction<br>
(almost) for free.</p>
<p>Lars' work goes beyond that by constructing a <em>deep embedding</em> of<br>
equations into HOL itself.</p>
<p>d) Section »Termination is a property of specifications, not functions«</p>
<p>Speaking about »termination« for function specifications is illusive,<br>
since the logic itself does not know about a concept called<br>
»termination«.  But you can utilize typical termination arguments (e.g.<br>
well-founded relations) to automate the derivation of equations from a<br>
primitive, abstract definition.</p>
<p>e) Why there is nothing but a quite loose characterization of the<br>
»executable« sublanguage of Isabelle/HOL.</p>
<p>It is the sheer complexity of the system itself: The sublanguage is not<br>
built into the logic, but appears by a elaborate stack of tools:</p>
<ul>
<li>
<p>Tools to introduce concepts known from FP in a suitable manner:<br>
datatype, function.</p>
</li>
<li>
<p>Tool to generate programs for sets of equations: code generator.</p>
</li>
</ul>
<p>Both layers are highly customizable. Of course you can do some kind of<br>
FP while you use, but you are always free to make it crumble down doing<br>
some – apparent according to common sense but difficult to characterize<br>
precisely – »nonsense«, e.g. non-terminating simp rules for the<br>
termination prover.</p>
<p>Cheers,<br>
    Florian<br>
<a href="/user_uploads/14278/UBukJ2TYCtLyyIy-fTG3zplX/signature.asc">signature.asc</a></p>



<a name="294721912"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Isabelle%20functions%3A%20Always%20total%2C%20sometimes%20un.../near/294721912" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Isabelle.20functions.3A.20Always.20total.2C.20sometimes.20un.2E.2E.2E.html#294721912">(Aug 22 2022 at 16:18)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Surely the point is that Coq (or rather its underlying calculus, and similar type theories) have an operational semantics. The semantics of higher-order logic is set-theoretic. Therefore higher-order logic has no definitive operational semantics at all. Rather we identify an executable sublanguage.</p>
<p>Larry Paulson</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>