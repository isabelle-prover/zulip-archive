<html>
<head><meta charset="utf-8"><title>[isabelle] Issues of Isabelle · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html">[isabelle] Issues of Isabelle</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294739706"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294739706" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294739706">(Aug 22 2022 at 17:58)</a>:</h4>
<p>From: Askar Safin via Cl-isabelle-users &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
Hello. I want to share my personal experience with Isabelle. I will list<br>
its issues and give some ideas, which can be implemented in Isabelle and<br>
other proof assistants. This letter is attempt to help you, I don't want to<br>
blame you.</p>
<p>The following issues are very annoying, they are simply distract me from<br>
using Isabelle, but unfortunately I simply don't see better alternative at<br>
the moment. All they must be considered when developing new proof<br>
assistants. Unfortunately it seems they cannot be fixed in Isabelle,<br>
because this would require its full rewriting. It will be very nice if some<br>
of this problems will be addressed in Larry Paulson's (CC'd) project<br>
Alexandria.</p>
<p>In 2015 I formalized in Isabelle part of our Moscow State University<br>
lectures on mathematical logic (using latest Isabelle at that moment).<br>
(Unfortunately resulting proof script doesn't fully work in Isabelle 2017.)<br>
This is lectures: <a href="http://lpcs.math.msu.su/vml2010/lectures1-8.pdf">http://lpcs.math.msu.su/vml2010/lectures1-8.pdf</a> and this<br>
is my formalization in Isabelle: <a href="http://paste.debian.net/hidden/eb960c2e">http://paste.debian.net/hidden/eb960c2e</a> (I<br>
will call it vml2010_fol.thy). I formalized section 3 which proves some<br>
theorems about FOL. Even if you don't know Russian, I think you will easily<br>
understand what is going in that Isabelle source. I will use this source as<br>
an example of Isabelle problems.</p>
<p>Issues:</p>
<ol>
<li>Lack of true partial functions.</li>
</ol>
<p>There is a lot of definitions at that section 3 which make sense only if<br>
some assumptions apply. For example, I have a datatype for FOL terms and a<br>
function "Tm", which returns "True" if a term is indeed valid. And lots of<br>
subsequent definitions assume that "Tm" is true. Unfortunately I don't have<br>
a way to specify this assumption in code, so I have to simply put it to a<br>
comment. Here is example:</p>
<p>(* assumes "Tm \&lt;Sigma&gt; t" *)<br>
primrec<br>
  Tm_vars      :: "[Var set, raw_Tm] \&lt;Rightarrow&gt; bool" and<br>
  Tm_list_vars :: "[Var set, raw_Tm list] \&lt;Rightarrow&gt; bool"<br>
where<br>
  "Tm_vars xs (Var x) \&lt;longleftrightarrow&gt; x \&lt;in&gt; xs"<br>
| "Tm_vars xs (Fapp f args) \&lt;longleftrightarrow&gt; Tm_list_vars xs args"<br>
| "Tm_list_vars xs [] \&lt;longleftrightarrow&gt; True"<br>
| "Tm_list_vars xs (t # ts) \&lt;longleftrightarrow&gt; Tm_vars xs t \&lt;and&gt;<br>
Tm_list_vars xs ts"</p>
<p>This was definition of "variables of this term" which makes sense only if<br>
the term is actually valid (technically the definition will work even if<br>
term is "wrong", but this is not important).</p>
<p>There are even more complex cases. For example:</p>
<p>(*<br>
assumes "model \&lt;Sigma&gt; M"<br>
assumes "image_in g xs (domain M)"<br>
assumes "Tm \&lt;Sigma&gt; t"<br>
assumes "Tm_vars xs t"<br>
*)<br>
primrec<br>
  Tm_value  :: "[raw_model, raw_Tm     ] \&lt;Rightarrow&gt; ((Var<br>
\&lt;Rightarrow&gt; ZF) \&lt;Rightarrow&gt; ZF     )" and<br>
  Tm_list_value :: "[raw_model, raw_Tm list] \&lt;Rightarrow&gt; ((Var<br>
\&lt;Rightarrow&gt; ZF) \&lt;Rightarrow&gt; ZF list)"<br>
where<br>
  "Tm_value _ (Var x) g = g x"<br>
| "Tm_value M (Fapp f args) g = Finterpret M f (Tm_list_value M args g)"<br>
| "Tm_list_value _ [] _ = []"<br>
| "Tm_list_value M (t # ts) g = Tm_value M t g # Tm_list_value M ts g"</p>
<p>This was definition of "value of term in this model". As you can see it<br>
assumes that:</p>
<ul>
<li>The model is actually the model of a given signature</li>
<li>Values of variables actually belong to model's domain</li>
<li>The term is valid</li>
<li>The term doesn't use variables not listed in "xs"</li>
</ul>
<p>When I write new definition I must be careful to write in comments all<br>
assumptions for definitions I use. When I write a lemma I must write all<br>
assumptions used by definitions. And it is possible that I will forget one<br>
and Isabelle will not tell me about this. You may say: "If Isabelle<br>
accepted your lemma, then it is true in its form, even if you forgot some<br>
assumption". Yes, but I want a lemma to convey information I meant. And I<br>
meant that proposition only if all assumptions apply, i. e. only if whole<br>
formula makes sense.</p>
<p>You may say "just use option". Well, yes, it is possible that this will<br>
make all assumptions explicit, and I will not be able to forget some<br>
assumption. But the code will become even larger and it will be even harder<br>
to read and write it.</p>
<p>And we still have 0 / 0 = 0. This proposition alone will distract any<br>
"working mathematician". Even computer algebra system Mathematica deal with<br>
division better. (Note that Alexandria announced computer algebra<br>
integration).</p>
<p>What I want is functions which take proof object as an argument. I. e.<br>
division should take as arguments "a", "b" and proof object of proposition<br>
"b ~= 0". You will say that the syntax will be impossible to read and<br>
write. No. Division will look the same, i. e. "a / b", A proof assistant<br>
will automatically search proof object for "b ~= 0" in the context and pass<br>
it to division function. I. e. we will write this: "a = 0 ==&gt; b ~= 0 ==&gt; a<br>
/ b = 0" and the proof assistant will transform this to: "a = 0 ==&gt; !!! p<br>
::: (b ~= 0). (divide a b p = 0)". Here this "!!!" construct is usual type<br>
theory Pi-term. Also we will be able to write something like this:</p>
<p>have "b ~= 0" by ...<br>
...<br>
have "a / b = c" by ... (* here the proof assistant found proof object for<br>
b ~= 0 in the context *)</p>
<p>Moreover, "a &amp;&amp;&amp; b" in Isabelle is "!! C. (A ==&gt; B ==&gt; C) ==&gt; C". So, proof<br>
object for A is available in B. So we can write, say, "b ~= 0 &amp;&amp;&amp; a / b =<br>
1". But not "a / b = 1 &amp;&amp;&amp; b ~= 0". You will say that we break commutation.<br>
But this matches actual mathematics practice. Suppose you have read in some<br>
mathematical article: "Let's assume that b is not 0 and a / b = 1". Now<br>
imagine "Let's assume that a / b = 1 and b is not 0". You see? The first<br>
variant is natural and the second is not. I think that proof-object-powered<br>
partial functions really match actual mathematics. We actually assume them<br>
when we talk about mathematics. Especially compared to 0 / 0 = 0.</p>
<p>True partial function will be especially useful in ZF. Nearly all functions<br>
will take proof objects. Say, sum for natural numbers will take proof that<br>
both arguments are actually natural numbers. Working in ZF may become easy<br>
like HOL. This proof objects will be something like alternative to HOL<br>
type-checking.</p>
<p>Of course, this is not complete solution. I don't know how to deal with<br>
meta-implication/object-implication distinction, with non-classical logics<br>
etc.</p>
<ol start="2">
<li>There is no proof method which works for all simple cases.</li>
</ol>
<p>When I write proof scripts, it is nearly impossible to figure which proof<br>
method (auto, blast etc) I should use and why. Usually I first try "auto",<br>
then "blast", then, say, "fastforce", then "metis" etc. This is very<br>
annoying. For example, see this example:<br>
<a href="https://en.wikipedia.org/wiki/Isabelle_(proof_assistant)">https://en.wikipedia.org/wiki/Isabelle_(proof_assistant)</a> . You see auto,<br>
fastforce, simp, rule, blast.</p>
<p>Often "auto" and "blast" doesn't work, but "rule" or "fact" or "." or ".."<br>
surprisingly does.</p>
<p>For example:</p>
<p>lemma Fm_vars_minus:<br>
  assumes "Fm_vars xs A"<br>
  shows "Fm_vars (xs - {x}) (any x A)" (is ?a)<br>
  and "Fm_vars (xs - {x}) (exists x A)" (is ?e)<br>
proof -<br>
  have "Fm_vars (xs \&lt;union&gt; {x}) A" using assms and Fm_vars_subset by<br>
blast<br>
  thus ?a and ?e by auto<br>
qed</p>
<p>The first step can be proved by "blast", but not "auto", the second - by<br>
"auto" and not by blast, and even not by "blast+".</p>
<p>Yes, I know that auto uses simplification rules, and blast does not. And<br>
thus I cannot put "blast" instead of "auto" in that example. But why we<br>
just don't have one method which combines power of blast and auto's<br>
simplification rules?</p>
<p>Also, consider this code:</p>
<p>notepad begin<br>
  have A and B sorry<br>
  hence A and B by auto<br>
end</p>
<p>"auto" works, but blast and metis do not. Yes, I know that I must put "+"<br>
after blast and metis. But why auto doesn't require such "+"? This is<br>
inconsistency.</p>
<p>Consider this:</p>
<p>notepad begin<br>
  have "A &amp;&amp;&amp; B" sorry<br>
  hence "A &amp;&amp;&amp; B" by auto<br>
end</p>
<p>Here I simply could not find working method. "auto+", "blast+", "metis+",<br>
"rule+", "fact+" - all they fail.</p>
<p>Consider this (from vml2010_fol.thy):</p>
<p>have "(THE x. x \&lt;in&gt; X \&lt;and&gt; f x = y) \&lt;in&gt; X \&lt;and&gt; f (THE x. x \&lt;in&gt;<br>
X \&lt;and&gt; f x = y) = y" using x_def and uqAdvInq by (rule theI)</p>
<p>Why I should write (rule theI) here? Why just "auto" doesn't work? Why<br>
"auto" doesn't know anything about theI? Why even "using theI by auto"<br>
doesn't work?</p>
<p>Consider this:</p>
<p>have "partial_bij_betw f X Y \&lt;Longrightarrow&gt; f x \&lt;in&gt; Y<br>
\&lt;Longrightarrow&gt; the_inv_into X f (f x) \&lt;in&gt; X" by (rule ff1yy)</p>
<p>Why I cannot write "using ff1yy by auto" here? "auto" is not powerful<br>
enough to replace "y" with "f x"? Why "using ff1yy by blast" doesn't work?<br>
"using ff1yy by metis" surprisingly works. But metis doesn't support<br>
simplification, and so will not work in similar situation where<br>
simplification will be also required.</p>
<p>Consider this:</p>
<p>also have "... \&lt;longleftrightarrow&gt; (\&lt;forall&gt; obj \&lt;in&gt; domain M'.<br>
calc M' A (\&lt;lambda&gt; y. if y = x then obj else (\&lt;phi&gt; \&lt;circ&gt; g) y))"<br>
using partial_bij_betw_any and bij .</p>
<p>Why auto and blast don't work, but "." does?! As well as I know "." is<br>
simple method, so why it works when more powerful methods such as auto and<br>
blast doesn't work?</p>
<p>Isabelle is too similar to programming. Hypothetical "working<br>
mathematician" will simply cry.</p>
<hr>
<p>Recently I found out Alexandria. I think you should take this project as<br>
opportunity to develop better proof assistant and possible rewrite<br>
everything. Instead of basing everything on top of Isabelle in its current<br>
form (0 / 0 = 0). I don't mean I want to participate in the project, I just<br>
gave some ideas. I hope you will use this opportunity to do something good.</p>
<p>Feel free to publish this letter or any parts of it anywhere, say, in some<br>
mathematical magazine.</p>
<p>==<br>
Askar Safin<br>
<a href="http://vk.com/safinaskar">http://vk.com/safinaskar</a></p>



<a name="294739769"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294739769" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294739769">(Aug 22 2022 at 17:58)</a>:</h4>
<p>From: José Manuel Rodriguez Caballero &lt;<a href="mailto:josephcmac@gmail.com">josephcmac@gmail.com</a>&gt;<br>
The beautiful formula 0 / 0 = 0 makes sense to a mathematician, although<br>
this was not the original motivation. I interprete it as the identification<br>
between 0 and infinity. Indeed, let G be the multiplicative group of<br>
non-zero real numbers. This is a Lie group with two connected components:<br>
the positive real numbers and the negative ones. Let H be the union of G<br>
with the zero. In H we take the topology from G and  we define the set of<br>
fundamental neighbourhoods of zero to be the set of real numbers either<br>
larger than n or smaller than 1/n.</p>
<p>Consider the function f(x) = 1/x if x is non-zero and f(0) = k. This<br>
function transform H into itself. It is easy to prove that f(x) is<br>
continuous in H if and only if k = 0. Notice that f(0) = 0 can be rewritten<br>
as 0/0 = 0 using a slight abuse of notation.</p>
<p>Jose M.</p>



<a name="294739785"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294739785" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294739785">(Aug 22 2022 at 17:58)</a>:</h4>
<p>From: José Manuel Rodriguez Caballero &lt;<a href="mailto:josephcmac@gmail.com">josephcmac@gmail.com</a>&gt;<br>
typographical correction (I forgot to multiply by 0 at the right)</p>
<p>0*f(0) = 0 can be rewritten as 0/0 = 0 using a slight abuse of notation.</p>
<p>Jose M.</p>
<p>2018-08-15 5:28 GMT-04:00 José Manuel Rodriguez Caballero &lt;<br>
<a href="mailto:josephcmac@gmail.com">josephcmac@gmail.com</a>&gt;:</p>



<a name="294739797"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294739797" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294739797">(Aug 22 2022 at 17:58)</a>:</h4>
<p>From: José Manuel Rodriguez Caballero &lt;<a href="mailto:josephcmac@gmail.com">josephcmac@gmail.com</a>&gt;<br>
another typographical correction<br>
in place of<br>
the set of real numbers either larger than n or smaller than 1/n.</p>
<p>read</p>
<p>set of real numbers which in absolute value are either larger than n or<br>
smaller than 1/n.</p>
<p>2018-08-15 5:33 GMT-04:00 José Manuel Rodriguez Caballero &lt;<br>
<a href="mailto:josephcmac@gmail.com">josephcmac@gmail.com</a>&gt;:</p>



<a name="294739824"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294739824" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294739824">(Aug 22 2022 at 17:58)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Dear Askar, thanks for your thoughtful message. It's always valuable to have feedback from new users.</p>
<ol>
<li>The question of partial functions has been around for a long time, and the following 20 year old survey is still worth reading: Treating Partiality in a Logic of Total Functions &lt;<a href="http://wwwbroy.in.tum.de/publ/papers/MS97.pdf">http://wwwbroy.in.tum.de/publ/papers/MS97.pdf</a>&gt; (Müller and Slind, 1996). I won't repeat the arguments here. I would merely mention that other approaches have been tried in other systems. PVS &lt;<a href="http://pvs.csl.sri.com/">http://pvs.csl.sri.com/</a>&gt; can support partial functions (by generating validity conditions), as did IMPS &lt;<a href="https://link.springer.com/article/10.1007/BF00881906">https://link.springer.com/article/10.1007/BF00881906</a>&gt; (using a calculus of definedness). As I understand it, type theory-based systems such as Coq &lt;<a href="https://coq.inria.fr/">https://coq.inria.fr/</a>&gt; also handle partial functions (using the implicit argument approach you outline, along with irrelevance of proofs). The penalty for using more complicated approaches is that proofs become longer and more difficult.</li>
</ol>
<p>It's a good bet that anybody using Isabelle or HOL is willing to live with a calculus of total functions only. As that survey article describes, we can formalise what we want to express well enough, without being forced to repeatedly prove that subexpressions are defined. You mention your wish to make assumptions explicit (e.g., that an FOL term is well-defined), even when those assumptions aren't needed to prove the given property. But one could equally say that the formalism itself is telling us which assumptions are needed and which are not. Your theory only regards an FOL term as well-defined if each function application has the required number of arguments, and yet the set of variables in a raw term is perfectly meaningful regardless of that.</p>
<p>Division is another excellent example. It's easy to imagine that postulating x/0 = 0 introduces inconsistency, but instead it reveals which identities are sensitive to division by zero and which are not. We discover that x/x=1 still requires the assumption that x is nonzero, while (u+v)/x = u/x + v/x does not. Most of us are happy to have as few assumptions as possible, as this makes proofs easier.</p>
<ol start="2">
<li>We'd certainly like to have a proof method that works for all simple cases, but it isn't easy. In theory, auto should do it, but as you note, it doesn't (and auto is unlikely to change very much). Work on better automation has been ongoing for decades now. Sledgehammer is one attempt at a magic bullet, but it's also defeated in some surprisingly easy cases. But a lot of new work is promising, e.g. Zhan's auto2 &lt;<a href="https://arxiv.org/abs/1707.04757">https://arxiv.org/abs/1707.04757</a>&gt; and some recent work by Nagashima, e.g. PSL &lt;<a href="https://arxiv.org/abs/1606.02941">https://arxiv.org/abs/1606.02941</a>&gt;. </li>
</ol>
<p>Mathematicians who use Isabelle today are pioneers, which means that some things will be painful, but on the other hand, they will be the first to make new discoveries.</p>
<p>Larry Paulson</p>



<a name="294739925"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294739925" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294739925">(Aug 22 2022 at 17:59)</a>:</h4>
<p>From: "Dr A. Koutsoukou-Argyraki" &lt;<a href="mailto:ak2110@cam.ac.uk">ak2110@cam.ac.uk</a>&gt;<br>
Dear Askar,</p>
<p>just a small practical tip (in case you don't use  this already)<br>
it saves plenty of time to use the keyword : "try0 "<br>
which tries several methods and tells you if one of them works,<br>
so the users don't need to try them all one by one themselves.</p>
<p>Also the keyword "try" does the above plus moreover runs sledgehammer <br>
and looks for counterexamples with quickcheck and nitpick,<br>
so you don't need to try all the proof methods separately one by one <br>
yourself.</p>
<p>Best wishes,<br>
Angeliki</p>



<a name="294740798"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294740798" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294740798">(Aug 22 2022 at 18:04)</a>:</h4>
<p>From: Askar Safin via Cl-isabelle-users &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
Lawrence, current approach with partial functions lacks any mathematical<br>
accuracy.</p>
<p>You said that "x / x = 1" requires assumption "x ~= 0", but "(u+v)/x = u/x</p>
<ul>
<li>v/x" does not. And you present this as feature. This is not a feature,<br>
this is absolutely strange behavior. What will "working mathematician" say<br>
about this? Let both theorems require "x ~= 0". This makes slightly harder<br>
to use this theorems, but this will make whole system more sound.</li>
</ul>
<p>Look at this:</p>
<p>(* Current behavior *)<br>
lemma l1: "(u+v)/x = u/x + v/x" sorry<br>
notepad begin<br>
assume "c ~= 0" (* Usually we work with assumption that denominator is non-zero anyway *)<br>
... (* Some steps *)<br>
have "(a+b)/c = a/c + b/c" using l1 by auto</p>
<p>(* With implicit proof object arguments *)<br>
lemma l1: assumes "x ~= 0" shows "(u+v)/x = u/x + v/x" sorry<br>
notepad begin<br>
assume a1: "c ~= 0"<br>
... (* Some steps *)<br>
have "(a+b)/c = a/c + b/c" using l1 and a1 by auto</p>
<p>As you can see the only thing that my proposal adds is "and a1". So, proofs<br>
become just slightly bigger, but a lot more sound. Moreover, if we mandate<br>
all assumptions, some proofs will become even shorter! For example, actual<br>
lemma inverse_inverse_eq "inverse (inverse a) = a" uses proof by cases "a =<br>
0", it will be simpler if we know that "a ~= 0".</p>
<p>Finally, I'm making another proposal. Let all proof methods (auto, blast<br>
etc) automatically extract from environment facts about well-definedness of<br>
its premises and goals. So, under this new proposal you will not need even<br>
write "and a1" like in example above. Moreover, you will not need to<br>
explicitly pass similar assumption even if you use lemma "x/x = 1", so<br>
proof will always become not bigger than currently. But in all cases you<br>
will need to have all assumptions available in context, of course.</p>
<p>Taking proof objects as arguments will allow us to make true "THE"<br>
construct and true Hilbert's choice operator. It will be possible to write<br>
"THE x. P x" only if we know that "?! x. P x" and similar condition for<br>
Hilbert's choice. Current THE and SOME are absolutely strange to "working<br>
mathematician".</p>
<p>I often see argument form some people that proof assistants should be as<br>
close to "real mathematics" as possible, because:</p>
<ol>
<li>This is why we create proof assistants</li>
<li>This is only way to get mathematicians to work with proof assistants</li>
</ol>
<p>Thus these people argue that proof assistants should be based on ZFC,<br>
because "real math" uses ZFC, that proof assistants should be classical,<br>
because "real math" is classical. I partially agree with such position. And<br>
in "real math" we have true partial functions (and 0/0=0 have nothing to do<br>
with "real math"). So, we need them [i. e. partial functions] here, in<br>
proof assistants.</p>
<p>But my arguments are not purely theoretical. See: first of all, with true<br>
partial functions you will never handle strange cases like division by zero<br>
(as opposed to current proof of inverse_inverse_eq). Second (and this is<br>
very important!), you will catch errors early. You will not be even state<br>
lemma if you didn't list all assumptions. Thus you will catch error when<br>
you state your lemma and not when you will unable to prove it after several<br>
hours.</p>
<p>My proposals can dramatically change proofs in ZF. Consider this:</p>
<p>(* Common part *)<br>
lemma add_nat: "a : nat ==&gt; b : nat ==&gt; a + b : nat" sorry (* Here I use "+" for raw_add from standard library *)<br>
lemma add_comm: "a : nat ==&gt; b : nat ==&gt; a + b = b + a" sorry<br>
lemma add_assoc: "a : nat ==&gt; b : nat ==&gt; c : nat ==&gt; (a + b) + c = a + (b + c)" sorry</p>
<p>(* Current behavior *)<br>
notepad begin<br>
assume a: "a : nat" and b: "b : nat" and c: "c : nat"<br>
hence "b + a : nat" using add_nat by auto<br>
have "(a + b) + c = (b + a) + c" using a and b and add_comm by auto<br>
also have "... = c + (b + a)" using ba and c and add_comm by auto<br>
also have "... = (c + b) + a" using a and b and c and add_assoc by auto<br>
finally have "a + b + c = c + b + a" .<br>
end</p>
<p>Now I'm making third proposal. Not only prover should extract<br>
well-definedness facts for terms from context, but also it should try to<br>
prove them.</p>
<p>(* If all 3 my proposals apply *)<br>
notepad begin<br>
assume "a : nat" and "b : nat" and "c : nat"<br>
have "(a + b) + c = (b + a) + c" using add_comm by auto<br>
also have "... = c + (b + a)" using add_comm by auto<br>
also have "... = (c + b) + a" using add_assoc by auto<br>
finally have "a + b + c = c + b + a" .<br>
end</p>
<p>As you can see, proof became considerably smaller and simpler. And now we<br>
don't need tricks like "natify" from standard lib. That "natify" version<br>
from standard library is nonsense (why add two non-numbers?) and doesn't<br>
early detect errors.</p>
<p>So, working with sets like "nat" will become as easy as working with types.<br>
And thus ZFC will became as easy to work with as HOL!!!</p>
<blockquote>
<p>Treating Partiality in a Logic of Total Functions (Müller and Slind, 1996)<br>
All methods proposed in this article are not satisfactory as opposed to<br>
true partial function. Because all they allow one to write term "0 / 0",<br>
and it will type-check.</p>
</blockquote>
<blockquote>
<p>It's a good bet that anybody using Isabelle or HOL is willing to live with a calculus of total functions only<br>
So, you mean that everybody wanting partiality already moved to other<br>
systems? Unfortunately, I cannot move to systems supporting partiality,<br>
because they lack some Isabelle features. I tried Coq, it allows<br>
constructing true partial functions. But its standard library has total<br>
division instead of partial one. And Coq has very strange type system as<br>
opposed to natural Isabelle's HOL. Coq's proofs are unreadable. I like<br>
Isabelle's foundations, logic framework, nice declarative proofs, IDE. I<br>
want something like Isabelle, but with partiality, but as well as I know<br>
there is no currently such system. And it would be very good if you will<br>
use Alexandria project to create such system.</p>
</blockquote>
<p>Freek Wiedijk [CC'd] in his slides "The next generation of proof<br>
assistants: ten questions" ( <a href="http://www.cs.ru.nl/~freek/talks/lsfa.pdf">http://www.cs.ru.nl/~freek/talks/lsfa.pdf</a> )<br>
gives the following Tobias Nipkow's (CC'd) quote: "Occasionally I do [hate<br>
the totality of the HOL logic]. But mostly not. The next generation of<br>
proof assistants will take it into account".</p>
<p>So, when this "next generation of proof assistants" will emerge?! How long<br>
should I wait for them?! Why not to create them right now?!!! Why not use<br>
Alexandria's money to create the future now?!!!</p>
<p>==<br>
Askar Safin<br>
<a href="http://vk.com/safinaskar">http://vk.com/safinaskar</a></p>



<a name="294740808"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294740808" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294740808">(Aug 22 2022 at 18:04)</a>:</h4>
<p>From: Lars Hupel &lt;<a href="mailto:hupel@in.tum.de">hupel@in.tum.de</a>&gt;</p>
<blockquote>
<p>You said that "x / x = 1" requires assumption "x ~= 0", but "(u+v)/x = u/x<br>
+ v/x" does not. And you present this as feature. This is not a feature,<br>
this is absolutely strange behavior. What will "working mathematician" say<br>
about this? Let both theorems require "x ~= 0". This makes slightly harder<br>
to use this theorems, but this will make whole system more sound.</p>
</blockquote>
<p>As Larry has already said, this has literally nothing to do with<br>
soundness. See also &lt;<a href="https://www.hillelwayne.com/post/divide-by-zero/">https://www.hillelwayne.com/post/divide-by-zero/</a>&gt;<br>
for a survey on this.</p>
<blockquote>
<p>So, when this "next generation of proof assistants" will emerge?! How long<br>
should I wait for them?! Why not to create them right now?!!!</p>
</blockquote>
<p>Nobody prevents you from working on a next-generation proof assistant.<br>
In fact, I think many people would be very excited about a proof of concept.</p>
<p>Cheers<br>
Lars</p>



<a name="294740824"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294740824" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294740824">(Aug 22 2022 at 18:04)</a>:</h4>
<p>From: Askar Safin via Cl-isabelle-users &lt;<a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>
I will repeat: main drawback of Isabelle's totality is need to manually<br>
keep track of assumptions, i. e. see my first letter, where I had to write<br>
all assumptions in comments without any help from Isabelle. This was main<br>
reason I gave up on developing this proof script more.</p>
<p>And the second drawback is that what I write doesn't correspond to what I<br>
mean. When I write "(x + y) / z = x / z + y / z" I mean "only if z ~= 0",<br>
but Isabelle doesn't require such assumption. So, I have to manually make<br>
sure that such assumption is always present in the context and thus what I<br>
write is actually correspond to what I mean.</p>
<p>So, current approach lacks some degree of automation.</p>
<p>And finally, I will say again that division is partial in actual<br>
mathematics. Actual proofs assume partial division, and proof assistants<br>
must do the same to be close to real math. I will repeat that phrase "Let's<br>
assume that b ~= 0 and a / b = 4" is OK for mathematical text, but "Let's<br>
assume that a / b = 4 and b ~= 0" is not, and thus the same should apply to<br>
proof assistants. It should be possible to directly convert any mathematical<br>
text to proof script.</p>
<p>==<br>
Askar Safin<br>
<a href="http://vk.com/safinaskar">http://vk.com/safinaskar</a></p>



<a name="294740841"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294740841" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294740841">(Aug 22 2022 at 18:04)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
On Do, 2018-08-23 at 18:35 +0300, Askar Safin via Cl-isabelle-users<br>
wrote:</p>
<blockquote>
<blockquote>
<p>As Larry has already said, this has literally nothing to do with<br>
soundness. See also &lt; <a href="https://www.hillelwayne.com/post/divide-by-ze">https://www.hillelwayne.com/post/divide-by-ze</a><br>
ro/ &gt;<br>
for a survey on this.<br>
I will repeat: main drawback of Isabelle's totality is need to<br>
manually<br>
keep track of assumptions, i. e. see my first letter, where I had to<br>
write<br>
all assumptions in comments without any help from Isabelle. This was<br>
main<br>
reason I gave up on developing this proof script more.</p>
</blockquote>
<p>And the second drawback is that what I write doesn't correspond to<br>
what I<br>
mean. When I write "(x + y) / z = x / z + y / z" I mean "only if z ~=<br>
0",<br>
but Isabelle doesn't require such assumption. So, I have to manually<br>
make<br>
sure that such assumption is always present in the context and thus<br>
what I<br>
write is actually correspond to what I mean.</p>
</blockquote>
<p>Another option would be to encode partiality explicitly, on top of HOL,<br>
e.g., by lifting everything into an option monad. Then, you could use<br>
Isabelle's standard reasoning tools to reason about definedness. I<br>
doubt that definedness is trivial enough to do it fully automatic,<br>
e.g., what is about "1/f(x)", with a very complicated f, that has a<br>
very complicated proof that !x. f(x) ~= 0.</p>
<p>However, current Isabelle lacks automation or syntax support for such<br>
an embedding, but maybe this might be a more feasible short-term<br>
solution than writing a new proof assistant from scratch.</p>
<blockquote>
<p>So, current approach lacks some degree of automation.</p>
<p>And finally, I will say again that division is partial in actual<br>
mathematics. Actual proofs assume partial division, and proof<br>
assistants<br>
must do the same to be close to real math. I will repeat that phrase<br>
"Let's<br>
assume that b ~= 0 and a / b = 4" is OK for mathematical text, but<br>
"Let's<br>
assume that a / b = 4 and b ~= 0" is not, and thus the same should<br>
apply to<br>
proof assistants. </p>
</blockquote>
<p>This imposes an execution order! But don't you also want to have <br>
"a&amp;b = b&amp;a", and substitution? then both terms must have the same<br>
meaning.</p>
<p>Of course, in the option monad, you could explicitly define a <br>
short-circuit version of "&amp;", which, however, would not be commutative.</p>



<a name="294741036"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294741036" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294741036">(Aug 22 2022 at 18:05)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 23/08/18 16:44, Askar Safin via Cl-isabelle-users wrote:</p>
<blockquote>
<p>lemma l1: assumes "x ~= 0" shows "(u+v)/x = u/x + v/x" sorry<br>
notepad begin<br>
assume a1: "c ~= 0"<br>
... (* Some steps *)<br>
have "(a+b)/c = a/c + b/c" using l1 and a1 by auto</p>
</blockquote>
<p>Just a side remark on proper naming of facts in Isabelle/Isar: if you<br>
need meaningless names, you can just use <em>, <strong>, </strong></em> or decimal numerals<br>
1, 2, 3, ...</p>
<p>There is no need to have a prefix like "l" for "lemma" or "a" for<br>
assumption above. In fact, it is bad style to decorate fact names<br>
according to there provenience, especially in  Isar proofs, where facts<br>
often change there origin between 'assume', 'obtain', 'case', 'have',<br>
'show', 'note' etc.</p>
<blockquote>
<p>have "(a+b)/c = a/c + b/c" using l1 and a1 by auto</p>
</blockquote>
<p>More stylistic notes: Isar goals can have before and after it. Before<br>
you have important things from the local proof context, after it<br>
relevant global things from the library. According to this rule of of<br>
thumb, the above becomes:</p>
<p>from a1 have "(a+b)/c = a/c + b/c" using l1 by auto</p>
<p>This discipline works more smoothly, if you always expand the old<br>
(obsolete) command abbreviations "hence" == "then have" and "thus" ==<br>
"then show" -- on average they make proof texts longer, and harder to write.</p>
<p>Makarius</p>



<a name="294741275"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294741275" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294741275">(Aug 22 2022 at 18:07)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Dear Askar,</p>
<p>The problem is that different mathematicians have quite different ideas of what a proof assistant should do. Some people want mathematics to be typed while other people firmly reject type systems. Some would like to see actual texts formalised, including syntactic elements such as parentheses. Some would like to be notified when the statement of a theorem includes assumptions not needed for the proof. You have the opposite wish: you'd like some definitions to be conditional on certain well-formedness assumptions, even when they aren't strictly necessary. It's not a common wish, but note that once you leave the world of definitions, you can include additional assumptions in theorems and they will be checked when you use the theorems.</p>
<p>An interesting observation about division is that when we put x/0 = 0, we do not change the meaning of definition where it is defined but merely extend its domain. Contrast this with the way division is implemented in computer hardware and in most computer languages: in OCaml I can type</p>
<h1>-4 mod 3;;</h1>
<p>val it : int = -1</p>
<p>and this violates an elementary property of division: that the remainder lies between 0 and the divisor. In other words, division on a computer (any computer) regularly delivers the wrong answer. Somehow people cope with this. Similarly people are able to cope with the formalisms of today's proof assistants, none of which are a perfect match to mathematical reasoning.</p>
<p>It may be that in the future, somebody will come up with a natural and practical formalisation of partial functions. Probably people are getting research funding for this sort of work. But I have funding for a different research programme.</p>
<p>Larry</p>



<a name="294741435"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Issues%20of%20Isabelle/near/294741435" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Issues.20of.20Isabelle.html#294741435">(Aug 22 2022 at 18:08)</a>:</h4>
<p>From: "Chun Tian (binghe)" &lt;<a href="mailto:binghe.lisp@gmail.com">binghe.lisp@gmail.com</a>&gt;<br>
Hi,</p>
<p>I want to point out a similar problem in Isabelle’s Extended_Real theory, in which the sum operator as a total function permits that ∞ + (-∞) = (∞::ereal), the case in which textbooks said it should be avoided (i.e. no definition):</p>
<p>function plus_ereal where<br>
  "ereal r + ereal p = ereal (r + p)"<br>
| "∞ + a = (∞::ereal)"<br>
| "a + ∞ = (∞::ereal)"<br>
| "ereal r + -∞ = - ∞"<br>
| "-∞ + ereal p = -(∞::ereal)"<br>
| "-∞ + -∞ = -(∞::ereal)"</p>
<p>HOL4’s extrealTheory [1] currently has the same problem, but its original authors have fixed the definition, and soon it [2] will be submit to HOL4 official.</p>
<p>What I observed is, having a total function here, many related theorems have simpler proofs and less assumptions, because otherwise lemmas like "a + b = b + a” is not true any more, if we don’t put extra assumptions that a and b are not mixing of ∞ and (-∞).  I found that, theorem prover doesn’t forbid its user to write down a term which has no definition, just with that term it is not possible to manipulate it with any theorem.</p>
<p>Is above definition of “plus_ereal” <em>wrong</em>?  I think so, but I don’t think everyone agrees with me.</p>
<p>—Chun</p>
<p>[1] <a href="https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml">https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml</a> &lt;<a href="https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml">https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml</a>&gt;<br>
[2] <a href="https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml">https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml</a> &lt;<a href="https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml">https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml</a>&gt;<br>
<a href="/user_uploads/14278/i3UauW-UbgQzMV3loWFdm0oF/signature.asc">signature.asc</a></p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>