<html>
<head><meta charset="utf-8"><title>[isabelle] New AFP entries: LTL Model Checker · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20New.20AFP.20entries.3A.20LTL.20Model.20Checker.html">[isabelle] New AFP entries: LTL Model Checker</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294276927"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20New%20AFP%20entries%3A%20LTL%20Model%20Checker/near/294276927" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20New.20AFP.20entries.3A.20LTL.20Model.20Checker.html#294276927">(Aug 19 2022 at 14:24)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Below you find 5 new entries, the components of an exceutable and reasonably<br>
efficient LTL Model Checker. The last entry combines them all. An early version<br>
was described in a CAV 2013 paper: <a href="http://www.in.tum.de/~nipkow/pubs/cav13.html">http://www.in.tum.de/~nipkow/pubs/cav13.html</a></p>
<hr>
<p>The CAVA Automata Library<br>
Peter Lammich</p>
<p>We report on the graph and automata library that is used in the fully verified<br>
LTL model checker CAVA. As most components of CAVA use some type of graphs or<br>
automata, a common automata library simplifies assembly of the components and<br>
reduces redundancy.</p>
<p>The CAVA Automata Library provides a hierarchy of graph and automata classes,<br>
together with some standard algorithms. Its object oriented design allows for<br>
sharing of algorithms, theorems, and implementations between its classes, and<br>
also simplifies extensions of the library. Moreover, it is integrated into the<br>
Automatic Refinement Framework, supporting automatic refinement of the abstract<br>
automata types to efficient data structures.</p>
<p>Note that the CAVA Automata Library is work in progress. Currently, it is very<br>
specifically tailored towards the requirements of the CAVA model checker.<br>
Nevertheless, the formalization techniques presented here allow an extension of<br>
the library to a wider scope. Moreover, they are not limited to graph libraries,<br>
but apply to class hierarchies in general.</p>
<p>The CAVA Automata Library is described in the paper: Peter Lammich, The CAVA<br>
Automata Library, Isabelle Workshop 2014, to appear.</p>
<p><a href="http://afp.sourceforge.net/entries/CAVA_Automata.shtml">http://afp.sourceforge.net/entries/CAVA_Automata.shtml</a></p>
<hr>
<p>Converting Linear-Time Temporal Logic to Generalized Büchi Automata<br>
Alexander Schimpf and Peter Lammich</p>
<p>We formalize linear-time temporal logic (LTL) and the algorithm by Gerth et al.<br>
to convert LTL formulas to generalized Büchi automata. We also formalize some<br>
syntactic rewrite rules that can be applied to optimize the LTL formula before<br>
conversion. Moreover, we integrate the Stuttering Equivalence AFP-Entry by<br>
Stefan Merz, adapting the lemma that next-free LTL formula cannot distinguish<br>
between stuttering equivalent runs to our setting.</p>
<p>We use the Isabelle Refinement and Collection framework, as well as the Autoref<br>
tool, to obtain a refined version of our algorithm, from which efficiently<br>
executable code can be extracted.</p>
<p><a href="http://afp.sourceforge.net/entries/LTL_to_GBA.shtml">http://afp.sourceforge.net/entries/LTL_to_GBA.shtml</a></p>
<hr>
<p>Verified Efficient Implementation of Gabow's Strongly Connected Components Algorithm<br>
Peter Lammich</p>
<p>We present an Isabelle/HOL formalization of Gabow's algorithm for finding the<br>
strongly connected components of a directed graph. Using data refinement<br>
techniques, we extract efficient code that performs comparable to a reference<br>
implementation in Java. Our style of formalization allows for re-using large<br>
parts of the proofs when defining variants of the algorithm. We demonstrate this<br>
by verifying an algorithm for the emptiness check of generalized Büchi<br>
automata, re-using most of the existing proofs.</p>
<p><a href="http://afp.sourceforge.net/entries/Gabow_SCC.shtml">http://afp.sourceforge.net/entries/Gabow_SCC.shtml</a></p>
<hr>
<p>Promela Formalization<br>
René Neumann</p>
<p>We present an executable formalization of the language Promela, the description<br>
language for models of the model checker SPIN. This formalization is part of the<br>
work for a completely verified model checker (CAVA), but also serves as a useful<br>
(and executable!) description of the semantics of the language itself, something<br>
that is currently missing. The formalization uses three steps: It takes an<br>
abstract syntax tree generated from an SML parser, removes syntactic sugar and<br>
enriches it with type information. This further gets translated into a<br>
transition system, on which the semantic engine (read: successor function) operates.</p>
<p><a href="http://afp.sourceforge.net/entries/Promela.shtml">http://afp.sourceforge.net/entries/Promela.shtml</a></p>
<hr>
<p>A Fully Verified Executable LTL Model Checker<br>
Javier Esparza, Peter Lammich, René Neumann, Tobias Nipkow, Alexander Schimpf,<br>
Jan-Georg Smaus</p>
<p>We present an LTL model checker whose code has been completely verified using<br>
the Isabelle theorem prover. The checker consists of over 4000 lines of ML code.<br>
The code is produced using the Isabelle Refinement Framework, which allows us to<br>
split its correctness proof into (1) the proof of an abstract version of the<br>
checker, consisting of a few hundred lines of ``formalized pseudocode'', and (2)<br>
a verified refinement step in which mathematical sets and other abstract<br>
structures are replaced by implementations of efficient structures like<br>
red-black trees and functional arrays. This leads to a checker that, while still<br>
slower than unverified checkers, can already be used as a trusted reference<br>
implementation against which advanced implementations can be tested.</p>
<p><a href="http://afp.sourceforge.net/entries/CAVA_LTL_Modelchecker.shtml">http://afp.sourceforge.net/entries/CAVA_LTL_Modelchecker.shtml</a></p>
<hr>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>