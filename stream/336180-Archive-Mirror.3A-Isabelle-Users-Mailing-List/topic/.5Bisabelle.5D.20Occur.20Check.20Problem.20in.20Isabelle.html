<html>
<head><meta charset="utf-8"><title>[isabelle] Occur Check Problem in Isabelle · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Occur.20Check.20Problem.20in.20Isabelle.html">[isabelle] Occur Check Problem in Isabelle</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294139223"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Occur%20Check%20Problem%20in%20Isabelle/near/294139223" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Occur.20Check.20Problem.20in.20Isabelle.html#294139223">(Aug 18 2022 at 17:54)</a>:</h4>
<p>From: Jasmin Blanchette &lt;<a href="mailto:jasmin.blanchette@gmail.com">jasmin.blanchette@gmail.com</a>&gt;<br>
Hi Anja,</p>
<blockquote>
<p>I can not prove the lemma, however. <br>
Can you tell me how I should do in the proof of the <br>
lemma continues to Isabelle runs through here?</p>
</blockquote>
<ol>
<li>
<p>For the benefit of the readers who did not follow the thread on isabelle-dev, it would help if you could provide some context and explan what you want to achieve. People here are unlikely to finish your proofs for you, but they will gladly help with conceptual roadblocks.</p>
</li>
<li>
<p>The formatting of your code got lost at some point. It now looks like this:</p>
</li>
</ol>
<blockquote>
<p>datatype 'a trm =             Var 'a           | Fn 'a "('a <br>
trm) list"        <br>
       types          'a subst = "('a \&lt;times&gt; 'a trm) list"        <br>
       text {* Applying a substitution to a variable: *}        fun assoc <br>
:: "'a \&lt;Rightarrow&gt; 'b \&lt;Rightarrow&gt; ('a \&lt;times&gt; 'b) list \&lt;Rightarrow&gt; <br>
'b"        where          "assoc x d [] = d"        | "assoc x d ((p,q)#t) <br>
= (if x = p then q else assoc x d t)"        <br>
       text {* Applying a substitution to a term: *}        primrec </p>
</blockquote>
<p>With code like this, you're unlikely to get a helpful answer.</p>
<ol start="3">
<li>My general advice for learning Isabelle, which I've shared with your supervisor in an informal discussion earlier tonight (and he seemed not to disagree, but that could have been the wine), would be to tackle an easier problem than unification first and gain some experience and confidence doing that. Some people have observed that there's no learning curve when learning an interactive theorem prover, but rather a "series of steep cliffs". If the cliffs are steep, you can compensate by taking smaller strides.</li>
</ol>
<p>I hope this helps.</p>
<p>Regards,</p>
<p>Jasmin</p>



<a name="294139251"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Occur%20Check%20Problem%20in%20Isabelle/near/294139251" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Occur.20Check.20Problem.20in.20Isabelle.html#294139251">(Aug 18 2022 at 17:54)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
On 07/20/2011 11:41 PM, Jasmin Blanchette wrote:</p>
<blockquote>
<ol>
<li>For the benefit of the readers who did not follow the thread on<br>
isabelle-dev, it would help if you could provide some context and<br>
explan what you want to achieve.<br>
[...]</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>The formatting of your code got lost at some point.<br>
[...]</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>My general advice for learning Isabelle, which I've shared with<br>
your supervisor in an informal discussion earlier tonight (and he<br>
seemed not to disagree, but that could have been the wine), would be<br>
to tackle an easier problem than unification first and gain some<br>
experience and confidence doing that.</li>
</ol>
</blockquote>
<p>Let me add:</p>
<ol start="4">
<li>Please do not attempt to send your questions/followups off-list to <br>
individuals who responded previously. Instead, keep the mailing list on <br>
Cc. Keeping the discussion public is important, since</li>
</ol>
<p>a) it ensures that others can learn from your problems/solutions,<br>
b) it distributes the question answering workload over community members,<br>
c) if questions are public (and permanently archived) they are often <br>
better thought-out, and<br>
d) it allows the assessment of how much of the work is actually your <br>
own, which is important if the work is part of coursework or a thesis.</p>
<p>Alex</p>



<a name="294139436"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Occur%20Check%20Problem%20in%20Isabelle/near/294139436" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Occur.20Check.20Problem.20in.20Isabelle.html#294139436">(Aug 18 2022 at 17:55)</a>:</h4>
<p>From: René Thiemann &lt;<a href="mailto:rene.thiemann@uibk.ac.at">rene.thiemann@uibk.ac.at</a>&gt;<br>
Dear Anja,</p>
<p>you might also have a look at IsaFoR at <br>
<a href="http://cl-informatik.uibk.ac.at/software/ceta/">http://cl-informatik.uibk.ac.at/software/ceta/</a></p>
<p>It contains several formalizations about terms and term rewriting, including a fully formalized unification algorithm for first order terms (theory Substitution.thy).</p>
<p>Cheers,<br>
René</p>



<a name="294141964"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Occur%20Check%20Problem%20in%20Isabelle/near/294141964" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Occur.20Check.20Problem.20in.20Isabelle.html#294141964">(Aug 18 2022 at 18:09)</a>:</h4>
<p>From: Anja Gerbes &lt;<a href="mailto:agerb@gmx.de">agerb@gmx.de</a>&gt;<br>
Good evening,</p>
<p>I can not prove the lemma, however. <br>
Can you tell me how I should do in the proof of the <br>
lemma continues to Isabelle runs through here?</p>
<p>Thank you in advance</p>
<p>Anja Gerbes        </p>
<p>datatype 'a trm =             Var 'a           | Fn 'a "('a <br>
trm) list"        <br>
        types          'a subst = "('a \&lt;times&gt; 'a trm) list"        <br>
        text {* Applying a substitution to a variable: *}        fun assoc <br>
:: "'a \&lt;Rightarrow&gt; 'b \&lt;Rightarrow&gt; ('a \&lt;times&gt; 'b) list \&lt;Rightarrow&gt; <br>
'b"        where          "assoc x d [] = d"        | "assoc x d ((p,q)#t) <br>
= (if x = p then q else assoc x d t)"        <br>
        text {* Applying a substitution to a term: *}        primrec <br>
apply_subst_list :: "('a trm) list \&lt;Rightarrow&gt; 'a subst \&lt;Rightarrow&gt; ('a <br>
trm) list"  and                apply_subst :: "'a trm \&lt;Rightarrow&gt; 'a <br>
subst  \&lt;Rightarrow&gt; 'a trm" (infixl "\&lt;triangleleft&gt;" 60) where          <br>
"apply_subst_list [] s = []"        | "apply_subst_list (x#xs) s = <br>
(apply_subst x s)#(apply_subst_list xs s)"        | "(Var v) <br>
\&lt;triangleleft&gt; s = assoc v (Var v) s"        | "(Fn f xs) \&lt;triangleleft&gt; <br>
s = (Fn f (apply_subst_list xs s))"        <br>
        text {* Composition of substitutions: *}        fun compose :: "'a <br>
subst \&lt;Rightarrow&gt; 'a subst \&lt;Rightarrow&gt; 'a subst" (infixl "\&lt;bullet&gt;" <br>
80)        where          " [] \&lt;bullet&gt; bl = bl"        | "((a,b) # al) <br>
\&lt;bullet&gt; bl = (a, b \&lt;triangleleft&gt; bl) # (al \&lt;bullet&gt; bl)"        <br>
        text {* Equivalence of substitutions: *}        definition eqv <br>
(infix "=\&lt;^sub&gt;s" 50)        where          "s1 =\&lt;^sub&gt;s s2 \&lt;equiv&gt; <br>
\&lt;forall&gt;t. t \&lt;triangleleft&gt; s1 = t \&lt;triangleleft&gt; s2"           <br>
        text {* Occurs Check: *}        <br>
        fun eq :: "'a trm \&lt;Rightarrow&gt; 'a trm \&lt;Rightarrow&gt; bool"        <br>
where         "eq x y = (if x = y then True else False)"        <br>
        primrec occ :: "'a trm \&lt;Rightarrow&gt; 'a trm \&lt;Rightarrow&gt; bool" and <br>
               occ_list :: "'a trm \&lt;Rightarrow&gt; 'a trm list <br>
\&lt;Rightarrow&gt; bool" where          "occ u (Var v)     = False"        | <br>
"occ u (Fn f xs)   = (if (list_ex (eq u) xs) then True else (occ_list u <br>
xs))"        | "occ_list u []     = False"        | "occ_list u (x#xs) = <br>
(if occ u x then True else occ_list u xs)"        <br>
        text {* Listenverarbeitung und Unifikationalgorithmus: *}        <br>
fun  unify :: "'a trm \&lt;Rightarrow&gt; 'a trm \&lt;Rightarrow&gt; 'a subst option" <br>
and             unify_list :: "'a trm list \&lt;Rightarrow&gt; 'a trm list <br>
\&lt;Rightarrow&gt; 'a subst option" where          "unify u (Var v) = (if (occ <br>
(Var v) u)                                   then None        <br>
                          else Some [(v, u)])"        | "unify <br>
(Var v) u = (if (occ (Var v) u)                               <br>
    then None                                  else Some <br>
[(v, u)])"        | "unify (Fn f xs) (Fn g ys) = (if (f \&lt;noteq&gt; g) then <br>
None else unify_list xs ys)"          | "unify_list [] [] = Some[]"        <br>
| "unify_list (x#xs) (y#ys) = (case unify x y of                     <br>
                       None \&lt;Rightarrow&gt; None             <br>
                             | Some subst \&lt;Rightarrow&gt; case <br>
unify_list xs ys of                                        <br>
                     None \&lt;Rightarrow&gt; None                <br>
                                           | Some <br>
subst' \&lt;Rightarrow&gt; Some (subst \&lt;bullet&gt; subst'))"        | "unify_list _ 
_ = None"                 subsection {* Specification: Most general <br>
unifiers *}        <br>
        definition          "Unifier \&lt;sigma&gt; t u \&lt;equiv&gt; <br>
(t\&lt;triangleleft&gt;\&lt;sigma&gt; = u\&lt;triangleleft&gt;\&lt;sigma&gt;)"        <br>
        definition          "MGU \&lt;sigma&gt; t u  \&lt;equiv&gt; Unifier \&lt;sigma&gt; t <br>
u \&lt;and&gt;  (\&lt;forall&gt;\&lt;theta&gt;. Unifier \&lt;theta&gt; t u            <br>
\&lt;longrightarrow&gt; (\&lt;exists&gt;\&lt;gamma&gt;. \&lt;theta&gt;  =\&lt;^sub&gt;s \&lt;sigma&gt; <br>
\&lt;bullet&gt; \&lt;gamma&gt;))"        <br>
        lemma MGUI[intro]:          "\&lt;lbrakk&gt;t  \&lt;triangleleft&gt; \&lt;sigma&gt; <br>
= u \&lt;triangleleft&gt;  \&lt;sigma&gt;; \&lt;And&gt;\&lt;theta&gt;. t \&lt;triangleleft&gt;  \&lt;theta&gt; <br>
= u \&lt;triangleleft&gt; \&lt;theta&gt;  \&lt;Longrightarrow&gt; \&lt;exists&gt;\&lt;gamma&gt;. \&lt;theta&gt; <br>
 =\&lt;^sub&gt;s \&lt;sigma&gt; \&lt;bullet&gt;  \&lt;gamma&gt;\&lt;rbrakk&gt;          <br>
\&lt;Longrightarrow&gt; MGU \&lt;sigma&gt; t u"          by (simp only:Unifier_def <br>
MGU_def, auto)        <br>
        lemma MGU_sym[sym]:          "MGU \&lt;sigma&gt; s t \&lt;Longrightarrow&gt; <br>
MGU \&lt;sigma&gt; t s"          by (auto simp:MGU_def Unifier_def)        <br>
        subsection {* Basic lemmas *}        <br>
        lemma apply_empty[simp]: "t \&lt;triangleleft&gt; [] = t"        apply <br>
(induct t)        apply (simp)        apply (simp)        apply (simp)      <br>
  apply (simp)        done         <br>
        lemma compose_empty[simp]: "\&lt;sigma&gt; \&lt;bullet&gt; [] = \&lt;sigma&gt;"       <br>
 by (induct \&lt;sigma&gt;) auto        <br>
        lemma assoc_compose[simp]:"assoc a (Var a) (s1 \&lt;bullet&gt; s2) = <br>
assoc a (Var a) s1 \&lt;triangleleft&gt; s2"        apply(induct_tac s1)        <br>
apply(simp)        apply(auto)        done        <br>
        lemma  apply_compose[simp]: "t \&lt;triangleleft&gt; (s1 \&lt;bullet&gt; s2) =  <br>
t \&lt;triangleleft&gt; s1 \&lt;triangleleft&gt; s2"        apply (induct t)        <br>
apply(simp)        apply(simp)        apply(simp)        apply(simp)        <br>
done        <br>
        subsection {* Partial correctness *}        <br>
        text {* Some lemmas about occ and MGU: *}        <br>
        lemma subst_no_occ:         shows "\&lt;not&gt; occ (Var v) t          <br>
   \&lt;Longrightarrow&gt; Var v \&lt;noteq&gt; t             \&lt;Longrightarrow&gt; t <br>
\&lt;triangleleft&gt; [(v,s)] = t"           and "\&lt;not&gt; occ_list (Var v) ts    <br>
         \&lt;Longrightarrow&gt; (\&lt;And&gt;u. u \&lt;in&gt; set ts              <br>
 \&lt;Longrightarrow&gt; Var v \&lt;noteq&gt; u)             \&lt;Longrightarrow&gt; <br>
apply_subst_list ts [(v,s)] = ts"        apply (induct rule: trm.inducts)   <br>
     apply (simp_all)        ...        done</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>