<html>
<head><meta charset="utf-8"><title>[isabelle] Opposite of the `transfer` method ¬∑ Archive Mirror: Isabelle Users Mailing List ¬∑ Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html">[isabelle] Opposite of the `transfer` method</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294759380"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294759380" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294759380">(Aug 22 2022 at 20:07)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
Hi!</p>
<p>I‚Äôm looking for a proof method that is like <code>transfer</code> but transforms<br>
into the opposite direction.</p>
<p>Consider, for example, the following code:</p>
<p>axiomatization equivalence :: "[nat, nat] ‚áí bool" where<br>
      is_equi<br>
valence:<br>
        "equivp equivalence"<br>
    and<br>
      is_compatible_with_plus<br>
:<br>
        "‚ü¶equivalence n n'; equivalence m m'‚üß ‚üπ<br>
        equivalence (n +<br>
m) (n' + m')"</p>
<p>quotient_type abstract = nat / equivalence<br>
      using is_equivalence .</p>
<p>lift_definition abstract_plus :: "[abstract, abstract] ‚áí abstract"<br>
      is "(+)"<br>
      using is_compatible_with_plus .</p>
<p>The <code>transfer</code> method can replace equalities of <code>abstract</code> values by<br>
equivalences of <code>nat</code> values:</p>
<p>lemma "abstract_plus a b = abstract_plus c d"<br>
    proof transfer<br>
      ‚Äï ‚Äπyields \&lt;^term&gt;‚Äπ‚ãÄa b c d. equivalence (a + b) (c + d)‚Ä∫‚Ä∫<br>
      oops</p>
<p>However, it does not perform the opposite conversion:</p>
<p>lemma "equivalence (a + b) (c + d)"<br>
    proof transfer<br>
      ‚Äï ‚Äπalso yields \&lt;^term&gt;‚Äπ‚ãÄa b c d. equivalence (a + b) (c + d)‚Ä∫‚Ä∫<br>
      oops</p>
<p>Is there a proof method that replaces equivalences by equalities on a<br>
corresponding quotient type? I know that there‚Äôs the <code>transferred</code><br>
attribute, but this works only for facts, not for goals.</p>
<p>The background of my question is that I‚Äôd like to employ the simplifier<br>
for reasoning with arbitrary equivalences. The idea is to reduce a goal<br>
that states an equivalence to a goal that states a corresponding<br>
equality on a quotient type and then let the simplifier do equational<br>
reasoning in that quotient type.</p>
<p>All the best,<br>
Wolfgang</p>



<a name="294759555"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294759555" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294759555">(Aug 22 2022 at 20:08)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
One step in the right direction might be to invoke the simplifier using<br>
equations auto-generated by <code>quotient_type</code> and <code>lift_definition</code>, like<br>
so:</p>
<p>lemma "equivalence (a + b) (c + d)"<br>
    proof (simp only: abstract.abs_eq_iff [THEN sym] abstract_plus.abs_eq [THEN sym])<br>
      ‚Äï ‚Äπyields \&lt;^term&gt;‚Äπabstract_plus (abs_abstract a) (abs_abstract b) = abstract_plus (abs_abstract c) (abs_abstract d)‚Ä∫‚Ä∫<br>
      oops</p>
<p>However, I wouldn‚Äôt like to specify the rewrite rules manually like in<br>
this code snippet. Is there a way to automatically gather all<br>
<code>abs_eq_iff</code> and <code>abs_eq</code> rules or perhaps only those that are related<br>
to the equivalence relation used in the goal?</p>
<p>All the best,<br>
Wolfgang</p>



<a name="294759871"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294759871" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294759871">(Aug 22 2022 at 20:10)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt;<br>
Dear Wolfgang,</p>
<p>Collecting the rewrite rules will not get you very far in general, because you need a <br>
relational approach to deal with that; think of something like</p>
<p>list_all2 equivalence (map ((+) x) xs) (map ((+) y) ys)</p>
<p>That's why the transfer package uses a relation approach that is beyond the simplifier's <br>
reach.</p>
<p>Now, unfortunately, the transfer package does not offer a proof method to from a raw type <br>
(nat) to an abstract type. AFAIK the main reason for that is that it typically will not <br>
work well. The transfer method assumes that only constants need to be replaced. This is <br>
violated for lift_definition when the right-hand side is a compound term, which is the <br>
usual case.</p>
<p>However, the whole machinery can also be made to work in the other directions; it's just <br>
not implemented. Alternatively, you can manually define the reversed correspondence <br>
relation rev_cr :: "nat =&gt; abstract =&gt; bool" as "rev_cr = conversep cr_abstract" and adapt <br>
the transfer rules accordingly. But that's quite a bit of manual work.</p>
<p>Finally, the old quotient package by Cezary and Urban supports transferring in both <br>
directions (Section 11.9.4 in isar-ref: quotient_definition instead of lift_definition, <br>
methods lifting and descending). They also have the restriction in place that the raw term <br>
must be a constant. Note however that this package is not so well integrated into the HOL <br>
library as transfer.</p>
<p>Hope this helps,<br>
Andreas</p>



<a name="294759936"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294759936" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294759936">(Aug 22 2022 at 20:11)</a>:</h4>
<p>From: "Thiemann, Ren√©" &lt;<a href="mailto:Rene.Thiemann@uibk.ac.at">Rene.Thiemann@uibk.ac.at</a>&gt;<br>
Hi Wolfgang,</p>
<p>I‚Äôm unsure whether there is a proof method, however there is the ‚Äúuntransferred‚Äù attribute that<br>
works in the opposite direction. So also transfer is to a certain extend bidirectional.</p>
<p>lemma "equivalence (a + b) (c + d)"<br>
proof -<br>
  have "abstract_plus a b = abstract_plus c d" for a b c d sorry<br>
  from this[untransferred] show ?thesis .<br>
qed</p>
<p>Perhaps this solves your goal.</p>
<p>Best,<br>
Ren√©</p>



<a name="294759961"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294759961" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294759961">(Aug 22 2022 at 20:11)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
Dear Andreas,</p>
<p>thanks a lot for your response.</p>
<blockquote>
<p>Collecting the rewrite rules will not get you very far in general,<br>
because you need a relational approach to deal with that; think of<br>
something like</p>
<p>list_all2 equivalence (map ((+) x) xs) (map ((+) y) ys)</p>
<p>That‚Äôs why the transfer package uses a relation approach that is<br>
beyond the simplifier‚Äôs reach.</p>
</blockquote>
<p>Well, in my use cases, premises and conclusions are always applications<br>
of equivalence relations. I guess invoking those rewrite rules will work<br>
for turning these applications of equivalence relations into equalities<br>
on the quotient type. However, I‚Äôd still like to avoid this approach,<br>
since it means too much manual work for my taste.</p>
<blockquote>
<p>Finally, the old quotient package by Cezary and Urban supports<br>
transferring in both directions (Section 11.9.4 in <code>isar-ref</code>:<br>
<code>quotient_definition</code> instead of <code>lift_definition</code>, methods <code>lifting</code><br>
and <code>descending</code>).</p>
</blockquote>
<p>I tried with the old quotient package, but it didn‚Äôt work for me.<br>
Consider my example code adapted to the old package:</p>
<p>axiomatization equivalence :: "[nat, nat] ‚áí bool" where<br>
      is_equivalence:<br>
        "equivp equivalence"<br>
    and<br>
      is_compatible_with_plus:<br>
        "‚ü¶equivalence n n'; equivalence m m'‚üß ‚üπ<br>
        equivalence (n + m) (n' + m')"</p>
<p>quotient_type abstract = nat / equivalence<br>
      using is_equivalence .</p>
<p>quotient_definition "abstract_plus :: [abstract, abstract] ‚áí abstract"<br>
      is "(+) :: [nat, nat] ‚áí nat"<br>
      using is_compatible_with_plus .</p>
<p>Now assume I have a goal <code>equivalence (a + b) (c + d)</code> and I want it to<br>
be turned into the goal <code>abstract_plus x y = abstract_plus z u</code>. Neither<br>
applying <code>lifting</code> nor applying <code>descending</code> does that: <code>lifting</code> leaves<br>
the goal in place; <code>descending</code> just adds explicit universal<br>
quantification of the variables via <code>‚ãÄ</code>. What am I doing wrong here?</p>
<p>All the best,<br>
Wolfgang</p>



<a name="294759971"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294759971" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294759971">(Aug 22 2022 at 20:11)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
Hi, Ren√©!</p>
<p>Thanks a lot for your response.</p>
<p>Technically, your solution would work. However, it would mean that the<br>
user would have to add a considerable amount of boilerplate, because<br>
stating the equations on the quotient types is necessary.</p>
<p>Maybe I should explain a bit more the background of my question.</p>
<p>I‚Äôm working with a process calculus. I have an algebraic data type<br>
<code>process</code> of processes (or rather process terms) and several<br>
bisimilarity relations, which describe different notions of behavioral<br>
equivalence.</p>
<p>Most of the proofs I‚Äôm conducting are proofs of bisimilarities, proving<br>
goals of the form <code>p ‚àº q</code> where <code>p</code> and <code>q</code> are processes and <code>(‚àº)</code> is<br>
one of the bisimilarity relations. In many of these proofs, I‚Äôm using<br>
calculational reasoning, exploiting the fact that <code>(‚àº)</code> is transitive.</p>
<p>There are certain core facts about the bisimilarity relations that state<br>
things like transitivity and commutativity of certain process operators<br>
modulo bisimilarity, things like <code>(p ‚à• q) ‚à• r ‚àº p ‚à• (q ‚à• r)</code> and <code>p ‚à• q
‚àº q ‚à• p</code>. Having to apply these facts manually in the proofs is really<br>
painful. My goal is to have a proof method that applies such technical<br>
facts as rewrite rules, analogously to what the simplifier does with<br>
equations.</p>
<p>For example, in a proof I might have something like the following:</p>
<p>from "p ‚àº q ‚à• r" have "p ‚à• q ‚àº r ‚à• (q ‚à• q)" sorry</p>
<p>I‚Äôd like to replace the <code>sorry</code> with something as simple as <code>by simp</code>.<br>
While your approach would work, it would mean I had to add a quotient<br>
type version of every single proof step.</p>
<p>Of course, it would be an option to translate the overall bisimilarity<br>
goal of each proof into a goal about quotient type equations and then<br>
reason in the quotient type throughout the proof. However, this would<br>
feel quite unnatural to me. The main reason is that there‚Äôs not a single<br>
best bisimilarity but there are multiple ones; so I would have to work<br>
with several quotient types and convert back and forth between them.</p>
<p>I was considering using quotient types only internally as a means to<br>
make the simplifier reason with arbitrary equivalences. The basic idea<br>
is to translate both the goal and the rewrite rules (like <code>p ‚à• q ‚àº
q ‚à• p</code>) into statements that use equality on quotient types and then<br>
employ the simplifier to solve the new goals entirely.</p>
<p>I‚Äôm wondering how others reason with equivalence relations. Somehow I<br>
can‚Äôt imagine that a situation like mine is so rare; so I‚Äôd be surprised<br>
if there isn‚Äôt an approach to performing ‚Äúequivalence reasoning‚Äù<br>
conveniently. Any hints?</p>
<p>All the best,<br>
Wolfgang</p>



<a name="294759982"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294759982" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294759982">(Aug 22 2022 at 20:11)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;</p>
<blockquote>
<p>I‚Äôm wondering how others reason with equivalence relations. Somehow I<br>
can‚Äôt imagine that a situation like mine is so rare; so I‚Äôd be<br>
surprised<br>
if there isn‚Äôt an approach to performing ‚Äúequivalence reasoning‚Äù<br>
conveniently. Any hints?</p>
</blockquote>
<p>Coq has a setoid rewrite engine, which might be what you want here?.<br>
The idea is to rewrite wrt arbitrary preorders.</p>
<p>Up to my knowledge, such a thing has not yet been implemented in<br>
Isabelle (though I'm collecting possible applications, as I might<br>
implement such a thing sooner or later ;) )</p>



<a name="294760010"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Opposite%20of%20the%20%60transfer%60%20method/near/294760010" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Opposite.20of.20the.20.60transfer.60.20method.html#294760010">(Aug 22 2022 at 20:11)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
Am Donnerstag, den 04.07.2019, 17:26 +0100 schrieb Peter Lammich:</p>
<blockquote>
<blockquote>
<p>I‚Äôm wondering how others reason with equivalence relations. Somehow<br>
I can‚Äôt imagine that a situation like mine is so rare; so I‚Äôd be<br>
surprised if there isn‚Äôt an approach to performing ‚Äúequivalence<br>
reasoning‚Äù conveniently. Any hints?</p>
</blockquote>
<p>Coq has a setoid rewrite engine, which might be what you want here?</p>
</blockquote>
<p>Well, I‚Äôd want something like that for Isabelle. üòâ</p>
<p>I have a considerable amount of Isabelle code, which I wouldn‚Äôt like to<br>
translate to Coq, for three reasons:</p>
<p>* The translation would take a lot of time.</p>
<p>* The translation would perhaps not be straightforward because of<br>
    Coq‚Äôs constructivity.</p>
<p>* Coq doesn‚Äôt have a proper proof language along the lines of Isar.</p>
<blockquote>
<p>Up to my knowledge, such a thing has not yet been implemented in<br>
Isabelle (though I‚Äôm collecting possible applications, as I might<br>
implement such a thing sooner or later üòâ).</p>
</blockquote>
<p>Please implement it! <span aria-label="pray" class="emoji emoji-1f64f" role="img" title="pray">:pray:</span></p>
<p>All the best,<br>
Wolfgang</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>