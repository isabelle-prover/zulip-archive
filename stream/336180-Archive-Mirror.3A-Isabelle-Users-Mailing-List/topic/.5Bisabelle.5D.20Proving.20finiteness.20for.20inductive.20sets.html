<html>
<head><meta charset="utf-8"><title>[isabelle] Proving finiteness for inductive sets · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proving.20finiteness.20for.20inductive.20sets.html">[isabelle] Proving finiteness for inductive sets</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294118693"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Proving%20finiteness%20for%20inductive%20sets/near/294118693" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Proving.20finiteness.20for.20inductive.20sets.html#294118693">(Aug 18 2022 at 16:11)</a>:</h4>
<p>From: Joachim Breitner &lt;<a href="mailto:mail@joachim-breitner.de">mail@joachim-breitner.de</a>&gt;<br>
Dear list,</p>
<p>for a current project of mine, I have to talk about the set of<br>
subexpressions of a syntax tree and I need both the fact that this set<br>
is finite and the individual introduction rules.</p>
<p>My first attempt, which can be seen at<br>
<a href="http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/CPSUtils.thy;h=b76dbbe68a4002b277fc7abbe930d235ff5cc85b;hb=df00ade5a418f1666624f8334ea253accf05d1c1">http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/CPSUtils.thy;h=b76dbbe68a4002b277fc7abbe930d235ff5cc85b;hb=df00ade5a418f1666624f8334ea253accf05d1c1</a><br>
was to define the set of subexpressions using the fun package. Showing<br>
finiteness was easily done by induction. But proving the local rules I<br>
need (e.g. lambdas1, lambdas2, app1, app2,... in that file) turned out<br>
to be very inelegant, repetitive and ugly.</p>
<p>If I had defined the sets of subexpressions inductively, these rules<br>
would be provided directly, but then the proof of finiteness is harder.<br>
I worked on a general solution and the result so far can be seen at<br>
<a href="http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/Finite_Inductive_Set.thy;h=23bc9d27951e270342404b546546ccb77caf303c;hb=df00ade5a418f1666624f8334ea253accf05d1c1">http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/Finite_Inductive_Set.thy;h=23bc9d27951e270342404b546546ccb77caf303c;hb=df00ade5a418f1666624f8334ea253accf05d1c1</a></p>
<p>The main result is</p>
<p>84 lemma lfp_finite:<br>
  85   assumes mono: "mono F"<br>
  86       and finite: "finiteness_preserving F"<br>
  87       and desc: "descending_functional p F"<br>
  88   shows "finite (lfp F)"</p>
<p>where finiteness_preserving means that F S is finite if S already is and<br>
descending_functional means that newly added elements are smaller than<br>
previously added elements when measured with "p" (for which I later only<br>
use the size function).</p>
<p>Here is an example application of the system. I define an inductive set<br>
giving the tails of a list:</p>
<p>194 inductive tails for l<br>
 195   where "tails l l"<br>
 196       | "tails l (x#xs) \&lt;Longrightarrow&gt; tails l xs"</p>
<p>207 lemma "finite (tails l)"<br>
 208 unfolding tails_def<br>
 209 proof (induct rule: lfp_finite[of _ size, case_names mono finiteness desc])<br>
 210 case mono show ?case by mono<br>
 211 next<br>
 212 case finiteness show ?case by (intro finiteness_preserving_lemmas, simp)<br>
 213 next<br>
 214 case desc show ?case<br>
 215   by (rule, auto simp add: Bex_def mem_def fun_diff_def bool_diff_def)<br>
 216 qed</p>
<p>For the proof of monotonicity, I copied the ML code from inductive.ML<br>
into a custom method.</p>
<p>For the proof of finiteness preserving I wrote some intro rules breaking<br>
down the functional generated by inductive_set and handling the types of<br>
clauses I observed so far.</p>
<p>For the proof that the functional is descending I had to persuade<br>
Isabelle not to be confused by sets vs. predicates, then it went through<br>
easily (at least in this simple case).</p>
<p>So far so nice. For these kind of inductive sets, the result is quite<br>
satisfying, and maybe can be useful for others as well.</p>
<p>Unfortunately, in my case, I need mutually recursive sets. Line 29 of<br>
CPSUtils has "inductive_set lambdas' and calls' and values'"<br>
demonstrating the issue, but a smaller example is at the end of<br>
Finite_Inductive_Set.thy:</p>
<p>296 inductive tails' and elems' for l<br>
 297   where "tails' l l"<br>
 298       | "tails' l (x#xs) \&lt;Longrightarrow&gt; tails' l xs"<br>
 299       | "tails' l (x#xs) \&lt;Longrightarrow&gt; elems' l x"</p>
<p>The problem is that inducive_set generates a combined fixed point of<br>
type "bool =&gt; 'a list =&gt; 'a =&gt; bool". This large set is then projected<br>
onto "'a list =&gt; bool" or "'a =&gt; bool" by extracting those elements<br>
where the boolean flag fits and where the “other” field is undefined.</p>
<p>I wrote a rule that converts such a fixed point to one with uncurried<br>
arguments, i.e. "((bool \&lt;times&gt; 'a list) \&lt;times&gt; 'a) =&gt; bool" in<br>
lfp_curry and the variant lfp_curryD which carries the monotonicity<br>
requirement along. This way I end up at a fixed point where I can apply<br>
lfp_finite. Unfortunately, these fixed points do not preserve<br>
finiteness, as can be seen by this unsolvable goal:</p>
<p>finiteness_preserving (λp x. ¬ fst (fst x) ∧ snd x = l)</p>
<p>This rule, which comes from the first equation about tails', adds all<br>
triples where the first field is False and the last field is l (as<br>
expected), but makes no statement about the second fields. I.e. this<br>
rule adds one element per member of 'a! And naturally, this makes my<br>
whole process fail.</p>
<p>The other rules share the same problem in that they do not specify all<br>
fields.</p>
<p>I’m not sure how to proceed from here. A workaround would be to define a<br>
combined set using Inl/Inr:</p>
<p>inductive tailselems for l<br>
  where "tailselems l (Inl l)"<br>
      | "tailselems l (Inl (x#xs)) ⟹ tailselems l (Inl xs)"<br>
      | "tailselems l (Inl (x#xs)) ⟹ tailselems l (Inr x)"</p>
<p>But this would get quickly very unwieldy, especially as I need to<br>
recursively define more than one set.</p>
<p>Another possible fix could involve changes to inducitve_set. Why not set<br>
all invalid fields of the added members to undefined, and thus do not<br>
add all those never-used elements? BTW, what is the reason not to use<br>
Inl/Inr there in the first place?</p>
<p>Or is there maybe a completely different solution that I’m just not<br>
seeing yet?</p>
<p>Thanks in advance,<br>
Joachim<br>
<a href="/user_uploads/14278/OgRa9V7jkJYdTaDNFFmi7Els/signature.asc">signature.asc</a></p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>