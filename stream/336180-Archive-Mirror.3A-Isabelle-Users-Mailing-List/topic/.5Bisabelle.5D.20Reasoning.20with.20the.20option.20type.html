<html>
<head><meta charset="utf-8"><title>[isabelle] Reasoning with the option type · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html">[isabelle] Reasoning with the option type</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294636993"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294636993" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294636993">(Aug 22 2022 at 09:29)</a>:</h4>
<p>From: Alfio Martini &lt;<a href="mailto:alfio.martini@acm.org">alfio.martini@acm.org</a>&gt;<br>
Dear Isabelle Users,</p>
<p>In a previous thread (Isabelle: A logic of partial functions?) I asked<br>
some questions about the use of the constant "undefined" when<br>
dealing with partial functions, which  have to be made total according<br>
to the foundations of Isabelle.</p>
<p>The long thread about my difficulties with Sledgehammer made<br>
me realize that my definition was not general enough. And after<br>
looking into the very well written tutorial on Code Generation, I<br>
was convinced that I had to deal with the option type.</p>
<p>I'm  also very grateful to all that reply my original messages with<br>
many insightful and helpful observations.<br>
So, if some novice is interested I include here (my) proof of the<br>
total correctness of that sum algorithm.</p>
<p>I only ask the evaluation of some more experienced user, if<br>
this is the correct way to reason  with the option type. It looks<br>
a bit clumsy.</p>
<p>The thy file is attached. Many thanks for any remarks!</p>
<p>Best!<br>
<a href="/user_uploads/14278/3Os1BlrbjWWUYBqC-et95ULO/SumIntOption.thy">SumIntOption.thy</a></p>



<a name="294637138"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294637138" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294637138">(Aug 22 2022 at 09:30)</a>:</h4>
<p>From: "Eugene W. Stark" &lt;<a href="mailto:stark@cs.stonybrook.edu">stark@cs.stonybrook.edu</a>&gt;<br>
I am not very experienced, but I looked at your proof.<br>
It seems very long, and there are lots of apparently unnecessary<br>
assumptions that float in and out.  I came up with the attached,<br>
which is rather shorter.  I did not see how the use of the<br>
option type introduces any complication here.  Hopefully I did<br>
not misunderstand something important.</p>
<p>- Gene Stark<br>
<a href="/user_uploads/14278/y3K2XYSVApI6V5sSq3TXuxZp/SumIntOption.thy">SumIntOption.thy</a></p>



<a name="294637149"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294637149" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294637149">(Aug 22 2022 at 09:30)</a>:</h4>
<p>From: Alfio Martini &lt;<a href="mailto:alfio.martini@acm.org">alfio.martini@acm.org</a>&gt;<br>
Hi Eugene,</p>
<p>Thank you for your feedback. Indeed it looks much shorter, since the<br>
simplifier takes care of the<br>
many intermediate steps I wrote it down. Anyway, at least for these<br>
exercises, I try to use Isabelle to check<br>
my handwritten proofs (or any handwritten proof that is made without<br>
assuming automated tools).<br>
That is why they look unnecessary  long. But I will use some of your<br>
suggestions in order to improve its presentation.</p>
<p>Best!</p>



<a name="294637164"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294637164" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294637164">(Aug 22 2022 at 09:30)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;<br>
It is, of course, not unreasonable to do things by hand like you did in <br>
order to get to know the system better.</p>
<p>I would, however, like to show you how to shorten the proof a bit more. <br>
Isabelle's automation is very powerful, but you have to help it along a <br>
bit. As a rule, when you try to prove a fact about a recursively-defined <br>
function, it is advisable to use the induction rule for that function <br>
that the function package gives you. It makes things easier, both for <br>
you and for the automation.</p>
<p>So let's apply it and see what we end up with:</p>
<p>theorem<br>
   "l ≤ u ⟹ sumO l u f = Some (∑k=l..u. f k)"<br>
apply (induction l u f rule: sumO.induct)<br>
apply simp_all</p>
<p>The remaining goal is then something like<br>
⋀n m f. n &lt; m ⟹ f m + setsum f {n..m - 1} = setsum f {n..m}</p>
<p>This should be intuitively obvious, we're just splitting off the last <br>
term in the sum from n to m. We can show this as an auxiliary lemma, e.g.</p>
<p>lemma setsum_last_int:<br>
   "(n::int) &lt; m ⟹ f m + setsum f {n..m - 1} = setsum f {n..m}"<br>
   by (subst setsum.insert[symmetric]) (auto simp del: setsum.insert <br>
intro: setsum.cong)</p>
<p>Now the proof is fully automatic:<br>
theorem<br>
   "l ≤ u ⟹ sumO l u f = Some (∑k=l..u. f k)"<br>
   by (induction l u f rule: sumO.induct) (simp_all add: setsum_last_int)</p>
<p>Cheers,</p>
<p>Manuel</p>



<a name="294637292"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294637292" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294637292">(Aug 22 2022 at 09:31)</a>:</h4>
<p>From: Alfio Martini &lt;<a href="mailto:alfio.martini@acm.org">alfio.martini@acm.org</a>&gt;<br>
Hi Manuel,</p>
<p>Thank you for the explanations about this more general technique. I have<br>
seen now that it is<br>
explained in detail in the "Programming and Proving" tutorial under the<br>
name of "computation<br>
induction". I have tried to see the logical structure underlying your<br>
version of the proof  using<br>
Isar. I came up with the following and I assume there is a more elegant way<br>
to write it.</p>
<p>lemma setsum_last_int:<br>
  "(n::int) &lt; m ⟹ f m + setsum f {n..m - 1} = setsum f {n..m}"<br>
  by (subst setsum.insert[symmetric])<br>
  (auto simp del: setsum.insert intro: setsum.cong)</p>
<p>theorem<br>
  assumes "l ≤ u"<br>
  shows "sumO l u f = Some (∑k=l..u. f k)"  (is "?P l u f")<br>
  using assms<br>
   proof (induction l u f  rule: sumO.induct)<br>
      fix l::int and f<br>
      show "?P l l f" by simp<br>
   next<br>
      fix n::int and m and f<br>
      assume "n&lt;m" and "(n ≤ m - 1 ==&gt; ?P n (m - 1) f)"<br>
      then  show "?P n m f"  using setsum_last_int by simp<br>
   next<br>
      fix n::int and m and f<br>
      assume "m&lt;n"  and "n≤m"<br>
      then have False by simp<br>
      then show "?P n m f" by (rule FalseE)<br>
   qed</p>
<p>It was very helpful, because I haven´t seen before that the last goal<br>
follows by a simple contradiction.<br>
Yet, I am not comfortable with the way I wrote the induction hypothesis in<br>
the second goal. I had<br>
to use the metalogical symbol "==&gt;". Assuming that I insist and writing all<br>
the details above,  how could<br>
I avoid using "==&gt;"? I have no clue.</p>
<p>Best!</p>



<a name="294637300"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294637300" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294637300">(Aug 22 2022 at 09:31)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;<br>
Since the induction hypothesis contains meta implication, there is no <br>
other way to write it. You can, however, give names to your three <br>
different cases so you don't have to fix/assume everything yourself:</p>
<p>theorem<br>
assumes "l ≤ u"<br>
shows "sumO l u f = Some (∑k=l..u. f k)"  (is "?P l u f")<br>
using assms<br>
proof (induction l u f rule: sumO.induct[case_names 1 2 3])<br>
   case (1 l f)<br>
   show ?case by simp<br>
next<br>
   case (2 n m f)<br>
   thus ?case using setsum_last_int by simp<br>
next<br>
   case (3 n m f)<br>
   hence False by simp<br>
   thus "?P n m f" by (rule FalseE)<br>
qed</p>
<p>Cheers,</p>
<p>Manuel</p>



<a name="294637327"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294637327" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294637327">(Aug 22 2022 at 09:31)</a>:</h4>
<p>From: Alfio Martini &lt;<a href="mailto:alfio.martini@acm.org">alfio.martini@acm.org</a>&gt;<br>
Great! I tried to use case, but it did not work, because I was not aware<br>
that<br>
I could declare the arbitrary fixed variables in that way (although it<br>
seems to<br>
be  there in section 4.4.2 of the tutorial for the case of structural<br>
induction).</p>
<p>Cheers!</p>



<a name="294637408"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Reasoning%20with%20the%20option%20type/near/294637408" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Reasoning.20with.20the.20option.20type.html#294637408">(Aug 22 2022 at 09:32)</a>:</h4>
<p>From: Alfio Martini &lt;<a href="mailto:alfio.martini@acm.org">alfio.martini@acm.org</a>&gt;<br>
Hi Eugene,</p>
<p>and there are lots of apparently unnecessary</p>
<blockquote>
<p>assumptions that float in and out.</p>
</blockquote>
<p>You are completely right. My original (long) version would be like this<br>
without<br>
the unnecessary assumptions.</p>
<p>theorem<br>
  fixes u::int and l::int<br>
  assumes assm: "l≤u"<br>
  shows "sumO l u f = Some (∑ k=l..u. (f k))" (is "?P u")<br>
  using assms<br>
    proof (induct u rule: int_ge_induct)<br>
      show "?P l"<br>
       proof -<br>
         have "sumO l l f = Some (f l)" by simp<br>
         also have "... = Some (∑ k=l..l. (f k))" by simp<br>
         finally show "sumO l l f = Some (∑ k=l..l. (f k))" by this<br>
       qed<br>
    next<br>
      fix i::int<br>
      assume hip01: "i≥l" and HI:"?P i"<br>
      show "sumO l (i+1) f = Some (∑ k=l..i+1. (f k))"<br>
         proof -<br>
            have<br>
            "sumO l (i+1) f = (case sumO l i f of<br>
             None ⇒ None | Some v ⇒ Some ((f (i+1) + v)))"<br>
             using hip01 by simp<br>
             also have "... = Some (f (i+1) + (∑ k=l..i. (f k)))"<br>
             using HI and hip01 by simp<br>
             also have "... = Some (∑ k=l..i+1. (f k))"<br>
                proof -<br>
                   have "{l..i + 1} = insert (i+1) {l..i}" using hip01<br>
                     by auto<br>
                   thus ?thesis by simp<br>
                qed<br>
              finally  show "sumO l (i+1) f = Some (∑ k=l..i+1. (f k))" by<br>
this<br>
         qed<br>
    qed</p>
<p>Best!</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>