<html>
<head><meta charset="utf-8"><title>[isabelle] Recent inconsistency in HOL/Isabelle a matter ... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Recent.20inconsistency.20in.20HOL.2FIsabelle.20a.20matter.20.2E.2E.2E.html">[isabelle] Recent inconsistency in HOL/Isabelle a matter ...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294703827"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Recent%20inconsistency%20in%20HOL/Isabelle%20a%20matter%20.../near/294703827" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Recent.20inconsistency.20in.20HOL.2FIsabelle.20a.20matter.20.2E.2E.2E.html#294703827">(Aug 22 2022 at 14:54)</a>:</h4>
<p>From: Ken Kubota &lt;<a href="mailto:mail@kenkubota.de">mail@kenkubota.de</a>&gt;<br>
Dear Makarius Wenzel, dear Lawrence C. Paulson,<br>
dear Members of the Research Community,</p>
<p>Catching up with the email discussion of the last weeks, I feel the need to <br>
comment on some statements by Makarius Wenzel and by Lawrence C. Paulson, e.g., <br>
Wenzel's claim:</p>
<p>"The assumption that any of the LCF-style provers is 100% correct is<br>
wrong -- that was never the case in last decades. If your work depends<br>
on that assumption, you need to rethink what you are doing."<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00075.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00075.html</a></p>
<p>In other contributions, similar statements are made. For example, in the <br>
German-language presentation at<br>
<a href="https://youtu.be/R8pyFwil9KY">https://youtu.be/R8pyFwil9KY</a><br>
from minute 30:18 on Wenzel argues that John Harrison's HOL Light has a <br>
provably safe kernel, but is implemented in the unsafe programming <br>
language/environment OCaml, claiming more or less all that HOL implementations <br>
are subject to logical failures in the same way.</p>
<p>Paulson adds the "point of view of many mathematicians, [that] reliance on <br>
computers introduces too much uncertainty" also because of hardware failure due <br>
to physical influence ("cosmic rays and the like").<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00080.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00080.html</a><br>
This is not convincing to me, not only because the human brain is subject to <br>
physical influence, too, but such effects can by minimized by repeating the <br>
proof verification, which drastically reduces the likeliness of such errors <br>
(with exponential decay depending on the number of independent systems, I <br>
believe).</p>
<p>In general, the aim of these arguments seems highly problematic to me, as they <br>
seem to confuse violations of the LCF approach itself with minor technical <br>
questions.</p>
<p>Of course, depending on the choice of the programming language/environment, <br>
there may be ways to bypass restrictions guarding the LCF logical kernel. But <br>
these are technical implementation details. Not every logician wants to create <br>
and implement a new language for proof verification (however, I did with the R0 <br>
implementation), and therefore many have to rely upon ML, Standard ML, OCaml or <br>
other software meta-languages, including their disadvantages such as offering <br>
the means to freely manipulate the kernel with some hack.<br>
But when carrying out a proof, the author clearly knows whether he uses regular <br>
proof commands or some hacks of the software meta-language (e.g., ML or OCaml); <br>
moreover, such hacks can be easily identified in the proof script.</p>
<p>These implementation details are a completely different issue than a flaw in <br>
the logical kernel, as recently discovered in Isabelle/HOL.</p>
<p>For the same reason, the reference to Hugo Herbelin's email at<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00077.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00077.html</a><br>
is inappropriate, since he only refers to either such weaknesses that are <br>
technical implementation details as described above, or weaknesses where <br>
improvement attempts are already in progress (and which obviously have little <br>
to do with the formal language, i.e., the logic, itself).</p>
<p>The inconsistency in Isabelle/HOL found by Kuncar and Popescu in<br>
<a href="http://doi.org/10.1007/978-3-319-22102-1_16">http://doi.org/10.1007/978-3-319-22102-1_16</a><br>
<a href="http://andreipopescu.uk/pdf/ITP2015.pdf">http://andreipopescu.uk/pdf/ITP2015.pdf</a><br>
clearly is a flaw in the logical kernel, and not only a matter of some <br>
technical hack (exploiting some programming language/environment).</p>
<p>Tobias Nipkow expressed it very clearly: "This is not a minor issue with fonts <br>
but concerns and endangers the very core of what we are doing."<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00083.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00083.html</a></p>
<p>If you believe that other HOL systems are affected in the same way, please <br>
provide the reference to papers on inconsistencies in that systems.<br>
As of my knowledge, rather the opposite is the case, e.g.,</p>
<ul>
<li>
<p>HOL Light provides some self-verification:<br>
<a href="http://www.cl.cam.ac.uk/~jrh13/papers/holhol.pdf">http://www.cl.cam.ac.uk/~jrh13/papers/holhol.pdf</a></p>
</li>
<li>
<p>and HOL Zero offers a reward for finding soundness-related flaws:<br>
<a href="http://www.proof-technologies.com/holzero/unsoundnesses.html">http://www.proof-technologies.com/holzero/unsoundnesses.html</a></p>
</li>
</ul>
<p>But relativizing a flaw in the logical kernel itself by classifying it into the <br>
same category as a hack allowed by the technical implementation more or less <br>
ends up in giving up the LCF approach as a whole.</p>
<p>Similarly, I disagree with some statements of Lawrence C. Paulson:<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00075.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00075.html</a><br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00089.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00089.html</a><br>
I can understand that Paulson is not very happy about such an incidence, but <br>
denying that the flaw is an inconsistency is not helpful, since it very <br>
obviously has the two properties of a classical paradox: self-reference <br>
(circularity) and negativity (negation).<br>
Moreover, the source code should be subject to scrutiny, of course, otherwise <br>
we cannot talk of a system conforming to the LCF approach.</p>
<p>Basically, I agree with the replies of Popescu and Kuncar:<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00096.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00096.html</a><br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00097.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00097.html</a></p>
<p>In the same manner, I somewhat disagree with Tobias Nipkow's following <br>
statement from 2015 I recently stumbled across:<br>
"The length of this dicussion puzzles me. Typedef can introduce <br>
inconsistencies, nobody wants this behaviour and nobody needs this behaviour. <br>
There is a perfectly clear way to rule out this whole class of unwanted <br>
behaviours: do not allow certain cycles. This solution, including code, has <br>
been on the table for a year now. By now not just mere users but also <br>
certification agencies are worried. This is a pressing issue and it is not <br>
rocket science."<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00115.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00115.html</a></p>
<p>My impression is, that in the Isabelle group, the attitude is only that <br>
self-reference (circularity) is a problem, but no further analysis is made, <br>
including the comparison with other systems by trying to express the same <br>
phenomenon within the other systems, and the search for the exact reason for <br>
the paradox, which goes beyond just self-reference.<br>
Self-reference in formal logic shows that some dependency is not properly <br>
resolved.<br>
The proper way to correctly resolve these dependencies in order to avoid <br>
paradoxes is a way by means of the formal language (in the tradition of Russell <br>
and Church).</p>
<p>For this reason, I consider the approach by Kuncar and Popescu as a rather <br>
preliminary solution.<br>
As far as I have looked at it, it seems to keep track of the dependencies in <br>
the background.<br>
It may work, but the logician's desire for naturally expressing formal logic <br>
and mathematics would be using the means of the formal language to keep track <br>
of the dependencies (in order to avoid paradoxes). The same critique could be <br>
applied to the type correctness conditions (TCCs) of PVS, where correctness is <br>
checked only afterwards, instead of directly preventing the expression of <br>
incorrect terms (non-well-formed formulae / non-wffs) by means of the language.<br>
In R0, the same problem was solved using syntactical means only: type <br>
abstraction, i.e., the binding of type variables with lambda.</p>
<p>In my opinion, the inconsistency in Isabelle/HOL created by axiomatic type <br>
classes (ad hoc overloading of constants) has three reasons:</p>
<ol>
<li>The LCF approach is not implemented properly.</li>
</ol>
<p>Clearly, in the documentation a strict distinction between the kernel and the <br>
rest is missing, not to speak of the inner kernel and the extension. In the <br>
original HOL system, the logic is a separate part (Part III: The HOL Logic <br>
[Gordon and Melham, 1993, pp. 191–232]), in current HOL4 a separate file <br>
(<a href="http://freefr.dl.sourceforge.net/project/hol/hol/kananaskis-10/kananaskis-10-logic.pdf">http://freefr.dl.sourceforge.net/project/hol/hol/kananaskis-10/kananaskis-10-logic.pdf</a>). <br>
Within the logic, the extension is easily identifiable (e.g., online <br>
as the section "2.5 Extensions of theories"). I have discussed this earlier in <br>
Oct. 2016:<br>
"If one takes the LCF approach of a small trusted logical kernel for serious, <br>
the logic has to be described in a separate and clearly identifiable part, as <br>
the kernel should be a verified and therefore trusted, not a blindly trusted <br>
kernel.<br>
Further, the extensions are clearly marked as 'extensions' in the table of <br>
contents, and the use of axioms ('Asserting an axiom', section 2.5.4 Extension <br>
by type definition) is clearly named"<br>
<a href="https://sourceforge.net/p/hol/mailman/message/35437586/">https://sourceforge.net/p/hol/mailman/message/35437586/</a></p>
<p>Similar as in the documentation, in the source code the distinction between the <br>
kernel and the rest seems to be missing, as otherwise the introduction of <br>
axiomatic type classes (ad hoc overloading of constants) could not have <br>
happened, as discussed in the following section.</p>
<ol start="2">
<li>The implementation of axiomatic type classes (ad hoc overloading of <br>
constants) in Isabelle/HOL introduces something between a constant and a <br>
variable, and hence clearly is not only an extension of the logic, but a <br>
modification of the inner kernel itself. In line 1 of example 2 in<br>
<a href="http://andreipopescu.uk/pdf/ITP2015.pdf">http://andreipopescu.uk/pdf/ITP2015.pdf</a> (p. 2)<br>
a constant c is declared, but specified later in line 3, making it practically <br>
a variable without imposing the restrictions on variables on it.<br>
Hence the inner kernel is modified in such a way that the restrictions on <br>
variables can be bypassed.<br>
In Q0 (which doesn't have type variables), these restrictions on variables are <br>
part of Rule R' [Andrews, 2002, p. 214].<br>
In R0, type variables are introduced as variables (of type tau), which means <br>
that the restrictions on variables of Rule R' automatically cover the case of <br>
type variables, preventing such a paradox as the one in Isabelle/HOL by means <br>
of the language in the form a uniform treatment of both regular variables and <br>
type variables (since types are not a separate syntactic category anymore, but <br>
terms of type tau; hence, type variable are simply variables of type tau).<br>
In HOL, these restrictions on type variables are represented by condition (iii) <br>
in both</li>
</ol>
<ul>
<li>2.5.1 Extension b<br>
[message truncated]</li>
</ul>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>