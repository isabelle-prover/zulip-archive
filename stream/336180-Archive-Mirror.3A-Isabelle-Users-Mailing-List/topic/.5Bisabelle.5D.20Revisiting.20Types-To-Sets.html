<html>
<head><meta charset="utf-8"><title>[isabelle] Revisiting Types-To-Sets Â· Archive Mirror: Isabelle Users Mailing List Â· Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Revisiting.20Types-To-Sets.html">[isabelle] Revisiting Types-To-Sets</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294761712"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Revisiting%20Types-To-Sets/near/294761712" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Revisiting.20Types-To-Sets.html#294761712">(Aug 22 2022 at 20:25)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear All,</p>
<p>I hope it is not entirely inappropriate to provide several further comments<br>
on the progress in the development of an extension of the framework<br>
Types-To-Sets in the form of a reply to a remark that was made in the<br>
previous thread on this subject:<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-June/msg00072.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-June/msg00072.html</a>.</p>
<p>I believe that I have finally reached the stage at which the full<br>
automation of the relativization process is possible in certain cases. If<br>
certain conditions are met, the users need not have almost any<br>
understanding of the relativization algorithm and only a minimal amount of<br>
effort is required on their part to perform the relativization. Moreover,<br>
this effort comes down to, primarily, providing lists of definitions and<br>
theorems that they would like to relativize. The enabling feature was the<br>
implementation of the algorithm for the relativization of definitions (the<br>
algorithm was suggested by Fabian Immler).</p>
<p>After my signature, I provide an example of the relativization of a small<br>
section of the theory about preorders from the theory files Orderings.thy<br>
and Set_Interval.thy. This theory provides, approximately, 12 relativized<br>
definitions and 55 new relativized theorems for only one proof that needed<br>
to be done by the user (the proof is that of the parametricity property<br>
that exists between the locale predicates of the class.preorder and the<br>
newly introduced locale preorder_ow). The example is available as part of<br>
the GitHub repository <a href="https://github.com/xanonec/HOL-TTS-Ext">https://github.com/xanonec/HOL-TTS-Ext</a>, where the<br>
development takes place.</p>
<p>The conditions that I am referring to in the previous paragraph are that<br>
only the plain definitions are used in the type-based theory (at this<br>
stage, the relativization of constants obtained using other specification<br>
elements still needs to be performed explicitly by the user) and that the<br>
definitions do not contain Hilbert choice, definite description operator,<br>
undefined constants and other possible sources of 'non-determinism'.<br>
However, usually, it is relatively easy to provide the relativization of<br>
constants obtained using the specification elements other than 'definition'<br>
manually.</p>
<p>Effectively, the framework provides a convenient tool for synthesizing<br>
significant parts of the libraries of relativized results (e.g.<br>
HOL-Algebra) from the type-based counterparts in a nearly automated manner<br>
(e.g. see <a href="https://github.com/xanonec/HOL-SML-Relativization">https://github.com/xanonec/HOL-SML-Relativization</a>).</p>
<p>I believe that I am reaching the stage at which the work can be considered<br>
to be nearly feature-complete. Nevertheless, at this stage, I still welcome<br>
suggestions for the improvement of the functionality.</p>
<p>The only downside is that, by now, I also realised that it will take a<br>
substantial amount of time before I can provide a stable release of the<br>
software. There is still a very substantial amount of software engineering<br>
work that needs to be done before this work can be considered to be<br>
completed. Also, it seems that I will not be able to afford to allow myself<br>
to spend as much time on this project as I was able in the last couple of<br>
months from the beginning of autumn.</p>
<p>Thank you</p>
<p>section â€¹Relativization of the results about ordersâ€º<br>
theory Simple_Orders<br>
  imports<br>
    "../TTS"<br>
begin</p>
<p>subsection â€¹Definitions I: user-defined relativizationsâ€º</p>
<p>locale ord_ow =<br>
  fixes ğ”˜ :: "'ao set"<br>
    and le :: "['ao, 'ao] â‡’ bool" (infix â€¹â‰¤â‡©oâ‡©wâ€º 50)<br>
    and ls :: "['ao, 'ao] â‡’ bool" (infix â€¹&lt;â‡©oâ‡©wâ€º 50)<br>
begin</p>
<p>notation le (â€¹'(â‰¤â‡©oâ‡©w')â€º)<br>
  and le (infix â€¹â‰¤â‡©oâ‡©wâ€º 50)<br>
  and ls (â€¹'(&lt;â‡©oâ‡©w')â€º)<br>
  and ls (infix â€¹&lt;â‡©oâ‡©wâ€º 50)</p>
<p>abbreviation (input) ge (infix â€¹â‰¥â‡©oâ‡©wâ€º 50) where "x â‰¥â‡©oâ‡©w y â‰¡ y â‰¤â‡©oâ‡©w x"<br>
abbreviation (input) gt (infix â€¹&gt;â‡©oâ‡©wâ€º 50) where "x &gt;â‡©oâ‡©w y â‰¡ y &lt;â‡©oâ‡©w x"</p>
<p>notation ge (â€¹'(â‰¥â‡©oâ‡©w')â€º)<br>
  and ge (infix â€¹â‰¥â‡©oâ‡©wâ€º 50)<br>
  and gt (â€¹'(&gt;â‡©oâ‡©w')â€º)<br>
  and gt (infix â€¹&gt;â‡©oâ‡©wâ€º 50)</p>
<p>end</p>
<p>locale preorder_ow = ord_ow ğ”˜ le ls<br>
  for ğ”˜ :: "'ao set" and le ls +<br>
  assumes less_le_not_le:<br>
    "âŸ¦ x âˆˆ ğ”˜; y âˆˆ ğ”˜ âŸ§ âŸ¹ x &lt;â‡©oâ‡©w y âŸ· x â‰¤â‡©oâ‡©w y âˆ§ Â¬ (y â‰¤â‡©oâ‡©w x)"<br>
    and order_refl[iff]: "x âˆˆ ğ”˜ âŸ¹ x â‰¤â‡©oâ‡©w x"<br>
    and order_trans: "âŸ¦ x âˆˆ ğ”˜; y âˆˆ ğ”˜; z âˆˆ ğ”˜; x â‰¤â‡©oâ‡©w y; y â‰¤â‡©oâ‡©w z âŸ§ âŸ¹ x<br>
â‰¤â‡©oâ‡©w z"</p>
<p>context<br>
  includes lifting_syntax<br>
begin</p>
<p>lemma preorder_transfer[transfer_rule]:<br>
  assumes [transfer_rule]: "right_total A"<br>
  shows<br>
    "((A ===&gt; A ===&gt; (=)) ===&gt; (A ===&gt; A ===&gt; (=))  ===&gt; (=))<br>
    (preorder_ow (Collect (Domainp A))) class.preorder"<br>
  unfolding preorder_ow_def class.preorder_def<br>
  apply transfer_prover_start<br>
  apply transfer_step+<br>
  by blast</p>
<p>end</p>
<p>subsection â€¹Definitions II: automated relativizationâ€º</p>
<p>tts_unoverload_definitions<br>
  ("(â‰¤)::?'a::ordâ‡’?'a::ordâ‡’bool", "(&lt;)::?'a::ordâ‡’?'a::ordâ‡’bool")<br>
  in lessThan_def (â€¹'(/with _ : (1{..&lt;_})/')â€º)<br>
    and atMost_def (â€¹'(/with _ : (1{.._})/')â€º)<br>
    and greaterThan_def (â€¹'(/with _ : (1{_&lt;..})/')â€º)<br>
    and atLeast_def (â€¹'(/with _ : (1{_..})/')â€º)<br>
    and greaterThanLessThan_def (â€¹'(/with _ : (1{_&lt;..&lt;_})/')â€º)<br>
    and atLeastLessThan_def (â€¹'(/with _ _ : (1{_..&lt;_})/')â€º)<br>
    and greaterThanAtMost_def (â€¹'(/with _ _ : (1{_&lt;.._})/')â€º)<br>
    and atLeastAtMost_def (â€¹'(/with _ : (1{_.._})/')â€º )<br>
    and min_def (â€¹'(/with _ : Â«minÂ» _ _/')â€º [1000, 1000, 1000] 1000)<br>
    and max_def (â€¹'(/with _ : Â«maxÂ» _ _/')â€º [1000, 1000, 1000] 1000)</p>
<p>tts_relativize_definitions<br>
  types: (?'a â€¹ğ”˜::'a setâ€º)<br>
  in lessThan_with_def (â€¹'(/on _ with _ : (1{..&lt;_})/')â€º)<br>
    and atMost_with_def (â€¹'(/on _ with _ : (1{.._})/')â€º)<br>
    and greaterThan_with_def (â€¹'(/on _ with _: (1{_&lt;..})/')â€º)<br>
    and atLeast_with_def (â€¹'(/on _ with _ : (1{_..})/')â€º)<br>
    and greaterThanLessThan_with_def (â€¹'(/on _ with _ : (1{_&lt;..&lt;_})/')â€º)<br>
    and atLeastLessThan_with_def (â€¹'(/on _ with _ _ : (1{_..&lt;_})/')â€º)<br>
    and greaterThanAtMost_with_def (â€¹'(/on _ with _ _ : (1{_&lt;.._})/')â€º)<br>
    and atLeastAtMost_with_def (â€¹'(/on _ with _ : (1{_.._})/')â€º)<br>
    and min_with_def<br>
    and max_with_def</p>
<p>tts_unoverload_definitions<br>
  in bdd_above_def (â€¹'(/with _ : Â«bdd'_aboveÂ» _/')â€º)<br>
    and bdd_below_def (â€¹'(/with _ : Â«bdd'_belowÂ» _/')â€º)</p>
<p>tts_relativize_definitions<br>
  types: (?'a â€¹ğ”˜::'a setâ€º)<br>
  in bdd_above_with_def (â€¹'(/on _ with _ : Â«bdd'_aboveÂ» _/')â€º)<br>
    and bdd_below_with_def (â€¹'(/on _ with _ : Â«bdd'_belowÂ» _/')â€º)</p>
<p>subsubsection â€¹Relativization of theoremsâ€º</p>
<p>context preorder_ow<br>
begin</p>
<p>tts_relativize_facts<br>
  types: (?'a ğ”˜)<br>
  substituting preorder_ow_axioms<br>
  trying auto<br>
  in preorder_class.less_irrefl<br>
    and preorder_class.bdd_below_Ioc<br>
    and preorder_class.bdd_above_Ioc<br>
    and preorder_class.bdd_above_Iic<br>
    and preorder_class.bdd_above_Iio<br>
    and preorder_class.bdd_below_Ici<br>
    and preorder_class.bdd_below_Ioi<br>
    and preorder_class.bdd_above_Icc<br>
    and preorder_class.bdd_above_Ioo<br>
    and preorder_class.bdd_below_Icc<br>
    and preorder_class.bdd_below_Ioo<br>
    and preorder_class.bdd_above_Ico<br>
    and preorder_class.bdd_below_Ico<br>
    and preorder_class.Ioi_le_Ico<br>
    and preorder_class.eq_refl<br>
    and preorder_class.less_imp_le<br>
    and preorder_class.less_not_sym<br>
    and preorder_class.less_imp_not_less<br>
    and preorder_class.less_asym'<br>
    and preorder_class.less_imp_triv<br>
    and preorder_class.less_trans<br>
    and preorder_class.less_le_trans<br>
    and preorder_class.le_less_trans<br>
    and preorder_class.bdd_aboveI<br>
    and preorder_class.bdd_belowI<br>
    and preorder_class.less_asym<br>
    and preorder_class.bdd_above_Int1<br>
    and preorder_class.bdd_above_Int2<br>
    and preorder_class.bdd_below_Int1<br>
    and preorder_class.bdd_below_Int2<br>
    and preorder_class.bdd_above_mono<br>
    and preorder_class.bdd_below_mono<br>
    and bdd_above_empty<br>
    and preorder_class.bdd_below_empty</p>
<p>tts_relativize_facts<br>
  types: (?'a ğ”˜) and (?'b â€¹ğ”˜â‡©2::'b setâ€º)<br>
  substituting preorder_ow_axioms<br>
  trying (auto intro: bdd_above_empty bdd_below_empty)<br>
  in preorder_class.bdd_belowI2<br>
    and preorder_class.bdd_aboveI2</p>
<p>end</p>
<p>tts_statistics</p>
<p>end</p>
<hr>
<p>Automatically generated unoverloaded definitions:</p>
<p>theorem lessThan_with_def: (with ?less : {..&lt;?u}) â‰¡ {x. ?less x ?u}<br>
theorem lessThan_with.overloaded: lessThan â‰¡ lessThan_with (&lt;)<br>
theorem atMost_with_def: (with ?less_eq : {..?u}) â‰¡ {x. ?less_eq x ?u}<br>
theorem atMost_with.overloaded: atMost â‰¡ atMost_with (â‰¤)<br>
theorem greaterThan_with_def: (with ?less : {?l&lt;..}) â‰¡ {x. ?less ?l x}<br>
theorem greaterThan_with.overloaded: greaterThan â‰¡ greaterThan_with (&lt;)<br>
theorem atLeast_with_def: (with ?less_eq : {?l..}) â‰¡ {x. ?less_eq ?l x}<br>
theorem atLeast_with.overloaded: atLeast â‰¡ atLeast_with (â‰¤)<br>
theorem greaterThanLessThan_with_def: (with ?less : {?l&lt;..&lt;?u}) â‰¡ (with<br>
?less : {?l&lt;..}) âˆ© (with ?less : {..&lt;?u})<br>
theorem greaterThanLessThan_with.overloaded: greaterThanLessThan â‰¡<br>
greaterThanLessThan_with (&lt;)<br>
theorem atLeastLessThan_with_def: (with ?less_eq ?less : {?l..&lt;?u}) â‰¡ (with<br>
?less_eq : {?l..}) âˆ© (with ?less : {..&lt;?u})<br>
theorem atLeastLessThan_with.overloaded: atLeastLessThan â‰¡<br>
atLeastLessThan_with (â‰¤) (&lt;)<br>
theorem greaterThanAtMost_with_def: (with ?less_eq ?less : {?l&lt;..?u}) â‰¡<br>
(with ?less : {?l&lt;..}) âˆ© (with ?less_eq : {..?u})<br>
theorem greaterThanAtMost_with.overloaded: greaterThanAtMost â‰¡<br>
greaterThanAtMost_with (â‰¤) (&lt;)<br>
theorem atLeastAtMost_with_def: (with ?less_eq : {?l..?u}) â‰¡ (with ?less_eq<br>
: {?l..}) âˆ© (with ?less_eq : {..?u})<br>
theorem atLeastAtMost_with.overloaded: atLeastAtMost â‰¡ atLeastAtMost_with<br>
(â‰¤)<br>
theorem min_with_def: (with ?less_eq : Â«minÂ» ?a ?b) â‰¡ if ?less_eq ?a ?b<br>
then ?a else ?b<br>
theorem min_with.overloaded: min â‰¡ min_with (â‰¤)<br>
theorem max_with_def: (with ?less_eq : Â«maxÂ» ?a ?b) â‰¡ if ?less_eq ?a ?b<br>
then ?b else ?a<br>
theorem max_with.overloaded: max â‰¡ max_with (â‰¤)</p>
<p>theorem bdd_above_with_def: (with ?less_eq : Â«bdd_aboveÂ» ?A) â‰¡ âˆƒM. âˆ€xâˆˆ?A.<br>
?less_eq x M<br>
theorem bdd_above_with.overloaded: bdd_above â‰¡ bdd_above_with (â‰¤)<br>
theorem bdd_below_with_def: (with ?less_eq : Â«bdd_belowÂ» ?A) â‰¡ âˆƒm. Ball ?A<br>
(?less_eq m)<br>
theorem bdd_below_with.overloaded: bdd_below â‰¡ bdd_below_with (â‰¤)</p>
<hr>
<p>[message truncated]</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>