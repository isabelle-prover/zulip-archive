<html>
<head><meta charset="utf-8"><title>[isabelle] Several questions in relation to a use case fo... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html">[isabelle] Several questions in relation to a use case fo...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294748883"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294748883" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294748883">(Aug 22 2022 at 18:57)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear All,</p>
<p>Recently, I started using the functionality of Isabelle/HOL that is<br>
associated with "types to sets". However, I am not certain if I am using<br>
this functionality in the most appropriate manner. Questions 1-3 are<br>
general questions about the functionality of "types to sets" and its<br>
applications in HOL; question 4 is specific to my application and not<br>
directly related to "types to sets".</p>
<ol>
<li>I was not able to find the documentation for the functionality<br>
associated with "types to sets" in the standard distribution of<br>
Isabelle/HOL. I would appreciate if anyone could point me in the right<br>
direction.</li>
</ol>
<p>I would like to apologise in advance for asking questions 2 and 3 if the<br>
answers to these questions are already available in the documentation or in<br>
another post on the mailing list.</p>
<ol start="2">
<li>
<p>Theories Finite.thy and T2_Spaces.thy in the folder<br>
HOL/Types_To_Sets/Examples contain the following line: "The aforementioned<br>
development can be automated. The main part is already automated by the<br>
transfer_prover.". This comment follows immediately after the specification<br>
of the 'relativised' definitions and the transfer rules for these<br>
definitions (e.g. lines 27-103 in the theory T2_Spaces.thy). I would like<br>
to understand how exactly one should approach the automation of the<br>
specification of the 'relativised' definitions and the transfer rules for<br>
them. Indeed, some of the transfer rules that are used in my application do<br>
not seem to be entirely trivial to prove. It would also be useful to be<br>
able to generate definitions automatically. However, the aforementioned<br>
examples do not elaborate on how this can be done. I would appreciate if<br>
someone with experience in using 'types to sets' could provide an example<br>
of an application of the automation to the lines 27-103 in the theory<br>
T2_Spaces.thy.</p>
</li>
<li>
<p>At the moment I am in the process of the relativisation of several<br>
theorems about topological spaces in HOL (e.g. results in<br>
Analysis/Topology_Euclidean_Space). However, I am curious to know if<br>
the main results about topological spaces have already been relativised<br>
somewhere. If not, are there any plans to do it in the context of the<br>
official development of HOL. I find it rather odd that the relativised<br>
versions of theorems about topological spaces in HOL do not seem to be<br>
available anywhere in the standard distribution (unless, of course, they<br>
are and I am not being able to find them).</p>
</li>
<li>
<p>The final question is technical in nature and not directly related to<br>
"types to sets". The theory Analysis/Topology_Euclidean_Space defines the<br>
class "second_countable_topology". This class provides an explicit type<br>
sort constraint in the specification of its assumptions:</p>
</li>
</ol>
<p>class second_countable_topology = topological_space +<br>
  assumes ex_countable_subbasis:<br>
    "∃B::<em>'a::topological_space set set</em>. countable B ∧ open =<br>
generate_topology B"</p>
<p>This seems to cause a problem when using "class.second_countable_topology"<br>
as an explicit predicate. For example, anecdotally, it is possible to prove</p>
<p>definition "Sorgenfrey_Basis_ll = {x. x ∈ {x::real set. ∃a b. x = {a..&lt;b}}}"<br>
definition "Sorgenfrey_Line_ll = generate_topology Sorgenfrey_Basis_ll"</p>
<p>interpretation real : second_countable_topology "Sorgenfrey_Line_ll"<br>
  sorry</p>
<p>because the goal of the interpretation unfolds to 'class.topological_space<br>
Sorgenfrey_Line_ll ∧ class.second_countable_topology_axioms <em>TYPE(real)</em>'</p>
<p>The same issue causes problems for other use cases of the<br>
"class.second_countable_topology" as an explicit predicate (e.g. in the<br>
specification of the transfer rules for a relativised definition following<br>
the methodology in the example T2_Spaces.thy). Thus, I would like to<br>
understand if there is any method that one can use to resolve the issue and<br>
ensure that the "class.second_countable_topology" can be used as an<br>
explicit predicate with the 'intended' meaning of 'open'.</p>
<p>Thank you</p>



<a name="294748897"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294748897" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294748897">(Aug 22 2022 at 18:57)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
As it happens, I have been porting large sections of the HOL Light metric space library, which includes many results about topological spaces relativized to explicit topologies (as opposed to the topological_space type class). I have gradually been transferring these results into the Analysis library, where they will become visible in the development version of Isabelle and ultimately in the next release.</p>
<p>I’m interested in the “types to sets” mechanism, but I have never been able to figure it out.</p>
<p>Larry Paulson</p>



<a name="294748912"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294748912" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294748912">(Aug 22 2022 at 18:57)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Here is the initial NEWS entry from Isabelle2016-1 (December 2016):</p>
<ul>
<li>Session HOL-Types_To_Sets provides an experimental extension of<br>
Higher-Order Logic to allow translation of types to sets.</li>
</ul>
<p>That was the proof-of-concept implementation from the ITP2016 paper by<br>
Ondrej Kuncar and Andrei Popescu.</p>
<p>There was still quite a lot missing for production quality. Already in<br>
summer 2016 I had sent a many concrete hints to the authors to improve<br>
the implementation, but hardly anything has happened since then.</p>
<p>More recently, Fabian Immler has polished this preliminary version a<br>
bit, see NEWS in Isabelle2018 (August 2018):</p>
<ul>
<li>Session HOL-Types_To_Sets: more tool support (unoverload_type combines<br>
internalize_sorts and unoverload) and larger experimental application<br>
(type based linear algebra transferred to linear algebra on subspaces).<p>Makarius</p>
</li>
</ul>



<a name="294748938"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294748938" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294748938">(Aug 22 2022 at 18:57)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Many thanks. I hope it will be usable soon, though I’m not sure whether it will ever replace large-scale porting efforts such as the one I’m engaged in (as opposed to allowing one-off instantiations of important theorems within proofs).</p>
<p>Larry</p>



<a name="294748966"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294748966" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294748966">(Aug 22 2022 at 18:57)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear Professor Lawrence Paulson,</p>
<p>Thank you for your reply. If possible, I would like to understand if the<br>
development work that you are referring to is related to the type<br>
'topology' (line 19 in the theory Analysis/Abstract_Topology.thy in the<br>
development version of Isabelle). In this case, of course, I am familiar<br>
with some of the content of the theories that are related to this type.<br>
Indeed, my intention is to use "types to sets" as an interface between the<br>
type class 'topological_space' (and its subclasses) and the type 'topology'.</p>
<p>As a side note, I would like to clarify for anyone else who might wish to<br>
provide any comments in relation to my original query that in Question 3 in<br>
my email I am referring specifically to the relativisation of the results<br>
about the type class 'topological_spaces' (and its subclasses) using the<br>
methodology associated with "types to sets" (nevertheless, of course, any<br>
further comments about similar developments are highly appreciated). Thus,<br>
to be more specific, I would like to understand if anyone is using "types<br>
to sets" for the relativisation of the results about the type class<br>
'topological_spaces' (and its subclasses) to sets.</p>
<p>Thank you</p>



<a name="294748976"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294748976" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294748976">(Aug 22 2022 at 18:57)</a>:</h4>
<p>From: Fabian Immler &lt;<a href="mailto:immler@in.tum.de">immler@in.tum.de</a>&gt;<br>
I am not using it, but I would like to use "types to sets" at some point <br>
for the purpose of relativizing topological results.</p>
<p>Just recently (isabelle/ab5a8a2519b0), I added some more tooling towards <br>
this goal: automatically defining unoverloaded constants from overloaded <br>
definitions. A "print_theorems" after the unoverload_definition command <br>
in src/HOL/Types_To_Sets/Examples/Unoverload_Def.thy should give an <br>
intuition about what it is supposed to achieve.</p>
<p>Best regards,<br>
Fabian<br>
<a href="/user_uploads/14278/HIgOdz4RE1O5naH7MvsJx6bc/smime.p7s">smime.p7s</a></p>



<a name="294749041"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294749041" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294749041">(Aug 22 2022 at 18:58)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear Fabian Immler,</p>
<p>Thank you for your reply.</p>
<p>Unfortunately, I did not update the repository immediately before asking<br>
the question and it was several days out of date. Thus, I was not aware of<br>
your work on 'unoverload_definition'. Indeed, the functionality that is<br>
provided by this tool is very useful and partially answers Question 2 from<br>
my original query. Also, I look forward to seeing your version of the<br>
relativised results about the topological spaces in HOL.</p>
<p>To complete my understanding of the current status of the development of<br>
"types to sets" (from the 'user' perspective), I would like to know if, at<br>
the moment, it is necessary to prove the transfer rules for each definition<br>
manually. It seems that for some definitions the goals for the transfer<br>
rules are not trivial to prove automatically, i.e. it seems to be necessary<br>
to use a substantial amount of code for such proofs (although, indeed, all<br>
proofs follow a very similar outline). Perhaps, I am not familiar enough<br>
with the methods that one would normally use for such proofs. For example,<br>
the only method that I know that can be used to prove</p>
<p>inductive generate_topology_on :: "'a set set ⇒ 'a set ⇒ 'a set ⇒ bool"<br>
  for S :: "'a set set"<br>
  where<br>
    UNIV: "generate_topology_on S A A"<br>
  | Int: "generate_topology_on S A (a ∩ b)"<br>
  if "generate_topology_on S A a" and "generate_topology_on S A b" and<br>
    "a ⊆ A" and "b ⊆ A"<br>
  | UN: "generate_topology_on S A (⋃K)"<br>
    if "(⋀k. k ∈ K ⟹ k ⊆ A ⟹ generate_topology_on S A k)"<br>
  | Basis: "generate_topology_on S A s" if "s ∈ S" and "s ⊆ A"</p>
<p>lemma [transfer_rule]:<br>
  includes lifting_syntax<br>
  assumes [transfer_rule]: "right_total T" "bi_unique T"<br>
  shows<br>
    "((rel_set (rel_set T)) ===&gt; (rel_set T ===&gt; (=)))<br>
    (λB. generate_topology_on B (Collect (Domainp T))) generate_topology"</p>
<p>is induction used explicitly in both directions. The resulting proof is<br>
over one hundred lines long. Therefore, it seems that the required effort<br>
is not reasonable for something that should be possible to automate. Even<br>
partial advice on either one of the queries in this paragraph will be<br>
highly appreciated.</p>
<p>Thank you</p>



<a name="294749330"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294749330" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294749330">(Aug 22 2022 at 19:00)</a>:</h4>
<p>From: Fabian Immler &lt;<a href="mailto:immler@in.tum.de">immler@in.tum.de</a>&gt;<br>
Hi  ,</p>
<p>On 1/21/2019 5:59 PM, mailing-list anonymous wrote:</p>
<blockquote>
<p>To complete my understanding of the current status of the development of<br>
"types to sets" (from the 'user' perspective), I would like to know if, at<br>
the moment, it is necessary to prove the transfer rules for each definition<br>
manually.<br>
In a way, yes. At the moment, you need to state the transfer rule for <br>
each of your constants manually. For plain definitions, the method <br>
"transfer_prover" will automatically prove those rules.</p>
</blockquote>
<p>For definitions that involve e.g., choice, the situation is not so <br>
clear. I guess it usually helps to define a similar constant that <br>
defaults to a parametric value when the choice is non-unique.<br>
See for example the definition of sum_with:<br>
<a href="http://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Types_To_Sets/Examples/Group_On_With.thy#l290">http://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Types_To_Sets/Examples/Group_On_With.thy#l290</a></p>
<blockquote>
<p>It seems that for some definitions the goals for the transfer<br>
rules are not trivial to prove automatically, i.e. it seems to be necessary<br>
to use a substantial amount of code for such proofs (although, indeed, all<br>
proofs follow a very similar outline). Perhaps, I am not familiar enough<br>
with the methods that one would normally use for such proofs. For example,<br>
the only method that I know that can be used to prove</p>
<p>inductive generate_topology_on :: "'a set set ⇒ 'a set ⇒ 'a set ⇒ bool"<br>
   for S :: "'a set set"<br>
   where<br>
     UNIV: "generate_topology_on S A A"<br>
   | Int: "generate_topology_on S A (a ∩ b)"<br>
   if "generate_topology_on S A a" and "generate_topology_on S A b" and<br>
     "a ⊆ A" and "b ⊆ A"<br>
   | UN: "generate_topology_on S A (⋃K)"<br>
     if "(⋀k. k ∈ K ⟹ k ⊆ A ⟹ generate_topology_on S A k)"<br>
   | Basis: "generate_topology_on S A s" if "s ∈ S" and "s ⊆ A"</p>
<p>lemma [transfer_rule]:<br>
   includes lifting_syntax<br>
   assumes [transfer_rule]: "right_total T" "bi_unique T"<br>
   shows<br>
     "((rel_set (rel_set T)) ===&gt; (rel_set T ===&gt; (=)))<br>
     (λB. generate_topology_on B (Collect (Domainp T))) generate_topology"</p>
<p>is induction used explicitly in both directions.<br>
Another option might be to prove transfer rules for lfp (like in the <br>
attached Scratch.thy). It looks like the named theorems collection <br>
"nitpick_unfold" contains definitions of inductive predicates in terms <br>
of lfp (I am not sure where they come from, though). It could be that <br>
this helps to carry out the proof without induction and in a more <br>
principled way.</p>
</blockquote>
<p>Fabian<br>
<a href="/user_uploads/14278/rS4L6nHrlaif588hL2rUd7gf/Scratch.thy">Scratch.thy</a><br>
<a href="/user_uploads/14278/4Tmgv4EjE3UpaYhIc1HfzHYp/smime.p7s">smime.p7s</a></p>



<a name="294749347"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294749347" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294749347">(Aug 22 2022 at 19:00)</a>:</h4>
<p>From: Fabian Immler &lt;<a href="mailto:immler@in.tum.de">immler@in.tum.de</a>&gt;<br>
Are you sure that this is the definition that you want?<br>
Every set that is not a subset of the "carrier" A is in the topology:<br>
lemma "generate_topology_on S A B" if "¬B ⊆ A"<br>
   using UN[of "{B}" A S] that<br>
   by simp</p>
<p>This probably won't play nicely with the topology type in <br>
Abstract_Topology, which assumes that the carrier is the union of all <br>
members of the topology.</p>
<p>Fabian<br>
<a href="/user_uploads/14278/CqBgYa2s8GR_dXq0NKBTDogI/smime.p7s">smime.p7s</a></p>



<a name="294749364"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294749364" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294749364">(Aug 22 2022 at 19:00)</a>:</h4>
<p>From: Fabian Immler &lt;<a href="mailto:immler@in.tum.de">immler@in.tum.de</a>&gt;<br>
This does indeed lead to strange effects. I removed the sort constraint <br>
in isabelle/7aafd0472661.</p>
<p>Fabian<br>
<a href="/user_uploads/14278/yzlJmv5Tun4UlblOWgqZ0a67/smime.p7s">smime.p7s</a></p>



<a name="294749386"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294749386" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294749386">(Aug 22 2022 at 19:00)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear Fabian Immler/All,</p>
<p>Thank you for your replies.</p>
<p>At the moment, you need to state the transfer rule for</p>
<blockquote>
<p>each of your constants manually. For plain definitions, the method<br>
"transfer_prover" will automatically prove those rules.<br>
</p>
</blockquote>
<p>Thank you for clarifying this. I believe that the comment "The<br>
aforementioned development can be automated. The main part is already<br>
automated by the transfer_prover." that could be found in some of the<br>
examples in HOL/Types_To_Sets/Examples is slightly confusing. Initially, I<br>
misinterpreted the comment "The aforementioned development can be<br>
automated" as an indication that the functionality for automation was<br>
already implemented in the context of the development of "types to sets",<br>
but the examples do not show how this functionality can be used.</p>
<p>Another option might be to prove transfer rules for lfp (like in the</p>
<blockquote>
<p>attached Scratch.thy). It looks like the named theorems collection<br>
"nitpick_unfold" contains definitions of inductive predicates in terms<br>
of lfp (I am not sure where they come from, though). It could be that<br>
this helps to carry out the proof without induction and in a more<br>
principled way.<br>
</p>
</blockquote>
<p>Indeed, I suspected that my proof is naive. Also, thank you for pointing<br>
out the existence of nitpick_unfold. I can foresee that the theorems from<br>
this collection may be useful for other purposes.</p>
<blockquote>
<p>Are you sure that this is the definition that you want?<br>
Every set that is not a subset of the "carrier" A is in the topology:<br>
lemma "generate_topology_on S A B" if "¬B ⊆ A"<br>
  using UN[of "{B}" A S] that<br>
  by simp</p>
<p>This probably won't play nicely with the topology type in<br>
Abstract_Topology, which assumes that the carrier is the union of all<br>
members of the topology.<br>
</p>
</blockquote>
<p>Thank you for pointing out this 'impurity' in the definition. However, of<br>
course, it was very easy to correct:</p>
<p>inductive generate_topology_on :: "'a set set ⇒ 'a set ⇒ 'a set ⇒ bool"<br>
  for S :: "'a set set"<br>
  where<br>
    UNIV: "generate_topology_on S A A"<br>
  | Int: "generate_topology_on S A (a ∩ b)"<br>
  if "generate_topology_on S A a" and "generate_topology_on S A b" and<br>
    "a ⊆ A" and "b ⊆ A"<br>
  | UN: "generate_topology_on S A (⋃K)"<br>
  if "K ⊆ Pow A" and "(⋀k. k ∈ K ⟹ generate_topology_on S A k)"<br>
  | Basis: "generate_topology_on S A s" if "s ∈ S" and "s ⊆ A"</p>
<p>lemma "generate_topology_on S A B ⟹ B ⊆ A"<br>
  by (induction rule: generate_topology_on.induct) auto</p>
<p>The issue was left unnoticed because I have not yet used the definition in<br>
the context of the results about the type 'topology'. Thus far, it did not<br>
cause any problems because the definition topological_space_on_with_def<br>
from HOL/Types_To_Sets/Examples/T2_Spaces does not impose any restrictions<br>
on the sets for which O holds true, provided that these sets are not<br>
elements of the power set of A, e.g.</p>
<p>lemma "topological_space_on_with A (λx. x ∈ {{}, A} ∨ x = UNIV)"<br>
  unfolding topological_space_on_with_def by blast</p>
<p>In my own relativised theorems I restrict the statements to the carrier set<br>
explicitly (following the outline presented in<br>
HOL/Types_To_Sets/Examples/T2_Spaces), e.g.</p>
<p>lemma topological_basis_imp_subbasis_rel:<br>
  fixes "open" and B and A and S<br>
  assumes "topological_space_on_with A open"<br>
    and "B ⊆ Pow A"<br>
    and "topological_basis_on_with A open B"<br>
    and "S ⊆ A"<br>
  shows "open S = generate_topology_on B A S"</p>
<p>However, I wonder if some of the statements of the relativised theorems<br>
could be simplified further if the definition topological_space_on_with<br>
could guarantee that all open sets are in the power set of the carrier.</p>
<p>There is yet another minor issue that I would like to mention in the<br>
context of the present discussion. The theorem compact_imp_closed_set_based<br>
from the example HOL/Types_To_Sets/Examples/T2_Spaces is stated under the<br>
assumption that the set A is not empty, i.e.</p>
<p>lemma compact_imp_closed_set_based:<br>
  assumes "(A::'a set) ≠ {}"<br>
  shows "∀open. t2_space_on_with A open ⟶ (∀S⊆A. compact_on_with A open S ⟶<br>
    closed_on_with A open S)"</p>
<p>However, the assumption "(A::'a set) ≠ {}" is redundant:</p>
<p>lemma compact_imp_closed_set_based_with_empty:<br>
  "∀open. t2_space_on_with A open ⟶<br>
  (∀S⊆A. compact_on_with A open S ⟶ closed_on_with A open S)"<br>
proof(cases "A={}")<br>
  case True then show ?thesis<br>
    unfolding<br>
      t2_space_on_with_def<br>
      compact_on_with_def<br>
      closed_on_with_def<br>
      topological_space_on_with_def<br>
    by simp<br>
next<br>
  case False then show ?thesis by (rule compact_imp_closed_set_based)<br>
qed</p>
<p>In fact, many other relativised results about topological spaces hold even<br>
if the carrier set is empty (e.g. see topological_basis_imp_subbasis_rel<br>
above). In my view, it would be useful to mention this in the example<br>
HOL/Types_To_Sets/Examples/T2_Spaces.</p>
<p>In conclusion, Questions 1 - 3 from my original query have now been<br>
answered in full. Most certainly, it would be nice to see the 'official'<br>
version of the relativised results about the topological spaces sooner<br>
rather than later.</p>
<p>As a side note, I am still not certain as to whether there is a way to<br>
interpret a type as a second_countable_topology (Question 4) with an<br>
alternative predicate for 'open'. Of course, this issue is nearly<br>
orthogonal to the main line of the inquiry.</p>
<p>Thank you</p>



<a name="294749391"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294749391" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294749391">(Aug 22 2022 at 19:00)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear All,</p>
<p>I would like to apologise for making the remark "As a side note, I am still<br>
not certain as to whether there is a way to interpret a type as a<br>
second_countable_topology (Question 4) with an alternative predicate for<br>
'open'." in my last email.</p>
<p>The issue was resolved by Fabian Immler earlier today (<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00074.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00074.html</a>)</p>
<ul>
<li>thank you.</li>
</ul>
<p>Therefore, all questions from my original inquiry were answered and I would<br>
like to propose to close this topic. Of course, if anyone has anything to<br>
add, I will appreciate further comments.</p>
<p>Thank you</p>



<a name="294749485"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Several%20questions%20in%20relation%20to%20a%20use%20case%20fo.../near/294749485" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Several.20questions.20in.20relation.20to.20a.20use.20case.20fo.2E.2E.2E.html#294749485">(Aug 22 2022 at 19:01)</a>:</h4>
<p>From: "Thiemann, René" &lt;<a href="mailto:Rene.Thiemann@uibk.ac.at">Rene.Thiemann@uibk.ac.at</a>&gt;<br>
As far as I know, proving these transfer rules explicitly has to be done manually,<br>
though they are often easy to prove. The final deletion of the types via types-to-sets<br>
is usually only a small last step that needs to be done. Therefore, I my opinion the<br>
description in the initial Types-to-Sets paper is misleading as it, which indicates<br>
a lot more automation.</p>
<p>I can further provide you with two developments where transfer + types-to-sets has been used<br>
and can answer you questions on these developments. In both applications, we proved transfer<br>
rules manually!</p>
<ul>
<li>
<p>In AFP/Berlekamp_Zassenhaus there is quite a simple application of types-to-sets:<br>
  prime-fields are modeled via types first, and later on several algorithms that<br>
  work on types are basically copied to a setting where the prime is a term.<br>
  A description is available at <a href="https://dl.acm.org/citation.cfm?doid=3018610.3018617">https://dl.acm.org/citation.cfm?doid=3018610.3018617</a><br>
  and you can contact me personally for an extended (submitted) journal version.</p>
</li>
<li>
<p>In AFP/Perron_Frobenius there is a more involved setup where the type-based<br>
  Brouwer’s fixpoint theorem has been converted into a set-based version,<br>
  and where the HOL-Analysis vectors/matrices are connected to the ones in AFP/Jordan_Normal_Form.<br>
  The corresponding description is at <a href="https://dl.acm.org/citation.cfm?doid=3176245.3167103">https://dl.acm.org/citation.cfm?doid=3176245.3167103</a></p>
</li>
</ul>
<p>Maybe, these examples are of interest.<br>
Cheers,<br>
René<br>
<a href="/user_uploads/14278/Dh74HCJk4Xwc9MBDJ-zUZCAY/signature.asc">signature.asc</a></p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>