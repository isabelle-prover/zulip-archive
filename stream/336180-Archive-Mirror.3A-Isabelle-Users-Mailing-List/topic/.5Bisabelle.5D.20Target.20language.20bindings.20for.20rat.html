<html>
<head><meta charset="utf-8"><title>[isabelle] Target language bindings for rat · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html">[isabelle] Target language bindings for rat</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294660615"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660615" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660615">(Aug 22 2022 at 12:02)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear all,</p>
<p>I am looking for bindings of rational numbers to the target languages of the code <br>
generator. Has anyone done something in this direction? E.g., something analogous to <br>
Code_Numeral.integer and Code_Target_Int.thy?</p>
<p>Haskell and OCaml support arbitrary-precision rational numbers in their libraries <br>
(Rational and Num.num) and there is a library for Scala (<a href="https://github.com/non/spire">https://github.com/non/spire</a>), <br>
but I have not found anything for SML. Does anyone know of such a library for SML?</p>
<p>Best,<br>
Andreas</p>



<a name="294660659"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660659" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660659">(Aug 22 2022 at 12:03)</a>:</h4>
<p>From: Wenda Li &lt;<a href="mailto:wl302@cam.ac.uk">wl302@cam.ac.uk</a>&gt;<br>
Hi Andreas,</p>
<p>As far as I know, src/Tools/rat.ML is an implementation of rational <br>
number in Isabelle/ML and MetiTarski <br>
(<a href="https://bitbucket.org/lcpaulson/metitarski/src">https://bitbucket.org/lcpaulson/metitarski/src</a>) uses another <br>
implementation that is inherited from John Harrison somehow.</p>
<p>I have considered this question before, but considering there is no <br>
standard implementation of rational number in the standard PolyML <br>
library, I thought it is risky to do such binding...</p>
<p>Hope this helps,<br>
Wenda</p>



<a name="294660668"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660668" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660668">(Aug 22 2022 at 12:03)</a>:</h4>
<p>From: Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;<br>
There is an implementation used in HOL4 at</p>
<p><a href="https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/portableML/Arbrat.{sig,sml}">https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/portableML/Arbrat.{sig,sml}</a></p>
<p>Michael</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294660724"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660724" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660724">(Aug 22 2022 at 12:03)</a>:</h4>
<p>From: "W. Douglas Maurer" &lt;<a href="mailto:maurer@email.gwu.edu">maurer@email.gwu.edu</a>&gt;<br>
The main problem with standard treatments of rational numbers, as I see it, is: how often do you reduce to lowest terms? For example: (1/3+1/6)+1/2 -- do you reduce 1/3+1/6 to 1/2 immediately, and then add 1/2 to get 2/2, reducing to 1? Or do you leave 1/3+1/6 as 9/18 and then add 1/2 to get 36/36, reducing only at the end? The problem is that reducing to lowest terms is slow, in the worst case. You can ask the user when to reduce, potentially saving time, but would users necessarily know the best times to reduce? Is anyone aware of a good general solution to this problem? -WDMaurer</p>
<p>Sent from my iPhone</p>



<a name="294660733"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660733" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660733">(Aug 22 2022 at 12:03)</a>:</h4>
<p>From: Lochbihler  Andreas &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Wenda, Michael and Mr. Douglas Maurer,</p>
<p>Thanks for your input.</p>
<p>The libraries for rational numbers in Isabelle and HOL4 are very similar, so I guess that it makes sense to add binding to Isabelle's implementation in the Eval target of the code generator (because Eval runs in the namespace of Isabelle, so everything is available. I still have to check whether this improves evaluation times at all (compared to using Code_Target_Int), because the code in rat.ML is in principle quite similar to what would be executed if we use the existing code setup for rat.</p>
<p>Meanwhile, I have started to setup bindings to Haskell and OCaml, and there I noticed a nice speedup (ca. 3X for Haskell and 10X for OCaml) over the existing setup for rat with Code_Target_Int in place.</p>
<p>As for the normalisation business, the current setup always reduces rational numbers to lowest terms. This is also what happens in the implementations in rat.ML and in HOL4. The Haskell standard library also does that (<a href="http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Real.html#line-372">http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Real.html#line-372</a>). In OCaml's library Num, the user can set a flag whether rationals should be kept in lowest terms. It seems as if this is set to false by default. The Spire library for Scala also always reduces rationals (<a href="https://github.com/non/spire/blob/32345c24a598369388763abf7e5aed8621af1d15/core/shared/src/main/scala/spire/math/Rational.scala#L377">https://github.com/non/spire/blob/32345c24a598369388763abf7e5aed8621af1d15/core/shared/src/main/scala/spire/math/Rational.scala#L377</a>).</p>
<p>For the target language bindings, we do not have to commit to any strategy, as long as the rationals are only manipulated by the target language library. Only when we convert them back into nominator and denominator in Isabelle, normalisation makes a difference. And it seems as if in this case (I guess a rather rare case) we can normalise if necessary.</p>
<p>Best,<br>
Andreas</p>



<a name="294660751"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660751" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660751">(Aug 22 2022 at 12:03)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;<br>
My own, perhaps somewhat naïve, thoughts on this: What is the advantage<br>
of using target-language rats? Are they really faster than the code that<br>
Isabelle produces?</p>
<p>Intuitively, I would think that the basic operations on rational numbers<br>
translate to operations on integers very clearly and obviously and that<br>
there is not much room for creativity – except for the question of if<br>
and when to reduce the numerator and denominator.</p>
<p>A FFI-based implementation using the GNU Multiple Precision Arithmetic<br>
Library (GMP) might be faster because it reduces overhead, but even<br>
Haskell (which uses GMP for its integers) does not do that and relies on<br>
‘pure’ rational numbers implemented as a datatype instead.</p>
<p>On the question of normalisation, let me remark that the GMP always<br>
assumes that rats are in canonical form and also brings all results into<br>
canonical form, and the GMP people generally seem know their stuff, so<br>
this is probably a good idea. (I think they also offer ‘raw’ functions<br>
without this normalisation though)</p>
<p>Cheers,</p>
<p>Manuel</p>



<a name="294660767"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660767" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660767">(Aug 22 2022 at 12:03)</a>:</h4>
<p>From: Manuel Eberl &lt;<a href="mailto:eberlm@in.tum.de">eberlm@in.tum.de</a>&gt;<br>
the existing setup for rat with Code_Target_Int in place.</p>
<p>I find that a bit surprising, considering how rats are implemented in<br>
Haskell. One possible explanation that I have is that perhaps the<br>
exported code uses Isabelle's GCD operation on natural numbers, whereas<br>
the Haskell version uses the GCD operation that GMP provides, and which<br>
is probably much faster.</p>
<p>Another possible reason is perhaps some issue with lazyness; Haskell's<br>
"Ratio" datatype is declared with strict fields, whereas Isabelle<br>
probably declares "rat" with the lazy fields. Perhaps this can cause<br>
large unevaluated chunks to hang around longer than they should?</p>
<p>However, the fact that the difference is even more pronounced in OCaml<br>
seems to speak against that. I don't know the OCaml implementation, so I<br>
don't know if the GCD thing might also be an explanation there.</p>



<a name="294660788"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660788" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660788">(Aug 22 2022 at 12:03)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Hi Manuel,</p>
<p>On 18/12/15 09:29, Manuel Eberl wrote:</p>
<blockquote>
<p>On 18/12/15 09:01, Lochbihler Andreas wrote:</p>
<blockquote>
<p>I noticed a nice speedup (ca. 3X for Haskell and 10X for OCaml) over<br>
the existing setup for rat with Code_Target_Int in place.</p>
</blockquote>
<p>I find that a bit surprising, considering how rats are implemented in<br>
Haskell. One possible explanation that I have is that perhaps the<br>
exported code uses Isabelle's GCD operation on natural numbers, whereas<br>
the Haskell version uses the GCD operation that GMP provides, and which<br>
is probably much faster.<br>
Your guess seems to be right. If I serialise the gcd operation on integer to the target <br>
language implementation, the differences almost vanish.</p>
</blockquote>
<blockquote>
<p>Another possible reason is perhaps some issue with lazyness; Haskell's<br>
"Ratio" datatype is declared with strict fields, whereas Isabelle<br>
probably declares "rat" with the lazy fields. Perhaps this can cause<br>
large unevaluated chunks to hang around longer than they should?</p>
<p>However, the fact that the difference is even more pronounced in OCaml<br>
seems to speak against that. I don't know the OCaml implementation, so I<br>
don't know if the GCD thing might also be an explanation there.</p>
<p>It is.</p>
</blockquote>
<p>Thanks,<br>
Andreas</p>



<a name="294660845"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660845" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660845">(Aug 22 2022 at 12:04)</a>:</h4>
<p>From: Jose Divasón &lt;<a href="mailto:jose.divasonm@unirioja.es">jose.divasonm@unirioja.es</a>&gt;<br>
Dear all,</p>
<p>in my AFP about the Gauss-Jordan algorithm I worked with rational matrices,<br>
so I serialised the rational numbers from Isabelle to Haskell, see:<br>
<a href="http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Rational.html">http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Rational.html</a></p>
<p>For exporting code to SML, I just used the file Code_Target_Int together<br>
with serialisations from gcd to PolyML.IntInf.gcd and MLton.IntInf.gcd (as<br>
far as I know, there is no gcd implementation in the standard library). I<br>
also serialised the operations div and mod, see<br>
<a href="http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Generation_IArrays_SML.html">http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Generation_IArrays_SML.html</a>.<br>
Without such GCD serialisations, i.e. only using Code_Target_Int, times<br>
were 20 times slower in my case.</p>
<p>Best,<br>
Jose</p>



<a name="294660910"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660910" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660910">(Aug 22 2022 at 12:04)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Jose,</p>
<p>Did you measure how much you gained from serialising rat to Haskell's Rational type <br>
(compared with using Code_Target_Int plus an appropriate setup to implement gcd on integer <br>
and int with Prelude.gcd)? In my quick experiment this morning, I could not see a <br>
significant speed-up.</p>
<p>I was also a bit surprised by your comparison of serialisation options for divmod_integer <br>
in Code_Generation_IArrays_SML. In SML, quotRem and divMod behave differently when it <br>
comes to negative numbers. In that respect, quotRem is the wrong choice. For example,<br>
quotRem (~10, 6) evaluates to (~4, ~6) and divMod (~10, 6) to (~2, 2). In Isabelle/HOL,<br>
value [nbe] "divmod_integer (-10, 6)" gives (-2, 2). So the generated code may actually <br>
return a different result than what you have proved. (I do not know whether such negative <br>
numbers can occur in your application).</p>
<p>Given that the generated ML code should work for all ML systems, I think we cannot take <br>
the serialisations of gcd into the distribution by default.</p>
<p>Best,<br>
Andreas</p>



<a name="294660933"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660933" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660933">(Aug 22 2022 at 12:04)</a>:</h4>
<p>From: Jose Divasón &lt;<a href="mailto:jose.divasonm@unirioja.es">jose.divasonm@unirioja.es</a>&gt;<br>
Dear Andreas,</p>
<p>Did you measure how much you gained from serialising rat to Haskell's</p>
<blockquote>
<p>Rational type (compared with using Code_Target_Int plus an appropriate<br>
setup to implement gcd on integer and int with Prelude.gcd)? In my quick<br>
experiment this morning, I could not see a significant speed-up.<br>
</p>
</blockquote>
<p>Yes, I did. I also carried out quick experiments and noticed more or less<br>
the same as you: Haskell's Rational type was just a little bit faster,<br>
almost insignificant.</p>
<blockquote>
<p>I was also a bit surprised by your comparison of serialisation options for<br>
divmod_integer in Code_Generation_IArrays_SML. In SML, quotRem and divMod<br>
behave differently when it comes to negative numbers. In that respect,<br>
quotRem is the wrong choice. For example,<br>
quotRem (~10, 6) evaluates to (~4, ~6) and divMod (~10, 6) to (~2, 2). In<br>
Isabelle/HOL,<br>
value [nbe] "divmod_integer (-10, 6)" gives (-2, 2). So the generated code<br>
may actually return a different result than what you have proved. (I do not<br>
know whether such negative numbers can occur in your application).<br>
</p>
</blockquote>
<p>Good point, let me take a glance at it.</p>
<blockquote>
<p>Given that the generated ML code should work for all ML systems, I think<br>
we cannot take the serialisations of gcd into the distribution by default.<br>
</p>
</blockquote>
<p>Yes, you are completely right. Each time I exported code, I had to decide<br>
which serialisation was going to be used depending on the ML interpreter.</p>
<p>Best,<br>
Jose</p>



<a name="294660938"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660938" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660938">(Aug 22 2022 at 12:04)</a>:</h4>
<p>From: Jose Divasón &lt;<a href="mailto:jose.divasonm@unirioja.es">jose.divasonm@unirioja.es</a>&gt;<br>
I think it works for my concrete case (integer numbers are only used for<br>
representing rational numbers), however for a general integer manipulation<br>
this is not a correct serialisation.</p>
<p>In my exported code, quot is only used when nomalising rational numbers (by<br>
means of the Rat.normalise definition). If I am not wrong, for such a<br>
function it is the same using "div" as using "quot".</p>
<p>So, "-20 div 6" would return different results (as expected), but normalize<br>
(-20,6) the same:</p>
<p>code_printing<br>
constant "op div :: integer =&gt; _ =&gt; _" ⇀ (SML) "(IntInf.div ((_), (_)))"<br>
| constant "op mod :: integer =&gt; _ =&gt; _" ⇀ (SML) "(IntInf.mod ((_), (_)))"</p>
<p>value[code] "-20 div 6::int" (<em>Result: - 4</em>)<br>
value[code] "Rat.normalize (-20,6)" (<em>Result: (-10,3) :: "int × int"</em>)</p>
<p>code_printing<br>
constant "op div :: integer =&gt; _ =&gt; _" ⇀ (SML) "(IntInf.quot ((_), (_)))"<br>
| constant "op mod :: integer =&gt; _ =&gt; _" ⇀ (SML) "(IntInf.rem ((_), (_)))"</p>
<p>value[code] "-20 div 6::int" (<em>Result: - 3 :: "int"</em>)<br>
value[code] "Rat.normalize (-20,6)" (<em>Result: (-10,3) :: "int × int"</em>)</p>
<p>Then, I took advantage of it and decided to use quot, since it is supposed<br>
to be faster. Nevertheless, I have to study it carefully again because<br>
maybe I am wrong.</p>
<p>Best,<br>
Jose</p>



<a name="294660956"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294660956" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294660956">(Aug 22 2022 at 12:04)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Jose,</p>
<p>Rat.normalise only divides by divisors, so the remainder is always 0 and the problem <br>
should not occur in this case.</p>
<p>Best,<br>
Andreas</p>



<a name="294661120"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Target%20language%20bindings%20for%20rat/near/294661120" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Target.20language.20bindings.20for.20rat.html#294661120">(Aug 22 2022 at 12:05)</a>:</h4>
<p>From: "Thiemann, Rene" &lt;<a href="mailto:Rene.Thiemann@uibk.ac.at">Rene.Thiemann@uibk.ac.at</a>&gt;<br>
Dear all,</p>
<p>concerning division on integers, I also observed some optimization potential, which is save in a way that<br>
it only invokes the divmod on positive numbers. At least<br>
in my application gave a significant speedup, cf.</p>
<p><a href="http://afp.sourceforge.net/browser_info/current/AFP/Algebraic_Numbers/Improved_Code_Equations.html">http://afp.sourceforge.net/browser_info/current/AFP/Algebraic_Numbers/Improved_Code_Equations.html</a></p>
<p>Cheers,<br>
René</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>