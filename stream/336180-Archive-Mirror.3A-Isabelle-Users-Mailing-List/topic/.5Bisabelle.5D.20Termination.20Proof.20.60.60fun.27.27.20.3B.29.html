<html>
<head><meta charset="utf-8"><title>[isabelle] Termination Proof ``fun&#x27;&#x27; ;) · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html">[isabelle] Termination Proof ``fun&#x27;&#x27; ;)</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294075195"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294075195" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294075195">(Aug 18 2022 at 13:16)</a>:</h4>
<p>From: Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;<br>
Scott West wrote:</p>
<p>This example, and others similar to it, are described in the paper by<br>
Slind and Owens, available from</p>
<p><a href="http://www.cs.utah.edu/~slind/papers/hosc.regexp/">http://www.cs.utah.edu/~slind/papers/hosc.regexp/</a></p>
<p>Michael.</p>



<a name="294075211"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294075211" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294075211">(Aug 18 2022 at 13:16)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Hi Scott,</p>
<p>This is nonterminating in general, unless the obj type is finite. So <br>
there can't be just a simple "measure".</p>
<p>If your application does not require the functional view (like for code <br>
generation), you best define all_children as an inductive set or <br>
predicate, which avoids all termination issues and is usually much simpler.</p>
<p>You can define partial functions in Isabelle (see the function tutorial <br>
for a small example), but this introduces explicit domain predicates and <br>
in particular prevents code generation unless your function is <br>
tail-recursive (this is how it is done in Stefan's formalization...)</p>
<p>But if you really just need all_children defined somehow, then just use <br>
"inductive"</p>
<p>Alex</p>



<a name="294075261"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294075261" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294075261">(Aug 18 2022 at 13:16)</a>:</h4>
<p>From: Stephan Merz &lt;<a href="mailto:Stephan.Merz@loria.fr">Stephan.Merz@loria.fr</a>&gt;<br>
Basically you'll have to take the complement of your set "seen" with <br>
respect to the set of reachable nodes (i.e., the transitive closure of <br>
the children function from the node "src"). And yes, you'll have to <br>
prove that transitive closure to be a finite set, otherwise the function <br>
wouldn't terminate.</p>
<p>We have recently formalized a very similar function in the context of an <br>
automaton construction for model checking, and I could send you the <br>
theories and a paper (off-list) if you are interested.</p>
<p>Regards,<br>
Stephan</p>
<p>Scott West wrote:<br>
<a href="/user_uploads/14278/O3e3Ex8w6DU675OINJXcYZTR/Stephan_Merz.vcf">Stephan_Merz.vcf</a></p>



<a name="294075271"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294075271" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294075271">(Aug 18 2022 at 13:16)</a>:</h4>
<p>From: Konrad Slind &lt;<a href="mailto:slind@cs.utah.edu">slind@cs.utah.edu</a>&gt;<br>
The termination of a similar operation (depth-first traversal)<br>
on a graph given by a function is discussed on pages 8-10<br>
of</p>
<p><a href="http://www.cs.utah.edu/~slind/papers/hosc.regexp/paper.pdf">http://www.cs.utah.edu/~slind/papers/hosc.regexp/paper.pdf</a></p>
<p>It uses a lexicographic combination of measure functions.</p>
<p>Cheers,<br>
Konrad.</p>



<a name="294077031"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294077031" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294077031">(Aug 18 2022 at 13:28)</a>:</h4>
<p>From: Scott West &lt;<a href="mailto:scott.west@inf.ethz.ch">scott.west@inf.ethz.ch</a>&gt;<br>
Hello all,</p>
<p>I have recently been trying to write a function, which Isabelle would <br>
like to know terminates. The basic task is to find reachability, but I <br>
don't have an explicit graph, I have a function which returns children <br>
of the current node.</p>
<p>So I recursively define this function to essentially be something like:</p>
<p>all_children :: obj =&gt; obj set =&gt; obj set<br>
all_children src seen =<br>
   if src \&lt;in&gt; seen<br>
     then seen<br>
     else<br>
       foldr all_children (children src) (seen \&lt;union&gt; {src})</p>
<p>I can't for the life of me figure out what the measure function should <br>
be in this case. Been thinking on it for a few days and I don't know how <br>
to state a termination proof in a way that Isabelle will understand. I <br>
should preface that by saying I only know of the "measure" method... and <br>
even then, not really well.</p>
<p>If anyone could provide some hint on how to go about this, then that <br>
would be great.</p>
<p>Regards,<br>
Scott</p>



<a name="294077045"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294077045" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294077045">(Aug 18 2022 at 13:28)</a>:</h4>
<p>From: Stefan Berghofer &lt;<a href="mailto:berghofe@in.tum.de">berghofe@in.tum.de</a>&gt;<br>
Scott West wrote:<br>
Hello Scott,</p>
<p>when defining the above function with "fun", you also have to supply<br>
a suitable congruence rule for foldr in order to be able to prove<br>
termination. However, it might actually be easier to define all_children<br>
without using foldr, i.e. by turning the first parameter into a list<br>
of objects that still have to be inspected:</p>
<p>all_children :: obj list =&gt; obj set =&gt; obj set<br>
   all_children [] seen = seen<br>
   all_children (src # srcs) seen =<br>
     if src \&lt;in&gt; seen<br>
       then all_children srcs seen<br>
       else<br>
         all_children (children src @ srcs) (seen \&lt;union&gt; {src})</p>
<p>This approach is used in the formalization of depth first search<br>
by Nishihara an Minamide, which you can find in the AFP:</p>
<p><a href="http://afp.sourceforge.net/entries/Depth-First-Search.shtml">http://afp.sourceforge.net/entries/Depth-First-Search.shtml</a></p>
<p>I recently generalized this formalization a little (using locales),<br>
allowing the user to freely choose the representation of "obj set",<br>
as well as the implementation of the children, \&lt;union&gt;, and \&lt;in&gt;<br>
operators. You can currently find the generalized version at</p>
<p><a href="http://www.in.tum.de/~berghofe/papers/automata/DFS.thy">http://www.in.tum.de/~berghofe/papers/automata/DFS.thy</a></p>
<p>For examples of how to apply this version of DFS, see</p>
<p><a href="http://www.in.tum.de/~berghofe/papers/automata/Automata.thy">http://www.in.tum.de/~berghofe/papers/automata/Automata.thy</a></p>
<p>Greetings,<br>
Stefan</p>



<a name="294077504"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294077504" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294077504">(Aug 18 2022 at 13:30)</a>:</h4>
<p>From: Scott West &lt;<a href="mailto:scott.west@inf.ethz.ch">scott.west@inf.ethz.ch</a>&gt;<br>
Hello Alex,</p>
<blockquote>
<p>Exactly! You will need to define a set "L" which contains all the nodes <br>
that can be "seen". Instead of "measures" I would prefer the use of <br>
"psubset" here.<br>
</p>
</blockquote>
<p>I'll look at psubset, thanks!</p>
<blockquote>
<p>But this is not the only problem you have here. Moreover the use of <br>
"foldr" complicates the proof. When you start your termination proof, <br>
you will notice, that there is no call of "foldr" anymore. Here the <br>
"Higher Order Recursion" <br>
(<a href="http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf">http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf</a>, chapter 9) <br>
comes into play. "foldr" is eliminated using the congruence rule <br>
'foldr_cong' (from List.thy) I think. But this rule 'abstracts' over the <br>
second argument (of f), so that you are not able state anything about it <br>
(and you will need it to proof termination). Therefore you have probably <br>
first to find the right congruence rule for 'foldr' that somehow <br>
preserves the information, that the second argument of f is always a <br>
subset of "L".</p>
</blockquote>
<p>I read the functions.pdf that you pointed me to, however I still dont' <br>
feel as if I know how the congruence mechanism works in practice. How <br>
does it <code>abstract' over the second argument of </code>f' ?</p>
<p>If I do need to reformulate the foldr_cong rule to fit my needs, are <br>
there any good examples of how these rules are applied during the proof, <br>
so I can see what's going wrong?</p>
<blockquote>
<p>Maybe it is a better idea to eliminate the use of foldr (if possible) <br>
completely.<br>
</p>
</blockquote>
<p>I do now have a version that I created without foldr that I can prove <br>
termination. However eventually I will be doing things where foldr <br>
becomes important (modeling imperative code, so the accumulated <br>
parameter will be the state). So I guess I'm going down a more difficult <br>
road ;).</p>
<p>Thanks again for the help!</p>
<p>Regards,<br>
Scott</p>



<a name="294077784"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Termination%20Proof%20%60%60fun%27%27%20%3B%29/near/294077784" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Termination.20Proof.20.60.60fun.27.27.20.3B.29.html#294077784">(Aug 18 2022 at 13:32)</a>:</h4>
<p>From: Alexander Schimpf &lt;<a href="mailto:info@hitstec.de">info@hitstec.de</a>&gt;<br>
Dear Scott,</p>
<p>Scott West schrieb:</p>
<blockquote>
<p>Hello Alex,</p>
<blockquote>
<p>Exactly! You will need to define a set "L" which contains all the <br>
nodes that can be "seen". Instead of "measures" I would prefer the <br>
use of "psubset" here.<br>
</p>
</blockquote>
<p>I'll look at psubset, thanks!</p>
<blockquote>
<p>But this is not the only problem you have here. Moreover the use of <br>
"foldr" complicates the proof. When you start your termination proof, <br>
you will notice, that there is no call of "foldr" anymore. Here the <br>
"Higher Order Recursion" <br>
(<a href="http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf">http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf</a>, chapter <br>
9) comes into play. "foldr" is eliminated using the congruence rule <br>
'foldr_cong' (from List.thy) I think. But this rule 'abstracts' over <br>
the second argument (of f), so that you are not able state anything <br>
about it (and you will need it to proof termination). Therefore you <br>
have probably first to find the right congruence rule for 'foldr' <br>
that somehow preserves the information, that the second argument of f <br>
is always a subset of "L".</p>
</blockquote>
<p>I read the functions.pdf that you pointed me to, however I still dont' <br>
feel as if I know how the congruence mechanism works in practice. How <br>
does it <code>abstract' over the second argument of </code>f' ?</p>
<p>If I do need to reformulate the foldr_cong rule to fit my needs, are <br>
there any good examples of how these rules are applied during the <br>
proof, so I can see what's going wrong?<br>
Well, I am not really sure if there are any. But I've created a small <br>
example, that I think addresses your problem. Instead of using foldr <br>
explicitly and to avoid the problems arise with congruence rules, I've <br>
just used mutual recursion <br>
(<a href="http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf">http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf</a>, Chapter 5) <br>
to achieve the same behavior. In my example (see Test.thy) the function <br>
'f' is similar to your 'all_children' function, the (abstract) function <br>
'g' is somewhat similar to your 'children' function.<br>
After the function definition is established and the completeness is <br>
proofed, the termination proof is considered, which relies on the fact, <br>
that there is an function called 'lim' which computes an upper bound for <br>
'f' (and therefore for its second argument). So far, 'lim' is not really <br>
defined in my example (that's up to you), but requires some properties <br>
to be true (for example finiteness, etc.)<br>
After that a special partial termination property (called 'subset_prop') <br>
for the function 'f' and its mutual recursive counterpart 'foldr_f' is <br>
proofed, since it is required in the termination proof. This property is <br>
important and I don't think you can get a similar property when you use <br>
'foldr' directly (but I've not verified that!)<br>
At the end the termination proof is established using a special <br>
termination ordering (called 'my_term_ord'), which is a lexicographical <br>
combination of 'finite_psubset' and the 'less_than' relation. The latter <br>
is needed since in my mutual recursive version the termination of the <br>
foldr replacement have to also to be proofed.</p>
</blockquote>
<blockquote>
<blockquote>
<p>Maybe it is a better idea to eliminate the use of foldr (if possible) <br>
completely.<br>
</p>
</blockquote>
<p>I do now have a version that I created without foldr that I can prove <br>
termination. However eventually I will be doing things where foldr <br>
becomes important (modeling imperative code, so the accumulated <br>
parameter will be the state). So I guess I'm going down a more <br>
difficult road ;).<br>
Just try using the mutual recursive version that I've suggested in the <br>
example. After finishing the termination it is probably possible to <br>
proof, that the mutual recursive (helphing) funciton 'foldr_f' is in <br>
fact (in some sense) equal to the ordinary 'foldr' function, so that it <br>
can be replaced.</p>
</blockquote>
<blockquote>
<p>Thanks again for the help!<br>
No problem, so far!</p>
</blockquote>
<p>Regards,<br>
Alex<br>
<a href="/user_uploads/14278/dn1Un-HNCnJ9nS3vxgbKL2tC/Test.thy">Test.thy</a></p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>