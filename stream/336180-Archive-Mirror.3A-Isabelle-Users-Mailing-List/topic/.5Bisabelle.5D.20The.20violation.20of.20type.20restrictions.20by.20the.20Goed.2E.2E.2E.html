<html>
<head><meta charset="utf-8"><title>[isabelle] The violation of type restrictions by the Goed... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20The.20violation.20of.20type.20restrictions.20by.20the.20Goed.2E.2E.2E.html">[isabelle] The violation of type restrictions by the Goed...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294664302"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20The%20violation%20of%20type%20restrictions%20by%20the%20Goed.../near/294664302" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20The.20violation.20of.20type.20restrictions.20by.20the.20Goed.2E.2E.2E.html#294664302">(Aug 22 2022 at 12:25)</a>:</h4>
<p>From: Ken Kubota &lt;<a href="mailto:mail@kenkubota.de">mail@kenkubota.de</a>&gt;<br>
Dear Ramana Kumar and List Members,</p>
<p>Thank you for your comment at<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00061.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00061.html</a></p>
<p>concerning my contribution available at<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00057.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00057.html</a></p>
<p>I would also like to thank other members for their comments, which have been <br>
noted. As Ramana Kumar directly addresses the crucial question, I would like to <br>
concentrate on and answer it in section 2 further below.</p>
<ol>
<li>The presentations of the proof by Andrews and Rautenberg</li>
</ol>
<p>Syntactically, of course, in Paulson's claimed theorem 'proved_iff_proved_PfP'<br>
    &gt; a  &lt;-&gt;  &gt; PfP "a"<br>
the right-hand side (PfP "a") is an object-language statement. We agree on this <br>
point.</p>
<p>I refer to the meaning ("semantically"), since I am basically trying to <br>
summarize the (incorrect) presentations of the proof by Andrews and Rautenberg, <br>
in which neither the claimed lemma 'proved_iff_proved_PfP' nor an equivalent <br>
lemma is proven, but is used as a rule implicitly or explicitly justified by <br>
its meaning; for example, in Andrews' presentation from the statement of the <br>
left-hand side (a) the statement of the right-hand side (PfP "a") is inferred <br>
while giving an informal argument only ("since the wff Proof represents the <br>
numerical relation Proof" [Andrews, 2002, p. 314 (7101)]), thus violating <br>
Andrews' own strict formal (syntactic) standards. Therefore, I previously wrote <br>
that "step 7101.4 has no syntactic justification" at<br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-July/msg00170.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-July/msg00170.html</a></p>
<p>The purpose of this passage about Andrews and Rautenberg is to show that the <br>
presentations of the proof by both of them fail, as they do not prove the <br>
claimed lemma 'proved_iff_proved_PfP' at all, although this would be a <br>
necessary step.</p>
<p>So in order to verify whether Goedel's First Incompleteness Theorem can be <br>
formally obtained, I suggest focusing on and proceeding to Paulson's <br>
presentation discussed below.</p>
<ol start="2">
<li>The presentation of the proof by Paulson</li>
</ol>
<p>Not only the right-hand side (PfP "a"), but also the left-hand side (a) is an <br>
object-language statement, which in Q0 always have type 'o' (Boolean truth <br>
values). Moreover, if the proposition 'a' has type 'o' (omicron), it cannot <br>
have a second type "tm" (for term) unless this is identical with 'o', since in <br>
Q0 all mathematical objects, including propositions (object-language <br>
statements), have exactly and only one type. It is not possible in Q0 to assign <br>
a second type to a mathematical object.</p>
<p>Furthermore, the type "tm" (for term) in Isabelle is intended for the notation, <br>
which in Q0 is not part of the object language itself. The purpose of types in <br>
Q0 is to categorize mathematical objects, but not their names. Obviously types <br>
in Isabelle are used for non-mathematical purposes also.</p>
<p>If you believe that the type "tm" (for term) is definable within Q0, you could<br>
a) negatively refute my argument that any Goedel encoding function violates <br>
type restrictions, or<br>
b) positively present the definition of type "tm" (for term) within Q0 on the <br>
basis of the primitive types 'o' (omicron, for truth values) and 'i' (iota, for <br>
individuals) only [cf. Andrews, 2002, p. 210, and Church, 1940, p. 56], as, for <br>
example, similar to nat = (o(oi)).</p>
<p>In Q0, there are two kinds of definitions:</p>
<ol>
<li>The first kind of definition are _metamathematical_ definitions in order to <br>
set up the formal language, for example</li>
</ol>
<ul>
<li>the definition of (the concept of) type symbols [cf. Andrews, 2002, p. 210] or</li>
<li>the definition of (the concept of) wffs (well-formed formulae) [cf. Andrews, <br>
2002, p. 211].<br>
Definitions of this sort are very often "defined inductively" [Andrews, 2002, <br>
pp. 210, 211], fostering metamathematical reasoning (i.e., via arithmetization) <br>
about the properties of the object language. Unlike the other kind of <br>
definition described below, they also often ramify into several possibilities, <br>
which in the literature appear as a list "(a) [...] / (b) [...] / (c) [...]" <br>
[Andrews, 2002, pp. 210, 211], and in the software implementation by Paulson as <br>
a list separated by the propositional connective for the logical relation "or", <br>
represented by the vertical bar (single pipe) '|'.</li>
</ul>
<ol start="2">
<li>The second kind of definition are _mathematical_ definitions, which do <br>
nothing more than add a shorthand (a label) to a more complex wff (well-formed <br>
formula) in order to increase readability. Typical examples are</li>
</ol>
<ul>
<li>
<p>the definitions of the propositional connectives and the universal and <br>
existential quantifiers [cf. Andrews, 2002, p. 212],</p>
</li>
<li>
<p>the definitions of subset, power set, union, etc. [cf. Andrews, 2002, p. 231],</p>
</li>
<li>the definition of the uniqueness quantifier [cf. Andrews, 2002, p. 233], and</li>
<li>the definitions of zero, the successor function, and the set of natural <br>
numbers [cf. Andrews, 2002, p. 260].<br>
All these definitions explicitly use the formulation "stands for" [Andrews, <br>
2002, pp. 212, 231, 233, 260] in order to express that they are only shorthands <br>
which can be replaced by the original wff. The single exception also implies <br>
substitution: "Let [nat] be the type symbol (o(oi))." [Andrews, 2002, p. 260]<br>
So if we discuss the definability of "tm" within Q0, the first kind of <br>
definition is out of question, since it would modify Q0, and therefore go <br>
beyond Q0 instead of remaining within.</li>
</ul>
<p>The difference between these two kinds of definition can be demonstrated best <br>
by looking at the different logical levels and comparing their implementation <br>
in R0 [cf. Kubota, 2015] and Isabelle:</p>
<p>Logical level                         R0 implementation        Isabelle</p>
<ol>
<li>definition of the formal language  C++ classes (<em>.cc)       theories (</em>.thy)</li>
<li>theorems and wff definitions       proofs (<em>.r0)            theories (</em>.thy)</li>
<li>(Hilbert-style) metatheorems       proof templates (<em>.r0t)  theories (</em>.thy)</li>
</ol>
<p>A PDF sheet is available online at:<br>
<a href="http://www.kenkubota.de/files/Logical_Layers_in_R0_and_Isabelle.pdf">http://www.kenkubota.de/files/Logical_Layers_in_R0_and_Isabelle.pdf</a></p>
<p>Since Isabelle uses natural deduction, Hilbert-style (informal) metatheorems <br>
become symbolically representable and part of the formal language itself, <br>
although within the formal language, theorems and metatheorems are still <br>
distinguished (with "Meta-logic" [Nipkow, 2015, p. 11] operators having a lower <br>
precedence than the "Logic" [Nipkow, 2015, p. 11] operators). So in Isabelle, <br>
both Hilbert-style theorems (level 2) and Hilbert-style metatheorems (level 3) <br>
are merged into the same sphere (Isabelle theory files).</p>
<p>Further, unlike the R0 implementation, which uses the concept of _direct <br>
encoding_, Isabelle provides a "logical framework; I prefer to speak of a <br>
meta-logic" [Paulson, 1988, p. 3]. Thus, even the definition of the formal <br>
language (the object language, defined in level 1), which is hard-coded in the <br>
C++ source code of the R0 implementation, in Isabelle is specified in the <br>
Isabelle theory files.</p>
<p>In summary, all three logical levels in Isabelle are merged into the same <br>
sphere (Isabelle theory files), which provides advantages for the practical <br>
purpose of automation, but also creates the danger of confusion of these <br>
different levels in the implementation.</p>
<p>The first kind of definition (_metamathematical_ definitions) such as the <br>
definition of the concept of type symbols or of the concept of wffs belongs to <br>
level 1.<br>
The second kind of definition (_mathematical_ definitions) such as the <br>
definition of propositional connectives belongs to level 2.<br>
(Note that the terms "metamathematical" or "meta-language" are, depending on <br>
the context, sometimes used for notions of level 1, sometimes for notions of <br>
level 3.)</p>
<p>For example, the definition of propositional connectives in R0 is outsourced <br>
into *.r0 proof files (level 2), but the (general) definition of the concept of <br>
type symbols and the concept of wffs as such in R0 is implemented in the C++ <br>
source code (level 1), as they modify (set up) the formal language and could <br>
not be specified at a later time (i.e., in levels 2 or 3).<br>
(Note that in the dependent type theory R0, types are also mathematical objects </p>
<ul>
<li>wffs -, and definable in level 2.)</li>
</ul>
<p>But the definition of type "tm" (for term) is exactly this kind of <br>
_metamathematical_ definition (level 1). According to Paulson at<br>
<a href="http://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-ar.pdf">http://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-ar.pdf</a> (p. 5),<br>
"[t]he following datatype defines the syntax of terms in the HF theory:</p>
<p>nominal_datatype tm = Zero | Var name | Eats tm tm</p>
<p>The type name (of variable names) has been created using the nominal framework."<br>
So both "tm" and "fm" (cf. ibid.) are actually - in terms of computer science - <br>
datatypes ("nominal_datatype"), and - in terms of mathematics - <br>
metamathematical notions or notions of the meta-language that describe <br>
("define[ ] the syntax of") the formal language (the object language) itself.</p>
<p>Paulson's implementation of the Goedel encoding function as specified at<br>
<a href="http://afp.sourceforge.net/browser_info/current/AFP/Incompleteness/Coding.html">http://afp.sourceforge.net/browser_info/current/AFP/Incompleteness/Coding.html</a><br>
maps from datatypes "tm" and "fm" to datatype "tm":<br>
"class quot =<br>
  fixes quot :: "'a =&gt; tm"  ("⌈_⌉")</p>
<p>instantiation tm :: quot<br>
begin<br>
  definition quot_tm :: "tm =&gt; tm"<br>
    where "quot_tm t = quot_dbtm (trans_tm [] t)"</p>
<p>instance ..<br>
end</p>
<p>[...]</p>
<p>instantiation fm :: quot<br>
begin<br>
  definition quot_fm :: "fm =&gt; tm"<br>
    where "quot_fm A = quot_dbfm (trans_fm [] A)"</p>
<p>instance ..<br>
end"</p>
<p>In the application of a Goedel numbering function (or Goedel encoding function) <br>
'G' to an argument 'a' as in<br>
    Ga = n<br>
according to the restrictions on lambda application (case (b) in the definition <br>
of wffs [cf. Andrews, 2002, p. 211]), 'G' must be a function with a valid <br>
mathematical input (domain) type and a valid mathematical output (codomain) <br>
type, and the input (domain) type must match the type of 'a' (which must be a <br>
concrete mathematical type symbol of level 2).</p>
<p>But "tm", "fm" and "dbtm" are clearly metamathematical notions (level 1) and <br>
not concrete mathema<br>
[message truncated]</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>