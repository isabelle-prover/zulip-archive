<html>
<head><meta charset="utf-8"><title>[isabelle] Things identified via `rewrites` not treated a... Â· Archive Mirror: Isabelle Users Mailing List Â· Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html">[isabelle] Things identified via `rewrites` not treated a...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294759422"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Things%20identified%20via%20%60rewrites%60%20not%20treated%20a.../near/294759422" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html#294759422">(Aug 22 2022 at 20:07)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
Hi!</p>
<p>In my work on formalizing process calculi I tripped over an issue with<br>
Isabelleâ€™s locale support that I donâ€™t fully understand. Iâ€™d like to<br>
illustrate this issue here with some example code that is much simpler<br>
than my actual code but still illustrates the point.</p>
<p>Letâ€™s first introduce a locale that describes an involution, which we<br>
call negation.</p>
<p>locale negation =<br>
      fixes neg :: "'a â‡’ 'a" ("âŠ– _" [81] 80)<br>
      assumes neg_neg: "âŠ– (âŠ– x) = x"</p>
<p>Next, we define a locale that captures structures with a zero and a<br>
subtraction. Any such structure gives rise to a negation and this<br>
negation has the property that it turns zero into zero.</p>
<p>locale zero_subtraction =<br>
      fixes zero :: 'a ("ğŸ¬")<br>
      fixes sub :: "['a, 'a] â‡’ 'a" (infixl "âŠ–" 65)<br>
      assumes sub_sub: "x âŠ– (x âŠ– y) = y"<br>
      assumes sub_zero_2: "x âŠ– ğŸ¬ = x"<br>
    begin</p>
<p>abbreviation neg :: "'a â‡’ 'a" ("âŠ– _" [81] 80) where<br>
      "âŠ– x â‰¡ ğŸ¬ âŠ– x"</p>
<p>sublocale negation neg<br>
    proof<br>
      fix x<br>
      show "ğŸ¬ âŠ– (ğŸ¬ âŠ– x) = x" using sub_sub .<br>
    qed</p>
<p>lemma neg_zero:<br>
      shows "âŠ– ğŸ¬ = ğŸ¬"<br>
      using sub_zero_2 .</p>
<p>end</p>
<p>Finally, we introduce a locale that captures structures with a negation,<br>
a zero, and an addition. We import the <code>negation</code> locale to provide the<br>
negation structure. Since we can construct subtraction from negation and<br>
addition, we introduce a corresponding sublocale relationship. This<br>
would give us another instance of the <code>negation</code> locale through the<br>
<code>zero_subtraction</code> locale, albeit with the same negation operator. To<br>
prevent this, we use <code>rewrites</code>.</p>
<p>locale negation_zero_addition =<br>
      negation neg for neg :: "'a â‡’ 'a" ("âŠ– _" [81] 80) +<br>
      fixes zero :: 'a ("ğŸ¬")<br>
      fixes add :: "['a, 'a] â‡’ 'a" (infixl "âŠ•" 65)<br>
      assumes add_zero_1: "ğŸ¬ âŠ• x = x"<br>
      assumes add_zero_2: "x âŠ• ğŸ¬ = x"<br>
      assumes neg_add: "âŠ– (x âŠ• y) = (âŠ– x) âŠ• (âŠ– y)"<br>
      assumes add_cancel: "x âŠ• ((âŠ– x) âŠ• y) = y"<br>
    begin</p>
<p>abbreviation sub :: "['a, 'a] â‡’ 'a" (infixl "âŠ–" 65) where<br>
      "x âŠ– y â‰¡ x âŠ• (âŠ– y)"</p>
<p>sublocale zero_subtraction zero sub<br>
      rewrites "zero_subtraction.neg zero sub = neg"<br>
    proof unfold_locales<br>
      fix x and y<br>
      have "x âŠ• (âŠ– (x âŠ• (âŠ– y))) = x âŠ• ((âŠ– x) âŠ• (âŠ– (âŠ– y)))"<br>
        (is "?l = _")<br>
        by (simp add: neg_add)<br>
      also have "â€¦ = âŠ– (âŠ– y)"<br>
        using add_cancel .<br>
      also have "â€¦ = y" (is "_ = ?r")<br>
        using neg_neg .<br>
      finally show "?l = ?r" .<br>
    next<br>
      fix x<br>
      have "x âŠ• (âŠ– ğŸ¬) = (âŠ– (âŠ– x)) âŠ• (âŠ– ğŸ¬)" (is "?l = _")<br>
        by (simp add: neg_neg)<br>
      also have "â€¦ = âŠ– (âŠ– x âŠ• ğŸ¬)"<br>
        by (simp add: neg_add)<br>
      also have "â€¦ = âŠ– (âŠ– x)"<br>
        by (simp add: add_zero_2)<br>
      also have "â€¦ = x" (is "_ = ?r")<br>
        using neg_neg .<br>
      finally show "?l = ?r" .<br>
    next<br>
      show "(Î»x. ğŸ¬ âŠ• (âŠ– x)) = (Î»x. âŠ– x)"<br>
        by (simp add: add_zero_1)<br>
    qed</p>
<p>end</p>
<p>Now letâ€™s have an interpretation.</p>
<p>interpretation int:<br>
      negation_zero_addition â€¹uminus :: int â‡’ intâ€º â€¹0â€º â€¹(+)â€º<br>
      by unfold_locales simp_all</p>
<p>I would like to prove that integer negation applied to the integer 0 is<br>
the integer 0 again, using <code>neg_zero</code>. However, that doesnâ€™t work.</p>
<p>lemma "- (0 :: int) = 0"<br>
      using int.neg_zero<br>
      oops</p>
<p>The problem is that the goal refers to the negation operator of <code>int</code>,<br>
while <code>int.neg_zero</code> refers to the negation operator that is derived<br>
from zero and subtraction (where subtraction in turn is derived from<br>
negation and addition). Both negation operators are equal, and I have<br>
communicated this equality by means of <code>rewrites</code>, but Isabelle<br>
apparently doesnâ€™t make use of it.</p>
<p>How can I use facts like <code>int.neg_zero</code> in proofs of lemmas like the<br>
above one?</p>
<p>All the best,<br>
Wolfgang</p>



<a name="294759484"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Things%20identified%20via%20%60rewrites%60%20not%20treated%20a.../near/294759484" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html#294759484">(Aug 22 2022 at 20:08)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear Wolfgang Jeltsch,</p>
<p>Given that there has not been an official answer for more than one day, at<br>
least, I can offer a plausible practical solution. Nevertheless, please<br>
keep in mind that I am not familiar with the implementation details of the<br>
locale interpretation and the associated rewrite algorithms (if you still<br>
insist on getting to the heart of the matter, it should possible to debug<br>
the source code).</p>
<p>Using only the abbreviation âŠ– from negation_zero_addition, the suggested<br>
rewrite rule is 'zero_subtraction.neg ğŸ¬ sub=neg', which stands for '(âŠ–)<br>
ğŸ¬=neg' (see print_abbrevs). The theorem neg_zero is '((âŠ–) ğŸ¬) ğŸ¬ = ğŸ¬'<br>
after the interpretation inside the context of negation_zero_addition.<br>
Trying to (for example) unfold '((âŠ–) ğŸ¬) ğŸ¬ = ğŸ¬' with '(âŠ–) ğŸ¬=neg' leaves<br>
the theorem in the same state:</p>
<p>lemma subst1: "(âŠ–) ğŸ¬ â‰¡ neg" by (simp add: add_zero_1)<br>
lemma subst2: "(âŠ–) ğŸ¬ x â‰¡ neg x" by (simp add: add_zero_1)<br>
lemma thm1: "((âŠ–) ğŸ¬) ğŸ¬ â‰¡ ğŸ¬" sorry<br>
lemma thm2: "f ((âŠ–) ğŸ¬) â‰¡ f ((âŠ–) ğŸ¬)" by simp<br>
thm thm1[unfolded subst1] (<em>unfold 'fails': ((âŠ–) ğŸ¬) ğŸ¬ â‰¡ ğŸ¬</em>)<br>
thm thm1[unfolded subst2] (<em>unfold 'succeeds': âŠ– ğŸ¬ â‰¡ ğŸ¬</em>)<br>
thm thm2[unfolded subst1] (<em>unfold 'succeeds': ?f neg â‰¡ ?f neg</em>)<br>
thm thm2[unfolded subst2] (<em>unfold 'succeeds': ?f neg â‰¡ ?f neg</em>)</p>
<p>I can only speculate as to whether the mechanism used for rewriting during<br>
the locale interpretation is not entirely different from the technique used<br>
in the example above. As you can also see from the code listing above, the<br>
rewrite rule '(âŠ–) ğŸ¬ x â‰¡ neg x' achieves the desired effect. Using the<br>
abbreviation zero_subtraction.neg, this rule becomes 'zero_subtraction.neg<br>
ğŸ¬ sub x= neg x'. However, it may be even safer to replace the abbreviation<br>
zero_subtraction.neg with a predefined constant (see the code listing<br>
below). In this case, 'zero_subtraction.neg ğŸ¬ sub= neg' is, most likely,<br>
the best available option: I expect that with this rule all plausible<br>
algorithms would agree on the intuitively desired solution unanimously.</p>
<p>It would be useful for me if someone who knows the details of the<br>
implementation could confirm/correct/provide further explanation of any<br>
aspects of what is stated above.</p>
<p>Thank you</p>
<p>locale negation =<br>
  fixes neg :: "'a â‡’ 'a" ("âŠ– _" [81] 80)<br>
  assumes neg_neg: "âŠ– (âŠ– x) = x"</p>
<p>locale zero_subtraction =<br>
  fixes zero :: 'a ("ğŸ¬")<br>
  fixes sub :: "['a, 'a] â‡’ 'a" (infixl "âŠ–" 65)<br>
  assumes sub_sub: "x âŠ– (x âŠ– y) = y"<br>
  assumes sub_zero_2: "x âŠ– ğŸ¬ = x"<br>
begin</p>
<p>definition neg :: "'a â‡’ 'a" ("âŠ– _" [81] 80) where<br>
  "âŠ– x â‰¡ ğŸ¬ âŠ– x"</p>
<p>sublocale negation neg<br>
proof<br>
  fix x<br>
  show "âŠ– (âŠ– x) = x" unfolding neg_def using sub_sub .<br>
qed</p>
<p>lemma neg_zero:<br>
  shows "âŠ– ğŸ¬ = ğŸ¬"<br>
  unfolding neg_def using sub_zero_2 .</p>
<p>end</p>
<p>locale negation_zero_addition =<br>
  negation neg for neg :: "'a â‡’ 'a" ("âŠ– _" [81] 80) +<br>
  fixes zero :: 'a ("ğŸ¬")<br>
  fixes add :: "['a, 'a] â‡’ 'a" (infixl "âŠ•" 65)<br>
  assumes add_zero_1: "ğŸ¬ âŠ• x = x"<br>
  assumes add_zero_2: "x âŠ• ğŸ¬ = x"<br>
  assumes neg_add: "âŠ– (x âŠ• y) = (âŠ– x) âŠ• (âŠ– y)"<br>
  assumes add_cancel: "x âŠ• ((âŠ– x) âŠ• y) = y"<br>
begin</p>
<p>abbreviation sub :: "['a, 'a] â‡’ 'a" (infixl "âŠ–" 65) where<br>
  "x âŠ– y â‰¡ x âŠ• (âŠ– y)"</p>
<p>lemma zs: "zero_subtraction zero sub"<br>
proof unfold_locales<br>
  fix x and y<br>
  have "x âŠ• (âŠ– (x âŠ• (âŠ– y))) = x âŠ• ((âŠ– x) âŠ• (âŠ– (âŠ– y)))"<br>
    (is "?l = _")<br>
    by (simp add: neg_add)<br>
  also have "â€¦ = âŠ– (âŠ– y)"<br>
    using add_cancel .<br>
  also have "â€¦ = y" (is "_ = ?r")<br>
    using neg_neg .<br>
  finally show "?l = ?r" .<br>
next<br>
  fix x<br>
  have "x âŠ• (âŠ– ğŸ¬) = (âŠ– (âŠ– x)) âŠ• (âŠ– ğŸ¬)" (is "?l = _")<br>
    by (simp add: neg_neg)<br>
  also have "â€¦ = âŠ– (âŠ– x âŠ• ğŸ¬)"<br>
    by (simp add: neg_add)<br>
  also have "â€¦ = âŠ– (âŠ– x)"<br>
    by (simp add: add_zero_2)<br>
  also have "â€¦ = x" (is "_ = ?r")<br>
    using neg_neg .<br>
  finally show "?l = ?r" .<br>
qed</p>
<p>sublocale zero_subtraction zero sub<br>
  rewrites "zero_subtraction.neg zero sub = neg"<br>
apply(rule zs)<br>
unfolding zero_subtraction.neg_def[OF zs]<br>
by (simp add: add_zero_1)</p>
<p>thm neg_zero (* âŠ– ğŸ¬ = ğŸ¬ *)</p>
<p>end</p>
<p>interpretation int:<br>
  negation_zero_addition â€¹uminus :: int â‡’ intâ€º â€¹0â€º â€¹(+)â€º<br>
  by unfold_locales simp_all</p>
<p>thm int.neg_zero (* - 0 = 0 *)</p>



<a name="294759496"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Things%20identified%20via%20%60rewrites%60%20not%20treated%20a.../near/294759496" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html#294759496">(Aug 22 2022 at 20:08)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt;<br>
Dear Wolfgang,</p>
<p>The problem is that you have abbreviations on the left-hand sides of your rewrites instead <br>
of definitions. Abbreviations are just for pretty-printing; in the underlying term <br>
representation, abbreviations are unfolded (and implicitly beta-reduced). If you change <br>
the abbreviations into definitions, then the rewriting works as expected. Let's look into <br>
what's happening:</p>
<p>The term sub in zero_subtraction expands to Î»x y. (+) x (uminus y).<br>
So the rewrite rule "zero_subtraction.neg zero sub = neg" becomes in the interpretation</p>
<p>Î»x. int.sub 0 x = uminus</p>
<p>This has a lambda on the left, i.e., it is not a proper higher-order rewrite rule. It will <br>
only kick in if there is a lambda abstraction in the term. However, in the theorem <br>
neg_zero, the beta redex "(Î»x. int.sub 0 x) 0" has already been reduced so int.sub 0 0. So <br>
the rewrite rule will not trigger. If you turn the abbreviations into definitions, there <br>
will be no trouble with implicit beta-reductions and eta-expansions.</p>
<p>Alternatively, you can add the eta-expanded version of the rewrite rule:</p>
<p>sublocale zero_subtraction zero sub<br>
       rewrites "zero_subtraction.neg zero sub = neg"<br>
         and "zero_subtraction.neg zero sub x = neg x"</p>
<p>Then it works as expected.</p>
<p>Hope this helps<br>
Andreas</p>



<a name="294759512"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Things%20identified%20via%20%60rewrites%60%20not%20treated%20a.../near/294759512" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html#294759512">(Aug 22 2022 at 20:08)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
Thanks a lot for your explanation.</p>
<p>I cannot say that I fully understand whatâ€™s going on, but I think I have<br>
at least some idea.</p>
<p>Apparently, the problem has more to do with rewriting in general than<br>
with rewriting introduced by <code>rewrites</code> clauses. I understand that<br>
defining <code>(âŠ–)</code> as an abbreviation via <code>x âŠ– y â‰¡ x âŠ• ((âŠ–) y)</code> doesnâ€™t play<br>
well with using a partial application of it in the rewrite rule <code>(âŠ–) ğŸ¬ 
= neg</code>. While <code>(âŠ–) ğŸ¬</code> looks like an innocent partial application, it i<br>
s in fact <code>Î»y. ğŸ¬ âŠ• ((âŠ–) y)</code>, and thus the rewrite rule doesnâ€™t match i<br>
n places where <code>(âŠ–)</code> is fully applied, because full applications of<br>
abbreviations donâ€™t use <code>Î»</code>.</p>
<p>When using <code>definition</code> instead of <code>abbreviation</code>, rewriting takes place<br>
in all your above four examples. I think Iâ€™ll fix my issue by switching<br>
from <code>abbreviation</code> to <code>definition</code> for <code>(âŠ–)</code>.</p>
<p>All the best,<br>
Wolfgang</p>



<a name="294759573"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Things%20identified%20via%20%60rewrites%60%20not%20treated%20a.../near/294759573" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html#294759573">(Aug 22 2022 at 20:08)</a>:</h4>
<p>From: Wolfgang Jeltsch &lt;<a href="mailto:wolfgang-it@jeltsch.info">wolfgang-it@jeltsch.info</a>&gt;<br>
Thanks for this detailed explanation. It seems that the thoughts I just<br>
sent as a response to mailing-list anonymous went in the right<br>
direction. <span aria-label="smile" class="emoji emoji-1f642" role="img" title="smile">:smile:</span></p>
<p>All the best,<br>
Wolfgang</p>



<a name="294759653"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Things%20identified%20via%20%60rewrites%60%20not%20treated%20a.../near/294759653" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html#294759653">(Aug 22 2022 at 20:09)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear Wolfgang Jeltsch,</p>
<p>Thank you for your reply. Indeed, my initial intention was to write a<br>
reply with the fully expanded abbreviations (initially, in writing the<br>
reply I analysed the structure of the terms in ML and used<br>
Conv.rewrs_conv instead of the attribute â€˜unfolded'). However, I<br>
thought that the structure of the terms would be apparent anyway,<br>
because there was only one abbreviation left to expand.</p>
<p>Unfortunately, I have not studied, specifically, the HRS algorithms<br>
(apparently) used for rewriting in lambda calculus/Isabelle.<br>
Therefore, I did not wish to speculate any further as to why <code>Î»y. ğŸ¬ âŠ•
((âŠ–) y)</code> is not suitable as the lhs of a rule. In any case, the answer<br>
by Andreas Lochbihler provides a more complete explanation.</p>
<p>Thank you</p>



<a name="294759667"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Things%20identified%20via%20%60rewrites%60%20not%20treated%20a.../near/294759667" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Things.20identified.20via.20.60rewrites.60.20not.20treated.20a.2E.2E.2E.html#294759667">(Aug 22 2022 at 20:09)</a>:</h4>
<p>From: mailing-list anonymous &lt;<a href="mailto:mailing.list.anonymous@gmail.com">mailing.list.anonymous@gmail.com</a>&gt;<br>
Dear All,</p>
<p>I apologise for posting the same message twice. The mistake is related<br>
to making the first attempt to use a different email client that would<br>
enable the modification of the email headers (related to my previous<br>
post <a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00110.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00110.html</a>).<br>
I will make every attempt to ensure that this does not happen again.</p>
<p>Thank you</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>