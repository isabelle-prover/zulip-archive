<html>
<head><meta charset="utf-8"><title>[isabelle] Trying to fit HOL to traditional math verbiage · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html">[isabelle] Trying to fit HOL to traditional math verbiage</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294146956"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294146956" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294146956">(Aug 18 2022 at 18:37)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Am 04/11/2011 17:55, schrieb Lawrence Paulson:</p>
<blockquote>
<p>Some of the other points that you mention relate to basic lambda-calculus. There is no need to study the lambda calculus in its full glory, as it is quite irrelevant to higher-order logic. Lambda-notation merely expresses the notion of a function, something that is curiously lacking in standard mathematical practice.</p>
</blockquote>
<p>Actually, "x |-&gt; e" is often used, and I wish Church had adopted it,<br>
that would make it unnecessary to explain to a mathematician what this<br>
lambda means. But you are right that the |-&gt; notation is not really a<br>
first-class citizen in mathematics.</p>
<p>Tobias</p>
<blockquote>
<p>The type of the composition operator is a well-known device, known as currying, for expressing functions that take multiple arguments. Again, traditional mathematics is quite careless in such situations. You remark that functions have domains and ranges, but typically the function composition operator is not written in such terms at all, and is allowed to apply to any compatible pairs of functions whatever. In the language of set theory, it is a class function.</p>
<p>Anything that you can define in higher-order logic is not merely explicable in traditional mathematical terms, but it is easily so. But there are plenty of things you can write in mathematics that are impossible to formalise in higher-order logic. This is because mathematics is essentially open-ended.</p>
<p>Larry Paulson</p>
<p>On 3 Nov 2011, at 18:45, James Frank wrote:</p>
<blockquote>
<p>I'll ask the easy question first. In my inbox, there's <a href="mailto:isabelle-users@cl.cam.ac.uk">isabelle-users@cl.cam.ac.uk</a> and <a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a> . Does it make any difference which address I use to send in a question? If it doesn't, you don't need to answer that question.</p>
<p>I've tried not to ask different forms of my next question. That's because after studying enough type theory, lambda calculus, functional programming, and files from ~~/src/HOL, I'll figure out most of the answers. But that could be up to a years worth of work, and I'm trying to get a feel for where this road is going, and whether I may need to travel the road less traveled.</p>
<p>My question, stated very general, is this: "Can I take a file such as ~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard math definitions and theorems, with a few changes to accommodate types, and have these standard definitions/theorems be describing the same objects as the Isabelle definitions and lemma?" I'm not talking about starting with a different logical framework or set of axioms, and ending up at the same place.</p>
<p>Below I ask related questions which are probably more straight forward to answer, and, if answered, might answer the question just posed.</p>
<p>To get more specific, I'll ask some questions about "definition comp" in Fun.thy, which is the definition of function composition.</p>
<p>First, here are some related goals to set the context, for why I'm thinking about this now:<br>
1) I want to cater to mathematicians who are doing traditional mathematics. Therefore, the language of my definitions and theorems needs to be reasonably familiar to them. I'd like to start rephrasing Isabelle defs and thms now.<br>
2) I want to build on, and learn from, what others have done. Therefore, my first choice is HOL rather than ZF, since the library is larger, even though HOL is not as "traditional".</p>
<p>Here's the definition of comp from Fun.thy:</p>
<p>definition comp :: "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c" (infixl "o" 55) where<br>
 "f o g = (\&lt;lambda&gt;x. f (g x))"</p>
<p>Studying Haskell is what led me to Isabelle, and I studied just enough functional programming to know that comp is a function that takes type "('b =&gt; 'c)" and returns type (('a =&gt; 'b) =&gt; 'a =&gt; 'c)). I guess that's right, although I ask below about (\&lt;lambda&gt;x. f (g x)), and about its domain and range.</p>
<p>Functions have domains and ranges. You won't be surprised here, but never once have I seen "function composition" be defined with the domain being a set of functions, and the range being a set of functions whose elements are functions, which take functions, and return functions.</p>
<p>Here's what I want out of "definition comp", using more standard math language:</p>
<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o g):'a--&gt;'b, where (f o g)(x) = f(g(x)).</p>
<p>Notice that I tweak the definition to use types rather than sets. I was also tempted to stick "(f o g) = (%x. f(g x))" in there, not that I know much more than what it symbolizes. The details and groundwork could be worked out if it's basically the same thing as "comp".</p>
<p>A pertinent point here is that with a definition such as DEFINITION 1.1.1, I'm not making many demands on someone. They might be willing to go with it even with only an intuitive understanding of types and lambda calculus. However, it's important to me that something like DEFINITION 1.1.1 and "comp" be the same thing. Not be like, "think of them as the same", but "are the same".</p>
<p>Okay, what I really want is something like this:<br>
   (f o g) = {(a,c) in AxC | ThereExists b in B, such that (a,b) is in g and (b,c) is in f}.</p>
<p>You can tell me different, but I assume I'm correct in saying that "comp" is not this set, and can't be this set, though with some work, some form of equivalence could be shown. Again, I guess that's right.</p>
<p>Somewhere in this question is me trying to figure out how different "comp" is from a standard definition of composition. Is "comp" close enough to a standard definition to try and phrase it using standard language, or it's "functional programming, type theory, and lambda calculus", and I should just accept it for what it is. Regardless, it is what it is, and I want to describe it as what it is, but describe it using language other than Isabelle code.</p>
<p>POINT 1: In a standard definition of function composition, there are typically three functions, "f", "g", and "f o g".</p>
<p>POINT2: In "comp", there are four functions, "f", "g", "(\&lt;lambda&gt;x. f (g x))", and the function of type<br>
   "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c".</p>
<p>What I've said above might could be summarized with this question:<br>
   What is this thing, this function "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c"?</p>
<p>If I have to incorporate that into my traditional-style definition, then it's no longer traditional-style. If I have to do that, then I'm doing something different.</p>
<p>If it's necessary details, and a way of specifying "g:'a--&gt;'b, f:'b--&gt;'c, and (f o g):'a--&gt;'b", and I can easily formalize the connection prior to my function composition definition, then the situation is salvageable.</p>
<p>Anyway, feel free to comment or not.</p>
<p>Thanks,<br>
James</p>
</blockquote>
</blockquote>



<a name="294147045"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147045" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147045">(Aug 18 2022 at 18:38)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
On Fri, Nov 4, 2011 at 5:46 PM, James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt; wrote:</p>
<blockquote>
<blockquote>
<p>Have you seen it [composition] being defined as a function before? If so, what was<br>
its domain and range?</p>
<p>(I also want to ask: how would you usually think of an ordinary<br>
function that takes two arguments? This line would continue into a<br>
discussion about currying, but I'll leave it out for now.)</p>
</blockquote>
<p>I could restate the essence of my first email: Currying is not a problem. It<br>
not being a part of the math literature is a problem. I don't understand<br>
currying because I wasn't taught currying. My math professors didn't teach<br>
me currying because they didn't understand currying. Most likely, they were<br>
very happy knowing nothing about currying. Most likely, they will die happy<br>
knowing nothing about currying. That's not a problem unless I want them to<br>
read something that I write that involves currying, but I will, or someone<br>
like them, so it's a problem.</p>
</blockquote>
<p>It's not too hard. I would encourage you to answer my two questions above.</p>
<blockquote>
<p>For example, when I use "comp f g" in my mind rather than "f o g", it gives<br>
me better understanding.</p>
</blockquote>
<p>I agree. (That's why I like Lisp's syntax, or rather, lack of syntax.)</p>
<blockquote>
<p>I think I had figured out that the whole thing,<br>
   "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c"<br>
is (%x. f(g x)), or "f o g", though initially I was mistaking (%x. f(g x))<br>
for the function of type ('a =&gt; `c), since in a traditional definition if<br>
g:A--&gt;B and f: B--&gt;C, then (f o g):A--&gt;C.</p>
</blockquote>
<p>You got it right the first time. The type of (%x. f (g x)) is 'a =&gt; 'c.</p>
<blockquote>
<p>But if "f" is the function of type ('b =&gt; 'c), "g" is the function of type<br>
('a  =&gt; 'b), and (%x. f(g x)) is the function of type "('b =&gt; 'c)  =&gt; ('a<br>
 =&gt; 'b)  =&gt; 'a  =&gt; 'c", then who is that function of type ('a =&gt; `c)?</p>
</blockquote>
<p>Since "%x. f (g x)" is the function of type 'a =&gt; 'c (and it is equal<br>
by definition to "f o g"), the question should perhaps be what is the<br>
function of type "('b =&gt; 'c) =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'c"? And the<br>
answer, as I mentioned before, is "comp". Let's see how this works in<br>
full detail.<br>
We have the following typings</p>
<p>f :: 'b =&gt; 'c<br>
  g :: 'a =&gt; 'b<br>
  comp :: ('b =&gt; 'c) =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'c</p>
<p>therefore</p>
<p>comp f :: ('a =&gt; 'b) =&gt; 'a =&gt; 'c</p>
<p>and thus</p>
<p>comp f g :: 'a =&gt; 'c</p>
<p>Done. For extra practice, consider the definition of "comp f g".<br>
It was given as "%x. f (g x)", and we now know that it is a function<br>
of type 'a =&gt; 'c.<br>
That means "x" has type 'a, and f (g x) has type 'c.<br>
And indeed that checks out:<br>
  x :: 'a, so<br>
  g x :: 'b, so<br>
  f (g x) :: 'c</p>



<a name="294147072"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147072" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147072">(Aug 18 2022 at 18:38)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
I'm not used to using "reply all", so I put this back public, along with <br>
my previous response, where I admit that it's pretty foolish to be <br>
wanting to eliminate something that's at the core. After this set, I <br>
don't want to be so guilty of cluttering up the mailing list with <br>
non-technical emails.</p>
<p>On 11/4/2011 6:13 PM, Lawrence Paulson wrote:</p>
<blockquote>
<p>On 4 Nov 2011, at 19:31, James Frank wrote:</p>
<blockquote>
<p>The problem is with this ubiquitous "'a =&gt;  'b =&gt;  'c" type statement. It's not a part of 98% (a little less or little more) of the math world.<br>
I can't believe that any serious mathematician would struggle with this.</p>
</blockquote>
<p>Larry Paulson<br>
</p>
</blockquote>
<p>It never entered my mind that they couldn't understand it, it's my <br>
assumption that they don't even want to, especially not for me.</p>
<p>But that's an assumption for my purposes. You're Larry Paulson at <br>
Cambridge. You make waves. I ride waves. The only safe assumption for me <br>
is that no one is going to learn functional programming concepts for me.</p>
<p>We try and cater to the reader, some of us more than others. I'm trying <br>
to set myself up now to do that in the future. I see the HOL wave and <br>
the ZF wave. The HOL wave is bigger, and I want the potential support <br>
and opportunity that may come with it, so I initially pick the HOL wave.</p>
<p>But you make it sound simple, this transition to math heavily tied into <br>
functional programming. It's not that some of the basic concepts are <br>
rocket science, but where's the satisfaction in just having a basic, <br>
intuitive understanding of concepts? Having that attitude goes against <br>
the very core of seeking to justify everything in math.</p>
<p>And then there's always the person who wants to take it to the next <br>
level. It's not enough for him or her to do algebra, he or she has to go <br>
wild with categories, and make me do lots of searches to find a decent <br>
textbook on categories for self-study, when algebra is perfectly fine <br>
without another level of abstraction.</p>
<p>It sounds like I'm lecturing. It's not really my place to do that here, <br>
but, obviously, I'm willing to do it.</p>
<p>--James</p>
<hr>
<p>Dr. Paulson,</p>
<blockquote>
<p>There is a sense in which your question is not entirely meaningful...<br>
I can see that. It would be like me saying, "That epsilon in the <br>
definition of limit is annoying me, because it annoys my students, and <br>
they don't want to learn about epsilons. What's an easy way for me to <br>
get rid of it?"</p>
</blockquote>
<p>But the realization that I was going to commit some "rigor sins" is what <br>
brought this on.</p>
<p>The basic idea is that I have two parallel lines of language in a <br>
document. Standard "math English", and the Isabelle code. The purpose is <br>
to help me clarify ideas, and to make the math more interesting and <br>
appealing to a typical mathematician.</p>
<p>There's not a problem with something like "lemma interior_ball: <br>
"x:interior S &lt;-&gt; (EX e&gt;0. ball x e &lt;= interior S)".</p>
<p>The problem is with this ubiquitous "'a =&gt; 'b =&gt; 'c" type statement. <br>
It's not a part of 98% (a little less or little more) of the math world.</p>
<p>Initially, I thought, "Okay, mask it with some other notation if you <br>
can, or talk about how, all together, the Isabelle code is equivalent to <br>
my math English".</p>
<p>I realized I can't do that. When I get to qed, I want to say, "Look, <br>
I've proved my math English theorem with Isabelle code." But if my math <br>
English is not a reasonable mirror of the Isabelle code, then I haven't <br>
proved anything but the Isabelle code.</p>
<p>It's not a real problem. I either broach a subject and give rigorous or <br>
semi-rigorous explanations, or I use certain math without explaining <br>
what I'm doing, and let the reader figure it out.</p>
<p>It's just that every analysis book in the world has a token introduction <br>
to set theory, functions, etc.. With math, I'm an imitator, and easily <br>
following that pattern is blown out of the water with HOL.</p>
<blockquote>
<p>Anything that you can define in higher-order logic is not merely <br>
explicable in traditional mathematical terms, but it is easily so. But <br>
there are plenty of things you can write in mathematics that are <br>
impossible to formalise in higher-order logic.</p>
</blockquote>
<p>The good news is that different foundations converge at a higher point <br>
where they a lot of math in common.</p>
<p>Again, there's no real problem. Very few people have an in-depth <br>
understanding of the foundations of math, so there's a lot of skipping <br>
that low level stuff anyway, or totally ignoring it.</p>
<p>--James</p>
<p>On 11/4/2011 11:55 AM, Lawrence Paulson wrote:<br>
There is a sense in which your question is not entirely meaningful, <br>
because you're asking whether rigorous but informal mathematics is <br>
adequately captured by a particular formalisation, and such issues are <br>
ultimately subjective. However, traditional mathematics is often assumed <br>
to be based on set theory, and higher-order logic has very <br>
straightforward models in set theory. In particular, if you look at the <br>
function f o g, then you get exactly the same set of ordered pairs by <br>
either route, assuming you're in the mood to interpret a function as a <br>
set of ordered pairs. The situation with higher-order logic is very <br>
different from that presented by various constructive type theories you <br>
may have seen, where you typically cannot regard a function as a set of <br>
pairs.</p>
<p>Some of the other points that you mention relate to basic <br>
lambda-calculus. There is no need to study the lambda calculus in its <br>
full glory, as it is quite irrelevant to higher-order logic. <br>
Lambda-notation merely expresses the notion of a function, something <br>
that is curiously lacking in standard mathematical practice. The type of <br>
the composition operator is a well-known device, known as currying, for <br>
expressing functions that take multiple arguments. Again, traditional <br>
mathematics is quite careless in such situations. You remark that <br>
functions have domains and ranges, but typically the function <br>
composition operator is not written in such terms at all, and is allowed <br>
to apply to any compatible pairs of functions whatever. In the language <br>
of set theory, it is a class function.</p>
<p>Anything that you can define in higher-order logic is not merely <br>
explicable in traditional mathematical terms, but it is easily so. But <br>
there are plenty of things you can write in mathematics that are <br>
impossible to formalise in higher-order logic. This is because <br>
mathematics is essentially open-ended.</p>
<p>Larry Paulson</p>
<p>On 3 Nov 2011, at 18:45, James Frank wrote:</p>
<p>I'll ask the easy question first. In my inbox, there's <br>
<a href="mailto:isabelle-users@cl.cam.ac.uk">isabelle-users@cl.cam.ac.uk</a> and <a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a> . Does <br>
it make any difference which address I use to send in a question? If it <br>
doesn't, you don't need to answer that question.</p>
<p>I've tried not to ask different forms of my next question. That's <br>
because after studying enough type theory, lambda calculus, functional <br>
programming, and files from ~~/src/HOL, I'll figure out most of the <br>
answers. But that could be up to a years worth of work, and I'm trying <br>
to get a feel for where this road is going, and whether I may need to <br>
travel the road less traveled.</p>
<p>My question, stated very general, is this: "Can I take a file such as <br>
~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard <br>
math definitions and theorems, with a few changes to accommodate types, <br>
and have these standard definitions/theorems be describing the same <br>
objects as the Isabelle definitions and lemma?" I'm not talking about <br>
starting with a different logical framework or set of axioms, and ending <br>
up at the same place.</p>
<p>Below I ask related questions which are probably more straight forward <br>
to answer, and, if answered, might answer the question just posed.</p>
<p>To get more specific, I'll ask some questions about "definition comp" in <br>
Fun.thy, which is the definition of function composition.</p>
<p>First, here are some related goals to set the context, for why I'm <br>
thinking about this now:<br>
1) I want to cater to mathematicians who are doing traditional <br>
mathematics. Therefore, the language of my definitions and theorems <br>
needs to be reasonably familiar to them. I'd like to start rephrasing <br>
Isabelle defs and thms now.<br>
2) I want to build on, and learn from, what others have done. Therefore, <br>
my first choice is HOL rather than ZF, since the library is larger, even <br>
though HOL is not as "traditional".</p>
<p>Here's the definition of comp from Fun.thy:</p>
<p>definition comp :: "('b =&gt;  'c)  =&gt;  ('a  =&gt;  'b)  =&gt;  'a  =&gt;  'c" <br>
(infixl "o" 55) where<br>
   "f o g = (\&lt;lambda&gt;x. f (g x))"</p>
<p>Studying Haskell is what led me to Isabelle, and I studied just enough <br>
functional programming to know that comp is a function that takes type <br>
"('b =&gt;  'c)" and returns type (('a =&gt;  'b) =&gt;  'a =&gt;  'c)). I guess <br>
that's right, although I ask below about (\&lt;lambda&gt;x. f (g x)), and <br>
about its domain and range.</p>
<p>Functions have domains and ranges. You won't be surprised here, but <br>
never once have I seen "function composition" be defined with the domain <br>
being a set of functions, and the range being a set of functions whose <br>
elements are functions, which take functions, and return functions.</p>
<p>Here's what I want out of "definition comp", using more standard math <br>
language:</p>
<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o <br>
g):'a--&gt;'b, where (f o g)(x) = f(g(x)).</p>
<p>Notice that I tweak the definition to use types rather than sets. I was <br>
also tempted to stick "(f o g) = (%x. f(g x))" in there, not that I know <br>
much more than what it symbolizes. The details and groundwork could be <br>
worked out if it's basically the same thing as "comp".</p>
<p>A pertinent point here is that with a definition such as DEFINITION <br>
1.1.1, I'm not making many demands on someone. They might be willing to <br>
go with it even with only an intuitive understanding of types and lambda <br>
calculus. However, it's important to me that something like DEFINITION <br>
1.1.1 and "comp" be the same thing. Not be like, "think of them as the <br>
same", but "are the same".</p>
<p>Okay, what I really want<br>
[message truncated]</p>



<a name="294147086"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147086" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147086">(Aug 18 2022 at 18:38)</a>:</h4>
<p>From: Steven Obua &lt;<a href="mailto:steven.obua@googlemail.com">steven.obua@googlemail.com</a>&gt;<br>
Hi James,</p>
<p>you might be interested in following the progress of the "ProofPeer" (<a href="http://www.proofpeer.com">www.proofpeer.com</a>) project which aims to build a cloud-based interactive theorem proving system. I hope that until the end of November a first prototype will be up and running that can be played with. You can already sign-up for it and login now, but not do much else. </p>
<p>We were also faced with the question which language / logic to use for ProofPeer. In the end we settled for Higher-Order Logic Set Theory as a logic, and a functional programming language inspired by Standard ML, Scala and Isabelle/Isar. </p>
<p>I think every serious mathematician will (want to) learn some pieces of higher-order logic and functional programming. At the same time, ZF set theory is a very flexible and elegant tool, and, as you pointed out, is familiar to all mathematicians. Our version of Higher-Order Set Theory provides a framework where you work in set theory most of the time and whenever you can, only becoming aware of and employing higher-order logic when you reach the boundaries of what can be done in a straightforward and comfortable way in ZF set theory. </p>
<p>Cheers,</p>
<p>Steven Obua</p>



<a name="294147106"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147106" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147106">(Aug 18 2022 at 18:38)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
Ramana,</p>
<p>Thanks for answering anyway, but this shows that a big part of the <br>
battle is getting the notation down. At least I was right that there are <br>
4 functions instead of 3 (though I was actually wrong in the total <br>
number, as I discovered below).</p>
<p>I'm not used to a character that's been defined as an operator being <br>
used by itself to refer to a function. Even now, I know I can talk of <br>
"comp", but I don't know if I can talk of "o" without using it with f <br>
and g. In Haskell I can refer to + by putting it in (+). All this would <br>
feel second nature if I had been doing much coding and using functions <br>
like sum(a,b) instead of "a+b".</p>
<p>That's all notation, it's six of one, or a half dozen of the other.</p>
<p>However, there's "comp", "comp f", and "comp f g", and those variations <br>
are related to currying and the nifty things currying allows you to do <br>
when defining other functions with "comp", as I understand it.</p>
<p>First, I don't know how to use "comp f g x", where to put the <br>
parentheses, but that's trivial, and shows I haven't worked far enough <br>
into the basic tutorials.</p>
<p>More importantly, I'm trying to figure out what the simple analogy is <br>
between set based function composition and functional programming <br>
function composition. My short answer guess is, "There is no simple <br>
analogy to be made using the set function composition notation and the <br>
functional programming function composition notation". Yes, they <br>
accomplish the same thing, but no, they're not close enough. Their <br>
notational similarities will hurt you and make a fool out of you.</p>
<p>Currying allows me to specify 3 related functions, "comp", "comp f", and <br>
"comp f g". Wait. I need a fourth function which involves a variable...</p>
<p>But, no, it's even worse, now that I've studied your comments below <br>
more. You listed five functions:<br>
       f :: 'b =&gt; 'c<br>
       g :: 'a =&gt; 'b<br>
       comp :: ('b =&gt; 'c) =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'c<br>
       comp f :: ('a =&gt; 'b) =&gt; 'a =&gt; 'c<br>
       comp f g :: 'a =&gt; 'c</p>
<p>But that's helpful, along with comment on following the "type path". I <br>
think it's a little clearer now that the lambda notation is just a way <br>
to specify the path that x::`a follows when used as an argument for g.</p>
<p>It's currying. It can't be something else. That's why you guys <br>
immediately tied my questions into currying.</p>
<p>But now, to answer your two questions:</p>
<p>_Q1_: Have you seen it [composition] being defined as a function before? If so, what was<br>
its domain and range?</p>
<p>It's always defined as a function, where a function is a set of ordered pairs. If g:A--&gt;B and f:B--&gt;C, then the domain and range are determined for (f o g). We have to have (f o g):A--&gt;C, where A, B, and C can be any sets.</p>
<p>_Q2_:(I also want to ask: how would you usually think of an ordinary function that takes two arguments? This line would continue into a discussion about currying, but I'll leave it out for now.)</p>
<p>As a two variable function f(x,y).</p>
<p>But it's not acceptable for me to think like that now. When I was studying functional programming for practical reasons, it was acceptable to think of "f: 'a =&gt;  'b =&gt;  'c" as a two variable function f(a,b), but once you make it part of a math definition, I'm only allowed to to think of it as what it is.</p>
<p>The only option is to set up an equivalence that allows me to think the way I want to think.</p>
<p>Thanks for the help,<br>
--James</p>



<a name="294147118"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147118" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147118">(Aug 18 2022 at 18:38)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
Again, I didn't hit the right reply button on a previous reply, so I put <br>
this back public. In my reply to Piotr, I said complementary things <br>
about both Mizar and Isabelle. Personally, I'd like to learn all the <br>
proof assistants, just for the fun of it.</p>



<a name="294147142"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147142" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147142">(Aug 18 2022 at 18:38)</a>:</h4>
<p>From: Josef Urban &lt;<a href="mailto:josef.urban@gmail.com">josef.urban@gmail.com</a>&gt;<br>
Hi,</p>
<p>Piotr Rudnicki forwarded this thread, here is my view.</p>
<p>I have seen the following justifications of doing formal<br>
mathematics in simply typed HOL instead of in standard set theory:</p>
<ol>
<li>Better automation of type inference</li>
<li>Better automation of (total) functions</li>
</ol>
<p>I do not think any of them is particularly valid today. It seems<br>
to me that they are just deeply embedded in the LCF heritage (use<br>
of ML, etc.). Larry himself has formalized ZF quite far in Isabelle.</p>
<p>ad (1): Automation of type inference in existing HOL-based<br>
systems based on Hindley-Milner is quite simple in comparison to<br>
dependent type systems, be it done foundationally as in Coq, or<br>
as a soft type system as in Mizar. Additional type class<br>
systems (in Isabelle and Coq) are themselves soft type systems<br>
grafted on top of the systems' foundational cores, already<br>
motivated by user demand for improved (non-foundational)<br>
type-related automations.</p>
<p>ad (2): Automation of working with (not just total) functions is<br>
again a fairly simple mechanism, implementable also in set<br>
theory.</p>
<p>I think that any of the major systems (starting with Isabelle)<br>
has today integrated much more powerful automations, based on<br>
bridges to automated tools working in propositional and<br>
first-order (not higher-order) logic, and its decidable<br>
fragments.</p>
<p>I believe that the focus on total functions as foundational<br>
objects came from their success in programming, but it is foreign<br>
to most of mathematics as done by mathematicians. The<br>
set-theoretical world of HOL is different from standard set<br>
theory. Basic set-theoretical cosnstructs like von Neuman's<br>
ordinals do not work for HOL's standard "sets" because of the<br>
type constraints. The universe is sparser, because its sets are<br>
typed. When I see a set-theory-related development done<br>
in (Isabelle/)HOL (last time this was measure theory), it leaves<br>
me wondering about how/if various set-theoretical agendas and<br>
their implications (e.g. the forcing methods, implications of the<br>
axiom of choice) are answered.</p>
<p>To sum up: I do not think that there are good pragmatic<br>
automation-related reasons for persuading mathematicians to work<br>
in HOL instead of ZF. Given the very low penetration that formal<br>
mathematics has so far among mathematicians, I think it would not<br>
hurt the formal systems to go where the mathematicians are.</p>
<p>Josef</p>



<a name="294147168"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147168" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147168">(Aug 18 2022 at 18:38)</a>:</h4>
<p>From: Serguei Mokhov &lt;<a href="mailto:serguei@gmail.com">serguei@gmail.com</a>&gt;<br>
James,</p>
<p>JFYI, perhaps you should bring up some of these questions on the<br>
Foundations of Mathematics (FOM) mailing list to get some of the<br>
insight from the "other side" and see what they have to say about HOL<br>
and FOM.</p>
<p><a href="http://www.cs.nyu.edu/mailman/listinfo/fom">http://www.cs.nyu.edu/mailman/listinfo/fom</a></p>
<p>-s</p>



<a name="294147211"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147211" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147211">(Aug 18 2022 at 18:39)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jlcaadawson@netspeed.com.au">jlcaadawson@netspeed.com.au</a>&gt;<br>
Unfortunately "where the mathematicians are" is to use language in a way <br>
which is typical of natural languages, which contain exactly the sort of <br>
inconsistencies and ambiguities which lead people to use formal systems <br>
instead.</p>
<p>For example, mathematicians say things like "the derivative of f(x)", <br>
when they are referring to the derivative of f, and they say f(n) = <br>
O(g(n)) (but that O(g(n)) is a set of functions), when they mean f is <br>
_in the set_ O(g) - etc.</p>
<p>Jeremy</p>



<a name="294147222"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147222" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147222">(Aug 18 2022 at 18:39)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
On Sat, Nov 5, 2011 at 5:21 PM, James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt; wrote:</p>
<blockquote>
<p>I'm not used to a character that's been defined as an operator being used by<br>
itself to refer to a function. Even now, I know I can talk of "comp", but I<br>
don't know if I can talk of "o" without using it with f and g. In Haskell I<br>
can refer to + by putting it in (+). All this would feel second nature if I<br>
had been doing much coding and using functions like sum(a,b) instead of<br>
"a+b".</p>
<p>That's all notation, it's six of one, or a half dozen of the other.</p>
</blockquote>
<p>You're right, it's just syntax. You can talk about o on its own by<br>
putting it in brackets (o), just like + in Haskell. (o) is the same<br>
thing as comp.</p>
<blockquote>
<p>_Q1_: Have you seen it [composition] being defined as a function before? If<br>
so, what was<br>
its domain and range?</p>
<p>It's always defined as a function, where a function is a set of ordered<br>
pairs. If g:A--&gt;B and f:B--&gt;C, then the domain and range are determined for<br>
(f o g). We have to have (f o g):A--&gt;C, where A, B, and C can be any sets.</p>
</blockquote>
<p>No. I was asking whether you'd seen composition itself, just the (o),<br>
defined as a function before. You're saying that the result of<br>
composition, f o g, is always a function. That's right. But I guess<br>
usually you would think of the "o" there as an operator that can never<br>
appear on its own without two arguments around it. From the<br>
higher-order perspective, as you've noticed, all of these are<br>
functions: "_ o _", "f o _", "_ o g", and "f o g". The first one takes<br>
two functions and returns a function. The second two take one function<br>
and return a function. The last one takes something (maybe not a<br>
function, depends on g) and returns something else (again, depends on<br>
f).</p>
<blockquote>
<p>_Q2_:(I also want to ask: how would you usually think of an ordinary<br>
function that takes two arguments? This line would continue into a<br>
discussion about currying, but I'll leave it out for now.)</p>
<p>As a two variable function f(x,y).</p>
<p>But it's not acceptable for me to think like that now. When I was studying<br>
functional programming for practical reasons, it was acceptable to think of<br>
"f: 'a =&gt;  'b =&gt;  'c" as a two variable function f(a,b), but once you make<br>
it part of a math definition, I'm only allowed to to think of it as what it<br>
is.</p>
</blockquote>
<p>There are at least three ways to think about functions of multiple arguments.</p>
<p>1) Have a new variation on the theme of "function" for every number of<br>
arguments it might take, so a function of two arguments is a different<br>
although similar kind of entity as a function of one argument. It<br>
might be a set of triples as opposed to a set of pairs, for example.</p>
<p>2) (Curried functions) Every function takes exactly one argument. To<br>
get the effect of taking more arguments, return a function to consume<br>
the remaining arguments. For example, suppose we have f(x,y) = x + y.<br>
As a curried function, f would have type num =&gt; num =&gt; num, or, for<br>
clarity, num =&gt; (num =&gt; num). When you apply it to one argument, it<br>
returns a function of type num =&gt; num. Thus f 3 :: num =&gt; num. Now if<br>
you apply that resulting function to one argument, it returns a<br>
number. (f 3) 4 :: num (and (f 3) 4 = 7). We would usually write f 3 4<br>
for (f 3) 4, by making function application associate to the left.</p>
<p>3) Every function takes exactly one argument. To get the effect of<br>
taking more arguments, take all your required arguments at once in a<br>
tuple. The function f as above would in this case have type num * num<br>
=&gt; num. You apply it to a pair of numbers (3,4), and get back a number<br>
f (3,4) = 7.</p>
<p>Representations 2 and 3 are closely related. Indeed, you can write a<br>
(higher-order) function to transform a curried function into an<br>
uncurried function (and vice versa).</p>
<p>Are any of these close to how you usually think of functions of<br>
multiple arguments?</p>



<a name="294147253"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147253" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147253">(Aug 18 2022 at 18:39)</a>:</h4>
<p>From: "Tim (McKenzie) Makarios" &lt;<a href="mailto:tjm1983@gmail.com">tjm1983@gmail.com</a>&gt;<br>
This discussion reminds me of this thesis:<br>
<a href="http://people.pwf.cam.ac.uk/mg262/GanesalingamMdis.pdf">http://people.pwf.cam.ac.uk/mg262/GanesalingamMdis.pdf</a><br>
I've only read fragments of it, but particularly relevant to what<br>
started this whole discussion is the observation on page 189 that the<br>
standard set theory definition of functions doesn't reflect how<br>
mathematicians actually think of functions.  In particular, according to<br>
that definition, functions don't have unique codomains.  (The footnote<br>
about this observation being novel indicates that the author was unaware<br>
of page 19 of Topoi: <a href="http://tinyurl.com/7qx72ou">http://tinyurl.com/7qx72ou</a> .  In the interests of<br>
full disclosure, the author of Topoi is Rob Goldblatt, who is my current<br>
supervisor.)</p>
<p>Tim<br>
&lt;&gt;&lt;<br>
<a href="/user_uploads/14278/v7TGKbZs04_o7EIeDdvGfAcn/signature.asc">signature.asc</a></p>



<a name="294147336"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147336" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147336">(Aug 18 2022 at 18:39)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
Thanks for the link.</p>
<p>The range/codomain part of function definition shows that much of math <br>
is just logic games.</p>
<p>To prove that f is a function, you have to show that for every element <br>
in the domain, there exists an element in the codomain that it's mapped <br>
to. But the best you might can do is show that it maps to an element in <br>
some interval. So someone, somewhere back  in history, conveniently <br>
decided to loosen up the definition of function to allow that. <br>
Otherwise, a tighter definition of function becomes a big show stopper.</p>
<p>Begin reasonably pragmatic, I'd say all these logic games are useless <br>
other than the fact that it recently occurred to me that using the Axiom <br>
of Choice is not just a useless logic game. If you can know two sets <br>
aren't equal, and the Axiom of Choice can give you that, then that's useful.</p>
<p>As to how this applies to me, it's not my fault. I'm a product of a <br>
centuries old university system that has programmed me to have certain <br>
expectations, and want certain things.</p>
<p>--James</p>



<a name="294147386"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147386" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147386">(Aug 18 2022 at 18:40)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
Ramana,</p>
<p>Thanks again for the help. I'll answer your last question first, and <br>
then go long-winded on you.</p>
<p>_Q_:  Representations 2 and 3 are closely related. Indeed, you can write <br>
a (higher-order) function to transform a curried function into an <br>
uncurried function (and vice versa).  Are any of these close to how you <br>
usually think of functions of multiple arguments?</p>
<p>Yes, #3 pretty much represents multi-variable calculus. It's all about <br>
having a function f:R^n --&gt; R^m. N-tuples. It's all about n-tuples.</p>
<p>As to currying, in the Haskell books, it was quickly pointed out that <br>
though curried functions were primarily being used, as you say, which <br>
they said, going back and forth between curried functions and uncurried <br>
functions is not a problem. All these details about curried functions <br>
will help me if curried functions become a part of what I'm doing.</p>
<p>However, the reason that we're having to talk about multi-variable <br>
functions, in relation to function composition, is not because of how <br>
function composition is implemented with sets, but how it's implemented <br>
without sets.</p>
<p>The definition of sets function composition doesn't make it a function <br>
which takes multiple arguments. If the domain is a collection of <br>
n-tuples, then we have a multi-variable function. If not... I always get <br>
paranoid when making technical claims, even if they're basic.</p>
<p>I'll stop here. All I have to do flip a mental switch. Initially, I make <br>
it my goal to prove every theorem in Rudin just like he does. If I flip <br>
a switch, then I decide it's good to implement them with proofs founded <br>
on curried functions.</p>
<p>But I still have questions, which you don't need to answer. Are curried <br>
functions merely part of implementation, or can they be abstracted out?</p>
<p>Where am I going to find the definition of function? I see that function <br>
is already being used in Fun.thy. I see that Groups.thy is two levels up <br>
from HOL.thy, and functions are used in groups. My guess is that I'm <br>
going to find function at the compiler level.</p>
<p>Thanks,<br>
James</p>



<a name="294147445"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147445" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147445">(Aug 18 2022 at 18:40)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
On Mon, Nov 7, 2011 at 6:08 PM, James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt; wrote:</p>
<blockquote>
<p>Ramana,<br>
Yes, #3 pretty much represents multi-variable calculus. It's all about<br>
having a function f:R^n --&gt; R^m. N-tuples. It's all about n-tuples.</p>
<p>As to currying, in the Haskell books, it was quickly pointed out that though<br>
curried functions were primarily being used, as you say, which they said,<br>
going back and forth between curried functions and uncurried functions is<br>
not a problem. All these details about curried functions will help me if<br>
curried functions become a part of what I'm doing.</p>
</blockquote>
<p>Good. I'm glad they were both familiar already.</p>
<blockquote>
<p>But I still have questions, which you don't need to answer. Are curried<br>
functions merely part of implementation, or can they be abstracted out?</p>
</blockquote>
<p>I'm not sure what you mean. You said "or" between two things that<br>
would go together. I think the answer is "no".</p>
<blockquote>
<p>Where am I going to find the definition of function? I see that function is<br>
already being used in Fun.thy. I see that Groups.thy is two levels up from<br>
HOL.thy, and functions are used in groups. My guess is that I'm going to<br>
find function at the compiler level.</p>
</blockquote>
<p>Functions are fundamental to HOL, so you're right if you're calling<br>
that the "compiler level". (But you don't have to go to the ML<br>
compiler level!) The function type operator (the "=&gt;" we were using<br>
before) is primitive, that is, not created by type definition. In the<br>
usual model of HOL in set theory, it constructs function spaces.</p>



<a name="294147449"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147449" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147449">(Aug 18 2022 at 18:40)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
Ramana,</p>
<p>Makes sense, I guess. And even in src/ZF/ZF.thy I see that primitive.</p>
<p>It's all functional programming. That's my revelation of yesterday. <br>
Anything that gives me recursion is probably going to be functional <br>
programming.</p>
<p>My requirements have changed. All I want is the easiest possible way to <br>
learn a tool that allows me to do some logic and have the appearance of <br>
sets. If there's a problem, it's false illusions.</p>
<p>Thanks,<br>
James</p>



<a name="294147593"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147593" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147593">(Aug 18 2022 at 18:41)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
I'll ask the easy question first. In my inbox, there's <br>
<a href="mailto:isabelle-users@cl.cam.ac.uk">isabelle-users@cl.cam.ac.uk</a> and <a href="mailto:cl-isabelle-users@lists.cam.ac.uk">cl-isabelle-users@lists.cam.ac.uk</a> . Does <br>
it make any difference which address I use to send in a question? If it <br>
doesn't, you don't need to answer that question.</p>
<p>I've tried not to ask different forms of my next question. That's <br>
because after studying enough type theory, lambda calculus, functional <br>
programming, and files from ~~/src/HOL, I'll figure out most of the <br>
answers. But that could be up to a years worth of work, and I'm trying <br>
to get a feel for where this road is going, and whether I may need to <br>
travel the road less traveled.</p>
<p>My question, stated very general, is this: "Can I take a file such as <br>
~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard <br>
math definitions and theorems, with a few changes to accommodate types, <br>
and have these standard definitions/theorems be describing the same <br>
objects as the Isabelle definitions and lemma?" I'm not talking about <br>
starting with a different logical framework or set of axioms, and ending <br>
up at the same place.</p>
<p>Below I ask related questions which are probably more straight forward <br>
to answer, and, if answered, might answer the question just posed.</p>
<p>To get more specific, I'll ask some questions about "definition comp" in <br>
Fun.thy, which is the definition of function composition.</p>
<p>First, here are some related goals to set the context, for why I'm <br>
thinking about this now:<br>
1) I want to cater to mathematicians who are doing traditional <br>
mathematics. Therefore, the language of my definitions and theorems <br>
needs to be reasonably familiar to them. I'd like to start rephrasing <br>
Isabelle defs and thms now.<br>
2) I want to build on, and learn from, what others have done. Therefore, <br>
my first choice is HOL rather than ZF, since the library is larger, even <br>
though HOL is not as "traditional".</p>
<p>Here's the definition of comp from Fun.thy:</p>
<p>definition comp :: "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c" (infixl <br>
"o" 55) where<br>
   "f o g = (\&lt;lambda&gt;x. f (g x))"</p>
<p>Studying Haskell is what led me to Isabelle, and I studied just enough <br>
functional programming to know that comp is a function that takes type <br>
"('b =&gt; 'c)" and returns type (('a =&gt; 'b) =&gt; 'a =&gt; 'c)). I guess that's <br>
right, although I ask below about (\&lt;lambda&gt;x. f (g x)), and about its <br>
domain and range.</p>
<p>Functions have domains and ranges. You won't be surprised here, but <br>
never once have I seen "function composition" be defined with the domain <br>
being a set of functions, and the range being a set of functions whose <br>
elements are functions, which take functions, and return functions.</p>
<p>Here's what I want out of "definition comp", using more standard math <br>
language:</p>
<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o <br>
g):'a--&gt;'b, where (f o g)(x) = f(g(x)).</p>
<p>Notice that I tweak the definition to use types rather than sets. I was <br>
also tempted to stick "(f o g) = (%x. f(g x))" in there, not that I know <br>
much more than what it symbolizes. The details and groundwork could be <br>
worked out if it's basically the same thing as "comp".</p>
<p>A pertinent point here is that with a definition such as DEFINITION <br>
1.1.1, I'm not making many demands on someone. They might be willing to <br>
go with it even with only an intuitive understanding of types and lambda <br>
calculus. However, it's important to me that something like DEFINITION <br>
1.1.1 and "comp" be the same thing. Not be like, "think of them as the <br>
same", but "are the same".</p>
<p>Okay, what I really want is something like this:<br>
     (f o g) = {(a,c) in AxC | ThereExists b in B, such that (a,b) is in <br>
g and (b,c) is in f}.</p>
<p>You can tell me different, but I assume I'm correct in saying that <br>
"comp" is not this set, and can't be this set, though with some work, <br>
some form of equivalence could be shown. Again, I guess that's right.</p>
<p>Somewhere in this question is me trying to figure out how different <br>
"comp" is from a standard definition of composition. Is "comp" close <br>
enough to a standard definition to try and phrase it using standard <br>
language, or it's "functional programming, type theory, and lambda <br>
calculus", and I should just accept it for what it is. Regardless, it is <br>
what it is, and I want to describe it as what it is, but describe it <br>
using language other than Isabelle code.</p>
<p>POINT 1: In a standard definition of function composition, there are <br>
typically three functions, "f", "g", and "f o g".</p>
<p>POINT2: In "comp", there are four functions, "f", "g", "(\&lt;lambda&gt;x. f <br>
(g x))", and the function of type<br>
     "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c".</p>
<p>What I've said above might could be summarized with this question:<br>
     What is this thing, this function "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; <br>
'a  =&gt; 'c"?</p>
<p>If I have to incorporate that into my traditional-style definition, then <br>
it's no longer traditional-style. If I have to do that, then I'm doing <br>
something different.</p>
<p>If it's necessary details, and a way of specifying "g:'a--&gt;'b, <br>
f:'b--&gt;'c, and (f o g):'a--&gt;'b", and I can easily formalize the <br>
connection prior to my function composition definition, then the <br>
situation is salvageable.</p>
<p>Anyway, feel free to comment or not.</p>
<p>Thanks,<br>
James</p>



<a name="294147694"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147694" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147694">(Aug 18 2022 at 18:41)</a>:</h4>
<p>From: "Tim (McKenzie) Makarios" &lt;<a href="mailto:tjm1983@gmail.com">tjm1983@gmail.com</a>&gt;<br>
On 08/11/11 05:00, James Frank wrote:</p>
<blockquote>
<p>To prove that f is a function, you have to show that for every element<br>
in the domain, there exists an element in the codomain that it's mapped<br>
to. But the best you might can do is show that it maps to an element in<br>
some interval.</p>
</blockquote>
<p>What?  Why?</p>
<blockquote>
<p>So someone, somewhere back  in history, conveniently<br>
decided to loosen up the definition of function to allow that.</p>
</blockquote>
<p>To allow what?  I'm not convinced that anyone deliberately decided that<br>
the definition of functions shouldn't correspond with how mathematicians<br>
actually think about them.  I think it's just a long-standing imprecision.</p>
<blockquote>
<p>Otherwise, a tighter definition of function becomes a big show stopper.</p>
</blockquote>
<p>Why?  Can you give an example?</p>
<blockquote>
<p>--James</p>
</blockquote>
<p>Tim<br>
&lt;&gt;&lt;<br>
<a href="/user_uploads/14278/R5UbgueZFRMlACVJQ88oVSE6/signature.asc">signature.asc</a></p>



<a name="294147772"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147772" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147772">(Aug 18 2022 at 18:42)</a>:</h4>
<p>From: Ramana Kumar &lt;<a href="mailto:rk436@cam.ac.uk">rk436@cam.ac.uk</a>&gt;<br>
There are many ways to go about answering your question, and I'm sure<br>
other people on the list will make better attempts than me. But I hope<br>
multiple answers will help you, at least for different perspectives.<br>
The main thing I want to say is that I think the situation is<br>
salvageable: functional programming, (simple) type theory, and lambda<br>
calculus are not so far removed from traditional mathematics.<br>
You may be interested also in looking at Higher Order Set Theory. But<br>
for now let's stick with HOL.<br>
I'll make a few specific comments below, under the relevant bits of<br>
your message.</p>
<p>On Thu, Nov 3, 2011 at 6:45 PM, James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt; wrote:</p>
<blockquote>
<p>My question, stated very general, is this: "Can I take a file such as<br>
~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard<br>
math definitions and theorems, with a few changes to accommodate types, and<br>
have these standard definitions/theorems be describing the same objects as<br>
the Isabelle definitions and lemma?" I'm not talking about starting with a<br>
different logical framework or set of axioms, and ending up at the same<br>
place.</p>
</blockquote>
<p>I think yes.</p>
<blockquote>
<p>Functions have domains and ranges. You won't be surprised here, but never<br>
once have I seen "function composition" be defined with the domain being a<br>
set of functions, and the range being a set of functions whose elements are<br>
functions, which take functions, and return functions.</p>
</blockquote>
<p>Have you seen it being defined as a function before? If so, what was<br>
its domain and range?</p>
<p>(I also want to ask: how would you usually think of an ordinary<br>
function that takes two arguments? This line would continue into a<br>
discussion about currying, but I'll leave it out for now.)</p>
<blockquote>
<p>Here's what I want out of "definition comp", using more standard math<br>
language:</p>
<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o g):'a--&gt;'b,<br>
where (f o g)(x) = f(g(x)).</p>
</blockquote>
<p>This looks like a definition of composition as an "operator", rather<br>
than a function. From a "first-order" perspective, since functions are<br>
on a higher level than the values they take and receive, we need a<br>
separate concept for things like comp that operate on functions<br>
themselves. Notice that Definition 1.1.1 doesn't ever say that "o"<br>
itself is taking arguments and returning a value, rather, it specifies<br>
what the function "f o g" (which is really a function and not an<br>
operator) does by saying what it does on arguments.</p>
<p>When you switch to the "higher-order" perspective, these distinctions<br>
all disappear. Functions are values too, and operators that<br>
take/receive functions are also just functions. So the function<br>
composition operator is itself a function.</p>
<blockquote>
<p>Okay, what I really want is something like this:<br>
   (f o g) = {(a,c) in AxC | ThereExists b in B, such that (a,b) is in g and<br>
(b,c) is in f}.</p>
<p>You can tell me different, but I assume I'm correct in saying that "comp" is<br>
not this set, and can't be this set, though with some work, some form of<br>
equivalence could be shown. Again, I guess that's right.</p>
</blockquote>
<p>It could be that set in a model of HOL, but the sets in the model<br>
wouldn't be the same as the sets encoded in Set.thy for example. To<br>
avoid confusion, perhaps I should just say "you're right, comp is not<br>
that set, but it is in some sense equivalent."</p>
<blockquote>
<p>POINT 1: In a standard definition of function composition, there are<br>
typically three functions, "f", "g", and "f o g".</p>
<p>POINT2: In "comp", there are four functions, "f", "g", "(\&lt;lambda&gt;x. f (g<br>
x))", and the function of type<br>
   "('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c".</p>
</blockquote>
<p>The fourth function in "comp" is function composition itself (denoted by "o").</p>



<a name="294147805"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147805" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147805">(Aug 18 2022 at 18:42)</a>:</h4>
<p>From: James Frank &lt;<a href="mailto:james.isa@gmx.com">james.isa@gmx.com</a>&gt;<br>
Tim,</p>
<p>Thanks for the question, primarily so I can leave in a civilized manner <br>
and say something positive. By asking my question, I've made about 3 <br>
transitions.</p>
<p>It was functional programming, then proof assistants, and now it's all <br>
the same. In messing around with Isabelle for about a month, it raised <br>
my awareness so that I could see that Coq is a functional programming <br>
language. Coq provides me with a book which will teach me functional <br>
programming and the proof assistant software at the same time. Isabelle <br>
starts at the intermediate level in regards to functional programming. <br>
That's too high for me.</p>
<p>Everyone here has been very helpful, accessible, and professional. I'm <br>
not a professional, and I don't act like one.</p>
<p>Now to your questions.</p>
<p>SHORT ANSWER: Let f(x)=sin(x).</p>
<p>REFERENCE: <a href="http://www.angelo.edu/faculty/cdiminni/">http://www.angelo.edu/faculty/cdiminni/</a> . The area code is <br>
actually 325, not 915.</p>
<p>YOU ASK: What? Why?</p>
<p>Because the definition requires it.</p>
<p>Let f be a subset of AxB. Then f is a function if<br>
1) for every x in A, their exists some y in B such that (x,y) is in f, and<br>
2) if (x,y1) is in f, and (x,y2) is in f, then y1=y2.</p>
<p>We call A the domain of f, and we call B the codomain of f. The range of <br>
f is that subset of B... It's getting obnoxious at this point. The range <br>
is the actual values that the x's are mapped to.</p>
<p>YOU ASK AND SAY:  To allow what? I'm not convinced that anyone <br>
deliberately decided that the definition of functions shouldn't <br>
correspond with how mathematicians actually think about them. I think <br>
it's just a long-standing imprecision.</p>
<p>I'm not a historian. I was speculating on the reasons. It doesn't make <br>
sense to continue to have such a loose definition of function unless <br>
there's an advantage. EXAMPLE: Definition of limit. Newton and Liebniz <br>
started limit (or used it). Weierstrass tightened it up. Everyone <br>
accepted the tighter epsilon-delta definition.</p>
<p>WE ARGUE:</p>



<a name="294147833"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294147833" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294147833">(Aug 18 2022 at 18:42)</a>:</h4>
<p>From: "Tim (McKenzie) Makarios" &lt;<a href="mailto:tjm1983@gmail.com">tjm1983@gmail.com</a>&gt;<br>
On 11/11/11 06:28, James Frank wrote:</p>
<blockquote>
<p>SHORT ANSWER: Let f(x)=sin(x).</p>
</blockquote>
<p>This could define several different functions.  For example, it could<br>
define a function from the complex numbers to the complex numbers; it<br>
could define a function from the real numbers to the real numbers; or,<br>
it could define a function from the real numbers to [-1,1].  The point<br>
is that according to the standard definition of functions, the last two<br>
are identical.</p>
<blockquote>
<p>YOU ASK: What? Why?</p>
<p>Because the definition requires it.</p>
<p>Let f be a subset of AxB. Then f is a function if<br>
1) for every x in A, their exists some y in B such that (x,y) is in f, and<br>
2) if (x,y1) is in f, and (x,y2) is in f, then y1=y2.</p>
<p>We call A the domain of f, and we call B the codomain of f.</p>
</blockquote>
<p>But "the codomain" isn't well defined.  I think the example from Topoi<br>
illustrates my point quite well.  What is the identity function on the<br>
natural numbers?  According to the traditional definition, the answer is<br>
{(0,0), (1,1), (2,2), ...}.<br>
What is the injection function from the natural numbers to the integers?<br>
{(0,0), (1,1), (2,2), ...}.<br>
The traditional definition requires that an identity function on a set A<br>
is exactly the same function as every injection function from A to any<br>
superset of A.  I don't believe that this is how mathematicians actually<br>
treat identity and injection functions.</p>
<p>And the crucial thing is this:  If I ask "What is the codomain of<br>
{(0,0), (1,1), (2,2), ...}?",<br>
the answer has to be that the codomain isn't uniquely defined, but must<br>
be some superset of the natural numbers.</p>
<p>Tim<br>
&lt;&gt;&lt;<br>
<a href="/user_uploads/14278/c3tYe52JMJcvhyJ3kGkFkdOW/signature.asc">signature.asc</a></p>



<a name="294148494"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20fit%20HOL%20to%20traditional%20math%20verbiage/near/294148494" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20fit.20HOL.20to.20traditional.20math.20verbiage.html#294148494">(Aug 18 2022 at 18:46)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
There is a sense in which your question is not entirely meaningful, because you're asking whether rigorous but informal mathematics is adequately captured by a particular formalisation, and such issues are ultimately subjective. However, traditional mathematics is often assumed to be based on set theory, and higher-order logic has very straightforward models in set theory. In particular, if you look at the function f o g, then you get exactly the same set of ordered pairs by either route, assuming you're in the mood to interpret a function as a set of ordered pairs. The situation with higher-order logic is very different from that presented by various constructive type theories you may have seen, where you typically cannot regard a function as a set of pairs.</p>
<p>Some of the other points that you mention relate to basic lambda-calculus. There is no need to study the lambda calculus in its full glory, as it is quite irrelevant to higher-order logic. Lambda-notation merely expresses the notion of a function, something that is curiously lacking in standard mathematical practice. The type of the composition operator is a well-known device, known as currying, for expressing functions that take multiple arguments. Again, traditional mathematics is quite careless in such situations. You remark that functions have domains and ranges, but typically the function composition operator is not written in such terms at all, and is allowed to apply to any compatible pairs of functions whatever. In the language of set theory, it is a class function.</p>
<p>Anything that you can define in higher-order logic is not merely explicable in traditional mathematical terms, but it is easily so. But there are plenty of things you can write in mathematics that are impossible to formalise in higher-order logic. This is because mathematics is essentially open-ended.</p>
<p>Larry Paulson</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>