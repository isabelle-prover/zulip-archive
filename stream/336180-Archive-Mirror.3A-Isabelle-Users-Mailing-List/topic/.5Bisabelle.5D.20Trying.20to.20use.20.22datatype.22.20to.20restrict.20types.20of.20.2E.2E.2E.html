<html>
<head><meta charset="utf-8"><title>[isabelle] Trying to use &quot;datatype&quot; to restrict types of ... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html">[isabelle] Trying to use &quot;datatype&quot; to restrict types of ...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294229649"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229649" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229649">(Aug 19 2022 at 09:36)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Gottfried,</p>
<p>I still did not quite get the meaning of the sT type. If I understand <br>
you correctly, you use the values over which a variable ranges (what you <br>
call "mapped to") also for the names of the variables.</p>
<p>Anyway, let's look at your issue with the value command. This command <br>
use various evaluation strategies with Isabelle's code generator being <br>
the default (and usually the fastest). Now, the definition of sFOLf1 for <br>
Eq uses HOL equality on the right-hand side for the type sT:<br>
   "sFOLf1 E (Eq x y) = (E x = E y)"<br>
However, you have not told Isabelle how to compute equality on type sT, <br>
which is done as an instance of the type class equal.</p>
<p>The enum sort constraint comes from using the ! quantifier over sT in<br>
   "sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)"<br>
By default, ! is implemented to enumerate all values for v and test for <br>
each whether the predicate holds. Again, Isabelle does not know how to <br>
enumerate all values of type sT. You can do so by instantiating the type <br>
class enum.</p>
<p>Best,<br>
Andreas</p>



<a name="294229661"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229661" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229661">(Aug 19 2022 at 09:36)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
On 1/21/2013 1:34 AM, Andreas Lochbihler wrote:</p>
<blockquote>
<p>I still did not quite get the meaning of the sT type. If I understand <br>
you correctly, you use the values over which a variable ranges (what <br>
you call "mapped to") also for the names of the variables.<br>
Andreas,</p>
</blockquote>
<p>At this point, I stop trying to tell you "how things are" and only say <br>
"some of what I think is happening". What you've given me so far has <br>
satisfied my basic urge to try and do this. To finish it out will <br>
require me to know more, and it may not be needed or even desirable to <br>
implement.</p>
<p>There's a lot of magic that goes on with Isabelle, and to a certain <br>
extent, I'm blindly laying down some of the foundation based on having <br>
looked a little at HOL.thy, Set.thy, Larry's Isabelle/ZF and Obua's <br>
HOLZF. Isabelle/HOL is magically proving standard theorems, and I'd say <br>
"I'm probably getting lucky", but I think this is like playing the stock <br>
market where "luck don't get you very far", and you're shut down fast if <br>
what you're doing is completely based on guesswork.</p>
<p>I don't think that variables of type sT really take on values in the <br>
normal sense. What takes on values is the predicate "inS" that they're <br>
used in, which is of type bool, so the only real values I'm dealing with <br>
are True and False, which ultimately come from my predicate of type "sT <br>
=&gt; sT =&gt; bool".</p>
<p>These five Isar statements set me up initially and demonstrate that <br>
variables of type sT get their meaning from being used in the predicate <br>
"inS".</p>
<p>--"The primitive type."<br>
typedecl sT</p>
<p>--"The predicate 'is an element of'."<br>
consts inS :: "sT =&gt; sT =&gt; bool"</p>
<p>--"HOL equal is defined."<br>
axiomatization where<br>
   Ax_x: "!q.!p. ( !x. (inS x q) &lt;-&gt; (inS x p) ) &lt;-&gt; (p = q)"</p>
<p>--"The empty set constant."<br>
consts emS :: "sT"</p>
<p>--"The empty set constant axiomatized."<br>
axiomatization where<br>
   Ax_e: "!x.~(inS x emS)"</p>
<p>Having only crept along at a snail's pace, I've used 4 out of the 10 <br>
axioms I need, and Sledgehammer magically finds the right theorems to <br>
prove other theorems, it times out when a "theorem" is false, and <br>
Nitpick sometimes magically shows that a false "theorem" is false.</p>
<p>Several of the other 6 axioms have me worried, but it could all come to <br>
a screeching halt today, and I'd still be impressed by the magic.</p>
<blockquote>
<p>Anyway, let's look at your issue with the value command. This command <br>
use various evaluation strategies with Isabelle's code generator being <br>
the default (and usually the fastest). Now, the definition of sFOLf1 <br>
for Eq uses HOL equality on the right-hand side for the type sT:<br>
  "sFOLf1 E (Eq x y) = (E x = E y)"<br>
However, you have not told Isabelle how to compute equality on type <br>
sT, which is done as an instance of the type class equal.</p>
</blockquote>
<p>Okay. I don't really compute equality, I define it as shown above by <br>
axiom Ax_x. I stuck that axiom into the experimental fFOLdt theory and <br>
it didn't get rid of the error.</p>
<p>Even after only having made the statement "typedecl sT", HOL will prove <br>
that "=" for type "sT" is reflexive, symmetric, and transitive. So HOL <br>
equal magically works for me in a basic way, because I've used it a <br>
whole lot based on the properties I've attached to "=" with axiom Ax_x.</p>
<p>Thanks for the help. I need to make some more progress on getting the <br>
first 9 axioms in. What will cause me logic problems is not necessarily <br>
what I was trying to prevent by using my sFOLf function.</p>
<p>Regards,<br>
GB</p>
<blockquote>
<p>The enum sort constraint comes from using the ! quantifier over sT in<br>
  "sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)"<br>
By default, ! is implemented to enumerate all values for v and test <br>
for each whether the predicate holds. Again, Isabelle does not know <br>
how to enumerate all values of type sT. You can do so by instantiating <br>
the type class enum.</p>
<p>Best,<br>
Andreas</p>
<p>On 01/18/2013 06:50 PM, Gottfried Barrow wrote:</p>
<blockquote>
<p>On 1/18/2013 1:28 AM, Andreas Lochbihler wrote:</p>
<blockquote>
<p>you need to embed your formulas deeply in HOL, i.e., you cannot use<br>
the standard HOL connectives &amp;, |, !, etc. for your syntax. So you<br>
must use your formula datatype also for the subexpressions of your<br>
connectives:<br>
Hope this helps,<br>
Andreas,</p>
</blockquote>
<p>It helped a lot. I wouldn't have gotten to this next step without a fix.</p>
<p>I'll answer a few questions and then show you the failure I'm at now.</p>
<blockquote>
<p>I am not sure what sT is supposed to stand for. Is it the type for<br>
variable names or the type of values that variables can take. In the<br>
former case: what is the type of values?</p>
</blockquote>
<p>Type "sT" is a primitive type that represents a set. By "can take", I<br>
guess you mean "mapped to" as shown by your "env" below.</p>
<p>Semantically, I don't think a variable of type sT is mapped to another<br>
value in the sense of a function.</p>
<p>I have a function:</p>
<p>consts seS :: "sT =&gt; (sT =&gt; bool) =&gt; sT"</p>
<p>I then use a function of that type, (seS q P), in an axiom describing a<br>
property for every (q::sT) and (P::(sT =&gt; bool)), where P is a property<br>
that holds for q. (Actually the (sT =&gt; bool) type function is what I'm<br>
trying to tighten up with this sFOLf function.)</p>
<p>Variables of type sT are only used with the predicate \&lt;in&gt;, such as<br>
(x::sT \&lt;in&gt; y::sT), or as a binder variable in \&lt;exists&gt; or \&lt;forall&gt;,<br>
such as (!x. phi) or (? x. phi), where phi is a FOL formula built up<br>
starting with the atomic formulas (x \&lt;in&gt; y) and (x = y).</p>
<p>Variables of type sT are used in HOL functions, but that's only because<br>
that's how Isabelle makes me do it. The constant functions I define<br>
represent sets, and axioms are used to state what is true about those<br>
functions.</p>
<p>I could get more detailed, but I now get wellsortedness errors when<br>
trying to use the function sFOLf in a "value" statement.</p>
<p>The command</p>
<p>value "sFOLf1 sID (In x y)"</p>
<p>gives the error</p>
<p>"Wellsortedness error... Type sT not of sort equal. No type arity sT ::<br>
equal"</p>
<p>A similar error with "enum" in place of "equal" is after the third<br>
"value" command. The "Eq" and the "Forall" mess things up.</p>
<p>I'm trying to keep this short, but I'm not all that clear on the<br>
"environment" requirement. However, like I said, variables of type sT<br>
aren't really mapped anywhere.</p>
<p>To use the "value" command, I just made my "env" function the identity<br>
function.</p>
<p>The code is below, and I attached it as a THY.</p>
<p>Thanks for the help,<br>
GB</p>
<p>theory sts__sFOLdt<br>
imports Complex_Main<br>
begin</p>
<p>typedecl sT</p>
<p>consts inS :: "sT =&gt; sT =&gt; bool"</p>
<p>datatype sFOLdt =<br>
   In sT sT<br>
| Eq sT sT<br>
| Forall sT sFOLdt</p>
<p>type_synonym env = "(sT =&gt; sT)"</p>
<p>definition sID :: "sT =&gt; sT" where<br>
   "sID s = s"</p>
<p>fun sFOLf :: "env =&gt; sFOLdt =&gt; bool" where<br>
   "sFOLf E (In x y) = inS x y"</p>
<p>value "sFOLf sID (In x y)"</p>
<p>fun sFOLf1 :: "env =&gt; sFOLdt =&gt; bool" where<br>
   "sFOLf1 E (In x y) = inS x y"<br>
| "sFOLf1 E (Eq x y) = (E x = E y)"</p>
<p>value "sFOLf1 sID (In x y)"</p>
<p>fun sFOLf2 :: "env =&gt; sFOLdt =&gt; bool" where<br>
   "sFOLf2 E (In x y) = inS x y"<br>
| "sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)"</p>
<p>value "sFOLf2 sID (In x y)"</p>
<p>end</p>
</blockquote>
</blockquote>



<a name="294229667"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229667" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229667">(Aug 19 2022 at 09:36)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Gottfried,</p>
<blockquote>
<p>--"HOL equal is defined."<br>
axiomatization where<br>
   Ax_x: "!q.!p. ( !x. (inS x q) &lt;-&gt; (inS x p) ) &lt;-&gt; (p = q)"</p>
<p>Okay. I don't really compute equality, I define it as shown above by<br>
axiom Ax_x. I stuck that axiom into the experimental fFOLdt theory and<br>
it didn't get rid of the error.<br>
The error remains because</p>
</blockquote>
<ol>
<li>you did not declare the axiom Ax_x as a code equation, and</li>
<li>it is not executable as the !x-quantifier ranges over sT for which <br>
you have not provided an implementation.</li>
</ol>
<p>The code generator will not work unless you provide a concrete <br>
representation for the elements of sT.</p>
<blockquote>
<p>Even after only having made the statement "typedecl sT", HOL will prove<br>
that "=" for type "sT" is reflexive, symmetric, and transitive.<br>
No, it is not HOL that proves these three properties, = on any type is <br>
by axiom in HOL.thy reflexive, transitive and symmetric. As you use <br>
axiomatization, it is your job to make sure that your specification is <br>
consistent with HOL's axioms.</p>
</blockquote>
<p>Regards,<br>
Andreas</p>



<a name="294229673"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229673" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229673">(Aug 19 2022 at 09:36)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
On 1/21/2013 8:55 AM, Andreas Lochbihler wrote:</p>
<blockquote>
<p>The error remains because<br>
1. you did not declare the axiom Ax_x as a code equation, and<br>
2. it is not executable as the !x-quantifier ranges over sT for which <br>
you have not provided an implementation.</p>
<p>The code generator will not work unless you provide a concrete <br>
representation for the elements of sT.</p>
</blockquote>
<p>Andreas,</p>
<p>"Satisfying the code generator" falls under what I had talked about <br>
needing, which is "knowing more". The learning curve for "more" in <br>
regards to the foundations of Isabelle is "huge", so I put that off for <br>
now. I consider what I'm trying to do as something that should be done <br>
by experts, but which the experts haven't taken time to do.</p>
<p>Still, the phrase "code generator" tells me what to search on to try and <br>
finish the problem, so thanks for the tip.</p>
<blockquote>
<blockquote>
<p>Even after only having made the statement "typedecl sT", HOL will prove<br>
that "=" for type "sT" is reflexive, symmetric, and transitive.<br>
No, it is not HOL that proves these three properties, = on any type is <br>
by axiom in HOL.thy reflexive, transitive and symmetric. As you use <br>
axiomatization, it is your job to make sure that your specification is <br>
consistent with HOL's axioms.</p>
</blockquote>
</blockquote>
<p>Being the argumentative type (GB::argumentative), I'm under the <br>
impression that I can restate any axiom or theorem and "prove it again", <br>
that with my reflexive, transitive, and symmetric proofs, I'm <br>
effectively proving "A --&gt; A" for previous axioms or theorems "A" in <br>
HOL.thy. (I'm actually stating the 3 theorems after attaching additional <br>
properties to "=" with my axiom).</p>
<p>I had looked previously at the axioms for "=" here in HOL.thy:</p>
<p>axiomatization where<br>
   refl: "t = (t::'a)" and<br>
   subst: "s = t \&lt;Longrightarrow&gt; P s \&lt;Longrightarrow&gt; P t" and<br>
   ext: "(!!x::'a. (f x ::'b) = g x) ==&gt; (%x. f x) = (%x. g x)"<br>
     -- {*Extensionality is built into the meta-logic, and this rule <br>
expresses<br>
          a related property.  It is an eta-expanded version of the <br>
traditional<br>
          rule, and similar to the ABS rule of HOL*} and</p>
<p>the_eq_trivial: "(THE x. x = a) = (a::'a)"</p>
<p>Number 1 is classic "reflexive", number 2 makes sense, but I quit at 3 <br>
and 4 at trying to understand why this gives us all the typical <br>
properties of equality.</p>
<p>In the past, I had wondered whether HOL "=" has any special properties <br>
that would result in inconsistencies once my axiom was attached to it <br>
for type sT. Makarius said, paraphrasing, "HOL equal just has the <br>
typical properties of equal." I decided, "Okay, then I'll consider that <br>
until I attach additional properties to it for my type sT, that it's <br>
simply reflexive, symmetric, and transitive." Consequently, I do proofs <br>
for those 3 things regardless of what I read in HOL.thy or what you or <br>
Makarius tell me.</p>
<p>I looked now a little further at this "equal is symmetric" theorem in <br>
HOL.thy:</p>
<p>lemma sym: "s = t ==&gt; t = s"<br>
   by (erule subst) (rule refl)</p>
<p>Still, my three theorems aren't exact restatements of anything in HOL. <br>
(I didn't actually look much past "lemma sym", so they could be.) If <br>
they are restatements, it doesn't hurt to prove them again after I add <br>
my own "equality" axiom.</p>
<p>If you say, "You're restating the obvious", I would say, "But in <br>
Isabelle, with automatic proof methods, it's so easy to restate and <br>
prove the obvious. So I do it to be explicit, and to show what I can't <br>
know or haven't taken time to know based on "imports Complex_Main".</p>
<blockquote>
<p>As you use axiomatization, it is your job to make sure that your <br>
specification is consistent with HOL's axioms.</p>
</blockquote>
<p>And that is a major concern of mine, and my fFOLdt and fFOLf idea was an <br>
attempt to deal with unknowns that might cause my logic to be inconsistent.</p>
<p>Thanks,<br>
GB</p>



<a name="294229679"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229679" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229679">(Aug 19 2022 at 09:36)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Gottfried,</p>
<p>If you want to prove that your notion of equality of sT is really <br>
reflexive, transitive and symmetric, then you might do the following:</p>
<p>definition eq :: "sT =&gt; sT =&gt; bool" where<br>
   "eq p q = (!x. inS x q &lt;--&gt; inS x p)"</p>
<p>lemma "eq x x" &lt;proof&gt;<br>
lemma "eq x y = eq y x" &lt;proof&gt;<br>
lemma "eq x y ==&gt; eq y z ==&gt; eq x z" &lt;proof&gt;</p>
<p>By using your own predicate eq instead of =, you avoid that the <br>
automated proof methods use any of HOL's predefined properties.</p>
<p>Andreas</p>



<a name="294229735"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229735" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229735">(Aug 19 2022 at 09:37)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
Andreas,</p>
<p>Alright, I get this last part for free. I haven't tried it out yet, but <br>
there's enough temporary good news with my sFOLf that I go ahead and <br>
send this email off, since I now need to experiment with both what <br>
you've just given me and with the sFOLf, which might take a few days.</p>
<p>Before talking about sFOLf, in the past, I had tried to create my own <br>
primitive "=" like this,</p>
<p>consts eqS :: "sT = &gt; sT =&gt; bool",</p>
<p>and then use it in its undefined form in my axiom which defines set <br>
equality.</p>
<p>Well, I don't just state trivial theorems to prove them, I also state <br>
them to run Nitpick on them, so I ran Nitpick on this theorem,</p>
<p>theorem "!x. !y. (eqS x y) &lt;-&gt; (x = y)",</p>
<p>and Nitpick found a counterexample, though the theorem was also proved <br>
"by auto" or something simple like that.</p>
<p>The scary part is that all the theorems I had proved still worked using <br>
my primitive eqS.</p>
<p>As to my sFOLf, I looked at Larry's ZF.thy, when I was searching for <br>
"code generator", and I saw this:</p>
<p>typedecl i<br>
arities  i :: "term"</p>
<p>After some trial and error, and seeing "arity", "equal", and "enum" in <br>
the error messages, I put in some "arities" like this:</p>
<p>typedecl sT<br>
arities  sT :: equal<br>
arities  sT :: enum</p>
<p>That got rid of the errors in the simplified code I include below. As to <br>
it being legitimate, I guess I'll find out, but what I have learned is <br>
this: "arities, it's an Isar command that is used periodically". That <br>
could be a very important lesson.</p>
<p>Thanks for the "eq" to help me try and isolate my equal from the HOL equal.</p>
<p>Regards,<br>
GB</p>
<p>theory sTs__sFOLdt_130121b<br>
imports Complex_Main<br>
begin<br>
typedecl sT<br>
arities  sT :: equal<br>
arities  sT :: enum</p>
<p>consts inS :: "sT =&gt; sT =&gt; bool"</p>
<p>datatype sFOLdt =<br>
   In sT sT<br>
| Eq sT sT<br>
| Forall sT sFOLdt</p>
<p>type_synonym env = "(sT =&gt; sT)"</p>
<p>definition sID :: "sT =&gt; sT" where<br>
   "sID s = s"</p>
<p>fun sFOLf :: "env =&gt; sFOLdt =&gt; bool" where<br>
   "sFOLf E (In x y) = inS x y"<br>
| "sFOLf E (Eq x y) = (E x = E y)"<br>
| "sFOLf E (Forall x f) = (!v. sFOLf (E(x := v)) f)"</p>
<p>value "sFOLf sID (In x y)"<br>
value "sFOLf sID (Eq x y)"<br>
value "sFOLf sID (Forall x (Eq x x) )"<br>
end</p>



<a name="294229841"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229841" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229841">(Aug 19 2022 at 09:38)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Gottfried,</p>
<p>arities declares that a type belongs to the given type class, but leaves <br>
the parameters of the type class uninterpreted and the assumptions <br>
unproven. Thus, it is like axiomatisation: you can use it to introduce <br>
inconsistencies. Here's an example:</p>
<p>class false = assumes FalseI: "x = x ==&gt; False"</p>
<p>typedecl my_type<br>
arities my_type :: false</p>
<p>lemma "False"<br>
apply(rule FalseI)<br>
apply(rule refl)<br>
done</p>
<p>Without the arities command, I could not finish the proof of the lemma, <br>
because Isabelle does not know whether the type class "false" can be <br>
instantiated at all. With the arities command, I declare that my_type <br>
satisfies the axiom FalseI for all x of type my_type.</p>
<p>Hence, arities (like axiomatization) belongs to the group of commands <br>
for an axiomatic approach to formalisations. As most people nowadays <br>
prefer a definitional approach, I would not call arities frequently used.</p>
<p>Have said all this, it is obvious that the arities declarations make the <br>
error messages for the values command go away. But not for the code <br>
generator, it will continue to complain about missing code equations for <br>
the type class parameters. The second evaluation strategy (normalisation <br>
by evaluation) works.</p>
<p>Andreas</p>



<a name="294229904"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294229904" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294229904">(Aug 19 2022 at 09:38)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
On 1/22/2013 1:19 AM, Andreas Lochbihler wrote:</p>
<blockquote>
<p>arities declares that a type belongs to the given type class, but <br>
leaves the parameters of the type class uninterpreted and the <br>
assumptions unproven. Thus, it is like axiomatisation: you can use it <br>
to introduce inconsistencies. Here's an example:</p>
</blockquote>
<p>Andreas,</p>
<p>So what we can say is that Isar commands that are axiomatic are <br>
excellent commands for getting rid of error messages.</p>
<p>It looks like I have three options:</p>
<p>(1) Learn about arities and see if I can or can't assign my type sT to <br>
type class "enum".<br>
(2) Learn about code generation and figure out how to make my type sT <br>
computable.<br>
(3) Never use "datatype" and "fun" in such a way that it requires me to <br>
have a concrete representation of type sT.</p>
<p>It appears that option (3) is working for me, at least for the simple <br>
stuff I'm doing now. I think (3) would require that I be able to do <br>
induction and recursion without "datatype". That I will be able do that, <br>
I don't know. Ideally I would want to, if it's practical enough.</p>
<p>It finally sunk in that "value" is computing values, as you said, and so <br>
I need a concrete representation.</p>
<p>Actually, that last sentence doesn't "represent the situation". Isabelle <br>
can magically deal with a whole lot of things that haven't been <br>
completely defined. So, what I really know is that in this particular <br>
situation, with how I tried to use "value", it finally got to where it <br>
needed a more concrete representation.</p>
<p>Trial and error, with some informative error messages, and a little help <br>
interpreting them, can help teach a person the abstract limits of Isabelle.</p>
<p>I renamed sFOLdt and sFOLf to "sD" and "sF", completely implemented the <br>
9 FOL formulas, and then proved a few basic theorems.</p>
<p>It turns out that "sD" and "sF" is a heavy weight solution. Theorems <br>
that Sledgehammer can easily prove without this layer of heavy <br>
recursion, it can't do with it in.</p>
<p>It also messes up the value of metis proofs. Most of the facts that <br>
metis is now using for proofs aren't informative at all. I have big <br>
plans for metis proofs, even in detailed proofs. I provide a step, I <br>
apply Sledgehammer to it, it finds the theorems that justifies the step, <br>
I don't have to, up front, memorize hundreds of theorem names, and the <br>
facts in the metis proof can teach a person something, that is, if <br>
they're not facts like "sF.simps(9)", like I'm getting now.</p>
<p>However, this recursive restriction of the HOL functions that can be <br>
used is possibly a "fallback" solution, or a "parallel" solution.</p>
<p>What I did got extra, in trying to make type sT computable, is the <br>
beginnings of a recursive definition of what a set is (possibly a bogus <br>
definition), which is basically an attempt to implement the idea that <br>
every set is built from the empty set.</p>
<p>I was going to try and prove something about it, like, "Okay, let's see <br>
if I got lucky, and see if Sledgehammer can prove that my recursive <br>
function sTf satisfies the properties of the ordered pair axiom". But <br>
then, I haven't defined what membership means for it yet.</p>
<p>But first running a combination of Sledgehammer and Nitpick on a theorem <br>
is always a winner. Nitpick can sometimes tells me in a few seconds what <br>
a loser idea I've come up with.</p>
<p>In regards to the "eq" function that you gave me. That's basically my <br>
"equality axiom", which I suppose you know. It would make proving <br>
reflexive, etc less messy, but I already know that the "equality axiom" <br>
is reflexive, symmetric, and transitive, so that wasn't what got me <br>
motivated. What motivated me was the idea of using it in a trick to <br>
define my own "=" and not use the HOL "=".</p>
<p>However, there is a cardinal rule I now live by, based on nothing any <br>
expert has told me. But it is this:</p>
<p>"Never, ever, leave HOL equal undefined for a type, and then add axioms <br>
for that type."</p>
<p>So, if I have to define HOL equal for my type sT, then I might as well <br>
use HOL equal as my only equal, with whatever luggage it already comes <br>
with, which I assume is nothing bad for my type sT, even with the <br>
additional axioms, or we'd all probably be in trouble.</p>
<p>You say:</p>
<blockquote>
<p>The second evaluation strategy (normalisation by evaluation) works.</p>
</blockquote>
<p>I think you're saying here that the non-arities approach, that is, <br>
making my type sT concrete and computable (to "satisfy the code <br>
generator"), would work, if I could do it.</p>
<p>Thanks for the "arities" example of inconsistency.</p>
<p>The theory below shows my simple use of the recursive "sD" and "sF" in a <br>
way described in item (3) above. I have two versions of the axioms and <br>
two versions of a theorem. One version with outermost universal <br>
quantifiers, and one version without them, to try and make it easier for <br>
the theorem to be proved. Knowing, because of a previous thread, that <br>
the meta-logic will take care of outermost quantification for me, is <br>
very valuable information.</p>
<p>At the very bottom is my infant, experimentation of defining a recursive <br>
set.</p>
<p>Also, thanks to Alfio for some points on recursion and the need for the <br>
environment.</p>
<p>Regards,<br>
GB</p>
<p>theory sTs__sF_130122_01<br>
imports Complex_Main<br>
begin</p>
<p>typedecl sT</p>
<p>consts inS :: "sT =&gt; sT =&gt; bool"</p>
<p>datatype sD =<br>
   In sT sT<br>
| Eq sT sT<br>
| Not sD<br>
| And sD sD<br>
| Or sD sD<br>
| Imp sD sD<br>
| Iff sD sD<br>
| Forall sT sD<br>
| Exists sT sD</p>
<p>type_synonym env = "(sT =&gt; sT)"</p>
<p>definition sID :: "sT =&gt; sT" where<br>
   "sID s = s"</p>
<p>primrec sF :: "env =&gt; sD =&gt; bool"<br>
where<br>
   "sF E (In x y) = inS x y"<br>
| "sF E (Eq x y) = (E x = E y)"<br>
| "sF E (Not f) = (¬(sF E f))"<br>
| "sF E (And f g) = (sF E f &amp; sF E g)"<br>
| "sF E (Or f g) = (sF E f | sF E g)"<br>
| "sF E (Imp f g) = (sF E f --&gt; sF E g)"<br>
| "sF E (Iff f g) = (sF E f &lt;-&gt; sF E g)"<br>
| "sF E (Forall x f) = (!v. sF (E(x := v)) f)"<br>
| "sF E (Exists x f) = (? v. sF (E(x := v)) f)"</p>
<p>--"THE AXIOM OF EXTENSION: SET EQUALITY."<br>
axiomatization where<br>
Ax_x: "sF sID<br>
   (Forall p<br>
     (Forall q<br>
       (Iff (Eq p q) (Forall x (Iff (In x p) (In x q))))<br>
     )<br>
   )" and<br>
Ax_x2: "sF sID<br>
   (Iff (Eq p q) (Forall x (Iff (In x p) (In x q))))"</p>
<p>theorem "(sF sID (In x y)) &lt;-&gt; (inS x y)"<br>
   by(simp)</p>
<p>theorem "(sF sID (Eq x y)) &lt;-&gt; (x = y)"<br>
   by (metis sF.simps(2) sID_def)</p>
<p>--"THE AXIOM OF EXISTENCE: THE EMPTY SET EXISTS."<br>
consts emS :: "sT"</p>
<p>axiomatization where<br>
   Ax_e:  "sF sID (Forall x (Not (In x emS)))" and<br>
   Ax_e2: "sF sID (Not (In x emS))"</p>
<p>--"NO X EXISTS IN THE EMPTY SET."<br>
theorem "sF sID (Not (Exists x (In x emS)) )"<br>
   by (metis Ax_e sF.simps(3) sF.simps(8) sF.simps(9))</p>
<p>--"THE EMPTY SET IS UNIQUE."<br>
theorem "sF sID<br>
(Forall q<br>
   (Iff<br>
     (Forall x (Not (In x q)))<br>
     (Eq q emS)<br>
   )<br>
)"<br>
oops</p>
<p>theorem "sF sID<br>
   (Iff<br>
     (Forall x (Not (In x q)))<br>
     (Eq q emS)<br>
   )"<br>
--"Sledgehammer found a proof, but it takes longer to execute than I'm<br>
    willing to wait."<br>
--"by (metis Ax_e2 Ax_x2 sF.simps(1) sF.simps(3) sF.simps(7) sF.simps(8))"<br>
oops</p>
<p>--"THE RECURSIVE SET TYPE: Everything is built from emS."</p>
<p>--"The unordered pair set."<br>
consts upS :: "sT =&gt; sT =&gt; sT"</p>
<p>--"The separation set, 'all x in q such that P x'."<br>
consts seS :: "sT =&gt; (sT =&gt; bool) =&gt; sT"</p>
<p>datatype sTd =<br>
   emSd<br>
| upSd sTd sTd<br>
| seSd sTd "sT =&gt; bool"</p>
<p>fun sTf :: "sTd =&gt; sT" where<br>
   "sTf emSd       = emS"<br>
| "sTf (upSd p q) = upS (sTf p) (sTf q)"<br>
| "sTf (seSd q P) = seS (sTf q) P"</p>
<p>value "sTf emSd"<br>
value "sTf ( upSd emSd emSd )"<br>
value "sTf ( seSd q (%x. inS x emS) )"<br>
value "sTf ( seSd emSd (%x. inS x emS) )"<br>
value "sTf ( seSd emSd (%x. P) )"</p>
<p>end</p>



<a name="294232146"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232146" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232146">(Aug 19 2022 at 09:57)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
Hi,</p>
<p>I'm trying to set up this formula,</p>
<p>!q. !P. ?u. (!x. x \&lt;in&gt; u &lt;-&gt; (x \&lt;in&gt; q &amp; P x)),</p>
<p>so that P is only a FOL formula with a free variable x. I'm getting an <br>
error when I get to the part that uses quantification.</p>
<p>Currently P is of type (sT =&gt; bool), but I want to restrict it according <br>
to the following recursive definition:</p>
<p>Let x and y be variables, and let f and g be formulas, then<br>
x \&lt;in&gt; y is a formula,<br>
x = y is a formula,<br>
~(f) is a formula,<br>
(f &amp; g) is a formula,<br>
(f | g) is a formula,<br>
(f --&gt; g) is a formula,<br>
(f &lt;-&gt; g) is formula,<br>
(!x. f) is a formula,<br>
(?x. f) is a formula, and<br>
nothing else is a formula.</p>
<p>Really, all I want to do is restrict the syntax that can be used, but P <br>
has to have a type, P has to be based on recursion, and I have to use <br>
pattern matching, so I guess I have to use "datatype".</p>
<p>Here is what I have, where the last line causes an error, with the error <br>
shown below.</p>
<hr>
<p>typedecl sT</p>
<p>consts inS :: "sT =&gt; sT =&gt; bool" (infixl "inS" 55)</p>
<p>datatype sFOLdt =<br>
In sT sT<br>
|Eq sT sT<br>
|Not bool<br>
|And bool bool<br>
|Or bool bool<br>
|Imp bool bool<br>
|Iff bool bool<br>
|Forall sT bool</p>
<p>function sFOLf :: "sFOLdt =&gt; bool" where<br>
"sFOLf (In u1 u2) = (u1 inS u2)" |<br>
"sFOLf (Eq u1 u2) = (u1 = u2)" |<br>
"sFOLf (Not f) = (~(f))" |<br>
"sFOLf (And f1 f2) = (f1 &amp; f2)" |<br>
"sFOLf (Or f1 f2) = (f1 | f2)" |<br>
"sFOLf (Imp f1 f2) = (f1 --&gt; f2)" |<br>
"sFOLf (Iff f1 f2) = (f1 &lt;-&gt; f2)" |<br>
"sFOLf (Forall u f) = (!u. f)"</p>
<p>OUTPUT WINDOW ERROR:<br>
Additional type variable(s) in specification of "sFOLf_graph": 'a<br>
Specification depends on extra type variables: "'a"<br>
The error(s) above occurred in "sTs.sFOLf_sumC_def"<br>
The error(s) above occurred in definition "sFOLf_sumC_def":<br>
"(sFOLf_sumC ≡ (%(x::sFOLdt). (THE_default undefined (%(y::bool). <br>
(sFOLf_graph TYPE('a) x y)))))"</p>
<hr>
<p>I've attached a 33KB screen capture which shows the same thing. I <br>
switched the screen capture from JPG to PNG and it went from 244KB to <br>
33KB, using <a href="http://lightscreen.sourceforge.net/">http://lightscreen.sourceforge.net/</a></p>
<p>Thanks,<br>
GB<br>
<a href="/user_uploads/14278/fggTZ31-tU3IWnHPU1jW_JXH/function-error.1.png">function error.1.png</a></p>
<div class="message_inline_image"><a href="/user_uploads/14278/fggTZ31-tU3IWnHPU1jW_JXH/function-error.1.png" title="function error.1.png"><img src="/user_uploads/14278/fggTZ31-tU3IWnHPU1jW_JXH/function-error.1.png"></a></div>



<a name="294232162"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232162" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232162">(Aug 19 2022 at 09:57)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
Please change "function" to "fun".</p>
<p>It still works out the same. Without the "Forall" lines in my "datatype" <br>
and "fun", my sFOLf function terminates correctly with the message <br>
"Found termination order: "{}"".</p>
<p>Thanks,<br>
GB</p>



<a name="294232205"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232205" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232205">(Aug 19 2022 at 09:57)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
People can ignore what I was talking about, unless someone wants to give <br>
me a complete "datatype" and "fun/primrec" solution based on the <br>
informal, recursive definition I gave. Or a solution of another form <br>
would be okay.</p>
<p>Trying to figure out how recursion works, I have this experimental code:</p>
<p>typedecl sT<br>
consts inS :: "sT =&gt; sT =&gt; bool" (infixl "inS" 55)</p>
<p>datatype sFOLdt =<br>
   In     sT sT<br>
  |And    bool bool<br>
  |Rec    bool</p>
<p>primrec sFOLf :: "sFOLdt =&gt; bool" where<br>
   "sFOLf (In u1 u2)   = (u1 inS u2)"                           |<br>
   "sFOLf (And f1 f2)  = ((sFOLf (Rec f1)) &amp; (sFOLf (Rec f2)))" |<br>
   "sFOLf (Rec f)      = True"</p>
<p>which gives the error: Extra variables on rhs: "(sFOLf::(sFOLdt =&gt; bool))"</p>
<p>All that to say, trial and error has shown me I haven't understood <br>
certain basic things, but trial and error can be an excellent learning <br>
aid sometimes.</p>
<p>Regards,<br>
GB</p>



<a name="294232284"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232284" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232284">(Aug 19 2022 at 09:58)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
John,</p>
<p>No, you're on the mark. Thanks for the tip. That gets rid of that <br>
particular error, but there are some major problems still. I'm not doing <br>
any real recursion. Like for this statement,</p>
<p>"sFOLf (And f1 f2)  = (f1 &amp; f2)",</p>
<p>I would need to recurse on f1 and f2, but I'm not even close; that's all <br>
messed up. I get an error from trying</p>
<p>value "sFOLf (And True True)"</p>
<p>Alfio pointed out section 2.5.6 of the tutorial, page 19:</p>
<p><a href="http://isabelle.in.tum.de/website-Isabelle2012/dist/Isabelle2012/doc/tutorial.pdf">http://isabelle.in.tum.de/website-Isabelle2012/dist/Isabelle2012/doc/tutorial.pdf</a></p>
<p>Thanks,<br>
GB</p>



<a name="294232292"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232292" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232292">(Aug 19 2022 at 09:58)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Hi Gottfried,</p>
<p>you need to embed your formulas deeply in HOL, i.e., you cannot use the <br>
standard HOL connectives &amp;, |, !, etc. for your syntax. So you must use <br>
your formula datatype also for the subexpressions of your connectives:</p>
<p>datatype sFOLdt =<br>
   In sT sT<br>
| Eq sT sT<br>
| Not sFOLdt<br>
| And sFOLdt sFOLdt<br>
| Or sFOLdt sFOLdt<br>
| Imp sFOLdt sFOLdt<br>
| Iff sFOLdt sFOLdt<br>
| Forall sT sFOLdt</p>
<p>I am not sure what sT is supposed to stand for. Is it the type for <br>
variable names or the type of values that variables can take. In the <br>
former case: what is the type of values? In the latter case: this would <br>
be a very unusual setup, to mix values of variables (like in Eq and In) <br>
with name binding (like in Forall); in that case, replace sT with some <br>
type of variable names, e.g., string.</p>
<p>Your sFOLf function would then interpret such formulae in terms of HOL. <br>
However, you need to deal with variables (sT) that occur freely in your <br>
formula. They must be bound by some environment (I use val for the type <br>
of values that variables can take).</p>
<p>type_synonym env = (sT =&gt; val)</p>
<p>Then, your sFOLf function should look like this:</p>
<p>fun sFOLf :: "env =&gt; sFOLdt =&gt; bool"<br>
where<br>
   "sFOLf E (In x y) = inS x y"<br>
| "sFOLf E (Eq x y) = (E x = E y)<br>
| "sFOLf E (Not f) = \&lt;not&gt; (sFOLf E f)"<br>
| "sFOLf E (And f g) = (sFOLf E f &amp; sFOLf E g)"<br>
| "sFOLf E (Forall x f) = (!v. sFOLf (E(x := v)) f)"<br>
| ,.. (* remaining cases *)</p>
<p>Hope this helps,<br>
Andreas</p>



<a name="294232318"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232318" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232318">(Aug 19 2022 at 09:58)</a>:</h4>
<p>From: Lars Noschinski &lt;<a href="mailto:noschinl@in.tum.de">noschinl@in.tum.de</a>&gt;<br>
This definition is not primitive recursive and hence rejected by primrec <br>
(recursive calls my only make the arguments structurally smaller, so <br>
"sFOLf (Rec f1)" is not valid on the rhs.</p>
<p>-- Lars</p>



<a name="294232389"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232389" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232389">(Aug 19 2022 at 09:59)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
Lars,</p>
<p>That  was my experimental effort to force some termination; from that <br>
and some other ideas, I figured out I was too far off to stumble on to <br>
something that would make it all work.</p>
<p>However, it's not obvious to me why "sFOLf (Rec f1)" is not smaller. No <br>
matter what "f1" is, it looks like I should get ""sFOLf (Rec f1) = True" <br>
on the second call of sFOLf.</p>
<p>On the other hand, "((sFOLf (Rec f1)) &amp; (sFOLf (Rec f2)))" starts out as <br>
"bool &amp; bool", and it ends up as "bool &amp; bool", even with the recursive <br>
calls, so I guess that wouldn't be considered "structurally smaller". It <br>
would help if I had a more precise understanding of "structurally <br>
smaller", but I don't worry about that right now.</p>
<p>Thanks,<br>
GB</p>



<a name="294232410"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232410" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232410">(Aug 19 2022 at 09:59)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:webertj@in.tum.de">webertj@in.tum.de</a>&gt;<br>
You know that, but the primrec command doesn't. Quoting from Section<br>
10.3 of the Isabelle/Isar reference manual<br>
(<a href="http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2012/doc/isar-ref.pdf">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2012/doc/isar-ref.pdf</a>):</p>
<p>Each equation needs to be of the form:<br>
    f x1 ... xm (C y1 ... yk) z1 ... zn = rhs<br>
  such that C is a datatype constructor, rhs contains only the free<br>
  variables on the left-hand side (or from the context), and all<br>
  recursive occurrences of f in rhs are of the form f ... yi ...<br>
  for some i.</p>
<p>Best regards,<br>
Tjark</p>



<a name="294232420"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232420" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232420">(Aug 19 2022 at 09:59)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
On 1/18/2013 1:28 AM, Andreas Lochbihler wrote:</p>
<blockquote>
<p>you need to embed your formulas deeply in HOL, i.e., you cannot use <br>
the standard HOL connectives &amp;, |, !, etc. for your syntax. So you <br>
must use your formula datatype also for the subexpressions of your <br>
connectives:<br>
Hope this helps,<br>
Andreas,</p>
</blockquote>
<p>It helped a lot. I wouldn't have gotten to this next step without a fix.</p>
<p>I'll answer a few questions and then show you the failure I'm at now.</p>
<blockquote>
<p>I am not sure what sT is supposed to stand for. Is it the type for <br>
variable names or the type of values that variables can take. In the <br>
former case: what is the type of values?</p>
</blockquote>
<p>Type "sT" is a primitive type that represents a set. By "can take", I <br>
guess you mean "mapped to" as shown by your "env" below.</p>
<p>Semantically, I don't think a variable of type sT is mapped to another <br>
value in the sense of a function.</p>
<p>I have a function:</p>
<p>consts seS :: "sT =&gt; (sT =&gt; bool) =&gt; sT"</p>
<p>I then use a function of that type, (seS q P), in an axiom describing a <br>
property for every (q::sT) and (P::(sT =&gt; bool)), where P is a property <br>
that holds for q. (Actually the (sT =&gt; bool) type function is what I'm <br>
trying to tighten up with this sFOLf function.)</p>
<p>Variables of type sT are only used with the predicate \&lt;in&gt;, such as <br>
(x::sT \&lt;in&gt; y::sT), or as a binder variable in \&lt;exists&gt; or \&lt;forall&gt;, <br>
such as (!x. phi) or (? x. phi), where phi is a FOL formula built up <br>
starting with the atomic formulas (x \&lt;in&gt; y) and (x = y).</p>
<p>Variables of type sT are used in HOL functions, but that's only because <br>
that's how Isabelle makes me do it. The constant functions I define <br>
represent sets, and axioms are used to state what is true about those <br>
functions.</p>
<p>I could get more detailed, but I now get wellsortedness errors when <br>
trying to use the function sFOLf in a "value" statement.</p>
<p>The command</p>
<p>value "sFOLf1 sID (In x y)"</p>
<p>gives the error</p>
<p>"Wellsortedness error... Type sT not of sort equal. No type arity sT :: <br>
equal"</p>
<p>A similar error with "enum" in place of "equal" is after the third <br>
"value" command. The "Eq" and the "Forall" mess things up.</p>
<p>I'm trying to keep this short, but I'm not all that clear on the <br>
"environment" requirement. However, like I said, variables of type sT <br>
aren't really mapped anywhere.</p>
<p>To use the "value" command, I just made my "env" function the identity <br>
function.</p>
<p>The code is below, and I attached it as a THY.</p>
<p>Thanks for the help,<br>
GB</p>
<p>theory sts__sFOLdt<br>
imports Complex_Main<br>
begin</p>
<p>typedecl sT</p>
<p>consts inS :: "sT =&gt; sT =&gt; bool"</p>
<p>datatype sFOLdt =<br>
   In sT sT<br>
| Eq sT sT<br>
| Forall sT sFOLdt</p>
<p>type_synonym env = "(sT =&gt; sT)"</p>
<p>definition sID :: "sT =&gt; sT" where<br>
   "sID s = s"</p>
<p>fun sFOLf :: "env =&gt; sFOLdt =&gt; bool" where<br>
   "sFOLf E (In x y) = inS x y"</p>
<p>value "sFOLf sID (In x y)"</p>
<p>fun sFOLf1 :: "env =&gt; sFOLdt =&gt; bool" where<br>
   "sFOLf1 E (In x y) = inS x y"<br>
| "sFOLf1 E (Eq x y) = (E x = E y)"</p>
<p>value "sFOLf1 sID (In x y)"</p>
<p>fun sFOLf2 :: "env =&gt; sFOLdt =&gt; bool" where<br>
   "sFOLf2 E (In x y) = inS x y"<br>
| "sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)"</p>
<p>value "sFOLf2 sID (In x y)"</p>
<p>end<br>
<a href="/user_uploads/14278/3OFFHEM4TzPXLfrwwEcwkyYr/sTs__sFOLdt.thy">sTs__sFOLdt.thy</a></p>



<a name="294232429"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20Trying%20to%20use%20%22datatype%22%20to%20restrict%20types%20of%20.../near/294232429" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20Trying.20to.20use.20.22datatype.22.20to.20restrict.20types.20of.20.2E.2E.2E.html#294232429">(Aug 19 2022 at 09:59)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:gottfried.barrow@gmx.com">gottfried.barrow@gmx.com</a>&gt;<br>
I was actually looking at that last night, but with all the dots and <br>
with other information overload, I didn't sort much of it out, so thanks <br>
for the clarification.</p>
<p>I was mainly looking for examples to use as plug 'n play templates, <br>
which can get me some progress sometimes.</p>
<p>Thanks to John Wickerson also for a clarification on the same subject.</p>
<p>Regards,<br>
GB</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>