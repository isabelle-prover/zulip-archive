<html>
<head><meta charset="utf-8"><title>[isabelle] antiquotations · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html">[isabelle] antiquotations</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294055488"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294055488" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294055488">(Aug 18 2022 at 11:16)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
I'm having some trouble using antiquotations.</p>
<p>I find, for example that</p>
<p>val ls_sp = @{simproc let_simp} ;</p>
<p>works fine,  but</p>
<p>val ncn_sp = @{simproc natless_cancel_numerals} ;</p>
<p>doesn't work, message is<br>
 ***    ERROR "Undefined simplification procedure: <br>
\"natless_cancel_numerals\""</p>
<p>(and many more that I've tried also don't work).</p>
<p>How should I use these antiquotations?</p>
<p>Another problem I've found with antiquotations is that commenting them <br>
out doesn't work properly, thus</p>
<p>val ls_sp = @{simproc let_simp} ;<br>
(*<br>
val ncn_sp = @{simproc natless_cancel_numerals} ;<br>
*)</p>
<p>produces the same error message about natless_cancel_numerals</p>
<p>Jeremy</p>



<a name="294055505"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294055505" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294055505">(Aug 18 2022 at 11:16)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Dear Jeremy,</p>
<blockquote>
<p>I find, for example that</p>
<p>val ls_sp = @{simproc let_simp} ;</p>
<p>works fine,  but</p>
<p>val ncn_sp = @{simproc natless_cancel_numerals} ;</p>
<p>doesn't work, message is<br>
***    ERROR "Undefined simplification procedure: <br>
\"natless_cancel_numerals\""</p>
</blockquote>
<p>Hmmm... It seems that the difference is that "let_simp" was declared <br>
using the "simproc_setup" command (in HOL.thy), and the declaration of <br>
"natless_cancel_numerals" still happens using the (imperative) ML <br>
operations. This might be the reason for the anomaly, though I am not sure.</p>
<blockquote>
<p>Another problem I've found with antiquotations is that commenting them <br>
out doesn't work properly, thus</p>
<p>val ls_sp = @{simproc let_simp} ;<br>
(*<br>
val ncn_sp = @{simproc natless_cancel_numerals} ;<br>
*)</p>
<p>produces the same error message about natless_cancel_numerals</p>
</blockquote>
<p>Yes, this is probably worth improving: At the stage where the <br>
antiquotations are expended, comments are not taken into account.</p>
<p>I am sure, Makarius can comment on these issues when he is back from <br>
vacation.</p>
<p>Alex</p>



<a name="294055518"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294055518" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294055518">(Aug 18 2022 at 11:16)</a>:</h4>
<p>From: Amine Chaieb &lt;<a href="mailto:chaieb@in.tum.de">chaieb@in.tum.de</a>&gt;<br>
Alexander Krauss wrote:<br>
The @{simproc } Antiquotation just asks the context for a simproc <br>
declared under that name. If the simproc has not been "registered", it <br>
can not be found. The simproc_setup command does this consequently.</p>
<p>The distribution is not yet cleaned up in this aspect, i.e. not all <br>
simprocs are declared "officially".</p>
<p>Amine.</p>



<a name="294055730"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294055730" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294055730">(Aug 18 2022 at 11:18)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Having studied the recent threads on the "effect of use_thy", <br>
"antiquotations" etc. here is a summary in my own words, together with <br>
some additional hints on how to avoid problems with old ways of doing <br>
things, and moving on towards more powerful concepts.</p>
<p>* ML code should be used within a proper theory only, with explicit <br>
    "uses" declarations for the theory header specification for any "use"  <br>
    command in the body.  Inline "ML" commands work without further ado.</p>
<p>For historical reasons, the theory loader is a bit too liberal in <br>
    skimping over ill-specified dependencies, which occasionally results <br>
    in confusing situations, where the loader and the user disagree on the <br>
    state of a theory being fully loaded.  This will improve eventually, <br>
    as we remove more legacy features, especially the possibility of <br>
    loading ML files ``after a theory'', which has caused endless trouble <br>
    ever since it was introduced many years ago.  (Long ago this feature <br>
    was really needed, because it was impossible to prove theorems within <br>
    a theory body, which is hard to believe today.)</p>
<p>* The raw interactive ML toplevel is mostly obsolete.  After many years <br>
    of the two toplevels side-by-side, we have finally passed the turning <br>
    point where everything is Isar, and ML is smoothly integrated into <br>
    that.  Proper context-dependent antiquotations are just one benefit <br>
    from this principle, and typing additional ML {* *} should be a small <br>
    price to pay in current Proof General (adding a key binding to produce <br>
    that wrapping should be trivial anyway).</p>
<p>Further benefits of turning everything into Isar transactions will <br>
    become more relevant in the future.  The point is that this uniform <br>
    arrangement allows the Isar toplevel to ``manage'' isolated <br>
    executions.  For example, it enables to schedule transactions <br>
    concurrently (which is still limited to whole theory files in <br>
    Isabelle2007).  Or just think of interrupting individual Isar commands <br>
    instead of the whole Isabelle process with all its concurrent <br>
    transactions being worked on at some point.</p>
<p>If you really need the bare-metal feeling of the raw ML toplevel (e.g. <br>
    for special debugging situations), here is an easy way to get it with <br>
    proper Isar context, but without antiquotations:</p>
<p>theory A imports B begin<br>
      exit               (<em>leaving Isar for now</em>)<br>
      ML&gt; ...            (<em>raw ML text here</em>)<br>
      ML&gt; Isar.loop();   (<em>back to normal</em>)</p>
<p>This also works within a proof or locale contexte etc.</p>
<p>* ML functions that refer to the old-style (dynamic) context, such as <br>
    "the_context" and "thm" are very hard to understand exactly and should <br>
    be replaced more and more by proper antiquotations (which are <br>
    statically scoped at compile-time).</p>
<p>This means that pointing your finger at some bits of ML code, you <br>
    already know its context (i.e. where your finger is within the <br>
    Isabelle/Isar text), and any terms, thms etc. being referenced by <br>
    antiquotation are fixed values wrt. to that context.  Moreover there <br>
    is some degree of static checking of formal references.  For example, <br>
    @{const_name wf} or @{thm wf_induct} will only compile if these <br>
    entities are well-formed according to the compile-time context.</p>
<p>Slightly more delicate issues arise when ML implementations are moved <br>
    between contexts along with logical entities, by re-interpreting <br>
    general ``declarations'' wrt. to a given morphism.  Some recent papers <br>
    and talks by Chaieb/Wenzel explain these advanced concepts further.</p>
<p>* The expander for antiquotations is ignorant of ML syntax.  In <br>
    particular, Isar entities referenced inside ML comments are still <br>
    statically checked, which might occasionally appear more rigid than <br>
    expected.</p>
<p>At some later stage, the expansion mechanism might learn bits of ML <br>
    syntax (which is quite delicate), so this could be liberalized <br>
    eventually.  A more interesting application of ML syntax interacting <br>
    with Isar antiquotations is to produce different code in ML pattern <br>
    positions (of fun/case/let) vs. plain ML expressions.</p>
<p>* The @{theory} antiquotation requires special care, because it produces <br>
    a static reference to the current theory value, which is still <br>
    developed further in the present theory body.  If the ML environment <br>
    somehow keeps this value persistently, it is likely to cause ``stale <br>
    theory'' errors when accessed later.  As explained in the rudimentary <br>
    "Isabelle/Isar Implementation Manual", theory certificates work like a <br>
    linear type in ML, but a persistent @{theory} value violates the <br>
    linearity restriction.</p>
<p>In the worst case, one needs to keep a @{theory_ref} instead, which is <br>
    a sliding theory reference that never becomes stale, but may evolve <br>
    monotonically without further notice (just like the implicit theory <br>
    reference present within any @{context}, @{thm}, or @{cterm} value).</p>
<p>Luckily, raw theory values are rarely required these days, since <br>
    Proof.context has taken over its role to represent ``the context'' <br>
    most of the time. (In new-style local theory specifications, such as <br>
    definitions within a locale, the context is disguised as local_theory, <br>
    which is of the same ML type Proof.context, but holds additional <br>
    target information to tell how results are processed).</p>
<p>Makarius</p>



<a name="294056050"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056050" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056050">(Aug 18 2022 at 11:20)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Fri, 8 Feb 2008, Jeremy Dawson wrote:</p>
<blockquote>
<p>Mostly my problems are something do to with theories.  I don't know if <br>
the problems I've faced today are because of theories or not, but I <br>
think it is quite likely.  But I waste an enormous amount of time trying <br>
to cope with things that don't work as expected.</p>
</blockquote>
<p>The general advice is to let Isar take over control as much as possible, <br>
while avoiding raw ML accesses (in particular operations with unclear <br>
theory/proof context).</p>
<p>In particular:</p>
<p>- Use ProofGeneral by default.<br>
  - Always work within a theory body, if a theory is required.  Do not <br>
    rely on accidental theory states from previous use_thy etc.</p>
<p>- Use ML antiquotions as much as possible, because here the context is <br>
    checked statically at compile time.</p>
<blockquote>
<p>The latest example is contained in the attached theory file. For some <br>
reason the ML expression bool_axioms RL [fun_cong] produces an empty <br>
list of results when it appears in the theory file being loaded.</p>
<p>After the theory file is modified in the way shown (ie not using <br>
bool_axioms RL [fun_cong]) it loads OK.  Then, after that, the <br>
expression bool_axioms RL [fun_cong] returns exactly the results <br>
expected.  Why does the same ML expression behave differently at <br>
different points ?</p>
</blockquote>
<p>This is a good example why proper contexts matter.  The bool_axioms list <br>
is bound at the ML toplevel in a situation <em>before</em> certain type class <br>
instantiations in your theory.  For the resolution to work out, these type <br>
arities need to be present in the theory.  Your ML code fails to produce <br>
any result here, because it references bool_axioms in the raw ML <br>
environment, without going through the Isar layer, which would have <br>
transferred the result as required.</p>
<p>Using a proper ML antiquotation makes things work as expected:</p>
<p>@{thms bool_axioms} RL [fun_cong]</p>
<p>It is important to keep in mind that the ML environment is not the real <br>
thing, just a low-level view on the implementation platform.</p>
<p>Makarius</p>



<a name="294056089"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056089" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056089">(Aug 18 2022 at 11:20)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Makarius wrote:</p>
<blockquote>
<p>On Fri, 8 Feb 2008, Jeremy Dawson wrote:</p>
<blockquote>
<p>Mostly my problems are something do to with theories.  I don't know if <br>
the problems I've faced today are because of theories or not, but I <br>
think it is quite likely.  But I waste an enormous amount of time trying <br>
to cope with things that don't work as expected.<br>
</p>
</blockquote>
<p>The general advice is to let Isar take over control as much as possible, <br>
while avoiding raw ML accesses (in particular operations with unclear <br>
theory/proof context).</p>
<p>In particular:</p>
<p>- Use ProofGeneral by default.<br>
  - Always work within a theory body, if a theory is required.  Do not <br>
    rely on accidental theory states from previous use_thy etc.<br>
  - Use ML antiquotions as much as possible, because here the context is <br>
    checked statically at compile time.</p>
<blockquote>
<p>The latest example is contained in the attached theory file. For some <br>
reason the ML expression bool_axioms RL [fun_cong] produces an empty <br>
list of results when it appears in the theory file being loaded.</p>
<p>After the theory file is modified in the way shown (ie not using <br>
bool_axioms RL [fun_cong]) it loads OK.  Then, after that, the <br>
expression bool_axioms RL [fun_cong] returns exactly the results <br>
expected.  Why does the same ML expression behave differently at <br>
different points ?<br>
</p>
</blockquote>
<p>This is a good example why proper contexts matter.  The bool_axioms list <br>
is bound at the ML toplevel in a situation <em>before</em> certain type class <br>
instantiations in your theory.  For the resolution to work out, these type <br>
arities need to be present in the theory. <br>
Makarius,</p>
</blockquote>
<p>Thanks for this - I think I understand this point.</p>
<blockquote>
<p>Your ML code fails to produce <br>
any result here, because it references bool_axioms in the raw ML <br>
environment, without going through the Isar layer, which would have <br>
transferred the result as required.</p>
<p>However I don't understand this - as I said in my earlier email, exactly <br>
the same ML code _does_ produce the desired result later on.  So why <br>
does the _same_ ML expression behave _differently_ at different points <br>
?  Both the points where the ML expression bool_axioms RL [fun_cong] is <br>
used occur _after_ the point where fun is shown to be in the<br>
axclass boolean_class  (I understand that this is what the problem was).<br>
Using a proper ML antiquotation makes things work as expected:</p>
<p>@{thms bool_axioms} RL [fun_cong]</p>
<p>I gather your point is that</p>
</blockquote>
<p>@{thms bool_axioms}</p>
<p>transfers bool_axioms to the current theory.  But this is exactly what I <br>
don't want!<br>
My complaint is that the _same_ ML expression bool_axioms RL [fun_cong] <br>
behaves differently between (a) where I put it in the theory file, where <br>
it doesn't work, and (b) when I use it later, in trying to debug the <br>
problem.  I want the same expression to have the same meaning when I am <br>
trying to debug it as the meaning it has when it fails to work! </p>
<p>Incidentally, some years ago I discovered that thms "bool_axioms" <br>
retrieves the theorems<br>
bool_axioms, after transferring them to the current theory.  I asked how <br>
to retrieve named theorem(s) without transferring them to the current <br>
theory - no one then seemed to know.  Does anyone know how to do this?</p>
<p>Further questions from my previous email, whose answers would, I hope, <br>
help me to understand the complexities of theories in Isar:</p>
<p>theory_of_thm (hd bool_axioms); produces a different result inside the <br>
Isar file<br>
from the result it gives afterwards.  Why is this?</p>
<p>If I understand correctly the_context () returns the current theory as <br>
at the point where it is executed.  Is that correct?  </p>
<p>The difficulty in using Isar seems to be that the current theory keeps <br>
on changing, much more than with typical .ML proof files. Is this correct? </p>
<p>So far as I understood the previous emails,<br>
ML {* XXX the_context  () <em>} and ML {</em> XXX@{theory} *} would only return <br>
a different result if the code represented by XXX actually changed the <br>
current theory.  Is that correct?</p>
<p>A further question from a previous email (the answer given then was to <br>
use a different function) : bind_thm(s) seems to sometimes work (in the <br>
sense of storing a theorem in the database so that it can be effectively <br>
retrieved later).  Why is this?  What is the difference between bind_thm <br>
and the function I was told to use (ie, PureThy.add_thmss)?</p>
<p>Finally, is all this stuff documented anywhere?</p>
<blockquote>
<p>It is important to keep in mind that the ML environment is not the real <br>
thing, just a low-level view on the implementation platform.</p>
<p>I'm not sure what this means, but it is the language in which enormous <br>
amounts of Isabelle proofs are and have been written - and it is still <br>
the only language for doing lots of things (including some fairly <br>
mundane things, as my theory file showed) in Isabelle.</p>
</blockquote>
<p>Jeremy</p>



<a name="294056098"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056098" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056098">(Aug 18 2022 at 11:20)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Here are some references that might help:</p>
<ul>
<li>
<p>Makarius Wenzel and Burkhart Wolff. Building Formal Method Tools in the <br>
   Isabelle/Isar Framework. In Theorem Proving in Higher Order Logics, <br>
   TPHOLs 2007.<br>
<a href="http://www4.in.tum.de/~wenzelm/papers/isar-tool-framework.pdf">http://www4.in.tum.de/~wenzelm/papers/isar-tool-framework.pdf</a></p>
</li>
<li>
<p>Makarius Wenzel and Amine Chaieb. SML with antiquotations embedded into <br>
   Isabelle/Isar. In J. Carette and F. Wiedijk, editors. Programming <br>
   Languages for Mechanized Mathematics Workshop (CALCULEMUS 2007). <br>
<a href="http://www4.in.tum.de/~wenzelm/papers/Isar-SML.pdf">http://www4.in.tum.de/~wenzelm/papers/Isar-SML.pdf</a></p>
</li>
<li>
<p>Amine Chaieb and Makarius Wenzel. Context aware Calculation and <br>
   Deduction --- Ring Equalities via Gröbner Bases in Isabelle. In M. <br>
   Kauers, M. Kerber, R. Miner, and W. Windsteiger, editors. Towards <br>
   Mechanized Mathematical Assistants (CALCULEMUS 2007 and MKM 2007).<br>
<a href="http://www4.in.tum.de/~wenzelm/papers/context-methods.pdf">http://www4.in.tum.de/~wenzelm/papers/context-methods.pdf</a></p>
</li>
<li>
<p>Makarius Wenzel.  The Isabelle/Isar Implementation Manual.  Distributed <br>
   with Isabelle2007 (incomplete).<br>
<a href="http://isabelle.in.tum.de/dist/Isabelle/doc/implementation.pdf">http://isabelle.in.tum.de/dist/Isabelle/doc/implementation.pdf</a></p>
</li>
</ul>
<p>These things did not appear overnight out of the blue, but emerged from <br>
principles that have been present in Isabelle for many years already.</p>
<p>The following talk provides an overview of the general state of affairs of <br>
integrating everything into some kind of ``logical operating system'':</p>
<ul>
<li>Makarius Wenzel.<br>
   Aspects of locality in Isabelle --- local proofs, local theories, and <br>
   local everything.<br>
<a href="http://www.matf.bg.ac.yu/~janicic/locality.pdf">http://www.matf.bg.ac.yu/~janicic/locality.pdf</a></li>
</ul>
<p>When using the system you do not have to understand all the details, but <br>
merely sit back comfortably and let the framework do most of the job. <br>
Complications mostly arise from trying to challange things by interfering <br>
with the low-level implementation layer.</p>
<p>Makarius</p>



<a name="294056114"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056114" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056114">(Aug 18 2022 at 11:20)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Dear Jeremy,</p>
<p>In addition to the references, let me try to comment more specifically<br>
on some of your problems / complaints:</p>
<blockquote>
<p>My complaint is that the _same_ ML expression bool_axioms RL<br>
[fun_cong] behaves differently between (a) where I put it in the<br>
theory file, where it doesn't work, and (b) when I use it later, in<br>
trying to debug the problem.</p>
</blockquote>
<p>If your radio doesn't work in the cellar, but does work in the living<br>
room, then you cannot debug the problem in the living room. You have to<br>
go to the cellar.</p>
<blockquote>
<p>I want the same expression to have the same meaning when I am trying<br>
to debug it as the meaning it has when it fails to work!</p>
</blockquote>
<p>You should debug it in the same context: Open the offending theory in<br>
PG, step to the point until it breaks, and debug it there. Then you<br>
should be able to see what the problem is.</p>
<blockquote>
<p>If I understand correctly the_context () returns the current theory<br>
as at the point where it is executed.  Is that correct?<br>
[...]<br>
So far as I understood the previous emails, ML {* XXX the_context  ()<br>
<em>} and ML {</em> XXX@{theory} *} would only return a different result if<br>
the code represented by XXX actually changed the current theory.  Is<br>
that correct?</p>
</blockquote>
<p>No. Strictly speaking, the behaviour of the_context () is completely<br>
unspecified: Since theories can be loaded in parallel, you could get<br>
almost anything, including a theory that is currently developing in a<br>
different thread. The "current context" is not defined in terms of the<br>
point in time when something is executed. It must be given statically,<br>
by the location in the theory source. The @{theory} antiquotation does that.</p>
<p>Let me repeat: If you use "the_context ()" in production code, it will<br>
break with obscure errors sooner or later.</p>
<blockquote>
<p>A further question from a previous email (the answer given then was<br>
to use a different function) : bind_thm(s) seems to sometimes work<br>
(in the sense of storing a theorem in the database so that it can be<br>
effectively retrieved later).  Why is this?  What is the difference<br>
between bind_thm and the function I was told to use (ie,<br>
PureThy.add_thmss)?</p>
</blockquote>
<p>You can read the answer from its type:</p>
<p>bind_thms         : string * Thm.thm list -&gt; unit<br>
PureThy.add_thmss : ((bstring * Thm.thm list) * Thm.attribute list) list<br>
                 -&gt; Context.theory -&gt; Thm.thm list list * Context.theory</p>
<p>Since bind_thms is impure, it can only update some global reference<br>
hanging around. This is incompatible with paralellism. At the moment it<br>
may work sometimes, but it is guaranteed to break sooner or later.</p>
<p>These changes are necessary, since the ability to process theories in<br>
paralell decides whether you can use the 15 extra cores in your next CPU :-)</p>
<p>You can usually tell these "dont-use" functions from the type: If you<br>
feel they should depend on or change the theory or context, and this is<br>
not explicit in the type, then this is calling for trouble.</p>
<p>Since my comments above are a little non-constructive ("don't do this"),<br>
I had another look at the theory you sent recently. You just need to<br>
change a few things to avoid all the trouble.</p>
<ol>
<li>Instead of the (evil, imperative) bind_thms, use a proper<br>
declaration. On the theory level, the "setup" command will do what you<br>
need. It takes an ML snippet of type "theory -&gt; theory". In your example:</li>
</ol>
<p>setup {*<br>
   let<br>
     val boolexp = @{thm "boolexp"} ;</p>
<p>val bool_axioms = Seq.list_of (EVERY'<br>
       [REPEAT o dresolve_tac [conjunct1, conjunct2], REPEAT o etac allE,<br>
atac] 1<br>
         (boolexp RS revcut_rl)) ;<br>
   in<br>
     snd o PureThy.add_thmss [(("bool_axioms", bool_axioms), [])]<br>
   end<br>
*}</p>
<p>will do the right thing. If you find the syntax of PureThy.add_thmss too<br>
complicated, just define yourself a shortcut:</p>
<p>ML {*<br>
   fun save_thms (name, thms) =<br>
     snd o PureThy.add_thmss [((name, thms), [])]<br>
*}</p>
<ol start="2">
<li>Use antiquotations to refer to things from the context. Don't use the<br>
imperative "thm" or "thms". They have no context, so they are bad :-).</li>
</ol>
<p>I recognise that it is hard to "unlearn" these things when they have<br>
worked for you all the years. But it is really necessary to change them <br>
(and thus break backwards compatibility) in order to bring Isabelle <br>
forward.  But in the end, it should not be so difficult to solve your <br>
concrete problems.</p>
<p>I hope this helps... Please don't hesitate to ask if you run into more <br>
problems, and include theory files whenever you can.</p>
<p>All the best,<br>
Alex</p>



<a name="294056123"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056123" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056123">(Aug 18 2022 at 11:20)</a>:</h4>
<p>From: Stefan Berghofer &lt;<a href="mailto:berghofe@in.tum.de">berghofe@in.tum.de</a>&gt;<br>
Jeremy Dawson wrote:<br>
Dear Jeremy,</p>
<p>the reason for this effect is that each theorem contains an ML reference<br>
pointing to the theory it has been proved in (or been looked up in). The<br>
theorems contained in bool_axioms refer to some intermediate theory that<br>
does not yet contain the information that fun is in boolean_class. However,<br>
as soon as your theory has been completely processed, all theorems that<br>
have been proved in the preceeding intermediate theories are promoted to<br>
theorems that are also valid in the final theory. This is done by<br>
(imperatively!) updating the theory references contained in the theorems,<br>
which explains why the very same ML expression (denoting a data structure<br>
containing a reference) suddenly behaves in a different way.</p>
<p>This usage of references might indeed seem a bit strange at first sight,<br>
but it seems to be the only way to achieve that definitions and proofs<br>
may be intermixed within the same theory, which was impossible with the<br>
implementation of theories we had in Isabelle more than a decade ago.</p>
<p>An effect similar to the one that you have noticed can be produced by<br>
executing the ML command</p>
<p>Type.of_sort (Sign.tsig_of (theory_of_thm (hd bool_axioms)))<br>
     (Type ("fun", [TFree ("'a", HOLogic.typeS), TFree ("'b", ["BI.boolean_class"])]),<br>
      ["BI.boolean_class"])</p>
<p>for checking whether a function type is a member of boolean_class. This<br>
expression returns "false" when executed inside your theory, but "true"<br>
when executed outside your theory, because the theory returned by<br>
"theory_of_thm ..." is changed when closing the theory.</p>
<p>Greetings,<br>
Stefan</p>



<a name="294056290"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056290" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056290">(Aug 18 2022 at 11:22)</a>:</h4>
<p>From: Lucas Dixon &lt;<a href="mailto:ldixon@inf.ed.ac.uk">ldixon@inf.ed.ac.uk</a>&gt;<br>
-----BEGIN PGP SIGNED MESSAGE-----<br>
Hash: SHA1</p>
<p>Alexander Krauss wrote:<br>
I'm curious about this: is it really the case that references are<br>
inherently incompatible with parallelism? Is there some reason why it<br>
cannot update a thread-local reference?</p>
<p>I would expect that you can cut the Isar/ML cake both ways:<br>
anti-quotations in Isar or quotations in ML. I feel there should be a<br>
confluence proof there somewhere :)</p>
<p>So, is there some reason this is not possible? In particular, Isar is<br>
executed in ML, so it seems rather strange to me that you cannot<br>
replicate it's effect in ML, for example by pasting the function calls<br>
used by Isar into the ML.</p>
<p>cheers,<br>
lucas<br>
-----BEGIN PGP SIGNATURE-----<br>
Version: GnuPG v1.4.6 (GNU/Linux)<br>
Comment: Using GnuPG with Mozilla - <a href="http://enigmail.mozdev.org">http://enigmail.mozdev.org</a></p>
<p>iD8DBQFHs4HXogMqU4edHsMRAjj/AJ0fAFJEtuZYSsziwW/nTSJqqHNJsQCdFCyS<br>
aOP6FBuIs/se0AyydGDCyqM=<br>
=UlWW<br>
-----END PGP SIGNATURE-----</p>



<a name="294056428"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056428" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056428">(Aug 18 2022 at 11:22)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Lucas Dixon wrote:<br>
Lucas / Alexander,</p>
<p>Well, yes, one would think so.</p>
<p>Perusing the source code, I see a function called<br>
eval_antiquotes (to be exact, I used !ML_Context.eval_antiquotes_fn)</p>
<p>which gives results like this:</p>
<p>val eval_antiquotes = !ML_Context.eval_antiquotes_fn ;<br>
eval_antiquotes "val x = y ; val c = @{context} ; \<br>
  \ val a = b ; val cs = @{claset} ; val t = @{theory}" ;<br>
val eval_antiquotes = fn : string -&gt; string * string</p>
<blockquote>
<h1>val it =</h1>
<p>("structure Isabelle =\nstruct\nval context = <br>
ML_Context.the_local_context ();\nval claset = Classical.local_claset_of <br>
(ML_Context.the_local_context ());\nval thy = ML_Context.the_context <br>
();\nend;",<br>
      "val x = y ; val c = Isabelle.context ;  val a = b ; val cs = <br>
Isabelle.claset ; val t = Isabelle.thy")<br>
: string * string</p>
</blockquote>
<p>Is this in fact used when the system encounters code such as</p>
<p>ML {* val x = y ; val c = @{context} ; \<br>
  \ val a = b ; val cs = @{claset} ; val t = @{theory} *} ?</p>
<p>Or to be exact, is this translated code executed when the system <br>
encounters the<br>
ML {* ... *} ?  If not, what exactly does happen ?</p>
<p>If so, how does it work that in this case calls such as <br>
ML_Context.the_context () are safe to use ? (in general when are they <br>
safe and when not ?)</p>
<p>In terms of threads in general:<br>
When you're sitting at the terminal typing input into Isar, it gets <br>
executed in the context of  a particular theory, doesn't it ?  Obviously <br>
it manages to avoid any ambiguity (ie, it doesn't execute it in the <br>
context of some other theory which is currently developing in a <br>
different thread. How does it identify which is the relevant theory ? </p>
<p>Regards,</p>
<p>Jeremy</p>



<a name="294056478"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056478" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056478">(Aug 18 2022 at 11:22)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Wed, 13 Feb 2008, Lucas Dixon wrote:</p>
<blockquote>
<p>Alexander Krauss wrote:</p>
<blockquote>
<p>Since bind_thms is impure, it can only update some global reference<br>
hanging around. This is incompatible with paralellism. At the moment it<br>
may work sometimes, but it is guaranteed to break sooner or later.</p>
</blockquote>
<p>I'm curious about this: is it really the case that references are<br>
inherently incompatible with parallelism? Is there some reason why it<br>
cannot update a thread-local reference?</p>
</blockquote>
<p>In principle you can do this, but this requires extra bookeeping of some <br>
kind of ``thread data environment''.  In post-Isabelle2007 we already have <br>
this for the "print_mode", which is now thread-safe without giving up the <br>
slightly odd "setmp" idiom. Such contraptions should be the exeption, not <br>
the rule.</p>
<p>Even Java programmers have started to envy powerful concepts of purely <br>
functional programming, which partly explains the current excitement about <br>
Scala.</p>
<blockquote>
<p>I would expect that you can cut the Isar/ML cake both ways: <br>
anti-quotations in Isar or quotations in ML. I feel there should be a <br>
confluence proof there somewhere :)</p>
</blockquote>
<p>In principle yes.  This is a bit like the Holo Deck in Startrek TNG, which <br>
is sufficiently powerful to simulate another Enterprise with another fully <br>
functional Holo Deck inside -- potentially ad infinitum.  In the end it is <br>
a matter of practical concern which level to take as primary one, which as <br>
secondary, and stop the nesting at some point.</p>
<blockquote>
<p>So, is there some reason this is not possible? In particular, Isar is <br>
executed in ML, so it seems rather strange to me that you cannot <br>
replicate it's effect in ML, for example by pasting the function calls <br>
used by Isar into the ML.</p>
</blockquote>
<p>Since the Isar toplevel is more powerful than the raw ML one, the choice <br>
of preference is clear to me.  Also you don't want your ``operating <br>
system'' code (i.e. the Isar infrastructure) pasted into your application <br>
code.  Moreover, we have recently started to repair some defects in <br>
versions of SML/ML, by passing through our management of ML sources within <br>
Isar.</p>
<p>Makarius</p>



<a name="294056498"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056498" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056498">(Aug 18 2022 at 11:22)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Thu, 14 Feb 2008, Jeremy Dawson wrote:</p>
<blockquote>
<p>Perusing the source code, I see a function called<br>
eval_antiquotes (to be exact, I used !ML_Context.eval_antiquotes_fn)</p>
<p>which gives results like this:</p>
<p>val eval_antiquotes = !ML_Context.eval_antiquotes_fn ;<br>
eval_antiquotes "val x = y ; val c = @{context} ; \<br>
 \ val a = b ; val cs = @{claset} ; val t = @{theory}" ;<br>
val eval_antiquotes = fn : string -&gt; string * string</p>
<blockquote>
<h1>val it =</h1>
<p>("structure Isabelle =\nstruct\nval context = ML_Context.the_local_context<br>
();\nval claset = Classical.local_claset_of (ML_Context.the_local_context<br>
());\nval thy = ML_Context.the_context ();\nend;",<br>
     "val x = y ; val c = Isabelle.context ;  val a = b ; val cs =<br>
Isabelle.claset ; val t = Isabelle.thy")<br>
: string * string</p>
</blockquote>
<p>Is this in fact used when the system encounters code such as</p>
<p>ML {* val x = y ; val c = @{context} ; \<br>
 \ val a = b ; val cs = @{claset} ; val t = @{theory} *} ?</p>
<p>Or to be exact, is this translated code executed when the system encounters<br>
the<br>
ML {* ... *} ?</p>
</blockquote>
<p>Yes, here you see the compile time Isar context closure wrapped around ML <br>
text issued to the underlying platform.  Our previously mentioned paper <br>
about SML-antiquotations is explains this in a more abstract fashion.</p>
<blockquote>
<p>If so, how does it work that in this case calls such as <br>
ML_Context.the_context () are safe to use ? (in general when are they <br>
safe and when not ?)</p>
</blockquote>
<p>Here it is safe, because it runs in a critical section -- just for compile <br>
time.  Later at run-time, where the actual work happens, eveything is <br>
purely functional and enables proper paralellism without further worries.</p>
<blockquote>
<p>In terms of threads in general: When you're sitting at the terminal <br>
typing input into Isar, it gets executed in the context of a particular <br>
theory, doesn't it ?  Obviously it manages to avoid any ambiguity (ie, <br>
it doesn't execute it in the context of some other theory which is <br>
currently developing in a different thread. How does it identify which <br>
is the relevant theory ?</p>
</blockquote>
<p>It is determined from the context :-)</p>
<p>Pointing your finger at a particular position in Isar source text, you <br>
determine a certain context once and for all.  Any embedded ML code at <br>
that point will keep this as a first-class value (of type Proof.context) <br>
for later use at run-time; provided proper antiquotations are used.  So <br>
this is just the well-known static closure principle applied to <br>
Isabelle/Isar + embedded ML.</p>
<p>In contrast, low-level access to global references buys you dynamic <br>
scoping in the best case, and erratic non-determinism in the worst case. <br>
This is why thm"foo", thms"foo", the_context() are all bad.</p>
<p>Makarius</p>



<a name="294056513"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056513" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056513">(Aug 18 2022 at 11:22)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
^^^^^^</p>
<p>This should read SML/NJ (we've managed to replace 5 integer types by just <br>
one true version).</p>
<p>Makarius</p>



<a name="294056565"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056565" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056565">(Aug 18 2022 at 11:23)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Makarius wrote:</p>
<blockquote>
<blockquote>
<p>If so, how does it work that in this case calls such as <br>
ML_Context.the_context () are safe to use ? (in general when are they <br>
safe and when not ?)<br>
</p>
</blockquote>
<p>Here it is safe, because it runs in a critical section -- just for compile <br>
time.  Later at run-time, where the actual work happens, eveything is <br>
purely functional and enables proper paralellism without further worries.</p>
<p>Makarius,</p>
</blockquote>
<p>How do these critical sections work?  Is it to do with the function <br>
CRITICAL which appears in the source code?</p>
<blockquote>
<blockquote>
<p>In terms of threads in general: When you're sitting at the terminal <br>
typing input into Isar, it gets executed in the context of a particular <br>
theory, doesn't it ?  Obviously it manages to avoid any ambiguity (ie, <br>
it doesn't execute it in the context of some other theory which is <br>
currently developing in a different thread. How does it identify which <br>
is the relevant theory ?<br>
</p>
</blockquote>
<p>It is determined from the context :-)</p>
<p>The question relates to what the system does.  That is to say, when I am <br>
sitting at the terminal and type in ML {* val a = @{context} *} what is <br>
the ML code which the system evaluates ?  I want to know what ML code I <br>
would put there which would achieve exactly the same effect.<br>
Pointing your finger at a particular position in Isar source text, you <br>
determine a certain context once and for all.  Any embedded ML code at <br>
that point will keep this as a first-class value (of type Proof.context) <br>
for later use at run-time; provided proper antiquotations are used.  So <br>
this is just the well-known static closure principle applied to <br>
Isabelle/Isar + embedded ML.<br>
</p>
</blockquote>
<blockquote>
<p>In contrast, low-level access to global references buys you dynamic <br>
scoping in the best case, and erratic non-determinism in the worst case. <br>
This is why thm"foo", thms"foo", the_context() are all bad.</p>
<p>So what functions, _in ML_, are good, for these purposes? </p>
</blockquote>
<p>Jeremy</p>
<blockquote>
<p>Makarius</p>
</blockquote>



<a name="294056579"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056579" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056579">(Aug 18 2022 at 11:23)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Makarius wrote:</p>
<blockquote>
<blockquote>
<p>So, is there some reason this is not possible? In particular, Isar is <br>
executed in ML, so it seems rather strange to me that you cannot <br>
replicate it's effect in ML, for example by pasting the function calls <br>
used by Isar into the ML.<br>
</p>
</blockquote>
<p>Since the Isar toplevel is more powerful than the raw ML one, <br>
I don't get this.  Is it in fact true that Isabelle (including Isar) is <br>
(entirely) written in ML?<br>
If so, how can you do things in Isar that can't be done in ML?</p>
</blockquote>
<p>Jeremy</p>
<blockquote>
<p>Makarius</p>
</blockquote>



<a name="294056610"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056610" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056610">(Aug 18 2022 at 11:23)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Fri, 15 Feb 2008, Jeremy Dawson wrote:</p>
<blockquote>
<p>How do these critical sections work?  Is it to do with the function <br>
CRITICAL which appears in the source code?</p>
</blockquote>
<p>See appendix A.2 of the fragmentary Isabelle/Isar implementation manual. <br>
It explains the programming model for multithreaded Isabelle; the short <br>
and simple message is: do it purely functionally and in accord with the <br>
official concepts of context (as a plain value).</p>
<p>In rare situations, user code may also have to synchronize things <br>
explicitly, but well-behaved programs should only do this for tiny amounts <br>
of time, i.e. refrain from any real computations / proof search inside a <br>
critical section.</p>
<blockquote>
<p>The question relates to what the system does.  That is to say, when I am <br>
sitting at the terminal and type in ML {* val a = @{context} *} what is <br>
the ML code which the system evaluates ?  I want to know what ML code I <br>
would put there which would achieve exactly the same effect.</p>
</blockquote>
<p>You can look at the Isar implementation to find out the details, just for <br>
curiosity.  It is of course out of question to attempt to interfere with <br>
the existing infrastructure in user ML code.</p>
<blockquote>
<blockquote>
<p>In contrast, low-level access to global references buys you dynamic <br>
scoping in the best case, and erratic non-determinism in the worst <br>
case. This is why thm"foo", thms"foo", the_context() are all bad.</p>
<p>So what functions, _in ML_, are good, for these purposes? </p>
</blockquote>
</blockquote>
<p>Basically none.  You can refer to the compile time context using <br>
@{context}, or get a runtime context as explicit functional argument from <br>
somewhere else.  For example, a proof method is essentially a function <br>
Proof.context -&gt; args -&gt; tactic, and your implementation will be something <br>
like (fn ctxt =&gt; fn args =&gt; ...), so you get the context ``by induction <br>
hypothesis'' over the structure of your program.</p>
<p>Concerning theorem lookup, ProofContext.get_thm: Proof.context -&gt; thmref<br>
-&gt; thm enables to retrieve named facts from a given context, but it is<br>
rarely useful within abstract code, because the name spacing rules behind <br>
this are quite delicate.  Better refer to proper theorem <em>values</em> <br>
directly, either via @{thm ...} at compile time, or by using well-typed <br>
interfaces to derived context data, such as DatatypePackage.the_datatype <br>
or similar operations of whatever tool you build yourself.</p>
<p>The general idea of strongly-typed context data is explained in section <br>
1.1 in the Isabelle/Isar implementation manual.</p>
<p>Makarius</p>



<a name="294056751"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056751" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056751">(Aug 18 2022 at 11:24)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Makarius et al,</p>
<p>At present I have a function modify_ss (of type  : <br>
MetaSimplifier.simpset -&gt; MetaSimplifier.simpset).</p>
<p>It is used in a further function</p>
<p>fun modified_ss () = modify_ss (simpset ()) ;</p>
<p>Now I observe that</p>
<p>val simpset = simpset_of o ML_Context.the_context;</p>
<p>and given the previous remarks about using the_context () I assume that <br>
you wouldn't approve of using simpset (), either.  Is that correct?</p>
<p>But if I understand the previous emails correctly, to write<br>
fun modified_ss () = modify_ss (simpset_of @{theory}) ;<br>
would have the effect that the simpset used was invariably one <br>
particular simpset, namely that relevant when the text "@{theory}" was <br>
interpreted.</p>
<p>But I want modified_ss () to take the simpset relevant at the time it is <br>
called, and modify it.</p>
<p>How do I define modified_ss in the approved way - using antiquotations <br>
as and where appropriate ?</p>
<p>Jeremy</p>



<a name="294056809"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056809" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056809">(Aug 18 2022 at 11:24)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Thu, 21 Feb 2008, Jeremy Dawson wrote:</p>
<blockquote>
<p>At present I have a function modify_ss (of type  : MetaSimplifier.simpset -&gt;<br>
MetaSimplifier.simpset).</p>
<p>It is used in a further function</p>
<p>fun modified_ss () = modify_ss (simpset ()) ;</p>
<p>Now I observe that</p>
<p>val simpset = simpset_of o ML_Context.the_context;</p>
<p>and given the previous remarks about using the_context () I assume that you<br>
wouldn't approve of using simpset (), either.  Is that correct?</p>
</blockquote>
<p>Yes, the simpset() form is indeed a legacy feature.  If it occurs in <br>
one-shot scripts, it can usually be replaced by the static version <br>
@{simpset}; the same for @{claset} or @{clasimpset}.</p>
<p>Your application sounds more like requiring a run-time context, though. So <br>
assuming you have a proper value (ctxt: Proof.context) already, you may <br>
get the simpset component like this:</p>
<p>local_simpset_of ctxt</p>
<p>and then add your stuff to the result.</p>
<blockquote>
<p>How do I define modified_ss in the approved way - using antiquotations <br>
as and where appropriate ?</p>
</blockquote>
<p>Most likely, no antiquotations will get involved here, because you are <br>
working only with a runtime context.  You still need to get hold of that, <br>
i.e. ``by induction over the structure of your code'' as explained <br>
earlier.</p>
<p>Makarius</p>



<a name="294056856"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056856" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056856">(Aug 18 2022 at 11:25)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Dear Jeremy,</p>
<p>That depends on the application.</p>
<p>You use "setup", when you want to apply the function to the current <br>
theory at that point in the source. This can be used e.g. to</p>
<p>- install new commands, methods and attributes</p>
<p>- Do something else (definitions, proofs or anything) at a<br>
    specific point.</p>
<p>On the other hand, if you are adding something like a method (=Isar <br>
version of a tactic), then you are usually given a theory (or a <br>
Proof.context) by the framework.</p>
<p>Can you describe your application (i.e. what does "addsm" do and how <br>
should it be used on a theory), then I can be more concrete.</p>
<p>Alex</p>



<a name="294056868"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294056868" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294056868">(Aug 18 2022 at 11:25)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Alexander Krauss wrote:<br>
Dear Alexander,</p>
<p>thanks - OK, now I've got a function of a type which hopefully doesn't <br>
use any impure features:</p>
<h1>val addsm = fn : Context.theory -&gt; Context.theory</h1>
<p>Now, what do I do with it? </p>
<p>(Your email showed an example using setup {* ... : theory -&gt; theory *},<br>
 but I have this function, and want to use it, inside an ML file which <br>
is to be "used" by a theory)</p>
<p>regards,</p>
<p>Jeremy Dawson</p>



<a name="294057220"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294057220" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294057220">(Aug 18 2022 at 11:28)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Makarius wrote:</p>
<blockquote>
<p>Having studied the recent threads on the "effect of use_thy", <br>
"antiquotations" etc. here is a summary in my own words, together with <br>
some additional hints on how to avoid problems with old ways of doing <br>
things, and moving on towards more powerful concepts.</p>
<p>* The raw interactive ML toplevel is mostly obsolete.  After many years <br>
    of the two toplevels side-by-side, we have finally passed the turning <br>
    point where everything is Isar, and ML is smoothly integrated into <br>
    that.  Proper context-dependent antiquotations are just one benefit <br>
    from this principle, and typing additional ML {* *} should be a small <br>
    price to pay in current Proof General (adding a key binding to produce <br>
    that wrapping should be trivial anyway).</p>
<p>Unfortunately the integration isn't "smooth".  In fact I'm working on a <br>
project now where it is demanded that everything is in Isar, so I have <br>
to try to work in this way.  And it is incredibly frustrating, because <br>
things seem to sometimes work, and sometimes not, with no apparent <br>
reason, seemingly randomly.</p>
</blockquote>
<p>Mostly my problems are something do to with theories.  I don't know if <br>
the problems I've faced today are because of theories or not, but I <br>
think it is quite likely.  But I waste an enormous amount of time trying <br>
to cope with things that don't work as expected.  What is a simple job <br>
when I'm doing proofs using "the raw interactive ML toplevel" becomes <br>
slow and frustrating when I try to use Isar as much as possible, while <br>
using ML for the things not available in Isar.</p>
<p>The latest example is contained in the attached theory file.<br>
For some reason the ML expression bool_axioms RL [fun_cong] produces an <br>
empty list of results when it appears in the theory file being loaded.</p>
<p>After the theory file is modified in the way shown (ie not using <br>
bool_axioms RL [fun_cong]) it loads OK.  Then, after that, the <br>
expression bool_axioms RL [fun_cong]<br>
returns exactly the results expected.  Why does the same ML expression <br>
behave differently at different points ?</p>
<p>Why is this?  I suspect it is to do with theories, and noted that<br>
theory_of_thm (hd bool_axioms); produces a different result inside the <br>
Isar file<br>
from the result it gives afterwards.  Why is this?</p>
<p>I waste an enormous amount of time trying to cope with things that don't <br>
work as expected.  When a proof works fine at the terminal, but doesn't <br>
work when you put it into a theory file and load that theory file, <br>
debugging the situation is very difficult. (This is quite apart from the <br>
fact that debugging Isar is naturally more difficult than debugging ML, <br>
because when you load an ML proof file that fails, the theorems proved <br>
prior to the failure are there for you to use).</p>
<p>Something that is a simple job when I'm doing proofs solely in ML <br>
becomes slow and frustrating when I try to use Isar as much as possible <br>
(and ML for the things not available in Isar.)  Often it seems to be <br>
something to do with theories.  And although I've been using Isabelle <br>
for over 10 years now, it seems that these difficulties have only arisen <br>
in the last few years, and mostly to do with trying to use Isar.  In <br>
short, using Isar is so much more difficult than using pure ML for <br>
proofs. (Of course, learning two languages instead of one is no doubt <br>
part of the reason also).</p>
<blockquote>
<p>* ML functions that refer to the old-style (dynamic) context, such as <br>
    "the_context" and "thm" are very hard to understand exactly and should <br>
    be replaced more and more by proper antiquotations (which are <br>
    statically scoped at compile-time).</p>
<p>If I understand correctly the_context () returns the current theory as <br>
at the point where it is executed.  Is that correct?  If so, it doesn't <br>
seem so hard to understand.  But - again I may be wrong here - the <br>
difficulty in using Isar seems to be that the current theory keeps on <br>
changing, much more than with typical .ML proof files.<br>
So far as I understood the previous emails,<br>
ML {* XXX the_context  () <em>} and ML {</em> XXX@{theory} *} would only return <br>
a different result if the code represented by XXX actually changed the <br>
current theory.  Is that correct?</p>
</blockquote>
<p>Anyway, attached is the theory file that has taken so much of my time.<br>
If the experts could tell me why bffcs0 is different from bffcs1-3, I'd <br>
be grateful.</p>
<p>Regards,</p>
<p>Jeremy Dawson</p>



<a name="294057376"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294057376" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294057376">(Aug 18 2022 at 11:29)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Jeremy Dawson wrote:<br>
After spending so long composing an email, I forgot to attach the file, <br>
here it is.</p>
<p>Thanks,</p>
<p>Jeremy<br>
<a href="/user_uploads/14278/GSJPSTmy_0AxCA8nf3TBD0ct/BI.thy">BI.thy</a></p>



<a name="294057640"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294057640" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294057640">(Aug 18 2022 at 11:31)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
Makarius wrote:</p>
<p>In relation to advocating the use of antiquotations, you said:<br>
(this was in relation to advocating the use of antiquotations)</p>
<p>But now I find that using @{theory} instead of the_context () produces <br>
an error</p>
<p>Exception-<br>
   ERROR<br>
      "Stale theory encountered:\n{ProtoPure, Pur (etc)</p>
<p>When I change this back to the_context () the error goes away.</p>
<p>What is a stale theory, and why does @{theory} produce a stale theory?</p>
<p>Jeremy Dawson</p>



<a name="294057673"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294057673" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294057673">(Aug 18 2022 at 11:31)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
As explained in the Isar Implementation Manual, theory acts like a linear <br>
type.  The "Stale theory" error indicates that it has been used in <br>
non-linerar fashion.</p>
<p>Note that @{theory} is rarely used in production code, only in one-liner <br>
tests within a toplevel ML command etc.  If you really need to keep a live <br>
reference to a (potentially evolving) theory, then use @{theory_ref}.</p>
<p>Normally one would just pass through a Proof.context, instead of <br>
manipulating with low-level theory certificates.</p>
<p>Makarius</p>



<a name="294733592"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294733592" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294733592">(Aug 22 2022 at 17:22)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
The canonical documentation for Isabelle/ML is the "implementation"<br>
manual. You can look at the index for Isar.goal or use Isabelle/jEdit to<br>
make a hypersearch for it on all documentation sources:<br>
$ISABELLE_HOME/src/Doc -- the latter gives a "live" view on that<br>
document (including example snippets) in the Prover IDE.</p>
<p>Anyway, I suspect that Jeremy wants to recreate the look-and-feel of<br>
different system called "Isabelle98" from 20 years ago. For that, the<br>
proof method called "tactic" might help: it is documented in the<br>
"isar-ref" manual, section "7.3: Tactics -- improper proof methods".<br>
This already indicates that we are looking at fringe topics of Isabelle2017.</p>
<p>Makarius</p>



<a name="294733924"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294733924" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294733924">(Aug 22 2022 at 17:25)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:Jeremy.Dawson@anu.edu.au">Jeremy.Dawson@anu.edu.au</a>&gt;<br>
Hi Makarius,</p>
<p>Thanks - what I really meant when I asked about documentation was, how <br>
do I find out how to get the goal as an ML value when I don't already <br>
know the answer to that question.  I agree that if I know the answer <br>
then it's easy to find it in the canonical documentation.</p>
<p>In fact the preceding section in the Implementation manual is about the <br>
Proof structure, which also looks as though it contains useful stuff, <br>
except that one needs to get hold of the current proof state.  How do <br>
you get the current proof state as an ML value?</p>
<p>Thanks for the pointer about apply tactic ..., yes it's possible to <br>
write a tactic which does nothing but print out the goal, and can use <br>
the goal as an ML value within the tactic, but when I tried to define a <br>
reference value in which to save the goal value I found I couldn't.  Has <br>
the version of ML available to Isar users been jinxed, or something, so <br>
that reference variables don't work?</p>
<p>For your information, I don't want to recreate the look-and-feel of<br>
(what you now, I think correctly, admit is a) different system called <br>
"Isabelle98".  I just want to get stuff done.  The sort of stuff (like <br>
finding out how to get hold of the current goal) that takes no time at <br>
all in HOL4 or Isabelle2005 (which is actually what I use when I'm <br>
building on previous work) and takes hours in your Isabelle 2017</p>
<p>Incidentally, on the subject of documentation - what about the Isabelle <br>
cookbook - why isn't it included as part of the Isabelle documentation <br>
(and kept up to date)?</p>
<p>Cheers,</p>
<p>Jeremy</p>



<a name="294734107"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294734107" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294734107">(Aug 22 2022 at 17:26)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On 05/06/18 04:12, Jeremy Dawson wrote:</p>
<blockquote>
<p>In fact the preceding section in the Implementation manual is about the<br>
Proof structure, which also looks as though it contains useful stuff,<br>
except that one needs to get hold of the current proof state.  How do<br>
you get the current proof state as an ML value?</p>
</blockquote>
<p>E.g. like this:</p>
<p>lemma "x = x"<br>
  ML_val ‹@{Isar.goal}›<br>
  ML_val ‹Toplevel.proof_of @{Isar.state}›</p>
<p>This has little practical relevance though. We are merely toying around<br>
with details of the implementation here.</p>
<blockquote>
<p>Thanks for the pointer about apply tactic ..., yes it's possible to<br>
write a tactic which does nothing but print out the goal, and can use<br>
the goal as an ML value within the tactic, but when I tried to define a<br>
reference value in which to save the goal value I found I couldn't.  Has<br>
the version of ML available to Isar users been jinxed, or something, so<br>
that reference variables don't work?</p>
</blockquote>
<p>Isabelle/ML is a very clean parallel programming environment, as<br>
explained in chapter 0 of the "implementation" manual. Section 0.7.9 is<br>
about Usynchronitzed.ref and Section 0.8 about "Thread-safe programming".</p>
<blockquote>
<p>For your information, I don't want to recreate the look-and-feel of<br>
(what you now, I think correctly, admit is a) different system called<br>
"Isabelle98".  I just want to get stuff done.  The sort of stuff (like<br>
finding out how to get hold of the current goal) that takes no time at<br>
all in HOL4 or Isabelle2005 (which is actually what I use when I'm<br>
building on previous work) and takes hours in your Isabelle 2017</p>
</blockquote>
<p>In Isabelle you have the goal right there in the source, and the Prover<br>
IDE manages proof documents that apply to it. Anything beyond that is<br>
for tool developers, and even that is quite easy if you think about the<br>
system in the proper way, and look a bit through the documentation.</p>
<p>Note that "to get stuff done" (doing proofs) usually requires no<br>
Isabelle/ML at all.</p>
<p>Makarius</p>



<a name="294734680"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294734680" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294734680">(Aug 22 2022 at 17:29)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:Jeremy.Dawson@anu.edu.au">Jeremy.Dawson@anu.edu.au</a>&gt;<br>
Hi Makarius,</p>
<p>not clear what you mean by this - sure, the goal has been entered in <br>
textual form by the user, and obviously the system turns this into the <br>
ML value - but I can't see how the ML value is "there in the source".</p>
<p>What do you mean by this?</p>
<p>Cheers,</p>
<p>Jeremy</p>



<a name="294734898"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294734898" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294734898">(Aug 22 2022 at 17:30)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
The true proof state is the partial proof text that you edit in the<br>
Prover IDE: as Isar source.</p>
<p>You don't need the ML value to do the proof, it is part of the<br>
implementation.</p>
<p>It might be fun to explore the implementation, but it can also take some<br>
years to get to the bottom of it.</p>
<p>Makarius</p>



<a name="294735447"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294735447" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294735447">(Aug 22 2022 at 17:33)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:Jeremy.Dawson@anu.edu.au">Jeremy.Dawson@anu.edu.au</a>&gt;<br>
Hi</p>
<p>I don't seem to be able to use the goals or subgoals antiquotations <br>
correctly</p>
<p>lemma example: "a = b --&gt; b = a"<br>
ML_prf {* @{thm refl} *}</p>
<p>ML_prf {* @{goals} <em>} (</em> fails *)<br>
ML_prf {* @{subgoals} <em>} (</em> fails *)<br>
ML_prf {* @{context} <em>} (</em> OK *)<br>
ML_prf {* @{theory} <em>} (</em> OK *)</p>
<p>what am I doing wrong here?</p>
<p>Thanks</p>
<p>Jeremy</p>



<a name="294735683"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294735683" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294735683">(Aug 22 2022 at 17:35)</a>:</h4>
<p>From: Lars Hupel &lt;<a href="mailto:hupel@in.tum.de">hupel@in.tum.de</a>&gt;<br>
Dear Jeremy,</p>
<blockquote>
<p>I don't seem to be able to use the goals or subgoals antiquotations<br>
correctly</p>
</blockquote>
<p>as far as I understand, those are "document antiquotations", i.e. they<br>
may only appear in document text, but not in ML:</p>
<p>text ‹@{goals}›</p>
<p>If you want to take a look at the proof state from within the IDE, you<br>
have two choices:</p>
<p>1) open the "State" panel<br>
2) open the "Output" panel and check the "Proof state" box</p>
<blockquote>
<p>lemma example: "a = b --&gt; b = a"<br>
ML_prf {* @{thm refl} *}</p>
</blockquote>
<p>Note that this can be shorter expressed as "thm refl" directly. No need<br>
to wrap that into ML.</p>
<p>Cheers<br>
Lars</p>



<a name="294735880"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294735880" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294735880">(Aug 22 2022 at 17:36)</a>:</h4>
<p>From: Dominique Unruh &lt;<a href="mailto:unruh@ut.ee">unruh@ut.ee</a>&gt;<br>
Hi,</p>
<p>you can use</p>
<p>lemma example: "a = b --&gt; b = a"<br>
  ML_val {* @{Isar.goal} *}</p>
<p>to get the current goal. Note though, that this does not work with ML_prf.</p>
<p>Best wishes,<br>
Dominique.</p>



<a name="294736266"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294736266" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294736266">(Aug 22 2022 at 17:38)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:Jeremy.Dawson@anu.edu.au">Jeremy.Dawson@anu.edu.au</a>&gt;<br>
Hi Dominique,</p>
<p>Thanks - that's most helpful.  Do you know if this is documented anywhere?</p>
<p>Cheers,</p>
<p>Jeremy</p>



<a name="294736459"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20antiquotations/near/294736459" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20antiquotations.html#294736459">(Aug 22 2022 at 17:39)</a>:</h4>
<p>From: Dominique Unruh &lt;<a href="mailto:unruh@ut.ee">unruh@ut.ee</a>&gt;<br>
I don't know if it's documented. I found it via autocompletion in<br>
Isabelle/jEdit. But it took some experimenting to figure out that it works<br>
with ML_val. (Because otherwise it just thrown UNDEF).</p>
<p>Best wishes,<br>
Dominique.</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>