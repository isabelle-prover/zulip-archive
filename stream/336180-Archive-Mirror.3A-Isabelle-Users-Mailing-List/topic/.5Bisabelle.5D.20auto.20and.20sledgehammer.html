<html>
<head><meta charset="utf-8"><title>[isabelle] auto and sledgehammer · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20auto.20and.20sledgehammer.html">[isabelle] auto and sledgehammer</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294273266"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20auto%20and%20sledgehammer/near/294273266" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20auto.20and.20sledgehammer.html#294273266">(Aug 19 2022 at 14:04)</a>:</h4>
<p>From: Gergely Buday &lt;<a href="mailto:gbuday@gmail.com">gbuday@gmail.com</a>&gt;<br>
Hi,</p>
<p>sledgehammer returns a number of lemmas that can be fed to metis to verify<br>
a lemma.</p>
<p>auto is sometimes better finding the proof, but it does not return any<br>
information on the lemmas used. Has anybody been thinking on the idea of<br>
extending auto's implementation to return with the list of lemmas?<br>
Possibly, the non-trivial lemmas.</p>
<p>This would yield more readable scripts, but there might be a reason that<br>
this is not done.</p>
<ul>
<li>Gergely</li>
</ul>



<a name="294273308"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20auto%20and%20sledgehammer/near/294273308" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20auto.20and.20sledgehammer.html#294273308">(Aug 19 2022 at 14:05)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
These two tools work in very different ways. The idea behind sledgehammer is to use a lot of very powerful tools to search for proof, but not to trust the result; instead, we merely extract the list of relevant lemmas to give to a weak but trustworthy internal prover. It is true that this list is very interesting in its own right, especially when it is shorter than one might expect.</p>
<p>Auto uses Isabelle’s internal reasoners. As you have guessed, they use an enormous number of basic lemmas in order to traverse formulas, and it might be interesting to identify the less trivial ones by somehow processing the proof object. This might be a good student project.</p>
<p>Larry Paulson</p>



<a name="294273329"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20auto%20and%20sledgehammer/near/294273329" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20auto.20and.20sledgehammer.html#294273329">(Aug 19 2022 at 14:05)</a>:</h4>
<p>From: Gottfried Barrow &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;<br>
On 14-03-26 03:31, Gergely Buday wrote:</p>
<p>(Skip past the first 4 paragraphs to get an algorithm for how to <br>
sometimes be able to narrow down what auto is doing, and for a list of <br>
traces to help you do that, and get trace info about other things.)</p>
<p>I'm all for automated tools which give me good information, so, when <br>
needed, I can understand the logic for a proof step, or to make explicit <br>
in a document what lemmas are being used for a proof step.</p>
<p>If Larry Paulson is sympathetic with a request like this, that can't be <br>
a bad thing. I'll do my part and pull strings for grant money, with my <br>
personal friends at Intel, Google, Microsoft, Apple, IBM and all the big <br>
USA defense companies, that should have lots of money after 14 years of <br>
war, like Raytheon which I didn't get a job with, General Dynamics, <br>
Lockheed Martin, and Hughes which I didn't get a job with.</p>
<p>And Motorola, which lost out to Intel, but which has been on my mind <br>
lately, because of <code>num</code>. Is a <code>num</code> big endian or little endian? The <br>
order of the <code>num</code> binary digits is reversed, so in my mind it's big <br>
endian, because binary digits are permanently embedded in my mind as <br>
being little endian, because of thinking about binary digits in relation <br>
to Intel microprocessors, for a long time.</p>
<p>However, Wiki relates endianess to how you read things from left to <br>
right, and if Num.One is considered memory location 0, then maybe <code>num</code> <br>
is little endian, because then, the reading of a <code>num</code> number is <br>
reversed from how it's stored in memory. I'm looking around the room <br>
right now for someone to engage with in thoughtful, intellectual <br>
discourse about the endianness of <code>num</code>. There is no one in the room but <br>
me. That's okay. There's the little kid next door, but he just wants me <br>
to throw him the football, the football not being a soccer ball, the <br>
football being related to chronic brain injury for those who bash their <br>
heads against 280 pound men, pound not being a form of British currency <br>
in this context, and bitcoin not being currency in the context of the <br>
IRS, but merely property.</p>
<blockquote>
<p>auto is sometimes better finding the proof, but it does not return any<br>
information on the lemmas used.</p>
</blockquote>
<p>The traces give you info about how auto proves a lemma. If it's doing a <br>
lot for a proof step, it's not easy to tell what it did, but then that's <br>
because it did a lot. If you want to narrow down how auto proves a proof <br>
step, you study the trace to the extent you want to, and then apply <br>
other automatic methods directly, such as blast and arith, and from the <br>
simp rules you see in the trace experiment with simp, you do things like <br>
the following, while looking at the output panel trace:</p>
<p>(1) apply(simp only:) and apply(auto simp only:), where if this prevents <br>
auto from proving the lemma, you can start adding back rules you see in <br>
the simp trace with <code>only</code>, or start deleting simp rules using <code>del</code> to <br>
see if you can find simp rules it has to have, as shown next.</p>
<p>(2) apply(simp only: foo bar) and apply(auto simp only: foo bar).</p>
<p>(3)  apply(simp del: foo bar) and apply(auto simp del: foo bar).</p>
<p>(4) apply(blast), (apply arith).</p>
<p>If</p>
<p>(1) <code>apply(auto simp only:)</code> or <code>apply(simp only:)</code> shuts it down,</p>
<p>(2) <code>apply(auto simp only: foo1 foo2 foo3)</code> or <code>apply(simp only: foo1 
foo2 foo3)</code>proves it,</p>
<p>(3) the blast trace shows it didn't call blast,</p>
<p>(5) the linarith_trace shows it didn't use linear arithmetic,</p>
<p>(6) in the trace it looks like all other rewrites are trivial <br>
simplifications,</p>
<p>(7) or rewrites based on <code>unknown rewrite rule</code>s that come from your <br>
lemma assumptions,</p>
<p>then there's some chance logically, if there aren't other traces you <br>
need to enable, that (2) above is the non-trivial lemma info that you're <br>
requesting.</p>
<p>Here are some traces I've accumulated over several years, that I either <br>
insert with a macro, or have in an imported helper file. You use <br>
<code>declare</code> to enable them globally and <code>using</code> to declare them in a <br>
proof. For auto, I'm interested in the simp, blast, and linarith traces <br>
because that's the only ones I know about that will tell what auto is doing:</p>
<p>declare[[blast_trace=false, blast_stats=false]]<br>
declare[[simp_trace=false, simp_trace_depth_limit=100]]<br>
declare[[linarith_trace=false]]<br>
declare[[rule_trace=false]]<br>
declare[[metis_trace=false]]<br>
declare[[simp_debug=false]]<br>
declare[[metis_verbose = false]]<br>
declare[[unify_trace_simp=false]] (*controls tracing of the <br>
simplification phase of higher-order unification*)<br>
declare[[unify_trace_types=false]]</p>
<p>My standard insertion for traces is this:</p>
<p>using[[simp_trace, simp_trace_depth_limit=100, linarith_trace, rule_trace]]<br>
using[[blast_trace, blast_stats]]</p>
<p>To use the blast traces, you use the following, which was most helpfully <br>
provided by Makarius Wenzel:</p>
<p>attribute_setup blast_trace = {*<br>
   Scan.lift<br>
    (Parse.$$$ "=" -- Args.$$$ "true" &gt;&gt; K true ||<br>
     Parse.$$$ "=" -- Args.$$$ "false" &gt;&gt; K false ||<br>
     Scan.succeed true) &gt;&gt;<br>
   (fn b =&gt; Thm.declaration_attribute (K (Config.put_generic Blast.trace <br>
b)))<br>
*}</p>
<p>attribute_setup blast_stats = {*<br>
   Scan.lift<br>
    (Parse.$$$ "=" -- Args.$$$ "true" &gt;&gt; K true ||<br>
     Parse.$$$ "=" -- Args.$$$ "false" &gt;&gt; K false ||<br>
     Scan.succeed true) &gt;&gt;<br>
   (fn b =&gt; Thm.declaration_attribute (K (Config.put_generic Blast.stats <br>
b)))<br>
*}</p>
<blockquote>
<p>Has anybody been thinking on the idea of extending auto's implementation to return with the list of lemmas? Possibly, the non-trivial lemmas.</p>
</blockquote>
<p>Personally, I wish I could always shut down <code>simp</code> and <code>auto</code> with <br>
<code>only</code>, other than trivial rewrites being done, like symmetry and <br>
negation of False rewrites, which are generally obnoxious things to have <br>
to manually take care of.</p>
<p>But, if there would be a huge performance hit, even when the traces <br>
aren't enabled, because it would slow down doing the thousands of <br>
low-level things it always has do, that would be bad.</p>
<p>Regards,<br>
GB</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>