<html>
<head><meta charset="utf-8"><title>[isabelle] generalize a property · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20generalize.20a.20property.html">[isabelle] generalize a property</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294076789"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20generalize%20a%20property/near/294076789" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20generalize.20a.20property.html#294076789">(Aug 18 2022 at 13:26)</a>:</h4>
<p>From: barzan stefania &lt;<a href="mailto:stefania_barzan@yahoo.com">stefania_barzan@yahoo.com</a>&gt;<br>
Dear all,</p>
<p>In Isabelle i always deal with simple algebra properties.  <br>
I<br>
proved that having g,h,y,t in (G,times), (a, b, a1, b1, c, c1 :: int) and this two equations:  <br>
                                  (g (^) a) times (h (^) b)= t times (y<br>
(^) c) <br>
                              and (g (^) a1) times (h (^) b1)= t times (y (^) c1) <br>
                              ==&gt;(g (^) (a-a1)) times (h (^) (b-b1))= y (^) (c-c1) is true.</p>
<p>How can<br>
i generalize this for finitely many base elements? <br>
(for example to prove that<br>
having (g1 (^) a1) times (g2 (^) a2) times... times (g87 (^) (a87))= t<br>
times (y (^) c) <br>
                              and (g1 (^) a1') times (g2 (^) a2') times... times (g87<br>
(^) (a87'))= t times (y (^) c1) <br>
         to get true (g1 (^) (a1-a1')) times (g2<br>
(^) (a2-a2')) times... times (g87 (^) (a87-a87')))=  y (^) (c-c1)). <br>
Is<br>
there a way at all? Is is not right the way i look at the problem?  </p>
<p>Thank you very much!<br>
Stefania Barzan</p>



<a name="294076813"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20generalize%20a%20property/near/294076813" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20generalize.20a.20property.html#294076813">(Aug 18 2022 at 13:26)</a>:</h4>
<p>From: Jeremy Dawson &lt;<a href="mailto:jeremy@rsise.anu.edu.au">jeremy@rsise.anu.edu.au</a>&gt;<br>
barzan stefania wrote:</p>
<blockquote>
<p>Dear all,</p>
<p>In Isabelle i always deal with simple algebra properties.  <br>
I<br>
proved that having g,h,y,t in (G,times), (a, b, a1, b1, c, c1 :: int) and this two equations:  <br>
                                  (g (^) a) times (h (^) b)= t times (y<br>
(^) c) <br>
                              and (g (^) a1) times (h (^) b1)= t times (y (^) c1) <br>
                              ==&gt;(g (^) (a-a1)) times (h (^) (b-b1))= y (^) (c-c1) is true.</p>
<p>How can<br>
i generalize this for finitely many base elements? <br>
(for example to prove that<br>
having (g1 (^) a1) times (g2 (^) a2) times... times (g87 (^) (a87))= t<br>
times (y (^) c) <br>
                              and (g1 (^) a1') times (g2 (^) a2') times... times (g87<br>
(^) (a87'))= t times (y (^) c1) <br>
         to get true (g1 (^) (a1-a1')) times (g2<br>
(^) (a2-a2')) times... times (g87 (^) (a87-a87')))=  y (^) (c-c1)). <br>
Is<br>
there a way at all? Is is not right the way i look at the problem?  </p>
<p>Thank you very much!<br>
Stefania Barzan</p>
<p>Barzan,</p>
</blockquote>
<p>To express something like</p>
<p>(g1 (^) a1') times (g2 (^) a2') times... times (g87(^) (a87'))</p>
<p>in a general way, you want to use foldl or foldr,</p>
<blockquote>
<p>read "foldl";<br>
val it = Const ("List.foldl", "('a =&gt; 'b =&gt; 'a) =&gt; 'a =&gt; 'b List.list =&gt; <br>
'a")<br>
: Term.term<br>
read "foldr";<br>
val it = Const ("List.foldr", "('a =&gt; 'b =&gt; 'b) =&gt; 'a List.list =&gt; 'b =&gt; <br>
'b")<br>
: Term.term</p>
</blockquote>
<p>Jeremy</p>
<p>&gt;       <br>
&gt;</p>



<a name="294076826"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20generalize%20a%20property/near/294076826" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20generalize.20a.20property.html#294076826">(Aug 18 2022 at 13:27)</a>:</h4>
<p>From: Amine Chaieb &lt;<a href="mailto:ac638@cam.ac.uk">ac638@cam.ac.uk</a>&gt;<br>
Hi,</p>
<p>It seems like you need a version of setprod that works in set-based <br>
locales and not just on classes. This kind of problems starts showing up <br>
more often.</p>
<p>If you had classes (i.e. no carrier set G --- I hope I am interpreting <br>
your formalization right) then</p>
<p>you could write e.g. "setprod (%i. g i (^) a i) {1..n}</p>
<p>for (g1 (^) an) times (gn (^) an) times... times (gn (^) (an))</p>
<p>where times is also denoted by *.</p>
<p>Within a set-based locale, you might need to use the fold or fold_image <br>
iterator to "re"define setprod. Have a look at HOL/FiniteSet.thy to see <br>
how setprod is defined in terms of fold_image.</p>
<p>A "hack" here is also to use foldl or foldr (proofs with foldr are <br>
easier in general) over lists --- the length of the list will give you <br>
the n above, but you have to "artificially" enforce that you have the <br>
same number of g's and a's either by enforcing the two list to have the <br>
same length or by just using a list of pairs (gi,ai).</p>
<p>Hope I am understanding your message right and that this helps,<br>
Amine.</p>
<p>barzan stefania wrote:</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>