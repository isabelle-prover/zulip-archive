<html>
<head><meta charset="utf-8"><title>[isabelle] inductive_set and ordinal induction · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html">[isabelle] inductive_set and ordinal induction</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294656074"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656074" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656074">(Aug 22 2022 at 11:34)</a>:</h4>
<p>From: Christoph Dittmann &lt;<a href="mailto:f-isabellelist@yozora.eu">f-isabellelist@yozora.eu</a>&gt;<br>
Hi,</p>
<p>after investigating a little, I learned that inductive_set builds on<br>
inductive.</p>
<p>The same question applies to inductive: For an inductive predicate X,<br>
can I somehow get an induction schema like<br>
  "[| ... |] ==&gt; P X"<br>
as opposed to<br>
  "[| X x; ... |] ==&gt; P x"<br>
?</p>
<p>If there is no way to get this automatically, is there maybe a way to<br>
access the monotonicity rule of an inductive predicate, so that I can<br>
apply lfp_ordinal_induct?</p>
<p>Christoph</p>



<a name="294656079"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656079" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656079">(Aug 22 2022 at 11:34)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Hopefully one can get access to the monotonicity theorem proved internally in <br>
the cause of an inductive definition. But I don't know how. It is not called <br>
X_mono or X.mono. In the worst case it is hidden...</p>
<p>Tobias<br>
<a href="/user_uploads/14278/hzrwwlRaXA3E3oLJi2p3tL53/smime.p7s">smime.p7s</a></p>



<a name="294656100"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656100" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656100">(Aug 22 2022 at 11:34)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Indeed, inductive does not bind the monotonicity theorem to a theorem name and so the <br>
monotonicity theorem is not accessible from user space. Moreover, the monotonicity prover <br>
is not exported in the ML interface either, so you cannot even state the monotonicity <br>
theorem yourself and have the monotonicity prover solve the goal once more.</p>
<p>Andreas</p>



<a name="294656117"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656117" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656117">(Aug 22 2022 at 11:34)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Bummer! Is there any reason not to make the monotonicity theorem availble in <br>
user space? If not...</p>
<p>Tobias<br>
<a href="/user_uploads/14278/tw0pTwXXgPezr27yJmr3U_In/smime.p7s">smime.p7s</a></p>



<a name="294656134"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656134" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656134">(Aug 22 2022 at 11:34)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
No, I'd be glad if it was made available. Probably nobody ever invested the time to adapt <br>
the code base.</p>
<p>Andreas</p>



<a name="294656167"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656167" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656167">(Aug 22 2022 at 11:35)</a>:</h4>
<p>From: Stefan Berghofer &lt;<a href="mailto:berghofe@in.tum.de">berghofe@in.tum.de</a>&gt;<br>
Hi all,</p>
<p>monotonicity and similar theorems are not made available to the user because this would expose<br>
the inner workings of the inductive definition package, which can change without prior notice.<br>
For a more detailed discussion of this problem, see e.g. this thread:</p>
<p><a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-May/msg00079.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-May/msg00079.html</a><br>
<a href="https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-June/msg00013.html">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-June/msg00013.html</a></p>
<p>Greetings,<br>
Stefan</p>



<a name="294656219"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656219" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656219">(Aug 22 2022 at 11:35)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Stefan,</p>
<p>You are right in that the rules generated by the inductive package suffice for proving. <br>
However, sometimes it is easier to prove some statement using a higher-level reasoning <br>
principle than with the point-wise rules for inductive predicates. Thus, there may be <br>
cases where it is easier to derive a property from the internal construction than from <br>
what is exposed. Most of the other Isabelle packages I know follow the same principle: the <br>
internal constructions are accessible, but normally not used. If anyone uses the internal <br>
constructions, it is obvious that the proofs will break if the implementation is changed.</p>
<p>For comparison, partial_function also exposes the internal definition and the monotonicity <br>
theorem and I actually use this frequently to derive better induction rules for my <br>
functions. In principle, such rules could be derived from the induction rule provided, but <br>
I would have to do the derivation for each function. By using the internal derivation, I <br>
can do the derivation once and just instantiate the appropriate lemma.  Of course, I know <br>
that I have to change my proofs when partial_function changes, but as I am using the <br>
internal definition only in a principled way, the required adaptations should also be <br>
canonical.</p>
<p>Something similar can also be useful for the inductive package, as this request shows.</p>
<p>From what I saw in the Isabelle repository, this distinction between official and <br>
internal theorems might be more explicit in the next release. The internal theorems are <br>
only made available if a specific attribute is set at definition time. Something similar <br>
could also be done for inductive.</p>
<p>Best,<br>
Andreas</p>



<a name="294656225"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656225" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656225">(Aug 22 2022 at 11:35)</a>:</h4>
<p>From: Christoph Dittmann &lt;<a href="mailto:f-isabellelist@yozora.eu">f-isabellelist@yozora.eu</a>&gt;<br>
I don't see how ordinal induction (like lfp_ordinal_induct)<br>
  "[| ... |] ==&gt; P X"<br>
is derivable from the pointwise induction rule<br>
  "[| X x; ... |] ==&gt; P x"<br>
provided by the inductive package.</p>
<p>Or is it derivable?</p>
<p>Best,<br>
Christoph</p>



<a name="294656255"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656255" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656255">(Aug 22 2022 at 11:35)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Christoph,</p>
<p>The general answer first:<br>
The rules generated by the inductive package suffice to prove that the predicate equals <br>
the internal construction. Thus, you can prove the same as you can prove with access the <br>
internal construction. However, this proof of equivalence can be quite tedious (which is <br>
why I support making the internal construction accessible).</p>
<p>In the specific case of lfp_ordinal_induct, you just have to look at its proof. It uses <br>
three properties of lfp and f:</p>
<ol>
<li>Monotonicity of f: You have to prove this yourself manually, but this is doable.</li>
<li>lfp_unfold: This corresponds to X.simps[abs_def]</li>
<li>lfp_lowerbound: This corresponds to X.induct</li>
</ol>
<p>Hope this helps,<br>
Andreas</p>



<a name="294656286"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656286" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656286">(Aug 22 2022 at 11:35)</a>:</h4>
<p>From: Johannes Hölzl &lt;<a href="mailto:hoelzl@in.tum.de">hoelzl@in.tum.de</a>&gt;<br>
Dear Christoph,</p>
<p>the prove using lfp_ordinal_induct is quite different, the inductive<br>
package does not produce it for you.</p>
<p>As Andreas points out, you can directly use the definition of the<br>
predicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>
Then you can apply lfp_ordinal_induct. </p>
<ul>
<li>Johannes</li>
</ul>



<a name="294656374"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656374" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656374">(Aug 22 2022 at 11:36)</a>:</h4>
<p>From: Christoph Dittmann &lt;<a href="mailto:f-isabellelist@yozora.eu">f-isabellelist@yozora.eu</a>&gt;<br>
Dear Johannes,</p>
<p>thank you, and also Andreas for your answers.</p>
<p>&lt;inductive_pred&gt;_def is "&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;".<br>
Can I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>
to copy&amp;paste it?</p>
<p>I tried pattern matching like<br>
  note X_def (is "_ == lfp ?f")<br>
but this doesn't work (the isar manual agrees).</p>
<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>
inductive package?  If not, maybe my approach of redefining the<br>
inductive predicate explicitly via lfp and proving equality could be<br>
more robust against changes in the inductive package?</p>
<p>Best,<br>
Christoph</p>



<a name="294656404"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656404" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656404">(Aug 22 2022 at 11:36)</a>:</h4>
<p>From: Johannes Hölzl &lt;<a href="mailto:hoelzl@in.tum.de">hoelzl@in.tum.de</a>&gt;<br>
As far as I understood Stefan, the _def theorems are actually internal.</p>
<p>I think you should be on the save side with your last suggestion, i.e.<br>
defining the functional F_def and then prove:</p>
<p>inductive X ...</p>
<p>definition F where<br>
  "F = ..."</p>
<p>lemma "X = lfp F"<br>
  unfolding X_def F_def by simp</p>
<p>Then you should be on the save side if we change the internals of the<br>
inductive package.</p>
<ul>
<li>Johannes</li>
</ul>



<a name="294656425"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656425" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656425">(Aug 22 2022 at 11:36)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
On 27/10/2015 16:16, Johannes Hölzl wrote:</p>
<blockquote>
<p>As far as I understood Stefan, the _def theorems are actually internal.</p>
</blockquote>
<p>But it is exported, and hasn't changed over many years and I don't see any <br>
impending change there either.</p>
<p>Tobias</p>
<blockquote>
<p>I think you should be on the save side with your last suggestion, i.e.<br>
defining the functional F_def and then prove:</p>
<p>inductive X ...</p>
<p>definition F where<br>
   "F = ..."</p>
<p>lemma "X = lfp F"<br>
   unfolding X_def F_def by simp</p>
<p>Then you should be on the save side if we change the internals of the<br>
inductive package.</p>
<p>- Johannes</p>
<p>Am Dienstag, den 27.10.2015, 15:22 +0100 schrieb Christoph Dittmann:</p>
<blockquote>
<p>Dear Johannes,</p>
<p>thank you, and also Andreas for your answers.<br>
</p>
</blockquote>
<p>On 10/27/2015 02:26 PM, Johannes Hölzl wrote:</p>
<blockquote>
<blockquote>
<p>As Andreas points out, you can directly use the definition of the<br>
predicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>
Then you can apply lfp_ordinal_induct.</p>
</blockquote>
<p>&lt;inductive_pred&gt;_def is "&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;".<br>
Can I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>
to copy&amp;paste it?</p>
<p>I tried pattern matching like<br>
   note X_def (is "_ == lfp ?f")<br>
but this doesn't work (the isar manual agrees).</p>
<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>
inductive package?  If not, maybe my approach of redefining the<br>
inductive predicate explicitly via lfp and proving equality could be<br>
more robust against changes in the inductive package?</p>
<p>Best,<br>
Christoph<br>
</p>
</blockquote>
<p><a href="/user_uploads/14278/UhQ6XHkQRfmGKkJ_J7qJx3-U/smime.p7s">smime.p7s</a></p>
</blockquote>



<a name="294656434"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656434" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656434">(Aug 22 2022 at 11:36)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
On 27/10/2015 16:16, Johannes Hölzl wrote:</p>
<blockquote>
<p>As far as I understood Stefan, the _def theorems are actually internal.</p>
<p>I think you should be on the save side with your last suggestion, i.e.<br>
defining the functional F_def and then prove:</p>
<p>inductive X ...</p>
<p>definition F where<br>
   "F = ..."</p>
<p>lemma "X = lfp F"<br>
   unfolding X_def F_def by simp</p>
<p>Then you should be on the save side if we change the internals of the<br>
inductive package.</p>
</blockquote>
<p>No, you are not: the simp proof may well fail if X_def changes, and if it <br>
disappears altogether the unfolding breaks.</p>
<p>Tobias</p>
<blockquote>
<p>- Johannes</p>
<p>Am Dienstag, den 27.10.2015, 15:22 +0100 schrieb Christoph Dittmann:</p>
<blockquote>
<p>Dear Johannes,</p>
<p>thank you, and also Andreas for your answers.<br>
</p>
</blockquote>
<p>On 10/27/2015 02:26 PM, Johannes Hölzl wrote:</p>
<blockquote>
<blockquote>
<p>As Andreas points out, you can directly use the definition of the<br>
predicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>
Then you can apply lfp_ordinal_induct.</p>
</blockquote>
<p>&lt;inductive_pred&gt;_def is "&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;".<br>
Can I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>
to copy&amp;paste it?</p>
<p>I tried pattern matching like<br>
   note X_def (is "_ == lfp ?f")<br>
but this doesn't work (the isar manual agrees).</p>
<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>
inductive package?  If not, maybe my approach of redefining the<br>
inductive predicate explicitly via lfp and proving equality could be<br>
more robust against changes in the inductive package?</p>
<p>Best,<br>
Christoph<br>
</p>
</blockquote>
<p><a href="/user_uploads/14278/24Gm8TNHSgV0LXLezdT6F-ns/smime.p7s">smime.p7s</a></p>
</blockquote>



<a name="294656442"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656442" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656442">(Aug 22 2022 at 11:36)</a>:</h4>
<p>From: Christoph Dittmann &lt;<a href="mailto:f-isabellelist@yozora.eu">f-isabellelist@yozora.eu</a>&gt;<br>
I was thinking more of something like the proof of X_lfp_equiv I posted<br>
in my original posting, without using X_def.</p>
<p>The only drawback is that I need to state the monotone function twice in<br>
slightly different form, once for the inductive predicate and once again<br>
to redefine it with lfp.</p>
<p>Best,<br>
Christoph</p>



<a name="294656492"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656492" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656492">(Aug 22 2022 at 11:37)</a>:</h4>
<p>From: Johannes Hölzl &lt;<a href="mailto:hoelzl@in.tum.de">hoelzl@in.tum.de</a>&gt;<br>
Am Dienstag, den 27.10.2015, 16:33 +0100 schrieb Tobias Nipkow:</p>
<blockquote>
<blockquote>
<p>lemma "X = lfp F"<br>
   unfolding X_def F_def by simp</p>
<p>Then you should be on the save side if we change the internals of the<br>
inductive package.</p>
</blockquote>
<p>No, you are not: the simp proof may well fail if X_def changes, and if it <br>
disappears altogether the unfolding breaks.</p>
</blockquote>
<p>Okay, I should be more specific with safe side: You only need to perform<br>
local changes. You need to adapt your proof only locally, only this<br>
proof.</p>
<p>If you would sprinkle X_def all over the place and inductive changes it,<br>
you can _not_ overwrite X_def like</p>
<p>lemma X_def: "X = lfp ..."</p>
<p>as Isabelle does not allow the same theorem name in one theory.</p>
<blockquote>
<p>Am Dienstag, den 27.10.2015, 15:22 +0100 schrieb Christoph Dittmann:</p>
<blockquote>
<blockquote>
<p>Dear Johannes,</p>
<p>thank you, and also Andreas for your answers.<br>
</p>
</blockquote>
<p>On 10/27/2015 02:26 PM, Johannes Hölzl wrote:</p>
<blockquote>
<blockquote>
<p>As Andreas points out, you can directly use the definition of the<br>
predicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>
Then you can apply lfp_ordinal_induct.</p>
</blockquote>
<p>&lt;inductive_pred&gt;_def is "&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;".<br>
Can I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>
to copy&amp;paste it?</p>
<p>I tried pattern matching like<br>
   note X_def (is "_ == lfp ?f")<br>
but this doesn't work (the isar manual agrees).</p>
<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>
inductive package?  If not, maybe my approach of redefining the<br>
inductive predicate explicitly via lfp and proving equality could be<br>
more robust against changes in the inductive package?</p>
<p>Best,<br>
Christoph<br>
</p>
</blockquote>
</blockquote>
</blockquote>



<a name="294656515"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656515" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656515">(Aug 22 2022 at 11:37)</a>:</h4>
<p>From: Johannes Hölzl &lt;<a href="mailto:hoelzl@in.tum.de">hoelzl@in.tum.de</a>&gt;<br>
Yes, it should be considered fixed, and I support Andreas' idea of<br>
exporting the monotonicity theorem. </p>
<ul>
<li>Johannes</li>
</ul>



<a name="294656679"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294656679" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294656679">(Aug 22 2022 at 11:38)</a>:</h4>
<p>From: Tobias Nipkow &lt;<a href="mailto:nipkow@in.tum.de">nipkow@in.tum.de</a>&gt;<br>
Stefan, you could call it something like mono_internal, thus expressing that it <br>
may change.</p>
<p>Tobias<br>
<a href="/user_uploads/14278/jSr-LWCsEzTxVvPzdHkgyT-J/smime.p7s">smime.p7s</a></p>



<a name="294657720"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294657720" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294657720">(Aug 22 2022 at 11:45)</a>:</h4>
<p>From: Christoph Dittmann &lt;<a href="mailto:f-isabellelist@yozora.eu">f-isabellelist@yozora.eu</a>&gt;<br>
Hi,</p>
<p>I would like to use lfp_ordinal_induct_set with inductive_set.</p>
<p>When I define:</p>
<p>inductive_set X where "⟦ ⋀b. f a b ⟹ b ∈ X ⟧ ⟹ a ∈ X"</p>
<p>I get an induction theorem X.induct for free.  However, X.induct talks<br>
about elements, not sets.  The following induction schema based on least<br>
fixed points also works:</p>
<p>lemma X_lfp_induct:<br>
  assumes step: "⋀S. P S ⟹ P (S ∪ {a. ∀b. f a b ⟶ b ∈ S})"<br>
    and union: "⋀M. ∀S ∈ M. P S ⟹ P (⋃M)"<br>
  shows "P X"<br>
oops</p>
<p>I managed to prove X_lfp_induct (see attachment) by redefining X<br>
manually via the lfp function and then showing that this definition is<br>
equivalent to the inductive_set.  Then X_lfp_induct follows from<br>
lfp_ordinal_induct_set from ~~/src/HOL/Inductive.thy.</p>
<p>For this I needed to prove things like monotonicity, which I assume<br>
inductive_set already proves internally.  So my approach seems a little<br>
redundant and I think there could be a better way.</p>
<p>Is there an easier way to get a least fixed point induction schema like<br>
this for inductive_sets in general, maybe even fully automatic?</p>
<p>Thanks,<br>
Christoph<br>
<a href="/user_uploads/14278/Y6AB5bQgq46omnmL4RNHpXBT/lfp.thy">lfp.thy</a></p>



<a name="294659037"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20inductive_set%20and%20ordinal%20induction/near/294659037" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20inductive_set.20and.20ordinal.20induction.html#294659037">(Aug 22 2022 at 11:53)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
A few notes on these questions about internal construction vs. external <br>
results (or "interface") of derived definitional packages.</p>
<ul>
<li>
<p>Historically, constant definitions were always visible in the fact<br>
   namespace.  A bit later, we introduced the "concealed" flag, as formal<br>
   means to say that the accidental presence of such facts is better<br>
   ignored (especially by tools like find_theorems of sledgehammer).  Only<br>
   recently (i.e. some years ago) the namespaces for definitional axioms<br>
   and facts (stored theorems) were clearly separated.  Thus it became<br>
   possible to make formal definitions relatively hard to access by<br>
   user-space tools.  (The 'private' modifier from Isabelle2015 has a<br>
   similar effect.)</p>
</li>
<li>
<p>Some weeks ago, I tried to make a few definitional packages more serious<br>
   in this respect, by using an empty binding for the facts of the internal<br>
   definitions.  Thus a few cases were exposed, where applications were<br>
   actually using this, despite the original intentions.  So I added<br>
   another configuration option to re-enable the lost definitional fact.</p>
</li>
<li>
<p>I have now done the same for 'inductive', 'coinductive' etc. treating<br>
   the "mono" rule like the internal definition.  This exposed surprisingly<br>
   many cases where the definition was used in applications.  So the<br>
   question, whether the "mono" rule is morally public or not is futile.</p>
</li>
</ul>
<p>In conclusion, this is the relevant NEWS entry from Isabelle/ca53150406c9, <br>
which is meant for the coming release:</p>
<p>* Inductive definitions ('inductive', 'coinductive', etc.) expose<br>
   low-level facts of the internal construction only if the option<br>
   "inductive_defs" is enabled. This refers to the internal predicate<br>
   definition and its monotonicity result. Rare INCOMPATIBILITY.</p>
<p>* Recursive function definitions ('fun', 'function', 'partial_function')<br>
   expose low-level facts of the internal construction only if the option<br>
   "function_defs" is enabled. Rare INCOMPATIBILITY.</p>
<p>This means the new situation is both more restrictive and more permissive.</p>
<p>There was also a discussion about the "stability of interfaces" in <br>
Isabelle.  It does not really exist.  Everything may change at some point. <br>
Of course, we don't change things at will, according to current weather <br>
conditions.  But we are still moving conceptually forward to a hopefully <br>
better system.</p>
<p>A recent example for that is the upheaval of the 'datatype' package after <br>
many years.</p>
<p>Makarius</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>