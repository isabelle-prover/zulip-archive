<html>
<head><meta charset="utf-8"><title>[isabelle] lexical matters · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html">[isabelle] lexical matters</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294125542"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125542" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125542">(Aug 18 2022 at 16:46)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 19/1/11 3:25 AM, Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt; wrote:</p>
<blockquote>
<p>On 19/01/11 14:04, <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a> wrote:</p>
<blockquote>
<p>I never thought that advocating a trustworthy pretty printer would be so<br>
controversial!!!</p>
</blockquote>
<p>It's just not an interesting problem.  We can solve it trivially by<br>
writing<br>
everything out in sexp-like notation.  ACL2 is demonstrably an acceptable<br>
format for security-critical validation, and this is all the<br>
pretty-printing<br>
they have.</p>
</blockquote>
<p>Not sure what you mean here.  You seem to be saying that low-tech printers<br>
are the way forward, which again seems to be suggesting that good concrete<br>
syntax printers do not help human readability.</p>
<blockquote>
<p>Moreover, with proof terms (in Isabelle) and things like OpenTheory for<br>
the<br>
3 HOLs, we can avoid having to look at clients' ML code.</p>
</blockquote>
<p>I am also advocating proof porting.  With proof porting, however, we have<br>
the same problem - in the target system, we still need to know that the<br>
ported theorem is the right one and that the ported definitions are right.</p>
<p>All of the "3 HOLs" (presumably you are not including HOL Zero in the 3 HOLs<br>
:) have problems with printing irregular names, and all of them have<br>
problems coping with overloaded variables.</p>
<p>Mark.</p>



<a name="294125561"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125561" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125561">(Aug 18 2022 at 16:46)</a>:</h4>
<p>From: Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;<br>
On 19/01/11 14:36, <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a> wrote:</p>
<blockquote>
<p>on 19/1/11 3:25 AM, Michael Norrish&lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;  wrote:</p>
</blockquote>
<blockquote>
<blockquote>
<p>It's just not an interesting problem.  We can solve it trivially by writing<br>
everything out in sexp-like notation.  ACL2 is demonstrably an acceptable<br>
format for security-critical validation, and this is all the pretty-printing<br>
they have.</p>
</blockquote>
</blockquote>
<blockquote>
<p>Not sure what you mean here.  You seem to be saying that low-tech<br>
printers are the way forward, which again seems to be suggesting<br>
that good concrete syntax printers do not help human readability.</p>
</blockquote>
<p>Of course they do.  We also know that in our day-to-day use of our systems, the pretty-printer is not a cause of problems, so we can use the nice readability-enhancing features of these systems.  On the other hand, if there is a worry about malicious attacks (as in the validated work scenario) then people concerned about these things can print the terms in question using sexp-syntax, which we know to be adequate.</p>
<blockquote>
<blockquote>
<p>Moreover, with proof terms (in Isabelle) and things like OpenTheory for the<br>
3 HOLs, we can avoid having to look at clients' ML code.</p>
</blockquote>
</blockquote>
<blockquote>
<p>I am also advocating proof porting.  With proof porting, however, we have<br>
the same problem - in the target system, we still need to know that the<br>
ported theorem is the right one and that the ported definitions are right.</p>
</blockquote>
<p>Right, which is why we have the pretty-printing solution of my paragraph above.</p>
<blockquote>
<p>All of the "3 HOLs" (presumably you are not including HOL Zero in the 3 HOLs<br>
:) have problems with printing irregular names, and all of them have<br>
problems coping with overloaded variables.</p>
</blockquote>
<p>I guess you mean overloaded constants.  My thought-experiment sexp-syntax would raise an exception if it encountered variable or constant names that were lexically bad.  Overloads would not be printed at all.  Instead, you'd get things like</p>
<p>(= (integer$+ (integer$int_of_num x) (integer$int_of_num y))<br>
      (integer$int_of_num (arithmetic$+ x y)))</p>
<p>Michael</p>



<a name="294125572"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125572" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125572">(Aug 18 2022 at 16:46)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:gerwin.klein@nicta.com.au">gerwin.klein@nicta.com.au</a>&gt;<br>
On 19/01/2011, at 1:50 PM, &lt;<a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a>&gt; &lt;<a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a>&gt; wrote:</p>
<blockquote>
<p>on 18/1/11 10:22 PM, Gerwin Klein &lt;<a href="mailto:gerwin.klein@nicta.com.au">gerwin.klein@nicta.com.au</a>&gt; wrote:</p>
<blockquote>
<blockquote>
<p>We should remember that at the moment it is very easy for someone to<br>
maliciously produce what appears to be a formal proof of some statement<br>
...</p>
</blockquote>
<p>I don't think this is a problem in practice. Theorem provers are already<br>
used in big certification projects. The evaluators in such projects<br>
usually<br>
know what they are doing,</p>
</blockquote>
<p>How can you be so confident about this?</p>
</blockquote>
<p>Talking to some of them. I'm sure this is not the case for all evaluators, but there are people in that business that have used Isabelle for longer than most of the current developers.</p>
<blockquote>
<p>In the large, safety-critical<br>
certification projects I have been involved with, the evaluators do the best<br>
they can with the tools they have available.  Proof checkers with readable<br>
and highly trustworthy output is a luxury not available to them.</p>
</blockquote>
<p>Depends on the project, of course, and what level of certification. Currently not that many certifications with interactive formal proof exist, but some do (ACL2 has been used quite a bit). As you say, evaluators need to take the best that is available. LCF provers are a long way ahead of what they usually have to deal with. That's why I don't think it's a problem in practice.</p>
<blockquote>
<blockquote>
<p>at least up to the level where they would easily<br>
be able to spot attempts to make syntactically misleading proof<br>
statements.<br>
It's easy enough to scan for ML blocks or similar in theory files, spot<br>
duplicate identifiers, etc, and demand good explanations for their<br>
presence<br>
(or just forbid them). And the threat of just using a proof checker is<br>
always there, so why try to cheat on syntax?</p>
</blockquote>
<p>The input in this process is the full power of an ML program.  We all know<br>
that it is possible to hide incredibly subtle things in huge programs.  Are<br>
we to ban non-trivial ML in the process of producing a proof?</p>
</blockquote>
<p>If you're really concerned about malicious users, why not? Usual Isabelle interaction makes no use of ML. Very few of the AFP entries, many of them substantial, do anything remotely like that. </p>
<blockquote>
<p>This would be<br>
forcing contractors to do their work with one hand tied behind their back.<br>
The contracted, safety-critical proof work I have been involved with would<br>
certainly have been completely infeasible without writing large amounts of<br>
ML program to support my proof work.</p>
</blockquote>
<p>In Isabelle? HOL4 or HOL-light, sure, that's their main interaction mode, but Isabelle hasn't had the ML-as-user-interface paradigm for quite a few years.</p>
<p>I'm not saying that you'll never want to use any ML for bigger advanced projects, but these ML bits are a far way off from complex ML programs. Compared to the effort that should go into validating models and statements, checking small amounts of proof method ML code for pretty printing cheat attempts would be trivial (there's no reason to have any pretty printing code there at all). There's no reason evaluators should have to accept huge amounts of complex ML code.</p>
<blockquote>
<p>It is far better for the auditor if they can treat the ML code that<br>
establishes the final theorem as some sort of black box.  To do this the<br>
theorem prover needs certain basic properties, including a trustworthy<br>
printer.</p>
</blockquote>
<p>Well, there is one, you just don't seem to like it: inspecting the term on the ML level. As Michael says, it's as least as good as Lisp s-expressions. </p>
<p>There's a difference between accidentally creating something misleading (reasonably hard to do if you use the normal interface) and a malicious user with motivation and criminal energy. If you want to guard against the latter, low-tech plain terms and external proof checking surely brings more assurance than further infrastructure.</p>
<blockquote>
<blockquote>
<p>I'm with Larry on this: the much bigger problem is to convince yourself<br>
that<br>
the model and final theorem are in any way useful or right. This is where<br>
cheating will happen much earlier.</p>
</blockquote>
<p>I did not say that this was not a problem!  This is the big problem!  </p>
</blockquote>
<p>I guess we're all mostly of the same opinion fundamentally anyway, just different views on where to put resources and emphasis.</p>
<blockquote>
<p>And<br>
this is the problem that I am advocating needs a tool that properly supports<br>
the process - the process of determining that the model and final theorem<br>
are right (as well as that the final theorem has actually been proved).<br>
This process involves using the pretty printer.</p>
</blockquote>
<p>Checking that the proof shows what you think it does involves the pretty printer only at a very shallow level. It's not the case that we can't trust the Isabelle pretty printer to support development and that it will magically show us wrong terms. </p>
<p>I've often seen and written theorems that didn't mean what I thought they meant. It's so far never been the fault of the pretty printer. It can be, because you'd  be able to trick it with some effort, but getting rid of that possibility is about assurance, not about finding the right proof statement. It can have different solutions.</p>
<p>Cheers,<br>
Gerwin</p>



<a name="294125590"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125590" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125590">(Aug 18 2022 at 16:46)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 19/1/11 3:51 AM, Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt; wrote:</p>
<blockquote>
<p>...</p>
<blockquote>
<p>Not sure what you mean here.  You seem to be saying that low-tech<br>
printers are the way forward, which again seems to be suggesting<br>
that good concrete syntax printers do not help human readability.</p>
</blockquote>
<p>Of course they do.  We also know that in our day-to-day use of our<br>
systems,<br>
the pretty-printer is not a cause of problems, so we can use the nice<br>
readability-enhancing features of these systems.  On the other hand, if<br>
there is a worry about malicious attacks (as in the validated work<br>
scenario)<br>
then people concerned about these things can print the terms in question<br>
using sexp-syntax, which we know to be adequate.</p>
</blockquote>
<p>So if you recognise that good concrete-syntax pretty printers are generally<br>
good for human readability, then this is also true for the proof auditor.<br>
If we could have a trusted system that supports proof auditing AND has a<br>
good trustworthy concrete-syntax printer, then isn't that the best of both<br>
worlds?</p>
<blockquote>
<blockquote>
<p>All of the "3 HOLs" (presumably you are not including HOL Zero in the 3<br>
HOLs :) have problems with printing irregular names, and all of them<br>
have problems coping with overloaded variables.</p>
</blockquote>
<p>I guess you mean overloaded constants....</p>
</blockquote>
<p>No, I mean variables that are overloaded with other variables.  The sort of<br>
thing that basic Hindley-Milner type inference cannot deal with (but this is<br>
for parsing so let's not get distracted by this).  Apart from HOL Zero, no<br>
other system is capable of printing (or parsing, as it happens) an<br>
expression with overloaded variables.</p>
<p>I suppose your low-tech s-exp printer would throw these out too.  It's<br>
starting to be less trivial than originally envisaged.  Isn't it just best<br>
to have a good trustworthy concrete-syntax printer?</p>
<p>Mark.</p>



<a name="294125606"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125606" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125606">(Aug 18 2022 at 16:46)</a>:</h4>
<p>From: Konrad Slind &lt;<a href="mailto:konrad.slind@gmail.com">konrad.slind@gmail.com</a>&gt;<br>
If a trusted prettyprinter is deemed to be important tool for the auditor,<br>
then<br>
the auditor can code one up, or look over your shoulder while you code it.<br>
It's a fairly simple task. Of course, for the paranoid, this just means<br>
that<br>
something else will emerge to be anxious about.</p>
<p>Konrad.</p>



<a name="294125624"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125624" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125624">(Aug 18 2022 at 16:46)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 19/1/11 4:02 AM, Gerwin Klein &lt;<a href="mailto:gerwin.klein@nicta.com.au">gerwin.klein@nicta.com.au</a>&gt; wrote:</p>
<blockquote>
<blockquote>
<p>In the large, safety-critical certification projects I have been involved<br>
with,<br>
the evaluators do the best<br>
they can with the tools they have available.  Proof checkers with<br>
readable<br>
and highly trustworthy output is a luxury not available to them.</p>
</blockquote>
<p>Depends on the project, of course, and what level of certification.<br>
Currently not that many certifications with interactive formal proof<br>
exist,<br>
but some do (ACL2 has been used quite a bit). As you say, evaluators need<br>
to<br>
take the best that is available. LCF provers are a long way ahead of what<br>
they usually have to deal with. That's why I don't think it's a problem in<br>
practice.</p>
</blockquote>
<p>So it's ok because LCF systems don't tend to get used!  I'm trying to enable<br>
LCF system to get used in practice.  This can potentially greatly increase<br>
the assurance in the project.</p>
<blockquote>
<blockquote>
<p>Are we to ban non-trivial ML in the process of producing a proof?</p>
</blockquote>
</blockquote>
<p>This reduces what can be done in the project.</p>
<blockquote>
<p>If you're really concerned about malicious users, why not? Usual Isabelle<br>
interaction makes no use of ML. Very few of the AFP entries, many of them<br>
substantial, do anything remotely like that.</p>
</blockquote>
<p>Yes, but I've been involved in large safety-critical projects where use of<br>
ML has been a practical necessity.  Formal methods is generally currently<br>
extremely expensive if it involves formal proof (but not in the projects<br>
where I have been involved with).</p>
<blockquote>
<blockquote>
<p>The contracted, safety-critical proof work I have been involved with<br>
would<br>
certainly have been completely infeasible without writing large amounts<br>
of<br>
ML program to support my proof work.</p>
</blockquote>
<p>In Isabelle? HOL4 or HOL-light, sure, that's their main interaction mode,<br>
but Isabelle hasn't had the ML-as-user-interface paradigm for quite a few<br>
years.</p>
</blockquote>
<p>Yes, so Isabelle would be safer in this respect because the proof scripts<br>
aren't even in ML.  But to enable cost-effective large formal verification<br>
projects involving formal proof, I think allowing the contractor to use the<br>
power of ML to overcome practical problems, specific to the particular<br>
project, would be an extremely useful thing.  I'm talking about bespoke<br>
automation and bespoke semi-automation.  Now it's always possible to do a<br>
bit of bespoke pre-processing and still use a restricted, non-ML paradigm,<br>
but this will often have its own integrity risks and is in any case is<br>
fundamentally limited.  We need to give contractors the full power of ML to<br>
get the costs of full formal verification down.  But we shouldn't trust them<br>
not to be malicious!</p>
<blockquote>
<p>I'm not saying that you'll never want to use any ML for bigger advanced<br>
projects, but these ML bits are a far way off from complex ML programs.<br>
Compared to the effort that should go into validating models and<br>
statements,<br>
checking small amounts of proof method ML code for pretty printing cheat<br>
attempts would be trivial (there's no reason to have any pretty printing<br>
code there at all). There's no reason evaluators should have to accept<br>
huge<br>
amounts of complex ML code.</p>
</blockquote>
<p>I've been involved with large safety-critical projects that use 20,000 lines<br>
of bespoke ML.</p>
<blockquote>
<blockquote>
<p>It is far better for the auditor if they can treat the ML code that<br>
establishes the final theorem as some sort of black box.  To do this the<br>
theorem prover needs certain basic properties, including a trustworthy<br>
printer.</p>
</blockquote>
<p>Well, there is one, you just don't seem to like it: inspecting the term on<br>
the ML level. As Michael says, it's as least as good as Lisp<br>
s-expressions.</p>
</blockquote>
<p>Good concrete-syntax printers make it much easier to read.  When hundreds of<br>
lines of specification need to be reviewed, concrete syntax is a practical<br>
necessity.</p>
<blockquote>
<p>There's a difference between accidentally creating something misleading<br>
(reasonably hard to do if you use the normal interface) and a malicious<br>
user<br>
with motivation and criminal energy. If you want to guard against the<br>
latter, low-tech plain terms and external proof checking surely brings<br>
more<br>
assurance than further infrastructure.</p>
</blockquote>
<p>I find that analysts just make mistakes, especially when things are being<br>
done on the industrial scale,  and especially when there is a team of<br>
analysts.  Now occasionally these mistakes will surface in really bizarre<br>
ways, and things that one would think "this would never happen in practice"<br>
actually do happen.  I regret not keeping a careful log of strange problems.<br>
 But problems with the pretty printer have certainly caused all sorts of<br>
problems, and, I think, some connected with the soundness of the analysis<br>
being undertaken.  These problems have often been quite subtle.</p>
<blockquote>
<p>I guess we're all mostly of the same opinion fundamentally anyway, just<br>
different views on where to put resources and emphasis.</p>
</blockquote>
<p>Absolutely.</p>
<blockquote>
<blockquote>
<p>And this is the problem that I am advocating needs a tool that properly<br>
supports<br>
the process - the process of determining that the model and final theorem<br>
are right (as well as that the final theorem has actually been proved).<br>
This process involves using the pretty printer.</p>
</blockquote>
<p>Checking that the proof shows what you think it does involves the pretty<br>
printer only at a very shallow level. It's not the case that we can't<br>
trust<br>
the Isabelle pretty printer to support development and that it will<br>
magically show us wrong terms.</p>
</blockquote>
<p>The complex Isabelle derived code, outside the relatively small core of code<br>
implementing crucial trusted components such as the inference kernel and the<br>
pretty printer, may be susceptible to constructing expressions that end up<br>
exploiting problems with Isabelle's pretty printer.  I have found that such<br>
things are easy to subtly create maliciously (but of course if the user<br>
cannot use ML, I think we can assume the developers won't do this).  But I<br>
have also found that in practice on large projects, subtle problems with<br>
tools, including theorem provers, just happen accidentally.</p>
<p>For example (forgive me if my lack of deep understanding of the Isabelle<br>
core means I am wrong here), but presumably it is quite feasible, in<br>
principle, that some complex bit of derived Isablle code occasionally<br>
constructs terms that involve overloaded variables.  This is certainly true<br>
in the "3 HOL" systems (i.e. the 4 HOL systems minus HOL Zero :).  So nasty<br>
terms that involve overloaded varaibles could "magically" get innocently<br>
constructed by well-meaning source code developed by well-meaning Isabelle<br>
developers.</p>
<blockquote>
<p>I've often seen and written theorems that didn't mean what I thought they<br>
meant. It's so far never been the fault of the pretty printer. It can be,<br>
because you'd  be able to trick it with some effort, but getting rid of<br>
that<br>
possibility is about assurance, not about finding the right proof<br>
statement.<br>
It can have different solutions.</p>
</blockquote>
<p>Yes, the risk is that the wrong theorems are being proved or that things are<br>
being given the wrong definitions, and this is why we need proof auditing,<br>
and this is why we need good concrete-syntax pretty printers, to enable the<br>
auditor to effectively review things.  But I find I'm repeating myself<br>
here...</p>
<p>Mark.</p>



<a name="294125635"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125635" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125635">(Aug 18 2022 at 16:46)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 19/1/11 5:22 AM, Konrad Slind &lt;<a href="mailto:konrad.slind@gmail.com">konrad.slind@gmail.com</a>&gt; wrote:</p>
<p>Not so simple that existing theorem provers have trusted pretty printers<br>
(other than HOL Zero)....</p>
<p>I think it would be an excellent use of formal methods to formally verify a<br>
trusted pretty printer (such as HOL Zero's).  And, no, I'm wouldn't get<br>
paranoid about how we trust the theorem prover used to do this.</p>
<p>Mark.</p>



<a name="294125751"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125751" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125751">(Aug 18 2022 at 16:47)</a>:</h4>
<p>From: Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt;<br>
Hi Mark,</p>
<p>This discussion is a bit strange. It seems this is mostly due to a <br>
conflation of at least three very different functionalities that you <br>
expect from a "theorem prover":</p>
<p>(a) Checking Proofs -- This requires a trusted inference kernel only, <br>
based on abstract syntax. No interesting parsing or pretty printing <br>
here. Challenges: Logical complexities, Performance, Keeping code simple <br>
and understandable.</p>
<p>(b) Developing Proofs -- This requires flexibility and automation, <br>
support for arbitrary user-level code, and a way to reduce everything to <br>
kernel-level inferences. Trusted pretty printing is not an issue here <br>
either. Instead I want as powerful tools as possible.</p>
<p>(c) Auditing Definitions and Theorem Statements -- This is mainly an <br>
interface problem of the auditor trying to understand what has been <br>
proved. Pretty printing plays a role here, but there are many other <br>
things. But note that proofs play no role here. This is just about <br>
definitions and theorem statements.</p>
<p>I hereby make the bold claim that any system trying to do any two of <br>
these things at the same time is bound to make some lousy compromises <br>
that aren't acceptable if you are really serious.</p>
<p>It happens that LCF-style provers traditionally try to do both (a) and <br>
(b), and they do make compromises. Bringing (c) into the picture and <br>
trying to add it into one of those systems would probably make the <br>
situation worse, not better. This is just an argument for a separate <br>
tool, which could be HOL0. I have the impression though that you are <br>
trying to address both (a) and (c) at the same time, which may lead to <br>
new lousy compromises.</p>
<p>The issues about someone maliciously attacking the kernel etc. are <br>
orthogonal and probably have standard solutions. Operating systems and <br>
security people can solve this as soon as it is important enough for <br>
someone to pay the price. But logicians are not the right people to do this.</p>
<blockquote>
<blockquote>
<p>If a trusted prettyprinter is deemed to be important tool for the auditor,<br>
then the auditor can code one up, or look over your shoulder while<br>
you code it.  It's a fairly simple task.</p>
</blockquote>
<p>Mark Adams wrote:<br>
Not so simple that existing theorem provers have trusted pretty printers<br>
(other than HOL Zero)....</p>
</blockquote>
<p>previously, Mark Adams wrote:</p>
<blockquote>
<p>but just<br>
a healthy degree of concern, especially when the problems can be easily<br>
addressed.</p>
</blockquote>
<p>So are you claiming that is it easily addressed or that it isn't??? <br>
Maybe your reasoning needs to be checked by a trusted kernel?</p>
<p>Anyway, what properties must a pretty printer have in order to be <br>
trustworthy? Is there anything formal to be said here apart from Freek <br>
Wiedijk's Pollack-consistency? Or is it just defined in terms of the <br>
attacks you happen to imagine right now? It would be interesting to read <br>
some details here instead of just a claim of how important it is.</p>
<p>Alex</p>



<a name="294125879"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294125879" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294125879">(Aug 18 2022 at 16:48)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
Hi everyone, shall we make this the last e-mail on this subject open to the<br>
list?  I understand that this thread is perhaps not of the question/answer<br>
type that most Isabelle users would be interested in.  Why don't people<br>
e-mail me if they want to see or participate in any of the continuations and<br>
we'll keep it private.  Unless there are lots of objections to keeping it<br>
private that is...</p>
<p>on 19/1/11 9:56 AM, Alexander Krauss &lt;<a href="mailto:krauss@in.tum.de">krauss@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>Hi Mark,</p>
<p>This discussion is a bit strange. It seems this is mostly due to a<br>
conflation of at least three very different functionalities that you<br>
expect from a "theorem prover":</p>
<p>(a) Checking Proofs -- ...</p>
<p>(b) Developing Proofs -- ...</p>
<p>(c) Auditing Definitions and Theorem Statements -- ...</p>
<p>I hereby make the bold claim that any system trying to do any two of<br>
these things at the same time is bound to make some lousy compromises<br>
that aren't acceptable if you are really serious.</p>
<p>...</p>
</blockquote>
<p>I think it's helpful to the discussion to break it down into different<br>
activities like you have.  You are right to differentiate between checking<br>
proofs and developing proofs.  I have always viewed auditing definitions and<br>
theorem statements as part of the process of checking proofs, but I suppose<br>
you could split it off as a different activity.</p>
<p>But I would say that there is absolutely no conflict in practice in catering<br>
for (a) and (c) together in the same system, and furthermore that they<br>
naturally go hand-in-hand.  The inference kernel does (a), and is<br>
architecturally separate from the pretty printer which supports (c).  Both<br>
have trustworthiness as their top priority.</p>
<p>There is some conflict between (a)/(c) and (b).  So both (a) and (c) ideally<br>
involve using a system where trustworthiness is the top priority, together<br>
with sufficient efficiency to enable (a) and with certain aspects of<br>
usability to support doing (c) effectively (such as good pretty-printing of<br>
definitions and theorems, and good user feedback for certain basic<br>
operations).  To achieve the trustworthiness, the source code for the<br>
trusted parts is ideally written with the utmost simplicity and clarity.<br>
But for (b), its top priorities are general usability and efficiency, with<br>
trustworthiness having less importance.  There is a conflict between general<br>
usability and clarity of the inference kernel, because things like<br>
hierarchical theories, for example, can help usability but (at least<br>
traditionally) involve greatly complicating the inference kernel.  Also, to<br>
pursue efficiency for (b), the inference kernel is typically made<br>
significantly bigger and more complicated.</p>
<p>So yes, HOL Zero was written to support (a)/(c) and avoid the conflicts with<br>
(b).  But no, I don't see there being any significant compromises in the HOL<br>
Zero implementation.  Take a look for yourself and see!  And then compare it<br>
with HOL4, ProofPower HOL and Isabelle.  (I can point out the equivalent<br>
parts of each system if you are really interested in doing this.)</p>
<p>HOL Light is an interesting case.  It's simplicity (and the simplicity of<br>
it's embryonic forerunner - the GTT system implemented by Konrad and John)<br>
is the inspiration for HOL Zero.  I would suggest that HOL Light sits<br>
between (a) and (b) with some slightly uncomfortable compromises (its lack<br>
of theory hierarchy, for example, arguably makes it less usable), but that<br>
at the same time does a surprisingly good job.  The inference kernel has<br>
only 10 inference rules and is very simple, but it is not at all unusably<br>
slow.  And Flyspeck is showing that HOL Light is up to the task of being<br>
used on big projects.  But anyway, I saw HOL Light as still unsatisfactory,<br>
if only due to its pretty printer making it inappropriate for the (c) role,<br>
and reluctantly decided that a new system was required to fill the gap.</p>
<p>I think HOL4, ProofPower and Isabelle are aiming for (b) and get the balance<br>
about right.  Their use of an LCF-style architecture gives good assurance<br>
but without conflicting with (b) in my opinion.  I think the balance is a<br>
bit wrong as regards to their pretty printers (because the problems can be<br>
relatively easily addressed without compromising on (b), and furthermore<br>
this would actually help (b)), and this is what this thread has become<br>
about.</p>
<blockquote>
<p>The issues about someone maliciously attacking the kernel etc. are<br>
orthogonal and probably have standard solutions. Operating systems and<br>
security people can solve this as soon as it is important enough for<br>
someone to pay the price. But logicians are not the right people to do<br>
this.</p>
</blockquote>
<p>They are not orthogonal in my opinion, because the LCF-style architecture<br>
itself delivers trustworthiness to protect against both the malicious and<br>
the accidental.  I think the orthogonality comes in when differentiating<br>
between trustworthiness within the scope of the ML program implementing the<br>
theorem prover and trustworthiness outside its scope (e.g. bugs in the ML<br>
interpreter, operating system interrupts, etc, etc).  But I agree that we<br>
should get the security experts in to help with the latter.</p>
<blockquote>
<p>Mark Adams wrote:</p>
<blockquote>
<p>Not so simple that existing theorem provers have trusted pretty<br>
printers (other than HOL Zero)....</p>
</blockquote>
<p>previously, Mark Adams wrote:</p>
<blockquote>
<p>but just a healthy degree of concern, especially when the problems<br>
can be easily addressed.</p>
</blockquote>
<p>So are you claiming that is it easily addressed or that it isn't???<br>
Maybe your reasoning needs to be checked by a trusted kernel?</p>
</blockquote>
<p>:-)</p>
<p>I'm claiming that it's easy.  My suggestion that it was "not so simple" was<br>
just to emphasise that nothing much has been done about these things until<br>
now.</p>
<blockquote>
<p>Anyway, what properties must a pretty printer have in order to be<br>
trustworthy? Is there anything formal to be said here apart from Freek<br>
Wiedijk's Pollack-consistency? Or is it just defined in terms of the<br>
attacks you happen to imagine right now? It would be interesting to read<br>
some details here instead of just a claim of how important it is.</p>
</blockquote>
<p>I've spent a long time thinking about it and independently came up with the<br>
tightest of Freek's "Pollack consistency" concepts.  I called it<br>
"parser/printer completeness".  But there's more to this than Freek's paper<br>
because he doesn't cover "printing soundness" - i.e. printing what the user<br>
expects (it's misleading to print an "and" when internally it's an "or").</p>
<p>Mark.</p>



<a name="294127643"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127643" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127643">(Aug 18 2022 at 16:56)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
It depends what you want to do in the end.  Generating sources that are <br>
fed back into the system is inherently hard.  I have occasionally seen <br>
people doing it empirically, e.g. trying Syntax.read_term on some <br>
identifier and checking if they get a "Free" term -- but this does not <br>
really take the scoping rules of const vs. free vs. bound into account.</p>
<p>Unless your output needs to be inspected directly by users it is easier to <br>
avoid generating sources altogether, and use the Isabelle/ML interfaces to <br>
get logical content into the system.  This is the norml way in LCF-style <br>
provers.  Concrete syntax is just a superficial add-on for end-users.</p>
<p>Makarius</p>



<a name="294127665"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127665" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127665">(Aug 18 2022 at 16:56)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
On a related topic, what does Isabelle do for parsing/printing irregular<br>
variable/constant names?  E.g. a variable with a space in its name.  Is it<br>
possible to parse such a variable name, and, whether it is or not, what does<br>
the printer output?</p>
<p>Mark</p>
<p>on 16/1/11 12:45 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>



<a name="294127681"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127681" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127681">(Aug 18 2022 at 16:56)</a>:</h4>
<p>From: Matthias Schmalz &lt;<a href="mailto:Matthias.Schmalz@inf.ethz.ch">Matthias.Schmalz@inf.ethz.ch</a>&gt;<br>
-----BEGIN PGP SIGNED MESSAGE-----<br>
Hash: SHA1</p>
<p>Mark,</p>
<p>I think, I can answer that; other readers should feel free to correct me.</p>
<p><a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a> schrieb:</p>
<blockquote>
<p>On a related topic, what does Isabelle do for parsing/printing irregular<br>
variable/constant names?  E.g. a variable with a space in its name.  Is it<br>
possible to parse such a variable name, </p>
</blockquote>
<p>No, as<br>
term "a a"<br>
is rejected.</p>
<blockquote>
<p>and, whether it is or not, what does<br>
the printer output?</p>
</blockquote>
<p>If you create variables with irregular names using the ML<br>
infrastructure, the printer justs prints them:</p>
<p>ML_val {*<br>
cterm_of @{theory} (Free ("a a", @{typ bool}))<br>
*}</p>
<p>... prints<br>
val it = "a a" : cterm</p>
<ul>
<li>-Matthias<br>
-----BEGIN PGP SIGNATURE-----<br>
Version: GnuPG v1.4.6 (GNU/Linux)<br>
Comment: Using GnuPG with Mozilla - <a href="http://enigmail.mozdev.org">http://enigmail.mozdev.org</a></li>
</ul>
<p>iD8DBQFNMx6UczhznXSdWggRAnCrAJwLsrSrcYzqATD6GF2MxiRTJ9o/qgCfd8Uq<br>
r24zX3C4KVZvEN3aqTAY4Ks=<br>
=4xpw<br>
-----END PGP SIGNATURE-----</p>



<a name="294127735"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127735" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127735">(Aug 18 2022 at 16:57)</a>:</h4>
<p>From: Matthias Schmalz &lt;<a href="mailto:Matthias.Schmalz@inf.ethz.ch">Matthias.Schmalz@inf.ethz.ch</a>&gt;<br>
-----BEGIN PGP SIGNED MESSAGE-----<br>
Hash: SHA1</p>
<blockquote>
<p>It depends what you want to do in the end.  Generating sources that are<br>
fed back into the system is inherently hard.  I have occasionally seen<br>
people doing it empirically, e.g. trying Syntax.read_term on some<br>
identifier and checking if they get a "Free" term -- but this does not<br>
really take the scoping rules of const vs. free vs. bound into account.</p>
</blockquote>
<p>For the moment, I need to generate sources. Heuristic solutions are<br>
fine. Are you aware of other pitfalls than hitting reserved keywords,<br>
predefined constants, and capturing?</p>
<blockquote>
<p>Unless your output needs to be inspected directly by users it is easier<br>
to avoid generating sources altogether, and use the Isabelle/ML<br>
interfaces to get logical content into the system.  This is the norml<br>
way in LCF-style provers.  Concrete syntax is just a superficial add-on<br>
for end-users.</p>
</blockquote>
<p>On the long run, I indeed intend to bypass the parser. I implement my<br>
tool in Scala and would like to avoid writing my own Scala/ML linkup.<br>
Is there a way of accessing the term datatype via the the Isabelle/Scala<br>
interface? Can I use Isabelle/Scala to access the Syntax.read_term function?</p>
<p>Thanks,<br>
Matthias</p>
<p>-----BEGIN PGP SIGNATURE-----<br>
Version: GnuPG v1.4.6 (GNU/Linux)<br>
Comment: Using GnuPG with Mozilla - <a href="http://enigmail.mozdev.org">http://enigmail.mozdev.org</a></p>
<p>iD8DBQFNMyWEczhznXSdWggRAvr3AJ0eRIp9uf9kgwKUp04ezV8mv5WNjgCghaiE<br>
i8BbcS+Rrm35tdaKS05fAys=<br>
=SKRs<br>
-----END PGP SIGNATURE-----</p>



<a name="294127762"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127762" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127762">(Aug 18 2022 at 16:57)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Sun, 16 Jan 2011, Matthias Schmalz wrote:</p>
<blockquote>
<p>-----BEGIN PGP SIGNED MESSAGE-----<br>
Hash: SHA1</p>
<blockquote>
<p>It depends what you want to do in the end.  Generating sources that are<br>
fed back into the system is inherently hard.  I have occasionally seen<br>
people doing it empirically, e.g. trying Syntax.read_term on some<br>
identifier and checking if they get a "Free" term -- but this does not<br>
really take the scoping rules of const vs. free vs. bound into account.</p>
</blockquote>
<p>For the moment, I need to generate sources. Heuristic solutions are <br>
fine. Are you aware of other pitfalls than hitting reserved keywords, <br>
predefined constants, and capturing?</p>
</blockquote>
<p>This depends on various fine points of what you really need, i.e. just <br>
detect lexical identifiers or ensure that certain generated names are <br>
resolved as free variables, not constants.</p>
<p>The following example does the lexical check only, quite reliably in the <br>
sense that I've studied the relevant Isabelle/Pure sources for 15min.</p>
<p>ML {*</p>
<p>fun is_syntax_ident ctxt s =<br>
   Syntax.is_identifier s andalso<br>
     not (can Name.dest_internal s) andalso<br>
     not (Syntax.is_keyword (ProofContext.syn_of ctxt) s);</p>
<p>*}</p>
<p>locale test =<br>
   fixes xxx ("FOO")<br>
begin</p>
<p>lemma True<br>
proof</p>
<p>fix yyy ("BAR")</p>
<p>ML_val {* is_syntax_ident @{context} "FOO" *}<br>
   ML_val {* is_syntax_ident @{context} "BAR" *}<br>
   ML_val {* is_syntax_ident @{context} "True" *}<br>
   ML_val {* is_syntax_ident @{context} "x" *}<br>
   ML_val {* is_syntax_ident @{context} "x_" *}</p>
<p>qed</p>
<p>end</p>
<p>It is important to work with the proper local context.  In particular, a <br>
background @{theory} is generally not sufficient.</p>
<blockquote>
<blockquote>
<p>Unless your output needs to be inspected directly by users it is easier <br>
to avoid generating sources altogether, and use the Isabelle/ML <br>
interfaces to get logical content into the system.  This is the norml <br>
way in LCF-style provers.  Concrete syntax is just a superficial add-on <br>
for end-users.</p>
</blockquote>
<p>On the long run, I indeed intend to bypass the parser. I implement my <br>
tool in Scala and would like to avoid writing my own Scala/ML linkup. Is <br>
there a way of accessing the term datatype via the the Isabelle/Scala <br>
interface? Can I use Isabelle/Scala to access the Syntax.read_term <br>
function?</p>
</blockquote>
<p>Not yet, but this will come at some point.  There are some raw technical <br>
issues, and some more profound questions concerning the formal context on <br>
the Isabelle/Scala side.  Some concrete applications will make this emerge <br>
more quickly :-)</p>
<p>Makarius</p>



<a name="294127777"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127777" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127777">(Aug 18 2022 at 16:57)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
On Sun, 16 Jan 2011, Matthias Schmalz wrote:</p>
<blockquote>
<p><a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a> schrieb:</p>
<blockquote>
<p>On a related topic, what does Isabelle do for parsing/printing <br>
irregular variable/constant names?  E.g. a variable with a space in its <br>
name.  Is it possible to parse such a variable name,</p>
</blockquote>
<p>No, as<br>
term "a a"<br>
is rejected.</p>
</blockquote>
<p>By extending the syntax in user space, you can easily inject odd strings <br>
into the term language, e.g. via something like</p>
<p>FREE ''foo bar''</p>
<p>with a grammar production for the "FREE" literal token and a suitable <br>
parse translations.  See the existing CONST notation, although I do not <br>
really recommend to try this at home.</p>
<blockquote>
<p>If you create variables with irregular names using the ML <br>
infrastructure, the printer justs prints them:</p>
<p>ML_val {*<br>
cterm_of @{theory} (Free ("a a", @{typ bool}))<br>
*}</p>
<p>... prints<br>
val it = "a a" : cterm</p>
</blockquote>
<p>This use of cterm_of reminds me of an old trick that has come out of use <br>
some years ago, because printing with the background theory certificate <br>
lacks local syntax of the foreground context (local theory or proof body).</p>
<p>Did you come up with idea yourself, or do we still have it in some old <br>
manual?</p>
<p>Here is the localized version:</p>
<p>ML_val {*<br>
   writeln (Syntax.string_of_term @{context} (Free ("a a", @{typ bool})))<br>
*}</p>
<p>Makarius</p>



<a name="294127795"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127795" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127795">(Aug 18 2022 at 16:57)</a>:</h4>
<p>From: Matthias Schmalz &lt;<a href="mailto:Matthias.Schmalz@inf.ethz.ch">Matthias.Schmalz@inf.ethz.ch</a>&gt;<br>
-----BEGIN PGP SIGNED MESSAGE-----<br>
Hash: SHA1</p>
<p>I made it up by myself, being unaware of Syntax.string_of_term. Don't<br>
worry about the manuals.</p>
<ul>
<li>-Matthias<br>
-----BEGIN PGP SIGNATURE-----<br>
Version: GnuPG v1.4.6 (GNU/Linux)<br>
Comment: Using GnuPG with Mozilla - <a href="http://enigmail.mozdev.org">http://enigmail.mozdev.org</a></li>
</ul>
<p>iD8DBQFNM0l7czhznXSdWggRAusXAJ4qB/WlFBQUmfbfXywAVPsIHv8xuQCdGOqO<br>
r6Rt5033J5jZhXciaOPRDek=<br>
=DFfR<br>
-----END PGP SIGNATURE-----</p>



<a name="294127870"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294127870" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294127870">(Aug 18 2022 at 16:57)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
Thanks for your answers, Matthias/Makarius.</p>
<p>I have a follow-up question...  What about variables overloaded with other<br>
variables (i.e. same name but different type) or overloaded with constants<br>
(same name, any type) - can terms with any such overloading be parsed, and<br>
what happens when they are printed?</p>
<p>Mark.</p>
<p>on 16/1/11 7:21 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>



<a name="294128009"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128009" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128009">(Aug 18 2022 at 16:58)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
As far as the kernel is concerned, the identity of atoms (variables, <br>
consts) consists of both the name and type, although "overloading" means <br>
something different in Isabelle.</p>
<p>In contrast, in the syntax layer (the so-called "term check/uncheck" <br>
phase, which generalizes the idea of type-inference) variables are <br>
expected to be consistently typed: equal name imples equal type, and <br>
scopes for variables vs. constants are resolved consistently.</p>
<p>If you print a term that violates this, it might look "funny", or outright <br>
misleading.  This effect can already happen due to the customary omission <br>
of type information for variables.</p>
<p>Anyway, it also depends what is meant by "printed" exactly.  In Isabelle <br>
there is quite a bit of extra formal markup in the output, that is not <br>
shown in plain text.  In Proof General you already get the typical <br>
Isabelle color-code of blue/green/brown variables and black constants. <br>
In a Prover IDE like Isabelle/jEdit you could make even more out of that, <br>
e.g. tell the user the full truth about term atoms via tooltips or popups.</p>
<p>Makarius</p>



<a name="294128037"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128037" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128037">(Aug 18 2022 at 16:58)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
I see.</p>
<p>Is there a printing mode for type-annotating constants and/or variables with<br>
their types (like in HOL4)?  I'm concerned about the risk of statements<br>
being displayed in a misleading way.</p>
<p>Mark</p>
<p>on 17/1/11 7:40 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>



<a name="294128066"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128066" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128066">(Aug 18 2022 at 16:58)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
You can implement your own in user space.  These things are not part of <br>
the kernel.  Even the ML toplevel pretty printer can be modified in user <br>
space.</p>
<p>Anyway, do you now the funny paper about by Freek Wiedijk, UITP 2010?</p>
<p>I've known this "issue" ever since I got exposed to Isabelle for the very <br>
first time, in summer 1993.</p>
<p>Makarius</p>



<a name="294128094"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128094" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128094">(Aug 18 2022 at 16:58)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
This was a copy-paste accident: Freek's paper is about <br>
"Pollack-inconsistency".</p>
<p>Makarius</p>



<a name="294128140"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128140" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128140">(Aug 18 2022 at 16:58)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a></p>
<blockquote>
<blockquote>
<p>Is there a printing mode for type-annotating constants and/or variables<br>
with their types (like in HOL4)?  I'm concerned about the risk of<br>
statements being displayed in a misleading way.</p>
</blockquote>
<p>...<br>
Anyway, do you now the funny paper about "Pollack-inconsistency" by Freek<br>
Wiedijk, UITP 2010?</p>
</blockquote>
<p>Yes thanks.  In fact my HOL system, HOL Zero<br>
(<a href="http://proof-technologies.com/holzero.html">http://proof-technologies.com/holzero.html</a>), deals with all these issues<br>
(or so I claim - there is a $100 bounty for anyone that spots a problem).  I<br>
was wondering how well Isabelle fared.</p>
<blockquote>
<p>I've known this "issue" ever since I got exposed to Isabelle for the very<br>
first time, in summer 1993.</p>
</blockquote>
<p>It puzzles me how little has been done about these things until now.  Are<br>
not people concerned that what is being displayed could be misleading?</p>
<p>Mark.</p>



<a name="294128211"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128211" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128211">(Aug 18 2022 at 16:59)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
There are other, more pressing problems. Sitting at a bare-bones ML <br>
toplevel merely gives you an illusion of "direct" access to a system, but <br>
there are still many things that can go wrong.</p>
<p>An LCF-style prover is reasonably correct by construction, independently <br>
of concrete syntax input and output.  Errors in the <br>
internalization/externalization do not multiply as quickly as genuine <br>
logical errors.</p>
<p>Makarius</p>



<a name="294128236"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128236" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128236">(Aug 18 2022 at 16:59)</a>:</h4>
<p>From: Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;<br>
No.</p>
<p>If one has reason to suspect that something funny might be going on, the terms in question can be examined using the primitive ML API.</p>
<p>Alternatively, one can print the term out using a primitive pretty-printer that doesn't attempt to do anything "fancy".</p>
<p>For example, in HOL4 one can use</p>
<p>Parse.print_term_by_grammar min_grammars</p>
<p>Michael</p>



<a name="294128254"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128254" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128254">(Aug 18 2022 at 16:59)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:webertj@in.tum.de">webertj@in.tum.de</a>&gt;<br>
Well, I for one think it's an unsatisfying design flaw in (some)<br>
existing provers that one cannot trust their output.</p>
<p>In practice, however, this becomes a potential problem only when you<br>
want to check a proof from an untrustworthy source.  (Proof objects<br>
provide a partial solution here.)</p>
<p>As long as you assume a non-malicious user who wants to create a valid<br>
machine-checked proof, it is not much of an issue.</p>
<p>Kind regards,<br>
Tjark</p>



<a name="294128341"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128341" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128341">(Aug 18 2022 at 16:59)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
This does not sound like you are speaking here about Isabelle at all. We <br>
do not assume a "non-malicious" user.  You can always inspect internal <br>
certificates, even before embarking on full proof terms.</p>
<p>Makarius</p>



<a name="294128377"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128377" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128377">(Aug 18 2022 at 16:59)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 17/1/11 11:14 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>
<blockquote>
<p>There are other, more pressing problems.</p>
</blockquote>
<p>I think trustworthiness in theorem provers should always be a top priority.<br>
After all, this is why we are using them in the first place.  So long as it<br>
doesn't have terrible consequences on other aspects of the theorem prover,<br>
such as efficiency or usability, that is.</p>
<blockquote>
<p>Sitting at a bare-bones ML<br>
toplevel merely gives you an illusion of "direct" access to a system, but<br>
there are still many things that can go wrong.</p>
</blockquote>
<p>Yes, but I think it's helpful to divide up possible things that can go wrong<br>
into those that are due to the design or implementation of the ML program,<br>
and those that are due to things largely outside the scope of the program<br>
(e.g. bugs in the ML interpreter, OS events interfering with normal<br>
operation, etc, etc).  The former is where all the problems arise in<br>
reality, and is very much under within out capability to solve.  I may be<br>
wrong, but you're presumably talking about the latter?</p>
<blockquote>
<p>An LCF-style prover is reasonably correct by construction, independently<br>
of concrete syntax input and output.  Errors in the internalization/<br>
externalization do not multiply as quickly as genuine logical errors.</p>
</blockquote>
<p>Yes, I agree that the LCF style largely solves problems of trustworthiness,<br>
and that the sort of problems it solves are the most serious.  But given<br>
that this has been solved (a long time ago), shouldn't we tackle the<br>
remaining problems?</p>
<p>Mark.</p>



<a name="294128425"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128425" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128425">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 17/1/11 11:34 PM, Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt; wrote:</p>
<blockquote>
<p>On 18/01/11 09:34, <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a> wrote:</p>
<blockquote>
<p>It puzzles me how little has been done about these things until now.  Are<br>
not people concerned that what is being displayed could be misleading?</p>
</blockquote>
<p>No.</p>
<p>If one has reason to suspect that something funny might be going on, the<br>
terms in question can be examined using the primitive ML API.</p>
</blockquote>
<p>This relies on having a sharp-sighted user who can spot subtle strange<br>
behaviour (in addition to all the other demands on the attention of the poor<br>
theorem prover user).  And in any case, it will sometimes not be possible to<br>
spot that something funny has happened, because it may appear to be behaving<br>
precisely as expected (even though it actually isn't).  Isn't it better to<br>
have tools that we can solidly rely on?</p>
<p>But yes, I suppose terms can be examined in terms of their primitive syntax,<br>
but surely this is completely impractical for large industrial formal<br>
methods projects involving large formal specifications.  In practice, anyone<br>
reviewing a large industrial proof will be using the normal pretty printer.<br>
That is, if anyone is actually bothering to do a reviewing exercise in the<br>
first place...</p>
<blockquote>
<p>Alternatively, one can print the term out using a primitive pretty-printer<br>
that doesn't attempt to do anything "fancy".</p>
<p>For example, in HOL4 one can use</p>
<p>Parse.print_term_by_grammar min_grammars</p>
</blockquote>
<p>I don't think this particular command solves the irregular names problem, or<br>
the overloaded variables problem.  But I suppose if used in conjunction with<br>
HOL4's optional type annotated output and the new facility for coloured<br>
printing of variables then it could help.</p>
<p>Mark.</p>



<a name="294128485"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128485" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128485">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Trustworthiness is just one of many problems, and we have been able to <br>
increase it in Isabelle gradually over the years.</p>
<p>Apart from that efficiency, accessibility, usability etc. are of general <br>
importance to make our arcane provers acceptable to more people out there. <br>
I often find myself in the situation of a formalistic fundamentalist when <br>
speaking to people outside our community.</p>
<p>E.g. when you start moving towards serious Prover IDEs, what I've been <br>
involved for quite some time now, you will find many more issues than the <br>
rather trivial parse/print problem of the low-level term language.  Of <br>
course, I always try to keep as much immediate reliability as possible. <br>
But I also feel one should separate concerns here: if you need extreme <br>
trustworthiness, then you should export full theory and proof content to <br>
some tiny external checker.  The latter does not even need concrete syntax <br>
in the traditional sense.</p>
<p>HOL0 could be one such checker, if it would be able to absorb huge <br>
theories and proofs (traces of inferences).  Then one could implement some <br>
"HOL0" button in Isabelle.</p>
<p>Makarius</p>



<a name="294128504"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128504" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128504">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Obviously trustworthiness is important. Nevertheless, a fixation on this one issue can be counter-productive. I'm not aware of a single piece of research that was invalidated due to bugs in theorem provers.</p>



<a name="294128521"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128521" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128521">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 18/1/11 12:12 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>
<blockquote>
<p>On Tue, 18 Jan 2011, <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a> wrote:</p>
<blockquote>
<p>Yes, I agree that the LCF style largely solves problems of<br>
trustworthiness, and that the sort of problems it solves are the<br>
most serious.  But given that this has been solved (a long time<br>
ago), shouldn't we tackle the remaining problems?</p>
</blockquote>
<p>Trustworthiness is just one of many problems, and we have been<br>
able to increase it in Isabelle gradually over the years.</p>
<p>Apart from that efficiency, accessibility, usability etc. are of general<br>
importance to make our arcane provers acceptable to more people<br>
out there.  I often find myself in the situation of a formalistic<br>
fundamentalist when speaking to people outside our community.</p>
</blockquote>
<p>Yes, and I similarly.  There are people out there who simply don't want any<br>
involvement with formal proof.  My fear is that, as we are trying to push<br>
theorem proving more towards mainstream usage, sceptics will emerge citing<br>
"well you can't even trust theorem provers anyway".  There was that debate<br>
in the 1970s...</p>
<blockquote>
<p>E.g. when you start moving towards serious Prover IDEs, what I've been<br>
involved for quite some time now, you will find many more issues than the<br>
rather trivial parse/print problem of the low-level term language.</p>
</blockquote>
<p>Yes, adding layers can present more problems, and I'm sure you have more<br>
experience in this than me.  But surely we should be addressing these<br>
problems as they arise, instead of brushing many of them under the carpet?<br>
Shouldn't there be some sort of research effort concentrating on this?</p>
<blockquote>
<p>Of course, I always try to keep as much immediate reliability as possible.<br>
But I also feel one should separate concerns here: if you need extreme<br>
trustworthiness, then you should export full theory and proof content to<br>
some tiny external checker.  The latter does not even need concrete syntax<br>
in the traditional sense.</p>
</blockquote>
<p>Unfortunately, the external checker needs to have a trustworthy printer<br>
(despite that this has not traditionally been expressed as a priority).  It<br>
needs to be able to print syntax in a highly readable way, so that a proof<br>
auditor can effectively review exactly what the checker has checked.  A<br>
large project involving formal proof might have hundreds of definitions that<br>
need reviewing, as well as the end-result theorems that use these<br>
definitions.  Wading through primitive syntax makes this an almost<br>
impossible task.</p>
<blockquote>
<p>HOL0 could be one such checker, if it would be able to absorb huge<br>
theories and proofs (traces of inferences).  Then one could implement some<br>
"HOL0" button in Isabelle.</p>
</blockquote>
<p>Well that's what I designed it for!  Being able to absorb huge theories is<br>
of course crucial.  But also is being able to trust the inference kernel and<br>
the pretty printer.  The HOL Zero button already exists in a prototype HOL<br>
Light variant I developed.  Not so easy for Isabelle HOL....</p>
<p>Mark.</p>



<a name="294128547"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128547" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128547">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 18/1/11 12:38 PM, Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt; wrote:</p>
<blockquote>
<p>Obviously trustworthiness is important. Nevertheless, a fixation on this<br>
one<br>
issue can be counter-productive. I'm not aware of a single piece of<br>
research<br>
that was invalidated due to bugs in theorem provers.<br>
 On the other hand, I<br>
have seen a great many papers where the work was essentially worthless<br>
because of inadequate modelling of the problem. Naturally, the theorem<br>
prover cannot check that a model is realistic, but I frequently hear the<br>
suggestion that nothing can go wrong if you use a theorem prover. The<br>
community needs to focus more on ways of making models trustworthy. There<br>
are probably quite a few interesting research topics along those lines.</p>
</blockquote>
<p>I agree that there are more important issues that require more attention.<br>
I'm not advocating endless fixation with cosmic rays and the like, but just<br>
a healthy degree of concern, especially when the problems can be easily<br>
addressed.</p>
<p>We should remember that at the moment it is very easy for someone to<br>
maliciously produce what appears to be a formal proof of some statement but<br>
is in fact something that takes advantage of the sorts of pretty printer<br>
problems I am talking about.  Now if theorem provers are ever going to make<br>
it big, we are then in the situation where commercial pressures, etc, are<br>
pushing people to claim they have proved something when they have in fact<br>
not.  One of the important roles of a theorem prover should be as a highly<br>
trustworthy tool to support a human proof auditor checking that some huge<br>
10,000 line proof of a theorem does indeed establish the theorem.</p>
<p>Mark.</p>
<blockquote>
<p>Larry Paulson</p>
<p>On 18 Jan 2011, at 11:55, &lt;<a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a>&gt; wrote:</p>
<blockquote>
<p>on 17/1/11 11:14 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>
<blockquote>
<p>There are other, more pressing problems.</p>
</blockquote>
<p>I think trustworthiness in theorem provers should always be a top<br>
priority.<br>
After all, this is why we are using them in the first place.  So long as<br>
it<br>
doesn't have terrible consequences on other aspects of the theorem<br>
prover,<br>
such as efficiency or usability, that is.</p>
</blockquote>
</blockquote>



<a name="294128570"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128570" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128570">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 18/1/11 2:01 AM, Tjark Weber &lt;<a href="mailto:webertj@in.tum.de">webertj@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>As long as you assume a non-malicious user who wants to create a valid<br>
machine-checked proof, it is not much of an issue.</p>
</blockquote>
<p>Yes, but I don't think we can assume a non-malicious user!  What if someone<br>
wants to claim they have proved something in order to get paid?<br>
Subcontracting out proofs could be a serious business in the future.</p>
<p>Mark.</p>



<a name="294128591"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128591" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128591">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: Tjark Weber &lt;<a href="mailto:webertj@in.tum.de">webertj@in.tum.de</a>&gt;<br>
And a malicious user, by misusing ML in Isabelle theory files, couldn't<br>
replace the functions that you would use to inspect internal<br>
certificates -- or the entire inference kernel; or even the entire<br>
Isabelle process -- with his own implementation?</p>
<p>Kind regards,<br>
Tjark</p>



<a name="294128607"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128607" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128607">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Yes, depending how much criminal energy you want to invest.</p>
<p>Actually, this my favourite theoretical attack on LCF prover integrity. <br>
After "The Matrix" it also has a name, see <br>
<a href="http://en.wikipedia.org/wiki/Blue_Pill_%28malware%29">http://en.wikipedia.org/wiki/Blue_Pill_%28malware%29</a></p>
<p>We could harden Isabelle/ML against this, since the ML environment is <br>
under our control.  Since this has no practical relevance, though, it has <br>
not been done so far.  It is important to keep focused on real problems.</p>
<p>Makarius</p>



<a name="294128621"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128621" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128621">(Aug 18 2022 at 17:00)</a>:</h4>
<p>From: Lawrence Paulson &lt;<a href="mailto:lp15@cam.ac.uk">lp15@cam.ac.uk</a>&gt;<br>
Once you assume malicious users, you are turning theorem-proving software into security software. The time for this may come, but it will require a significant investment in security engineering. The first step would be to develop a realistic threat model. And this isn't really possible in the absence of actual attacks. It will be interesting to see if there are any over the coming years.</p>
<p>Larry</p>



<a name="294128644"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128644" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128644">(Aug 18 2022 at 17:01)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 18/1/11 2:28 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>
<blockquote>
<p>On Tue, 18 Jan 2011, Tjark Weber wrote:</p>
<blockquote>
<p>...</p>
<p>And a malicious user, by misusing ML in Isabelle theory files, couldn't<br>
replace the functions that you would use to inspect internal<br>
certificates -- or the entire inference kernel; or even the entire<br>
Isabelle process -- with his own implementation?</p>
</blockquote>
<p>Yes, depending how much criminal energy you want to invest.</p>
</blockquote>
<p>Like the printer problems I mention, I also see these ML trojan horse issues<br>
as important, easy-to-address and yet problems that have not yet been<br>
addressed.  The ML interpreter should support being able to block<br>
overwriting in some way or other.  E.g. supply the interpreter with a<br>
datatype or a function name that cannot be overwritten.  It isn't exactly<br>
rocket science, and it removes a risk.  I just don't understand why nothing<br>
has been done about this.</p>
<blockquote>
<p>Actually, this my favourite theoretical attack on LCF prover integrity.<br>
After "The Matrix" it also has a name, see<br>
<a href="http://en.wikipedia.org/wiki/Blue_Pill_%28malware%29">http://en.wikipedia.org/wiki/Blue_Pill_%28malware%29</a></p>
<p>We could harden Isabelle/ML against this, since the ML environment is<br>
under our control.  Since this has no practical relevance, though, it has<br>
not been done so far.  It is important to keep focused on real problems.</p>
</blockquote>
<p>How could this be done?</p>
<p>Mark.</p>



<a name="294128659"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128659" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128659">(Aug 18 2022 at 17:01)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Dvid Matthews kindly provides ways in Poly/ML to manage the whole <br>
compilation process in user space, including printing and binding of the <br>
results.  One would merely have to protect agains shadowing of certain <br>
structure names, say.</p>
<p>When you've showed me an early version of HOL0 in Cambridge ITP 2009, I <br>
have already pointed out that OCaml is not the best platform for that (due <br>
to its mutable strings and silently overflowing machine words called <br>
"int").</p>
<p>Makarius</p>



<a name="294128698"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128698" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128698">(Aug 18 2022 at 17:01)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 18/1/11 7:10 PM, Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt; wrote:</p>
<blockquote>
<p>....</p>
<p>Dvid Matthews kindly provides ways in Poly/ML to manage the whole<br>
compilation process in user space, including printing and binding of the<br>
results.  One would merely have to protect agains shadowing of certain<br>
structure names, say.</p>
</blockquote>
<p>Oh good.  This is excellent news.  How long has this been available for?</p>
<p>A related problem is overwriting a datatype's pretty printer.  Do you know<br>
if Poly/ML can protect against this?</p>
<blockquote>
<p>When you've showed me an early version of HOL0 in Cambridge ITP 2009, I<br>
have already pointed out that OCaml is not the best platform for that (due<br>
to its mutable strings and silently overflowing machine words called<br>
"int").</p>
</blockquote>
<p>Yes you did (was it Montreal ITP 2008?).  HOL Zero uses a technique to avoid<br>
problems with mutable strings (unlike HOL Light) and doesn't use machine<br>
words for its representation of natural number numerals (like HOL Light).</p>
<p>But you are right - OCaml is not the best language.  Larry convinced me a<br>
few months ago that SML is simply more well-defined.  I plan to port it to<br>
SML as a priority as soon version 1.0 is out.  But this port might not be<br>
until next year.</p>
<p>Mark.</p>



<a name="294128709"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128709" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128709">(Aug 18 2022 at 17:01)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Maybe 2 years.  It was one of the many improvements that David Matthews <br>
did for parallel ML and ML IDE support.</p>
<p>This is where the Isabelle/ML compiler invocation happens: <br>
<a href="http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2009-2/src/Pure/ML/ml_compiler_polyml-5.3.ML">http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2009-2/src/Pure/ML/ml_compiler_polyml-5.3.ML</a> <br>
It is basically the Isabelle/Isar toplevel running ML, with toplevel name <br>
space management and pretty printing under our control. Without that <br>
parallel Isabelle would hardly work in practice.</p>
<p>Makarius</p>



<a name="294128763"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128763" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128763">(Aug 18 2022 at 17:01)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:gerwin.klein@nicta.com.au">gerwin.klein@nicta.com.au</a>&gt;<br>
I don't think this is a problem in practice. Theorem provers are already used in big certification projects. The evaluators in such projects usually know what they are doing, at least up to the level where they would easily be able to spot attempts to make syntactically misleading proof statements. It's easy enough to scan for ML blocks or similar in theory files, spot duplicate identifiers, etc, and demand good explanations for their presence (or just forbid them). And the threat of just using a proof checker is always there, so why try to cheat on syntax? </p>
<p>I'm with Larry on this: the much bigger problem is to convince yourself that the model and final theorem are in any way useful or right. This is where cheating will happen much earlier. </p>
<p>Cheers,<br>
Gerwin</p>



<a name="294128787"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128787" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128787">(Aug 18 2022 at 17:01)</a>:</h4>
<p>From: Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;<br>
If the contractor's product is being audited sufficiently carefully, the auditor will notice the dubious calls to the pretty-printing/bare-ML infrastructure that were required to get the fake result looking acceptable.</p>
<p>I really do not believe that this is an interesting issue.</p>
<p>If the terms are really so large that printing them in "raw" form is likely to be a problem, then they will be just as incomprehensible in pretty form, and just as unreliable when checked by eye-balling.  In that situation, the client will presumably check their supplier's work by doing something like</p>
<p>if aconv myterm (concl suppliers_thm) then print "OK"<br>
   else print "FAILURE"</p>
<p>And voilà, the pretty-printing "issue" disappears.</p>
<p>Michael</p>



<a name="294128800"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128800" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128800">(Aug 18 2022 at 17:02)</a>:</h4>
<p>From: Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;<br>
And the auditor failing to spot such malfeasance would be barely worth the name.</p>
<p>Michael</p>



<a name="294128868"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128868" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128868">(Aug 18 2022 at 17:02)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 18/1/11 10:22 PM, Gerwin Klein &lt;<a href="mailto:gerwin.klein@nicta.com.au">gerwin.klein@nicta.com.au</a>&gt; wrote:</p>
<blockquote>
<blockquote>
<p>We should remember that at the moment it is very easy for someone to<br>
maliciously produce what appears to be a formal proof of some statement<br>
...</p>
</blockquote>
<p>I don't think this is a problem in practice. Theorem provers are already<br>
used in big certification projects. The evaluators in such projects<br>
usually<br>
know what they are doing,</p>
</blockquote>
<p>How can you be so confident about this?  In the large, safety-critical<br>
certification projects I have been involved with, the evaluators do the best<br>
they can with the tools they have available.  Proof checkers with readable<br>
and highly trustworthy output is a luxury not available to them.</p>
<blockquote>
<p>at least up to the level where they would easily<br>
be able to spot attempts to make syntactically misleading proof<br>
statements.<br>
It's easy enough to scan for ML blocks or similar in theory files, spot<br>
duplicate identifiers, etc, and demand good explanations for their<br>
presence<br>
(or just forbid them). And the threat of just using a proof checker is<br>
always there, so why try to cheat on syntax?</p>
</blockquote>
<p>The input in this process is the full power of an ML program.  We all know<br>
that it is possible to hide incredibly subtle things in huge programs.  Are<br>
we to ban non-trivial ML in the process of producing a proof?  This would be<br>
forcing contractors to do their work with one hand tied behind their back.<br>
The contracted, safety-critical proof work I have been involved with would<br>
certainly have been completely infeasible without writing large amounts of<br>
ML program to support my proof work.</p>
<p>It is far better for the auditor if they can treat the ML code that<br>
establishes the final theorem as some sort of black box.  To do this the<br>
theorem prover needs certain basic properties, including a trustworthy<br>
printer.</p>
<blockquote>
<p>I'm with Larry on this: the much bigger problem is to convince yourself<br>
that<br>
the model and final theorem are in any way useful or right. This is where<br>
cheating will happen much earlier.</p>
</blockquote>
<p>I did not say that this was not a problem!  This is the big problem!  And<br>
this is the problem that I am advocating needs a tool that properly supports<br>
the process - the process of determining that the model and final theorem<br>
are right (as well as that the final theorem has actually been proved).<br>
This process involves using the pretty printer.</p>
<p>Mark.</p>



<a name="294128882"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128882" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128882">(Aug 18 2022 at 17:02)</a>:</h4>
<p>From: <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a><br>
on 18/1/11 10:52 PM, Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt; wrote:</p>
<blockquote>
<p>On 19/01/11 00:11, <a href="mailto:mark@proof-technologies.com">mark@proof-technologies.com</a> wrote:<br>
...</p>
<blockquote>
<p>Yes, but I don't think we can assume a non-malicious user!  What if<br>
someone wants to claim they have proved something in order to get<br>
paid? Subcontracting out proofs could be a serious business in the<br>
future.</p>
</blockquote>
<p>If the contractor's product is being audited sufficiently carefully, the<br>
auditor will notice the dubious calls to the pretty-printing/bare-ML<br>
infrastructure that were required to get the fake result looking<br>
acceptable.</p>
</blockquote>
<p>The input to the process is raw ML code, and huge amounts of it.  Almost<br>
anything can be hidden in this, unless very strict coding standards are<br>
enforced.  It is a far nicer situation for the auditor to be able to treat<br>
the ML code more-or-less as a black box, and review the state of the theorem<br>
prover after it has supposedly established the end-result theorem.  I am<br>
advocating a tool that makes life for the auditor easier.  A tool with a<br>
pretty printer that can be trusted.</p>
<blockquote>
<p>If the terms are really so large that printing them in "raw" form is<br>
likely<br>
to be a problem, then they will be just as incomprehensible in pretty<br>
form,</p>
</blockquote>
<p>You appear to be claiming that concrete syntax printers are of no practical<br>
use to the human reader.</p>
<blockquote>
<p>and just as unreliable when checked by eye-balling.  In that situation,<br>
the<br>
client will presumably check their supplier's work by doing something like</p>
<p>if aconv myterm (concl suppliers_thm) then print "OK"<br>
else print "FAILURE"</p>
<p>And voilà, the pretty-printing "issue" disappears.</p>
</blockquote>
<p>Let's assume we don't trust the parser.  How do we know that 'myterm' is<br>
correct?  We need to review definitions and terms, and this is best done<br>
using a trustworthy pretty printer.</p>
<p>I never thought that advocating a trustworthy pretty printer would be so<br>
controversial!!!</p>
<p>Mark.</p>



<a name="294128907"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20lexical%20matters/near/294128907" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20lexical.20matters.html#294128907">(Aug 18 2022 at 17:02)</a>:</h4>
<p>From: Michael Norrish &lt;<a href="mailto:Michael.Norrish@nicta.com.au">Michael.Norrish@nicta.com.au</a>&gt;<br>
It's just not an interesting problem.  We can solve it trivially by writing everything out in sexp-like notation.  ACL2 is demonstrably an acceptable format for security-critical validation, and this is all the pretty-printing they have.</p>
<p>Moreover, with proof terms (in Isabelle) and things like OpenTheory for the 3 HOLs, we can avoid having to look at clients' ML code.</p>
<p>Michael</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>