<html>
<head><meta charset="utf-8"><title>[isabelle] nat_code Equation · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html">[isabelle] nat_code Equation</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294227146"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294227146" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294227146">(Aug 19 2022 at 09:15)</a>:</h4>
<p>From: René Thiemann &lt;<a href="mailto:rene.thiemann@uibk.ac.at">rene.thiemann@uibk.ac.at</a>&gt;<br>
Dear all,</p>
<p>I recently had to check some very large proof using the code that was generated by Isabelle.<br>
Unfortunately we have not been able to parse the proof within reasonable time. <br>
Therefore, we started to profile our parser (which is written as an Isabelle function) <br>
and we stumbled upon a strange hotspot: nat!</p>
<p>In Code_Integer we have the following code-equation:</p>
<p>lemma nat_code [code]:<br>
  "nat k = (if k ≤ 0 then 0 else<br>
     let<br>
       (l, j) = divmod_int k 2;<br>
       n = nat l;<br>
       l' = n + n<br>
     in if j = 0 then l' else Suc l')"<br>
proof -<br>
  have "2 = nat 2" by simp<br>
  show ?thesis<br>
    apply (subst mult_2 [symmetric])<br>
    apply (auto simp add: Let_def divmod_int_mod_div not_le<br>
     nat_div_distrib nat_mult_distrib mult_div_cancel mod_2_not_eq_zero_eq_one_int)<br>
    apply (unfold <code>2 = nat 2</code>)<br>
    apply (subst nat_mod_distrib [symmetric])<br>
    apply simp_all<br>
  done<br>
qed</p>
<p>Is there any reason why this is so complex? I would imagine a much simpler equation where<br>
the proof is also simple.</p>
<p>lemma [code]: "nat k = (if k ≤ 0 then 0 else Suc (nat (k - 1)))"<br>
proof (cases k)<br>
  case (nonneg n)<br>
  show ?thesis unfolding nonneg<br>
    by (induct n, auto)<br>
qed simp</p>
<p>Best regards,<br>
René</p>



<a name="294227154"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294227154" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294227154">(Aug 19 2022 at 09:15)</a>:</h4>
<p>From: René Neumann &lt;<a href="mailto:rene.neumann@in.tum.de">rene.neumann@in.tum.de</a>&gt;<br>
Why not something tail-recursive, which, under the assumption that the<br>
compiler cannot optimize the above into something tail-recursive, should<br>
perform even better (probably except for Haskell):</p>
<p>fun nat' :: "int ⇒ nat ⇒ nat" where<br>
  "nat' k accu = (if k ≤ 0 then accu else nat' (k - 1) (Suc accu))"</p>
<p>lemma nat'_correct:<br>
  "nat' k l = nat k + l"<br>
proof (cases k)<br>
  case (nonneg n)<br>
  show ?thesis unfolding nonneg<br>
    by (induct n arbitrary: l) simp_all<br>
qed simp</p>
<p>lemma [code]: "nat k = nat' k 0"<br>
unfolding nat'_correct by simp</p>
<ul>
<li>René<br>
<a href="/user_uploads/14278/GyIQWjzThcXXW5ermUonNOym/smime.p7s">smime.p7s</a></li>
</ul>



<a name="294227159"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294227159" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294227159">(Aug 19 2022 at 09:15)</a>:</h4>
<p>From: René Neumann &lt;<a href="mailto:rene.neumann@in.tum.de">rene.neumann@in.tum.de</a>&gt;<br>
Just for the fun, a simple test:</p>
<p>fun nat' :: "int ⇒ nat ⇒ nat" where<br>
  "nat' k accu = (if k ≤ 0 then accu else nat' (k - 1) (Suc accu))"</p>
<p>fun nat_th :: "int ⇒ nat" where<br>
  "nat_th k = (if k ≤ 0 then 0 else Suc (nat_th (k - 1)))"</p>
<p>ML {*<br>
  val y : <a href="http://IntInf.int">IntInf.int</a> = 70000000;</p>
<p>(* Tail-recursive approach *)<br>
  val t = <a href="http://Time.now">Time.now</a> ();<br>
  val _ = @{code nat'} y (@{code nat} 0);<br>
  val nat_tail = Time.- (<a href="http://Time.now">Time.now</a> (), t);</p>
<p>(* René Thiemann's approach *)<br>
  val t = <a href="http://Time.now">Time.now</a> ();<br>
  val _ = @{code nat_th} y;<br>
  val nat_th = Time.- (Time.now() , t);</p>
<p>(* approach from Code_Integer *)<br>
  val t = <a href="http://Time.now">Time.now</a> ();<br>
  val _ = @{code nat} y;<br>
  val nat = Time.- (Time.now(), t);<br>
*}<br>
Results:</p>
<p>val nat_tail = 9.403: Time.time<br>
val nat_th = 28.333: Time.time<br>
val nat = 9.594: Time.time</p>
<p>Here the difference between nat_tail and nat is neglegible. When running<br>
the above multiple times, sometimes 'nat_tail' is a little better, other<br>
times 'nat' is.</p>
<ul>
<li>René<br>
<a href="/user_uploads/14278/PTb9oY48fNmraFM9q2vCRbeW/smime.p7s">smime.p7s</a></li>
</ul>



<a name="294227177"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294227177" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294227177">(Aug 19 2022 at 09:15)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:huffman@in.tum.de">huffman@in.tum.de</a>&gt;<br>
Note that if you import HOL/Library/Code_Nat.thy, which declares a<br>
binary code representation for type nat, then the implementation of<br>
function nat from Code_Integer is <em>much</em> faster than either nat' or<br>
nat_th.</p>
<ul>
<li>Brian</li>
</ul>



<a name="294227245"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294227245" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294227245">(Aug 19 2022 at 09:16)</a>:</h4>
<p>From: René Thiemann &lt;<a href="mailto:rene.thiemann@uibk.ac.at">rene.thiemann@uibk.ac.at</a>&gt;<br>
Since my use-case is a more complex program in Haskell, I prefer my version,<br>
but indeed for eager languages the tail-recursive variant is more plausible.</p>
<p>with nat (from library)<br>
3.32 seconds</p>
<p>with my version of nat:<br>
2.61 seconds</p>
<p>with your tail-rec. version of nat:<br>
2.76 seconds</p>
<p>Best regards,<br>
René</p>



<a name="294227248"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294227248" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294227248">(Aug 19 2022 at 09:16)</a>:</h4>
<p>From: René Thiemann &lt;<a href="mailto:rene.thiemann@uibk.ac.at">rene.thiemann@uibk.ac.at</a>&gt;<br>
Perhaps, then one can load this more complex nat-function only in "HOL/Library/Code_Nat.thy"?</p>
<ul>
<li>René</li>
</ul>



<a name="294228364"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228364" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228364">(Aug 19 2022 at 09:25)</a>:</h4>
<p>From: René Thiemann &lt;<a href="mailto:rene.thiemann@uibk.ac.at">rene.thiemann@uibk.ac.at</a>&gt;<br>
Hi Brian,</p>
<p>Unfortunately, HOL/Library/Code_Nat.thy does not fully work in my case. </p>
<p>The following short example shows the problem:</p>
<p>theory Test<br>
 imports "~~/src/HOL/Library/Code_Nat"<br>
begin</p>
<p>fun foo where <br>
  "foo xs 0 = True"<br>
| "foo [] (Suc _) = False"<br>
| "foo (x # xs) (Suc n) = foo xs n"</p>
<p>export_code foo in Haskell file -</p>
<p>complains about</p>
<p>"Nat.Suc" is not a constructor, on left hand side of equation, in theorem:<br>
foo [] (Suc ?uu) ≡ False</p>
<p>Of course, I can drop the pattern matching on Suc, but I do not want to do that<br>
manually for all my functions.</p>
<p>Cheers,<br>
René</p>
<p>PS: The problem also occurs in the development version of Isabelle where<br>
  I imported Code_Binary_Nat instead of Code_Nat (changeset ad52ddd35c3a)</p>



<a name="294228478"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228478" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228478">(Aug 19 2022 at 09:26)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:huffman@in.tum.de">huffman@in.tum.de</a>&gt;<br>
Hi René,</p>
<p>The ML setup in Code_Nat.thy is intended to automatically translate<br>
away patterns involving Suc, so that you don't have to do it yourself.<br>
Unfortunately the translation is kind of picky; it only works if for<br>
each rule with a "Suc n" pattern, there is a matching rule with a "0"<br>
pattern in its place. E.g. the following modification works with<br>
Code_Nat.thy in Isabelle2012:</p>
<p>fun foo where<br>
  "foo [] 0 = True"<br>
| "foo (x # xs) 0 = True"<br>
| "foo [] (Suc _) = False"<br>
| "foo (x # xs) (Suc n) = foo xs n"</p>
<p>But instead of changing your code, please try out the attached version<br>
of Code_Nat.thy, where I have modified the code preprocessor.</p>
<p>Florian: Perhaps you could look at my code and see whether it would be<br>
suitable to check in to the development repo. It might still contain<br>
some bugs; I haven't tested it on nested patterns like "Suc (Suc n)"<br>
for example.</p>
<ul>
<li>Brian<br>
<a href="/user_uploads/14278/oJ2yUN5cCskUsCZIxKfbjYCe/Code_Nat.thy">Code_Nat.thy</a></li>
</ul>



<a name="294228483"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228483" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228483">(Aug 19 2022 at 09:26)</a>:</h4>
<p>From: Florian Haftmann &lt;<a href="mailto:florian.haftmann@informatik.tu-muenchen.de">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>
Hi Brian,</p>
<p>I will put this in my queue which at the moment is near denial of<br>
service :-(.  But note that the code originally is from Stefan.</p>
<p>Cheers,<br>
    Florian<br>
<a href="/user_uploads/14278/aLt_imzzahu66t7hdqERlMMO/signature.asc">signature.asc</a></p>



<a name="294228505"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228505" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228505">(Aug 19 2022 at 09:26)</a>:</h4>
<p>From: René Thiemann &lt;<a href="mailto:rene.thiemann@uibk.ac.at">rene.thiemann@uibk.ac.at</a>&gt;</p>
<blockquote>
<blockquote>
<p>fun foo where<br>
 "foo xs 0 = True"<br>
| "foo [] (Suc _) = False"<br>
| "foo (x # xs) (Suc n) = foo xs n"</p>
<p>export_code foo in Haskell file -</p>
<p>complains about</p>
<p>"Nat.Suc" is not a constructor, on left hand side of equation, in theorem:<br>
foo [] (Suc ?uu) ≡ False</p>
</blockquote>
<p>The ML setup in Code_Nat.thy is intended to automatically translate<br>
away patterns involving Suc, so that you don't have to do it yourself.<br>
Unfortunately the translation is kind of picky; it only works if for<br>
each rule with a "Suc n" pattern, there is a matching rule with a "0"<br>
pattern in its place.</p>
</blockquote>
<p>I understand.</p>
<blockquote>
<p>E.g. the following modification works with<br>
Code_Nat.thy in Isabelle2012:</p>
<p>fun foo where<br>
 "foo [] 0 = True"<br>
| "foo (x # xs) 0 = True"<br>
| "foo [] (Suc _) = False"<br>
| "foo (x # xs) (Suc n) = foo xs n"</p>
<p>But instead of changing your code, please try out the attached version<br>
of Code_Nat.thy, where I have modified the code preprocessor.</p>
</blockquote>
<p>Thanks Brian, for the new version of Code_Nat. Unfortunately, it works for foo, <br>
but not for other functions. A minimized example that fails is as follows:</p>
<p>fun double :: "nat ⇒ nat" where<br>
  "double 0 = 0"<br>
| "double n = n + n"</p>
<p>export_code double in Haskell file -</p>
<p>Constructor as head in equation:<br>
nat_of_num ?n ≡ plus_nat_inst.plus_nat (pred_numeral ?n) (nat_of_num num.One) </p>
<p>René</p>



<a name="294228563"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228563" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228563">(Aug 19 2022 at 09:27)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:huffman@in.tum.de">huffman@in.tum.de</a>&gt;<br>
This took me a minute to figure out! In this example double.simps<br>
actually contains the rule "double (Suc n) = Suc n + Suc n". Since the<br>
RHS mentions "Suc" we must also generate code for "Suc" as well, which<br>
is where the problem starts.</p>
<p>In the code equation for Suc, "Suc n = n + 1", my code preprocessor<br>
incorrectly translates away the Suc on the LHS. I attach an updated<br>
version that fixes this.</p>
<p>However, after some more thought I don't think that my general<br>
approach will work at all for patterns like "Suc (Suc n)"; in the long<br>
run we'll probably have to stay with a code preprocessor like the<br>
current one, which can combine multiple equations into single ones<br>
that use if-then-else or case.</p>
<ul>
<li>Brian<br>
<a href="/user_uploads/14278/eLAQ63V5Cn7ztvrdIcdx2Zpu/Code_Nat.thy">Code_Nat.thy</a></li>
</ul>



<a name="294228698"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228698" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228698">(Aug 19 2022 at 09:28)</a>:</h4>
<p>From: Florian Haftmann &lt;<a href="mailto:florian.haftmann@informatik.tu-muenchen.de">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>
Hi René,</p>
<p>the observation made by Brian has indeed been the primary motiviation<br>
for this »representation-ignorant binary digit scanning« equation.<br>
There is a high chance that this could be changed in a similar way you<br>
suggest.  However, there is a reform of all that code generation<br>
arithmetic stuff ongoing, and this particular issue cannot be dealt in<br>
isolation with within the distribution.  So, I would recommend to<br>
declare this code equation in your particular application until this<br>
reform shows up in a release (it is very likely that this will not be<br>
the upcoming release).</p>
<p>Hope this helps,<br>
    Florian<br>
<a href="/user_uploads/14278/ctiEDi90JoBhi_VJIHH3HUlY/signature.asc">signature.asc</a></p>



<a name="294228741"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228741" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228741">(Aug 19 2022 at 09:28)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
Just some side-remarks about the Isabelle/ML that is quoted above:</p>
<p>* Type int is always the normal mathematical one, i.e. IntInf and Int<br>
     coincide.  (There are some special tricks to make the different SML<br>
     implementations underlying Isabelle/ML agree on this.)</p>
<p>* Structure Timing provides some tools for timing, notably the classic<br>
     timeit and timeap combinators.  Since timing on multicore hardware<br>
     is difficult to get right, it currently prints elapsed / CPU / GC time<br>
     to give some starting points for further guessing.  (In any case it is<br>
     the standard library entry for that, so when better timing mechanisms<br>
     become available they will be integrated here.)</p>
<p>Makarius</p>



<a name="294228806"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294228806" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294228806">(Aug 19 2022 at 09:29)</a>:</h4>
<p>From: René Thiemann &lt;<a href="mailto:rene.thiemann@uibk.ac.at">rene.thiemann@uibk.ac.at</a>&gt;<br>
Hi Florian,</p>
<p>This is perfectly fine for me. I can easily install my code-equation<br>
and will also wait on other changes in arithmetic. Anyway, my main <br>
motivation for posting my observation was that if one does not know <br>
about Code_Nat one obtains strange-looking code for "nat".</p>
<p>Cheers,<br>
René</p>



<a name="294234156"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20nat_code%20Equation/near/294234156" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20nat_code.20Equation.html#294234156">(Aug 19 2022 at 10:13)</a>:</h4>
<p>From: Florian Haftmann &lt;<a href="mailto:florian.haftmann@informatik.tu-muenchen.de">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>
Hi all,</p>
<blockquote>
<blockquote>
<p>Thanks Brian, for the new version of Code_Nat.</p>
</blockquote>
</blockquote>
<p>see now <a href="http://isabelle.in.tum.de/repos/isabelle/rev/0a2371e7ced3">http://isabelle.in.tum.de/repos/isabelle/rev/0a2371e7ced3</a></p>
<p>It is now possible, in theory Code_Binary_Nat, to drop the dependency on<br>
the venerable preprocessor by Stefan Berghofer (theory<br>
Code_Abstract_Nat) and install this specific preprocessor instead.</p>
<blockquote>
<p>However, after some more thought I don't think that my general<br>
approach will work at all for patterns like "Suc (Suc n)"; in the long<br>
run we'll probably have to stay with a code preprocessor like the<br>
current one, which can combine multiple equations into single ones<br>
that use if-then-else or case.</p>
</blockquote>
<p>Also the preprocessor from Code_Abstract_Nat cannot compile away all<br>
patterns: it always needs 0/Suc twins to proceed.</p>
<p>Cheers,<br>
    Florian<br>
<a href="/user_uploads/14278/_PMuNXpRH9dPPItcbIzpVd5I/signature.asc">signature.asc</a></p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>