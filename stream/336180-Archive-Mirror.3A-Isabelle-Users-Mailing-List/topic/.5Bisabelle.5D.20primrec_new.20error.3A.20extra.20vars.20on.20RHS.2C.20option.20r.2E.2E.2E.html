<html>
<head><meta charset="utf-8"><title>[isabelle] primrec_new error: extra vars on RHS, option r... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20primrec_new.20error.3A.20extra.20vars.20on.20RHS.2C.20option.20r.2E.2E.2E.html">[isabelle] primrec_new error: extra vars on RHS, option r...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294263258"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20primrec_new%20error%3A%20extra%20vars%20on%20RHS%2C%20option%20r.../near/294263258" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20primrec_new.20error.3A.20extra.20vars.20on.20RHS.2C.20option.20r.2E.2E.2E.html#294263258">(Aug 19 2022 at 13:19)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:andreas.lochbihler@inf.ethz.ch">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>
Dear Gottfried,</p>
<p>This looks like a primrec_new bug in Isabelle2013-2 (it works with "the" development <br>
version, e.g., 761e40ce91bc). As a workaround, you can wrap x in some function such as id.</p>
<p>primrec_new get_hS_FAILS :: "hD =&gt; hD fset" where<br>
   "get_hS_FAILS hEM    = {||}"<br>
  |"get_hS_FAILS (hS x) = id x"</p>
<p>Best,<br>
Andreas</p>



<a name="294263280"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20primrec_new%20error%3A%20extra%20vars%20on%20RHS%2C%20option%20r.../near/294263280" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20primrec_new.20error.3A.20extra.20vars.20on.20RHS.2C.20option.20r.2E.2E.2E.html#294263280">(Aug 19 2022 at 13:19)</a>:</h4>
<p>From: G B &lt;<a href="mailto:igbi@gmx.com">igbi@gmx.com</a>&gt;</p>
<blockquote>
<blockquote>
<p>[by Andreas]...As a workaround, you can wrap x in some function such as id.</p>
</blockquote>
</blockquote>
<p>Andreas, thanks again.</p>
<blockquote>
<p>Incidentally, I'm wondering whether you really need the "hEM" constructor in</p>
<p>datatype_new hD = hEM | hS "hD fset"</p>
<p>The canonical definition of hereditarily finite sets reads</p>
<p>datatype_new hD = hS "hD fset"</p>
</blockquote>
<p>Jasmin,</p>
<p>No, I don't, but I would have wasted a lot of time to find out that I <br>
don't, if you wouldn't have told me, so I'm grateful for you taking the <br>
time to tell me, and for other things also.</p>
<p>I am a foreigner, living among wizards, where I've known mainly only <br>
about the canonical Canon_List_Rule, in which there is <code>Nil</code> and <code>Cons x 
xs</code>. Because the Canon_List_Rule demands the existence of <code>Nil</code>, I <br>
concluded that I must claim the existence of a <code>hEM</code>.</p>
<p>True mathematical elegance is a statement that is so simple, it's hard <br>
for a novice to understand what information the statement contains.</p>
<p>Now, I understand the magic of the polymorphic empty set, <code>{||}</code>, along <br>
with the fact that it happens to be type correct for the constructor <br>
<code>hs</code>. The understanding about <code>{||}</code> being type correct didn't come <br>
until I started to try and simplify another <code>datatype</code>, based on your <br>
question/suggestion.</p>
<p>This demonstrates the value of occasionally interacting with actual <br>
humanoids, rather than only indirectly interacting through software. <br>
Error messages and failed proof attempts are valuable in that they tell <br>
me, "Novice, we wizards want to teach you something. It is enough that <br>
we have told you that you are wrong."</p>
<p>But when I don't get an error message and my proofs succeed, and I'm <br>
being logically clumsy, the software alone can't teach me a better way.</p>
<p>It appears that use of <code>datatype_new</code> to define hereditarily finite sets <br>
is not something that is easily hidden.</p>
<p>I actually only defined 'hD` because I figure if wizards are talking <br>
about hereditarily finite sets, then it's something I'm supposed to care <br>
about.</p>
<p>The <code>hS</code> ends up being one of 4 variations of sets I'm trying to work on <br>
that are variations of ZFC sets. I have two more powerful versions that <br>
hopefully will pan out. For a year and a half, I've worked on an axiom <br>
based set that gives me things I can be used with little or no modification.</p>
<p>The appearance of <code>datatype_new</code> has turned me into a closet <br>
constructivist, where I use <code>THE</code> and <code>SOME</code> only to hypocritically <br>
rebel against the constructivists, but never use if <code>THE</code> and <code>SOME</code> <br>
will prevent me from producing what could otherwise be used for computation.</p>
<p>On August 8, 2013, I was getting some foggy ideas on how I thought I <br>
needed to recursively define a certain object using nested sets. On that <br>
day, there came the list email "Re: [isabelle] nested datatypes" [1], <br>
which told of the a new datatype package coming down the pipe, and I saw <br>
that I merely needed to wait for that, because traditional ZFC sets are <br>
like the Hotel California, you can check elements in, but it's a hell in <br>
there, because it's hard to check them out. At least, that's my impression.</p>
<p>A large part of the value of Nitpick and Sledgehammer is the help they <br>
give me in prototyping. In one day, Nitpick showed me I needed to <br>
abandon two different definitions I was trying to implement. Then, after <br>
coming up with a partially good definition, Nitpick and Sledgehammer <br>
helped me get enough other definitions going, and theorems proved, to <br>
know I was on the right track.</p>
<p>I could start hitting these four variations hard, but I have a bad <br>
co-dependent relation with Sledgehammer. It's a high when it gives me an <br>
easy proof, but when it doesn't immediately provide a proof, I have to <br>
get manipulative. I don't care that I'm being manipulative. I only care <br>
that it takes too much time, and that I don't have a bigger toolbox to <br>
be able to optimize the metis proofs it gives me.</p>
<p>So, I have to take a huge, time-consuming tangent on logic.</p>
<p>I am a prophet who makes easy, fail-safe prophecies. In the game of <br>
logic, Isabelle will be a huge gamer-changer with the masses, and <br>
datatype_new will be a big game-changer in the game of Isabelle/HOL.</p>
<p>Regards,<br>
GB</p>
<p>[1] <br>
<a href="https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-August/msg00017.html">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-August/msg00017.html</a></p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>