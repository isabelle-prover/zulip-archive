<html>
<head><meta charset="utf-8"><title>[isabelle] quotient package: descending method raises typ... · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20quotient.20package.3A.20descending.20method.20raises.20typ.2E.2E.2E.html">[isabelle] quotient package: descending method raises typ...</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294148896"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20quotient%20package%3A%20descending%20method%20raises%20typ.../near/294148896" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20quotient.20package.3A.20descending.20method.20raises.20typ.2E.2E.2E.html#294148896">(Aug 18 2022 at 18:49)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:huffman@in.tum.de">huffman@in.tum.de</a>&gt;<br>
Hello all,</p>
<p>I tried to test the higher-order lifting capabilities of the<br>
Isabelle2011-1 quotient package recently. Here is my example theory:</p>
<p>theory Scratch<br>
imports "~~/src/HOL/Quotient_Examples/FSet"<br>
begin</p>
<p>lemma "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
apply descending</p>
<p>*** Type unification failed: Clash of types "_ list" and "_ fset"</p>
<hr>
<p>*** Type error in application: incompatible operand type</p>
<hr>
<p>*** Operator:  map :: ('b fset \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'b<br>
fset list \&lt;Rightarrow&gt; 'a fset list<br>
*** Operand:   map f :: 'b list \&lt;Rightarrow&gt; 'a list</p>
<p>A recent development version (4ecf63349466) yields exactly the same<br>
error message.</p>
<p>To test whether the multiple occurrences of map_fset at different<br>
types were causing the problem, I tried a simpler example:</p>
<p>lemma "concat_fset (map_fset (\&lt;lambda&gt;x. {|x|}) xs) = xs"<br>
apply descending</p>
<p>*** Type unification failed: Clash of types "_ list" and "_ fset"</p>
<hr>
<p>*** Type error in application: incompatible operand type</p>
<hr>
<p>*** Operator:  map :: ('a \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'a list<br>
\&lt;Rightarrow&gt; 'a fset list<br>
*** Operand:   \&lt;lambda&gt;x. [x] :: 'a \&lt;Rightarrow&gt; 'a list</p>
<p>Is there some additional configuration/setup I need to do to enable<br>
lifting of higher-order theorems, or does this error indicate a bug in<br>
the quotient package?</p>
<p>Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>
which the descending method actually works? I can't seem to find one.</p>
<ul>
<li>Brian</li>
</ul>



<a name="294148907"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20quotient%20package%3A%20descending%20method%20raises%20typ.../near/294148907" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20quotient.20package.3A.20descending.20method.20raises.20typ.2E.2E.2E.html#294148907">(Aug 18 2022 at 18:49)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:huffman@in.tum.de">huffman@in.tum.de</a>&gt;<br>
Hello all,</p>
<p>I tried to test the higher-order lifting capabilities of the<br>
Isabelle2011-1 quotient package recently. Here is my example theory:</p>
<p>theory Scratch<br>
imports "~~/src/HOL/Quotient_Examples/FSet"<br>
begin</p>
<p>lemma "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
apply descending</p>
<p>*** Type unification failed: Clash of types "_ list" and "_ fset"</p>
<hr>
<p>*** Type error in application: incompatible operand type</p>
<hr>
<p>*** Operator:  map :: ('b fset \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'b<br>
fset list \&lt;Rightarrow&gt; 'a fset list<br>
*** Operand:   map f :: 'b list \&lt;Rightarrow&gt; 'a list</p>
<p>A recent development version (4ecf63349466) yields exactly the same<br>
error message.</p>
<p>To test whether the multiple occurrences of map_fset at different<br>
types were causing the problem, I tried a simpler example:</p>
<p>lemma "concat_fset (map_fset (\&lt;lambda&gt;x. {|x|}) xs) = xs"<br>
apply descending</p>
<p>*** Type unification failed: Clash of types "_ list" and "_ fset"</p>
<hr>
<p>*** Type error in application: incompatible operand type</p>
<hr>
<p>*** Operator:  map :: ('a \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'a list<br>
\&lt;Rightarrow&gt; 'a fset list<br>
*** Operand:   \&lt;lambda&gt;x. [x] :: 'a \&lt;Rightarrow&gt; 'a list</p>
<p>Is there some additional configuration/setup I need to do to enable<br>
lifting of higher-order theorems, or does this error indicate a bug in<br>
the quotient package?</p>
<p>Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>
which the descending method actually works? I can't seem to find one.</p>
<ul>
<li>Brian</li>
</ul>



<a name="294148936"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20quotient%20package%3A%20descending%20method%20raises%20typ.../near/294148936" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20quotient.20package.3A.20descending.20method.20raises.20typ.2E.2E.2E.html#294148936">(Aug 18 2022 at 18:49)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:huffman@in.tum.de">huffman@in.tum.de</a>&gt;<br>
On Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href="mailto:urbanc@in.tum.de">urbanc@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>Hi Brian,</p>
<p>I am not sure whether this will help to establish your<br>
theorem, but here is something to get you started. "Descending"<br>
can only guess what the theorem should look like on<br>
the raw type. From what I have seen it might guess wrong<br>
in case of higher-order theorems (or in case where you are<br>
trying to lift constants of type ('a list) list to<br>
('a fset) fset).</p>
<p>One way to get around this is to already provide the<br>
lemma from which you want to lift. Like so</p>
<p>theory Scratch<br>
imports "~~/src/HOL/Quotient_Examples/FSet"<br>
begin</p>
<p>lemma map_concat_rev:<br>
 "concat (map (map f) xss) = map f (concat xss)"<br>
by (rule map_concat[symmetric])</p>
<p>lemma<br>
 "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
apply(lifting map_concat_rev)</p>
</blockquote>
<p>Yes, I also tried this. I understand that the "lifting" method<br>
typically should discharge the current goal, but in this case it<br>
leaves me with two new subgoals:</p>
<p>goal (2 subgoals):</p>
<ol>
<li>
<p>⋀fa x y.<br>
       ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>
       ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>
           list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>
           map map</p>
</li>
<li>
<p>(∀f xss.<br>
        concat_fset<br>
         (((abs_fset ---&gt; rep_fset) ---&gt;<br>
           (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>
           map (map_fset f) xss) =<br>
        map_fset f (concat_fset xss)) =<br>
    (∀f xss.<br>
        concat_fset (map_fset (map_fset f) xss) =<br>
        map_fset f (concat_fset xss))</p>
</li>
</ol>
<p>I'm not sure what I should do at this point. Is there some additional<br>
setup I can do that will allow "lifting" to discharge these<br>
automatically, or are users expected to try to discharge these<br>
manually?</p>
<ul>
<li>Brian</li>
</ul>
<blockquote>
<p>Brian Huffman writes:<br>
 &gt; Hello all,<br>
 &gt;<br>
 &gt; I tried to test the higher-order lifting capabilities of the<br>
 &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>
 &gt;<br>
 &gt; theory Scratch<br>
 &gt; imports "~~/src/HOL/Quotient_Examples/FSet"<br>
 &gt; begin<br>
 &gt;<br>
 &gt; lemma "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
 &gt; apply descending<br>
 &gt;<br>
 &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; ***<br>
 &gt; *** Type error in application: incompatible operand type<br>
 &gt; ***<br>
 &gt; *** Operator:  map :: ('b fset \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'b<br>
 &gt; fset list \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; *** Operand:   map f :: 'b list \&lt;Rightarrow&gt; 'a list<br>
 &gt;<br>
 &gt; A recent development version (4ecf63349466) yields exactly the same<br>
 &gt; error message.<br>
 &gt;<br>
 &gt; To test whether the multiple occurrences of map_fset at different<br>
 &gt; types were causing the problem, I tried a simpler example:<br>
 &gt;<br>
 &gt; lemma "concat_fset (map_fset (\&lt;lambda&gt;x. {|x|}) xs) = xs"<br>
 &gt; apply descending<br>
 &gt;<br>
 &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; ***<br>
 &gt; *** Type error in application: incompatible operand type<br>
 &gt; ***<br>
 &gt; *** Operator:  map :: ('a \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'a list<br>
 &gt; \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; *** Operand:   \&lt;lambda&gt;x. [x] :: 'a \&lt;Rightarrow&gt; 'a list<br>
 &gt;<br>
 &gt; Is there some additional configuration/setup I need to do to enable<br>
 &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>
 &gt; the quotient package?<br>
 &gt;<br>
 &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>
 &gt; which the descending method actually works? I can't seem to find one.<br>
 &gt;<br>
 &gt;<br>
 &gt; - Brian</p>
<p>--</p>
</blockquote>



<a name="294148948"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20quotient%20package%3A%20descending%20method%20raises%20typ.../near/294148948" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20quotient.20package.3A.20descending.20method.20raises.20typ.2E.2E.2E.html#294148948">(Aug 18 2022 at 18:49)</a>:</h4>
<p>From: Christian Urban &lt;<a href="mailto:urbanc@in.tum.de">urbanc@in.tum.de</a>&gt;<br>
Hi Brian,</p>
<p>Lifting (and descending) cannot always be done completely<br>
automatically. This is already a feature of the original<br>
work of Homeier. This means the tactic just return what<br>
they cannot solve automatically.</p>
<p>If I remember correctly, Cezary and I encountered similar <br>
problems with lifting properties about concat such as</p>
<p>"concat [] = []"<br>
   "concat (x # xs) = x @ concat xs"</p>
<p>This required us to do some contortions like proving the <br>
property concat_rsp in FSet.thy.</p>
<p>Best wishes,<br>
Christian</p>
<p>Brian Huffman writes:</p>
<blockquote>
<p>On Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href="mailto:urbanc@in.tum.de">urbanc@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>Hi Brian,</p>
<p>I am not sure whether this will help to establish your<br>
theorem, but here is something to get you started. "Descending"<br>
can only guess what the theorem should look like on<br>
the raw type. From what I have seen it might guess wrong<br>
in case of higher-order theorems (or in case where you are<br>
trying to lift constants of type ('a list) list to<br>
('a fset) fset).</p>
<p>One way to get around this is to already provide the<br>
lemma from which you want to lift. Like so</p>
<p>theory Scratch<br>
imports "~~/src/HOL/Quotient_Examples/FSet"<br>
begin</p>
<p>lemma map_concat_rev:<br>
 "concat (map (map f) xss) = map f (concat xss)"<br>
by (rule map_concat[symmetric])</p>
<p>lemma<br>
 "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
apply(lifting map_concat_rev)</p>
</blockquote>
<p>Yes, I also tried this. I understand that the "lifting" method<br>
typically should discharge the current goal, but in this case it<br>
leaves me with two new subgoals:</p>
<p>goal (2 subgoals):<br>
 1. ⋀fa x y.<br>
       ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>
       ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>
           list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>
           map map<br>
 2. (∀f xss.<br>
        concat_fset<br>
         (((abs_fset ---&gt; rep_fset) ---&gt;<br>
           (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>
           map (map_fset f) xss) =<br>
        map_fset f (concat_fset xss)) =<br>
    (∀f xss.<br>
        concat_fset (map_fset (map_fset f) xss) =<br>
        map_fset f (concat_fset xss))</p>
<p>I'm not sure what I should do at this point. Is there some additional<br>
setup I can do that will allow "lifting" to discharge these<br>
automatically, or are users expected to try to discharge these<br>
manually?</p>
<ul>
<li>Brian</li>
</ul>
<blockquote>
<p>Brian Huffman writes:<br>
 &gt; Hello all,<br>
 &gt;<br>
 &gt; I tried to test the higher-order lifting capabilities of the<br>
 &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>
 &gt;<br>
 &gt; theory Scratch<br>
 &gt; imports "~~/src/HOL/Quotient_Examples/FSet"<br>
 &gt; begin<br>
 &gt;<br>
 &gt; lemma "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
 &gt; apply descending<br>
 &gt;<br>
 &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; ***<br>
 &gt; *** Type error in application: incompatible operand type<br>
 &gt; ***<br>
 &gt; *** Operator:  map :: ('b fset \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'b<br>
 &gt; fset list \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; *** Operand:   map f :: 'b list \&lt;Rightarrow&gt; 'a list<br>
 &gt;<br>
 &gt; A recent development version (4ecf63349466) yields exactly the same<br>
 &gt; error message.<br>
 &gt;<br>
 &gt; To test whether the multiple occurrences of map_fset at different<br>
 &gt; types were causing the problem, I tried a simpler example:<br>
 &gt;<br>
 &gt; lemma "concat_fset (map_fset (\&lt;lambda&gt;x. {|x|}) xs) = xs"<br>
 &gt; apply descending<br>
 &gt;<br>
 &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; ***<br>
 &gt; *** Type error in application: incompatible operand type<br>
 &gt; ***<br>
 &gt; *** Operator:  map :: ('a \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'a list<br>
 &gt; \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; *** Operand:   \&lt;lambda&gt;x. [x] :: 'a \&lt;Rightarrow&gt; 'a list<br>
 &gt;<br>
 &gt; Is there some additional configuration/setup I need to do to enable<br>
 &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>
 &gt; the quotient package?<br>
 &gt;<br>
 &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>
 &gt; which the descending method actually works? I can't seem to find one.<br>
 &gt;<br>
 &gt;<br>
 &gt; - Brian</p>
<p>--</p>
</blockquote>
</blockquote>



<a name="294152329"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20quotient%20package%3A%20descending%20method%20raises%20typ.../near/294152329" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20quotient.20package.3A.20descending.20method.20raises.20typ.2E.2E.2E.html#294152329">(Aug 18 2022 at 19:09)</a>:</h4>
<p>From: Brian Huffman &lt;<a href="mailto:huffman@in.tum.de">huffman@in.tum.de</a>&gt;<br>
[Note to isabelle-users members: This a continuation of an old thread<br>
from Dec. 18.]</p>
<p>On Fri, Feb 3, 2012 at 4:35 PM, Cezary Kaliszyk<br>
&lt;<a href="mailto:cezarykaliszyk@gmail.com">cezarykaliszyk@gmail.com</a>&gt; wrote:</p>
<blockquote>
<p>Hi Brian,</p>
<p>It is very late to answer your email, but I added the compositional<br>
respectfulness and preservation theorems for 'map', which means<br>
that the theorem you mentioned (map_concat) now lifts automatically.</p>
</blockquote>
<p>Hi Cezary,</p>
<p>Thanks for adding the new respectfulness and preservation theorems for<br>
map. Unfortunately the descending method still produces the same error<br>
message, but the proof does indeed work with the lifting method now:</p>
<p>theory Scratch imports "~~/src/HOL/Quotient_Examples/FSet" begin</p>
<p>lemma "map_fset f (concat_fset xss) = concat_fset (map_fset (map_fset f) xss)"<br>
by (lifting map_concat)</p>
<p>I also tried my other example again:</p>
<p>lemma concat_map_single: "concat (map (\&lt;lambda&gt;x. [x]) xs) = xs"<br>
by (induct xs, simp_all)</p>
<p>lemma "concat_fset (map_fset (\&lt;lambda&gt;x. {|x|}) xs) = xs"<br>
apply (lifting concat_map_single)</p>
<p>Here the lifting method leaves a couple of subgoals, but by following<br>
your example I was able to state and prove the necessary<br>
respectfulness and preservation theorems:</p>
<p>lemma map_rsp3 [quot_respect]:<br>
  "((op = ===&gt; list_eq) ===&gt; list_eq ===&gt; list_all2 list_eq OOO<br>
list_eq) map map"</p>
<p>lemma map_prs3 [quot_preserve]:<br>
  "((id ---&gt; rep_fset) ---&gt; rep_fset ---&gt; (abs_fset o map abs_fset))<br>
map = map_fset"</p>
<p>So it seems that the quotient package needs a separate respectfulness<br>
theorem for each of these type instances of map:</p>
<p>map_rsp, for map :: ('a =&gt; 'b) =&gt; 'a list =&gt; 'b list<br>
map_rsp2, for map :: ('a list =&gt; 'b list) =&gt; 'a list list =&gt; 'b list list<br>
map_rsp3, for map :: ('a =&gt; 'b list) =&gt; 'a list =&gt; 'b list list</p>
<p>I suppose I would need another theorem map_rsp4 in order to use map at<br>
type ('a list =&gt; 'b) =&gt; 'a list list =&gt; 'b list, for example.</p>
<p>Moving on, I also tried lifting another monad law, which gave me a<br>
completely new error message.</p>
<p>lemma concat_map_concat: "concat (map concat xsss) = concat (concat xsss)"<br>
by (induct xsss, simp_all)</p>
<p>lemma "concat_fset (map_fset concat_fset xsss) = concat_fset (concat_fset xsss)"<br>
apply (lifting concat_map_concat)</p>
<p>*** Solve_quotient_assm failed. Possibly a quotient theorem is missing.</p>
<p>Perhaps you could help me determine what quotient theorem I need here?<br>
I suspect that this error has something to do the variable xsss :: 'a<br>
list list list, with the 3-deep nesting of the list type.</p>
<ul>
<li>Brian</li>
</ul>
<blockquote>
<p>On Sun, Dec 18, 2011 at 11:46 AM, Christian Urban &lt;<a href="mailto:urbanc@in.tum.de">urbanc@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<p>Hi Brian,</p>
<p>Lifting (and descending) cannot always be done completely<br>
automatically. This is already a feature of the original<br>
work of Homeier. This means the tactic just return what<br>
they cannot solve automatically.</p>
<p>If I remember correctly, Cezary and I encountered similar<br>
problems with lifting properties about concat such as</p>
<p>"concat [] = []"<br>
  "concat (x # xs) = x @ concat xs"</p>
<p>This required us to do some contortions like proving the<br>
property concat_rsp in FSet.thy.</p>
<p>Best wishes,<br>
Christian</p>
<p>Brian Huffman writes:</p>
<p>On Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href="mailto:urbanc@in.tum.de">urbanc@in.tum.de</a>&gt; wrote:<br>
 &gt; &gt;<br>
 &gt; &gt; Hi Brian,<br>
 &gt; &gt;<br>
 &gt; &gt; I am not sure whether this will help to establish your<br>
 &gt; &gt; theorem, but here is something to get you started. "Descending"<br>
 &gt; &gt; can only guess what the theorem should look like on<br>
 &gt; &gt; the raw type. From what I have seen it might guess wrong<br>
 &gt; &gt; in case of higher-order theorems (or in case where you are<br>
 &gt; &gt; trying to lift constants of type ('a list) list to<br>
 &gt; &gt; ('a fset) fset).<br>
 &gt; &gt;<br>
 &gt; &gt; One way to get around this is to already provide the<br>
 &gt; &gt; lemma from which you want to lift. Like so<br>
 &gt; &gt;<br>
 &gt; &gt; theory Scratch<br>
 &gt; &gt; imports "~~/src/HOL/Quotient_Examples/FSet"<br>
 &gt; &gt; begin<br>
 &gt; &gt;<br>
 &gt; &gt; lemma map_concat_rev:<br>
 &gt; &gt;  "concat (map (map f) xss) = map f (concat xss)"<br>
 &gt; &gt; by (rule map_concat[symmetric])<br>
 &gt; &gt;<br>
 &gt; &gt; lemma<br>
 &gt; &gt;  "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
 &gt; &gt; apply(lifting map_concat_rev)<br>
 &gt;<br>
 &gt; Yes, I also tried this. I understand that the "lifting" method<br>
 &gt; typically should discharge the current goal, but in this case it<br>
 &gt; leaves me with two new subgoals:<br>
 &gt;<br>
 &gt; goal (2 subgoals):<br>
 &gt;  1. ⋀fa x y.<br>
 &gt;        ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>
 &gt;        ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>
 &gt;            list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>
 &gt;            map map<br>
 &gt;  2. (∀f xss.<br>
 &gt;         concat_fset<br>
 &gt;          (((abs_fset ---&gt; rep_fset) ---&gt;<br>
 &gt;            (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>
 &gt;            map (map_fset f) xss) =<br>
 &gt;         map_fset f (concat_fset xss)) =<br>
 &gt;     (∀f xss.<br>
 &gt;         concat_fset (map_fset (map_fset f) xss) =<br>
 &gt;         map_fset f (concat_fset xss))<br>
 &gt;<br>
 &gt; I'm not sure what I should do at this point. Is there some additional<br>
 &gt; setup I can do that will allow "lifting" to discharge these<br>
 &gt; automatically, or are users expected to try to discharge these<br>
 &gt; manually?<br>
 &gt;<br>
 &gt; - Brian<br>
 &gt;<br>
 &gt; &gt; Brian Huffman writes:<br>
 &gt; &gt;  &gt; Hello all,<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; I tried to test the higher-order lifting capabilities of the<br>
 &gt; &gt;  &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; theory Scratch<br>
 &gt; &gt;  &gt; imports "~~/src/HOL/Quotient_Examples/FSet"<br>
 &gt; &gt;  &gt; begin<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; lemma "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
 &gt; &gt;  &gt; apply descending<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Operator:  map :: ('b fset \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'b<br>
 &gt; &gt;  &gt; fset list \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; &gt;  &gt; *** Operand:   map f :: 'b list \&lt;Rightarrow&gt; 'a list<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; A recent development version (4ecf63349466) yields exactly the same<br>
 &gt; &gt;  &gt; error message.<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; To test whether the multiple occurrences of map_fset at different<br>
 &gt; &gt;  &gt; types were causing the problem, I tried a simpler example:<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; lemma "concat_fset (map_fset (\&lt;lambda&gt;x. {|x|}) xs) = xs"<br>
 &gt; &gt;  &gt; apply descending<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Operator:  map :: ('a \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'a list<br>
 &gt; &gt;  &gt; \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; &gt;  &gt; *** Operand:   \&lt;lambda&gt;x. [x] :: 'a \&lt;Rightarrow&gt; 'a list<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; Is there some additional configuration/setup I need to do to enable<br>
 &gt; &gt;  &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>
 &gt; &gt;  &gt; the quotient package?<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>
 &gt; &gt;  &gt; which the descending method actually works? I can't seem to find one.<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; - Brian<br>
 &gt; &gt;<br>
 &gt; &gt; --</p>
<p>--<br>
</p>
</blockquote>
<p>--<br>
Cezary Kaliszyk, University of Innsbruck,<br>
<a href="http://cl-informatik.uibk.ac.at/~cek/">http://cl-informatik.uibk.ac.at/~cek/</a></p>
</blockquote>



<a name="294152698"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20quotient%20package%3A%20descending%20method%20raises%20typ.../near/294152698" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20quotient.20package.3A.20descending.20method.20raises.20typ.2E.2E.2E.html#294152698">(Aug 18 2022 at 19:11)</a>:</h4>
<p>From: Cezary Kaliszyk &lt;<a href="mailto:cezarykaliszyk@gmail.com">cezarykaliszyk@gmail.com</a>&gt;<br>
Hi Brian,</p>
<p>On Sat, Feb 04, 2012 at 10:05:00AM +0100, Brian Huffman wrote:</p>
<blockquote>
<blockquote>
<p>It is very late to answer your email, but I added the compositional<br>
respectfulness and preservation theorems for 'map', which means<br>
that the theorem you mentioned (map_concat) now lifts automatically.<br>
Thanks for adding the new respectfulness and preservation theorems for<br>
map. Unfortunately the descending method still produces the same error<br>
message [...]</p>
</blockquote>
</blockquote>
<p>Should be fixed now. As mentioned before in this thread the procedure<br>
for guessing which theorem one wants to lift (and the procedure for<br>
guessing the lifted theorem) is a heuristic. The idea for the<br>
heuristic is to be greedy as this is what the user wants in most<br>
cases, however the implementation was not greedy enough.</p>
<blockquote>
<p>Moving on, I also tried lifting another monad law, which gave me a<br>
completely new error message.</p>
<p>lemma concat_map_concat: "concat (map concat xsss) = concat (concat xsss)"<br>
by (induct xsss, simp_all)</p>
<p>lemma "concat_fset (map_fset concat_fset xsss) = concat_fset (concat_fset xsss)"<br>
apply (lifting concat_map_concat)</p>
<p>*** Solve_quotient_assm failed. Possibly a quotient theorem is missing.</p>
<p>Perhaps you could help me determine what quotient theorem I need here?<br>
I suspect that this error has something to do the variable xsss :: 'a<br>
list list list, with the 3-deep nesting of the list type.</p>
</blockquote>
<p>If instead of lifting you use lifting_setup and manually apply<br>
regularize and injection, you can see the missing quotient theorem,<br>
namely:</p>
<p>Quotient (list_all2 (list_all2 op \&lt;approx&gt; OOO op \&lt;approx&gt;) OOO op \&lt;approx&gt;)<br>
     (abs_fset \&lt;circ&gt; map (abs_fset \&lt;circ&gt; map abs_fset))<br>
     (map (map rep_fset \&lt;circ&gt; rep_fset) \&lt;circ&gt; rep_fset)</p>
<p>Since this involves a composition of 3 relations I imagine it to be<br>
very tedious to prove; but if you declare it with the [quot_thm]<br>
attribute, the lifting will only leave the usual respectfulness and<br>
preservation obligations.</p>
<p>Regards,</p>
<p>Cezary</p>
<blockquote>
<p>On Sun, Dec 18, 2011 at 11:46 AM, Christian Urban &lt;<a href="mailto:urbanc@in.tum.de">urbanc@in.tum.de</a>&gt; wrote:</p>
<blockquote>
<blockquote>
<p>Hi Brian,</p>
<p>Lifting (and descending) cannot always be done completely<br>
automatically. This is already a feature of the original<br>
work of Homeier. This means the tactic just return what<br>
they cannot solve automatically.</p>
<p>If I remember correctly, Cezary and I encountered similar<br>
problems with lifting properties about concat such as</p>
<p>"concat [] = []"<br>
  "concat (x # xs) = x @ concat xs"</p>
<p>This required us to do some contortions like proving the<br>
property concat_rsp in FSet.thy.</p>
<p>Best wishes,<br>
Christian</p>
<p>Brian Huffman writes:</p>
<p>On Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href="mailto:urbanc@in.tum.de">urbanc@in.tum.de</a>&gt; wrote:<br>
 &gt; &gt;<br>
 &gt; &gt; Hi Brian,<br>
 &gt; &gt;<br>
 &gt; &gt; I am not sure whether this will help to establish your<br>
 &gt; &gt; theorem, but here is something to get you started. "Descending"<br>
 &gt; &gt; can only guess what the theorem should look like on<br>
 &gt; &gt; the raw type. From what I have seen it might guess wrong<br>
 &gt; &gt; in case of higher-order theorems (or in case where you are<br>
 &gt; &gt; trying to lift constants of type ('a list) list to<br>
 &gt; &gt; ('a fset) fset).<br>
 &gt; &gt;<br>
 &gt; &gt; One way to get around this is to already provide the<br>
 &gt; &gt; lemma from which you want to lift. Like so<br>
 &gt; &gt;<br>
 &gt; &gt; theory Scratch<br>
 &gt; &gt; imports "~~/src/HOL/Quotient_Examples/FSet"<br>
 &gt; &gt; begin<br>
 &gt; &gt;<br>
 &gt; &gt; lemma map_concat_rev:<br>
 &gt; &gt;  "concat (map (map f) xss) = map f (concat xss)"<br>
 &gt; &gt; by (rule map_concat[symmetric])<br>
 &gt; &gt;<br>
 &gt; &gt; lemma<br>
 &gt; &gt;  "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
 &gt; &gt; apply(lifting map_concat_rev)<br>
 &gt;<br>
 &gt; Yes, I also tried this. I understand that the "lifting" method<br>
 &gt; typically should discharge the current goal, but in this case it<br>
 &gt; leaves me with two new subgoals:<br>
 &gt;<br>
 &gt; goal (2 subgoals):<br>
 &gt;  1. ⋀fa x y.<br>
 &gt;        ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>
 &gt;        ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>
 &gt;            list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>
 &gt;            map map<br>
 &gt;  2. (∀f xss.<br>
 &gt;         concat_fset<br>
 &gt;          (((abs_fset ---&gt; rep_fset) ---&gt;<br>
 &gt;            (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>
 &gt;            map (map_fset f) xss) =<br>
 &gt;         map_fset f (concat_fset xss)) =<br>
 &gt;     (∀f xss.<br>
 &gt;         concat_fset (map_fset (map_fset f) xss) =<br>
 &gt;         map_fset f (concat_fset xss))<br>
 &gt;<br>
 &gt; I'm not sure what I should do at this point. Is there some additional<br>
 &gt; setup I can do that will allow "lifting" to discharge these<br>
 &gt; automatically, or are users expected to try to discharge these<br>
 &gt; manually?<br>
 &gt;<br>
 &gt; - Brian<br>
 &gt;<br>
 &gt; &gt; Brian Huffman writes:<br>
 &gt; &gt;  &gt; Hello all,<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; I tried to test the higher-order lifting capabilities of the<br>
 &gt; &gt;  &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; theory Scratch<br>
 &gt; &gt;  &gt; imports "~~/src/HOL/Quotient_Examples/FSet"<br>
 &gt; &gt;  &gt; begin<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; lemma "concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)"<br>
 &gt; &gt;  &gt; apply descending<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Operator:  map :: ('b fset \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'b<br>
 &gt; &gt;  &gt; fset list \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; &gt;  &gt; *** Operand:   map f :: 'b list \&lt;Rightarrow&gt; 'a list<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; A recent development version (4ecf63349466) yields exactly the same<br>
 &gt; &gt;  &gt; error message.<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; To test whether the multiple occurrences of map_fset at different<br>
 &gt; &gt;  &gt; types were causing the problem, I tried a simpler example:<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; lemma "concat_fset (map_fset (\&lt;lambda&gt;x. {|x|}) xs) = xs"<br>
 &gt; &gt;  &gt; apply descending<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; *** Type unification failed: Clash of types "_ list" and "_ fset"<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>
 &gt; &gt;  &gt; ***<br>
 &gt; &gt;  &gt; *** Operator:  map :: ('a \&lt;Rightarrow&gt; 'a fset) \&lt;Rightarrow&gt; 'a list<br>
 &gt; &gt;  &gt; \&lt;Rightarrow&gt; 'a fset list<br>
 &gt; &gt;  &gt; *** Operand:   \&lt;lambda&gt;x. [x] :: 'a \&lt;Rightarrow&gt; 'a list<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; Is there some additional configuration/setup I need to do to enable<br>
 &gt; &gt;  &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>
 &gt; &gt;  &gt; the quotient package?<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>
 &gt; &gt;  &gt; which the descending method actually works? I can't seem to find one.<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt;<br>
 &gt; &gt;  &gt; - Brian<br>
 &gt; &gt;<br>
 &gt; &gt; --</p>
<p>--<br>
</p>
</blockquote>
</blockquote>
</blockquote>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>