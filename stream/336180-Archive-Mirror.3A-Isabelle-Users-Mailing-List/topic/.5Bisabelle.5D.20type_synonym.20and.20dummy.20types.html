<html>
<head><meta charset="utf-8"><title>[isabelle] type_synonym and dummy types · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20type_synonym.20and.20dummy.20types.html">[isabelle] type_synonym and dummy types</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294746600"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20type_synonym%20and%20dummy%20types/near/294746600" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20type_synonym.20and.20dummy.20types.html#294746600">(Aug 22 2022 at 18:42)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
Hi, consider the following definition</p>
<p>definition finite_rel :: "_ rel ⇒ bool" where "finite_rel ≡ finite"</p>
<p>I would expect to define a constant that is restricted to relations,<br>
i.e., ('a*'a) set, as suggested by </p>
<p>type_synonym 'a rel = "('a × 'a) set"</p>
<p>However, the expansion of type_synonym seems to take place before<br>
expansion of underscores, such that I actually get</p>
<p>consts<br>
  finite_rel :: "('a × 'b) set ⇒ bool"</p>
<p>i.e., a constant that is more general than expected.</p>
<p>Is this just a random feature, or is their some rationale behind?</p>



<a name="294746634"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20type_synonym%20and%20dummy%20types/near/294746634" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20type_synonym.20and.20dummy.20types.html#294746634">(Aug 22 2022 at 18:42)</a>:</h4>
<p>From: Andreas Lochbihler &lt;<a href="mailto:mail@andreas-lochbihler.de">mail@andreas-lochbihler.de</a>&gt;<br>
Hi Peter,</p>
<p>I'd say that this is a random feature from user perspective, but I <br>
believe that there is some rationale in terms of implementation <br>
complexitz behind that. As you've observed, dummy types are instantiated <br>
with fresh variables only after type abbreviations have been expanded. <br>
The expansion mechanism would have to be more complicated if it had to <br>
track which dummy types variables are derived from the same syntactic <br>
input term.</p>
<p>By the way, IIRC I noticed this behaviour many years ago when we worked <br>
together on our first joint formalisation and you had used dummy types <br>
in there. Since then, I've tried to avoid dummy types unless for <br>
experiments.</p>
<p>Best,<br>
Andreas</p>



<hr><p>Last updated: Nov 01 2025 at 16:22 UTC</p>
</html>