<html>
<head><meta charset="utf-8"><title>[isabelle] union-find based unification · Archive Mirror: Isabelle Users Mailing List · Zulip Chat Archive</title></head>
<h2>Stream: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/index.html">Archive Mirror: Isabelle Users Mailing List</a></h2>
<h3>Topic: <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html">[isabelle] union-find based unification</a></h3>

<hr>

<base href="https://isabelle.zulipchat.com/">

<head><link href="http://isabelle.systems/zulip-archive/style.css" rel="stylesheet"></head>

<a name="294237022"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237022" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237022">(Aug 19 2022 at 10:34)</a>:</h4>
<p>From: Christian Sternagel &lt;<a href="mailto:c.sternagel@gmail.com">c.sternagel@gmail.com</a>&gt;<br>
Dear all,</p>
<p>is anybody aware of an Isabelle/HOL (or even better Imperative_HOL) <br>
formalization of a union-find data structure for which also code can be <br>
generated? I found</p>
<p><a href="http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml">http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml</a></p>
<p>which mentions union-find trees in the introduction, but by skimming <br>
over the theory names nothing immediately jumped at me ;)</p>
<p>The reason I ask is for an efficient (code generatable) formalization, <br>
using union-find,  of a first-order unification algorithm. Anybody aware <br>
that this was already done?</p>
<p>cheers</p>
<p>chris</p>



<a name="294237070"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237070" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237070">(Aug 19 2022 at 10:34)</a>:</h4>
<p>From: Lukas Bulwahn &lt;<a href="mailto:bulwahn@in.tum.de">bulwahn@in.tum.de</a>&gt;<br>
Hi Christian,</p>
<p>I have an efficient first-order unification algorithm in Imperative HOL <br>
in my shelf (from back in 2009).<br>
I was mainly interested in using Imperative HOL and what the problems in <br>
larger developments are with the Imperative HOL framework.<br>
Also, we used that as case study for the partial function prototype in 2010.</p>
<p>However, I never found time to polish the proofs and make that work <br>
publicly available.<br>
If you are interested, we can discuss if the unpolished development is <br>
of any use for you.</p>
<p>Lukas</p>



<a name="294237102"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237102" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237102">(Aug 19 2022 at 10:34)</a>:</h4>
<p>From: Christian Sternagel &lt;<a href="mailto:c.sternagel@gmail.com">c.sternagel@gmail.com</a>&gt;<br>
Dear Lukas,</p>
<p>I vaguely remember that we already talked about this and well, I am <br>
interested ;)</p>
<p>(If possible, I would like to improve the generated code for IsaFoR, <br>
however, after some recent improvements by René, this might no longer be <br>
necessary, let's see.)</p>
<p>In principle I'm also interested in using Imperative HOL for algorithm <br>
refinement prior to code generation (at the moment it's not clear to me <br>
whether this is possible at all, i.e., for some pure function "f", prove <br>
that an Imperative HOL function "g" is a faithful implementation... if I <br>
understand correctly, "g" will always have its result type wrapped in <br>
"Heap" and thus we cannot prove a code equation between "f" and "g"... <br>
but maybe I'm wrong).</p>
<p>cheers</p>
<p>chris</p>



<a name="294237162"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237162" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237162">(Aug 19 2022 at 10:34)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;</p>
<blockquote>
<p><a href="http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml">http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml</a></p>
</blockquote>
<p>The union-find structures are in the examples folder in<br>
Examples/Union_Find.thy.</p>
<p>However, someone seems to have messed up ROOT.ML when porting to<br>
Isabelle2013, such that this file is not compiled any more!</p>
<p>I'll check whether Union_Find still compiles under 2013, and send a<br>
patch here if it does not.</p>
<p>Best, and thanks for pointing to the problem,<br>
  Peter</p>
<blockquote>
<p>which mentions union-find trees in the introduction, but by skimming <br>
over the theory names nothing immediately jumped at me ;)</p>
<p>The reason I ask is for an efficient (code generatable) formalization, <br>
using union-find,  of a first-order unification algorithm. Anybody aware <br>
that this was already done?</p>
<p>cheers</p>
<p>chris</p>
</blockquote>



<a name="294237170"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237170" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237170">(Aug 19 2022 at 10:34)</a>:</h4>
<p>From: Lukas Bulwahn &lt;<a href="mailto:bulwahn@in.tum.de">bulwahn@in.tum.de</a>&gt;<br>
Hi Christian,</p>
<p>On 03/22/2013 08:21 AM, Christian Sternagel wrote:</p>
<blockquote>
<p>Dear Lukas,</p>
<p>I vaguely remember that we already talked about this and well, I am <br>
interested ;)</p>
<p>I will send you the sources. If you have time to polish it, we can <br>
submit it to the AFP.<br>
(If possible, I would like to improve the generated code for IsaFoR, <br>
however, after some recent improvements by René, this might no longer <br>
be necessary, let's see.)</p>
<p>I believe that the functional implementation of unification based on a <br>
efficient functional Map implementation is only a minor constant factor <br>
slower than the imperative implementation.<br>
Then you would not even have to consider the Imperative HOL setting.</p>
</blockquote>
<blockquote>
<p>In principle I'm also interested in using Imperative HOL for algorithm <br>
refinement prior to code generation (at the moment it's not clear to <br>
me whether this is possible at all, i.e., for some pure function "f", <br>
prove that an Imperative HOL function "g" is a faithful <br>
implementation... if I understand correctly, "g" will always have its <br>
result type wrapped in "Heap" and thus we cannot prove a code equation <br>
between "f" and "g"... but maybe I'm wrong).</p>
<p>I have an argument how to define escaping this monad and set up code <br>
generation in a sound way by extending the code generation specialities <br>
for Imperative HOL even more.<br>
However, I would rather want to see that the monad remains in the whole <br>
program.</p>
</blockquote>
<p>I was always hoping that the newly developed Lifting package could <br>
automate the tedious task of lifting all purely functional parts into <br>
the monad, but I never tried that.</p>
<p>Lukas</p>
<blockquote>
<p>cheers</p>
<p>chris</p>
<p>On 03/22/2013 02:48 PM, Lukas Bulwahn wrote:</p>
<blockquote>
<p>Hi Christian,</p>
<p>I have an efficient first-order unification algorithm in Imperative HOL<br>
in my shelf (from back in 2009).<br>
I was mainly interested in using Imperative HOL and what the problems in<br>
larger developments are with the Imperative HOL framework.<br>
Also, we used that as case study for the partial function prototype in<br>
2010.</p>
<p>However, I never found time to polish the proofs and make that work<br>
publicly available.<br>
If you are interested, we can discuss if the unpolished development is<br>
of any use for you.</p>
<p>Lukas</p>
</blockquote>
<p>On 03/22/2013 06:03 AM, Christian Sternagel wrote:</p>
<blockquote>
<blockquote>
<p>Dear all,</p>
<p>is anybody aware of an Isabelle/HOL (or even better Imperative_HOL)<br>
formalization of a union-find data structure for which also code can<br>
be generated? I found</p>
<p><a href="http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml">http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml</a> </p>
<p>which mentions union-find trees in the introduction, but by skimming<br>
over the theory names nothing immediately jumped at me ;)</p>
<p>The reason I ask is for an efficient (code generatable) formalization,<br>
using union-find,  of a first-order unification algorithm. Anybody<br>
aware that this was already done?</p>
<p>cheers</p>
<p>chris</p>
</blockquote>
</blockquote>
</blockquote>



<a name="294237191"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237191" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237191">(Aug 19 2022 at 10:35)</a>:</h4>
<p>From: Peter Lammich &lt;<a href="mailto:lammich@in.tum.de">lammich@in.tum.de</a>&gt;<br>
If you want to invest some manual work in the algorithm refinement, you<br>
can see examples how to do that in the Separation_Logic_Imperative_HOL<br>
entry. For example, the Union_Find data structures are first formalized<br>
and proved correct on functional lists, and then refined to<br>
Imperative/HOL.</p>
<p>Currently, I'm working on a more automatic way to refine (monadic, using<br>
the refinement monad) programs to Imperative/HOL, but there is nothing<br>
to show yet.</p>



<a name="294237225"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237225" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237225">(Aug 19 2022 at 10:35)</a>:</h4>
<p>From: Gerwin Klein &lt;<a href="mailto:Gerwin.Klein@nicta.com.au">Gerwin.Klein@nicta.com.au</a>&gt;<br>
This seems to be my fault. It's now back in and online again.</p>
<p>Cheers,<br>
Gerwin</p>
<hr>
<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>



<a name="294237251"></a>
<h4><a href="https://isabelle.zulipchat.com/#narrow/stream/336180-Archive%20Mirror%3A%20Isabelle%20Users%20Mailing%20List/topic/%5Bisabelle%5D%20union-find%20based%20unification/near/294237251" class="zl"><img src="http://isabelle.systems/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Email Gateway <a href="http://isabelle.systems/zulip-archive/stream/336180-Archive-Mirror.3A-Isabelle-Users-Mailing-List/topic/.5Bisabelle.5D.20union-find.20based.20unification.html#294237251">(Aug 19 2022 at 10:35)</a>:</h4>
<p>From: Makarius &lt;<a href="mailto:makarius@sketis.net">makarius@sketis.net</a>&gt;<br>
That is a very interesting observation.</p>
<p>Just yesterday, I've attended a talk by a Coq person who made substantial <br>
investments to include monadic imperative programming to the Coq code <br>
extraction mechanism.  He had exactly the same example, so there is <br>
probably just that one :-)  I was also wondering how much you get in <br>
return for adding such impurity Coq.  (The approach was also somehow <br>
biased towards sequential execution, which is a bit anachronistic for code <br>
optimization.)</p>
<p>So maybe I should point him to this mail thread, to join the discussion.</p>
<p>Makarius</p>



<hr><p>Last updated: Feb 22 2026 at 20:30 UTC</p>
</html>