[
    {
        "content": "<p>Hi! Considering the following silly definition </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">test</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹(nat × nat) set›</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">has_next_hop</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"nat set ⇒ graph ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"has_next_hop S G = (∀x∈S.∃y.(x, y) ∈ G)\"</span>\n\n<span class=\"k\">export_code</span><span class=\"w\"> </span><span class=\"n\">has_next_hop</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Isabelle refuses to generate code for this function and gives the following error message:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Wellsortedness</span><span class=\"w\"> </span><span class=\"n\">error</span>\n<span class=\"o\">(</span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"n\">equation</span><span class=\"w\"> </span><span class=\"n\">has_next_hop</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"n\">≡</span><span class=\"w\"> </span><span class=\"n\">∀x∈</span><span class=\"o\">?</span><span class=\"n\">s.</span><span class=\"w\"> </span><span class=\"n\">∃y.</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">∈</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">g</span><span class=\"o\">):</span>\n<span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">enum</span>\n<span class=\"n\">No</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">arity</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">enum</span>\n</code></pre></div>\n<p>From my understanding, it seems to be an issue related to type classes, specifically that <code>nat</code> does not belong to the <code>enum</code>sort. How can I resolve this error so that I can successfully generate code for my function?</p>\n<p>Thanks,<br>\nLiangrun</p>",
        "id": 442997696,
        "sender_full_name": "Liangrun Da",
        "timestamp": 1717661479
    },
    {
        "content": "<p>You cannot make <code>nat</code> an instance of <code>enum</code>, as it is for explicitly enumerating finite types.</p>\n<p>This is also the main problem why code generation fails: You have an unbounded existential quantifier in your definition, so by default the code generator tries to implement this by checking all possible values (this is where the <code>enum</code> comes in), however there are infinitely many of them(and <code>nat</code> therefore can not be an instance of <code>enum</code>), so this does not work.</p>\n<p>So your best best is probably changing your definition in a way that only finitely man <code>y</code>s have to be checked</p>",
        "id": 443001147,
        "sender_full_name": "Simon Roßkopf",
        "timestamp": 1717662442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302181\">Simon Roßkopf</span> <a href=\"#narrow/stream/202961-General/topic/.22not.20of.20sort.20enum.22.20error.20with.20code.20generation/near/443001147\">said</a>:</p>\n<blockquote>\n<p>You cannot make <code>nat</code> an instance of <code>enum</code>, as it is for explicitly enumerating finite types.</p>\n<p>This is also the main problem why code generation fails: You have an unbounded existential quantifier in your definition, so by default the code generator tries to implement this by checking all possible values (this is where the <code>enum</code> comes in), however there are infinitely many of them(and <code>nat</code> therefore can not be an instance of <code>enum</code>), so this does not work.</p>\n<p>So your best best is probably changing your definition in a way that only finitely man <code>y</code>s have to be checked</p>\n</blockquote>\n<p>Thank you! It works after I change it to:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">test</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹(nat × nat) set›</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">has_next_hop</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"nat set ⇒ graph ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"has_next_hop S G = (∀x∈S.∃(a, _)∈G. (x = a))\"</span>\n\n<span class=\"k\">export_code</span><span class=\"w\"> </span><span class=\"n\">has_next_hop</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 443007976,
        "sender_full_name": "Liangrun Da",
        "timestamp": 1717664413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302181\">Simon Roßkopf</span> <a href=\"#narrow/stream/202961-General/topic/.22not.20of.20sort.20enum.22.20error.20with.20code.20generation/near/443001147\">said</a>:</p>\n<blockquote>\n<p>You cannot make <code>nat</code> an instance of <code>enum</code>, as it is for explicitly enumerating finite types.</p>\n<p>This is also the main problem why code generation fails: You have an unbounded existential quantifier in your definition, so by default the code generator tries to implement this by checking all possible values (this is where the <code>enum</code> comes in), however there are infinitely many of them(and <code>nat</code> therefore can not be an instance of <code>enum</code>), so this does not work.</p>\n<p>So your best best is probably changing your definition in a way that only finitely man <code>y</code>s have to be checked</p>\n</blockquote>\n<p>A follow-up error puzzled me:</p>\n<p>I tried to compute the transitive closure of graph using <code>reachable_graph</code>. I used the same pattern to define <code>has_descendant</code>. However this time Isabelle refused to generate code (also gave me the <code>not of sort enum</code> error message). </p>\n<p>I thought <code> (∀x∈S.∃(a, _)∈ (reachable_graph G). (x = a))</code> doesn't need to enumerate <code>nat</code> and should be able to produce code (just like <code>(∀x∈S.∃(a, _)∈ G. (x = a))</code> does). Could you give me some hint why <code>has_descendant</code> fails?</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">test</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n\">graph</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹(nat × nat) set›</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">reachable_graph</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"graph ⇒ graph\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"reachable_graph G = rtrancl G\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">has_next_hop</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"nat set ⇒ graph ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"has_next_hop S G = (∀x∈S.∃(a, _)∈ G. (x = a))\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">has_descendant</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"nat set ⇒ graph ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"has_descendant S G = (∀x∈S.∃(a, _)∈ (reachable_graph G). (x = a))\"</span>\n\n<span class=\"k\">export_code</span><span class=\"w\"> </span><span class=\"n\">has_descendant</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 443012088,
        "sender_full_name": "Liangrun Da",
        "timestamp": 1717665681
    },
    {
        "content": "<p>Your graph might be infinite</p>",
        "id": 443012914,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1717665902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348400\">Fabian Huch</span> <a href=\"#narrow/stream/202961-General/topic/.22not.20of.20sort.20enum.22.20error.20with.20code.20generation/near/443012914\">said</a>:</p>\n<blockquote>\n<p>Your graph might be infinite</p>\n</blockquote>\n<p>If that was the reason, what makes <code>has_next_hop</code> different from <code>hash_descendant</code>? Isabelle can generate code for <code>has_next_hop</code> but <code>G</code> in <code>has_next_hop</code> could also be infinite.</p>",
        "id": 443013965,
        "sender_full_name": "Liangrun Da",
        "timestamp": 1717666232
    },
    {
        "content": "<p>The puzzling thing should be why it can even generate code for <code>has_next_hop</code>, not why it can't generate code for <code>has_descendant</code>.</p>",
        "id": 443015113,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1717666652
    },
    {
        "content": "<p>And the answer is that there is special code setup for dealing with sets, membership, and equality, but not for your custom function</p>",
        "id": 443015250,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1717666692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348400\">Fabian Huch</span> <a href=\"#narrow/stream/202961-General/topic/.22not.20of.20sort.20enum.22.20error.20with.20code.20generation/near/443015250\">said</a>:</p>\n<blockquote>\n<p>And the answer is that there is special code setup for dealing with sets, membership, and equality, but not for your custom function</p>\n</blockquote>\n<p>Thanks for your answer!</p>",
        "id": 443015671,
        "sender_full_name": "Liangrun Da",
        "timestamp": 1717666823
    }
]