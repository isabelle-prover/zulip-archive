[
    {
        "content": "<p>I have the following lemma that I was expecting to be used to simplify a proof goal:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">index_update</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]:</span>\n  <span class=\"s\">\"n &lt; CARD('b::finite) ⟹ index (update (f::'a['b]) n x) n = x\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">update_def</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>This lemma is a part of the <a href=\"https://trustworthy.systems/software/TS/c-parser/\">C-to-Isabelle parser</a>, and as you can see is marked as a simplification rule by default. I have the following proof goal that is not considering this rule, and I'm wondering why:</p>\n<div class=\"codehilite\"><pre><span></span><code> 1. ⋀s. 0 ≤ i ⟹\n         i &lt; 10 ⟹\n         client_orders_&#39;&#39; s.[unat (word_of_int i)] = NOT_CACHED ⟹\n         server_orders.[unat (word_of_int i)] =\n         Arrays.update (client_orders_&#39;&#39; s) (unat (word_of_int i))\n          (server_orders.[unat (word_of_int i)]).[unat (word_of_int i)]\n</code></pre></div>\n<p>This is a translation of some C code where <code>client_orders</code> and <code>server_orders</code> are both arrays of size 10. The index being used to read values out of these arrays is <code>i</code>, and the assumptions here show that <code>i</code> is between 0 and 10, i.e. <code>i &lt; 10</code>. Intuitively I would expect this rule to apply here, since this proof goal is just showing that the <code>client_orders</code> array is being updated to contain the value at <code>i</code> in <code>server_orders</code>. </p>\n<p>Of course, I see that the proof goal is not in the exact same shape as the lemma - there is an additional assumption here, namely: </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">client_orders_''</span> <span class=\"n\">s.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">=</span> <span class=\"n\">NOT_CACHED</span> <span class=\"err\">⟹</span>\n</code></pre></div>\n<p>Is this what's preventing the simplification rule from being considered? Some background, this assumption is coming from an if statement in the C code that I've parsed. There are actual 2 proof goals here, the other one being the else case of the code. Can that be used to aid in the proof?</p>\n<p>I also am thinking that because <code>i</code> is an <code>int</code>, it is not finite, so that may also be causing the lemma to not be used.</p>",
        "id": 266462714,
        "sender_full_name": "Alex Weisberger",
        "timestamp": 1640902481
    },
    {
        "content": "<p>What happens if you do <code>apply (subst index_update)</code>? If it doesn't work, try putting a <code>using [[show_sorts, unify_trace_failure]]</code> before it and check the output.</p>",
        "id": 266623014,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1641142821
    },
    {
        "content": "<p>Adding <code>apply (subst index_update)</code> leads to this proof state:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code> <span class=\"n\">1</span><span class=\"ow\">.</span> <span class=\"err\">⋀</span><span class=\"n\">s</span><span class=\"o\">::</span><span class=\"n\">lifted_globals.</span>\n       <span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">::</span><span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"err\">≤</span> <span class=\"n\">i</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">i</span> <span class=\"err\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">::</span><span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">client_orders_''</span> <span class=\"n\">s.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">=</span> <span class=\"n\">NOT_CACHED</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">&lt;</span> <span class=\"n\">CARD</span><span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">)</span>\n <span class=\"n\">2</span><span class=\"ow\">.</span> <span class=\"err\">⋀</span><span class=\"n\">s</span><span class=\"o\">::</span><span class=\"n\">lifted_globals.</span>\n       <span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">::</span><span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"err\">≤</span> <span class=\"n\">i</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">i</span> <span class=\"err\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">::</span><span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">client_orders_''</span> <span class=\"n\">s.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">=</span> <span class=\"n\">NOT_CACHED</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">server_orders.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">=</span>\n       <span class=\"n\">server_orders.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n <span class=\"n\">3</span><span class=\"ow\">.</span> <span class=\"err\">⋀</span><span class=\"n\">s</span><span class=\"o\">::</span><span class=\"n\">lifted_globals.</span>\n       <span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">::</span><span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"err\">≤</span> <span class=\"n\">i</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">i</span> <span class=\"err\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">::</span><span class=\"n\">int</span><span class=\"o\">)</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">client_orders_''</span> <span class=\"n\">s.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"err\">≠</span> <span class=\"n\">NOT_CACHED</span> <span class=\"err\">⟹</span>\n       <span class=\"n\">server_orders.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">=</span>\n       <span class=\"n\">client_orders_''</span> <span class=\"n\">s.</span><span class=\"o\">[</span><span class=\"n\">unat</span> <span class=\"o\">(</span><span class=\"n\">word_of_int</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>It looks like it introduces a new goal, #1, but makes #2 trivial (<code>apply(auto)</code> afterwards discharges that goal).</p>\n<p>I think adding <code>using [[show_sorts, unify_trace_failure]]</code> is showing that there's a type mismatch somewhere, here's part of the output:</p>\n<div class=\"codehilite\"><pre><span></span><code>The following types do not unify:\n32 word[10] ⇒ nat ⇒ 32 word\n(nat ⇒ 32 word)[?&#39;b::finite] ⇒ nat ⇒ nat ⇒ 32 word\n</code></pre></div>\n<p>There are other similar errors, but there's quite a bit of output - I won't post it all unless you think it's helpful.</p>\n<p>I'm assuming there's a type issue with subgoal 1: <code>unat (word_of_int i) &lt; CARD(10)</code>. CARD is defined in the <code>Cardinality</code> theory as:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">translations</span> <span class=\"s\">\"CARD('t)\"</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span> <span class=\"s\">\"CONST card (CONST UNIV :: 't set)\"</span>\n</code></pre></div>\n<p>I've honestly never seen a definition like this so I don't know how to interpret it.</p>",
        "id": 266630621,
        "sender_full_name": "Alex Weisberger",
        "timestamp": 1641153913
    },
    {
        "content": "<p>Hm, depending on where you got that goal from, one possibility might be that the polymorphism of <code>word_of_int</code> is the problem here. <code>word_of_int</code> probably has a type something like <code>int ⇒ 'a :: finite word</code>, so if you just write <code>unat (word_of_int n)</code> in two different places, Isabelle will infer the most general situation, which is that the two occurances of <code>word_of_int</code>can have different bit-width.</p>\n<p>Type annotations to fix the bit width here would help with that.</p>",
        "id": 266631088,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1641154639
    }
]