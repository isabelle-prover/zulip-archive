[
    {
        "content": "<p>Recently I've ran into a few cases where I prove a proposition, but it's only true vacuously because the assumptions aren't satisfiable. Of course, we have to be careful about defining assumptions for this reason. But, this is a big problem practically, since detecting such assumptions is not always trivial.</p>\n<p>So, does anyone have any advice for how to a) detect this scenario or b) prove that this isn't the case? I read <a href=\"https://proofcraft.org/blog/isabelle-style-part2.html\">Gerwin Klein's Isabell style guide</a> a while back where he mentions this pitfall, and recommends proving that a theorem's assumptions are satisfiable. Is that the best thing to do?</p>",
        "id": 389971341,
        "sender_full_name": "Alex Weisberger",
        "timestamp": 1694221372
    },
    {
        "content": "<p>To detect inconsistent assumptions, perhaps we can attempt to prove False using Sledgehammer. Showing assumptions are satisfiable is much harder -- not sure if there is a systematic way. Nitpick?</p>",
        "id": 390009029,
        "sender_full_name": "Wenda Li",
        "timestamp": 1694247341
    },
    {
        "content": "<p>Nitpick has been working really well to show that a theorem is false, but I wouldn't know how to use it to check the satisfiability of assumptions.</p>",
        "id": 390030615,
        "sender_full_name": "Alex Weisberger",
        "timestamp": 1694262315
    },
    {
        "content": "<p>Might be a bit simplistic, but I was thinking that we can substitute False for the actual conclusion and then call <code>nitpick</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"x&lt;(1::real) ‚üπ False\"</span>\n<span class=\"w\">  </span><span class=\"kt\">nitpick</span>\n</code></pre></div>\n<p>If a counterexample can be found, then the assumption is satisfiable (in the example above we can have <code>x=0</code> to satisfy the assumption).</p>",
        "id": 390031944,
        "sender_full_name": "Wenda Li",
        "timestamp": 1694263321
    },
    {
        "content": "<p>That's a really good idea.</p>",
        "id": 390033057,
        "sender_full_name": "Alex Weisberger",
        "timestamp": 1694264196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"459086\">Alex Weisberger</span> <a href=\"#narrow/stream/202961-General/topic/Detecting.20Vacuously.20True.20Propositions/near/389971341\">said</a>:</p>\n<blockquote>\n<p>Recently I've ran into a few cases where I prove a proposition, but it's only true vacuously because the assumptions aren't satisfiable. Of course, we have to be careful about defining assumptions for this reason. But, this is a big problem practically, since detecting such assumptions is not always trivial.</p>\n<p>So, does anyone have any advice for how to a) detect this scenario or b) prove that this isn't the case? I read <a href=\"https://proofcraft.org/blog/isabelle-style-part2.html\">Gerwin Klein's Isabell style guide</a> a while back where he mentions this pitfall, and recommends proving that a theorem's assumptions are satisfiable. Is that the best thing to do?</p>\n</blockquote>\n<p>Hi Alex,</p>\n<p>I hope you're doing well!</p>\n<p>I once faced a challenge similar to yours when I was trying to produce numerous conjectures algorithmically. I noticed that most of these conjectures turned out to be 'vacuously' false. Naturally, I aimed to filter out such 'vacuously' correct conjectures.</p>\n<p>To tackle this, I extracted premises from these conjectures using Logic.strip_imp_prems and then integrated them into a proof state. Following that, I used Quickcheck and Nitpick on the proof state.</p>\n<p>For your situation, you might consider creating a new proposition by merging the premises into a single term using meta-conjunction. </p>\n<p>One thing to note: while this method worked for me, it did require a bit of ML-level programming, especially the first time around. If you have only a small number of problems, Wenda's approach seems more suitable to me.</p>\n<p>Here's a link that might be helpful:<br>\n<a href=\"https://github.com/data61/PSL/blob/7f63c6d5f81a9d7441e1e84063c2ac9c0eaf725d/Abduction/Seed_Of_Or2And_Edge.ML#L136C19-L136C19\">GitHub Link</a></p>\n<p>I hope this helps, and I'm here if you have any more questions!</p>\n<p>Best,<br>\nYutaka</p>",
        "id": 392869614,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1695591351
    }
]