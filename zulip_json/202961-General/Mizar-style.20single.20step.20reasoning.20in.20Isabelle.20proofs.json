[
    {
        "content": "<p>Hi community,</p>\n<p>Suppose I want to prove the commutativity of set union: <code>A ∪ (B ∪ C) = (A ∪ B) ∪ C</code> holds.</p>\n<p>The way I can manage to do this is by a snippet like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span><span class=\"w\"> </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">commutative_union</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"A ∪ (B ∪ C) = (A ∪ B) ∪ C\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">semigroup.assoc</span><span class=\"w\"> </span><span class=\"n\">sup.semigroup_axioms</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">commutative_union</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"A ∪ (B ∪ C) = (A ∪ B) ∪ C\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">subgoal_tac</span><span class=\"w\"> </span><span class=\"s\">\"A ∪ (B ∪ C) ⊆ (A ∪ B) ∪ C\"</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">subgoal_tac</span><span class=\"w\"> </span><span class=\"s\">\"(A ∪ B) ∪ C ⊆ A ∪ (B ∪ C)\"</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n<span class=\"w\">   </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">subgoal_tac</span><span class=\"w\"> </span><span class=\"s\">\"∀a. a ∈ A ∪ (B ∪ C) = (a ∈ A ∨ a ∈ (B ∪ C))\"</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">subgoal_tac</span><span class=\"w\"> </span><span class=\"s\">\"∀a.  (a ∈ A ∨ a ∈ (B ∪ C)) = (a ∈ A ∨ a ∈ B ∨ a ∈ C)\"</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">subgoal_tac</span><span class=\"w\"> </span><span class=\"s\">\"∀a.  (a ∈ A ∨ a ∈ B ∨ a ∈ C) = ((a ∈ A ∨ a ∈ B) ∨ a ∈ C) \"</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">subgoal_tac</span><span class=\"w\"> </span><span class=\"s\">\"∀a. ((a ∈ A ∨ a ∈ B) ∨ a ∈ C) = (a ∈ (A ∪ B) ∨ a ∈ C)\"</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">subgoal_tac</span><span class=\"w\"> </span><span class=\"s\">\"∀a. (a ∈ (A ∪ B) ∨ a ∈ C) = (a ∈ (A ∪ B) ∪ C)\"</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">blast</span><span class=\"o\">+</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>The first proof is kind of cheating, as it uses facts about set unions from the library.<br>\nThe second proof tries to detail out the proof, however is a bit clumsy and definitely not idiomatic.<br>\nI was wondering if there is an elegant and idiomatic way to write this proof, such that each step does one rewriting, <br>\nwithout any verbose script lines like <code>apply blast</code>, just like the single-step proofs in Mizar? (Sebastian very kindly showed how this can be done in Mizar but I forgot where to get that Mizar snippet for the same proposition now, would be nice if someone can point me to that Mizar snippet proving<br>\n<code>A ∪ (B ∪ C) = (A ∪ B) ∪ C</code>.)</p>\n<p><a href=\"/user_uploads/14278/HRHahC9Z34uAz6DagBskTfoD/Scratch.thy\">Scratch.thy</a></p>",
        "id": 398533898,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1698255673
    },
    {
        "content": "<p>Isar is Isabelle’s Mizar-style proof language. Have you looked at the <code>prog-prove</code> tutorial, which is mentioned as the first document on the documentation page of the Isabelle website? An introduction to Isar is provided there towards the end.</p>",
        "id": 398540798,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1698258645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"423655\">Wolfgang Jeltsch</span> <a href=\"#narrow/stream/202961-General/topic/Mizar-style.20single.20step.20reasoning.20in.20Isabelle.20proofs/near/398540798\">said</a>:</p>\n<blockquote>\n<p>Isar is Isabelle’s Mizar-style proof language. Have you looked at the <code>prog-prove</code> tutorial, which is mentioned as the first document on the documentation page of the Isabelle website? An introduction to Isar is provided there towards the end.</p>\n</blockquote>\n<p>Hi Wolfgang,</p>\n<p>Thanks for the pointer!</p>\n<p>I did look at that a while ago, and my experience was not very pleasant last time Isarfying real-world proofs. I remember being stuck in the middle of an Isar proof for a complicated lemma that involved many steps.</p>\n<p>I was just wondering if there's a simple construct that allows you to do one rewriting at a time. Something that manipulates the proof state one step further and nothing else (just like elimination rules do).<br>\nI will give it a second careful read, but a quick skim seem to suggest that <code>from this</code> seem to be the best available construct?</p>",
        "id": 398545204,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1698260537
    },
    {
        "content": "<p>When it comes to proof methods, you may want to have a look at <code>unfold</code> and <code>subst</code>. Also the Isar construct <code>unfolding</code> could be useful.</p>\n<p>Sad that your experience with Isar was negative. In my opinion it’s one of the greatest features of Isabelle.</p>\n<p>Note that Isar not only gives you readable proofs, but it also generally makes proving <em>easier</em>, because you state intermediate propositions that you want to show, which also helps to guide automated provers.</p>",
        "id": 398565104,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1698270510
    },
    {
        "content": "<p>If you could say more concretely where you get stuck with Isar, people might be able to help you overcome the difficulties that you experience. As I said, Isar is a great feature in my opinion, and I suspect that you’ve merely approached it in an unfortunate way.</p>",
        "id": 398565306,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1698270610
    }
]