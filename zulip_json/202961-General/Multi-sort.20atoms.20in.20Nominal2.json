[
    {
        "content": "<p>I'm experimenting with Nominal2's support for multi-sort atoms (see <a href=\"https://www.isa-afp.org/theories/nominal2/#Atoms.html\">this example in the Nominal package</a> and the discussion in Section 5 of <a href=\"https://nms.kcl.ac.uk/christian.urban/Publications/nominal-atoms.pdf\">this paper</a>). The idea is to define a toy typed λ-calculus in Church's style, that is, where each variable includes its type (e.g. <code>λxₒ. xₒ</code>). So, I came up with the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"s\">\"Nominal2.Nominal2\"</span><span class=\"w\"> </span><span class=\"s\">\"Nominal2.Atoms\"</span><span class=\"w\"></span>\n<span class=\"k\">begin</span><span class=\"w\"></span>\n\n<span class=\"c\">(* In this example I'm using \"var\", \"ty\" and \"Var\" from Nominal2.Atoms *)</span><span class=\"w\"></span>\n\n<span class=\"k\">nominal_datatype</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">EVar</span><span class=\"w\"> </span><span class=\"n\">var</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">EApp</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"n\">exp</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">EAbs</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"o\">::</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"k\">binds</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">M</span><span class=\"w\"></span>\n\n<span class=\"c\">(* I want to prove that λxₒ. xₒ = λyₒ. yₒ *)</span><span class=\"w\"></span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"EAbs (Var x (TVar ''o'')) (EVar (Var x (TVar ''o''))) = EAbs (Var y (TVar ''o'')) (EVar (Var y (TVar ''o'')))\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">(* cannot prove this! *)</span><span class=\"w\"></span>\n\n<span class=\"k\">end</span><span class=\"w\"></span>\n</code></pre></div>\n<p>As shown in the code above, the problem I found is that I cannot even prove the equality of two α-equivalent terms, which, I think, should work out of the box as is the case for single-sort atoms. Having a look at the Nominal2's implementation, it seems to me that the root cause is the lacking of a simproc similar to <code>alpha_lst</code> that works on <code>at_base</code> instead of <code>at</code>. However, since I'm not an expert in the Nominal package, I may very well be missing something.</p>",
        "id": 323060647,
        "sender_full_name": "Javier Diaz",
        "timestamp": 1674490697
    },
    {
        "content": "<p>It is possible to prove it in a rather low-level fashion (see below). But generally, I agree with the assessment that as soon one leaves <code>at</code>, things are much more painful than they should be. For starters the various <code>Abs1_eq_iff...</code> lemmas that are available for <code>at</code> are lacking for <code>at_base</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">supp_Var</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"supp (Var x T) = {Atom (sort_of_ty T) x}\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Abs_var_inverse</span><span class=\"w\"> </span><span class=\"n\">Var_def</span><span class=\"w\"> </span><span class=\"n\">atom_var_def</span><span class=\"w\"> </span><span class=\"n\">supp_at_base</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Rep_var_Var</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"Rep_var (Var x T) = Atom (sort_of_ty T) x\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">Rep_var</span><span class=\"o\">[</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"s\">\"Var x T\"</span><span class=\"o\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Var_def</span><span class=\"w\"> </span><span class=\"n\">Abs_var_inverse</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"c\">(* I want to prove that λxₒ. xₒ = λyₒ. yₒ *)</span><span class=\"w\"></span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"EAbs (Var x (TVar ''o'')) (EVar (Var x (TVar ''o''))) = EAbs (Var y (TVar ''o'')) (EVar (Var y (TVar ''o'')))\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Abs_eq_iff2</span><span class=\"w\"> </span><span class=\"n\">alpha_lst</span><span class=\"w\"> </span><span class=\"n\">exp.supp</span><span class=\"w\"> </span><span class=\"n\">supp_Var</span><span class=\"w\"> </span><span class=\"n\">Rep_var_Var</span><span class=\"w\"> </span><span class=\"n\">atom_var_def</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Var_def</span><span class=\"o\">[</span><span class=\"n\">symmetric</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">supp_swap</span><span class=\"w\"> </span><span class=\"n\">fresh_star_def</span><span class=\"w\"> </span><span class=\"n\">permute_var_def</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"o\">!:</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">_</span><span class=\"w\"> </span><span class=\"s\">\"(atom (Var x (TVar ''o'')) ⇌ atom (Var y (TVar ''o'')))\"</span><span class=\"o\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">if_splits</span><span class=\"o\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 323070715,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1674493178
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361271\">Dmitriy Traytel</span> <a href=\"#narrow/stream/202961-General/topic/Multi-sort.20atoms.20in.20Nominal2/near/323070715\">said</a>:</p>\n<blockquote>\n<p>It is possible to prove it in a rather low-level fashion (see below). But generally, I agree with the assessment that as soon one leaves <code>at</code>, things are much more painful than they should be. For starters the various <code>Abs1_eq_iff...</code> lemmas that are available for <code>at</code> are lacking for <code>at_base</code>.</p>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">supp_Var</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"supp (Var x T) = {Atom (sort_of_ty T) x}\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Abs_var_inverse</span><span class=\"w\"> </span><span class=\"n\">Var_def</span><span class=\"w\"> </span><span class=\"n\">atom_var_def</span><span class=\"w\"> </span><span class=\"n\">supp_at_base</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">Rep_var_Var</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"Rep_var (Var x T) = Atom (sort_of_ty T) x\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">Rep_var</span><span class=\"o\">[</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"s\">\"Var x T\"</span><span class=\"o\">]</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Var_def</span><span class=\"w\"> </span><span class=\"n\">Abs_var_inverse</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"c\">(* I want to prove that λxₒ. xₒ = λyₒ. yₒ *)</span><span class=\"w\"></span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"EAbs (Var x (TVar ''o'')) (EVar (Var x (TVar ''o''))) = EAbs (Var y (TVar ''o'')) (EVar (Var y (TVar ''o'')))\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Abs_eq_iff2</span><span class=\"w\"> </span><span class=\"n\">alpha_lst</span><span class=\"w\"> </span><span class=\"n\">exp.supp</span><span class=\"w\"> </span><span class=\"n\">supp_Var</span><span class=\"w\"> </span><span class=\"n\">Rep_var_Var</span><span class=\"w\"> </span><span class=\"n\">atom_var_def</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Var_def</span><span class=\"o\">[</span><span class=\"n\">symmetric</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">supp_swap</span><span class=\"w\"> </span><span class=\"n\">fresh_star_def</span><span class=\"w\"> </span><span class=\"n\">permute_var_def</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">intro</span><span class=\"o\">!:</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">_</span><span class=\"w\"> </span><span class=\"s\">\"(atom (Var x (TVar ''o'')) ⇌ atom (Var y (TVar ''o'')))\"</span><span class=\"o\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">split</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">if_splits</span><span class=\"o\">)</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks a lot, Dmitriy. Your answer is very helpful. It seems to me that the current Nominal package is not yet ready for a serious formalization using multi-sort atoms. <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 323072441,
        "sender_full_name": "Javier Diaz",
        "timestamp": 1674493574
    }
]