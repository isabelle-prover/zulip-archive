[
    {
        "content": "<p>Consider the following theory formalizing boolean circuits and weighted circuit satisfiability:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">DebugNitpick</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span><span class=\"w\"> </span><span class=\"s\">\"HOL-Library.FSet\"</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">boolean_circuit</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">  </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Not</span><span class=\"w\"> </span><span class=\"s\">\"'a boolean_circuit\"</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">And</span><span class=\"w\"> </span><span class=\"s\">\"'a boolean_circuit fset\"</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Or</span><span class=\"w\"> </span><span class=\"s\">\"'a boolean_circuit fset\"</span>\n\n<span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">var_interpretation</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"{var :: ('a ⇒ bool). finite {v. var v}}\"</span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">not_finite_existsD</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n\n<span class=\"c\">(* the number of variables that are assigned to True *)</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">weight</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a var_interpretation ⇒ nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"weight var = card {v. Rep_var_interpretation var v}\"</span>\n\n<span class=\"kn\">function</span><span class=\"w\"> </span><span class=\"n\">eval</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a var_interpretation ⇒ 'a boolean_circuit ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"eval var (Var v) = Rep_var_interpretation var v\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"eval var (Not circuit) = (¬eval var circuit)\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"eval var (And circuits) = fBall circuits (eval var)\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"eval var (Or circuits) = fBex circuits (eval var)\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">pat_completeness</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"kn\">termination</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">(* this is provable, omitted here for simplicity *)</span>\n\n<span class=\"c\">(* weighted circuit sat = is there a satisfying interpretation with weight k? *)</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">wcs</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a boolean_circuit ⇒ nat ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"wcs circuit k = (∃ var. weight var = k ∧ eval var circuit)\"</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">debug_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">debug_el</span>\n\n<span class=\"k\">declare</span><span class=\"o\">[[</span><span class=\"n\">show_types</span><span class=\"o\">]]</span>\n\n<span class=\"c\">(* \"And {Or {}}\" does not have a satisfying interpretation with weight 0,</span>\n<span class=\"c\">    i.e. the empty interpretation *)</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"¬wcs (And {| Or (fempty :: debug_type boolean_circuit fset)|}) 0\"</span>\n<span class=\"w\">  </span><span class=\"kt\">nitpick</span>\n<span class=\"w\">  </span><span class=\"c\">(* here, nitpick finds a counterexample with an empty variable interpretation</span>\n<span class=\"c\">     in wcs, which should however have \"eval var circuit\" evaluate to False;</span>\n<span class=\"c\">     so this counterexample is invalid *)</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">wcs_def</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Nitpick claims to find a counterexample for the lemma at the bottom, however the counterexample is invalid. Is this a bug in Nitpick (I am aware that it does not run inside the Isabelle kernel) or am I misunderstanding something here?</p>",
        "id": 571390254,
        "sender_full_name": "Tim",
        "timestamp": 1770026771
    }
]