[
    {
        "content": "<p>Section 2.7 of the Eisbach User Manual presents the reverse matching technique. I wanted to try it out and came up with the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"(⋀n m. Suc n = m) ⟹ False\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">    </span><span class=\"n\">match</span><span class=\"w\"> </span><span class=\"n\">premises</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"s\">‹</span>\n<span class=\"s\">      match (\"Suc 1 = 1\") in P ⇒ ‹</span>\n<span class=\"s\">        match premises in prems: _ ⇒ ‹</span>\n<span class=\"s\">          print_fact prems,</span>\n<span class=\"s\">          print_term P</span>\n<span class=\"s\">        ›</span>\n<span class=\"s\">      ›</span>\n<span class=\"s\">    ›</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I would have expected both printing methods to show <code>Suc 1 = 1</code>, but instead I get the following output:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">print_fact</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">prems</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Suc</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">n15</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">m15</span>\n<span class=\"n\">print_term</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Suc</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">n11</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">m11</span>\n</code></pre></div>\n<p>Is reverse matching not working (anymore), or am I missing something?</p>",
        "id": 386686411,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1692735521
    },
    {
        "content": "<p>It seems that also the example in the user manual is at least not working as I understood it should: instantiation of schematic variables is not persistent. This is the example:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">asms</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"⋀x :: 'a. A x\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"A y\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">match</span><span class=\"w\"> </span><span class=\"n\">asms</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"A y\"</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"s\">‹rule H›</span><span class=\"o\">)?</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">    </span><span class=\"n\">match</span><span class=\"w\"> </span><span class=\"n\">asms</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"s\">‹</span>\n<span class=\"s\">     match (\"A y\") in P ⇒ ‹rule H›</span>\n<span class=\"s\">    ›</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n</code></pre></div>\n<p>Inserting diagnostic commands similar to the ones in my post above next to the <code>rule H</code> invocation will result in output containing a schematic variable instead of <code>y</code>. Now let’s restrict the type of the variable and replace <code>y</code> by a constant:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">asms</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"⋀x :: nat. A x\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"A y\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">match</span><span class=\"w\"> </span><span class=\"n\">asms</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"A y\"</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"s\">‹rule H›</span><span class=\"o\">)?</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span>\n<span class=\"w\">    </span><span class=\"n\">match</span><span class=\"w\"> </span><span class=\"n\">asms</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"s\">‹</span>\n<span class=\"s\">     match (\"A 0\") in P ⇒ ‹rule H›</span>\n<span class=\"s\">    ›</span>\n<span class=\"w\">  </span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n</code></pre></div>\n<p>This code still works, which again illustrates that the <code>x</code> from the assumption did not get bound beyond the actual matching activity, since otherwise rule <code>H</code> would have been specialized to <code>A 0</code>, making it impossible to prove <code>A y</code> with it.</p>",
        "id": 386688760,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1692736580
    }
]