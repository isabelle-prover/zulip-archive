[
    {
        "content": "<p>Suppose we have this theory fragment:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">CXLMEM3</span><span class=\"w\"> </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n<span class=\"c\">(* memory as finite association list: still code_pred has difficulty showing inductive relations between two states in a transition,</span>\n<span class=\"c\">  we therefore revert to a different representation for ext/internal transitions*)</span>\n\n<span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"(nat * int) list\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">read_mem</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"mem ⇒ nat ⇒ int\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"read_mem [] i = 0\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"read_mem ((j,v)#xs) i = (if i = j then v else read_mem xs i)\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">write_mem</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"mem ⇒ nat ⇒ int ⇒ mem\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"write_mem [] i v = [(i, v)]\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"write_mem ((j,w)#xs) i v = (if i = j then (i, v)#xs else (j, w)#write_mem xs i v)\"</span>\n\n<span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n\">txid</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">Memop</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Write</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">int</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">Memop_res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">RdRes</span><span class=\"w\"> </span><span class=\"n\">txid</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">WrRes</span><span class=\"w\"> </span><span class=\"n\">txid</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Pending</span><span class=\"w\"> </span><span class=\"n\">txid</span><span class=\"w\"> </span><span class=\"n\">Memop</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">perform_Memop</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"Memop ⇒ mem ⇒ (mem * int)\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"perform_Memop (Read i) m = (m, read_mem m i)\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"perform_Memop (Write i v) m = (write_mem m i v, v)\"</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">Req</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemRd</span><span class=\"w\"> </span><span class=\"n\">txid</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">DRS</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemData</span><span class=\"w\"> </span><span class=\"n\">txid</span><span class=\"w\"> </span><span class=\"n\">int</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">Rwd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemWrite</span><span class=\"w\"> </span><span class=\"n\">txid</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"n\">int</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">NDR</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cmp</span><span class=\"w\"> </span><span class=\"n\">txid</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">mem_msg</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ReqMsg</span><span class=\"w\"> </span><span class=\"n\">Req</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">RwdMsg</span><span class=\"w\"> </span><span class=\"n\">Rwd</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">BIRsp</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">NDRMsg</span><span class=\"w\"> </span><span class=\"n\">NDR</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">DRSMsg</span><span class=\"w\"> </span><span class=\"n\">DRS</span><span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">BISnp</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">get_op_addr</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"mem_msg ⇒ nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"get_op_addr m = (case m of (ReqMsg (MemRd txk i)) ⇒ i | _ ⇒ 0)\"</span>\n\n<span class=\"k\">record</span><span class=\"w\"> </span><span class=\"n\">cxl_state</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">  </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"mem\"</span>\n<span class=\"w\">  </span><span class=\"n\">m2sreqs</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"Req list\"</span>\n<span class=\"w\">  </span><span class=\"n\">m2srwds</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"Rwd list\"</span>\n<span class=\"w\">  </span><span class=\"n\">s2mdrss</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"DRS list\"</span>\n<span class=\"w\">  </span><span class=\"n\">s2mndrs</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"NDR list\"</span>\n<span class=\"w\">  </span><span class=\"n\">counter</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">nat</span>\n\n<span class=\"c\">(* Transitions over tupled state for executability *)</span>\n\n<span class=\"k\">inductive</span><span class=\"w\">  </span><span class=\"n\">external_step</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"(mem * Req list * Rwd list * DRS list * NDR list * nat * Memop list * Memop_res list)  ⇒ (mem * Req list * Rwd list * DRS list * NDR list * nat * Memop list * Memop_res list) ⇒ bool\"</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"kp\">infix</span><span class=\"w\"> </span><span class=\"s\">\"↝e\"</span><span class=\"w\"> </span><span class=\"n\">50</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">    </span><span class=\"n\">read_to_memread</span><span class=\"o\">:</span><span class=\"s\">\"(m, reqs, rwds, drss, ndrs, cnt, Read i # mops, mress) ↝e (m, MemRd cnt i # reqs, rwds, drss, ndrs, cnt+1, mops, Pending cnt (Read i) # mress)\"</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">write_to_memwrite</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(m, reqs, rwds, drss, ndrs, cnt, Write i v # mops, mress) ↝e (m, reqs, MemWrite cnt i v # rwds, drss, ndrs, cnt+1, mops, Pending cnt (Write i v) # mress)\"</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">write_cmp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(m, reqs, rwds, drss, ndrs1 @ [Cmp txid] @ ndrs2, cnt, mops, mress1 @ [Pending txid (Write i v)] @ mress2) ↝e (m, reqs, rwds, drss, ndrs1@ndrs2, cnt, mops, WrRes txid i v # mress1 @ mress2)\"</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">read_memdata</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(m, reqs, rwds, drss1 @ [MemData txid v] @ drss2, ndrss, cnt, mops, mress1 @ [Pending txid (Read i)] @ mress2) ↝e (m, reqs, rwds, drss1 @ drss2, ndrss, cnt, mops, RdRes txid i v # mress1 @ mress2)\"</span>\n\n\n<span class=\"k\">inductive</span><span class=\"w\"> </span><span class=\"n\">internal_step</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"(mem * Req list * Rwd list * DRS list * NDR list * nat * Memop list * Memop_res list)  ⇒ (mem * Req list * Rwd list * DRS list * NDR list * nat * Memop list * Memop_res list) ⇒ bool\"</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"kp\">infix</span><span class=\"w\"> </span><span class=\"s\">\"↝i\"</span><span class=\"w\"> </span><span class=\"n\">50</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">    </span><span class=\"s\">\"(m, reqs1 @ [MemRd txid i] @ reqs2, rwds, drss, ndrs, cnt, mops, mress) ↝i (m, reqs1 @ reqs2, rwds, MemData txid (read_mem m i) # drss, ndrs, cnt, mops, mress)\"</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"(m, reqs, rwds1 @ [MemWrite txid i v] @ rwds2, drss, ndrs, cnt, mops, mress) ↝i (write_mem m i v, reqs, rwds1 @ rwds2, drss, Cmp txid # ndrs, cnt, mops, mress)\"</span>\n\n<span class=\"k\">inductive</span><span class=\"w\"> </span><span class=\"n\">system_step</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"(mem * Req list * Rwd list * DRS list * NDR list * nat * Memop list * Memop_res list)  ⇒ (mem * Req list * Rwd list * DRS list * NDR list * nat * Memop list * Memop_res list) ⇒ bool\"</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"kp\">infix</span><span class=\"w\"> </span><span class=\"s\">\"↝\"</span><span class=\"w\"> </span><span class=\"n\">50</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">    </span><span class=\"s\">\"tuple1 ↝e tuple2 ⟹ tuple1 ↝ tuple2\"</span>\n<span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"tuple1 ↝i tuple2 ⟹ tuple1 ↝ tuple2\"</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">mem3_42</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"mem\"</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"mem3_42 = write_mem [] 3 42\"</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">initial1</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"mem * Req list * Rwd list * DRS list * NDR list * nat * Memop list * Memop_res list\"</span>\n<span class=\"w\">  </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"initial1 = (mem3_42, [], [], [], [], 15, [Read 3], [])\"</span>\n\n\n<span class=\"kn\">code_pred</span><span class=\"w\"> </span><span class=\"n\">system_step</span><span class=\"w\"> </span><span class=\"ow\">.</span>\n</code></pre></div>\n<p>The code_pred command gets stuck processing near the <code>.</code> position.  After a while it finishes and nothing gets outputted. Trying</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kt\">values</span><span class=\"w\"> </span><span class=\"ow\">{</span><span class=\"n\">x.</span><span class=\"w\"> </span><span class=\"n\">initial1</span><span class=\"w\"> </span><span class=\"n\">↝</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"ow\">}</span>\n\n<span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">system_step.equation</span>\n</code></pre></div>\n<p>gives me the </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Outer</span><span class=\"w\"> </span><span class=\"k\">syntax</span><span class=\"w\"> </span><span class=\"n\">error⌂</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"o\">,</span>\n<span class=\"n\">but</span><span class=\"w\"> </span><span class=\"kp\">identifier</span><span class=\"w\"> </span><span class=\"n\">initial1⌂</span><span class=\"w\"> </span><span class=\"n\">was</span><span class=\"w\"> </span><span class=\"n\">found</span>\n</code></pre></div>\n<p>error on the first command, and no output on the second command. Any ideas?</p>\n<p>【EDIT】: I inputted my questions to LLMs which partially solved the problem. Might be helpful for future users so I don't delete the question:</p>\n<ol>\n<li>the values command requires quotations for the term being evaluated. </li>\n<li>Non-constructor functions such as <code>@</code> are hard for the predicate compiler to deal with. For which I need to replace. I am trying to find a good way to express the same thing concisely. Is there a canonical way of doing this? Any suggestions appreciated.</li>\n</ol>\n<p>Best,<br>\nChengsong</p>",
        "id": 553744147,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1762304763
    }
]