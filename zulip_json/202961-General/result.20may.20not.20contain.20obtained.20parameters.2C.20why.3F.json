[
    {
        "content": "<p>A student asked me why proofs of this form (never mind the abstract <code>P</code>, they had a concrete predicate in its place) are rejected:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∃x. P x\"</span>\n<span class=\"k\">proof</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"P x\"</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"P x\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>(the <code>show</code> here gives <code>Result contains obtained parameters: x</code>)</p>\n<p>And I had to admit that I have no idea why (I habitually start such proofs with <code>proof -</code>, in which case the goal does not contain the local <code>x</code>, and of course the result <code>∃x. P x</code> is perfectly provable from having obtained a concrete witness <code>x</code>) — i can see that in general, obtained variables should not occur in result statements, but here that restriction seems overzealous. Or could it be dangerous to permit this, and if so, how and when?</p>",
        "id": 569266012,
        "sender_full_name": "terru",
        "timestamp": 1769005055
    },
    {
        "content": "<p>An informal answer would be the one below (a more detailed answer might be more nuanced). The following three starts of the proof produce the same proof obligation:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∃x. P x\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">standard</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∃x. P x\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∃x. P x\"</span>\n<span class=\"k\">proof</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n</code></pre></div>\n<p>That is, when one writes <code>proof</code> without the <code>-</code>, there is an automatic attempt to apply an Isabelle rule/theorem. In the case of an existential quantifier, applying <code>proof</code> will automatically try to apply the fact <code>exI</code> (i.e. <code>?P ?x ⟹ ∃x. ?P x</code>), which says that to show an existential statement, one must provide a witness. However, after <code>apply (rule exI)</code>, your witness has already been chosen for you but it doesn't have a proper name (its provisional name is <code>?x</code>). You can see this yourself by checking the state after providing a witness as below and checking the state after deleting the square brackets and their content:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∃x. P x\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">c</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n</code></pre></div>\n<p>In other words, doing <code>apply (rule exI[where x=c])</code> is telling Isabelle: \"the term c is the witness for my existential statement\". Similarly, <code>apply (rule exI)</code> is telling Isabelle: \"the term ?x is the witness for my existential statement\". The problem then is that if you <code>obtain</code> a term <code>x</code>, this obtained one is not necessarily the same as the one introduced by a naive application of <code>exI</code> (i.e. ?x). If we allow the suggested proof-structure, we would implicitly be saying that <code>x = ?x</code> which is not true in all types. The correct conclusion for the proof-structure then should be <code>show \"P ?x\"</code> but in your local context the variable <code>?x</code> does not formally have an assigned value inside the type (thus the error <code>Unbound schematic variable: ?x</code>).</p>",
        "id": 569302114,
        "sender_full_name": "Jonathan Julian Huerta y Munive",
        "timestamp": 1769013609
    },
    {
        "content": "<p>This has nothing to do with <code>exI</code> or naming (<code>?x</code> is a regular schematic variable, there is no 'provisional name'), but is a consequence of how natural deduction works (which Isar implements) -- have a look at the ∃E rule: <br>\n<a href=\"/user_uploads/14278/dQ2XLptZ4WlwlIA1NvmHxDDd/image.png\">image.png</a><br>\ny cannot appear free in B.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/dQ2XLptZ4WlwlIA1NvmHxDDd/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"1328x249\" src=\"/user_uploads/thumbnail/14278/dQ2XLptZ4WlwlIA1NvmHxDDd/image.png/840x560.webp\"></a></div>",
        "id": 569324668,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1769019524
    },
    {
        "content": "<p>(here's a simple example without exI:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">refl2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"x = x ⟹ True\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">True</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">refl2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"P x\"</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"x=x\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>returns <code>Result contains obtained parameters: x \nLocal statement fails to refine any pending goal</code>)</p>",
        "id": 569325402,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1769019757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"485021\">terru</span> <a href=\"#narrow/channel/202961-General/topic/result.20may.20not.20contain.20obtained.20parameters.2C.20why.3F/near/569266012\">said</a>:</p>\n<blockquote>\n<p>Or could it be dangerous to permit this, and if so, how and when?</p>\n</blockquote>\n<p>It would be unsound. Consider this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">good</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"∀(x :: bool). ∃y. x = y\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">allI</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">(*note: ?y may depend on x*)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"∃(x :: bool). ∀y. x = y\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">allI</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">(*note: ?x may not depend on y*)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">refl</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"∃(x :: bool). ∀y. x = y\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">allI</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">fix</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">bool</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"z = y\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"z = y\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"c\">(*note: ?x may not depend on new skolem variable z*)</span>\n<span class=\"k\">qed</span>\n</code></pre></div>",
        "id": 569370194,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1769034856
    },
    {
        "content": "<p>well, yes, this all makes sense to me. But I'm still struggling with the idea that the non-proof I gave should mean something fundamentally different, from, say:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∃x. P x\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"P x\"</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"∃x. P x\"</span>\n<span class=\"w\">    </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"s\">‹P x›</span><span class=\"w\"> </span><span class=\"ow\">.</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>Since I thought that an initial proof method should (modulo changes to the context, but that seems (?) unimportant here as the obtain only needs <code>P</code>, which is the same in both) do the same as applying it as the first step to <code>?thesis</code> &amp; then supplying intermediate facts (assuming they still make sense). So either more is going on in the context than I was aware of, or my understanding of initial proof methods is wrong?</p>",
        "id": 569446589,
        "sender_full_name": "terru",
        "timestamp": 1769075342
    },
    {
        "content": "<p>Now you only use the obtained variable within the subproof of B in the ND rule</p>",
        "id": 569447566,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1769075662
    },
    {
        "content": "<p>Here's an even simpler falsity without any existental introduction:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"(⋀y. x = y) ⟹ False\"</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"w\">  </span><span class=\"k\">proof</span>\n<span class=\"w\">    </span><span class=\"k\">fix</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">bool</span><span class=\"w\"> </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"x=y\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"x=y\"</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">qed</span>\n</code></pre></div>",
        "id": 569447722,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1769075705
    }
]