[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span> I simplified <code>is_balanced</code>. Indeed, one should be able to prove <code>is_balanced_inter</code> and <code>is_balanced_union</code>. It should not be necessary to embed these two lemmas in the definition <code>is_balanced</code>.<br>\nPlease see my PR.</p>",
        "id": 169640026,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562239413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span>  I replaced the name <code>deutsch_jozsa</code> with <code>jozsa</code> which is shorter <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span>  and I made all the changes accordingly.</p>",
        "id": 169641771,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562241201
    },
    {
        "content": "<p>I just completed the proof of the lemma <code>is_balanced_union</code> (see PR).</p>",
        "id": 169734378,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562358833
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span>  What is the purpose of <code>[case_names ge 1 step]</code> in <code>ind_from_1</code> ? I'm not sure since if I remove it, the rest of the code still works.</p>",
        "id": 169737148,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562362625
    },
    {
        "content": "<p>If you use the induction rule it gives you a name for the cases, i.e.<br>\nproof (induction n rule: ind_from_1)<br>\n  case ge <br>\n  show ?case <br>\nnext<br>\n  case 1<br>\n...<br>\nThis is good if the induction rule is very unusual and hard to understand. E.g. if you have strange base cases or something.</p>\n<p>I didn't used it in the code as I found it sufficiently understandable without the case name and will probably remove it.  I am just working on tidying up the code a bit, a lot of it is provisional as I tried out a lot today to find the best way of defining stuff.</p>",
        "id": 169737423,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562363039
    },
    {
        "content": "<p>It's nice that you renamed the cases thanks to <code>[case_names ge 1 step]</code>. Otherwise <code>case 1</code>, <code>case 2</code> and <code>case (3 n)</code> that one sees are not very telling.</p>",
        "id": 169737704,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562363419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span>  What were your motivations to change <code>const</code> ?</p>",
        "id": 170437848,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562664986
    },
    {
        "content": "<p>I wanted to add an assumption to the locale jozsa that ensures that each function is either constant or balanced. For this is_const and is_balanced have to be defined before the locale specification since assumptions cannot be added to locale afterwards. However, I am still not at a point where I need to use is_const or is_balanced at all so I kept that issue for later.</p>",
        "id": 170438113,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562665235
    },
    {
        "content": "<p>Ok, I see. The assumption in the locale <code>jozsa</code> that <code>f</code> is either constant or balanced is fine, and even needed, since in a Deutsch's problem Bob promises Alice that he will use a fonction that is either constant or balanced.<br>\nBut, given how <code>const</code> is defined (with a parameter <code>n</code> for the domain of <code>f</code>) this definition and also <code>is_balanced</code> should be in a dedicated locale with <code>jozsa</code> as a sublocale.<br>\nI will do it.</p>",
        "id": 170438956,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562666046
    },
    {
        "content": "<p>Do you agree ?</p>",
        "id": 170439186,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562666288
    },
    {
        "content": "<p>Yes I had that thought too.  I think I even wrote it in a commentary  or something so I think it's a good idea</p>",
        "id": 170439679,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562666790
    },
    {
        "content": "<p>PR submitted.</p>",
        "id": 170441424,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562668537
    },
    {
        "content": "<p>Does someone have an idea how a matrix representation of the result of taking n times the tensor product of H would look like?</p>",
        "id": 170531309,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562756357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span>  I assume that you want the matrix representation of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\"> H^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> wrt the computational basis. For <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">i,j\\leq 2^n </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, it's given by</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><msup><mn>2</mn><mi>n</mi></msup></msqrt></mfrac><mo stretchy=\"false\">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy=\"false\">)</mo><mrow><mi>j</mi><mi mathvariant=\"normal\">.</mi><mi>i</mi></mrow></msup><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">H^{\\otimes n}(i,j) = \\frac{1}{\\sqrt{2^n}} (-1)^{j.i},</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.071331em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.821331em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.25144em;vertical-align:-0.93em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.2027799999999997em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.590392em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span><span style=\"top:-2.86722em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,\n-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,\n-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,\n35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,\n-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467\ns-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422\ns-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.93em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.874664em;\"><span style=\"top:-3.1130000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord mtight\">.</span><span class=\"mord mathdefault mtight\">i</span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span></span></span></span></span></p>\n<p>where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mi mathvariant=\"normal\">.</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">j.i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord\">.</span><span class=\"mord mathdefault\">i</span></span></span></span> denotes the <strong>bitwise</strong> inner product of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>j</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|j\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">⟩</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>i</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|i\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">⟩</span></span></span></span>.</p>",
        "id": 170560398,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562778983
    },
    {
        "content": "<p>Thanks a lot :)</p>",
        "id": 170561273,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562779655
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span> Two additional remarks. First, the inner product  <code>inner_prod</code> is defined in <code>Quantum.thy</code> and denoted <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mi>j</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle i|j\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\">i</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">⟩</span></span></span></span>. Second, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>i</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|i\\rangle </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">⟩</span></span></span></span> (the ith element of the computational basis ) is just <code>unit_vec 2^n i</code>.</p>",
        "id": 170564534,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562781787
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span>  It makes sense to introduce the abbreviation <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mi mathvariant=\"normal\">.</mi><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i.j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord\">.</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo stretchy=\"false\">⟨</mo><mrow><mtext>u</mtext><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant=\"normal\">_</mi><mi>v</mi><mi>e</mi><mi>c</mi></mrow><mtext>  </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext>  </mtext><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mrow><mtext>u</mtext><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant=\"normal\">_</mi><mi>v</mi><mi>e</mi><mi>c</mi></mrow><mtext>  </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext>  </mtext><mi>j</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle {\\text unit\\_vec}\\;2^n\\;i|{\\text unit\\_vec}\\;2^n\\;j\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">u</span></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">t</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">c</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">u</span></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">t</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">c</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">⟩</span></span></span></span> if you plan to use it heavily.</p>",
        "id": 170574914,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562789058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span> I plan to work on your theory. What is the next thing I should tackle ?</p>",
        "id": 170613707,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562834524
    },
    {
        "content": "<p>I am still trying to understand the matrix representation of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">H^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>. I would be happy if you could explain it to me again. <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant=\"normal\">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant=\"normal\">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>j</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle unit\\_vec ~2^n~ i| unit\\_vec~ 2^n~ j \\rangle </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">t</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">c</span><span class=\"mspace nobreak\"> </span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace nobreak\"> </span><span class=\"mord mathdefault\">i</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">t</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">c</span><span class=\"mspace nobreak\"> </span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace nobreak\"> </span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">⟩</span></span></span></span> is 1 if i=j and 0 otw. right? But e.g. for n=1, i.e. just the usual Hadamard gate the element at position i=0 and j=0 should be positive not negative. I found a solution for which I convert decimals into binaries which is not a nice thing to express the gate with.</p>",
        "id": 170613901,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562834727
    },
    {
        "content": "<p>Besides that I was sometimes unsure about design choices, I made comments in the code in that case. I finished everything up to the last application of the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊕</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">H^{\\oplus n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊕</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> gate (and of course the measurement following after that). I might need to restructure some things though depending on this last bit (regarding the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n\\ge 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> issue outside of the locale).</p>",
        "id": 170614056,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562834843
    },
    {
        "content": "<blockquote>\n<p>I am still trying to understand the matrix representation of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">H^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span>. I would be happy if you could explain it to me again. <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant=\"normal\">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>i</mi><mi mathvariant=\"normal\">∣</mi><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi mathvariant=\"normal\">_</mi><mi>v</mi><mi>e</mi><mi>c</mi><mtext> </mtext><msup><mn>2</mn><mi>n</mi></msup><mtext> </mtext><mi>j</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle unit\\_vec ~2^n~ i| unit\\_vec~ 2^n~ j \\rangle </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">t</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">c</span><span class=\"mspace nobreak\"> </span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace nobreak\"> </span><span class=\"mord mathdefault\">i</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">t</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">c</span><span class=\"mspace nobreak\"> </span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace nobreak\"> </span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">⟩</span></span></span></span> is 1 if i=j and 0 otw. right? </p>\n</blockquote>\n<p>correct</p>\n<blockquote>\n<p>But e.g. for n=1, i.e. just the usual Hadamard gate the element at position i=0 and j=0 should be positive not negative.</p>\n</blockquote>\n<p>The formula is correct, but <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>j</mi><mi mathvariant=\"normal\">.</mi><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">j.i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord\">.</span><span class=\"mord mathdefault\">i</span></span></span></span> is the bitwise inner product of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>i</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|i\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\">i</span><span class=\"mclose\">⟩</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>j</mi><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|j\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">⟩</span></span></span></span>.</p>",
        "id": 170615280,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562835916
    },
    {
        "content": "<p>So, it's not the <code>inner_prod</code> in <code>Quantum.thy</code>.  I will edit my previous post.<br>\nFor instance, the bitwise inner product of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mn>00</mn><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">|00\\rangle</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mclose\">⟩</span></span></span></span> with itself is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, not <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 170616623,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562837268
    },
    {
        "content": "<p>Then, I guess this is what I have done so far :( Convert i and j into binary numbers, pad them with 0's (depending on the way you define them) and multiply them bitwise. This makes everything very hard to prove. I really hoped that there was a better way.</p>",
        "id": 170616976,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562837548
    },
    {
        "content": "<p>Given <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">0 \\leq i&lt;2^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, we need its binary representation, then we will be able to define the bitwise inner product of any two unit vectors of dimension <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 170617723,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562838191
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span>  Does it seem reasonable ? After that , everything should be easy to prove. I will write a theory <code>Binary_Nat.thy</code>and push it into my master branch for you to use it. Is it ok ?</p>",
        "id": 170620674,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562840758
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228778\">@Anthony Bordg</span>  I already did that but in a rather specific way. It would probably be good to have it more general so I would be glad if you could do that.</p>",
        "id": 170620991,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562841056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228778\">@Anthony Bordg</span>  did you already start? My approach seems to be rather inefficient, the proof that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mrow><mo>⊕</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">H^{\\oplus n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊕</span><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> equals this new representation takes forever and is rather ugly. I basically just converted the decimals with the usual method (divide and mod by 2). The output is a nat list containing 0's and 1's. Then, I wrote another function, taking two of these lists and add 1 to the result if both lists have a 1 at the same entry. Is there a better way?</p>",
        "id": 170637470,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1562854928
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"228778\">Anthony Bordg</span>  did you already start? </p>\n</blockquote>\n<p>Yes, I started but it's not ready yet. <span aria-label=\"working on it\" class=\"emoji emoji-1f6e0\" role=\"img\" title=\"working on it\">:working_on_it:</span></p>",
        "id": 170642397,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1562857901
    },
    {
        "content": "<p><code>Binary_Nat.thy</code> (see my master branch) is almost completely done, but one <code>sorry</code> remains inside the last proof (the proof of <code>bin_rep_eq</code>). The step is quite obvious, since the terms in the sum cancel except the first and the last ones, but I have a hard time making it clear to Isabelle. To help I think one needs to use <code>of_nat</code>, but even so the proof remains problematic. <br>\nDo you have any suggestion to help Isabelle ?</p>",
        "id": 170884585,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563190604
    },
    {
        "content": "<p>Is there a way to separate the sum <code>\\&lt;Sum&gt;i&lt;n. m mod 2^(n-i) - m mod 2^(n-1-i)</code>into the difference of two sums?</p>",
        "id": 170885289,
        "sender_full_name": "Yijun He",
        "timestamp": 1563191410
    },
    {
        "content": "<p>We will then obtain <code>\\&lt;Sum&gt;i&lt;n. m mod 2^(n-i) - \\&lt;Sum&gt;i&lt;n. m mod 2^(n-1-i)</code>. Then we can take out the first and last terms, giving <code>\\&lt;Sum&gt;i\\&lt;in&gt;{1..&lt;n}. m mod 2^(n-i) - \\&lt;Sum&gt;i\\&lt;in&gt;{0..&lt;n-1}. m mod 2^(n-1-i)</code>. These two sums should cancel out by a lemma <code>sum_diff</code>.</p>",
        "id": 170885568,
        "sender_full_name": "Yijun He",
        "timestamp": 1563191694
    },
    {
        "content": "<p>I will try it.</p>",
        "id": 170886497,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563192567
    },
    {
        "content": "<p>Also the <code>sum_diff</code> is the lemma in <code>Basics.thy</code>, and importing the theory will cause some proofs in <code>Binary_Nat.thy</code> to fail, but they can easily be fixed.</p>",
        "id": 170886622,
        "sender_full_name": "Yijun He",
        "timestamp": 1563192710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228785\">@Yijun He</span> By the way I realize that <code>sum_diff</code> it's a misnomer , it should be called something like <code>sum_of_index_diff</code>. I will fix the name.</p>",
        "id": 170931296,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563224466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228785\">@Yijun He</span> The relevant lemma is <code>sum_subtractf</code> in <code>Groups_Big.thy</code>.</p>",
        "id": 170931585,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563224646
    },
    {
        "content": "<p>But now the definition for the bitwise inner product I build upon bin_rep and all proofs built on that are not working anymore. Is there no other solution? It is a nat list after all.  Adding <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>m</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">m \\ge 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> does not instantly help but I will try to adapt the proofs in another way to the new def of bin_rep :)</p>",
        "id": 171060994,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1563354519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span> Ok, I will try to help.</p>",
        "id": 171064207,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563357958
    },
    {
        "content": "<p>Thanks, I am already halfway through. I just did a new commit, maybe I should have defined  bitwise_inner_product or Hn differently (I had that nat first in Hn and not in bitwise_inner_product)?</p>",
        "id": 171064606,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1563358389
    },
    {
        "content": "<p>I finished except for one small lemma :)</p>",
        "id": 171067411,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1563361227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span>  I'm currently having a look at it. The first thing which is not very clear for me is the order of the three arguments. The natural order is <code>bitwise_inner_product n i j</code>, but with your notation it seems that the order is <code>bitwise_inner_product i n j</code>. Is it correct ?</p>",
        "id": 171067950,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563361731
    },
    {
        "content": "<p>Yes please also see the comment I left about that. If we want to use the notation <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><msub><mo>⋅</mo><mi>n</mi></msub><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i ⋅_n j </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⋅</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span> the order of the argument is fixed as i n j otherwise it can easily be changed to i n j.</p>",
        "id": 171068349,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1563362191
    },
    {
        "content": "<p>Since its not possible to write <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><msub><mo>⋅</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">i⋅_{n+1} j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8678509999999999em;vertical-align:-0.208331em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⋅</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span></span></span></span>, maybe this should be discarded after all anyway</p>",
        "id": 171068521,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1563362395
    },
    {
        "content": "<p>Ok, after the lunch I will make a few changes. In the meantime please continue with your proofs.</p>",
        "id": 171068569,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563362406
    },
    {
        "content": "<p>I pushed the measurement outline</p>",
        "id": 171423152,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1563795782
    },
    {
        "content": "<p>Thanks Hanna. I will have a look as soon as possible, but first I need to work a little bit more on the quantum Fourier transform.</p>",
        "id": 171434667,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1563805372
    },
    {
        "content": "<p>I finished the Deutsch-Jozsa algorithm <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> Except from that (optional?) proof we talked about earlier everything is done. But I still need to tidy everything up a bit.</p>",
        "id": 171677188,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564048111
    },
    {
        "content": "<p>Congrats! <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 171677323,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564048220
    },
    {
        "content": "<p>Is all the type-information in <code>is_balanced</code> needed ?</p>",
        "id": 172298672,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564742181
    },
    {
        "content": "<p>It was but actually it might not be needed anymore (or at least not that many type annotations)</p>",
        "id": 172298831,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564742423
    },
    {
        "content": "<p>Is not <code>ind_from_1</code> a particular case of <code>nat_induct_at_least</code> ?</p>",
        "id": 172299458,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564743410
    },
    {
        "content": "<p>It might be useful though.</p>",
        "id": 172300463,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564744707
    },
    {
        "content": "<p>I would say that <code>Uf_mult_without_empty_summands_sum_even</code> is easier to read than <code>Uf_mult_without_empty_summands_sum_even'</code>.<br>\nI removed the braces since there are not needed.</p>",
        "id": 172301930,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564746530
    },
    {
        "content": "<p>I will change <code>Uf_mult_without_empty_summands_sum_even</code> accordingly after you finish looking over the file</p>",
        "id": 172303307,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564748114
    },
    {
        "content": "<blockquote>\n<p>Is not <code>ind_from_1</code> a particular case of <code>nat_induct_at_least</code> ?</p>\n</blockquote>\n<p>I didn't noticed that. I looked it up in the internet and there it was suggested to write a customary induction rule. It might be better to use the existing one, i.e.  <code>nat_induct_at_least</code></p>",
        "id": 172303373,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564748174
    },
    {
        "content": "<p>For <code>bin_rep_geq_0</code> note that there is a very simple proof, namely <code>using assms by simp</code>. Actually, this lemma is probably not even necessary.</p>",
        "id": 172325459,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564765873
    },
    {
        "content": "<p>From <code> H_tensor_n_is_tensor_of_H</code> one can factor out a lemma, namely <code>H^⇩⊗ 1 = H</code>.</p>",
        "id": 172328998,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564768713
    },
    {
        "content": "<p>In <code>sum_every_odd_summand_is_zero</code>, <code>A</code> is an odd choice of notation for a function.</p>",
        "id": 172401124,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564827980
    },
    {
        "content": "<p>Sry I was thinking about matrix entries and A is often used to denote an arbitrary matrix. But with the degree of generality the lemma has in its final version (not much to do with matrices anymore) it is better to replace it with another notation.</p>",
        "id": 172403042,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564831748
    },
    {
        "content": "<blockquote>\n<p>For <code>bin_rep_geq_0</code> note that there is a very simple proof, namely <code>using assms by simp</code>. Actually, this lemma is probably not even necessary.</p>\n</blockquote>\n<p>Same might be the case for H_values_right_bottom and H_values</p>",
        "id": 172403115,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564831909
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Is not <code>ind_from_1</code> a particular case of <code>nat_induct_at_least</code> ?</p>\n</blockquote>\n<p>I didn't noticed that. I looked it up in the internet and there it was suggested to write a customary induction rule. It might be better to use the existing one, i.e.  <code>nat_induct_at_least</code></p>\n</blockquote>\n<p>All the proofs using <code>ind_from_1</code> have been rewritten with <code>nat_induct_at_least</code>.</p>",
        "id": 172403211,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564832046
    },
    {
        "content": "<p>To help the reader or maintainer, if there are multiple assumptions then one should specify the exact subset of assumptions needed to prove a given fact. For instance, to prove the first fact in the proof of <code>U⇩f_mult_without_empty_summands_even</code>, one should use <code>assms(1,2,4)</code> instead of <code>assms</code>.</p>",
        "id": 172408358,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564842042
    },
    {
        "content": "<p>In an intricate formalization one should use <code>show ?thesis</code> whenever possible to declutter the code.</p>",
        "id": 172408629,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564842494
    },
    {
        "content": "<p>The proof <code>U⇩f_mult_without_empty_summands_sum_odd</code> has been rewritten in the same style than <code>U⇩f_mult_without_empty_summands_sum_even</code>.</p>",
        "id": 172409673,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564844461
    },
    {
        "content": "<p>A simpler name for <code>index_tensor_mat_vec2_i_smaller_row_B</code> would be indeed welcome. <br>\nWhat about <code>index_tensor_mat_with_vec2</code> ? <br>\nFrom the formula it's already clear that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mtext>dim_row</mtext><mtext> </mtext><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">i &lt; \\text{dim\\_row}\\,B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00444em;vertical-align:-0.31em;\"></span><span class=\"mord text\"><span class=\"mord\">dim_row</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, so one does not need to \"embed\" this condition into the name. <br>\nOk, I see that a confusion would be possible with <code>index_tensor_mat_vec2_i_greater_row_B</code> which also needs a new name.<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 172412709,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564850291
    },
    {
        "content": "<p>I was thinking about that too (thats why I suggested that name in the comment), but there is also a lemma called <code>index_tensor_mat_vec2_i_greater_row_B</code>, if you rename <code>index_tensor_mat_vec2_i_smaller_row_B</code> to <code>index_tensor_mat_with_vec2</code>  how would you name that lemma?</p>",
        "id": 172412891,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564850677
    },
    {
        "content": "<p>Maybe we could put them together to one lemma with two goals and then name it <code>index_tensor_mat_with_vec2</code>?</p>",
        "id": 172412914,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564850754
    },
    {
        "content": "<p>Since thematically they are closely related.</p>",
        "id": 172412962,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564850782
    },
    {
        "content": "<blockquote>\n<p>Yes maybe we could put them together to one lemma with two goals and then name it <code>index_tensor_mat_with_vec2</code>?</p>\n</blockquote>\n<p>It's a possible solution. <br>\nI hesitate between <code>index_tensor_mat_with_vec2</code>  and <code>index_tensor_mat_with_vec2_row_cond</code>. The name matters only to us, since these two lemmas are too ad hoc to be useful for someone else.</p>",
        "id": 172413262,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564851297
    },
    {
        "content": "<p>But in any case, it's worth emphasizing that <code>i</code> and <code>B</code> should not be into the name, since i and B are completely arbitrary, they are mere notations, one could choose <code>k</code> and <code>C</code> or whatever.</p>",
        "id": 172413412,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564851509
    },
    {
        "content": "<p>Since the two lemmas don't share the same assumptions, it's not easy to merge them into a single lemma.</p>",
        "id": 172413701,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564851974
    },
    {
        "content": "<p>I can simply use <code>index_tensor_mat_with_vec2_row_cond</code> and <code>index_tensor_mat_with_vec2_row_cond_bis</code> which are not great but not bad either.</p>",
        "id": 172413796,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564852197
    },
    {
        "content": "<p>What is the problem with:</p>\n<div class=\"codehilite\"><pre><span></span>lemma index_tensor_mat_vec2:\n  fixes A B:: &quot;complex Matrix.mat&quot; and i:: &quot;nat&quot;\n  assumes &quot;i &lt; (dim_row A) * (dim_row B)&quot;\n      and &quot;0 &lt; (dim_col A) * (dim_col B)&quot;\n      and &quot;dim_row A = 2&quot;\n      and &quot;dim_col A = 1&quot;\n  shows &quot;i &lt; dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (0, 0)) * (B $$ (i,0))&quot;\n    and &quot;i ≥ dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (1, 0)) * (B $$ ( i -dim_row B,0))&quot;\nproof-\n  show &quot;i &lt; dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (0, 0)) * (B $$ (i,0))&quot;\n    using index_tensor_mat assms by auto\nnext\n  show  &quot;i ≥ dim_row B ⟶ (A ⨂ B) $$ (i, 0) = (A  $$ (1, 0)) * (B $$ ( i -dim_row B,0))&quot;\n  proof\n    assume a0: &quot;i ≥ dim_row B&quot;\n    have &quot;(A ⨂ B) $$ (i,0) = A $$ (i div (dim_row B), 0) * B $$ (i mod (dim_row B),0)&quot;\n      using assms index_tensor_mat[of A &quot;dim_row A&quot; &quot;dim_col A&quot; B &quot;dim_row B&quot; &quot;dim_col B&quot; i 0]\n      by auto\n    moreover have &quot;i div (dim_row B) = 1&quot;\n      using assms a0\n      by simp\n    then have &quot;i mod (dim_row B) = i - (dim_row B)&quot;\n      by (simp add: modulo_nat_def)\n    ultimately show &quot;(A ⨂ B) $$ (i, 0) = (A  $$ (1, 0)) * (B $$ ( i -dim_row B,0))&quot;\n      by (simp add: ‹i div dim_row B = 1›)\n  qed\nqed\n</pre></div>\n\n\n<p>that the assumptions in the first case became stronger?</p>",
        "id": 172414215,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564852945
    },
    {
        "content": "<p>Since the first lemma is not needed it could also be deleted (although it feels nicer/more complete to have both cases) and the second could get the short name</p>",
        "id": 172414378,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564853259
    },
    {
        "content": "<blockquote>\n<p>Since the first lemma is not needed it could also be deleted (although it feels nicer/more complete to have both cases) and the second could get the short name</p>\n</blockquote>\n<p>Do you mean the first lemma is not used ? If so, it should be deleted.</p>",
        "id": 172414553,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564853583
    },
    {
        "content": "<p>One should write <code>assms(1) assms(2) assms(4)</code> for instance as <code>assms(1,2,4)</code> for conciseness.</p>",
        "id": 172414619,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564853730
    },
    {
        "content": "<p>No since its proof is very easy it is not.</p>",
        "id": 172414669,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564853789
    },
    {
        "content": "<p>The abbreviations <code>zero</code>, <code>one</code> and the lemmas <code>ket_zero_is_state</code>, <code>ket_one_is_state</code> are duplicates of  those in <code>Deutsch.thy</code>. Idem with <code>H_on_ket_zero_is_state</code>.</p>",
        "id": 172443060,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564912675
    },
    {
        "content": "<p>The lemma <code>ψ⇩1⇩0_values</code> does not need the third assumption.</p>",
        "id": 172443191,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564912895
    },
    {
        "content": "<p>The theory does not import Deutsch.thy</p>",
        "id": 172443347,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564913211
    },
    {
        "content": "<blockquote>\n<p>The theory does not import Deutsch.thy</p>\n</blockquote>\n<p>It does now <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 172443408,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564913330
    },
    {
        "content": "<p>Of course it could though. Should Grover do it too?</p>",
        "id": 172443409,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564913334
    },
    {
        "content": "<p>I feel for Deutsch and Deutsch-Jozsa it is more reasonable than for Grover</p>",
        "id": 172443421,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564913363
    },
    {
        "content": "<p>Sry for typos I am on my phone</p>",
        "id": 172443424,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1564913379
    },
    {
        "content": "<blockquote>\n<p>But in any case, it's worth emphasizing that <code>i</code> and <code>B</code> should not be into the name, since i and B are completely arbitrary, they are mere notations, one could choose <code>k</code> and <code>C</code> or whatever.</p>\n</blockquote>\n<p>Same problem with <code>ψ⇩1⇩0_tensor_n</code> for instance. I will simply name it <code>ψ⇩1⇩0_tensor</code>.</p>",
        "id": 172443425,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564913388
    },
    {
        "content": "<p>The lemma <code>bin_rep_geq_0</code> is not required.</p>",
        "id": 172444990,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564916503
    },
    {
        "content": "<p>There is a lot of places where the assumption <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n\\geq 1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> is not needed.</p>",
        "id": 172445230,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564916877
    },
    {
        "content": "<p>The lemma <code>bin_rep_index_0</code> has been generalised.</p>",
        "id": 172446454,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1564919187
    },
    {
        "content": "<p>A lot of parentheses can be removed to declutter the code.</p>",
        "id": 172494903,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565002375
    },
    {
        "content": "<p>In the lemma <code>bitwise_inner_prod_fst_el_0</code> only the first assumption is required. In the same way, the third assumption in <code>bitwise_inner_prod_fst_el_is_1</code> is not necessary.</p>",
        "id": 172495019,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565002533
    },
    {
        "content": "<p>The lemma <code>i_div_value_1</code> is not used anywhere, I removed it.</p>",
        "id": 172495803,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565003448
    },
    {
        "content": "<p>When the same fact is proven twice for two different variables that play symmetric roles, then one can merge them into a single fact.<br>\nFor instance, in <code>bitwise_inner_prod_fst_el_is_1</code> one can replace </p>\n<div class=\"codehilite\"><pre><span></span>moreover have &quot;k∈{0..n} ⟶ bin_rep (Suc n) i ! (k+1) = bin_rep n (i mod 2^n) ! k&quot; for k\n    using bin_rep_def by(metis Suc_eq_plus1 bin_rep_aux.simps(2) bin_rep_aux_neq_nil butlast.simps(2) nth_Cons_Suc)\nmoreover have &quot;k∈{0..n} ⟶ bin_rep (Suc n) j ! (k+1) = bin_rep n (j mod 2^n) ! k&quot; for k\n    using bin_rep_def by(metis Suc_eq_plus1 bin_rep_aux.simps(2) bin_rep_aux_neq_nil butlast.simps(2) nth_Cons_Suc)\n</pre></div>\n\n\n<p>with</p>\n<div class=\"codehilite\"><pre><span></span>moreover have &quot;k∈{0..n} ⟶ bin_rep (Suc n) i ! (k+1) = bin_rep n (i mod 2^n) ! k\n∧ bin_rep (Suc n) j ! (k+1) = bin_rep n (j mod 2^n) ! k&quot; for k\n    using bin_rep_def by(metis Suc_eq_plus1 bin_rep_aux.simps(2) bin_rep_aux_neq_nil butlast.simps(2) nth_Cons_Suc)\n</pre></div>",
        "id": 172497967,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565005811
    },
    {
        "content": "<p>The declarations <code>declare [[show_types]]</code> may be useful in the process of formalization, but they should be removed before submitting a PR.</p>",
        "id": 172498529,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565006518
    },
    {
        "content": "<blockquote>\n<p>The declarations <code>declare [[show_types]]</code> may be useful in the process of formalization, but they should be removed before submitting a PR.</p>\n</blockquote>\n<p>Please see my message about that.</p>",
        "id": 172498691,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565006710
    },
    {
        "content": "<p>Note that when <code>i</code> has type <code>nat</code>, then the assumption <code>i ≥ 0</code> is useless.</p>",
        "id": 172509595,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565016045
    },
    {
        "content": "<p><code>for k</code> being part of a statement, it should be on the same line with the statement itself.</p>",
        "id": 172515762,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565021029
    },
    {
        "content": "<p>Regarding your comment about renaming the lemma <code>sqrt_2_to_n_times_sqrt_2_n_plus_one</code>, this lemma is really ad hoc, so the name does not matter and it won't be used outside the theory. So, what about <code>aux_comp</code> (which stands for <em>auxiliary computation</em>) ?</p>",
        "id": 172573904,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565084698
    },
    {
        "content": "<p>Would be already much better than the current name. But aux_comp could mean anything. Maybe sqrt_2_aux_comp or something that has sqrt in its name?</p>",
        "id": 172579229,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565090312
    },
    {
        "content": "<blockquote>\n<p>Would be already much better than the current name. But aux_comp could mean anything. Maybe sqrt_2_aux_comp or something that has sqrt in its name?</p>\n</blockquote>\n<p>Ok, <code>aux_comp_with_sqrt2</code> sounds good.</p>",
        "id": 172593728,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565101827
    },
    {
        "content": "<p>Given the fact that it's a trivial result, it does not deserve a structured proof.<br>\nSo, I have replaced </p>\n<div class=\"codehilite\"><pre><span></span>lemma sqrt_2_to_n_times_sqrt_2_n_plus_one [simp]:\n  shows &quot;2^n/(sqrt(2)^n * sqrt(2)^(n+1)) = 1/sqrt 2&quot;\n proof(induction n)\n  show &quot;2^0/(sqrt(2)^0 * sqrt(2)^(0+1)) = 1/sqrt 2&quot; by simp\nnext\n  fix n\n  assume IH: &quot;2^n/(sqrt(2)^n * sqrt(2)^(n+1)) = 1/sqrt 2&quot;\n  have &quot;sqrt 2 ^ Suc n * sqrt 2 ^ (Suc n + 1) = sqrt(2)^n * sqrt(2)^(n+1) * sqrt(2)^2&quot;\n    by simp\n  then have &quot;2^Suc n /(sqrt 2 ^ Suc n * sqrt 2 ^ (Suc n + 1)) = (2 ^ n * 2) /(sqrt(2)^n * sqrt(2)^(n+1) * sqrt(2)^2)&quot;\n    by (metis power_Suc semiring_normalization_rules(7))\n  then show &quot;2 ^ Suc n /(sqrt 2 ^ Suc n * sqrt 2 ^ (Suc n + 1)) = 1/sqrt 2&quot;\n    using IH by auto\nqed\n</pre></div>\n\n\n<p>with</p>\n<div class=\"codehilite\"><pre><span></span>lemma aux_comp_with_sqrt2:\n  shows &quot;(sqrt 2)^n * (sqrt 2)^n = 2^n&quot;\n  by (smt power_mult_distrib real_sqrt_mult_self)\n\nlemma aux_comp_with_sqrt2_bis [simp]:\n  shows &quot;2^n/(sqrt(2)^n * sqrt(2)^(n+1)) = 1/sqrt 2&quot;\n  using aux_comp_with_sqrt2 by (simp add: mult.left_commute)\n</pre></div>\n\n\n<p>Note that smt proofs are fine, see Gerwin's <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00128.html\" target=\"_blank\" title=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00128.html\">answer</a>.</p>",
        "id": 172596224,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565103435
    },
    {
        "content": "<p>One can read</p>\n<div class=\"codehilite\"><pre><span></span>lemma sum_n_summands_one_or_minus:\n  fixes F:: &quot;nat ⇒ nat&quot; (*I renamed this because f suggested that it was jozsa&#39;s f function but it might also be f(k)+1*)\n    and A::&quot;nat set&quot;\n  assumes &quot;finite A&quot;\n  shows &quot;(∑ k ∈ A. (-1)^(F(k))) ≤ card A &quot;\n  and &quot;(∑ k ∈ A. (-1)^(F(k))) ≥ -card A &quot;\n</pre></div>\n\n\n<p>, but it's better to stick to mathematical practice and choose <code>g</code> instead if <code>f</code> is not available for the reason you mentioned. Usually, capitals are not used for functions.<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 172596796,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565103774
    },
    {
        "content": "<blockquote>\n<p>Note that smt proofs are fine, see Gerwin's answer.</p>\n</blockquote>\n<p>Good to know that it changed. There might be other proofs with can be shortened by smt I replaced some of the smts with structured proofs because of the entry in the style guide about it.</p>",
        "id": 172597153,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565103998
    },
    {
        "content": "<blockquote>\n<p>but it's better to stick to mathematical practice and choose g instead if f is not available for the reason you mentioned.</p>\n</blockquote>\n<p>Usually, capitals are not used for functions.<br>\nGreat thanks that fully answers my question. I think I choose F to resemble f(k) (since the function is only used for f(k) and f(k)+1)</p>",
        "id": 172597488,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565104208
    },
    {
        "content": "<p>In the same spirit, I have replaced</p>\n<div class=\"codehilite\"><pre><span></span>lemma sum_n_summands_one_or_minus:\n  fixes g:: &quot;nat ⇒ nat&quot; and A:: &quot;nat set&quot;\n  assumes &quot;finite A&quot;\n  shows &quot;(∑k∈A. (-1)^(g k)) ≤ card A&quot; and &quot;(∑k∈A. (-1)^(g k)) ≥ -card A&quot;\nproof-\n  have f0: &quot;k ∈ A⟶ (-(1::int))^(g(k)) = 1 ∨  (-(1::int))^(g(k)) = -1&quot; for k::nat\n    by (metis neg_one_even_power neg_one_odd_power)\n      (*This was proposed by sledgehammer(with different variables) I added it to avoid smt. Should it stay?\n        If yes it might be possible to replace second smt*)\n  obtain G :: &quot;int ⇒ (nat ⇒ int) ⇒ nat set ⇒ nat&quot; where\n    &quot;∀A F i. sum F A ≤ int (card A) * i ∨ ¬ F (G i F A) ≤ i ∧ G i F A ∈ A&quot;\n    by (meson sum_bounded_above)\n  then show &quot;(∑ k::nat ∈ A. (-1)^(F(k))) ≤ card A &quot;\n     using f0\n   by (metis (no_types) mult.right_neutral negative_zle of_nat_1 order_refl)\nnext\n  have &quot;k ∈ A⟶ (-(1::nat))^(F(k)) = 1 ∨  (-(1::nat))^(F(k)) = -1&quot; for k\n    by (metis int_ops(2) neg_one_even_power neg_one_odd_power)\n  then show  &quot;(∑ k ∈ A. (-1)^(F(k))) ≥ -card A &quot;\n    using assms\n    by (smt card_eq_sum of_nat_1 of_nat_sum sum_mono sum_negf)\nqed\n</pre></div>\n\n\n<p>with </p>\n<div class=\"codehilite\"><pre><span></span>lemma aux_ineq_with_card:\n  fixes g:: &quot;nat ⇒ nat&quot; and A:: &quot;nat set&quot;\n  assumes &quot;finite A&quot;\n  shows &quot;(∑k∈A. (-1)^(g k)) ≤ card A&quot; and &quot;(∑k∈A. (-1)^(g k)) ≥ -card A&quot;\n   apply (smt assms neg_one_even_power neg_one_odd_power card_eq_sum of_nat_1 of_nat_sum sum_mono)\n  apply (smt assms neg_one_even_power neg_one_odd_power card_eq_sum of_nat_1 of_nat_sum sum_mono sum_negf).\n</pre></div>\n\n\n<p>Note the change in the name. One does not need to find a clever name. Indeed, since these proofs are somewhat handled automatically, nobody will use it in another formalization, they will just run Sledgehammer instead.</p>",
        "id": 172599518,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565105539
    },
    {
        "content": "<p><code>const_has_max_value</code> was renamed <code>aux_comp_with_cmod</code>.</p>",
        "id": 172601550,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565106955
    },
    {
        "content": "<p><code>cmod_smaller_n</code> was renamed <code>cmod_less</code>. The former name had the problem already pointed out about arbitrary notations that should not find their way into names. Also, note that there are well established conventions in Isabelle/HOL, in particular <em>less</em> in names is common for a statement involving <code>&lt;</code>.</p>",
        "id": 172602381,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565107482
    },
    {
        "content": "<p>The following example in <code>Deutsch-Jozsa.thy</code> is a good case study:</p>\n<div class=\"codehilite\"><pre><span></span>lemma sum_divide_distrib_cmod:\n  fixes n:: nat and g:: &quot;nat ⇒ int&quot; and a:: real\n  shows &quot;(cmod(complex_of_real(∑k&lt;n. g k / a)))⇧2 = (cmod (∑k&lt;n. g k) / a)⇧2&quot;\nproof-\n  have &quot;(complex_of_real(∑k::nat&lt;n. (g k) / a)) = (∑k::nat&lt;n. (g k) / a)&quot; by blast\n  then have &quot;(cmod(complex_of_real(∑k::nat&lt;n. (g k) / a)))⇧2 = (cmod((∑k::nat&lt;n. (g k) / a)))⇧2&quot;\n    by blast\n  moreover have &quot;(∑k::nat&lt;n. (g k) / a) = (∑k::nat&lt;n. (g k))/ a&quot;\n    by (simp add: sum_divide_distrib)\n  ultimately show &quot;(cmod(complex_of_real(∑k::nat&lt;n. (g k) / a)))⇧2 = (cmod (∑k::nat&lt;n. (g k)) / a)⇧2&quot;\n    by (metis norm_of_real of_real_of_int_eq power2_abs power_divide)\nqed\n</pre></div>\n\n\n<p>Actually, if one runs Sledgehammer, then it finds a proof, namely</p>\n<div class=\"codehilite\"><pre><span></span> by (metis cmod_square_real of_int_sum of_real_of_int_eq power_divide sum_divide_distrib)\n</pre></div>\n\n\n<p>which is perfectly fine, since the result being trivial one does not want a structured proof in that case. Also, since the proof is handled automatically, there is no need for a clever name, instead of reusing this lemma in the future people will prove it again (automatically, for free). Hence, one does not run out of clever names and avoid a headache with the choice of the name.<br>\nIt simply becomes </p>\n<div class=\"codehilite\"><pre><span></span>lemma aux_comp_sum_divide_cmod:\n  fixes n:: nat and g:: &quot;nat ⇒ int&quot; and a:: real\n  shows &quot;(cmod(complex_of_real(∑k&lt;n. g k / a)))⇧2 = (cmod (∑k&lt;n. g k) / a)⇧2&quot;\n  by (metis cmod_square_real of_int_sum of_real_of_int_eq power_divide sum_divide_distrib)\n</pre></div>\n\n\n<p>and the prefix <em>aux_comp</em> is a way to  signal the thoughts above.<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 172605351,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565109500
    },
    {
        "content": "<p><code>add_limits_max_value</code> is useless, one can simply run <code>by simp</code> instead where this lemma is used.</p>",
        "id": 172606117,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565110083
    },
    {
        "content": "<p>For a reason already explained the name <code>prob_first_n_qubits_0</code> is not satisfying. What about <code>prob_fst_qubits_0</code> ?</p>",
        "id": 172751550,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565257606
    },
    {
        "content": "<p>But is in general reasonable to use such a definition?</p>",
        "id": 172751830,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565258006
    },
    {
        "content": "<p>Why does the prefix <code>meas</code> appear in <code>meas_fst_n_qubits_zero_remaining_indices</code> while there is no measure in the statement of this lemma ?<br>\nSomething like <code>indices_with_fst_qubits_0</code> might be better.</p>",
        "id": 172751909,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565258091
    },
    {
        "content": "<blockquote>\n<p>But is in general reasonable to use such a definition?</p>\n</blockquote>\n<p>I'm going to investigate this question.</p>",
        "id": 172751930,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565258140
    },
    {
        "content": "<p><code>indices_with_fst_qubits_0</code> is fine. The meas appears since the lemma shows what the remaining indices are in the case that the first n qubits are measured and are all 0.</p>",
        "id": 172753010,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565259607
    },
    {
        "content": "<p><em>tensor_n</em> appears a lot in names, for instance in <code>hadamard_gate_tensor_n_times_ψ⇩2_is_ψ⇩3</code>, with the usual problem. <br>\n<em>iter_tensor</em> is a good alternative (iter stands for iterated), for instance  it gives <code>hadamard_gate_iter_tensor_times_ψ⇩2_is_ψ⇩3</code>, or even better in that case <code>iter_tensor_of_H_times_ψ⇩2_is_ψ⇩3</code>. <br>\nH is fine here, since given the context it's meaningful in itself and there is absolutely no ambiguity that it stands for the Hadamard gate.</p>",
        "id": 172753596,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565260349
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>But is in general reasonable to use such a definition?</p>\n</blockquote>\n<p>I'm going to investigate this question.</p>\n</blockquote>\n<p>In the second comment below <code>text ‹Measurement›</code> it's written that <code>prob_fst_qubits_0 n v</code> is equal to </p>\n<div class=\"codehilite\"><pre><span></span>∏i∈{0..n} . prob0 (n+1) v i)\n</pre></div>\n\n\n<p>(assuming that v is a state of an n+1-qubits system). But, actually it's equal to <br>\nsomething more complicated involving <code>post_meas0</code>. It's certainly the origin of the trouble.<br>\nAlso, one should prove it for any state v, not only for jozsa_algo, since the proof will be more general and actually simpler.<br>\nOtherwise, this approach is perfectly reasonable.<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 172770623,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565275187
    },
    {
        "content": "<p>Great there might be a generalized version in the comment below. It could solve the issue but actually I think I considered that and increased n in the counterpart as well :/ It might be just a remnant of a proof attempt in the comment.</p>",
        "id": 172771485,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565275647
    },
    {
        "content": "<p><code>not_const_cannot_have_max_value1</code> was renamed <code>max_value_of_not_const_less</code>.</p>",
        "id": 172777386,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565279697
    },
    {
        "content": "<blockquote>\n<p>Great there might be a generalized version in the comment below. It could solve the issue but actually I think I considered that and increased n in the counterpart as well :/ It might be just a remnant of a proof attempt in the comment.</p>\n</blockquote>\n<p>I'm trying to complete the proof.<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 172800650,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565296090
    },
    {
        "content": "<p>I simplified <code>prob_fst_qubits_0</code> as well by removing the condition <code>state (n+1) v</code>.</p>",
        "id": 173122564,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565709351
    },
    {
        "content": "<blockquote>\n<p>For a reason already explained the name <code>prob_first_n_qubits_0</code> is not satisfying. What about <code>prob_fst_qubits_0</code> ?</p>\n</blockquote>\n<p>I did not realize until this evening that the notations introduced in <code>Deutsch-Jozsa</code> are not coherent with the ones in <code>Quantum.thy</code>. One should replace <code>prob_fst_qubits_0</code> with <code>prob0_fst_qubits</code>.<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 173153921,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565732264
    },
    {
        "content": "<p>When you wrote <code>text ‹General lemmata needed for the probability proofs›</code>, do you mean general lemmata to compute probabilities ?<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 173200815,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565788270
    },
    {
        "content": "<p>Yes, they concern the probability that the first n qubits are 0.</p>",
        "id": 173201564,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565788815
    },
    {
        "content": "<blockquote>\n<p>I did not realize until this evening that the notations introduced in <code>Deutsch-Jozsa</code> are not coherent with the ones in <code>Quantum.thy</code>. One should replace <code>prob_fst_qubits_0</code> with <code>prob0_fst_qubits</code>.<br>\n<span class=\"user-mention silent\" data-user-id=\"228787\">Hanna Lachnitt</span></p>\n</blockquote>\n<p>Yes thats fine. I put the 0 in the name to match the notation in Quantum, but put it in the end because I didn't wanted it to sound as if its only about one qubit from the fst n ones. But it gets pretty clear from the name</p>",
        "id": 173201847,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1565789008
    },
    {
        "content": "<p>It's picky but often after the command <code>using</code> there is useless stuff  that could be removed. It's confusing if one tries to read the proofs to understand them, since there is a lot of useless stuff.<br>\nOne example:</p>\n<div class=\"codehilite\"><pre><span></span>have &quot;k &lt; 2^n⟶((1 div 2) ⋅⇘n⇙  k) = 0&quot; for k::nat\n    using bitwise_inner_prod_with_zero by simp\n</pre></div>\n\n\n<p>instead of</p>\n<div class=\"codehilite\"><pre><span></span>have &quot;k &lt; 2^n⟶((1 div 2) ⋅⇘n⇙  k) = 0&quot; for k::nat\n    using bin_rep_def bin_rep_aux_def bitwise_inner_prod_def bitwise_inner_prod_with_zero by simp\n</pre></div>\n\n\n<p>A second example:</p>\n<div class=\"codehilite\"><pre><span></span>moreover have &quot;(cmod(jozsa_algo $$ (1,0)))⇧2\n               = (cmod (∑k&lt;(2::nat)^n. (-1)^(f k+ 1 + ((1 div 2) ⋅⇘n⇙  k))/(sqrt(2)^n * sqrt(2)^(n+1))))⇧2&quot;\n      using  ψ⇩3_dim by auto\n</pre></div>\n\n\n<p>instead of</p>\n<div class=\"codehilite\"><pre><span></span>moreover have &quot;(cmod(jozsa_algo $$ (1,0)))⇧2\n               = (cmod (∑k&lt;(2::nat)^n. (-1)^(f k+ 1 + ((1 div 2) ⋅⇘n⇙  k))/(sqrt(2)^n * sqrt(2)^(n+1))))⇧2&quot;\n      using jozsa_algo_result const_def assms ψ⇩3_values ψ⇩3_dim by auto\n</pre></div>\n\n\n<p>Please clean your proofs when you are done and get rid of useless definitions and lemmas after <code>using</code>.<br>\n<span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span></p>",
        "id": 173205025,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565791036
    },
    {
        "content": "<p>It's even more picky, but sometimes there is an irregular use of white spaces. For example, one finds <code>∑k &lt; 2^n</code> or <code>∑k&lt;2^n</code> or <code>∑ k &lt; 2 ^ n</code>. <br>\nIf LaTeX is so pleasing to the eye, it's due in part to standardized spaces.<br>\nFor example, I find</p>\n<div class=\"codehilite\"><pre><span></span>shows &quot;∀A B. A∩B={}∧ A∪B=C⟶(∑k::nat ∈ C. g k) = (∑ k::nat ∈ A. g k) + (∑ k::nat ∈ B. g k)&quot;\n</pre></div>\n\n\n<p>less pleasing than</p>\n<div class=\"codehilite\"><pre><span></span>shows &quot;∀A B. A ∩ B = {} ∧ A ∪ B = C ⟶ (∑k∈C. g k) = (∑k∈A. g k) + (∑k∈B. g k)&quot;\n</pre></div>\n\n\n<p>Another example:</p>\n<div class=\"codehilite\"><pre><span></span>and &quot;jozsa_algo_eval = 0 ⟷ is_balanced &quot;\n</pre></div>\n\n\n<p>there is no white space after the first quotation mark but there is one before the second.</p>",
        "id": 173207777,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565792862
    },
    {
        "content": "<p>Note that instead of writing <code>∀x∈{i::nat. i &lt; 2^n}. g x = 0</code> one can write <code>∀x&lt; 2^n. g x = 0</code>.</p>",
        "id": 173213762,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565796802
    },
    {
        "content": "<p>Regarding your comment about possibly generalizing the lemmas involving <code>f k</code> and <code>f k + 1</code>, we could indeed write one general lemma and see the current lemmas as two different instances, but I'm not sure it's worth the trouble.</p>",
        "id": 173229468,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1565807594
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span> <br>\nI managed to prove the following lemma:</p>\n<div class=\"codehilite\"><pre><span></span>lemma prob0_fst_qubits_eq: (* To move in Measurement.thy *)\n  fixes n:: nat\n  shows &quot;prob0_fst_qubits n v = (cmod(v $$ (0,0)))⇧2 + (cmod(v $$ (1,0)))⇧2&quot;\nproof-\n  have &quot;prob0_fst_qubits n v = (∑j∈{k| k::nat. (k&lt;2^(n+1)) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)}. (cmod(v $$ (j,0)))⇧2)&quot;\n    using prob0_fst_qubits_def by simp\n  moreover have &quot;… = (∑j∈{0,1}. (cmod(v $$ (j,0)))⇧2)&quot;\n    using prob0_fst_qubits_index by simp\n  finally show ?thesis by simp\nqed\n</pre></div>",
        "id": 173494314,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566147922
    },
    {
        "content": "<p>The prerequisites are as follow:</p>\n<div class=\"codehilite\"><pre><span></span>lemma select_index_div_2: (* To move in Measurement.thy *)\n  fixes n i j::&quot;nat&quot;\n  assumes &quot;i &lt; 2^(n+1)&quot; and &quot;j&lt;n&quot;\n  shows &quot;select_index n j (i div 2) = select_index (n+1) j i&quot;\nproof-\n  have &quot;2^(n-Suc j) ≤ i div 2 mod 2^(n-j) ⟹ 2^(n-j) ≤ i mod 2^(n+1-j)&quot;\n  proof-\n    define a::nat where a0:&quot;a = i div 2 mod 2^(n-j)&quot;\n    assume &quot;2^(n-Suc j) ≤ a&quot;\n    then have &quot;2*a + i mod 2 ≥ 2^(n-(Suc j)+1)&quot; by simp\n    then have f0:&quot;2*a + i mod 2 ≥ 2^(n-j)&quot;\n      by (metis Suc_diff_Suc Suc_eq_plus1 assms(2))\n    have &quot;a &lt; 2^(n-j)&quot; using a0 by simp\n    then have &quot;2*a + i mod 2 &lt; 2*2^(n-j)&quot; by linarith\n    then have &quot;2*a + i mod 2 &lt; 2^(n-j+1)&quot; by simp\n    then have f1:&quot;2*a + i mod 2 &lt; 2^(n+1-j)&quot;\n      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))\n    have &quot;i = 2*(a + 2^(n-j)*(i div 2 div 2^(n-j))) + i mod 2&quot; using a0 by simp\n    then have &quot;i = 2*a + i mod 2 + 2^(n-j+1)*(i div 2 div 2^(n-j))&quot; by simp\n    then have &quot;i = 2*a + i mod 2 + 2^(n+1-j)*(i div 2 div 2^(n-j))&quot;\n      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))\n    then have &quot;i mod 2^(n+1-j) = 2*a + i mod 2&quot;\n      using f1 by (metis mod_if mod_mult_self2)\n    then show &quot;2^(n-j) ≤ i mod 2^(n+1-j)&quot;\n      using f0 by simp\n  qed\n  moreover have &quot;2^(n-j) ≤ i mod 2^(n+1-j) ⟹ 2^(n-Suc j) ≤ i div 2 mod 2^(n-j)&quot;\n  proof-\n    define a::nat where a0:&quot;a = i div 2 mod 2^(n-j)&quot;\n    assume a1:&quot;2^(n-j) ≤ i mod 2^(n+1-j)&quot;\n    have f0:&quot;2^(n-j) = 2^(n-Suc j+1)&quot;\n      by (metis Suc_diff_Suc Suc_eq_plus1 assms(2))\n    have &quot;a &lt; 2^(n-j)&quot; using a0 by simp\n    then have &quot;2*a + i mod 2 &lt; 2*2^(n-j)&quot; by linarith\n    then have &quot;2*a + i mod 2 &lt; 2^(n-j+1)&quot; by simp\n    then have f1:&quot;2*a + i mod 2 &lt; 2^(n+1-j)&quot;\n      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))\n    have &quot;i = 2*(a + 2^(n-j)*(i div 2 div 2^(n-j))) + i mod 2&quot; using a0 by simp\n    then have &quot;i = 2*a + i mod 2 + 2^(n-j+1)*(i div 2 div 2^(n-j))&quot; by simp\n    then have &quot;i = 2*a + i mod 2 + 2^(n+1-j)*(i div 2 div 2^(n-j))&quot;\n      by (metis Nat.add_diff_assoc2 Suc_leD Suc_leI assms(2))\n    then have &quot;i mod 2^(n+1-j) = 2*a + i mod 2&quot;\n      using f1 by (metis mod_if mod_mult_self2)\n    then have &quot;2*a + i mod 2 ≥ 2^(n-j)&quot;\n      using a1 by simp\n    then have &quot;(2*a + i mod 2) div 2 ≥ (2^(n-j)) div 2&quot;\n      using div_le_mono by blast\n    then show &quot;2^(n-Suc j) ≤ a&quot; by (simp add: f0)\n  qed\n  ultimately show ?thesis\n    using select_index_def assms by auto\nqed\n\nlemma select_index_suc_even: (* To move in Measurement.thy *)\n  fixes n k i:: nat\n  assumes &quot;k &lt; 2^n&quot; and &quot;select_index n i k&quot;\n  shows &quot;select_index (Suc n) i (2*k)&quot;\nproof-\n  have &quot;select_index n i k = select_index n i (2*k div 2)&quot; by simp\n  moreover have &quot;… = select_index (Suc n) i (2*k)&quot;\n  proof-\n    have &quot;i &lt; n&quot; using assms(2) select_index_def\n      by (metis (no_types, hide_lams) Suc_eq_plus1 assms(1) calculation diff_diff_left diff_le_self\ndiff_self_eq_0 div_by_1 le_0_eq le_eq_less_or_eq less_imp_diff_less mod_div_trivial mult.left_neutral mult_eq_0_iff mult_le_mono1 not_less plus_1_eq_Suc power_0 semiring_normalization_rules(7))\n    thus ?thesis\n      using select_index_div_2 assms(1) select_index_def by(metis Suc_1 Suc_eq_plus1 Suc_mult_less_cancel1 power_Suc)\n  qed\n  ultimately show &quot;select_index (Suc n) i (2*k)&quot;\n    using assms(2) by simp\nqed\n\nlemma select_index_suc_odd:\n  fixes n k i:: nat\n  assumes &quot;k ≤ 2^n -1&quot; and &quot;select_index n i k&quot;\n  shows &quot;select_index (Suc n) i (2*k+1)&quot;\nproof-\n  have &quot;((2*k+1) mod 2^(Suc n - i) ≥ 2^(n - i)) =\n(((2*k+1) div 2) mod 2^(n - i) ≥ 2^(n-1-i))&quot;\n  proof-\n    have &quot;2*k+1 &lt; 2^(n + 1)&quot;\n      using assms(1)\n      by (smt Suc_1 Suc_eq_plus1 Suc_le_lessD Suc_le_mono add_Suc_right distrib_left_numeral le_add_diff_inverse mult_le_mono2 nat_mult_1_right one_le_numeral one_le_power plus_1_eq_Suc power_add power_one_right)\n    moreover have &quot;i &lt; n&quot;\n      using assms(2) select_index_def\n      by (metis (no_types, hide_lams) add_cancel_left_left add_diff_inverse_nat diff_le_self div_by_1 le_antisym less_le_trans less_one mod_div_trivial not_le power_0)\n    ultimately show ?thesis\n      using select_index_div_2[of &quot;2*k+1&quot; &quot;n&quot; i] select_index_def\n      by (metis Nat.le_diff_conv2 Suc_eq_plus1 Suc_leI assms(2) diff_Suc_1 less_imp_le less_power_add_imp_div_less one_le_numeral one_le_power power_one_right)\n  qed\n  moreover have &quot;… = (k mod 2^(n - i) ≥ 2^(n-1-i))&quot; by simp\n  ultimately show ?thesis\n  proof-\n    have &quot;i ≤ Suc n -1&quot; using assms(2) select_index_def by auto\n    moreover have &quot;2*k+1 ≤ 2^(Suc n)-1&quot;\n      using assms(1) by (smt Suc_diff_1 Suc_eq_plus1 add_diff_cancel_right&#39; diff_Suc_diff_eq2 diff_diff_left diff_is_0_eq diff_mult_distrib2 le_add2 mult_2 mult_Suc_right plus_1_eq_Suc pos2 power_Suc zero_less_power)\n    ultimately show ?thesis\n      using select_index_def\n      by (metis ‹(2 ^ (n - 1 - i) ≤ (2 * k + 1) div 2 mod 2 ^ (n - i)) = (2 ^ (n - 1 - i) ≤ k mod 2 ^ (n - i))› ‹(2 ^ (n - i) ≤ (2 * k + 1) mod 2 ^ (Suc n - i)) = (2 ^ (n - 1 - i) ≤ (2 * k + 1) div 2 mod 2 ^ (n - i))› assms(2) diff_Suc_1)\n  qed\nqed\n\nlemma aux_range:\n  fixes k:: nat\n  assumes &quot;k &lt; 2^(Suc n + 1)&quot; and &quot;k ≥ 2&quot;\n  shows &quot;k = 2 ∨ k = 3 ∨ (∃l. l≥2 ∧ l≤2^(n+1)-1 ∧ (k = 2*l ∨ k = 2*l + 1))&quot;\nproof(rule disjCI)\n  assume &quot;¬ (k = 3 ∨ (∃l≥2. l ≤ 2^(n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1)))&quot;\n  have &quot;k &gt; 3 ⟶ (∃l≥2. l ≤ 2^(n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1))&quot;\n  proof\n    assume asm:&quot;k &gt; 3&quot;\n    have &quot;even k ∨ odd k&quot; by simp\n    then obtain l where &quot;k = 2*l ∨ k = 2*l+1&quot; by (meson evenE oddE)\n    moreover have &quot;l ≥ 2&quot;\n      using asm calculation by linarith\n    moreover have &quot;l ≤ 2^(n+1) - 1&quot;\n      using assms(1) by (metis Suc_diff_1 Suc_eq_plus1 calculation(1) dvd_triv_left even_Suc_div_two less_Suc_eq_le less_power_add_imp_div_less nonzero_mult_div_cancel_left pos2 power_one_right zero_less_power zero_neq_numeral)\n    ultimately show &quot;∃l≥2. l ≤ 2^(n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1)&quot; by auto\n  qed\n  then have &quot;k ≤ 2&quot;\n    using ‹¬ (k = 3 ∨ (∃l≥2. l ≤ 2 ^ (n + 1) - 1 ∧ (k = 2 * l ∨ k = 2 * l + 1)))› less_Suc_eq_le by auto\n  thus &quot;k = 2&quot;\n    using assms(2) by simp\nqed\n\nlemma select_index_with_1: (* To move in Measurement.thy *)\n  fixes n:: nat\n  assumes &quot;n ≥ 1&quot;\n  shows &quot;∀k. k &lt; 2^(n+1) ⟶ k ≥ 2 ⟶ (∃i&lt;n. select_index (n+1) i k)&quot;\n  using assms\nproof(rule nat_induct_at_least)\n  show &quot;∀k&lt; 2^(1+1). 2 ≤ k ⟶ (∃i&lt;1. select_index (1+1) i k)&quot;\n  proof-\n    have &quot;select_index 2 0 2 = True&quot;\n      using select_index_def by simp\n    moreover have &quot;select_index 2 0 3&quot;\n      using select_index_def by simp\n    ultimately show ?thesis\n      by (metis Suc_leI add_Suc_shift le_eq_less_or_eq mult_2 not_less one_add_one one_plus_numeral\nplus_1_eq_Suc power.simps(2) power_one_right semiring_norm(3) zero_less_one_class.zero_less_one)\n  qed\nnext\n  show &quot;⋀n. 1 ≤ n ⟹\n         ∀k &lt; 2^(n+1). 2 ≤ k ⟶ (∃i&lt;n. select_index (n+1) i k) ⟹\n         ∀k &lt; 2^(Suc n + 1). 2 ≤ k ⟶ (∃i&lt;Suc n. select_index (Suc n +1) i k)&quot;\n  proof-\n    fix n:: nat\n    assume asm:&quot;n ≥ 1&quot; and IH:&quot;∀k &lt; 2^(n+1). 2 ≤ k ⟶ (∃i&lt;n. select_index (n+1) i k)&quot;\n    have &quot;select_index (Suc n + 1) n 2&quot;\n    proof-\n      have &quot;select_index (Suc n) n 1&quot;\n        using select_index_def by(smt Suc_1 Suc_diff_Suc Suc_lessI add_diff_cancel_right&#39; diff_Suc_1\ndiff_commute diff_zero le_eq_less_or_eq less_Suc_eq_le nat.simps(3) nat_power_eq_Suc_0_iff\none_mod_two_eq_one plus_1_eq_Suc power_one_right zero_less_power)\n      thus ?thesis\n        using select_index_suc_even by (metis Suc_eq_plus1 less_numeral_extra(4) mult_2 not_less_less_Suc_eq one_add_one one_less_power zero_less_Suc)\n    qed\n    moreover have &quot;select_index (Suc n + 1) n 3&quot;\n    proof-\n      have &quot;select_index (Suc n) n 1&quot;\n        using select_index_def by(smt Suc_1 Suc_diff_Suc Suc_lessI add_diff_cancel_right&#39; diff_Suc_1\ndiff_commute diff_zero le_eq_less_or_eq less_Suc_eq_le nat.simps(3) nat_power_eq_Suc_0_iff\none_mod_two_eq_one plus_1_eq_Suc power_one_right zero_less_power)\n      thus ?thesis\n        using select_index_suc_odd by (metis One_nat_def Suc_eq_plus1 mult_2 numeral_3_eq_3 select_index_def)\n    qed\n    moreover have &quot;∃i&lt;Suc n. select_index (Suc n +1) i (2*k)&quot; if &quot;k ≥ 2&quot; and &quot;k ≤ 2^(n + 1)-1&quot; for k:: nat\n    proof-\n      obtain i where &quot;i&lt;n&quot; and &quot;select_index (n+1) i k&quot;\n        using IH by(metis One_nat_def Suc_diff_Suc ‹2 ≤ k› ‹k ≤ 2 ^ (n + 1) - 1› diff_zero le_imp_less_Suc pos2 zero_less_power)\n      then have &quot;select_index (Suc n +1) i (2*k)&quot;\n        using select_index_suc_even\n        by (metis One_nat_def Suc_diff_Suc add.commute diff_zero le_imp_less_Suc plus_1_eq_Suc pos2 that(2) zero_less_power)\n      thus ?thesis\n        using ‹i &lt; n› less_SucI by blast\n    qed\n    moreover have &quot;∃i&lt;Suc n. select_index (Suc n +1) i (2*k +1)&quot; if &quot;k ≥ 2&quot; and &quot;k ≤ 2^(n + 1)-1&quot; for k:: nat\n    proof-\n      obtain i where &quot;i&lt;n&quot; and &quot;select_index (n+1) i k&quot;\n        using IH by(metis One_nat_def Suc_diff_Suc ‹2 ≤ k› ‹k ≤ 2 ^ (n + 1) - 1› diff_zero le_imp_less_Suc pos2 zero_less_power)\n      then have &quot;select_index (Suc n +1) i (2*k+1)&quot;\n        using select_index_suc_odd that(2) by simp\n      thus ?thesis\n        using ‹i &lt; n› less_SucI by blast\n    qed\n    ultimately show &quot;∀k&lt; 2^(Suc n + 1). 2 ≤ k ⟶ (∃i&lt;Suc n. select_index (Suc n +1) i k)&quot;\n      using aux_range by (metis lessI)\n  qed\nqed\n</pre></div>",
        "id": 173494373,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566148047
    },
    {
        "content": "<p>and </p>\n<div class=\"codehilite\"><pre><span></span>lemma prob0_fst_qubits_index: (* To move in Measurement.thy *)\n  fixes n:: nat and v:: &quot;complex Matrix.mat&quot;\n  shows &quot;{k| k::nat. (k&lt;2^(n+1)) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)} = {0,1}&quot;\nproof(induct n)\n  case 0\n  show &quot;{k |k. k &lt; 2^(0+1) ∧ (∀i∈{0..&lt;0}. ¬ select_index (0+1) i k)} = {0,1}&quot; by auto\nnext\n  case (Suc n)\n  show &quot;⋀n. {k |k. k &lt; 2^(n+1) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)} = {0,1} ⟹\n         {k |k. k &lt; 2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n + 1) i k)} =\n         {0, 1}&quot;\n  proof-\n    fix n\n    assume IH: &quot;{k |k. k &lt; 2^(n+1) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i k)} = {0,1}&quot;\n    then have &quot;{0,1} ⊆ {k |k. k &lt; 2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n + 1) i k)}&quot;\n    proof-\n      have &quot;k &lt; 2^(n+1) ⟶ k &lt; 2^(Suc n + 1)&quot; for k::nat by simp\n      moreover have &quot;(∀i∈{0..&lt;n}. ¬ select_index (n+1) i 0) ∧ (∀i∈{0..&lt;n}. ¬ select_index (n+1) i 1)&quot;\n        using IH by auto\n      then have &quot;(∀i∈{0..&lt;n}. ¬ select_index (Suc n +1) i 0) ∧ (∀i∈{0..&lt;n}. ¬ select_index (Suc n +1) i 1)&quot;\n        using select_index_suc_odd[of 0 &quot;n+1&quot;] Suc_eq_plus1\n        by (smt One_nat_def Suc_1 add_Suc_shift add_diff_cancel_right&#39; atLeastLessThan_iff diff_diff_cancel\nle_eq_less_or_eq less_Suc_eq linorder_not_le mod_less nat_power_eq_Suc_0_iff select_index_def zero_less_power)\n      moreover have &quot;select_index (Suc n + 1) n 0 = False&quot; using select_index_def by simp\n      moreover have &quot;select_index (Suc n + 1) n 1 = False&quot; using select_index_def by simp\n      ultimately show ?thesis\n        by (smt One_nat_def Suc_1 Suc_eq_plus1 Suc_lessI atLeast0_lessThan_Suc empty_iff insertE\nmem_Collect_eq nat.simps(1) nat_power_eq_Suc_0_iff pos2 subsetI zero_less_power)\n    qed\n    moreover have &quot;{k |k. k &lt; 2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n + 1) i k)} ⊆ {0,1}&quot;\n    proof-\n      have &quot;∀k&lt;2^(Suc n +1). k ≥ 2 ⟶ (∃i&lt;Suc n. ¬ select_index (Suc n +1) i k = False)&quot;\n        using select_index_with_1[of &quot;Suc n&quot;] by (metis Suc_eq_plus1 add.commute le_add1)\n      thus ?thesis by auto\n    qed\n    ultimately show &quot;{k |k. k&lt;2^(Suc n + 1) ∧ (∀i∈{0..&lt;Suc n}. ¬ select_index (Suc n +1) i k)} = {0,1}&quot; by auto\n  qed\nqed\n</pre></div>",
        "id": 173494425,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566148107
    },
    {
        "content": "<p>Now, one can introduce the following, more general, machinery:</p>\n<div class=\"codehilite\"><pre><span></span>(* Below in iter_post_meas0, the firt argument n corresponds to the number of qubits of the system\n, and the second argument m corresponds to the number of qubits that have been measured. *)\n\nprimrec iter_post_meas0:: &quot;nat ⇒ nat ⇒ complex Matrix.mat ⇒ complex Matrix.mat&quot; where (* To move in Quantum.thy or better in a new file Measurement.thy *)\n  &quot;iter_post_meas0 n 0 v = v&quot;\n| &quot;iter_post_meas0 n (Suc m) v = post_meas0 n (iter_post_meas0 n m v) m&quot;\n\n(* iter_prob0 outputs the probability that successive measurements of the first m qubits\ngive m zeros. *)\n\ndefinition iter_prob0:: &quot;nat ⇒ nat ⇒ complex Matrix.mat ⇒ real&quot; where (* idem *)\n  &quot;iter_prob0 n m v = (∏i∈{k|k::nat. k ≤ m-1}. prob0 n (iter_post_meas0 n i v) i)&quot;\n</pre></div>",
        "id": 173494489,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566148219
    },
    {
        "content": "<p>But, it remains elusive to prove the following lemma:</p>\n<div class=\"codehilite\"><pre><span></span>lemma iter_prob0_eq: (* To do *)\n  fixes n:: nat and v:: &quot;complex Matrix.mat&quot;\n  assumes &quot;n ≥ 1&quot;\n  shows &quot;iter_prob0 (Suc n) n v = prob0_fst_qubits n v&quot; sorry\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span> <span class=\"user-mention\" data-user-id=\"228785\">@Yijun He</span></p>",
        "id": 173494515,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566148308
    },
    {
        "content": "<p>I will try to prove it tomorrow :)</p>",
        "id": 173502824,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1566164177
    },
    {
        "content": "<blockquote>\n<p>Note that instead of writing <code>∀x∈{i::nat. i &lt; 2^n}. g x = 0</code> one can write <code>∀x&lt; 2^n. g x = 0</code>.</p>\n</blockquote>\n<p>This also applies to iter_prob0, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy=\"false\">{</mo><mi>k</mi><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mo>:</mo><mo>:</mo><mi>n</mi><mi>a</mi><mi>t</mi><mi mathvariant=\"normal\">.</mi><mi>k</mi><mo>≤</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">i\\in \\{k|k::nat. k\\le m-1\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord\">.</span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span> can be writen as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>≤</mo><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i\\le m-1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">i &lt; m</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">m</span></span></span></span></p>",
        "id": 173528924,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1566206832
    },
    {
        "content": "<p>Further clean-up would be possible, especially more comments, but for now it's enough.<br>\nIt only remains to move a few things in different theories.</p>",
        "id": 173664424,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566312357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228787\">@Hanna Lachnitt</span> Do you plan to use the bitwise inner product in another formalization ? If so, It should be moved to Quantum.thy.</p>",
        "id": 173671040,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566317057
    },
    {
        "content": "<p>If we want to do Simon's algorithm at some point (period finding) it would be useful. But right now I don't see any other application.</p>",
        "id": 173671247,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1566317257
    },
    {
        "content": "<p>Maybe it will also be useful for the QFT ?<br>\nIf you agree, I will move it in Quantum.thy.</p>",
        "id": 173672310,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566318073
    },
    {
        "content": "<p>I got rid of all the things related to measurements. They are now part of  <code>Measurement.thy</code>.</p>",
        "id": 173676582,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566321254
    },
    {
        "content": "<blockquote>\n<p>Maybe it will also be useful for the QFT ?<br>\nIf you agree, I will move it in Quantum.thy.</p>\n</blockquote>\n<p>I moved your contribution on the bitwise inner product and the associated lemmas in a dedicated subsection of <code>Quantum.thy</code>.</p>",
        "id": 173681406,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566324610
    },
    {
        "content": "<p>Thanks could you add me as an author please?</p>",
        "id": 173801294,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1566399159
    },
    {
        "content": "<blockquote>\n<p>Thanks could you add me as an author please?</p>\n</blockquote>\n<p>It's already done. In front of the subsection on the bitwise inner product, which was imported from <code>Deutsch-Jozsa.thy</code> to <code>Quantum.thy</code>, I added immediately a comment with the authorship of this subsection.</p>",
        "id": 173805921,
        "sender_full_name": "Anthony Bordg",
        "timestamp": 1566402097
    },
    {
        "content": "<p>Thanks a lot :)</p>",
        "id": 173808587,
        "sender_full_name": "Hanna Lachnitt",
        "timestamp": 1566403735
    }
]