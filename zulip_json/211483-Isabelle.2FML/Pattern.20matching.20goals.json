[
    {
        "content": "<p>Hi! I'd like to do some goal-dependent branching in my tactics, but run into some issue with unification. The following is a minimal example illustrating the issue:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">ML</span><span class=\"s\">‹</span>\n<span class=\"s\">  fun strip_trueprop ((Const (@{const_name HOL.Trueprop}, _)) $ c) = c</span>\n<span class=\"s\">    | strip_trueprop c = c</span>\n\n<span class=\"s\">  val pattern = Syntax.parse_term @{context} \"?x = ?y\" |&gt; Type.strip_constraints</span>\n\n<span class=\"s\">  fun is_unifiable_pair (ctxt : Proof.context) (t0 : term) (t1 : term) =</span>\n<span class=\"s\">      Unify.unifiers (Context.Proof ctxt, Envir.empty 0, [(t0,t1)])</span>\n<span class=\"s\">   |&gt; Seq.pull</span>\n<span class=\"s\">   |&gt; Option.isSome</span>\n\n<span class=\"s\">  fun is_equality (ctxt : Proof.context) (goal : term) : bool =</span>\n<span class=\"s\">     goal |&gt; Type.strip_constraints |&gt; is_unifiable_pair ctxt pattern</span>\n\n\n<span class=\"s\">  val term0 = @{term \"x=y\"} |&gt; Type.strip_constraints</span>\n<span class=\"s\">  val term1 = Syntax.parse_term @{context} \"x=y\" |&gt; Type.strip_constraints</span>\n\n<span class=\"s\">  val compare0 = is_equality @{context} term0 (* false *)</span>\n<span class=\"s\">  val compare1 = is_equality @{context} term1 (* true  *)</span>\n<span class=\"s\">›</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹x=y›</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic‹SUBGOAL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">goal</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">_)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span>\n<span class=\"w\">     </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">strip_trueprop</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">is_equality</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span>\n<span class=\"w\">        </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">print_tac</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"s\">\"match\"</span>\n<span class=\"w\">        </span><span class=\"n\">else</span><span class=\"w\"> </span><span class=\"n\">print_tac</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"s\">\"no match\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">1›</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">(* no match *)</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 351595578,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682077189
    },
    {
        "content": "<p>Can someone explain why the match isn't succeeding in all cases?</p>",
        "id": 351595781,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682077233
    },
    {
        "content": "<p>Not an answer but a question: Why don’t you use Eisbach with its <code>match</code> method?</p>",
        "id": 351609656,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1682080339
    },
    {
        "content": "<p>I'm working in the context of a quite performance sensitive proof automation and found that circumventing Eisbach by writing tactics directly in ML both gives me more control and leads to slightly better performance.</p>",
        "id": 351611329,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682080699
    },
    {
        "content": "<p>The problem is that you only parsed the terms but did not check them. This left you with some placeholders <code>_</code> in your types, which it cannot unify against any other type other than <code>_</code> itself.<br>\nIn particular, the concrete representation of  your term <code>pattern</code> is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"HOL.eq\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s\">\"_\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"x\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"_\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"y\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"_\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>while what you actually want is this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"HOL.eq\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s\">\"?'a ⇒ ?'a ⇒ bool\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"x\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"?'a\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"y\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"?'a\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You should use <code>read_term</code> rather than <code>parse_term</code> to get a type-checked term.<br>\nIn the words of the <a href=\"https://isabelle.in.tum.de/doc/implementation.pdf\">implementation manual, page 94</a>: <code>read = parse; check</code>.</p>\n<p>Gimme a second to adapt your code...</p>",
        "id": 351612709,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1682080998
    },
    {
        "content": "<p>Wow, super.</p>",
        "id": 351613291,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682081121
    },
    {
        "content": "<p><code>Syntax.read_term</code> complains about the schematic variable, but <code>Proof_Context.read_term_pattern</code> seems to work fine?</p>",
        "id": 351613936,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682081269
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">ML</span><span class=\"s\">‹</span>\n<span class=\"s\">  val ctxt = Proof_Context.set_mode Proof_Context.mode_schematic @{context}</span>\n<span class=\"s\">  val pattern = Syntax.read_term ctxt \"(?x :: ?'a) = ?y\"</span>\n\n<span class=\"s\">  fun maxidx_of_terms terms = fold (Integer.max o Term.maxidx_of_term) terms (~1)</span>\n\n<span class=\"s\">  fun is_unifiable_pair (ctxt : Proof.context) (t0 : term) (t1 : term) =</span>\n<span class=\"s\">      Unify.unifiers (Context.Proof ctxt, Envir.empty (maxidx_of_terms [t0, t1] + 1), [(t0, t1)])</span>\n<span class=\"s\">   |&gt; Seq.pull</span>\n<span class=\"s\">   |&gt; Option.isSome</span>\n\n<span class=\"s\">  fun is_equality (ctxt : Proof.context) (goal : term) : bool =</span>\n<span class=\"s\">    goal |&gt; is_unifiable_pair ctxt pattern</span>\n\n<span class=\"s\">  val term0 = @{term \"x=y\"}</span>\n<span class=\"s\">  val term1 = Syntax.read_term @{context} \"x=y\"</span>\n\n<span class=\"s\">  val compare0 = is_equality @{context} term0 (* true *)</span>\n<span class=\"s\">  val compare1 = is_equality @{context} term1 (* true  *)</span>\n<span class=\"s\">›</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹x=y›</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic‹SUBGOAL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">goal</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">_)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span>\n<span class=\"w\">     </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">HOLogic.dest_Trueprop</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">is_equality</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span>\n<span class=\"w\">        </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">print_tac</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"s\">\"match\"</span>\n<span class=\"w\">        </span><span class=\"n\">else</span><span class=\"w\"> </span><span class=\"n\">print_tac</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"s\">\"no match\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">1›</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">(* match *)</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n</code></pre></div>",
        "id": 351615060,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1682081498
    },
    {
        "content": "<p>Awesome, thanks a lot! Is there meaningful difference between <code>read_term</code> in <code>mode_schematic</code>, and <code>Proof_Context.read_term_pattern</code>?</p>",
        "id": 351615733,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682081613
    },
    {
        "content": "<p>BTW. if you really just want to look whether some term matches the equality constant, you can simply do this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">try_bool</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">try</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">#&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Option.getOpt</span><span class=\"w\"> </span><span class=\"n\">o</span><span class=\"w\"> </span><span class=\"n\">rpair</span><span class=\"w\"> </span><span class=\"n\">false</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">is_equality</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">try_bool</span><span class=\"w\"> </span><span class=\" -Symbol\">\\&lt;^Const_fn&gt;</span><span class=\"s\">‹HOL.eq _ for _ _ =&gt; true›</span>\n</code></pre></div>",
        "id": 351616403,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1682081746
    },
    {
        "content": "<p>Thanks! No, my actual use is more complicated and will require the general version</p>",
        "id": 351616655,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682081798
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233154\">Kevin Kappelmann</span> <a href=\"#narrow/stream/211483-Isabelle.2FML/topic/Pattern.20matching.20goals/near/351615060\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">ML</span><span class=\"s\">‹</span>\n<span class=\"s\">  val ctxt = Proof_Context.set_mode Proof_Context.mode_schematic @{context}</span>\n<span class=\"s\">  val pattern = Syntax.read_term ctxt \"(?x :: ?'a) = ?y\"</span>\n\n<span class=\"s\">  fun maxidx_of_terms terms = fold (Integer.max o Term.maxidx_of_term) terms (~1)</span>\n\n<span class=\"s\">  fun is_unifiable_pair (ctxt : Proof.context) (t0 : term) (t1 : term) =</span>\n<span class=\"s\">      Unify.unifiers (Context.Proof ctxt, Envir.empty (maxidx_of_terms [t0, t1] + 1), [(t0, t1)])</span>\n<span class=\"s\">   |&gt; Seq.pull</span>\n<span class=\"s\">   |&gt; Option.isSome</span>\n\n<span class=\"s\">  fun is_equality (ctxt : Proof.context) (goal : term) : bool =</span>\n<span class=\"s\">    goal |&gt; is_unifiable_pair ctxt pattern</span>\n\n<span class=\"s\">  val term0 = @{term \"x=y\"}</span>\n<span class=\"s\">  val term1 = Syntax.read_term @{context} \"x=y\"</span>\n\n<span class=\"s\">  val compare0 = is_equality @{context} term0 (* true *)</span>\n<span class=\"s\">  val compare1 = is_equality @{context} term1 (* true  *)</span>\n<span class=\"s\">›</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹x=y›</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic‹SUBGOAL</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">goal</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"o\">_)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span>\n<span class=\"w\">     </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">HOLogic.dest_Trueprop</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">is_equality</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span>\n<span class=\"w\">        </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"n\">print_tac</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"s\">\"match\"</span>\n<span class=\"w\">        </span><span class=\"n\">else</span><span class=\"w\"> </span><span class=\"n\">print_tac</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"k\">context</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"s\">\"no match\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">1›</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">(* match *)</span>\n<span class=\"w\">  </span><span class=\"gr\">oops</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Small update: it should actually be <code>val pattern = Syntax.read_term ctxt \"(?x :: ?'a) = ?y\"</code></p>",
        "id": 351617975,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1682082046
    },
    {
        "content": "<p>Thanks again Kevin, this was very helpful</p>",
        "id": 351620660,
        "sender_full_name": "Hanno Becker",
        "timestamp": 1682082554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"570503\">Hanno Becker</span> <a href=\"#narrow/stream/211483-Isabelle.2FML/topic/Pattern.20matching.20goals/near/351615733\">said</a>:</p>\n<blockquote>\n<p>Awesome, thanks a lot! Is there meaningful difference between <code>read_term</code> in <code>mode_schematic</code>, and <code>Proof_Context.read_term_pattern</code>?</p>\n</blockquote>\n<p>There are some differences, but I do not know exactly what the differences are. One difference is that <code>mode_pattern</code> will create schematic types wherever possible whereas <code>mode_schematic</code> will create polymorphic types. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">ML</span><span class=\"s\">‹</span>\n<span class=\"s\">  val pattern1 = Proof_Context.read_term_pattern @{context} \"?x = ?y\"</span>\n<span class=\"s\">  val pattern2 = Proof_Context.read_term_schematic @{context} \"?x = ?y\"</span>\n<span class=\"s\">›</span>\n</code></pre></div>\n<p>creates the concrete terms:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">pattern1</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">   </span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"HOL.eq\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s\">\"?'a1 ⇒ ?'a1 ⇒ bool\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"x\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"?'a1\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"y\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"?'a1\"</span><span class=\"o\">)</span>\n<span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">pattern2</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">   </span><span class=\"n\">Const</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"HOL.eq\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s\">\"'a ⇒ 'a ⇒ bool\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\"> </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"x\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"'a\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"w\">  </span><span class=\"n\">Var</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"s\">\"y\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"s\">\"'a\"</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 351621070,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1682082641
    }
]