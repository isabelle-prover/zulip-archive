[
    {
        "content": "<p>Inspired by <a href=\"https://martin.kleppmann.com/2019/09/14/strange-loop-isabelle.html\">https://martin.kleppmann.com/2019/09/14/strange-loop-isabelle.html</a> and <a href=\"https://www.microsoft.com/en-us/research/publication/tla-proofs/\">https://www.microsoft.com/en-us/research/publication/tla-proofs/</a>, I made an attempt to prove a Peterson mutex.</p>\n<p>It did not go too far: <a href=\"https://gist.github.com/suhr/c13d89be9110b6c3ac8a0ffdfd422735\">https://gist.github.com/suhr/c13d89be9110b6c3ac8a0ffdfd422735</a></p>\n<p>I'm really impressed how far you can go by just applying <code>sledgehammer</code> everywhere. But you can only go so far doing so.</p>\n<p>My question is: how do you approach proving problems like this? For tiny problems proving is easy: you can always apply substitutions and rules directly if you need to. But in the case of bigger problems, definitions are rather large to substitute them into every lemma.</p>\n<p>I would also greatly appreciate any help on this particular problem.</p>",
        "id": 259063098,
        "sender_full_name": "suhr",
        "timestamp": 1635234988
    },
    {
        "content": "<p>You could try to find statements that help you on your way to your final proof, eg:</p>\n<div class=\"codehilite\"><pre><span></span><code>lemma &quot;show_this_statement&quot;\nproof (induct t)\ncase base -- this is you base case of your data type, eg &quot;case 0&quot; for t::nat\n    show ?thesis by ...\nnext\ncase step --this is your induction step, eg &quot;case (Suc t)&quot; for t::nat\n    have &quot;some_more_statements&quot; by ...\n    then show ?thesis by ...\nqed\n</code></pre></div>\n<p>You can have as many proof-steps as you like in Isar-style proofs. <br>\nDoes this help? (I don't know what exactly you want to prove)</p>",
        "id": 259065898,
        "sender_full_name": "Katharina Kreuzer",
        "timestamp": 1635236898
    },
    {
        "content": "<p>The lemma I actually want to prove is the following</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">flag_inv</span><span class=\"o\">:</span>\n  <span class=\"kp\">assumes</span> <span class=\"n\">sp</span><span class=\"o\">:</span> <span class=\"s\">\"spec m\"</span>\n  <span class=\"kp\">and</span> <span class=\"n\">dom</span><span class=\"o\">:</span> <span class=\"s\">\"i ∈ {0,1}\"</span>\n  <span class=\"kp\">shows</span> <span class=\"s\">\"pc (m t) i ∈ {a2, a3a, a3b, cs} ⟶ flag (m t) i\"</span>\n</code></pre></div>\n<p>It is an invariant about all possible behaviors of the specified system. What is basically says is that if a process <code>i</code> is in one of the given states, then the flag for a given process is set.</p>\n<p>System behaviors are modeled as functions <code>nat ⇒ state</code>, returning the system state in a given moment of time. Predicate <code>init</code> defines the<br>\nstate at the moment of time equal to zero, while relation <code>nxt</code> defines how the state <code>m t</code> is related to state <code>m (Suc t)</code>.</p>\n<p>Lemmas <code>same_flag</code>, <code>flag_a2</code> and <code>flag_a3a</code> are actually auxiliary lemmas for proving <code>flag_inv</code>. The problem is, I got stuck at <code>flag_a3a</code>.</p>\n<p>Proofs generated by <code>sledgehammer</code> for <code>same_flag</code> and <code>flag_a2</code> invoke an SMT solver, even though the definitions are mostly using just logic and equality. I suspect that my way to define things might make things harder than they should be, but I don't know how to diagnose it.</p>",
        "id": 259070187,
        "sender_full_name": "suhr",
        "timestamp": 1635239719
    },
    {
        "content": "<p>Most of the statements the smt solver and metis use are all your definitions (<code>*_def</code>). Without these definitions, the system cannot know what to reason about. What happens, if you hand in all those definitions by hand? <br>\nEither by <code>using ...</code> or you could try what happens if you say something like <code>apply (auto simp add: ...)</code></p>",
        "id": 259070752,
        "sender_full_name": "Katharina Kreuzer",
        "timestamp": 1635240110
    },
    {
        "content": "<p>I figured out two lemmas, that seem to be quite useful. But now I have a different problem:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">ninv_next</span><span class=\"o\">:</span>\n  <span class=\"kp\">assumes</span> <span class=\"n\">sp</span><span class=\"o\">:</span> <span class=\"s\">\"spec m\"</span>\n  <span class=\"kp\">and</span> <span class=\"n\">refl</span><span class=\"o\">:</span> <span class=\"s\">\"∀s. P s s\"</span>\n  <span class=\"kp\">and</span> <span class=\"n\">st</span><span class=\"o\">:</span> <span class=\"s\">\"∀s s'. ∀i ∈ {0,1}. (nall i s s' ⟶ P s s')\"</span>\n<span class=\"kp\">shows</span> <span class=\"s\">\"P (m t) (m (Suc t))\"</span>\n  <span class=\"k\">using</span> <span class=\"n\">sp</span> <span class=\"n\">refl</span> <span class=\"n\">st</span> <span class=\"n\">spec_def</span> <span class=\"n\">nxt_def</span> <span class=\"k\">by</span> <span class=\"n\">metis</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">same_flag</span><span class=\"o\">:</span>\n  <span class=\"kp\">assumes</span> <span class=\"n\">sp</span><span class=\"o\">:</span> <span class=\"s\">\"spec m\"</span>\n  <span class=\"kp\">and</span> <span class=\"n\">dom</span><span class=\"o\">:</span> <span class=\"s\">\"i ∈ {0,1}\"</span>\n  <span class=\"kp\">shows</span> <span class=\"s\">\"pc (m t) i ∈ {a1,a4} ∨ flag (m t) i = flag(m (Suc t)) i\"</span> <span class=\"o\">(</span><span class=\"kp\">is</span> <span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"o\">)</span>\n<span class=\"k\">proof</span> <span class=\"o\">-</span>\n  <span class=\"k\">let</span> <span class=\"s\">\"?P\"</span> <span class=\"o\">=</span> <span class=\"s\">\"λj s s'. pc s j ∈ {a1,a4} ∨ flag s j = flag s' j\"</span>\n  <span class=\"k\">have</span> <span class=\"n\">refl</span><span class=\"o\">:</span> <span class=\"s\">\"∀s. ?P i s s\"</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n  <span class=\"k\">have</span> <span class=\"n\">st</span><span class=\"o\">:</span> <span class=\"s\">\"∀s s'. ∀j ∈ {0,1}. (nall j s s' ⟶ ?P j s s')\"</span>\n    <span class=\"k\">using</span> <span class=\"n\">dom</span> <span class=\"n\">nall_def</span>  <span class=\"n\">n0_def</span> <span class=\"n\">n1_def</span> <span class=\"n\">n2_def</span> <span class=\"n\">n3a_def</span> <span class=\"n\">n3b_def</span> <span class=\"n\">n4_def</span> <span class=\"n\">ncs_def</span>\n    <span class=\"k\">by</span> <span class=\"n\">auto</span>\n  <span class=\"k\">show</span> <span class=\"o\">?</span><span class=\"n\">thesis</span> <span class=\"k\">using</span> <span class=\"n\">sp</span> <span class=\"n\">dom</span> <span class=\"n\">refl</span> <span class=\"n\">st</span> <span class=\"n\">ninv_next</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>Even though <code>?P i</code> satisfies both <code>refl</code> and <code>st</code>, for some reason I can't derive the conclusion that <code>?P i (m t) (m (Suc t))</code>.</p>",
        "id": 259340360,
        "sender_full_name": "suhr",
        "timestamp": 1635396702
    },
    {
        "content": "<p>In st, it should be <code>?P i</code> instead of <code>?P j</code> right?</p>\n<p>Otherwise, from the distance, that looks like finding the right instantiation for <code>P</code> fails. Try <code>ninv_next[of _ \"?P i\"]</code> instead of <code>ninv_next</code>. At least that could help you going forward. in finding the issue.</p>",
        "id": 259340926,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1635397251
    },
    {
        "content": "<p>Yes, this indeed helps. Thanks!</p>",
        "id": 259341167,
        "sender_full_name": "suhr",
        "timestamp": 1635397462
    },
    {
        "content": "<p>Is there a way to abbreviate <code>using nall_def n0_def n1_def n2_def n3a_def n3b_def n4_def ncs_def</code> into something like <code>using defs</code>?</p>",
        "id": 259344845,
        "sender_full_name": "suhr",
        "timestamp": 1635401949
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>lemmas defs = nall_def n0_def n1_def n2_def n3a_def n3b_def n4_def ncs_def\n</code></pre></div>\n<p>but it is not clear if this is really a good idea</p>",
        "id": 259345241,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1635402433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"452827\">suhr</span> has marked this topic as resolved.</p>",
        "id": 261417279,
        "sender_full_name": "Notification Bot",
        "timestamp": 1636896701
    }
]