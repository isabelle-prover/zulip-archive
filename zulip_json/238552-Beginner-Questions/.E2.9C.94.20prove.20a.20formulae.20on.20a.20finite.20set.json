[
    {
        "content": "<p>Hi all,<br>\nI have a question about proving a formula on finite sets. Isabelle can prove if I define specific sets (sets with particular values) and then write the formula. </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span> <span class=\"n\">p_list</span> <span class=\"o\">::</span> <span class=\"s\">\"nat list\"</span> <span class=\"kp\">where</span>\n<span class=\"s\">\"p_list = [1::nat,2,3,4]\"</span>\n<span class=\"k\">definition</span> <span class=\"n\">q_list</span> <span class=\"o\">::</span> <span class=\"s\">\"nat list\"</span> <span class=\"kp\">where</span>\n<span class=\"s\">\"q_list = [1::nat,2,3]\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">compare_1</span><span class=\"o\">:</span> <span class=\"s\">\"(∀i∈set(p_list).(P(i) ⟶</span>\n<span class=\"s\">          (∃j∈ set(q_list).</span>\n<span class=\"s\">              (Q(j) ∧ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))</span>\n<span class=\"s\">          )</span>\n<span class=\"s\">        )</span>\n<span class=\"s\">∧ ((∀i∈ set(p_list). P(i) ⟶ (∀i1 ∈ set(p_list)-{i}. ¬P(i1)))</span>\n<span class=\"s\">∧ (∀j∈ set(q_list). Q(j) ⟶ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))))</span>\n<span class=\"s\">⟷ (∃i∈ set(p_list).∃j∈ set(q_list).((P(i) ⟶ Q(j))</span>\n<span class=\"s\">            ∧ (∀i1∈set(p_list)-{i}.¬P(i1)) ∧ (∀j1∈set(q_list)-{j}.¬Q(j1))))\"</span>\n  <span class=\"k\">unfolding</span> <span class=\"n\">p_list_def</span> <span class=\"n\">q_list_def</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">smt</span> <span class=\"o\">(</span><span class=\"n\">z3</span><span class=\"o\">)</span> <span class=\"n\">DiffD1</span> <span class=\"n\">DiffI</span> <span class=\"n\">insert_iff</span> <span class=\"n\">list.set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span> <span class=\"n\">singletonD</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Isabelle cannot prove if I write the lemma with generic set definitions (even if I limited the cardinality).</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">test_general</span><span class=\"o\">:</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">p_list</span><span class=\"o\">::</span><span class=\"s\">\"nat list\"</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">q_list</span><span class=\"o\">::</span><span class=\"s\">\"nat list\"</span>\n  <span class=\"kp\">assumes</span> <span class=\"s\">\"card (set p_list) &lt; 3\"</span> <span class=\"kp\">and</span> <span class=\"s\">\"card (set q_list) &lt; 3\"</span> <span class=\"kp\">and</span> <span class=\"s\">\"card (set p_list) &gt; 1\"</span> <span class=\"kp\">and</span> <span class=\"s\">\"card (set q_list) &gt; 1\"</span>\n  <span class=\"kp\">shows</span> <span class=\"s\">\"(∀i∈set(p_list).(P(i) ⟶</span>\n<span class=\"s\">          (∃j∈ set(q_list).</span>\n<span class=\"s\">              (Q(j) ∧ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))</span>\n<span class=\"s\">          )</span>\n<span class=\"s\">        )</span>\n<span class=\"s\">∧ ((∀i∈ set(p_list). P(i) ⟶ (∀i1 ∈ set(p_list)-{i}. ¬P(i1)))</span>\n<span class=\"s\">∧ (∀j∈ set(q_list). Q(j) ⟶ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))))</span>\n<span class=\"s\">⟷ (∃i∈ set(p_list).∃j∈ set(q_list).((P(i) ⟶ Q(j))</span>\n<span class=\"s\">            ∧ (∀i1∈set(p_list)-{i}.¬P(i1)) ∧ (∀j1∈set(q_list)-{j}.¬Q(j1))))\"</span>\n  <span class=\"kt\">sledgehammer</span>\n</code></pre></div>\n<p>Could you explain why and give me some advice to deal with it, please?</p>",
        "id": 286708691,
        "sender_full_name": "Trinh Le Khanh",
        "timestamp": 1655643684
    },
    {
        "content": "<p>To me, the latter lemma is much harder... </p>\n<p>With concrete lists (e.g., <code>p_list = [1::nat,2,3,4]</code>), propositions involving <code>∀i∈set(p_list) ...</code> can be proved by unfolding/enumerating all possible values, which is in general easier for automatic theorem provers. In comparison, <code>card (set p_list) &lt; 3</code> gives us infinitely many possible <code>p_list</code> even though we know its length is less than 3, which makes the reasoning on \"for all\" and \"exists\" much more challenging.</p>",
        "id": 286709516,
        "sender_full_name": "Wenda Li",
        "timestamp": 1655644848
    },
    {
        "content": "<p>So you mean even if I limited the cardinality is 2 but the concrete value would unpredictable (e.g., {1,2}, {200,5000}, etc.)? <br>\nIs there any way to guide Isabelle to compute the random values for <code>p_list</code> first, then invoke them from the formula?</p>",
        "id": 286710421,
        "sender_full_name": "Trinh Le Khanh",
        "timestamp": 1655646011
    },
    {
        "content": "<p>I created a function to generate a list with concrete values and use it in the lemma, but it's still unprovable</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">finite_set_with_card_eq</span> <span class=\"o\">::</span> <span class=\"s\">\"nat ⇒ nat list\"</span> <span class=\"kp\">where</span>\n<span class=\"s\">\"finite_set_with_card_eq 0 = []\"</span> <span class=\"o\">|</span>\n<span class=\"s\">\"finite_set_with_card_eq k = [k] @ finite_set_with_card_eq (k-1)\"</span>\n\n<span class=\"kt\">value</span> <span class=\"s\">\"finite_set_with_card_eq 5\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">test_general</span><span class=\"o\">:</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">p_list</span><span class=\"o\">::</span><span class=\"s\">\"nat list\"</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">q_list</span><span class=\"o\">::</span><span class=\"s\">\"nat list\"</span>\n  <span class=\"kp\">assumes</span> <span class=\"s\">\"p_list = finite_set_with_card_eq 3\"</span> <span class=\"kp\">and</span> <span class=\"s\">\"q_list = finite_set_with_card_eq 3\"</span>\n  <span class=\"kp\">shows</span> <span class=\"s\">\"(∀i∈set(p_list).(P(i) ⟶</span>\n<span class=\"s\">          (∃j∈ set(q_list).</span>\n<span class=\"s\">              (Q(j) ∧ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))</span>\n<span class=\"s\">          )</span>\n<span class=\"s\">        )</span>\n<span class=\"s\">∧ ((∀i∈ set(p_list). P(i) ⟶ (∀i1 ∈ set(p_list)-{i}. ¬P(i1)))</span>\n<span class=\"s\">∧ (∀j∈ set(q_list). Q(j) ⟶ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))))</span>\n<span class=\"s\">⟷ (∃i∈ set(p_list).∃j∈ set(q_list).((P(i) ⟶ Q(j))</span>\n<span class=\"s\">            ∧ (∀i1∈set(p_list)-{i}.¬P(i1)) ∧ (∀j1∈set(q_list)-{j}.¬Q(j1))))\"</span>\n  <span class=\"kt\">sledgehammer</span>\n</code></pre></div>",
        "id": 286710860,
        "sender_full_name": "Trinh Le Khanh",
        "timestamp": 1655646709
    },
    {
        "content": "<p>Even in this case, Sledgehammer still needs to figure out a way to prove <code>p_list = [3, 2, 1]</code> first, which itself involves non-trivial rewriting rules. Sledgehammer itself is not yet smart enough to do that right now. </p>\n<p>We can try to treat Sledgehammer as a black box, if it fails we can then simplify the problem manually and throw it to Sledgehammer again:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">finite_set_with_card_eq</span> <span class=\"o\">::</span> <span class=\"s\">\"nat ⇒ nat list\"</span> <span class=\"kp\">where</span>\n<span class=\"s\">\"finite_set_with_card_eq 0 = []\"</span> <span class=\"o\">|</span>\n<span class=\"s\">\"finite_set_with_card_eq k = [k] @ finite_set_with_card_eq (k-1)\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">test_general</span><span class=\"o\">:</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">p_list</span><span class=\"o\">::</span><span class=\"s\">\"nat list\"</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">q_list</span><span class=\"o\">::</span><span class=\"s\">\"nat list\"</span>\n  <span class=\"kp\">assumes</span> <span class=\"s\">\"p_list = finite_set_with_card_eq 3\"</span> <span class=\"kp\">and</span> <span class=\"s\">\"q_list = finite_set_with_card_eq 3\"</span>\n  <span class=\"kp\">shows</span> <span class=\"s\">\"(∀i∈set(p_list).(P(i) ⟶</span>\n<span class=\"s\">          (∃j∈ set(q_list).</span>\n<span class=\"s\">              (Q(j) ∧ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))</span>\n<span class=\"s\">          )</span>\n<span class=\"s\">        )</span>\n<span class=\"s\">∧ ((∀i∈ set(p_list). P(i) ⟶ (∀i1 ∈ set(p_list)-{i}. ¬P(i1)))</span>\n<span class=\"s\">∧ (∀j∈ set(q_list). Q(j) ⟶ (∀j1 ∈ set(q_list)-{j}. ¬Q(j1)))))</span>\n<span class=\"s\">⟷ (∃i∈ set(p_list).∃j∈ set(q_list).((P(i) ⟶ Q(j))</span>\n<span class=\"s\">            ∧ (∀i1∈set(p_list)-{i}.¬P(i1)) ∧ (∀j1∈set(q_list)-{j}.¬Q(j1))))\"</span>\n<span class=\"k\">proof</span> <span class=\"o\">-</span>\n  <span class=\"k\">have</span> <span class=\"err\">*</span><span class=\"o\">:</span><span class=\"s\">\"p_list = [3, 2, 1]\"</span> <span class=\"s\">\"q_list = [3, 2, 1]\"</span>\n    <span class=\"k\">unfolding</span> <span class=\"n\">assms</span> <span class=\"k\">by</span> <span class=\"n\">eval</span><span class=\"o\">+</span>\n  <span class=\"k\">show</span> <span class=\"o\">?</span><span class=\"n\">thesis</span>\n    <span class=\"k\">unfolding</span> <span class=\"err\">*</span>\n    <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">smt</span> <span class=\"o\">(</span><span class=\"n\">z3</span><span class=\"o\">)</span> <span class=\"n\">DiffE</span> <span class=\"n\">DiffI</span> <span class=\"n\">insert_iff</span> <span class=\"n\">list.set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span> <span class=\"n\">singletonD</span><span class=\"o\">)</span>\n<span class=\"k\">qed</span>\n</code></pre></div>",
        "id": 286715664,
        "sender_full_name": "Wenda Li",
        "timestamp": 1655652728
    },
    {
        "content": "<p>I see. Thank you very much for your help.</p>",
        "id": 286715928,
        "sender_full_name": "Trinh Le Khanh",
        "timestamp": 1655653106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"353155\">Trinh Le Khanh</span> has marked this topic as resolved.</p>",
        "id": 286715939,
        "sender_full_name": "Notification Bot",
        "timestamp": 1655653129
    }
]