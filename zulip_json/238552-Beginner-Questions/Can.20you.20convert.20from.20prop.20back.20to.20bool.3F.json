[
    {
        "content": "<p>I am curious, would something like this be admissiable in HOL:</p>\n<div class=\"codehilite\"><pre><span></span><code>axiomatization Proptrue :: ‹prop ⇒ bool›  where\n  prop_iff_bool [simp]: ‹Trueprop (Proptrue P) ≡ P›\n</code></pre></div>\n<p>Then you can use meta-propositions in HOL ones, e.g:</p>\n<div class=\"codehilite\"><pre><span></span><code>lemma ‹Proptrue(P ⟹ Q) ⟶ (P ⟶  Q)› by(auto)\n</code></pre></div>\n<p>Sorry if this is a very dumb idea/question, I'm new to Isabelle!</p>",
        "id": 255510304,
        "sender_full_name": "Isaac Oscar Gariano",
        "timestamp": 1632971309
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Admissible_rule\">admissible</a> is not the right word in this context since your axiomatisation adds theorems about a new constant that previously were not derivable (since the constant did not exist).</p>\n<p>I suppose you are interested in whether this would introduce any inconsistencies. I think it would not but you better ask an expert on the mailing list if you want to be sure (or maybe <span class=\"user-mention\" data-user-id=\"302181\">@Simon Roßkopf</span> knows a simple argument?)</p>\n<p>In any case, it does not seem like a good idea to add such a constant. Reasoning in isar using meta level connectives is more convenient than using object level connectives.</p>",
        "id": 255552546,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1632999162
    },
    {
        "content": "<p>Yes your right, I did mean to say consistent, although now I wonder if this would be provable:</p>\n<div class=\"codehilite\"><pre><span></span><code>lemma LPropTrue:\n  fixes p :: ‹prop›\n  obtains b :: ‹bool› where ‹Trueprop b ≡ p›\nsorry\n</code></pre></div>\n<p>I have found that using the Pure/prop connectives is easier for Isar, but then I have to use the HOL versions if I want to parse a prop to HOL-only operators (e.g. I can't write ‹THE y . (P(x) ⟹ Q)›)</p>\n<p>I also wonder why the HOL operators need to have a seperate 'bool' type and why they can't just be axiomatised for 'prop'.</p>",
        "id": 255652642,
        "sender_full_name": "Isaac Oscar Gariano",
        "timestamp": 1633037798
    },
    {
        "content": "<p>Also, on a related note what got me thinking about Proptrue was me trying to make some syntax sugar, but it keeps wrapping things in Trueprop:</p>\n<div class=\"codehilite\"><pre><span></span><code>syntax &quot;_foo&quot; :: ‹prop ⇒ prop ⇒ prop&#39;› (‹⫿_›)\nparse_ast_translation ‹[(&quot;_foo&quot;, fn _ =&gt; fn [body] =&gt; body)]›\n</code></pre></div>\n<p>However <code>prop ‹⫿P›</code>, and even <code>‹(⫿(P :: prop)) :: prop›</code> reports a type error</p>\n<div class=\"codehilite\"><pre><span></span><code>Operator:  Trueprop :: bool ⇒ prop\nOperand:   P :: prop\n</code></pre></div>\n<p>Using <code>declare [[syntax_ast_trace]]</code> the AST is apparently:</p>\n<div class=\"codehilite\"><pre><span></span><code> (&quot;\\&lt;^const&gt;HOL.Trueprop&quot; (&quot;_constrain&quot; (&quot;\\&lt;^const&gt;HOL.Trueprop&quot; (&quot;_constrain&quot; P &lt;position&gt;)) &quot;\\&lt;^type&gt;prop&quot;))\n</code></pre></div>\n<p>Interstingly, if I don't use ML and instead do</p>\n<div class=\"codehilite\"><pre><span></span><code>translations &quot;⫿P&quot; ⇀ &quot;P&quot;\n</code></pre></div>\n<p>It works as expected, but that's not sufficient as I have more complicated desugarings I want to do.</p>",
        "id": 255655045,
        "sender_full_name": "Isaac Oscar Gariano",
        "timestamp": 1633038993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"447537\">Isaac Oscar Gariano</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Can.20you.20convert.20from.20prop.20back.20to.20bool.3F/near/255652642\">said</a>:</p>\n<blockquote>\n<p>Yes your right, I did mean to say consistent, although now I wonder if this would be provable:</p>\n<div class=\"codehilite\"><pre><span></span><code>lemma LPropTrue:\n  fixes p :: ‹prop›\n  obtains b :: ‹bool› where ‹Trueprop b ≡ p›\nsorry\n</code></pre></div>\n<p>I have found that using the Pure/prop connectives is easier for Isar, but then I have to use the HOL versions if I want to parse a prop to HOL-only operators (e.g. I can't write ‹THE y . (P(x) ⟹ Q)›)</p>\n<p>I also wonder why the HOL operators need to have a seperate 'bool' type and why they can't just be axiomatised for 'prop'.</p>\n</blockquote>\n<p>That lemma is unprovable. The best you can do, given your axiomatisation for <code>Proptrue</code>, is this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">axiomatization</span> <span class=\"n\">Proptrue</span> <span class=\"o\">::</span> <span class=\"err\">‹</span><span class=\"kt\">prop</span> <span class=\"err\">⇒</span> <span class=\"n\">bool</span><span class=\"err\">›</span>  <span class=\"kp\">where</span>\n  <span class=\"n\">prop_iff_bool</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]:</span> <span class=\"err\">‹</span><span class=\"n\">Trueprop</span> <span class=\"o\">(</span><span class=\"n\">Proptrue</span> <span class=\"o\">(</span><span class=\"n\">PROP</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"err\">≡</span> <span class=\"n\">PROP</span> <span class=\"n\">P</span><span class=\"err\">›</span>\n\n<span class=\"kn\">lemma</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">p</span> <span class=\"o\">::</span> <span class=\"err\">‹</span><span class=\"kt\">prop</span><span class=\"err\">›</span>\n  <span class=\"kp\">obtains</span> <span class=\"err\">‹</span><span class=\"n\">Trueprop</span> <span class=\"n\">True</span> <span class=\"err\">≡</span> <span class=\"n\">p</span><span class=\"err\">›</span> <span class=\"o\">|</span> <span class=\"err\">‹</span><span class=\"n\">Trueprop</span> <span class=\"n\">False</span> <span class=\"err\">≡</span> <span class=\"n\">p</span><span class=\"err\">›</span>\n<span class=\"k\">proof</span> <span class=\"o\">-</span>\n  <span class=\"k\">assume</span>\n    <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"s\">\"Trueprop True ≡ p ⟹ thesis\"</span> <span class=\"kp\">and</span>\n    <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"s\">\"Trueprop False ≡ p ⟹ thesis\"</span>\n  <span class=\"k\">have</span> <span class=\"n\">p_eq</span><span class=\"o\">:</span> <span class=\"s\">\"Trueprop (Proptrue p) ≡ p\"</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n  <span class=\"k\">have</span>\n    <span class=\"n\">h1'</span> <span class=\"o\">:</span> <span class=\"s\">\"Trueprop True ≡ Trueprop (Proptrue p) ⟹ thesis\"</span> <span class=\"kp\">and</span>\n    <span class=\"n\">h2'</span> <span class=\"o\">:</span> <span class=\"s\">\"Trueprop False ≡ Trueprop (Proptrue p) ⟹ thesis\"</span> <span class=\"k\">by</span>\n      <span class=\"o\">(</span><span class=\"n\">subst</span><span class=\"o\">(</span><span class=\"n\">asm</span><span class=\"o\">)</span> <span class=\"n\">p_eq</span> <span class=\"o\">|</span> <span class=\"n\">fact</span> <span class=\"n\">h1</span> <span class=\"o\">|</span> <span class=\"n\">fact</span> <span class=\"n\">h2</span><span class=\"o\">)+</span>\n  <span class=\"k\">show</span> <span class=\"n\">thesis</span>\n  <span class=\"k\">proof</span> <span class=\"o\">(</span><span class=\"n\">cases</span> <span class=\"s\">\"Proptrue p\"</span><span class=\"o\">)</span>\n    <span class=\"k\">case</span> <span class=\"n\">True</span>\n    <span class=\"k\">have</span> <span class=\"s\">\"Trueprop True ≡ Trueprop (Proptrue p)\"</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">True</span><span class=\"o\">)</span>\n    <span class=\"k\">then</span> <span class=\"k\">show</span> <span class=\"n\">thesis</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">h1'</span><span class=\"o\">)</span>\n  <span class=\"k\">next</span>\n    <span class=\"k\">case</span> <span class=\"n\">False</span>\n    <span class=\"k\">hence</span> <span class=\"s\">\"Trueprop False ≡ Trueprop (Proptrue p)\"</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n    <span class=\"k\">then</span> <span class=\"k\">show</span> <span class=\"n\">thesis</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">h2'</span><span class=\"o\">)</span>\n  <span class=\"k\">qed</span>\n<span class=\"k\">qed</span>\n</code></pre></div>",
        "id": 255662848,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1633042957
    },
    {
        "content": "<p>You can, in theory, axiomatise all HOL operators to live in <code>prop</code> but then you loose the distinction between meta-level and object level logic. You want to keep you meta logic simple and separate from your object  logic</p>",
        "id": 255663111,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1633043076
    }
]