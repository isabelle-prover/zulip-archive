[
    {
        "content": "<p>The following lemma seems obvious to me</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">card_indicator</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">::</span><span class=\"s\">\"'a set\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">::</span><span class=\"s\">\"'a ⇒ bool\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"finite U\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\">  </span><span class=\"s\">\"card { u ∈ U .   (P u)} =  (∑ u ∈ U  .  (if (P u) then 1 else 0))\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"kt\">sledgehammer</span>\n</code></pre></div>\n<p>but <code>sledgehammer</code> fails to find a proof. </p>\n<p>I was trying to mimic a Lean proof that if I have three 2-element subsets of a 4-element set <code>U</code>, then at least one element of <code>U</code> appears in at least two of them.; that proof starts out with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean4\"><pre><span></span><code><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">Type</span><span class=\"w\"> </span><span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Fintype</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">]</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">U_card</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"o\">)</span>\n<span class=\"w\"> </span><span class=\"c1\">-- `f` is an indicator function, mapping each element of `U` to the set of indices</span>\n<span class=\"w\"> </span><span class=\"c1\">-- of sets that contain that element.</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">→</span><span class=\"w\"> </span><span class=\"n\">Finset</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">))</span>\n<span class=\"w\"> </span><span class=\"c1\">-- Each of those sets contains exactly two elements.</span>\n<span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∀</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">:</span>\n<span class=\"w\"> </span><span class=\"c1\">-- There is some element `u : U` that is an element of two distinct sets:</span>\n<span class=\"w\"> </span><span class=\"c1\">-- that is, `f u` contains two distinct indices.</span>\n<span class=\"w\"> </span><span class=\"bp\">∃</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">≠</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"bp\">∧</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">:=</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"c1\">-- begin our proof</span>\n\n<span class=\"w\"> </span><span class=\"c1\">-- the elements of `U` appear in the three sets with multiplicity 6,</span>\n<span class=\"w\"> </span><span class=\"c1\">-- since each set has cardinality 2</span>\n<span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span>\n<span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span>\n\n<span class=\"w\"> </span><span class=\"c1\">-- we can also express this as a sum of sums of indicator functions;</span>\n<span class=\"w\"> </span><span class=\"c1\">-- importantly, we can swap the sum operators.</span>\n<span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Fin</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">#</span><span class=\"o\">{</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"bp\">|</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"w\"> </span><span class=\"bp\">=</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"bp\">∑</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"bp\">∈</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\"> </span><span class=\"bp\">·</span><span class=\"w\"> </span><span class=\"n\">rw</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">Finset</span><span class=\"bp\">.</span><span class=\"n\">sum_comm</span><span class=\"o\">]</span><span class=\"bp\">;</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>and it was in the line labeled <code>h2</code> that I failed, and subsequently tried to simplify down to a minimal example, which is the one above. </p>\n<p>Given how often (in probability theory, for instance), cardinalities and indicator functions are tossed around, I felt that surely this must be straightforward....but apparently it's not. I tried <code>nitpick</code> to see whether I'd stupidly missed some hypothesis in the statement of the lemma, but nothing obvious came up. </p>\n<p>I also tried changing <code>(if (P u) then 1 else 0))\"</code> to `(if (P u) then (1::nat) else 0))\" in case that nudge would help, but it had no visible effect. </p>\n<p>Can someone suggest how to make this work?</p>",
        "id": 527336953,
        "sender_full_name": "John  Hughes",
        "timestamp": 1751795848
    },
    {
        "content": "<p>sledgehammer gave me this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">card_indicator</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">::</span><span class=\"s\">\"'a set\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">::</span><span class=\"s\">\"'a ⇒ bool\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"finite U\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\">  </span><span class=\"s\">\"card { u ∈ U .   (P u)} =  (∑ u ∈ U  .  (if (P u) then 1 else 0))\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no_types</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lifting</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"n\">card_eq_sum</span>\n<span class=\"w\">      </span><span class=\"n\">sum.inter_filter</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 527337545,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1751796627
    },
    {
        "content": "<p>When I paste that in, it certainly works (and very quickly). </p>\n<p>I've just gone in and commented out the remainder of the file I was working on, and once I've done that, this tiny lemma (right at the top) can be handled by sledgehammer.  I'm not sure what's going on there, but I'm certainly happy to be able to proceed -- thank you. It's a relief to know that I didn't miss something stupid in the lemma statement. :)</p>",
        "id": 527338182,
        "sender_full_name": "John  Hughes",
        "timestamp": 1751797492
    },
    {
        "content": "<p>probably later in your file more lemmas got fed to sledgehammer so it timed out, you could have perhaps tried to increase the time limit on your sledgehammer call</p>",
        "id": 527341713,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1751801880
    },
    {
        "content": "<p>Also sledgehammer not finding a proof does not mean it's not easily provable. If you re-write the <code>card</code> to a sum (<code>subst card_eq_sum</code>) then <code>solve_direct</code> tells you that there already is a rule for this.</p>",
        "id": 527408200,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1751869977
    },
    {
        "content": "<p>Thanks, Fabian. There's a challenge for a beginner, namely, how to know that I <strong>can</strong> rewrite \"card\" to a sum.  I suppose that I could start at the very bottom of the chain of theories included in <code>Main</code> and read them all and try to remember everything I see, but it's hard to believe that this is a viable approach (esp. for those of us whose memory is already over-full and fast declining). Is there some other recommended way to know such things? </p>\n<p>Should I, for instance, say to myself \"I seem to be having trouble with <code>card</code>, so I should look at its definition, and then do a <code>find_theorems</code> and look for anything with <code>card</code> in it.\"? Or is there some other way that you use when you start to use some part of Isabelle that you're not already familiar with?</p>",
        "id": 527733060,
        "sender_full_name": "John  Hughes",
        "timestamp": 1751992237
    },
    {
        "content": "<p>If I state a lemma like that I'd think: \"surely there's something about card begin equal to a sum\" so I'd search for the pattern</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kt\">find_theorems</span><span class=\"w\"> </span><span class=\"s\">\"card _ = sum _ _\"</span>\n</code></pre></div>\n<p>But looking through a theory of a concept you're using isn't a bad idea either.</p>",
        "id": 527734225,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1751992637
    },
    {
        "content": "<p>Sledgehammer _usually_ also works well in finding lemmas, but sometimes it doesn't.</p>",
        "id": 527734512,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1751992732
    },
    {
        "content": "<p>Thanks. Can you bear with me for a few more beginner questions? </p>\n<ol>\n<li>After I write </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">card_eq_sum</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I would normally try to write something like <code>show ?thesis by sledgehammer</code>, but in this case the <code>subst</code> has changed the goal so this warns me that what I'm hoping to <code>show</code> isn't  (a refinement of) the current goal. So I end up copying the new goal and pasting it in, to get <br>\n<code>show \" (∑x∈{u ∈ U. P u}. 1) = (∑u∈U. if P u then 1 else 0) \" by sledgehammer</code>, and then I'm on my way.  But I keep wondering if there's some other way to refer to the changed goal without the copy-paste step. </p>\n<ol start=\"2\">\n<li>After I write </li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">card_eq_sum</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I might instead type <code>solve_direct</code> (something I didn't know I could do until 5 minutes ago). It tells  me that</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">current</span><span class=\"w\"> </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">solved</span><span class=\"w\"> </span><span class=\"n\">directly</span><span class=\"w\"> </span><span class=\"k\">with</span>\n<span class=\"w\">  </span><span class=\"n\">Groups_Big.comm_monoid_add_class.sum.inter_filter</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>but I'm not sure what to do with that information. Is there a common set of steps one takes to use this information? </p>\n<p>I've seen this before in cases like this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">h1</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"P 1\"</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"P 1\"</span>\n</code></pre></div>\n<p>where \"auto solve_direct\" says that the goal can be solved with <code>h1</code>. But I've never know exactly what sequence of steps I should follow to make use of this information. </p>\n<p>As I seem to often say in my questions, \"You have no idea how little I know/understand about Isabelle, so please explain it to me as if I'm in kindergarten.\"</p>\n<p>Thanks in advance.</p>",
        "id": 527737921,
        "sender_full_name": "John  Hughes",
        "timestamp": 1751993932
    },
    {
        "content": "<ol>\n<li>If you want to have a structured proof there is no nice way around it. I simply do <code>apply ...</code> for exploration, and you can even start a <code>proof</code> after a few <code>apply</code> steps (just don't do that in anything you'd want to maintain).</li>\n<li><code>solve_direct</code> tells you when the conclusion of an existing rule unifies with your current goal IIRC, i.e., you can <code>apply (rule Groups_Big.comm_monoid_add_class.sum.inter_filter)</code> (shorten the name as appropriate) to apply that rule backwards.</li>\n</ol>",
        "id": 527742474,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1751995532
    },
    {
        "content": "<p>Ah...thank you.  Perhaps <code>solve_direct</code> was an early automation tool, perhaps even pre-Isar. </p>\n<p>I've tried pretty hard to stick to what I think of as \"core Isar\" and avoid apply-scripts, just as I avoided \"asm\" when writing C-code in the 1970s. :)  Perhaps I should actually get familiar with apply-scripts, but avoiding them has worked for me so far. </p>\n<p>It seems that in the first case, I can do this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">card_eq_sum</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\" (∑x∈{u ∈ U. P u}. 1) = (∑u∈U. if P u then 1 else 0) \"</span>\n<span class=\"w\">  </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">sum.inter_filter</span><span class=\"o\">)</span><span class=\"w\">    </span><span class=\"n\">&lt;</span><span class=\"o\">--------------</span>\n<span class=\"w\">    </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"finite U\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n</code></pre></div>\n<p>where the marked line is kind of a structured-proof proxy for your <code>apply</code>.</p>",
        "id": 527750058,
        "sender_full_name": "John  Hughes",
        "timestamp": 1751998435
    }
]