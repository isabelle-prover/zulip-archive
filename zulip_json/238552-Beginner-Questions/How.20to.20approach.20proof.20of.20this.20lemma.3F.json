[
    {
        "content": "<p>I have parser combinators theory that I'm currently writing. For every parser combinator I need to prove that it does not produce any new input if it succeeded. And for most of them proofs were trivial, except one.</p>\n<p><code>many</code> combinator takes in another parser, which is guaranteed to eat input, which is why I was able to prove that this function is terminated, but I couldn’t prove that it does not produce input.</p>\n<p>At first I tried to prove it by contradiction, but that didn’t lead me anywhere. Next, I thought that induction could help me, but the inductive rule that Isabelle itself derived turned out to be of little use, since it did not reflect recursion. Attempts to formulate it myself also did not lead me anywhere, although this does not mean that it cannot be formulated.</p>\n<p>Next, I decided to try to model it through the proof of the following statement \"∃n. many'_raw p i = repeated_raw n (run_greedy p) i\". From it I was able to deduce that many does not produce input, but couldn't prove statement itself.</p>\n<p>Can you give any advice on how to approach the proof? I need to prove either <code>many'_raw_repeated_relation</code> or <code>many'_raw_is_parser</code>.</p>\n<p>Here's the <a href=\"https://github.com/remimimimimi/concrete-math/blob/main/src/ConcreteMath/ParserCombinators.thy#L539-L540\">code</a>.</p>",
        "id": 420897863,
        "sender_full_name": "Remi",
        "timestamp": 1707665032
    },
    {
        "content": "<p>which library are you importing? (which return?)</p>",
        "id": 420899662,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707666408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/How.20to.20approach.20proof.20of.20this.20lemma.3F/near/420899662\">said</a>:</p>\n<blockquote>\n<p>which library are you importing? (which return?)</p>\n</blockquote>\n<p>It's from <code>Certification_Monads.Error_Monad</code>, but those <code>return</code> and <code>error</code> are just abbreviations to <code>Inr</code> and <code>Inl</code>.</p>",
        "id": 420900328,
        "sender_full_name": "Remi",
        "timestamp": 1707666927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/How.20to.20approach.20proof.20of.20this.20lemma.3F/near/420899662\">said</a>:</p>\n<blockquote>\n<p>which library are you importing? (which return?)</p>\n</blockquote>\n<p>Sorry, haven't tested code, it apparently not working, and you'll need full file. It just requires AFP to be installed.</p>",
        "id": 420901715,
        "sender_full_name": "Remi",
        "timestamp": 1707668034
    },
    {
        "content": "<p>I have the AFP, I just needed the import :-)</p>",
        "id": 420901972,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707668224
    },
    {
        "content": "<p>What do you mean with does not respect the structure? A tried for a while and got:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\"> </span><span class=\"kn\">lemma</span>\n<span class=\"w\">   </span><span class=\"s\">\"</span><span class=\"ss\">\\&lt;exists&gt;</span><span class=\"s\">n. many'_raw p i = repeated_raw n (run_greedy p) i\"</span>\n<span class=\"w\">   </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"n\">subgoal</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">     </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">if_splits</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum.case_eq_if</span><span class=\"w\"> </span><span class=\"n\">pure_raw_def</span><span class=\"o\">)</span>\n<span class=\"w\">     </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"s\">\"run_greedy p []\"</span><span class=\"o\">)</span>\n<span class=\"w\">     </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">_</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"o\">])</span>\n<span class=\"w\">     </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">if_splits</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum.case_eq_if</span><span class=\"w\"> </span><span class=\"n\">pure_raw_def</span><span class=\"o\">)[</span><span class=\"n\">2</span><span class=\"o\">]</span>\n<span class=\"w\">     </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no_types</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">lifting</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">greedy_parser_def</span><span class=\"w\"> </span><span class=\"n\">list.size</span><span class=\"o\">(</span><span class=\"n\">3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">mem_Collect_eq</span><span class=\"w\"> </span><span class=\"n\">mem_case_prodE</span><span class=\"w\"> </span><span class=\"n\">mem_case_prodI2</span><span class=\"w\"> </span><span class=\"n\">run_greedy</span><span class=\"w\"> </span><span class=\"n\">sum.collapse</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">zero_order</span><span class=\"o\">(</span><span class=\"n\">3</span><span class=\"o\">))</span>\n<span class=\"w\">   </span><span class=\"n\">subgoal</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">p</span>\n<span class=\"w\">     </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"o\">_</span><span class=\"w\"> </span><span class=\"s\">\"Suc _\"</span><span class=\"o\">])</span><span class=\"w\"> </span><span class=\"c\">(*actually Suc n where n is coming from IH*)</span>\n<span class=\"w\">     </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">if_splits</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum.case_eq_if</span><span class=\"w\"> </span><span class=\"n\">pure_raw_def</span><span class=\"w\"> </span><span class=\"n\">map_raw_def</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(I was too lazy to go one, because I did not understand why I do not get a <code>run_greedy p (a # i)</code> out of the goal)</p>",
        "id": 420962118,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707720654
    },
    {
        "content": "<p>but I might also be missing something here</p>",
        "id": 420962172,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707720699
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"233198\">@Mathias Fleury</span> Didn't understand your question. </p>\n<p>I nitpicked goal and it found counterexample. So this lemma about relation between <code>many'_raw</code> and <code>repeated_raw</code> is poorly formulated.</p>\n<p>But that goal now auxulary, as <span class=\"user-mention\" data-user-id=\"345579\">@Mikhail Mandrykin</span> wrote proof for main lemma <code>is_parser (many'_raw)</code>!</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"is_parser (many'_raw p)\"</span><span class=\"w\"> </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">is_parser_def</span><span class=\"w\"> </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">allI</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"∀r v. many'_raw p i = Inr (r, v) ⟶ length r ≤ length i\"</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">many'_raw.induct</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"k\">thus</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">run_greedy</span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">many'_raw.simps</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fastforce</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">sum.splits</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">del</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">many'_raw.simps</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">qed</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"233198\">@Mathias Fleury</span> Thanks for help, and wonderful <code>isabelle-emacs</code>!</p>",
        "id": 421014970,
        "sender_full_name": "Remi",
        "timestamp": 1707739417
    }
]