[
    {
        "content": "<p>Dear all,</p>\n<p>I am posting this here in addition to my mailing list email from yesterday. In short, I am working on a proof, which<br>\ninducts over all abelian groups and passes to the quotient group in one of the cases during the induction step. This creates a type issue even if<br>\ngeneralizing the group itself since the types of elements of the quotient group and the original group are different. I have come up with a short minimal working example to illustrate the proof with a short sketch:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span> <span class=\"n\">Scratch</span>\n  <span class=\"kp\">imports</span> <span class=\"n\">Complex_Main</span>\n  <span class=\"s\">\"Jacobson_Basic_Algebra.Ring_Theory\"</span>\n\n<span class=\"k\">begin</span>\n\n<span class=\"k\">context</span> <span class=\"n\">abelian_group</span>\n\n<span class=\"k\">begin</span>\n\n<span class=\"c\">(* below are just examples, otherwise can't use P and Q for the factor group *)</span>\n<span class=\"k\">definition</span> <span class=\"n\">P</span> <span class=\"o\">::</span> <span class=\"s\">\"'b set ‚áí nat ‚áí bool\"</span> <span class=\"kp\">where</span>\n  <span class=\"s\">\"P A n = True\"</span>\n\n<span class=\"k\">definition</span> <span class=\"n\">Q</span> <span class=\"o\">::</span> <span class=\"s\">\"'b set ‚áí 'b set ‚áí bool\"</span> <span class=\"kp\">where</span> <span class=\"s\">\"Q A B = undefined\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">induction_sketch</span><span class=\"o\">:</span>\n  <span class=\"kp\">fixes</span> <span class=\"n\">n</span> <span class=\"o\">::</span> <span class=\"n\">nat</span>\n  <span class=\"kp\">shows</span> <span class=\"s\">\"‚àÄ A. Q A G ‚ü∂ P A n\"</span>\n<span class=\"k\">proof</span><span class=\"o\">-</span>\n  <span class=\"k\">have</span> <span class=\"s\">\"abelian_group G (‚ãÖ) ùü≠ ‚üπ (‚àÄ A. Q A G ‚ü∂ P A n)\"</span>\n  <span class=\"k\">proof</span><span class=\"o\">(</span><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">arbitrary</span><span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"s\">\"(‚ãÖ)\"</span> <span class=\"s\">\"ùü≠\"</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">nat_less_induct</span><span class=\"o\">)</span>\n    <span class=\"k\">fix</span> <span class=\"n\">n</span>\n    <span class=\"k\">fix</span> <span class=\"n\">G</span> <span class=\"o\">::</span> <span class=\"s\">\"'a set\"</span>\n    <span class=\"k\">fix</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"kp\">infixl</span> <span class=\"s\">\"‚äï\"</span> <span class=\"n\">65</span><span class=\"o\">)</span>\n    <span class=\"k\">fix</span> <span class=\"n\">unit</span> <span class=\"o\">::</span> <span class=\"s\">\"'a\"</span>\n    <span class=\"k\">assume</span> <span class=\"n\">hind</span><span class=\"o\">:</span> <span class=\"s\">\"‚àÄm&lt;n. ‚àÄx xa xb. abelian_group x xa xb ‚ü∂ (‚àÄA. Q A x ‚ü∂ P A m)\"</span>\n      <span class=\"kp\">and</span> <span class=\"n\">hgroupG</span><span class=\"o\">:</span> <span class=\"s\">\"abelian_group G add unit\"</span>\n    <span class=\"k\">interpret</span> <span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"n\">abelian_group</span> <span class=\"n\">G</span> <span class=\"n\">add</span> <span class=\"n\">unit</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">hgroupG</span><span class=\"o\">)</span>\n    <span class=\"k\">obtain</span> <span class=\"n\">K</span> <span class=\"o\">::</span> <span class=\"s\">\"'a set\"</span> <span class=\"kp\">where</span> <span class=\"n\">hK</span><span class=\"o\">:</span> <span class=\"s\">\"subgroup_of_abelian_group K G (‚äï) unit\"</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">interpret</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">subgroup_of_abelian_group</span> <span class=\"n\">K</span> <span class=\"n\">G</span> <span class=\"s\">\"(‚äï)\"</span> <span class=\"n\">unit</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">hK</span><span class=\"o\">)</span>\n    <span class=\"c\">(* below trivial *)</span>\n    <span class=\"k\">have</span> <span class=\"n\">hgroupGK</span><span class=\"o\">:</span> <span class=\"s\">\"abelian_group (G.Factor_Group G K) K.quotient_composition (K.Class unit)\"</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">obtain</span> <span class=\"n\">C</span> <span class=\"o\">::</span> <span class=\"s\">\"('a set) set\"</span> <span class=\"kp\">and</span> <span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"s\">\"nat\"</span> <span class=\"kp\">where</span> <span class=\"n\">hmn</span><span class=\"o\">:</span> <span class=\"s\">\"m &lt; n\"</span> <span class=\"kp\">and</span>\n      <span class=\"n\">hQC</span><span class=\"o\">:</span> <span class=\"s\">\"Q C (G.Factor_Group G K)\"</span> <span class=\"gr\">sorry</span>\n    <span class=\"k\">show</span> <span class=\"s\">\"(‚àÄA. Q A G ‚ü∂ P A n)\"</span>\n    <span class=\"k\">proof</span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"o\">)</span>\n      <span class=\"k\">fix</span> <span class=\"n\">A</span> <span class=\"k\">assume</span> <span class=\"s\">\"Q A G\"</span>\n      <span class=\"c\">(* claim I can prove *)</span>\n      <span class=\"k\">moreover</span> <span class=\"k\">have</span> <span class=\"s\">\"Q A G ‚üπ P C m ‚üπ P A n\"</span> <span class=\"gr\">sorry</span>\n      <span class=\"c\">(* this should be a combination of hind, hgroupGK, hQC and hmn but fails *)</span>\n      <span class=\"k\">moreover</span> <span class=\"k\">have</span> <span class=\"s\">\"P C m\"</span> <span class=\"k\">using</span> <span class=\"n\">hind</span> <span class=\"n\">hgroupGK</span> <span class=\"n\">hQC</span> <span class=\"n\">hmn</span> <span class=\"gr\">sorry</span>\n      <span class=\"k\">ultimately</span> <span class=\"k\">show</span> <span class=\"s\">\"P A n\"</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n    <span class=\"k\">qed</span>\n  <span class=\"k\">qed</span>\n  <span class=\"k\">then</span> <span class=\"k\">show</span> <span class=\"o\">?</span><span class=\"n\">thesis</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">abelian_group_axioms</span><span class=\"o\">)</span>\n<span class=\"k\">qed</span>\n\n<span class=\"k\">end</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>The problematic bit is the lines:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"c\">(* this should be a combination of hind, hgroupGK, hQC and hmn but fails *)</span>\n      <span class=\"k\">moreover</span> <span class=\"k\">have</span> <span class=\"s\">\"P C m\"</span> <span class=\"k\">using</span> <span class=\"n\">hind</span> <span class=\"n\">hgroupGK</span> <span class=\"n\">hQC</span> <span class=\"n\">hmn</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Here, I fail to be able to specialize the induction hypothesis to the quotient group because the induction hypothesis is over a  group, whose carrier is in <code>' b set</code> and the carrier of the quotient group is in <code>'a set set</code>. Thanks in advance for your help on making this work!</p>",
        "id": 294335176,
        "sender_full_name": "Mantas Baksys",
        "timestamp": 1660931723
    },
    {
        "content": "<p>Yeah I'm afraid that doesn't work. That's just a restriction of HOL's type system: you cannot do quantification over type variables.</p>\n<p>The only solution I can think of is to simply always work on groups with elements of type <code>nat</code>. I assume everything is countable in your case (otherwise you wouldn't be able to do induction), so you can simply obtain some arbitrary bijection between your group elements and some set of natural numbers and then push everything along the isomorphism. It's not great, but it works.</p>",
        "id": 294914772,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1661275825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232736\">Manuel Eberl</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Induction.20over.20a.20generalised.20type/near/294914772\">said</a>:</p>\n<blockquote>\n<p>Yeah I'm afraid that doesn't work. That's just a restriction of HOL's type system: you cannot do quantification over type variables.</p>\n<p>The only solution I can think of is to simply always work on groups with elements of type <code>nat</code>. I assume everything is countable in your case (otherwise you wouldn't be able to do induction), so you can simply obtain some arbitrary bijection between your group elements and some set of natural numbers and then push everything along the isomorphism. It's not great, but it works.</p>\n</blockquote>\n<p>Thanks for the idea! I think the induction argument should work over all groups, not just countable ones. In the actual statement of Kneser‚Äôs theorem, we just pick nonempty finite subsets A, B of the group G, which we do not a-priori assume to be countable, so the group itself may not biject with a set of naturals. If I‚Äôm getting this right, your idea is to find a fixed type, in which we could embed all (abelian) groups?</p>",
        "id": 294925226,
        "sender_full_name": "Mantas Baksys",
        "timestamp": 1661279653
    },
    {
        "content": "<p>Yeah I don't think there is such a type‚Ä¶</p>",
        "id": 294930912,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1661281988
    },
    {
        "content": "<p>If I understood you correctly, your induction step is to go from the group to some quotient group of that group?</p>",
        "id": 294931230,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1661282123
    },
    {
        "content": "<p>In that case, what you could do is to fix an arbitrary canonical representative for each of the equivalence classes and then just work with those representatives instead of the classes. This way, your <code>'a group</code> is still an <code>'a group</code> after the quotienting.</p>",
        "id": 294931447,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1661282219
    },
    {
        "content": "<p>Definitely not the nicest solution, but it should work.</p>",
        "id": 294931492,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1661282240
    },
    {
        "content": "<p>Just as a side note, I'm not an expert on this topic, but I think that even in systems that do support type-level quantification like Coq and Lean you might run into trouble here and have to employ a similar trick. But I might be wrong.</p>",
        "id": 294931991,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1661282419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232736\">Manuel Eberl</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Induction.20over.20a.20generalised.20type/near/294931447\">said</a>:</p>\n<blockquote>\n<p>In that case, what you could do is to fix an arbitrary canonical representative for each of the equivalence classes and then just work with those representatives instead of the classes. This way, your <code>'a group</code> is still an <code>'a group</code> after the quotienting.</p>\n</blockquote>\n<p>Thanks, this indeed looks like a possible solution, I will try to implement it soon</p>",
        "id": 294996070,
        "sender_full_name": "Mantas Baksys",
        "timestamp": 1661327672
    }
]