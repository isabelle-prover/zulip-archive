[
    {
        "content": "<p>Suppose I wanted to define the type of local homeomorphisms in the context of <code>Abstract_topology</code>. I cannot transform this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span> <span class=\"n\">is_chart</span> <span class=\"o\">::</span> <span class=\"s\">\"'a topology ⇒ 'e topology ⇒ 'a set ⇒ 'e set ⇒ ('a ⇒ 'e) ⇒ ('e ⇒ 'a)</span>\n<span class=\"s\">  ⇒ bool\"</span> <span class=\"kp\">where</span>\n<span class=\"s\">\"is_chart Ta Te A E f g ≡ openin Ta A ∧ openin Te E ∧</span>\n<span class=\"s\">  homeomorphic_maps (subtopology Ta A) (subtopology Te E) f g\"</span>\n</code></pre></div>\n<p>into a type with fixed topologies right? I mean using <code>typedef</code> with some trick.</p>",
        "id": 244177322,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624900821
    },
    {
        "content": "<p>I gave up on fixing the topologies, but why does this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">import</span> <span class=\"n\">Analysis.Abstract_topology</span>\n\n<span class=\"k\">definition</span> <span class=\"n\">is_chart</span> <span class=\"o\">::</span> <span class=\"s\">\"'a topology ⇒ 'e topology ⇒ 'a set ⇒ 'e set ⇒ ('a ⇒ 'e) ⇒ ('e ⇒ 'a)</span>\n<span class=\"s\">  ⇒ bool\"</span> <span class=\"kp\">where</span>\n<span class=\"s\">\"is_chart Ta Te A E f g ≡ openin Ta A ∧ openin Te E ∧</span>\n<span class=\"s\">  homeomorphic_maps (subtopology Ta A) (subtopology Te E) f g\"</span>\n\n<span class=\"kn\">typedef</span> <span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span> <span class=\"n n-Type\">'e</span><span class=\"o\">)</span> <span class=\"n\">chart</span> <span class=\"o\">=</span>\n  <span class=\"s\">\"{(Ta::'a topology, Te::'e topology, A::'a set, E::'e set, f, g).</span>\n<span class=\"s\">    is_chart Ta Te A E f g}\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"kp\">where</span> <span class=\"n\">x</span><span class=\"o\">=</span><span class=\"s\">\"(discrete_topology, discrete_topology, {}, {}, (λx. undefined),</span>\n<span class=\"s\">    (λx. undefined))\"</span><span class=\"o\">])</span> <span class=\"n\">simp</span>\n\n<span class=\"k\">setup_lifting</span> <span class=\"n\">type_definition_chart</span>\n</code></pre></div>\n<p>not work?</p>",
        "id": 244203938,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624914033
    },
    {
        "content": "<p>How about this one? </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span> <span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span> <span class=\"n n-Type\">'e</span><span class=\"o\">)</span> <span class=\"n\">chart</span> <span class=\"o\">=</span>\n  <span class=\"s\">\"{(Ta::'a topology, Te::'e topology, A::'a set, E::'e set, f, g).</span>\n<span class=\"s\">    is_chart Ta Te A E f g}\"</span>\n  <span class=\"kp\">apply</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"kp\">where</span> <span class=\"n\">x</span><span class=\"o\">=</span><span class=\"s\">\"(discrete_topology {}, discrete_topology {}, {},</span>\n<span class=\"s\">          {}, (λx. undefined),(λx. undefined))\"</span><span class=\"o\">])</span>\n  <span class=\"k\">unfolding</span> <span class=\"n\">is_chart_def</span> <span class=\"n\">homeomorphic_maps_def</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n</code></pre></div>",
        "id": 244244592,
        "sender_full_name": "Wenda Li",
        "timestamp": 1624953174
    },
    {
        "content": "<p>It works thank you very much! I am puzzeld though (apart from the fact that I forgot to add something after <code>discrete_topology</code>): if I write this</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span> <span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span> <span class=\"n n-Type\">'e</span><span class=\"o\">)</span> <span class=\"n\">chart</span> <span class=\"o\">=</span>\n  <span class=\"s\">\"{(Ta::'a topology, Te::'e topology, A::'a set, E::'e set, f, g).</span>\n<span class=\"s\">    is_chart Ta Te A E f g}\"</span>\n  <span class=\"kp\">apply</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"kp\">where</span> <span class=\"n\">x</span><span class=\"o\">=</span><span class=\"s\">\"(discrete_topology {}, discrete_topology {}, {},</span>\n<span class=\"s\">          {}, (λx. undefined),(λx. undefined))\"</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>and then I run sledgehammer it does not find a proof. Is it normal?</p>",
        "id": 244261896,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624963526
    },
    {
        "content": "<p>Also, <code>setup_lifting type_definition_chart</code> gives a warning </p>\n<div class=\"codehilite\"><pre><span></span><code>Generation of a parametrized correspondence relation failed.\nReason:  No relator for the type &quot;Abstract_Topology.topology&quot; found.\n</code></pre></div>\n<p>but the code works fine. Should I worry about it?</p>",
        "id": 244262056,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624963645
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244261896\">said</a>:</p>\n<blockquote>\n<p>and then I run sledgehammer it does not find a proof. Is it normal?</p>\n</blockquote>\n<p>Yes, it is normal. Sledgehammer is bad when the goal is of higher-order nature (i.e., functions as arguments). Generally, Sledgehammer is a bit unpredictable --  it may fail at some goal that appears easy to us, but sometimes it can exceed our expectation by succeeding on extremely challenging problems.</p>",
        "id": 244263205,
        "sender_full_name": "Wenda Li",
        "timestamp": 1624964361
    },
    {
        "content": "<p>Also I wonder why the last lemma in this mwe</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span> <span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span> <span class=\"n n-Type\">'e</span><span class=\"o\">)</span> <span class=\"n\">chart</span> <span class=\"o\">=</span>\n  <span class=\"s\">\"{(Ta::'a topology, Te::'e topology, A::'a set, E::'e set, f, g).</span>\n<span class=\"s\">    openin Ta A ∧ openin Te E ∧ homeomorphic_maps (subtopology Ta A) (subtopology Te E) f g}\"</span>\n  <span class=\"kp\">apply</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">exI</span><span class=\"o\">[</span><span class=\"kp\">where</span> <span class=\"n\">x</span><span class=\"o\">=</span><span class=\"s\">\"(discrete_topology {}, discrete_topology {}, {},</span>\n<span class=\"s\">          {}, (λx. undefined),(λx. undefined))\"</span><span class=\"o\">])</span>\n  <span class=\"k\">unfolding</span> <span class=\"n\">homeomorphic_maps_def</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n\n<span class=\"k\">setup_lifting</span> <span class=\"n\">type_definition_chart</span>\n\n<span class=\"kn\">lift_definition</span> <span class=\"n\">apply_chart</span><span class=\"o\">::</span><span class=\"s\">\"('a, 'e) chart ⇒ 'a ⇒ 'e\"</span>\n  <span class=\"kp\">is</span> <span class=\"s\">\"λ(Ta, Te, A, E, f, g). f\"</span> <span class=\"ow\">.</span>\n\n<span class=\"k\">declare</span> <span class=\"o\">[[</span><span class=\"n\">coercion</span> <span class=\"n\">apply_chart</span><span class=\"o\">]]</span>\n\n<span class=\"kn\">lift_definition</span> <span class=\"n\">inv_chart</span><span class=\"o\">::</span><span class=\"s\">\"('a, 'e) chart ⇒ 'e ⇒ 'a\"</span>\n  <span class=\"kp\">is</span> <span class=\"s\">\"λ(Ta, Te, A, E, f, g). g\"</span> <span class=\"ow\">.</span>\n\n<span class=\"kn\">lift_definition</span> <span class=\"n\">source_topology</span><span class=\"o\">::</span><span class=\"s\">\"('a, 'e) chart ⇒ 'a topology\"</span>\n  <span class=\"kp\">is</span> <span class=\"s\">\"λ(Ta, Te, A, E, f, g). Ta\"</span> <span class=\"ow\">.</span>\n\n<span class=\"kn\">lift_definition</span> <span class=\"n\">range_topology</span><span class=\"o\">::</span><span class=\"s\">\"('a, 'e) chart ⇒ 'e topology\"</span>\n  <span class=\"kp\">is</span> <span class=\"s\">\"λ(Ta, Te, A, E, f, g). Te\"</span> <span class=\"ow\">.</span>\n\n<span class=\"kn\">lift_definition</span> <span class=\"k\">domain</span><span class=\"o\">::</span><span class=\"s\">\"('a, 'e) chart ⇒ 'a set\"</span>\n  <span class=\"kp\">is</span> <span class=\"s\">\"λ(Ta, Te, A, E, f, g). A\"</span> <span class=\"ow\">.</span>\n\n<span class=\"kn\">lift_definition</span> <span class=\"n\">codomain</span><span class=\"o\">::</span><span class=\"s\">\"('a, 'e) chart ⇒ 'e set\"</span>\n  <span class=\"kp\">is</span> <span class=\"s\">\"λ(Ta, Te, A, E, f, g). E\"</span> <span class=\"ow\">.</span>\n\n\n<span class=\"gu\">subsection</span> <span class=\"err\">‹</span><span class=\"n\">Properties</span><span class=\"err\">›</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">open_domain</span><span class=\"o\">[</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">]:</span> <span class=\"s\">\"openin (source_topology c) (domain c)\"</span>\n  <span class=\"kp\">and</span> <span class=\"n\">open_codomain</span><span class=\"o\">[</span><span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">]:</span> <span class=\"s\">\"openin (range_topology c) (codomain c)\"</span>\n  <span class=\"kp\">and</span> <span class=\"n\">chart_homeomorphism</span><span class=\"o\">:</span> <span class=\"s\">\"homeomorphic_maps (subtopology (source_topology c) (domain c))</span>\n<span class=\"s\">    (subtopology (range_topology c) (codomain c)) c (inv_chart c)\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">transfer</span><span class=\"o\">,</span> <span class=\"n\">auto</span><span class=\"o\">)+</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">at_within_domain</span><span class=\"o\">:</span> <span class=\"s\">\"at x within domain c = at x\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"x ∈ domain c\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">at_within_open</span><span class=\"o\">[</span><span class=\"n\">OF</span> <span class=\"n\">that</span> <span class=\"n\">open_domain</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>does not work...</p>",
        "id": 244263231,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624964381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246083\">Wenda Li</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244263205\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244261896\">said</a>:</p>\n<blockquote>\n<p>and then I run sledgehammer it does not find a proof. Is it normal?</p>\n</blockquote>\n<p>Yes, it is normal. Sledgehammer is bad when the goal is of higher-order nature (i.e., functions as arguments). Generally, Sledgehammer is a bit unpredictable --  it may fail at some goal that appears easy to us, but sometimes it can exceed our expectation by succeeding on extremely challenging problems.</p>\n</blockquote>\n<p>Ok thank you very much!</p>",
        "id": 244263341,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624964420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244262056\">said</a>:</p>\n<blockquote>\n<p>Also, <code>setup_lifting type_definition_chart</code> gives a warning </p>\n<div class=\"codehilite\"><pre><span></span><code>Generation of a parametrized correspondence relation failed.\nReason:  No relator for the type &quot;Abstract_Topology.topology&quot; found.\n</code></pre></div>\n<p>but the code works fine. Should I worry about it?</p>\n</blockquote>\n<p>There might be a problem if you want to use the <strong>lift and transfer framework</strong> sometimes later. If you don't plan to use that framework, <code>setup_lifting type_definition_chart</code> is actually not necessary.</p>",
        "id": 244263554,
        "sender_full_name": "Wenda Li",
        "timestamp": 1624964556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246083\">Wenda Li</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244263554\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244262056\">said</a>:</p>\n<blockquote>\n<p>Also, <code>setup_lifting type_definition_chart</code> gives a warning </p>\n<div class=\"codehilite\"><pre><span></span><code>Generation of a parametrized correspondence relation failed.\nReason:  No relator for the type &quot;Abstract_Topology.topology&quot; found.\n</code></pre></div>\n<p>but the code works fine. Should I worry about it?</p>\n</blockquote>\n<p>There might be a problem if you want to use the <strong>lift and transfer framework</strong> sometimes later. If you don't plan to use that framework, <code>setup_lifting type_definition_chart</code> is actually not necessary.</p>\n</blockquote>\n<p>I do plan to use (you can see my use in the mwe) it but it works despite the warning!</p>",
        "id": 244263660,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624964635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244263231\">said</a>:</p>\n<blockquote>\n<p>Also I wonder why the last lemma in this mwe</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"ow\">...</span>\n</code></pre></div>\n<p>does not work...</p>\n</blockquote>\n<p>The problem is that these proofs should be super easy but Isabelle does not find them automatically and apparently I am not able to write any proof by hand, I can only use auto simp fastforce and sledgehammer</p>",
        "id": 244264130,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624964927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244263660\">said</a>:</p>\n<blockquote>\n<p>I do plan to use (you can see my use in the mwe) it but it works despite the warning!</p>\n</blockquote>\n<p>Yes, I just saw that. It is nice that <code>transfer</code> works so far. You may need to work out those relator stuff when it fails.</p>",
        "id": 244264172,
        "sender_full_name": "Wenda Li",
        "timestamp": 1624964961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246083\">Wenda Li</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244264172\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244263660\">said</a>:</p>\n<blockquote>\n<p>I do plan to use (you can see my use in the mwe) it but it works despite the warning!</p>\n</blockquote>\n<p>Yes, I just saw that. It is nice that <code>transfer</code> works so far. You may need to work out those relator stuff when it fails.</p>\n</blockquote>\n<p>Yep I would not know how to do that because I do not know either abstract topology nor the transfer package but I will ask for help here in case!</p>",
        "id": 244264340,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624965106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244264130\">said</a>:</p>\n<blockquote>\n<p>The problem is that these proofs should be super easy but Isabelle does not find them automatically and apparently I am not able to write any proof by hand, I can only use auto simp fastforce and sledgehammer</p>\n</blockquote>\n<p>That is the idea of <strong>interactive</strong> theorem proving and the difference between us and those ATPs -- we can always learn to proceed when automation fails even though we may proceed at a mush slower pace :-)</p>",
        "id": 244264412,
        "sender_full_name": "Wenda Li",
        "timestamp": 1624965136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246083\">Wenda Li</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244264412\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"370356\">Nicolò Cavalleri</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244264130\">said</a>:</p>\n<blockquote>\n<p>The problem is that these proofs should be super easy but Isabelle does not find them automatically and apparently I am not able to write any proof by hand, I can only use auto simp fastforce and sledgehammer</p>\n</blockquote>\n<p>That is the idea of <strong>interactive</strong> theorem proving and the difference between us and those ATPs -- we can always learn to proceed when automation fails even though we may proceed at a mush slower pace :-)</p>\n</blockquote>\n<p>Yeah actually I saw the problem in my proof... the theorem <code>at_within_open</code> does not apply here.</p>",
        "id": 244264662,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624965319
    },
    {
        "content": "<p>As for</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">at_within_domain</span><span class=\"o\">:</span> <span class=\"s\">\"at x within domain c = at x\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"x ∈ domain c\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">at_within_open</span><span class=\"o\">[</span><span class=\"n\">OF</span> <span class=\"n\">that</span> <span class=\"n\">open_domain</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>Your <code>at_within_open[OF that open_domain]</code> is not valid. The proof can be fixed if you can prove <code>open (domain c)</code> (I am not sure if it is provable or not):</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">at_within_domain</span><span class=\"o\">:</span> <span class=\"s\">\"at x within domain c = at x\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"x ∈ domain c\"</span>\n<span class=\"k\">proof</span> <span class=\"o\">-</span>\n  <span class=\"k\">have</span> <span class=\"s\">\"open (domain c)\"</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">then</span> <span class=\"k\">show</span> <span class=\"o\">?</span><span class=\"n\">thesis</span> <span class=\"k\">using</span> <span class=\"n\">at_within_open</span><span class=\"o\">[</span><span class=\"n\">OF</span> <span class=\"n\">that</span><span class=\"o\">]</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n<span class=\"k\">qed</span>\n</code></pre></div>",
        "id": 244264668,
        "sender_full_name": "Wenda Li",
        "timestamp": 1624965322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246083\">Wenda Li</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Local.20homeomorphism/near/244264668\">said</a>:</p>\n<blockquote>\n<p>As for</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">at_within_domain</span><span class=\"o\">:</span> <span class=\"s\">\"at x within domain c = at x\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"x ∈ domain c\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">at_within_open</span><span class=\"o\">[</span><span class=\"n\">OF</span> <span class=\"n\">that</span> <span class=\"n\">open_domain</span><span class=\"o\">])</span>\n</code></pre></div>\n<p>Your <code>at_within_open[OF that open_domain]</code> is not valid. The proof can be fixed if you can prove <code>open (domain c)</code> (I am not sure if it is true or not):</p>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">at_within_domain</span><span class=\"o\">:</span> <span class=\"s\">\"at x within domain c = at x\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"x ∈ domain c\"</span>\n<span class=\"k\">proof</span> <span class=\"o\">-</span>\n  <span class=\"k\">have</span> <span class=\"s\">\"open (domain c)\"</span> <span class=\"gr\">sorry</span>\n  <span class=\"k\">then</span> <span class=\"k\">show</span> <span class=\"o\">?</span><span class=\"n\">thesis</span> <span class=\"k\">using</span> <span class=\"n\">at_within_open</span><span class=\"o\">[</span><span class=\"n\">OF</span> <span class=\"n\">that</span><span class=\"o\">]</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n<span class=\"k\">qed</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>No I think it is not true but hopefully I should manage to recover a proof if someone who knows well Abstract topology will answer me in the thread <code>Filters in abstract topology</code></p>",
        "id": 244264775,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624965396
    },
    {
        "content": "<p>Thank you very much though!</p>",
        "id": 244264783,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1624965405
    }
]