[
    {
        "content": "<p>Hello everyone!</p>\n<p>I built a minimal working example of something else I am working on, which isolates a problem that I have:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"s\">\"Test\"</span>\n<span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">dat1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">NConst</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">NSum</span><span class=\"w\"> </span><span class=\"s\">\"dat2 list\"</span>\n<span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">dat2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">PlusOne</span><span class=\"w\"> </span><span class=\"n\">dat1</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PlusTwo</span><span class=\"w\"> </span><span class=\"n\">dat1</span>\n\n<span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n\">eval1_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"((nat ⇒ nat) ⇒ dat1 ⇒ nat)\"</span>\n<span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n\">eval2_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"((nat ⇒ nat) ⇒ dat2 ⇒ nat)\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">evall</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"((nat ⇒ nat) ⇒ dat2 ⇒ nat) ⇒ (nat ⇒ nat) ⇒ dat2 list ⇒ nat\"</span>\n<span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"evall ev v [] = 0\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"evall ev v (e # Θ) = (ev v e) + (evall ev v Θ)\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">eval_list_cong</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">fundef_cong</span><span class=\"o\">]:</span>\n<span class=\"w\">  </span><span class=\"s\">\"⟦ v1 = v2; Θ1 = Θ2; ⋀e. e ∈ set Θ1 ⟹ ev1 v1 e = ev2 v2 e ⟧</span>\n<span class=\"s\">  ⟹ evall ev1 v1 Θ1 = evall ev2 v2 Θ2\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">Θ1</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Θ2</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n\n<span class=\"kn\">function</span><span class=\"w\"> </span><span class=\"n\">eval1</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">eval1_type</span>\n<span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">eval2</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">eval2_type</span>\n<span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"eval1 v (NConst i) = v i\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"eval1 v (NSum Θ) = (evall eval2 v Θ)\"</span>\n\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"eval2 v (PlusOne e) = (eval1 v e) + 1\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"eval2 v (PlusTwo e) = (eval1 v e) + 2\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">pat_completeness</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"kn\">termination</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">relation</span><span class=\"w\"> </span><span class=\"s\">\"measure (λk. (case k of</span>\n<span class=\"s\">    Inl(v, e) ⇒ size e |</span>\n<span class=\"s\">    Inr(v, e) ⇒ size e))\"</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I need to do a manual termination proof because my actual piece of work relies on a more complex lexicographic termination order. And suppose I want to outsource the <code>evall</code> function.<br>\nThe problem that arises now is that Isabelle does not know that the argument <code>e ∈ Θ</code> can be considered smaller than<code>Θ</code> (sorry).</p>\n<p>I suppose this requires an adjustment of the measure function that somehow enters the list recursion from the recursion over <code>dat1</code> and <code>dat2</code>. But how would I do that exactly?</p>\n<p>Best,<br>\nMarvin</p>",
        "id": 471474450,
        "sender_full_name": "Marvin Brieger",
        "timestamp": 1726748646
    },
    {
        "content": "<p>If you simplify that proof obligation you see that all that is missing is the fact that <code>size e ≤ size_list size Θ</code>. This is obviously true, and you can prove it e.g. with an auxiliary lemma. Or just ad-hoc using induction:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">termination</span><span class=\"w\"> </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">relation</span><span class=\"w\"> </span><span class=\"s\">\"measure (λ(v, e) ⇒ size e)\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">goal_cases</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"n\">Θ</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">hence</span><span class=\"w\"> </span><span class=\"s\">\"size e ≤ size_list size Θ\"</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">Θ</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">thus</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n</code></pre></div>",
        "id": 471537925,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1726768703
    }
]