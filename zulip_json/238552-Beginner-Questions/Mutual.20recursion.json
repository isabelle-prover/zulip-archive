[
    {
        "content": "<p>I'm trying to build two mutually recursive datatypes. The broad notion is that new \"lines\" are created by naming two points that are on them, and new \"points\" are created by naming two lines that should contain the new point (thus making the lines 'meet'). I have two versions of the code, simplified down to illustrate a particular problem. (The use of \"real\" here, for example,  is to avoid talking about an <code>'a  'b fpoint</code>, and similarly for <code>fline</code>.)</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">MWE4</span>\n<span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Complex_Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"c\">(* Successful, but not what I wanted *)</span>\n<span class=\"k\">datatype</span><span class=\"w\">  </span><span class=\"n\">fpoint1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BaseP</span><span class=\"w\"> </span><span class=\"s\">\"real\"</span><span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">NewP</span><span class=\"w\"> </span><span class=\"s\">\"fline1\"</span><span class=\"w\"> </span><span class=\"s\">\"fline1\"</span>\n<span class=\"kp\">and</span><span class=\"w\">  </span><span class=\"n\">fline1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BaseL</span><span class=\"w\"> </span><span class=\"s\">\"real\"</span><span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">NewL</span><span class=\"w\"> </span><span class=\"s\">\"fpoint1\"</span><span class=\"w\"> </span><span class=\"s\">\"fpoint1\"</span>\n\n<span class=\"c\">(* Closer, but unsuccessful *)</span>\n<span class=\"k\">datatype</span><span class=\"w\">  </span><span class=\"n\">fpoint</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BaseP</span><span class=\"w\"> </span><span class=\"s\">\"real\"</span><span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">NewP</span><span class=\"w\"> </span><span class=\"s\">\"fline set\"</span>\n<span class=\"kp\">and</span><span class=\"w\">  </span><span class=\"n\">fline</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BaseL</span><span class=\"w\"> </span><span class=\"s\">\"real\"</span><span class=\"w\">  </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">NewL</span><span class=\"w\"> </span><span class=\"s\">\"fpoint set\"</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>The first says that a point can be either something we started with ('BaseP') or created from two existing lines, and similarly for lines. The problem with this is equality: I want the point <code>NewP k n</code> to be the same as <code>NewP n k</code>. So I thought \"rather than separating the two points, I could put them in a set, because in general <code>{n,k} = {k,n}</code>. The second datatype description tries this, but produces an error: *</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Unsupported</span><span class=\"w\"> </span><span class=\"n\">recursive</span><span class=\"w\"> </span><span class=\"n\">occurrence</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"s\">\"fline\"</span><span class=\"w\"> </span><span class=\"n\">via</span>\n<span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">constructor</span><span class=\"w\"> </span><span class=\"s\">\"Set.set\"</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"s\">\"fline set\"</span>\n<span class=\"n\">Use</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"s\">\"bnf\"</span><span class=\"w\"> </span><span class=\"n\">command</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">register</span><span class=\"w\"> </span><span class=\"s\">\"Set.set\"</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">bounded</span>\n<span class=\"n\">natural</span><span class=\"w\"> </span><span class=\"k\">functor</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">allow</span><span class=\"w\"> </span><span class=\"n\">nested</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">co</span><span class=\"o\">)</span><span class=\"n\">recursion</span><span class=\"w\"> </span><span class=\"n\">through</span><span class=\"w\"> </span><span class=\"n\">it.</span>\n</code></pre></div>\n<p>I tried to read about the bnf command, but the only example of its <code>bd:</code> argument comes after 47 pages of documentation, and I just couldn't make sense of it. </p>\n<p>What I really want to use is a notion of an \"unordered pair\". That would be nice because it's of bounded complexity compared to an arbitrary set. And I even found that there was a notion of Upair ... but it's defined in ZF instead of HOL. </p>\n<p>Is there some easy way to define an unordered pair type in Isabelle, in a way that won't make mutually recursive datatype definitions choke? </p>\n<p>The key property is that </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"o\">((</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">((</span><span class=\"n\">c</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">&lt;</span><span class=\"o\">--</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"n\">/\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">\\/</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">/\\</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>where I'm using <code>(( . ))</code> as my imagined constructor for an unordered pair.</p>",
        "id": 499291696,
        "sender_full_name": "John  Hughes",
        "timestamp": 1739381852
    },
    {
        "content": "<p>There is also a <code>uprod</code> type in <code>HOL-Library.Uprod</code> that will work. The reason why <code>set</code> does not work is that it is unbounded. Using e.g. <code>fset</code> (finite sets) from <code>HOL-Library</code> would work</p>",
        "id": 499429924,
        "sender_full_name": "Jan van Brügge",
        "timestamp": 1739441132
    },
    {
        "content": "<p>I'll try <code>uprod</code>; thanks. A google search only sent me to the ZF version. :(</p>",
        "id": 499535286,
        "sender_full_name": "John  Hughes",
        "timestamp": 1739467345
    },
    {
        "content": "<p>I found it by grepping for <code>quotient_type</code> in the isabelle sources</p>",
        "id": 499554929,
        "sender_full_name": "Jan van Brügge",
        "timestamp": 1739472666
    }
]