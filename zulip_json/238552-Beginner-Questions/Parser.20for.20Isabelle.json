[
    {
        "content": "<p>I am wondering if there is a way to parse the syntax of Isabelle/Isar into an AST that I can implement in Isabelle/jEdit, I know that there is a parser in Isabelle/ML in the source of Isabelle, but how can I see the actual parsed tree?</p>",
        "id": 422547159,
        "sender_full_name": "Minh D",
        "timestamp": 1708492843
    },
    {
        "content": "<p>There is no parse tree - parsing is done via parsing combinators without ever creating one. As the syntax is not static but user-extensible,  parsing is dependent on the theory context.</p>\n<p>Not sure what you're trying to implement but you can view the markup tree already in jEdit in the Sidekick panel (select <code>isabelle-markup</code>).</p>",
        "id": 422565008,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1708503455
    },
    {
        "content": "<p>Just for the sake of completeness: There <em>is</em> an AST for the inner syntax. But Isar is part of the outer syntax, which indeed does not have an AST.</p>",
        "id": 422584955,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1708510709
    },
    {
        "content": "<p>Thank you both for the answers. </p>\n<blockquote>\n<p>As the syntax is not static but user-extensible, parsing is dependent on the theory context.</p>\n</blockquote>\n<p>As I am new to this, what do you mean by user-extensible? Isn't the syntax for Isabelle/Isar is already mentioned in the Isabelle/Isar reference manual?</p>\n<blockquote>\n<p>There is an AST for the inner syntax.</p>\n</blockquote>\n<p>How can I get to produce the AST for the inner syntax?</p>",
        "id": 422621872,
        "sender_full_name": "Minh D",
        "timestamp": 1708523393
    },
    {
        "content": "<p>At almost any point in an Isabelle theory, you can open an ML block and do some stuff there. Such as: declaring new commands (like <code>proof</code>, <code>lemma</code>, <code>by</code>, <code>qed</code>, <code>fun</code>), new methods (like <code>simp</code>, <code>auto</code>) etc., and when you do that you can specify a parser (in the form of a parser combinator) to parse the arguments of that command or method.</p>",
        "id": 422647423,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1708530374
    },
    {
        "content": "<p>The \"built-in\" Isar commands like \"have\", \"also\", etc. are not special in that regard. You could define your own Isar-style commands in your theories, and indeed some people do.</p>",
        "id": 422647556,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1708530416
    },
    {
        "content": "<p>The reference manual just lists the canonical pre-defined Isar commands.</p>",
        "id": 422647693,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1708530458
    },
    {
        "content": "<p>The only thing that is really fixed (as far as I am aware) is the tokenisation.</p>",
        "id": 422647873,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1708530495
    },
    {
        "content": "<p>I actually have no idea how to look at the inner syntax AST. I just know it exists because there are parse/print translations (kind of \"hooks\" that can manipulate syntax after parsing) that operate on it. Chapter 8 of the reference manual has some information about this. But this is quite obscure internal stuff that only very few Isabelle users actually care about.</p>",
        "id": 422649278,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1708530848
    },
    {
        "content": "<p>Dear <span class=\"user-mention\" data-user-id=\"689992\">@Minh D</span> </p>\n<p>Do you already know what you intend to do with the inner syntax ASTs?</p>\n<p>I have some experience in analyzing them to build AI tools for Isabelle. Perhaps I am familiar with the APIs you are searching for.</p>",
        "id": 422720036,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1708557389
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"232736\">@Manuel Eberl</span> for the detailed explanation, I finally see what it means to say \"user-extensible\" syntax for Isabelle.<br>\n<span class=\"user-mention\" data-user-id=\"644411\">@Yutaka Nagashima</span>  Thank you, it would be great if I can understand how to work around with the inner syntax AST, can I DM you?</p>",
        "id": 422737965,
        "sender_full_name": "Minh D",
        "timestamp": 1708569777
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"689992\">@Minh D</span> <br>\nSure. I have a full-time job, so please be aware that my replies may be slow.</p>",
        "id": 422895954,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1708632442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/422720036\">said</a>:</p>\n<blockquote>\n<p>Dear <span class=\"user-mention silent\" data-user-id=\"689992\">Minh D</span> </p>\n<p>Do you already know what you intend to do with the inner syntax ASTs?</p>\n<p>I have some experience in analyzing them to build AI tools for Isabelle. Perhaps I am familiar with the APIs you are searching for.</p>\n</blockquote>\n<p>Dear <span class=\"user-mention\" data-user-id=\"644411\">@Yutaka Nagashima</span> </p>\n<p>Could I get some help from you as well, please?<br>\nI have similar questions of needing a parser for Isabelle to do some source-to-source transformation.<br>\nFor instance, some search-and-replace cannot be intuitively implemented using regex only, such as replacing occurrences of variables that are not inside a lambda expression. <br>\nCould I DM you about the details?<br>\nThanks in advance!</p>\n<p>Best wishes,<br>\nChengsong</p>",
        "id": 427387296,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1710750832
    },
    {
        "content": "<p>There is some prior work on that. Some students at TUM were working on building refactoring tools for Isabelle/jEdit. As I recall they used the markup generated by PIDE, i.e. the same stuff Isabelle/jEdit uses for highlighting and annotations as well. But I honestly don't know anything about this stuff. Maybe <span class=\"user-mention\" data-user-id=\"348400\">@Fabian Huch</span>  knows?</p>",
        "id": 427400521,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1710753336
    },
    {
        "content": "<p>I don't know of any students doing that.</p>",
        "id": 427509798,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1710775141
    },
    {
        "content": "<p>Hm, someone ought to know. Sounds like the kind of thing you'd have supervised. Maybe ask Tobias.</p>",
        "id": 427769982,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1710867249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"241231\">Chengsong Tan</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/427387296\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/422720036\">said</a>:</p>\n<blockquote>\n<p>Dear <span class=\"user-mention silent\" data-user-id=\"689992\">Minh D</span> </p>\n<p>Do you already know what you intend to do with the inner syntax ASTs?</p>\n<p>I have some experience in analyzing them to build AI tools for Isabelle. Perhaps I am familiar with the APIs you are searching for.</p>\n</blockquote>\n<p>Dear <span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> </p>\n<p>Could I get some help from you as well, please?<br>\nI have similar questions of needing a parser for Isabelle to do some source-to-source transformation.<br>\nFor instance, some search-and-replace cannot be intuitively implemented using regex only, such as replacing occurrences of variables that are not inside a lambda expression. <br>\nCould I DM you about the details?<br>\nThanks in advance!</p>\n<p>Best wishes,<br>\nChengsong</p>\n</blockquote>\n<p>Sure, you can send me direct messages. It might take a bit longer to respond since I have a full-time job. </p>\n<p>However, if you are working on a non-confidential project, I think it's better to have our conversation in public. That way, others can also read the messages. They might learn something new or may know something that I don't.</p>",
        "id": 427826322,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1710889939
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 429751702,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1711493270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/427826322\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"241231\">Chengsong Tan</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/427387296\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/422720036\">said</a>:</p>\n<blockquote>\n<p>Dear <span class=\"user-mention silent\" data-user-id=\"689992\">Minh D</span> </p>\n<p>Do you already know what you intend to do with the inner syntax ASTs?</p>\n<p>I have some experience in analyzing them to build AI tools for Isabelle. Perhaps I am familiar with the APIs you are searching for.</p>\n</blockquote>\n<p>Dear <span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> </p>\n<p>Could I get some help from you as well, please?<br>\nI have similar questions of needing a parser for Isabelle to do some source-to-source transformation.<br>\nFor instance, some search-and-replace cannot be intuitively implemented using regex only, such as replacing occurrences of variables that are not inside a lambda expression. <br>\nCould I DM you about the details?<br>\nThanks in advance!</p>\n<p>Best wishes,<br>\nChengsong</p>\n</blockquote>\n<p>Sure, you can send me direct messages. It might take a bit longer to respond since I have a full-time job. </p>\n<p>However, if you are working on a non-confidential project, I think it's better to have our conversation in public. That way, others can also read the messages. They might learn something new or may know something that I don't.</p>\n</blockquote>\n<p>Yes sure, I am happy to discuss in public. Do you know of any existing Isabelle parsers? I essentially want to do some source-to-source transformations in Isabelle, and to do that I need to be able to parse the code such that I can refer to the constructs like a lemma, a conjunct in a logic formula, a subgoal, a named fact inside a lemma and etc. It would be great if there's already something that can be used out of the box. Or if you have any experience in hand-rolling such a parser and know the caveats it would be very helpful.</p>\n<p>Thanks a lot,<br>\nChengsong</p>",
        "id": 429752016,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1711493470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"241231\">@Chengsong Tan</span> </p>\n<p>Hi Chengsong,</p>\n<p>Sorry for this late reply. </p>\n<p>I do not have a monolithic framework for this. </p>\n<p>However, in my projects, I worked on source-to-source transformation, partly using a domain-specific language (DSL). </p>\n<p>The ML code I used for this resides here: <a href=\"https://github.com/data61/PSL/tree/master/SeLFiE\">https://github.com/data61/PSL/tree/master/SeLFiE</a>. <br>\nThe DSL is described in this paper: <a href=\"https://arxiv.org/abs/2010.10296\">https://arxiv.org/abs/2010.10296</a>.</p>\n<blockquote>\n<p>need to be able to parse the code such that I can refer to the constructs like a lemma, a conjunct in a logic formula, a subgoal, a named fact inside a lemma and etc.</p>\n</blockquote>\n<p>I am familiar with referring to constructs like lemmas, conjuncts in a logic formula, subgoals, and named facts inside a lemma, but in the context of Isabelle/ML.</p>\n<p>Would you prefer to work on Isabelle/ML?</p>\n<p>Regards,<br>\nYutaka</p>",
        "id": 431793066,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1712508193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/431793066\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"241231\">Chengsong Tan</span> </p>\n<p>Hi Chengsong,</p>\n<p>Sorry for this late reply. </p>\n<p>I do not have a monolithic framework for this. </p>\n<p>However, in my projects, I worked on source-to-source transformation, partly using a domain-specific language (DSL). </p>\n<p>The ML code I used for this resides here: <a href=\"https://github.com/data61/PSL/tree/master/SeLFiE\">https://github.com/data61/PSL/tree/master/SeLFiE</a>. <br>\nThe DSL is described in this paper: <a href=\"https://arxiv.org/abs/2010.10296\">https://arxiv.org/abs/2010.10296</a>.</p>\n<blockquote>\n<p>need to be able to parse the code such that I can refer to the constructs like a lemma, a conjunct in a logic formula, a subgoal, a named fact inside a lemma and etc.</p>\n</blockquote>\n<p>I am familiar with referring to constructs like lemmas, conjuncts in a logic formula, subgoals, and named facts inside a lemma, but in the context of Isabelle/ML.</p>\n<p>Would you prefer to work on Isabelle/ML?</p>\n<p>Regards,<br>\nYutaka</p>\n</blockquote>\n<p>Hi Yukata,</p>\n<p>Thanks a lot for replying!</p>\n<p>Yes I can work with Isabelle/ML, any tool that gets the job done would be great (I haven't used it though).</p>\n<p>So if I have an Isabelle theory file, what's the quickest way to set up a parser and play with it by manipulating the .thy file? </p>\n<p>I am now starting to read your paper, please feel free to tell me the best way to get started on this.</p>\n<p>Best wishes,<br>\nChengsong</p>",
        "id": 435478226,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1714084840
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"241231\">@Chengsong Tan</span> ,</p>\n<p>(Sorry for the late reply.)</p>\n<p>This might sound strange, but I believe you don't need a new parser. You can use Isabelle's default parser and manipulate the abstract (inner-)syntax tree.</p>\n<p>You previously mentioned wanting to perform source-to-source transformations, specifically \"replacing occurrences of variables that are not inside a lambda expression.\"</p>\n<p>For most cases, manipulating the inner-syntax trees should suffice.</p>\n<p>A good first step might be to familiarize yourself with the abstract syntax tree by using the ML functions in this file: <code>src/Pure/term.ML</code>.</p>\n<p>I personally found that I had to transform this datatype into a format more amenable for analysis and developed this file for that purpose: <a href=\"https://github.com/data61/PSL/blob/master/SeLFiE/SeLFiE.thy\">https://github.com/data61/PSL/blob/master/SeLFiE/SeLFiE.thy</a>.</p>",
        "id": 436784676,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1714687880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/436784676\">said</a>:</p>\n<blockquote>\n<p>Hi <span class=\"user-mention silent\" data-user-id=\"241231\">Chengsong Tan</span> ,</p>\n<p>(Sorry for the late reply.)</p>\n<p>This might sound strange, but I believe you don't need a new parser. You can use Isabelle's default parser and manipulate the abstract (inner-)syntax tree.</p>\n<p>You previously mentioned wanting to perform source-to-source transformations, specifically \"replacing occurrences of variables that are not inside a lambda expression.\"</p>\n<p>For most cases, manipulating the inner-syntax trees should suffice.</p>\n<p>A good first step might be to familiarize yourself with the abstract syntax tree by using the ML functions in this file: <code>src/Pure/term.ML</code>.</p>\n<p>I personally found that I had to transform this datatype into a format more amenable for analysis and developed this file for that purpose: <a href=\"https://github.com/data61/PSL/blob/master/SeLFiE/SeLFiE.thy\">https://github.com/data61/PSL/blob/master/SeLFiE/SeLFiE.thy</a>.</p>\n</blockquote>\n<p>Hi Yukata,</p>\n<p>Thanks a lot for your reply!<br>\nI have been looking at the file <code>term.ML</code> as well as <code>parse.ML</code>, but hvae not yet found a function   which turns a string into a theory AST, as to my understanding, there should be some sort of parser in Isaebelle that parses an entire <code>.thy</code> file, and returns a list of statements/code blocks (or AST trees), but where can I find them?</p>\n<p>Thanks a lot,<br>\nChengsong</p>",
        "id": 437351906,
        "sender_full_name": "Chengsong Tan",
        "timestamp": 1715036951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"241231\">@Chengsong Tan</span> </p>\n<blockquote>\n<p>as to my understanding, there should be some sort of parser in Isaebelle that parses an entire <code>.thy</code> file</p>\n</blockquote>\n<p><span aria-label=\"smiling face with tear\" class=\"emoji emoji-1f972\" role=\"img\" title=\"smiling face with tear\">:smiling_face_with_tear:</span></p>\n<p>Maybe the previous comments from @Fabian Huch and @Manuel Eberl could be helpful.</p>\n<p>If I understand correctly, the entire Isabelle framework does not function as you, I, and other ML enthusiasts would wish. </p>\n<p>I presume that the simple parser-AST mechanism has been traded off for a flexible user interface and ubiquitous parallelism. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n<p>On a fundamental level, I have the impression that the original Isabelle framework was built with a focus on proof (script) checking rather than on proof construction in the 1980s.</p>\n<p>And this design choice seems to permeate from low-level inference to the Isar language.</p>\n<p>On the bright side, creating a proof obligation of type 'thm' or 'Proof.state' from a string describing only the inner syntax is relatively straightforward. <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span></p>",
        "id": 437364424,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1715046969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"241231\">Chengsong Tan</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/437351906\">said</a>:</p>\n<blockquote>\n<p>I have been looking at the file <code>term.ML</code> as well as <code>parse.ML</code>, but hvae not yet found a function   which turns a string into a theory AST, as to my understanding, there should be some sort of parser in Isaebelle that parses an entire <code>.thy</code> file, and returns a list of statements/code blocks (or AST trees), but where can I find them?</p>\n</blockquote>\n<p>There is a parser that turns it into a list of statements (we call them commands). An AST does not exist conceptually, as outer syntax parsers are shallowly embedded. You can find the parser code in <code>src/Pure/Isar/token.ML</code> and <code>src/Pure/Isar/token.scala</code>.</p>",
        "id": 438010087,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1715358318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/437364424\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">If</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">understand</span><span class=\"w\"> </span><span class=\"n\">correctly</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">entire</span><span class=\"w\"> </span><span class=\"n\">Isabelle</span><span class=\"w\"> </span><span class=\"n\">framework</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"kn\">function</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"k\">ML</span><span class=\"w\"> </span><span class=\"n\">enthusiasts</span><span class=\"w\"> </span><span class=\"n\">would</span><span class=\"w\"> </span><span class=\"n\">wish.</span>\n\n<span class=\"n\">I</span><span class=\"w\"> </span><span class=\"k\">presume</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">simple</span><span class=\"w\"> </span><span class=\"n\">parser</span><span class=\"o\">-</span><span class=\"n\">AST</span><span class=\"w\"> </span><span class=\"n\">mechanism</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">been</span><span class=\"w\"> </span><span class=\"n\">traded</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">flexible</span><span class=\"w\"> </span><span class=\"n\">user</span><span class=\"w\"> </span><span class=\"n\">interface</span><span class=\"w\"> </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">ubiquitous</span><span class=\"w\"> </span><span class=\"n\">parallelism.</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"n\">thinking</span><span class=\"o\">:</span>\n</code></pre></div>\n<p>Mostly for a flexible user interface. With a shallow embedding for parsers, one still could gain that, but then you still have the problem that there is no closed set of syntax.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"644411\">Yutaka Nagashima</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/437364424\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">On</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">fundamental</span><span class=\"w\"> </span><span class=\"n\">level</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">impression</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">original</span><span class=\"w\"> </span><span class=\"n\">Isabelle</span><span class=\"w\"> </span><span class=\"n\">framework</span><span class=\"w\"> </span><span class=\"n\">was</span><span class=\"w\"> </span><span class=\"n\">built</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">focus</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">script</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">checking</span><span class=\"w\"> </span><span class=\"n\">rather</span><span class=\"w\"> </span><span class=\"n\">than</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"n\">construction</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">1980s.</span>\n</code></pre></div>\n<p>Isar was developed much later (2004 ish). The focus was human-readable proofs.  For writing proofs, one usually does not need source text transformations (especially at the time).</p>",
        "id": 438011325,
        "sender_full_name": "Fabian Huch",
        "timestamp": 1715358805
    },
    {
        "content": "<p>Hello everyone, <br>\nI am trying to implement a pluraity voting system and i have problem when adding the ballots...<br>\nI have the isabelle code below with which I want to take a sorted Preference-List (most favoured at top, least at bottom) and add a 1 which was encrypted with aencrypt from \"Game_Based_Crypto.Elgamal\" to another list. The other list has Pairs which consist of one element like the ones in the Preference-List and a second one which holds the encrypted numeric value of how many times someone voted for it:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">verifyPlurality</span><span class=\"w\"> </span><span class=\"kp\">imports</span>\n<span class=\"s\">\"Game_Based_Crypto.Elgamal\"</span>\n<span class=\"s\">\"...lot of folders.../Preference_List\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">context</span><span class=\"w\"> </span><span class=\"n\">elgamal_base</span>\n<span class=\"k\">begin</span>\n\n<span class=\"c\">(*The Preference_List is already encrypted,</span>\n<span class=\"c\"> this function takes the encrypted Preference_List finds its first element in</span>\n<span class=\"c\"> the Pair-List representing the Ballot where the votes are accumulated and adds 1</span>\n<span class=\"c\"> (encrypted 1 because of the homomorphic adding)*)</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">add_plurality_ballot</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'grp pub_key ⇒'a Preference_List ⇒ ('a × 'b) list ⇒ ('a × 'b) list\"</span>\n<span class=\"w\">    </span><span class=\"kp\">where</span>\n<span class=\"w\">    </span><span class=\"s\">\"add_plurality_ballot _ [] (s) = s\"</span><span class=\"o\">|</span>\n<span class=\"w\">    </span><span class=\"s\">\"add_plurality_ballot pk (x # xs) (s) =</span>\n<span class=\"s\">    (case find (λ(y,c). (x = y)) s of</span>\n<span class=\"s\">      None ⇒ add_plurality_ballot pk xs (s) |</span>\n<span class=\"s\">      Some (y, c) ⇒ (y,c + (aencrypt pk 1)) # remove1 (λ(a,_).a = y) s)\"</span>\n\n<span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>A Preference_List is just this with some functions: <code>type_synonym 'a Preference_List = \" 'a list\"</code><br>\nI get this error:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"n\">unification</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Variable</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"o\">::</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">one</span>\n\n<span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">application</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">incompatible</span><span class=\"w\"> </span><span class=\"n\">operand</span><span class=\"w\"> </span><span class=\"n\">type</span>\n\n<span class=\"n\">Operator</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">aencrypt</span><span class=\"w\"> </span><span class=\"n\">pk</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'grp</span><span class=\"w\"> </span><span class=\"n\">×</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">spmf</span>\n<span class=\"n\">Operand</span><span class=\"o\">:</span><span class=\"w\">   </span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">??</span><span class=\"n n-Type\">'a</span>\n\n<span class=\"n\">Coercion</span><span class=\"w\"> </span><span class=\"n\">Inference</span><span class=\"o\">:</span>\n\n<span class=\"n\">Local</span><span class=\"w\"> </span><span class=\"n\">coercion</span><span class=\"w\"> </span><span class=\"n\">insertion</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">operand</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span>\n<span class=\"n\">Variable</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"o\">::</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">one</span>\n\n<span class=\"n\">Now</span><span class=\"w\"> </span><span class=\"n\">trying</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">infer</span><span class=\"w\"> </span><span class=\"n\">coercions</span><span class=\"w\"> </span><span class=\"n\">globally.</span>\n\n<span class=\"n\">Coercion</span><span class=\"w\"> </span><span class=\"n\">inference</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span>\n<span class=\"n\">weak</span><span class=\"w\"> </span><span class=\"n\">unification</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">subtype</span><span class=\"w\"> </span><span class=\"n\">constraints</span><span class=\"w\"> </span><span class=\"n\">fails</span>\n<span class=\"n\">Clash</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"s\">\"_ × _\"</span><span class=\"w\"> </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"s\">\"_ ⇒ _\"</span>\n</code></pre></div>\n<p>I mean, I get these are not the same types but is there a way to convert one or is there an altogether different/better solution? </p>\n<p>Thank you for the help :)</p>",
        "id": 438115877,
        "sender_full_name": "Jamie",
        "timestamp": 1715440838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348400\">Fabian Huch</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/438011325\">said</a>:</p>\n<blockquote>\n<p>Isar was developed much later (2004 ish). The focus was human-readable proofs.  For writing proofs, one usually does not need source text transformations (especially at the time).</p>\n</blockquote>\n<p>Yes, Isar was developed in the 2000s, later than the original Isabelle framework. </p>\n<p>When writing the comment, I assumed that recently many people have been trying to obtain abstract-syntax trees of 'proofs' from Isabelle for machine learning. </p>\n<p>In that sense, the problem stems from the original design of Isabelle, and Isar adds another level of complexity to that. Of course, this does not imply that the designs of Isabelle or Isar were bad; they were good for allowing users to check their statements by interacting with Isabelle. </p>\n<p>However, Isabelle is not designed to produce what machine learning enthusiasts are seeking these days.</p>\n<p>(I do not know about <span class=\"user-mention\" data-user-id=\"241231\">@Chengsong Tan</span> 's motives, though. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> )</p>",
        "id": 438147464,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1715477683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"713625\">Jamie</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Parser.20for.20Isabelle/near/438115877\">said</a>:</p>\n<blockquote>\n<p>Hello everyone, <br>\nI am trying to implement a pluraity voting system and i have problem when adding the ballots...<br>\nI have the isabelle code below with which I want to take a sorted Preference-List (most favoured at top, least at bottom) and add a 1 which was encrypted with aencrypt from \"Game_Based_Crypto.Elgamal\" to another list. The other list has Pairs which consist of one element like the ones in the Preference-List and a second one which holds the encrypted numeric value of how many times someone voted for it:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">verifyPlurality</span><span class=\"w\"> </span><span class=\"kp\">imports</span>\n<span class=\"s\">\"Game_Based_Crypto.Elgamal\"</span>\n<span class=\"s\">\"...lot of folders.../Preference_List\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">context</span><span class=\"w\"> </span><span class=\"n\">elgamal_base</span>\n<span class=\"k\">begin</span>\n\n<span class=\"c\">(*The Preference_List is already encrypted,</span>\n<span class=\"c\"> this function takes the encrypted Preference_List finds its first element in</span>\n<span class=\"c\"> the Pair-List representing the Ballot where the votes are accumulated and adds 1</span>\n<span class=\"c\"> (encrypted 1 because of the homomorphic adding)*)</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">add_plurality_ballot</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'grp pub_key ⇒'a Preference_List ⇒ ('a × 'b) list ⇒ ('a × 'b) list\"</span>\n<span class=\"w\">    </span><span class=\"kp\">where</span>\n<span class=\"w\">    </span><span class=\"s\">\"add_plurality_ballot _ [] (s) = s\"</span><span class=\"o\">|</span>\n<span class=\"w\">    </span><span class=\"s\">\"add_plurality_ballot pk (x # xs) (s) =</span>\n<span class=\"s\">    (case find (λ(y,c). (x = y)) s of</span>\n<span class=\"s\">      None ⇒ add_plurality_ballot pk xs (s) |</span>\n<span class=\"s\">      Some (y, c) ⇒ (y,c + (aencrypt pk 1)) # remove1 (λ(a,_).a = y) s)\"</span>\n\n<span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>A Preference_List is just this with some functions: <code>type_synonym 'a Preference_List = \" 'a list\"</code><br>\nI get this error:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"n\">unification</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Variable</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"o\">::</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">one</span>\n\n<span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">application</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">incompatible</span><span class=\"w\"> </span><span class=\"n\">operand</span><span class=\"w\"> </span><span class=\"n\">type</span>\n\n<span class=\"n\">Operator</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">aencrypt</span><span class=\"w\"> </span><span class=\"n\">pk</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'grp</span><span class=\"w\"> </span><span class=\"n\">×</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">spmf</span>\n<span class=\"n\">Operand</span><span class=\"o\">:</span><span class=\"w\">   </span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">??</span><span class=\"n n-Type\">'a</span>\n\n<span class=\"n\">Coercion</span><span class=\"w\"> </span><span class=\"n\">Inference</span><span class=\"o\">:</span>\n\n<span class=\"n\">Local</span><span class=\"w\"> </span><span class=\"n\">coercion</span><span class=\"w\"> </span><span class=\"n\">insertion</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">operand</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span>\n<span class=\"n\">Variable</span><span class=\"w\"> </span><span class=\"n n-Type\">'grp</span><span class=\"o\">::</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">one</span>\n\n<span class=\"n\">Now</span><span class=\"w\"> </span><span class=\"n\">trying</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">infer</span><span class=\"w\"> </span><span class=\"n\">coercions</span><span class=\"w\"> </span><span class=\"n\">globally.</span>\n\n<span class=\"n\">Coercion</span><span class=\"w\"> </span><span class=\"n\">inference</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span>\n<span class=\"n\">weak</span><span class=\"w\"> </span><span class=\"n\">unification</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">subtype</span><span class=\"w\"> </span><span class=\"n\">constraints</span><span class=\"w\"> </span><span class=\"n\">fails</span>\n<span class=\"n\">Clash</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"s\">\"_ × _\"</span><span class=\"w\"> </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"s\">\"_ ⇒ _\"</span>\n</code></pre></div>\n<p>I mean, I get these are not the same types but is there a way to convert one or is there an altogether different/better solution? </p>\n<p>Thank you for the help :)</p>\n</blockquote>\n<p>Hi <span class=\"user-mention\" data-user-id=\"713625\">@Jamie</span> ,</p>\n<p>I guess this question is not so much about the ‘Parser for Isabelle.’ <br>\nSo, I suggest you open a separate question in ‘Beginner Questions’ for maximum visibility.</p>\n<p><span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 438147689,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1715477973
    }
]