[
    {
        "content": "<p>Hello, i just started learning Isabelle. Is it possible to use partial function as a parameter in theorems in Isabelle?</p>\n<p>(I want to formalise calculus book proofs to understand them better, and there functions are partial usually.)</p>",
        "id": 240167119,
        "sender_full_name": "Lessness",
        "timestamp": 1621938069
    },
    {
        "content": "<p>In Isabelle/HOL, not really because HOL is a logic of total functions. You can emulate partiality in various ways, e.g. by viewing a partial function from a type <code>'a</code> to a type <code>'b</code> as a total function <code>'a ⇒ 'b option</code>. Then you can just map everything that is supposed to be undefined to <code>None</code> and everything else to <code>Some y</code> (where <code>y</code> is the actual value).</p>\n<p>In practice, it is not very nice to work this way. The recommended approach is thus to simply do everything with total functions, track the information about what their domain is separately, and just ignore the behaviour of functions outside their intended domain. There are some constants and some notation to facilitate this, e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f \\in A\\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> means that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is a function that maps any element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to an element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>∈</mo><mi>A</mi><msub><mo>→</mo><mi>E</mi></msub><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f\\in A\\to_E B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">→</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">E</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> additionally requires <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> to map anything not in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> to the designated <code>undefined</code> value. For more information about the <code>undefined</code> value, see <a href=\"https://www.joachim-breitner.de/blog/732-Isabelle_functions__Always_total%2C_sometimes_undefined\">Joachim Breitner's blog article</a>. If you really do want to treat partiality explicitly, I would suggest this approach over the <code>option</code> one.</p>\n<p>In our analysis formalisation in the Isabelle/HOL standard library, the problem of partiality never really arises, I think. We always just do everything with total functions, but assumptions in theorems may sometimes assume that the function is only continuous/differentiable/etc. on a certain set, e.g. <code>continuous_on A f</code> means that <code>f</code> is continuous on the set <code>A</code>.</p>\n<p>You could in principle also use Isabelle/ZF. ZF (Zermelo–Fraenkel set theory) is often considered the ‘standard’ foundation for mathematics, and it does have partial functions. I cannot really say how pleasant or unpleasant it would be to do analysis with this in Isabelle/ZF, but I can say that HOL is definitely used much more in Isabelle than ZF, and certainly more developed.</p>",
        "id": 240170860,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1621940679
    },
    {
        "content": "<p>Personally I think if you're just starting to learn Isabelle, it's probably easier to start with Isabelle/HOL because there's more material. It may also be less frustrating to start with something like the prog-prove tutorial or the ‘Concrete Semantics’/‘Functional Data Structures’ books (which are free!) because you get a sense of achievement more easily than when formalising maths, in my opinion.</p>",
        "id": 240173478,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1621942350
    }
]