[
    {
        "content": "<p>Problem with pattern match and the simplifier.</p>\n<p>Hi! I've managed to make a proof that I think is more verbose than it should be. The following code states the lemma and succesfully prooves the first case.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">reduceContractStep_preserves_assets</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"s\">\"validAndPositive_state state ⟹</span>\n<span class=\"s\">   assetsInState state = assetsInReduceStepResult state (reduceContractStep env state cont)\"</span><span class=\"w\"></span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">cont</span><span class=\"o\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"validAndPositive_state state\"</span><span class=\"w\"> </span><span class=\"s\">\"cont = Close\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"s\">\"accounts state\"</span><span class=\"o\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">Nil</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">next</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fix</span><span class=\"w\"> </span><span class=\"n\">refundPay</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">AccountNotEmpty</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"accounts state = (Cons refundPay rest)\"</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">accId</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"accId = fst (fst refundPay)\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">tok</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"tok = snd (fst refundPay)\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">money</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"money = snd refundPay\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"n\">patternMatch</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"refundPay = ((accId, tok), money)\"</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">accId_def</span><span class=\"w\"> </span><span class=\"n\">money_def</span><span class=\"w\"> </span><span class=\"n\">tok_def</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c\">(* How do I improve the pattern matching of refundPay?</span>\n<span class=\"c\">        I would like to define something like this:</span>\n<span class=\"c\">          define accId tok money where \"((accId, tok), money) ≡ refundPay\"</span>\n<span class=\"c\">        Or</span>\n<span class=\"c\">            let \"((accId, tok), money)\" = refundPay</span>\n<span class=\"c\">        (This fails for pattern match Clash)</span>\n<span class=\"c\">        Or</span>\n<span class=\"c\">          assume AccountNotEmpty: \"accounts state = (Cons refundPay rest)\"</span>\n<span class=\"c\">    *)</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"money &gt; 0\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">AccountNotEmpty</span><span class=\"w\"> </span><span class=\"n\">PositiveAccounts.allAccountsPositiveState.elims</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">PositiveAccounts.validAndPositive_state.elims</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"n\">allAccountsPositiveMeansFirstIsPositive</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"w\"> </span><span class=\"n\">AccountNotEmpty</span><span class=\"w\"> </span><span class=\"n\">patternMatch</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">next</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The first thing that surprised me was that I had to manually add the <code>validAndPositive_state state</code> restriction in the <code>Case_Close</code> assumption, for some reason, the <code>?thesis</code> variable does not include it.</p>\n<p>The second thing has to do with pattern matching. In the <code>Cons case</code>, which I stated as the <code>AccountNotEmpty</code> assumption, I tried to pattern match on <code>refundPay</code> to prove that if the state is valid, then the money in the payment is positive, and then prove the <code>?thesis</code> for the lemma. The previous code works but is too verbose, and any attempt to pattern match the <code>refundPay</code> constructor fails for a different reason. How can I improve this proof?</p>",
        "id": 323036345,
        "sender_full_name": "Hernán Rajchert",
        "timestamp": 1674484788
    },
    {
        "content": "<p>For pattern-matching: you should use <code>obtain</code></p>",
        "id": 323061173,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1674490836
    },
    {
        "content": "<p>Thanks, with obtain I was able to express it like this, which is clearer</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">reduceContractStep_preserves_assets</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"s\">\"validAndPositive_state state ⟹</span>\n<span class=\"s\">   assetsInState state = assetsInReduceStepResult state (reduceContractStep env state cont)\"</span><span class=\"w\"></span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">cont</span><span class=\"o\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"validAndPositive_state state\"</span><span class=\"w\"> </span><span class=\"s\">\"cont = Close\"</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"s\">\"accounts state\"</span><span class=\"o\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">Nil</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">next</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fix</span><span class=\"w\"> </span><span class=\"n\">refundPay</span><span class=\"w\"> </span><span class=\"n\">rest</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">AccountNotEmpty</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"accounts state = (Cons refundPay rest)\"</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">accId</span><span class=\"w\"> </span><span class=\"n\">tok</span><span class=\"w\"> </span><span class=\"n\">money</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">patternMatch</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"((accId, tok), money) = refundPay\"</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">Product_Type.prod.exhaust_sel</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"money &gt; 0\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">AccountNotEmpty</span><span class=\"w\"> </span><span class=\"n\">PositiveAccounts.allAccountsPositiveState.elims</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">PositiveAccounts.validAndPositive_state.elims</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"n\">allAccountsPositiveMeansFirstIsPositive</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"w\"> </span><span class=\"n\">AccountNotEmpty</span><span class=\"w\"> </span><span class=\"n\">patternMatch</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">next</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 323077480,
        "sender_full_name": "Hernán Rajchert",
        "timestamp": 1674494968
    },
    {
        "content": "<p>On the initial part of the question, how can I set an assumption or premise part of the proof facts \"from here on\" so I don't have to reference it every time with <code>using</code>?</p>",
        "id": 323118005,
        "sender_full_name": "Hernán Rajchert",
        "timestamp": 1674507940
    },
    {
        "content": "<p>You cannot. You can combine assumptions in a single name however:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">note</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Case_Close</span><span class=\"w\"> </span><span class=\"n\">AccountNotEmpty</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but not sure that this is helping here</p>",
        "id": 323167162,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1674537585
    },
    {
        "content": "<p>BTW, I would write the <code>patternMatch</code> the otherway arround <code> patternMatch: \"refundPay = ((accId, tok), money)\"</code> to make it simplifier compatible</p>",
        "id": 323167267,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1674537648
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"551600\">Hernán Rajchert</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Problem.20with.20pattern.20match.20and.20the.20simplifier.2E/near/323036345\">said</a>:</p>\n<blockquote>\n<p>The first thing that surprised me was that I had to manually add the <code>validAndPositive_state state</code> restriction in the <code>Case_Close</code> assumption, for some reason, the <code>?thesis</code> variable does not include it.</p>\n</blockquote>\n<p>I think that <code>cases</code> doesn’t pass down facts it is fed with; so you just have to reference said facts where you actually need them within the proof by case distinction. It is different for <code>induction</code>. The <code>induction</code> method generates dedicated goals for the different cases (therefore you use <code>?case</code>, not <code>?thesis</code>). These dedicated goals would typically not fit facts from outside the proof by induction; therefore, <code>induction</code> is capable of receiving facts, which it then adapts and passes down to the different cases.</p>",
        "id": 323385919,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1674609189
    },
    {
        "content": "<p>Thanks! This helps me understand the refinement process. I did notice that induction includes the premises while cases doesn't</p>",
        "id": 323485947,
        "sender_full_name": "Hernán Rajchert",
        "timestamp": 1674653617
    },
    {
        "content": "<p>To go a bit deeper: <code>cases</code> introduces equality constraints as extra facts for the different cases and this way specializes the goal according to the different cases. The <code>induction</code> method cannot do that. The intuitive reason is that if it would link a case to the general statement via equality constraints, it would only talk about the first layer of the induction, while it has to talk about all those layers (you can apply induction steps arbitrarily often). The solution is to generate case-specific goals, accessible via <code>?case</code>, and this then necessitates the generation of case-specific premises. The <code>induction</code> methods does both of that; for the latter you have to pass outside premises to it. With <code>cases</code>, on the other hand, using your outside premises in conjunction with the equality constraints that <code>cases</code> generates for the different cases will do the job.</p>",
        "id": 323511830,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1674659848
    }
]