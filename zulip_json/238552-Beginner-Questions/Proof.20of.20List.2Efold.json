[
    {
        "content": "<p>What I want to achieve is the distributive:  <code>\\sum{j=1,n}. (aj * bj + aj * cj) = \\sum{j=1, n}. aj * (bj + cj) </code> . Here I abstract a b c as list.</p>\n<p>I already defined the distributive <code>lemma left_commute : theorem ?x ⋅ (?a + ?b) = ?x ⋅ ?a + ?x ⋅ ?b</code>, but stuck at above proof.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"'a list\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"x * (a + b) = x * a + x * b\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">local.distrib_left</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n = 1 ⟹</span>\n<span class=\"s\">  List.fold (+) (map2 (*) r x) a + List.fold (+) (map2 (*) r y) a = List.fold (+) (map2 (*) r (map2 (+) x y)) a\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"n\">vec_def</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">local.add.left_commute</span><span class=\"w\"> </span><span class=\"n\">local.add_comm</span><span class=\"w\"> </span><span class=\"n\">local.distrib_left</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"</span>\n<span class=\"s\">  List.fold (+) x a + List.fold (+) y a = List.fold (+) (x@y) a\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">local.add.left_commute</span><span class=\"w\"> </span><span class=\"n\">local.fold_plus_sum_list_rev</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n &gt; 1 ⟹</span>\n<span class=\"s\">  List.fold (+) (map2 (*) r x) a + List.fold (+) (map2 (*) r y) a = List.fold (+) ((map2 (*) r x) @ (map2 (*) r y))  a\"</span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">c2</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">presburger</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c4</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n &gt; 1 ⟹</span>\n<span class=\"s\">  length (map2 (*) r x) = length (map2 (*) r (map2 (+) x y))\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vec_def</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c5</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n &gt; 1 ⟹</span>\n<span class=\"s\">  List.fold (+) ((map2 (*) r x) @ (map2 (*) r y))  a = List.fold (+)  (map2 (*) r (map2 (+) x y)) a\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"n\">vec_def</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"gr\">oops</span>\n</code></pre></div>\n<p>Intuitively, the proof is straightforward, but i find the problem might lie on isabelle can not expend it throughly.</p>\n<p>Any help would be appreciated.</p>",
        "id": 419143781,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706744297
    },
    {
        "content": "<p>can you post your entire theory file, including the statement you want to prove? in general, you probably shouldn't be defining your own <code>sum</code> unless you're doing it for learning purposes</p>",
        "id": 419154115,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1706750561
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Sym_Regular_Algebra</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\">  </span><span class=\"s\">\"Regular_Algebras.Regular_Algebras\"</span><span class=\"w\"> </span><span class=\"n\">Matrix.Utility</span><span class=\"w\"> </span><span class=\"n\">Matrix.Matrix_Legacy</span>\n<span class=\"k\">begin</span>\n\n\n<span class=\"k\">type_synonym</span><span class=\"w\">  </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">Matrix</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"'a list list\"</span>\n\n<span class=\"k\">context</span><span class=\"w\"> </span><span class=\"n\">Sr_algebra</span><span class=\"w\"> </span><span class=\"k\">begin</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">equations</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a vec ⇒ 'a vec ⇒ 'a\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"equations a b = (List.fold (+) (List.map2 (*) a b) 0)\"</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">ewp_vec</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a vec ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"ewp_vec v = (∀i∈set v. ¬ ewp i)\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"x * (a + b) = x * a + x * b\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">local.distrib_left</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c1</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n = 1 ⟹</span>\n<span class=\"s\">  List.fold (+) (map2 (*) r x) a + List.fold (+) (map2 (*) r y) a = List.fold (+) (map2 (*) r (map2 (+) x y)) a\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"n\">vec_def</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">local.add.left_commute</span><span class=\"w\"> </span><span class=\"n\">local.add_comm</span><span class=\"w\"> </span><span class=\"n\">local.distrib_left</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c2</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"</span>\n<span class=\"s\">  List.fold (+) x a + List.fold (+) y a = List.fold (+) (x@y) a\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">local.add.left_commute</span><span class=\"w\"> </span><span class=\"n\">local.fold_plus_sum_list_rev</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c3</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n &gt; 1 ⟹</span>\n<span class=\"s\">  List.fold (+) (map2 (*) r x) a + List.fold (+) (map2 (*) r y) a = List.fold (+) ((map2 (*) r x) @ (map2 (*) r y))  a\"</span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">c2</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">presburger</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c4</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n &gt; 1 ⟹</span>\n<span class=\"s\">  length (map2 (*) r x) = length (map2 (*) r (map2 (+) x y))\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vec_def</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c5</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ n &gt; 1 ⟹</span>\n<span class=\"s\">  List.fold (+) ((map2 (*) r x) @ (map2 (*) r y))  a = List.fold (+)  (map2 (*) r (map2 (+) x y)) a\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"n\">vec_def</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">induct</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"gr\">oops</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>What I am trying to prove is <code>lemma \"vec n a ⟹ vec n l ⟹ mat n n m1 ⟹ n &gt; 0 ⟹ ∀i∈set [0..&lt;n]. equations a (m1!i) + l!i = a!i ⟹  ∀i∈set [0..&lt;n]. ewp_vec (col m2 i) ⟹\nvec n b ⟹ vec n l ⟹ mat n n m2 ⟹ n &gt; 0 ⟹ ∀i∈set [0..&lt;n]. equations b (m2!i) + l!i = b!i ⟹  ∀i∈set [0..&lt;n]. ewp_vec (col m1 i) ⟹ ∀i∈set [0..&lt;n]. a!i = b!i\"</code>. So I have to split it into small cases.  Is there any usual way to use the sum operator?</p>",
        "id": 419182240,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706769113
    },
    {
        "content": "<blockquote>\n<p>Intuitively, the proof is straightforward, but i find the problem might lie on isabelle can not expend it throughly.</p>\n</blockquote>\n<p>Then I must have a very different intuition how such a proof would look like, because it very much looks like what I expected:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">fold_0</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹NO_MATCH 0 a ⟹ fold (+) (xs) a = fold (+) (xs) 0 + a›</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">local.add_zeror</span><span class=\"w\"> </span><span class=\"n\">local.fold_plus_sum_list_rev</span><span class=\"o\">)</span>\n\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">c5</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"vec n r ⟹ vec n x ⟹ vec n y ⟹ List.fold (+)  (map2 (*) r (map2 (+) x y)) a = List.fold (+) ((map2 (*) r x) @ (map2 (*) r y))  a\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">subgoal</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">vec_def</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">subgoal</span><span class=\"w\"> </span><span class=\"n\">premises</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"w\"> </span><span class=\"n\">rs</span>\n<span class=\"w\">    </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">)[</span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"s\">‹m-1›</span><span class=\"w\"> </span><span class=\"s\">‹tl ys›</span><span class=\"w\"> </span><span class=\"s\">‹tl rs›</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">-)</span>\n<span class=\"w\">    </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">ys;</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">rs</span><span class=\"o\">)</span>\n<span class=\"w\">       </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fold_0</span><span class=\"w\"> </span><span class=\"n\">c3</span><span class=\"w\"> </span><span class=\"n\">vec_def</span><span class=\"w\"> </span><span class=\"n\">semigroup.assoc</span><span class=\"o\">[</span><span class=\"n\">OF</span><span class=\"w\"> </span><span class=\"n\">local.add.semigroup_axioms</span><span class=\"o\">])</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">smt</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">verit</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">c2</span><span class=\"w\">  </span><span class=\"n\">local.add_comm</span><span class=\"w\"> </span><span class=\"n\">local.distrib_left</span><span class=\"w\"> </span><span class=\"n\">semigroup.assoc</span><span class=\"o\">[</span><span class=\"n\">OF</span><span class=\"w\"> </span><span class=\"n\">local.add.semigroup_axioms</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">vec_def</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n</code></pre></div>\n<p>(I was too lazy to find out what ac_simps rules apply in this algebra, so I used the very slow smt call)</p>",
        "id": 419184153,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706770440
    },
    {
        "content": "<p>And simp followed by induct is considered bad practice</p>",
        "id": 419184324,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706770551
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"234226\">@Yong Kiam</span> 's suggestion is to use the already existing:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">equations</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a vec ⇒ 'a vec ⇒ 'a\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"equations a b = sum_list (List.map2 (*) a b)\"</span>\n</code></pre></div>",
        "id": 419198404,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706777074
    },
    {
        "content": "<p>which is the best choice</p>",
        "id": 419198543,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706777135
    },
    {
        "content": "<p>Thanks a lot. It works for me enough. Another question is which would be good practice if not use induct tactic</p>",
        "id": 419204485,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706779335
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"233198\">@Mathias Fleury</span>  meant not to use <code>induct</code> right after a <code>simp</code> -- just start your proof with <code>induct</code>. The reason for this is that it will be much easier to trace the induction (after <code>simp</code>, the proof state might be very different)</p>",
        "id": 419205815,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1706779790
    },
    {
        "content": "<p>ah, I see. Thanks</p>",
        "id": 419206459,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706779999
    },
    {
        "content": "<p>BTW, the better option might be to use a newer matrix library in which the vector dot product is defined</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">text</span><span class=\"w\"> </span><span class=\"s\">‹This theory is marked as legacy, since there is a better</span>\n<span class=\"s\">  implementation of matrices available in @{file ‹../Jordan_Normal_Form/Matrix.thy›}.</span>\n<span class=\"s\">  That formalization is more abstract, more complete in terms of operations,</span>\n<span class=\"s\">  and it still provides an efficient implementation.›</span>\n</code></pre></div>",
        "id": 419206879,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1706780137
    },
    {
        "content": "<p>I will try this way, using vector dot product is exactly what I need in the lemma. Thank</p>",
        "id": 419207185,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706780236
    },
    {
        "content": "<p>Sorry to ask question again, I was stuck at <code>lemma m9: shows \"vec n r ⟹ vec n x ⟹ (sum_list (map2 (*) r x)) * z= sum_list ((map2 (*) r (map (λr. r * z) x)))\" this lemma\n</code></p>",
        "id": 419247020,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706794448
    },
    {
        "content": "<p>I believe this will again be solved if you use the newer matrix library which knows about the laws for scalar multiplication</p>",
        "id": 419249322,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1706795198
    },
    {
        "content": "<p>I am unconvinced that the newer library will help. I am sure that it is <em>better</em>, but this proof is not hard at all:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">m9</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"(sum_list (map2 (*) r x)) * z= sum_list ((map2 (*) r (map (λr. r * z) x)))\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"n\">subgoal</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"n\">subgoal</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">r</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ac_simps</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n</code></pre></div>",
        "id": 419249682,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706795312
    },
    {
        "content": "<p>From this thread, I have the impression that you do not know what arbitrary is</p>",
        "id": 419249805,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706795364
    },
    {
        "content": "<p>yes, I read the document which says that arbitrary is used to generalize. But don't know how to use it exactly</p>",
        "id": 419250099,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706795466
    },
    {
        "content": "<p>have you worked through \"Programming and Proving in Isabelle/HOL\"? this is covered by that, for example</p>",
        "id": 419251092,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1706795762
    },
    {
        "content": "<p>I have impressions about one example there, which generalized a fix value to arbitraray variable.  But is there any tricks to choose which variable needs to be generalized?  Like above lemma, x and r are both list, why induct on x and arbitrary on r. Thanks.</p>",
        "id": 419251625,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706795923
    },
    {
        "content": "<p>that comes from experience, maybe <span class=\"user-mention\" data-user-id=\"233198\">@Mathias Fleury</span> has some heuristic in this case (although I think inducting on either should work fine here)</p>",
        "id": 419251802,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1706795986
    },
    {
        "content": "<p>Thanks, Yong. Maybe need to write more isabelle code to get such skill</p>",
        "id": 419253383,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1706796472
    },
    {
        "content": "<p><code>r</code> is a dummy list, while <code>x</code> is the list you are manipulating with the <code>*z</code>. So I picked <code>x</code> (although I believe both work)</p>",
        "id": 419253559,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706796522
    }
]