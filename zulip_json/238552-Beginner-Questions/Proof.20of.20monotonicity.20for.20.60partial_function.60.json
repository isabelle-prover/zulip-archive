[
    {
        "content": "<p>Hi everyone,</p>\n<p>I've been trying to use <code>partial_function</code> to define the cartesian product of lazy lists as defined in the <a href=\"https://www.isa-afp.org/sessions/coinductive/#Coinductive_List\"><code>Coinductive</code> AFP entry</a> (which, from my understanding of corecursion, I cannot define as primitive corecursive).</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">partial_function</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">llist</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">lmaps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹('a ⇒ 'b llist) ⇒ 'a llist ⇒ 'b llist›</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">‹lmaps f xs = (case xs of LNil ⇒ LNil | LCons x xs ⇒ lappend (f x) (lmaps f xs))›</span>\n\n<span class=\"k\">partial_function</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">llist</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">lproduct</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹'a llist llist ⇒ 'a llist llist›</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">‹lproduct xss = (case xss of</span>\n<span class=\"s\">      LNil ⇒ LCons LNil LNil</span>\n<span class=\"s\">    | LCons xs xss ⇒ lmaps (λ i. lmap (LCons i) (lproduct xss)) xs)›</span>\n</code></pre></div>\n<p>(I could have gone away with using <code>lconcat (lmap (λ i. lmap (LCons i) (lproduct xss)) xs)</code> instead of using <code>lmaps</code>.)</p>\n<p>However, somehow,  Isabelle is unable to proof monotonicity of the <code>lproduct</code> function, failing with the following error</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">exception</span><span class=\"w\"> </span><span class=\"n\">THM</span><span class=\"w\"> </span><span class=\"n\">0</span><span class=\"w\"> </span><span class=\"n\">raised</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"n\">83</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"s\">\"goal.ML\"</span><span class=\"o\">):</span>\n<span class=\"n\">•</span><span class=\"w\">  </span><span class=\"n\">Proof</span><span class=\"w\"> </span><span class=\"n\">failed.</span>\n<span class=\"w\">   </span><span class=\"n\">1.</span><span class=\"w\"> </span><span class=\"n\">⋀x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">xss.</span>\n<span class=\"w\">      </span><span class=\"n\">monotone</span><span class=\"w\"> </span><span class=\"n\">llist.le_fun</span><span class=\"w\"> </span><span class=\"n\">lprefix</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">λlproduct.</span><span class=\"w\"> </span><span class=\"n\">lmaps</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">λi.</span><span class=\"w\"> </span><span class=\"n\">lmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LCons</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lproduct</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"n\">•</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">⋀x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">xss.</span>\n<span class=\"w\">   </span><span class=\"n\">monotone</span><span class=\"w\"> </span><span class=\"n\">llist.le_fun</span><span class=\"w\"> </span><span class=\"n\">lprefix</span>\n<span class=\"w\">    </span><span class=\"o\">(</span><span class=\"n\">λlproduct.</span><span class=\"w\"> </span><span class=\"n\">lmaps</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">λi.</span><span class=\"w\"> </span><span class=\"n\">lmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LCons</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lproduct</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">⟹</span>\n<span class=\"w\">  </span><span class=\"o\">(</span><span class=\"n\">⋀x.</span><span class=\"w\"> </span><span class=\"n\">monotone</span><span class=\"w\"> </span><span class=\"n\">llist.le_fun</span><span class=\"w\"> </span><span class=\"n\">lprefix</span>\n<span class=\"w\">     </span><span class=\"o\">(</span><span class=\"n\">λlproduct.</span>\n<span class=\"w\">      </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">LNil</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">LCons</span><span class=\"w\"> </span><span class=\"n\">LNil</span><span class=\"w\"> </span><span class=\"n\">LNil</span>\n<span class=\"w\">      </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">LCons</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"w\"> </span><span class=\"n\">⇒</span>\n<span class=\"w\">       </span><span class=\"n\">lmaps</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">λi.</span><span class=\"w\"> </span><span class=\"n\">lmap</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">LCons</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">lproduct</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I tried to prove this subgoal myself, which is basically a one-liner </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">lproduct_mono</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹'a llist llist›</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span>\n<span class=\"w\">    </span><span class=\"s\">‹⋀ (xs :: 'a llist) (xss :: 'a llist llist).</span>\n<span class=\"s\">      mono_llist (λ lproduct. lmaps (λi. lmap (LCons i) (lproduct xss)) xs)›</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span>\n<span class=\"w\">    </span><span class=\"s\">‹mono_llist (λ lproduct.</span>\n<span class=\"s\">      case_llist (LCons LNil LNil) (λ xs xss. lmaps (λi. lmap (LCons i) (lproduct xss)) xs) xss)›</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">xss</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">intro</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>After looking at the <code>mono_tac</code> function in the <a href=\"https://isabelle.in.tum.de/library/HOL/HOL/ISABELLE_HOME/src/HOL/Tools/Function/partial_function.ML.html\"><code>partial_function.ML</code> file</a>,  I tried to change the proof to better reflect what I understand this tactic is doing, and ended up with </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">cases</span><span class=\"w\"> </span><span class=\"n\">xss;</span><span class=\"w\"> </span><span class=\"n\">hypsubst;</span><span class=\"w\"> </span><span class=\"n\">subst</span><span class=\"w\"> </span><span class=\"n\">llist.case;</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">llist.const_mono</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which also works.</p>\n<p>I'm not sure what's wrong here, neither how I can try to debug this issue. I even tried to add the <code>partial_function_mono</code> attribute on the lemma (as described in the reference manual), to no avail.</p>\n<p>Is anybody familiar with <code>partial_function</code> or knows what may be going wrong here?</p>",
        "id": 428170448,
        "sender_full_name": "Ghilain Bergeron",
        "timestamp": 1711038535
    },
    {
        "content": "<p>Ah! <br>\nI understand what's missing now.<br>\nI have to prove that <code>⋀ xs xss. monotone llist.le_fun lprefix (λ lproduct. lmaps (λi. lmap (LCons i) (lproduct xss)) xs)</code>. I initially thought that the output was a bit broken for some reason. Now I have to see if I can actually prove this (or derive it one way or another).</p>",
        "id": 428174294,
        "sender_full_name": "Ghilain Bergeron",
        "timestamp": 1711039655
    },
    {
        "content": "<p>Have you tried <code>corec</code> instead of <code>primcorec</code>? That might work</p>",
        "id": 429072778,
        "sender_full_name": "Jan van Brügge",
        "timestamp": 1711193226
    },
    {
        "content": "<p>Using <code>corec</code> for <code>lproduct</code> requires that either <code>lconcat</code> or <code>lmaps</code> (depending on which one is used in the definition) be friendly, which I'm afraid I don't know how they can be :c</p>",
        "id": 429075199,
        "sender_full_name": "Ghilain Bergeron",
        "timestamp": 1711195488
    },
    {
        "content": "<p>ah true</p>",
        "id": 429077204,
        "sender_full_name": "Jan van Brügge",
        "timestamp": 1711197317
    }
]