[
    {
        "content": "<p>Hi, I am writing a proof by induction with a list.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">calc_votes</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'b list ⇒ 'b Profile ⇒'b Votes ⇒ 'b Votes\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"calc_votes [ ] prof votes = votes\"</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"s\">\"calc_votes (party # parties) prof votes =</span>\n<span class=\"s\">      calc_votes parties prof (cnt_votes party prof empty_v 0)\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">calc_votes_permutation</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span>\n<span class=\"w\">    </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'b Parties\"</span><span class=\"w\"> </span><span class=\"kp\">and</span>\n<span class=\"w\">    </span><span class=\"n\">p2</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"s\">\"'b Parties\"</span><span class=\"w\"> </span><span class=\"kp\">and</span>\n<span class=\"w\">    </span><span class=\"n\">profl</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"s\">\"'b Profile\"</span><span class=\"w\"> </span><span class=\"kp\">and</span>\n<span class=\"w\">    </span><span class=\"n\">votes</span><span class=\"o\">::</span><span class=\"s\">\"'b Votes\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"p1 &lt;~~&gt; p2\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes p1 profl votes = calc_votes p2 profl votes\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">Nil</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"p2 = []\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"n\">perm_empty_imp</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">next</span>\n<span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes (a # p1) profl votes =</span>\n<span class=\"s\">             calc_votes p1 profl (cnt_votes a profl empty_v 0)\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes (a # p2) profl votes =</span>\n<span class=\"s\">             calc_votes p2 profl (cnt_votes a profl empty_v 0)\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">v'</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"v' = (cnt_votes a profl empty_v 0)\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes p1 profl v' =</span>\n<span class=\"s\">             calc_votes p2 profl v'\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes (a # p1) profl votes =</span>\n<span class=\"s\">             calc_votes (a # p2) profl votes\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>First: Nil case should be trivial but even <code>\"p1 = [ ]\" using assms by simp</code> does not work. How is this possible if Nil itself is \"[ ]\" as I read in the documentation?<br>\nSecond: in Cons, I am stuck on the step where I use v' (I introduced it to make it clearer). I know the induction proof is assuming as true that <code>\"calc_votes p1 profl v = calc_votes p2 profl v\"</code> , while in the step I have v', which is different. The only solution I could think of brings me to useless unrolling of the recursion. How do I solve this? TIA</p>",
        "id": 421137018,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707775069
    },
    {
        "content": "<p>I don't know for sure without more context, however, your induction doesn't look like it is set up correctly. you probably want the following :</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"ow\">...</span>\n<span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"o\">)</span>\n<span class=\"ow\">...</span>\n</code></pre></div>\n<p>which means to use the assumptions <code>p1 &lt;~~&gt; p2</code> when as part of the predicate instantiating the induction theorem and also to generalize over p2</p>",
        "id": 421180695,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1707803547
    },
    {
        "content": "<p>I really think (also after <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Foldr.20invariant.20on.20permutations/near/419800146\">https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner-Questions/topic/Foldr.20invariant.20on.20permutations/near/419800146</a>) that you should start with an Isabelle tutorial like the prog-prove.</p>",
        "id": 421180930,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707803717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234226\">Yong Kiam</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421180695\">said</a>:</p>\n<blockquote>\n<p>I don't know for sure without more context, however, your induction doesn't look like it is set up correctly. you probably want the following :</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"ow\">...</span>\n<span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">p2</span><span class=\"o\">)</span>\n<span class=\"ow\">...</span>\n</code></pre></div>\n<p>which means to use the assumptions <code>p1 &lt;~~&gt; p2</code> when as part of the predicate instantiating the induction theorem and also to generalize over p2</p>\n</blockquote>\n<p>Thanks, but I had already tried and it did not work.</p>",
        "id": 421187027,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707808310
    },
    {
        "content": "<p>You are missing the \"using assms\" before the proof induction</p>",
        "id": 421187280,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707808476
    },
    {
        "content": "<p>Isabelle's induction method does <em>not</em> work by assuming \"p1 = []\" but by replacing p1 by [] at all occurrences</p>",
        "id": 421187353,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707808549
    },
    {
        "content": "<p>and if you forget some occurrences (like not putting the assms), then you cannot prove anything</p>",
        "id": 421187416,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707808578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421180930\">said</a>:</p>\n<blockquote>\n<p>I really think (also after <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Foldr.20invariant.20on.20permutations/near/419800146\">https://isabelle.zulipchat.com/#narrow/stream/238552-Beginner-Questions/topic/Foldr.20invariant.20on.20permutations/near/419800146</a>) that you should start with an Isabelle tutorial like the prog-prove.</p>\n</blockquote>\n<p>I already read the prog-prove but I will try to do some exercises from here, thanks.</p>",
        "id": 421187547,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707808679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421187280\">said</a>:</p>\n<blockquote>\n<p>You are missing the \"using assms\" before the proof induction</p>\n</blockquote>\n<p>You mean like the example provided by <span class=\"user-mention\" data-user-id=\"234226\">@Yong Kiam</span> , right? I put it, still it does not work.</p>",
        "id": 421187666,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707808759
    },
    {
        "content": "<p>and what does not work? can you provide an error message?</p>",
        "id": 421187794,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707808836
    },
    {
        "content": "<p>and if the problem is <code>calc_votes p1 profl v = calc_votes p2 profl v</code>: you have told Isabelle that you want to use the IH at this point</p>",
        "id": 421188251,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707809114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421187794\">said</a>:</p>\n<blockquote>\n<p>and what does not work? can you provide an error message?</p>\n</blockquote>\n<p>Nevermind, I fixed it, thanks</p>",
        "id": 421189314,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707809791
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421188251\">said</a>:</p>\n<blockquote>\n<p>and if the problem is <code>calc_votes p1 profl v = calc_votes p2 profl v</code>: you have told Isabelle that you want to use the IH at this point</p>\n</blockquote>\n<p>It's not working because I am inducting on p1, having <code>(a # p1)</code> but since I am not inducting on p2 I have p2 and not what I actually would need, which is <code>(a # p2)</code>. So my induction proof is proving <code>calc_votes (a # p1) ... = calc_votes p2 ...</code> , while I should prove  <code>calc_votes (a # p1) ... = calc_votes (a # p2) ... </code>. Maybe I should use some  <code>obtain</code> ? I hope I was clear.</p>",
        "id": 421190225,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707810307
    },
    {
        "content": "<p>Also, I will look in the doc to check if there is some similar case/example.</p>",
        "id": 421190394,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707810397
    },
    {
        "content": "<p>in the inductive case, you will probably need to unfold the assumption <code>a # p_1 &lt;~~&gt; p_2</code> a little in order to apply the inductive hypothesis</p>",
        "id": 421194315,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1707812153
    },
    {
        "content": "<p>you need to obtain a p_2' such that mset p_2 = mset (a # p_2') yeas</p>",
        "id": 421200331,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707814636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421200331\">said</a>:</p>\n<blockquote>\n<p>you need to obtain a p_2' such that mset p_2 = mset (a # p_2') yeas</p>\n</blockquote>\n<p>Actually p_2 is a list, not a multiset (also because I use permutation operator). Maybe you meant <code>p_2' = mset (a # p_2)</code> and then proving the inductive case on (a # p1) and p_2' (indeed, a # p_2)?</p>",
        "id": 421233184,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707827146
    },
    {
        "content": "<p>You are getting the induction wrong. You have a p_2 (the list). From this list you could remove the element a. This yields the p_2' I was writing about</p>",
        "id": 421233710,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707827340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421233710\">said</a>:</p>\n<blockquote>\n<p>You are getting the induction wrong. You have a p_2 (the list). From this list you could remove the element a. This yields the p_2' I was writing about</p>\n</blockquote>\n<p>I understand, you mean something like this right?<br>\n<code>obtain p2' where \"p2 &lt;~~&gt; (a # p2')\" using assms by (metis Cons.prems)</code></p>",
        "id": 421237283,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707828597
    },
    {
        "content": "<p>I would have written it directly as <code>obtain p2' where \"a # p1 &lt;~~&gt; (a # p2')\"</code>, but yes (this is one transitivity step away from your version)</p>",
        "id": 421237494,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707828668
    },
    {
        "content": "<p>BTW, I'm not sure induction on lists is the best way to prove your goal (as it involves permutation), perhaps you may have better luck with induction on permutations (I don't have Isabelle open at the moment to see what the permutation induction is called)</p>",
        "id": 421239683,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1707829433
    },
    {
        "content": "<p>Or using multisets directly…</p>",
        "id": 421241377,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707830085
    },
    {
        "content": "<p>I already tried to wrote it with Multisets with fold_mset but I found it a bit hard for my case. I'll try again today then</p>",
        "id": 421244273,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707831143
    },
    {
        "content": "<p>You can also continue with the current approach… you are not far away from proving this theorem</p>",
        "id": 421245413,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707831554
    },
    {
        "content": "<p>The real question is probably what comes next</p>",
        "id": 421245440,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707831565
    },
    {
        "content": "<p>In general, the more complicated your structures are, the more proof you will require. For example, lists are multisets + order on the elements. So it is more complicated. Like here: the p_2' would be <code>remove1 a p_2</code> compared to <code>p_1 - {#a#}</code></p>",
        "id": 421245814,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1707831688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421245413\">said</a>:</p>\n<blockquote>\n<p>You can also continue with the current approach… you are not far away from proving this theorem</p>\n</blockquote>\n<p>I continued, I got to this point in the proving:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">p2'</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"p2 &lt;~~&gt; (a # p2')\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">Cons.prems</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"(a # p1) &lt;~~&gt; (a # p2')\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"n\">Cons.prems</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes (a # p1) profl votes =</span>\n<span class=\"s\">             calc_votes p1 profl (cnt_votes a profl empty_v 0)\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"… =</span>\n<span class=\"s\">             calc_votes p2' profl (cnt_votes a profl empty_v 0)\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">Cons.IH</span><span class=\"w\"> </span><span class=\"n\">Cons.prems</span><span class=\"w\"> </span><span class=\"s\">‹mset p2 = mset (a # p2')›</span><span class=\"w\"> </span><span class=\"n\">calc_votes.simps</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">cons_perm_imp_perm</span><span class=\"w\"> </span><span class=\"n\">list.exhaust</span><span class=\"w\"> </span><span class=\"n\">mset_zero_iff_right</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"... = calc_votes (a # p2') profl votes\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"... = calc_votes p2 profl votes\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>but I cannot do the last step, since p2 is not equal to (a # p2') but it's a permutation. So to do this step I would require exactly the lemma i am proving and I don't know how to do this otherwise.</p>",
        "id": 421314070,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707853594
    },
    {
        "content": "<p>you may need to prove a helper lemma (e.g., something saying you can pull an element from within a list to the front)</p>\n<p>alternatively, go for <code>mset</code> or an induction principle for permutations</p>",
        "id": 421352224,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1707872785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234226\">Yong Kiam</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421352224\">said</a>:</p>\n<blockquote>\n<p>you may need to prove a helper lemma (e.g., something saying you can pull an element from within a list to the front)</p>\n<p>alternatively, go for <code>mset</code> or an induction principle for permutations</p>\n</blockquote>\n<p>I don't understand, how would the helper lemma you wrote help my case?</p>\n<p>for mset you mean to write the function itself with Multisets? alternatively, do you know where I can find infos about induction on permutations?</p>",
        "id": 421382364,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1707894425
    },
    {
        "content": "<p>I'm actually not sure what the appropriate induction is called in Isabelle, maybe someone else could chime in, but this is the induction principle that's used in HOL4:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">   </span><span class=\"o\">[</span><span class=\"n\">PERM_IND</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"n\">Theorem</span>\n<span class=\"w\">      </span><span class=\"n\">⊢</span><span class=\"w\"> </span><span class=\"n\">∀P.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">∧</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">l1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">∧</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">∀l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">l3.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">∧</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">l3</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">⇒</span>\n<span class=\"w\">            </span><span class=\"n\">∀l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">PERM</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n</code></pre></div>\n<p>going for <code>mset</code> as <span class=\"user-mention\" data-user-id=\"233198\">@Mathias Fleury</span> suggested seems like the right way to go to me.<br>\nconcretely: define another function that works over multisets, prove that your list version is equivalent to the <code>mset</code> version in some adequate way, then the permutation results follow for free</p>",
        "id": 421383449,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1707894991
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"671670\">@Salvatore Francesco Rossetta</span> . </p>\n<p>I am building an induction prover inside Isabelle. </p>\n<p>(This might be a bit confusing, but in the video, I refer to it as 'abduction prover' because of the search algorithm I use within the prover. However, it is primarily designed for solving inductive problems.)<br>\n<a href=\"https://youtu.be/rXU-lJxP_GI\">https://youtu.be/rXU-lJxP_GI</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"rXU-lJxP_GI\" href=\"https://youtu.be/rXU-lJxP_GI\"><img src=\"https://uploads.zulipusercontent.net/5cafcd521ae910e84c565218750620f29e34e597/68747470733a2f2f692e7974696d672e636f6d2f76692f7258552d6c4a78505f47492f64656661756c742e6a7067\"></a></div><p>It might be able to find a proof for you if you're lucky.<br>\nYou can get the induction prover for Isabelle here: <a href=\"https://github.com/data61/PSL\">https://github.com/data61/PSL</a></p>\n<p>The tool may not handle the use of <code>assumes</code> very well.<br>\nSo, it might prefer </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">prove</span><span class=\"w\">  </span><span class=\"s\">\"(p1 &lt;~~&gt; p2) ==&gt; calc_votes p1 profl votes = calc_votes p2 profl votes\"</span>\n</code></pre></div>\n<p>rather than </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"p1 &lt;~~&gt; p2\"</span>\n<span class=\"w\"> </span><span class=\"n\">prove</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes p1 profl votes = calc_votes p2 profl votes\"</span>\n</code></pre></div>\n<p>Also, please note that it takes a while for this tool to find a proof. Once, I waited for more than 30 minutes before it delivered a proof to me.</p>",
        "id": 421551631,
        "sender_full_name": "Yutaka Nagashima",
        "timestamp": 1707953409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234226\">Yong Kiam</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421383449\">said</a>:</p>\n<blockquote>\n<p>I'm actually not sure what the appropriate induction is called in Isabelle, maybe someone else could chime in, but this is the induction principle that's used in HOL4:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">   </span><span class=\"o\">[</span><span class=\"n\">PERM_IND</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"n\">Theorem</span>\n<span class=\"w\">      </span><span class=\"n\">⊢</span><span class=\"w\"> </span><span class=\"n\">∀P.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">∧</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">l1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">∧</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">∀l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">l3.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">∧</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">l3</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">⇒</span>\n<span class=\"w\">            </span><span class=\"n\">∀l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">PERM</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n</code></pre></div>\n<p>going for <code>mset</code> as <span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> suggested seems like the right way to go to me.<br>\nconcretely: define another function that works over multisets, prove that your list version is equivalent to the <code>mset</code> version in some adequate way, then the permutation results follow for free</p>\n</blockquote>\n<p>wait actually permutations are defined as multiset equality. I forgot that.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">src/HOL/Combinatorics/List_Permutation.thy</span><span class=\"o\">:</span><span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">perm</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"ss\">\\&lt;open&gt;</span><span class=\"s\">'a list </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> 'a list </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> bool</span><span class=\"ss\">\\&lt;close&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"kp\">infixr</span><span class=\"w\"> </span><span class=\"ss\">\\&lt;open&gt;</span><span class=\"s\">&lt;~~&gt;</span><span class=\"ss\">\\&lt;close&gt;</span><span class=\"w\"> </span><span class=\"n\">50</span><span class=\"o\">)</span>\n<span class=\"n\">src/HOL/Combinatorics/List_Permutation.thy</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"ss\">\\&lt;open&gt;</span><span class=\"s\">xs &lt;~~&gt; ys </span><span class=\"ss\">\\&lt;equiv&gt;</span><span class=\"s\"> mset xs = mset ys</span><span class=\"ss\">\\&lt;close&gt;</span>\n</code></pre></div>\n<p>So we do not have a permutation induction (at least no a builtin one).</p>",
        "id": 421729029,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1708026609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671670\">Salvatore Francesco Rossetta</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421314070\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421245413\">said</a>:</p>\n<blockquote>\n<p>You can also continue with the current approach… you are not far away from proving this theorem</p>\n</blockquote>\n<p>I continued, I got to this point in the proving:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cons</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">obtain</span><span class=\"w\"> </span><span class=\"n\">p2'</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"p2 &lt;~~&gt; (a # p2')\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">Cons.prems</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"(a # p1) &lt;~~&gt; (a # p2')\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"n\">Cons.prems</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"calc_votes (a # p1) profl votes =</span>\n<span class=\"s\">             calc_votes p1 profl (cnt_votes a profl empty_v 0)\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"… =</span>\n<span class=\"s\">             calc_votes p2' profl (cnt_votes a profl empty_v 0)\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">Cons.IH</span><span class=\"w\"> </span><span class=\"n\">Cons.prems</span><span class=\"w\"> </span><span class=\"s\">‹mset p2 = mset (a # p2')›</span><span class=\"w\"> </span><span class=\"n\">calc_votes.simps</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">cons_perm_imp_perm</span><span class=\"w\"> </span><span class=\"n\">list.exhaust</span><span class=\"w\"> </span><span class=\"n\">mset_zero_iff_right</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"... = calc_votes (a # p2') profl votes\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"... = calc_votes p2 profl votes\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>but I cannot do the last step, since p2 is not equal to (a # p2') but it's a permutation. So to do this step I would require exactly the lemma i am proving and I don't know how to do this otherwise.</p>\n</blockquote>\n<p>Right, so this would mean that you have to generalize your assumptions somehow and change your induction principle. Maybe actually induction on the length of <code>l1</code>?</p>",
        "id": 421729629,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1708026837
    },
    {
        "content": "<p>(BTW I would still like to get the full theory with all the definitions)</p>",
        "id": 421729748,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1708026866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421729029\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"234226\">Yong Kiam</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421383449\">said</a>:</p>\n<blockquote>\n<p>I'm actually not sure what the appropriate induction is called in Isabelle, maybe someone else could chime in, but this is the induction principle that's used in HOL4:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">   </span><span class=\"o\">[</span><span class=\"n\">PERM_IND</span><span class=\"o\">]</span><span class=\"w\">  </span><span class=\"n\">Theorem</span>\n<span class=\"w\">      </span><span class=\"n\">⊢</span><span class=\"w\"> </span><span class=\"n\">∀P.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">∧</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">∧</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">l1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">l2</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"n\">∧</span>\n<span class=\"w\">            </span><span class=\"o\">(</span><span class=\"n\">∀l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">l3.</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">∧</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">l3</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l3</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">⇒</span>\n<span class=\"w\">            </span><span class=\"n\">∀l1</span><span class=\"w\"> </span><span class=\"n\">l2.</span><span class=\"w\"> </span><span class=\"n\">PERM</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">l1</span><span class=\"w\"> </span><span class=\"n\">l2</span>\n</code></pre></div>\n<p>going for <code>mset</code> as <span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> suggested seems like the right way to go to me.<br>\nconcretely: define another function that works over multisets, prove that your list version is equivalent to the <code>mset</code> version in some adequate way, then the permutation results follow for free</p>\n</blockquote>\n<p>wait actually permutations are defined as multiset equality. I forgot that.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">src/HOL/Combinatorics/List_Permutation.thy</span><span class=\"o\">:</span><span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">input</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">perm</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"ss\">\\&lt;open&gt;</span><span class=\"s\">'a list </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> 'a list </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> bool</span><span class=\"ss\">\\&lt;close&gt;</span><span class=\"w\">  </span><span class=\"o\">(</span><span class=\"kp\">infixr</span><span class=\"w\"> </span><span class=\"ss\">\\&lt;open&gt;</span><span class=\"s\">&lt;~~&gt;</span><span class=\"ss\">\\&lt;close&gt;</span><span class=\"w\"> </span><span class=\"n\">50</span><span class=\"o\">)</span>\n<span class=\"n\">src/HOL/Combinatorics/List_Permutation.thy</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"ss\">\\&lt;open&gt;</span><span class=\"s\">xs &lt;~~&gt; ys </span><span class=\"ss\">\\&lt;equiv&gt;</span><span class=\"s\"> mset xs = mset ys</span><span class=\"ss\">\\&lt;close&gt;</span>\n</code></pre></div>\n<p>So we do not have a permutation induction (at least no a builtin one).</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">perm_induct</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"P [] []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"⋀x xs ys. P (x # xs) (x # ys)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"⋀x y xs ys. P (x # y # xs) (y # x # ys)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"⋀xs ys zs. P xs ys ⟹ P ys zs ⟹ P xs zs\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"mset xs = mset ys ⟹ P xs ys\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">arbitrary</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">ys</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">Nil</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span>\n<span class=\"w\">    </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"k\">next</span>\n<span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Cons</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span>\n<span class=\"w\">    </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">neq_Nil_conv</span><span class=\"w\"> </span><span class=\"n\">perm_empty2</span><span class=\"o\">)</span>\n<span class=\"k\">qed</span>\n</code></pre></div>",
        "id": 421785147,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1708056984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421729629\">said</a>:</p>\n<blockquote>\n<p>Right, so this would mean that you have to generalize your assumptions somehow and change your induction principle. Maybe actually induction on the length of <code>l1</code>?</p>\n</blockquote>\n<p>At this point, if the problem is that my p2 is p2 &lt;~~&gt; a # p2', can't i define it simply as p2 =a # p2' so I can do the last step?</p>",
        "id": 421806066,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1708069537
    },
    {
        "content": "<p>I don't get what you mean here, but the point is that p2 does <em>not</em> necessarily start with <code>a</code>, it's a permutation of <code>a # p_1</code></p>",
        "id": 421806797,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1708069970
    },
    {
        "content": "<p>if you want to assume something stronger about <code>p_2</code>, you'll have to use induction on a different (more general) statement, or use a different induction principle, as Mathias mentioned</p>",
        "id": 421806913,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1708070041
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"671670\">Salvatore Francesco Rossetta</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421806066\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421729629\">said</a>:</p>\n<blockquote>\n<p>Right, so this would mean that you have to generalize your assumptions somehow and change your induction principle. Maybe actually induction on the length of <code>l1</code>?</p>\n</blockquote>\n<p>At this point, if the problem is that my p2 is p2 &lt;~~&gt; a # p2', can't i define it simply as p2 =a # p2' so I can do the last step?</p>\n</blockquote>\n<p>You are doing an induction. You are not allowed to define anything. You get variables and you have to work with them.</p>",
        "id": 421810031,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1708071591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234226\">Yong Kiam</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proof.20using.20induction.20on.20list/near/421806913\">said</a>:</p>\n<blockquote>\n<p>if you want to assume something stronger about <code>p_2</code>, you'll have to use induction on a different (more general) statement, or use a different induction principle, as Mathias mentioned</p>\n</blockquote>\n<p>Now I get it, to say that p2= a # p2' means this would be proved only with p2 having a as a first element, while I want the more general case, right?<br>\nSo on a general level, as an idea, I should do induction on length of p1 and in the ≠0 case do some obtain like p1' &lt;~~&gt; a # p1 and same with p2 right? I don't know if I was clear</p>",
        "id": 421812828,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1708072672
    },
    {
        "content": "<p>you can do something like this, but I'm not sure it will help you in this case, what about trying to use <code>perm_induct</code> which I wrote above?</p>",
        "id": 421829681,
        "sender_full_name": "Yong Kiam",
        "timestamp": 1708078980
    }
]