[
    {
        "content": "<p>Hi, sorry for long question. I have this loop</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">function</span><span class=\"w\"> </span><span class=\"n\">loop_divisor</span><span class=\"w\"> </span><span class=\"o\">::</span>\n<span class=\"w\">    </span><span class=\"s\">\"('a::linorder, 'b) Divisor_Module_Params ⇒ ('a::linorder, 'b) Divisor_Module_Params\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"(parties rec = []) ⟹ loop_divisor rec = rec\"</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"s\">\"¬(parties rec = []) ⟹ loop_divisor rec = loop_divisor (divisor_module rec)\"</span>\n</code></pre></div>\n<p>for which I want to prove termination. rec is a record with a list \"parties\". divisor_module removes head of this list, which gets shorter, this way: </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">divisor_module</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('a::linorder, 'b) Divisor_Module_Params ⇒ ('a::linorder, 'b) Divisor_Module_Params\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"divisor_module rec =</span>\n<span class=\"s\">  (let</span>\n<span class=\"s\">    p = hd (parties rec);</span>\n<span class=\"s\">    ps = remove_first (parties rec);</span>\n<span class=\"s\">    ni = Min (snd (snd (result rec)));</span>\n<span class=\"s\">    nrec = ⦇ result = (fst (result rec) ∪ {ni}, {},snd (snd (result rec)) - {ni}),</span>\n<span class=\"s\">                    parties = ps, indexes = indexes rec,</span>\n<span class=\"s\">                    seats = assign_seat ni p (seats rec),</span>\n<span class=\"s\">                    votes = votes rec, fract_votes = update_votes p (seats rec) (indexes rec) (votes rec) (fract_votes rec) (params rec),</span>\n<span class=\"s\">                    params = params rec ⦈</span>\n<span class=\"s\">  in</span>\n<span class=\"s\">    nrec)\"</span>\n</code></pre></div>\n<p>My idea was to write a lemma about the list getting shorter and use it in the termination of the loop above. I already wrote a lemma for remove_first which seems correct to me. </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">remove_first</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ 'a list\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"remove_first (x # xs) = xs\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_remove_first</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(x # xs) ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length xs &lt; length (x # xs)\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"x # xs ≠ []\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"length (x # xs) = Suc (length xs)\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>But then trying to prove that in divisor_module \"parties nrec\" (indeed ps) is shorter than \"parties rec\"</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">divisor_module_p_length</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty_parties</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"parties rec ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length (parties (divisor_module rec)) &lt; length (parties rec)\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"length (remove_first (parties rec)) &lt; length (parties rec)\"</span>\n<span class=\"w\">    </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">non_empty_parties</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">length_remove_first</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>it fails to prove the subgoal. Isn't my first lemma sufficient for this? Also, since I am a beginner in proofing, is the logic behind the proofing correct or I should proceed in another way? Thanks in advance</p>",
        "id": 418415338,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1706359719
    },
    {
        "content": "<p>First your remove_first is exactly <code>tl</code></p>",
        "id": 418416249,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706360574
    },
    {
        "content": "<p>Second, you have not provided enough to reproduce the bug. </p>\n<p>If the problem is this, then let's see where rule is stuck:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"length (remove_first (parties rec)) &lt; length (parties rec)\"</span>\n<span class=\"w\">    </span><span class=\"n\">supply</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"n\">unify_trace_failure</span><span class=\"o\">]]</span>\n<span class=\"w\">    </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">length_remove_first</span><span class=\"o\">)</span>\n\n<span class=\"c\">(*</span>\n<span class=\"c\">Clash: List.list.Cons =/= Scratch.stuff.parties</span>\n<span class=\"c\">Failed to apply proof method⌂:</span>\n<span class=\"c\">goal (1 subgoal):</span>\n<span class=\"c\"> 1. length (remove_first (parties rec)) &lt; length (parties rec)</span>\n<span class=\"c\">*)</span>\n</code></pre></div>\n<p>… so it is stuck because it does not why <code>parties rec</code> would  be unifiable with \"Cons _ _\"</p>",
        "id": 418416526,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706360884
    },
    {
        "content": "<p>Now I strongly suspect that if you had used tl, then simp would actually be able to solve the goal</p>",
        "id": 418416612,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706360977
    },
    {
        "content": "<p>Here the version I tried without the <code>Divisor_Module_Params</code> that is not part of Main:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">stuff</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parties</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹nat list›</span><span class=\"o\">)</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">divisor_module</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"_ ⇒ stuff\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"divisor_module rec =   S (tl (parties rec))\"</span>\n\n\n<span class=\"kn\">function</span><span class=\"w\"> </span><span class=\"n\">loop_divisor</span><span class=\"w\"> </span><span class=\"o\">::</span>\n<span class=\"w\">    </span><span class=\"s\">\"stuff ⇒ stuff\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"(parties rec = []) ⟹ loop_divisor rec = rec\"</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"s\">\"¬(parties rec = []) ⟹ loop_divisor rec = loop_divisor (divisor_module rec)\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">remove_first</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ 'a list\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"remove_first (x # xs) = xs\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_remove_first</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(x # xs) ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length xs &lt; length (x # xs)\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"x # xs ≠ []\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"length (x # xs) = Suc (length xs)\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">divisor_module_p_length</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty_parties</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"parties rec ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length (parties (divisor_module rec)) &lt; length (parties rec)\"</span>\n<span class=\"w\">   </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 418416684,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706361029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Proofing.20measures.20with.20simp/near/418416684\">said</a>:</p>\n<blockquote>\n<p>Here the version I tried without the <code>Divisor_Module_Params</code> that is not part of Main:</p>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">stuff</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parties</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹nat list›</span><span class=\"o\">)</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">divisor_module</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"_ ⇒ stuff\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"divisor_module rec =   S (tl (parties rec))\"</span>\n\n\n<span class=\"kn\">function</span><span class=\"w\"> </span><span class=\"n\">loop_divisor</span><span class=\"w\"> </span><span class=\"o\">::</span>\n<span class=\"w\">    </span><span class=\"s\">\"stuff ⇒ stuff\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"(parties rec = []) ⟹ loop_divisor rec = rec\"</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"s\">\"¬(parties rec = []) ⟹ loop_divisor rec = loop_divisor (divisor_module rec)\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">remove_first</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ 'a list\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"remove_first (x # xs) = xs\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_remove_first</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(x # xs) ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length xs &lt; length (x # xs)\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"x # xs ≠ []\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"length (x # xs) = Suc (length xs)\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">divisor_module_p_length</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty_parties</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"parties rec ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length (parties (divisor_module rec)) &lt; length (parties rec)\"</span>\n<span class=\"w\">   </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I used tl and also simp in the lemma but it is not working, i think it's the only changes to my code, then to me it looks the same.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">record</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'b</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Divisor_Module_Params</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">  </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a Result\"</span>\n<span class=\"w\">  </span><span class=\"n\">parties</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'b Parties\"</span>\n<span class=\"w\">  </span><span class=\"n\">indexes</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a set\"</span>\n<span class=\"w\">  </span><span class=\"n\">seats</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('a, 'b) Seats\"</span>\n<span class=\"w\">  </span><span class=\"n\">votes</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'b StructVotes\"</span>\n<span class=\"w\">  </span><span class=\"n\">fract_votes</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'b StructVotes\"</span>\n<span class=\"w\">  </span><span class=\"n\">params</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"nat list\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">divisor_module</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"_ ⇒ ('a::linorder, 'b) Divisor_Module_Params\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"divisor_module rec =</span>\n<span class=\"s\">  (let</span>\n<span class=\"s\">    ni = Min (snd (snd (result rec)))</span>\n<span class=\"s\">     in ⦇ result = (fst (result rec) ∪ {ni}, {},snd (snd (result rec)) - {ni}),</span>\n<span class=\"s\">                    parties = tl (parties rec), indexes = indexes rec,</span>\n<span class=\"s\">                    seats = assign_seat ni (hd(parties rec)) (seats rec),</span>\n<span class=\"s\">                    votes = votes rec, fract_votes = update_votes (hd(parties rec)) (seats rec) (indexes rec) (votes rec) (fract_votes rec) (params rec),</span>\n<span class=\"s\">                    params = params rec ⦈)\"</span>\n\n<span class=\"kn\">function</span><span class=\"w\"> </span><span class=\"n\">loop_divisor</span><span class=\"w\"> </span><span class=\"o\">::</span>\n<span class=\"w\">    </span><span class=\"s\">\"('a::linorder, 'b) Divisor_Module_Params ⇒ ('a::linorder, 'b) Divisor_Module_Params\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"(parties rec = []) ⟹ loop_divisor rec = rec\"</span><span class=\"w\"> </span><span class=\"o\">|</span>\n<span class=\"w\">  </span><span class=\"s\">\"¬(parties rec = []) ⟹ loop_divisor rec = loop_divisor (divisor_module rec)\"</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">remove_first</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ 'a list\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"remove_first (x # xs) = xs\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_remove_first</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(x # xs) ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length xs &lt; length (x # xs)\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">non_empty</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"x # xs ≠ []\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"length (x # xs) = Suc (length xs)\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">thesis</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">divisor_module_p_length</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">non_empty_parties</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"parties rec ≠ []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"length (parties (divisor_module rec)) &lt; length (parties rec)\"</span>\n<span class=\"w\"> </span><span class=\"n\">supply</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"n\">unify_trace_failure</span><span class=\"o\">]]</span>\n<span class=\"w\">   </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>The error is always failing to prove the subgoal. Could it be for the record instead of datatype?</p>",
        "id": 418429832,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1706372836
    },
    {
        "content": "<ol>\n<li>Your example is still not working when importing only Main</li>\n<li>There is a \"by auto\" missing after the definition of loop_divisor to prove completeness.</li>\n<li>Did you look at the error message? The result after simp is:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">parties</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"w\"> </span><span class=\"n\">≠</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"n\">⟹</span>\n<span class=\"w\">    </span><span class=\"n\">length</span>\n<span class=\"w\">     </span><span class=\"o\">(</span><span class=\"n\">parties</span>\n<span class=\"w\">       </span><span class=\"o\">(</span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">ni</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Min</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">)))</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">⦇result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">insert</span><span class=\"w\"> </span><span class=\"n\">ni</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">fst</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">)),</span><span class=\"w\"> </span><span class=\"ow\">{}</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">snd</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"ow\">{</span><span class=\"n\">ni</span><span class=\"ow\">}</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">parties</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parties</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">),</span><span class=\"w\"> </span><span class=\"n\">indexes</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">indexes</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">seats</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">seats</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">votes</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">votes</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">fract_votes</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fract_votes</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">params</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">params</span><span class=\"w\"> </span><span class=\"n\">rec⦈</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">&lt;</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">parties</span><span class=\"w\"> </span><span class=\"n\">rec</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>which clearly shows that the Let is not unfolded by simp…  Therefore you need to Let_def to the simplifier.</p>",
        "id": 418430373,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1706373380
    },
    {
        "content": "<p>thanks, I added Let_def, now it is working</p>",
        "id": 418431948,
        "sender_full_name": "Salvatore Francesco Rossetta",
        "timestamp": 1706374934
    }
]