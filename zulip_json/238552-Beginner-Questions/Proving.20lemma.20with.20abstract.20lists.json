[
    {
        "content": "<p>Hello everyone,<br>\nI need to prove this lemma with abstract definitions of <code>t_betaSet</code>, <code>t_TrigInstance_1</code>, and <code>t_SyncInstance_1</code>.  I firstly defined them by concrete values, then used abstract definitions. If I use a concrete definition, it's provable. Otherwise, it's unprovable. For detail, I present my process in the three below steps.</p>\n<div class=\"codehilite\"><pre><span></span><code>((∀t ∈ set t_SyncInstance_1. ∀l ∈ set (snd t). P (fst t) l ⟶ (∃alp ∈ set t_betaSet. (∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h))) ∧ (∀pair ∈ set t_TrigInstance_1. ∀x ∈ set (snd pair). Q (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ Q (fst pair) y)) ∧ (∀pair ∈ set t_SyncInstance_1. ∀x ∈ set (snd pair). P (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ P (fst pair) y)))\n⟹ (∃t ∈ set t_SyncInstance_1. ∃alp ∈ set t_betaSet.∃l ∈ set (snd t). P (fst t) l ⟶ ((∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h) ∧ (∀l1 ∈ set (snd t) - {l}. ¬P (fst t) l1) ∧ (∀t1 ∈ set t_SyncInstance_1 - {t}.∀l2 ∈ set (snd t).¬P (fst t1) l2)))\n</code></pre></div>\n<ol>\n<li>If I define all term like <code>t_betaSet</code>, <code>t_TrigInstance_1</code>, and <code>t_SyncInstance_1</code> by concrete values, the lemma is PROVABLE (I used sledgehammer):</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code>definition t_betaSet :: &quot;(nat * nat) list list&quot; where\n&quot;t_betaSet = [[(5,7), (6,7)], [(5,7), (6,8)], [(5,8), (6,7)], [(5,8), (6,8)]]&quot;\n\ndefinition t_TrigInstance_1 :: &quot;(nat * nat list) list&quot; where\n&quot;t_TrigInstance_1 = [(5, [7, 8]), (6, [7, 8])]&quot;\n\n(*------*)\ndefinition t_SyncInstance_1 :: &quot;(nat * nat list) list&quot; where\n&quot;t_SyncInstance_1 = [(0, [2,3])]&quot;\n(*------*)\nlemma specific_proving: &quot;((∀t ∈ set t_SyncInstance_1. ∀l ∈ set (snd t). P (fst t) l ⟶ (∃alp ∈ set t_betaSet. (∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h))) ∧ (∀pair ∈ set t_TrigInstance_1. ∀x ∈ set (snd pair). Q (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ Q (fst pair) y)) ∧ (∀pair ∈ set t_SyncInstance_1. ∀x ∈ set (snd pair). P (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ P (fst pair) y)))\n⟹ (∃t ∈ set t_SyncInstance_1. ∃alp ∈ set t_betaSet.∃l ∈ set (snd t). P (fst t) l ⟶ ((∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h) ∧ (∀l1 ∈ set (snd t) - {l}. ¬P (fst t) l1) ∧ (∀t1 ∈ set t_SyncInstance_1 - {t}.∀l2 ∈ set (snd t).¬P (fst t1) l2)))&quot;\n  unfolding t_SyncInstance_1_def t_TrigInstance_1_def t_betaSet_def\n  by (metis insert_Diff_single insert_iff list.simps(15) numeral_eq_iff old.prod.inject prod.collapse semiring_norm(88))\n</code></pre></div>\n<ol start=\"2\">\n<li>In the second step, I defined all the terms inside the lemma. Then, I used <code>sledgehammer</code> to prove but it's UNPROVABLE. For detail, the sledgehammer supposed some solutions to try but when I use them, it's highlighted by red color.<br>\nHowever, if I use the command in the first step, it is PROVABLE.</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code>lemma manual_specific_proving:\n  fixes t_SyncInstance_1 :: &quot;(nat * nat list) list&quot;\n  fixes t_TrigInstance_1 :: &quot;(nat * nat list) list&quot;\n  fixes t_betaSet :: &quot;(nat * nat) list list&quot;\n  assumes &quot;t_TrigInstance_1 = [(5, [7, 8]), (6, [7, 8])]&quot;\n  assumes &quot;t_SyncInstance_1 = [(0, [2, 3, 4]), (1, [2, 3, 4])]&quot;\n  assumes &quot;t_betaSet = [[(5,7), (6,7)], [(5,7), (6,8)], [(5,8), (6,7)], [(5,8), (6,8)]]&quot;\n  shows\n&quot;((∀t ∈ set t_SyncInstance_1. ∀l ∈ set (snd t). P (fst t) l ⟶ (∃alp ∈ set t_betaSet. (∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h))) ∧ (∀pair ∈ set t_TrigInstance_1. ∀x ∈ set (snd pair). Q (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ Q (fst pair) y)) ∧ (∀pair ∈ set t_SyncInstance_1. ∀x ∈ set (snd pair). P (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ P (fst pair) y)))\n⟹ (∃t ∈ set t_SyncInstance_1. ∃alp ∈ set t_betaSet.∃l ∈ set (snd t). P (fst t) l ⟶ ((∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h) ∧ (∀l1 ∈ set (snd t) - {l}. ¬P (fst t) l1) ∧ (∀t1 ∈ set t_SyncInstance_1 - {t}.∀l2 ∈ set (snd t).¬P (fst t1) l2)))&quot;\n  using assms\n  (*sledgehammer UNPROVABLE:by (smt insertI1 insert_Diff_if insert_commute list.simps(15) numeral_eq_iff  semiring_norm(88) singletonD snd_conv)*)\n  by (metis insert_Diff_single insert_iff list.simps(15) numeral_eq_iff old.prod.inject prod.collapse semiring_norm(88))\n</code></pre></div>\n<ol start=\"3\">\n<li>I defined  <code>t_SyncInstance_1</code> in an abstract way and try to prove it but it's UNPROVABLE. Can anyone give me some advice, please? </li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code>lemma abstract_proving:\n  fixes t_SyncInstance_1 :: &quot;(nat * nat list) list&quot;\n  fixes t_TrigInstance_1 :: &quot;(nat * nat list) list&quot;\n  fixes t_betaSet :: &quot;(nat * nat) list list&quot;\n  assumes &quot;t_TrigInstance_1 = [(5, [7, 8]), (6, [7, 8])]&quot;\n  assumes &quot;t_betaSet = [[(5,7), (6,7)], [(5,7), (6,8)], [(5,8), (6,7)], [(5,8), (6,8)]]&quot;\n  assumes &quot;t_SyncInstance_1 ≠ []&quot; and &quot;∀sync ∈ set t_SyncInstance_1. length (snd sync) &gt; 1&quot;\n  shows\n&quot;((∀t ∈ set t_SyncInstance_1. ∀l ∈ set (snd t). P (fst t) l ⟶ (∃alp ∈ set t_betaSet. (∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h))) ∧ (∀pair ∈ set t_TrigInstance_1. ∀x ∈ set (snd pair). Q (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ Q (fst pair) y)) ∧ (∀pair ∈ set t_SyncInstance_1. ∀x ∈ set (snd pair). P (fst pair) x ⟶ (∀y ∈ set (snd pair) - { x }. ¬ P (fst pair) y)))\n⟹ (∃t ∈ set t_SyncInstance_1. ∃alp ∈ set t_betaSet.∃l ∈ set (snd t). P (fst t) l ⟶ ((∃elm ∈ set alp. Q (fst elm) (snd elm)) ∧ (∀elm ∈ set alp.∀h ∈ set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}. ¬Q (fst elm) h) ∧ (∀l1 ∈ set (snd t) - {l}. ¬P (fst t) l1) ∧ (∀t1 ∈ set t_SyncInstance_1 - {t}.∀l2 ∈ set (snd t).¬P (fst t1) l2)))&quot;\n  using assms\nproof (induction t_SyncInstance_1) print_cases\n  case Nil thus ?case by auto\nnext\n  case (Cons a t_SyncInstance_1)\n  assume\n      IH : &quot;(∀t∈set t_SyncInstance_1.\n                ∀l∈set (snd t).\n                   P (fst t) l ⟶\n                   (∃alp∈set t_betaSet.\n                       (∃elm∈set alp. Q (fst elm) (snd elm)) ∧\n                       (∀elm∈set alp.\n                           ∀h∈set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}.\n                              ¬ Q (fst elm) h))) ∧\n            (∀pair∈set t_TrigInstance_1.\n                ∀x∈set (snd pair).\n                   Q (fst pair) x ⟶ (∀y∈set (snd pair) - {x}. ¬ Q (fst pair) y)) ∧\n            (∀pair∈set t_SyncInstance_1.\n                ∀x∈set (snd pair).\n                   P (fst pair) x ⟶ (∀y∈set (snd pair) - {x}. ¬ P (fst pair) y)) ⟹\n            t_TrigInstance_1 = [(5, [7, 8]), (6, [7, 8])] ⟹\n            t_betaSet =\n            [[(5, 7), (6, 7)], [(5, 7), (6, 8)], [(5, 8), (6, 7)], [(5, 8), (6, 8)]] ⟹\n            t_SyncInstance_1 ≠ [] ⟹\n            ∀sync∈set t_SyncInstance_1. 1 &lt; length (snd sync) ⟹\n            ∃t∈set t_SyncInstance_1.\n               ∃alp∈set t_betaSet.\n                  ∃l∈set (snd t).\n                     P (fst t) l ⟶\n                     (∃elm∈set alp. Q (fst elm) (snd elm)) ∧\n                     (∀elm∈set alp.\n                         ∀h∈set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}.\n                            ¬ Q (fst elm) h) ∧\n                     (∀l1∈set (snd t) - {l}. ¬ P (fst t) l1) ∧\n                     (∀t1∈set t_SyncInstance_1 - {t}. ∀l2∈set (snd t). ¬ P (fst t1) l2)&quot;\n      and\n      prems :\n        &quot;(∀t∈set (a # t_SyncInstance_1).\n             ∀l∈set (snd t).\n                P (fst t) l ⟶\n                (∃alp∈set t_betaSet.\n                    (∃elm∈set alp. Q (fst elm) (snd elm)) ∧\n                    (∀elm∈set alp.\n                        ∀h∈set (lookup_1 (fst elm) t_TrigInstance_1) - {snd elm}.\n                           ¬ Q (fst elm) h))) ∧\n         (∀pair∈set t_TrigInstance_1.\n             ∀x∈set (snd pair). Q (fst pair) x ⟶ (∀y∈set (snd pair) - {x}. ¬ Q (fst pair) y)) ∧\n         (∀pair∈set (a # t_SyncInstance_1).\n             ∀x∈set (snd pair). P (fst pair) x ⟶ (∀y∈set (snd pair) - {x}. ¬ P (fst pair) y))&quot;\n        &quot;t_TrigInstance_1 = [(5, [7, 8]), (6, [7, 8])]&quot;\n        &quot;t_betaSet = [[(5, 7), (6, 7)], [(5, 7), (6, 8)], [(5, 8), (6, 7)], [(5, 8), (6, 8)]]&quot;\n        &quot;a # t_SyncInstance_1 ≠ []&quot; &quot;∀sync∈set (a # t_SyncInstance_1). 1 &lt; length (snd sync)&quot;\n  show ?case sledgehammer\nqed\n</code></pre></div>\n<p>Thank you very much.</p>",
        "id": 221031481,
        "sender_full_name": "Trinh Le Khanh",
        "timestamp": 1609117254
    }
]