[
    {
        "content": "<p>Is there a way to limit the simplifier to a single <code>simproc</code>, in my case fun_upd2? I understand that I can specify a list of theorems and omit all others with <code>only</code> but this doesn't seem to extend to simproc(s). IE: `simp only: fun_upd2' fails with \"Undefined fact\".</p>",
        "id": 361175538,
        "sender_full_name": "Matt Griffin",
        "timestamp": 1685052777
    },
    {
        "content": "<p>It is hard to recommend.  The ML version:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"s\">‹ALLGOALS (Simplifier.simp_tac (empty_simpset @{context} addsimprocs [</span><span class=\"ss\">\\&lt;^simproc&gt;</span><span class=\"s\">‹fun_upd2›]))›</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Better is probably the \"one simproc is going rogue, let's deactivate it\":</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\">  </span><span class=\"o\">[[</span><span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"n\">del</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fun_upd2</span><span class=\"o\">]]</span>\n</code></pre></div>",
        "id": 361214948,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1685076666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Specifying.20simprocs/near/361214948\">said</a>:</p>\n<blockquote>\n<p>It is hard to recommend.  The ML version:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"s\">‹ALLGOALS (Simplifier.simp_tac (empty_simpset @{context} addsimprocs [</span><span class=\"ss\">\\&lt;^simproc&gt;</span><span class=\"s\">‹fun_upd2›]))›</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Better is probably the \"one simproc is going rogue, let's deactivate it\":</p>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\">  </span><span class=\"o\">[[</span><span class=\"n\">simproc</span><span class=\"w\"> </span><span class=\"n\">del</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">fun_upd2</span><span class=\"o\">]]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Thanks for this. For context, I needed to run <code>fun_upd2</code> to simplify a very large map structure with repeating keys and the simp method took too long (mainly due to arith_simps/rel_simps which would persist even with \"del:\"). Unfortunately, the ML version you suggested doesn't solve the speed issue but I think I understand why. Looking at the definition of <code>fun_upd2</code> it invokes the simplifier in the last step of \"Goal.prove\". </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Goal.prove</span><span class=\"w\"> </span><span class=\"n\">ctxt</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">[]</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">Logic.mk_equals</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"o\">))</span>\n<span class=\"w\">              </span><span class=\"o\">(</span><span class=\"n\">fn</span><span class=\"w\"> </span><span class=\"o\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span>\n<span class=\"w\">                </span><span class=\"n\">resolve_tac</span><span class=\"w\"> </span><span class=\"n\">ctxt</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">eq_reflection</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"n\">THEN</span>\n<span class=\"w\">                </span><span class=\"n\">resolve_tac</span><span class=\"w\"> </span><span class=\"n\">ctxt</span><span class=\"w\"> </span><span class=\"n\">@</span><span class=\"ow\">{</span><span class=\"n\">thms</span><span class=\"w\"> </span><span class=\"n\">ext</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"n\">THEN</span>\n<span class=\"w\">                </span><span class=\"n\">simp_tac</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">put_simpset</span><span class=\"w\"> </span><span class=\"n\">ss</span><span class=\"w\"> </span><span class=\"n\">ctxt</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is there any way I can limit the simpset in this call, or alternately pass the goal back to the caller to solve?</p>",
        "id": 361360108,
        "sender_full_name": "Matt Griffin",
        "timestamp": 1685114268
    },
    {
        "content": "<p>I think that this is only doing the rewriting and should not be the cause of your problem</p>",
        "id": 361363676,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1685114988
    },
    {
        "content": "<p>can you try</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">supply</span><span class=\"o\">[[</span><span class=\"n\">simp_trace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">simp_debug</span><span class=\"o\">]]</span>\n</code></pre></div>\n<p>to see if there is something weird?</p>",
        "id": 361363884,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1685115028
    },
    {
        "content": "<p>I had to extend the <code>simp_trace_depth_limit</code> to get meaningful results</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"n\">simp_trace</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">simp_debug</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">simp_trace_depth_limit</span><span class=\"o\">=</span><span class=\"n\">40</span><span class=\"o\">]]</span><span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"s\">‹ALLGOALS (Simplifier.simp_tac (empty_simpset @{context} addsimprocs [</span><span class=\"ss\">\\&lt;^simproc&gt;</span><span class=\"s\">‹fun_upd2›]))›</span><span class=\"o\">)[</span><span class=\"n\">1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>Seems to produce output as I would expect. I guess rewriting for such a large map takes time.  I am able to prove the goal much faster than the rewriting rule using a custom proof method (my use case can make a number of assumptions fun_upd2 cannot) so I've added my own <code>simproc</code> goal. Thank you for the help.</p>",
        "id": 361406388,
        "sender_full_name": "Matt Griffin",
        "timestamp": 1685124830
    }
]