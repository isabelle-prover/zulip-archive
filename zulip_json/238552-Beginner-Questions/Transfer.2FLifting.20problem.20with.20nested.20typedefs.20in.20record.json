[
    {
        "content": "<p>I have started formalizing some work involving presheaves of posets and related structures. To ensure that the structure satisfies its defining properties, such as having a transitive, reflexive, antisymmetric relation for a poset, I encoded them as record types with 'valid' predicates.</p>\n<p>Recently, I discovered <code>typedef</code> and the transfer/lifting architecture, and I realized that this approach might be a much better way to handle things because it enforces the validity predicate by default. Consequently, I decided to rewrite my formalization. So far, I have successfully formalized Functions and (topological) Spaces. However, I'm encountering difficulties when trying to formalize a presheaf, which is a contravariant functor from a topological space into sets, using <code>transfer</code>.</p>\n<p>I defined a RawPresheaf as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">record</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">RawPresheaf</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">  </span><span class=\"n\">prim_space</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'A Space\"</span>\n<span class=\"w\">  </span><span class=\"n\">prim_ob</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('A Open, 'x set) Function\"</span>\n<span class=\"w\">  </span><span class=\"n\">prim_ar</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('A Inclusion, ('x, 'x) Function) Function\"</span>\n</code></pre></div>\n<p>It includes a valid predicate:</p>\n<p><code>definition valid :: \"('A, 'x) RawPresheaf ⇒ bool\"</code></p>\n<p>Then I defined <code>Presheaf</code> as:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'A</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">Presheaf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"{ rF :: ('A, 'x) RawPresheaf . valid rF}\"</span>\n</code></pre></div>\n<p>Now, I am attempting to prove the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"lemma\"><pre><span></span><code>  fixes F :: \"('A, 'x) Presheaf\" and i :: \"'A Inclusion\"\n  assumes \"i ∈ inclusions (space F)\"\n  shows \"Function.dom (ar F ⋅ i) = ob F ⋅ (Space.cod i)\"\n  apply transfer\n</code></pre></div>\n<p>The current state of the proof is as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prove</span><span class=\"o\">)</span>\n<span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"w\"> </span><span class=\"n\">subgoals</span><span class=\"o\">):</span>\n<span class=\"w\"> </span><span class=\"n\">1.</span><span class=\"w\"> </span><span class=\"n\">⋀F</span><span class=\"w\"> </span><span class=\"n\">i.</span><span class=\"w\"> </span><span class=\"n\">Presheaf.valid</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">⟹</span><span class=\"w\"> </span><span class=\"n\">valid_inc</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"n\">⟹</span><span class=\"w\"> </span><span class=\"n\">Function.raw_dom</span><span class=\"w\"> </span><span class=\"o\">(?</span><span class=\"n\">ad17</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prim_ar</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">prim_ob</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"n\">⋅</span><span class=\"w\"> </span><span class=\"n\">RawInclusion.raw_cod</span><span class=\"w\"> </span><span class=\"n\">i</span>\n<span class=\"w\"> </span><span class=\"n\">2.</span><span class=\"w\"> </span><span class=\"n\">Transfer.Rel</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rel_fun</span><span class=\"w\"> </span><span class=\"o\">(=)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rel_fun</span><span class=\"w\"> </span><span class=\"n\">cr_Inclusion</span><span class=\"w\"> </span><span class=\"n\">cr_Function</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">ad17</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">⋅</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It appears that the presence of the anonymous function <code>?ad17</code> indicates that transfer has failed on the <code>\\cdot</code> operation (defined as <code>app</code>), even though <code>app</code> is defined as a lifted version of <code>raw_app</code>](<a href=\"https://github.com/nasosev/cva/blob/1c0a16aac93a21f0cb292977836d402a6573d096/new/Function.thy#L76\">https://github.com/nasosev/cva/blob/1c0a16aac93a21f0cb292977836d402a6573d096/new/Function.thy#L76</a>), and I did not encounter any problems using <code>transfer</code> on <code>app</code> in the Space and Function theories, only in Presheaf, which is defined in terms of them. Hence, I suspect that the issue may be due to the nested <code>typedef</code> definition of Presheaf, but I'm not certain. I have consulted the manual and attempted to use <code>transfer'</code>, <code>transfer_prover</code>, and <code>transfer fixing:</code>, but without success.</p>\n<p>I would greatly appreciate any assistance here! The source code is available <a href=\"https://github.com/nasosev/cva/tree/main/new\">here</a>.</p>",
        "id": 371173791,
        "sender_full_name": "Naso",
        "timestamp": 1688133579
    }
]