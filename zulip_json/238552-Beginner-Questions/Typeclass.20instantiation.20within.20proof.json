[
    {
        "content": "<p>Is it possible to instantiate a (type)class within a proof? The \"instantiation\" and \"instance\" keywords do not work. If not, how can I work around this?</p>\n<p>Here is an MWE showing the kind of thing I am trying to do:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span><span class=\"w\"> </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"{f::nat ⇒ 'a ::{zero}. True}\"</span>\n<span class=\"w\">  </span><span class=\"kp\">morphisms</span><span class=\"w\"> </span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"n\">Abs</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n\n<span class=\"k\">setup_lifting</span><span class=\"w\"> </span><span class=\"n\">type_definition_ps</span>\n\n<span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"{plus,zero}\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">plus</span>\n<span class=\"k\">begin</span>\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"n\">plus_ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a ps ⇒ 'a ps ⇒ 'a ps\"</span><span class=\"w\"> </span><span class=\"kp\">is</span><span class=\"w\"> </span><span class=\"s\">\"λf g x. f x + g x\"</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"{semigroup_add,zero}\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">semigroup_add</span>\n<span class=\"k\">begin</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">(* imagine a proof here *)</span>\n<span class=\"k\">end</span>\n\n<span class=\"kn\">lemma</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span><span class=\"w\"> </span><span class=\"c\">(* want to prove this *)</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>In this example, I want to instantiate the type <code>'a</code> with class <code>semigroup_add</code> in order to prove the lemma. Alternatively, I tried the following proof:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span>\n<span class=\"k\">proof</span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"OFCLASS('a, semigroup_add_class)\"</span><span class=\"w\"> </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">semigroup_add_class_def</span>\n<span class=\"w\">  </span><span class=\"k\">proof</span><span class=\"o\">-</span>\n<span class=\"w\">    </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"OFCLASS('a, plus_class)\"</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"w\">  </span><span class=\"k\">next</span>\n<span class=\"w\">    </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)\"</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"ow\">.</span>\n<span class=\"w\">  </span><span class=\"k\">qed</span>\n<span class=\"w\">  </span><span class=\"k\">hence</span><span class=\"w\"> </span><span class=\"s\">\"OFCLASS('a ps, semigroup_add_class)\"</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">hence</span><span class=\"w\"> </span><span class=\"s\">\"OFCLASS('a ps, plus_class) &amp;&amp;&amp; class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span><span class=\"w\"> </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">semigroup_add_class_def</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"k\">thus</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>However, I'm not sure how to fill the gaps.</p>\n<p>Of course, the last instantiation in my MWE is morally equivalent to the lemma I want to prove, but I'm trying to do this in a more complicated context (I'm using types to sets).</p>",
        "id": 388179817,
        "sender_full_name": "Artem Khovanov",
        "timestamp": 1693422982
    },
    {
        "content": "<p>I use interpret:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"{f::nat ⇒ 'a ::{zero}. True}\"</span>\n<span class=\"w\">  </span><span class=\"kp\">morphisms</span><span class=\"w\"> </span><span class=\"n\">nth</span><span class=\"w\"> </span><span class=\"n\">Abs</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n\n<span class=\"k\">setup_lifting</span><span class=\"w\"> </span><span class=\"n\">type_definition_ps</span>\n\n<span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"{plus,zero}\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">plus</span>\n<span class=\"k\">begin</span>\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"n\">plus_ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a ps ⇒ 'a ps ⇒ 'a ps\"</span><span class=\"w\"> </span><span class=\"kp\">is</span><span class=\"w\"> </span><span class=\"s\">\"λf g x. f x + g x\"</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"k\">end</span>\n\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">False</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">interpret</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">semigroup_add</span><span class=\"w\"> </span><span class=\"s\">‹plus :: 'a :: {semigroup_add,zero} ps ⇒ 'a ps ⇒ 'a ps›</span>\n<span class=\"w\">    </span><span class=\"gr\">sorry</span>\n<span class=\"w\">  </span><span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">ps.add_assoc</span>\n</code></pre></div>",
        "id": 388181114,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1693423526
    },
    {
        "content": "<p>I'm not sure how I can use this to apply my instantiation. As I understand, I would have to basically repeat the instantiation proof within the <code>interpret</code>? What I would like to do is to somehow use the existing instantiation to prove the lemma.</p>\n<p>For instance if I have this instantiation:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"{semigroup_add,zero}\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">semigroup_add</span>\n<span class=\"k\">begin</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">standard</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">transfer</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">add.assoc</span><span class=\"o\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>I don't want to have to repeat its proof in the proof of my lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span>\n</code></pre></div>\n<p>In my actual application the instantiation proof is long and split over many classes.</p>",
        "id": 388210407,
        "sender_full_name": "Artem Khovanov",
        "timestamp": 1693437115
    },
    {
        "content": "<p>If you can prove the instantiation, the proof is trivial:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\">  </span><span class=\"k\">interpret</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">semigroup_add</span><span class=\"w\"> </span><span class=\"s\">‹plus :: 'a :: {semigroup_add,zero} ps ⇒ 'a ps ⇒ 'a ps›</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold_locales</span>\n</code></pre></div>",
        "id": 388249436,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1693457923
    },
    {
        "content": "<p>BTW for the lemma you did not know how to prove <code>class.semigroup_add</code> is a constant, so <code>class.semigroup_add_def</code> exists to unfold it.</p>",
        "id": 388249624,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1693458027
    },
    {
        "content": "<p>Sorry, I'm still unsure how to proceed. In my example, I don't have the<code>'a::semigroup_add</code> class annotation, I just have the fact <code>class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)</code>. What I'm unsure how to do is precisely this: how to go from this <code>class.semigroup_add</code> assertion to the <code>::semigroup_add</code> annotation.</p>",
        "id": 388344776,
        "sender_full_name": "Artem Khovanov",
        "timestamp": 1693494218
    },
    {
        "content": "<p>Basically, what I want to prove is this lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span>\n</code></pre></div>\n<p>Given this instantiation:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"{semigroup_add,zero}\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">semigroup_add</span>\n</code></pre></div>",
        "id": 388346196,
        "sender_full_name": "Artem Khovanov",
        "timestamp": 1693494633
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">unfold_locales</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">transfer</span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">assms</span><span class=\"w\"> </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"k\">class</span><span class=\"ow\">.</span><span class=\"n\">semigroup_add_def</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n</code></pre></div>",
        "id": 388348742,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1693495346
    },
    {
        "content": "<p>Doesn't this proof just repeat the proof of the instantiation? In my application, the proof of the instantiation is quite long and split over many classes, and what I'm asking essentially is whether it's possible to just reference it rather than writing it all out again.</p>",
        "id": 388351021,
        "sender_full_name": "Artem Khovanov",
        "timestamp": 1693495977
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">hand_written_instance</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a::{plus,zero}⇒'a⇒'a)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a ps⇒'a ps⇒'a ps)\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"k\">class</span><span class=\"ow\">.</span><span class=\"n\">semigroup_add_def</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"n\">ps</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"{semigroup_add,zero}\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">semigroup_add</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">  </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"class.semigroup_add ((+)::'a⇒'a⇒'a)\"</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">unfold_locales</span>\n<span class=\"w\">  </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">hand_written_instance</span><span class=\"o\">[</span><span class=\"n\">OF</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\">  </span><span class=\"s\">‹OFCLASS('a ps, semigroup_add_class)›</span>\n<span class=\"w\">    </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">intro_classes</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">unfold</span><span class=\"w\"> </span><span class=\"k\">class</span><span class=\"ow\">.</span><span class=\"n\">semigroup_add_def</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n<span class=\"k\">qed</span>\n</code></pre></div>",
        "id": 388366592,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1693499941
    },
    {
        "content": "<p>Ah OK, thanks! I guess what I was wondering was if it was possible to go in the other direction. In my application, the instance proof already exists, and I need the hand-written proof (so that I can apply the transfer package). I think what I will have to do is to manually create the hand-written proof by pasting in each instance proof, then stitching them together.</p>\n<p>What I am actually trying to obtain is a \"hand-written\" version of</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">fpxs</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">field</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">field</span>\n</code></pre></div>\n<p>in <code>Formal_Puiseux_Series.Formal_Puiseux_Series</code> (from the AFP).</p>",
        "id": 388371695,
        "sender_full_name": "Artem Khovanov",
        "timestamp": 1693501669
    },
    {
        "content": "<p>(In case anyone comes across this)<br>\nThe way you do what I wanted to do (ie turn the type sort into a locale hypothesis) is by using the attribute <code>unoverload_type 'a</code> from the Types-To-Sets library. An example is here:<br>\n<a href=\"https://isabelle.in.tum.de/dist/library/HOL/HOL-Types_To_Sets/T2_Spaces.html\">https://isabelle.in.tum.de/dist/library/HOL/HOL-Types_To_Sets/T2_Spaces.html</a></p>",
        "id": 389059693,
        "sender_full_name": "Artem Khovanov",
        "timestamp": 1693865591
    }
]