[
    {
        "content": "<p>I am attempting to prove the strong normalisation of combinatory logic. I have run into an unexpected \"Unbound Schematic Variable <code>?thesis</code>\" error. The code is below (I have attempted to minimise as far as possible and am using Isabelle 2020). Most likely missing something obvious as I am pretty new to Isabelle. The error occurs in the last <code>sorried</code> proof at both instance of <code>?thesis</code>.</p>\n<div class=\"codehilite\"><pre><span></span><code>section â€¹Strong_Normalisationâ€º\n\ntheory Strong_Normalisation\n  imports Main\n  abbrevs &quot;âŸ¶w&quot; = &quot;âŸ¶â‡©w&quot;\n      and &quot;â†’p&quot; = &quot;â†’â‡©p&quot;\n      and &quot;âŸ¶b&quot; = &quot;âŸ¶â‡©Î²&quot;\nbegin\n\n(* definition of types for combinatory terms *)\n\ndatatype tp = is_At:  TAtt &quot;nat&quot; | TArr &quot;tp&quot; &quot;tp&quot; (infixr &quot;â†’â‡©p&quot; 200)\n\nabbreviation is_Arr :: &quot;tp â‡’ bool&quot; where\n  &quot;is_Arr Ï„ â‰¡ Â¬ (is_At Ï„)&quot;\n\n(* head of a combinatory term *)\n\ndatatype (plugins del: size) hd =\n  is_Var: Var (var: string)(type: tp) (&quot;_:_&quot; [100,100] 100)\n| is_S : S (type: tp)  (&quot;S:_&quot; 100)\n| is_K : K (type: tp)  (&quot;K:_&quot; 100)\n| is_Sym: Sym (sym: string)(type: tp) (&quot;_:_&quot; [100,100] 100)\n\nabbreviation is_Comb :: &quot; hd â‡’ bool&quot; where\n  &quot;is_Comb Î¶ â‰¡ (is_S Î¶) âˆ¨  (is_K Î¶)&quot;\n\nsubsection â€¹Termsâ€º\n\nconsts head0 :: &#39;a\n\n(* combinatory term *)\n\ndatatype  tm =\n  is_Hd: Hd &quot;hd&quot;\n| App (&quot;fun&quot;:  &quot;tm&quot;) (arg: &quot; tm&quot;)\nwhere\n  &quot;head (App s _) = head0 s&quot;\n| &quot;fun (Hd Î¶) = Hd Î¶&quot;\n| &quot;arg (Hd Î¶) = Hd Î¶&quot;\n\noverloading head0 â‰¡ &quot;head0 :: tm â‡’ hd&quot;\nbegin\n\nprimrec head0 :: &quot;tm â‡’ hd&quot; where\n  &quot;head0 (Hd Î¶) = Î¶&quot;\n| &quot;head0 (App s _) = head0 s&quot;\n\nend\n\nsubsection â€¹Definition of types and combinatorsâ€º\n\nfun args :: &quot;tm â‡’ tm list&quot; where\n  &quot;args (Hd _) = []&quot;\n| &quot;args (App s t) = args s @ [t]&quot;\n\n(* type of head symbol *)\ndefinition type_hd :: &quot;hd â‡’ tp&quot; where\n  &quot;type_hd t = type(t)&quot;\n\n(* type of term *)\nfun type :: &quot;tm â‡’ tp&quot; where\n&quot;type (Hd h) = type_hd h&quot; |\n&quot;type (App s t) = (case (type s) of\n                    TAtt Ï„ â‡’ TAtt Ï„ |\n                    (Î± â†’â‡©p Î³) â‡’ Î³)&quot;\n\nfun size_tp :: &quot;tp â‡’ nat&quot; where\n &quot;size_tp (TAtt Ï„) = 0&quot; |\n &quot;size_tp (Î± â†’â‡©p Î³) = 1 + size_tp Î± + size_tp Î³&quot;\n\n(* inductive predicate that holds if term is well-typed *)\ninductive typed :: &quot;tm â‡’ bool&quot; where\n&quot;typed (Hd (Var _ _))&quot; |\n&quot;typed (Hd (Sym _ _))&quot; |\n&quot;typed (Hd (K (Ïƒ â†’â‡©p Î³ â†’â‡©p Ïƒ)))&quot; |\n&quot;typed (Hd (S ((Ïƒ â†’â‡©p Ï„ â†’â‡©p Î³) â†’â‡©p (Ïƒ â†’â‡©p Ï„) â†’â‡©p Ïƒ â†’â‡©p Î³)))&quot; |\n&quot;typed t1 âŸ¹ (type t1 = (Ïƒ â†’â‡©p Î³)) âŸ¹ typed t2 âŸ¹ (type t1 = Ïƒ) âŸ¹ typed (App t1 t2)&quot;\n\n\n(* inductive definition of combinatory (weak) reduction *)\ninductive\n  weak_reduce :: &quot;tm â‡’ tm â‡’ bool&quot; (&quot; _ âŸ¶â‡©w _&quot; [80,80] 80)\nwhere\n  w1[intro!]: &quot;t1 âŸ¶â‡©w t2 âŸ¹ App t1 t âŸ¶â‡©w App t2 t&quot;\n| w2[intro!]: &quot;t1 âŸ¶â‡©w t2 âŸ¹ App t t1 âŸ¶â‡©w App t t2&quot;\n| w4[intro!]: &quot;App (App (Hd (K _)) t1) t2 âŸ¶â‡©w t1&quot;\n| w7[intro!]: &quot;App (App (App (Hd (S _)) t1) t2 ) t3 âŸ¶â‡©w App (App t1 t3) (App t2 t3)&quot;\n\ninductive\n weak_star :: &quot;tm â‡’ tm â‡’ nat â‡’ bool&quot;  (&quot; _ âŸ¶â‡©w* _ _&quot; [80,80] 80)\nwhere\n ws1[intro!] : &quot;t âŸ¶â‡©w* t 0&quot;\n|ws2[intro!] : &quot;âŸ¦(t âŸ¶â‡©w t&#39;); (t&#39; âŸ¶â‡©w* t&#39;&#39; n)âŸ§ âŸ¹ (t âŸ¶â‡©w* t&#39;&#39; (n+1))&quot;\n\ndefinition normal_form :: &quot;tm â‡’ bool&quot; where\n &quot;normal_form t1 = (âˆ€ x. Â¬(t1 âŸ¶â‡©w x))&quot;\n\ndefinition normalizable :: &quot;tm â‡’ bool&quot; where\n &quot;normalizable t1 = (âˆƒ x n. ((t1 âŸ¶â‡©w* x n) âˆ§ (normal_form x)))&quot;\n\ndefinition bounded_sn :: &quot;nat â‡’ tm â‡’ bool&quot; where\n  &quot;bounded_sn n t1 âŸ· (âˆ€m. âˆ€ t. (t1 âŸ¶â‡©w* t m) âŸ¶ m â‰¤ n)&quot;\n\ndefinition sn :: &quot;tm â‡’ bool&quot; where\n &quot;sn t1 = (âˆƒn. bounded_sn n t1)&quot;\n\nfunction sc :: &quot;tm â‡’ bool&quot; where\n &quot;sc t1 = (case (type t1) of\n            TAtt Ï„ â‡’ sn t1 |\n            (Î± â†’â‡©p Î³) â‡’ (âˆ€ t2. (type t2 = Î±) âŸ¶ (sc t2 âŸ¶  sc (App t1 t2) ) ))&quot;\n  by auto\n  termination\n    by (relation &quot;measure (Î»(t). size_tp (type t))&quot;) auto\n\nlemma a3_10 :\n  fixes Ï„ :: &quot;tp&quot; and\n        t :: &quot;tm&quot;\n  assumes &quot;typed t&quot; and\n          &quot;type t = Ï„&quot; and\n          &quot; Â¬ (is_Comb (head t))&quot;\n  shows  &quot;âˆ€s âˆˆ (set (args t)). sn s âŸ¹ sc t&quot; and\n         &quot;sc t âŸ¹ sn t&quot;\n  using assms\nproof(induction &quot;size_tp Ï„&quot;)\n  case 0\n  then show ?thesis sorry\nnext\n  case (Suc x)\n  then show ?thesis sorry\nqed\n</code></pre></div>",
        "id": 236357790,
        "sender_full_name": "Ahmed B",
        "timestamp": 1619537036
    },
    {
        "content": "<p><code>?thesis</code> is the last explicitly stated goal; you can't normally use that in an induction anyway because the induction changes the goal. You should use <code>?case</code> instead.</p>\n<p>The reason why <code>?case</code> does not work here either is probably because each of the two cases has two goals. I guess the <code>induction</code>method does not define <code>?case</code> when there is more than one. You can either write down the goals in <code>show</code> explicitly, or you could change your lemma statement so that you use HOL implication and connect the two goals with a HOL conjunction (i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>âˆ§</mo></mrow><annotation encoding=\"application/x-tex\">\\wedge</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">âˆ§</span></span></span></span>) so that you only have one goal.</p>",
        "id": 236358507,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1619537271
    },
    {
        "content": "<p>Thanks for your swift response!</p>",
        "id": 236359497,
        "sender_full_name": "Ahmed B",
        "timestamp": 1619537507
    },
    {
        "content": "<p>Other solution:<br>\n(I don't understand why the <code>next</code> between the cases are necessaryâ€¦)</p>\n<div class=\"codehilite\"><pre><span></span><code>proof(induction &quot;size_tp Ï„&quot;)\n  case 0\n  case 1\n  show ?case\n    sorry\nnext\n  case 0\n  case 2\n  show ?case\n    sorry\nnext\n  case (Suc x)\n  case 1\n  show ?case\n    sorry\nnext\n  case (Suc x)\n  case 2\n  show ?case\n    sorry\nqed\n</code></pre></div>",
        "id": 236362273,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1619538530
    },
    {
        "content": "<p>What!?! ðŸ¤¯</p>",
        "id": 236362469,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1619538604
    },
    {
        "content": "<p>TIL</p>",
        "id": 236362596,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1619538638
    },
    {
        "content": "<p>The slight problem with this idiom is that I have never seen any documentation on it. So I don't really know if I should search longer or of it accidentally works.</p>",
        "id": 236367571,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1619540534
    },
    {
        "content": "<p>(I think I stumbled by accident on itâ€¦)</p>",
        "id": 236367610,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1619540556
    }
]