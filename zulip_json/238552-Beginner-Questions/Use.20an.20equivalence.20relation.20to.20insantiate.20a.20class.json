[
    {
        "content": "<p>Similar to my previous question, I have a <code>Value</code> datatype and an <code>evalValue :: Environment =&gt; State =&gt; Value =&gt; int</code> function. </p>\n<p>I'm trying to instantiate the <code>semigroup_add</code> class for <code>Value</code>, but of course this is not true</p>\n<p><code> AddValue (AddValue a b) c = AddValue a (AddValue b c)</code></p>\n<p>Can I use <code>valueEquiv</code> and <code>semigroup_add_value_equiv</code> defined below to instantiate the <code>semigroup_add</code> class?</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">zero</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"zero_Value = Constant 0\"</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">one</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"one_Value = Constant 1\"</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">plus</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"plus_Value a b = AddValue a b\"</span>\n\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">valueEquiv</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"Value ⇒ Value ⇒ bool\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">infix</span><span class=\"w\"> </span><span class=\"s\">‹≡⇩v›</span><span class=\"w\"> </span><span class=\"n\">50</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"(a ≡⇩v b) ⟷  (∀env st. evalValue env st a = evalValue env st b)\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">semigroup_add_value_equiv</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"a + b + c ≡⇩v a + (b + c)\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">valueEquiv_def</span><span class=\"w\"> </span><span class=\"n\">plus_Value_def</span><span class=\"o\">)</span>\n\n\n<span class=\"k\">instantiation</span><span class=\"w\"> </span><span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">semigroup_add</span>\n<span class=\"k\">begin</span>\n<span class=\"kn\">instance</span><span class=\"w\"> </span><span class=\"k\">proof</span>\n<span class=\"w\">  </span><span class=\"k\">fix</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">Value</span>\n<span class=\"w\">  </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"s\">\"(a + b) + c = a + (b + c)\"</span>\n<span class=\"w\">    </span><span class=\"c\">(* Can I use the equivalence rule to solve this? *)</span>\n<span class=\"k\">qed</span>\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 338082930,
        "sender_full_name": "Hernán Rajchert",
        "timestamp": 1677375403
    },
    {
        "content": "<p>You might want to consider defining your Value type as a quotient type on the equivalence relation you give. This would give you the properties you desire from your type, abstracting away implementation details of how Values are stored.</p>",
        "id": 338281005,
        "sender_full_name": "Christian Pardillo Laursen",
        "timestamp": 1677491792
    },
    {
        "content": "<p>I was going to say the same. However, I think <span class=\"user-mention\" data-user-id=\"551600\">@Hernán Rajchert</span> is interested in code extraction. How does code extraction work for quotient types? Is it possible to (easily) extract code that works with the underlying representations?</p>",
        "id": 338332393,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1677505992
    },
    {
        "content": "<p>My knowledge of quotient types is limited, and I think it might make more sense for the <code>AssocMap</code> (in the previous question) than the <code>Value</code> type. </p>\n<p>My idea of adding <code>semigroup_add</code> to <code>Value</code> was because I wanted to overload the <code>numeral</code> class (and also the arithmetic functions) to have a nicer syntax when I write my language expression in Isabelle. With the help of some <code>abbreviation</code>s I was able to achieve the following syntax</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"n\">const</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"int ⇒ Value\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">‹_⇩c›</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">1000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">1000</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"(n)⇩c ≡ Constant n\"</span>\n\n<span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"n\">addValue</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"[Value, Value] ⇒ Value\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">infixl</span><span class=\"w\"> </span><span class=\"s\">‹+⇩v›</span><span class=\"w\"> </span><span class=\"n\">65</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"a +⇩v b ≡ AddValue a b\"</span>\n\n<span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"n\">subValue</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"[Value, Value] ⇒ Value\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">infixl</span><span class=\"w\"> </span><span class=\"s\">‹-⇩v›</span><span class=\"w\"> </span><span class=\"n\">65</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"a -⇩v b ≡ SubValue a b\"</span>\n\n<span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"n\">mulValue</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"[Value, Value] ⇒ Value\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">infixl</span><span class=\"w\"> </span><span class=\"s\">‹⋆⇩v›</span><span class=\"w\"> </span><span class=\"n\">70</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"a ⋆⇩v b ≡ MulValue a b\"</span>\n\n<span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"n\">divValue</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"Value ⇒ Value ⇒ Value\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">infixl</span><span class=\"w\"> </span><span class=\"s\">\"(÷⇩v)\"</span><span class=\"w\"> </span><span class=\"n\">70</span><span class=\"o\">)</span><span class=\"w\">  </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"a ÷⇩v b ≡ DivValue a b\"</span>\n\n<span class=\"k\">abbreviation</span><span class=\"w\"> </span><span class=\"n\">condValue</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"Observation ⇒ Value ⇒ Value ⇒ Value\"</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">‹_ ?⇩v _ : _›</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">1000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">1000</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">1000</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"n\">700</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"c ?⇩v t : f ≡ Cond c t f\"</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v1 = Constant 3 +⇩v Constant 2\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v2 = Constant 3 +⇩v Constant 2\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v3 = 4⇩c -⇩v Constant 3\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v4 = 4⇩c -⇩v 3⇩c\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v5 = 6⇩c ÷⇩v 2⇩c\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v6 = 6⇩c +⇩v 4⇩c ÷⇩v 2⇩c\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v7 = (6⇩c +⇩v 4⇩c) ÷⇩v 2⇩c\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v8 = TrueObs ?⇩v 4⇩c : 6⇩c\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v9 = FalseObs ?⇩v 4⇩c : 6⇩c\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v10 = TrueObs ?⇩v (4⇩c +⇩v 32⇩c) : 6⇩c\"</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">\"v11 = FalseObs ?⇩v (4⇩c +⇩v 2⇩c) : 6⇩c ⋆⇩v 2⇩c\"</span>\n</code></pre></div>\n<p>If I could define <code>numeral</code>, <code>plus</code>,  <code>minus</code>,<code>times</code> and <code>divide/inverse</code> then I wouldn't need the abbreviations.</p>\n<p>Note that <code>Value</code> and <code>Observation</code> are mutual recursive and so are <code>evalValue</code> and <code>evalObservation</code>. This raises three questions: </p>\n<ul>\n<li>Can I define a quotient type for a mutual recursion?</li>\n<li>Does it make sense to leave Value as it is and create another \"wrapper\" type that uses <code>Value</code> and <code>evalValue</code> with the equivalence relationship? </li>\n<li>Is this worth it or should I just use abbreviations? I noted that in <code>concrete semantics</code> the types for IMP are defined normally and they use an equivalence <code>~</code> to check if two commands are equivalent, they don't use a quotient type</li>\n</ul>",
        "id": 338351121,
        "sender_full_name": "Hernán Rajchert",
        "timestamp": 1677510052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"551600\">Hernán Rajchert</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Use.20an.20equivalence.20relation.20to.20insantiate.20a.20class/near/338351121\">said</a>:</p>\n<blockquote>\n<p>My idea of adding <code>semigroup_add</code> to <code>Value</code> was because I wanted to overload the <code>numeral</code> class (and also the arithmetic functions) to have a nicer syntax when I write my language expression in Isabelle.</p>\n</blockquote>\n<p>At least for order relations there is a base class that contains only the relevant methods, like <code>(&lt;)</code>, but not properties. Maybe something like that also exists for <code>(+)</code>. You may want to trace the superclass chains that start from <code>semigroup_add</code> back to the superclasses.</p>",
        "id": 338354468,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1677510784
    },
    {
        "content": "<blockquote>\n<p>Can I define a quotient type for a mutual recursion?</p>\n</blockquote>\n<p>You always define a quotient type based on a representation type, like you do for subtypes. If only your representation types are defined by multiple recursion, you’re fine.</p>",
        "id": 338355361,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1677510980
    },
    {
        "content": "<p>Yes, the <code>plus</code>,  <code>minus</code> and <code>times</code> could offer me the <code>(+)</code>, <code>(-)</code> and <code>(*)</code> syntax override. The <code>divide</code> class offers me an infix <code>div</code> and the <code>inverse_divide</code> offers me <code>/</code> (which I don't think applies here because my Constant's are ints, so I cannot offer an inverse)</p>\n<p>Maybe as a compromise, I can define the classes that doesn't involve properties for their syntax, use the <code>sub_c</code> abbreviation for Constants, and then have equivalence relations instead of equality relations. But this means I could never use the <code>semigroup_add</code> class, at most I could use the <code>semigroup</code> locale with an <code>f</code> that uses <code>evalValue</code>. Not sure if this would be useful or if it just complicates things.</p>",
        "id": 338360320,
        "sender_full_name": "Hernán Rajchert",
        "timestamp": 1677512106
    },
    {
        "content": "<p>When just specifying, I would always opt for quotient types, I think. If quotient types work well with code extraction, I’d go for it also here, I guess. I haven’t looked at the details of your code, though.</p>",
        "id": 338366771,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1677513699
    }
]