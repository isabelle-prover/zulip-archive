[
    {
        "content": "<p>I've got a pair of locales defining something called an affine plane: affine_plane_data, which is then included into affine_plane. </p>\n<p>I've got another local defining a projective plane.  (this is a little bit like having locals for Groups and Rings, say except that a Group starts with a set and two operations, while an affine plane starts with two sets and three functions, so it's a little messier. </p>\n<p>There's a construction for taking an affine plane and building an associated projective plane, and I'm trying to formalize it. As a first step, I need to show that there's a unique something with some property; I have a lemma stating that:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'point</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'line</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">projPoint</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">OrdinaryP</span><span class=\"w\"> </span><span class=\"n n-Type\">'point</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Ideal</span><span class=\"w\"> </span><span class=\"s\">\"'line set\"</span>\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'point</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'line</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">projLine</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">OrdinaryL</span><span class=\"w\"> </span><span class=\"n n-Type\">'line</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Infty</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">AB</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">Points</span><span class=\"o\">::</span><span class=\"s\">\"'p set\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">Lines</span><span class=\"o\">::</span><span class=\"s\">\"'l set\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">meets</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'p â‡’ 'l â‡’ bool\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">join</span><span class=\"o\">::</span><span class=\"s\">\"'p â‡’ 'p â‡’ 'l\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">find_parallel</span><span class=\"o\">::</span><span class=\"s\">\"'l â‡’ 'p â‡’ 'l\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">ap</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"affine_plane Points Lines meets join find_parallel\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">lp</span><span class=\"o\">::</span><span class=\"s\">\"'l â‡’ 'l set\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"lp = affine_plane_data.line_pencil Points Lines meets\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">::</span><span class=\"n n-Type\">'p</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"P âˆˆ Points\"</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">pPoints</span><span class=\"o\">::</span><span class=\"s\">\"('p, 'l) projPoint set\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">pp</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"pPoints =  {OrdinaryP R | R. (R âˆˆ Points)} âˆª {Ideal s | s k . (k âˆˆ Lines) âˆ§ s = lp k}\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"Ideal t âˆˆ pPoints\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"âˆƒ! k âˆˆ Lines . k âˆˆ t âˆ§ meets P k\"</span>\n</code></pre></div>\n<p>whose proof I'll omit. The gist of this is \"if, in an affine plane, you have a point (P) and a line-pencil (t), you can produce a unique line k as shown in the last line of code. </p>\n<p>I'd now like to define a function, <code>point_pencil_join:: 'p =&gt; ('p, 'l projPoint) =&gt; 'l</code> which says \"Given a point and a line-pencil, produce the line guaranteed by the lemma; given anything else, it's undefined.\" </p>\n<p>I have several problems here: </p>\n<ul>\n<li>There are a bunch of assumptions here before I can assure existence and uniqueness, but I don't see how to incorporate those into a function definition. </li>\n<li>Even if I <em>could</em> do so, I don't see how to write a function definition whose right-hand side is \"the thing that theorem promises me exists and is unique\"</li>\n</ul>\n<p>I realize this is all pretty abstract, so offering help is difficult. But if someone has an example (even in the HOL sources) of something like this being done, I'd love to see it. A kind of simple example would be something like </p>\n<p>(a) a theorem showing that for any two integers $x$ and $y$ there are unique Bezout coeffiients $a$ and $b$ with $ax + by = gcd(x,y)$. (Alas, they're not actually unique, but bear with me), and then</p>\n<p>(b) using that theorem to write </p>\n<p><code>define bezout_pair:: int =&gt; int =&gt; int x int where ...</code></p>",
        "id": 501544173,
        "sender_full_name": "John  Hughes",
        "timestamp": 1740403860
    },
    {
        "content": "<p>Some quick suggestions without looking too closely. In my experience for constructing mathematical objects, the function/definition does the construction, then you prove a seperate lemma(s) showing that given certain assumptions holding on the inputs, the result of the function/definition has the properties you want (e.g. is unique etc). Alternatively, if you don't know how to explicitly construct the object consider using the <code>THE</code> keyword in a definition (i.e. THE x . P x represents a unique value that satisfies some predicate P). There are plenty of examples of the latter in the libraries if you do a quick search (SOME is a weaker keyword, which doesn't imply uniqueness). Similar lemmas are still useful in this approach for simplifying reasoning on the definition.</p>",
        "id": 501564822,
        "sender_full_name": "Chelsea Edmonds",
        "timestamp": 1740408844
    },
    {
        "content": "<p>More generally, I have done a lot of work on formalising combinatorial designs - specifically using locales effectively to do so (including constructions which combine several different designs to get a new one etc). Steiner systems and projective planes have the same underlying structure, so this could potentially be useful? Even if just as examples of locale usage in this way. This library is a good starting point: <a href=\"https://www.isa-afp.org/entries/Design_Theory.html\">https://www.isa-afp.org/entries/Design_Theory.html</a> (the hypergraph and undirected graph theory libraries also show other extensions using locales to represent the same structures using different terminologies/types etc).</p>",
        "id": 501566108,
        "sender_full_name": "Chelsea Edmonds",
        "timestamp": 1740409142
    },
    {
        "content": "<p>Also just saw someone else share this great past message re using THE if you go with that approach: <a class=\"message-link\" href=\"/#narrow/channel/238552-Beginner-Questions/topic/Proving.20lemma.20with.20definite.20description/near/291315915\">#Beginner Questions &gt; Proving lemma with definite description @ ðŸ’¬</a></p>",
        "id": 501584227,
        "sender_full_name": "Chelsea Edmonds",
        "timestamp": 1740413196
    }
]