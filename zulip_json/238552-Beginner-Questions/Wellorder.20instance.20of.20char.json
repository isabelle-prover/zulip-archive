[
    {
        "content": "<p>I'm stuck at proving the <code>wellorder</code> properties for <code>char</code>. The current goal is</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">proof</span> <span class=\"o\">(</span><span class=\"n\">prove</span><span class=\"o\">)</span>\n<span class=\"n\">goal</span> <span class=\"o\">(</span><span class=\"n\">1</span> <span class=\"n\">subgoal</span><span class=\"o\">):</span>\n <span class=\"n\">1</span><span class=\"ow\">.</span> <span class=\"err\">⋀</span><span class=\"o\">(</span><span class=\"n\">P</span><span class=\"o\">::</span><span class=\"n\">char</span> <span class=\"err\">⇒</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">char.</span> <span class=\"o\">(</span><span class=\"err\">⋀</span><span class=\"n\">x</span><span class=\"o\">::</span><span class=\"n\">char.</span> <span class=\"o\">(</span><span class=\"err\">⋀</span><span class=\"n\">y</span><span class=\"o\">::</span><span class=\"n\">char.</span> <span class=\"n\">of_char</span> <span class=\"n\">y</span> <span class=\"err\">&lt;</span> <span class=\"n\">of_char</span> <span class=\"n\">x</span> <span class=\"err\">⟹</span> <span class=\"n\">P</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">⟹</span> <span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"err\">⟹</span> <span class=\"n\">P</span> <span class=\"n\">a</span>\n</code></pre></div>\n<p>I would assume this should be pretty straightforward since there exist  a <code>wellorder</code> instance for <code>nat</code>?</p>",
        "id": 246372334,
        "sender_full_name": "Robert Soeldner",
        "timestamp": 1626606939
    },
    {
        "content": "<p>I played around a bit and came up with this instantiation proof:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">wellorder_char</span><span class=\"o\">:</span>\n  <span class=\"s\">\"class.wellorder (λc d. of_char c ≤ (of_char d :: nat)) (λc d. of_char c &lt; (of_char d :: nat))\"</span>\n<span class=\"k\">proof</span> <span class=\"o\">(</span><span class=\"n\">standard</span><span class=\"o\">,</span> <span class=\"n\">auto</span><span class=\"o\">)</span>\n  <span class=\"k\">fix</span> <span class=\"n\">P</span> <span class=\"n\">a</span>\n  <span class=\"k\">assume</span> <span class=\"n\">step</span><span class=\"o\">:</span> <span class=\"s\">\"(⋀y. (of_char y :: nat) &lt; (of_char x :: nat) ⟹ P y) ⟹ P x\"</span> <span class=\"kp\">for</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">char</span>\n  <span class=\"n\">define</span> <span class=\"n\">n</span> <span class=\"kp\">where</span> <span class=\"s\">\"n = (of_char a :: nat)\"</span>\n  <span class=\"k\">have</span> <span class=\"s\">\"⋀q. (of_char q :: nat) ≤ n ⟹ P q\"</span>\n  <span class=\"k\">proof</span> <span class=\"o\">(</span><span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">less_induct</span><span class=\"o\">)</span>\n    <span class=\"k\">case</span> <span class=\"o\">(</span><span class=\"n\">less</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"k\">then</span> <span class=\"k\">show</span> <span class=\"o\">?</span><span class=\"k\">case</span>\n      <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">metis</span> <span class=\"n\">step</span> <span class=\"n\">nat_less_le</span><span class=\"o\">)</span>\n    <span class=\"k\">qed</span>\n  <span class=\"k\">then</span> <span class=\"k\">show</span> <span class=\"s\">\"P a\"</span>\n    <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">n_def</span><span class=\"o\">)</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>I assume it can be simplified, but hope this helps :)</p>",
        "id": 246386716,
        "sender_full_name": "Alexander Taepper",
        "timestamp": 1626625679
    },
    {
        "content": "<p><code>proof (standard, auto)</code>? I see you like to live dangerously. <span aria-label=\"smiling devil\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling devil\">:smiling_devil:</span></p>",
        "id": 246386924,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1626625998
    },
    {
        "content": "<p>Note that if you want a <code>linorder</code> instance for <code>char</code>, you should import <code>HOL-Library.Char_ord</code>.</p>",
        "id": 246387769,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1626627359
    },
    {
        "content": "<p>As for <code>wellorder</code>, here's a more general solution that works for any finite types:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">class</span> <span class=\"n\">finite_linorder</span> <span class=\"o\">=</span> <span class=\"n\">finite</span> <span class=\"o\">+</span> <span class=\"n\">linorder</span>\n<span class=\"k\">begin</span>\n\n<span class=\"kn\">subclass</span> <span class=\"n\">wellorder</span>\n<span class=\"k\">proof</span>\n  <span class=\"k\">fix</span> <span class=\"n\">P</span> <span class=\"o\">::</span> <span class=\"s\">\"'a ⇒ bool\"</span> <span class=\"kp\">and</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n n-Type\">'a</span>\n  <span class=\"k\">assume</span> <span class=\"n\">IH</span><span class=\"o\">:</span> <span class=\"s\">\"⋀x. (⋀y. y &lt; x ⟹ P y) ⟹ P x\"</span>\n  <span class=\"n\">define</span> <span class=\"n\">xs</span> <span class=\"kp\">where</span> <span class=\"s\">\"xs = sorted_list_of_set (UNIV :: 'a set)\"</span>\n  <span class=\"n\">define</span> <span class=\"n\">f</span> <span class=\"kp\">where</span> <span class=\"s\">\"f = (λi. xs ! i)\"</span>\n  <span class=\"n\">define</span> <span class=\"n\">n</span> <span class=\"kp\">where</span> <span class=\"s\">\"n = card (UNIV :: 'a set)\"</span>\n  <span class=\"k\">have</span> <span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"s\">\"set xs = UNIV\"</span> <span class=\"s\">\"sorted xs\"</span> <span class=\"s\">\"distinct xs\"</span> <span class=\"kp\">and</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"s\">\"length xs = n\"</span>\n    <span class=\"k\">unfolding</span> <span class=\"n\">xs_def</span> <span class=\"k\">using</span> <span class=\"n\">finite</span><span class=\"o\">[</span><span class=\"n\">of</span> <span class=\"n\">UNIV</span><span class=\"o\">]</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">n_def</span><span class=\"o\">)</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">range_f</span><span class=\"o\">:</span> <span class=\"s\">\"∃j&lt;n. f j = y\"</span> <span class=\"kp\">for</span> <span class=\"n\">y</span>\n    <span class=\"k\">using</span> <span class=\"n\">xs</span> <span class=\"k\">unfolding</span> <span class=\"n\">f_def</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">metis</span> <span class=\"n\">UNIV_I</span> <span class=\"n\">in_set_conv_nth</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"k\">from</span> <span class=\"n\">xs</span> <span class=\"k\">have</span> <span class=\"n\">less_iff</span><span class=\"o\">:</span> <span class=\"s\">\"f i &lt; f j ⟷ i &lt; j\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"i &lt; n\"</span> <span class=\"s\">\"j &lt; n\"</span> <span class=\"kp\">for</span> <span class=\"n\">i</span> <span class=\"n\">j</span>\n    <span class=\"k\">using</span> <span class=\"n\">that</span> <span class=\"n\">n</span> <span class=\"k\">unfolding</span> <span class=\"n\">f_def</span>\n    <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">metis</span> <span class=\"n\">linorder_class.not_le</span> <span class=\"n\">local.antisym_conv1</span> <span class=\"n\">local.not_less</span> <span class=\"n\">local.sorted_nth_mono</span>\n              <span class=\"n\">nth_eq_iff_index_eq</span> <span class=\"n\">order_class.less_le</span><span class=\"o\">)</span>\n\n  <span class=\"k\">from</span> <span class=\"n\">range_f</span> <span class=\"k\">obtain</span> <span class=\"n\">i</span> <span class=\"kp\">where</span> <span class=\"s\">\"i &lt; n\"</span> <span class=\"s\">\"f i = x\"</span>\n    <span class=\"k\">by</span> <span class=\"n\">blast</span>\n  <span class=\"k\">moreover</span> <span class=\"k\">have</span> <span class=\"s\">\"P (f i)\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"i &lt; n\"</span>\n    <span class=\"k\">using</span> <span class=\"n\">that</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">induction</span> <span class=\"n\">i</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">less_induct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"n\">IH</span> <span class=\"n\">range_f</span> <span class=\"n\">less_iff</span> <span class=\"kp\">in</span> <span class=\"n\">metis</span><span class=\"o\">)</span>\n  <span class=\"k\">ultimately</span> <span class=\"k\">show</span> <span class=\"s\">\"P x\"</span>\n    <span class=\"k\">by</span> <span class=\"n\">blast</span>\n<span class=\"k\">qed</span>\n\n<span class=\"k\">end</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">char</span> <span class=\"o\">::</span> <span class=\"n\">finite_linorder</span> <span class=\"ow\">..</span>\n</code></pre></div>",
        "id": 246387821,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1626627406
    },
    {
        "content": "<p>Or, alternative solution without the extra type class:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">finite_linorder_is_wellorder</span><span class=\"o\">:</span>\n  <span class=\"kp\">assumes</span> <span class=\"s\">\"SORT_CONSTRAINT('a :: {finite, linorder})\"</span>\n  <span class=\"kp\">shows</span>   <span class=\"s\">\"OFCLASS('a, wellorder_class)\"</span>\n<span class=\"k\">proof</span>\n  <span class=\"k\">fix</span> <span class=\"n\">P</span> <span class=\"o\">::</span> <span class=\"s\">\"'a ⇒ bool\"</span> <span class=\"kp\">and</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n n-Type\">'a</span>\n  <span class=\"k\">assume</span> <span class=\"n\">IH</span><span class=\"o\">:</span> <span class=\"s\">\"⋀x. (⋀y. y &lt; x ⟹ P y) ⟹ P x\"</span>\n  <span class=\"n\">define</span> <span class=\"n\">xs</span> <span class=\"kp\">where</span> <span class=\"s\">\"xs = sorted_list_of_set (UNIV :: 'a set)\"</span>\n  <span class=\"n\">define</span> <span class=\"n\">f</span> <span class=\"kp\">where</span> <span class=\"s\">\"f = (λi. xs ! i)\"</span>\n  <span class=\"n\">define</span> <span class=\"n\">n</span> <span class=\"kp\">where</span> <span class=\"s\">\"n = card (UNIV :: 'a set)\"</span>\n  <span class=\"k\">have</span> <span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"s\">\"set xs = UNIV\"</span> <span class=\"s\">\"sorted xs\"</span> <span class=\"s\">\"distinct xs\"</span> <span class=\"kp\">and</span> <span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"s\">\"length xs = n\"</span>\n    <span class=\"k\">unfolding</span> <span class=\"n\">xs_def</span> <span class=\"k\">using</span> <span class=\"n\">finite</span><span class=\"o\">[</span><span class=\"n\">of</span> <span class=\"n\">UNIV</span><span class=\"o\">]</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">simp_all</span> <span class=\"n\">add</span><span class=\"o\">:</span> <span class=\"n\">n_def</span><span class=\"o\">)</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">range_f</span><span class=\"o\">:</span> <span class=\"s\">\"∃j&lt;n. f j = y\"</span> <span class=\"kp\">for</span> <span class=\"n\">y</span>\n    <span class=\"k\">using</span> <span class=\"n\">xs</span> <span class=\"k\">unfolding</span> <span class=\"n\">f_def</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">metis</span> <span class=\"n\">UNIV_I</span> <span class=\"n\">in_set_conv_nth</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"k\">from</span> <span class=\"n\">xs</span> <span class=\"k\">have</span> <span class=\"n\">less_iff</span><span class=\"o\">:</span> <span class=\"s\">\"f i &lt; f j ⟷ i &lt; j\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"i &lt; n\"</span> <span class=\"s\">\"j &lt; n\"</span> <span class=\"kp\">for</span> <span class=\"n\">i</span> <span class=\"n\">j</span>\n    <span class=\"k\">using</span> <span class=\"n\">that</span> <span class=\"n\">n</span> <span class=\"k\">unfolding</span> <span class=\"n\">f_def</span>\n    <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">metis</span> <span class=\"n\">not_less</span> <span class=\"n\">sorted_nth_mono</span> <span class=\"n\">nth_eq_iff_index_eq</span> <span class=\"n\">less_le</span><span class=\"o\">)</span>\n\n  <span class=\"k\">from</span> <span class=\"n\">range_f</span> <span class=\"k\">obtain</span> <span class=\"n\">i</span> <span class=\"kp\">where</span> <span class=\"s\">\"i &lt; n\"</span> <span class=\"s\">\"f i = x\"</span>\n    <span class=\"k\">by</span> <span class=\"n\">blast</span>\n  <span class=\"k\">moreover</span> <span class=\"k\">have</span> <span class=\"s\">\"P (f i)\"</span> <span class=\"kp\">if</span> <span class=\"s\">\"i &lt; n\"</span>\n    <span class=\"k\">using</span> <span class=\"n\">that</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">induction</span> <span class=\"n\">i</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">less_induct</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">use</span> <span class=\"n\">IH</span> <span class=\"n\">range_f</span> <span class=\"n\">less_iff</span> <span class=\"kp\">in</span> <span class=\"n\">metis</span><span class=\"o\">)</span>\n  <span class=\"k\">ultimately</span> <span class=\"k\">show</span> <span class=\"s\">\"P x\"</span>\n    <span class=\"k\">by</span> <span class=\"n\">blast</span>\n<span class=\"k\">qed</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">char</span> <span class=\"o\">::</span> <span class=\"n\">wellorder</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">finite_linorder_is_wellorder</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 246387926,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1626627519
    },
    {
        "content": "<p>Thank you for this. Impressive how fast you found the proof :)</p>",
        "id": 246389850,
        "sender_full_name": "Robert Soeldner",
        "timestamp": 1626630111
    }
]