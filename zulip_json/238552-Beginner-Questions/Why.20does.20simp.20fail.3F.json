[
    {
        "content": "<p>Hi folks. I'm very new to Isabelle, and trying to get started by proving some very basic things about 32-bit words. In the following code I prove a lemma, and then try to use the simp tactic to rewrite using my lemma.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"w\"> </span><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Wordplay</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span><span class=\"w\"> </span><span class=\"s\">\"Word_Lib.Word_32\"</span><span class=\"w\"> </span><span class=\"s\">\"Word_Lib.Hex_Words\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">context</span>\n<span class=\"w\">  </span><span class=\"kp\">includes</span><span class=\"w\"> </span><span class=\"n\">bit_operations_syntax</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">ith_and</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"word32 ⇒ word32 ⇒ nat ⇒ bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"ith_and x y i = ((bit x i) ∧ (bit y i))\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">to_bl_and</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"to_bl(x &amp;&amp; y) = rev (map (ith_and x y) [0 ..&lt;32])\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">to_bl_eq_rev</span><span class=\"w\"> </span><span class=\"n\">word_size</span><span class=\"w\"> </span><span class=\"n\">rev_map</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">bit_and_iff</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">bit_and_iff</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n<span class=\"w\">  </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">bit_and_iff</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">blast</span>\n<span class=\"w\">  </span><span class=\"k\">done</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">and_leq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"∀x y. pop_count (x AND y) ≤ pop_count x\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pop_count_def</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">to_bl_and</span><span class=\"o\">)</span>\n\n<span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>That last <code>apply(simp add:to_bl_and)</code> fails, even though the goal looks like it could be simplified.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">prove</span><span class=\"o\">)</span>\n<span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"n\">subgoal</span><span class=\"o\">):</span>\n<span class=\"w\"> </span><span class=\"n\">1.</span><span class=\"w\"> </span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">y.</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to_bl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)))</span>\n<span class=\"w\">          </span><span class=\"n\">≤</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to_bl</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"n\">Failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"n\">method⌂</span><span class=\"o\">:</span>\n<span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"n\">subgoal</span><span class=\"o\">):</span>\n<span class=\"w\"> </span><span class=\"n\">1.</span><span class=\"w\"> </span><span class=\"n\">∀x</span><span class=\"w\"> </span><span class=\"n\">y.</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to_bl</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)))</span>\n<span class=\"w\">          </span><span class=\"n\">≤</span><span class=\"w\"> </span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"w\"> </span><span class=\"n\">id</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">to_bl</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 359435913,
        "sender_full_name": "Jamie Jorgensen",
        "timestamp": 1684425653
    },
    {
        "content": "<p>Oh! I think I got it! I guess I need to explicitly declare the types of x and y in this lemma. Sorry to post a question, and then immediately get to the answer. Isn't that always the way it goes? I had been tearing my hair out on this one for a while.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">and_leq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"∀x y :: word32. pop_count (x AND y) ≤ pop_count x\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">pop_count_def</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">to_bl_and</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(Still not sure if this is the right way to prove this lemma, but I'm making progress at least)</p>",
        "id": 359445308,
        "sender_full_name": "Jamie Jorgensen",
        "timestamp": 1684428052
    },
    {
        "content": "<p>You could for </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">and_leq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"pop_count (x AND y) ≤ pop_count x\"</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">word32</span>\n</code></pre></div>\n<p>Generally, writing <code>∀</code> for variables in a lemma is a bad idea (if you don't have to give a type, you can drop the for completely).</p>",
        "id": 359545315,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1684473103
    },
    {
        "content": "<p>And for words, expect to write a <em>lot</em> of types</p>",
        "id": 359545334,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1684473119
    },
    {
        "content": "<p>including in intermediate steps if you work on extracting parts of the word</p>",
        "id": 359545395,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1684473148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/Why.20does.20simp.20fail.3F/near/359545315\">said</a>:</p>\n<blockquote>\n<p>You could for </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">and_leq</span><span class=\"w\"> </span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"pop_count (x AND y) ≤ pop_count x\"</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">word32</span>\n</code></pre></div>\n<p>Generally, writing <code>∀</code> for variables in a lemma is a bad idea (if you don't have to give a type, you can drop the for completely).</p>\n</blockquote>\n<p>Thank you! Very helpful!</p>",
        "id": 360146690,
        "sender_full_name": "Jamie Jorgensen",
        "timestamp": 1684723873
    }
]