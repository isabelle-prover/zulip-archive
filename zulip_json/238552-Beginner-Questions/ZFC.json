[
    {
        "content": "<p>Hello, <br>\nI do not work with Isabelle yet and therefore still need some basic information. I am interested  in statements (wff's) of axiomatic set theory  (based on ZFC), such as A:≅ \"∀a∀b∃c∃d (c∈d∧(¬c=a∨¬d=b)∨c=a∧d=b∧¬c∈d)\". The statement A is true in ZFC and is just to give a simple example.<br>\nWhat result does Isabelle return in this case:<br>\n1) statement A is true in ZFC and<br>\n2) chain of evidence for the truth of this statement?<br>\nMany thanks in advance for your feedback.</p>",
        "id": 273670341,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1646152988
    },
    {
        "content": "<p>Hi, when typing in Isabelle/HOL <code>lemma \"∀a b. ∃c d. ((c∈d ∧ (¬c=a ∨¬d=b)) ∨ (c=a ∧ d=b ∧ ¬c∈d))\"</code>, Isabelle immediately outputs a counterexample: </p>\n<div class=\"codehilite\"><pre><span></span><code>Auto Quickcheck found a counterexample:\n  a = a1\n  b = {a1}\n</code></pre></div>\n<p>The reason is because in Isabelle/HOL, <code>a</code> and <code>b</code> above have types <code>a::'a</code> and <code>b::'a set</code> respectively and Isabelle cannot guarantee that type <code>'a</code> has an element other than <code>a</code>. Nevertheless, I assume this is not the case for someone using Isabelle/ZFC which I have not learned to run. On the other hand,  the following theorem is true in Isabelle/HOL:</p>\n<div class=\"codehilite\"><pre><span></span><code>lemma &quot;CARD(&#39;a) ≥ 2 ⟹ ∀a::&#39;a. ∀b::&#39;a set. ∃c d. ((c∈d ∧ (¬c=a ∨¬d=b)) ∨ (c=a ∧ d=b ∧ ¬c∈d))&quot;\n  by (metis (full_types) UNIV_I card.empty card_Suc_eq empty_iff\n      insertCI lessI linorder_not_less numeral_2_eq_2)\n</code></pre></div>\n<p>Here, Isabelle's <code>Sledgehammer</code> tool automatically found a proof calling the theorem prover <code>metis</code> and we are only assuming that the type <code>'a</code> has cardinality greater than 2.</p>",
        "id": 273678158,
        "sender_full_name": "Jonathan Julian Huerta y Munive",
        "timestamp": 1646155694
    },
    {
        "content": "<p>Thanks a lot for the quick response.<br>\nThe opposite of A is<br>\n¬A:≅ ∃ab∀cd (c∈d ⇔ c=a ∧ d=b), hence the counterexample given by the Auto Quickcheck is correct only for one direction:  <br>\n⇐: c=a ∧ d={a} implies c∈d, but the other direction (⇒) of the counterexample for A is not true in ZFC.<br>\nBut the second result  from Isabelle's Sledgehammer is close to the truth in ZFC, even if the constraint \"a has cardinality greater than 2\" is not necessary.<br>\nI suspect that in Isabelle/ZFC the result will be complete including chain of evidence.<br>\nSome further questions:<br>\na) is Isabelle/ZFC available?<br>\nb) is there a chain of evidence in the second example, or does Sledgehammer just provide true/false?</p>",
        "id": 273776109,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1646212298
    },
    {
        "content": "<p>a) Yes just run Isabelle by selecting ZF as base session (<code>isabelle jedit -l ZF</code>)<br>\nb) auto proves your goal automatically.<br>\nc) Sledghemmar is not available for ZF.</p>",
        "id": 273777323,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1646212937
    },
    {
        "content": "<p>Oh and auto does not prove detailled information how it proved the goal</p>",
        "id": 273777426,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1646212982
    },
    {
        "content": "<p>Remark that a large majority of people (including me!) have  never used Isabelle/ZF.</p>",
        "id": 273777493,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1646213020
    },
    {
        "content": "<p>Hello,</p>\n<p>I have now successfully installed Isabelle on my computer (hopefully) and would like to start with a small and simple example. For me it is first important to get familiar with the way Isabelle works. Therefore, I would like to have an automatic proof for statement A in ZFC where <br>\nA= \"∃xn∀t∃u (t∈x ⇒ n∈t∧t∈u∧u∈x)\"<br>\nI have some questions:<br>\ni) what could be the easiest program to run here in Isabelle?</p>\n<p>ii) how do I start the created program?</p>\n<p>iii) Where do I find the result \"A is false\" or \"A is true\" after running the program?</p>\n<p>Thanks a lot in advance</p>",
        "id": 275245176,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1647268978
    },
    {
        "content": "<p>I suggest two things:</p>\n<ul>\n<li>Use, or at least start with, HOL, not ZFC, because Isabelle’s HOL support is much better developed than its ZFC support.</li>\n<li>Study the <code>prog-prove</code> tutorial available from the IDE and the website, as it is by far the best way to get into Isabelle.</li>\n</ul>",
        "id": 275308882,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1647298510
    },
    {
        "content": "<p>There may be some misunderstanding here on what Isabelle is for and what it can do. You don't run programs in Isabelle, at least not in Isabelle/ZF. The main function of Isabelle is to formally verify proofs you provide. It can fill small gaps in your proofs, but it will not serve as an oracle where you provide a statement and it tells you if it is true or not with a generated proof (\"chain of evidence\"). The way it works is that you provide Isabelle/ZF a statement with a proof written in a formal proof language and Isabelle tells you if your proof is correct. Things may be somewhat different in Isabelle/HOL, but I never used it so I do not know the details.</p>",
        "id": 275477228,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1647417848
    },
    {
        "content": "<p>At least with Isabelle/HOL, you can also extract code, meaning you can turn certain computable parts of your development into program code in one of the major functional programming languages (ML, Haskell, Scala, at least). As a result, you can essentially write executable code whose correctness you’ve checked fully or partially.</p>",
        "id": 275537760,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1647448004
    },
    {
        "content": "<p>Thank you for the feedback.<br>\nI would like to explain my ideas more precisely.<br>\nIt is about transforming statements which are described in the language of axiomatic set theory (FOL) as wff, into other statements. The new statement (wff) should be less complicated but equivalent to the original one, within the framework of some given ZFC axioms (union, foundation, replacement). Here is a simple example.<br>\nWe define statements A and B as follows:<br>\nA= \"∃xn∀t∃u (t∈x ⇒ n∈t∧t∈u∧u∈x)\"<br>\nB= \"∃x∀t∃u (t∈x ⇒ t∈u∧u∈x)\"<br>\nNow here the statement A shall be replaced by the simpler B. It is obvious that B follows directly from A (A--&gt;B), but proving the opposite direction is already harder (B--&gt;A). At exactly this point I see the use of Isabelle/HOL (possibly involving Sledgehammer) or Isabelle/ZFC. It is not primarily about getting a chain of evidence from Isabelle, but only a hint that A is derivable from B, under certain assumptions, or not. With such a hint, it then makes sense to search for a chain of evidence, if it is not found automatically. The search for a chain of evidence can be very time-consuming and the knowledge whether (B--&gt;A) or ¬(B--&gt;A) holds would facilitate the work in this context extremely, since in each case the opposite can be excluded (if the problem is decideable). In the present example a helpful result from Isabelle would be the confirmation that (B--&gt;A) holds.</p>",
        "id": 275901182,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1647683367
    },
    {
        "content": "<p>Do I get this correctly that you are looking for automated proving or disproving of such implications or at least simplifications of the problem? There are certainly automated provers in Isabelle, but only few of them are capable of simplifying goals (most will either prove them completely or fail). The only example of a prover that can also simplify and at the same time should work with ZF is <code>simp</code>, but I’m not sure how useful it is for doing what you want to do.</p>",
        "id": 275909679,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1647694970
    },
    {
        "content": "<p>Somewhat surprisingly, for this particular example Isabelle/ZF auto method confirms the implication in both directions, theory file attached <a href=\"/user_uploads/14278/PRKTQokHRaVAXEDejCGSFXjf/Scratch.thy\">Scratch.thy</a> .  I would not count on that happening on nontrivial statements though.</p>",
        "id": 275960302,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1647772688
    },
    {
        "content": "<p>Oh, I didn’t know that <code>auto</code> works for Isabelle/ZF. I think <code>blast</code> only works for Isabelle/HOL. Is that correct?</p>",
        "id": 275969679,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1647786254
    },
    {
        "content": "<p><code>simp</code>, <code>auto</code>, <code>blast</code> and  <code>fast</code> work for Isabelle/ZF.</p>",
        "id": 275973108,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1647791205
    },
    {
        "content": "<p>Ah, I think <code>blast</code> is presented in the reference manual as a classical reasoner, and probably I translated that erroneously as “works only with Isabelle/HOL” instead of “works perhaps also with Isabelle/FOL and Isabelle/ZF but not with Isabelle/CTT”. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 275973355,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1647791580
    },
    {
        "content": "<p>The fact that Isabelle/ZF auto method confirms both directions sounds optimistic to me especially since only one direction is trivial. For the other direction, several ZFC axioms are already needed, some of which I mentioned above, and some formal effort is already required (for B--&gt;A).  <br>\nThe important thing is not so much to get a chain of evidence, but rather the hint that it is possible to find one. With the information that it is possible to find a proof (in the example: Theorem B--&gt;Theorem A), one can then try to construct one. So it would save a lot of effort, because in the negative case one would not try to find a proof by oneself.</p>",
        "id": 275984820,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1647806296
    },
    {
        "content": "<p>The small program example Scratch.thy seems to be exactly what I am looking for in general.<br>\nI just saw that for the theorems A and B I forgot to require that x should be not equal to the empty set (x≠⌀), since in the case x=⌀ both sides always hold, so this means that<br>\nA= \"∃xn∀t∃u (t∈x ⇒ n∈t∧t∈u∧u∈x)∧x≠⌀\" and B= \"∃x∀t∃u (t∈x ⇒ t∈u∧u∈x)∧x≠⌀\"<br>\nUnder this change, does Isabelle/ZF auto method also confirm both directions?</p>",
        "id": 276016150,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1647849770
    },
    {
        "content": "<p>After adding the x nonempty condition  A --&gt; B is accepted but  B--&gt; A is not.</p>",
        "id": 276018945,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1647851832
    },
    {
        "content": "<p>Is there a chance that simp, blast, or fast with the example program Scratch.thy find a correct solution? Is sledgehammer available for Isabelle/ZF after all?</p>",
        "id": 276039427,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1647864003
    },
    {
        "content": "<p>By definition, the answer accepted is correct. But there is no guarantee that tactics can prove every provable goal.</p>",
        "id": 276039997,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1647864334
    },
    {
        "content": "<p>simp, blast and fast also do not accept B--&gt;A in this example. Sledgehammer is not available for Isabelle/ZF.</p>",
        "id": 276150412,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1647933223
    },
    {
        "content": "<p>I have a basic question about Isabelle/ZF for a better understanding:<br>\nThe manual of Isabelle/ZF (Isabelle's Logics: FOL and ZF, Lawrence C. Paulson <br>\nComputer Laboratory University of Cambridge, with Contributions by Tobias Nipkow and Markus Wenzel December 12, 2021) says \"A tremendous amount of set theory has been formally developed, including the basic properties of relations, functions, ordinals and cardinals. Significant results have been proved, such as the Schröder-Bernstein Theorem, the Wellordering Theorem and a version of Ramsey’s Theorem. ZF provides both the integers and the natural numbers\". <br>\nWhat does \"The Schröder-Bernstein theorem is proven\" mean? Is it just a formal (syntactically) verification of an existing proof for this theorem written in FOL/ZF? Or is it an automatically generated proof of this theorem, or at least some parts of the proof? Or is the output of Isabelle/ZF here: \"The Schröder-Bernstein Theorem is true in ZFC\", but no chain of evidence or parts of it are generated?<br>\nThank you for a feedback</p>",
        "id": 276714402,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1648284374
    },
    {
        "content": "<p>Most (*) proofs in Isabelle are user-guided proofs with some holes completed by algorithms.</p>\n<p>(*) actually, loads of proofs are automatically generated whenever you, for example, define a data type. But I am talking about the proofs users actually write down in a theory file.</p>",
        "id": 276714574,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1648284696
    },
    {
        "content": "<p>How could the concrete proof step B --&gt; A (see above) be automatically generated in Isabelle? I am mainly interested in Isabelle/ZF determining \"B --&gt; A is true\" and not so much in a chain of proof, which I can search for myself if I know that such a chain exists. The statements A and B were defined in our example as follows:<br>\nA= \"∃xn∀t∃u (t∈x ⇒ n∈t∧t∈u∧u∈x)∧x≠⌀\" <br>\nand <br>\nB= \"∃x∀t∃u (t∈x ⇒ t∈u∧u∈x)∧x≠⌀\".<br>\nB --&gt; A can be proven with the help of the ZFC-axioms of foundation, replacement and union. I chose this example to become familiar with Isabelle and see if it could be used for my ideas.<br>\nThe proof is not too difficult, so Isabelle/ZF should actually be able to conclude that B--&gt;A is true.<br>\nWhat further tools can be used in Isabelle for this example?</p>",
        "id": 276731399,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1648308889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"482248\">Ulrich Schmid</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/ZFC/near/276714402\">schrieb</a>:</p>\n<blockquote>\n<p>Or is the output of Isabelle/ZF here: \"The Schröder-Bernstein Theorem is true in ZFC\", but no chain of evidence or parts of it are generated?</p>\n</blockquote>\n<p>I don’t know exactly what you would consider a “chain of evidence”. Usually, when Isabelle proves something, it derives the result from known facts by logical deduction steps whose correctness it checks. By default, Isabelle doesn’t construct a proof term, which you could inspect afterwards to convince yourself that there is indeed a proof. However, the Isabelle software is constructed such that every deduction it performs has to pass a correctness check. Therefore, it’s as good as if Isabelle would construct a proof term, as long as you trust the small core component that checks for the correctness of deduction steps.</p>",
        "id": 276779934,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1648375608
    },
    {
        "content": "<p>\"The Schröder-Bernstein theorem is proven\" means that someone has formulated the theorem and written its proof in Isabelle formal proof language (Isar) which was then verified by Isabelle as correct. It also means that you can reference this theorem when you are writing a proof of another theorem. Except for very simple cases the output of Isabelle/ZF is more like \"the proof provided is correct\" rather than \"this is true in ZFC\".</p>",
        "id": 276796340,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1648398943
    },
    {
        "content": "<p>I would like to question again an essential point at the example B --&gt; A which can occur as a partial step in a longer proof of a corresponding theorem. If the whole proof is written in Isar, then sooner or later Isabelle comes to exactly this point and now has to check if it can be verified. In the present case Isabelle would not accept the present theorem. How does it continue at this point and how often does this occur?</p>",
        "id": 276840422,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1648455476
    },
    {
        "content": "<p>Here is the theorem <a href=\"https://isabelle.in.tum.de/library/ZF/ZF/Cardinal.html#Cardinal.schroeder_bernstein|fact\">https://isabelle.in.tum.de/library/ZF/ZF/Cardinal.html#Cardinal.schroeder_bernstein|fact</a>. All you other questions require that you start a tutorial on Isabelle (Isabelle/HOL is define). This will clarify what Isabelle is and what it can do.</p>",
        "id": 276870092,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1648472814
    },
    {
        "content": "<p>I can only second this. Even if you’re going to work in Isabelle/ZF, studying the Isabelle/HOL tutorial called <code>prog-prove</code> will be extremely valuable. It’s the one accessible introduction to Isabelle I know. Switching from Isabelle/HOL to Isabelle/ZF shouldn’t be difficult: it only means switching the underlying logic and learning which of the automated provers don’t work for ZF. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 276894912,
        "sender_full_name": "Wolfgang Jeltsch",
        "timestamp": 1648483358
    },
    {
        "content": "<p>Thanks for the information, I will look into it.</p>",
        "id": 276974353,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1648543457
    },
    {
        "content": "<p>I've dug into the documentation a bit and created a small example. For this I have oriented myself on the above Cardinal Theory:<br>\n<a href=\"https://isabelle.in.tum.de/library/ZF/ZF/Cardinal.html#Cardinal.schroeder_bernstein|fact\">https://isabelle.in.tum.de/library/ZF/ZF/Cardinal.html#Cardinal.schroeder_bernstein|fact</a><br>\nand used this as a template. The definitions \"eqpoll\" and \"finite\" I have taken over to prove the lemma abc (see attachment):<br>\nLet A be a infinite set ==&gt; A ≈ A ∪ {A}.<br>\nBut Isabelle does not accept my program and brings the message: Bad theory import \"Draft.OrderType\", bad theory import \"Draft.finite\",....<br>\nThank you for a feedback<br>\n<a href=\"/user_uploads/14278/DForGnUR4nBbOxE2f5vezKDw/Exercise1.pdf\">Exercise1.pdf</a></p>",
        "id": 281547381,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1651939358
    },
    {
        "content": "<p>A couple of things: you need to qualify the imports with \"ZF\" when importing from Isabelle/ZF.  There is no need to provide type specifications. The symbol \\&lt;approx&gt; and the word \"Finite\" are already used by your imports, so you cannot reuse them. The lemma is too complicated to be proven by auto.  I attach the file that works (except for the proof of the lemma of course). You may want to check  IsarMathLib's <a href=\"https://isarmathlib.org/Cardinal_ZF.html\">Cardinal_ZF</a> theory  on various results on cardinals that are not in the standard Isabelle distribution. <br>\n<a href=\"/user_uploads/14278/a3w7zpzvVrKJ-1zpiQYGatCH/Exercise1.thy\">Exercise1.thy</a></p>",
        "id": 281554950,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1651949326
    },
    {
        "content": "<p>Small error of retranscription (Exercise1.thy) <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<p>I think you should read:<br>\ndefinition eqpoll (infix \"≅\" 70) where \"A≅B ≡ ∃f. f∈bij(A,B)\"<br>\nrather<br>\ndefinition eqpoll (infix \"≅\" 70) where \"A≅B ≡ ∃f. f∈A\"</p>",
        "id": 281587277,
        "sender_full_name": "Roland Coghetto",
        "timestamp": 1651998856
    },
    {
        "content": "<p>yes thank you, that is correct. I have now changed this in the program. <br>\nThe proof for lemma abc can be written as follows:<br>\nA is infinite  ==&gt; there is an uncountably infinite subset I of A with I =  {i1, i2, i3,.....}.<br>\nNow we can define a bijective function f: I -&gt; I ∪ {A} by<br>\nf(i1) = A,<br>\nf(i2) = i1,<br>\nf(i3) = i2,<br>\nand so on......<br>\nWith the help of f we can define a bijective function g: A -&gt;  A ∪ {A} as follows<br>\ng(x) = f(x) if x is an element of I and g(x) = x otherwise.</p>\n<p>Maybe there is a shorter proof, but my question is, how can this proof be integrated into the program \"Exercise1.thy\" in a way that Isabelle can verify it?</p>",
        "id": 281596013,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1652011863
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228975\">@Roland Coghetto</span> , thanks. <br>\n As for the first step (A is infinite ==&gt;...) I suggest to focus on that and try to prove as a separate lemma. The first step would be to formulate it so that it has a chance of being true (uncountably infinite?) , then try to formally express what you mean by the notation {i1,i2,...} (probably a subset of A that is bijective with natural numbers).</p>",
        "id": 281603305,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1652022340
    },
    {
        "content": "<p>sorry, this is a spelling mistake, correct is \"a countably infinite subset I\".<br>\nI will try to implement your suggestion and describe each individual step as transparently as possible.</p>",
        "id": 281612779,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1652035757
    },
    {
        "content": "<p>I constructed a proof in ZFC (see appendix page 1) with 3 lemmas and in a second step tried to translate the result into Isabelle (see page 2). Proof of lemma1 and lemma2 \"by auto\" and lemma3 using the first two, but the following error messages occur in Isabelle:</p>\n<ul>\n<li>Inner lexical error</li>\n<li>Inner syntax error: unexpected end of input</li>\n</ul>\n<p><a href=\"/user_uploads/14278/eTGS8tpAODQJYMcBldfBJCiV/ZFC.pdf\">ZFC.pdf</a></p>",
        "id": 282339691,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1652515054
    },
    {
        "content": "<p>It would be easier if you would format code directly in Zulip using Markdown. See here how to do that <a href=\"https://zulip.com/help/format-your-message-using-markdown#code\">https://zulip.com/help/format-your-message-using-markdown#code</a>. Alternatively, you can attach the theory file to the message.</p>",
        "id": 282350350,
        "sender_full_name": "Lukas Stevens",
        "timestamp": 1652531041
    },
    {
        "content": "<p>Your problem is that the term ℕ is not defined.</p>",
        "id": 282350564,
        "sender_full_name": "Lukas Stevens",
        "timestamp": 1652531321
    },
    {
        "content": "<p>If I understand it correctly, the set of natural numbers is just called <code>nat</code> in ZF.</p>",
        "id": 282350662,
        "sender_full_name": "Lukas Stevens",
        "timestamp": 1652531461
    },
    {
        "content": "<p>There are a couple of problems.  </p>\n<ol>\n<li>You define the notion <code>FiniteSet(A)</code>, but then in the lemma ad1 you reference <code>finite(A)</code>, and in lemma ad3 you reference <code>Finite(A)</code>.  I guess they all should be <code>FiniteSet(A)</code>, or perhaps (better) <code>Finite(A)</code> as this is defined in one of the imported theories.</li>\n<li>As Lukas mentions the set of natural numbers is <code>nat</code> in Isabelle/ZF  </li>\n<li>The translated versions  have additional general quantifiers and parentheses  added that are not needed</li>\n<li>Negation is <code>\\&lt;not&gt;</code> in Isabelle/ZF, not \"~\"<br>\nThe Isabelle version of your lemmas is actually much closer to what one would write in informal English than your translations. <br>\nFrom your informal version I assume you meant something like this</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">ad1</span><span class=\"o\">:</span> <span class=\"kp\">assumes</span> <span class=\"s\">\"</span><span class=\"ss\">\\&lt;not&gt;</span><span class=\"s\">FiniteSet(A)\"</span> <span class=\"kp\">shows</span> <span class=\"s\">\"</span><span class=\"ss\">\\&lt;exists&gt;</span><span class=\"s\">B. B</span><span class=\"ss\">\\&lt;subseteq&gt;</span><span class=\"s\">A </span><span class=\"ss\">\\&lt;and&gt;</span><span class=\"s\"> B</span><span class=\"ss\">\\&lt;cong&gt;</span><span class=\"s\">nat\"</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(consider using <code>Finite(A)</code> instead of <code>FiniteSet(A)</code> and <code>\\&lt;approx&gt;</code> instead of  <code>\\&lt;cong&gt;</code>  here as those are defined in the imports  and there are lemmas there about these notions that you may want to reference in your proofs). So better:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">ad1</span><span class=\"o\">:</span> <span class=\"kp\">assumes</span> <span class=\"s\">\"</span><span class=\"ss\">\\&lt;not&gt;</span><span class=\"s\">Finite(A)\"</span> <span class=\"kp\">shows</span> <span class=\"s\">\"</span><span class=\"ss\">\\&lt;exists&gt;</span><span class=\"s\">B. B</span><span class=\"ss\">\\&lt;subseteq&gt;</span><span class=\"s\">A </span><span class=\"ss\">\\&lt;and&gt;</span><span class=\"s\"> B</span><span class=\"ss\">\\&lt;approx&gt;</span><span class=\"s\">nat\"</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Similarly the remaining lemmas can be</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">ad2</span><span class=\"o\">:</span> <span class=\"kp\">assumes</span> <span class=\"s\">\"B</span><span class=\"ss\">\\&lt;approx&gt;</span><span class=\"s\">nat\"</span> <span class=\"kp\">shows</span> <span class=\"s\">\"</span><span class=\"ss\">\\&lt;exists&gt;</span><span class=\"s\">g. g </span><span class=\"ss\">\\&lt;in&gt;</span><span class=\"s\"> bij(B,B</span><span class=\"ss\">\\&lt;union&gt;</span><span class=\"s\">{A})\"</span> <span class=\"gr\">sorry</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">ad3</span><span class=\"o\">:</span> <span class=\"kp\">assumes</span> <span class=\"s\">\"</span><span class=\"ss\">\\&lt;not&gt;</span><span class=\"s\">Finite(A)\"</span> <span class=\"kp\">shows</span> <span class=\"s\">\"A </span><span class=\"ss\">\\&lt;approx&gt;</span><span class=\"s\"> (A </span><span class=\"ss\">\\&lt;union&gt;</span><span class=\"s\"> {A})\"</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Now you can put the line <code>proof -</code> after the statement of lemma ad1 and try to express the first line of the informal proof (A is not empty, hence we can pick  an element that belongs to A). Note the empty set is denoted <code>0</code> in Isabelle/ZF. The first line of the proof of <a href=\"https://github.com/SKolodynski/IsarMathLib/blob/03d0583ee1a2e2fd9fa364e807076a1470d8b29d/IsarMathLib/ZF1.thy#L63\">this lemma</a> might help you with the syntax you need.</p>",
        "id": 282367782,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1652555593
    },
    {
        "content": "<p>Small correction: <code>~</code> can indeed be used as a shorthand for <code>\\&lt;not&gt;</code>.</p>",
        "id": 282407471,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1652618123
    },
    {
        "content": "<p>thanks a lot for the suggestions. I will go through them and then try again</p>",
        "id": 282422451,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1652639747
    },
    {
        "content": "<p>I have 3 further questions:<br>\n1) I made a copy of a program in Isabelle which works (see appendix Scratch.thy). But in the copy Isabelle does not give any feedback (see appendix Scratch1). The color of the font in the copy appears in pink. What could be the reason here?<br>\n<a href=\"/user_uploads/14278/7Kgz3b1dWngON4hB9HxlGs15/Bildschirmfoto-2022-05-22-um-14.56.22.png\">Bildschirmfoto-2022-05-22-um-14.56.22.png</a> <a href=\"/user_uploads/14278/aeHupv3egqBoWjYk2yIz6oL7/Bildschirmfoto-2022-05-22-um-14.56.41.png\">Bildschirmfoto-2022-05-22-um-14.56.41.png</a> <br>\n2)How can I find the best proving method for a given lemma (auto, blast, simp,...)?<br>\n3) There is a notation with pointed bracket for example:<br>\nlemma ad1: assumes \"\\&lt;not&gt;Finite(A)\" shows \"\\&lt;exists&gt;B. B\\&lt;subseteq&gt;A \\&lt;and&gt; B\\&lt;approx&gt;nat\" <br>\nIsabelle makes a transformation without pointed brackets in:<br>\nlemma ad1: assumes \"~Finite(A)\" shows \"∃B. B⊆A ∧ B≈nat\" by blast<br>\nWhat does this mean and what is the best way to enter source code in Isabelle?<br>\nthanks for a feedback</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/7Kgz3b1dWngON4hB9HxlGs15/Bildschirmfoto-2022-05-22-um-14.56.22.png\" title=\"Bildschirmfoto-2022-05-22-um-14.56.22.png\"><img src=\"/user_uploads/14278/7Kgz3b1dWngON4hB9HxlGs15/Bildschirmfoto-2022-05-22-um-14.56.22.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/14278/aeHupv3egqBoWjYk2yIz6oL7/Bildschirmfoto-2022-05-22-um-14.56.41.png\" title=\"Bildschirmfoto-2022-05-22-um-14.56.41.png\"><img src=\"/user_uploads/14278/aeHupv3egqBoWjYk2yIz6oL7/Bildschirmfoto-2022-05-22-um-14.56.41.png\"></a></div>",
        "id": 283231903,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1653225631
    },
    {
        "content": "<p>1) I don't know. It is good to set <code>ISABELLE_LOGIC=ZF</code> in the <code>etc/settings</code> file, but I am not sure if it is related to this. If you attach the <code>Scratch1.thy</code> file here I can check if it loads in my setup. <br>\n2) There are just a couple of them, the best one is the one that works. If several work, choose them in the order simp, blast, auto.  Blast and auto are more capable than simp, but slower. There are assertions that blast accepts but auto does not  and vice versa. Again it is very rare that a lemma can be proven just by \"using assms by auto\" or similar, usually you have to write a proof. <br>\n3) The notation with pointed brackets is what is in the source text i.e. in the file on disk. You can see that by looking at the file (like your Scratch.thy) with a word editor like Notepad. When isabelle loads such file it displays the markup as symbols. For example if it sees \"\\&lt;exists&gt;\" it displays \"∃\". The \"Predefined Isabelle symbols\" section in Appendix of the <a href=\"https://isabelle.in.tum.de/doc/isar-ref.pdf\">Isabelle/Isar Reference Manual</a>  provides a list of symbols and the pointed bracket strings that correspond to them. When I want to enter such symbol in Isabelle/jEdit interface I type a couple of letters like <code>\\&lt;ex</code> and then wait a second or two for Isabelle to show a list of hints, from which I choose (with arrows and TAB) the symbol I want.</p>",
        "id": 283248312,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1653248776
    },
    {
        "content": "<p>here a the files Scratch.thy and Scratch1.thy<br>\n<a href=\"/user_uploads/14278/eWjpY00tfNGnJ1aLS32puYBg/Scratch.thy\">Scratch.thy</a> <br>\n<a href=\"/user_uploads/14278/rJqxDB1l8LJH6yPVl-XBiaDI/Scratch.thy\">Scratch.thy</a><br>\n<a href=\"/user_uploads/14278/9OpmA5sNZ62JJvxKPpsDOJP4/Scratch1.thy\">Scratch1.thy</a> <br>\n<a href=\"/user_uploads/14278/8PX7hpEt-TmzPz4oShQ92Jy_/Scratch1.thy\">Scratch1.thy</a></p>",
        "id": 283353680,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1653328050
    },
    {
        "content": "<p>Scratch is verified by Isabelle, but with Scratch1 there is no reaction. It is in both cases the same source code (Sratch1 is a copy of Scratch, \"copy and paste\").</p>",
        "id": 283354363,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1653328424
    },
    {
        "content": "<p>This problem has occurred several times with other files as well. It also happens sometimes that after a restart of Isabelle the files work again in Isabelle.</p>",
        "id": 283354924,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1653328750
    },
    {
        "content": "<p>Both files work fine in my setup (Linux). They are not identical: for example you have <code>\\&lt;longrightarrow&gt; t\\&lt;in&gt;u \\&lt;and&gt; u\\&lt;in&gt;x</code> in Sratch.thy and <code>\\&lt;longrightarrow&gt; (t\\&lt;in&gt;u \\&lt;and&gt; u\\&lt;in&gt;x)</code> in Scratch1.thy.</p>",
        "id": 283357394,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1653329832
    },
    {
        "content": "<p>Yes, obviously I changed something in the meantime in one of the two files with the attempt to get Scratch1 running. But if you compare both printscreans above the source code is identical.<br>\nMy main question is the following: What can I do if a program does not run in Isabelle (in the example Scratch1, printscrean see above). Can this be due to the source code or rather to the system settings or hardware- system (MacBook Air)? You have mentioned \"ISABELLE_LOGIC=ZF\" in the etc/settings-file. How can I get access to this file?<br>\nHere is another example of this kind (Skratch2), where Isabell shows no reaction:<br>\n<a href=\"/user_uploads/14278/Q7Kb5cbEER4L8nY-4LOv-Kfw/Scratch2.thy\">Scratch2.thy</a> <br>\n<a href=\"/user_uploads/14278/1aJ8qy12JQlqODtT2_O6Amxu/Scratch2.thy\">Scratch2.thy</a><br>\nthankyou</p>",
        "id": 283727213,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1653389739
    },
    {
        "content": "<p>I am pretty sure the contents of the file is not the reason this happens. I only use Isabelle on Linux and I have not seen this, maybe such things happen on other platforms. In my setup the etc/settings file is in the directory where I unpacked the <code>Isabelle2021-1_linux.tar.gz</code> file that I downloaded from the Isabelle site. This can be any directory on Linux. I don't know where this file might be on MacBook Air.</p>",
        "id": 283757488,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1653404279
    },
    {
        "content": "<p>I noticed that after a restart Isabelle always processes only the first program. If I call further programs afterwards, these are not processed, i.e. Isabelle remains inactive. However, I can always call the first program again and edit it, and Isabelle reacts immediately. <br>\nI am of your opinion that this is due to the settings or the operating system, or the low capacity of my laptop. Is there something like a technical support for Isabelle?</p>",
        "id": 284021135,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1653579413
    },
    {
        "content": "<p>The Isabelle <a href=\"https://lists.cam.ac.uk/sympa/arc/cl-isabelle-users\">mailing list</a> is the best approximation of that that I know of.</p>",
        "id": 284036572,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1653586802
    },
    {
        "content": "<p>I had an appointment with apple technical support today. It turned out that my system requirements are too weak for Isabelle. Therefore I will get a stronger system, which I had already planned independently. After that I will continue to work with Isabelle. Thank you very much for your support so far.</p>",
        "id": 284244131,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1653765343
    },
    {
        "content": "<p>I intend to buy a new laptop. Are there any differences between Microsoft and Macintosh regarding Isabelle, or are both operating systems equally suitable for it (performance, technical problems,...)?</p>",
        "id": 284524059,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1654023982
    },
    {
        "content": "<p>I think both should be fine. I think most \"power users\" in the community user either Linux or Mac, but not due to any problems with Isabelle under Windows, and Makarius does make sure that all of these are equally well-maintained. (I for one have only ever used it in Linux).</p>\n<p>I did hear, however, that the new ARM-based Macbooks do provide very good performance with Isabelle. But I for one think that you should just make your decision based on general personal preference.</p>",
        "id": 284524518,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1654024210
    },
    {
        "content": "<p>I received an error message when working in Isabelle (see attachment). What can I do?<br>\n<a href=\"/user_uploads/14278/z4IOXGoPZOLf82rHxV3TlNoX/Bildschirmfoto-2022-06-30-um-08.14.25.png\">Bildschirmfoto-2022-06-30-um-08.14.25.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/z4IOXGoPZOLf82rHxV3TlNoX/Bildschirmfoto-2022-06-30-um-08.14.25.png\" title=\"Bildschirmfoto-2022-06-30-um-08.14.25.png\"><img src=\"/user_uploads/14278/z4IOXGoPZOLf82rHxV3TlNoX/Bildschirmfoto-2022-06-30-um-08.14.25.png\"></a></div>",
        "id": 287980975,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1656570593
    },
    {
        "content": "<p>there is no error message, it just means that Isabelle is compiling HOL-Library. You have to wait until that finishes (compiling should happen only once)</p>",
        "id": 287985049,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1656573339
    },
    {
        "content": "<p>I am just wondering how you triggered that because HOL-Library has nothing to do with ZF</p>",
        "id": 287985142,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1656573373
    },
    {
        "content": "<p>You probably changed the base session in the theories panel (right on the screenshot: you have set HOL-Codegenator_Test). Just set it back.</p>",
        "id": 287985213,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1656573450
    },
    {
        "content": "<p>Thanks, obviously I accidentally clicked that.</p>",
        "id": 287993968,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1656578708
    },
    {
        "content": "<p>After a short break, I am now continuing to familiarize myself with Isabelle. Therefore I start with very simple examples. In the Scratch5 file I have formulated two lemmas (hyp0 and hyp1, see attachement). The first lemma is true and follows directly from the axiom of infinity. The second lemma, however, is false in ZFC, since it contains the expression \"y∈y\", which contradicts the axiom of foundation. However, both lemmas are verified by Isabelle. I suspect the reason is that Isabelle/ZF considers each entity as a class. My first question now is whether I am guessing correctly here and my second is how to tell Isabelle to consider all entities in my theory file as sets (y∈V). <br>\n<a href=\"/user_uploads/14278/Low80LI_6w5-AM0JHfTSyTtV/Scratch5.thy\">Scratch5.thy</a></p>",
        "id": 288625796,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1657085556
    },
    {
        "content": "<p>When I run this, neither of the two are proven. Note that as long as the <code>by blast</code> bit is purple, the corresponding proof method is still running and the theorem is not to be considered proven yet.</p>\n<p>This is because Isabelle forks proofs into separate threads in the background to make processing faster, and to allow for more convenient interactive editing. If you were to try to build this theory in batch mode, you would get an error (or rather, the build process would run forever).</p>",
        "id": 288629541,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1657089769
    },
    {
        "content": "<p>Here is a proof for your first theorem and a proof of the opposite of your second theorem.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">hyp1</span><span class=\"o\">:</span> <span class=\"s\">\"∃y. ¬Finite(y)\"</span>\n  <span class=\"k\">using</span> <span class=\"n\">nat_not_Finite</span> <span class=\"k\">by</span> <span class=\"n\">blast</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">hyp2</span><span class=\"o\">:</span> <span class=\"s\">\"y ∉ y\"</span>\n  <span class=\"k\">using</span> <span class=\"n\">mem_not_refl</span> <span class=\"k\">by</span> <span class=\"n\">blast</span>\n</code></pre></div>\n<p>I don't know anything about Isabelle/ZF, but I found the relevant lemmas with <code>find_theorems</code> (you can also use the \"Find Theorems\" panel in Isabelle/jEdit).</p>",
        "id": 288629899,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1657090097
    },
    {
        "content": "<p>Unfortunately, Isabelle/ZF doesn't have sledgehammer. Otherwise I'm sure sledgehammer could have found those easily.</p>",
        "id": 288629919,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1657090119
    },
    {
        "content": "<p>Unless your goal is specifically to do something with ZF(C), you should really look at Isabelle/HOL instead. Even if your goal <em>is</em> ZF(C), it might make sense to do some Isabelle/HOL first.</p>\n<p>But I don't know what you're trying to do exactly, so I cannot say for certain.</p>",
        "id": 288629971,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1657090192
    },
    {
        "content": "<p>I am mainly interested in set theoretic statements in ZFC, so called wff's (well formed formulas). <br>\nFor example A:=\"∀n∃x∀t∃u (t∈x ⇒ n∈t∧t∈u∧u∈x)\"<br>\nThe statement A here says that for every set n there is an infinite set x with n∩x = ⌀.<br>\nOn the one hand, the focus is on simplifying such wff's equivalently (e.g., fewer variables or logical connectives). On the other hand, it is also about showing that two wff's represent the same content (A &lt;=&gt; B).<br>\nMy hope is that I can use Isabelle to support this.</p>",
        "id": 289292278,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1657614224
    },
    {
        "content": "<p>Since a few months I have a new MacBook Pro with 16 GB memory and 10 CPU cores. The battery usually lasts a long time, but when I work with Isabelle, the computer gets very hot after a short time and the battery indicator goes down quickly. I have the impression that Isabelle is constantly working intensively in the background with large amounts of data. What can I do here?</p>",
        "id": 292304904,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1659857320
    },
    {
        "content": "<p>Isabelle certainly makes your computer work hard, so you don't have to. However, if you are doing nothing, it should also be doing nothing. If you've loaded dozens of large theories, things might get sluggish. Also if a proof above the point your looking at is in a loop.</p>",
        "id": 293424511,
        "sender_full_name": "Lawrence Paulson",
        "timestamp": 1660498126
    },
    {
        "content": "<p>Thanks for your feedback.<br>\nI would like to prove simple statements in Isabelle using the ZF axioms. I also succeeded with the statements basic1, ... ,basic4 (see below). All four statements are direct consequences of the axiom of foundation and are accepted by Isabelle with \"using foundation by blast\". But the statement basic5 is not accepted, although the proof in ZF is quite analogous to the other statements. What could be the reason for this, or what must be added here?</p>\n<p>theory Scratch2<br>\n  imports ZF<br>\nbegin </p>\n<p>lemma basic1: \"∀x. x∉x\"<br>\n  using foundation by blast </p>\n<p>lemma basic2: \"∀x y. x∈y⟶y∉x\"<br>\n  using foundation by blast</p>\n<p>lemma basic3: \"∀x y. x∈y⟶x≠y\"<br>\n  using foundation by blast</p>\n<p>lemma basic4: \"∀x y z. x∈y∧y∈z⟶x≠z\"<br>\n  using foundation by blast</p>\n<p>lemma basic5: \"∀x y z. x∈y∧y∈z⟶z∉x\"<br>\n  using foundation by blast</p>\n<p>end</p>",
        "id": 294159103,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1660852462
    },
    {
        "content": "<p>The reason is that the statement exceeds Isabelle's \"blast\" method capabilities for automatic proof search. The only way to fix this is to write a more detailed proof (assuming the assertion is true). If you were to explain to someone how the basic5  assertion follows from the foundation and perhaps some other axioms, what would you say?</p>",
        "id": 294326055,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1660928568
    },
    {
        "content": "<p>The proof is not very difficult (indirect):<br>\nAssuming z∈x holds under the condition x∈y∈z, we consider the set A={x,y,z} (analogous to the proof of lemma basic2, with A={x,y,}). Case analysis for x, y, and z yields a contradiction to the axiom of foundation, for all three cases. The set <br>\nA={x,y,z} always exists for any three sets x,y und z. This fact follows from the axiom of replacement. Or alternatively, with the help of the axioms of pairing and union.<br>\nTanks a lot for your feedback</p>",
        "id": 294337135,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1660932347
    },
    {
        "content": "<p>Probably the part with considering A={x,y,z} has a bit of creativity in it that blast is too weak for.  The following works:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span> <span class=\"n\">Scratch3</span>\n  <span class=\"kp\">imports</span> <span class=\"n\">ZF</span>\n<span class=\"k\">begin</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">basic5a</span><span class=\"o\">:</span> <span class=\"kp\">assumes</span> <span class=\"s\">\"x∈y\"</span> <span class=\"kp\">and</span> <span class=\"s\">\"y∈z\"</span> <span class=\"kp\">shows</span> <span class=\"s\">\"z∉x\"</span>\n<span class=\"k\">proof</span> <span class=\"o\">-</span>\n  <span class=\"k\">let</span> <span class=\"o\">?</span><span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"s\">\"{x,y,z}\"</span>\n  <span class=\"k\">have</span> <span class=\"s\">\"?A≠0\"</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n  <span class=\"k\">with</span> <span class=\"n\">assms</span> <span class=\"k\">show</span> <span class=\"s\">\"z∉x\"</span> <span class=\"k\">using</span> <span class=\"n\">foundation</span> <span class=\"k\">by</span> <span class=\"n\">blast</span>\n<span class=\"k\">qed</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">basic5</span><span class=\"o\">:</span> <span class=\"kp\">shows</span> <span class=\"s\">\"∀x y z. x∈y ∧ y∈z ⟶ z∉x\"</span> <span class=\"k\">using</span> <span class=\"n\">basic5a</span> <span class=\"k\">by</span> <span class=\"n\">blast</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 294403780,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1660980870
    },
    {
        "content": "<p>Yes, now it works, thanks.<br>\nIs there a possibility to prove statements like basic5 without isar, e.g. only with a suitable tactic (blast, auto, best, simp,...) involving suitable lemmas? This could also prove certain generalizations of statements like basic5, for example, \"∀x y z u. x∈y ∧ y∈z ∧ z∈u⟶ u∉x\" etc, without having to change the proof ( in this case A ={x,y,z,u}).<br>\nThis aspect would be very interesting, since it would then be possible to prove or disprove statements (wff`s) that are in a similar context, even without having a proof idea in advance. In the case that Isabelle confirms the truth of a statement one can then try to find a proof (if Isabelle does not deliver one). Also to simplify statements this would be a great help.</p>",
        "id": 294427992,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1660994813
    },
    {
        "content": "<p>It is possible to put a each step of a proof into a lemma so that the keyword \"proof\" is never used. In the above case it would look like this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span> <span class=\"n\">Scratch4</span>\n  <span class=\"kp\">imports</span> <span class=\"n\">ZF</span>\n<span class=\"k\">begin</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">basic5a</span><span class=\"o\">:</span> <span class=\"kp\">shows</span> <span class=\"s\">\"{x,y,z} ≠ 0\"</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">basic5b</span><span class=\"o\">:</span> <span class=\"kp\">assumes</span> <span class=\"s\">\"x∈y\"</span> <span class=\"kp\">and</span> <span class=\"s\">\"y∈z\"</span> <span class=\"kp\">shows</span> <span class=\"s\">\"z∉x\"</span>\n  <span class=\"k\">using</span> <span class=\"n\">assms</span> <span class=\"n\">basic5a</span> <span class=\"n\">foundation</span> <span class=\"k\">by</span> <span class=\"n\">blast</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">basic5</span><span class=\"o\">:</span> <span class=\"kp\">shows</span> <span class=\"s\">\"∀x y z. x∈y ∧ y∈z ⟶ z∉x\"</span> <span class=\"k\">using</span> <span class=\"n\">basic5b</span> <span class=\"k\">by</span> <span class=\"n\">blast</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>However, formulating such lemmas is like writing proofs, except with more typing and less clear structure for longer proofs. The only advantage of such style that I can see is that each proof step has a name, so you can reference it while proving something else. Isabelle is only designed to verify proofs you know in advance. It does not work well as an oracle telling you if a given assertion is true or false. Isabelle/ZF can tell you that something is true if it is simple enough but it cannot disprove a statement, it can only fail to accept it.</p>",
        "id": 294467004,
        "sender_full_name": "Sławomir Kołodyńaski",
        "timestamp": 1661017051
    },
    {
        "content": "<p>Since Sledgehammer is not available in Isabelle/ZF, I would like to transform some questions from ZF  (including all ZF axioms) to Isabelle/HOL to prove them there. For this purpose, a two-digit predicate P(a,b) is defined for the element relation. For a∈b in ZF we write P(a,b) in HOL. The ZF axioms are defined as properties of P in HOL. For example, the axiom of the empty set in ZF (∃x∀t ¬t∈x) provides the first property for P in HOL: ∃x∀t ¬P(t,x). Thus, all ZF axioms can be transformed to HOL very easily. In this way, very special questions within set theory can then be transferred to HOL in order to prove them there. Is this procedure in principle reasonable and possible?</p>",
        "id": 296794893,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1662116554
    },
    {
        "content": "<p>I did remember that correctly, but deleted the message: what you describe is done in HOL-ZF right? <a href=\"https://isabelle.in.tum.de/dist/library/HOL/HOL-ZF/index.html\">https://isabelle.in.tum.de/dist/library/HOL/HOL-ZF/index.html</a></p>",
        "id": 296796969,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1662117362
    },
    {
        "content": "<p>If in HOLZF all contents from Isabelle/ZF can be described, then it corresponds to my idea. The inversion does not apply of course. I will look at the whole thing and try to understand the main points, which are interesting for me.</p>",
        "id": 296987040,
        "sender_full_name": "Ulrich Schmid",
        "timestamp": 1662208614
    },
    {
        "content": "<p>Paulson's ZFC in HOL is good too. Very powerful! <br>\n<a href=\"https://www.isa-afp.org/entries/ZFC_in_HOL.html\">https://www.isa-afp.org/entries/ZFC_in_HOL.html</a></p>",
        "id": 298056367,
        "sender_full_name": "Ciarán Dunne",
        "timestamp": 1662759066
    }
]