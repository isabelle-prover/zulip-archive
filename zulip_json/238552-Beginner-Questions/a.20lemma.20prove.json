[
    {
        "content": "<p>For some purpose, I want to prove such a lemma: if one automaton could be reachable and another automaton could be reachable, such that the concat of these two automata could be reachable. The qa is a list and x is an LTS transition.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">concat_lemma</span><span class=\"o\">:</span><span class=\"s\">\"single_LTS_reachable_by_path qa x ⟹ single_LTS_reachable_by_path q xa ⟹ single_LTS_reachable_by_path (qa @ q) (x @ xa)\"</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">inverse_concat_lemma</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"single_LTS_reachable_by_path q (xa @ y) ⟹ ∃p qa. q = qa @ p ∧ single_LTS_reachable_by_path qa xa ∧ single_LTS_reachable_by_path p y\"</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The definition of single_LTS_reachable_by_path and others are below:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">type_synonym</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'q</span><span class=\"o\">,</span><span class=\"n n-Type\">'a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">LTS</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"('q * 'a set * 'q) set\"</span>\n\n\n<span class=\"k\">primrec</span><span class=\"w\"> </span><span class=\"n\">LTS_is_reachable</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('q, 'a) LTS </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> 'q </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> 'a list </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> 'q </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> bool\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">   </span><span class=\"s\">\"LTS_is_reachable </span><span class=\"ss\">\\&lt;Delta&gt;</span><span class=\"s\"> q [] q' = (q = q' ∨ (q, {}, q') ∈ Δ)\"</span><span class=\"o\">|</span>\n<span class=\"w\">   </span><span class=\"s\">\"LTS_is_reachable </span><span class=\"ss\">\\&lt;Delta&gt;</span><span class=\"s\"> q (a # w) q' =</span>\n<span class=\"s\">      (</span><span class=\"ss\">\\&lt;exists&gt;</span><span class=\"s\">q'' </span><span class=\"ss\">\\&lt;sigma&gt;</span><span class=\"s\">. a </span><span class=\"ss\">\\&lt;in&gt;</span><span class=\"s\"> </span><span class=\"ss\">\\&lt;sigma&gt;</span><span class=\"s\"> </span><span class=\"ss\">\\&lt;and&gt;</span><span class=\"s\"> (q, </span><span class=\"ss\">\\&lt;sigma&gt;</span><span class=\"s\">, q'') </span><span class=\"ss\">\\&lt;in&gt;</span><span class=\"s\"> </span><span class=\"ss\">\\&lt;Delta&gt;</span><span class=\"s\"> </span><span class=\"ss\">\\&lt;and&gt;</span><span class=\"s\"> LTS_is_reachable </span><span class=\"ss\">\\&lt;Delta&gt;</span><span class=\"s\"> q'' w q')\"</span>\n\n<span class=\"k\">primrec</span><span class=\"w\"> </span><span class=\"n\">single_LTS_reachable_by_path</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ (('q,'a) LTS * 'q * 'q) list  ⇒ bool \"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"single_LTS_reachable_by_path w []= (w = [])\"</span><span class=\"o\">|</span>\n<span class=\"s\">\"single_LTS_reachable_by_path w (x# xs) = (∃p q. (w = p @ q ∧ LTS_is_reachable (fst x) (fst (snd x)) p (snd (snd x)) ∧ single_LTS_reachable_by_path q xs))\"</span>\n</code></pre></div>\n<p>For the primrec and fun in isabelle, how many tactic could be used.</p>",
        "id": 338785451,
        "sender_full_name": "Hongjian Jiang",
        "timestamp": 1677663853
    }
]