[
    {
        "content": "<p>Is there a typeclass for countably infinite types?</p>\n<p>I've tried the following:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"n\">countably_infinite</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">countable</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"s\">\"∀n. ∃(x::'a). to_nat x = n\"</span>\n</code></pre></div>\n<p>(Also some variations with <code>x::'a::countable</code>, ..., as this definition is rejected from Isablle):</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"n\">unification</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Variable</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"o\">::</span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">sort</span><span class=\"w\"> </span><span class=\"n\">countable</span>\n\n<span class=\"n\">Failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">meet</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">constraint</span><span class=\"o\">:</span>\n\n<span class=\"n\">Term</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n\">λx.</span><span class=\"w\"> </span><span class=\"n\">to_nat</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">??</span><span class=\"n n-Type\">'b</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"n\">bool</span>\n<span class=\"n\">Type</span><span class=\"o\">:</span><span class=\"w\">  </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">⇒</span><span class=\"w\"> </span><span class=\"o\">??</span><span class=\"n n-Type\">'a</span>\n</code></pre></div>\n<p>Or with <code>countable</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">Additional</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"k\">locale</span><span class=\"w\"> </span><span class=\"kn\">specification</span><span class=\"w\"> </span><span class=\"s\">\"countably_infinite\"</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span>\n<span class=\"n\">Type</span><span class=\"w\"> </span><span class=\"n\">variable</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">two</span><span class=\"w\"> </span><span class=\"n\">distinct</span><span class=\"w\"> </span><span class=\"n\">sorts</span>\n<span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">above</span><span class=\"w\"> </span><span class=\"n\">occurred</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">axiom</span><span class=\"w\"> </span><span class=\"s\">\"class.countably_infinite_def\"</span>\n</code></pre></div>",
        "id": 395006808,
        "sender_full_name": "Robert Soeldner",
        "timestamp": 1696500828
    },
    {
        "content": "<p><code>to_nat</code> is defined outside the <code>countable</code> class, so it does not exist without the sort constraint. You could try</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"n\">countably_infinite</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">countable</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">cinf_surj</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"∀(n :: nat). ∃(x::'a). Eps inj x = n\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∀n. ∃(x::'a :: countably_infinite). to_nat x = n\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">to_nat_def</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">cinf_surj</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(And indeed there is no such type class. Not even one for just infinite types. If there was, one could use the sort <code>{countable, infinite}</code>.)</p>",
        "id": 395012530,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1696502538
    },
    {
        "content": "<p>this makes sense, thank you <span class=\"user-mention\" data-user-id=\"361271\">@Dmitriy Traytel</span> <br>\nIs there any particular reason this is not part of the HOL library, or was it just not needed? I'm asking to ensure I'm not going into a rabbit hole :-)</p>",
        "id": 395013597,
        "sender_full_name": "Robert Soeldner",
        "timestamp": 1696502782
    },
    {
        "content": "<p>I needed something like that in a recent (not-yet-published) formalization of mine. There I defined the type of countably infinite sets <code>'a cinfset</code>. In the type definition, I used predicates <code>countable</code> and <code>infinite</code> and to prove non-emptiness <code>'a</code> has to be infinite, so I created a type class for infinite types locally (my formulation was using cardinals and required a bit more that was useful in my context). Having  an <code>infinite</code> type class in the library would make sense IMO.</p>",
        "id": 395015159,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1696503298
    }
]