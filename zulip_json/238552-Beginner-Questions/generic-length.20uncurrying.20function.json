[
    {
        "content": "<p>Hello, be warned: I am not that deep into simple type theory so my question might be incredibly stupid from a theoretical standpoint alone... Is there a way to define a function that does generic length uncurrying? That is, I'm looking for a function that takes as argument any curried function  </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">t_1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">t_2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"ow\">...</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">t_n</span>\n</code></pre></div>\n<p>of arbitrary length n and returns a function </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">g</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">t_1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t_2</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"ow\">...</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">t_</span><span class=\"ow\">{</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"ow\">}</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">t_n</span>\n</code></pre></div>\n<p>Thank you very much in advance!</p>",
        "id": 515031373,
        "sender_full_name": "Alicia",
        "timestamp": 1745924673
    },
    {
        "content": "<p>No, that is not possible</p>",
        "id": 515060718,
        "sender_full_name": "Jan van Brügge",
        "timestamp": 1745932612
    },
    {
        "content": "<p>With overloading one can get pretty far actually.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">consts</span><span class=\"w\"> </span><span class=\"n\">uncurry</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('A ⇒ 'B) ⇒ 'C ⇒ 'D\"</span>\n\n<span class=\"k\">overloading</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun</span><span class=\"w\"> </span><span class=\"n\">≡</span><span class=\"w\"> </span><span class=\"s\">\"uncurry :: ('a ⇒ 'b ⇒ 'c) ⇒ 'a × 'B ⇒ 'C\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('a ⇒ 'b ⇒ 'c) ⇒ 'a × 'B ⇒ 'C\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"uncurry_fun f = (λ(a, b). uncurry (f a) b)\"</span>\n<span class=\"k\">end</span>\n<span class=\"k\">overloading</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit</span><span class=\"w\"> </span><span class=\"n\">≡</span><span class=\"w\"> </span><span class=\"s\">\"uncurry :: ('a ⇒ 'b) ⇒ (unit ⇒ 'a) ⇒ 'b\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('a ⇒ 'b) ⇒ (unit ⇒ 'a) ⇒ 'b\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"uncurry_unit f g = f (g ())\"</span>\n<span class=\"k\">end</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, λ(). b) = f a b\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">unit.case</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, b, λ(). c) = f a b c\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">unit.case</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, b, c, λ(). d) = f a b c d\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">unit.case</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, b, c, d, λ(). e) = f a b c d e\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">unit.case</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n</code></pre></div>",
        "id": 515299985,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1746018412
    },
    {
        "content": "<p>Above I use the unit type to stop the overloaded recursion.</p>",
        "id": 515300671,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1746018574
    },
    {
        "content": "<p>Probably it would be safer to introduce a new dummy type for this purpose---the unit type might have other legitimate uses.</p>",
        "id": 515300998,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1746018649
    },
    {
        "content": "<p>I.e. something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">consts</span><span class=\"w\"> </span><span class=\"n\">uncurry</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('A ⇒ 'B) ⇒ 'C ⇒ 'D\"</span>\n<span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"w\"> </span><span class=\"n\">stop_curry</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Stop_Curry</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">get_curry</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"s\">\"$_\"</span><span class=\"o\">)</span>\n\n<span class=\"k\">overloading</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun</span><span class=\"w\"> </span><span class=\"n\">≡</span><span class=\"w\"> </span><span class=\"s\">\"uncurry :: ('a ⇒ 'b ⇒ 'c) ⇒ 'a × 'B ⇒ 'C\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('a ⇒ 'b ⇒ 'c) ⇒ 'a × 'B ⇒ 'C\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"uncurry_fun f = (λ(a, b). uncurry (f a) b)\"</span>\n<span class=\"k\">end</span>\n<span class=\"k\">overloading</span><span class=\"w\"> </span><span class=\"n\">uncurry_stop_curry</span><span class=\"w\"> </span><span class=\"n\">≡</span><span class=\"w\"> </span><span class=\"s\">\"uncurry :: ('a ⇒ 'b) ⇒ 'a stop_curry ⇒ 'b\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">uncurry_stop_curry</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('a ⇒ 'b) ⇒ 'a stop_curry ⇒ 'b\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"uncurry_stop_curry f g = f (get_curry g)\"</span>\n<span class=\"k\">end</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, $b) = f a b\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_stop_curry_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">stop_curry.sel</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, b, $c) = f a b c\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_stop_curry_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">stop_curry.sel</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, b, c, $d) = f a b c d\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_stop_curry_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">stop_curry.sel</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, b, c, d, $e) = f a b c d e\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_stop_curry_def</span><span class=\"w\"> </span><span class=\"n\">prod.case</span><span class=\"w\"> </span><span class=\"n\">stop_curry.sel</span><span class=\"w\"> </span><span class=\"ow\">..</span>\n</code></pre></div>",
        "id": 515302087,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1746018920
    },
    {
        "content": "<p>ok, but that is not just one function, yes with workarounds one can achieve something similar. Usually in this cases however it is better to ask \"what are you trying to achieve\" and find a better wax to express it</p>",
        "id": 515312551,
        "sender_full_name": "Jan van Brügge",
        "timestamp": 1746021545
    },
    {
        "content": "<p>If you're willing to go down this route, I don't quite see why you need the extra marker to stop the recursion? You can replace the <code>uncurry_unit</code> of Dmitriy's first listing with:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">overloading</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit</span><span class=\"w\"> </span><span class=\"n\">≡</span><span class=\"w\"> </span><span class=\"s\">\"uncurry :: ('a ⇒ 'b) ⇒ 'a ⇒ 'b\"</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"('a ⇒ 'b) ⇒ 'a ⇒ 'b\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"uncurry_unit f g = f (g)\"</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>and still get</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a, b, c, d) = f a b c d\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit_def</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n</code></pre></div>\n<p>as expected. However, note that type inference in the presence of this <code>uncurry</code> (and overloaded constants more generally) becomes supremely annoying:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">\"uncurry f (a,b,c,d)\"</span><span class=\"w\"> </span><span class=\"c\">(* infers 'g for this expression, instead of `'a =&gt; 'b =&gt; 'c =&gt; 'd =&gt; 'e` *)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry (λa b c d. d) (a,b,c,d) = d\"</span><span class=\"w\"> </span><span class=\"gr\">oops</span><span class=\"w\"> </span><span class=\"c\">(* unprovable since it infers different types for a,b,c,d each time *)</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"uncurry (λ(a::'a) (b::'b) (c::'c) (d::'d). d) (a::'a,b::'b,c::'c,d::'d) = (d::'d)\"</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">uncurry_fun_def</span><span class=\"w\"> </span><span class=\"n\">uncurry_unit_def</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c\">(* goes through *)</span>\n</code></pre></div>\n<p>So this is a fun corner of Isabelle, but as Jan says, probably not what you actually want to do ;)</p>",
        "id": 515313426,
        "sender_full_name": "terru",
        "timestamp": 1746021735
    },
    {
        "content": "<p>Ah, I thought I need some special type as a marker to make the cases non-overlapping--- but indeed they already are non-overlapping. Nice <span class=\"user-mention\" data-user-id=\"485021\">@terru</span>.</p>\n<p>I agree that the entire overloading approach may not be what one should use, especially not as a beginner. But I felt triggered by Jan's categorical statement. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 515356436,
        "sender_full_name": "Dmitriy Traytel",
        "timestamp": 1746032549
    }
]