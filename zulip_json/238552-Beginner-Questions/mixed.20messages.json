[
    {
        "content": "<p>I got </p>\n<p>show add (Suc m) n = add n (Suc m) <br>\nSuccessful attempt to solve goal by exported rule:<br>\n  (add ?ma2 n = add n ?ma2) ⟹ add (Suc ?ma2) n = add n (Suc ?ma2) <br>\nproof (state)<br>\nthis:<br>\n  add (Suc m) n = add n (Suc m)</p>\n<p>goal:<br>\nNo subgoals! <br>\nFailed to finish proof⌂:<br>\ngoal (1 subgoal):</p>\n<ol>\n<li>add m n = add n m ⟹ Suc (add n m) = add n (Suc m)</li>\n</ol>\n<p>So once no subgoals, on the other hand Failed to finish proof. </p>\n<p>Does the first relate to to the Suc m case and the failed proof to the top level theorem?</p>\n<p>lemma add_commute: \"add m n = add n m\"<br>\nproof (induction m)<br>\n  case 0<br>\n  then show ?case by (simp add: add_0_right)<br>\nnext<br>\n  case (Suc m)<br>\n  then show ?case by (simp)<br>\nqed</p>",
        "id": 223345830,
        "sender_full_name": "Gergely Buday",
        "timestamp": 1611132818
    },
    {
        "content": "<p>Please use code blocks for readability like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>```isabelle\nlemma &quot;x = x&quot;\n  by (rule refl)\n```\n</code></pre></div>\n<p>It looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"s\">\"x = x\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">rule</span> <span class=\"n\">refl</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 223346086,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1611132973
    },
    {
        "content": "<p>show can fail in two ways: 1. there can be no corresponding to prove (e.g., no such goal generated by induction). 2. discharging the goal can fail because the tactic fails.</p>",
        "id": 223346276,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1611133111
    },
    {
        "content": "<p>To make it easier understand the difference, do not show the state in the output panel (untick the \"Proof state\"). The state panel refers to the global state and the output panel to the current goal.</p>",
        "id": 223346429,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1611133216
    },
    {
        "content": "<p>If there's read text and a <code>Failed to finished proofs</code>, that is what counts.</p>\n<p>The <code>no subgoals</code> is a consequence of the fact that proofs with <code>by</code> are forked in Isabelle, i.e. when Isabelle encounters a <code>by</code>, the theorem is immediately considered as proven and you can carry on doing things. The proof is forked to the background and if it fails at some point, you get an error, but the theorem is still there.</p>\n<p>This is to make working easier (and faster) in interactive mode. For the batch mode, there is a phase in the end where it waits for all these forked proofs to complete, and if there are any errors, the build fails.</p>",
        "id": 223346442,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1611133227
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 223350168,
        "sender_full_name": "Gergely Buday",
        "timestamp": 1611135680
    }
]