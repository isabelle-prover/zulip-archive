[
    {
        "content": "<p>I have defined a property of lists:</p>\n<div class=\"codehilite\"><pre><span></span><code>definition property :: &quot;color list ⇒ bool&quot; where\n  &quot;property clrs ⟷ (∀a &lt; length clrs. ∀b &lt; length clrs.\n    a &lt; b ∧ clrs ! a = clrs ! b ⟶ (∃m ∈ {a..b}. clrs ! m ≠ clrs ! a))&quot;\n</code></pre></div>\n<p>I would now like to show that <code>property (xs @ ys) ==&gt; property (ys @ zs) ==&gt; property (xs @ zs) ==&gt; property (xs @ ys @ zs)</code>. AFAICS, the proof would involve some unpleasant index arithmetic to distinguish the cases of which list <code>a</code> and <code>b</code> point into. Is there an easier way to express this? Maybe some way of manipulating sequences where \"m is between a and b\" is more of a first-class construct?</p>",
        "id": 226197957,
        "sender_full_name": "Jakub Kądziołka",
        "timestamp": 1613165001
    },
    {
        "content": "<p>Your property is just a very complicated way to say that the list must not have adjacent equal elements:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">successively_conv_nth</span><span class=\"o\">:</span> <span class=\"s\">\"successively R xs ⟷ (∀i&lt;length xs - 1. R (xs ! i) (xs ! Suc i))\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">induction</span> <span class=\"n\">xs</span> <span class=\"n\">rule</span><span class=\"o\">:</span> <span class=\"n\">induct_list012</span><span class=\"err\">;</span> <span class=\"n\">force</span> <span class=\"n\">simp</span><span class=\"o\">:</span> <span class=\"n\">nth_Cons</span> <span class=\"n\">split</span><span class=\"o\">:</span> <span class=\"n\">nat.splits</span><span class=\"o\">)</span>\n\n<span class=\"k\">definition</span> <span class=\"n\">property</span> <span class=\"o\">::</span> <span class=\"s\">\"'a list ⇒ bool\"</span> <span class=\"kp\">where</span>\n  <span class=\"s\">\"property clrs ⟷ (∀a &lt; length clrs. ∀b &lt; length clrs.</span>\n<span class=\"s\">    a &lt; b ∧ clrs ! a = clrs ! b ⟶ (∃m ∈ {a..b}. clrs ! m ≠ clrs ! a))\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">propertyD</span><span class=\"o\">:</span> <span class=\"s\">\"property xs ⟹ i &lt; j ⟹ j &lt; length xs ⟹ xs ! i = xs ! j ⟹ ∃m ∈ {i..j}. xs ! m ≠ xs ! i\"</span>\n  <span class=\"k\">unfolding</span> <span class=\"n\">property_def</span> <span class=\"k\">by</span> <span class=\"n\">auto</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">property_altdef</span><span class=\"o\">:</span> <span class=\"s\">\"property xs ⟷ distinct_adj xs\"</span>\n<span class=\"k\">proof</span> <span class=\"o\">(</span><span class=\"n\">intro</span> <span class=\"n\">iffI</span><span class=\"o\">)</span>\n  <span class=\"k\">assume</span> <span class=\"n\">p</span><span class=\"o\">:</span> <span class=\"s\">\"property xs\"</span>\n  <span class=\"k\">show</span> <span class=\"s\">\"distinct_adj xs\"</span>\n    <span class=\"k\">unfolding</span> <span class=\"n\">distinct_adj_def</span> <span class=\"n\">successively_conv_nth</span>\n  <span class=\"k\">proof</span> <span class=\"o\">(</span><span class=\"n\">intro</span> <span class=\"n\">allI</span> <span class=\"n\">impI</span><span class=\"o\">)</span>\n    <span class=\"k\">fix</span> <span class=\"n\">i</span> <span class=\"k\">assume</span> <span class=\"n\">i</span><span class=\"o\">:</span> <span class=\"s\">\"i &lt; length xs - 1\"</span>\n    <span class=\"k\">show</span> <span class=\"s\">\"xs ! i ≠ xs ! Suc i\"</span>\n    <span class=\"k\">proof</span>\n      <span class=\"k\">assume</span> <span class=\"err\">*</span><span class=\"o\">:</span> <span class=\"s\">\"xs ! i = xs ! Suc i\"</span>\n      <span class=\"k\">with</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"k\">have</span> <span class=\"s\">\"∃m∈{i..Suc i}. xs ! m ≠ xs ! i\"</span>\n        <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">intro</span> <span class=\"n\">propertyD</span><span class=\"o\">)</span> <span class=\"n\">auto</span>\n      <span class=\"k\">thus</span> <span class=\"n\">False</span> <span class=\"k\">using</span> <span class=\"err\">*</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">auto</span> <span class=\"n\">simp</span><span class=\"o\">:</span> <span class=\"n\">le_Suc_eq</span><span class=\"o\">)</span>\n    <span class=\"k\">qed</span>\n  <span class=\"k\">qed</span>\n<span class=\"k\">next</span>\n  <span class=\"k\">assume</span> <span class=\"s\">\"distinct_adj xs\"</span>\n  <span class=\"k\">show</span> <span class=\"s\">\"property xs\"</span> <span class=\"k\">unfolding</span> <span class=\"n\">property_def</span>\n  <span class=\"k\">proof</span> <span class=\"n\">safe</span>\n    <span class=\"k\">fix</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"k\">assume</span> <span class=\"n\">ij</span><span class=\"o\">:</span> <span class=\"s\">\"i &lt; j\"</span> <span class=\"s\">\"j &lt; length xs\"</span> <span class=\"s\">\"xs ! i = xs ! j\"</span>\n    <span class=\"k\">from</span> <span class=\"err\">‹</span><span class=\"n\">distinct_adj</span> <span class=\"n\">xs</span><span class=\"err\">›</span> <span class=\"k\">have</span> <span class=\"s\">\"xs ! i ≠ xs ! Suc i\"</span>\n      <span class=\"k\">using</span> <span class=\"n\">ij</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">auto</span> <span class=\"n\">simp</span><span class=\"o\">:</span> <span class=\"n\">successively_conv_nth</span> <span class=\"n\">distinct_adj_def</span><span class=\"o\">)</span>\n    <span class=\"k\">thus</span> <span class=\"s\">\"∃m∈{i..j}. xs ! m ≠ xs ! i\"</span>\n      <span class=\"k\">using</span> <span class=\"n\">ij</span> <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">intro</span> <span class=\"n\">bexI</span><span class=\"o\">[</span><span class=\"n\">of</span> <span class=\"o\">_</span> <span class=\"s\">\"Suc i\"</span><span class=\"o\">])</span> <span class=\"n\">auto</span>\n  <span class=\"k\">qed</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>Your property then easily follows with the library theorems:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"s\">\"property (xs @ ys) ⟹ property (ys @ zs) ⟹ property (xs @ zs) ⟹ property (xs @ ys @ zs)\"</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">auto</span> <span class=\"n\">simp</span><span class=\"o\">:</span> <span class=\"n\">property_altdef</span> <span class=\"n\">distinct_adj_append_iff</span> <span class=\"n\">hd_append</span> <span class=\"n\">split</span><span class=\"o\">:</span> <span class=\"n\">if_splits</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Note that this uses <code>successively</code> and <code>distinct_adj</code>, which is not yet in Isabelle2020 (but in Isabelle2021).</p>\n<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>",
        "id": 226214356,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1613175436
    },
    {
        "content": "<p>And, yes, you are right in thinking that with the indices it would end up being quite messy (quite a few more case distinctions). Even more so with your original definition of <code>property</code> using an existential quantifier, since the automation is not good at instantiating existentials.</p>",
        "id": 226214473,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1613175568
    }
]