[
    {
        "content": "<p>When I define my lemmas and have universally quantified variables, I can either </p>\n<ol>\n<li>not bind them</li>\n<li>bind them with <code>⋀</code></li>\n<li>bind them with <code>∀</code><br>\nI'm not sure when to use what and how to convert back and forth. Looking at <code>measure_induct</code> and <code>measure_induct_rule</code> kind of exemplifies my confusion - which variant is good for what?</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">measure_induct</span>\n<span class=\"o\">(</span><span class=\"n\">⋀x.</span><span class=\"w\"> </span><span class=\"n\">∀y.</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">&lt;</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">⟶</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">⟹</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">⟹</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">a</span>\n<span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">measure_induct_rule</span>\n<span class=\"o\">(</span><span class=\"n\">⋀x.</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">⋀y.</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"n\">&lt;</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"n\">⟹</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">⟹</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">⟹</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">a</span>\n</code></pre></div>",
        "id": 482854766,
        "sender_full_name": "Jonathan Lindegaard Starup",
        "timestamp": 1731843433
    },
    {
        "content": "<p>In my experience, the difference does not really matter</p>",
        "id": 482858888,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1731847107
    },
    {
        "content": "<p>Both versions are annoying to work with OF:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹(⋀x. ∀y. f y &lt; f x ⟶ P y ⟹ P x) ⟹ P a›</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"k\">context</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹(⋀x. ∀y. f y &lt; f x ⟶ P y ⟹ P x)›</span>\n<span class=\"k\">begin</span>\n<span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">[</span><span class=\"n\">OF</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"c\">(*</span>\n<span class=\"c\">unexpected for me</span>\n<span class=\"c\">(⋀x. ∀y. ?f y &lt; ?f x ⟶ ?P1 y (?x1 y) ⟹ ∀y. ?f1 x y &lt; ?f1 x (?x1 x) ⟶ ?P1 x y) ⟹ ?P1 ?a (?x1 ?a)</span>\n<span class=\"c\">*)</span>\n</code></pre></div>",
        "id": 482858899,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1731847124
    },
    {
        "content": "<p>I've found just in my experience that it can sometimes affect automation/the sucess of sledgehammer calls, and some tactics (which is why some big libraries have both). Generally, keep in mind that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⋀</mo></mrow><annotation encoding=\"application/x-tex\">\\bigwedge</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">⋀</span></span></span></span> is part of Isabelle's metalogic, whereas <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> is not. You can't mix the two inside a single logical formula, so this sometimes determines what you are using. This is why, for example, in <code>measure\\_induct</code> it switches to using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> as it's also using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\rightarrow</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">→</span></span></span></span>. My general principle when defining lemmas is to (1) avoid binding if it's not logically necessary, (2) use Isabelle's meta logic for universal quantification (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⋀</mo></mrow><annotation encoding=\"application/x-tex\">\\bigwedge</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">⋀</span></span></span></span>) where possible, and (3) only use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span> in lemma definitions if you need to, e.g. if  if you are writing a lemma to help prove a statement that already uses <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi></mrow><annotation encoding=\"application/x-tex\">\\forall</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord\">∀</span></span></span></span>/uses other logical symbols.</p>",
        "id": 482880592,
        "sender_full_name": "Chelsea Edmonds",
        "timestamp": 1731864576
    },
    {
        "content": "<p>That was also my experience. Is there a better way to do it? I cant really get <code>measure_induct</code> to work like <code>induction t</code> does.</p>\n<p>If I have <code>shows \"P x\"</code> I can just use <code>proof (induction x)</code> but <code>proof (induction rule:measure_induct)</code> fails (<code>Illegal schematic variable(s)</code>)</p>",
        "id": 482880821,
        "sender_full_name": "Jonathan Lindegaard Starup",
        "timestamp": 1731864736
    },
    {
        "content": "<p>I think this is an issue with how you're using induction. Try something like <code>induct x rule: measure_induct[where f = ...]</code> (you could also just use of instead). Basically I think you'll need to specify what you want f to be in order to use the induct tactic with that rule otherwise it doesn't know what to do with f (which is a schematic variable in the rule). In comparison <code>induction x</code> as a tactic tries to be clever and automatically deduce the induction rule you want to apply, so in more complex situations often uses the wrong induction rule which results in goals that aren't particularly useful.</p>",
        "id": 482895231,
        "sender_full_name": "Chelsea Edmonds",
        "timestamp": 1731876586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/channel/238552-Beginner-Questions/topic/when.20to.20use.20.E2.8B.80.2E.20vs.20.E2.88.80.2E/near/482858899\">said</a>:</p>\n<blockquote>\n<p>Both versions are annoying to work with OF:</p>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹(⋀x. ∀y. f y &lt; f x ⟶ P y ⟹ P x) ⟹ P a›</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"k\">context</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹(⋀x. ∀y. f y &lt; f x ⟶ P y ⟹ P x)›</span>\n<span class=\"k\">begin</span>\n<span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">[</span><span class=\"n\">OF</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"c\">(*</span>\n<span class=\"c\">unexpected for me</span>\n<span class=\"c\">(⋀x. ∀y. ?f y &lt; ?f x ⟶ ?P1 y (?x1 y) ⟹ ∀y. ?f1 x y &lt; ?f1 x (?x1 x) ⟶ ?P1 x y) ⟹ ?P1 ?a (?x1 ?a)</span>\n<span class=\"c\">*)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>You could use <code>uOF</code> from the AFP:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span>\n<span class=\"w\">  </span><span class=\"kp\">imports</span>\n<span class=\"w\">    </span><span class=\"n\">Main</span>\n<span class=\"w\">    </span><span class=\"n\">ML_Unification.Unification_Attributes</span>\n<span class=\"w\">    </span><span class=\"n\">ML_Unification.ML_Unification_HOL_Setup</span>\n<span class=\"k\">begin</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹(⋀x. ∀y. f y &lt; f x ⟶ P y ⟹ P x) ⟹ P a›</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n<span class=\"k\">context</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">‹(⋀x. ∀y. f y &lt; f x ⟶ P y ⟹ P x)›</span>\n<span class=\"k\">begin</span>\n<span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">[</span><span class=\"n\">uOF</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c\">(*what you want*)</span>\n<span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"o\">[</span><span class=\"n\">uOF</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"n\">resolve</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"c\">(*same behaviour as OF*)</span>\n<span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 482945391,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1731914070
    },
    {
        "content": "<p>Follow up and context for my problem: I tried something like</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">datatype</span><span class=\"w\"> </span><span class=\"n\">dat</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Data</span>\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">‹func Data = 0 + 1›</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">‹P (d::dat)›</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"o\">:</span><span class=\"n\">measure_induct</span><span class=\"o\">[</span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"o\">])</span>\n<span class=\"w\">  </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"k\">then</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"gr\">sorry</span>\n<span class=\"k\">qed</span>\n</code></pre></div>\n<p>On which <code>case (1 x)</code> gave me the error <code>exception THM 1 raised (line 1242 of \"thm.ML\"): assume: variables</code></p>\n<p>I have now realized that the error is because <code>func: dat =&gt; 'a</code> since <code>1</code> is overloaded. so the induction instantiation has a type variable. I have really had a lot of issues with unconstrained type variables. I wish the errors regarding them were more clear</p>",
        "id": 483501787,
        "sender_full_name": "Jonathan Lindegaard Starup",
        "timestamp": 1732114181
    },
    {
        "content": "<p>Typing functions is always better (also better for refactoring later)</p>",
        "id": 483502103,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1732114261
    },
    {
        "content": "<p>Much less error-prone</p>",
        "id": 483502152,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1732114277
    },
    {
        "content": "<p>Yeah, I keep relearning that. But sometimes I have functions with with type variables just on the result (stupid example but perhaps <code>nat =&gt; 'a list</code> and then the same kind of problems occur.</p>",
        "id": 483503387,
        "sender_full_name": "Jonathan Lindegaard Starup",
        "timestamp": 1732114573
    }
]