[
    {
        "content": "<p>I'm trying to prove a lemmu using list induction. I need to use a function I defined on a list, and I need the induction to be on the reverse of a list(I need the cases to be  \"\"Nil\" |  \"snoc xs x\" \" instead of \" \"Nil\" | x # xs\"). I can't use \"proof(induct l1 rule:  comp.induct rev_induct)\" since it throws an error \"Failed to join given rules into one mutual rule\". I tried defining the function differently:</p>\n<p>\"fun comp :: \"'a list ⇒ 'a\"  where<br>\n    \"comp [x] = x\"<br>\n  | \"comp [x,f,y] = f\" <br>\n  | \"comp xs = (if (length xs &gt; 3) then (comp (drop 2 xs) #0 (hd (tl (rev xs)))) else undefined )\"   \" but this doesn't work either.</p>\n<p>I also tried defining a new variable as \"ys = rev xs\" but then my inductive hypothesis has things <br>\nlike<br>\n \" v # vb  = ys⟹  P ys⟹ Q ys\" </p>\n<p>and \" v # vb # vc = ys\" which makes it very hard (or maybe impossible) to prove things.</p>\n<ol>\n<li>Is there a way I can modify my function to be suitable for use with rev_induct?</li>\n<li>Is there a way I can write a function with cases \"Nil | xs # [x]\" instead of the regular way? This throws an error since Isabelle can't detect the constructor (\"Non-constructor pattern not allowed in sequential mode\")</li>\n</ol>\n<p>TIA</p>",
        "id": 432300103,
        "sender_full_name": "ee",
        "timestamp": 1712683928
    },
    {
        "content": "<p>You are giving two rules instead of one. If you give only one it will work:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">comp</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ 'a\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"s\">\"comp [x] = x\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"comp [x,f,y] = f\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"comp xs = (if (length xs &gt; 3) then comp (drop 2 xs @ [hd (tl (rev xs))]) else undefined )\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"comp xs ∈ set xs\"</span>\n<span class=\"w\">  </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">induction</span><span class=\"w\"> </span><span class=\"n\">xs</span><span class=\"w\"> </span><span class=\"n\">rule</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">rev_induct</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n<span class=\"w\">  </span><span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 432300670,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1712684157
    },
    {
        "content": "<p>But if you want to compose rules, you need to define your own induction principle.</p>",
        "id": 432300784,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1712684190
    },
    {
        "content": "<p>For 2: not, this would not be computable</p>",
        "id": 432300880,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1712684224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/why.20can't.20I.20use.20two.20induction.20rules.20at.20the.20same.20time/near/432300784\">said</a>:</p>\n<blockquote>\n<p>But if you want to compose rules, you need to define your own induction principle.</p>\n</blockquote>\n<p>Yeah that's what I figured. Thanks!</p>",
        "id": 432306534,
        "sender_full_name": "ee",
        "timestamp": 1712685756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/why.20can't.20I.20use.20two.20induction.20rules.20at.20the.20same.20time/near/432300880\">said</a>:</p>\n<blockquote>\n<p>For 2: not, this would not be computable</p>\n</blockquote>\n<p>I would not necessarily recommend doing this, but it can be done by setting up \"append at the back\" as a free constructor:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">snoc</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"snoc xs x = xs @ [x]\"</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">case_list_rev</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a ⇒ ('b list ⇒ 'b ⇒ 'a) ⇒ 'b list ⇒ 'a\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"case_list_rev x f xs = (if xs = [] then x else f (butlast xs) (last xs))\"</span>\n\n<span class=\"k\">free_constructors</span><span class=\"w\"> </span><span class=\"n\">case_list_rev</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">Nil</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">snoc</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">snoc_def</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">rev_exhaust</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_snoc</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">termination_simp</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"s\">\"length (snoc xs x) = Suc (length xs)\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">snoc_def</span><span class=\"o\">)</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"f [] = 0\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"f (snoc xs x) = f xs + 1\"</span>\n</code></pre></div>",
        "id": 432313039,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1712687267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232736\">Manuel Eberl</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/why.20can't.20I.20use.20two.20induction.20rules.20at.20the.20same.20time/near/432313039\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/why.20can't.20I.20use.20two.20induction.20rules.20at.20the.20same.20time/near/432300880\">said</a>:</p>\n<blockquote>\n<p>For 2: not, this would not be computable</p>\n</blockquote>\n<p>I would not necessarily recommend doing this, but it can be done by setting up \"append at the back\" as a free constructor:</p>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">snoc</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"snoc xs x = xs @ [x]\"</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">case_list_rev</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a ⇒ ('b list ⇒ 'b ⇒ 'a) ⇒ 'b list ⇒ 'a\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"case_list_rev x f xs = (if xs = [] then x else f (butlast xs) (last xs))\"</span>\n\n<span class=\"k\">free_constructors</span><span class=\"w\"> </span><span class=\"n\">case_list_rev</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">Nil</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">snoc</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">snoc_def</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">rev_exhaust</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_snoc</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">termination_simp</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"s\">\"length (snoc xs x) = Suc (length xs)\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">snoc_def</span><span class=\"o\">)</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"f [] = 0\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"f (snoc xs x) = f xs + 1\"</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Never mind, this is a very bad idea because 1. the code generation doesn't work for this and 2. it overwrites the existing constructors of the <code>list</code> type.</p>",
        "id": 432313531,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1712687391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232736\">Manuel Eberl</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/why.20can't.20I.20use.20two.20induction.20rules.20at.20the.20same.20time/near/432313039\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/why.20can't.20I.20use.20two.20induction.20rules.20at.20the.20same.20time/near/432300880\">said</a>:</p>\n<blockquote>\n<p>For 2: not, this would not be computable</p>\n</blockquote>\n<p>I would not necessarily recommend doing this, but it can be done by setting up \"append at the back\" as a free constructor:</p>\n<p><div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">snoc</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"snoc xs x = xs @ [x]\"</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">case_list_rev</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a ⇒ ('b list ⇒ 'b ⇒ 'a) ⇒ 'b list ⇒ 'a\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"case_list_rev x f xs = (if xs = [] then x else f (butlast xs) (last xs))\"</span>\n\n<span class=\"k\">free_constructors</span><span class=\"w\"> </span><span class=\"n\">case_list_rev</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">Nil</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">snoc</span>\n<span class=\"w\">  </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">snoc_def</span><span class=\"w\"> </span><span class=\"k\">using</span><span class=\"w\"> </span><span class=\"n\">rev_exhaust</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">length_snoc</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">termination_simp</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"s\">\"length (snoc xs x) = Suc (length xs)\"</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">snoc_def</span><span class=\"o\">)</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span>\n<span class=\"w\">  </span><span class=\"s\">\"f [] = 0\"</span>\n<span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"f (snoc xs x) = f xs + 1\"</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Uh could you still explain  how this works a little? I' m not at all familiar with the sytax and keywords you are using, it seems like something that could be useful in the future.</p>",
        "id": 432441356,
        "sender_full_name": "ee",
        "timestamp": 1712736534
    },
    {
        "content": "<p><code>free_constructors</code> appears 7 times in the entire AFP, so not really useful</p>",
        "id": 432441992,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1712736736
    },
    {
        "content": "<p>The idea is that you can set your own constructors as definition for the BNF</p>",
        "id": 432442082,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1712736766
    },
    {
        "content": "<p>Yeah, it allows you to do pattern matching on something that isn't a datatype. It's also used for e.g. the <code>nat</code> type, which looks like a datatype but actually isn't.</p>",
        "id": 432447207,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1712737978
    },
    {
        "content": "<p>But unlike what I initially thought, it appears that you can only have one set of \"free constructors\" per datatype, so it only makes sense to do this exactly once per type and only with constructors that are really \"canonical\".</p>",
        "id": 432447516,
        "sender_full_name": "Manuel Eberl",
        "timestamp": 1712738051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233198\">Mathias Fleury</span> <a href=\"#narrow/stream/238552-Beginner-Questions/topic/why.20can't.20I.20use.20two.20induction.20rules.20at.20the.20same.20time/near/432300784\">said</a>:</p>\n<blockquote>\n<p>But if you want to compose rules, you need to define your own induction principle.</p>\n</blockquote>\n<p>Sorry, could I have some insight into how I can do this properly? </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"n\">inductC</span><span class=\"o\">:</span>\n<span class=\"w\">  </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list ⇒ bool\"</span>\n<span class=\"w\">    </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">a0</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a list\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\"> </span><span class=\"n\">h0</span><span class=\"o\">:</span><span class=\"s\">\"P []\"</span>\n<span class=\"w\">  </span><span class=\"kp\">assumes</span><span class=\"w\">  </span><span class=\"n\">h1</span><span class=\"o\">:</span><span class=\"s\">\"⋀ x. comp [x] ∧ P [x]\"</span>\n<span class=\"w\">    </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">h2</span><span class=\"o\">:</span><span class=\"s\">\"⋀ x f y. (comp [x, f, y] ∧ P [x, f, y]) \"</span>\n<span class=\"w\">    </span><span class=\"kp\">and</span>\n<span class=\"w\">    </span><span class=\"n\">ind</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"⋀ f v g. comp v ∧ comp [last v, f, g] ∧</span>\n<span class=\"s\">        P (v ) ⟹ P ( append v [f,g])\"</span>\n<span class=\"w\">  </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"s\">\"comp a0\"</span>\n<span class=\"w\">  </span><span class=\"kp\">shows</span><span class=\"w\"> </span><span class=\"s\">\"P a0\"</span>\n</code></pre></div>\n<p>I saw an example that used a format like this, but then when I try to use this to prove a lemma, some of the states don't pick any of the assumptions, eg <br>\n\"proof (state)<br>\nthis:</p>\n<p>goal (4 subgoals):\" .<br>\n The only one that does is the inductive steps case actually. I was thinking h0 h1 h2 would act as the base cases(they can be proved using the definition of \"comp\") but there's nothing in the scope I can use to prove them.</p>",
        "id": 432489909,
        "sender_full_name": "ee",
        "timestamp": 1712751216
    },
    {
        "content": "<p>Look at <code>list.induct</code> and <code>rev.induct</code> to see what the format is</p>",
        "id": 432497614,
        "sender_full_name": "Mathias Fleury",
        "timestamp": 1712753649
    }
]