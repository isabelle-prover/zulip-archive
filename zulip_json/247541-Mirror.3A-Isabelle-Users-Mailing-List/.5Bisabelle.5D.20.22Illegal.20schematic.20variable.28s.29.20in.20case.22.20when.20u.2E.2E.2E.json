[
    {
        "content": "<p>From: \"<a href=\"mailto:Isaac@ecs.vuw.ac.nz\">Isaac@ecs.vuw.ac.nz</a>\" &lt;<a href=\"mailto:Isaac@ecs.vuw.ac.nz\">Isaac@ecs.vuw.ac.nz</a>&gt;<br>\nHello,<br>\nI seem to have a fund a bug with induction, but I couldn't work out where I should report this;</p>\n<p>Bassically, if I put a function inside a context like this:<br>\n    context fixes par :: bool begin<br>\n        function foo :: ‹bool ⇒ bool› where<br>\n            ‹foo True = (∀ j :: bool. par ∧ (par ⟶ foo False))› |<br>\n            ‹foo False = True›<br>\n            by(auto) termination by(relation ‹measure (λb . if b then 1 else 0)›, auto)<br>\n    end<br>\nThe generated \"thm foo.induct\" is as expected:<br>\n    ((⋀x. ?par ⟹ ?P False) ⟹ ?P True) ⟹ ?P False ⟹ ?P ?a0.0</p>\n<p>However if I try and use it with the \"induction\" method, it breaks:<br>\n    lemma assumes ‹par› shows ‹foo par val› proof(induction val rule: foo.induct)</p>\n<p>This suggests the proof text:<br>\n    case 1<br>\n    then show ?case sorry<br>\n    next<br>\n    case 2<br>\n    then show ?case sorry<br>\n    qed</p>\n<p>But that text reports an error on the first \"case 1\":<br>\n    proof (state)<br>\n    goal (2 subgoals):</p>\n<p>1. (⋀x. ?par ⟹ foo par False) ⟹ foo par True<br>\n    2. foo par False<br>\n    Illegal schematic variable(s) in case \"1\"⌂</p>\n<p>A simple workaround is to use \"proof(induction val rule: foo.induct[of par])\", and everything works as expected:<br>\n    proof (state)<br>\n    goal (2 subgoals):</p>\n<p>1. (⋀x. par ⟹ foo par False) ⟹ foo par True<br>\n    2. foo par False</p>\n<p>And the proof goes through (after replacing \"sorry\" with \"by (auto)\")</p>\n<p>As an asside, the reason I have my function in a context to begin with is so that it dosen't put \"⋀par\" arround each case, which would break my proof, because each step dosn't hold for each \"par\", but rather the specific one i've assumed to be true!</p>",
        "id": 257016237,
        "sender_full_name": "Email Gateway",
        "timestamp": 1633931730
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nIt's not a bug, in that sense. The theorem you're trying to use isn't the usual shape for an induction rule, and it's reporting that as best it can.</p>\n<p>Exporting a theorem out of a context, in general, changes its shape, although typically not much. There's no guarantee that induction-shaped rules are exported to induction-shaped rules, etc. Since you've now left an anonymous context and there's no way to return, or get access to foo.induct by any other name, it might seem confusing that foo.induct is not an induction rule, but it's just a consequence of the steps that have been taken.</p>\n<p>You've written a postscript in which you explain your reasoning for using a context, which looks like it boils down to saying that some other approach wasn't working. I suspect you should rewind and try other fixes to your original induction problem.</p>\n<p>Good luck with it,<br>\n    Thomas.</p>",
        "id": 257037547,
        "sender_full_name": "Email Gateway",
        "timestamp": 1633944938
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi Isaac,</p>\n<p>The generated induction rule depends on the context parameter ?par and you have to tell <br>\nthe induction method how it is supposed to be instantiated. That's what the \"taking\" <br>\noption is good for:</p>\n<p>proof(induction val taking: par rule: foo.induct)</p>\n<p>This is typical for definitions inside a context, be them fun(ction) or (co)inductive(_set).</p>\n<blockquote>\n<p>As an asside, the reason I have my function in a context to begin with is so that it <br>\ndosen't put \"⋀par\" arround each case, which would break my proof, because each step dosn't <br>\nhold for each \"par\", but rather the specific one i've assumed to be true!</p>\n</blockquote>\n<p>Right. That's the reason why I often put a function definition into an anonymous context. <br>\nThere's also an alternative where you explicitly specify the desired instantiation upon <br>\neach induction call:</p>\n<p>function foo :: ‹bool ⇒ bool ⇒ bool› where<br>\n   ‹foo par True = (∀ j :: bool. par ∧ (par ⟶ foo par False))› |<br>\n   ‹foo par False = True›<br>\n   by(auto) termination by(relation ‹measure (λ(_, b). if b then 1 else 0)›, auto)</p>\n<p>lemma assumes ‹par› shows ‹foo par val›<br>\nproof(induction par'≡\"par\" val rule: foo.induct)</p>\n<p>For induction, the usability is about the same. The difference comes with the <code>.cases</code> <br>\nrule where you don't have to instantiate \"par\" in the version with the context.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 257085638,
        "sender_full_name": "Email Gateway",
        "timestamp": 1633968695
    }
]