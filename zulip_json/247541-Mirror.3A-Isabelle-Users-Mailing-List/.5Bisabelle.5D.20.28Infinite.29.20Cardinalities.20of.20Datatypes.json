[
    {
        "content": "<p>From: Asta Halkjær From &lt;<a href=\"mailto:andro.from@gmail.com\">andro.from@gmail.com</a>&gt;<br>\nHi,</p>\n<p>In my current project, I'm interested in knowing that a lot of datatypes<br>\ninherit the cardinality of their parameters, in a similar way to how a lot<br>\nof datatypes are countable as long as their parameters are.<br>\nFor instance, the cardinal library already knows about lists, so you can<br>\nprove the following:</p>\n<p>lemma<br>\n  assumes ‹infinite (UNIV :: 'a set)›<br>\n  shows ‹|UNIV :: 'a list set| =o |UNIV :: 'a set|›<br>\n  using assms card_of_lists_infinite by fastforce</p>\n<p>But I would like an automatic way to generate lemmas like this for other<br>\ndatatypes (of the correct shape) as well.<br>\nIs there any existing work on this?</p>\n<p>Best,<br>\nAsta</p>",
        "id": 319973333,
        "sender_full_name": "Email Gateway",
        "timestamp": 1673104556
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;<br>\nHi Asta,</p>\n<p>The closest to this is perhaps the proof that we do internally in the datatype construction, where we establish for any BNF ‘a T:</p>\n<p>\"|{x. set_T x ⊆ A}| ≤o ( |A| +c ctwo) ^c (bd_T +c |UNIV :: bd_type_T T set| )\"</p>\n<p>If you take A to be UNIV this is the same as:</p>\n<p>\"|UNIV :: 'a T set| ≤o |UNIV :: 'a set| ^c (bd_T +c |UNIV :: bd_type_T T set| )”</p>\n<p>If you further know that T is countable you can get to:</p>\n<p>\"|UNIV :: 'a T set| ≤o |UNIV :: 'a set| ^c natLeq”</p>\n<p>This gives a rather crude upper bound (and no lower bound) if you compare with what you found in the library for lists. On the upside it works for any BNF.<br>\nBut probably you want something more precise for the datatypes “of the correct shape”. Do you have an intuition what the correct shape is (just sums of products, i.e., no nesting?).</p>\n<p>Best wishes,<br>\nDmitriy</p>",
        "id": 320269178,
        "sender_full_name": "Email Gateway",
        "timestamp": 1673281637
    },
    {
        "content": "<p>From: Asta Halkjær From &lt;<a href=\"mailto:andro.from@gmail.com\">andro.from@gmail.com</a>&gt;<br>\nHi Dmitriy,</p>\n<p>Cool! What I am interested in is logical syntax.<br>\nI have just submitted an AFP entry with a framework for proving<br>\ncompleteness, so I wanted a generic solution for users of that framework.<br>\nThe non-generic solution I came up with is the following.<br>\nThe example here is first-order logic. I have done the same for hybrid<br>\nlogic.</p>\n<p>Syntax can be written down linearly, so I can write an injective function<br>\nfrom terms and formulas to lists of type ('f + 'p) + marker &lt;*&gt; nat.<br>\nHere 'f is the type of functions symbols, 'p is the type of propositional<br>\nsymbols and marker is just an enumeration type.<br>\nMy encoding is basically Polish notation but with the natural numbers added<br>\nin to ease the injectivity proof.<br>\nFor example: \"Imp p q\" becomes \"Inr (ImpM, length (encode p)) # encode p @<br>\nencode q\".<br>\nI wrote a similar function for labelled hybrid logic formulas.</p>\n<p>Then I wrote a helper lemma that does the cardinal arithmetic for both<br>\ncases.<br>\nSince the marker type is finite and I assume that 'f is infinite, 'f + 'p<br>\nswallows marker &lt;*&gt; nat .<br>\nIn the end I get that |UNIV :: ('f, 'p) fm set| &lt;=o |UNIV :: 'f set| +c<br>\n|UNIV :: 'p set|.<br>\nThis feels like a nice bound to me.</p>\n<p>While this is not automatic, the injective function should not be too hard<br>\nto copy and modify to other syntax.</p>\n<p>Best,<br>\nAsta</p>\n<p>Den man. 9. jan. 2023 kl. 17.25 skrev Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;:</p>",
        "id": 320274250,
        "sender_full_name": "Email Gateway",
        "timestamp": 1673282927
    }
]