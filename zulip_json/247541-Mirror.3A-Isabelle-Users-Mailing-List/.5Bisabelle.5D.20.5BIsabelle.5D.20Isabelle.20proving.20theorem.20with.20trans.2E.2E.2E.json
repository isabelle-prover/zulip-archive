[
    {
        "content": "<p>From: \"Wong, Yat\" &lt;<a href=\"mailto:yat.wong18@imperial.ac.uk\">yat.wong18@imperial.ac.uk</a>&gt;<br>\nHi everyone,</p>\n<p>I met some problems when I was trying to prove my theorems with my defined translation.</p>\n<hr>\n<p>My theory imports theory with:</p>\n<div class=\"codehilite\"><pre><span></span><code>imports Nlist IntExt Hilbert ZF.Univ\n(* Nlist, IntExt, Hilbert are defined on my own, they only contain theorems related to int *)\n</code></pre></div>\n\n\n<hr>\n<p>I had defined a few translations like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>consts\n  &quot;time&quot; :: &quot;i&quot;\n  &quot;sig&quot; :: &quot;i ⇒ i&quot;\n  &quot;BaseChTy&quot; :: &quot;i&quot;\n\nsyntax\n  &quot;time&quot; :: &quot;i&quot;\n  &quot;sig&quot; :: &quot;i ⇒ i&quot;\ntranslations\n  &quot;time&quot; ⇌ &quot;CONST int&quot;\n  &quot;sig(A)&quot; ⇌ &quot;CONST int → A&quot;\n</code></pre></div>\n\n\n<hr>\n<p>Then, I want to prove a theorem like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>theorem sig_mono: &quot;⟦ A ⊆ B ⟧ ⟹ sig(A) ⊆ sig(B)&quot;\n</code></pre></div>\n\n\n<hr>\n<p>It should be a very simple theorem, and should be proved with theorem <em>Pi_mono</em> in a single step:</p>\n<div class=\"codehilite\"><pre><span></span><code>thm Pi_mono\n?B ⊆ ?C ⟹ ?A → ?B ⊆ ?A → ?C\n</code></pre></div>\n\n\n<hr>\n<p>So I did it like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>theorem sig_mono: &quot;⟦ A ⊆ B ⟧ ⟹ sig(A) ⊆ sig(B)&quot;\n\napply(drule Pi_mono[of _ _ &quot;time&quot;])\n(*Output:\ngoal (1 subgoal):\n 1. sig(A) ⊆ sig(B) ⟹ sig(A) ⊆ sig(B)\n*)\n\napply(simp)\n(*Output:\nFailed ...\n*)\n</code></pre></div>\n\n\n<hr>\n<p>Since the premise has become the same as the goal, it should be proved immediately, but it didn't. May I know have I done anything wrong in the translation definition?<br>\nI tried to change the theorem to:</p>\n<div class=\"codehilite\"><pre><span></span><code>theorem sig_mono: &quot;⟦ A ⊆ B ⟧ ⟹ (time → A) ⊆ (time → B)&quot;\n(*Output:\ngoal (1 subgoal):\n 1. A ⊆ B ⟹ sig(A) ⊆ sig(B)\n*)\n\napply(drule Pi_mono[of _ _ &quot;time&quot;])\n(*Output:\ngoal (1 subgoal):\n 1. sig(A) ⊆ sig(B) ⟹ sig(A) ⊆ sig(B)\n*)\n\napply(simp)\n(*Output:\nSuccess ...\n*)\n</code></pre></div>\n\n\n<p>Then it works immediately, but shouldn't the translation will make them to be the same thing?</p>\n<hr>\n<p>Thanks for Mathias Fleury’s reply from stack overflow, I tried to do a simplify trace, and it shows something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>theorem sig_mono: &quot;⟦ A ⊆ B ⟧ ⟹ sig(A) ⊆ sig(B)&quot;\nusing [[show_sorts]] apply(drule Pi_mono[of _ _ &quot;time&quot;])\nusing [[simp_trace]] apply(simp)\noops\n\n(*\nOutput:\n[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:\nsig(A::i) ⊆ sig(B::i) ⟹ sig(A) ⊆ sig(B)\n[1]Adding rewrite rule &quot;??.unknown&quot;:\nsig(A::i) ⊆ sig(B::i) ≡ True\n*)\n</code></pre></div>\n\n\n<hr>\n<p>while the <em>time -&gt; A</em> version shows:</p>\n<div class=\"codehilite\"><pre><span></span><code>theorem sig_mono: &quot;⟦ A ⊆ B ⟧ ⟹ time → A ⊆ time → B&quot;\nusing [[show_sorts]] apply(drule Pi_mono[of _ _ &quot;time&quot;])\nusing [[simp_trace]] apply(simp)\noops\n\n(*\nOutput:\n[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:\nsig(A::i) ⊆ sig(B::i) ⟹ sig(A) ⊆ sig(B)\n[1]Adding rewrite rule &quot;??.unknown&quot;:\nsig(A::i) ⊆ sig(B::i) ≡ True\n[1]Applying instance of rewrite rule &quot;??.unknown&quot;:\nsig(A::i) ⊆ sig(B::i) ≡ True\n[1]Rewriting:\nsig(A::i) ⊆ sig(B::i) ≡ True\n*)\n</code></pre></div>\n\n\n<hr>\n<p>Why can this time version can apply the instance of rewrite rule to continue to the proof, but the original one does not?</p>\n<p>Thank you very much,</p>\n<p>Best regards,<br>\nChester</p>",
        "id": 206004309,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596620625
    }
]