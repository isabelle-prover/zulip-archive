[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I noticed that in the RC0, the simplification rules for the type bit <br>\n(from HOL-Library.Z2) have changed.</p>\n<p>Besides other rules, we have the following simp rules:</p>\n<p>* xor ?b ?c = of_bool (odd ?b ≠ odd ?c)<br>\n  * of_bool (¬ ?P) = 1 - of_bool ?P<br>\n  * (-) = (+)<br>\n  * (+) = xor</p>\n<p>These rules can give us a rewrite-cycle: xor is rewritten in terms of <br>\n\"of_bool (... ~= ...)\" which goes to \"1 - of_bool ...\" which goes to \"1 </p>\n<ul>\n<li>of_bool ...\" which goes to \"xor 1 (of_bool ...)\". And we have xor back!</li>\n</ul>\n<p>Whether this actually happens depends on the concrete case (sometimes <br>\nthe a case distinction splitter rule on the arguments of the xor happens <br>\ninstead, I think).</p>\n<p>But I have found that it can be quite easily triggered nonetheless.</p>\n<p>For example, ‹xor b c = of_bool (b ≠ c)› makes the simplifier loop.</p>\n<p>And if we add the (quite useful, imho) simp rule \"((a=x) = (b=x)) = <br>\n(a=b)\" for bits, then even something as natural as ‹a + b + b = a› loops.</p>\n<p>An example theory is attached.</p>\n<p>Of course, I don't know if there are any important reasons for those <br>\nxor-related simp-rules, but personally I feel that removing them (at <br>\nleast the \"xor ?b ?c = of_bool (odd ?b ≠ odd ?c)\" rule) would make the <br>\nsimplifier much less fragile in the presence of bit-related arithmetic.</p>\n<p>(Also, as an aside: why is there \"odd\" in the definition of xor? <br>\nWouldn't \"xor ?b ?c = of_bool (?b ≠ ?c)\" be simpler and equivalent?)</p>\n<p>Best wishes,<br>\nDominique.<br>\n<a href=\"/user_uploads/14278/EvyKMN7_VLUMWt1Wm9fT64hO/Scratch.thy\">Scratch.thy</a></p>",
        "id": 257532181,
        "sender_full_name": "Email Gateway",
        "timestamp": 1634217240
    }
]