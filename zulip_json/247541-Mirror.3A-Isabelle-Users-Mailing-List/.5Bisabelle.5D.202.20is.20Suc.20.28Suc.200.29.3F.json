[
    {
        "content": "<p>From: Li Yongjian &lt;<a href=\"mailto:lyj238@gmail.com\">lyj238@gmail.com</a>&gt;<br>\nDear experts:</p>\n<p>I define a simple function add,</p>\n<p>primrec add::\"nat ⇒nat ⇒nat\" where<br>\n\"add x 0= x\" |<br>\n\"add x (Suc y) =Suc (add x y)\"</p>\n<p>But I can't prove the following lemmas.</p>\n<p>lemma \"add 5 2= 7\"</p>\n<p>lemma \"add 7 2000= 2007\"</p>\n<p>So I want to ask what is the definition of a natural number 3,  2000?</p>\n<p>regards<br>\nlyj</p>",
        "id": 273036615,
        "sender_full_name": "Email Gateway",
        "timestamp": 1645666363
    },
    {
        "content": "<p>From: Alex Weisberger &lt;<a href=\"mailto:alex.m.weisberger@gmail.com\">alex.m.weisberger@gmail.com</a>&gt;<br>\nHello,</p>\n<p>It looks to me like primrec doesn't add the function definition to the set<br>\nof simplification rules (many people refer to this as the \"simp set\").<br>\nTherefore the definition can't be used to find a proof by simplification.</p>\n<p>You can add it explicitly in a couple of different ways depending on your<br>\npreference:</p>\n<p>lemma \"add 5 2 = 7\"<br>\n  by (simp add: add_def)</p>\n<p>or</p>\n<p>lemma \"add 5 2 = 7\" unfolding add_def by simp</p>\n<p>An alternative is to use \"fun\" to define the function instead of \"primrec\"<br>\nsince that will automatically add some simplification rules for this<br>\nfunction definition:</p>\n<p>fun add::\"nat ⇒nat ⇒nat\" where<br>\n\"add x 0= x\" |<br>\n\"add x (Suc y) = Suc (add x y)\"</p>\n<p>Surprisingly, that doesn't allow a proof by \"auto\" or \"simp\" directly. A<br>\nlittle sledgehammering and searching for relevant lemmas led to this:</p>\n<p>lemma \"add 5 2 = 7\"<br>\n  by (simp add: eval_nat_numeral)</p>\n<p>I'm still not sure why auto or simpl wouldn't work directly in this case if<br>\nanyone can shed some light on that.</p>",
        "id": 273041886,
        "sender_full_name": "Email Gateway",
        "timestamp": 1645672163
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nNumerals (2, 3, ...) are not Suc-terms but more efficient binary representations <br>\nthat need to be converted into Suc-form first before equations that <br>\npattern-match on Suc apply. The recommened rewrite rules for this conversion are <br>\neval_nat_numeral or numeral_eq_Suc.<br>\n(In general it is not a good idea to unfold internal definitions like add_def if <br>\nadd was defined by some other means than `definition').</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/F5ch02nZXG1kSZOgD0NzNjlr/smime.p7s\">smime.p7s</a></p>",
        "id": 273050888,
        "sender_full_name": "Email Gateway",
        "timestamp": 1645682384
    },
    {
        "content": "<p>From: Li Yongjian &lt;<a href=\"mailto:lyj238@gmail.com\">lyj238@gmail.com</a>&gt;<br>\nBy my learning experience in Isabelle, primrec def should be unfolded<br>\nautomatically?</p>\n<p>Is it ture?</p>",
        "id": 273056298,
        "sender_full_name": "Email Gateway",
        "timestamp": 1645688565
    },
    {
        "content": "<p>From: Alex Weisberger &lt;<a href=\"mailto:alex.m.weisberger@gmail.com\">alex.m.weisberger@gmail.com</a>&gt;<br>\nI thought so as well. For what it's worth, the proof with the addition of<br>\neval_nat_numeral works for the primrec definition as well:</p>\n<p>lemma \"add 5 2 = 7\"<br>\n  by (simp add: eval_nat_numeral)</p>\n<p>So my initial suggestion about unfolding might have worked for a different<br>\nreason, the unfolding isn't required.</p>",
        "id": 273106174,
        "sender_full_name": "Email Gateway",
        "timestamp": 1645717431
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nYes, \"fun\" and \"primrec\" both add the \"simps\" rules to the simpset <br>\nautomatically. These (roughly) correspond to the equations that you <br>\nright down in your invocation of the \"fun\"/\"primrec\" command.</p>\n<p>Technically, these are <em>not</em> the definition of the constant in HOL. A <br>\ndefinition is always a single equation of the form \"myconst = …\". For <br>\n\"primrec\", the definition is in terms of the underlying datatype's <br>\nprimitive recursion combinator and is somewhat readable. For \"fun\", the <br>\ndefinition is fairly technical and inaccessible with \"normal\" means for <br>\ngood reason.</p>\n<p>The problem here is, as was already said in similar words, that your <br>\n\"simp\" rules proceed by recursion on natural numbers with the <br>\nconstructors \"Suc\" and \"0\". But if the argument is not in that form, <br>\nthose rules cannot apply so the simplifier does nothing.</p>\n<p>There are a number of solutions here:</p>\n<ol>\n<li>\n<p>bring the argument into the \"successor notation\" form, e.g. by adding <br>\nsomething like eval_nat_numeral to the simpset.</p>\n</li>\n<li>\n<p>prove alternative simplification rules that apply to your situation <br>\nas well, e.g.</p>\n</li>\n</ol>\n<blockquote>\n<p>y &gt; 0 ⟹ add x y = Suc (add x (y - 1))</p>\n</blockquote>\n<p>or, specifically tailored to numerals,</p>\n<blockquote>\n<p>lemma \"add x (numeral y) = Suc (add x (pred_numeral y))\"<br>\n  by (simp add: numeral_eq_Suc)</p>\n</blockquote>\n<p>(see addendum below for explanation of this)</p>\n<ol start=\"3\">\n<li>use something like the \"code_simp\" tactic to evaluate your term. (not <br>\n100% sure whether this uses any unverified code internally, but I don't <br>\nthink it does – unlike the similar and much more performant \"eval\" tactic)</li>\n</ol>\n<blockquote>\n<p>lemma \"add 5 2 = 7\"<br>\n  apply code_simp</p>\n</blockquote>\n<p>Manuel</p>\n<ul>\n<li>addendum:</li>\n</ul>\n<p>To understand this, you have to know how numerals work in Isabelle. I'm <br>\nnot sure if this is actually documented anywhere. You can look at the <br>\nHOL.Num theory – the basic idea is fairly simple: we have a datatype <br>\n\"num\" representing positive binary numbers (with constructors One, Bit0, <br>\nBit1), and the \"numeral\" function converts between \"num\" and e.g. <br>\nnatural numbers. Some parsing/printing magic then makes things so that <br>\nyou can write \"5\" in HOL and what's actually there is \"numeral (Bit1 <br>\n(Bit0 One))\"</p>\n<p>The only remaining ingredient here is that there is a function <br>\n\"pred_numeral :: num ⇒ 'a\" that works like \"numeral\" except that it <br>\ngives you the predecessor. So \"numeral n = 1 + pred_numeral n\" holds <br>\nunconditionally. Of course, just writing \"numeral n - 1\" would also work <br>\nI think.</p>\n<p>On 24/02/2022 16:43, Alex Weisberger wrote:</p>\n<blockquote>\n<p>I thought so as well. For what it's worth, the proof with the addition <br>\nof eval_nat_numeral works for the primrec definition as well:</p>\n<p>lemma \"add 5 2 = 7\"<br>\n  by (simp add: eval_nat_numeral)</p>\n<p>So my initial suggestion about unfolding might have worked for a <br>\ndifferent reason, the unfolding isn't required.</p>\n<p>On Thu, Feb 24, 2022 at 2:42 AM Li Yongjian &lt;<a href=\"mailto:lyj238@gmail.com\">lyj238@gmail.com</a>&gt; wrote:</p>\n<p>By my learning experience in Isabelle, primrec def should be<br>\n    unfolded automatically?</p>\n<p>Is it ture?</p>\n<p>On Thu, Feb 24, 2022 at 11:09 AM Alex Weisberger<br>\n    &lt;<a href=\"mailto:alex.m.weisberger@gmail.com\">alex.m.weisberger@gmail.com</a>&gt; wrote:</p>\n<p>Hello,</p>\n<p>It looks to me like primrec doesn't add the function<br>\n        definition to the set of simplification rules (many people<br>\n        refer to this as the \"simp set\"). Therefore the definition<br>\n        can't be used to find a proof by simplification.</p>\n<p>You can add it explicitly in a couple of different ways<br>\n        depending on your preference:</p>\n<p>lemma \"add 5 2 = 7\"<br>\n          by (simp add: add_def)</p>\n<p>or</p>\n<p>lemma \"add 5 2 = 7\" unfolding add_def by simp</p>\n<p>An alternative is to use \"fun\" to define the function instead<br>\n        of \"primrec\" since that will automatically add some<br>\n        simplification rules for this function definition:</p>\n<p>fun add::\"nat ⇒nat ⇒nat\" where<br>\n        \"add x 0= x\" |<br>\n        \"add x (Suc y) = Suc (add x y)\"</p>\n<p>Surprisingly, that doesn't allow a proof by \"auto\" or \"simp\"<br>\n        directly. A little sledgehammering and searching for relevant<br>\n        lemmas led to this:</p>\n<p>lemma \"add 5 2 = 7\"<br>\n          by (simp add: eval_nat_numeral)</p>\n<p>I'm still not sure why auto or simpl wouldn't work directly in<br>\n        this case if anyone can shed some light on that.</p>\n<p>On Wed, Feb 23, 2022 at 8:32 PM Li Yongjian &lt;<a href=\"mailto:lyj238@gmail.com\">lyj238@gmail.com</a>&gt;<br>\n        wrote:</p>\n<p>Dear experts:<br>\n            I define a simple function add,</p>\n<p>primrec add::\"nat ⇒nat ⇒nat\" where<br>\n            \"add x 0= x\" |<br>\n            \"add x (Suc y) =Suc (add x y)\"</p>\n<p>But I can't prove the following lemmas.</p>\n<p>lemma \"add 5 2= 7\"</p>\n<p>lemma \"add 7 2000= 2007\"</p>\n<p>So I want to ask what is the definition of a natural<br>\n            number 3,  2000?</p>\n<p>regards<br>\n            lyj<br>\n</p>\n</blockquote>",
        "id": 273109254,
        "sender_full_name": "Email Gateway",
        "timestamp": 1645718644
    }
]