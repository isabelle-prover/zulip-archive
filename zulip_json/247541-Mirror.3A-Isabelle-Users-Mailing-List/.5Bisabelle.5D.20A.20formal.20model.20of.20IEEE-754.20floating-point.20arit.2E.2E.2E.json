[
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nDear floating-point enthusiasts,</p>\n<p>As you may know, a formalization of IEEE-754 floating-point arithmetic<br>\nin Isabelle/HOL is readily available from the AFP [1].</p>\n<p>The type \"('e, 'f) float\" of floating-point values that is defined in<br>\nthis AFP entry is based on the bit-vector representation of floating-<br>\npoint values. Specifically, the type contains several bit-vector<br>\nrepresentations of the NaN (\"Not-a-Number\") value.</p>\n<p>In contrast, SMT-LIB defines a floating-point theory [2] whose type of<br>\nfloating-point values contains exactly one NaN value. (According to<br>\nSMT-LIB, this is \"in agreement with Level 2 of IEEE 754-2008.\")</p>\n<p>This means that the two types are not isomorphic: we cannot (soundly)<br>\nmap Isabelle's floating-point type to SMT-LIB's if we want to benefit<br>\nfrom the decision procedures for floating-point values that are<br>\navailable in SMT solvers.</p>\n<p>To address this, it seems clear to me that one should define a<br>\nfloating-point type in Isabelle that corresponds to the SMT-LIB type,<br>\ni.e. that formalizes floating-point values at specification level 2 of<br>\nthe IEEE standard.</p>\n<p>My question then is: what to do with the current type of floating-point<br>\nvalues? Should it be retained, or replaced with the new type?</p>\n<p>The bit-vector notation for floating-point values is undoubtedly<br>\nuseful, but there is a many-to-one relationship between bit vectors and<br>\nfloating-point data at specification level 2, so a (non-injective)<br>\nembedding function onto the new type would suffice to retain this<br>\nnotation. Is there much point in reasoning about floating-point<br>\noperations at the representation level when a formalization of<br>\nfloating-point data at specification level 2 is available?</p>\n<p>Best,<br>\nTjark</p>\n<p>[1] <a href=\"https://www.isa-afp.org/entries/IEEE_Floating_Point.html\">https://www.isa-afp.org/entries/IEEE_Floating_Point.html</a><br>\n[2] <a href=\"https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml\">https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml</a></p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 285255291,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654610667
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi Tjark,</p>\n<p>when I worked with the AFP entry, I try to identify all NaNs anyway, as <br>\ndoing so makes proofs easier.</p>\n<p>even for my formalization of LLVM floating point semantics, I currently <br>\ndo not support distinguishing NaNs, as their semantics seems to be <br>\nimplementation defined.</p>",
        "id": 285261811,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654613250
    },
    {
        "content": "<p>From: Lennart Beringer &lt;<a href=\"mailto:eberinge@cs.princeton.edu\">eberinge@cs.princeton.edu</a>&gt;<br>\nHi Tjark,</p>\n<p>I notice that the dependency graph of modules at <a href=\"https://flocq.gitlabpages.inria.fr/\">https://flocq.gitlabpages.inria.fr/</a><br>\nhas nodes IEEE754.Binary and BinarySingleNaN, the former importing the latter.<br>\nI'm not a \"floating point enthusiast\" and haven't used Flocq much myself but<br>\nmaybe the relationship between the types defined in these modules is relevant for<br>\nthis discussion, and treatments of this aspect could be harmonized between <br>\ndifferent provers?</p>\n<p>Best,</p>\n<p>Lennart.</p>\n<p>----- Forwarded Message -----<br>\nFrom: \"Tjark Weber\" &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nTo: \"isabelle-users\" &lt;<a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a>&gt;<br>\nCc: <a href=\"mailto:ly271@cam.ac.uk\">ly271@cam.ac.uk</a>, <a href=\"mailto:hellauer@in.tum.de\">hellauer@in.tum.de</a>, <a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a><br>\nSent: Tuesday, 7 June, 2022 10:03:34<br>\nSubject: [isabelle] A formal model of IEEE-754 floating-point arithmetic: Specification level</p>\n<p>Dear floating-point enthusiasts,</p>\n<p>As you may know, a formalization of IEEE-754 floating-point arithmetic<br>\nin Isabelle/HOL is readily available from the AFP [1].</p>\n<p>The type \"('e, 'f) float\" of floating-point values that is defined in<br>\nthis AFP entry is based on the bit-vector representation of floating-<br>\npoint values. Specifically, the type contains several bit-vector<br>\nrepresentations of the NaN (\"Not-a-Number\") value.</p>\n<p>In contrast, SMT-LIB defines a floating-point theory [2] whose type of<br>\nfloating-point values contains exactly one NaN value. (According to<br>\nSMT-LIB, this is \"in agreement with Level 2 of IEEE 754-2008.\")</p>\n<p>This means that the two types are not isomorphic: we cannot (soundly)<br>\nmap Isabelle's floating-point type to SMT-LIB's if we want to benefit<br>\nfrom the decision procedures for floating-point values that are<br>\navailable in SMT solvers.</p>\n<p>To address this, it seems clear to me that one should define a<br>\nfloating-point type in Isabelle that corresponds to the SMT-LIB type,<br>\ni.e. that formalizes floating-point values at specification level 2 of<br>\nthe IEEE standard.</p>\n<p>My question then is: what to do with the current type of floating-point<br>\nvalues? Should it be retained, or replaced with the new type?</p>\n<p>The bit-vector notation for floating-point values is undoubtedly<br>\nuseful, but there is a many-to-one relationship between bit vectors and<br>\nfloating-point data at specification level 2, so a (non-injective)<br>\nembedding function onto the new type would suffice to retain this<br>\nnotation. Is there much point in reasoning about floating-point<br>\noperations at the representation level when a formalization of<br>\nfloating-point data at specification level 2 is available?</p>\n<p>Best,<br>\nTjark</p>\n<p>[1] <a href=\"https://www.isa-afp.org/entries/IEEE_Floating_Point.html\">https://www.isa-afp.org/entries/IEEE_Floating_Point.html</a><br>\n[2] <a href=\"https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml\">https://smtlib.cs.uiowa.edu/theories-FloatingPoint.shtml</a></p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 285266082,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654614823
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:kleing@unsw.edu.au\">kleing@unsw.edu.au</a>&gt;<br>\nHi Tjark,</p>\n<p>I would have thought that it's the only useful representation for implementation verification, because that is what implementations have to use. E.g. a C or assembly program operates on bit vector representations and will have to deal with the fact that multiple of these map to the abstract value NaN. </p>\n<p>If you remove that, what semantics do you give to a program that manipulates bit vector representations of floating point values?</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 285326536,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654643892
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:kleing@unsw.edu.au\">kleing@unsw.edu.au</a>&gt;<br>\nThat sounds like an excellent idea to me.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 285326574,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654643947
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIf IEEE has two treatments of NaN, we should not trash the one we have but <br>\nderive the other one as well, as the Coq library seems to (thanks, Lennart).</p>\n<p>Tjark: I would encourage you to extend the AFP entry accordingly (in <br>\nconsultation with one of the authors or contributors, if they still reply...)</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/yh0YYYSIurVpWxFx2gI50dNm/smime.p7s\">smime.p7s</a></p>",
        "id": 285349286,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654668821
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nNote that the NaN is slightly over specified in the current entry. They use<br>\nsome_nan as the only value for NaN produced by operations, which allows you to<br>\nprove that all NaN results from operations are equal.</p>\n<p>Peter</p>",
        "id": 285357900,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654675770
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nGerwin,</p>\n<p>I would think that the abstract (\"level 2\") semantics is sufficient to<br>\nverify most code that uses floating points. Code that cares about the<br>\nspecific bit-vector representation of floating-point values should be<br>\nrelatively rare in comparison, but I acknowledge that it exists (for<br>\ninstance, you might want to verify an implementation of IEEE-754).</p>\n<p>Best,<br>\nTjark</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 285370839,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654683455
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nDear all,</p>\n<p>Thank you for your input! I will try to summarize what I think are some<br>\nkey points from this discussion:</p>\n<ol>\n<li>\n<p>Both the abstract (\"level 2\") specification of floating-point data<br>\nand the bit-vector representation are potentially useful.</p>\n</li>\n<li>\n<p>Flocq defines two kinds of (binary) floating-point types: one with a<br>\nsingle NaN value, and one with multiple NaN values. The latter is based<br>\non the former.</p>\n</li>\n<li>\n<p>The AFP entry currently only defines a floating-point type with<br>\nmultiple NaN values.</p>\n</li>\n<li>\n<p>However, only one of these NaN values (\"some_nan\") is returned as<br>\nthe result of floating-point operations.¹ Flocq is more flexible in<br>\nthis regard: its floating-point operations are parameterized on<br>\nfunctions that return a NaN result for NaN arguments.</p>\n</li>\n</ol>\n<p>Perhaps the best way forward then is to add a new floating-point type<br>\nwith a single NaN value to the AFP entry, to define the floating-point<br>\noperations (also) on this type, and to redefine the floating-point<br>\noperations on the existing floating-point type in terms of the new type<br>\n(much like in Flocq).</p>\n<p>I hope to be able to make some progress in this direction in the near<br>\nfuture. If anyone wants to contribute or has further input (especially<br>\nauthors/maintainers of the current AFP entry), please get in touch!</p>\n<p>Best,<br>\nTjark</p>\n<p>¹ This is arguably not conforming to the IEEE standard, which specifies<br>\nthat the result should be one of the input NaNs.</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 285385569,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654692673
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>I hope to be able to make some progress in this direction in the near<br>\nfuture. If anyone wants to contribute or has further input (especially<br>\nauthors/maintainers of the current AFP entry), please get in touch!</p>\n</blockquote>\n<p>I have written an automated test suite, that tests the current floating <br>\npoint semantics against pre-defined operation+result vectors, currently <br>\ndrawn from IBM's FPGen testsuite (the publically available 32bit test <br>\nvectors). Its core is an executable result checker, that currently works <br>\nfor +,-,*,div, fmadd, and sqrt.</p>\n<p>While this is not very polished yet, it already can discover the bug in <br>\nthe formalization of fmadd (fixed in afp-devel).</p>\n<p>I'm not sure how to best integrate this development though, as the AFP <br>\ndoes not support the scripts + C programs etc that I used for the test runs.</p>",
        "id": 285387714,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654693580
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:kleing@unsw.edu.au\">kleing@unsw.edu.au</a>&gt;<br>\nHi Tjark,</p>\n<p>I strongly disagree with the \"rare\" point, not because it is wrong, but because it is not an argument.</p>\n<p>This is a common fallacy in program verification: if the semantics of a language allows specific (unwanted) behaviours, you cannot verify the program in a semantics that assumes these behaviours do not exist, no matter if used rarely or even never. Instead, you must use a semantics that has those behaviours (or at least can detect them) and prove their absence. So if you assume a unique representation of NaN in your formalisation, the formalisation is already disqualified for safety proofs in programs in languages that have direct access to the bit vector representation, because you cannot observe those failures.</p>\n<p>There are multiple ways to deal with this of course -- instead of modelling all representations, you could have a semantics that explicitly fails as soon as there is an unwanted representation, but this would mean something like an option type into whatever is used for float. I doubt that this is what one would want (esp since this is what NaN neatly expresses anyway). You could also try to prove a language invariant that the representation is always valid, but this excludes languages like C and assembly. You could try to have that invariant as a program invariant, but then you still need to be able to distinguish valid from non-valid representations and you'll have a problem that is isomorphic to projecting to an option type (maybe nicer to deal with on the technical level).</p>\n<p>I have not looked closely at the Flocq formalisation, but it sounds to me like the level 2 semantics is basically a quotient on the bitvector representation. It should be possible to transport most properties both ways across that quotient, so that you can have a level 1 semantics for the program, and use the level 2 semantics for verifying properties about it together with suitable transport theorems. The difficulties one encounters transporting properties across are exactly the parts where the level 2 semantics fails to observe failure in real implementations. It would be very nice to crystallise that out in an abstract way that is independent of specific programming languages.</p>\n<p>This has similarities to using integers for program verification vs machine words (much smaller scope here, but still there): there are many properties that are perfectly preserved and useful if you verify a program with integer semantics, but if you only use integers you won't know. What the machine word type does is force you to acknowledge the limitations of the real program and deal with them. You can either reason about the more complex machine word type or you can reason about the integer type and suitably generate side conditions about overflow (assuming you manage to catch all cases). Both are fine. What is not fine is only using integers and saying that the property still holds because overflow is rare.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 285465228,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654730078
    },
    {
        "content": "<p>From: Matthew Fernandez &lt;<a href=\"mailto:matthew.fernandez@gmail.com\">matthew.fernandez@gmail.com</a>&gt;<br>\nI read Tjark’s comments to mean code that needs to distinguish differing NaN representations or to recover from a NaN result is rare. If so, I would say this is accurate, and using a single NaN representation seems sufficient. There’s a lot of floating point code that treats any NaN result as “give up.” In contrast, there’s only a much smaller amount of code that tries to distinguish different NaNs or cast back and forth between integer and floating point representations.</p>\n<p>For the former code, a proof would simply give you nothing in the face of NaNs. I.e. you’d have to prove a NaN value never arose or add the absence of intermediate NaNs to your assumptions. Maybe I misunderstand you though, Gerwin.</p>",
        "id": 285468983,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654733005
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nGerwin,</p>\n<p>On Wed, 2022-06-08 at 23:13 +0000, Gerwin Klein wrote:</p>\n<blockquote>\n<blockquote>\n<p>On 8 Jun 2022, at 20:16, Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt; wrote:<br>\nI would think that the abstract (\"level 2\") semantics is sufficient<br>\nto verify most code that uses floating points. Code that cares<br>\nabout the specific bit-vector representation of floating-point<br>\nvalues should be relatively rare in comparison, but I acknowledge<br>\nthat it exists (for instance, you might want to verify an<br>\nimplementation of IEEE-754).</p>\n</blockquote>\n<p>I strongly disagree with the \"rare\" point, not because it is wrong,<br>\nbut because it is not an argument.</p>\n<p>This is a common fallacy in program verification: if the semantics of<br>\na language allows specific (unwanted) behaviours, you cannot verify<br>\nthe program in a semantics that assumes these behaviours do not<br>\nexist, no matter if used rarely or even never. Instead, you must use<br>\na semantics that has those behaviours (or at least can detect them)<br>\nand prove their absence. So if you assume a unique representation of<br>\nNaN in your formalisation, the formalisation is already disqualified<br>\nfor safety proofs in programs in languages that have direct access to<br>\nthe bit vector representation, because you cannot observe those<br>\nfailures.</p>\n</blockquote>\n<p>I agree, but for programs that (are written in language fragments that)<br>\ndo not directly access the bit-vector representation of floating-point<br>\ndata, verification against the abstract (\"level 2\") semantics is sound.</p>\n<p>Of course, one should not use that semantics to verify <em>arbitrary</em> C<br>\nprograms without further checks. In fact, one couldn't: level 2 does<br>\nnot specify the bit encoding of floating-point data. If we need to<br>\nreason about the bit encoding, it would clearly be unsound to assume<br>\nthat NaN has only one encoding.</p>\n<blockquote>\n<p>This has similarities to using integers for program verification vs<br>\nmachine words (much smaller scope here, but still there): there are<br>\nmany properties that are perfectly preserved and useful if you verify<br>\na program with integer semantics, but if you only use integers you<br>\nwon't know. What the machine word type does is force you to<br>\nacknowledge the limitations of the real program and deal with them.<br>\nYou can either reason about the more complex machine word type or you<br>\ncan reason about the integer type and suitably generate side<br>\nconditions about overflow (assuming you manage to catch all cases).<br>\nBoth are fine. What is not fine is only using integers and saying<br>\nthat the property still holds because overflow is rare.</p>\n</blockquote>\n<p>I think a more apt comparison would be between bounded integers (that<br>\ncorrectly model C arithmetic including overflow) and machine words.<br>\nMachine-word semantics is needed for programs that apply bit operations<br>\nto integer data; but bounded-integer semantics suffices to verify<br>\nprograms that only use arithmetic operations on integers. Neither<br>\nsemantics will ignore overflows.</p>\n<p>Best,<br>\nTjark</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 285471499,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654735133
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:kleing@unsw.edu.au\">kleing@unsw.edu.au</a>&gt;<br>\nHi Tjark,</p>\n<blockquote>\n<p>On 9 Jun 2022, at 10:37, Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt; wrote:</p>\n<p>On Wed, 2022-06-08 at 23:13 +0000, Gerwin Klein wrote:</p>\n<blockquote>\n<p>On 8 Jun 2022, at 20:16, Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt; wrote:</p>\n<blockquote>\n<p>I would think that the abstract (\"level 2\") semantics is sufficient<br>\nto verify most code that uses floating points. Code that cares<br>\nabout the specific bit-vector representation of floating-point<br>\nvalues should be relatively rare in comparison, but I acknowledge<br>\nthat it exists (for instance, you might want to verify an<br>\nimplementation of IEEE-754).</p>\n</blockquote>\n<p>I strongly disagree with the \"rare\" point, not because it is wrong,<br>\nbut because it is not an argument.</p>\n<p>This is a common fallacy in program verification: if the semantics of<br>\na language allows specific (unwanted) behaviours, you cannot verify<br>\nthe program in a semantics that assumes these behaviours do not<br>\nexist, no matter if used rarely or even never. Instead, you must use<br>\na semantics that has those behaviours (or at least can detect them)<br>\nand prove their absence. So if you assume a unique representation of<br>\nNaN in your formalisation, the formalisation is already disqualified<br>\nfor safety proofs in programs in languages that have direct access to<br>\nthe bit vector representation, because you cannot observe those<br>\nfailures.</p>\n</blockquote>\n<p>I agree, but for programs that (are written in language fragments that)<br>\ndo not directly access the bit-vector representation of floating-point<br>\ndata, verification against the abstract (\"level 2\") semantics is sound.</p>\n<p>Of course, one should not use that semantics to verify <em>arbitrary</em> C<br>\nprograms without further checks. In fact, one couldn't: level 2 does<br>\nnot specify the bit encoding of floating-point data. If we need to<br>\nreason about the bit encoding, it would clearly be unsound to assume<br>\nthat NaN has only one encoding.</p>\n</blockquote>\n<p>Cool, I think we are in agreement then. My point was that if I'm verifying arbitrary C programs with type unsoundness etc  (which I do regularly) I don't know if I'm in a fragment for which level 2 is sound or not until I've done the verification. For that, level 1 is useful. Having both levels available would be even more useful, so I'm all for adding level 2, but I'm against removing level 1.</p>\n<blockquote>\n<blockquote>\n<p>This has similarities to using integers for program verification vs<br>\nmachine words (much smaller scope here, but still there): there are<br>\nmany properties that are perfectly preserved and useful if you verify<br>\na program with integer semantics, but if you only use integers you<br>\nwon't know. What the machine word type does is force you to<br>\nacknowledge the limitations of the real program and deal with them.<br>\nYou can either reason about the more complex machine word type or you<br>\ncan reason about the integer type and suitably generate side<br>\nconditions about overflow (assuming you manage to catch all cases).<br>\nBoth are fine. What is not fine is only using integers and saying<br>\nthat the property still holds because overflow is rare.</p>\n</blockquote>\n<p>I think a more apt comparison would be between bounded integers (that<br>\ncorrectly model C arithmetic including overflow) and machine words.<br>\nMachine-word semantics is needed for programs that apply bit operations<br>\nto integer data; but bounded-integer semantics suffices to verify<br>\nprograms that only use arithmetic operations on integers. Neither<br>\nsemantics will ignore overflows.</p>\n</blockquote>\n<p>I shouldn't have started that rabbit hole, but now that we're here I need to point out that bounded integers are exactly equivalent to machine words (in fact that is what the machine word representation can be derived from), so bounded integers don't work as analogy for the float problem. But I think we agree sufficiently that we don't need to search for a better analogy :-)</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 285507812,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654766990
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:kleing@unsw.edu.au\">kleing@unsw.edu.au</a>&gt;</p>\n<blockquote>\n<p>On 9 Jun 2022, at 10:02, Matthew Fernandez &lt;<a href=\"mailto:matthew.fernandez@gmail.com\">matthew.fernandez@gmail.com</a>&gt; wrote:</p>\n</blockquote>\n<blockquote>\n<p>I read Tjark’s comments to mean code that needs to distinguish differing NaN representations or to recover from a NaN result is rare.</p>\n</blockquote>\n<p>Agreed so far.</p>\n<blockquote>\n<p>If so, I would say this is accurate, and using a single NaN representation seems sufficient.</p>\n</blockquote>\n<p>I don't agree with the second part as stated (but possibly with what you meant). It'd certainly be possible to write a semantics that only has a single NaN value, but you'd basically be reconstructing the cases the level 1 semantics deals with when you are either projecting multiple representations into one abstract NaN or trying to exclude those representations before they are abstracted. Either way you have to be able to say that they either don't occur or if you allow them to occur, how they behave. The level 1 semantics makes that straightforward. The level 2 semantics doesn't (it basically assumes this has already happened, e.g. as a language invariant).</p>\n<p>It's not like C programs don't screw with representations all the time. They will absolutely rely on things like zeroing a memory region being equivalent to the value 0 in float etc. If you want to be able to deal with that, you need to be able to deal with representations. You can forbid some etc, but you can't start the semantics with just abstract values.</p>\n<blockquote>\n<p>There’s a lot of floating point code that treats any NaN result as “give up.” In contrast, there’s only a much smaller amount of code that tries to distinguish different NaNs or cast back and forth between integer and floating point representations.</p>\n</blockquote>\n<p>Yes, I do agree that actually using them for computation is rare and I likely wouldn't be interested in verifying such programs. I could maybe see a NaN in/NaN out situation, but I'd mostly be interested in showing that a particular program doesn't produce NaN. I claim that for that purpose, you can't start with the level 2 semantics if the programming language doesn't implement it. You can end up there, but your basic program semantics has to do more and what it has to do is modelled nicely by level 1.</p>\n<p>There is a lot of design space on how you could model all this, and I think I understand your point about proving that no NaN ever happens. I'd still say that a level 1 float representation fits extremely well for that. It can deal with NaN in expressions (so you don't have to generate side conditions for every sub-expression), it can deal with multiple representations of NaN for code that screws up representations in stupid ways, and I can easily state that I want none of these NaN representations to occur, because they are just values in the float type, not something extra.</p>\n<p>(As added bonus, if you have multiple NaN, you don't have to work hard to make sure Isabelle doesn't produce reflexivity for NaN)</p>\n<blockquote>\n<p>For the former code, a proof would simply give you nothing in the face of NaNs. I.e. you’d have to prove a NaN value never arose or add the absence of intermediate NaNs to your assumptions.</p>\n</blockquote>\n<p>Demanding absence of NaN for every intermediate sub-expression is a lot of side conditions that you have to solve before you get to reason about what the program actually does. It'd be possible, but I don't think it'd be nice. </p>\n<blockquote>\n<p>Maybe I misunderstand you though, Gerwin.</p>\n</blockquote>\n<p>I think we're converging.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 285511785,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654769155
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nGerwin,</p>\n<p>This is justified by the fact that the floating-point operations in<br>\nIEEE-754 treat (different representations of) NaN uniformly. Therefore,<br>\nthe level 2 semantics is simply a quotient of the more detailed bit-<br>\nvector semantics.</p>\n<p>Anyway, I think we are mostly in agreement (at least, I have no plans<br>\nto remove the bit-vector semantics from the AFP entry). Just for the<br>\nrecord (and to avoid potential confusion), I'd like to mention that<br>\nwhat you are calling \"level 1\" semantics in this thread (i.e., the bit<br>\nrepresentation of floating-point data) is actually specification level<br>\n4 in IEEE-754.</p>\n<p>Best,<br>\nTjark</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 285518312,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654773533
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:kleing@unsw.edu.au\">kleing@unsw.edu.au</a>&gt;</p>\n<blockquote>\n<p>On 9 Jun 2022, at 21:18, Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt; wrote:</p>\n<p>Gerwin,</p>\n<p>On Thu, 2022-06-09 at 10:04 +0000, Gerwin Klein wrote:</p>\n<blockquote>\n<blockquote>\n<p>If so, I would say this is accurate, and using a single NaN<br>\nrepresentation seems sufficient.</p>\n</blockquote>\n<p>I don't agree with the second part as stated (but possibly with what<br>\nyou meant). It'd certainly be possible to write a semantics that only<br>\nhas a single NaN value, but you'd basically be reconstructing the<br>\ncases the level 1 semantics deals with when you are either projecting<br>\nmultiple representations into one abstract NaN or trying to exclude<br>\nthose representations before they are abstracted. Either way you have<br>\nto be able to say that they either don't occur or if you allow them<br>\nto occur, how they behave. The level 1 semantics makes that<br>\nstraightforward. The level 2 semantics doesn't (it basically assumes<br>\nthis has already happened, e.g. as a language invariant).</p>\n</blockquote>\n<p>This is justified by the fact that the floating-point operations in<br>\nIEEE-754 treat (different representations of) NaN uniformly. Therefore,<br>\nthe level 2 semantics is simply a quotient of the more detailed bit-<br>\nvector semantics.</p>\n</blockquote>\n<p>Yup, exactly.</p>\n<blockquote>\n<p>Anyway, I think we are mostly in agreement (at least, I have no plans<br>\nto remove the bit-vector semantics from the AFP entry). Just for the<br>\nrecord (and to avoid potential confusion), I'd like to mention that<br>\nwhat you are calling \"level 1\" semantics in this thread (i.e., the bit<br>\nrepresentation of floating-point data) is actually specification level<br>\n4 in IEEE-754.</p>\n</blockquote>\n<p>Thanks, yes, good point. I didn't actually look that up and just used 1 as the counter point.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 285608761,
        "sender_full_name": "Email Gateway",
        "timestamp": 1654817972
    }
]