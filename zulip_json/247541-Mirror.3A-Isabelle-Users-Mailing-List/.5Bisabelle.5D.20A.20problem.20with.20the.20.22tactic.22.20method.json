[
    {
        "content": "<p>From: Burkhart Wolff &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>I found a behaviour that is quite mysterious to me, and <br>\nwould like to know if someone can help me out.</p>\n<p>The condensed version of my tactic program looks like this:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>ML‹<br>\nval SPY1 = Unsynchronized.ref(@{thm refl});<br>\nval SPY2 = Unsynchronized.ref(@{thm refl});</p>\n<p>fun prove_ev_trans  st = <br>\n   let val _ = (SPY2:= st) in<br>\n   case  Thm.concl_of st of <br>\n      @{term True} =&gt; all_tac st<br>\n   |  @{term False}=&gt; all_tac st<br>\n   end;<br>\n›</p>\n<p>lemma HH5: \"P XXX (2::int) XX \"<br>\n apply(tactic ‹COND (fn thm =&gt; (SPY1:=thm; true)) all_tac all_tac›)<br>\n apply(tactic ‹prove_ev_trans ›) <br>\n sorry</p>\n<p>ML‹Thm.concl_of(!SPY1);<br>\n     Thm.concl_of(!SPY2);<br>\n›</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</p>\n<p>Do not worry that the body of prove_ev_trans is quite nonsensical and<br>\ndo not worry that apply(tactic ‹prove_ev_trans ›) fails after all.</p>\n<p>What really bothers me is the very different outcome in SPY1 and SPY2: </p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>ML‹Thm.concl_of(!SPY1);<br>\n     Thm.concl_of(!SPY2);<br>\n›</p>\n<p>val it =<br>\n  Const (\"Pure.prop\", \"prop ⇒ prop\") $<br>\n    (Const (\"HOL.Trueprop\", \"bool ⇒ prop\") $<br>\n      (Free (\"P\", \"'a ⇒ int ⇒ 'b ⇒ bool\") $ Free (\"XXX\", \"'a\") $<br>\n        (Const (\"Num.numeral_class.numeral\", \"num ⇒ int\") $<br>\n          (Const (\"Num.num.Bit0\", \"num ⇒ num\") $ Const (\"Num.num.One\", \"num\"))) $<br>\n        Free (\"XX\", \"'b\"))):<br>\n  term<br>\nval it = Const (\"Pure.prop\", \"prop ⇒ prop\") $ (Const (\"Pure.term\", \"prop ⇒ prop\") $ Const (\"Pure.dummy_pattern\", \"prop\")): term</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</p>\n<p>So, already in the call of the second tactic “” call the content of the thm is reduced to </p>\n<p>Const (\"Pure.dummy_pattern\", \"prop”)</p>\n<p>(* it does not depend on the first </p>\n<p>apply(tactic ‹COND (fn thm =&gt; (SPY1:=thm; true)) all_tac all_tac›)</p>\n<p>call, commenting it out results in the same *)</p>\n<p>Can someone explain this and better: find a way around this ?<br>\nI assume that this is connected to internal goal protection.<br>\nBut I need the possibility to peek into the current proof state in <br>\norder to realise a very large case-match efficiently.</p>\n<p>Best regards,</p>\n<p>Burkhart</p>",
        "id": 483358377,
        "sender_full_name": "Email Gateway",
        "timestamp": 1732052498
    },
    {
        "content": "<p>From: Burkhart Wolff &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>I found a behaviour that is quite mysterious to me, and <br>\nwould like to know if someone can help me out.</p>\n<p>The condensed version of my tactic program looks like this:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>ML‹<br>\nval SPY1 = Unsynchronized.ref(@{thm refl});<br>\nval SPY2 = Unsynchronized.ref(@{thm refl});</p>\n<p>fun prove_ev_trans  st = <br>\n    let val _ = (SPY2:= st) in<br>\n    case  Thm.concl_of st of <br>\n       @{term True} =&gt; all_tac st<br>\n    |  @{term False}=&gt; all_tac st<br>\n    end;<br>\n›</p>\n<p>lemma HH5: \"P XXX (2::int) XX \"<br>\n  apply(tactic ‹COND (fn thm =&gt; (SPY1:=thm; true)) all_tac all_tac›)<br>\n  apply(tactic ‹prove_ev_trans ›) <br>\n  sorry</p>\n<p>ML‹Thm.concl_of(!SPY1);<br>\n      Thm.concl_of(!SPY2);<br>\n›</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</p>\n<p>Do not worry that the body of prove_ev_trans is quite nonsensical and<br>\ndo not worry that apply(tactic ‹prove_ev_trans ›) fails after all.</p>\n<p>What really bothers me is the very different outcome in SPY1 and SPY2: </p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>ML‹Thm.concl_of(!SPY1);<br>\n      Thm.concl_of(!SPY2);<br>\n›</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>val it =<br>\n   Const (\"Pure.prop\", \"prop ⇒ prop\") $<br>\n     (Const (\"HOL.Trueprop\", \"bool ⇒ prop\") $<br>\n       (Free (\"P\", \"'a ⇒ int ⇒ 'b ⇒ bool\") $ Free (\"XXX\", \"'a\") $<br>\n         (Const (\"Num.numeral_class.numeral\", \"num ⇒ int\") $<br>\n           (Const (\"Num.num.Bit0\", \"num ⇒ num\") $ Const (\"Num.num.One\", \"num\"))) $<br>\n         Free (\"XX\", \"'b\"))):<br>\n   term<br>\nval it = Const (\"Pure.prop\", \"prop ⇒ prop\") $ (Const (\"Pure.term\", \"prop ⇒ prop\") $ Const (\"Pure.dummy_pattern\", \"prop\")): term</p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</p>\n<p>So, already in the call of the second tactic “” call the content of the thm is reduced to </p>\n<p>Const (\"Pure.dummy_pattern\", \"prop”)</p>\n<p>(* it does not depend on the first </p>\n<p>apply(tactic ‹COND (fn thm =&gt; (SPY1:=thm; true)) all_tac all_tac›)</p>\n<p>call, commenting it out results in the same *)</p>\n<p>Can someone explain this and better: find a way around this ?<br>\nI assume that this is connected to internal goal protection.<br>\nBut I need the possibility to peek into the current proof state in <br>\norder to realise a very large case-match efficiently.</p>\n<p>Best regards,</p>\n<p>Burkhart</p>",
        "id": 484059946,
        "sender_full_name": "Email Gateway",
        "timestamp": 1732363983
    }
]