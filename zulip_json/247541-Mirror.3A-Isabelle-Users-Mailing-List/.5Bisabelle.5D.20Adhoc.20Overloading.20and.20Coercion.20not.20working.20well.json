[
    {
        "content": "<p>From: \"<a href=\"mailto:Isaac@ecs.vuw.ac.nz\">Isaac@ecs.vuw.ac.nz</a>\" &lt;<a href=\"mailto:Isaac@ecs.vuw.ac.nz\">Isaac@ecs.vuw.ac.nz</a>&gt;<br>\nI'm not sure if this is the wrong place to post my question, but basically, adhoc_overloading's are failing to resolve when a coercion also needs to be inserted, here is the simplest example I could construct:</p>\n<p>datatype A = makeA<br>\ndatatype B = makeB A<br>\ndeclare [[coercion_enabled, coercion makeB]]</p>\n<p>abbreviation barB :: ‹B ⇒ bool› where ‹barB b ≡ True›</p>\n<p>consts foo :: ‹'a ⇒ 'b  ⇒ bool›<br>\ndefinition fooA :: ‹bool  ⇒ A ⇒ bool› where ‹fooA b a ≡ True›<br>\ndefinition fooB :: ‹nat ⇒ B ⇒ bool› where ‹fooB n a ≡ True›<br>\nadhoc_overloading foo fooB</p>\n<p>term ‹barB a ∧ fooA True a›<br>\nterm ‹barB (makeB a) ∧ foo True x›<br>\nterm ‹barB a ∧ foo True (a :: A)›<br>\nterm ‹barB a ∧ foo True a› ―‹ERRO: Unresolved adhoc overloading of constant foo :: \"[bool, B] ⇒ bool\" in term \"True ∧ foo True x\"; no instances›</p>\n<p>Basically, I would assume that the \"barB x\" call gives a constraint that \"x\" is coercible to \"B\", and the call to \"foo True x\" should give that \"x\" is coercible to \"A\", as there are no other possible \"foo\" implementations (fooB isn't a possibility because True isn't coercible to nat).<br>\nSadly it's not working it out, unless I basically tell it what the type of 'x' needs to be.</p>\n<p>Any ideas how I can improve this?</p>\n<p>(Alternatively, if I could get it to infer the type of a variable from it's name that might make dealing with overloaded definitions more manageable,<br>\ne.g. coq lets you do \"Implicit Type a : A.\" and then it will infer a variable called a or a' a1 etc as having type \"A\" (unless you give a type)).</p>\n<p>— Isaac Oscar Gariano​</p>",
        "id": 256383624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1633513233
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;<br>\nHi Isaac,</p>\n<p>From the point of view of coercion inference, “foo True x” does not impose any constraint on x because of foo’s rather general declared type. In particular, coercion inference (which lives in Pure) knows nothing about adhoc_overloading (which lives in HOL).</p>\n<p>As a result, you will either have to write type-correct terms (i.e., not use coercions) or at least make sure that you have enough type annotations for adhoc_overloading to do its work.</p>\n<p>As for giving a variable a fixed type, you could fix it in an unnamed context:</p>\n<p>context fixes a :: B begin</p>\n<p>...</p>\n<p>end</p>\n<p>The idea of “default types” for names/name classes was floating around one day, but it turned out to be not so easy to find a flexible and understandable solution.</p>\n<p>Best wishes,<br>\nDmitriy</p>",
        "id": 256403369,
        "sender_full_name": "Email Gateway",
        "timestamp": 1633523965
    }
]