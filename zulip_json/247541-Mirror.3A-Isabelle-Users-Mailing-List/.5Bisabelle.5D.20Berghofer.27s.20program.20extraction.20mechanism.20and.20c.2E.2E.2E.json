[
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>I'm interested to understand if/how Stefan Berghofer's program <br>\nextraction mechanism<br>\nfor Isabelle as developed in his PhD thesis (in the sense of obtaining <br>\nrealizers)<br>\n<a href=\"https://www21.in.tum.de/~berghofe/papers/phd.pdf\">https://www21.in.tum.de/~berghofe/papers/phd.pdf</a></p>\n<p>is related to the current approaches for code generation from <br>\nIsabelle/HOL.</p>\n<p>It would be great if you could share your insights.</p>\n<p>Many thanks in advance!<br>\nAngeliki</p>",
        "id": 227474407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614103040
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI don't know terribly much about Berghofer's work, but I'm fairly<br>\ncertain it has absolutely nothing to do with how the code generator works.</p>\n<p>I think Berghofer's approach is closer to what people do e.g. in Coq:<br>\nusing the Curry–Howard isomorphism to get code from the proof terms.</p>\n<p>My impression from a distance that Berghofer's implementation is a very<br>\nimpressive accomplishment, but one that has not been used for anything<br>\nbut small examples so far.</p>\n<p>One big problem is that (unless I misunderstood something) it only works<br>\nas long as you don't use any non-constructive reasoning (i.e. no axiom<br>\nof choice, no proof by contradiction).</p>\n<p>However, one of the big strengths of Isabelle/HOL is automation, and<br>\nnone of the automation cares about constructive vs non-constructive, nor<br>\ndoes it care about keeping proof terms small (because normally proof<br>\nterms are not stored anyway). Thus, if you use automation, Berghofer's<br>\napproach will either not work at all (because the automation used<br>\nsomething non-constructive somewhere) or run into performance problems<br>\nor give you horribly bloated code (because the automation produced huge<br>\nand overly complicated proof terms).</p>\n<p>And these problems only become bigger if you apply it to bigger examples.</p>\n<p>The code generator, on the other hand, works by having very tight<br>\ncontrol over what code is produced: things like equational and recursive<br>\ndefinitions work out of the box, anything else (quantifiers, choice,<br>\ninductive predicates, abstract types, quotient types) requires some<br>\nextra work (e.g. proving code equations, running \"code_pred\", …).</p>\n<p>Basically, the code generator works by translating equations in HOL into<br>\n\"equations\" in ML/Haskell/Scala/etc. and \"pretending\" that the meaning<br>\nis the same (which is somewhat justified). And anything constant that<br>\nisn't specified by a simple equation has to be brought into that form by<br>\nthe user (by supplying code equations).</p>\n<p>Hope that helps – if I said anything wrong, I'm sure someone will<br>\ncorrect me.</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/ei538O5H-OpVhSltYjSec-jd/smime.p7s\">smime.p7s</a></p>",
        "id": 227476414,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614103763
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nThis is ameliorated by the fact that lemmas often have no<br>\n\"computational content\": their proofs do not affect the extracted<br>\nprogram. Therefore Isabelle's automation may still be useful in<br>\n(possibly large) parts of a formalization intended for program<br>\nextraction.</p>\n<p>Best,<br>\nTjark</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 227531942,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614128402
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nNote that code generation using extraction from proofs works in two steps:</p>\n<p>a) The extraction part: Turning a proof into a set of definitions and<br>\ncorresponding equational theorems in Isabelle/HOL</p>\n<p>b) The code generation part: Turning those theorems into executable<br>\nprograms.</p>\n<p>Hence there is no fundamental difference: both approaches rely on a<br>\nregular code generator, although that has been replaced in the meantime.</p>\n<p>Personally I tend to view proof terms in Isabelle as a device to bolster<br>\nthe logical foundations.  The code generation examples in the<br>\ndistributions are nice demonstrations – but the mechanism so far has no<br>\nimpact on practical applications.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/_FGz7LjZDADvWR19ft3FiJeQ/signature.asc\">signature.asc</a></p>",
        "id": 227789436,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614268548
    }
]