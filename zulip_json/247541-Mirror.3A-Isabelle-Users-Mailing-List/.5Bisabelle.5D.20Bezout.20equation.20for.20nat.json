[
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:holubstep@gmail.com\">holubstep@gmail.com</a>&gt;<br>\nHello,</p>\n<p>for some reason, I need to characterize all solutions of the Bezout-like <br>\nequation<br>\na<em>x + b</em>y = c<br>\nin nat.  That is, no subtraction, no negative numbers.</p>\n<p>Here, is the report on the outcome, in case it is of a general interest, <br>\nor in case it duplicates some existing work.<br>\nIt can be seen as na extension of bezw from GCD.thy, in particular, of<br>\n‹Versions of Bezout for ‹nat›, by Amine Chaieb.›</p>\n<hr>\n<p>We define a division of /c/ by /a/ modulo /b/ constructively as follows</p>\n<p>definition div_mod<br>\n   where \"div_mod c a b =<br>\n   (let b' = b div gcd a b;<br>\n        a' = a div gcd a b;<br>\n        c' = c div gcd a b<br>\n    in<br>\n    nat (int c' * fst (bezw a' b') mod int b')<br>\n   )<br>\n   \"<br>\nIts desired property, if the necessary condition is satisfied, is <br>\ncaptured by the introduction rule:</p>\n<p>lemma div_modI: assumes \"gcd a b dvd c\"<br>\n   shows \"a * div_mod c a b mod b = c mod b\"<br>\nsorry</p>\n<p>and its minimality:</p>\n<p>lemma div_mod_min: assumes \"a * x mod b = c mod b\"<br>\n   shows  \"a * div_mod c a b mod b = c mod b\" and<br>\n                \"div_mod c a b ≤ x\"<br>\nsorry</p>\n<p>For non-zero b, the value satisfies the following bound:</p>\n<p>lemma div_mod_bound: assumes \"b ≠ 0\" shows \"div_mod c a b &lt; b div gcd a b\"<br>\nsorry</p>\n<p>For b  = 0 we get the standard division:</p>\n<p>lemma div_mod_zero: assumes \"b = 0\" shows \"div_mod c a b = c div a\"<br>\nsorry</p>\n<p>and division by zero is zero, as usual,</p>\n<p>lemma div_mod_zero': assumes \"a = 0\" shows \"div_mod c a b = 0\"</p>\n<p>Back to the original motivation, we now have the following <br>\ncharacterization of solvability:</p>\n<p>lemma bezout_nat_solution_test: \"(∃ x y. a<em>x + b</em>y = (c:: nat)) ⟷ (gcd a <br>\nb) dvd c ∧ a * div_mod c a b ≤ c\"<br>\nsorry</p>\n<p>A solution can be easily obtained</p>\n<p>fun solve_bezout_nat :: \"nat ⇒ nat ⇒ nat ⇒ nat * nat\"<br>\n   where  \"solve_bezout_nat a b c =  (div_mod c a b, (c - a*div_mod c a <br>\nb) div b)\"</p>\n<p>with verification:</p>\n<p>lemma solve_bezout_nat_correct: assumes \"(gcd a b) dvd c\" and \"a * <br>\ndiv_mod c a b ≤ c\"<br>\n   shows \"a * fst (solve_bezout_nat a b c) + b * snd (solve_bezout_nat a <br>\nb c) = c\"<br>\n  (is \"a * ?x + b * ?y = c\")<br>\nsorry</p>\n<hr>\n<p>Best regards</p>\n<p>Stepan</p>",
        "id": 311271072,
        "sender_full_name": "Email Gateway",
        "timestamp": 1669033157
    }
]