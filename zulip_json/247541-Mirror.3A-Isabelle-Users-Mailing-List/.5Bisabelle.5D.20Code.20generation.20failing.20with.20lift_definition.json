[
    {
        "content": "<p>From: Dominic Mulligan &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>Consider the following:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span><span class=\"w\"> </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span><span class=\"w\"> </span><span class=\"k\">begin</span><span class=\"w\"></span>\n\n<span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"n n-Type\">'v</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹{ ((f::nat ⇀ 'v), (a::nat)). ∀x&gt;a. x ∉ dom f }›</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule_tac</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"s\">‹(Map.empty, 0)›</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"></span>\n\n<span class=\"k\">setup_lifting</span><span class=\"w\"> </span><span class=\"n\">type_definition_mem</span><span class=\"w\"></span>\n\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹'v mem›</span><span class=\"w\"> </span><span class=\"kp\">is</span><span class=\"w\"> </span><span class=\"s\">‹(Map.empty, 0)›</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"></span>\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"n\">alloc_mem</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹'v mem ⇒ (nat × 'v mem)›</span><span class=\"w\"> </span><span class=\"kp\">is</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s\">‹λm. (snd m, (fst m, 1 + snd m))›</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">clarsimp</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">domIff</span><span class=\"o\">)</span><span class=\"w\"></span>\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"n\">write_mem</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹'v mem ⇒ nat ⇒ 'v ⇒ 'v mem›</span><span class=\"w\"> </span><span class=\"kp\">is</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"s\">‹λm a v. ((fst m)(a ↦ v), 1 + a + snd m)›</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">clarsimp</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">metis</span><span class=\"w\"> </span><span class=\"n\">Suc_lessD</span><span class=\"w\"> </span><span class=\"n\">add.commute</span><span class=\"w\"> </span><span class=\"n\">add_lessD1</span><span class=\"w\"> </span><span class=\"n\">domIff</span><span class=\"w\"></span>\n<span class=\"n\">option.distinct</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">))</span><span class=\"w\"></span>\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"n\">read_mem</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹'v mem ⇒ nat ⇒ 'v option›</span><span class=\"w\"> </span><span class=\"kp\">is</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"s\">‹λm a. (fst m) a›</span><span class=\"w\"> </span><span class=\"ow\">.</span><span class=\"w\"></span>\n\n<span class=\"k\">end</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Now, code generation works for these definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">export_code</span><span class=\"w\"> </span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"n\">read_mem</span><span class=\"w\"> </span><span class=\"n\">write_mem</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">Scala</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But fails with \"No code equations\" for <code>alloc_mem</code>.  There appears to be<br>\nnothing out of the ordinary that would cause this failure at first glance.<br>\nDoes anybody know what is wrong?</p>\n<p>Thanks,<br>\nDominic</p>",
        "id": 311805349,
        "sender_full_name": "Email Gateway",
        "timestamp": 1669203234
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;<br>\nHi Dominic,</p>\n<p>This is a recurrent topic. ;) This behavior occurs because alloc_mem’s return type nests the abstract type (mem) in another type (prod). In such cases, a code generator restriction prevents using the rep_eq theorem generated by lift_definition as a code equation.</p>\n<p>You can pass the code_dt option to lift_definition to ask it to derive a different code equation that works with the code generator.</p>\n<p>lift_definition (code_dt) alloc_mem :: ‹'v mem ⇒ (nat × 'v mem)› is<br>\n    ‹λm. (snd m, (fst m, 1 + snd m))›<br>\n  by (clarsimp simp add: domIff)</p>\n<p>This is documented in Kunčar's PhD thesis (<a href=\"https://www21.in.tum.de/~kuncar/documents/kuncar-phdthesis.pdf\">https://www21.in.tum.de/~kuncar/documents/kuncar-phdthesis.pdf</a>, Section 6.4) and in isar-ref (page 282 for the Isabelle2022 edition).</p>\n<p>Dmitriy</p>",
        "id": 311811148,
        "sender_full_name": "Email Gateway",
        "timestamp": 1669205390
    },
    {
        "content": "<p>From: Dominic Mulligan &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nMany thanks, Dmitriy.  That's fixed my problem!</p>",
        "id": 311816306,
        "sender_full_name": "Email Gateway",
        "timestamp": 1669207161
    }
]