[
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nDear all,</p>\n<p>I define some general term type</p>\n<p>datatype 'a trm = App \"'a trm\" \"'a trm\" | Const string | Var 'a</p>\n<p>Now I want to embed a specific type of terms into this general type, <br>\nnamely a type of order terms. The inequality between two variables x and <br>\ny would be</p>\n<p>App (App (Const ''LE'') (Var x)) (Var y)</p>\n<p>In order to achieve this, I first define a predicate on 'a trm which is <br>\ntrue for terms that are order terms. Then I use typedef to introduce a <br>\nsubtype that only contains order terms. Since I also want to define <br>\nfunctions using pattern matching on this subtype, I am using <br>\nfree_constructors to introduce constructors for the different types of <br>\norder terms; however, generating code for the following lifted definition</p>\n<p>lift_definition trm_of_order_trm :: \"'a order_trm ⇒ 'a trm\" is id .</p>\n<p>now doesn't work since it now uses Rep_order_trm. One can prove the code <br>\nequation manually (see below) but is there a way to derive it automatically?</p>\n<p>Cheers,</p>\n<p>Lukas</p>\n<p>Full example:</p>\n<p>theory Scratch imports Main<br>\nbegin</p>\n<p>datatype 'a trm = App \"'a trm\" \"'a trm\" | Const string | Var 'a</p>\n<p>fun is_order_trm :: \"'a trm ⇒ bool\" where<br>\n\"is_order_trm (App (App (Const c) (Var x)) (Var y)) ⟷ c = ''LE'' ∨ c = ''LT'' ∨ c = ''EQ''\" |<br>\n\"is_order_trm _ ⟷ False\"</p>\n<p>typedef 'a order_trm = \"{t::'a trm. is_order_trm t}\"<br>\n   by (metis is_order_trm.simps(1) mem_Collect_eq)<br>\nsetup_lifting type_definition_order_trm</p>\n<p>abbreviation (input) \"App2ConstVars c x y ≡ (App (App ((Const c)) (Var x)) (Var y))\"<br>\nabbreviation (input) \"CtorOrder c x y ≡ Abs_order_trm (App2ConstVars c x y)\"<br>\ndefinition \"CtorLE ≡ CtorOrder ''LE''\"<br>\ndefinition \"CtorLT ≡ CtorOrder ''LT''\"<br>\ndefinition \"CtorEQ ≡ CtorOrder ''EQ''\"</p>\n<p>lemmas order_ctor_defs = CtorLE_def CtorLT_def CtorEQ_def</p>\n<p>lemma order_trm_cases:<br>\n   fixes t :: \"'a order_trm\"<br>\n   obtains<br>\n     (LE) x y where \"t = CtorLE x y\"<br>\n   | (LT) x y where \"t = CtorLT x y\"<br>\n   | (EQ) x y where \"t = CtorEQ x y\"<br>\nproof(cases t)<br>\n   case (Abs_order_trm t')<br>\n   then have \"is_order_trm t'\"<br>\n     by simp<br>\n   then show ?thesis using that Abs_order_trm<br>\n     apply(induction t' rule: is_order_trm.induct)<br>\n     by (auto simp: order_ctor_defs)<br>\nqed</p>\n<p>lift_definition trm_of_order_trm :: \"'a order_trm ⇒ 'a trm\" is id .</p>\n<p>free_constructors case_order_trm for<br>\n   \"CtorLE\" | \"CtorLT\" | \"CtorEQ\"<br>\n   apply(fact order_trm_cases)<br>\n   by (auto simp: order_ctor_defs Abs_order_trm_inject)</p>\n<p>text ‹I want to define functions on @{typ \"'a order_trm\"} using pattern matching›<br>\nfun sem :: \"'a rel ⇒ 'a order_trm ⇒ bool\" where<br>\n\"sem r (CtorLE x y) ⟷ (x, y) ∈ r\" |<br>\n\"sem r (CtorLT x y) ⟷ (x, y) ∈ r ∧ x ≠ y\" |<br>\n\"sem r (CtorEQ x y) ⟷ x = y\"</p>\n<p>definition \"Sem r A ≡ (∀t ∈ A. sem r t)\"</p>\n<p>lemma \"¬ Sem r {CtorLT x y, CtorEQ x y}\"<br>\n   unfolding Sem_def<br>\n   by simp</p>\n<p>text ‹<br>\n   Exporting code only works if I prove the following code equation manually.<br>\n   Can it be derived automatically?<br>\n›<br>\nlemma [code]:<br>\n   \"Rep_order_trm t = (case t of<br>\n                        CtorLE x y ⇒ App2ConstVars ''LE'' x y<br>\n                      | CtorLT x y ⇒ App2ConstVars ''LT'' x y<br>\n                      | CtorEQ x y ⇒ App2ConstVars ''EQ'' x y)\"<br>\n   by (auto split: order_trm.splits simp: Abs_order_trm_inverse order_ctor_defs)</p>\n<p>export_code sem trm_of_order_trm in SML</p>\n<p>value \"Sem {(1::nat, 2)} {(CtorEQ 1 2), (CtorLT 1 2)}\"</p>",
        "id": 228397098,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614686131
    }
]