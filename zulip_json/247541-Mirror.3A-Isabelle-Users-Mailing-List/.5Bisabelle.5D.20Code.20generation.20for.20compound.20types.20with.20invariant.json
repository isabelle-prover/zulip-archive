[
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi,</p>\n<p>This is a question on code generation for types with invariants.</p>\n<p>If I understand correctly, Section 3.2 in <br>\n<a href=\"https://isabelle.in.tum.de/~haftmann/pdf/data_refinement_in_isabelle_hol_haftmann_krauss_kuncar_nipkow.pdf\">https://isabelle.in.tum.de/~haftmann/pdf/data_refinement_in_isabelle_hol_haftmann_krauss_kuncar_nipkow.pdf</a> <br>\n(2013) explains that code generation does not support code equations for <br>\nlifted definitions targeting compound types where the abstract type does <br>\nnot appear at the top level.</p>\n<p>Here's a simple example where the target type is <code>_ option</code>. One can <br>\nsimilarly construct examples for <code>_ + _</code> or <code>_ * _</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"n\">nat_pos</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹{ n :: nat . n &gt; 0 }›</span>\n<span class=\"w\">   </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">gt_ex</span><span class=\"o\">)</span>\n<span class=\"k\">setup_lifting</span><span class=\"w\"> </span><span class=\"n\">nat_pos.type_definition_nat_pos</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">nat_minus_one</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹nat ⇒ nat option›</span>\n<span class=\"w\">   </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">‹nat_minus_one n ≡ if n - 1 &gt; 0 then Some (n - 1) else None›</span>\n\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"n\">nat_pos_minus_one</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹nat_pos ⇒ nat_pos option›</span>\n<span class=\"w\">   </span><span class=\"kp\">is</span><span class=\"w\"> </span><span class=\"s\">‹nat_minus_one›</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nat_minus_one_def</span><span class=\"o\">)</span>\n\n<span class=\"c\">(* No code equations for nat_pos_minus_one *)</span>\n<span class=\"k\">export_code</span><span class=\"w\"> </span><span class=\"n\">nat_pos_minus_one</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">OCaml</span>\n</code></pre></div>\n<p>I am aware that this limitation can be worked around by realizing <br>\n<code>nat_pos option</code> as a subtype of <code>nat option</code>. However, while it works <br>\nfor this toy example, the need to introduce such helper types seems <br>\nimpractical in general.</p>\n<p>Question 1:</p>\n<p>Is there a sound way to obtain code equations for examples as above, <br>\nwithout using intermediate types?</p>\n<p>Working at the SML-level is fine, so long as it builds atop of existing <br>\ncode generator interfaces and doesn't require fiddling with the shipped <br>\nsources.</p>\n<p>Question 2:</p>\n<p>Why does the code generator not generate code equations here, even <br>\nthough <code>lift_definition</code> has generated the correct proof obligations? <br>\nWhat is the soundness risk?</p>\n<p>I gather that the soundness of the code generator requires meta-proof <br>\nthat <code>Abs_C</code> is only used on terms satisfying the invariant. However, <br>\nthat's exactly what <code>lift_definition</code> asks us to prove. So, it would <br>\nseem to me that the following hack would be sound, despite using the <br>\ngenerally unsound <code>code_printing</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"n\">del</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"s\">‹Abs_nat_pos' ≡ Abs_nat_pos›</span>\n<span class=\"k\">code_printing</span><span class=\"w\"> </span><span class=\"kp\">constant</span><span class=\"w\"> </span><span class=\"n\">Abs_nat_pos'</span><span class=\"w\"> </span><span class=\"n\">⇀</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">OCaml</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"s\">\"Abs'_nat'_pos\"</span>\n\n<span class=\"k\">declare</span><span class=\"w\"> </span><span class=\"n\">nat_pos_minus_one_def</span><span class=\"o\">[</span><span class=\"n\">folded</span><span class=\"w\"> </span><span class=\"n\">Abs_nat_pos'_def</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"o\">]</span>\n<span class=\"k\">export_code</span><span class=\"w\"> </span><span class=\"n\">nat_pos_minus_one</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">OCaml</span>\n\n<span class=\"c\">(*</span>\n<span class=\"c\">let rec nat_pos_minus_one</span>\n<span class=\"c\">   x = Fun.map_fun rep_nat_pos (Option.map_option Abs_nat_pos)</span>\n<span class=\"c\">nat_minus_one x;;</span>\n<span class=\"c\">*)</span>\n</code></pre></div>\n<p>I would be grateful for thoughts on whether this is indeed a sound <br>\nworkaround for the current limitations.</p>\n<p>Thank you,<br>\nHanno</p>",
        "id": 412785392,
        "sender_full_name": "Email Gateway",
        "timestamp": 1705211499
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;<br>\nHi Hanno,</p>\n<p>While not an answer to your questions about the soundness boundaries of the code generator, let me point you to the code_dt feature of lift_definition, which automates the \"intermediate type\" construction.</p>\n<p>See also: <a href=\"https://lists.cam.ac.uk/sympa/arc/cl-isabelle-users/2022-11/msg00047.html\">https://lists.cam.ac.uk/sympa/arc/cl-isabelle-users/2022-11/msg00047.html</a></p>\n<p>Best wishes,<br>\nDmitriy</p>",
        "id": 412788593,
        "sender_full_name": "Email Gateway",
        "timestamp": 1705215005
    },
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi Dmitriy,</p>\n<p>Oof, I really ought to have noticed this - it's also clearly documented <br>\nin the Isabelle Reference Manual. Thanks a lot.</p>\n<p>I am still interested in the 2nd question, but the immediate issue is <br>\nsolved.</p>\n<p>All the best,<br>\nHanno</p>",
        "id": 412789370,
        "sender_full_name": "Email Gateway",
        "timestamp": 1705215787
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Hanno,</p>\n<blockquote>\n<p>Question 1:</p>\n<p>Is there a sound way to obtain code equations for examples as above, <br>\nwithout using intermediate types?</p>\n</blockquote>\n<p>see Dmitriy’s answer.  It is an omission that code_dt is not mentioned <br>\nin the tutorial on code generation, I will take a look at it.</p>\n<blockquote>\n<p>Question 2:</p>\n<p>Why does the code generator not generate code equations here, even <br>\nthough <code>lift_definition</code> has generated the correct proof obligations? <br>\nWhat is the soundness risk?</p>\n<p>I gather that the soundness of the code generator requires meta-proof <br>\nthat <code>Abs_C</code> is only used on terms satisfying the invariant. However, <br>\nthat's exactly what <code>lift_definition</code> asks us to prove.</p>\n</blockquote>\n<p>Logically, there is no issue concerning that.  But technically: the <br>\nsyntactic requirements for abstract code equations need to be checked, <br>\ncf. <br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Isar/code.ML$697\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Isar/code.ML$697</a> <br>\n– extending that check to nested types would result in a considerable <br>\namount of additional extra-logical trusted code for things which can be <br>\ndone inside the logic.</p>\n<p>Hope this helps,<br>\n    Florian</p>",
        "id": 413023181,
        "sender_full_name": "Email Gateway",
        "timestamp": 1705349710
    },
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi Florian,</p>\n<p>Thank you for your reply. It makes sense to prefer a solution which <br>\nbuilds on top of the existing trusted code base, rather than extending <br>\nit.</p>\n<p>All the best,<br>\nHanno</p>",
        "id": 413099786,
        "sender_full_name": "Email Gateway",
        "timestamp": 1705392674
    },
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi Florian, all,</p>\n<p>Quick follow-up: <code>code_dt</code> does not seem to work with compound <br>\ninvariants. Here is a minimal example:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"n\">nat_pos</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹{ n :: nat . n &gt; 0 ∧ n &gt; 0 }›</span>\n<span class=\"w\">   </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">gt_ex</span><span class=\"o\">)</span>\n<span class=\"k\">setup_lifting</span><span class=\"w\"> </span><span class=\"n\">nat_pos.type_definition_nat_pos</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"n\">nat_minus_one</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹nat ⇒ nat option›</span>\n<span class=\"w\">   </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">‹nat_minus_one n ≡ if n - 1 &gt; 0 then Some (n - 1) else None›</span>\n\n<span class=\"kn\">lift_definition</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">code_dt</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">nat_pos_minus_one</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">‹nat_pos ⇒ nat_pos</span>\n<span class=\"s\">option›</span>\n<span class=\"w\">   </span><span class=\"kp\">is</span><span class=\"w\"> </span><span class=\"s\">‹nat_minus_one›</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">nat_minus_one_def</span><span class=\"o\">)</span>\n\n<span class=\"c\">(* Tactic failed</span>\n<span class=\"c\">The error(s) above occurred for the goal statement⌂:</span>\n<span class=\"c\">rel_fun (eq_onp (pred_option (λn. 0 &lt; n ∧ 0 &lt; n))) (eq_onp (λn. 0 &lt; n ∧</span>\n<span class=\"c\">0 &lt; n))</span>\n<span class=\"c\">  (case_option (Rep_nat_pos undefined) (λx2. x2)) (case_option</span>\n<span class=\"c\">(Rep_nat_pos undefined) (λx2. x2)) *)</span>\n</code></pre></div>\n<p>This can be worked around by wrapping the invariant into a definition.</p>\n<p>Best,<br>\nHanno</p>",
        "id": 416499154,
        "sender_full_name": "Email Gateway",
        "timestamp": 1705554730
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nFor the record: In the tutorial on code generation I have added a <br>\nreference to lift_definition (which was missing so far). Hopefully this <br>\nclarifies the situation.</p>\n<p>This refers to rev. 82fbd5919f24 and will be part of the next Isabelle <br>\nrelease.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p><a href=\"/user_uploads/14278/csmBo39Mc6NcoCN7MI24Wcru/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/cYIU6Dy84OLo8vUaLULKDJz0/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 420780833,
        "sender_full_name": "Email Gateway",
        "timestamp": 1707552223
    }
]