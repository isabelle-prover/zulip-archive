[
    {
        "content": "<p>From: David Kretzmer &lt;<a href=\"mailto:david.k@posteo.de\">david.k@posteo.de</a>&gt;<br>\nDear all,</p>\n<p>is it possible to generate code for a potentially non-terminating<br>\nfunction <code>f :: A =&gt; B</code> if I ensure that whenever I actually call <code>f a</code>,<br>\nthen <code>f_dom a</code>?</p>\n<p>I sometimes have functions that are non-terminating in general but that<br>\nare only actually called with \"safe\" arguments. However, since I have to<br>\nprove termination in order for code generation to work (at least as far<br>\nas I know), I have to augment the function with additional checks that<br>\nensure termination. This feels unsatisfactory, since I could<br>\ntheoretically prove that these checks are never exercised during execution.</p>\n<p>A silly example:</p>\n<div class=\"codehilite\"><pre><span></span><code>(* Does not terminate for n &lt; 0 *)\nfunction(domintros) factorial :: &quot;int ⇒ int&quot; where\n  &quot;factorial n = (if n = 0 then 1 else n * (factorial (n-1)))&quot;\n  by pat_completeness auto\n\nlemma factorial_termination: &quot;n ≥ 0 ⟹ factorial_dom n&quot;\n  by (metis add.commute add_diff_cancel_left&#39; factorial.domintros\nint_ge_induct)\n\n(* A safe (i.e., terminating) wrapper around `factorial` *)\nfun factorial_safe :: &quot;int ⇒ int option&quot; where\n  &quot;factorial_safe n = (if n ≥ 0 then Some (factorial n) else None)&quot;\n\n(* Does not work because there are no code equations for `factorial` *)\nexport_code factorial_safe in SML\n</code></pre></div>\n<p>Here, <code>factorial_safe</code> checks the preconditions of <code>factorial</code> and only<br>\nactually makes the call if it is guaranteed to terminate. Unfortunately,<br>\ncode generation for <code>factorial_safe</code> fails because there are no code<br>\nequations for <code>factorial</code>.</p>\n<p>Best regards,<br>\nDavid</p>",
        "id": 217040838,
        "sender_full_name": "Email Gateway",
        "timestamp": 1605636762
    },
    {
        "content": "<p>From: \"Thiemann, René\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear David,</p>\n<p>I know at least two possibilities:</p>\n<p>(* potential solution via typedef: specify separate type for domain of function *)</p>\n<p>typedef fun_input = \"{n :: int. n ≥ 0}\" by auto</p>\n<p>setup_lifting type_definition_fun_input</p>\n<p>lift_definition num :: \"fun_input ⇒ int\" is \"λ x. x\" .</p>\n<p>lift_definition sub1 :: \"fun_input ⇒ fun_input” <br>\n  is \"λ x. if x = 0 then 0 else x - 1\"<br>\n  by auto</p>\n<p>function factorial :: \"fun_input ⇒ int\" where<br>\n  \"factorial n = (if num n = 0 then 1 else num n * factorial (sub1 n))\" <br>\n  by pat_completeness auto</p>\n<p>termination by (relation \"measure (λ n. nat (num n))\", auto; transfer, auto)</p>\n<p>lift_definition create_input :: \"int ⇒ fun_input\" is<br>\n  \"λ n. if n ≥ 0 then n else 0\" by auto</p>\n<p>definition factorial_safe :: \"int ⇒ int option\" where<br>\n  \"factorial_safe n = (if n ≥ 0 then Some (factorial (create_input n)) else None)” </p>\n<p>(* during runtime you don’t execute the invariant “n &gt;= 0” in every iteration,<br>\n   but you repeat the abort-condition in the sub1 function *)</p>\n<p>export_code factorial_safe in Haskell</p>\n<p>(* or use partial_function and put everything into option-type *)</p>\n<p>lemma map_option_mono [partial_function_mono]:<br>\n  shows \"mono_option (λf. map_option X (f y))\"<br>\n  by (smt flat_ord_def fun_ord_def map_option_is_None monotoneI)</p>\n<p>partial_function (option) fact_option :: \"int ⇒ int option\" where<br>\n  [code]: \"fact_option n = (if n = 0 then Some 1 else map_option ((*) n) (fact_option (n - 1)))\" </p>\n<p>export_code fact_option in Haskell</p>\n<p>I hope this helps,<br>\nRené</p>",
        "id": 217045511,
        "sender_full_name": "Email Gateway",
        "timestamp": 1605638867
    },
    {
        "content": "<p>From: David Kretzmer &lt;<a href=\"mailto:david.k@posteo.de\">david.k@posteo.de</a>&gt;<br>\nDear René,</p>\n<p>thank you very much! I especially like the typedef-approach, as it<br>\nallows one to nicely specify the preconditions directly in the type,<br>\nwhich are then available to all users of that type. This is pretty much<br>\nexactly what I was looking for.</p>\n<p>Best regards,<br>\nDavid</p>",
        "id": 217053886,
        "sender_full_name": "Email Gateway",
        "timestamp": 1605643033
    }
]