[
    {
        "content": "<p>From: <a href=\"mailto:isabelle-users@florianmaerkl.de\">isabelle-users@florianmaerkl.de</a><br>\nHello everyone,</p>\n<p>I am currently struggling with the following issue, which I tried to<br>\ncondense into a minimal example:<br>\nI have two locales \"FinalThing\" and \"DetailThing\" where FinalThing<br>\ndefines some useful definition \"final_result\" and DetailThing is made a<br>\nsublocale of FinalThing:</p>\n<p>locale FinalThing =<br>\n  fixes somefunc :: \"nat ⇒ nat\"<br>\n  assumes \"somefunc 42 = 1337\"<br>\nbegin<br>\ndefinition \"final_result = somefunc 42\"<br>\nend</p>\n<p>locale DetailThing =<br>\n  fixes someval :: \"nat\"<br>\n  assumes \"someval = 1336\"</p>\n<p>context DetailThing<br>\nbegin<br>\nfun thefunc :: \"nat ⇒ nat\" where<br>\n  \"thefunc _ = someval + 1\"<br>\nend<br>\nsublocale DetailThing ⊆ DetailSub: FinalThing<br>\n  where somefunc = thefunc</p>\n<p>(...)</p>\n<p>Now I interpret DetailThing and want to execute final_result from this<br>\ninterpretation:</p>\n<p>global_interpretation DetailThing<br>\n  where someval = \"1334 + 2\"<br>\n  defines final_result_impl = DetailSub.final_result<br>\n  and the_func_impl = thefunc<br>\n  by (standard, simp)</p>\n<p>export_code the_func_impl in SML ― ‹works because of the \"defines<br>\nfinal_result_impl = FinalThing.final_result\"›<br>\nexport_code final_result_impl in SML ― ‹doesn't work despite the<br>\n\"defines the_func_impl = thefunc\"›</p>\n<p>Here, I can generate code for thefunc since as it is defined directly in<br>\nDetailThing, but for final_result I get the error \"No code equations for<br>\nfinal_result_impl\".<br>\nI found this old thread describing the same problem as far as I<br>\nunderstood:<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-October/msg00034.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-October/msg00034.html</a><br>\nHowever the proposed solution uses permanent_interpretation which<br>\napparently doesn't exist anymore and I am unsure what the equivalent in<br>\nIsabelle 2020 would be.</p>\n<p>I've attached the full theory.</p>\n<p>Cheers</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/gIq6UOb4tmqLD0fDi7r_Mt05/SublocaleTest.thy\">SublocaleTest.thy</a></p>",
        "id": 206341578,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596881413
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Florian,</p>\n<p>I did not study your example in full but from</p>\n<blockquote>\n<p>global_interpretation DetailThing<br>\n  where someval = \"1334 + 2\"<br>\n  defines the_func_impl = thefunc<br>\n  and final_result_impl = DetailSub.final_result<br>\n  by standard simp</p>\n<p>find_theorems final_result_impl</p>\n</blockquote>\n<p>you see that no suitable code equations is provided for<br>\nfinal_result_impl, and looking at the theorems</p>\n<blockquote>\n<p>thm final_result_impl_def DetailSub.final_result_def</p>\n</blockquote>\n<p>I guess this is due to your definitions not forming a confluent system,<br>\nmaybe due to the construction</p>\n<blockquote>\n<p>fun thefunc :: \"nat ⇒ nat\" where<br>\n  \"thefunc _ = someval + 1\"</p>\n</blockquote>\n<p>which drops an argument.  (A rough first guess).</p>\n<p>In this case you have to provide your code equation explicitly.</p>\n<p>Note that global_interpretation is the offical successor of prototypic<br>\npermanent_interpretation.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/nUe3KWQEiWd7mWJ6ZQdtImS_/signature.asc\">signature.asc</a></p>",
        "id": 207175161,
        "sender_full_name": "Email Gateway",
        "timestamp": 1597686609
    }
]