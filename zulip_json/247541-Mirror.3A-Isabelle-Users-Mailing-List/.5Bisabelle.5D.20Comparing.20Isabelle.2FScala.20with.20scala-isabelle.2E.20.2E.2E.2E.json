[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I cannot fully answer that question because I was not able to find the <br>\ndocumentation of Isabelle/Scala.</p>\n<p>(Only the one in the system manual, which did not make clear to me what <br>\nIsabelle/Scala supports.)</p>\n<p>My impression of Isabelle/Scala is that it focuses a lot on the <br>\nhigh-level operations (theory management, builds, etc.) but does not <br>\nhave support for operating on lower-level data.</p>\n<p>For example, in scala-isabelle, you can directly and transparently work <br>\non terms, cterms, thms, etc. (For example, I can do something like <br>\n\"thm.proposition match { case Const(\"HOL.Trueprop\", t) =&gt; do something <br>\nwith term t }\". (And references on the scala side to Isabelle values can <br>\nget automatically garbage collected etc.)</p>\n<p>(And of course, this is extensible by ML code fragments in the Scala <br>\nprogram.)</p>\n<p>Of course, assuming that Isabelle/Scala allows to transfer data (e.g., <br>\nXML trees) between Scala and Isabelle, and that it allows to execute ML <br>\ncode, it would be possible to do all those things also with <br>\nIsabelle/Scala. But the question is whether that support is part of <br>\nIsabelle/Scala, or is something that can be hypothetically implemented. <br>\nThe basic invocation and communication between Scala and Isabelle is <br>\njust 1k LOC in scala-isabelle, so that's the smallest part of it.</p>\n<p>In fact, I think that it would be easy to base scala-isabelle on a <br>\ndifferent communication protocol, e.g., Isabelle/Scala. However, I opted <br>\nto make a simple lowlevel protocol instead because that way I got a <br>\nfactor 1000 improvement in roundtrip time over what Lars Hupel's <br>\nlibisabelle has. (And afaik, libisabelle was built on top of <br>\nIsabelle/PIDE, not sure how this relates to Isabelle/Scala.)</p>\n<p>That being said, I think it should not be hard to refactor <br>\nscala-isabelle so that one can choose whether to use Scala/Isabelle or <br>\nmy own protocol for the communication.</p>\n<p>All of this, of course, is under the assumption that I my guesses are <br>\nright about what Isabelle/Scala does.</p>\n<p>I would be happy if you can elucidate me as to what the purpose of <br>\nIsabelle/Scala is, and what features it has.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 225735865,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612895721
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 09/02/2021 19:34, Dominique Unruh wrote:</p>\n<blockquote>\n<p>My impression of Isabelle/Scala is that it focuses a lot on the high-level<br>\noperations (theory management, builds, etc.) but does not have support for<br>\noperating on lower-level data.</p>\n</blockquote>\n<p>Exactly. Over 10 years I have given many talks and written many papers about<br>\nIsabelle/Scala in contrast to Isabelle/ML. The main idea:</p>\n<p>* Isabelle/Scala is for systems-programming / system integration</p>\n<p>* Isabelle/ML is for mathematical logic</p>\n<p>Sometimes there is a bit of overlap, and some freedom to decide where things<br>\nhappen. But when you start to do term operations in Isabelle/Scala it is<br>\nprobably wrong.</p>\n<blockquote>\n<p>For example, in scala-isabelle, you can directly and transparently work on<br>\nterms, cterms, thms, etc. (For example, I can do something like<br>\n\"thm.proposition match { case Const(\"HOL.Trueprop\", t) =&gt; do something with<br>\nterm t }\". (And references on the scala side to Isabelle values can get<br>\nautomatically garbage collected etc.)</p>\n</blockquote>\n<p>So why not do this in Isabelle/ML? It works much better. E.g. you have proper<br>\nantiquotations for the const name \"HOL.Trueprop\" above --- without that it is<br>\nnot going to last very long.</p>\n<p>Why give up static scopes and types by pretending that ML operations can<br>\nhappen in Scala?</p>\n<blockquote>\n<p>(And of course, this is extensible by ML code fragments in the Scala program.)</p>\n</blockquote>\n<p>The proper way is to define Isabelle/Isar commands in Isabelle/ML, and let the<br>\nIsabelle/Scala front-end work in a high-level way with it.</p>\n<p>Chapter 4 of the \"system\" manual describes a fairly simple and declarative<br>\nserver protocol to work with Isabelle documents: the socket-version works via<br>\nJSON (e.g. for Python), but it is easier to work with the same in<br>\nIsabelle/Scala (the Headless PIDE session).</p>\n<p>Makarius</p>",
        "id": 225744586,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612899233
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nSome further side-remarks specifically for Isabelle2021 (see NEWS):</p>\n<ul>\n<li>General support for Isabelle/Scala system services, configured via the<br>\nshell function \"isabelle_scala_service\" in etc/settings (e.g. of an<br>\nIsabelle component); see implementations of class<br>\nIsabelle_System.Service in Isabelle/Scala. This supersedes former<br>\n\"isabelle_scala_tools\" and \"isabelle_file_format\": minor<br>\nINCOMPATIBILITY.</li>\n</ul>\n<p>Various examples may be found by using Isabelle/jEdit hypersearch for the text<br>\n\"isabelle_scala_service\" within all \"settings\" files in the $ISABELLE_HOME<br>\ndirectory (and all subdirectories).</p>\n<p>An alternative is to search for class instances of \"Isabelle_System.Service\"<br>\nin *.scala files within $ISABELLE_HOME.</p>\n<p>As an abstract example, a user-defined Isabelle/Scala module could register<br>\nits own command-line tools or Isabelle server commands (for JSON access). The<br>\nScala implementation does the main system integration; if some mathematical<br>\nlogic is required, it will be done in an auxiliary theory context for the tool<br>\n(e.g. embedded ML files to define Isar commands).</p>\n<p>As a concrete example, consider Isabelle/Naproche in Isabelle2021-RC5. Follow<br>\nthe Documentation pointer to $ISABELLE_NAPROCHE/Ex.thy --- it contains some<br>\nhints about the implementation at the bottom. Apart from Isabelle/ML and<br>\nIsabelle/Scala, this involves another program implemented in Haskell. The<br>\nlatter uses Isabelle/Haskell library for basic communication with<br>\nIsabelle/PIDE (even with properly checked antiquotations instead of freely<br>\ninvented string literals).</p>\n<p>Makarius</p>",
        "id": 225751154,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612901987
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;</p>\n<blockquote>\n<p>Exactly. Over 10 years I have given many talks and written many papers about<br>\nIsabelle/Scala in contrast to Isabelle/ML. The main idea:</p>\n<p>* Isabelle/Scala is for systems-programming / system integration</p>\n<p>* Isabelle/ML is for mathematical logic</p>\n<p>Sometimes there is a bit of overlap, and some freedom to decide where things<br>\nhappen. But when you start to do term operations in Isabelle/Scala it is<br>\nprobably wrong.</p>\n</blockquote>\n<p>Good. Then I got things right. So we have a clear separation of purposes <br>\nbetween Isabelle/Scala and scala-isabelle.</p>\n<p>*</p>\n<p>Isabelle/Scala is for systems-programming / system integration</p>\n<p>*</p>\n<p>Isabelle/ML is for mathematical logic</p>\n<p>* scala-isabelle is also for mathematical logic (and for any other<br>\n    more low-level inspection of Isabelle data)</p>\n<p>Anythings that can be done in scala-isabelle can also be done in <br>\nIsabelle/ML, of course. (And vice versa.) However, if due to the <br>\nconstraints of the project, we want to use Scala (or any other JVM <br>\nlanguage), then scala-isabelle would be the right choice.</p>\n<blockquote>\n<blockquote>\n<p>For example, in scala-isabelle, you can directly and transparently work on<br>\nterms, cterms, thms, etc. (For example, I can do something like<br>\n\"thm.proposition match { case Const(\"HOL.Trueprop\", t) =&gt; do something with<br>\nterm t }\". (And references on the scala side to Isabelle values can get<br>\nautomatically garbage collected etc.)<br>\nSo why not do this in Isabelle/ML? It works much better. E.g. you have proper<br>\nantiquotations for the const name \"HOL.Trueprop\" above --- without that it is<br>\nnot going to last very long.</p>\n</blockquote>\n</blockquote>\n<p>There can be several reasons (it depends on the project):</p>\n<p>* We use Isabelle as part of a bigger application (e.g., I developed<br>\n    the qrhl-tool theorem prover in Scala, and it uses Isabelle as a<br>\n    component for reasoning about verification conditions).</p>\n<p>* Scala is easier to debug and edit with modern IDEs. Isabelle/ML has<br>\n    some support (e.g., ctrl-click is useful), but imho it does not come<br>\n    close to the tool support that we have in modern IDEs.</p>\n<p>* I want integration with GUI components. (E.g., I could imagine some<br>\n    tool to interactively explore the structure of terms. This would be<br>\n    possible with Isabelle/Scala, I think, but I would have to serialize<br>\n    all possibly relevant information about the terms, send them over in<br>\n    a bunch, and then deserialize them. Lots of boilerplate.)</p>\n<p>About the antiquotation: This was just an illustrative example. You can <br>\nalso use antiquotations in Scala, so you could write something like <br>\n/term match { case term\"?x ==&gt; Trueprop ?y\" =&gt; print(x); print(y) }/.</p>\n<blockquote>\n<p>Why give up static scopes and types by pretending that ML operations can<br>\nhappen in Scala?</p>\n</blockquote>\n<p>Since Scala has a rich type system on its own, there is no need to give <br>\nup on those things. ML types can be mirrored on the Scala side.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 225979503,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613044518
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 11/02/2021 12:53, Dominique Unruh wrote:</p>\n<blockquote>\n<blockquote>\n<p>Exactly. Over 10 years I have given many talks and written many papers about<br>\nIsabelle/Scala in contrast to Isabelle/ML. The main idea:</p>\n<p>* Isabelle/Scala is for systems-programming / system integration</p>\n<p>* Isabelle/ML is for mathematical logic</p>\n<p>Sometimes there is a bit of overlap, and some freedom to decide where things<br>\nhappen. But when you start to do term operations in Isabelle/Scala it is<br>\nprobably wrong.</p>\n</blockquote>\n<p>Good. Then I got things right. So we have a clear separation of purposes<br>\nbetween Isabelle/Scala and scala-isabelle.</p>\n<p>*</p>\n<p>Isabelle/Scala is for systems-programming / system integration</p>\n<p>*</p>\n<p>Isabelle/ML is for mathematical logic</p>\n<p>* scala-isabelle is also for mathematical logic (and for any other more<br>\n    low-level inspection of Isabelle data)</p>\n<p>Anythings that can be done in scala-isabelle can also be done in Isabelle/ML,<br>\nof course. (And vice versa.) However, if due to the constraints of the<br>\nproject, we want to use Scala (or any other JVM language), then scala-isabelle<br>\nwould be the right choice.</p>\n</blockquote>\n<p>The choice is up to you. Within the regular Isabelle ecosystem, the proper<br>\nlanguage for heavy-duty symbolic logic is Isabelle/ML: it has been made<br>\nprecisely for that over 35 years. We could not crunch the great things in AFP<br>\nwithout Isabelle/ML as it is today.</p>\n<p>To conclude this overview of possibilities, here is a further NEWS entry from<br>\nIsabelle2021:</p>\n<p><strong>* ML </strong>*</p>\n<ul>\n<li>Antiquotations @{scala_function}, @{scala}, @{scala_thread} refer to<br>\nregistered Isabelle/Scala functions (of type String =&gt; String):<br>\ninvocation works via the PIDE protocol.</li>\n</ul>\n<p>This means that Isabelle/ML programs can appeal to operations in Scala, if<br>\nthat happens to be available on that side, e.g. for historical reaans or<br>\nexisting Java implementations. Thus the order of control is straight-forward:<br>\nML hands over to Scala like a regular function call, without any special<br>\nprogramming tricks exposed outside.</p>\n<p>An example application is Nitpick/Kodkod, which works either as a heavy JVM<br>\nprocess or light Scala thread (both invoked from Isabelle/ML):</p>\n<p><a href=\"https://isabelle.sketis.net/repos/isabelle-release/file/Isabelle2021-RC5/src/HOL/Tools/Nitpick/kodkod.ML#l1003\">https://isabelle.sketis.net/repos/isabelle-release/file/Isabelle2021-RC5/src/HOL/Tools/Nitpick/kodkod.ML#l1003</a></p>\n<p><a href=\"https://isabelle.sketis.net/repos/isabelle-release/file/Isabelle2021-RC5/src/HOL/Tools/Nitpick/kodkod.scala\">https://isabelle.sketis.net/repos/isabelle-release/file/Isabelle2021-RC5/src/HOL/Tools/Nitpick/kodkod.scala</a></p>\n<p>Side-remark: Originally I wanted to get rid of the JVM process for<br>\nIsabelle2021, but this has to wait for the next release, due to remaining<br>\nassumptions in the Kodkod implementation concerning the Java context<br>\n(interrupts, threads, exit).</p>\n<blockquote>\n<p>Scala is easier to debug and edit with<br>\nmodern IDEs. Isabelle/ML has some support<br>\n(e.g., ctrl-click is useful), but imho it<br>\ndoes not come close to the tool support<br>\nthat we have in modern IDEs.</p>\n</blockquote>\n<p>The term \"modern\" sounds very old-fashioned to me. Modern times have ended<br>\nsome decades ago; we now have the post-modern era.</p>\n<p>For Isabelle projects, the Isabelle Prover IDE has very good integration of<br>\neverything: Isar, ML, other sub-languages. I know this best and like this<br>\nbest. It is also quite easy to integrate your own sub-languages with PIDE<br>\nsupport (implemented all in Isabelle/ML).</p>\n<p>Isabelle/Scala is an exception: it is not (yet?) integrated into<br>\nIsabelle/PIDE, but the \"isabelle scala_project\" tool allows to generate a<br>\nGradle project for use in IntelliJ IDEA: I do like that IDE, but that alone<br>\nwould never be a reason to disregard our fine Isabelle/ML working environment.</p>\n<p>VSCode is another popular quasi-IDE option: Isabelle/VSCode is a minimal<br>\nexperiment, much more could be done. Generally, I see a lot of IDE concepts<br>\nretrofitted into the VSCode editor project, but it might require 5-10 more<br>\nyears to become a proper IDE.</p>\n<p>Makarius</p>",
        "id": 225988396,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613049766
    }
]