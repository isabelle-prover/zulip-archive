[
    {
        "content": "<p>From: Daniel Kirchner &lt;<a href=\"mailto:daniel@ekpyron.org\">daniel@ekpyron.org</a>&gt;<br>\nDear all,</p>\n<p>First some background information:</p>\n<p>I'm working at embedding a non-classical logic with non-classical<br>\nsyntax into the Isabelle/HOL logic using a shallow semantical embedding.<br>\nI.e. I have a custom proposition type o and a custom grammar starting<br>\nat a nonterminal my_prop to parse propositions of that type written in<br>\nthe target theory's \"native\" syntax (which is quite different from<br>\nIsabelle's usual term/prop syntax, so this involves some non-trivial<br>\nparse translations on the grammar tree starting at my_prop).</p>\n<p>This proposition type is connected to the HOL logic using a semantic<br>\nvalidity function <code>is_valid_in semanticContext proposition</code> (using<br>\nsome complex HOL semantics for the target theory's logic).</p>\n<p>Now I do define syntax for <code>is_valid_in</code> that parses its<br>\n<code>proposition</code> part starting from the nonterminal <code>my_prop</code>. But to<br>\nmake life easier and lower entry barriers for people used to the target<br>\ntheory's syntax, but not to Isabelle's term syntax, I'm also<br>\nintroducing copies of outer theory commands to directly act on<br>\n<code>my_prop</code>-propositions and among other things hide the semantic<br>\ncontext in the proof state. I.e. <code>my_theorem</code> accepts both short and<br>\nlong theorem specifications, but parses propositions starting from<br>\nmy_prop as grammar root. It internally sets up a fixed<br>\n\"semanticContext\" and can thereby transparently translate these<br>\n\"my_prop\"-propositions to regular \"prop\"-propositions. Furthermore,<br>\nthat semanticContext is stored in the Proof_Context and I define<br>\nfurther outer syntax commands like <code>my_assume</code>, <code>my_have</code>,<br>\n<code>my_show</code> (and some custom ones specific to reasoning mechanisms in<br>\nthe target logic) that again directly parse my_prop syntax and can<br>\ntransparently pick up (or sometimes manipulate) the semanticContext in<br>\nthe proof context, etc.</p>\n<p>Independently, I set up different \"printing modes\" (i.e. configurable<br>\nsets of print translations), s.t. it's possible to either view the proof<br>\nstate relative to the custom commands and \"my_prop\" or to view the<br>\ntranslation to Isabelle's native logic and to easily switch between<br>\nthose viewing mode, s.t. people familiar with either syntax can easily<br>\nget used to the other and in order to be transparent about the<br>\ntransformations automatically done by the custom commands.</p>\n<p>Now all of this is working quite nicely and most of the complexity of<br>\nthis nicely lives in the grammar and parse and print translations for<br>\nmy_prop.</p>\n<p>However, currently, I also have to parse full long statement and theorem<br>\nouter syntax in the custom commands, replacing reading propositions by<br>\ncustom logic that reads <code>my_prop</code> terms (by constructing a temporary<br>\nproof context with <code>Syntax.root</code> replaced by <code>my_prop</code> and parsing<br>\nthem as terms instead of propositions), which involves quite some<br>\nadditional complexity that I am not particularly happy with (I'm<br>\nbasically roughly reimplementing parts of Expression.read_statement to<br>\nread the theorem specification to then pass it on to<br>\nSpecification.theorem with some additional postprocessing, but the<br>\nprocess is quite complex and I would like to avoid this as much as<br>\npossible to keep things maintainable in the long run).</p>\n<p>So now to the actual question:</p>\n<p>In the situation described above I think I could avoid almost all<br>\ncomplexity in the custom outer syntax commands, if I could replace the<br>\ngrammar root symbol used to parse propositions in a Proof_Context.<br>\nWhile there is <code>Syntax.root</code> that can be used to replace the grammar<br>\nroot symbol for parsing terms, there currently seems to be no way to do<br>\nthe same for \"prop\" when parsing propositions (looking at the<br>\nimplementation of parse_term in the syntax phases, \"prop\" is<br>\nhard-coded, whereas the term root is read from the Syntax.root config<br>\noption in the respective proof context; I see no obvious reason why<br>\nthe proposition root could not symmetrically be a config option as<br>\nwell).</p>\n<p>So to cut a long story short: is there any particular reason why the<br>\nproposition root grammar symbol \"prop\" cannot or should not be a config<br>\noption in the proof context, similarly to the term root symbol? Or is<br>\nthere an entirely different, simpler approach to achieving the same<br>\nthing without having the proposition root symbol configurable, but also<br>\nwithout having to replicate major parts of the logic used to parse long<br>\nstatement/theorem outer syntax for the custom commands I want to define?<br>\nAlso how \"abusive\" of Isabelle's internals does my current approach<br>\n(e.g. temporarily changing Syntax.root for parsing the<br>\ncustom propositions as terms) sound in general ;-)? (It does seem to<br>\nwork quite perfectly, but I may be missing good reasons for not doing<br>\nthings like this in general).</p>\n<p>I do realize that I could probably avoid a good part of the complexity,<br>\nif I just wrapped all propositions in some special bracket syntax<br>\neverywhere and only had parse translations do the work e.g. of<br>\nextracting a stored semantic context, but ideally I would generally<br>\nlike to avoid that and keep syntactic overhead for statements in the<br>\ntarget logic's syntax at an absolute minimum (although I'm not sure how<br>\nsane of a desire that is ;-)) and I still need custom outer syntax<br>\ncommands anyways to properly \"initialize\"/create and manipulate the<br>\nimplicit semantic context in some cases, plus I e.g. also intend to<br>\nautomatically post-process theorems and potentially extract \"rulified\"<br>\nversions of them to be used for improved automated reasoning, etc.</p>\n<p>Thank you very much for your time and your replies!</p>\n<p>Best wishes,<br>\nDaniel Kirchner</p>",
        "id": 224366340,
        "sender_full_name": "Email Gateway",
        "timestamp": 1611856554
    }
]