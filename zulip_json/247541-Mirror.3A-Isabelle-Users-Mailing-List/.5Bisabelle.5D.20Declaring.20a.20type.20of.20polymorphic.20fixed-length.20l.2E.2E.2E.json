[
    {
        "content": "<p>From: Dominic Mulligan &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>Is there any way to declare polymorphic lists with a known-length, i.e.,<br>\nsomething of the following form:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'b</span><span class=\"o\">::</span><span class=\"s\">‹{len}›</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹{ xs::'a list. length xs =</span>\n<span class=\"s\">LENGTH('b) }›</span>\n<span class=\"w\">  </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ex_list_of_length</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>as a BNF?  Or alternatively, a way to massage the type declaration above<br>\ninto something that can be declared as a BNF?</p>\n<p>From experimenting, it seems that the <code>lift_bnf</code> command with the type<br>\nabove appears to succeed (i.e., all subgoals generated by the command are<br>\nclosed by <code>auto</code>) but then the proof cannot be completed as a load of<br>\ninternal tactic errors are produced [1].  On the other hand, manually<br>\ntrying to declare the type above as a BNF using the <code>bnf</code> command fails as<br>\nit appears to expect a relator function with a non-sensical type: after<br>\nsome debugging, something of the form ('c ⇒ 'd) ⇒ ('c ⇒ 'd).</p>\n<p>(As a minor UI suggestion, the default error message produced by <code>bnf</code> for<br>\na bad relator, \"Bad relator\", could be improved by printing out the type<br>\nthat it expects.)</p>\n<p>Thanks,<br>\nDominic</p>\n<p>[1]: Errors produced:</p>\n<p>Tactic failed<br>\nThe error(s) above occurred for the goal statement⌂:<br>\nmap_array id = id<br>\nTactic failed<br>\nThe error(s) above occurred for the goal statement⌂:<br>\n⋀f g. map_array (g ∘ f) = map_array g ∘ map_array f<br>\nTactic failed<br>\nThe error(s) above occurred for the goal statement⌂:<br>\n⋀f. set_array ∘ map_array f = (`) f ∘ set_array<br>\nTactic failed<br>\nThe error(s) above occurred for the goal statement⌂:<br>\n⋀x f g. (⋀z. z ∈ set_array x ⟹ f z = g z) ⟹ map_array f x = map_array g x<br>\nTactic failed<br>\nThe error(s) above occurred for the goal statement⌂:<br>\n⋀R. rel_array R =<br>\n     (BNF_Def.Grp {x. set_array x ⊆ {(x, y). R x y}} (map_array fst))¯¯ OO<br>\nBNF_Def.Grp {x. set_array x ⊆ {(x, y). R x y}} (map_array snd)<br>\nexception TYPE_MATCH raised (line 438 of \"type.ML\")</p>",
        "id": 411193003,
        "sender_full_name": "Email Gateway",
        "timestamp": 1704376618
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;<br>\nHi Dominic,</p>\n<p>The following works for me:</p>\n<p>typedef (overloaded) ('a, 'b::‹{len}›) array = ‹{ xs::'a list. length xs = LENGTH('b) }›<br>\n  by (simp add: Ex_list_of_length)</p>\n<p>lift_bnf (no_warn_wits, no_warn_transfer) ('a, 'b :: len) array<br>\n  by auto</p>\n<p>The options just suppress the warnings. Perhaps you forgot the class annotation on ‘b?</p>\n<p>The bnf command alternative also works, but involves of course a more complex proof where one needs to be careful with type annotation in the right places.</p>\n<p>definition \"map_array ≡ λf. Abs_array ∘ map f ∘ Rep_array\"<br>\ndefinition \"set_array ≡ set ∘ Rep_array\"<br>\ndefinition \"rel_array ≡ λR. BNF_Def.vimage2p Rep_array Rep_array (list_all2 R)\"<br>\ndefinition \"pred_array ≡ λP. list_all P ∘ Rep_array\"</p>\n<p>bnf \"('a, 'b :: len) array\"<br>\n  map: \"map_array :: ('a ⇒ 'a') ⇒ ('a, 'b) array ⇒ ('a', 'b :: len) array\"<br>\n  sets: set_array<br>\n  bd: natLeq<br>\n  rel: \"rel_array :: ('a ⇒ 'a' ⇒ bool) ⇒ ('a, 'b) array ⇒ ('a', 'b :: len) array ⇒ bool\"<br>\n  pred: pred_array<br>\nproof<br>\n  fix R :: \"'a ⇒ 'b ⇒ bool\"<br>\n  show \"(rel_array R ::  ('a, 'd) array ⇒  ('b, 'd) array ⇒ bool) =<br>\n    (λx y. ∃z :: ('a × 'b, 'd :: len) array. set_array z ⊆ {(x, y). R x y} ∧ map_array fst z = x ∧ map_array snd z = y)\"<br>\n    unfolding rel_array_def vimage2p_def fun_eq_iff<br>\n  proof (safe dest!: list.in_rel[THEN iffD1])<br>\n    fix x :: \"('a, 'd :: len) array\" and y :: \"('b, 'd :: len) array\" and z<br>\n    assume \"set z ⊆ {(x, y). R x y}\" and map: \"map fst z = Rep_array x\" \"map snd z = Rep_array y\"<br>\n    from this(1) this(2,3)[symmetric] show \"∃z :: ('a × 'b, 'd :: len) array. set_array z ⊆ {(x, y). R x y} ∧<br>\n           map_array fst z = x ∧ map_array snd z = y\"<br>\n      using Rep_array[of x] Rep_array[of y]<br>\n      by (intro exI[where x = \"Abs_array z\"])<br>\n        (auto simp: Rep_array[simplified] Abs_array_inverse Rep_array_inverse<br>\n          map_array_def set_array_def subset_iff dest: sym)<br>\n  qed (auto simp: map_array_def set_array_def<br>\n    Rep_array[simplified] Abs_array_inverse list.rel_map list.rel_refl_strong subset_iff)<br>\nqed (auto simp: fun_eq_iff map_array_def set_array_def rel_array_def pred_array_def<br>\n    Rep_array[simplified] Abs_array_inject Abs_array_inverse Rep_array_inverse vimage2p_def<br>\n    list.rel_compp list.pred_set finite_iff_ordLess_natLeq[symmetric]<br>\n    natLeq_card_order natLeq_cinfinite regularCard_natLeq)</p>\n<p>Best wishes,<br>\nDmitriy</p>",
        "id": 411243720,
        "sender_full_name": "Email Gateway",
        "timestamp": 1704394646
    },
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi Dominic, Dmitriy,</p>\n<p>Dmitriy's snippet works for me, too, but it fails when inserting <br>\n<code>setup_lifting</code> in between the <code>typedef</code> and <code>lift_bnf</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"kn\">typedef</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"kp\">overloaded</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'b</span><span class=\"o\">::</span><span class=\"s\">‹{len}›</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">array</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">‹{ xs::'a list. length xs</span>\n<span class=\"s\">= LENGTH('b) }›</span>\n<span class=\"w\">   </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Ex_list_of_length</span><span class=\"o\">)</span>\n\n<span class=\"k\">setup_lifting</span><span class=\"w\"> </span><span class=\"n\">array.type_definition_array</span>\n\n<span class=\"n\">lift_bnf</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">no_warn_wits</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">no_warn_transfer</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n n-Type\">'a</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n n-Type\">'b</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">array</span>\n<span class=\"w\">   </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">auto</span>\n</code></pre></div>\n<p>This fails with:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">exception</span><span class=\"w\"> </span><span class=\"n\">UnequalLengths</span><span class=\"w\"> </span><span class=\"n\">raised</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"n\">554</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"s\">\"library.ML\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Any clue if/why <code>lift_bnf</code> has to happen before <code>setup_lifting</code>?</p>\n<p>Hanno</p>",
        "id": 411255939,
        "sender_full_name": "Email Gateway",
        "timestamp": 1704399826
    },
    {
        "content": "<p>From: Dominic Mulligan &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Dmitriy,</p>\n<p>Thanks for that, we've got it working now.  As Hanno mentions, the<br>\n<code>lift_bnf</code> command seems to behave strangely if <code>setup_lifting</code> is called<br>\nfirst which was causing some confusion.</p>\n<p>Thanks,<br>\nDominic</p>",
        "id": 411354345,
        "sender_full_name": "Email Gateway",
        "timestamp": 1704454920
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;<br>\nHi Hanno,</p>\n<p>Thanks for pointing that out. I only managed to finalize and push my patch (see below) now.</p>\n<p>Indeed lift_bnf attempts to do a bit more in the presence of setup_lifting (namely, to derive transfer rules for the lifted set, map, etc.). This derivation did not work in cases where the raw type (‘a list in your example) had fewer type variables than the abstract type ((‘a, ‘b :: len) array).</p>\n<p>I made the derivation a bit more robust in Isabelle’s development repository (isabelle/33b10cd883ae) and your example will work in the next Isabelle release. In the meantime, one could use a singleton type as a workaround: </p>\n<p>typedef (overloaded) ('a, 'b::‹{len}›) array = ‹{ (xs::'a list, _::'b itself). length xs = LENGTH('b) }›<br>\n by (simp add: Ex_list_of_length)</p>\n<p>setup_lifting array.type_definition_array</p>\n<p>lift_bnf (no_warn_wits, no_warn_transfer) ('a, 'b :: len) array<br>\n  by auto</p>\n<p>Best wishes,<br>\nDmitriy</p>",
        "id": 419345252,
        "sender_full_name": "Email Gateway",
        "timestamp": 1706826791
    },
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi Dmitriy,</p>\n<p>This is great, thank you both for the workaround and for preparing a <br>\npatch for '24.</p>\n<p>Best,<br>\nHanno</p>",
        "id": 419390378,
        "sender_full_name": "Email Gateway",
        "timestamp": 1706854434
    }
]