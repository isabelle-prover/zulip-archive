[
    {
        "content": "<p>From: Oleksandr Gavenko &lt;<a href=\"mailto:gavenkoa@gmail.com\">gavenkoa@gmail.com</a>&gt;<br>\nI'm an enthusiast of math logic so what I'm doing with Isabelle is not for<br>\nsomething beneficial IRL, skip the mail if you value your time ))</p>\n<p>In David Hilbert's book<br>\n<a href=\"https://en.wikipedia.org/wiki/Grundlagen_der_Mathematik\">https://en.wikipedia.org/wiki/Grundlagen_der_Mathematik</a> there is a<br>\nmethodology to prove axiom independence via a model.</p>\n<p>A trivial informal example of independence proof: if we assign usual truth<br>\ntable for T / F for implication and define _ &amp; _ = F (for conjunction) we<br>\nget following as tautologies:</p>\n<p>(A &amp; B)⟶A   -- (F⟶_) ≡ T<br>\n(A &amp; B)⟶B</p>\n<p>Also MP rule keeps tautology status.</p>\n<p>But following statement (&amp;-introduction) is not a tautology:</p>\n<p>A⟶B⟶(A &amp; B)   -- (T⟶F) ≡ F, so (T⟶(T⟶F)) ≡ F</p>\n<p>So this axiom is independent from any implication axioms and &amp;-elimination<br>\naxioms.</p>\n<p>I asked the question earlier here:</p>\n<p><a href=\"https://proofassistants.stackexchange.com/questions/4585/defining-a-finite-model-for-proving-propositional-logic-axiom-indepencense-in-is\">https://proofassistants.stackexchange.com/questions/4585/defining-a-finite-model-for-proving-propositional-logic-axiom-indepencense-in-is</a></p>\n<p>I don't understand how to define truth tables and prove statements about<br>\noperations, defined by truth tables.</p>\n<p>My naive HOL code is:</p>\n<p>theory ax_ind<br>\n  imports Main<br>\nbegin</p>\n<p>datatype truth = T | F</p>\n<p>lemma truth_dom: \"a = T ∨ a = F\"<br>\n  by (cases a, clarify+)</p>\n<p>fun impl :: \"truth⇒truth⇒truth\" where<br>\n  \"impl F F = T\" |<br>\n  \"impl F T = T\" |<br>\n  \"impl T F = F\" |<br>\n  \"impl T T = T\"</p>\n<p>notation impl (infixr ‹→› 65)</p>\n<p>value \"(T→F)\"</p>\n<p>fun conja :: \"truth⇒truth⇒truth\" where<br>\n  \"conja F F = F\" |<br>\n  \"conja F T = F\" |<br>\n  \"conja T F = F\" |<br>\n  \"conja T T = F\"</p>\n<p>notation conja (infixr ‹&amp;› 60)</p>\n<p>value \"(T → F) → (F &amp; T)\"</p>\n<p>(* example of tautology proof *)<br>\nlemma \"((P::truth) → P) = T\"<br>\n  by(cases P, auto)</p>\n<p>(* example of inference rule keeping tautology *)<br>\nlemma<br>\n  fixes P::truth and Q::truth<br>\n  assumes \"P = T\" and \"(P→Q) = T\"<br>\n  shows \"Q = T\"<br>\nproof (rule ccontr)<br>\n  assume \"Q ≠ T\"<br>\n  then have \"Q = F\" using truth_dom by (auto)<br>\n  then have \"P→Q = F\" using assms(1) by (auto)<br>\n  then show False using assms(2) by auto<br>\nqed</p>\n<p>(* example of non-tautology *)<br>\nlemma \"∃ P Q. P → Q → (P &amp; Q) = F\"<br>\nproof -<br>\n  have \"(T → T → (T &amp; T)) = F\" by auto<br>\n  then show ?thesis by auto+<br>\nqed</p>\n<p>Above code is a rudimental attempt, things I don't like and hope veterans<br>\ncould reference to examples or suggest improvement:</p>\n<ul>\n<li>\n<p>I made \"fun\" working only by providing all combinations of truth values.<br>\nIn Hilbert's original work he used schematic rules, which shortens truth<br>\ntables and even denote \"ideas\". If I start encoding 3 or 4 values truth<br>\ntables patterns becomes handy:</p>\n</li>\n<li>\n<p>shorter definitions</p>\n</li>\n<li>shorter proof cases</li>\n</ul>\n<p>My attempts to define \"a -&gt; a = T\" resulted in an error \"Nonlinear patterns<br>\nnot allowed in sequential mode\", probably I need to read functions.pdf.</p>\n<p>??? What is the way to define a truth table for operators via helpful<br>\npatterns?</p>\n<ul>\n<li>I've heard about \"embedding logic\" into object logic. I assume it is<br>\nimportant because you could reason about embedded logic  - basically prove<br>\n<em>meta</em>-theorems (like deduction thm or in this letter case about tautology<br>\nof expression).</li>\n</ul>\n<p>I have a wild guess that the above code is already like \"embedded logic\".</p>\n<p>It might lack some syntax sugar, like operator ⊨, how can I define it?<br>\nNaive pseudocode is:</p>\n<p>definition ⊨::\"truth =&gt; bool\"<br>\nwhere \"⊨ expr ⟷ (expr = T) ∨ (expr = α) ∨ (expr = β)</p>\n<p>IDK how to capture variable number of free variables in \"expr\". Because an<br>\nexpression is a tautology when every truth table substitution leads to a<br>\nselected truth value set. Like:</p>\n<p>⊨A→B→A</p>\n<p>actually means:</p>\n<p>∀ A B. A→B→A ∈{T, α, β}</p>\n<p>And independence of an axiom is a statement that exist values for variables<br>\nof \"expr\" that results to non-true truth value:</p>\n<p>∃ A B. A→B→(A&amp;B) ∉{T, α, β}</p>\n<p>??? With my knowledge of Isabelle I cannot express a statement about *all<br>\nvariables, participating in formula* and quantify them as All or Ex.</p>\n<p>Seems latter ⊭ (non-tautology) could be defined as negation of ⊨.</p>\n<ul>\n<li>Is it possible to externalize or generalize a \"model\"? Like to be able to<br>\nattach a model to formulas and state that this formula is tautology in a<br>\ngiven model (or not)?</li>\n</ul>\n<p>It looks like some evaluator (or \"image\" creator) should be defined over<br>\nexpressions. Some values will denote \"true\", and theorems might look like<br>\nin pseudocode:</p>\n<p>fact: true_val(model) ∈{T, α, β}<br>\nfact: img_of (expr in model) ⊆  true_val(model)  (* image of expr over all<br>\npossible substitution of  variables in expr *)</p>\n<p>lemma \"model ⊨(A → A)\"</p>\n<p>??? What way could the model be externalized or abstracted and different<br>\ninstances could be referenced for a given expression?</p>\n<ul>\n<li>??? Could someone provide an example of nitpick (or another<br>\ncounterexample engine) finding values of expression variables leading to<br>\nnon-true value of expression?</li>\n</ul>\n<p>Hilbert used 3-4 valued truth tables in his work. I believe it is<br>\nmanageable for Isablelle.</p>",
        "id": 497147347,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738401343
    },
    {
        "content": "<p>From: Oleksandr Gavenko &lt;<a href=\"mailto:gavenkoa@gmail.com\">gavenkoa@gmail.com</a>&gt;<br>\nI'm an enthusiast of math logic so what I'm doing with Isabelle is not<br>\nfor something beneficial IRL, value your time ))</p>\n<p>In David Hilbert's book<br>\n<a href=\"https://en.wikipedia.org/wiki/Grundlagen_der_Mathematik\">https://en.wikipedia.org/wiki/Grundlagen_der_Mathematik</a> there is a<br>\nmethodology to prove axiom independence via a model.</p>\n<p>A trivial informal example of independence proof: if we assign usual<br>\ntruth table for T / F for implication and define _ &amp; _ = F (for<br>\nconjunction) we get following as tautologies:</p>\n<p>(A &amp; B)⟶A   -- (F⟶_) ≡ T<br>\n(A &amp; B)⟶B</p>\n<p>Also MP rule keeps tautology status.</p>\n<p>But following statement (&amp;-introduction) is not a tautology:</p>\n<p>A⟶B⟶(A &amp; B)   -- (T⟶F) ≡ F, so (T⟶(T⟶F)) ≡ F</p>\n<p>So this axiom is independent from any implication axioms and<br>\n&amp;-elimination axioms.</p>\n<p>I asked the question earlier here:</p>\n<p><a href=\"https://proofassistants.stackexchange.com/questions/4585/defining-a-finite-model-for-proving-propositional-logic-axiom-indepencense-in-is\">https://proofassistants.stackexchange.com/questions/4585/defining-a-finite-model-for-proving-propositional-logic-axiom-indepencense-in-is</a></p>\n<p>I don't understand how to define truth tables and prove statements<br>\nabout operations, defined by truth tables.</p>\n<p>My naive HOL code is:</p>\n<p>theory ax_ind<br>\n  imports Main<br>\nbegin</p>\n<p>datatype truth = T | F</p>\n<p>lemma truth_dom: \"a = T ∨ a = F\"<br>\n  by (cases a, clarify+)</p>\n<p>fun impl :: \"truth⇒truth⇒truth\" where<br>\n  \"impl F F = T\" |<br>\n  \"impl F T = T\" |<br>\n  \"impl T F = F\" |<br>\n  \"impl T T = T\"</p>\n<p>notation impl (infixr ‹→› 65)</p>\n<p>value \"(T→F)\"</p>\n<p>fun conja :: \"truth⇒truth⇒truth\" where<br>\n  \"conja F F = F\" |<br>\n  \"conja F T = F\" |<br>\n  \"conja T F = F\" |<br>\n  \"conja T T = F\"</p>\n<p>notation conja (infixr ‹&amp;› 60)</p>\n<p>value \"(T → F) → (F &amp; T)\"</p>\n<p>(* example of tautology proof *)<br>\nlemma \"((P::truth) → P) = T\"<br>\n  by(cases P, auto)</p>\n<p>(* example of inference rule keeping tautology *)<br>\nlemma<br>\n  fixes P::truth and Q::truth<br>\n  assumes \"P = T\" and \"(P→Q) = T\"<br>\n  shows \"Q = T\"<br>\nproof (rule ccontr)<br>\n  assume \"Q ≠ T\"<br>\n  then have \"Q = F\" using truth_dom by (auto)<br>\n  then have \"P→Q = F\" using assms(1) by (auto)<br>\n  then show False using assms(2) by auto<br>\nqed</p>\n<p>(* example of non-tautology *)<br>\nlemma \"∃ P Q. P → Q → (P &amp; Q) = F\"<br>\nproof -<br>\n  have \"(T → T → (T &amp; T)) = F\" by auto<br>\n  then show ?thesis by auto+<br>\nqed</p>\n<p>Above code is a rudimental attempt, things I don't like and hope<br>\nveterans could reference to examples or suggest improvement:</p>\n<ul>\n<li>\n<p>I made \"fun\" working only by providing all combinations of truth<br>\nvalues. In Hilbert's original work he used schematic rules, which<br>\nshortens truth tables and even denote \"ideas\". If I start encoding 3<br>\nor 4 values truth tables patterns becomes handy:</p>\n</li>\n<li>\n<p>shorter definitions</p>\n</li>\n<li>shorter proof cases</li>\n</ul>\n<p>My attempts to define \"a -&gt; a = T\" resulted in an error \"Nonlinear<br>\npatterns not allowed in sequential mode\", probably I need to read<br>\nfunctions.pdf.</p>\n<p>??? What is the way to define a truth table for operators via helpful patterns?</p>\n<ul>\n<li>I've heard about \"embedding logic\" into object logic. I assume it is<br>\nimportant because you could reason about embedded logic  - basically<br>\nprove <em>meta</em>-theorems (like deduction thm or in this letter case about<br>\ntautology of an expression).</li>\n</ul>\n<p>I have a wild guess that the above code is already like \"embedded logic\".</p>\n<p>It might lack some syntax sugar, like operator ⊨, how can I define it?<br>\nNaive pseudocode is:</p>\n<p>definition ⊨::\"truth =&gt; bool\"<br>\nwhere \"⊨ expr ⟷ (expr = T) ∨ (expr = α) ∨ (expr = β)  (* values, that<br>\nare considered \"true\" *)</p>\n<p>IDK how to capture <strong>variable</strong> number of free variables in \"expr\".<br>\nBecause an expression is a tautology when every truth table<br>\nsubstitution leads to a selected truth value set. Like:</p>\n<p>⊨A→B→A</p>\n<p>actually means:</p>\n<p>∀ A B. A→B→A ∈{T, α, β}</p>\n<p>And independence of an axiom is a statement that exist values for<br>\nvariables of \"expr\" that results to non-true truth value:</p>\n<p>∃ A B. A→B→(A&amp;B) ∉{T, α, β}</p>\n<p>??? With my knowledge of Isabelle I cannot express a statement about<br>\n<em>all variables, participating in formula</em> and quantify them as All or<br>\nEx.</p>\n<p>Seems latter ⊭ (non-tautology) could be defined as negation of ⊨.</p>\n<ul>\n<li>Is it possible to externalize or generalize a \"model\"? Like to be<br>\nable to attach a model to formulas and state that this formula is<br>\ntautology in a given model (or not)?</li>\n</ul>\n<p>It looks like some evaluator (or \"image\" creator) should be defined<br>\nover expressions. Some values will denote \"true\", and theorems might<br>\nlook like in pseudocode:</p>\n<p>fact: true_val(model) = {T, α, β}<br>\nfact: img_of (expr in model) ⊆  true_val(model)  (* image of expr over<br>\nall possible substitution of  variables in expr *)</p>\n<p>lemma \"model ⊨(A → A)\"</p>\n<p>??? What way could the model be externalized or abstracted and<br>\ndifferent instances of model could be referenced for a given<br>\nexpression?</p>\n<ul>\n<li>??? Could someone provide an example of nitpick (or another<br>\ncounterexample engine) finding values of expression variables leading<br>\nto non-true value of expression?</li>\n</ul>\n<p>Hilbert used 3-4 valued truth tables in his work. I believe it is<br>\nmanageable for Isablelle.</p>\n<p>PS I've sent an email to the list <a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a><br>\ninitially, probably that is a legacy one.</p>\n<p>PPS I searched for \"⊨\", \"sound\", \"complete\" in Isablelle's src/ &amp;<br>\nAFP's thys/, the latter has many examples that might be relevant for<br>\nthe goal. Variables are defined as \"nat\" and so on (from Cook_Levin<br>\nfolder of AFP):</p>\n<p>datatype literal = Neg nat | Pos nat<br>\ntype_synonym clause = \"literal list\"<br>\ntype_synonym formula = \"clause list\"<br>\ntype_synonym assignment = \"nat ⇒ bool\"</p>\n<p>abbreviation satisfies_literal :: \"assignment ⇒ literal ⇒ bool\" where<br>\n  \"satisfies_literal α x ≡ case x of Neg n ⇒ ¬ α n | Pos n ⇒ α n\"</p>\n<p>definition satisfies_clause :: \"assignment ⇒ clause ⇒ bool\" where<br>\n  \"satisfies_clause α c ≡ ∃x∈set c. satisfies_literal α x\"</p>\n<p>definition satisfies :: \"assignment ⇒ formula ⇒ bool\" (infix ‹⊨› 60) where<br>\n  \"α ⊨ φ ≡ ∀c∈set φ. satisfies_clause α c\"</p>\n<p>Above is specialized logic, other theories define formulas as<br>\nrecursive data structures. I think I lose human readable axiom<br>\nrepresentation because of \"constructor\" syntax of types. Dealing with<br>\n\"nat\" or formula \"trees\" is not fun ((</p>\n<p>That gives me ideas but I'm inexperienced with Isabelle enough to come<br>\nup with some clever abstraction so I can reason about validity of<br>\nexpression under a given model.</p>",
        "id": 497147410,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738401367
    }
]