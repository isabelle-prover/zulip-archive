[
    {
        "content": "<p>From: Li Yongjian &lt;<a href=\"mailto:lyj238@gmail.com\">lyj238@gmail.com</a>&gt;<br>\nDear experts:</p>\n<p>The following function is transformed from a function defined in a<br>\nlazy-evaluated function language HAWK.</p>\n<p>[image: image.png]<br>\nI. change it into Isabelle Form, but can' t prove its termination. I think<br>\nIsabelle's evaluation is not lazy, so its termination can't be proved?</p>\n<p>function  nextSig::\"bool signal⇒ nat signal\" and<br>\noutputSig ::\"bool signal ⇒ nat signal\" where<br>\nnext1:\"nextSig bS=delay 0 (outputSig bS)\" |<br>\noutput1:\"outputSig bS = sel bS (constantInt 0) (inc (nextSig bS)) \"<br>\n  apply pat_completeness<br>\n  by auto<br>\ntermination</p>\n<p>see the attached file</p>\n<p>regards!<br>\n<a href=\"/user_uploads/14278/7LZfiibuoMp3SfM3FfXuZndu/image.png\">image.png</a><br>\n<a href=\"/user_uploads/14278/fBfLXVkhOmIW3totNtW6oB3N/hawk.thy\">hawk.thy</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/7LZfiibuoMp3SfM3FfXuZndu/image.png\" title=\"image.png\"><img src=\"/user_uploads/14278/7LZfiibuoMp3SfM3FfXuZndu/image.png\"></a></div>",
        "id": 291990860,
        "sender_full_name": "Email Gateway",
        "timestamp": 1659610226
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Yongjian,</p>\n<p>In you case, I believe you need a bound function of type “bool signal =&gt; nat\" such that with each recursion the output of this function decreases.</p>\n<p>For example, in HOL-Computational_Algebra.Polynomial the bound function ‘degree’ is needed to show that the polynomial derivative function terminates:</p>\n<p>function pderiv :: \"('a :: {comm_semiring_1,semiring_no_zero_divisors}) poly ⇒ 'a poly\"<br>\n  where \"pderiv (pCons a p) = (if p = 0 then 0 else p + pCons 0 (pderiv p))\"<br>\n  by (auto intro: pCons_cases)<br>\ntermination pderiv<br>\n  by (relation \"measure degree\") simp_all</p>\n<p>Hope this helps,<br>\nWenda</p>",
        "id": 292088484,
        "sender_full_name": "Email Gateway",
        "timestamp": 1659659446
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nYou're in a fiddly situation here, unfortunately.</p>\n<p>You typically begin such a termination proof with the \"measure\" command. There used to be another way, but apparently the relevant theorems were hidden (?).</p>\n<p>If you apply \"measure X\" after \"termination\" in your problem, you'll see what needs to be true of your measure. Unfortunately, it's impossible, at the moment.</p>\n<p>The first problem is that your signal functions aren't passing arguments to each other that are decreasing in some measure. In this case, you can apply the clumsy fix of eta-expanding all the rules of the function definition:</p>\n<p>function  nextSig::\"bool signal⇒ nat signal\" and<br>\noutputSig ::\"bool signal ⇒ nat signal\" where<br>\nnext1:\"nextSig bS x = delay 0 (outputSig bS) x\" |<br>\noutput1:\"outputSig bS x = sel bS (constantInt 0) (inc (nextSig bS)) x\"<br>\n  apply pat_completeness<br>\n  by auto</p>\n<p>The value \"x\" is now being passed through the recursion in a way that it decreases. But, that's a byproduct of the way that the combinators delay, sel and inc work. To provide this information to the function package, you need to add congruence rules that look like this:</p>\n<p>lemma inc_cong[fundef_cong]:<br>\n  \"(⋀j. n = j ⟹ f j = f' j) ⟹ n = n' ⟹ inc f n = inc f' n'\"<br>\n  by (simp add: inc_def lift_def)</p>\n<p>This shape of congruence is used to allow either the simplifier or the fundef package to know that the parameter passed to \"f\" in \"inc f n\" will be the same n. Add the correct collection of congruences, and the goal you'll see after \"measure\" in termination will start to look provable. In fact, the fun package can pick the measure and prove it all by itself, once it has the right information available.</p>\n<p>I attach a partly completed version of your theory.</p>\n<p>The above approach is pretty clunky. There has been a lot of work on supporting other styles of termination/fixpoint definition. See, perhaps, Alexander Krauss' PhD at <a href=\"https://www21.in.tum.de/~krauss/\">https://www21.in.tum.de/~krauss/</a> ? Is there a more up-to-date reference? Anyway, it might be possible to sidestep the manual eta-expansion above, especially if the signal type ends up needing more features than just its evolution over time.</p>\n<p>Good luck with it,<br>\n    Thomas.</p>\n<p>This recursive function isn't exactly terminating because it's passing an argument that's getting smaller. Rather, it's passing an argument that becomes more precise with each iteration. Unfortunately the function package doesn't do the right thing by default.<br>\n<a href=\"/user_uploads/14278/Bf2ceOgDeOZngBLnrbhFlZvr/image.png\">image.png</a><br>\n<a href=\"/user_uploads/14278/NEOPXQSgtkQYuk1sG6JrVaZA/hawk.thy\">hawk.thy</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/Bf2ceOgDeOZngBLnrbhFlZvr/image.png\" title=\"image.png\"><img src=\"/user_uploads/14278/Bf2ceOgDeOZngBLnrbhFlZvr/image.png\"></a></div>",
        "id": 292124273,
        "sender_full_name": "Email Gateway",
        "timestamp": 1659689132
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThis looks like a job for co-recursion, not terminating recursion, and I hope that an expert on that topic can provide a precise solution.</p>\n<p>Larry Paulson</p>",
        "id": 292127982,
        "sender_full_name": "Email Gateway",
        "timestamp": 1659691324
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Li,</p>\n<p>as Larry pointed out, this is really something for corecursion. Isabelle's support for <br>\nfriendly corecursion (<a href=\"http://dx.doi.org/10.1007/978-3-662-54434-1_5\">http://dx.doi.org/10.1007/978-3-662-54434-1_5</a>) can handle all the <br>\ndefinitions in the theory without trouble. I've attached a commented theory of how this <br>\ncould look like.</p>\n<p>The implementation of the BNF_Corec package has still a few rough edges and limitations, <br>\nbut it worked out of the box for the examples in your theory. Please let us know if you <br>\nrun into any trouble and we'll be happy to figure out some workaround when possible.</p>\n<p>Hope this helps,<br>\nAndreas<br>\n<a href=\"/user_uploads/14278/oKT4VLJoQ85_5jHg7GWfQRYe/hawk.thy\">hawk.thy</a></p>",
        "id": 292310700,
        "sender_full_name": "Email Gateway",
        "timestamp": 1659865951
    }
]