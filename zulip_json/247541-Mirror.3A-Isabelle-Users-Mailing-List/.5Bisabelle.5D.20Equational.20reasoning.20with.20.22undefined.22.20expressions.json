[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHello,</p>\n<p>The calculational reasoning feature of Isabelle/Isar (commands \"also\" <br>\nand \"finally\") is very useful for many complex calculations but I <br>\nrepeatedly found one area where it is hard to use.</p>\n<p>Namely, when working with potentially undefined expressions (e.g., <br>\nlimits, series, integrals, suprema, division by zero, etc.).</p>\n<p>(Side note: I am aware that Isabelle/HOL is total. I do not wish to <br>\nresurrect the discussion whether things such as division by zero should <br>\nhave a fixed default value or not. When I say \"undefined\", I mean it in <br>\nthe sense of \"the limit doesn't exist\" etc. in common mathematical <br>\nparlance, irrespective of how the HOL-constant is precisely defined. <br>\nAlso, my meaning of \"undefined\" has nothing to do with the existing <br>\nHOL-constant \"undefined\".)</p>\n<p>For example, in a mathematical proof involving series, I may have a <br>\ncalculation saying \\ \\sum_{ }^{ }f_i\\le\\sum_{ }^{ }g_i\\le\\sum_{ }^{ <br>\n}h_i=z, with a comment explaining something like \"here the left series <br>\nexist because the right one exists\". Or somewhat more formally, we <br>\nconsider each of the series as an expression that can be a number, or <br>\n\"undefined\", and we interpret x\\le y as meaning \"if /y/ is defined, then <br>\n/x/ is defined and x\\le y\".</p>\n<p>When translating such proofs to Isabelle/HOL, I very often end up having <br>\nto do the calculation twice. I do one part of the proof that has a <br>\nsequence of steps of the form \"summable h_i \\implies summable g_i\". And <br>\nthen once these are established, I do the steps \"\\sum_{ }^{ <br>\n}g_i\\le\\sum_{ }^{ }h_i\" etc. This increases duplication and reduces <br>\nreadability a lot. Especially when I have nested series (where the <br>\nsummands of a series might also be series that are potentially <br>\nundefined), things get hard to read).</p>\n<p>Instead of this, one could recreate what is implicitly done in the <br>\nmathematical proof as follows:</p>\n<p>* One rewrites the expressions \\sum_{ }^{ }g_i (of type real) into<br>\n    expressions of type \"real option\", returning None if the series does<br>\n    not exist (or any of the summands does not exist).<br>\n    (Essentially, treating the computation as something that happens in<br>\n    the maybe-monad.)</p>\n<p>* One defines a relation \\le' on \"real option\" that has the meaning<br>\n    \"smaller-equal, and left is defined if right is\" as described above.</p>\n<p>There are two problems with that. First, one needs to define a lot of <br>\nnew relations (e.g., \"smaller, left if right\", \"smaller-equal, right if <br>\nleft\", \"..., right if and only if left\", etc.) I think this would not be <br>\na big one problem (e.g., one could have second order constants such as <br>\n\"left_if_right\" mapping \\le into \\le' and define some appropriate <br>\nsyntactic sugar for readability).</p>\n<p>The second problem is more substantial: Rewriting an expression of type <br>\n\"real\" (or any other type involved in calculational reasoning) into <br>\n\"real option\" is difficult. (Not conceptually difficult but difficult to <br>\ndo correctly.) \\sum_{ }^{ }g_i would be replaced by \"if summable g_i <br>\nthen Some \\sum_{ }^{ }g_i else None\". (This can be made more readable <br>\nwith a new constant \"series_lifted\", of course.) And even worse, <br>\nsomething like \\sum_i^{ }\\left(g_i+\\sum_j^{ }h_{ij}\\right) becomes a <br>\nvery unreadable term since it is None if any of the inner series diverge <br>\nor if the outer one diverges.</p>\n<p>I would like to resolve these difficulties, and my idea is the following:</p>\n<p>* Write an ML function \"lift: term -&gt; term\" that transforms normal<br>\n    expressions (e.g., of type real) to \"lifted\" expression (of type<br>\n    \"real option\").<br>\n    This function would of course need some configuration, e.g., to know<br>\n    that \"series :: (nat real -&gt; real)\" is something that can return<br>\n    something \"undefined\" and under what conditions this happens.<br>\n    This is the hard part and needs careful thinking about the details,<br>\n    I think.</p>\n<p>* Add some syntactic sugar and parse/print translations so that this<br>\n    function would be applied when parsing terms.<br>\n    (E.g., \"\\sum_{ }^{ }g_i\\ \\left[\\le\\right]_{\\leftarrow}\\ \\sum_{ }^{<br>\n    }h_i\" might be replaced by something like \"series_lifted g_i \\le'<br>\n    series_lifted h'\" on parsing and translated back on printing, where<br>\n    \"series_lifted\" is what the ML-function lift returns.)</p>\n<p>* Add a bunch of additional lemmas to ease working with these things.<br>\n    (E.g., trans-rules for constants such as \\le'. And wrapper-lemmas<br>\n    expressing existing results in terms of \"series_lifted\" etc., e.g.)</p>\n<p>Before I set out on this endeavor, I would like to hear from others <br>\nwhether there are other, better approaches to deal with calculational <br>\nreasoning in these situations. Or whether there are existing <br>\nimplementations of this or a similar idea (in Isabelle, or in other <br>\nprovers).</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 289184625,
        "sender_full_name": "Email Gateway",
        "timestamp": 1657543658
    },
    {
        "content": "<p>From: Claudio Sacerdoti Coen &lt;<a href=\"mailto:claudio.sacerdoticoen@unibo.it\">claudio.sacerdoticoen@unibo.it</a>&gt;<br>\nDear Dominique,</p>\n<p>just an observation: what you propose reminds me of what I suggested<br>\nyears ago for Matita/Coq</p>\n<p>Claudio Sacerdoti Coen and Enrico Zoli. “A Note on Formalising<br>\nUndefined Terms in Real Analysis”. In: PATE’07 (2007), p. 3. url:<br>\n<a href=\"https://www.cs.unibo.it/˜sacerdot/PAPERS/pate07.pdf\">https://www.cs.unibo.it/˜sacerdot/PAPERS/pate07.pdf</a>.</p>\n<p>Indeed one needs multiple relations, but the interesting part is that<br>\none observes in practice in real-world proofs very long zig-zags of the<br>\nform  &lt;&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;&gt;&gt; &lt;&lt;&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;   etc. where &gt; means \"if lhs is defined,<br>\nrhs is\" and &lt; the opposite. This allows to provide explicit proofs of<br>\ndefinedness only at the peaks of the zig-zags, like mathematicians do<br>\ninformally.</p>\n<p>At the time there were not many easy ways to automate what we proposed<br>\nin Coq/Matita, but I think that nowadays it should be much simpler to<br>\ndo, letting the system infer automatically what decorations to use for<br>\nrelations and for the lemmas.</p>\n<p>Since you are reviving my interest into that, please let me know if you<br>\nplan to actually work on that for Isar.</p>\n<p>Cheers,<br>\nC.S.C.</p>",
        "id": 289294861,
        "sender_full_name": "Email Gateway",
        "timestamp": 1657615916
    }
]