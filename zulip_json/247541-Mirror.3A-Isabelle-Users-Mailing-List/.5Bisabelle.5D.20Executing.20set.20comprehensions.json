[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear readers,</p>\n<p>For a change I would like to describe a solution rather than ask a question.</p>\n<p>If one is interested in executability, but wants to stay at an abstract level, <br>\none is sometimes faced with the challenge of executing set comprehensions. Of <br>\ncourse there is no silver bullet for those, but often they feel almost <br>\nexecutable, but Isabelle fails to recognize this.</p>\n<p>A brute force approach is to define a second version on the list level and prove <br>\nthe equivalence and execute the list version. Here I want to show how to stay on <br>\nthe set level, yet make it executable.</p>\n<p>A typical example:</p>\n<p>definition f :: \"(int * int) set ⇒ int set\" where<br>\n\"f M = {b. ∃a. (a,b) ∈ M ∧ a &gt; b}\"</p>\n<p>This is not executable because of the EX. So we need to reformulate f:</p>\n<p>lemma f_exec[code]: \"f M = (λ(a,b). b) ` {(a,b) ∈ M. a &gt; b}\"<br>\nunfolding f_def f'_def by auto</p>\n<p>The equivalence is automatic and the result executable, eg</p>\n<p>value \"f {(2,1), (1,2), (3,1)}\"</p>\n<p>In general, you can make a set comprehension executable by transforming it into <br>\ncompositions of ` (= map) and {a : M. ...} (= filter), where each component is <br>\nexecutable. (UN may also come in handy, but if frequently leads to \"UN x : M. <br>\n{...}\", which is better expressed with map and filter.)</p>\n<p>Note that the filter pattern is restricted:<br>\nIt works for variables x in {x : M. ...}; in the latest distribution it also <br>\nworks for pairs (see above) and triples. Arbitrary tuples would require a simproc.</p>\n<p>Best<br>\nTobias</p>\n<p><a href=\"/user_uploads/14278/ebePzbKvxBzluYtVG3wGjx70/smime.p7s\">smime.p7s</a></p>",
        "id": 537828378,
        "sender_full_name": "Email Gateway",
        "timestamp": 1757064165
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nSorry, ignore the \"f'_def\". - Tobias</p>\n<p>On 05/09/2025 11:22, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Dear readers,</p>\n<p>For a change I would like to describe a solution rather than ask a question.</p>\n<p>If one is interested in executability, but wants to stay at an abstract level, <br>\none is sometimes faced with the challenge of executing set comprehensions. Of <br>\ncourse there is no silver bullet for those, but often they feel almost <br>\nexecutable, but Isabelle fails to recognize this.</p>\n<p>A brute force approach is to define a second version on the list level and prove <br>\nthe equivalence and execute the list version. Here I want to show how to stay on <br>\nthe set level, yet make it executable.</p>\n<p>A typical example:</p>\n<p>definition f :: \"(int * int) set ⇒ int set\" where<br>\n\"f M = {b. ∃a. (a,b) ∈ M ∧ a &gt; b}\"</p>\n<p>This is not executable because of the EX. So we need to reformulate f:</p>\n<p>lemma f_exec[code]: \"f M = (λ(a,b). b) ` {(a,b) ∈ M. a &gt; b}\"<br>\nunfolding f_def f'_def by auto</p>\n<p>The equivalence is automatic and the result executable, eg</p>\n<p>value \"f {(2,1), (1,2), (3,1)}\"</p>\n<p>In general, you can make a set comprehension executable by transforming it into <br>\ncompositions of ` (= map) and {a : M. ...} (= filter), where each component is <br>\nexecutable. (UN may also come in handy, but if frequently leads to \"UN x : M. <br>\n{...}\", which is better expressed with map and filter.)</p>\n<p>Note that the filter pattern is restricted:<br>\nIt works for variables x in {x : M. ...}; in the latest distribution it also <br>\nworks for pairs (see above) and triples. Arbitrary tuples would require a simproc.</p>\n<p>Best<br>\nTobias</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/ETqWZa0qO5F-QKrIQNFcZUni/smime.p7s\">smime.p7s</a></p>",
        "id": 537828909,
        "sender_full_name": "Email Gateway",
        "timestamp": 1757064340
    },
    {
        "content": "<p>From: \"\\\"Lammich, Peter (UT-EEMCS)\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSo can we add some generic simp lemmas ( and later maybe a simproc) to the code preprocessor simpset? By default or as a library they?</p>\n<p>Peter</p>\n<p>On 5 Sept 2025 11:25, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:<br>\nSorry, ignore the \"f'_def\". - Tobias</p>\n<p>On 05/09/2025 11:22, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Dear readers,</p>\n<p>For a change I would like to describe a solution rather than ask a question.</p>\n<p>If one is interested in executability, but wants to stay at an abstract level,<br>\none is sometimes faced with the challenge of executing set comprehensions. Of<br>\ncourse there is no silver bullet for those, but often they feel almost<br>\nexecutable, but Isabelle fails to recognize this.</p>\n<p>A brute force approach is to define a second version on the list level and prove<br>\nthe equivalence and execute the list version. Here I want to show how to stay on<br>\nthe set level, yet make it executable.</p>\n<p>A typical example:</p>\n<p>definition f :: \"(int * int) set ⇒ int set\" where<br>\n\"f M = {b. ∃a. (a,b) ∈ M ∧ a &gt; b}\"</p>\n<p>This is not executable because of the EX. So we need to reformulate f:</p>\n<p>lemma f_exec[code]: \"f M = (λ(a,b). b) ` {(a,b) ∈ M. a &gt; b}\"<br>\nunfolding f_def f'_def by auto</p>\n<p>The equivalence is automatic and the result executable, eg</p>\n<p>value \"f {(2,1), (1,2), (3,1)}\"</p>\n<p>In general, you can make a set comprehension executable by transforming it into<br>\ncompositions of ` (= map) and {a : M. ...} (= filter), where each component is<br>\nexecutable. (UN may also come in handy, but if frequently leads to \"UN x : M.<br>\n{...}\", which is better expressed with map and filter.)</p>\n<p>Note that the filter pattern is restricted:<br>\nIt works for variables x in {x : M. ...}; in the latest distribution it also<br>\nworks for pairs (see above) and triples. Arbitrary tuples would require a simproc.</p>\n<p>Best<br>\nTobias</p>\n</blockquote>",
        "id": 537833943,
        "sender_full_name": "Email Gateway",
        "timestamp": 1757065966
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nDId something change about the code generator preprocessing here? In the <br>\npast I often explicitly put \"Set.filter\" into the code equations instead <br>\nof \"{x. P x}\" to make this sort of stuff work.</p>\n<p>On 05/09/2025 11:22, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Dear readers,</p>\n<p>For a change I would like to describe a solution rather than ask a <br>\nquestion.</p>\n<p>If one is interested in executability, but wants to stay at an <br>\nabstract level, one is sometimes faced with the challenge of executing <br>\nset comprehensions. Of course there is no silver bullet for those, but <br>\noften they feel almost executable, but Isabelle fails to recognize this.</p>\n<p>A brute force approach is to define a second version on the list level <br>\nand prove the equivalence and execute the list version. Here I want to <br>\nshow how to stay on the set level, yet make it executable.</p>\n<p>A typical example:</p>\n<p>definition f :: \"(int * int) set ⇒ int set\" where<br>\n\"f M = {b. ∃a. (a,b) ∈ M ∧ a &gt; b}\"</p>\n<p>This is not executable because of the EX. So we need to reformulate f:</p>\n<p>lemma f_exec[code]: \"f M = (λ(a,b). b) ` {(a,b) ∈ M. a &gt; b}\"<br>\nunfolding f_def f'_def by auto</p>\n<p>The equivalence is automatic and the result executable, eg</p>\n<p>value \"f {(2,1), (1,2), (3,1)}\"</p>\n<p>In general, you can make a set comprehension executable by <br>\ntransforming it into compositions of ` (= map) and {a : M. ...} (= <br>\nfilter), where each component is executable. (UN may also come in <br>\nhandy, but if frequently leads to \"UN x : M. {...}\", which is better <br>\nexpressed with map and filter.)</p>\n<p>Note that the filter pattern is restricted:<br>\nIt works for variables x in {x : M. ...}; in the latest distribution <br>\nit also works for pairs (see above) and triples. Arbitrary tuples <br>\nwould require a simproc.</p>\n<p>Best<br>\nTobias</p>\n</blockquote>",
        "id": 537846791,
        "sender_full_name": "Email Gateway",
        "timestamp": 1757071015
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<p>On 05/09/2025 13:16, Manuel Eberl wrote:</p>\n<blockquote>\n<p>DId something change about the code generator preprocessing here? In the past I <br>\noften explicitly put \"Set.filter\" into the code equations instead of \"{x. P x}\" <br>\nto make this sort of stuff work.</p>\n</blockquote>\n<p>Yes, Florian has recently modified this because I felt Set.filter\" wasn't ideal.</p>\n<p>Tobias</p>\n<blockquote>\n<p>On 05/09/2025 11:22, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Dear readers,</p>\n<p>For a change I would like to describe a solution rather than ask a question.</p>\n<p>If one is interested in executability, but wants to stay at an abstract level, <br>\none is sometimes faced with the challenge of executing set comprehensions. Of <br>\ncourse there is no silver bullet for those, but often they feel almost <br>\nexecutable, but Isabelle fails to recognize this.</p>\n<p>A brute force approach is to define a second version on the list level and <br>\nprove the equivalence and execute the list version. Here I want to show how to <br>\nstay on the set level, yet make it executable.</p>\n<p>A typical example:</p>\n<p>definition f :: \"(int * int) set ⇒ int set\" where<br>\n\"f M = {b. ∃a. (a,b) ∈ M ∧ a &gt; b}\"</p>\n<p>This is not executable because of the EX. So we need to reformulate f:</p>\n<p>lemma f_exec[code]: \"f M = (λ(a,b). b) ` {(a,b) ∈ M. a &gt; b}\"<br>\nunfolding f_def f'_def by auto</p>\n<p>The equivalence is automatic and the result executable, eg</p>\n<p>value \"f {(2,1), (1,2), (3,1)}\"</p>\n<p>In general, you can make a set comprehension executable by transforming it <br>\ninto compositions of ` (= map) and {a : M. ...} (= filter), where each <br>\ncomponent is executable. (UN may also come in handy, but if frequently leads <br>\nto \"UN x : M. {...}\", which is better expressed with map and filter.)</p>\n<p>Note that the filter pattern is restricted:<br>\nIt works for variables x in {x : M. ...}; in the latest distribution it also <br>\nworks for pairs (see above) and triples. Arbitrary tuples would require a <br>\nsimproc.</p>\n<p>Best<br>\nTobias</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/R-COITT8gVi3ToB-JiAUMCTZ/smime.p7s\">smime.p7s</a></p>",
        "id": 537867039,
        "sender_full_name": "Email Gateway",
        "timestamp": 1757077718
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<p>On 05/09/2025 11:52, \"Lammich, Peter (UT-EEMCS)\" (via cl-isabelle-users Mailing <br>\nList) wrote:</p>\n<blockquote>\n<p>So can we add some generic simp lemmas ( and later maybe a simproc) to the code <br>\npreprocessor simpset? By default or as a library they?</p>\n</blockquote>\n<p>Correct. Like this:</p>\n<p>lemma Collect_triple_member [code_unfold, no_atp]:<br>\n   \\&lt;open&gt;{(x, y, z). List.member xs (x, y, z) \\&lt;and&gt; P x y z} = Set.filter <br>\n(\\&lt;lambda&gt;(x, y, z). P x y z) (set xs)\\&lt;close&gt;<br>\n   by auto</p>\n<p>Tobias</p>\n<blockquote>\n<p>Peter</p>\n<p>On 5 Sept 2025 11:25, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:<br>\nSorry, ignore the \"f'_def\". - Tobias</p>\n<p>On 05/09/2025 11:22, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Dear readers,</p>\n<p>For a change I would like to describe a solution rather than ask a question.</p>\n<p>If one is interested in executability, but wants to stay at an abstract level, <br>\none is sometimes faced with the challenge of executing set comprehensions. Of <br>\ncourse there is no silver bullet for those, but often they feel almost <br>\nexecutable, but Isabelle fails to recognize this.</p>\n<p>A brute force approach is to define a second version on the list level and prove<br>\nthe equivalence and execute the list version. Here I want to show how to stay on<br>\nthe set level, yet make it executable.</p>\n<p>A typical example:</p>\n<p>definition f :: \"(int * int) set ⇒ int set\" where<br>\n\"f M = {b. ∃a. (a,b) ∈ M ∧ a &gt; b}\"</p>\n<p>This is not executable because of the EX. So we need to reformulate f:</p>\n<p>lemma f_exec[code]: \"f M = (λ(a,b). b) ` {(a,b) ∈ M. a &gt; b}\"<br>\nunfolding f_def f'_def by auto</p>\n<p>The equivalence is automatic and the result executable, eg</p>\n<p>value \"f {(2,1), (1,2), (3,1)}\"</p>\n<p>In general, you can make a set comprehension executable by transforming it into<br>\ncompositions of ` (= map) and {a : M. ...} (= filter), where each component is <br>\nexecutable. (UN may also come in handy, but if frequently leads to \"UN x : M. <br>\n{...}\", which is better expressed with map and filter.)</p>\n<p>Note that the filter pattern is restricted:<br>\nIt works for variables x in {x : M. ...}; in the latest distribution it also <br>\nworks for pairs (see above) and triples. Arbitrary tuples would require a simproc.</p>\n<p>Best<br>\nTobias<br>\n</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/Y9Q-I1KmRm8rKoSET24rZkhC/smime.p7s\">smime.p7s</a></p>",
        "id": 537868817,
        "sender_full_name": "Email Gateway",
        "timestamp": 1757078283
    }
]