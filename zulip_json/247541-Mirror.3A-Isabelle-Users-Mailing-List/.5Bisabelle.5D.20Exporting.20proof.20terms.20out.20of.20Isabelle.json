[
    {
        "content": "<p>From: Frédéric Blanqui &lt;<a href=\"mailto:frederic.blanqui@inria.fr\">frederic.blanqui@inria.fr</a>&gt;<br>\nDear all,</p>\n<p>I am very pleased to announce that one can now export all the proofs of <br>\nthe Isabelle/HOL library (that is up to Complex_Main) to the Dedukti and <br>\nLambdapi languages, using the Isabelle component <br>\n<a href=\"https://github.com/Deducteam/isabelle_dedukti\">https://github.com/Deducteam/isabelle_dedukti</a>.</p>\n<p>This allows cross-checking of Isabelle developments. There are also <br>\nongoing works for translating Dedukti files to other systems like Coq, <br>\nLean, PVS or Agda.</p>\n<p>Generating the proof terms takes about 47 minutes to Isabelle on my laptop.<br>\nThe translation to Dedukti or Lambdapi takes about 26 minutes.<br>\nThe verification of all the generated Dedukti files (4.5 Go) takes about <br>\n3 minutes with kocheck -j 7.</p>\n<p>This currently works with Isabelle-2021-1 only. We hope to update it to <br>\nIsabelle-2022 in the coming months. Help is very welcome!</p>\n<p>This is the result of several contributors: Makarius Wenzel, Michael <br>\nFärber, Yann Leray, Akihisa Yamada, Jérémy Dubut, that I want to thank <br>\nvery much.</p>\n<p>Best regards,</p>\n<p>Frédéric Blanqui.</p>\n<p>Useful links:</p>\n<p>Isabelle_Dedukti: <a href=\"https://github.com/Deducteam/isabelle_dedukti\">https://github.com/Deducteam/isabelle_dedukti</a></p>\n<p>Dedukti: <a href=\"https://github.com/Deducteam/dedukti\">https://github.com/Deducteam/dedukti</a></p>\n<p>Lambdapi: <a href=\"https://github.com/Deducteam/lambdapi\">https://github.com/Deducteam/lambdapi</a></p>\n<p>Kocheck: <a href=\"https://github.com/01mf02/kontroli-rs\">https://github.com/01mf02/kontroli-rs</a></p>",
        "id": 316077655,
        "sender_full_name": "Email Gateway",
        "timestamp": 1671120210
    },
    {
        "content": "<p>From: Nicolas Méric &lt;<a href=\"mailto:nicolas.meric@lri.fr\">nicolas.meric@lri.fr</a>&gt;<br>\nDear Frédéric,</p>\n<p>I looked at the code of the exporter, and I do not understand the<br>\ninitialization of the build options<br>\n(<a href=\"https://github.com/Deducteam/isabelle_dedukti/blob/0f25057f268c13c9c6e6699512370442a71d5ff6/src/exporter.scala#L30\">https://github.com/Deducteam/isabelle_dedukti/blob/0f25057f268c13c9c6e6699512370442a71d5ff6/src/exporter.scala#L30</a>).</p>\n<p>I thought that setting the record_proofs session option to 2 had the same<br>\nmeaning as enabling the export_standard_proofs option, but in the code<br>\nMakarius chose, for both cases, that is if export_standard_proofs is set or<br>\nnot, to have the record_proofs option set to 2.</p>\n<p>Do you know why he did that?</p>\n<p>I quickly looked at the sources of Isabelle, and both export_standard_proofs<br>\nand record_proofs=2 seem to set Proofterm.proofs to 2.</p>\n<p>Best regards,</p>\n<p>Nicolas Méric</p>",
        "id": 316689011,
        "sender_full_name": "Email Gateway",
        "timestamp": 1671438975
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Frédéric,</p>\n<p>I have done some proofterm exporting myself (to Lean, work-in-progress), <br>\nand I was wondering whether your exporting relates one issue that I <br>\nencountered.</p>\n<p>In Isabelle (or maybe specifically Isabelle/HOL), definitions are <br>\noutside the trusted kernel. When a definition (e.g., *definition \"a = <br>\n1\"*) is encountered, an axiom is simply added (in this case *a::'a::one <br>\n= 1*). It is possible to even give several definitions for the same <br>\nconstant on different types (i.e., we could end up with axioms *a::nat = <br>\n1* and <em>a::int = 2</em> at the same time). This is used under the hood in <br>\nthe type-class mechanism, and can also be accessed directly.</p>\n<p>The question is how to handle definitions when exporting proofterms. One <br>\nobvious solution is to simply treat definitions like any other axiom, <br>\nand simply add them in the exported theory as axioms. However, this <br>\nseems to defeat the purpose of external checking of Isabelle proofs <br>\n(i.e., when we do not trust the Isabelle implementation). Namely, there <br>\nis no guarantee that these axioms will be consistent. (I am aware that <br>\nthere are proofs that the Isabelle/HOL definitional framework with <br>\ntypeclasses that these axiomatizations are a conservative extension but <br>\nthat does not guarantee that the Isabelle implementation does it <br>\ncorrectly, and in my understanding, the point of external checking is <br>\nnot to trust the existing implementation.)</p>\n<p>The second obvious idea would be to replace definitional axioms by <br>\nproper definitions. That is, in the target logic, we would have <br>\nsomething that says that <em>a</em> is basically an abbreviation for <em>1</em>. <br>\nHowever, this would need a target logic with overloading or with type <br>\nequality checks. (For example, if I translate the example above into a <br>\ndefinition, I would have to write something like *a ('a) := if 'a=nat <br>\nthen 1::nat else if 'a=int then 2::int else undefined*<em>('a)</em>. (Here I am <br>\nwriting the type variables as arguments to <em>a</em> and <em>undefined</em> as an <br>\nexplicit argument <em>('a)</em> for clarity.) If I want to use those <br>\ndefinitions in exported proofs, I will have to use facts like *nat != <br>\nint* which are probably unprovable in many logics and might be unsound <br>\nin logics that have provable parametricity.</p>\n<p>The third idea (which I am using in my approach) is to process the <br>\nproofs to get rid of all the overloading first (after all, it's a <br>\nconservative extension). For example, in the above example, we end up <br>\nwith definition <em>a_nat := 1</em> and <em>a_int := 2</em> and then all theorems need <br>\nto be rewritten to use one or the other, or, if the theorem is stated at <br>\na larger type, take an all-quantified argument <em>a</em> and be proven for all <br>\n<em>a</em>. Doing this in practice isn't straightforward, but it seems to work <br>\n(work-in-progress!).</p>\n<p>So I wonder how you deal with this difficulty in your formalization. Do <br>\nyou export definitions as trusted axioms or do you use a different approach?</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 318063693,
        "sender_full_name": "Email Gateway",
        "timestamp": 1672135141
    }
]