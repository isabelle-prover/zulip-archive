[
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nThe 45-line definition of function \"resid\" in the attached theory takes between 30 and 40 minutes<br>\nto process.  This time increased very rapidly from a previous value of about 3 minutes when I added<br>\nfour clauses (the four preceding the final default clause).  The original definition was stated with<br>\n\"fun\" but I split it up using \"function\" to try to see which part was consuming the time.<br>\nAbout one minute is used to process the \"function (sequential)\" declaration, with the remainder of<br>\nthe time going to the proof of 46057 subgoals \"by pat_completeness auto\".  The termination proof<br>\ndoes not take significant time.  I note that the time-consuming portion appears to be single-threaded.</p>\n<p>Is there anything I can do, or am I out of luck?  The 30-40 minute processing time is probably<br>\nprohibitive for what I was trying to do, so it looks like I will have to abandon the generalization<br>\nI was trying to make and revert to a simpler version that processes in reasonable time.</p>\n<p>Thanks for any suggestions.<br>\n<a href=\"/user_uploads/14278/rt2RwP8mfmS96Z4VgXHbgYnD/Barf.thy\">Barf.thy</a></p>",
        "id": 245192679,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625669518
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAttached you find a version that works in reasonable time. I reduced the size of <br>\nthe patterns by replacing all \"Var 0\" by \"vn\" and testing if \"vn ~= Var 0 \\/ <br>\n...\". This got the number of cases just below 10.000. [I believe I did not <br>\nchange the meaning of the equations as a result]</p>\n<p>Note that the problem of minimizing the number of cases is hard: <br>\n<a href=\"https://www21.in.tum.de/~krauss/publication/2008-patterns/\">https://www21.in.tum.de/~krauss/publication/2008-patterns/</a></p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/732dMnB4aAXyAjgrn6KGCW8z/Barf.thy\">Barf.thy</a><br>\n<a href=\"/user_uploads/14278/qxirNVvhstZYQWXobGZdtXL-/smime.p7s\">smime.p7s</a></p>",
        "id": 245234772,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625688158
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nThanks!  The ideas for reducing the processing time are very helpful.</p>\n<p>I think there is something else going on besides the sheer number of subgoals, because removing<br>\nthe last four clauses in my original example still leaves about 18,000 subgoals, but the processing<br>\ntime is only about 3 minutes.  I guess when the patterns are expanded to the next level of depth<br>\nit applies a multiplicative factor to the time taken to discharge the subgoals.  One gets used to<br>\nthe function package often working so well that it is quite startling to see an exponential jump in<br>\nprocessing time with relatively small changes to the definitions.</p>\n<p>Right now I am confused, though, and I have to go back and re-do my homework on this definition.<br>\nI hit a blocking point in the series of lemmas I was trying to generalize and I jumped to the conclusion<br>\nthat I had missed some critical pairs (hence the additional four clauses), but at this moment I am not<br>\nso sure any more.</p>\n<p>Anyway, your ideas at least provide me with some control over my fate.  Thanks again!</p>",
        "id": 245263557,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625707706
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHmm, I wonder if some of the non-mandatory features of the function<br>\npackage (such as the generation of elimination rules) might affect the<br>\nperformance negatively here. Perhaps one could try to put an option into<br>\nthe function package to disable the generation of these and see what<br>\nhappens.</p>\n<p>(Full disclosure: I wrote the code that generates the pelims/elims rules<br>\nback in the day, so if this is the issue, it's my fault. :D )</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/Md_lniqf8m9tSs0cARAkas7X/smime.p7s\">smime.p7s</a></p>",
        "id": 245284026,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625731847
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nNote that up to the point where pat_completeness generates 46057 subgoals, <br>\nthings are not so bad. Proving all those (simple!) subgoals is the killer.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/hZYOLKIDT8Lz03MxrZxy3Pik/smime.p7s\">smime.p7s</a></p>",
        "id": 245285179,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625732678
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI'm not so sure. It's difficult to assess because I for one cannot get<br>\nit to build at all.</p>\n<p>Even if I replace the \"by pat_completeness auto\" with \"sorry\", Isabelle<br>\njust crashes after a few minutes. Both with x86_32 and x64. And that's<br>\non my beefy 32 GB machine.</p>\n<p>If I replace it with a \"apply pat_completeness apply auto oops\" it runs<br>\nfor something like 20 minutes and then freezes up my PC and crashes<br>\n(possibly killed by the OOM killer).</p>\n<p>The function package does a lot of work after pattern completeness and<br>\nnon-overlappingness have been proven. This is the stuff that happens<br>\nwhen you write \"done\". I for one think there is a good chance that this<br>\nis just as expensive as the user-contributed proofs, if not more so.</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/GPgy0LSD3wlwwu7S0JaMTith/smime.p7s\">smime.p7s</a></p>",
        "id": 245292257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625737844
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 08/07/2021 11:50, Manuel Eberl wrote:</p>\n<blockquote>\n<p>I'm not so sure. It's difficult to assess because I for one cannot get<br>\nit to build at all.</p>\n<p>Even if I replace the \"by pat_completeness auto\" with \"sorry\", Isabelle<br>\njust crashes after a few minutes. Both with x86_32 and x64. And that's<br>\non my beefy 32 GB machine.</p>\n<p>If I replace it with a \"apply pat_completeness apply auto oops\" it runs<br>\nfor something like 20 minutes and then freezes up my PC and crashes<br>\n(possibly killed by the OOM killer).</p>\n</blockquote>\n<p>Eugene and I could get up to \"apply auto\" in a matter of a very few minutes. It <br>\nis the auto (I also tried simp_all) that kills us.</p>\n<blockquote>\n<p>The function package does a lot of work after pattern completeness and<br>\nnon-overlappingness have been proven. This is the stuff that happens<br>\nwhen you write \"done\". I for one think there is a good chance that this<br>\nis just as expensive as the user-contributed proofs, if not more so.</p>\n</blockquote>\n<p>Maybe so, but we never got to \"done\".</p>\n<p>With the simplified version (with 10.000 cases), \"auto\" takes 30+ secs, \"done\" <br>\ntakes 3 secs.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Manuel</p>\n<p>On 08/07/2021 10:24, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Note that up to the point where pat_completeness generates 46057<br>\nsubgoals, things are not so bad. Proving all those (simple!) subgoals is<br>\nthe killer.</p>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>On 08/07/2021 10:10, Manuel Eberl wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hmm, I wonder if some of the non-mandatory features of the function<br>\npackage (such as the generation of elimination rules) might affect the<br>\nperformance negatively here. Perhaps one could try to put an option into<br>\nthe function package to disable the generation of these and see what<br>\nhappens.</p>\n<p>(Full disclosure: I wrote the code that generates the pelims/elims rules<br>\nback in the day, so if this is the issue, it's my fault. :D )</p>\n<p>Manuel</p>\n</blockquote>\n<p>On 08/07/2021 03:28, Eugene W. Stark wrote:</p>\n<blockquote>\n<blockquote>\n<p>Thanks!  The ideas for reducing the processing time are very helpful.</p>\n<p>I think there is something else going on besides the sheer number of<br>\nsubgoals, because removing<br>\nthe last four clauses in my original example still leaves about<br>\n18,000 subgoals, but the processing<br>\ntime is only about 3 minutes.  I guess when the patterns are expanded<br>\nto the next level of depth<br>\nit applies a multiplicative factor to the time taken to discharge the<br>\nsubgoals.  One gets used to<br>\nthe function package often working so well that it is quite startling<br>\nto see an exponential jump in<br>\nprocessing time with relatively small changes to the definitions.</p>\n<p>Right now I am confused, though, and I have to go back and re-do my<br>\nhomework on this definition.<br>\nI hit a blocking point in the series of lemmas I was trying to<br>\ngeneralize and I jumped to the conclusion<br>\nthat I had missed some critical pairs (hence the additional four<br>\nclauses), but at this moment I am not<br>\nso sure any more.</p>\n<p>Anyway, your ideas at least provide me with some control over my<br>\nfate.  Thanks again!</p>\n</blockquote>\n<p>On 7/7/21 4:02 PM, Tobias Nipkow wrote:</p>\n<blockquote>\n<blockquote>\n<p>Attached you find a version that works in reasonable time. I reduced<br>\nthe size of the patterns by replacing all \"Var 0\"<br>\nby \"vn\" and testing if \"vn ~= Var 0 \\/ ...\". This got the number of<br>\ncases just below 10.000. [I believe I did not change<br>\nthe meaning of the equations as a result]</p>\n<p>Note that the problem of minimizing the number of cases is hard:<br>\n<a href=\"https://www21.in.tum.de/~krauss/publication/2008-patterns/\">https://www21.in.tum.de/~krauss/publication/2008-patterns/</a></p>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>On 07/07/2021 16:51, Eugene W. Stark wrote:</p>\n<blockquote>\n<blockquote>\n<p>The 45-line definition of function \"resid\" in the attached theory<br>\ntakes between 30 and 40 minutes<br>\nto process.  This time increased very rapidly from a previous value<br>\nof about 3 minutes when I added<br>\nfour clauses (the four preceding the final default clause).  The<br>\noriginal definition was stated with<br>\n\"fun\" but I split it up using \"function\" to try to see which part<br>\nwas consuming the time.<br>\nAbout one minute is used to process the \"function (sequential)\"<br>\ndeclaration, with the remainder of<br>\nthe time going to the proof of 46057 subgoals \"by pat_completeness<br>\nauto\".  The termination proof<br>\ndoes not take significant time.  I note that the time-consuming<br>\nportion appears to be single-threaded.</p>\n<p>Is there anything I can do, or am I out of luck?  The 30-40 minute<br>\nprocessing time is probably<br>\nprohibitive for what I was trying to do, so it looks like I will<br>\nhave to abandon the generalization<br>\nI was trying to make and revert to a simpler version that processes<br>\nin reasonable time.</p>\n<p>Thanks for any suggestions.<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/emL9Hdm1MBIe4i6qaGbPonTr/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 245294211,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625739231
    }
]