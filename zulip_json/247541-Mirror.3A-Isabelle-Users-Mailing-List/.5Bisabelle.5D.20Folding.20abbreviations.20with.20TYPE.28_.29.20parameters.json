[
    {
        "content": "<p>From: Mikhail Mandrykin &lt;<a href=\"mailto:mandrykin@ispras.ru\">mandrykin@ispras.ru</a>&gt;<br>\nHello!</p>\n<p>I have a question about the current situation regarding abbreviations <br>\nwith dummy parameters of type \"'a itself\" e.g.<br>\n⬚‹abbreviation \"to_bounds TYPE('a::len) x ≡ uint (word_of_int x :: 'a <br>\nword)\"›<br>\nHere \"TYPE('a)\" is used to pass the length of the machine word <br>\nrepresented by the corresponding numeral type. It looks like a more or <br>\nless proper way to define and use such abbreviations, in particular it's <br>\nwhat Isabelle automatically does for abbreviations with hidden <br>\npolymorphism: for<br>\n⬚‹<br>\nabbreviation \"to_bounds' x ≡ uint (word_of_int x)\"<br>\nterm to_bounds'<br>\n›<br>\nIsabelle gives ▩‹\"to_bounds'\" :: \"'a itself ⇒ int ⇒ int\"›.<br>\nHowever, when I try to use such an abbreviation, it's not folded back <br>\nwhen pretty-printing:<br>\n⬚‹term \"to_bounds TYPE(8) 534\"›<br>\nsimply prints ▩‹\"uint (word_of_int 534)\" :: \"int\"› instead of <br>\n▩‹\"to_bounds TYPE(8) 534\" :: \"int\"›. The question is whether there's <br>\nsome pragmatic reason for not fully supporting such abbreviations?</p>\n<p>From technical point if view I looked at the implementation of constant <br>\nabbreviation folding in Pure and the code looks somewhat dubious about <br>\nthat. On the one hand, Consts.abbreviate calls <br>\nTerm.close_schematic_term, which adds dummy \"TYPE(_)\" parameters to <br>\nexpose the hidden polymorphism in the RHS of the abbreviation. On the <br>\nother hand, a local function strip_abss, which is used by <br>\nConsts.abbreviate only strips parameters that occur in the RHS as term <br>\nvariables and does not take into account type variables. But those <br>\nvariables of type \"'a itself\" usually don't occur directly in the RHS <br>\nand therefore the reverse abbreviation mechanism tries to fold an <br>\nabstraction of the form \"λ (_ :: 'a itself). t\" instead of the term \"t\" <br>\nand this is not how the unfolded abbreviation is actually represented. I <br>\nthough it might be better to explicitly support those parameters of type <br>\n\"'a itself\" as instances of the singleton type Pure.type and try to fold <br>\n\"RHS ('a)\" → \"LHS v_1 ... v_n (Pure.type :: 'a) v_{n+1} ... v_m\" (i.e. <br>\ninstantiate the LHS and RHS with the singleton Pure.type instead of the <br>\nvariable, if it does not occur in RHS as a variable), which is supported <br>\nby Pattern.match_rew used in Proof_Context.contract_abbrevs. I <br>\nimplemented a patch based on this idea (attached as <br>\ncontract_TYPE_abbrevs.patch). It works for the example given above, some <br>\nmore examples that we have in our formalizations and also passes <br>\n\"regular\" tests of building with \"isabelle build -a\" on my machine. A <br>\nnotable quirk of this approach is that it would also fold abbreviations <br>\neven if the type does not occur in the RHS by introducing fresh type <br>\nvariables e.g. folding \"f x\" to \"u TYPE(?'a) TYPE(?'b)\" when given \"u <br>\nTYPE('a) TYPE('b) x ≡ f x\". This can be prevented by checking occurrence <br>\nof the type variable in the RHS, but I'm not sure how to treat such <br>\ncases since they are quite strange anyway. So doesn't this approach have <br>\nsome undesirable pitfalls or the support was simply missing due to lack <br>\nof use cases? The feature seems useful for handling types with phantom <br>\nparameters that represent some additional information such as word or <br>\npointer type size.</p>\n<p>Regards,<br>\nMikhail<br>\n<a href=\"/user_uploads/14278/IkjL4u_iGO1y0fNXzGTk7KJo/contract_TYPE_abbrevs.patch\">contract_TYPE_abbrevs.patch</a></p>",
        "id": 203826928,
        "sender_full_name": "Email Gateway",
        "timestamp": 1594729776
    }
]