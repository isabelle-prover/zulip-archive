[
    {
        "content": "<p>From: Alex Meyer &lt;<a href=\"mailto:alex153@outlook.lv\">alex153@outlook.lv</a>&gt;<br>\nI am digesting specification of quicksort <a href=\"https://isabelle.in.tum.de/library/HOL/HOL-Imperative_HOL/Imperative_Quicksort.html\">https://isabelle.in.tum.de/library/HOL/HOL-Imperative_HOL/Imperative_Quicksort.html</a> and I have question:</p>\n<p>is it OK (acceptable by AFP standards) to specify algorithm as definition (e.g. swap) or is it strongly required that the final algorithm is specified as function (e.g. quicksort)?</p>\n<p>According to tutorial, definition is not for recursive functions and it does not create proof obligation for termination. As I can see from the example, then Isabelle can still prove lemmas and theorms about definitions (maybe with additional assumptions).</p>\n<p>So - as I understand: if the formalized algorithm is expected to be partially correct only (without the proof of termination) then it is OK that Isabelle theory specifies this algorithm (and its relevant sub-algorithms) as definition and proves theorems about this definition that resembles the partial correctness proofs.</p>\n<p>So - the specification of some algorithm as function is required only in the case when total correctnes should be proved.</p>\n<p>And just for clarification: is it really true, that the fun/function keyword requires that the specification of the function with fun/function is recursive, i.e., that the specified function should appear in the right hand side for at least one pattern-matching-clause? As can be understood from the tutorials then fun/function is for recursive definitions specifically, but nonetheless, Isabelle allows to write:</p>\n<p>function two_integer_max_case :: \"nat ⇒ nat ⇒ nat\" where<br>\n\"two_integer_max_case a b = (case a &gt; b of True ⇒ a | False ⇒ b)\"<br>\nby pat_completeness auto<br>\ntermination by auto</p>\n<p>And Isabelle also provides suggestions for the proof. But maybe it is just misleading - one should not expect that such function can be defined in such way...</p>\n<p>Alex</p>",
        "id": 231164791,
        "sender_full_name": "Email Gateway",
        "timestamp": 1616266843
    },
    {
        "content": "<p>From: Jakub Kądziołka &lt;<a href=\"mailto:kuba@kadziolka.net\">kuba@kadziolka.net</a>&gt;<br>\nOn Sat Mar 20, 2021 at 7:59 PM CET, Alex Meyer wrote:</p>\n<blockquote>\n<p>I am digesting specification of quicksort <a href=\"https://isabelle.in.tum.de/library/HOL/HOL-Imperative_HOL/Imperative_Quicksort.html\">https://isabelle.in.tum.de/library/HOL/HOL-Imperative_HOL/Imperative_Quicksort.html</a> and I have question:</p>\n<p>is it OK (acceptable by AFP standards) to specify algorithm as definition (e.g. swap) or is it strongly required that the final algorithm is specified as function (e.g. quicksort)?</p>\n<p>According to tutorial, definition is not for recursive functions and it does not create proof obligation for termination. As I can see from the example, then Isabelle can still prove lemmas and theorms about definitions (maybe with additional assumptions).</p>\n<p>So - as I understand: if the formalized algorithm is expected to be partially correct only (without the proof of termination) then it is OK that Isabelle theory specifies this algorithm (and its relevant sub-algorithms) as definition and proves theorems about this definition that resembles the partial correctness proofs.</p>\n</blockquote>\n<p>Alex,</p>\n<p>you seem to have a fundamental misunderstanding of what's happening<br>\nhere. On the level of the logic, 'fun' and 'function' are strictly<br>\ngeneralizations of 'definition'. When Isabelle doesn't require a<br>\ntermination proof, that's because it's trivial, not because the problem<br>\nof termination is ignored.</p>\n<p>In fact, termination isn't only required for total correctness, but also<br>\nfor logical consistency. Consider:</p>\n<p>function foo where<br>\n  \"foo x = (¬ foo x)\"<br>\n  by pat_completeness auto<br>\ntermination sorry</p>\n<p>theorem False<br>\nproof -<br>\n  have *: \"a = (¬ a) ⟹ False\" for a<br>\n    by simp<br>\n  show False by (fact *[OF foo.simps])<br>\nqed</p>\n<p>When both 'definition' and 'fun' accept a formula, the difference comes<br>\ndown to how proof automation will treat your function (by default) —<br>\nif you 'fun foo', the defining formula will become a fact named<br>\nfoo.simps. As the name suggests, it will be added to the simpset and the<br>\nsimplifier will unfold it by default. By contrast, for a<br>\n'definition foo', the fact is called foo_def and isn't added to the<br>\nsimpset.</p>\n<p>I presume that the reason the tutorial says that 'fun' should only be<br>\nused for recursive definitions, is that if you use it for non-recursive<br>\nones, your intermediate goals will get needlessly large, and thus not<br>\nvery readable.</p>\n<p>After all, if a function is defined by pattern matching and a subformula<br>\nof the goal matches that pattern, then unfolding the application is<br>\nprobably a good idea.</p>\n<blockquote>\n<p>function two_integer_max_case :: \"nat ⇒ nat ⇒ nat\" where<br>\n\"two_integer_max_case a b = (case a &gt; b of True ⇒ a | False ⇒ b)\"<br>\nby pat_completeness auto<br>\ntermination by auto</p>\n</blockquote>\n<p>In light of the above, function definitions with proofs this trivial<br>\nshould really use the 'fun' keyword instead. Indeed, use 'function' only<br>\nwhen 'fun' is having trouble with the termination proof.</p>\n<blockquote>\n<p>And just for clarification: is it really true, that the fun/function keyword requires that the specification of the function with fun/function is recursive, i.e., that the specified function should appear in the right hand side for at least one pattern-matching-clause?</p>\n</blockquote>\n<p>As you've demonstrated, this is not the case. In fact, there are<br>\nsituations where a function is non-recursive, and yet 'fun' is a better<br>\ntool for the job than 'definition'. Consider</p>\n<p>fun pred :: \"nat =&gt; nat\" where<br>\n  \"pred 0 = 0\" |<br>\n  \"pred (S n) = n\"</p>\n<p>Defining this function with 'definition' would require an explicit<br>\n'case' expression.</p>\n<p>Hope that helps,<br>\nJakub Kądziołka</p>",
        "id": 231167342,
        "sender_full_name": "Email Gateway",
        "timestamp": 1616269607
    }
]