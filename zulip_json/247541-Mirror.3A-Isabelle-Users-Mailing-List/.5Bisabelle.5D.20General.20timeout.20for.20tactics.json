[
    {
        "content": "<p>From: Max Haslbeck &lt;<a href=\"mailto:max.haslbeck@gmx.de\">max.haslbeck@gmx.de</a>&gt;<br>\nHi,</p>\n<p>is it possible to have a general timeout for all tactics or for all <code>apply</code> and <code>by</code> commands?</p>\n<p>For example, fastforce loops in the following proof:</p>\n<div class=\"codehilite\"><pre><span></span><code>lemma assumes A: &quot;x = y&quot; &quot;y = x&quot;\n  shows &quot;x = z&quot;\n  apply(fastforce simp add: A)\n</code></pre></div>\n<p>Can I just have it timeout after 10 seconds?</p>\n<p>I often run into this problem when working on Isabelle code and simply changing a definition or a lemma. I then go through the failed proofs coming after the change. And often there is a <code>metis</code> or <code>blast</code> command simply clogging up the CPU and making my laptop unresponsive.</p>\n<p>The documentation [1] says on page 97 in a footnote: “The lack of memoing and the strict nature of ML requires some care when working with low-level sequence operations, to avoid duplicate or premature evaluation of results. It also means that modified runtime behavior, such as timeout, is very hard to achieve for general tactics.”<br>\nIs there maybe a hack which I can activate when doing interactive proof development in Isabelle/jedit?</p>\n<p>Gruß<br>\nMax</p>\n<p>[1]: <a href=\"https://isabelle.in.tum.de/dist/Isabelle2020/doc/implementation.pdf\">https://isabelle.in.tum.de/dist/Isabelle2020/doc/implementation.pdf</a></p>",
        "id": 215445503,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604405816
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Max Haslbeck,</p>\n<p>There exists at least one example in Isabelle/HOL's source code: look<br>\nfor atp_tac in atp_problem_import.ML. At some point in the past, I was able<br>\nto use it to implement a timeout for one of my own tactics (this was done<br>\nfor experiments and debugging only, of course) using elements of the code<br>\nborrowed from the implementation of atp_tac.</p>\n<p>Also, I would like to make note on the subject of debugging rules for<br>\nclassical reasoner. In the past, I found it useful to use the single-step<br>\ntactics, as described in section 9.4.6 of the manual. However, I am sure<br>\nthat you are aware of them already.</p>\n<p>I hope you will find my comments useful. However, of course, this is not an<br>\nofficial reply and there may be a more canonical solution available.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 215447856,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604407414
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI know that problem well. Every once in a while, a rogue call of some<br>\ntactic (e.g. a heavily backgracking \"transfer\") loops and takes the<br>\nentire Isabelle/jEdit session with it.</p>\n<p>Sometimes one can delete the offending tactic call and the session<br>\nrecovers eventually, but most of the time it's faster to just kill it<br>\nand restart everything.</p>\n<p>Manuel</p>",
        "id": 215448363,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604407731
    },
    {
        "content": "<p>From: Freek Wiedijk &lt;<a href=\"mailto:freek@cs.ru.nl\">freek@cs.ru.nl</a>&gt;<br>\nDear all,</p>\n<p>It's not really relevant for this list, but in HOL Light<br>\nit is trivial to hack something like this together:</p>\n<p>exception Timeout;;</p>\n<p>Sys.set_signal Sys.sigalrm (Sys.Signal_handle (fun _ -&gt; raise Timeout));;</p>\n<p>let TIMED_TAC n tac g =<br>\n  let _ = Unix.alarm n in<br>\n  try<br>\n    let gs = tac g in<br>\n    let _ = Unix.alarm 0 in<br>\n    gs<br>\n  with x -&gt;<br>\n    let _ = Unix.alarm 0 in<br>\n    raise x;;</p>\n<p>If you do (TIMED_TAC 3 (MESON_TAC[...])), it will run<br>\n(MESON_TAC[...]) but if that doesn't succeed in 3 seconds,<br>\nit will fail with a Timeout exception.</p>\n<p>Freek</p>",
        "id": 215454358,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604411091
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I had a little bit more time now and implemented a rough sketch of a<br>\nplausible solution based on my own suggestion (its only purpose is to<br>\ndemonstrate that the functionality that you seek can be implemented<br>\neasily). Of course, it will need to be refined for any<br>\nserious applications. Also, with some further work, it can be integrated in<br>\nthe apply/by infrastructure:</p>\n<p>theory Scratch<br>\n  imports<br>\n    Main<br>\nbegin</p>\n<p>ML‹</p>\n<p>val timeout_parser = Method.text_closure</p>\n<p>fun process_timeout ctxt m = ctxt</p>\n<p>(* timeout configuration *)<br>\nval timeout_cfg = Attrib.setup_config_int \\&lt;^binding&gt;‹mtime› (K 0)</p>\n<p>(* copied from HOL/TPTP/atp_problem_import.ML with minor amendments *)<br>\nfun SOLVE_TIMEOUT mseconds tac st =<br>\n  let<br>\n    val result =<br>\n      Timeout.apply<br>\n        (Time.fromMilliseconds mseconds) (fn () =&gt; SINGLE (SOLVE tac) st) ()<br>\n      handle Timeout.TIMEOUT _ =&gt; NONE | ERROR _ =&gt; NONE<br>\n  in<br>\n    (<br>\n      case result of<br>\n        NONE =&gt; Seq.empty<br>\n      | SOME st' =&gt; Seq.single st'<br>\n    )<br>\n  end</p>\n<p>fun timeout_tac ctxt t m =<br>\n  let<br>\n    val tac = (Method.evaluate m ctxt) []<br>\n      |&gt; Context_Tactic.NO_CONTEXT_TACTIC ctxt<br>\n      |&gt; SOLVE_TIMEOUT t<br>\n  in SIMPLE_METHOD tac end;</p>\n<p>fun process_timeout m ctxt = timeout_tac ctxt (Config.get ctxt timeout_cfg)<br>\nm</p>\n<p>val _ = Theory.setup<br>\n  (<br>\n    Method.setup<br>\n      \\&lt;^binding&gt;‹timeout›<br>\n      (timeout_parser &gt;&gt; process_timeout)<br>\n      \"higher order timeout method\"<br>\n  );</p>\n<p>›</p>\n<p>declare[[mtime=1]]</p>\n<p>lemma<br>\n  assumes A: \"x = z\"<br>\n  shows \"x = z\"<br>\n  apply(timeout‹simp add: A›)<br>\n  done</p>\n<p>lemma<br>\n  assumes A: \"x = y\" \"y = x\"<br>\n  shows \"x = z\"<br>\n  apply(timeout‹fastforce simp add: A›)<br>\n  oops</p>\n<p>end</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 215464771,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604415861
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I have to admit that my previous replies were slightly rushed: I was trying<br>\nto do too many things at the same time after consuming a substantial amount<br>\nof caffeine :). Having had a look at my own replies, I noticed a few<br>\ntypographical/style errors.</p>\n<ol>\n<li>\n<p>The first sentence of the second paragraph of the first email should<br>\nread \"Also, I would like to make a note on the subject of debugging of the<br>\nrules for certain proof methods for classical reasoning.\"</p>\n</li>\n<li>\n<p>The ML part of the code in the second email was meant to look like the<br>\ncode shown below (more specifically, I noticed that a wrong naming<br>\nconvention was used for the function for the specification of the method<br>\nand there were a few redundancies). Keep in mind, this is still only a<br>\nsketch.</p>\n</li>\n</ol>\n<p>ML‹</p>\n<p>val timeout_cfg = Attrib.setup_config_int \\&lt;^binding&gt;‹mtime› (K 0)</p>\n<p>(* copied from HOL/TPTP/atp_problem_import.ML with minor amendments *)<br>\nfun SOLVE_TIMEOUT mseconds tac st =<br>\n  let<br>\n    val result =<br>\n      Timeout.apply<br>\n        (Time.fromMilliseconds mseconds) (fn () =&gt; SINGLE (SOLVE tac) st) ()<br>\n      handle Timeout.TIMEOUT _ =&gt; NONE | ERROR _ =&gt; NONE<br>\n  in<br>\n    (<br>\n      case result of<br>\n        NONE =&gt; Seq.empty<br>\n      | SOME st' =&gt; Seq.single st'<br>\n    )<br>\n  end</p>\n<p>fun timeout_tac ctxt t m = Method.evaluate m ctxt []<br>\n  |&gt; Context_Tactic.NO_CONTEXT_TACTIC ctxt<br>\n  |&gt; SOLVE_TIMEOUT t;</p>\n<p>fun process_timeout m ctxt =<br>\n  SIMPLE_METHOD (timeout_tac ctxt (Config.get ctxt timeout_cfg) m);</p>\n<p>val _ = Theory.setup<br>\n  (<br>\n    Method.setup<br>\n      \\&lt;^binding&gt;‹timeout›<br>\n      (Method.text_closure &gt;&gt; process_timeout)<br>\n      \"higher order timeout method\"<br>\n  );</p>\n<p>›</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 215502939,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604433506
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nI just want to make sure that somebody points out the obvious issue.</p>\n<p>Wrapping a timeout around fastforce, metis etc sounds like a good thing.<br>\nFailures are easier to find and address than divergence. However, it<br>\nwould be a disaster if there were lots of proofs that mostly worked<br>\nbut failed outright if some machine was running particularly slowly for<br>\nwhatever reason.</p>\n<p>So, it's easy enough to implement a timeout mechanism on a tactic or <br>\nmethod,<br>\nbut it's probably not useful for the purpose you really want, which is <br>\nto<br>\nset timeouts throughout your theories by default.</p>\n<p>Years ago I spent some time wondering whether there was some kind of <br>\nobjective<br>\ntiming that would make sense, e.g. the number of classical steps in a<br>\nfastforce/auto proof. Limiting those would be safer. I never got around <br>\nto<br>\nimplementing anything though.</p>\n<p>Best regards,<br>\n     Thomas.</p>",
        "id": 215571134,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604491201
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Thomas Sewell/All,</p>\n<p>Thank you for your remarks. It was never my intention to advocate the use<br>\nof this feature in production-level code. However, it can be useful for<br>\ndebugging and experimentation (e.g. when designing a new<br>\nsimpset/intro/dest/elim rules or a new tactic/proof method). Of course,<br>\nonce a simpset/rule set/tactic/method is designed, the timeout should be<br>\nremoved.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 215627509,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604516988
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nSome users (perhaps including me) might find this very useful even as an<br>\n\"always switched on\" option in the IDE – although I am not sure how well<br>\nthat works in practice.</p>\n<p>The main use case would be to kill those rogue \"transfer\" calls that<br>\nblock the entire system. But it's quite possible that after 10 seconds<br>\n(or whatever a suitable timeout would be) it might already have done too<br>\nmuch damage for the system to recover in a reasonable amount of time.</p>\n<p>Thomas is of course right to point out that this is not something that<br>\nshould run in batch mode because reproducibility goes completely out of<br>\nthe window if you switch it on.</p>\n<p>Manuel</p>",
        "id": 215628617,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604517493
    }
]