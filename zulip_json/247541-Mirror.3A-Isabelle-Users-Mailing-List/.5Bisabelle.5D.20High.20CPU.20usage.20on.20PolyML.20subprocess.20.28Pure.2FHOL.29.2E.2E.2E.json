[
    {
        "content": "<p>From: Bo Gan &lt;<a href=\"mailto:gan.bo@columbia.edu\">gan.bo@columbia.edu</a>&gt;<br>\nHi Isabelle users,</p>\n<p>I'm fairly new to Isabelle and provers in general. Currently I'm trying to<br>\nfollow the Programming and Proving Tutorial from Tobias (Nipkow) and having<br>\nfun with some very simple theories. However I did notice the GUI JEdit<br>\ngetting more and more sluggish when left almost idle for a day or two. The<br>\nPolyML subprocess (Pure/HOL heap) eats up ~2 cpu cores. Further debugging<br>\nreveals that the main PolyML thread and Event_Timer.manager_loop thread<br>\neach consume 80-90% the CPU time. Details on the PolyML process:</p>\n<p>cmdline=<br>\n\"/home/***/.isabelle/contrib/polyml-test-f86ae3dc1686/x86_64_32-linux/poly\"<br>\n\"-q\" \"--minheap\" \"500\" \"--gcthreads\" \"0\" \"--exportstats\" \"--eval\"<br>\n\"(PolyML.SaveState.loadHierarchy<br>\n[\"/home/***/.isabelle/heaps/polyml-5.8.2_x86_64_32-linux/Pure\",<br>\n\"/home/***/.isabelle/heaps/polyml-5.8.2_x86_64_32-linux/HOL\"];<br>\nPolyML.print_depth 0) handle exn =&gt; (TextIO.output (TextIO.stdErr,<br>\nGeneral.exnMessage exn ^ \": HOL\\n\"); OS.Process.exit OS.Process.failure)\"<br>\n\"--eval\" \"Options.load_default ()\" \"--eval\" \"Isabelle_Process.init ()\"</p>\n<p>PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+<br>\nCOMMAND</p>\n<p>1325109 ***   20   0 23.236g 696280   3888 R 99.9  4.3   1558:23 poly</p>\n<p>1325071 ***   20   0 23.236g 696280   3888 R 86.7  4.3   1229:05 poly</p>\n<p>1325101 ***   20   0 23.236g 696280   3888 S 20.0  4.3 107:43.02 poly</p>\n<p>1325102 ***   20   0 23.236g 696280   3888 S 13.3  4.3 105:41.89 poly</p>\n<p>1325103 ***   20   0 23.236g 696280   3888 S 13.3  4.3 105:39.40 poly</p>\n<p>1325108 ***   20   0 23.236g 696280   3888 S 13.3  4.3 101:19.50 poly</p>\n<p>1325068 ***   20   0 23.236g 696280   3888 S  6.7  4.3  33:40.44 poly</p>\n<p>1325104 ***   20   0 23.236g 696280   3888 S  6.7  4.3 107:10.92 poly</p>\n<p>1325107 ***   20   0 23.236g 696280   3888 S  6.7  4.3  99:25.42 poly</p>\n<p>1325062 ***   20   0 23.236g 696280   3888 S  0.0  4.3  40:50.67 poly</p>\n<p>1325066 ***   20   0 23.236g 696280   3888 S  0.0  4.3   0:00.00 poly</p>\n<p>1325067 ***   20   0 23.236g 696280   3888 S  0.0  4.3  33:41.02 poly</p>\n<p>1325069 ***   20   0 23.236g 696280   3888 S  0.0  4.3  33:39.01 poly</p>\n<p>1325070 ***   20   0 23.236g 696280   3888 S  0.0  4.3  33:41.40 poly</p>\n<p>1325072 ***   20   0 23.236g 696280   3888 S  0.0  4.3   0:00.00 poly</p>\n<p>1325078 ***   20   0 23.236g 696280   3888 S  0.0  4.3   0:11.03 poly</p>\n<p>1325100 ***   20   0 23.236g 696280   3888 S  0.0  4.3   0:48.37 poly</p>\n<p>1325105 ***   20   0 23.236g 696280   3888 S  0.0  4.3 104:58.21 poly</p>\n<p>1325106 ***   20   0 23.236g 696280   3888 S  0.0  4.3 102:55.48 poly</p>\n<p>Here's a snapshot of their ML call stack (collected from my own gdb python<br>\nscripts):</p>\n<p>Main Poly thread (1325071):<br>\n#0 0x7fc57b9064fd in Multithreading.synchronized(3)(1)+0x3e5,<br>\nsp=0x7fc67bf54870<br>\n#1 0x7fc57b905be0 in Multithreading.synchronized(3)+0x68, sp=0x7fc67bf54888<br>\n#2 0x7fc57b8e7456 in Command.fork_print(3)+0x2b6, sp=0x7fc67bf548a8<br>\n#3 0x7fc57b8f101f in List.mapPartial(2)()+0x16f, sp=0x7fc67bf548e8<br>\n#4 0x7fc57b8eff4a in Document.start_execution(1)(4)(1)+0x20a,<br>\nsp=0x7fc67bf54918<br>\n#5 0x7fc57b8efcdf in Document.start_execution(1)(4)+0x77, sp=0x7fc67bf54958<br>\n#6 0x7fc57b8efc15 in Document.start_execution(1)+0x3d, sp=0x7fc67bf54968<br>\n#7 0x7fc57b337e0e in o(2)(1)+0x1e, sp=0x7fc67bf549a8<br>\n#8 0x7fc57b939167 in Synchronized.timed_access(3)(1)try_change(1)+0x15f,<br>\nsp=0x7fc67bf549b0<br>\n#9 0x7fc57b90654b in Multithreading.synchronized(3)(1)+0x433,<br>\nsp=0x7fc67bf549e0<br>\n#10 0x7fc57b905be0 in Multithreading.synchronized(3)+0x68, sp=0x7fc67bf54a18<br>\n#11 0x7fc57b337d57 in Protocol._-(1)+0x87, sp=0x7fc67bf54a38<br>\n#12 0x7fc57b93f6bf in Thread_Data.setmp(4)(1)+0x1a7, sp=0x7fc67bf54a40<br>\n#13 0x7fc57b93f6bf in Thread_Data.setmp(4)(1)+0x1a7, sp=0x7fc67bf54a80<br>\n#14 0x7fc57b9ad319 in Future.future_job(4)job(1)+0x89, sp=0x7fc67bf54ac8<br>\n#15 0x7fc57b93fb00 in Future.worker_exec(2)ok-(1)(1)+0x30, sp=0x7fc67bf54af0<br>\n#16 0x7fc57b93f6bf in Thread_Data.setmp(4)(1)+0x1a7, sp=0x7fc67bf54b10<br>\n#17 0x7fc57b93ab0a in Task_Queue.update_timing(3)(1)+0x6a, sp=0x7fc67bf54b50<br>\n#18 0x7fc57b93e62e in Future.worker_exec(2)+0xce, sp=0x7fc67bf54b98<br>\n#19 0x7fc57b599156 in Future.task_context(4)(1)+0x13e, sp=0x7fc67bf54bd0<br>\n#20 0x7fc57b3241d3 in Protocol_Command.run(2)+0x9b, sp=0x7fc67bf54c20<br>\n#21 0x7fc57b32345e in<br>\nIsabelle_Process.init_protocol(1)(1)(2)protocol_loop(1)+0x50e,<br>\nsp=0x7fc67bf54c50<br>\n#22 0x7fc57b95457d in Unsynchronized.setmp(4)(1)+0x3d, sp=0x7fc67bf54c78<br>\n&lt;Identical frames discarded&gt;<br>\n#35 0x7fc57b31ff2a in Isabelle_Process.init_protocol(1)(1)(2)+0xcaa,<br>\nsp=0x7fc67bf54ee0<br>\n#36 0x7fc57b905e23 in Thread_Attributes.with_attributes(2)+0xab,<br>\nsp=0x7fc67bf54f40<br>\n#37 0x7fc57bd02517 in &lt;top level&gt;+0x17, sp=0x7fc67bf54f68<br>\n#38 0x7fc57c0354f1 in CODETREE().genCode(3)(1)+0x19, sp=0x7fc67bf54f70<br>\n#39 0x7fc57c057f91 in COMPILER_BODY().baseCompiler(4)executeCode(1)+0x19,<br>\nsp=0x7fc67bf54f80<br>\n#40 0x7fc57c07e8e1 in polyCompiler(2)defaultCompilerResultFun(2)(1)+0x19,<br>\nsp=0x7fc67bf54f90<br>\n#41 0x7fc57bd5c5c6 in PolyML.rootFunction(1)tryUseFileArguments(1)+0x4c6,<br>\nsp=0x7fc67bf54fa0<br>\n#42 0x7fc57bd55e67 in PolyML.rootFunction(1)+0xd57, sp=0x7fc67bf54fd0<br>\n#43 0x7fc57bd5503b in PolyML.runFunction(1)(1)+0x33, sp=0x7fc67bf54fe8</p>\n<p>Event_Timer (1325109):<br>\n#0 0x7fc57c0abd70 in VectorSliceOperations().subslice(3)+0x0,<br>\nsp=0x7fc67c149958<br>\n#1 0x7fc57bd10578 in convStats(2)parseStatistic(2)+0x68, sp=0x7fc67c149960<br>\n#2 0x7fc57bd1049f in convStats(2)parseStatistics(1)+0x1f, sp=0x7fc67c149990<br>\n#3 0x7fc57bd104b1 in convStats(2)parseStatistics(1)+0x31, sp=0x7fc67c1499b0<br>\n&lt;Identical frames discarded&gt;<br>\n#31 0x7fc57bd0f412 in convStats(2)+0x15a, sp=0x7fc67c149e10<br>\n#32 0x7fc57bd0f0ec in PolyML.Statistics.getLocalStats(1)+0x74,<br>\nsp=0x7fc67c149e28<br>\n#33 0x7fc57b7a9aab in Event_Timer.manager_loop(1)(1)+0x63, sp=0x7fc67c149ef8<br>\n#34 0x7fc57b939167 in Synchronized.timed_access(3)(1)try_change(1)+0x15f,<br>\nsp=0x7fc67c149f30<br>\n#35 0x7fc57b90654b in Multithreading.synchronized(3)(1)+0x433,<br>\nsp=0x7fc67c149f60<br>\n#36 0x7fc57b905be0 in Multithreading.synchronized(3)+0x68, sp=0x7fc67c149f98<br>\n#37 0x7fc57b7a98ef in Event_Timer.manager_loop(1)+0x57, sp=0x7fc67c149fb8<br>\n#38 0x7fc57b9aaec0 in Isabelle_Thread.fork(2)(1)(1)+0x30, sp=0x7fc67c149fc8<br>\n#39 0x7fc57b9aae02 in Thread.Thread.fork(2)threadFunction(1)+0x32,<br>\nsp=0x7fc67c149fe8</p>\n<p>I suspect we are wasting a lot of time invoking GC on PolyML runtime when<br>\ncollecting stats, but I could be totally wrong. This issue is reproducible<br>\nand quite annoying. Has anyone encountered the same?</p>",
        "id": 236302629,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619513323
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>in my experience (and I have heard similar things mentioned on this <br>\nmailing list before), Isabelle tends to become very sluggish sometimes <br>\nafter a while. (I find it especially happens after a session with a lot <br>\nof reexecuting theories and a lot of sledgehammer use.) I have not found <br>\na better way than restarting Isabelle when things have become \"stuck\". <br>\n(An alternative to restarting the whole jEdit is to disable and reenable <br>\nthe plugin in the plugin manager. Then your opened files stay open. But <br>\nit needs more clicks.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 237158697,
        "sender_full_name": "Email Gateway",
        "timestamp": 1620047737
    },
    {
        "content": "<p>From: Simon Wimmer &lt;<a href=\"mailto:wimmersimon@gmail.com\">wimmersimon@gmail.com</a>&gt;<br>\nHi,</p>\n<p>if Isabelle eats up two CPU cores when idling, it might be that something<br>\nis running forever.<br>\nFor beginners this is usually a non-terminating proof tactic, specifically<br>\nthings like blast, fastforce, force,<br>\nbut also simp and auto can loop if you give them the wrong rules.<br>\nYou can identify such non-terminating tactics by looking for the purple<br>\nbackground color.<br>\nIt indicates that something is still running.</p>\n<p>Kind regards,<br>\nSimon</p>",
        "id": 237159619,
        "sender_full_name": "Email Gateway",
        "timestamp": 1620048207
    },
    {
        "content": "<p>From: Alexander Kogtenkov via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nIs there an option in Isabelle/jEdit to treat proof tactics as failing after a specified timeout?<br>\n<br>\nThat would make the environment much more convenient and user-friendly. Purple does indeed indicate diverging tactics in a proof text, but 1) if there are several occurrences, one has to find them by hand; 2) the coloring engine sometimes becomes very unresponsive as well, so it’s not that easy to find these occurrences.<br>\n<br>\nBest regards,<br>\nAlexander Kogtenkov</p>",
        "id": 237162243,
        "sender_full_name": "Email Gateway",
        "timestamp": 1620049378
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nHere is a related suggestion that would be useful for the same reason: to modify the behaviour of “Go to next error” so that it regards any still-running proof method as an error. Then one could quickly jump to non-terminating proof steps.</p>\n<p>Larry</p>",
        "id": 237295819,
        "sender_full_name": "Email Gateway",
        "timestamp": 1620121680
    }
]