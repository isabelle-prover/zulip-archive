[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt;<br>\nHi all,</p>\n<p>I have a couple of related questions concerning the current state of the <br>\ndatatype package.</p>\n<p>Find my motivation in the attached theory: I want to »register« a type a <br>\nposteriori as a datatype.</p>\n<p>a) Construct the type</p>\n<p>b) Define the appropriate constructors</p>\n<p>c) Prove them as free constructors</p>\n<p>d) Prove the corresponding induction rule</p>\n<p>But then? Primrec still fails, obviously due to the lack of a recursion <br>\ncombinator.</p>\n<p>How to proceed from there?</p>\n<p>(When examining how it is done for the existing elementary types in HOL, <br>\nI found that the »old« datatype package with the traditional <br>\n»rep_datatype« is still in place – which leads to the somehow related <br>\nquestion if there are further migrations plans there.)</p>\n<p>For the presented example an appropriate solution is to introduce the <br>\ntype as a datatype and establish lifting a posteriori, but there might <br>\nbe other instances where this is the less comfortable way.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p><a href=\"/user_uploads/14278/Zqs-DRQWpBDMDXgjohR6Cq7h/Numeral.thy\">Numeral.thy</a><br>\n<a href=\"/user_uploads/14278/yqs8sf-lRyD7ONDrVbvEzrAE/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/q8sgcryX-Fq5BAEVVW-lwnvQ/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 495950684,
        "sender_full_name": "Email Gateway",
        "timestamp": 1737883604
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Florian,</p>\n<p>There is indeed no explicit rep_datatype command anymore, but there is an interface to register a recursor, which makes primrec work. I attach the code below. The ML bits are copied from the equivalent setup for natural numbers (which is the reason why this interface exists in the first place).</p>\n<p>To also make fun work with num, it would be good to also include the corresponding size class instance.</p>\n<p>Best wishes,<br>\nDmitriy</p>\n<p>fun rec_num_raw :: \"'a ⇒ (nat ⇒ 'a ⇒ 'a) ⇒ (nat ⇒ 'a ⇒ 'a) ⇒ nat ⇒ 'a\" where<br>\n  \"rec_num_raw one bit0 bit1 (Suc 0) = one\"<br>\n| \"rec_num_raw one bit0 bit1 (Suc n) = (if even n then bit1 (n div 2) (rec_num_raw one bit0 bit1 (n div 2))<br>\n     else bit0 ((Suc n) div 2) (rec_num_raw one bit0 bit1 ((Suc n) div 2)))\"</p>\n<p>lift_definition rec_num :: \"'a ⇒ (num ⇒ 'a ⇒ 'a) ⇒ (num ⇒ 'a ⇒ 'a) ⇒ num ⇒ 'a\" is<br>\n  rec_num_raw<br>\n  subgoal for one bit0 bit0' bit1 bit1' n<br>\n    by (induct one bit0 bit1 n rule: rec_num_raw.induct) auto<br>\n  done</p>\n<p>lemma rec_num:<br>\n  \"rec_num one bit0 bit1 One = one\"<br>\n  \"rec_num one bit0 bit1 (Bit0 x) = bit0 x (rec_num one bit0 bit1 x)\"<br>\n  \"rec_num one bit0 bit1 (Bit1 x) = bit1 x (rec_num one bit0 bit1 x)\"<br>\n  by (transfer; auto simp: gr0_conv_Suc)+</p>\n<p>ML ‹<br>\nval num_basic_lfp_sugar =<br>\n  let<br>\n    val ctr_sugar = the (Ctr_Sugar.ctr_sugar_of_global \\&lt;^theory&gt; \\&lt;^type_name&gt;‹num›);<br>\n    val recx = Logic.varify_types_global \\&lt;^term&gt;‹rec_num›;<br>\n    val C = body_type (fastype_of recx);<br>\n  in<br>\n    {T = @{typ num}, fp_res_index = 0, C = C, fun_arg_Tsss = [[], [[@{typ num}, C]], [[@{typ num}, C]]],<br>\n     ctr_sugar = ctr_sugar, recx = recx, rec_thms = @{thms rec_num}}<br>\n  end;<br>\n›</p>\n<p>ML ‹nat_basic_lfp_sugar›</p>\n<p>setup ‹<br>\nlet<br>\n  fun basic_lfp_sugars_of _ [\\&lt;^typ&gt;‹num›] _ _ ctxt =<br>\n      ([], [0], [num_basic_lfp_sugar], [], [], [], TrueI (<em>dummy</em>), [], false, ctxt)<br>\n    | basic_lfp_sugars_of bs arg_Ts callers callssss ctxt =<br>\n      BNF_LFP_Rec_Sugar.default_basic_lfp_sugars_of bs arg_Ts callers callssss ctxt;<br>\nin<br>\n  BNF_LFP_Rec_Sugar.register_lfp_rec_extension<br>\n    {nested_simps = [], special_endgame_tac = K (K (K (K no_tac))), is_new_datatype = K (K true),<br>\n     basic_lfp_sugars_of = basic_lfp_sugars_of, rewrite_nested_rec_call = NONE}<br>\nend<br>\n›</p>\n<blockquote>\n<p>On 26 Jan 2025, at 10.26, Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt; wrote:</p>\n<p>Hi all,</p>\n<p>I have a couple of related questions concerning the current state of the datatype package.</p>\n<p>Find my motivation in the attached theory: I want to »register« a type a posteriori as a datatype.</p>\n<p>a) Construct the type</p>\n<p>b) Define the appropriate constructors</p>\n<p>c) Prove them as free constructors</p>\n<p>d) Prove the corresponding induction rule</p>\n<p>But then? Primrec still fails, obviously due to the lack of a recursion combinator.</p>\n<p>How to proceed from there?</p>\n<p>(When examining how it is done for the existing elementary types in HOL, I found that the »old« datatype package with the traditional »rep_datatype« is still in place – which leads to the somehow related question if there are further migrations plans there.)</p>\n<p>For the presented example an appropriate solution is to introduce the type as a datatype and establish lifting a posteriori, but there might be other instances where this is the less comfortable way.</p>\n<p>Cheers,<br>\n  Florian<br>\n&lt;Numeral.thy&gt;&lt;OpenPGP_0xA707172232CFA4E9.asc&gt;</p>\n</blockquote>",
        "id": 497143399,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738398290
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt;<br>\nThanks a lot.</p>\n<p>Florian</p>\n<p>Am 01.02.25 um 09:23 schrieb Dmitriy Traytel (via cl-isabelle-users <br>\nMailing List):</p>\n<blockquote>\n<p>Hi Florian,</p>\n<p>There is indeed no explicit rep_datatype command anymore, but there is an interface to register a recursor, which makes primrec work. I attach the code below. The ML bits are copied from the equivalent setup for natural numbers (which is the reason why this interface exists in the first place).</p>\n<p>To also make fun work with num, it would be good to also include the corresponding size class instance.</p>\n<p>Best wishes,<br>\nDmitriy</p>\n<p>fun rec_num_raw :: \"'a ⇒ (nat ⇒ 'a ⇒ 'a) ⇒ (nat ⇒ 'a ⇒ 'a) ⇒ nat ⇒ 'a\" where<br>\n   \"rec_num_raw one bit0 bit1 (Suc 0) = one\"<br>\n| \"rec_num_raw one bit0 bit1 (Suc n) = (if even n then bit1 (n div 2) (rec_num_raw one bit0 bit1 (n div 2))<br>\n      else bit0 ((Suc n) div 2) (rec_num_raw one bit0 bit1 ((Suc n) div 2)))\"</p>\n<p>lift_definition rec_num :: \"'a ⇒ (num ⇒ 'a ⇒ 'a) ⇒ (num ⇒ 'a ⇒ 'a) ⇒ num ⇒ 'a\" is<br>\n   rec_num_raw<br>\n   subgoal for one bit0 bit0' bit1 bit1' n<br>\n     by (induct one bit0 bit1 n rule: rec_num_raw.induct) auto<br>\n   done</p>\n<p>lemma rec_num:<br>\n   \"rec_num one bit0 bit1 One = one\"<br>\n   \"rec_num one bit0 bit1 (Bit0 x) = bit0 x (rec_num one bit0 bit1 x)\"<br>\n   \"rec_num one bit0 bit1 (Bit1 x) = bit1 x (rec_num one bit0 bit1 x)\"<br>\n   by (transfer; auto simp: gr0_conv_Suc)+</p>\n<p>ML ‹<br>\nval num_basic_lfp_sugar =<br>\n   let<br>\n     val ctr_sugar = the (Ctr_Sugar.ctr_sugar_of_global \\&lt;^theory&gt; \\&lt;^type_name&gt;‹num›);<br>\n     val recx = Logic.varify_types_global \\&lt;^term&gt;‹rec_num›;<br>\n     val C = body_type (fastype_of recx);<br>\n   in<br>\n     {T = @{typ num}, fp_res_index = 0, C = C, fun_arg_Tsss = [[], [[@{typ num}, C]], [[@{typ num}, C]]],<br>\n      ctr_sugar = ctr_sugar, recx = recx, rec_thms = @{thms rec_num}}<br>\n   end;<br>\n›</p>\n<p>ML ‹nat_basic_lfp_sugar›</p>\n<p>setup ‹<br>\nlet<br>\n   fun basic_lfp_sugars_of _ [\\&lt;^typ&gt;‹num›] _ _ ctxt =<br>\n       ([], [0], [num_basic_lfp_sugar], [], [], [], TrueI (<em>dummy</em>), [], false, ctxt)<br>\n     | basic_lfp_sugars_of bs arg_Ts callers callssss ctxt =<br>\n       BNF_LFP_Rec_Sugar.default_basic_lfp_sugars_of bs arg_Ts callers callssss ctxt;<br>\nin<br>\n   BNF_LFP_Rec_Sugar.register_lfp_rec_extension<br>\n     {nested_simps = [], special_endgame_tac = K (K (K (K no_tac))), is_new_datatype = K (K true),<br>\n      basic_lfp_sugars_of = basic_lfp_sugars_of, rewrite_nested_rec_call = NONE}<br>\nend<br>\n›</p>\n<blockquote>\n<p>On 26 Jan 2025, at 10.26, Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt; wrote:</p>\n<p>Hi all,</p>\n<p>I have a couple of related questions concerning the current state of the datatype package.</p>\n<p>Find my motivation in the attached theory: I want to »register« a type a posteriori as a datatype.</p>\n<p>a) Construct the type</p>\n<p>b) Define the appropriate constructors</p>\n<p>c) Prove them as free constructors</p>\n<p>d) Prove the corresponding induction rule</p>\n<p>But then? Primrec still fails, obviously due to the lack of a recursion combinator.</p>\n<p>How to proceed from there?</p>\n<p>(When examining how it is done for the existing elementary types in HOL, I found that the »old« datatype package with the traditional »rep_datatype« is still in place – which leads to the somehow related question if there are further migrations plans there.)</p>\n<p>For the presented example an appropriate solution is to introduce the type as a datatype and establish lifting a posteriori, but there might be other instances where this is the less comfortable way.</p>\n<p>Cheers,<br>\n Florian<br>\n&lt;Numeral.thy&gt;&lt;OpenPGP_0xA707172232CFA4E9.asc&gt;<br>\n</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/e8odSMQf-Cg6fSC4fKiE3xUM/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/SGT5EpkRZIeJRSS2bCEGcV-n/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 497143460,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738398359
    }
]