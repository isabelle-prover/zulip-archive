[
    {
        "content": "<p>Hello,</p>\n<p>I have a question about parsing theory files. I've searched the chat but i haven't found the answer i was looking for, hence my message. </p>\n<p>I need to split theory files into specs and proofs: so definitions go to one file and lemmas with their proofs in another. Makarius pointed me towards <code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some (incomplete) code running on simple theories such as the Fibonacci example presented in the code generation doc.<br>\nI would just like to see if the approach is \"right\": i currently match on <code>span.name</code> and i wonder if i should match instead on <code>span.kind</code>. <br>\nI also wonder if i should include keywords such as \"::\", \":\", \".\", \"(\", \")\", \"[code]\" in Outer_Syntax and, if there is a unique way to classify keywords (like mapping \":\" to \"thy_goal\" when creating <code>thy_syntax</code>). </p>\n<p>For reference, the code i have is below.</p>\n<p>Thank you,</p>\n<p>Lacramioara  </p>\n<div class=\"codehilite\" data-code-language=\"Scala\"><pre><span></span><code><span class=\"k\">package</span><span class=\"w\"> </span><span class=\"n\">isabelle</span>\n<span class=\"k\">object</span><span class=\"w\"> </span><span class=\"nc\">Test_Thy_Parser</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">private</span><span class=\"w\"> </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">is_definition</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Command_Span</span><span class=\"p\">.</span><span class=\"nc\">Span</span><span class=\"p\">):</span><span class=\"w\"> </span><span class=\"nc\">Boolean</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">span</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"s\">\"theory\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"imports\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"begin\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"end\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"definition\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"fun\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"datatype\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"::\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">true</span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">false</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"k\">private</span><span class=\"w\"> </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">is_proof</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Command_Span</span><span class=\"p\">.</span><span class=\"nc\">Span</span><span class=\"p\">):</span><span class=\"w\"> </span><span class=\"nc\">Boolean</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">span</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"s\">\"theorem\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"lemma\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"qed\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"proof\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"by\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"(\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\")\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\":\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"s\">\"[code]\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">true</span>\n<span class=\"w\">    </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">false</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"k\">private</span><span class=\"w\"> </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">write_spans</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">spans</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">List</span><span class=\"p\">[</span><span class=\"nc\">Command_Span</span><span class=\"p\">.</span><span class=\"nc\">Span</span><span class=\"p\">]):</span><span class=\"w\"> </span><span class=\"nc\">Unit</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">content</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">new</span><span class=\"w\"> </span><span class=\"nc\">StringBuilder</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"n\">spans</span><span class=\"p\">.</span><span class=\"n\">zipWithIndex</span><span class=\"p\">.</span><span class=\"n\">foreach</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">content</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">.</span><span class=\"n\">content</span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">.</span><span class=\"n\">source</span><span class=\"p\">).</span><span class=\"n\">mkString</span><span class=\"p\">(</span><span class=\"s\">\" \"</span><span class=\"p\">))</span>\n<span class=\"w\">      </span><span class=\"n\">spans</span><span class=\"p\">.</span><span class=\"n\">lift</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">foreach</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">nextSpan</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nc\">Set</span><span class=\"p\">(</span><span class=\"s\">\"::\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\":\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"(\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\")\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"[code]\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"by\"</span><span class=\"p\">).</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">nextSpan</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">          </span><span class=\"n\">content</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s\">\"\\n\\n\"</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">nextSpan</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"[code]\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">          </span><span class=\"n\">content</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s\">\" \"</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">nextSpan</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"by\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">          </span><span class=\"n\">content</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s\">\"\\n \"</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">      </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"nc\">File</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">content</span><span class=\"p\">.</span><span class=\"n\">toString</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"w\">  </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Array</span><span class=\"p\">[</span><span class=\"nc\">String</span><span class=\"p\">]):</span><span class=\"w\"> </span><span class=\"nc\">Unit</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"Usage: isabelle scala -e 'split_isa_spec_proofs.scala' &lt;theory_file.thy&gt;\"</span><span class=\"p\">)</span>\n<span class=\"w\">      </span><span class=\"n\">sys</span><span class=\"p\">.</span><span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">thy_file</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">Path</span><span class=\"p\">.</span><span class=\"n\">explode</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">thy_file</span><span class=\"p\">.</span><span class=\"n\">is_file</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">s\"Error: File not found - </span><span class=\"si\">${</span><span class=\"n\">thy_file</span><span class=\"si\">}</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n<span class=\"w\">      </span><span class=\"n\">sys</span><span class=\"p\">.</span><span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"c1\">// Setup syntax with common theory keywords</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">thy_syntax</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">Outer_Syntax</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"::\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_defn\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"theory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_begin\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"imports\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_decl\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"begin\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_begin\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"fun\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_defn\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"datatype\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_defn\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"definition\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_defn\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\":\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_goal\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"(\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_goal\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\")\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_goal\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"lemma\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_goal\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"[code]\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_goal\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"theorem\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_goal\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"proof\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"proof\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"by\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"proof\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"qed\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"proof\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"s\">\"end\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"thy_end\"</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"c1\">// Read and parse theory content</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">theory_content</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">File</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">thy_file</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">spans</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">thy_syntax</span><span class=\"p\">.</span><span class=\"n\">parse_spans</span><span class=\"p\">(</span><span class=\"n\">theory_content</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"c1\">// Separate definitions and proofs</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">spans</span><span class=\"p\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">is_definition</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">spans</span><span class=\"p\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">is_proof</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"c1\">// Generate output files</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">base_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">thy_file</span><span class=\"p\">.</span><span class=\"n\">expand</span><span class=\"p\">.</span><span class=\"n\">implode</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">def_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">Path</span><span class=\"p\">.</span><span class=\"n\">explode</span><span class=\"p\">(</span><span class=\"n\">base_path</span><span class=\"p\">.</span><span class=\"n\">replaceAll</span><span class=\"p\">(</span><span class=\"s\">\"\\\\.thy$\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"_definitions.thy\"</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"kd\">val</span><span class=\"w\"> </span><span class=\"n\">proof_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nc\">Path</span><span class=\"p\">.</span><span class=\"n\">explode</span><span class=\"p\">(</span><span class=\"n\">base_path</span><span class=\"p\">.</span><span class=\"n\">replaceAll</span><span class=\"p\">(</span><span class=\"s\">\"\\\\.thy$\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"_proofs.thy\"</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"n\">write_spans</span><span class=\"p\">(</span><span class=\"n\">def_path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">write_spans</span><span class=\"p\">(</span><span class=\"n\">proof_path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">proofs</span><span class=\"p\">)</span>\n<span class=\"p\">}}</span>\n</code></pre></div>",
        "id": 496486643,
        "sender_full_name": "Lacramioara Astefanoaei",
        "timestamp": 1738136480
    },
    {
        "content": "<p>From: lacramioara &lt;<a href=\"mailto:lacramioara.astefanoaei@gmail.com\">lacramioara.astefanoaei@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I have posted the above on the zulip chat but i'm reposting here in case<br>\nsomeone in this audience has advice.</p>\n<p>My question is about parsing theory files. I've searched the zulip chat but i<br>\nhaven't found the answer i was looking for, hence my message.</p>\n<p>I need to split theory files into specs and proofs: definitions go to one file<br>\nand lemmas with their proofs in another. Makarius pointed me towards<br>\n<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some (incomplete)<br>\ncode running on simple theories such as the Fibonacci example presented in the<br>\ncode generation doc.</p>\n<p>What is not clear to me is if there is a \"right\" way to construct the mapping<br>\nfor the keywords to be added to Outer_Syntax.empty: apparently, i do not need<br>\nto include \"imports\" so i was wondering if there is a way to get rid of<br>\nenumerating all the tokens that might appear in theory files. I would also<br>\nlike to see if my understanding is correct in that i can choose the mapping as<br>\nit best suits my needs. For instance, i classify \"lemma\" as having kind<br>\n\"PRF_GOAL\" just as a way to make it appear in <code>Keyword.proof</code>. Would this be<br>\nsomething not inline with the underlying philosophy of Isabelle/Scala?</p>\n<p>For reference, the code i have is below.</p>\n<p>Thank you,<br>\nLacramioara </p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">package</span><span class=\"w\"> </span><span class=\"n\">isabelle</span>\n\n<span class=\"n\">object</span><span class=\"w\"> </span><span class=\"n\">Test_Thy_Parser</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n\n<span class=\"w\">  </span><span class=\"n\">private</span><span class=\"w\"> </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"n\">is_definition</span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Command_Span.Span</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kp\">keywords</span><span class=\"o\">:</span>\n<span class=\"n\">Keyword.Keywords</span><span class=\"o\">):</span><span class=\"w\"> </span><span class=\"n\">Boolean</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">    </span><span class=\"kp\">keywords</span><span class=\"ow\">.</span><span class=\"n\">kinds.get</span><span class=\"o\">(</span><span class=\"n\">span.name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">match</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">      </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">Some</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Keyword.theory_defn.contains</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">None</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">    </span><span class=\"ow\">}</span>\n<span class=\"w\">  </span><span class=\"ow\">}</span>\n\n<span class=\"w\">  </span><span class=\"n\">private</span><span class=\"w\"> </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"n\">is_proof</span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Command_Span.Span</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kp\">keywords</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Keyword.Keywords</span><span class=\"o\">):</span>\n<span class=\"n\">Boolean</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">    </span><span class=\"kp\">keywords</span><span class=\"ow\">.</span><span class=\"n\">kinds.get</span><span class=\"o\">(</span><span class=\"n\">span.name</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">match</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">      </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">Some</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Keyword.proof.contains</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"n\">None</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">false</span>\n<span class=\"w\">    </span><span class=\"ow\">}</span>\n<span class=\"w\">  </span><span class=\"ow\">}</span>\n\n<span class=\"w\">  </span><span class=\"n\">private</span><span class=\"w\"> </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"n\">write_spans</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Path</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">spans</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">[</span><span class=\"n\">Command_Span.Span</span><span class=\"o\">]):</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"ow\">{</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">content</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">StringBuilder</span><span class=\"o\">()</span>\n<span class=\"w\">    </span><span class=\"n\">spans.zipWithIndex.foreach</span><span class=\"w\"> </span><span class=\"ow\">{</span><span class=\"w\"> </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span>\n<span class=\"w\">      </span><span class=\"n\">content.append</span><span class=\"o\">(</span><span class=\"n\">span.content.map</span><span class=\"o\">(_</span><span class=\"ow\">.</span><span class=\"n\">source</span><span class=\"o\">)</span><span class=\"ow\">.</span><span class=\"n\">mkString</span><span class=\"o\">(</span><span class=\"s\">\" \"</span><span class=\"o\">))</span>\n<span class=\"w\">      </span><span class=\"n\">spans.lift</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">1</span><span class=\"o\">)</span><span class=\"ow\">.</span><span class=\"n\">foreach</span><span class=\"w\"> </span><span class=\"ow\">{</span><span class=\"w\"> </span><span class=\"n\">nextSpan</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span>\n<span class=\"w\">        </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"o\">(!</span><span class=\"n\">Set</span><span class=\"o\">(</span><span class=\"s\">\"(\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s\">\")\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s\">\"[code]\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"s\">\"by\"</span><span class=\"o\">)</span><span class=\"ow\">.</span><span class=\"n\">contains</span><span class=\"o\">(</span><span class=\"n\">nextSpan.name</span><span class=\"o\">))</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">          </span><span class=\"n\">content.append</span><span class=\"o\">(</span><span class=\"s\">\"\\n\\n\"</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"n\">else</span><span class=\"w\"> </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nextSpan.name</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"[code]\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">          </span><span class=\"n\">content.append</span><span class=\"o\">(</span><span class=\"s\">\" \"</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"n\">else</span><span class=\"w\"> </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nextSpan.name</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"by\"</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">          </span><span class=\"n\">content.append</span><span class=\"o\">(</span><span class=\"s\">\"\\n \"</span><span class=\"o\">)</span>\n<span class=\"w\">        </span><span class=\"ow\">}</span>\n<span class=\"w\">      </span><span class=\"ow\">}</span>\n<span class=\"w\">    </span><span class=\"ow\">}</span>\n<span class=\"w\">    </span><span class=\"n\">File.write</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">content.toString</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"ow\">}</span>\n\n<span class=\"w\">  </span><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">Array</span><span class=\"o\">[</span><span class=\"n\">String</span><span class=\"o\">]):</span><span class=\"w\"> </span><span class=\"n\">Unit</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">    </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">args.length</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">1</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">      </span><span class=\"n\">println</span><span class=\"o\">(</span><span class=\"s\">\"Usage: isabelle scala -e 'split_isa_spec_proofs.scala'</span>\n<span class=\"s\">&lt;theory_file.thy&gt;\"</span><span class=\"o\">)</span>\n<span class=\"w\">      </span><span class=\"n\">sys.exit</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"ow\">}</span>\n\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">thy_file</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Path.explode</span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"o\">(!</span><span class=\"n\">thy_file.is_file</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"ow\">{</span>\n<span class=\"w\">      </span><span class=\"n\">println</span><span class=\"o\">(</span><span class=\"n\">s\"Error</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">File</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">found</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"ow\">{</span><span class=\"n\">thy_file</span><span class=\"ow\">}</span><span class=\"s\">\")</span>\n<span class=\"s\">      sys.exit(1)</span>\n<span class=\"s\">    }</span>\n\n<span class=\"s\">    type Keywords = List[(String, Keyword.Spec)]</span>\n\n<span class=\"s\">    val thy_keywords : Keywords = List((\"</span><span class=\"n\">%\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"(\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\")\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\",\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"::\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\":\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\".\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"=\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"and\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">()),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"begin\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.QUASI_COMMAND</span><span class=\"o\">)),</span>\n<span class=\"w\">      </span><span class=\"n\">//</span><span class=\"o\">(</span><span class=\"s\">\"imports\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.QUASI_COMMAND</span><span class=\"o\">)),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"text\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.DOCUMENT_BODY</span><span class=\"o\">)),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"fun\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.THY_DEFN</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"fun\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"datatype\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.THY_DEFN</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"datatype\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"definition\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.THY_DEFN</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"definition\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"theory\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.THY_DEFN</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"theory\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"proof\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.PRF_GOAL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"proof\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"lemma\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.PRF_GOAL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"lemma\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"qed\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.QED</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"qed\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"by\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.PRF_ASM_GOAL</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"by\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"next\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.NEXT_BLOCK</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"next\"</span><span class=\"o\">))),</span>\n<span class=\"w\">      </span><span class=\"o\">(</span><span class=\"s\">\"end\"</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">Keyword.Spec</span><span class=\"o\">(</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Keyword.THY_DEFN</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">tags</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">(</span><span class=\"s\">\"end\"</span><span class=\"o\">)))</span>\n<span class=\"w\">      </span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"n\">//</span><span class=\"w\"> </span><span class=\"n\">Setup</span><span class=\"w\"> </span><span class=\"k\">syntax</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">common</span><span class=\"w\"> </span><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"kp\">keywords</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">thy_syntax</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Outer_Syntax.empty.add_keywords</span><span class=\"o\">(</span><span class=\"n\">thy_keywords</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"n\">//</span><span class=\"w\"> </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">parse</span><span class=\"w\"> </span><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">content</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">theory_content</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">File.read</span><span class=\"o\">(</span><span class=\"n\">thy_file</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">spans</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">thy_syntax.parse_spans</span><span class=\"o\">(</span><span class=\"n\">theory_content</span><span class=\"o\">)</span>\n\n\n<span class=\"w\">    </span><span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">thy_syntax.keywords</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">//</span><span class=\"w\"> </span><span class=\"n\">Separate</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"w\"> </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">proofs</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">spans.filter</span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">is_definition</span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"o\">,</span>\n<span class=\"n\">thy_syntax.keywords</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">proofs</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">spans.filter</span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">is_proof</span><span class=\"o\">(</span><span class=\"n\">span</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">thy_syntax.keywords</span><span class=\"o\">))</span>\n\n<span class=\"w\">    </span><span class=\"n\">//</span><span class=\"w\"> </span><span class=\"n\">Generate</span><span class=\"w\"> </span><span class=\"kp\">output</span><span class=\"w\"> </span><span class=\"n\">files</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">base_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">thy_file.expand.implode</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">def_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Path.explode</span><span class=\"o\">(</span><span class=\"n\">base_path.replaceAll</span><span class=\"o\">(</span><span class=\"s\">\"\\\\.thy$\"</span><span class=\"o\">,</span>\n<span class=\"s\">\"_definitions.thy\"</span><span class=\"o\">))</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"n\">proof_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Path.explode</span><span class=\"o\">(</span><span class=\"n\">base_path.replaceAll</span><span class=\"o\">(</span><span class=\"s\">\"\\\\.thy$\"</span><span class=\"o\">,</span>\n<span class=\"s\">\"_proofs.thy\"</span><span class=\"o\">))</span>\n\n<span class=\"w\">    </span><span class=\"n\">write_spans</span><span class=\"o\">(</span><span class=\"n\">def_path</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"o\">)</span>\n<span class=\"w\">    </span><span class=\"n\">write_spans</span><span class=\"o\">(</span><span class=\"n\">proof_path</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">proofs</span><span class=\"o\">)</span>\n\n<span class=\"w\">    </span><span class=\"n\">//</span><span class=\"w\"> </span><span class=\"n\">Report</span><span class=\"w\"> </span><span class=\"n\">results</span>\n<span class=\"w\">    </span><span class=\"n\">println</span><span class=\"o\">(</span><span class=\"n\">s\"\\nProcessed</span><span class=\"w\"> </span><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"kp\">file</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"ow\">{</span><span class=\"n\">thy_file</span><span class=\"ow\">}</span><span class=\"s\">\")</span>\n<span class=\"s\">    println(\"</span><span class=\"n\">Generated</span><span class=\"w\"> </span><span class=\"n\">files</span><span class=\"o\">:</span><span class=\"s\">\")</span>\n<span class=\"s\">    println(s\"</span><span class=\"w\">  </span><span class=\"n\">Definitions</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"ow\">{</span><span class=\"n\">def_path</span><span class=\"ow\">}</span><span class=\"s\">\")</span>\n<span class=\"s\">    println(s\"</span><span class=\"w\">  </span><span class=\"n\">Proofs</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"ow\">{</span><span class=\"n\">proof_path</span><span class=\"ow\">}</span><span class=\"s\">\")</span>\n<span class=\"s\">    println(s\"</span><span class=\"n\">\\nFound</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"ow\">{</span><span class=\"n\">definitions.length</span><span class=\"ow\">}</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"w\"> </span><span class=\"kp\">and</span><span class=\"w\"> </span><span class=\"n\">$</span><span class=\"ow\">{</span><span class=\"n\">proofs.length</span><span class=\"ow\">}</span>\n<span class=\"n\">proofs\"</span><span class=\"o\">)</span>\n<span class=\"w\">  </span><span class=\"ow\">}</span>\n<span class=\"ow\">}</span>\n</code></pre></div>",
        "id": 496994181,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738325704
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;</p>\n<p>On 1/31/25 13:14, lacramioara wrote:</p>\n<blockquote>\n<p>I need to split theory files into specs and proofs: definitions go to one file<br>\nand lemmas with their proofs in another. Makarius pointed me towards<br>\n<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some (incomplete)<br>\ncode running on simple theories such as the Fibonacci example presented in the<br>\ncode generation doc.</p>\n<p>What is not clear to me is if there is a \"right\" way to construct the mapping<br>\nfor the keywords to be added to Outer_Syntax.empty: apparently, i do not need<br>\nto include \"imports\" so i was wondering if there is a way to get rid of<br>\nenumerating all the tokens that might appear in theory files.</p>\n</blockquote>\n<p>Keywords and their kinds are specified by the theories themselves (the <br>\n'keywords' specification in the beginning, cf. <br>\n<a href=\"https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords\">https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords</a>); to parse <br>\na theory file, you have to read all theory headers (in the imports <br>\ngraph) first and collect the outer syntax.</p>\n<blockquote>\n<p>I would also<br>\nlike to see if my understanding is correct in that i can choose the mapping as<br>\nit best suits my needs. For instance, i classify \"lemma\" as having kind<br>\n\"PRF_GOAL\" just as a way to make it appear in <code>Keyword.proof</code>. Would this be<br>\nsomething not inline with the underlying philosophy of Isabelle/Scala?</p>\n</blockquote>\n<p>This would be like interpreting verbs as nouns as you are reading a <br>\ntext. I doubt that this is what you want to achieve, but you could do it.</p>\n<p>Fabian</p>",
        "id": 497013915,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738332239
    },
    {
        "content": "<p>From: Lacramioara Astefanoaei &lt;<a href=\"mailto:lacramioara.astefanoaei@gmail.com\">lacramioara.astefanoaei@gmail.com</a>&gt;<br>\nOn Fri, 31 Jan 2025 at 15:03, Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>On 1/31/25 13:14, lacramioara wrote:</p>\n<blockquote>\n<p>I need to split theory files into specs and proofs: definitions go to<br>\none file<br>\nand lemmas with their proofs in another. Makarius pointed me towards<br>\n<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some<br>\n(incomplete)<br>\ncode running on simple theories such as the Fibonacci example presented<br>\nin the<br>\ncode generation doc.</p>\n<p>What is not clear to me is if there is a \"right\" way to construct the<br>\nmapping<br>\nfor the keywords to be added to Outer_Syntax.empty: apparently, i do not<br>\nneed<br>\nto include \"imports\" so i was wondering if there is a way to get rid of<br>\nenumerating all the tokens that might appear in theory files.</p>\n</blockquote>\n<p>Keywords and their kinds are specified by the theories themselves (the<br>\n'keywords' specification in the beginning, cf.<br>\n<a href=\"https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords\">https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords</a>); to parse<br>\na theory file, you have to read all theory headers (in the imports<br>\ngraph) first and collect the outer syntax.</p>\n</blockquote>\n<p>Thank you for the pointer. I read there</p>\n<blockquote>\n<p>*Both minor keywords and major keywords of the Isar command language need<br>\nto be specified, in order to make parsing of proof documents work properly.<br>\n*</p>\n<p>which answers my question that there is no shortcut. (I still wonder why<br>\nthe parsing works in my case without me having to explicitly add the<br>\n\"imports\" keyword.)</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I would also<br>\nlike to see if my understanding is correct in that i can choose the<br>\nmapping as<br>\nit best suits my needs. For instance, i classify \"lemma\" as having kind<br>\n\"PRF_GOAL\" just as a way to make it appear in <code>Keyword.proof</code>. Would<br>\nthis be<br>\nsomething not inline with the underlying philosophy of Isabelle/Scala?</p>\n</blockquote>\n<p>This would be like interpreting verbs as nouns as you are reading a<br>\ntext. I doubt that this is what you want to achieve, but you could do it.<br>\n</p>\n</blockquote>\n<p>For the moment, the code i have achieves what i want in that it separates<br>\ndefinitions from lemmas and their proofs. I understand from your comparison<br>\nthat \"lemma\" shouldn't have kind \"PRF_GOAL\". What was somewhat implicit in<br>\nmy question was: where could one find the \"right\" kinds for keywords, as i<br>\ndid not find this information in the docs, while in the code the only<br>\nrelevant piece i found was <code>src/Pure/Thy/thy_header.scala</code>. I see now that<br>\ni can find examples of associatiations (keyword, kind) in what is generated<br>\nby <code>isabelle dump</code>. For instance, i see in the markup file for a toy<br>\ntheory: <code>accepted command_span name=lemma kind=thy_goal_stmt</code>.</p>\n<p>If i do a <code>pdfgrep -r \"thy_goal_stmt\" doc/</code> i find no results, so i<br>\nconclude that to get this information about the \"right\" mapping i just have<br>\nto extract it from the output of dump.</p>\n<p>Thank you for taking the time to respond,<br>\nLacramioara</p>\n<blockquote>\n<p>Fabian</p>\n</blockquote>",
        "id": 497147351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738401348
    },
    {
        "content": "<p>From: Lacramioara Astefanoaei &lt;<a href=\"mailto:lacramioara.astefanoaei@gmail.com\">lacramioara.astefanoaei@gmail.com</a>&gt;<br>\nOn Mon, 3 Feb 2025 at 10:31, Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>On 2/1/25 10:15, Lacramioara Astefanoaei wrote:</p>\n<p>On Fri, 31 Jan 2025 at 15:03, Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>On 1/31/25 13:14, lacramioara wrote:</p>\n<blockquote>\n<p>I need to split theory files into specs and proofs: definitions go to<br>\none file<br>\nand lemmas with their proofs in another. Makarius pointed me towards<br>\n<code>Outer_Syntax.scala</code>and, with the help of Copilot, i have some<br>\n(incomplete)<br>\ncode running on simple theories such as the Fibonacci example presented<br>\nin the<br>\ncode generation doc.</p>\n<p>What is not clear to me is if there is a \"right\" way to construct the<br>\nmapping<br>\nfor the keywords to be added to Outer_Syntax.empty: apparently, i do<br>\nnot need<br>\nto include \"imports\" so i was wondering if there is a way to get rid of<br>\nenumerating all the tokens that might appear in theory files.</p>\n</blockquote>\n<p>Keywords and their kinds are specified by the theories themselves (the<br>\n'keywords' specification in the beginning, cf.<br>\n<a href=\"https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords\">https://isabelle.in.tum.de/doc/isar-ref.pdf#keyword.keywords</a>); to parse<br>\na theory file, you have to read all theory headers (in the imports<br>\ngraph) first and collect the outer syntax.</p>\n</blockquote>\n<p>Thank you for the pointer. I read there</p>\n<blockquote>\n<p>*Both minor keywords and major keywords of the Isar command language need<br>\nto be specified, in order to make parsing of proof documents work properly.<br>\n*</p>\n<p>which answers my question that there is no shortcut. (I still wonder why<br>\nthe parsing works in my case without me having to explicitly add the<br>\n\"imports\" keyword.)</p>\n</blockquote>\n<p>The imports keyword is part of Pure and not part of the user-space, so it<br>\nis always part of the outer syntax.<br>\n</p>\n</blockquote>\n<p>I see, thank you!</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>I would also<br>\nlike to see if my understanding is correct in that i can choose the<br>\nmapping as<br>\nit best suits my needs. For instance, i classify \"lemma\" as having kind<br>\n\"PRF_GOAL\" just as a way to make it appear in <code>Keyword.proof</code>. Would<br>\nthis be<br>\nsomething not inline with the underlying philosophy of Isabelle/Scala?</p>\n</blockquote>\n<p>This would be like interpreting verbs as nouns as you are reading a<br>\ntext. I doubt that this is what you want to achieve, but you could do it.<br>\n</p>\n</blockquote>\n<p>For the moment, the code i have achieves what i want in that it separates<br>\ndefinitions from lemmas and their proofs. I understand from your comparison<br>\nthat \"lemma\" shouldn't have kind \"PRF_GOAL\". What was somewhat implicit in<br>\nmy question was: where could one find the \"right\" kinds for keywords, as i<br>\ndid not find this information in the docs, while in the code the only<br>\nrelevant piece i found was <code>src/Pure/Thy/thy_header.scala</code>. I see now that<br>\ni can find examples of associatiations (keyword, kind) in what is generated<br>\nby <code>isabelle dump</code>. For instance, i see in the markup file for a toy<br>\ntheory: <code>accepted command_span name=lemma kind=thy_goal_stmt</code>.</p>\n<p>If i do a <code>pdfgrep -r \"thy_goal_stmt\" doc/</code> i find no results, so i<br>\nconclude that to get this information about the \"right\" mapping i just have<br>\nto extract it from the output of dump.</p>\n<p>I am not sure if keyword kinds are explicitly documented anywhere;<br>\nhowever, I find the categories in Pure/Isar/keyword.scala very helpful to<br>\nunderstand them.</p>\n<p>You are right. (I was reusing the functionalities from <code>Keyword.scala</code> in<br>\nmy code, following the suggestions from Makarius.)<br>\nWhat i was missing was the mappings (span_name, span_kind) which, in the<br>\nend, i extracted from the YXML files generated by <code>isabelle dump</code>. These<br>\nmappings do exist, i've just found them in <code>src/Pure/Pure.thy</code> (previously,<br>\ni overlooked them as i was searching in scala files.). It would be amazing<br>\nif i could figure out how <code>Pure.thy</code> is used so that the mappings appear in<br>\nYXML files.</p>\n</blockquote>\n<blockquote>\n<p>Also note Tools/Find_Facts/src/thy_blocks.scala, which uses the keyword<br>\nkinds to parse the block structure of a theory.</p>\n<p>Thank you, yes, the code i have is a bit more verbose but basically works<br>\nlike your <code>span.is_of_kind(Keyword.&lt;x&gt;)</code>.</p>\n</blockquote>\n<blockquote>\n<p>Fabian<br>\n</p>\n</blockquote>",
        "id": 497437532,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738589905
    }
]