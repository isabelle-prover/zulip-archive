[
    {
        "content": "<p>From: Mikhail Mandrykin &lt;<a href=\"mailto:mandrykin@ispras.ru\">mandrykin@ispras.ru</a>&gt;<br>\nHello!</p>\n<p>Recently, I experimented with implementation of Isabelle proof methods, <br>\ncommands and proof elements to learn Isabelle internals more deeply as <br>\nwe plan to implement Isabelle commands and methods for our program <br>\nverification framework. At some point, I encountered quite puzzling <br>\nbehavior of commands <code>done</code>, <code>by</code> and <code>qed</code> with respect to implicit <br>\nexporting of the resulting goal state (actually, the protected initial <br>\nstatement as a theorem) into the outer context. I attached an example <br>\nexposing the various behaviors. The question is whether these various <br>\ndifferences in behavior are expected, especially the situation when the <br>\nproof is successfully finished inside jEdit, but then fails during build <br>\nby <code>isabelle build</code> command. I understand that normally Isabelle methods <br>\ndo not introduce local assumptions or fixed variables, so this seems not <br>\nreally critical (no intent to actually implement such methods for the <br>\nusers), but it would help with the general understanding to know whether <br>\nthis is totally unspecified to introduce those assumptions or is merely <br>\na pragmatic constraint</p>\n<p>Regards, Mikhail<br>\n<a href=\"/user_uploads/14278/Xf94rpXnfifd6fUP031etvnq/Bug.thy\">Bug.thy</a></p>",
        "id": 210418724,
        "sender_full_name": "Email Gateway",
        "timestamp": 1600362093
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 17/09/2020 19:00, Mikhail Mandrykin wrote:</p>\n<blockquote>\n<p>Recently, I experimented with implementation of Isabelle proof methods,<br>\ncommands and proof elements to learn Isabelle internals more deeply as we plan<br>\nto implement Isabelle commands and methods for our program verification<br>\nframework. At some point, I encountered quite puzzling behavior of commands<br>\n<code>done</code>, <code>by</code> and <code>qed</code> with respect to implicit exporting of the resulting<br>\ngoal state (actually, the protected initial statement as a theorem) into the<br>\nouter context. I attached an example exposing the various behaviors. The<br>\nquestion is whether these various differences in behavior are expected,<br>\nespecially the situation when the proof is successfully finished inside jEdit,<br>\nbut then fails during build by <code>isabelle build</code> command.</p>\n<p>I understand that&gt; normally Isabelle methods do not introduce local<br>\nassumptions or fixed<br>\nvariables, so this seems not really critical (no intent to actually implement<br>\nsuch methods for the users), but it would help with the general understanding<br>\nto know whether this is totally unspecified to introduce those assumptions or<br>\nis merely a pragmatic constraint</p>\n</blockquote>\n<p>Yes, proof methods cannot extend the logical context and expect to work properly.</p>\n<p>There are certain principles how proof contexts are constructed/deconstructed<br>\nby the Isar language, according to its structure. Some of this is explained in<br>\nthe \"implementation\" manual, but the general principle of survival is to do<br>\nthis in the \"usual way\", e.g. by looking at existing implementations in the<br>\nsources.</p>\n<p>Your theory \"Bug\" looks very non-standard in various respects. Can you say,<br>\nwhat you are actually trying to do?</p>\n<p>Makarius</p>",
        "id": 215973640,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604783396
    },
    {
        "content": "<p>From: Mikhail Mandrykin &lt;<a href=\"mailto:mandrykin@ispras.ru\">mandrykin@ispras.ru</a>&gt;<br>\nHello,</p>\n<blockquote>\n<p>Your theory \"Bug\" looks very non-standard in various respects. Can you <br>\nsay,<br>\nwhat you are actually trying to do?</p>\n</blockquote>\n<p>Actually, I was preparing a small Isabelle/ML programing tutorial for <br>\nrelatively experienced functional programmers (in Haskell and OCaml), <br>\nprimarily for internal use, to emphasize the features that are needed to <br>\nimplement custom proof methods. The tutorial was meant to be very <br>\npractically-oriented and so consisted of a set of example <br>\nimplementations that would use only the interfaces from a documented set <br>\nof ML interfaces. So I proceeded in the following way: I just came up <br>\nwith a problem, implemented a solution and then documented all the <br>\ninterfaces used in the solution using the available documentation as <br>\nwell as the knowledge obtained from inspection of the sources during the <br>\nimplementation. As one of the final, more complex examples, I decided to <br>\nimplement a sample triple of a proof method, an Isar command and a local <br>\ncontext command to support introduction of obtained facts into the local <br>\ncontext that would also support goal refinement with obtained variables. <br>\nThis is not possible in Pure, but in HOL the Hilbert epsilon operator <br>\ncan be used to extract the corresponding witness. I actually implemented <br>\nthe tactic and the commands (attached the resulting sample theory as <br>\nProof_Context.thy) and they seem to work as expected, the simplest way <br>\nto observe them in action is in the schematic_goal wf_min'' that <br>\ndirectly refines the statement using the obtained epsilon-expressions. <br>\nHowever, I myself did not fully understand the limitations of the proof <br>\nmethods since they are actually context-tactics and can return a <br>\nmodified context as a result, but I had not found any real examples of <br>\nmethods that would alter the context in any way other than by <br>\nintroduction of cases. So indeed, the logical context is never modified, <br>\nonly the extra-logical part is changed. The sample method <br>\n<code>hilbert_guess</code> (in Proof_Context.thy) thus is not a proper method as it <br>\nbreaks this convention by introducing obtained facts into the logical <br>\ncontext. So when I tried to compile the resulting tutorial document I <br>\nexperienced the problems I described and decided to clarify whether this <br>\nis an intended limitation of proof methods, because in practice in many <br>\ncases extending the logical context with assumptions actually works (the <br>\nassumptions are exported by the <code>done</code>/<code>qed</code> commands). So because this <br>\nmethod is only intended as experimental exploratory code, this is not a <br>\nreal issue, the real methods we implemented so far (those that work in <br>\nauxiliary local contexts) all perform the export internally and only <br>\nalter the context for extra-logical purposes e.g. remembering a <br>\ncounterexample model extracted from an SMT solver (Z3). The repository <br>\nwith the tutorial is available at <br>\n<a href=\"https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks\">https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks</a> <br>\n. Currently, we switched to different parts of our framework <br>\n(implementing the shallow embedding and the translator), so the tutorial <br>\nis currently not actively used, but may soon be needed as constructing <br>\nthe embedding also requires the use of custom automated proofs.</p>\n<p>Regards, Mikhail</p>\n<p>Makarius писал 2020-11-08 00:09:</p>\n<blockquote>\n<p>On 17/09/2020 19:00, Mikhail Mandrykin wrote:</p>\n<blockquote>\n<p>Recently, I experimented with implementation of Isabelle proof <br>\nmethods,<br>\ncommands and proof elements to learn Isabelle internals more deeply as <br>\nwe plan<br>\nto implement Isabelle commands and methods for our program <br>\nverification<br>\nframework. At some point, I encountered quite puzzling behavior of <br>\ncommands<br>\n<code>done</code>, <code>by</code> and <code>qed</code> with respect to implicit exporting of the <br>\nresulting<br>\ngoal state (actually, the protected initial statement as a theorem) <br>\ninto the<br>\nouter context. I attached an example exposing the various behaviors. <br>\nThe<br>\nquestion is whether these various differences in behavior are <br>\nexpected,<br>\nespecially the situation when the proof is successfully finished <br>\ninside jEdit,<br>\nbut then fails during build by <code>isabelle build</code> command.</p>\n<p>I understand that&gt; normally Isabelle methods do not introduce local<br>\nassumptions or fixed<br>\nvariables, so this seems not really critical (no intent to actually <br>\nimplement<br>\nsuch methods for the users), but it would help with the general <br>\nunderstanding<br>\nto know whether this is totally unspecified to introduce those <br>\nassumptions or<br>\nis merely a pragmatic constraint</p>\n</blockquote>\n<p>Yes, proof methods cannot extend the logical context and expect to<br>\nwork properly.</p>\n<p>There are certain principles how proof contexts are <br>\nconstructed/deconstructed<br>\nby the Isar language, according to its structure. Some of this is <br>\nexplained in<br>\nthe \"implementation\" manual, but the general principle of survival is <br>\nto do<br>\nthis in the \"usual way\", e.g. by looking at existing implementations in <br>\nthe<br>\nsources.</p>\n<p>Your theory \"Bug\" looks very non-standard in various respects. Can you <br>\nsay,<br>\nwhat you are actually trying to do?</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/JMBjNFiHQnQTjBOmAn4tnEUs/Proof_Context.thy\">Proof_Context.thy</a></p>\n</blockquote>",
        "id": 215976861,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604788445
    },
    {
        "content": "<p>From: Mikhail Mandrykin &lt;<a href=\"mailto:mandrykin@ispras.ru\">mandrykin@ispras.ru</a>&gt;<br>\nMikhail Mandrykin писал 2020-11-08 01:33:</p>\n<blockquote>\n<p>The repository with the tutorial is available at<br>\n<a href=\"https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks\">https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks</a><br>\nSorry, it seems this link won't work, if anyone is interested I uploaded <br>\na mirror on GitHub at <a href=\"https://github.com/schrodibear/isabelle-tasks\">https://github.com/schrodibear/isabelle-tasks</a></p>\n</blockquote>\n<p>Mikhail</p>\n<blockquote>\n<p>Hello,</p>\n<blockquote>\n<p>Your theory \"Bug\" looks very non-standard in various respects. Can you <br>\nsay,<br>\nwhat you are actually trying to do?</p>\n</blockquote>\n<p>Actually, I was preparing a small Isabelle/ML programing tutorial for<br>\nrelatively experienced functional programmers (in Haskell and OCaml),<br>\nprimarily for internal use, to emphasize the features that are needed<br>\nto implement custom proof methods. The tutorial was meant to be very<br>\npractically-oriented and so consisted of a set of example<br>\nimplementations that would use only the interfaces from a documented<br>\nset of ML interfaces. So I proceeded in the following way: I just came<br>\nup with a problem, implemented a solution and then documented all the<br>\ninterfaces used in the solution using the available documentation as<br>\nwell as the knowledge obtained from inspection of the sources during<br>\nthe implementation. As one of the final, more complex examples, I<br>\ndecided to implement a sample triple of a proof method, an Isar<br>\ncommand and a local context command to support introduction of<br>\nobtained facts into the local context that would also support goal<br>\nrefinement with obtained variables. This is not possible in Pure, but<br>\nin HOL the Hilbert epsilon operator can be used to extract the<br>\ncorresponding witness. I actually implemented the tactic and the<br>\ncommands (attached the resulting sample theory as Proof_Context.thy)<br>\nand they seem to work as expected, the simplest way to observe them in<br>\naction is in the schematic_goal wf_min'' that directly refines the<br>\nstatement using the obtained epsilon-expressions. However, I myself<br>\ndid not fully understand the limitations of the proof methods since<br>\nthey are actually context-tactics and can return a modified context as<br>\na result, but I had not found any real examples of methods that would<br>\nalter the context in any way other than by introduction of cases. So<br>\nindeed, the logical context is never modified, only the extra-logical<br>\npart is changed. The sample method <code>hilbert_guess</code> (in<br>\nProof_Context.thy) thus is not a proper method as it breaks this<br>\nconvention by introducing obtained facts into the logical context. So<br>\nwhen I tried to compile the resulting tutorial document I experienced<br>\nthe problems I described and decided to clarify whether this is an<br>\nintended limitation of proof methods, because in practice in many<br>\ncases extending the logical context with assumptions actually works<br>\n(the assumptions are exported by the <code>done</code>/<code>qed</code> commands). So<br>\nbecause this method is only intended as experimental exploratory code,<br>\nthis is not a real issue, the real methods we implemented so far<br>\n(those that work in auxiliary local contexts) all perform the export<br>\ninternally and only alter the context for extra-logical purposes e.g.<br>\nremembering a counterexample model extracted from an SMT solver (Z3).<br>\nThe repository with the tutorial is available at<br>\n<a href=\"https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks\">https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks</a><br>\n. Currently, we switched to different parts of our framework<br>\n(implementing the shallow embedding and the translator), so the<br>\ntutorial is currently not actively used, but may soon be needed as<br>\nconstructing the embedding also requires the use of custom automated<br>\nproofs.</p>\n<p>Regards, Mikhail</p>\n<p>Makarius писал 2020-11-08 00:09:</p>\n<p>On 17/09/2020 19:00, Mikhail Mandrykin wrote:</p>\n<blockquote>\n<blockquote>\n<p>Recently, I experimented with implementation of Isabelle proof <br>\nmethods,<br>\ncommands and proof elements to learn Isabelle internals more deeply <br>\nas we plan<br>\nto implement Isabelle commands and methods for our program <br>\nverification<br>\nframework. At some point, I encountered quite puzzling behavior of <br>\ncommands<br>\n<code>done</code>, <code>by</code> and <code>qed</code> with respect to implicit exporting of the <br>\nresulting<br>\ngoal state (actually, the protected initial statement as a theorem) <br>\ninto the<br>\nouter context. I attached an example exposing the various behaviors. <br>\nThe<br>\nquestion is whether these various differences in behavior are <br>\nexpected,<br>\nespecially the situation when the proof is successfully finished <br>\ninside jEdit,<br>\nbut then fails during build by <code>isabelle build</code> command.</p>\n<p>I understand that&gt; normally Isabelle methods do not introduce local<br>\nassumptions or fixed<br>\nvariables, so this seems not really critical (no intent to actually <br>\nimplement<br>\nsuch methods for the users), but it would help with the general <br>\nunderstanding<br>\nto know whether this is totally unspecified to introduce those <br>\nassumptions or<br>\nis merely a pragmatic constraint</p>\n</blockquote>\n<p>Yes, proof methods cannot extend the logical context and expect to<br>\nwork properly.</p>\n<p>There are certain principles how proof contexts are <br>\nconstructed/deconstructed<br>\nby the Isar language, according to its structure. Some of this is <br>\nexplained in<br>\nthe \"implementation\" manual, but the general principle of survival is <br>\nto do<br>\nthis in the \"usual way\", e.g. by looking at existing implementations <br>\nin the<br>\nsources.</p>\n<p>Your theory \"Bug\" looks very non-standard in various respects. Can you <br>\nsay,<br>\nwhat you are actually trying to do?</p>\n<p>Makarius</p>\n</blockquote>\n</blockquote>",
        "id": 215977463,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604789647
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 07/11/2020 23:33, Mikhail Mandrykin wrote:</p>\n<blockquote>\n<p>However, I myself did<br>\nnot fully understand the limitations of the proof methods since they are<br>\nactually context-tactics and can return a modified context as a result, but I<br>\nhad not found any real examples of methods that would alter the context in any<br>\nway other than by introduction of cases. So indeed, the logical context is<br>\nnever modified, only the extra-logical part is changed.</p>\n</blockquote>\n<p>That is indeed an important observation, both for this concrete situation and<br>\nas a general principle in Isabelle: things that are never done (or only in odd<br>\nexceptional situations) can lead to undefined behaviour.</p>\n<p>Put to the extreme, you can do almost arbitrary non-sense with Isabelle,<br>\nespecially in conjunction with logical operations where the programming<br>\ninterfaces cannot guarantee the structural integrity of the concepts behind<br>\nit: A theorem might be a theorem, but it could be non-sense or break other<br>\ntools or infrastructure (like Isar proof language elements).</p>\n<blockquote>\n<p>The<br>\nrepository with the tutorial is available at<br>\n<a href=\"https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks\">https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks</a></p>\n</blockquote>\n<p>That seems to be non-public.</p>\n<p>Makarius</p>",
        "id": 215977729,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604790186
    },
    {
        "content": "<p>From: Mikhail Mandrykin &lt;<a href=\"mailto:mandrykin@ispras.ru\">mandrykin@ispras.ru</a>&gt;</p>\n<blockquote>\n<p>Could you please fix your Isabelle theory?</p>\n</blockquote>\n<p>In Isabelle2020 it seems to be slight incompatibility in the definition <br>\nof <code>asym</code> inductive predicate in <code>Relation.thy</code>: it was simplified in <br>\nthe development version (would-be 2021) by removing an extra premise <br>\n<code>irrefl R</code>, which causes the failure. I pushed a fix into <code>Isabelle2020</code> <br>\ncompatibility branch</p>\n<p>Mikhail</p>\n<p>Buday Gergely писал 2020-11-09 12:29:</p>\n<blockquote>\n<p>I cloned your github repository and ran</p>\n<p>isabelle build -D .</p>\n<p>to get</p>\n<p>Running Tasks ...<br>\nTasks FAILED<br>\n(see also<br>\nC:\\Users\\EKE\\.isabelle\\Isabelle2020\\heaps\\polyml-5.8.1_x86_64_32-windows\\log\\Tasks)<br>\n\\&lt;Longrightarrow&gt; ?thesis<br>\n\\&lt;lbrakk&gt;bij ?f;<br>\n \\&lt;And&gt;x.<br>\n    \\&lt;lbrakk&gt;?y = ?f x;<br>\n     \\&lt;And&gt;x'. ?y = ?f x' \\&lt;Longrightarrow&gt; x' = x\\&lt;rbrakk&gt;<br>\n    \\&lt;Longrightarrow&gt; ?thesis\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; ?thesis</p>\n<p>Could you please fix your Isabelle theory?</p>\n<ul>\n<li>Gergely</li>\n</ul>\n<p>11/7/2020 11:53 PM keltezéssel, Mikhail Mandrykin írta:</p>\n<blockquote>\n<p>Mikhail Mandrykin писал 2020-11-08 01:33:</p>\n<blockquote>\n<p>The repository with the tutorial is available at<br>\n<a href=\"https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks\">https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks</a><br>\nSorry, it seems this link won't work, if anyone is interested I <br>\nuploaded a mirror on GitHub at <br>\n<a href=\"https://github.com/schrodibear/isabelle-tasks\">https://github.com/schrodibear/isabelle-tasks</a></p>\n</blockquote>\n<p>Mikhail</p>\n<blockquote>\n<p>Hello,</p>\n<blockquote>\n<p>Your theory \"Bug\" looks very non-standard in various respects. Can <br>\nyou say,<br>\nwhat you are actually trying to do?</p>\n</blockquote>\n<p>Actually, I was preparing a small Isabelle/ML programing tutorial for<br>\nrelatively experienced functional programmers (in Haskell and OCaml),<br>\nprimarily for internal use, to emphasize the features that are needed<br>\nto implement custom proof methods. The tutorial was meant to be very<br>\npractically-oriented and so consisted of a set of example<br>\nimplementations that would use only the interfaces from a documented<br>\nset of ML interfaces. So I proceeded in the following way: I just <br>\ncame<br>\nup with a problem, implemented a solution and then documented all the<br>\ninterfaces used in the solution using the available documentation as<br>\nwell as the knowledge obtained from inspection of the sources during<br>\nthe implementation. As one of the final, more complex examples, I<br>\ndecided to implement a sample triple of a proof method, an Isar<br>\ncommand and a local context command to support introduction of<br>\nobtained facts into the local context that would also support goal<br>\nrefinement with obtained variables. This is not possible in Pure, but<br>\nin HOL the Hilbert epsilon operator can be used to extract the<br>\ncorresponding witness. I actually implemented the tactic and the<br>\ncommands (attached the resulting sample theory as Proof_Context.thy)<br>\nand they seem to work as expected, the simplest way to observe them <br>\nin<br>\naction is in the schematic_goal wf_min'' that directly refines the<br>\nstatement using the obtained epsilon-expressions. However, I myself<br>\ndid not fully understand the limitations of the proof methods since<br>\nthey are actually context-tactics and can return a modified context <br>\nas<br>\na result, but I had not found any real examples of methods that would<br>\nalter the context in any way other than by introduction of cases. So<br>\nindeed, the logical context is never modified, only the extra-logical<br>\npart is changed. The sample method <code>hilbert_guess</code> (in<br>\nProof_Context.thy) thus is not a proper method as it breaks this<br>\nconvention by introducing obtained facts into the logical context. So<br>\nwhen I tried to compile the resulting tutorial document I experienced<br>\nthe problems I described and decided to clarify whether this is an<br>\nintended limitation of proof methods, because in practice in many<br>\ncases extending the logical context with assumptions actually works<br>\n(the assumptions are exported by the <code>done</code>/<code>qed</code> commands). So<br>\nbecause this method is only intended as experimental exploratory <br>\ncode,<br>\nthis is not a real issue, the real methods we implemented so far<br>\n(those that work in auxiliary local contexts) all perform the export<br>\ninternally and only alter the context for extra-logical purposes e.g.<br>\nremembering a counterexample model extracted from an SMT solver (Z3).<br>\nThe repository with the tutorial is available at<br>\n<a href=\"https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks\">https://forge.ispras.ru/projects/isabelle-tutorial/repository/isabelle-tasks</a> <br>\n. Currently, we switched to different parts of our framework<br>\n(implementing the shallow embedding and the translator), so the<br>\ntutorial is currently not actively used, but may soon be needed as<br>\nconstructing the embedding also requires the use of custom automated<br>\nproofs.</p>\n<p>Regards, Mikhail</p>\n<p>Makarius писал 2020-11-08 00:09:</p>\n<p>On 17/09/2020 19:00, Mikhail Mandrykin wrote:</p>\n<blockquote>\n<blockquote>\n<p>Recently, I experimented with implementation of Isabelle proof <br>\nmethods,<br>\ncommands and proof elements to learn Isabelle internals more deeply <br>\nas we plan<br>\nto implement Isabelle commands and methods for our program <br>\nverification<br>\nframework. At some point, I encountered quite puzzling behavior of <br>\ncommands<br>\n<code>done</code>, <code>by</code> and <code>qed</code> with respect to implicit exporting of the <br>\nresulting<br>\ngoal state (actually, the protected initial statement as a theorem) <br>\ninto the<br>\nouter context. I attached an example exposing the various <br>\nbehaviors. The<br>\nquestion is whether these various differences in behavior are <br>\nexpected,<br>\nespecially the situation when the proof is successfully finished <br>\ninside jEdit,<br>\nbut then fails during build by <code>isabelle build</code> command.</p>\n<p>I understand that&gt; normally Isabelle methods do not introduce local<br>\nassumptions or fixed<br>\nvariables, so this seems not really critical (no intent to actually <br>\nimplement<br>\nsuch methods for the users), but it would help with the general <br>\nunderstanding<br>\nto know whether this is totally unspecified to introduce those <br>\nassumptions or<br>\nis merely a pragmatic constraint</p>\n</blockquote>\n<p>Yes, proof methods cannot extend the logical context and expect to<br>\nwork properly.</p>\n<p>There are certain principles how proof contexts are <br>\nconstructed/deconstructed<br>\nby the Isar language, according to its structure. Some of this is <br>\nexplained in<br>\nthe \"implementation\" manual, but the general principle of survival <br>\nis to do<br>\nthis in the \"usual way\", e.g. by looking at existing implementations <br>\nin the<br>\nsources.</p>\n<p>Your theory \"Bug\" looks very non-standard in various respects. Can <br>\nyou say,<br>\nwhat you are actually trying to do?</p>\n<p>Makarius<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 216107835,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604938987
    },
    {
        "content": "<p>From: Buday Gergely via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nI cloned your github repository and ran</p>\n<p>isabelle build -D .</p>\n<p>to get</p>\n<p>Running Tasks ...<br>\nTasks FAILED<br>\n(see also <br>\nC:\\Users\\EKE\\.isabelle\\Isabelle2020\\heaps\\polyml-5.8.1_x86_64_32-windows\\log\\Tasks)<br>\n\\&lt;Longrightarrow&gt; ?thesis<br>\n\\&lt;lbrakk&gt;bij ?f;<br>\n  \\&lt;And&gt;x.<br>\n     \\&lt;lbrakk&gt;?y = ?f x;<br>\n      \\&lt;And&gt;x'. ?y = ?f x' \\&lt;Longrightarrow&gt; x' = x\\&lt;rbrakk&gt;<br>\n     \\&lt;Longrightarrow&gt; ?thesis\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; ?thesis</p>\n<p>Could you please fix your Isabelle theory?</p>\n<ul>\n<li>Gergely</li>\n</ul>\n<p>11/7/2020 11:53 PM keltezéssel, Mikhail Mandrykin írta:</p>",
        "id": 216191745,
        "sender_full_name": "Email Gateway",
        "timestamp": 1605003069
    }
]