[
    {
        "content": "<p>From: \"Devant, Pascal\" &lt;<a href=\"mailto:pascal.devant@rwth-aachen.de\">pascal.devant@rwth-aachen.de</a>&gt;<br>\nLately I have been working on a script that automatically runs sledgehammer on unproven lemmas in a given theory. The subcommand 'isabelle process' seemed to be sufficient for this purpose. And this is true if the only goal is to find proofs. However, when it comes to evaluating search times you quickly run into a problem with this approach because 'isabelle process' only returns the output of the underlaying poly process after its' termination.</p>\n<p>This \"output-after-termination\" behaviour has two unpleasant effects:</p>\n<ol>\n<li>There is no way to measure the actual search time of specific provers.</li>\n<li>A prover might find a proof fairly quick (e.g. after a few seconds) but the user will only get to see the proof ones all other provers have terminated. Since for most non-trivial lemmas there is almost always a prover that will run into a timeout. Hence the whole process is blocked for the set sledgehammer timeout.</li>\n</ol>\n<p>After some code inspection, I backtracked the described behaviour to the scala definition of 'result' in \"Pure/System/bash.scala\". In this definition Isabelle is waiting synchronously for the termination of the poly process by waiting for the result of \"File.read_lines\".</p>\n<p>To \"solve\" this behaviour I extended the given \"Process\" class in bash.scala by a modifed version of the existing \"result()\" method that reads the output stream of poly line by line and immediately redirects it to the console. After creating this method all that was left to do is using this method instead of \"result()\" in \"ml_process.scala\"<br>\nMy modifed version of the result method it attached below. It's most likly not a clean implementation since this is my first scala code but it works. (And this is what matters, I guess)</p>\n<p>Is there a special resason why this whole procedure is not made async in the current implementation of Isabelle?<br>\nIs there a chance that isabelle process will redirect the output of poly async in future versions of Isabelle, so I don't need to use my own \"patched\" version?</p>\n<p>Thanks for reading!</p>\n<p>Best regards,<br>\nPascal</p>\n<p>def logAsyncAndWaitForExit(<br>\n      progress_stdout: String =&gt; Unit = (_: String) =&gt; (),<br>\n      progress_stderr: String =&gt; Unit = (_: String) =&gt; (),<br>\n      progress_limit: Option[Long] = None,<br>\n      strict: Boolean = true): Process_Result =<br>\n    {<br>\n      stdin.close</p>\n<p>var out_lines = new ListBuffer[String]()<br>\n      Future.thread(\"async_stdout\") {<br>\n        while(true)<br>\n        {<br>\n          val line = stdout.readLine()<br>\n          if (line != null)<br>\n          {<br>\n            Console.println(line)</p>\n<p>this.synchronized {<br>\n              out_lines += line<br>\n            }<br>\n          }<br>\n        }<br>\n      }</p>\n<p>var err_lines = new ListBuffer[String]()<br>\n      Future.thread(\"async_stderr\") {<br>\n        while(true)<br>\n        {<br>\n          val line = stdout.readLine()<br>\n          if (line != null)<br>\n          {<br>\n            Console.println(line)</p>\n<p>this.synchronized {<br>\n              err_lines += line<br>\n            }<br>\n          }<br>\n        }<br>\n      }</p>\n<p>val rc =<br>\n        try { join }<br>\n        catch { case Exn.Interrupt() =&gt; terminate(); Exn.Interrupt.return_code }<br>\n      if (strict &amp;&amp; rc == Exn.Interrupt.return_code) throw Exn.Interrupt()</p>\n<p>Process_Result(rc, out_lines.toList, err_lines.toList, false, get_timing)<br>\n    }</p>",
        "id": 212906593,
        "sender_full_name": "Email Gateway",
        "timestamp": 1602320589
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 10/10/2020 00:43, Devant, Pascal wrote:</p>\n<blockquote>\n<p>Lately I have been working on a script that automatically runs sledgehammer on unproven lemmas in a given theory. The subcommand 'isabelle process' seemed to be sufficient for this purpose. And this is true if the only goal is to find proofs. However, when it comes to evaluating search times you quickly run into a problem with this approach because 'isabelle process' only returns the output of the underlaying poly process after its' termination.</p>\n<p>This \"output-after-termination\" behaviour has two unpleasant effects:<br>\n1. There is no way to measure the actual search time of specific provers.<br>\n2. A prover might find a proof fairly quick (e.g. after a few seconds) but the user will only get to see the proof ones all other provers have terminated. Since for most non-trivial lemmas there is almost always a prover that will run into a timeout. Hence the whole process is blocked for the set sledgehammer timeout.</p>\n</blockquote>\n<p>This old thread is still open, but it is about potential refinements for the<br>\nnext release, so an answer now is still on time.</p>\n<blockquote>\n<p>After some code inspection, I backtracked the described behaviour to the scala definition of 'result' in \"Pure/System/bash.scala\". In this definition Isabelle is waiting synchronously for the termination of the poly process by waiting for the result of \"File.read_lines\".</p>\n</blockquote>\n<p>I was at first confused by the proposed changes to Process.result, because the<br>\nexisting operation already supports incremental output via<br>\nprogress_stdout/progress_stderr.</p>\n<p>So here is my minor change to \"isabelle process\" for incremental output on<br>\nstdout/stderr (separately): <a href=\"https://isabelle-dev.sketis.net/rISABELLE6345cce0e576\">https://isabelle-dev.sketis.net/rISABELLE6345cce0e576</a></p>\n<blockquote>\n<p>Is there a special resason why this whole procedure is not made async in the current implementation of Isabelle?</p>\n</blockquote>\n<p>Historically, we used to have sophisticated interaction between the prover<br>\nprocess and Proof General / Emacs: it worked to some extent, but was more<br>\ndelicate and fragile than one would hope for.</p>\n<p>So with the emergence of Isabelle/PIDE process management and interaction<br>\nindependently of stdin/stdout/stderr, I downgraded old-fashioned processes to<br>\nbecome atomic functions (non-interactive). Only gradually, I added things like<br>\nprogress_stdout later on.</p>\n<p>Depending what you are actually trying to do, the above incremental<br>\nstdout/stderr stream might be OK for the purpose.</p>\n<p>More ambitious applications could work better with \"isabelle server\" and and<br>\nits explicit JSON message protocol: but that is some extra complexity. You<br>\ncould also try to implement your tool directly in Isabelle/Scala and use the<br>\nunderlying Headless.Session directly, without the extra JSON non-sense.</p>\n<p>There is quite some documentation on the server in the \"system\" manual,<br>\nchapter 4. For its Headless.Session, the \"isabelle dump\" tool may serve as<br>\ncanonical example.</p>\n<p>Note that you can browse Isabelle/Scala sources easily with IntelliJ IDEA,<br>\nusing the project generated by \"isabelle scala_project\" (see \"system\" manual<br>\nsection 5.5).</p>\n<p>Makarius</p>",
        "id": 215962414,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604766708
    }
]