[
    {
        "content": "<p>From: Alex Meyer &lt;<a href=\"mailto:alex153@outlook.lv\">alex153@outlook.lv</a>&gt;<br>\nHello!</p>\n<p>I am trying to find Isabelle code (parser and data structures for AST/abstract syntax trees) that can parse theory file (tree of loaded theory files) into in-memory structure like abstract syntax tree.</p>\n<p>It would be nice to have some quick pointers to the source files. All the details, of course, I am reading myself in source code and implementation/developer manuals (Isabelle Cookbook especially has chapters about parsing).</p>\n<p>So far I have found parser and AST structure for Pure:<br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Syntax/parser.ML\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Syntax/parser.ML</a><br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Syntax/ast.ML\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Syntax/ast.ML</a><br>\nand for complete theory files:<br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Isar/parse.ML\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Isar/parse.ML</a><br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Isar/local_theory.ML\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/Isar/local_theory.ML</a></p>\n<p>But I am trying to grasp the following 3 things:</p>\n<p>1) even the simplest theories contain infix commands that introduce new symbols with additionl grammatical rules with infix (even ToyLIst have them). Isar/parse.ML has commands for processing infix/mixfix - am I right that parse.ML tries to do such parsing in 2 steps: 1) builds extended grammar which includes additional grammatical rules from infix commands; 2) parses original theory file with extended grammar in the second pass?</p>\n<p>2) one usually works with trees fo theory files. Is Isar/parse.ML the top level parser that loads most specific theory file and and constructs the instance of Isar/local_theory.ML. And when use request to load the base theory files, then Isar/parse.ML can decorate/extende Isar/local_theory.ML instance with the additional branches/leaves that correspond to the data in the base files?</p>\n<p>3) Is parsing (the trees of theory files) really so simple? Or I am on the wrong path?<br>\nI had the question with similar ideas but with different technologies in mind last summer: <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2020-July/msg00025.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2020-July/msg00025.html</a> and I was strongly discouraged from such parsing and in-memory manipulation of theory files.<br>\nBut now - as I am looking on the Isabelle code - it seems to me that such parsing can be done with src/Pure/Isar code and arriving at the in-memory theory representation is not that hard? Or I am wrong?</p>\n<p>My intention is to have full control over the representation and manipulation of the code in theory files:<br>\n1) maybe I would like to parse or generate thy files with the grammatical framework, e.g., translate the sentence in natural language into thy file (similar efforts have been done in Coq). Just for the purposes of representation and open-ended deduction, no need to have certified proofs.<br>\n2) maybe I would like to preprocess code of theory files for the processing with neural networks in the style of <a href=\"https://arxiv.org/abs/2006.09265\">https://arxiv.org/abs/2006.09265</a> I have no clear thought yet, but I guess that this research can be extended if I can have full controle for the in-memory structurs of theory files.</p>\n<p>So - it would be nice to have some pointers. Just pointers, all remaining I will explore myself.</p>\n<p>I am sure that I will managed to do this, but pointers can make some shortcuts.</p>\n<p>Thanks,<br>\nAlex</p>",
        "id": 224559406,
        "sender_full_name": "Email Gateway",
        "timestamp": 1611972069
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 30/01/2021 03:00, Alex Meyer wrote:</p>\n<blockquote>\n<p>My intention is to have full control over the representation and manipulation<br>\nof the code in theory files:<br>\n1) maybe I would like to parse or generate thy files with the grammatical<br>\nframework, e.g., translate the sentence in natural language into thy file<br>\n(similar efforts have been done in Coq). Just for the purposes of<br>\nrepresentation and open-ended deduction, no need to have certified proofs.<br>\n2) maybe I would like to preprocess code of theory files for the processing<br>\nwith neural networks in the style of <a href=\"https://arxiv.org/abs/2006.09265\">https://arxiv.org/abs/2006.09265</a> I have<br>\nno clear thought yet, but I guess that this research can be extended if I can<br>\nhave full controle for the in-memory structurs of theory files.</p>\n</blockquote>\n<p>This \"full control\" is not going to work: Isabelle cannot be put into a box<br>\nlike that, it is far too flexible and powerful.</p>\n<p>The language of Isabelle is an open-ended framework for arbitrary semantic<br>\nembeddings, usually implemented in Isabelle/ML. Over the decades, I have<br>\nprovided means to \"tap\" some aspects of the internal representation of<br>\nIsabelle languages, with external markup in Isabelle/PIDE.</p>\n<blockquote>\n<p>I had the question with similar ideas but with different technologies in mind<br>\nlast summer:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2020-July/msg00025.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2020-July/msg00025.html</a><br>\nand I was strongly discouraged from such parsing and in-memory manipulation of<br>\ntheory files.</p>\n</blockquote>\n<p>That thread already provides good answers. In short: don't do it, but change<br>\nyour perspective on the problem.</p>\n<blockquote>\n<p>So - it would be nice to have some pointers. Just pointers, all remaining I<br>\nwill explore myself.</p>\n</blockquote>\n<p><a href=\"https://github.com/Deducteam/isabelle_dedukti\">https://github.com/Deducteam/isabelle_dedukti</a><br>\n<a href=\"https://github.com/UniFormal/MMT\">https://github.com/UniFormal/MMT</a><br>\n<a href=\"https://github.com/qaware/isabelle-afp-search\">https://github.com/qaware/isabelle-afp-search</a></p>\n<p>At the bottom of these tools there are two different approaches:</p>\n<p>(1) heavy headless PIDE session (as in \"isabelle dump\"): one big<br>\nIsabelle/ML/Scala process to crunch everything and export certain aspects</p>\n<p>(2) session build + export database (as in \"isabelle export\" or<br>\nIsabelle/Dedukti above): this is a regular \"isabelle build\" with certain options</p>\n<p>Generally note that the proper language for \"Isabelle systems programming\" is<br>\nIsabelle/Scala: not funny scripting languages like Python.</p>\n<p>The Isabelle/Dedukti application shows how to wrap rather simple Scala modules<br>\ninto Isabelle command line tools. That is for Isabelle2020, but it should be<br>\neasy to adapt to Isabelle2021 which will appear within approx. 2 weeks.</p>\n<p>Makarius</p>",
        "id": 225010753,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612357133
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Alex,</p>\n<blockquote>\n<p>2) maybe I would like to preprocess code of theory files for the processing with neural networks in the style of <a href=\"https://arxiv.org/abs/2006.09265\">https://arxiv.org/abs/2006.09265</a> &lt;<a href=\"https://arxiv.org/abs/2006.09265\">https://arxiv.org/abs/2006.09265</a>&gt; I have no clear thought yet, but I guess that this research can be extended if I can have full controle for the in-memory structurs of theory files.</p>\n</blockquote>\n<p>Regarding <a href=\"https://arxiv.org/abs/2006.09265\">https://arxiv.org/abs/2006.09265</a>, I was writing a parser for .thy files in Python to extract information. The code should be available from the supplementary material of the ICLR submission (<a href=\"https://openreview.net/forum?id=Pzj6fzU6wkj\">https://openreview.net/forum?id=Pzj6fzU6wkj</a> &lt;<a href=\"https://openreview.net/forum?id=Pzj6fzU6wkj\">https://openreview.net/forum?id=Pzj6fzU6wkj</a>&gt;). The framework is hacky and fragile but may be OK for early experimentation or quick prototyping. Feel free to reuse it as you see fit.</p>\n<p>For serious and robust development, I, too, believe the Isabelle/Scala interface is the best option. Dominiqueâ€™s scala-isabelle library (<a href=\"https://github.com/dominique-unruh/scala-isabelle\">https://github.com/dominique-unruh/scala-isabelle</a> &lt;<a href=\"https://github.com/dominique-unruh/scala-isabelle\">https://github.com/dominique-unruh/scala-isabelle</a>&gt;) could be of great use.</p>\n<p>Wenda</p>",
        "id": 225346450,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612553998
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI still don't understand the purpose of it.</p>\n<p>Why not use Isabelle/Scala directly, it is an integral part of Isabelle?</p>\n<p>Makarius</p>",
        "id": 225348646,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612555111
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nSorry for the confusion I caused, Makarius. I was referring to the scala-isabelle library as an example of interacting with Isabelle through a Scala interface. Depending on one's needs, using Isabelle/Scala directly could, of course, be the idiomatic solution.</p>\n<p>Wenda</p>",
        "id": 225355519,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612558618
    }
]