[
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nI am running Isabelle2021-RC1 under Ubuntu 20.04.  Is there any way to limit the memory use<br>\nof the \"veriT\" prover?  It seems not to be a very good citizen in this respect: when it is<br>\nrun from the \"try\" command it seems willing to grow its address space even to significantly<br>\nexceed the total amount of system RAM.  For example, I just observed a virtual address space<br>\nof 37.8GB on a system with 32GB total RAM and of course Java, poly, and various other things<br>\nwere also running, so this is unsupportable.  When this occurs, the system is sent into a<br>\nthrashing mode, from which it is difficult even to get back control of the desktop so that<br>\nthe offending process can be identified and killed.  So some ability to impose a limit is<br>\nneeded here.</p>",
        "id": 221715994,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609889365
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi Eugene,</p>\n<p>I never use \"try\", so I need some more information:</p>\n<ul>\n<li>\n<p>Are you talking about one veriT thread  that used so much memory or <br>\nmore than one veriT thread?</p>\n</li>\n<li>\n<p>on what theory was this? I would like to reproduce that.</p>\n</li>\n<li>\n<p>What was the real memory usage? Virtual memory is pretty meaningless: <br>\nI have a program that has a virtual memory usage of 256G but uses only 9M...</p>\n</li>\n</ul>\n<p>If the trashing is not too hard to reproduce:</p>\n<ul>\n<li>Does it still happen if you deactivate veriT in sledgehammer by adding:<p>ML ‹<br>\n  fun verit_rm_stgy f stgy thy =<br>\n     let<br>\n       val ctxt' = f (Proof_Context.init_global thy);<br>\n       val thy' = Proof_Context.theory_of ctxt';<br>\n     in Context.theory_map (Verit_Proof.verit_rm_stgy stgy) thy' end;<br>\n  ›</p>\n<p>setup ‹fold (verit_rm_stgy (fn x=&gt; x)) [\"del_insts\", \"ccfv_SIG\",<br>\n  \"ccfv_threshold\", \"default\", \"best\"]›</p>\n<p>ML ‹Verit_Proof.all_veriT_stgies (Context.Proof @{context})›<br>\n  (<em>should print: val it = []: string list</em>)</p>\n</li>\n</ul>\n<p>at the top of the file?</p>\n<ul>\n<li>If the previous point works, does it still happen if you deactivate <br>\nall but one veriT strategy in sledgehammer, by adding:<p>ML ‹<br>\n  fun verit_rm_stgy f stgy thy =<br>\n     let<br>\n       val ctxt' = f (Proof_Context.init_global thy);<br>\n       val thy' = Proof_Context.theory_of ctxt';<br>\n     in Context.theory_map (Verit_Proof.verit_rm_stgy stgy) thy' end;<br>\n  ›</p>\n<p>setup ‹fold (verit_rm_stgy (fn x=&gt; x)) [\"del_insts\", \"ccfv_SIG\",<br>\n  \"ccfv_threshold\", \"default\"]›</p>\n<p>ML ‹Verit_Proof.all_veriT_stgies (Context.Proof @{context})›<br>\n  (<em>should print: val it = [\"best\"]: string list</em>)</p>\n</li>\n</ul>\n<p>at the top of the file?</p>\n<p>Thanks,</p>\n<p>Mathias</p>",
        "id": 221743907,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609921814
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nOn 1/6/21 3:29 AM, Mathias Fleury wrote:</p>\n<blockquote>\n<p>Hi Eugene,</p>\n<p>I never use \"try\", so I need some more information:</p>\n<ul>\n<li>Are you talking about one veriT thread  that used so much memory or more than one veriT thread?</li>\n</ul>\n</blockquote>\n<p>I am not sure that I understand this question.  Threads share a single address space, so the amount of memory used<br>\nis not a property of a single thread, but of a process.  If you are asking about processes, then it was one veriT<br>\nprocess.  I did not check how many threads were part of that process.</p>\n<blockquote>\n<ul>\n<li>on what theory was this? I would like to reproduce that.</li>\n</ul>\n</blockquote>\n<p>It is not easy for me to supply any kind of simple theory with straightforward instructions for reproducing,<br>\nbut the next time it happens I will see if I can reproduce by using the same \"try\" in the same context.</p>\n<blockquote>\n<ul>\n<li>What was the real memory usage? Virtual memory is pretty meaningless: I have a program that has a virtual memory usage<br>\nof 256G but uses only 9M...<br>\n</li>\n</ul>\n</blockquote>\n<p>Again, I don't know what you mean by \"real memory usage\".  Unless a program uses some tricks such as sparse<br>\naddress spaces (which can be useful in some kind of in-memory database situations), the virtual memory will be the<br>\nsum of the code, data, heap and stack sizes.  Code and read-only data can be shared between processes, but this is<br>\nnot an issue here because there is only one veriT process, and I don't think any shared libraries used would be<br>\ncontributing to the issue.  The usage in question is almost certainly dynamic memory usage; i.e. heap.</p>\n<p>Linux utilities such as \"top\" and \"ps\" do report \"virtual size\" and \"resident-set size\".  The resident-set size<br>\nwould be the amount of actual RAM currently in use by the process.  This number is obviously limited by the<br>\namount of installed RAM and once it reaches a certain level there can essentially not be any further increases,<br>\nthough the size of the virtual address space can continue to increase if there is available swap.<br>\nIn the case of the example I cited, the RSS reached about 26GB, which took up enough of the system RAM so that<br>\nthere was severe thrashing.</p>\n<blockquote>\n<p>If the trashing is not too hard to reproduce:</p>\n<ul>\n<li>Does it still happen if you deactivate veriT in sledgehammer by adding:<p>ML ‹<br>\n  fun verit_rm_stgy f stgy thy =<br>\n    let<br>\n      val ctxt' = f (Proof_Context.init_global thy);<br>\n      val thy' = Proof_Context.theory_of ctxt';<br>\n    in Context.theory_map (Verit_Proof.verit_rm_stgy stgy) thy' end;<br>\n  ›</p>\n<p>setup ‹fold (verit_rm_stgy (fn x=&gt; x)) [\"del_insts\", \"ccfv_SIG\", \"ccfv_threshold\", \"default\", \"best\"]›</p>\n<p>ML ‹Verit_Proof.all_veriT_stgies (Context.Proof @{context})›<br>\n  (<em>should print: val it = []: string list</em>)</p>\n</li>\n</ul>\n<p>at the top of the file?</p>\n<ul>\n<li>If the previous point works, does it still happen if you deactivate all but one veriT strategy in sledgehammer, by adding:<p>ML ‹<br>\n  fun verit_rm_stgy f stgy thy =<br>\n    let<br>\n      val ctxt' = f (Proof_Context.init_global thy);<br>\n      val thy' = Proof_Context.theory_of ctxt';<br>\n    in Context.theory_map (Verit_Proof.verit_rm_stgy stgy) thy' end;<br>\n  ›</p>\n<p>setup ‹fold (verit_rm_stgy (fn x=&gt; x)) [\"del_insts\", \"ccfv_SIG\", \"ccfv_threshold\", \"default\"]›</p>\n<p>ML ‹Verit_Proof.all_veriT_stgies (Context.Proof @{context})›<br>\n  (<em>should print: val it = [\"best\"]: string list</em>)</p>\n</li>\n</ul>\n<p>at the top of the file?</p>\n</blockquote>\n<p>I can try this, but do not know if/when I will be able to report on results, since the situation is not<br>\ndeterministically reproducible at this time.</p>\n<blockquote>\n<p>Thanks,</p>\n<p>Mathias</p>\n<p>On 06/01/2021 00:28, Eugene W. Stark wrote:</p>\n<blockquote>\n<p>I am running Isabelle2021-RC1 under Ubuntu 20.04.  Is there any way to limit the memory use<br>\nof the \"veriT\" prover?  It seems not to be a very good citizen in this respect: when it is<br>\nrun from the \"try\" command it seems willing to grow its address space even to significantly<br>\nexceed the total amount of system RAM.  For example, I just observed a virtual address space<br>\nof 37.8GB on a system with 32GB total RAM and of course Java, poly, and various other things<br>\nwere also running, so this is unsupportable.  When this occurs, the system is sent into a<br>\nthrashing mode, from which it is difficult even to get back control of the desktop so that<br>\nthe offending process can be identified and killed.  So some ability to impose a limit is<br>\nneeded here.</p>\n</blockquote>\n</blockquote>",
        "id": 221755081,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609931033
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nOne additional data point:  The excessive memory consumption issue is not limited to sledgehammer --<br>\nit can occur even when there is simply a use in an Isar proof of smt that specifies \"verit\".<br>\nThe problem does not occur with proofs that already succeed in a short period of time; it happens when<br>\nyou invalidate some portion of the proof by editing, so that the particular smt proof doesn't work<br>\nany more.  This means that you can spam your whole session (if not your whole computer) if you happen<br>\nto make some changes that trigger uncontrolled memory use by veriT in subsequent proofs that<br>\nused to work before you made the changes.</p>\n<p>This is very much making me want a way to limit the memory use, otherwise I have to figure out how to<br>\ndisable veriT completely.</p>",
        "id": 222241667,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610312206
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi Eugene,</p>\n<p>I believe that there are two different problems here:</p>\n<ol>\n<li>\n<p>tactics running forever and using a lot of memory. This already<br>\n    happens with metis or blast. However, this behavior might be new for<br>\n    smt, because the smt_timeout was disabled<br>\n    (<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/478b7599a1a0\">http://isabelle.in.tum.de/repos/isabelle/rev/478b7599a1a0</a>) and smt<br>\n    solver are a lot more powerful than metis/blast. This is not<br>\n    specific to veriT and can happen with Z3 too.</p>\n<p>*   Solution: Set the smt_timeout to some reasonable value.</p>\n</li>\n<li>\n<p>the Sledgehammer problem that I cannot reproduce. It is hard to know<br>\n    what is really happening here, because I would not be surprised that<br>\n    the problem is actually the opposite: Isabelle uses tons of memory<br>\n    and is not able to kill veriT within the timeout and, therefore,<br>\n    veriT has a lot more time to use memory.</p>\n</li>\n</ol>\n<p>The motivation for 1 is avoiding timeouts that are hardware dependent <br>\n(e.g., if you run things on a raspberry pi).</p>\n<p>For 2, can you give me the ouput of the sledgehammer_params command?</p>\n<p>Mathias</p>",
        "id": 222266264,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610350136
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nMetis and blast run in ML, so are limited by the size of the ML heap.  Poly accepts a parameter that allows<br>\nyou to limit the size of the ML heap.  Similarly, Java accepts a parameter that allows you to limit the size<br>\nof its heap.  The problem here is that now there are additional processes getting fired off that can consume<br>\nmemory voraciously, and there is no way to limit it.  There is only a certain amount of RAM on the system,<br>\nand if each process uses as much as it wants with no limitation, then the RAM will become overcommitted and<br>\nthe system unstable.  It would be best if there were a single limit to the total amount of memory used by<br>\nall Isabelle-related processes, but that is a more complex thing to implement and a fallback is to make it<br>\npossible to place limits on the less-essential tools (e.g. smt solvers) that can cause trouble.</p>",
        "id": 222298968,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610373188
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi Eugene,</p>\n<p>On 11/01/2021 14:52, Eugene W. Stark wrote:</p>\n<blockquote>\n<blockquote>\n<p>Default parameters for Sledgehammer:<br>\n...<br>\nprovers = cvc4 vampire z3 e</p>\n</blockquote>\n</blockquote>\n<p>This indicates that veriT is not called by Sledgehammer as a prover <br>\nbackend. So problem 2 does not exist for you.</p>\n<blockquote>\n<p>Metis and blast run in ML, so are limited by the size of the ML heap.  Poly accepts a parameter that allows<br>\nyou to limit the size of the ML heap.  Similarly, Java accepts a parameter that allows you to limit the size<br>\nof its heap.  The problem here is that now there are additional processes getting fired off that can consume<br>\nmemory voraciously, and there is no way to limit it.  There is only a certain amount of RAM on the system,<br>\nand if each process uses as much as it wants with no limitation, then the RAM will become overcommitted and<br>\nthe system unstable.  It would be best if there were a single limit to the total amount of memory used by<br>\nall Isabelle-related processes, but that is a more complex thing to implement and a fallback is to make it<br>\npossible to place limits on the less-essential tools (e.g. smt solvers) that can cause trouble.</p>\n</blockquote>\n<p>You never have to use smt in your development (that might cripple <br>\nSledgehammer however).</p>\n<p>Anyway, unless you find a way to replicate the issue, I believe that <br>\nsetting the smt_timeout solves the problem and that no change is <br>\nrequired in Isabelle.</p>\n<p>Thanks for the report,</p>\n<p>Mathias</p>\n<blockquote>\n<p>On 1/11/21 2:28 AM, Mathias Fleury wrote:</p>\n<blockquote>\n<p>Hi Eugene,</p>\n<p>I believe that there are two different problems here:</p>\n<p>1. tactics running forever and using a lot of memory. This already happens with metis or blast. However, this behavior<br>\n     might be new for smt, because the smt_timeout was disabled<br>\n     (<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/478b7599a1a0\">http://isabelle.in.tum.de/repos/isabelle/rev/478b7599a1a0</a>) and smt solver are a lot more powerful than metis/blast.<br>\n     This is not specific to veriT and can happen with Z3 too.<br>\n       *  Solution: Set the smt_timeout to some reasonable value.</p>\n<p>2. the Sledgehammer problem that I cannot reproduce. It is hard to know what is really happening here, because I would<br>\n     not be surprised that the problem is actually the opposite: Isabelle uses tons of memory and is not able to kill<br>\n     veriT within the timeout and, therefore, veriT has a lot more time to use memory.</p>\n<p>The motivation for 1 is avoiding timeouts that are hardware dependent (e.g., if you run things on a raspberry pi).</p>\n<p>For 2, can you give me the ouput of the sledgehammer_params command?</p>\n<p>Mathias</p>\n</blockquote>\n<p>On 10/01/2021 21:56, Eugene W. Stark wrote:</p>\n<blockquote>\n<blockquote>\n<p>One additional data point:  The excessive memory consumption issue is not limited to sledgehammer --<br>\nit can occur even when there is simply a use in an Isar proof of smt that specifies \"verit\".<br>\nThe problem does not occur with proofs that already succeed in a short period of time; it happens when<br>\nyou invalidate some portion of the proof by editing, so that the particular smt proof doesn't work<br>\nany more.  This means that you can spam your whole session (if not your whole computer) if you happen<br>\nto make some changes that trigger uncontrolled memory use by veriT in subsequent proofs that<br>\nused to work before you made the changes.</p>\n<p>This is very much making me want a way to limit the memory use, otherwise I have to figure out how to<br>\ndisable veriT completely.</p>\n</blockquote>\n<p>On 1/6/21 6:03 AM, Eugene W. Stark wrote:</p>\n<blockquote>\n<blockquote>\n<p>On 1/6/21 3:29 AM, Mathias Fleury wrote:</p>\n<blockquote>\n<p>Hi Eugene,</p>\n<p>I never use \"try\", so I need some more information:</p>\n<ul>\n<li>Are you talking about one veriT thread  that used so much memory or more than one veriT thread?<br>\nI am not sure that I understand this question.  Threads share a single address space, so the amount of memory used<br>\nis not a property of a single thread, but of a process.  If you are asking about processes, then it was one veriT<br>\nprocess.  I did not check how many threads were part of that process.</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>on what theory was this? I would like to reproduce that.<br>\nIt is not easy for me to supply any kind of simple theory with straightforward instructions for reproducing,<br>\nbut the next time it happens I will see if I can reproduce by using the same \"try\" in the same context.</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>What was the real memory usage? Virtual memory is pretty meaningless: I have a program that has a virtual memory usage<br>\nof 256G but uses only 9M...</li>\n</ul>\n<p>Again, I don't know what you mean by \"real memory usage\".  Unless a program uses some tricks such as sparse<br>\naddress spaces (which can be useful in some kind of in-memory database situations), the virtual memory will be the<br>\nsum of the code, data, heap and stack sizes.  Code and read-only data can be shared between processes, but this is<br>\nnot an issue here because there is only one veriT process, and I don't think any shared libraries used would be<br>\ncontributing to the issue.  The usage in question is almost certainly dynamic memory usage; i.e. heap.</p>\n</blockquote>\n<p>Linux utilities such as \"top\" and \"ps\" do report \"virtual size\" and \"resident-set size\".  The resident-set size<br>\nwould be the amount of actual RAM currently in use by the process.  This number is obviously limited by the<br>\namount of installed RAM and once it reaches a certain level there can essentially not be any further increases,<br>\nthough the size of the virtual address space can continue to increase if there is available swap.<br>\nIn the case of the example I cited, the RSS reached about 26GB, which took up enough of the system RAM so that<br>\nthere was severe thrashing.</p>\n<blockquote>\n<p>If the trashing is not too hard to reproduce:</p>\n<ul>\n<li>Does it still happen if you deactivate veriT in sledgehammer by adding:<p>ML ‹<br>\n   fun verit_rm_stgy f stgy thy =<br>\n     let<br>\n       val ctxt' = f (Proof_Context.init_global thy);<br>\n       val thy' = Proof_Context.theory_of ctxt';<br>\n     in Context.theory_map (Verit_Proof.verit_rm_stgy stgy) thy' end;<br>\n   ›</p>\n<p>setup ‹fold (verit_rm_stgy (fn x=&gt; x)) [\"del_insts\", \"ccfv_SIG\", \"ccfv_threshold\", \"default\", \"best\"]›</p>\n<p>ML ‹Verit_Proof.all_veriT_stgies (Context.Proof @{context})›<br>\n   (<em>should print: val it = []: string list</em>)</p>\n</li>\n</ul>\n<p>at the top of the file?</p>\n<ul>\n<li>If the previous point works, does it still happen if you deactivate all but one veriT strategy in sledgehammer, by adding:<p>ML ‹<br>\n   fun verit_rm_stgy f stgy thy =<br>\n     let<br>\n       val ctxt' = f (Proof_Context.init_global thy);<br>\n       val thy' = Proof_Context.theory_of ctxt';<br>\n     in Context.theory_map (Verit_Proof.verit_rm_stgy stgy) thy' end;<br>\n   ›</p>\n<p>setup ‹fold (verit_rm_stgy (fn x=&gt; x)) [\"del_insts\", \"ccfv_SIG\", \"ccfv_threshold\", \"default\"]›</p>\n<p>ML ‹Verit_Proof.all_veriT_stgies (Context.Proof @{context})›<br>\n   (<em>should print: val it = [\"best\"]: string list</em>)</p>\n</li>\n</ul>\n<p>at the top of the file?<br>\nI can try this, but do not know if/when I will be able to report on results, since the situation is not<br>\ndeterministically reproducible at this time.</p>\n</blockquote>\n<blockquote>\n<p>Thanks,</p>\n<p>Mathias</p>\n</blockquote>\n<p>On 06/01/2021 00:28, Eugene W. Stark wrote:</p>\n<blockquote>\n<blockquote>\n<p>I am running Isabelle2021-RC1 under Ubuntu 20.04.  Is there any way to limit the memory use<br>\nof the \"veriT\" prover?  It seems not to be a very good citizen in this respect: when it is<br>\nrun from the \"try\" command it seems willing to grow its address space even to significantly<br>\nexceed the total amount of system RAM.  For example, I just observed a virtual address space<br>\nof 37.8GB on a system with 32GB total RAM and of course Java, poly, and various other things<br>\nwere also running, so this is unsupportable.  When this occurs, the system is sent into a<br>\nthrashing mode, from which it is difficult even to get back control of the desktop so that<br>\nthe offending process can be identified and killed.  So some ability to impose a limit is<br>\nneeded here.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 222683556,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610605459
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nI think it might be worth mentioning that there are good ways to set<br>\nresource limits on processes in any given OS. I've got consistent <br>\nresults<br>\nfrom ulimit on linux in the past (in a non-Isabelle project that run<br>\nthousands of SMT queries). It might be possible to add such limits to<br>\nthe veriT tasks as they're created, if necessary by wrapping the veriT<br>\nbinary in a script.</p>\n<p>Best regards,<br>\n     Thomas.</p>",
        "id": 222742288,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610641701
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis does not sound very portable: Would this work on Windows (with or without<br>\nCygwin)?</p>\n<p>Makarius</p>",
        "id": 224245883,
        "sender_full_name": "Email Gateway",
        "timestamp": 1611780926
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 11/01/2021 08:28, Mathias Fleury wrote:</p>\n<blockquote>\n<p>I believe that there are two different problems here:</p>\n<ol>\n<li>tactics running forever and using a lot of memory. This already happens<br>\n    with metis or blast. However, this behavior might be new for smt, because<br>\n    the smt_timeout was disabled<br>\n    (<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/478b7599a1a0\">http://isabelle.in.tum.de/repos/isabelle/rev/478b7599a1a0</a>) and smt solver<br>\n    are a lot more powerful than metis/blast. This is not specific to veriT<br>\n    and can happen with Z3 too.<br>\n      *  Solution: Set the smt_timeout to some reasonable value.</li>\n</ol>\n</blockquote>\n<p>The quoted changeset says:</p>\n<p>changeset:   72347:478b7599a1a0<br>\nparent:      72342:4195e75a92ef<br>\nuser:        desharna</p>",
        "id": 224246304,
        "sender_full_name": "Email Gateway",
        "timestamp": 1611781152
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nI don't have anything further to add.  I reported what I observed and what my opinion was about it.</p>",
        "id": 224249650,
        "sender_full_name": "Email Gateway",
        "timestamp": 1611782679
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nIt's likely there's a Windows feature similar to ulimit, but I<br>\nhave no idea what it might be. I quickly checked whether python's<br>\nsetrlimit was considered \"portable\", and it doesn't appear to be<br>\nthe case.</p>\n<p>Even if a portable version exists, I can't think of a sensible<br>\ndefault value. A sufficiently advanced user could already apply<br>\nthis on a compatible platform by fiddling with the contents of<br>\nIsabelle's contrib directory, I think, so maybe there's no need<br>\nfor any action.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 224319017,
        "sender_full_name": "Email Gateway",
        "timestamp": 1611837102
    },
    {
        "content": "<p>From: Jasmin Blanchette via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nThe idea came from me. Having a tactic operate with a timeout seems quite fragile. This adds a layer of randomness to Isabelle. In each AFP entry's ROOT file, there's a timeout for the entire session, which is a good practical compromise, but if we start having timeouts in every individual tactic, we might get all sorts of random failures. Other tactics like \"auto\" or \"metis\" don't have timeout.</p>\n<p>If this is the only or best way to reduce veriT's memory usage, we could consider reverting 478b7599a1a0, but this seems dubious to me.</p>\n<p>Jasmin</p>",
        "id": 225129529,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612426186
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<blockquote>\n<p>If this is the only or best way to reduce veriT's memory usage, we could consider reverting 478b7599a1a0, but this seems dubious to me.</p>\n</blockquote>\n<p>Perhaps a compromise would be to activate timeouts only for the <br>\ninteractive session? I find that the most annoying thing about timeouts <br>\nis that they can make a build of large heaps fail because the computer <br>\ngoes into swapping. While in the interactive session, timeouts could be <br>\nnice so that the computer does not go into expensive infinite loops when <br>\nsomething changes during editing. And since the interactive session is <br>\nusually edited by the same person who inserts the timeout, it's then up <br>\nto each person whether they want to use a timeout or not. (And <br>\nunpredictability is less of a problem during the interactive editing.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 225281883,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612520856
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFor my part, it is formally OK to do nothing for the release.</p>\n<p>It is up to the SMT + veriT experts to say if there is something severely<br>\nwrong that needs to be changed for the Isabelle2021 release. RC5 is planned<br>\nfor 08-Feb-2021. The final release approx. 1 week later.</p>\n<p>Makarius</p>",
        "id": 225298747,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612532185
    }
]