[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>I already sent this to the mailing list last year when 2021-1 came out <br>\nbut there was no answer, it probably got lost in the excitement of the <br>\nRC-process.</p>\n<p>Personally, I think this is a confusing problem and should be changed. <br>\nHowever, if this is intended behavior, I would be happy if someone who <br>\nfeels responsible for the \"bit\" type (in Z2) can confirm this.</p>\n<p>In Isabelle2021-1, the simplification rules for the type bit (from <br>\nHOL-Library.Z2) have changed.</p>\n<p>Besides other rules, we have the following simp rules:</p>\n<p>* xor ?b ?c = of_bool (odd ?b ≠ odd ?c)<br>\n  * of_bool (¬ ?P) = 1 - of_bool ?P<br>\n  * (-) = (+)<br>\n  * (+) = xor</p>\n<p>These rules can give us a rewrite-cycle: xor is rewritten in terms of <br>\n\"of_bool (... ~= ...)\" which goes to \"1 - of_bool ...\" which goes to \"1 </p>\n<ul>\n<li>of_bool ...\" which goes to \"xor 1 (of_bool ...)\". And we have xor back!</li>\n</ul>\n<p>Whether this actually happens depends on the concrete case (sometimes <br>\nthe a case distinction splitter rule on the arguments of the xor happens <br>\ninstead, I think).</p>\n<p>But I have found that it can be quite easily triggered nonetheless.</p>\n<p>For example, ‹xor b c = of_bool (b ≠ c)› makes the simplifier loop.</p>\n<p>And if we add the (quite useful, imho) simp rule \"((a=x) = (b=x)) = <br>\n(a=b)\" for bits, then even something as natural as ‹a + b + b = a› loops.</p>\n<p>An example theory is attached.</p>\n<p>Of course, I don't know if there are any important reasons for those <br>\nxor-related simp-rules, but personally I feel that removing them (at <br>\nleast the \"xor ?b ?c = of_bool (odd ?b ≠ odd ?c)\" rule) would make the <br>\nsimplifier much less fragile in the presence of bit-related arithmetic.</p>\n<p>(Also, as an aside: why is there \"odd\" in the definition of xor? <br>\nWouldn't \"xor ?b ?c = of_bool (?b ≠ ?c)\" be simpler and equivalent?)</p>\n<p>Best wishes,<br>\nDominique.<br>\n<a href=\"/user_uploads/14278/x0ndK9MwYlF9Q1ZA9L47BRyG/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294854958,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661257731
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Dominique,</p>\n<p>thanks for reporting this.</p>\n<p>a) The evil simp rule clearly is ‹of_bool (¬ ?P) = 1 - of_bool ?P›, I am<br>\nworking on getting rid of it.  (As often, the problem does not reside in<br>\nthe theory which exposed it).</p>\n<p>b) Concerning the deeper rationale, the history of theory Z2 is relevant.</p>\n<p>Before 2013/14, the type bit = 0 | 1 was heavily used to represent<br>\nsingle bit values e. g. in what is nowadays HOL/Bit_Operations.thy and<br>\nHOL-Library/Word.thy – but not in all consequence, in some places bool<br>\nwas used for the same purpose.</p>\n<p>Andreas Lochbihler then suggested to reconcile this, and from that time<br>\nbool has been used consistently, the of_bool embedding stemming from<br>\nthat time.  The »bit« type has been kept for backward compatibility.</p>\n<p>When starting re-working bit operations and word operations from 2019<br>\non, I did not dare to cut of that backward compatibility strain but<br>\nasked myself for which applications »bit« could be preferable to »bool«<br>\nand came to the conclusion that it is a complete model of the field with<br>\ntwo elements, hence re-shaping it into theory Z2.</p>\n<p>At that time I did not know of any applications but appreciated it as a<br>\nnice example how to introduce a data type with overloaded constructor<br>\nsymbols.  Also I tried to provide automation to reduce problems on type<br>\n»bit« to »bool«, hence using existing automation on »bool« to prove<br>\nproblems on »bit«, which explains the rather aggressive default simp rules.</p>\n<blockquote>\n<p>(Also, as an aside: why is there \"odd\" in the definition of xor?<br>\nWouldn't \"xor ?b ?c = of_bool (?b ≠ ?c)\" be simpler and equivalent?)</p>\n</blockquote>\n<p>You are clearly right that those RHSs could be formulated in a logically<br>\nsimpler way, but then the expression of the primary idea would get lost:<br>\nreduce expressions on »bit« to expressions on »bool« with simple<br>\nstraightforward correspondences.</p>\n<p>Your proposal would essentially loose the rewriting the »bool«.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/_AVL7lZRxp8Oiptm4iSgN6jA/OpenPGP_signature\">OpenPGP_signature</a></p>",
        "id": 294894599,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661269330
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>I wonder whether \"xor ?b ?c = of_bool (odd ?b ≠ odd ?c)\" shouldn't <br>\nremoved from the simp-set instead (or in addition to) \"of_bool (¬ ?P) = <br>\n1 - of_bool ?P\". And then of course add enough simp-rules for xor to <br>\ncompensate for this (such as \"xor a a = 0\" etc). (I would assume not too <br>\nmany are needed.) One advantage would be that it leads to more readable <br>\nsimplifications. Or alternatively rewrite xor to plus, that fits best <br>\nwith the Z2-view and also leads to readable simplification results.</p>\n<p>But that would of course not fit with the idea of rewriting everything <br>\nto bool.</p>\n<p>Another possibility would be to make bit a type synonym for bool and <br>\ndefine 1 := true, 0 := false. (While still possibly instantiating the <br>\nfield typeclass.)</p>\n<blockquote>\n<p>At that time I did not know of any applications<br>\nI can explain where I use it. In cryptography, we often have an <br>\nadversary with a one-bit output (and we look at how the probability <br>\ndistribution of that output changes). Now we could, of course, say the <br>\noutput is of type bool, but there are two stylistic arguments against <br>\nit: (a) We get farther away from the established notation in crypto <br>\n(where we'd write Pr[x=1 : x&lt;-A] and not Pr[x : x&lt;-A]). (b) Using type <br>\nbool implies a certain meaning of the bit values (truth) but the outputs <br>\n0/1 of the adversary do not represent a yes/no answer per se, but just <br>\ntwo choices.</p>\n</blockquote>\n<p>These arguments are of course a bit subjective, and technically there is <br>\nnothing that stops us from using bool here.</p>\n<blockquote>\n<p>You are clearly right that those RHSs could be formulated in a logically<br>\nsimpler way, but then the expression of the primary idea would get lost:<br>\nreduce expressions on »bit« to expressions on »bool« with simple<br>\nstraightforward correspondences.<br>\nAh, I understand now. \"odd\" is kind of \"to_bool\", and then it makes <br>\nsense intuitively!</p>\n</blockquote>\n<p>Best wishes,<br>\nDominique.</p>\n<p>On 8/23/22 18:41, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Hi Dominique,</p>\n<p>thanks for reporting this.</p>\n<p>a) The evil simp rule clearly is ‹of_bool (¬ ?P) = 1 - of_bool ?P›, I am<br>\nworking on getting rid of it.  (As often, the problem does not reside in<br>\nthe theory which exposed it).</p>\n<p>b) Concerning the deeper rationale, the history of theory Z2 is relevant.</p>\n<p>Before 2013/14, the type bit = 0 | 1 was heavily used to represent<br>\nsingle bit values e. g. in what is nowadays HOL/Bit_Operations.thy and<br>\nHOL-Library/Word.thy – but not in all consequence, in some places bool<br>\nwas used for the same purpose.</p>\n<p>Andreas Lochbihler then suggested to reconcile this, and from that time<br>\nbool has been used consistently, the of_bool embedding stemming from<br>\nthat time.  The »bit« type has been kept for backward compatibility.</p>\n<p>When starting re-working bit operations and word operations from 2019<br>\non, I did not dare to cut of that backward compatibility strain but<br>\nasked myself for which applications »bit« could be preferable to »bool«<br>\nand came to the conclusion that it is a complete model of the field with<br>\ntwo elements, hence re-shaping it into theory Z2.</p>\n<p>At that time I did not know of any applications but appreciated it as a<br>\nnice example how to introduce a data type with overloaded constructor<br>\nsymbols.  Also I tried to provide automation to reduce problems on type<br>\n»bit« to »bool«, hence using existing automation on »bool« to prove<br>\nproblems on »bit«, which explains the rather aggressive default simp rules.</p>\n<blockquote>\n<p>(Also, as an aside: why is there \"odd\" in the definition of xor?<br>\nWouldn't \"xor ?b ?c = of_bool (?b ≠ ?c)\" be simpler and equivalent?)<br>\nYou are clearly right that those RHSs could be formulated in a logically<br>\nsimpler way, but then the expression of the primary idea would get lost:<br>\nreduce expressions on »bit« to expressions on »bool« with simple<br>\nstraightforward correspondences.</p>\n</blockquote>\n<p>Your proposal would essentially loose the rewriting the »bool«.</p>\n<p>Cheers,<br>\n  Florian</p>\n</blockquote>",
        "id": 294921642,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661278320
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Dominique,</p>\n<p>see now <a href=\"https://isabelle.sketis.net/repos/isabelle/rev/c530cb79ccbc\">https://isabelle.sketis.net/repos/isabelle/rev/c530cb79ccbc</a> and<br>\n<a href=\"https://isabelle.sketis.net/repos/afp-devel/rev/cf809a286330\">https://isabelle.sketis.net/repos/afp-devel/rev/cf809a286330</a> where the<br>\nrule »of_bool (Not P) = …« is removed.</p>\n<blockquote>\n<p>I wonder whether \"xor ?b ?c = of_bool (odd ?b ≠ odd ?c)\" shouldn't<br>\nremoved from the simp-set instead (or in addition to) \"of_bool (¬ ?P) =<br>\n1 - of_bool ?P\". And then of course add enough simp-rules for xor to<br>\ncompensate for this (such as \"xor a a = 0\" etc). (I would assume not too<br>\nmany are needed.) One advantage would be that it leads to more readable<br>\nsimplifications. Or alternatively rewrite xor to plus, that fits best<br>\nwith the Z2-view and also leads to readable simplification results.</p>\n<p>But that would of course not fit with the idea of rewriting everything<br>\nto bool.</p>\n</blockquote>\n<p>There might be reasons that the global rewriting to bool should be<br>\nremoved entirely,<br>\nbut then it should be done consequently for all operations, not just xor.</p>\n<blockquote>\n<p>Another possibility would be to make bit a type synonym for bool and<br>\ndefine 1 := true, 0 := false. (While still possibly instantiating the<br>\nfield typeclass.)</p>\n</blockquote>\n<p>That could be worth a try.</p>\n<blockquote>\n<p>At that time I did not know of any applications<br>\nI can explain where I use it. In cryptography, we often have an<br>\nadversary with a one-bit output (and we look at how the probability<br>\ndistribution of that output changes). Now we could, of course, say the<br>\noutput is of type bool, but there are two stylistic arguments against<br>\nit: (a) We get farther away from the established notation in crypto<br>\n(where we'd write Pr[x=1 : x&lt;-A] and not Pr[x : x&lt;-A]). (b) Using type<br>\nbool implies a certain meaning of the bit values (truth) but the outputs<br>\n0/1 of the adversary do not represent a yes/no answer per se, but just<br>\ntwo choices.</p>\n<p>These arguments are of course a bit subjective, and technically there is<br>\nnothing that stops us from using bool here.</p>\n</blockquote>\n<p>If your applications demands a very particular binary type, it could be best<br>\nto construct your own copy of bool.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/uOPCmIQQipeWlCjXQUmh0Skj/OpenPGP_signature\">OpenPGP_signature</a></p>",
        "id": 295168766,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661408537
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>I can confirm that it works well for me now in Isabelle2022-RC2.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 299529289,
        "sender_full_name": "Email Gateway",
        "timestamp": 1663579344
    }
]