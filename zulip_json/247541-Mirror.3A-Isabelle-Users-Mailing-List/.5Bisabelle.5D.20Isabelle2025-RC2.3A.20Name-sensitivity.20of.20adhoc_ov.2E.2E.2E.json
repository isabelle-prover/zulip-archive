[
    {
        "content": "<p>From: \"\\\"Becker, Hanno\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Makarius,</p>\n<p>First, thanks for all your work on Isabelle2025, esp. the localization of syntax translations and making adhoc_overloading part of <code>Main</code> – this is great to see!</p>\n<p>Below is a (to me) unexpected behaviour of adhoc_overloading. I don’t know if it is intended or not, and if not, whether it could still be changed for Isabelle2025. But since you worked on inner syntax a lot in 2025, you may know the answer off-hand:</p>\n<p>Behaviour: When using adhoc_overloading in a locale A, other locales inheriting from A inherit the adhoc_overloading _only_ if they use exactly the same parameter name(s) as in A’s original declaration. This name-sensitivity is unexpected to me.</p>\n<p>Minimal example follows.</p>\n<p>=============</p>\n<p>theory Scratch<br>\n  imports Main<br>\nbegin</p>\n<p>consts uninterpreted_const :: ‹'a ⇒ 'a ⇒ 'a› (\"_ ⋆⋆ _\")</p>\n<p>locale test0 =<br>\n  fixes some_operator :: ‹'foo ⇒ 'foo ⇒ 'foo›<br>\nbegin<br>\nadhoc_overloading uninterpreted_const ⇌ some_operator<br>\nterm ‹a ⋆⋆ b› (* \"a ⋆⋆ b\" :: \"'foo\" <em>) (</em> ALL GOOD *)<br>\nend</p>\n<p>(* Derived locale, using the same parameter name, but different type parameter name *)<br>\nlocale test1 = test0 some_operator for some_operator :: ‹'bar ⇒ 'bar ⇒ 'bar›<br>\nbegin<br>\nterm ‹a ⋆⋆ b› (* \"a ⋆⋆ b\" :: \"'bar\" <em>) (</em> ALL GOOD *)<br>\nend</p>\n<p>(* Derived locale, using a different parameter name *)<br>\nlocale test2 = test0 some_operator' for some_operator' :: ‹'bar ⇒ 'bar ⇒ 'bar›<br>\nbegin<br>\nterm ‹a ⋆⋆ b› (* Unresolved adhoc overloading of constant uninterpreted_const :: \"??'a ⇒ ??'a ⇒ ??'a\" in term \"a ⋆⋆ b\"<br>\nno instances *)<br>\nend</p>\n<p>end</p>\n<p>============</p>\n<p>Thanks for your help,<br>\nHanno</p>",
        "id": 500632664,
        "sender_full_name": "Email Gateway",
        "timestamp": 1739966474
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nHi Hanno,</p>\n<p>Syntax declarations generally don't survive renaming or instantiation of <br>\nterm parameters, and the implementors of ad hoc overloading apparently <br>\nrespected this policy. You may consider the following example:</p>\n<p>locale test3 =<br>\n   a: test0 some_operator + b: test0 some_operator' for some_operator ... <br>\nand some_operator' ...</p>\n<p>Clemens</p>\n<p>On 2025-02-19 12:59, \"Becker, Hanno\" wrote:</p>\n<blockquote>\n<p>locale test0 =<br>\n  fixes some_operator :: ‹'foo ⇒ 'foo ⇒ 'foo›<br>\nbegin<br>\nadhoc_overloading uninterpreted_const ⇌ some_operator<br>\nterm ‹a ⋆⋆ b› (* \"a ⋆⋆ b\" :: \"'foo\" <em>) (</em> ALL GOOD *)<br>\nend</p>\n<p>(* Derived locale, using the same parameter name, but different type<br>\nparameter name *)<br>\nlocale test1 = test0 some_operator for some_operator :: ‹'bar ⇒ 'bar ⇒ <br>\n'bar›<br>\nbegin<br>\nterm ‹a ⋆⋆ b› (* \"a ⋆⋆ b\" :: \"'bar\" <em>) (</em> ALL GOOD *)<br>\nend</p>\n<p>(* Derived locale, using a different parameter name *)<br>\nlocale test2 = test0 some_operator' for some_operator' :: ‹'bar ⇒ 'bar <br>\n⇒ 'bar›<br>\nbegin<br>\nterm ‹a ⋆⋆ b› (* Unresolved adhoc overloading of constant<br>\nuninterpreted_const :: \"??'a ⇒ ??'a ⇒ ??'a\" in term \"a ⋆⋆ b\"<br>\nno instances *)<br>\nend</p>\n<p>end</p>\n<p>============</p>\n<p>Thanks for your help,<br>\nHanno</p>\n</blockquote>",
        "id": 500749747,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740002015
    },
    {
        "content": "<p>From: \"\\\"Becker, Hanno\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Clemens,</p>\n<p>Thank you for the reply!</p>\n<p>Is this the right approach for _overloaded_ syntax provided, though?</p>\n<p>And what is the reason to make an exception and inherit syntax declarations if names are unchanged? The naming of parameters having an effect of what gets inherited feels fragile.</p>\n<p>Best,<br>\nHanno</p>\n<p>﻿On 19/02/2025, 21:44, \"Clemens Ballarin\" &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a> &lt;mailto:<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;&gt; wrote:</p>\n<p>CAUTION: This email originated from outside of the organization. Do not click links or open attachments unless you can confirm the sender and know the content is safe.</p>\n<p>Hi Hanno,</p>\n<p>Syntax declarations generally don't survive renaming or instantiation of<br>\nterm parameters, and the implementors of ad hoc overloading apparently<br>\nrespected this policy. You may consider the following example:</p>\n<p>locale test3 =<br>\na: test0 some_operator + b: test0 some_operator' for some_operator ...<br>\nand some_operator' ...</p>\n<p>Clemens</p>\n<p>On 2025-02-19 12:59, \"Becker, Hanno\" wrote:</p>\n<blockquote>\n<p>locale test0 =<br>\nfixes some_operator :: ‹'foo ⇒ 'foo ⇒ 'foo›<br>\nbegin<br>\nadhoc_overloading uninterpreted_const ⇌ some_operator<br>\nterm ‹a ⋆⋆ b› (* \"a ⋆⋆ b\" :: \"'foo\" <em>) (</em> ALL GOOD *)<br>\nend</p>\n<p>(* Derived locale, using the same parameter name, but different type<br>\nparameter name *)<br>\nlocale test1 = test0 some_operator for some_operator :: ‹'bar ⇒ 'bar ⇒<br>\n'bar›<br>\nbegin<br>\nterm ‹a ⋆⋆ b› (* \"a ⋆⋆ b\" :: \"'bar\" <em>) (</em> ALL GOOD *)<br>\nend</p>\n<p>(* Derived locale, using a different parameter name *)<br>\nlocale test2 = test0 some_operator' for some_operator' :: ‹'bar ⇒ 'bar<br>\n⇒ 'bar›<br>\nbegin<br>\nterm ‹a ⋆⋆ b› (* Unresolved adhoc overloading of constant<br>\nuninterpreted_const :: \"??'a ⇒ ??'a ⇒ ??'a\" in term \"a ⋆⋆ b\"<br>\nno instances *)<br>\nend</p>\n<p>end</p>\n<p>============</p>\n<p>Thanks for your help,<br>\nHanno</p>\n</blockquote>",
        "id": 500798222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740030398
    }
]