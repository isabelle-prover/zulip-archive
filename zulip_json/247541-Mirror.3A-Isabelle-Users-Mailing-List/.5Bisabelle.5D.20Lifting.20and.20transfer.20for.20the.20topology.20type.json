[
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear lifting-and-transfer experts,</p>\n<p>I am considering to set up the lifting-and-transfer package for the topology type in “HOL-Analysis.Abstract_Topology”. This requires defining a “relator” to relate two topologies under some relation:</p>\n<p>definition rel_topology:: \"('a ⇒ 'b ⇒ bool) ⇒<br>\n    'a topology ⇒ 'b topology ⇒ bool\" where<br>\n  \"rel_topology R T1 T2 = undefined”</p>\n<p>And this relator should ideally satisfy the following properties:</p>\n<p>lemma rel_topology_eq [relator_eq]: \"rel_topology (=) = (=)\"<br>\n  sorry</p>\n<p>lemma rel_topology_mono [relator_mono]: \"rel_topology A ≤ rel_topology B\"<br>\n  if le: \"A ≤ B\"<br>\n  sorry</p>\n<p>lemma rel_topology_distr [relator_distr]:<br>\n  \"rel_topology A OO rel_topology B = rel_topology (A OO B)\"<br>\n  sorry</p>\n<p>definition topo_map::\"('a ⇒ 'b) ⇒ 'a topology ⇒ 'b topology\" where<br>\n  \"topo_map f T1 = undefined\"</p>\n<p>lemma Quotient_topology[quot_map]:<br>\n  assumes \"Quotient R Abs Rep T\"<br>\n  shows \"Quotient (rel_topology R) (topo_map Abs) (topo_map Rep) (rel_topology T)\"<br>\n  sorry</p>\n<p>I have been attempting to imitate the lifting setup for filters:</p>\n<p>definition map_filter_on :: \"'a set ⇒ ('a ⇒ 'b) ⇒ 'a filter ⇒ 'b filter\" where<br>\n  \"map_filter_on X f F = Abs_filter (λP. eventually (λx. P (f x) ∧ x ∈ X) F)”</p>\n<p>inductive rel_filter :: \"('a ⇒ 'b ⇒ bool) ⇒ 'a filter ⇒ 'b filter ⇒ bool\" for R F G where<br>\n \"rel_filter R F G”<br>\nif \"eventually (case_prod R) Z\" \"map_filter_on {(x, y). R x y} fst Z = F\" \"map_filter_on {(x, y). R x y} snd Z = G”</p>\n<p>because both ‘a topology and ‘a filter are constructed from ‘a set set but with different constraints. However, unlike filters it appears quite hard to define a map from one topology to another while satisfying the map compositionality as on filters:</p>\n<p>lemma map_filter_on_comp: \"map_filter_on X f (map_filter_on Y g F) = map_filter_on Y (f ∘ g) F\"<br>\n  if \"g ` Y ⊆ X\" and \"eventually (λx. x ∈ Y) F\"</p>\n<p>I was wondering if it is at all possible to define a relator for the topology type.</p>\n<p>Any hint or comment would be highly appreciated.</p>\n<p>Best,<br>\nWenda</p>",
        "id": 281333489,
        "sender_full_name": "Email Gateway",
        "timestamp": 1651772398
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nDear Wenda,</p>\n<p>I had the same need recently, and I wrote the definition of <br>\n\"rel_topology\" (together with various transfer and parametricity <br>\ntheorems) for it:</p>\n<p>definition rel_topology :: ‹('a ⇒ 'b ⇒ bool) ⇒ ('a topology ⇒ 'b<br>\n    topology ⇒ bool)› where<br>\n       ‹rel_topology R S T ⟷ (rel_fun (rel_set R) (=)) (openin S) (openin T)<br>\n      ∧ (∀U. openin S U ⟶ Domainp (rel_set R) U) ∧ (∀U. openin T U ⟶<br>\n    Rangep (rel_set R) U)›</p>\n<p>The first condition on the rhs says that the \"openin\" predictate relates <br>\nas one would expect.</p>\n<p>However, that turned out to be insufficient (e.g., for proving <br>\n‹(rel_topology R ===&gt; rel_set R) topspace topspace›). So I am <br>\nadditionally requiring that the open sets are in the domain/range of the <br>\nunderlying relation. (Your email is quite timely, I added this <br>\ncorrection yesterday evening! :) )</p>\n<p>This definition seems to work (in the sense that I have managed to prove <br>\nvarious nontrivial transfer theorems, including for infinite sums w.r.t. <br>\ndifferent topologies.</p>\n<p>You can find the whole thing here:</p>\n<p><a href=\"https://github.com/dominique-unruh/afp/blob/registers-infinite/thys/Hilbert_Space_Tensor_Product/Misc_Tensor_Product.thy\">https://github.com/dominique-unruh/afp/blob/registers-infinite/thys/Hilbert_Space_Tensor_Product/Misc_Tensor_Product.thy</a></p>\n<p>(This is work in progress. But the part relating to rel_topology does <br>\nnot have any sorry's as far as I can tell (since yesterday! :D). The <br>\nrepo is a clone of the AFP but I think you can just extract the <br>\nHilbert_Space_Tensor_Product directory on its own and it should work <br>\nwith the normal release AFP.)</p>\n<p>I have not tried to prove the lemmas you write below yet.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 281334653,
        "sender_full_name": "Email Gateway",
        "timestamp": 1651773001
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Dominique,</p>\n<p>Thanks a lot for your prompt reply! And I am so lucky to have you happen to think about the same problem :-)</p>\n<p>Your definition of rel_topology is awesome, but I am afraid that with it we still cannot derive the monotonicity lemma: \"A ≤ B ⟹ rel_topology A ≤ rel_topology B”.</p>\n<p>My intention with the list of properties I described in the previous email is that we can then freely lift from the topology type similar to set/list:</p>\n<p>typedef (overloaded) ('a, 'b) poly_inst (\"(_ ⇒⇩p /_)\" [1, 0] 0) =<br>\n  \"UNIV:: ('a ⇒ 'b) set\"<br>\n  by auto<br>\nsetup_lifting type_definition_poly_inst</p>\n<p>lift_definition PiE⇩p :: \"'a set ⇒ ('a ⇒ 'b set) ⇒ ('a ⇒⇩p 'b) set\" is<br>\n  \"λs f. PiE s f\" .</p>\n<p>text ‹This definition is only possible if we have @{thm Quotient_topology}›<br>\nlift_definition product_topology⇩p<br>\n  :: \"('a ⇒ 'b topology) ⇒ 'a set ⇒ ('a ⇒⇩p 'b) topology\" is<br>\n  \"λf s. product_topology f s\" .</p>\n<p>Nevertheless, being able to prove this number of non-trivial transfer theorems is perhaps the best we can do for now...</p>\n<p>Best,<br>\nWenda</p>",
        "id": 281423062,
        "sender_full_name": "Email Gateway",
        "timestamp": 1651835132
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMy own attempt at this was hopeless. If there is anyone out there who really has a good feel for how to define these things, it would be great if they could write a small tutorial…</p>\n<p>Larry Paulson</p>",
        "id": 281423219,
        "sender_full_name": "Email Gateway",
        "timestamp": 1651835281
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nI also failed miserably trying to define one for the \"measure\" type once.</p>\n<p>I mean, I could define one that works for two types that are completely <br>\nisomorphic, but that's probably not as general as what we really want to <br>\nhave.</p>\n<p>Manuel</p>",
        "id": 281435626,
        "sender_full_name": "Email Gateway",
        "timestamp": 1651842442
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi Wenda, Dominique and Manuel,</p>\n<p>The first attempt at defining a relator for a type is usually to follow the structure of <br>\nthe types it is built from. Joshua Schneider and I had an ITP paper on that topic a few <br>\nyears ago: Relational parametricity and quotient preservation for modular (co)datatypes <br>\n<a href=\"http://dx.doi.org/10.1007/978-3-319-94821-8_24\">http://dx.doi.org/10.1007/978-3-319-94821-8_24</a></p>\n<p>For rel_topology, we'd get what was Dominique's first attempt:</p>\n<p>rel_topology R S T = (rel_fun (rel_set R) (=)) (openin S) (openin T)</p>\n<p>since openin is the representation morphism of type 'a set =&gt; bool. The above paper gives <br>\nsufficient conditions on when Wenda's desired properties are satisfied (especially section <br>\n5 on subtypes). However, rel_topology_mono will certainly not hold with this definition. <br>\nThe reason is that the type variable 'a in <code>'a set =&gt; bool</code> occurs in a negative position, <br>\n  so this approach will yield a contravariant functor, for which the relator is anti-monotone:</p>\n<p>R &lt;= S ==&gt; rel_topology S &lt;= rel_topology R</p>\n<p>Accordingly, you'd be looking for a contravariant map function for the quotient <br>\npreservation theorem.</p>\n<p>Unfortunately, this approach sometimes does not give the right relator. For example, I <br>\noriginally defined rel_filter following this approach: <br>\n<a href=\"https://isabelle.in.tum.de/repos/isabelle/annotate/5431e1392b14/src/HOL/Topological_Spaces.thy#l2285\">https://isabelle.in.tum.de/repos/isabelle/annotate/5431e1392b14/src/HOL/Topological_Spaces.thy#l2285</a><br>\nHowever, this did not give the nice theorems for rel_filter that we have today in <br>\nIsabelle. As discussed at the end of Section 5 in the above paper, the current relator is <br>\nstronger and thereby eliminates some junk. In <br>\n<a href=\"https://isabelle.in.tum.de/repos/isabelle/rev/1d005f514417\">https://isabelle.in.tum.de/repos/isabelle/rev/1d005f514417</a>, I've switched out the old <br>\ndefinition for the new one.</p>\n<p>In particular, the definition via a mapper gives the desired properties a lot more <br>\ndirectly than if we try to define the relator directly. So it may be worth to look for a <br>\nsuitable map function (and decide whether it should be co- or contravariant).</p>\n<p>On 06.05.22 15:07, Manuel Eberl wrote:</p>\n<blockquote>\n<p>I also failed miserably trying to define one for the \"measure\" type once.</p>\n<p>I can well imagine that. <code>'a measure</code> consists of the sigma algebra <code>sets</code> and the measure <br>\nfunction <code>emeasure</code>. Let's just look at the types:</p>\n</blockquote>\n<p>sets :: \"'a measure =&gt; 'a set set\"<br>\nemeasure :: \"'a measure =&gt; 'a set =&gt; ennreal\"</p>\n<p>Here, the type variable 'a occurs in <code>sets</code> in a positive position and in <code>emeasure</code> in a <br>\nnegative position. This means that if we define the relator according to the types, we're <br>\nsetup for failure. We get neither monotonicity nor anti-monotonicity and the mapper will <br>\nonly work for isomorphism:</p>\n<blockquote>\n<p>I mean, I could define one that works for two types that are completely isomorphic, but <br>\nthat's probably not as general as what we really want to have.<br>\n</p>\n</blockquote>\n<p>One could try to get out of this problem via the isomorphism between sets and predicates. <br>\nIf we understood the set to be measured as a predicate, i.e., the indicator function, then <br>\nall occurrences of 'a would be covariant again and there would be hope.</p>\n<p>emeasure' :: \"'a measure =&gt; ('a =&gt; bool) =&gt; ennreal\"</p>\n<p>This duality between sets and predicates w.r.t. co/contravariance was one of the main <br>\nreasons why we have re-introduces a separate type <code>set</code> for sets about 10 years ago. (In <br>\n2008, the set type constructor had been replaces as a type synonym: 'a set = 'a =&gt; bool) <br>\nUnfortunately, when a new definition is made involving sets or predicates, we typically do <br>\n  not consider the co/contravariance aspect when we make a decision whether a parameter <br>\nshould be a set or a predicate. We are mostly guided by the mathematical practice or <br>\nconvenience of the notation. Of course, it's possible to define a relator on <code>'a set</code> that <br>\ntreats sets like predicates (see rel_pred in SPMF.thy), but that doesn't work well with <br>\nthe transfer and lifting packages. They do not support several relators for a type, and <br>\nthat's usually where my attempts in this direction have hit a wall. Proper support for <br>\nthis duality would require a substantial rewrite of these packages.</p>\n<p>I haven't yet thought about how a mapper or relator for topologies or measures could look <br>\nlike. However, both topologies and measures typically consider only a well-behaved <br>\nfunctions (continuous or measurable) whereas the transfer and lifting packages always work <br>\nwith the full function space, i.e., over the category SET. I don't know what complication <br>\nthis brings along.</p>\n<p>I hope that the above thoughts give you some inspiration where to look for solutions.</p>\n<p>Andreas</p>",
        "id": 281596729,
        "sender_full_name": "Email Gateway",
        "timestamp": 1652012858
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nDear Wenda,</p>\n<p>Your definition of rel_topology is awesome, but I am afraid that with it we<br>\nstill cannot derive the monotonicity lemma: \"A ≤ B ⟹ rel_topology A ≤<br>\nrel_topology B”.</p>\n<p>I think that specific problem should be relatively easy to fix by replacing<br>\n\"(rel_fun (rel_set R) (=)) (openin S) (openin T)\" by \"rel_set (rel_set R)<br>\n(Collect (openin S)) (Collect (openin T))\". (I.e., we see the topology not<br>\nas a predicate over sets but a set of sets (which is anyway more in line<br>\nwith usual language.) This would be monotonous.</p>\n<p>However, that would not address the other lemmas you wanted.</p>\n<p>I worked on it some more since your reply, and I think I have a much more<br>\nsatisfactory approach.</p>\n<p>Caveat: I have not formalized anything of what I write below in Isabelle. I<br>\nhave handwritten proofs for the claims but they are not carefully checked<br>\nso the claims I am giving might not be correct. I am not including the<br>\nproofs in this email because is would take too long to write them in a<br>\nreadable form. (But I can of course provide them if we need them.)</p>\n<p>The first step was to define a <em>map_topology</em> function. I believe the<br>\nnatural way to map topologies is the following (e.g. here<br>\n&lt;<a href=\"https://en.wikipedia.org/wiki/Topological_space#Topological_constructions\">https://en.wikipedia.org/wiki/Topological_space#Topological_constructions</a>&gt;):<br>\nFor a surjective function [image: f:X\\to Y], given a topology T on X, you<br>\nget a topology f(X) on Y by defining: [image: U\\in f\\left(X\\right)] iff [image:<br>\nf^{-1}\\in X].</p>\n<p>However, the requirement that [image: f] is surjective is awkward in our<br>\ncontext because we do not want to add conditions in the various relator<br>\ntheorems. So my solution is to [image: f\\left(T\\right)] be not a topology<br>\non [image: Y] but a topology on [image: \\text{im}f]. (I.e., with<br>\ntopspace [image:<br>\n\\text{im}f].) More precisely, for [image: f:X\\to Y] we define [image:<br>\n\\overline{f}] as follows:</p>\n<p>[image: U\\in\\overline{f}\\left(T\\right)]   iff   [image:<br>\nf^{-1}\\left(U\\right)\\cap\\text{top}\\left(T\\right)\\in T] and [image:<br>\nU\\subseteq f\\left(\\text{top}\\left(T\\right)\\right)].</p>\n<p>(In Isabelle, we would write [image: \\overline{f}] as *map_topology<br>\nf*.) ([image:<br>\n\\text{top}\\left(T\\right)] denotes the topspace of [image: T].)</p>\n<p>This construction has the following desired properties:  [image:<br>\n\\overline{\\text{id}}=\\text{id}].   [image: \\overline{f\\circ<br>\ng}=\\overline{f}\\circ\\overline{g}].    [image:<br>\n\\text{top}\\left(\\overline{f}\\left(T\\right)\\right)=f\\left(\\text{top}\\left(T\\right)\\right)].<br>\n  If [image: f=g] on [image: \\text{top}\\left(T\\right)], then [image:<br>\n\\overline{f}\\left(T\\right)=\\overline{g}\\left(T\\right)].</p>\n<p>We can not define <em>rel_topology.</em> The idea how to do it is inspired by the<br>\nway relations on sets are lifted to relations on probability distributions<br>\n(e.g., in probabilistic relational Hoare logic). It is also similar to how<br>\n<em>rel_filter</em> is defined. The basic idea is to say that two topologies are<br>\nrelated (for some relation [image: R]) if there is a topology on pairs (I<br>\ncall it the witness-topology) such that the witness-topology in a certain<br>\nsense satisfies [image: R] and the two topologies are the left/right<br>\nprojection of the joint-topology. Specifically, we define:</p>\n<p>For topologies [image: A,B],    [image: \\left(A,B\\right)\\in R]     iff<br>\n   [image:<br>\n\\exists T^{\\ast}.\\ \\ \\ \\text{top}\\left(T^{\\ast}\\right)\\subseteq R\\ \\<br>\n\\wedge\\ \\ \\ \\overline{\\text{fst}}\\left(T^{\\ast}\\right)=A\\ \\ \\ \\wedge\\ \\<br>\n\\overline{\\text{snd}}\\left(T^{\\ast}\\right)=B]</p>\n<p>Concerning the properties you desired:</p>\n<p>lemma rel_topology_eq [relator_eq]: \"rel_topology (=) = (=)\"<br>\n  sorry</p>\n<p>Holds. (Witness-topology for the [image: \\Leftarrow]-direction is [image:<br>\n\\overline{\\text{double}}\\left(A\\right)] where [image:<br>\n\\text{double}\\left(x\\right):=\\left(x,x\\right)].)</p>\n<p>lemma rel_topology_mono [relator_mono]: \"rel_topology A ≤ rel_topology B\"<br>\n  if le: \"A ≤ B\"</p>\n<p>Holds trivially by definition.</p>\n<p>lemma rel_topology_distr [relator_distr]:<br>\n  \"rel_topology A OO rel_topology B = rel_topology (A OO B)\"</p>\n<p>I do not know whether it holds. It looks like a difficult one to me. Is it<br>\nan important property?</p>\n<p>lemma Quotient_topology[quot_map]:<br>\n  assumes \"Quotient R Abs Rep T\"<br>\n  shows \"Quotient (rel_topology R) (topo_map Abs) (topo_map Rep)<br>\n(rel_topology T)\"</p>\n<p>Holds. The proof is more involved. (Quotient involves a number of<br>\nproperties, and for most of them one has to choose the witness-topology<br>\nsuitably.) But if I am not mistaken, it all works fine with a bit of work.</p>\n<p>[For my own reference: Quicknotes 2022, p.95–100.]</p>\n<p>I think this is better than the definition that I am currently using. (The<br>\ndefinition I use right now works for my purposes, but it may not be<br>\nsufficient for other purposes. And since one cannot use two relators for<br>\nthe same typo (I think), it would be good to have only one (good)<br>\ndefinition of *rel_topology *throughout all Isabelle theories.</p>\n<p>So if you feel that this is worth pursuing, maybe we can coordinate further<br>\noff-list? (I would also like to avoid duplicating work if we both develop<br>\nlifting of topologies.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 281609727,
        "sender_full_name": "Email Gateway",
        "timestamp": 1652031169
    }
]