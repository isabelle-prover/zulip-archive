[
    {
        "content": "<p><strong>From:</strong> Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;</p>\n<p>Consider the following theory:</p>\n<p>theory Scratch<br>\n  imports Main</p>\n<p>begin</p>\n<p>datatype a = A unit unit and b = B ‹unit ⇒ a›</p>\n<p>declare [[simp_trace]]<br>\nlemma \"x = B (A ())\"<br>\n  apply simp</p>\n<p>This produces the following output:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\nx = B (A ()) <br>\nexception UnequalLengths raised (line 553 of \"library.ML”)</p>\n<p>The exception goes away if we eliminate the mutually recursive datatype in favour of separate declarations, but the original of this issue is necessarily mutually recursive. Perhaps there are simpprocs involved with datatypes?</p>\n<p>Larry</p>",
        "id": 569232695,
        "sender_full_name": "Email Gateway",
        "timestamp": 1768995583
    },
    {
        "content": "<p><strong>From:</strong> Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;</p>\n<p>This seems to be indeed coming from Manuel's datatype_no_proper_subterm simproc.</p>\n<p>using [[simproc del: datatype_no_proper_subterm]]</p>\n<p>removes the low-level exception.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 21 Jan 2026, at 12.39, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Consider the following theory:</p>\n<p>theory Scratch<br>\n imports Main</p>\n<p>begin</p>\n<p>datatype a = A unit unit and b = B ‹unit ⇒ a›</p>\n<p>declare [[simp_trace]]<br>\nlemma \"x = B (A ())\"<br>\n apply simp</p>\n<p>This produces the following output:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\nx = B (A ()) <br>\nexception UnequalLengths raised (line 553 of \"library.ML”)</p>\n<p>The exception goes away if we eliminate the mutually recursive datatype in favour of separate declarations, but the original of this issue is necessarily mutually recursive. Perhaps there are simpprocs involved with datatypes?</p>\n<p>Larry<br>\n</p>\n</blockquote>",
        "id": 569243424,
        "sender_full_name": "Email Gateway",
        "timestamp": 1768999022
    },
    {
        "content": "<p><strong>From:</strong> Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;</p>\n<p>Okay, I see what the problem is. The simproc breaks in the presence of <br>\npartially applied constructors. That kind of issue can only arise in <br>\ndatatypes that have constructors whose arguments are functions returing <br>\ndatatypes. Such datatypes are out of scope for the simproc anyway, since <br>\nthey only have a \"dummy\" size function that always returns 0. If the <br>\nsimproc didn't break at the \"~~\" (raising an UnequalLengths), it would <br>\nbreak later on at the \"rule_by_tactic\" since it would have to show \"0 ≠ 0\".</p>\n<p>I think the following two steps would make sense to make this more robust:</p>\n<p>– catch the Unequal_Lengths exception and just abort the simproc</p>\n<p>– make the \"rule_by_tactic\" fail more gracefully in case the \"size\" <br>\nfunction does not work as intended</p>\n<p>It might be even better to have a check at the beginning to make sure <br>\nthat the datatype expression is in the \"supported fragment\" to begin <br>\nwith. But I'm not sure how one would do that. Perhaps it was a bad idea <br>\nto create this simproc in the first place. But it <em>does</em> do something <br>\nuseful, that users might reasonably expect Isabelle's automation to be <br>\nable to do. Namely automatically show that something like \"xs = Cons a <br>\n(Cons b xs)\" is false.</p>\n<p>Perhaps some of the datatype experts could comment on whether there is a <br>\nrobust way to check if a datatype has a \"proper\" size function and not <br>\njust a \"dummy\" one.</p>\n<p>Manuel</p>\n<p>On 21/01/2026 13:36, Dmitriy Traytel (via cl-isabelle-users Mailing <br>\nList) wrote:</p>\n<blockquote>\n<p>This seems to be indeed coming from Manuel's datatype_no_proper_subterm simproc.</p>\n<p>using [[simproc del: datatype_no_proper_subterm]]</p>\n<p>removes the low-level exception.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 21 Jan 2026, at 12.39, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Consider the following theory:</p>\n<p>theory Scratch<br>\n  imports Main</p>\n<p>begin</p>\n<p>datatype a = A unit unit and b = B ‹unit ⇒ a›</p>\n<p>declare [[simp_trace]]<br>\nlemma \"x = B (A ())\"<br>\n  apply simp</p>\n<p>This produces the following output:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\nx = B (A ())<br>\nexception UnequalLengths raised (line 553 of \"library.ML”)</p>\n<p>The exception goes away if we eliminate the mutually recursive datatype in favour of separate declarations, but the original of this issue is necessarily mutually recursive. Perhaps there are simpprocs involved with datatypes?</p>\n<p>Larry<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 569278994,
        "sender_full_name": "Email Gateway",
        "timestamp": 1769007958
    },
    {
        "content": "<p><strong>From:</strong> Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<p>Oops. I had a feeling that might be the culprit. I'll investigate.</p>\n<p>On 21/01/2026 13:36, Dmitriy Traytel wrote:</p>\n<blockquote>\n<p>This seems to be indeed coming from Manuel's datatype_no_proper_subterm simproc.</p>\n<p>using [[simproc del: datatype_no_proper_subterm]]</p>\n<p>removes the low-level exception.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 21 Jan 2026, at 12.39, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Consider the following theory:</p>\n<p>theory Scratch<br>\n  imports Main</p>\n<p>begin</p>\n<p>datatype a = A unit unit and b = B ‹unit ⇒ a›</p>\n<p>declare [[simp_trace]]<br>\nlemma \"x = B (A ())\"<br>\n  apply simp</p>\n<p>This produces the following output:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\nx = B (A ())<br>\nexception UnequalLengths raised (line 553 of \"library.ML”)</p>\n<p>The exception goes away if we eliminate the mutually recursive datatype in favour of separate declarations, but the original of this issue is necessarily mutually recursive. Perhaps there are simpprocs involved with datatypes?</p>\n<p>Larry<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 569289410,
        "sender_full_name": "Email Gateway",
        "timestamp": 1769010507
    },
    {
        "content": "<p><strong>From:</strong> Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;</p>\n<p>Hi Manuel,</p>\n<p>Something strange happened with your follow up response, which didn’t arrive in my inbox (nor in my spam filter). I do see it on Zulip’s mailing list mirror.</p>\n<p>Okay, I see what the problem is. The simproc breaks in the presence of partially applied constructors. That kind of issue can only arise in datatypes that have constructors whose arguments are functions returing datatypes. Such datatypes are out of scope for the simproc anyway, since they only have a \"dummy\" size function that always returns 0. If the simproc didn't break at the \"~~\" (raising an UnequalLengths), it would break later on at the \"rule_by_tactic\" since it would have to show \"0 ≠ 0\".</p>\n<p>I think the following two steps would make sense to make this more robust:</p>\n<p>– catch the Unequal_Lengths exception and just abort the simproc</p>\n<p>– make the \"rule_by_tactic\" fail more gracefully in case the \"size\" function does not work as intended</p>\n<p>It might be even better to have a check at the beginning to make sure that the datatype expression is in the \"supported fragment\" to begin with. But I'm not sure how one would do that. Perhaps it was a bad idea to create this simproc in the first place. But it <em>does</em> do something useful, that users might reasonably expect Isabelle's automation to be able to do. Namely automatically show that something like \"xs = Cons a (Cons b xs)\" is false.</p>\n<p>Perhaps some of the datatype experts could comment on whether there is a robust way to check if a datatype has a \"proper\" size function and not just a \"dummy\" one.</p>\n<p>The canonical way would be to query the size database and analyze the returned equations for whatever you precisely mean by being “proper”/“dummy” (I guess \"all right-hand-sides = 0\" is your definition of dummy):</p>\n<p>ML ‹BNF_LFP_Size.size_of @{context} @{type_name b}›</p>\n<p>Note that datatypes themselves know nothing about size functions; this is a separate plugin with a separate database. Datatypes do know through which type constructors they nest recursion. For example the following code checks whether recursion is nested through the function type.</p>\n<p>ML ‹BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name b}<br>\n |&gt; the |&gt; #fp_nesting_bnfs |&gt; map (Binding.name_of o BNF_Def.name_of_bnf)<br>\n |&gt; Library.exists (fn T =&gt; T = @{type_name fun})›</p>\n<p>Although “fun” is perhaps just one example where this shows up; I think size functions returning 0 could have other origins, e.g., when codatatypes or other “too large\" types are involved in datatype declarations.</p>\n<p>Best wishes,<br>\nDmitriy</p>\n<p>On 21 Jan 2026, at 13.54, Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt; wrote:</p>\n<p>Oops. I had a feeling that might be the culprit. I'll investigate.</p>\n<p>On 21/01/2026 13:36, Dmitriy Traytel wrote:<br>\nThis seems to be indeed coming from Manuel's datatype_no_proper_subterm simproc.</p>\n<p>using [[simproc del: datatype_no_proper_subterm]]</p>\n<p>removes the low-level exception.</p>\n<p>Dmitriy</p>\n<p>On 21 Jan 2026, at 12.39, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Consider the following theory:</p>\n<p>theory Scratch<br>\n imports Main</p>\n<p>begin</p>\n<p>datatype a = A unit unit and b = B ‹unit ⇒ a›</p>\n<p>declare [[simp_trace]]<br>\nlemma \"x = B (A ())\"<br>\n apply simp</p>\n<p>This produces the following output:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\nx = B (A ())<br>\nexception UnequalLengths raised (line 553 of \"library.ML”)</p>\n<p>The exception goes away if we eliminate the mutually recursive datatype in favour of separate declarations, but the original of this issue is necessarily mutually recursive. Perhaps there are simpprocs involved with datatypes?</p>\n<p>Larry</p>",
        "id": 569314815,
        "sender_full_name": "Email Gateway",
        "timestamp": 1769016739
    },
    {
        "content": "<p><strong>From:</strong> Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;</p>\n<p>On 21/01/2026 12:39, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>datatype a = A unit unit and b = B ‹unit ⇒ a›</p>\n<p>declare [[simp_trace]]<br>\nlemma \"x = B (A ())\"<br>\n   apply simp</p>\n<p>This produces the following output:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\nx = B (A ())<br>\nexception UnequalLengths raised (line 553 of \"library.ML”)</p>\n</blockquote>\n<p>Side-remark: this is how to see more directly from where the failure comes from.</p>\n<p>declare [[simp_debug]]<br>\nlemma \"x = B (A ())\"<br>\n   apply simp<br>\n(*<br>\n...<br>\n[1]Trying procedure \"BNF_Least_Fixpoint.datatype_no_proper_subterm\" on:<br>\nx = B (A ())<br>\nexception UnequalLengths raised (line 553 of \"library.ML\")<br>\n*)</p>\n<p>Thus it becomes clear that this is not a \"low level simplifier failure\", but a <br>\nproblem in the user-space library.</p>\n<p>Makarius</p>",
        "id": 569326512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1769020124
    },
    {
        "content": "<p><strong>From:</strong> Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;</p>\n<p>On 21/01/2026 18:31, Dmitriy Traytel (via cl-isabelle-users Mailing <br>\nList) wrote:</p>\n<blockquote>\n<p>The canonical way would be to query the size database and analyze the <br>\nreturned equations for whatever you precisely mean by being <br>\n“proper”/“dummy” (I guess \"all right-hand-sides = 0\" is your <br>\ndefinition of dummy):</p>\n</blockquote>\n<p>Hm, that still looks a bit brittle and ad-hoc. But it might work as a <br>\nfirst sanity check to abort early.</p>\n<p>I still need to rework the latter part as well though. Right now it <br>\nassumes that the proof with the \"size\" function will always go through <br>\nif a \"size\" function exists, and throws an exception if it doesn't. That <br>\nis probably an overly optimistic assumption considering the complexity <br>\nof the datatype/BNF package.</p>\n<p>A cleaner solution would be if the datatype package itself could provide <br>\nsome kind of proper subterm relation and a proof that it is irreflexive. <br>\nBut I assume that that's not straightforward to do or we would have done <br>\nit back then. Plus I think it is probably not a good idea to add even <br>\nmore bulk to the datatype package.</p>\n<p>@Makarius: Thanks for the hint about simp_debug. I did not know about <br>\nthat option.</p>\n<p>Manuel</p>",
        "id": 569449512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1769076211
    }
]