[
    {
        "content": "<p>From: \"\\\"Mulder, Ike\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports … begin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination rules of the Claset of two theories.</p>\n<p>The merging happens here&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604</a>&gt; – merging safe elimination rules specifically turns out to be slow in our case. There are two reasons for that, I think:</p>\n<p>1.  The complexity of merging the rules seems higher than it should be<br>\n  2.  We apparently have a lot (about 20000) safe elimination rules. Most of these are automatically added when declaring <code>datatype</code>s<br>\nThe safe elimination rules added by new datatypes have the form <code>caseI = caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic when defining enums with a lot of cases: the number of safe elimination rules added is quadratic in the number of cases in the enum. The addition of these elimination rules happens here&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe elimination rules for newly defined <code>datatype</code>s. That seems to improve performance a lot.</p>\n<p>Best, Ike</p>",
        "id": 525149986,
        "sender_full_name": "Email Gateway",
        "timestamp": 1750500743
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nI recall that there were some big performance problems in one of the AFP <br>\nentries on p-adic numbers as well. Switching in and out of locale <br>\ncontexts sometimes takes a full minute. I wonder if this is related to <br>\nsome of the issues you mention.</p>\n<p>Manuel</p>\n<p>On 20/06/2025 14:17, \"Mulder, Ike\" (via cl-isabelle-users Mailing List) <br>\nwrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … \nimports … begin</code> header is taking anywhere from 5-20 seconds.</p>\n<p>The second bottleneck we’re seeing is in the merging of elimination <br>\nrules of the Claset of two theories.</p>\n<p>The merging happens here <br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604</a>&gt; <br>\n– merging safe elimination rules specifically turns out to be slow in <br>\nour case. There are two reasons for that, I think:</p>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n<li>We apparently have a lot (about 20000) safe elimination rules.<br>\n    Most of these are automatically added when declaring <code>datatype</code>s</li>\n</ol>\n<p>The safe elimination rules added by new datatypes have the form <code>caseI \n= caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes <br>\nproblematic when defining enums with a lot of cases: the number of <br>\nsafe elimination rules added is quadratic in the number of cases in <br>\nthe enum. The addition of these elimination rules happens here <br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <br>\n<code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> <br>\nrules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe <br>\nelimination rules for newly defined <code>datatype</code>s. That seems to improve <br>\nperformance a lot.</p>\n<p>Best, Ike<br>\n</p>\n</blockquote>",
        "id": 525159475,
        "sender_full_name": "Email Gateway",
        "timestamp": 1750513106
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nPlenty of people have large datatype declarations. We need to find a way of handling them that doesn't generate a quadratic amount of anything. As a stopgap, the having the option of just relying on the (quadratically many) simprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large datatypes, since having lots of simprocs floating around causes its own issues.</p>\n<p>Larry</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of \"Mulder, Ike\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSent: 20 June 2025 13:17<br>\nTo: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: [isabelle] Merging elimination rules of Claset is slow - performance issue loading multiple theories</p>\n<p>Hello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports … begin</code> header is taking anywhere from 5-20 seconds.</p>\n<p>The second bottleneck we’re seeing is in the merging of elimination rules of the Claset of two theories.</p>\n<p>The merging happens here&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604</a>&gt; – merging safe elimination rules specifically turns out to be slow in our case. There are two reasons for that, I think:</p>\n<p>1.  The complexity of merging the rules seems higher than it should be<br>\n  2.  We apparently have a lot (about 20000) safe elimination rules. Most of these are automatically added when declaring <code>datatype</code>s</p>\n<p>The safe elimination rules added by new datatypes have the form <code>caseI = caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic when defining enums with a lot of cases: the number of safe elimination rules added is quadratic in the number of cases in the enum. The addition of these elimination rules happens here&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe elimination rules for newly defined <code>datatype</code>s. That seems to improve performance a lot.</p>\n<p>Best, Ike</p>",
        "id": 526388116,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751286037
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@ifi.lmu.de\">jasmin.blanchette@ifi.lmu.de</a>&gt;<br>\nI believe the behavior of mutually recursive datatypes might be worse than quadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy could comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the LeanHammer on the simplest goals I could imagine: the subgoals emerging from an induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] # xs\", because the quadratic distinct rules are not generated as theorem in Lean (presumably because of their quadratic nature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in mind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find a way of handling them that doesn't generate a quadratic amount of anything. As a stopgap, the having the option of just relying on the (quadratically many) simprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large datatypes, since having lots of simprocs floating around causes its own issues.</p>\n<p>Larry<br>\nFrom: <a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of \"Mulder, Ike\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSent: 20 June 2025 13:17<br>\nTo: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: [isabelle] Merging elimination rules of Claset is slow - performance issue loading multiple theories</p>\n<p>Hello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports … begin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination rules of the Claset of two theories.</p>\n<p>The merging happens here &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604</a>&gt; – merging safe elimination rules specifically turns out to be slow in our case. There are two reasons for that, I think:<br>\nThe complexity of merging the rules seems higher than it should be<br>\nWe apparently have a lot (about 20000) safe elimination rules. Most of these are automatically added when declaring <code>datatype</code>s<br>\nThe safe elimination rules added by new datatypes have the form <code>caseI = caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic when defining enums with a lot of cases: the number of safe elimination rules added is quadratic in the number of cases in the enum. The addition of these elimination rules happens here &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe elimination rules for newly defined <code>datatype</code>s. That seems to improve performance a lot.</p>\n<p>Best, Ike</p>\n</blockquote>",
        "id": 526401974,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751290044
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;<br>\nWhat about generating a function that enumerates cases of the datatype, <br>\nand having a single distinctiveness theorem for that function? Then only <br>\nthe proof of that theorem is expensive, and it can be used by <br>\nSledgehammer (but proof search might take a bit longer).</p>\n<p>Fabian</p>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be worse <br>\nthan quadratic. (For codatatypes, that's definitely the case.) Perhaps <br>\nDmitriy could comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the <br>\nLeanHammer on the simplest goals I could imagine: the subgoals <br>\nemerging from an induction proving \"xs ~= x # xs\". LeanHammer failed <br>\nto prove \"[] ~= [] # xs\", because the quadratic distinct rules are not <br>\ngenerated as theorem in Lean (presumably because of their quadratic <br>\nnature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep <br>\nSledgehammer in mind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find a <br>\nway of handling them that doesn't generate a quadratic amount of <br>\nanything. As a stopgap, the having the option of just relying on the <br>\n(quadratically many) simprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for <br>\nlarge datatypes, since having lots of simprocs floating around causes <br>\nits own issues.</p>\n<p>Larry</p>\n<hr>\n<p><em>From:</em>cl-isabelle-users-request@lists.cam.ac.uk <br>\n&lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of \"Mulder, <br>\nIke\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n<em>Sent:</em>20 June 2025 13:17<br>\n<em>To:</em>cl-isabelle-users@lists.cam.ac.uk <br>\n&lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n<em>Subject:</em>[isabelle] Merging elimination rules of Claset is slow - <br>\nperformance issue loading multiple theories<br>\nHello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … \nimports … begin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination <br>\nrules of the Claset of two theories.</p>\n<p>The merging happenshere <br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604&gt;–\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604&gt;–</a> <br>\nmerging safe elimination rules specifically turns out to be slow in <br>\nour case. There are two reasons for that, I think:</p>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n<li>We apparently have a lot (about 20000) safe elimination rules.<br>\n    Most of these are automatically added when declaring <code>datatype</code>s</li>\n</ol>\n<p>The safe elimination rules added by new datatypes have the form <br>\n<code>caseI = caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly <br>\nbecomes problematic when defining enums with a lot of cases: the <br>\nnumber of safe elimination rules added is quadratic in the number of <br>\ncases in the enum. The addition of these elimination rules <br>\nhappenshere <br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <br>\n<code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> <br>\nrules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these <br>\nsafe elimination rules for newly defined <code>datatype</code>s. That seems to <br>\nimprove performance a lot.</p>\n<p>Best, Ike<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 526405683,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751291086
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@ifi.lmu.de\">jasmin.blanchette@ifi.lmu.de</a>&gt;<br>\nYou mean something like</p>\n<p>myfunc Nil = 0<br>\n    myfunc (Cons _ _) = 1</p>\n<p>? If you want to investigate this, be my guest. :) Otherwise, I'll keep it as a project idea for a BSc thesis.</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 15:44, Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt; wrote:</p>\n<p>What about generating a function that enumerates cases of the datatype, and having a single distinctiveness theorem for that function? Then only the proof of that theorem is expensive, and it can be used by Sledgehammer (but proof search might take a bit longer).</p>\n<p>Fabian </p>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be worse than quadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy could comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the LeanHammer on the simplest goals I could imagine: the subgoals emerging from an induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] # xs\", because the quadratic distinct rules are not generated as theorem in Lean (presumably because of their quadratic nature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in mind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; &lt;mailto:<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find a way of handling them that doesn't generate a quadratic amount of anything. As a stopgap, the having the option of just relying on the (quadratically many) simprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large datatypes, since having lots of simprocs floating around causes its own issues.</p>\n<p>Larry<br>\nFrom: <a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a> &lt;mailto:<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; &lt;mailto:<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of \"Mulder, Ike\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; &lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSent: 20 June 2025 13:17<br>\nTo: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> &lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; &lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: [isabelle] Merging elimination rules of Claset is slow - performance issue loading multiple theories</p>\n<p>Hello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports … begin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination rules of the Claset of two theories.</p>\n<p>The merging happens here &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604</a>&gt; – merging safe elimination rules specifically turns out to be slow in our case. There are two reasons for that, I think:<br>\nThe complexity of merging the rules seems higher than it should be<br>\nWe apparently have a lot (about 20000) safe elimination rules. Most of these are automatically added when declaring <code>datatype</code>s<br>\nThe safe elimination rules added by new datatypes have the form <code>caseI = caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic when defining enums with a lot of cases: the number of safe elimination rules added is quadratic in the number of cases in the enum. The addition of these elimination rules happens here &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe elimination rules for newly defined <code>datatype</code>s. That seems to improve performance a lot.</p>\n<p>Best, Ike<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 526408562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751291829
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;<br>\nExactly. This sounds like a good thesis project.</p>\n<p>Fabian</p>\n<p>On 6/30/25 15:56, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>You mean something like</p>\n<p>myfunc Nil = 0<br>\nmyfunc (Cons _ _) = 1</p>\n<p>? If you want to investigate this, be my guest. :) Otherwise, I'll <br>\nkeep it as a project idea for a BSc thesis.</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 15:44, Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt; wrote:</p>\n<p>What about generating a function that enumerates cases of the <br>\ndatatype, and having a single distinctiveness theorem for that <br>\nfunction? Then only the proof of that theorem is expensive, and it <br>\ncan be used by Sledgehammer (but proof search might take a bit longer).</p>\n<p>Fabian</p>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be <br>\nworse than quadratic. (For codatatypes, that's definitely the case.) <br>\nPerhaps Dmitriy could comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out <br>\nthe LeanHammer on the simplest goals I could imagine: the subgoals <br>\nemerging from an induction proving \"xs ~= x # xs\". LeanHammer failed <br>\nto prove \"[] ~= [] # xs\", because the quadratic distinct rules are <br>\nnot generated as theorem in Lean (presumably because of their <br>\nquadratic nature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep <br>\nSledgehammer in mind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find <br>\na way of handling them that doesn't generate a quadratic amount of <br>\nanything. As a stopgap, the having the option of just relying on <br>\nthe (quadratically many) simprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for <br>\nlarge datatypes, since having lots of simprocs floating around <br>\ncauses its own issues.</p>\n<p>Larry</p>\n<hr>\n<p><em>From:</em>cl-isabelle-users-request@lists.cam.ac.uk <br>\n&lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of \"Mulder, <br>\nIke\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n<em>Sent:</em>20 June 2025 13:17<br>\n<em>To:</em>cl-isabelle-users@lists.cam.ac.uk <br>\n&lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n<em>Subject:</em>[isabelle] Merging elimination rules of Claset is slow - <br>\nperformance issue loading multiple theories<br>\nHello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … \nimports … begin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination <br>\nrules of the Claset of two theories.</p>\n<p>The merging happenshere <br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604&gt;–\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604&gt;–</a> <br>\nmerging safe elimination rules specifically turns out to be slow in <br>\nour case. There are two reasons for that, I think:</p>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n<li>We apparently have a lot (about 20000) safe elimination rules.<br>\n    Most of these are automatically added when declaring <code>datatype</code>s</li>\n</ol>\n<p>The safe elimination rules added by new datatypes have the form <br>\n<code>caseI = caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly <br>\nbecomes problematic when defining enums with a lot of cases: the <br>\nnumber of safe elimination rules added is quadratic in the number <br>\nof cases in the enum. The addition of these elimination rules <br>\nhappenshere <br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <br>\n<code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> <br>\nrules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these <br>\nsafe elimination rules for newly defined <code>datatype</code>s. That seems to <br>\nimprove performance a lot.</p>\n<p>Best, Ike</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 526421590,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751295224
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI have the vague memory that that's what the HOL4 guys do. An \"ord_t\" function. <br>\nAnd a threshold for ord_t to kick in and replace the quadratically many rules <br>\n(which, as Jasmin pointed out, are much better for s/h).</p>\n<p>Tobias</p>\n<p>On 30/06/2025 15:44, Fabian Huch wrote:</p>\n<blockquote>\n<p>What about generating a function that enumerates cases of the datatype, and <br>\nhaving a single distinctiveness theorem for that function? Then only the proof <br>\nof that theorem is expensive, and it can be used by Sledgehammer (but proof <br>\nsearch might take a bit longer).</p>\n<p>Fabian</p>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be worse than <br>\nquadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy <br>\ncould comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the <br>\nLeanHammer on the simplest goals I could imagine: the subgoals emerging from <br>\nan induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] # <br>\nxs\", because the quadratic distinct rules are not generated as theorem in Lean <br>\n(presumably because of their quadratic nature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in <br>\nmind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find a way of <br>\nhandling them that doesn't generate a quadratic amount of anything. As a <br>\nstopgap, the having the option of just relying on the (quadratically many) <br>\nsimprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large <br>\ndatatypes, since having lots of simprocs floating around causes its own issues.</p>\n<p>Larry</p>\n<hr>\n<p><em>From:</em>cl-isabelle-users-request@lists.cam.ac.uk &lt;cl-isabelle-users- <br>\n<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt; on behalf of \"Mulder, Ike\" &lt;cl-isabelle- <br>\n<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;<br>\n<em>Sent:</em>20 June 2025 13:17<br>\n<em>To:</em>cl-isabelle-users@lists.cam.ac.uk &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n<em>Subject:</em>[isabelle] Merging elimination rules of Claset is slow - <br>\nperformance issue loading multiple theories<br>\nHello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports … \nbegin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination rules of <br>\nthe Claset of two theories.</p>\n<p>The merging happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/\">https://isabelle.sketis.net/repos/isabelle/file/tip/</a> <br>\nsrc/Provers/classical.ML#l604&gt;– merging safe elimination rules specifically <br>\nturns out to be slow in our case. There are two reasons for that, I think:</p>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n<li>We apparently have a lot (about 20000) safe elimination rules. Most of<br>\n    these are automatically added when declaring <code>datatype</code>s</li>\n</ol>\n<p>The safe elimination rules added by new datatypes have the form <code>caseI = \ncaseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic <br>\nwhen defining enums with a lot of cases: the number of safe elimination rules <br>\nadded is quadratic in the number of cases in the enum. The addition of these <br>\nelimination rules happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/\">https://isabelle.sketis.net/repos/isabelle/</a> <br>\nfile/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <br>\n<code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that <br>\nscale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe <br>\nelimination rules for newly defined <code>datatype</code>s. That seems to improve <br>\nperformance a lot.</p>\n<p>Best, Ike<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/iVIrFiVag9JrdQKxosZZquLI/smime.p7s\">smime.p7s</a></p>",
        "id": 526428746,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751297234
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Jasmin, all,</p>\n<p>It is correct that the behavior of the internal type construction for (co)datatypes is worse than quadratic in the numbers of mutual types and type variables. However the number of constructors does not influence the internal construction much (there one works with a single constructor anyway). For example, for the below type the internal construction takes 56 milliseconds whereas producing the rest (including 3540 high-level distinctness theorems) takes 27 seconds on my machine (with parallelism disabled for more precise time measurements).</p>\n<p>ML ‹Multithreading.parallel_proofs := 0›<br>\ndeclare [[bnf_timing]]<br>\ndatatype a =<br>\n  A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | A9 | A10 |<br>\n  B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B10 |<br>\n  C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 |<br>\n  D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 | D10 |<br>\n  E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | E9 | E10 |<br>\n  F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | F9 | F10</p>\n<p>But distinctness is only one of the culprits (and as discussed might be useful for proof automation): disabling the plugins brings the time down to 8 seconds:</p>\n<p>datatype (plugins only:) a = …</p>\n<p>Depending on the use case one can also try selectively disable plugins.</p>\n<p>Dmitriy</p>\n<p>On 30 Jun 2025, at 15.20, Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@ifi.lmu.de\">jasmin.blanchette@ifi.lmu.de</a>&gt; wrote:</p>\n<p>I believe the behavior of mutually recursive datatypes might be worse than quadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy could comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the LeanHammer on the simplest goals I could imagine: the subgoals emerging from an induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] # xs\", because the quadratic distinct rules are not generated as theorem in Lean (presumably because of their quadratic nature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in mind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find a way of handling them that doesn't generate a quadratic amount of anything. As a stopgap, the having the option of just relying on the (quadratically many) simprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large datatypes, since having lots of simprocs floating around causes its own issues.</p>\n<p>Larry</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of \"Mulder, Ike\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSent: 20 June 2025 13:17<br>\nTo: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: [isabelle] Merging elimination rules of Claset is slow - performance issue loading multiple theories</p>\n<p>Hello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports … begin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination rules of the Claset of two theories.</p>\n<p>The merging happens here&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/Provers/classical.ML#l604</a>&gt; – merging safe elimination rules specifically turns out to be slow in our case. There are two reasons for that, I think:</p>\n<p>1.  The complexity of merging the rules seems higher than it should be<br>\n  2.  We apparently have a lot (about 20000) safe elimination rules. Most of these are automatically added when declaring <code>datatype</code>s</p>\n<p>The safe elimination rules added by new datatypes have the form <code>caseI = caseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic when defining enums with a lot of cases: the number of safe elimination rules added is quadratic in the number of cases in the enum. The addition of these elimination rules happens here&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083\">https://isabelle.sketis.net/repos/isabelle/file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083</a>&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that scale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe elimination rules for newly defined <code>datatype</code>s. That seems to improve performance a lot.</p>\n<p>Best, Ike</p>",
        "id": 526432517,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751298402
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21/06/2025 15:35, Manuel Eberl wrote:</p>\n<blockquote>\n<p>I recall that there were some big performance problems in one of the AFP <br>\nentries on p-adic numbers as well. Switching in and out of locale contexts <br>\nsometimes takes a full minute. I wonder if this is related to some of the <br>\nissues you mention.</p>\n</blockquote>\n<p>Performance problems need constructive existance proofs, otherwise they don't <br>\nexist.</p>\n<p>Can you point to specific locations in AFP?</p>\n<p>Makarius</p>",
        "id": 526451162,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751305120
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 20/06/2025 14:17, \"Mulder, Ike\" (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>We’ve been seeing performance problems where just the <code>theory … imports … \nbegin</code> header is taking anywhere from 5-20 seconds.</p>\n</blockquote>\n<p>I would not call this slow ...</p>\n<p>Many years ago we've seen theory merges &gt; 30 seconds occasionally, without <br>\ngetting worried.</p>\n<blockquote>\n<p>The second bottleneck we’re seeing is in the merging of elimination rules of <br>\nthe Claset of two theories.</p>\n<p>The merging happens here &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/\">https://isabelle.sketis.net/repos/isabelle/file/tip/</a> <br>\nsrc/Provers/classical.ML#l604&gt; – merging safe elimination rules specifically <br>\nturns out to be slow in our case. There are two reasons for that, I think:</p>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n<li>We apparently have a lot (about 20000) safe elimination rules. Most of<br>\n    these are automatically added when declaring <code>datatype</code>s</li>\n</ol>\n</blockquote>\n<p>Whenever there is a performance bottleneck, it needs to be \"proven <br>\nconstructively\" by some significant examples. This is important to reproduce <br>\nthe problem, and cross-check any attempts to improve the situation.</p>\n<p>Anything else is just speculation ...</p>\n<blockquote>\n<p>The safe elimination rules added by new datatypes have the form <code>caseI = caseJ \n==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic when <br>\ndefining enums with a lot of cases: the number of safe elimination rules added <br>\nis quadratic in the number of cases in the enum. The addition of these <br>\nelimination rules happens here &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/\">https://isabelle.sketis.net/repos/isabelle/</a> <br>\nfile/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging <code>simpset</code>s <br>\nstill seems to be fast, even in the presence of <code>simp</code> rules that scale <br>\nquadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe <br>\nelimination rules for newly defined <code>datatype</code>s. That seems to improve <br>\nperformance a lot.</p>\n</blockquote>\n<p>Now the focus has changed to datatypes. This raise a few more questions:</p>\n<p>* Is the claset merge operation really slow, or are the involved clasets <br>\njust very big?</p>\n<p>* Could the datatype package do something differently, with significant <br>\nimprovements and without too much extra complexity?</p>\n<p>* Could your application do something different? Where are the many <br>\ndatatypes coming from, actually? Can you avoid the expensive merge operations, <br>\ne.g. by making the theory graph more linear?</p>\n<p>Makarius</p>",
        "id": 526452205,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751305530
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 30/06/2025 19:36, Makarius wrote:</p>\n<blockquote>\n<p>* Could your application do something different? Where are the many <br>\ndatatypes coming from, actually?</p>\n</blockquote>\n<p>And more: Are the datatypes genuine datatypes (disjoint sums), or just record <br>\ntypes done with the somewhat bulky datatype_record package?</p>\n<p>Makarius</p>",
        "id": 526457796,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751307041
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nThe entry in question is \"Padic_Field\", and the theory that is affected <br>\nmost severely is \"Padic_Field_Powers\". We talked about this entry quite <br>\na bit when it was first submitted three years ago. Back then the <br>\nperformance problems were so severe I was wondering whether we could <br>\neven accept it.</p>\n<p>The entire entry is still pretty slow for what it is. But it's not as <br>\nexcessive as it once was. I asked the author to try to reduce the <br>\ncontext switches as much as possible and that already helped a lot. But <br>\nI also think some of the other performance tuning you did to Isabelle <br>\nsince then also helped.</p>\n<p>As it stands now, there are still two \"context\" commands in there that <br>\ntake about 5 s (elapsed) on my machine, namely in line 41 and line <br>\n10404. The \"lemma\" command on line 2837 and the subsequent \"blast\" call <br>\nalso take about 2 seconds each, presumably due to the context switch <br>\ninduced by \"(in padic_fields)\". As I recall, this used to be almost an <br>\norder of magnitude worse.</p>\n<p>Of course, 2 or 5 seconds is not dramatic. But in a development that <br>\nuses locales quite a bit, these numbers accumulate to an extent that <br>\nmakes working with such a development interactively (especially during <br>\nrefactoring) very annoying.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 30/06/2025 19:38, Makarius wrote:</p>\n<blockquote>\n<p>On 21/06/2025 15:35, Manuel Eberl wrote:</p>\n<blockquote>\n<p>I recall that there were some big performance problems in one of the <br>\nAFP entries on p-adic numbers as well. Switching in and out of locale <br>\ncontexts sometimes takes a full minute. I wonder if this is related <br>\nto some of the issues you mention.</p>\n</blockquote>\n<p>Performance problems need constructive existance proofs, otherwise <br>\nthey don't exist.</p>\n<p>Can you point to specific locations in AFP?</p>\n<p>Makarius</p>\n</blockquote>",
        "id": 526466372,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751309579
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nFor what it’s worth, it’s only with enumerated types (consisting of only nullary constructors), where we use a conversion to solve equations between them. The conversion works by mapping the constructors into numbers.</p>\n<p>Michael</p>\n<p>On 1/7/2025, 01:30, \"<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>\" &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; wrote:<br>\nI have the vague memory that that's what the HOL4 guys do. An \"ord_t\" function.<br>\nAnd a threshold for ord_t to kick in and replace the quadratically many rules<br>\n(which, as Jasmin pointed out, are much better for s/h).</p>\n<p>Tobias</p>\n<p>On 30/06/2025 15:44, Fabian Huch wrote:</p>\n<blockquote>\n<p>What about generating a function that enumerates cases of the datatype, and<br>\nhaving a single distinctiveness theorem for that function? Then only the proof<br>\nof that theorem is expensive, and it can be used by Sledgehammer (but proof<br>\nsearch might take a bit longer).</p>\n<p>Fabian</p>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be worse than<br>\nquadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy<br>\ncould comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the<br>\nLeanHammer on the simplest goals I could imagine: the subgoals emerging from<br>\nan induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] #<br>\nxs\", because the quadratic distinct rules are not generated as theorem in Lean<br>\n(presumably because of their quadratic nature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in<br>\nmind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;lp15@cam.ac.uk&lt;mailto:<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find a way of<br>\nhandling them that doesn't generate a quadratic amount of anything. As a<br>\nstopgap, the having the option of just relying on the (quadratically many)<br>\nsimprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large<br>\ndatatypes, since having lots of simprocs floating around causes its own issues.</p>\n<p>Larry</p>\n<hr>\n<p><em>From:</em>cl-isabelle-users-request@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; &lt;cl-isabelle-users-<br>\nrequest@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt;&gt; on behalf of \"Mulder, Ike\" &lt;cl-isabelle-<br>\nusers@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;&gt;<br>\n<em>Sent:</em>20 June 2025 13:17<br>\n<em>To:</em>cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; &lt;cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;&gt;<br>\n<em>Subject:</em>[isabelle] Merging elimination rules of Claset is slow -<br>\nperformance issue loading multiple theories<br>\nHello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports …\nbegin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination rules of<br>\nthe Claset of two theories.</p>\n<p>The merging happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/\">https://isabelle.sketis.net/repos/isabelle/file/tip/</a><br>\nsrc/Provers/classical.ML#l604&gt;– merging safe elimination rules specifically<br>\nturns out to be slow in our case. There are two reasons for that, I think:</p>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n<li>We apparently have a lot (about 20000) safe elimination rules. Most of<br>\n    these are automatically added when declaring <code>datatype</code>s</li>\n</ol>\n<p>The safe elimination rules added by new datatypes have the form <code>caseI =\ncaseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic<br>\nwhen defining enums with a lot of cases: the number of safe elimination rules<br>\nadded is quadratic in the number of cases in the enum. The addition of these<br>\nelimination rules happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/\">https://isabelle.sketis.net/repos/isabelle/</a><br>\nfile/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging<br>\n<code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that<br>\nscale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe<br>\nelimination rules for newly defined <code>datatype</code>s. That seems to improve<br>\nperformance a lot.</p>\n<p>Best, Ike<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 526499233,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751325202
    },
    {
        "content": "<p>From: \"\\\"Becker, Hanno\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nCan this be put into the user’s hand? Allow them to replace the autogeneration of (in)equality related lemmas by a simproc (perhaps through the existing plugin mechanism). This helps applications dealing with large datatypes (esp. enumerated types), while not enforcing change where the current approach works fine.</p>\n<p>Hanno</p>\n<p>From: &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of Michael Norrish &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nReply-To: \"<a href=\"mailto:Michael.Norrish@anu.edu.au\">Michael.Norrish@anu.edu.au</a>\" &lt;<a href=\"mailto:Michael.Norrish@anu.edu.au\">Michael.Norrish@anu.edu.au</a>&gt;<br>\nDate: Tuesday, 1 July 2025 at 00:14<br>\nTo: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;, \"<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: RE: [EXTERNAL] [isabelle] Merging elimination rules of Claset is slow - performance issue loading multiple theories</p>\n<p>CAUTION: This email originated from outside of the organization. Do not click links or open attachments unless you can confirm the sender and know the content is safe.</p>\n<p>For what it’s worth, it’s only with enumerated types (consisting of only nullary constructors), where we use a conversion to solve equations between them. The conversion works by mapping the constructors into numbers.</p>\n<p>Michael</p>\n<p>On 1/7/2025, 01:30, \"<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>\" &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; wrote:<br>\nI have the vague memory that that's what the HOL4 guys do. An \"ord_t\" function.<br>\nAnd a threshold for ord_t to kick in and replace the quadratically many rules<br>\n(which, as Jasmin pointed out, are much better for s/h).</p>\n<p>Tobias</p>\n<p>On 30/06/2025 15:44, Fabian Huch wrote:</p>\n<blockquote>\n<p>What about generating a function that enumerates cases of the datatype, and<br>\nhaving a single distinctiveness theorem for that function? Then only the proof<br>\nof that theorem is expensive, and it can be used by Sledgehammer (but proof<br>\nsearch might take a bit longer).</p>\n<p>Fabian</p>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be worse than<br>\nquadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy<br>\ncould comment on that.</p>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the<br>\nLeanHammer on the simplest goals I could imagine: the subgoals emerging from<br>\nan induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] #<br>\nxs\", because the quadratic distinct rules are not generated as theorem in Lean<br>\n(presumably because of their quadratic nature).</p>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in<br>\nmind. :)</p>\n<p>Jasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;lp15@cam.ac.uk&lt;mailto:<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;&gt; wrote:</p>\n<p>Plenty of people have large datatype declarations. We need to find a way of<br>\nhandling them that doesn't generate a quadratic amount of anything. As a<br>\nstopgap, the having the option of just relying on the (quadratically many)<br>\nsimprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large<br>\ndatatypes, since having lots of simprocs floating around causes its own issues.</p>\n<p>Larry</p>\n<hr>\n<p><em>From:</em>cl-isabelle-users-request@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; &lt;cl-isabelle-users-<br>\nrequest@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt;&gt; on behalf of \"Mulder, Ike\" &lt;cl-isabelle-<br>\nusers@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;&gt;<br>\n<em>Sent:</em>20 June 2025 13:17<br>\n<em>To:</em>cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; &lt;cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;&gt;<br>\n<em>Subject:</em>[isabelle] Merging elimination rules of Claset is slow -<br>\nperformance issue loading multiple theories<br>\nHello,</p>\n<p>We’ve been seeing performance problems where just the <code>theory … imports …\nbegin</code> header is taking anywhere from 5-20 seconds.<br>\nThe second bottleneck we’re seeing is in the merging of elimination rules of<br>\nthe Claset of two theories.</p>\n<p>The merging happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/\">https://isabelle.sketis.net/repos/isabelle/file/tip/</a><br>\nsrc/Provers/classical.ML#l604&gt;– merging safe elimination rules specifically<br>\nturns out to be slow in our case. There are two reasons for that, I think:</p>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n<li>We apparently have a lot (about 20000) safe elimination rules. Most of<br>\n    these are automatically added when declaring <code>datatype</code>s</li>\n</ol>\n<p>The safe elimination rules added by new datatypes have the form <code>caseI =\ncaseJ ==&gt; R</code> for all <code>i != j</code>. Therefore, this mainly becomes problematic<br>\nwhen defining enums with a lot of cases: the number of safe elimination rules<br>\nadded is quadratic in the number of cases in the enum. The addition of these<br>\nelimination rules happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/\">https://isabelle.sketis.net/repos/isabelle/</a><br>\nfile/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083&gt;.</p>\n<p>As for 1), I think the complexity could be improved because merging<br>\n<code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that<br>\nscale quadratically in the number of cases in an Enum.</p>\n<p>For now, I have written a small scrappy plugin that deletes these safe<br>\nelimination rules for newly defined <code>datatype</code>s. That seems to improve<br>\nperformance a lot.</p>\n<p>Best, Ike<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 526518330,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751340862
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHi Michael,</p>\n<p>Thanks for the correction. You are using a conversion. One could also just <br>\nsimplify with the thm</p>\n<p>ord_t x = ord_t y ==&gt; x = y</p>\n<p>The conversion is for efficiency? In particular because it only fires if x and y <br>\nare constructors?</p>\n<p>Tobias</p>\n<p>On 01/07/2025 01:12, Michael Norrish wrote:</p>\n<blockquote>\n<p>For what it’s worth, it’s only with enumerated types (consisting of only nullary <br>\nconstructors), where we use a conversion to solve equations between them. The <br>\nconversion works by mapping the constructors into numbers.</p>\n<p>Michael</p>\n<p>On 1/7/2025, 01:30, \"<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>\" &lt;cl-isabelle- <br>\n<a href=\"mailto:users-request@lists.cam.ac.uk\">users-request@lists.cam.ac.uk</a>&gt; wrote:</p>\n<p>I have the vague memory that that's what the HOL4 guys do. An \"ord_t\" function.</p>\n<p>And a threshold for ord_t to kick in and replace the quadratically many rules</p>\n<p>(which, as Jasmin pointed out, are much better for s/h).</p>\n<p>Tobias</p>\n<p>On 30/06/2025 15:44, Fabian Huch wrote:</p>\n<blockquote>\n<p>What about generating a function that enumerates cases of the datatype, and</p>\n</blockquote>\n<blockquote>\n<p>having a single distinctiveness theorem for that function? Then only the proof</p>\n</blockquote>\n<blockquote>\n<p>of that theorem is expensive, and it can be used by Sledgehammer (but proof</p>\n</blockquote>\n<blockquote>\n<p>search might take a bit longer).</p>\n</blockquote>\n<p>&gt;</p>\n<p>&gt;</p>\n<blockquote>\n<p>Fabian</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be worse than</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>quadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>could comment on that.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>LeanHammer on the simplest goals I could imagine: the subgoals emerging from</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>an induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] #</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>xs\", because the quadratic distinct rules are not generated as theorem in Lean</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>(presumably because of their quadratic nature).</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>mind. :)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Jasmin</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>--</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Prof. Dr. Jasmin Blanchette</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Chair of Theoretical Computer Science and Theorem Proving</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Ludwig-Maximilians-Universität München</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Oettingenstr. 67, 80538 München, Germany</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Tel.: +49 (0)89 2180 9341</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Web: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a> <br>\n&lt;<a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a> <br>\n&lt;mailto:<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;&gt; wrote:</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Plenty of people have large datatype declarations. We need to find a way of</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>handling them that doesn't generate a quadratic amount of anything. As a</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>stopgap, the having the option of just relying on the (quadratically many)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>simprules would be good.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The alternative of generating a simproc is probably good only for large</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>datatypes, since having lots of simprocs floating around causes its own issues.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Larry</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt; </p>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>From:</em>cl-isabelle-users-request@lists.cam.ac.uk &lt;mailto:cl-isabelle-users- <br>\n<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt; &lt;cl-isabelle-users-</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a> &lt;mailto:<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt;&gt; on behalf of <br>\n\"Mulder, Ike\" &lt;cl-isabelle-</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a> &lt;mailto:<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>Sent:</em>20 June 2025 13:17</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>To:</em>cl-isabelle-users@lists.cam.ac.uk &lt;mailto:cl-isabelle- <br>\n<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt; &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> &lt;mailto:cl-isabelle- <br>\n<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>Subject:</em>[isabelle] Merging elimination rules of Claset is slow -</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>performance issue loading multiple theories</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Hello,</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>We’ve been seeing performance problems where just the `theory … imports …</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>begin` header is taking anywhere from 5-20 seconds.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The second bottleneck we’re seeing is in the merging of elimination rules of</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>the Claset of two theories.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The merging happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/\">https://isabelle.sketis.net/repos/isabelle/file/</a> <br>\ntip/ &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/\">https://isabelle.sketis.net/repos/isabelle/file/tip/</a>&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>src/Provers/classical.ML#l604&gt;– merging safe elimination rules specifically</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>turns out to be slow in our case. There are two reasons for that, I think:</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>1. The complexity of merging the rules seems higher than it should be</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>2. We apparently have a lot (about 20000) safe elimination rules. Most of</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>these are automatically added when declaring <code>datatype</code>s</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The safe elimination rules added by new datatypes have the form `caseI =</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>caseJ ==&gt; R<code> for all </code>i != j`. Therefore, this mainly becomes problematic</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>when defining enums with a lot of cases: the number of safe elimination rules</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>added is quadratic in the number of cases in the enum. The addition of these</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>elimination rules happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/\">https://isabelle.sketis.net/repos/isabelle/</a> <br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/\">https://isabelle.sketis.net/repos/isabelle/</a>&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083&gt;.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>As for 1), I think the complexity could be improved because merging</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>scale quadratically in the number of cases in an Enum.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>For now, I have written a small scrappy plugin that deletes these safe</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>elimination rules for newly defined <code>datatype</code>s. That seems to improve</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>performance a lot.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Best, Ike</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;<br>\n</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/GfOM9rDwQpA0ThK3E-vqY4AN/smime.p7s\">smime.p7s</a></p>",
        "id": 526534089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751351813
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nTo be honest, I’m not sure of the historic motivation (it was me who wrote the code, but in 2002, and the commit message just says that I preferred to this to the unilateral use of your theorem as an iff, which is what had been being done).</p>\n<p>Of course, we could make the conversion fire on just the quadratically many constructor combinations (making the term-net bigger and grosser), but in fact we match against any equality on the type and then check to see that both sides are constants.  Only then do we apply the analogue of your ord_t.  Looking at the code I see we only do this for cases when #constructors &gt; 15, a number that I’m sure was pulled out of nowhere.  For smaller types, we just generate all the rewrites.</p>\n<p>Best wishes,<br>\nMichael</p>\n<p>On 1/7/2025, 16:36, \"Tobias Nipkow\" &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:<br>\nHi Michael,</p>\n<p>Thanks for the correction. You are using a conversion. One could also just<br>\nsimplify with the thm</p>\n<p>ord_t x = ord_t y ==&gt; x = y</p>\n<p>The conversion is for efficiency? In particular because it only fires if x and y<br>\nare constructors?</p>\n<p>Tobias</p>\n<p>On 01/07/2025 01:12, Michael Norrish wrote:</p>\n<blockquote>\n<p>For what it’s worth, it’s only with enumerated types (consisting of only nullary<br>\nconstructors), where we use a conversion to solve equations between them. The<br>\nconversion works by mapping the constructors into numbers.</p>\n<p>Michael</p>\n<p>On 1/7/2025, 01:30, \"cl-isabelle-users-request@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt;\" &lt;cl-isabelle-<br>\nusers-request@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:users-request@lists.cam.ac.uk\">users-request@lists.cam.ac.uk</a>&gt;&gt; wrote:</p>\n<p>I have the vague memory that that's what the HOL4 guys do. An \"ord_t\" function.</p>\n<p>And a threshold for ord_t to kick in and replace the quadratically many rules</p>\n<p>(which, as Jasmin pointed out, are much better for s/h).</p>\n<p>Tobias</p>\n<p>On 30/06/2025 15:44, Fabian Huch wrote:</p>\n<blockquote>\n<p>What about generating a function that enumerates cases of the datatype, and</p>\n</blockquote>\n<blockquote>\n<p>having a single distinctiveness theorem for that function? Then only the proof</p>\n</blockquote>\n<blockquote>\n<p>of that theorem is expensive, and it can be used by Sledgehammer (but proof</p>\n</blockquote>\n<blockquote>\n<p>search might take a bit longer).</p>\n</blockquote>\n<p>&gt;</p>\n<p>&gt;</p>\n<blockquote>\n<p>Fabian</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>On 6/30/25 15:20, Jasmin Blanchette wrote:</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I believe the behavior of mutually recursive datatypes might be worse than</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>quadratic. (For codatatypes, that's definitely the case.) Perhaps Dmitriy</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>could comment on that.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I cannot resist inserting an anecdote here. Last week, I tried out the</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>LeanHammer on the simplest goals I could imagine: the subgoals emerging from</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>an induction proving \"xs ~= x # xs\". LeanHammer failed to prove \"[] ~= [] #</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>xs\", because the quadratic distinct rules are not generated as theorem in Lean</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>(presumably because of their quadratic nature).</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Lesson: Thinking about \"simp\" is good, but we should also keep Sledgehammer in</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>mind. :)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Jasmin</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>--</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Prof. Dr. Jasmin Blanchette</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Chair of Theoretical Computer Science and Theorem Proving</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Ludwig-Maximilians-Universität München</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Oettingenstr. 67, 80538 München, Germany</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Tel.: +49 (0)89 2180 9341</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Web: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a><br>\n&lt;<a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html&gt;&lt;https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html%3e\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html&gt;&lt;https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html%3e</a>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>On 30. Jun 2025, at 14:20, Lawrence Paulson &lt;lp15@cam.ac.uk&lt;mailto:<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\n&lt;mailto:lp15@cam.ac.uk&lt;mailto:<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;&gt;&gt; wrote:</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Plenty of people have large datatype declarations. We need to find a way of</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>handling them that doesn't generate a quadratic amount of anything. As a</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>stopgap, the having the option of just relying on the (quadratically many)</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>simprules would be good.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The alternative of generating a simproc is probably good only for large</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>datatypes, since having lots of simprocs floating around causes its own issues.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Larry</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>From:</em>cl-isabelle-users-request@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; &lt;mailto:cl-isabelle-users-<br>\nrequest@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt;&gt; &lt;cl-isabelle-users-</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>request@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt; &lt;mailto:request@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:request@lists.cam.ac.uk\">request@lists.cam.ac.uk</a>&gt;&gt;&gt; on behalf of<br>\n\"Mulder, Ike\" &lt;cl-isabelle-</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt; &lt;mailto:users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;&gt;&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>Sent:</em>20 June 2025 13:17</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>To:</em>cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; &lt;mailto:cl-isabelle-<br>\nusers@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;&gt; &lt;cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; &lt;mailto:cl-isabelle-<br>\nusers@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:users@lists.cam.ac.uk\">users@lists.cam.ac.uk</a>&gt;&gt;&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><em>Subject:</em>[isabelle] Merging elimination rules of Claset is slow -</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>performance issue loading multiple theories</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Hello,</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>We’ve been seeing performance problems where just the `theory … imports …</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>begin` header is taking anywhere from 5-20 seconds.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The second bottleneck we’re seeing is in the merging of elimination rules of</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>the Claset of two theories.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The merging happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/\">https://isabelle.sketis.net/repos/isabelle/file/</a><br>\ntip/ &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/file/tip/&gt;&lt;https://isabelle.sketis.net/repos/isabelle/file/tip/%3e\">https://isabelle.sketis.net/repos/isabelle/file/tip/&gt;&lt;https://isabelle.sketis.net/repos/isabelle/file/tip/%3e</a>&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>src/Provers/classical.ML#l604&gt;– merging safe elimination rules specifically</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>turns out to be slow in our case. There are two reasons for that, I think:</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<ol>\n<li>The complexity of merging the rules seems higher than it should be</li>\n</ol>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>We apparently have a lot (about 20000) safe elimination rules. Most of</li>\n</ol>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>these are automatically added when declaring <code>datatype</code>s</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The safe elimination rules added by new datatypes have the form `caseI =</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>caseJ ==&gt; R<code> for all </code>i != j`. Therefore, this mainly becomes problematic</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>when defining enums with a lot of cases: the number of safe elimination rules</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>added is quadratic in the number of cases in the enum. The addition of these</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>elimination rules happenshere &lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/\">https://isabelle.sketis.net/repos/isabelle/</a><br>\n&lt;<a href=\"https://isabelle.sketis.net/repos/isabelle/&gt;&lt;https://isabelle.sketis.net/repos/isabelle/%3e\">https://isabelle.sketis.net/repos/isabelle/&gt;&lt;https://isabelle.sketis.net/repos/isabelle/%3e</a>&gt;</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>file/tip/src/HOL/Tools/Ctr_Sugar/ctr_sugar.ML#l1083&gt;.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>As for 1), I think the complexity could be improved because merging</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p><code>simpset</code>s still seems to be fast, even in the presence of <code>simp</code> rules that</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>scale quadratically in the number of cases in an Enum.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>For now, I have written a small scrappy plugin that deletes these safe</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>elimination rules for newly defined <code>datatype</code>s. That seems to improve</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>performance a lot.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Best, Ike</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 526547451,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751356740
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt;<br>\n(This thread covers a lot of topics which are not obviously covered by <br>\nthe subject. I am replying to the message which opened this particular <br>\nthread, in the hope that it won’t add more confusion.)</p>\n<blockquote>\n<p>Plenty of people have large datatype declarations. We need to find a way <br>\nof handling them that doesn't generate a quadratic amount of anything. <br>\nAs a stopgap, the having the option of just relying on the <br>\n(quadratically many) simprules would be good.</p>\n<p>The alternative of generating a simproc is probably good only for large <br>\ndatatypes, since having lots of simprocs floating around causes its own <br>\nissues.</p>\n</blockquote>\n<p>Concerning the quadratic blowup of distinctness rules: there was once a <br>\nmechanism to generate those rules for code generation lazily, and as <br>\nearly as 2009, we decided to drop it (very likely after a discussion <br>\nbetween Stefan Berghofer an me):</p>\n<p>hg log -r cda9a931a46b -p</p>\n<p>This seems to indicate that generating those rules is not a serious <br>\nissue, although different tools might still have their pitfalls to apply <br>\nthose rules efficiently.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p><a href=\"/user_uploads/14278/8Wq84iN1dA_T3f0VN3mxuCLV/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/2TKHkK07Ydyg4I2dWEnTo5BD/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 526644312,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751387009
    },
    {
        "content": "<p>From: \"\\\"Mulder, Ike\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nThe datatypes are genuine <code>datatype</code>s. Using Dimitry's example from the other thread, the slowdown we are seeing can be reproduced with three simple files:</p>\n<p>File Scratch1.thy:</p>\n<p>theory Scratch1<br>\n  imports<br>\n    Main<br>\nbegin</p>\n<p>datatype (plugins only:) enum1 =<br>\n  A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | A9 | A10 |<br>\n  B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B10 |<br>\n  C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 |<br>\n  D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 | D10 |<br>\n  E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | E9 | E10 |<br>\n  F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | F9 | F10 |<br>\n  G1 | G2 | G3 | G4 | G5 | G6 | G7 | G8 | G9 | G10 |<br>\n  H1 | H2 | H3 | H4 | H5 | H6 | H7 | H8 | H9 | H10 |<br>\n  I1 | I2 | I3 | I4 | I5 | I6 | I7 | I8 | I9 | I10 |<br>\n  J1 | J2 | J3 | J4 | J5 | J6 | J7 | J8 | J9 | J10</p>\n<p>datatype (plugins only:) enum2 =<br>\n  A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | A9 | A10 |<br>\n  B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B10 |<br>\n  C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 |<br>\n  D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 | D10 |<br>\n  E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | E9 | E10 |<br>\n  F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | F9 | F10 |<br>\n  G1 | G2 | G3 | G4 | G5 | G6 | G7 | G8 | G9 | G10 |<br>\n  H1 | H2 | H3 | H4 | H5 | H6 | H7 | H8 | H9 | H10 |<br>\n  I1 | I2 | I3 | I4 | I5 | I6 | I7 | I8 | I9 | I10 |<br>\n  J1 | J2 | J3 | J4 | J5 | J6 | J7 | J8 | J9 | J10</p>\n<p>end</p>\n<p>In file Scratch2.thy copy everything from Scratch1.thy, just replace the name of the theory with <code>Scratch2</code>.</p>\n<p>File Scratch3.thy:</p>\n<p>theory Scratch3<br>\n  imports<br>\n    Scratch1<br>\n    Scratch2<br>\nbegin<br>\n(* loading the imports here is slower than I'd expect *)</p>\n<p>ML‹<br>\n  val safe_elims_of_ctx =<br>\n    Context.Proof #&gt;<br>\n    Classical.get_cs #&gt;<br>\n    Classical.rep_cs #&gt; #safeEs #&gt;<br>\n    Item_Net.content #&gt; <a href=\"http://List.map\">List.map</a> #1 ;</p>\n<p>writeln (\"I see \" ^ (@{context} |&gt; safe_elims_of_ctx |&gt; List.length |&gt; Int.toString) ^ \" elim rules\\n\")<br>\n›</p>\n<p>end</p>\n<p>Best, Ike</p>\n<p>﻿On 30/06/2025, 19:10, \"Makarius\" &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a> &lt;mailto:<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;&gt; wrote:</p>\n<p>On 30/06/2025 19:36, Makarius wrote:</p>\n<blockquote>\n<ul>\n<li>Could your application do something different? Where are the many<br>\ndatatypes coming from, actually?</li>\n</ul>\n</blockquote>\n<p>And more: Are the datatypes genuine datatypes (disjoint sums), or just record<br>\ntypes done with the somewhat bulky datatype_record package?</p>\n<p>Makarius</p>",
        "id": 526810351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751465216
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt;<br>\nHi Ike,</p>\n<blockquote>\n<p>datatype (plugins only:) enum1 =<br>\n   A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | A9 | A10 |<br>\n   B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B10 |<br>\n   C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 |<br>\n   D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 | D10 |<br>\n   E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | E9 | E10 |<br>\n   F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | F9 | F10 |<br>\n   G1 | G2 | G3 | G4 | G5 | G6 | G7 | G8 | G9 | G10 |<br>\n   H1 | H2 | H3 | H4 | H5 | H6 | H7 | H8 | H9 | H10 |<br>\n   I1 | I2 | I3 | I4 | I5 | I6 | I7 | I8 | I9 | I10 |<br>\n   J1 | J2 | J3 | J4 | J5 | J6 | J7 | J8 | J9 | J10</p>\n<p>datatype (plugins only:) enum2 =<br>\n   A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | A9 | A10 |<br>\n   B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B10 |<br>\n   C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10 |<br>\n   D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 | D10 |<br>\n   E1 | E2 | E3 | E4 | E5 | E6 | E7 | E8 | E9 | E10 |<br>\n   F1 | F2 | F3 | F4 | F5 | F6 | F7 | F8 | F9 | F10 |<br>\n   G1 | G2 | G3 | G4 | G5 | G6 | G7 | G8 | G9 | G10 |<br>\n   H1 | H2 | H3 | H4 | H5 | H6 | H7 | H8 | H9 | H10 |<br>\n   I1 | I2 | I3 | I4 | I5 | I6 | I7 | I8 | I9 | I10 |<br>\n   J1 | J2 | J3 | J4 | J5 | J6 | J7 | J8 | J9 | J10</p>\n</blockquote>\n<p>I don’t know your particular applications, but depending on the logical <br>\nneeds such »enumerative« datatype declarations can be constructed <br>\nsimilar to type char in theory HOL.String. Or, if you don't need pattern <br>\npatching at all, specified as finite abstract type over natural numbers.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p><a href=\"/user_uploads/14278/ShWWX4JwpQmBtX6a3SCIyw9o/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/FHS90Ell3qX5QkLWXuHCivJd/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 526855953,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751479846
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 01/07/2025 11:54, Mulder, Ike wrote:</p>\n<blockquote>\n<p>The datatypes are genuine <code>datatype</code>s. Using Dimitry's example from the other thread, the slowdown we are seeing can be reproduced with three simple files:</p>\n</blockquote>\n<p>Datatypes with 100 constructors are not very realistic. We need an actual <br>\n\"constructive proof for performance problems\", one that resembles a proper <br>\napplication.</p>\n<p>I looked around in the Isabelle distribution, but did not find any. Even a <br>\nmerge of the theories from session HOL-Datatype_Benchmark does not exhibit <br>\nanything that looks too slow.</p>\n<p>Makarius</p>",
        "id": 526998126,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751549634
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nBelieve me, these big datatypes exist, even if they are not in the public domain. Isabelle scales extraordinarily well to huge developments. It would be great if it could do so here as well, rather than forcing users into awkward workarounds.</p>\n<p>I was wondering how HOL4 and HOL Light coped. In the source files of the letter I found the following:</p>\n<blockquote>\n<p>(* ------------------------------------------------------------------------- *)<br>\n(* Also add a cached rewrite of distinctness and injectivity theorems. Since *)<br>\n(* there can be quadratically many distinctness clauses, it would really be  *)<br>\n(* preferable to have a conversion, but this seems OK up 100 constructors.   *)<br>\n(* ------------------------------------------------------------------------- *)</p>\n</blockquote>\n<p>Larry</p>\n<blockquote>\n<p>On 3 Jul 2025, at 14:33, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>Datatypes with 100 constructors are not very realistic. We need an actual \"constructive proof for performance problems\", one that resembles a proper application.</p>\n<p>I looked around in the Isabelle distribution, but did not find any. Even a merge of the theories from session HOL-Datatype_Benchmark does not exhibit anything that looks too slow.</p>\n</blockquote>",
        "id": 527003603,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751551108
    },
    {
        "content": "<p>From: Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;<br>\nOn Thu, 3 Jul 2025, Makarius wrote:</p>\n<blockquote>\n<p>Datatypes with 100 constructors are not very realistic.</p>\n</blockquote>\n<p>This is an actual problem I ran into.  I wanted to prove some properties <br>\nof a particular state machine, but a datatype with ~50 states would never <br>\nfinish compiling.</p>\n<p>Roland</p>",
        "id": 527011331,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751552956
    },
    {
        "content": "<p>From: Dominic Mulligan &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHuge datatypes also arise naturally in modelling the semantics of CPU<br>\ninstruction sets.</p>\n<p>On Thu, 3 Jul 2025 at 15:29, Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt; wrote:</p>\n<blockquote>\n<p>On Thu, 3 Jul 2025, Makarius wrote:</p>\n<blockquote>\n<p>Datatypes with 100 constructors are not very realistic.</p>\n</blockquote>\n<p>This is an actual problem I ran into.  I wanted to prove some properties<br>\nof a particular state machine, but a datatype with ~50 states would never<br>\nfinish compiling.</p>\n<p>Roland</p>\n</blockquote>",
        "id": 527013184,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751553430
    },
    {
        "content": "<p>From: i n &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n  I would like to mention that for HOL4, some parts of the CakeML compiler proofs face performance issues when case splitting's datatypes with many constructors. Work on refactoring the datatypes to reduce the number of constructors sped up some proofs by quite a alot. Taking the previous example of enum1 one could define the datatype like this instead.</p>\n<div class=\"codehilite\" data-code-language=\"datatype\"><pre><span></span><code>  A1 | A2 | A3 | A4 | A5 | A6 | A7 | A8 | A9 | A10\ndatatype B =\n  B1 | B2 | B3 | B4 | B5 | B6 | B7 | B8 | B9 | B10\ndatatype C =\n  C1 | C2 | C3 | C4 | C5 | C6 | C7 | C8 | C9 | C10\ndatatype D =\n  D1 | D2 | D3 | D4 | D5 | D6 | D7 | D8 | D9 | D10\n\n...\ndatatype J =\n  J1 | J2 | J3 | J4 | J5 | J6 | J7 | J8 | J9 | J10\n\ndatatype enum1 =\n  A A | B B | C C | D D | E E | F F | G G | H H |\n  I I | J J\n\n```Irvin\n    On Thursday, 3 July 2025 at 01:58:21 pm UTC, Lawrence Paulson &lt;lp15@cam.ac.uk&gt; wrote:\n\n Believe me, these big datatypes exist, even if they are not in the public domain. Isabelle scales extraordinarily well to huge developments. It would be great if it could do so here as well, rather than forcing users into awkward workarounds.\n\nI was wondering how HOL4 and HOL Light coped. In the source files of the letter I found the following:\n\n&gt; (* ------------------------------------------------------------------------- *)\n&gt; (* Also add a cached rewrite of distinctness and injectivity theorems. Since *)\n&gt; (* there can be quadratically many distinctness clauses, it would really be  *)\n&gt; (* preferable to have a conversion, but this seems OK up 100 constructors.  *)\n&gt; (* ------------------------------------------------------------------------- *)\n\n\nLarry\n\n&gt; On 3 Jul 2025, at 14:33, Makarius &lt;makarius@sketis.net&gt; wrote:\n&gt;\n&gt; Datatypes with 100 constructors are not very realistic. We need an actual \"constructive proof for performance problems\", one that resembles a proper application.\n&gt;\n&gt; I looked around in the Isabelle distribution, but did not find any. Even a merge of the theories from session HOL-Datatype_Benchmark does not exhibit anything that looks too slow.\n</code></pre></div>",
        "id": 527013583,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751553541
    },
    {
        "content": "<p>From: \"\\\"wolff@lmf.cnrsfr\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nMy standard example is the C11 abstract syntax - a mutually dependant beast with around 60 constructors or so …<br>\nWe had to adopt several simplifications to get it through, but at the cost of compatibility ...</p>\n<p>Best</p>\n<p>Burkhart</p>\n<blockquote>\n<p>On 3 Jul 2025, at 15:33, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>On 01/07/2025 11:54, Mulder, Ike wrote:</p>\n<blockquote>\n<p>The datatypes are genuine <code>datatype</code>s. Using Dimitry's example from the other thread, the slowdown we are seeing can be reproduced with three simple files:</p>\n</blockquote>\n<p>Datatypes with 100 constructors are not very realistic. We need an actual \"constructive proof for performance problems\", one that resembles a proper application.</p>\n<p>I looked around in the Isabelle distribution, but did not find any. Even a merge of the theories from session HOL-Datatype_Benchmark does not exhibit anything that looks too slow.</p>\n<p>Makarius</p>\n</blockquote>",
        "id": 527032753,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751558965
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/07/2025 16:35, <a href=\"mailto:wolff@lmf.cnrsfr\">wolff@lmf.cnrsfr</a> wrote:</p>\n<blockquote>\n<p>My standard example is the C11 abstract syntax - a mutually dependant beast with around 60 constructors or so …<br>\nWe had to adopt several simplifications to get it through, but at the cost of compatibility ...</p>\n</blockquote>\n<p>So can you point to concrete locations in Isabelle/AFP to look at?</p>\n<p>Makarius</p>",
        "id": 527171049,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751631873
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/07/2025 16:36, Dominic Mulligan (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Huge datatypes also arise naturally in modelling the semantics of CPU <br>\ninstruction sets.</p>\n</blockquote>\n<p>This sounds like bad modelling: too concrete, too many flat cases. Has anybody <br>\ndone it in any other proof assistant?</p>\n<p>Makarius</p>",
        "id": 527171978,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751632199
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/07/2025 15:58, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>Believe me, these big datatypes exist, even if they are not in the public domain. Isabelle scales extraordinarily well to huge developments. It would be great if it could do so here as well, rather than forcing users into awkward workarounds.</p>\n</blockquote>\n<p>I was asking for \"constructive existence proofs of performance problems\", in <br>\norder to be able to reproduce the problem and see where it really happens (and <br>\nif something can be done about it).</p>\n<p>People who have non-public applications need to do extra homework to produce <br>\nrealistic examples that can be made public.</p>\n<blockquote>\n<p>I was wondering how HOL4 and HOL Light coped. In the source files of the letter I found the following:</p>\n<blockquote>\n<p>(* ------------------------------------------------------------------------- *)<br>\n(* Also add a cached rewrite of distinctness and injectivity theorems. Since *)<br>\n(* there can be quadratically many distinctness clauses, it would really be  *)<br>\n(* preferable to have a conversion, but this seems OK up 100 constructors.   *)<br>\n(* ------------------------------------------------------------------------- *)</p>\n</blockquote>\n</blockquote>\n<p>An interesting comment. I still wonder how to do proofs with so many cases <br>\nemerging over and over again ...</p>\n<p>Makarius</p>",
        "id": 527173049,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751632585
    },
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nThere are several examples in CompCert, e.g.</p>\n<p><a href=\"https://github.com/AbsInt/CompCert/blob/master/x86/Op.v#L73\">https://github.com/AbsInt/CompCert/blob/master/x86/Op.v#L73</a></p>\n<p><a href=\"https://github.com/AbsInt/CompCert/blob/master/x86/Asm.v#L108\">https://github.com/AbsInt/CompCert/blob/master/x86/Asm.v#L108</a></p>\n<p>Kevin</p>\n<p>On 04.07.25 14:29, Makarius wrote:</p>\n<blockquote>\n<p>On 03/07/2025 16:36, Dominic Mulligan (via cl-isabelle-users Mailing <br>\nList) wrote:</p>\n<blockquote>\n<p>Huge datatypes also arise naturally in modelling the semantics of CPU <br>\ninstruction sets.</p>\n</blockquote>\n<p>This sounds like bad modelling: too concrete, too many flat cases. Has <br>\nanybody done it in any other proof assistant?</p>\n<p>Makarius</p>\n</blockquote>",
        "id": 527175824,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751633737
    },
    {
        "content": "<p>From: Frédéric Tuong &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nOn Monday, July 7th, 2025 at 9:39 AM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>&gt; </p>\n<blockquote>\n<blockquote>\n<p>My standard example is the C11 abstract syntax - a mutually dependant beast with around 60 constructors or so …<br>\nWe had to adopt several simplifications to get it through, but at the cost of compatibility ...<br>\n</p>\n</blockquote>\n</blockquote>\n<p>&gt; </p>\n<blockquote>\n<p>So can you point to concrete locations in Isabelle/AFP to look at?<br>\n</p>\n</blockquote>\n<p>Unfortunately, we refrained from submitting it to the AFP because the evaluation of the generated datatypes started to take too much time (we probably had to interrupt it at some point):<br>\n<a href=\"https://gitlab.lisn.upsaclay.fr/ftuong/citadelle-devel/-/blob/9dc12a1704f18dde1e493736875474d50404f5d0/doc/Meta_C_generated.thy#L775\">https://gitlab.lisn.upsaclay.fr/ftuong/citadelle-devel/-/blob/9dc12a1704f18dde1e493736875474d50404f5d0/doc/Meta_C_generated.thy#L775</a></p>\n<p>which was generated from an ancestor version of this file:<br>\n<a href=\"https://github.com/visq/language-c/blob/2f7df0f9cbd48f6fa084b967c6fc0ac92c75eccc/src/Language/C/Syntax/AST.hs#L74\">https://github.com/visq/language-c/blob/2f7df0f9cbd48f6fa084b967c6fc0ac92c75eccc/src/Language/C/Syntax/AST.hs#L74</a></p>\n<p>Best,<br>\nFrédéric</p>\n<p><a href=\"/user_uploads/14278/vn5gFHYjPyi8C0YJavkrHAys/signature.asc\">signature.asc</a></p>",
        "id": 527522726,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751908153
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nThanks, Kevin. Not Isabelle, but still interesting. Without any change these examples, especially the second one with ~180 constructors, might be challenging in Isabelle. In this case, I would follow Irvin’s suggestion from this thread: split this type into palatable pieces. There are even comments in the CompCert type grouping the operations logically. So these comments could be formalized as separate datatypes.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 4 Jul 2025, at 14.49, Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt; wrote:</p>\n<p>There are several examples in CompCert, e.g.</p>\n<p><a href=\"https://github.com/AbsInt/CompCert/blob/master/x86/Op.v#L73\">https://github.com/AbsInt/CompCert/blob/master/x86/Op.v#L73</a></p>\n<p><a href=\"https://github.com/AbsInt/CompCert/blob/master/x86/Asm.v#L108\">https://github.com/AbsInt/CompCert/blob/master/x86/Asm.v#L108</a></p>\n<p>Kevin</p>\n<p>On 04.07.25 14:29, Makarius wrote:</p>\n<blockquote>\n<p>On 03/07/2025 16:36, Dominic Mulligan (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Huge datatypes also arise naturally in modelling the semantics of CPU instruction sets.<br>\nThis sounds like bad modelling: too concrete, too many flat cases. Has anybody done it in any other proof assistant?<br>\n    Makarius</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 528384697,
        "sender_full_name": "Email Gateway",
        "timestamp": 1752256574
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nThanks Frédéric, that’s an interesting example. Although a bit off-topic, if the topic is datatypes with many constructors. But at least it is an Isabelle example and moreover an interesting type from the type structure perspective.</p>\n<p>What kills this example is the type being highly mutual. Mutuality is a different dimension and as I have mentioned earlier the performance is for sure worse than quadratic in the number of mutual types. Already the type of the recursor here will be monstrous.</p>\n<p>There is a workaround: replace mutual recursion by nested recursion. Below I paste an isomorphic collection of types. (Modulo some trivial changes, such as defining the Either type as sum rather than using your definition and using the standard option type instead of the one from your library.) My thought process was as follows: 'a Expression was used by most types, so I moved it out to a separate type and replaced it by the extra type variable ‘e whenever it was used. Then the datatype command told me that the remaining types are not fully mutual and suggested that I split the types in the way that you see in the theory. Of these types none takes more than 10 seconds. Of course, now one has to write ('a, 'a Expression) CDeclaration instead of 'a CDeclaration from your version, but this can easily be hidden behind type synonyms.</p>\n<p>At some point Jasmin and I were working on automating such a mutual-to-nested reduction to alleviate performance problems with mutual types. This failed because we had the ambition to fully hide the nested view behind the mutual interface. But the issue was that the mutual interface itself became a bottleneck. So now we are advocating people to use nested types instead—they are beneficial not only for performance but also for abstraction: most of the time one does not want to reason about the entire language. Likely, there are things that can be said about a language's declarations without knowing precisely what the language’s expressions are.</p>\n<p>Dmitriy</p>\n<p>theory Scratch<br>\n  imports Main<br>\nbegin</p>\n<p>datatype Position = Position \"int\" \"string\" \"int\" \"int\"<br>\n                        | NoPosition <br>\n                        | BuiltinPosition <br>\n                        | InternalPosition<br>\ntype_synonym PosLength = \"(Position, int) <a href=\"http://Product_Type.prod\">Product_Type.prod</a>\"<br>\ndatatype Name = Name \"int\"<br>\ndatatype NodeInfo = OnlyPos \"Position\" \"PosLength\"<br>\n                        | NodeInfo \"Position\" \"PosLength\" \"Name\"<br>\ndatatype Ident = Ident \"string\" \"int\" \"NodeInfo\"<br>\ndatatype SUERef = AnonymousRef \"Name\"<br>\n                        | NamedRef \"Ident\"<br>\ndatatype CChar = CChar \"char\" \"HOL.bool\"<br>\n                        | CChars \"char List.list\" \"HOL.bool\"<br>\ndatatype CIntRepr = DecRepr <br>\n                        | HexRepr <br>\n                        | OctalRepr <br>\ndatatype CIntFlag = FlagUnsigned <br>\n                        | FlagLong <br>\n                        | FlagLongLong <br>\n                        | FlagImag <br>\ndatatype CFloat = CFloat \"string\"<br>\ndatatype ClangCVersion = ClangCVersion \"string\"<br>\ndatatype CString = CString \"string\" \"HOL.bool\"<br>\ndatatype 'f Flags = Flags \"int\"<br>\ndatatype CInteger = CInteger \"int\" \"CIntRepr\" \"CIntFlag Flags\"<br>\ndatatype CAssignOp = CAssignOp <br>\n                        | CMulAssOp <br>\n                        | CDivAssOp <br>\n                        | CRmdAssOp <br>\n                        | CAddAssOp <br>\n                        | CSubAssOp <br>\n                        | CShlAssOp <br>\n                        | CShrAssOp <br>\n                        | CAndAssOp <br>\n                        | CXorAssOp <br>\n                        | COrAssOp <br>\ndatatype CBinaryOp = CMulOp <br>\n                        | CDivOp <br>\n                        | CRmdOp <br>\n                        | CAddOp <br>\n                        | CSubOp <br>\n                        | CShlOp <br>\n                        | CShrOp <br>\n                        | CLeOp <br>\n                        | CGrOp <br>\n                        | CLeqOp <br>\n                        | CGeqOp <br>\n                        | CEqOp <br>\n                        | CNeqOp <br>\n                        | CAndOp <br>\n                        | CXorOp <br>\n                        | COrOp <br>\n                        | CLndOp <br>\n                        | CLorOp <br>\ndatatype CUnaryOp = CPreIncOp <br>\n                        | CPreDecOp <br>\n                        | CPostIncOp <br>\n                        | CPostDecOp <br>\n                        | CAdrOp <br>\n                        | CIndOp <br>\n                        | CPlusOp <br>\n                        | CMinOp <br>\n                        | CCompOp <br>\n                        | CNegOp <br>\ndatatype 'a CStorageSpecifier = CAuto \"'a\"<br>\n                        | CRegister \"'a\"<br>\n                        | CStatic \"'a\"<br>\n                        | CExtern \"'a\"<br>\n                        | CTypedef \"'a\"<br>\n                        | CThread \"'a\"<br>\ntype_synonym CStorageSpec = \"NodeInfo CStorageSpecifier\"<br>\ndatatype 'a CFunctionSpecifier = CInlineQual \"'a\"<br>\n                        | CNoreturnQual \"'a\"<br>\ntype_synonym CFunSpec = \"NodeInfo CFunctionSpecifier\"<br>\ndatatype CStructTag = CStructTag <br>\n                        | CUnionTag <br>\ndatatype 'a CConstant = CIntConst \"CInteger\" \"'a\"<br>\n                        | CCharConst \"CChar\" \"'a\"<br>\n                        | CFloatConst \"CFloat\" \"'a\"<br>\n                        | CStrConst \"CString\" \"'a\"<br>\ntype_synonym CConst = \"NodeInfo CConstant\"<br>\ntype_synonym ('a, 'b) Either = \"'a + 'b\"<br>\ndatatype 'a CStringLiteral = CStrLit \"CString\" \"'a\"</p>\n<p>datatype ('a, 'e) CAttribute = CAttr \"Ident\" \"'e List.list\" \"'a\"</p>\n<p>datatype ('a, 'e) CTypeQualifier = CConstQual \"'a\"<br>\n                        | CVolatQual \"'a\"<br>\n                        | CRestrQual \"'a\"<br>\n                        | CAtomicQual \"'a\"<br>\n                        | CAttrQual \"('a, 'e) CAttribute\"<br>\n                        | CNullableQual \"'a\"<br>\n                        | CNonnullQual \"'a\"<br>\ndatatype ('a, 'e) CAssemblyOperand = CAsmOperand \"Ident option\" \"'a CStringLiteral\" \"'e\" \"'a\"<br>\ndatatype ('a, 'e) CAssemblyStatement = CAsmStmt \"('a, 'e) CTypeQualifier option\" \"'a CStringLiteral\" \"('a, 'e) CAssemblyOperand List.list\" \"('a, 'e) CAssemblyOperand List.list\" \"'a CStringLiteral List.list\" \"'a\"</p>\n<p>datatype ('a, 'e) CEnumeration = CEnum \"Ident option\" \"(Ident, 'e option) <a href=\"http://Product_Type.prod\">Product_Type.prod</a> List.list option\" \"('a, 'e) CAttribute List.list\" \"'a\"<br>\ndatatype ('a, 'e) CPartDesignator = CArrDesig \"'e\" \"'a\"<br>\n                        | CMemberDesig \"Ident\" \"'a\"<br>\n                        | CRangeDesig \"'e\" \"'e\" \"'a\"<br>\ndatatype ('a, 'e) CInitializer = CInitExpr \"'e\" \"'a\"<br>\n  | CInitList \"(('a, 'e) CPartDesignator List.list, ('a, 'e) CInitializer) <a href=\"http://Product_Type.prod\">Product_Type.prod</a> List.list\" \"'a\"<br>\ndatatype ('a, 'e) CArraySize = CNoArrSize \"HOL.bool\"<br>\n                        | CArrSize \"HOL.bool\" \"'e\"<br>\ndatatype ('a, 'e) CDeclaration = CDecl \"('a, 'e) CDeclarationSpecifier List.list\" \"((('a, 'e) CDeclarator option, ('a, 'e) CInitializer option) <a href=\"http://Product_Type.prod\">Product_Type.prod</a>, 'e option) <a href=\"http://Product_Type.prod\">Product_Type.prod</a> List.list\" \"'a\"<br>\n                        | CStaticAssert \"'e\" \"'a CStringLiteral\" \"'a\"<br>\nand ('a, 'e) CDeclarator = CDeclr \"Ident option\" \"('a, 'e) CDerivedDeclarator List.list\" \"'a CStringLiteral option\" \"('a, 'e) CAttribute List.list\" \"'a\"<br>\nand ('a, 'e) CDerivedDeclarator = CPtrDeclr \"('a, 'e) CTypeQualifier List.list\" \"'a\"<br>\n                        | CArrDeclr \"('a, 'e) CTypeQualifier List.list\" \"('a, 'e) CArraySize\" \"'a\"<br>\n                        | CFunDeclr \"(Ident List.list, (('a, 'e) CDeclaration List.list, HOL.bool) <a href=\"http://Product_Type.prod\">Product_Type.prod</a>) Either\" \"('a, 'e) CAttribute List.list\" \"'a\"<br>\nand ('a, 'e) CDeclarationSpecifier = CStorageSpec \"'a CStorageSpecifier\"<br>\n                        | CTypeSpec \"('a, 'e) CTypeSpecifier\"<br>\n                        | CTypeQual \"('a, 'e) CTypeQualifier\"<br>\n                        | CFunSpec \"'a CFunctionSpecifier\"<br>\n                        | CAlignSpec \"('a, 'e) CAlignmentSpecifier\"<br>\nand ('a, 'e) CTypeSpecifier = CVoidType \"'a\"<br>\n                        | CCharType \"'a\"<br>\n                        | CShortType \"'a\"<br>\n                        | CIntType \"'a\"<br>\n                        | CLongType \"'a\"<br>\n                        | CFloatType \"'a\"<br>\n                        | CDoubleType \"'a\"<br>\n                        | CSignedType \"'a\"<br>\n                        | CUnsigType \"'a\"<br>\n                        | CBoolType \"'a\"<br>\n                        | CComplexType \"'a\"<br>\n                        | CInt128Type \"'a\"<br>\n                        | CSUType \"('a, 'e) CStructureUnion\" \"'a\"<br>\n                        | CEnumType \"('a, 'e) CEnumeration\" \"'a\"<br>\n                        | CTypeDef \"Ident\" \"'a\"<br>\n                        | CTypeOfExpr \"'e\" \"'a\"<br>\n                        | CTypeOfType \"('a, 'e) CDeclaration\" \"'a\"<br>\n                        | CAtomicType \"('a, 'e) CDeclaration\" \"'a\"<br>\nand ('a, 'e) CAlignmentSpecifier = CAlignAsType \"('a, 'e) CDeclaration\" \"'a\"<br>\n                        | CAlignAsExpr \"'e\" \"'a\"<br>\nand ('a, 'e) CStructureUnion = CStruct \"CStructTag\" \"Ident option\" \"('a, 'e) CDeclaration List.list option\" \"('a, 'e) CAttribute List.list\" \"'a\"</p>\n<p>datatype ('a, 'e) CFunctionDef = CFunDef \"('a, 'e) CDeclarationSpecifier List.list\" \"('a, 'e) CDeclarator\" \"('a, 'e) CDeclaration List.list\" \"('a, 'e) CStatement\" \"'a\"<br>\nand ('a, 'e) CStatement = CLabel \"Ident\" \"('a, 'e) CStatement\" \"('a, 'e) CAttribute List.list\" \"'a\"<br>\n                        | CCase \"'e\" \"('a, 'e) CStatement\" \"'a\"<br>\n                        | CCases \"'e\" \"'e\" \"('a, 'e)  CStatement\" \"'a\"<br>\n                        | CDefault \"('a, 'e) CStatement\" \"'a\"<br>\n                        | CExpr \"'e option\" \"'a\"<br>\n                        | CCompound \"Ident List.list\" \"('a, 'e) CCompoundBlockItem List.list\" \"'a\"<br>\n                        | CIf \"'e\" \"('a, 'e) CStatement\" \"('a, 'e) CStatement option\" \"'a\"<br>\n                        | CSwitch \"'e\" \"('a, 'e) CStatement\" \"'a\"<br>\n                        | CWhile \"'e\" \"('a, 'e) CStatement\" \"HOL.bool\" \"'a\"<br>\n                        | CFor \"('e option, ('a, 'e) CDeclaration<br>\n[message truncated]</p>",
        "id": 528387394,
        "sender_full_name": "Email Gateway",
        "timestamp": 1752257871
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;</p>\n<blockquote>\n<p>On 3 Jul 2025, at 15.44, Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt; wrote:</p>\n<p>On Thu, 3 Jul 2025, Makarius wrote:</p>\n<blockquote>\n<p>Datatypes with 100 constructors are not very realistic.</p>\n</blockquote>\n<p>This is an actual problem I ran into.  I wanted to prove some properties of a particular state machine, but a datatype with ~50 states would never finish compiling.</p>\n</blockquote>\n<p>Was that a datatype with 50 constructors (which should finish relatively quickly—if not, I’d like to see the example) or 50 mutually recursive datatypes (which has no chance)? If the latter, you could consider following the recipe from my response to Frédéric in this thread.</p>\n<p>Dmitriy</p>",
        "id": 528387784,
        "sender_full_name": "Email Gateway",
        "timestamp": 1752258071
    },
    {
        "content": "<p>From: Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;<br>\nOn Fri, 11 Jul 2025, Dmitriy Traytel wrote:</p>\n<blockquote>\n<p>On 3 Jul 2025, at 15.44, Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt; wrote:</p>\n<blockquote>\n<p>On Thu, 3 Jul 2025, Makarius wrote:</p>\n<blockquote>\n<p>Datatypes with 100 constructors are not very realistic.</p>\n</blockquote>\n<p>This is an actual problem I ran into.  I wanted to prove some <br>\nproperties of a particular state machine, but a datatype with ~50 <br>\nstates would never finish compiling.</p>\n</blockquote>\n<p>Was that a datatype with 50 constructors (which should finish relatively <br>\nquickly—if not, I’d like to see the example) or 50 mutually recursive <br>\ndatatypes (which has no chance)? If the latter, you could consider <br>\nfollowing the recipe from my response to Frédéric in this thread.</p>\n</blockquote>\n<p>It was something along the lines of</p>\n<p>datatype state = Start | Identifier | Comment | ...</p>\n<p>The threshold between \"usable\" and \"unusable\" performance lay between 11 <br>\nand 12 constructors on my machine; I would have needed significantly more. <br>\nThis was with Isabelle 2022, if I recall correctly.</p>\n<p>This isn't just about this particular case, though.  I'd like to be able <br>\nto use Isabelle to automate and \"forget about\" things, similar to a test <br>\nsuite.  So what I'd really wish for is that I could refactor my code and <br>\nhave temporarily, say, 200 states, and the proof would still complete in <br>\nreasonable time.</p>\n<p>Roland</p>",
        "id": 528457477,
        "sender_full_name": "Email Gateway",
        "timestamp": 1752325811
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 30/06/2025 19:36, Makarius wrote:</p>\n<blockquote>\n<p>Now the focus has changed to datatypes. This raise a few more questions:</p>\n<p>* Is the claset merge operation really slow, or are the involved clasets <br>\njust very big?</p>\n</blockquote>\n<p>To answer this question without inflating this thread once again, see now the <br>\nisabelle-dev repository <br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/rev/ca600cbfd4bf\">https://isabelle.sketis.net/repos/isabelle/rev/ca600cbfd4bf</a></p>\n<p>changeset:   82833:ca600cbfd4bf<br>\nuser:        wenzelm<br>\ndate:        Thu Jul 10 17:29:25 2025 +0200<br>\nfiles:       src/Provers/classical.ML<br>\ndescription:<br>\nmore accurate \"next\" counter for each insert operation: subtle change of <br>\nsemantics wrt. Item_Net.length, due to delete operation;<br>\navoid costly Item_Net.length, which is linear in size;</p>\n<p>That avoids a rather wasteful (and slightly wrong) allocation of a fresh index <br>\nfor new rule declarations.</p>\n<p>The change could probably be applied to the isabelle-release version, but that <br>\nis not my job. Isabelle development has only one linear line of history, no <br>\nbranches, and no actual merges.</p>\n<p>After that change (and in the coming release at the end of 2025), it still <br>\nremains a bad idea to introduce large flat datatypes without proper <br>\nsubstructure. Tons of individual cases will show up in proofs over and over <br>\nagain. No performance tuning of basic data structures can avoid that complexity.</p>\n<p>Makarius</p>",
        "id": 529921499,
        "sender_full_name": "Email Gateway",
        "timestamp": 1753113787
    }
]