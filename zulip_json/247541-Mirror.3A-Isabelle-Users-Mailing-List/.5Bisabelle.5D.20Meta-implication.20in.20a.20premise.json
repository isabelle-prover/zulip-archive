[
    {
        "content": "<p>From: Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;<br>\nHi,</p>\n<p>I've now encountered a similar, but reversed problem: OF and THEN don't <br>\nwork as expected with a premise that contains a meta-implication.</p>\n<p>notepad<br>\nbegin<br>\n   fix P Q R<br>\n   assume a: \"(P ⟹ Q) ⟹ R\"<br>\n   assume b: \"P ⟹ Q\"<br>\n   thm a [OF b]<br>\n   thm b [THEN a]<br>\n   (* expected R, got (P ⟹ P) ⟹ R *)<br>\nend</p>\n<p>I would like to compose two facts, one of which matches the first premise <br>\nof the other one (up to unification), just like AppP does.  Is there a way <br>\nto achieve this?</p>\n<p>Roland</p>",
        "id": 435902483,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714331684
    },
    {
        "content": "<p>From: Frédéric Boulanger &lt;<a href=\"mailto:frederic.boulanger@centralesupelec.fr\">frederic.boulanger@centralesupelec.fr</a>&gt;<br>\nHi,</p>\n<p>It seems that all you need is the simplifier:</p>\n<p>notepad<br>\nbegin<br>\n   fix P Q R<br>\n   assume a: \"(P ⟹ Q) ⟹ R\"<br>\n   assume b: \"P ⟹ Q\"<br>\n   thm a [OF b, simplified]<br>\n   thm b [THEN a, simplified]<br>\nend</p>\n<p>Frédéric</p>\n<p>Frédéric Boulanger<br>\nCentraleSupélec - Département Informatique  Laboratoire Méthodes Formelles (LMF)<br>\n3 rue Joliot-Curie, 91192 Gif-sur-Yvette cedex  Bât. 650 - 1 rue Raimond Castaing, 91190 Gif-sur-Yvette<br>\n+33 [0]1 75 31 78 32‬</p>",
        "id": 435904100,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714333314
    },
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nHere's an option if you don't mind using the AFP:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span>\n<span class=\"w\">   </span><span class=\"kp\">imports</span>\n<span class=\"w\">     </span><span class=\"n\">ML_Unification.ML_Unification_HOL_Setup</span>\n<span class=\"w\">     </span><span class=\"n\">ML_Unification.Unification_Attributes</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">notepad</span>\n<span class=\"k\">begin</span>\n<span class=\"w\">   </span><span class=\"k\">fix</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"n\">Q</span><span class=\"w\"> </span><span class=\"n\">R</span>\n<span class=\"w\">   </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"(P ⟹ Q) ⟹ R\"</span>\n<span class=\"w\">   </span><span class=\"k\">assume</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"P ⟹ Q\"</span>\n<span class=\"w\">   </span><span class=\"c\">(*the result you want*)</span>\n<span class=\"w\">   </span><span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">uOF</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">]</span>\n<span class=\"w\">   </span><span class=\"c\">(*the result you get when using OF*)</span>\n<span class=\"w\">   </span><span class=\"kt\">thm</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">uOF</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">mode</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">resolve</span><span class=\"o\">]</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Kevin</p>",
        "id": 435982981,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714378720
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe question is what to expect, or rather how Isabelle/Pure really works.</p>\n<p>The \"implementation\" manual has some explanations in chapter 2, notably <br>\nsection \"2.4.2 Rule composition\". The Isabelle/Isar proof language also works <br>\nwithin this school of thinking.</p>\n<p>So the canonical meta-question is: What are you trying to do? What is your <br>\napplication?</p>\n<p>Makarius</p>",
        "id": 435992978,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714382002
    },
    {
        "content": "<p>From: Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;<br>\nUnfortunately, in my case, this doesn't work:</p>\n<p>exception THM 0 raised<br>\n   OF: multiple unifiers</p>\n<p>The theorem I'm using is while_option_commute, and the terms ?b and ?b' <br>\nboth have the form (λx. cur x ≠ 0) in the facts I use.</p>\n<p>Roland</p>",
        "id": 436351595,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714510141
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIsabelle implements a logical framework (Pure) and the operators it provides for doing proofs rely on that framework to put user-level proofs together: in some object logic, typically HOL. The kernel does provide some primitives allowing you to perform derivations within Pure, but they are low-level, not well documented, and not easily reached from Isar. </p>\n<p>Larry</p>",
        "id": 436510188,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714573504
    },
    {
        "content": "<p>From: Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;<br>\nOn Mon, 29 Apr 2024, Makarius wrote:</p>\n<blockquote>\n<p>The \"implementation\" manual has some explanations in chapter 2, notably <br>\nsection \"2.4.2 Rule composition\".</p>\n</blockquote>\n<p>In the terminology of this section, what I want to do is close a branch by <br>\ncomposing with a fact (that isn't necessarily atomic).</p>\n<blockquote>\n<p>So the canonical meta-question is: What are you trying to do? What is <br>\nyour application?</p>\n</blockquote>\n<p>What I'm trying to do, on a meta-level, is learn how to prove things in <br>\nIsabelle.  Despite having spent quite some time with Isabelle now, I still <br>\nfind myself struggling to do even simple things.</p>\n<p>In my previous question, I've been trying to prove by induction that 2ⁿ ≤ <br>\nn! for n ≥ 4:</p>\n<p>primrec fac :: \"nat ⇒ nat\"<br>\n   where<br>\n     \"fac 0 = 1\"<br>\n   | \"fac (Suc n) = Suc n * fac n\"</p>\n<p>theorem fac_outgrows_powers_of_two:<br>\n     fixes n :: nat<br>\n     assumes \"n ≥ 4\"<br>\n     shows \"2 ^ n ≤ fac n\"<br>\n   proof ...<br>\n     fix n :: nat<br>\n     assume \"n = 4\"<br>\n     thus \"2 ^ n ≤ fac n\" ...<br>\n   next<br>\n     fix n :: nat<br>\n     assume \"n &gt; 4\" and \"2 ^ (n - 1) ≤ fac (n - 1)\"<br>\n     hence \"2 * 2 ^ (n - 1) ≤ n * fac (n - 1)\" ...<br>\n     thus \"2 ^ n ≤ fac n\" ...<br>\n   qed</p>\n<p>I finally came up with the following proof:</p>\n<p>lemma induction_from_start:<br>\n     fixes P :: \"nat ⇒ bool\"<br>\n     fixes n₀ :: \"nat\"<br>\n     assumes \"⋀n. n = n₀ ⟹ P n\"<br>\n     assumes \"⋀n. n &gt; n₀ ⟹ P (n - 1) ⟹ P n\"<br>\n     shows \"⋀n. n ≥ n₀ ⟹ P n\"<br>\n     using assms by (metis dec_induct diff_Suc_1 le_imp_less_Suc)</p>\n<p>lemma box_le: \"a ≤ b ⟹ a = c ⟹ b = d ⟹ c ≤ d\" by fast</p>\n<p>theorem fac_outgrows_powers_of_two:<br>\n     fixes n :: nat<br>\n     assumes \"n ≥ 4\"<br>\n     shows \"2 ^ n ≤ fac n\"<br>\n   proof (rule assms [THEN [3] induction_from_start])<br>\n     fix n :: nat<br>\n     assume \"n = 4\"<br>\n     thus \"2 ^ n ≤ fac n\" unfolding fac_def by simp<br>\n   next<br>\n     fix n :: nat<br>\n     assume \"n &gt; 4\"<br>\n     hence \"n &gt; 0\" by fastforce<br>\n     assume \"2 ^ (n - 1) ≤ fac (n - 1)\"<br>\n     hence \"2 * 2 ^ (n - 1) ≤ n * fac (n - 1)\"<br>\n       using ‹n &gt; 4› by (simp add: mult_le_mono)<br>\n     moreover have \"2 * 2 ^ (n - 1) = 2 ^ n\"<br>\n       using ‹n &gt; 0› by (simp add: power_eq_if)<br>\n     moreover have \"n * fac (n - 1) = fac n\"<br>\n       using ‹n &gt; 0› by (metis One_nat_def Suc_pred fac.simps(2))<br>\n     ultimately show \"2 ^ n ≤ fac n\" by (rule box_le)<br>\n   qed</p>\n<p>While that works, it took me a long time to figure out, and I'm not too <br>\nhappy about the result (in particular, about the initial proof method and <br>\nthe two separate helper lemmata).</p>\n<p>Being able to write structured proofs in Isar is great; it's the low-level <br>\nstuff leaking through the gaps that's driving me insane.  It often happens <br>\nthat I have some assumptions and a goal, and I <em>know</em> they fit together, I <br>\njust can't figure out what to tell Isabelle to make it work.</p>\n<p>From a conceptual point of view, I really miss composability: the ability <br>\nto break complex things down into an equivalent combination of more <br>\nelementary building blocks.</p>\n<p>Roland</p>",
        "id": 436561979,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714592773
    },
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nAs a comparative beginner, I'm almost certainly the wrong person to advise<br>\nyou on your more general problem, but it seems to me that your initial<br>\nlemma isn't expressing the thing you wanted to express. It should probably<br>\nbe something more like this:</p>\n<p>lemma induction_from_start:<br>\n  fixes P:: \"nat ⇒ bool\"<br>\n  fixes s::\"nat\"<br>\n  assumes \"P s\"<br>\n  assumes \"⋀n. n &gt; s ⟹ P (n - 1) ⟹ P n\"<br>\n  shows \"⋀n. n ≥ s  ⟹ P n\"</p>\n<p>i.e., you assume that for some fixed starting point <em>s</em>, P is true, and<br>\nthat inductive steps work for anything bigger than s. You've used \"n\" both<br>\nfor the starting point and for the induction variable, and I think that's<br>\nnot what you want.</p>\n<p>You've also used subtraction, and that may have coerced things to be ints<br>\nrather than nats or something, so a rewritten form would be:</p>\n<p>lemma induction_from_start:<br>\n  fixes P:: \"nat ⇒ bool\"<br>\n  fixes s::\"nat\"<br>\n  assumes \"P s\"<br>\n  assumes \"⋀n. n ≥ s ⟹ P (n) ⟹ P (Suc n)\"<br>\n  shows \"⋀n. n ≥ s  ⟹ P n\"</p>\n<p>which uses the Successor, which is what induction over the naturals works<br>\nwell on.</p>\n<p>I tried using sledgehammer to find a proof, and it suggested this:</p>\n<p>using assms(1) assms(2) <em>nat_induct_at_least</em> by blast</p>\n<p>(highlight mine). The highlighted theorem in fact says <em>exactly</em> what<br>\nyou're trying to say in your lemma. It's in $ISABELLE_HOME/src/HOL/Nat.thy,<br>\nwhich I found by typing</p>\n<p>thm nat_induct_at_least</p>\n<p>in my file and then command-clicking on nat_induct_at_least with my cursor<br>\n(use ctrl-click on Windows), which then opened up the definition of the<br>\nlemma for me to look at.</p>\n<p>I hope this is of some help. I definitely know how it feels to struggle<br>\nwith this stuff.</p>\n<p>--John</p>",
        "id": 436580625,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714601420
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nThe rule nat_induct_at_least will work for this if the condition n ≥ 4 is incorporated<br>\ninto the conclusion to be proved, so that it is available in the induction step:</p>\n<p>theorem fac_outgrows_powers_of_two:<br>\n    shows \"n ≥ 4 ⟹ 2 ^ n ≤ fac n\"<br>\n  proof (induct n rule: nat_induct_at_least)<br>\n    show \"2 ^ 4 ≤ fac 4\"<br>\n      by (simp add: numeral_3_eq_3 numeral_Bit0)<br>\n    fix n<br>\n    assume 1: \"4 ≤ n\" and 2: \"2 ^ n ≤ fac n\"<br>\n    have \"2 ^ Suc n ≤ n * 2 ^ n\"<br>\n      using 1 by simp<br>\n    also have \"... ≤ n * fac n\"<br>\n      using 1 2 by simp<br>\n    also have \"... ≤ fac (Suc n)\"<br>\n      by simp<br>\n    finally show \"2 ^ Suc n ≤ fac (Suc n)\"<br>\n      by blast<br>\n  qed</p>\n<p>I would like to be able to collapse some of the steps, but then I am not very good with<br>\ngetting Isabelle to do arithmetic reasoning.  The base case was proved with<br>\nSledgehammer.  It seems that automatic conversion of numerals into 0/Suc form<br>\nstops at 3, so some funny business is required to turn the numeral 4 into something<br>\nthat the simplification rules for function fac can deal with.</p>\n<p>As far as the induction proof is concerned, the approach I would take is to first work<br>\non stating the result in such a way that one of the available induction rules can<br>\nunderstand it and produce subgoals that look like they are sensible and true.<br>\nI don't know the available induction rules here particularly well, but John saved the<br>\nday by pointing out the rule nat_induct_at_least.</p>",
        "id": 436590846,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714606912
    },
    {
        "content": "<p>From: Tetsuya SATO &lt;<a href=\"mailto:sato.t.cv@m.titech.ac.jp\">sato.t.cv@m.titech.ac.jp</a>&gt;<br>\nHello,</p>\n<p>Explicit instantiations of parameters might solve the problem:</p>\n<p>notepad<br>\nbegin<br>\n   fix cur::\"'a ⇒ nat\" and  cur'::\"'b ⇒ nat\" and f1::\"'a ⇒ 'b\" and <br>\nc1::\"'a ⇒ 'a\" and c'1::\"'b ⇒ 'b\"<br>\n   define b1 where \"b1 = (λx. cur x ≠ 0)\"<br>\n   define b'1 where \"b'1 = (λx. cur' x ≠ 0)\"<br>\n   assume p1: \"⋀s::'a. b1 s = b'1 (f1 s)\"<br>\n   assume p2: \"⋀s::'a. b1 s ⟹ f1 (c1 s) = c'1 (f1 s)\"<br>\n   thm while_option_commute[of b1 b'1 f1 c1, OF p1 p2, simplified] (* <br>\nobtain the desired statement *)<br>\n   thm while_option_commute[OF p1 p2, simplified] (*error: THM 0 raised *)<br>\nend</p>\n<p>Tetsuya Sato</p>",
        "id": 436636955,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714636657
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nI hope this isn't too flippant, but I thought that the stages of this discussion were typical in a humorous way:</p>\n<p>original poster: I'm trying to get some specialised features of the Pure meta-logic to do exactly what I want and getting confused.<br>\nMakarius: what are you trying to do, anyway?<br>\noriginal poster: Oh, I'm trying to do an induction proof about a recursive function on naturals in HOL.</p>\n<p>This does seem to justify Makarius asking this question so often.</p>\n<p>Also:</p>\n<p>*   From a conceptual point of view, I really miss composability: the ability<br>\n  *   to break complex things down into an equivalent combination of more<br>\n  *<br>\nelementary building blocks.</p>\n<p>I think that this is exactly the right instinct. If you feel blocked from proceeding this way, it's probably because you don't<br>\nyet know enough moves in Isabelle.</p>\n<p>As others have pointed out, the library contains  nat_induct_at_least which is very similar to your induction_from_start lemma.<br>\nIt's also already been set up with the attribute [consumes 1], which doesn't change its logical meaning but is a hint to the<br>\ninduct method to prove its first premise immediately by consuming an assumption (much like erule), which results in the desired<br>\ninduction shape.</p>\n<p>Indeed, induct is a bit of a complex beast, and it's not straightforward to replicate some of its behaviour step-by-step. The special<br>\nfeature of induct is that it handles rules whose conclusion is of the shape \"?P ?x ?y\", which would normally be too general for<br>\nunification to consistently do what you want. Unfortunately, if you take either your lemma or the one from the library and compose<br>\nit with the assumption \"n &gt;= 4\" as a single step, this fixes \"?n\" to \"n\", and you no longer have a standard-shape induction lemma,<br>\nso the induct mechanism won't do the right thing with it. This might be why you're falling back to quite primitive mechanisms.</p>\n<p>If you do want to do every step yourself, I'd recommend you use \"where\" to pin the variables in your rule rather than OF/THEN to<br>\ncombine it with other steps. Don't misunderstand me, unification is super handy, and OF/THEN are really useful, but usually in<br>\ncases where the unification is constrained and will necessarily do what you want. For instance, this might be useful:</p>\n<p>lemmas an_induction_form =<br>\n  induction_from_start[where P=\"λn. 2 ^ n ≤ fac n\"]</p>\n<p>An intermediate option is to just set the lower bound in your rule ('s' in John's rephrasing of your rule). That variable appeared in<br>\nthe premises but not the conclusion of the induction rule, so it was always a risk for going wrong. This seems to be a valid way<br>\nto start your proof:<br>\n  proof (induct n rule: induction_from_start[where s=\"4\"])</p>\n<p>Finally, you can chain equalities or inequalities with the 'also have ...' mechanism in the Isar proof language. This is a bit specialised<br>\nbut it is really useful when your goal is to prove an inequality. Using that mechanism would avoid the need for your box_le lemma.</p>\n<p>I do sometimes end up needing to do transitivity manually in some cases. Theorems like order_le_less_trans can be useful.</p>\n<p>It occurs to me that the steps of your box_le lemma aren't in the naming scheme, since you don't need a named rule to apply an<br>\nequality. You can single-step apply an equality rewrite with the subst method.</p>\n<p>More broadly, once you know a sufficient set of mechanisms, you'll find that you can usually do things a step at a time if you need<br>\nto. Automation is useful too. I appreciate that induction is a bit of an exception.</p>\n<p>Hope any of that helps,<br>\n    Thomas.</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-request@lists.cam.ac.uk\">cl-isabelle-users-request@lists.cam.ac.uk</a>&gt; on behalf of John F. Hughes &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nSent: 01 May 2024 23:09<br>\nTo: Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;<br>\nCc: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;; <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: Re: [isabelle] Meta-implication in a premise</p>\n<p>As a comparative beginner, I'm almost certainly the wrong person to advise you on your more general problem, but it seems to me that your initial lemma isn't expressing the thing you wanted to express. It should probably be something more like this:</p>\n<p>lemma induction_from_start:<br>\n  fixes P:: \"nat ⇒ bool\"<br>\n  fixes s::\"nat\"<br>\n  assumes \"P s\"<br>\n  assumes \"⋀n. n &gt; s ⟹ P (n - 1) ⟹ P n\"<br>\n  shows \"⋀n. n ≥ s  ⟹ P n\"</p>\n<p>lemma induction_from_start:<br>\n  fixes P:: \"nat ⇒ bool\"<br>\n  fixes s::\"nat\"<br>\n  assumes \"P s\"<br>\n  assumes \"⋀n. n &gt; s ⟹ P (n - 1) ⟹ P n\"<br>\n  shows \"⋀n. n ≥ s  ⟹ P n\"</p>\n<p>i.e., you assume that for some fixed starting point s, P is true, and that inductive steps work for anything bigger than s. You've used \"n\" both for the starting point and for the induction variable, and I think that's not what you want.</p>\n<p>You've also used subtraction, and that may have coerced things to be ints rather than nats or something, so a rewritten form would be:</p>\n<p>lemma induction_from_start:<br>\n  fixes P:: \"nat ⇒ bool\"<br>\n  fixes s::\"nat\"<br>\n  assumes \"P s\"<br>\n  assumes \"⋀n. n ≥ s ⟹ P (n) ⟹ P (Suc n)\"<br>\n  shows \"⋀n. n ≥ s  ⟹ P n\"</p>\n<p>which uses the Successor, which is what induction over the naturals works well on.</p>\n<p>I tried using sledgehammer to find a proof, and it suggested this:</p>\n<p>using assms(1) assms(2) nat_induct_at_least by blast</p>\n<p>(highlight mine). The highlighted theorem in fact says exactly what you're trying to say in your lemma. It's in $ISABELLE_HOME/src/HOL/Nat.thy, which I found by typing</p>\n<p>thm nat_induct_at_least</p>\n<p>in my file and then command-clicking on nat_induct_at_least with my cursor (use ctrl-click on Windows), which then opened up the definition of the lemma for me to look at.</p>\n<p>I hope this is of some help. I definitely know how it feels to struggle with this stuff.</p>\n<p>--John</p>\n<p>On Wed, May 1, 2024 at 3:46 PM Roland Lutz &lt;rlutz@hedmen.org&lt;mailto:<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;&gt; wrote:<br>\nOn Mon, 29 Apr 2024, Makarius wrote:</p>\n<blockquote>\n<p>The \"implementation\" manual has some explanations in chapter 2, notably<br>\nsection \"2.4.2 Rule composition\".</p>\n</blockquote>\n<p>In the terminology of this section, what I want to do is close a branch by<br>\ncomposing with a fact (that isn't necessarily atomic).</p>\n<blockquote>\n<p>So the canonical meta-question is: What are you trying to do? What is<br>\nyour application?</p>\n</blockquote>\n<p>What I'm trying to do, on a meta-level, is learn how to prove things in<br>\nIsabelle.  Despite having spent quite some time with Isabelle now, I still<br>\nfind myself struggling to do even simple things.</p>\n<p>In my previous question, I've been trying to prove by induction that 2ⁿ ≤<br>\nn! for n ≥ 4:</p>\n<p>primrec fac :: \"nat ⇒ nat\"<br>\n   where<br>\n     \"fac 0 = 1\"<br>\n   | \"fac (Suc n) = Suc n * fac n\"</p>\n<p>theorem fac_outgrows_powers_of_two:<br>\n     fixes n :: nat<br>\n     assumes \"n ≥ 4\"<br>\n     shows \"2 ^ n ≤ fac n\"<br>\n   proof ...<br>\n     fix n :: nat<br>\n     assume \"n = 4\"<br>\n     thus \"2 ^ n ≤ fac n\" ...<br>\n   next<br>\n     fix n :: nat<br>\n     assume \"n &gt; 4\" and \"2 ^ (n - 1) ≤ fac (n - 1)\"<br>\n     hence \"2 * 2 ^ (n - 1) ≤ n * fac (n - 1)\" ...<br>\n     thus \"2 ^ n ≤ fac n\" ...<br>\n   qed</p>\n<p>I finally came up with the following proof:</p>\n<p>lemma induction_from_start:<br>\n     fixes P :: \"nat ⇒ bool\"<br>\n     fixes n₀ :: \"nat\"<br>\n     assumes \"⋀n. n = n₀ ⟹ P n\"<br>\n     assumes \"⋀n. n &gt; n₀ ⟹ P (n - 1) ⟹ P n\"<br>\n     shows \"⋀n. n ≥ n₀ ⟹ P n\"<br>\n     using assms by (metis dec_induct diff_Suc_1 le_imp_less_Suc)</p>\n<p>lemma box_le: \"a ≤ b ⟹ a = c ⟹ b = d ⟹ c ≤ d\" by fast</p>\n<p>theorem fac_outgrows_powers_of_two:<br>\n     fixes n :: nat<br>\n     assumes \"n ≥ 4\"<br>\n     shows \"2 ^ n ≤ fac n\"<br>\n   proof (rule assms [THEN [3] induction_from_start])<br>\n     fix n :: nat<br>\n     assume \"n = 4\"<br>\n     thus \"2 ^ n ≤ fac n\" unfolding fac_def by simp<br>\n   next<br>\n     fix n :: nat<br>\n     assume \"n &gt; 4\"<br>\n     hence \"n &gt; 0\" by fastforce<br>\n     assume \"2 ^ (n - 1) ≤ fac (n - 1)\"<br>\n     hence \"2 * 2 ^ (n - 1) ≤ n * fac (n - 1)\"<br>\n       using ‹n &gt; 4› by (simp add: mult_le_mono)<br>\n     moreover have \"2 * 2 ^ (n - 1) = 2 ^ n\"<br>\n       using ‹n &gt; 0› by (simp add: power_eq_if)<br>\n     moreover have \"n * fac (n - 1) = fac n\"<br>\n       using ‹n &gt; 0› by (metis One_nat_def Suc_pred fac.simps(2))<br>\n     ultimately show \"2 ^ n ≤ fac n\" by (rule box_le)<br>\n   qed</p>\n<p>While that works, it took me a long time to figure out, and I'm not too<br>\nhappy about the result (in particular, about the initial proof method and<br>\nthe two separate helper lemmata).</p>\n<p>Being able to write structured proofs in Isar is great; it's the low-level<br>\nstuff leaking through the gaps that's driving me insane.  It often happens<br>\nthat I have some assumptions and a goal, and I <em>know</em> they fit together, I<br>\njust can't figure out what to tell Isabelle to make it work.</p>\n<p>From a conceptual point of view, I really miss composability: the ability<br>\nto break complex things down into an equivalent combination of more<br>\nelementary building blocks.</p>\n<p>Roland</p>",
        "id": 436645966,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714639849
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI would never belittle the difficulty of getting even simple proofs out of an ITP. There are any number of pitfalls, and trying to prove something is particularly frustrating when it is obvious.</p>\n<p>I tackled this problem (using that wonderful induction rule nat_induct_at_least, which I hadn't heard of) and got the following: </p>\n<p>theorem fact_outgrows_powers_of_two:<br>\n  shows \"n ≥ 4 ⟹ 2 ^ n ≤ (fact n::nat)\"<br>\nproof (induct n rule: nat_induct_at_least)<br>\n  case base<br>\n  then show ?case<br>\n    by (auto simp: eval_nat_numeral)<br>\nnext<br>\n  case (Suc n)<br>\n  with Suc_le_D show ?case<br>\n    by (fastforce simp add: eval_nat_numeral)<br>\nqed</p>\n<p>There are two fine points to note. First I am using the built-in factorial (fact), which is overloaded over numeric types, so the type constraint is necessary. And two, rewriting by eval_nat_numeral transforms numerals into Suc-form, which you need here. The lemma Suc_le_D what suggested by sledgehammer.</p>\n<p>Larry</p>",
        "id": 436663104,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714646055
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIn this case I'm really surprised if sledgehammer cannot figure it out. That really is precisely what it is for.<br>\nLarry</p>",
        "id": 436663208,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714646110
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nQuite a few users, especially newbies, want to use Isabelle to explore proofs at a low level, basically in terms of individual rule applications. Isabelle is not designed for this application. It’s worth bearing in mind that proofs of even trivial facts can be enormous if broken down in that way.</p>\n<p>Larry</p>",
        "id": 437036562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1714843245
    }
]