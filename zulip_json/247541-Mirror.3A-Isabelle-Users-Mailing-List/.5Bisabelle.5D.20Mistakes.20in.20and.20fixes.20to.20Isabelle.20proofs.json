[
    {
        "content": "<p>From: Talia Ringer &lt;<a href=\"mailto:tringer@cs.washington.edu\">tringer@cs.washington.edu</a>&gt;<br>\nHi all, hope you're doing well! I'm looking to evaluate a machine learning<br>\ntool on a task related to proof repair for Isabelle. I'm curious if anyone<br>\nhas anything that might help us with benchmarks for this, like:</p>\n<ol>\n<li>examples of real mistakes in Isabelle proofs,</li>\n<li>examples of real fixes to broken Isabelle proofs,</li>\n<li>anecdotes about common ways they mess up when writing proofs,</li>\n<li>anecdotes about concrete ways they've messed up on particular proofs in<br>\nthe past, even if not documented in version control history.</li>\n</ol>\n<p>I'm also curious to what degree the kinds of changes seen in the Coq change<br>\ndata in REPLICA &lt;<a href=\"https://dependenttyp.es/pdf/analytics.pdf\">https://dependenttyp.es/pdf/analytics.pdf</a>&gt; are similar to<br>\nthose people make in Isabelle, and where and how they differ, though that<br>\nmay be a complex question that is not easy to address in an email.</p>\n<p>I super welcome any pointers any of you have!</p>\n<p>Talia</p>",
        "id": 285968663,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655144047
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nHello,</p>\n<p>I don't understand what you mean by \"mistakes in proofs\". The whole <br>\npoint of having a proof assistant is that you cannot make mistakes in <br>\nyour proofs, is it not?</p>\n<p>Or do you mean mistakes in definitions/theorem statements? Or perhaps <br>\n\"mistakes\" in the sense of \"bad style\"? Or \"mistakes\" as in \"existing <br>\nproof breaks due to some changes elsewhere in the library/in the system\"?</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 285973642,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655146636
    },
    {
        "content": "<p>From: Talia Ringer &lt;<a href=\"mailto:tringer@cs.washington.edu\">tringer@cs.washington.edu</a>&gt;<br>\nI know very well how proof assistants work :). Mistakes in proofs happen<br>\nwhen you are attempting to prove something, and you try a particular<br>\napproach to your proof, but it doesn't work, so you need to go back and<br>\nrevisit. See, for example, the linked paper.</p>\n<p>Talia</p>",
        "id": 285976207,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655147794
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nI did not mean to suggest that you don't (my apologies if it sounded that way), but I for one could not see what you meant, and I deemed it likely that others also might not.</p>\n<p>It might have become clear from reading the paper, but I think you are likely to get more responses from people if they don't have to read a paper before understanding what you mean.</p>\n<p>As for your question, here are a few fairly low-level things off the top of my head:</p>\n<ul>\n<li>\n<p>You try to prove something but the type is too polymorphic. You have to add a type constraint (e.g. 0 :: nat) somewhere or a more specific type class constraint and then it works. This is particularly tricky because you can have two terms that look exactly the same when printed but aren't.</p>\n</li>\n<li>\n<p>coercions got inserted in the wrong place; the fix is to add them manually in the right place.</p>\n</li>\n<li>\n<p>You forgot to declare some variable or term as \"arbitrary\" in an induction.</p>\n</li>\n<li>\n<p>You have to manually instantiate a fact that you use to help the automation along.</p>\n</li>\n<li>\n<p>Looping simplifier (but that tends to be less obvious to fix)</p>\n</li>\n<li>\n<p>A rule doesn't quite apply because of some minor discrepancy (e.g. a + b instead of b + a, different bracketing)</p>\n</li>\n<li>\n<p>very technical: \"using A B by (rule foo) some_method\" does not work because \"rule\" tries to match the chained facts A and B against the premises of \"foo\". Need to do e.g. \"by (rule foo) (use A B in some_method)\" instead.</p>\n</li>\n<li>\n<p>the simplifier does not rewrite underneath \"if\" by default; need to add if_cong as a congruence rule manually.</p>\n</li>\n<li>\n<p>very generally: auto/simp get stuck somewhere, but with a few extra \"simp\" rules the proof goes through.</p>\n</li>\n<li>\n<p>you added too many facts (and/or facts that are too general) to your goal state, which causes the automation to get lost and not terminate. Fix is to break the proof up into smaller Isar steps or remove unnecessary facts/instantiate them by hand to narrow down the search space.</p>\n</li>\n</ul>\n<p>Most of these are things that you tend to learn very early as an Isabelle user, but especially the polymorphism and the coercions happen even to experienced users and often take a minute or so to figure out.</p>\n<p>For a more high-level thing, reindexing arguments for sums are often fairly easy with \"sum.reindex_bij_witness\". If you don't know that trick, they can be fairly tedious.</p>\n<p>Let me know if you want be to explain any of these more. I'll let you know if I think of anything else.</p>\n<p>Cheers</p>\n<p>Manuel</p>",
        "id": 285991381,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655155370
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nTalia,</p>",
        "id": 285993899,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655156709
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nI second Manuel's points. Here are a few additions:</p>\n<p>On 13/06/2022 22:21, Manuel Eberl wrote:</p>\n<blockquote>\n<ul>\n<li>You try to prove something but the type is too polymorphic. You have <br>\nto add a type constraint (e.g. 0 :: nat) somewhere or a more specific <br>\ntype class constraint and then it works. This is particularly tricky <br>\nbecause you can have two terms that look exactly the same when printed <br>\nbut aren't.</li>\n</ul>\n</blockquote>\n<p>This comes in a few varieties. One is forgetting type annotations in <br>\nlemmas, as Manuel mentions. Related to that, you sometimes define too <br>\ngeneric constants for your concepts. For example, you might want to <br>\ndefine a shallowly embedded semantics on some memory type mem. For <br>\noperations that do not modify memory, it's tempting to do something <br>\nlike: definition \"add r1 r2 m = (r1+r2,m)\". If you forget a type <br>\nconstraint, the constant is too generic, and might require type <br>\nannotations later on ... though here, the \"correct\" way would be to add <br>\na type constraint to the definition.</p>\n<ul>\n<li>Another Isabelle pitfall is the typing of free variables in a lemma. <br>\nFor example, the following lemma is perfectly provable (but does not <br>\nmean what you expect):</li>\n</ul>\n<p>definition \"assert p ≡ if p then Some () else None\"</p>\n<p>lemma<br>\n         monad_laws: \"a⤜Some = a\" \"Some x⤜f = f x\"<br>\n     and assert_bind: \"assert p⤜f = (if p then f () else None)\"<br>\n     and garbage: \"x=y\"</p>\n<p>note: x and y have type unit in all four statements!</p>\n<blockquote>\n<ul>\n<li>\n<p>coercions got inserted in the wrong place; the fix is to add them <br>\nmanually in the right place.<br>\n(this was (and still is) my main critique point on coercions. They can <br>\nalter the meaning of your (main) theorem without noticing. )</p>\n</li>\n<li>\n<p>Looping simplifier (but that tends to be less obvious to fix)</p>\n</li>\n</ul>\n</blockquote>\n<p>The simplifier (and classical set) is one of Isabelle's aspects that <br>\nrequire a lot of experience, and there are only rough informal rules how <br>\na good simpset should look like.</p>\n<ul>\n<li>not simplified LHS of simp lemmas:</li>\n</ul>\n<p>lemma [simp]: \"f (1::nat) = (2::nat)\" will never be applied by the <br>\nsimplifier, as the simplifier will first rewrite 1 = Suc 0</p>\n<ul>\n<li>\n<p>adding a new simplification rule invalidates existing ones. Similar, a <br>\nrule like \"1=Suc 0\" could be added later, unwittingly making existing <br>\nsimplifier setup unusable.</p>\n</li>\n<li>\n<p>simp-rules interfere with locale interpretations:</p>\n</li>\n</ul>\n<p>interpretation my_locale \"(1::nat)\"</p>\n<p>all lemmas and abbreviations will use 1::nat, and break the first time <br>\nthe simplifier is run. Automatically declaring cong-rules would help <br>\nhere, but I don't remember why that isn't done by default.</p>",
        "id": 286045715,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655199806
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nRegarding the \"proofs break due to development further up in the theory <br>\nhierarchy\" thing, I think there are mainly two things that happen:</p>\n<ol>\n<li>\n<p>the name of some definition/theorem changes</p>\n</li>\n<li>\n<p>the content of some definition (including the type) or theorem changes</p>\n</li>\n</ol>\n<p>Typically such changes make things more general (e.g. a definition with <br>\na more general type, or a theorem with fewer/weaker premises), but the <br>\nother direction also happens.</p>\n<p>Things becoming less general is of course more likely to cause a <br>\nproblem, but even things becoming more general can become a problem, <br>\ne.g. if an Isar proof explicitly proves something that doesn't have to <br>\nbe proved anymore.</p>\n<p>Changes of names of course also leads to problems. A definition name <br>\nchanging can break a lot of things and is thus rarely done (it can <br>\nhappen accidentally when import order changes, e.g. with <br>\n<a href=\"http://MPoly_Type.degree\">MPoly_Type.degree</a> and <a href=\"http://Polynomial.degree\">Polynomial.degree</a>). Fact names changing happens <br>\nmore often and also breaks proofs that explicitly mention these facts by <br>\nnames. The most fragile ones here are sledgehammer-generated proofs <br>\nusing metis/smt. But these can typically be fixed easily by just running <br>\nsledgehammer again.</p>\n<p>Occasionally, things also break in much more obscure ways, e.g. the <br>\nautomation failing or looping on something it could previously do. <br>\nRepairing this then typically involves again breaking the goal down into <br>\nsmaller/more explicit steps. This happens particularly in proofs that <br>\nare written in \"bad style\" (in my opinion).</p>\n<p>Manuel</p>",
        "id": 286053025,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655204137
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThere's a whole class of such errors that fall under the general heading of \"omitting something obvious\". Other people have already mentioned instances of this, in particular omitting type constraints or type class constraints, which makes the claim too general. Also under this heading: omitting assertions that are too obvious (e.g. that any mentioned divisors are nonzero, or for a theorem about an integral, forgetting to assume that the given function has an integral).</p>\n<p>Another class of errors comes under \"setting up induction wrong\". This might mean using the wrong induction rule, trying to prove something that is insufficiently general, or incorrectly incorporating site conditions into the induction. This latter error is Isabelle specific and has to do with supplying (e.g. via \"using\") side conditions into the induction method and being sure to specify any variables in them as \"arbitrary\".</p>\n<p>Larry</p>",
        "id": 286056687,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655206259
    },
    {
        "content": "<p>From: Talia Ringer &lt;<a href=\"mailto:tringer@cs.washington.edu\">tringer@cs.washington.edu</a>&gt;<br>\nThanks, all, these are super helpful!</p>",
        "id": 286155210,
        "sender_full_name": "Email Gateway",
        "timestamp": 1655257916
    }
]