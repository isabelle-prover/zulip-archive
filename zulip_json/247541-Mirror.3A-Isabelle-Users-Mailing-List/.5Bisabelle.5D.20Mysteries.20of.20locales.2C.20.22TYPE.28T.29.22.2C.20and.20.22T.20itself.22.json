[
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\n(See attached theory file for full context.)</p>\n<p>I have a need to impose constraints on a type, as in the following locale declaration:</p>\n<p>locale nondegenerate =<br>\n   fixes dummy :: 'a<br>\n   assumes is_nondegenerate: \"∃x :: 'a. x ≠ undefined\"</p>\n<p>This works, and produces in the output window:</p>\n<blockquote>\n<p>locale nondegenerate<br>\n  fixes dummy :: \"'a\"<br>\n  assumes \"nondegenerate TYPE('a)\"</p>\n</blockquote>\n<p>I then make an interpretation of this locale (output shown as quotations):</p>\n<p>context<br>\n   begin</p>\n<p>interpretation nondegenerate ‹undefined :: bool›</p>\n<blockquote>\n<p>proof (prove)<br>\n  goal (1 subgoal):<br>\n   1. nondegenerate TYPE(bool)</p>\n</blockquote>\n<p>proof<br>\n       obtain f :: \"bool ⇒ bool\" where f: \"inj f\"<br>\n         using inj_on_id2 by blast<br>\n       show \"∃x :: bool. x ≠ undefined\"<br>\n         by blast<br>\n     qed</p>\n<p>So far, so good.  Then I try:</p>\n<p>lemma bool_is_nondegenerate:<br>\n     shows \"nondegenerate (undefined :: bool)\"</p>\n<blockquote>\n<p>Type unification failed: Clash of types \"bool\" and \"_ itself\"</p>\n<p>Type error in application: incompatible operand type</p>\n<p>Operator:  nondegenerate :: ??'a itself ⇒ bool<br>\n  Operand:   undefined :: bool</p>\n</blockquote>\n<p>Hmm... I try instead:</p>\n<p>lemma bool_is_nondegenerate:<br>\n     shows \"nondegenerate (undefined :: bool itself)\"<br>\n       using nondegenerate_axioms<br>\n       apply blast</p>\n<blockquote>\n<p>theorem bool_is_nondegenerate:<br>\n   nondegenerate undefined <br>\n  Failed to apply initial proof method⌂:<br>\n  using this:<br>\n    nondegenerate TYPE(bool)<br>\n  goal (1 subgoal):<br>\n   1. nondegenerate undefined</p>\n</blockquote>\n<p>In this case, Ctrl-hover in the output window over the<br>\n\"undefined\" in the goal shows \"constant: HOL.undefined\".</p>\n<p>oops</p>\n<p>Now I try:</p>\n<p>lemma bool_is_nondegenerate:<br>\n     shows \"nondegenerate TYPE(bool)\"<br>\n       ..</p>\n<blockquote>\n<p>theorem bool_is_nondegenerate:<br>\n   nondegenerate TYPE(bool)</p>\n</blockquote>\n<p>This appears to succeed.  I now check that this fact allows me to<br>\nreinstantiate the locale:</p>\n<p>end</p>\n<p>context<br>\n   begin</p>\n<p>interpretation nondegenerate ‹undefined :: bool›<br>\n       using bool_is_nondegenerate by blast</p>\n<p>end</p>\n<p>This succeeds, so it seems that I have achieved what I wanted.  But I don't have<br>\nthe slightest understanding of the failed cases, nor do I have a very clear idea of<br>\nwhat \"TYPE(T)\" and \"T itself\" really are.  I have looked on multiple occasions for<br>\nsome kind of documentation of these constructs, but I could not find any.</p>\n<p>Can someone explain how to understand the above?  Thanks.</p>\n<p>- Gene Stark<br>\n<a href=\"/user_uploads/14278/y-MP3S85bjBfG-mbTu2V8WAQ/Foo.thy\">Foo.thy</a></p>",
        "id": 299324038,
        "sender_full_name": "Email Gateway",
        "timestamp": 1663422401
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nHello,</p>\n<p>this mostly isn't really a locale issue, but an issue with the ML-style <br>\nad-hoc polymorphism in Isabelle. This is described briefly in §2.3.2 of <br>\nthe Isabelle implementation manual. But let me try to explain it here as <br>\nwell:</p>\n<p>Explicit polymorphism would be to model polymorphic constants as <br>\nfunctions that take \"type parameters\". Isabelle, on the other hand, does <br>\nnot have explicit type parameters but has a kind of implicit polymorphism.</p>\n<p>Consider for instance the following definition:</p>\n<p>definition \"foo = (∀x. x = x)\"</p>\n<p>This constant \"foo\" is of Boolean type, but it is polymorphic – even <br>\nthough its type itself is not polymorphic. The question of whether \"foo\" <br>\nis true or not depends on the type of the \"x\" that we are quantifying <br>\nover. Of course, this is just not possible. If you have something of <br>\ntype \"bool\", it cannot be True in one context and False in another.</p>\n<p>The solution to this is hinted at when you look at the warning message <br>\nemitted by Isabelle:</p>\n<blockquote>\n<p>Additional type variable(s) in specification of \"foo\": 'a<br>\nand inspecting the actual type of foo:<br>\n\"foo\"<br>\n  :: \"'a itself ⇒ bool\"<br>\nIsabelle adds an additional dummy parameter to the \"foo\" to make this <br>\nimplicit dependence on the \"type parameter\" 'a explicit. The type \"'a <br>\nitself\" is essentially a singleton type that only contains the dummy <br>\nvalue \"Pure.type :: 'a itself\", which can, for convenience, be written <br>\nwith the syntax \"TYPE('a)\". Similar tricks are often employed in Haskell <br>\nto bring type parameters to the term level.</p>\n</blockquote>\n<p>In practice, these issues rarely show up. One example is something like <br>\nthe characteristic of a (semi-)ring, where the ring in question comes <br>\nfrom a typeclass. The following is a slightly modified example taken <br>\nfrom the \"GCD\" theory in the HOL session in the Isabelle distribution:</p>\n<blockquote>\n<p>definition semiring_char :: \"'a :: semiring_1 itself ⇒ nat\"<br>\n  where \"semiring_char _ = Gcd {n. of_nat n = (0 :: 'a)}\"<br>\nHere, the dependence on the type parameter 'a was already made explicit <br>\nby adding a dummy \"itself\" parameter. One could also have done without it:</p>\n</blockquote>\n<blockquote>\n<p>definition semiring_char :: \"nat\"<br>\n  where \"semiring_char = Gcd {n. of_nat n = (0 :: 'a :: semiring_1)}\"<br>\nIn this case, we get the same warning as above and Isabelle would add <br>\nthe \"itself\" parameter and the end result would be the same.</p>\n</blockquote>\n<p>In your example, the perhaps confusing bit is that Isabelle seems to <br>\nhave eliminated your \"dummy\" parameter (presumably because nothing in <br>\nyour locale actually depends on the value of \"dummy\") and then, through <br>\nthe above mechanism, introduced its own dummy parameter of type \"'a <br>\nitself\". The exact mechanism of elimination of this unnecessary <br>\nparameter is not clear to me, especially because it doesn't do this in <br>\nother cases, such as \"locale foo = fixes x :: bool\". There we can do <br>\n\"interpretation foo True\" without an error.</p>\n<p>In any case, I would recommend just replacing your \"dummy :: 'a\" <br>\nparameter with a \"dummy :: 'a itself\" parameter and doing the <br>\ninterpretation with \"TYPE('a)\" instead of \"undefined :: 'a\".</p>\n<p>By the way, your \"degenerate\" locale might as well be turned into a <br>\n\"degenerate\" type class (you do get a \"additional type variables\" <br>\nwarning, but you can just ignore it):</p>\n<blockquote>\n<p>class nondegenerate =<br>\n  assumes is_nondegenerate: \"∃x :: 'a. x ≠ undefined\"</p>\n<p>instance bool :: nondegenerate<br>\n  by intro_classes blast<br>\nI for one would however phrase the axiom as \"∃x y. x ≠ y\" instead. <br>\nLogically equivalent, of course, but I for one think it's nicer.</p>\n</blockquote>\n<p>Hope that helps.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>For the nitpicks: \"'a itself\" is only a singleton type in the sense that <br>\nwe cannot prove it to have more than one value. The only way to <br>\nconstruct values of type \"'a itself\" is through \"Pure.type\" and of <br>\ncourse things like \"undefined\" and \"SOME x. True\". There is no way to <br>\nprove that it is a singleton type.</p>\n<p>On 17/09/2022 15:46, Eugene W. Stark wrote:</p>\n<blockquote>\n<p>(See attached theory file for full context.)</p>\n<p>I have a need to impose constraints on a type, as in the following <br>\nlocale declaration:</p>\n<p>locale nondegenerate =<br>\n  fixes dummy :: 'a<br>\n  assumes is_nondegenerate: \"∃x :: 'a. x ≠ undefined\"</p>\n<p>This works, and produces in the output window:</p>\n<blockquote>\n<p>locale nondegenerate<br>\n  fixes dummy :: \"'a\"<br>\n  assumes \"nondegenerate TYPE('a)\"</p>\n</blockquote>\n<p>I then make an interpretation of this locale (output shown as <br>\nquotations):</p>\n<p>context<br>\n  begin</p>\n<p>interpretation nondegenerate ‹undefined :: bool›</p>\n<blockquote>\n<p>proof (prove)<br>\n  goal (1 subgoal):<br>\n   1. nondegenerate TYPE(bool)</p>\n</blockquote>\n<p>proof<br>\n      obtain f :: \"bool ⇒ bool\" where f: \"inj f\"<br>\n        using inj_on_id2 by blast<br>\n      show \"∃x :: bool. x ≠ undefined\"<br>\n        by blast<br>\n    qed</p>\n<p>So far, so good.  Then I try:</p>\n<p>lemma bool_is_nondegenerate:<br>\n    shows \"nondegenerate (undefined :: bool)\"</p>\n<blockquote>\n<p>Type unification failed: Clash of types \"bool\" and \"_ itself\"</p>\n<p>Type error in application: incompatible operand type</p>\n<p>Operator:  nondegenerate :: ??'a itself ⇒ bool<br>\n  Operand:   undefined :: bool</p>\n</blockquote>\n<p>Hmm... I try instead:</p>\n<p>lemma bool_is_nondegenerate:<br>\n    shows \"nondegenerate (undefined :: bool itself)\"<br>\n      using nondegenerate_axioms<br>\n      apply blast</p>\n<blockquote>\n<p>theorem bool_is_nondegenerate:<br>\n   nondegenerate undefined   Failed to apply initial proof method⌂:<br>\n  using this:<br>\n    nondegenerate TYPE(bool)<br>\n  goal (1 subgoal):<br>\n   1. nondegenerate undefined</p>\n</blockquote>\n<p>In this case, Ctrl-hover in the output window over the<br>\n\"undefined\" in the goal shows \"constant: HOL.undefined\".</p>\n<p>oops</p>\n<p>Now I try:</p>\n<p>lemma bool_is_nondegenerate:<br>\n    shows \"nondegenerate TYPE(bool)\"<br>\n      ..</p>\n<blockquote>\n<p>theorem bool_is_nondegenerate:<br>\n   nondegenerate TYPE(bool)</p>\n</blockquote>\n<p>This appears to succeed.  I now check that this fact allows me to<br>\nreinstantiate the locale:</p>\n<p>end</p>\n<p>context<br>\n  begin</p>\n<p>interpretation nondegenerate ‹undefined :: bool›<br>\n      using bool_is_nondegenerate by blast</p>\n<p>end</p>\n<p>This succeeds, so it seems that I have achieved what I wanted. But I <br>\ndon't have<br>\nthe slightest understanding of the failed cases, nor do I have a very <br>\nclear idea of<br>\nwhat \"TYPE(T)\" and \"T itself\" really are.  I have looked on multiple <br>\noccasions for<br>\nsome kind of documentation of these constructs, but I could not find any.</p>\n<p>Can someone explain how to understand the above?  Thanks.</p>\n<p>- Gene Stark</p>\n</blockquote>",
        "id": 299810893,
        "sender_full_name": "Email Gateway",
        "timestamp": 1663694813
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nOn 9/20/22 13:26, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>this mostly isn't really a locale issue, but an issue with the ML-style ad-hoc polymorphism in Isabelle. This is <br>\ndescribed briefly in §2.3.2 of the Isabelle implementation manual. But let me try to explain it here as well:<br>\n</p>\n</blockquote>\n<p>Thanks for this pointer.  For some reason, \"TYPE\" and \"itself\" did not make it into to the index of<br>\nthis document.  I am pondering what it says in §2.3.2.  As is my usual experience with the core Isabelle documentation,<br>\nI feel as though one has to understand everything before understanding anything, but it is a start.</p>\n<blockquote>\n<p>Explicit polymorphism would be to model polymorphic constants as functions that take \"type parameters\". Isabelle, on the <br>\nother hand, does not have explicit type parameters but has a kind of implicit polymorphism.</p>\n<p>Consider for instance the following definition:</p>\n<p>definition \"foo = (∀x. x = x)\"</p>\n<p>This constant \"foo\" is of Boolean type, but it is polymorphic – even though its type itself is not polymorphic. The <br>\nquestion of whether \"foo\" is true or not depends on the type of the \"x\" that we are quantifying over. Of course, this is <br>\njust not possible. If you have something of type \"bool\", it cannot be True in one context and False in another.</p>\n<p>The solution to this is hinted at when you look at the warning message emitted by Isabelle:</p>\n<blockquote>\n<p>Additional type variable(s) in specification of \"foo\": 'a<br>\nand inspecting the actual type of foo:<br>\n\"foo\"<br>\n  :: \"'a itself ⇒ bool\"<br>\nIsabelle adds an additional dummy parameter to the \"foo\" to make this implicit dependence on the \"type parameter\" 'a <br>\nexplicit. The type \"'a itself\" is essentially a singleton type that only contains the dummy value \"Pure.type :: 'a <br>\nitself\", which can, for convenience, be written with the syntax \"TYPE('a)\". Similar tricks are often employed in Haskell <br>\nto bring type parameters to the term level.<br>\n</p>\n</blockquote>\n</blockquote>\n<p>Very helpful, thank you.</p>\n<blockquote>\n<p>In practice, these issues rarely show up. One example is something like the characteristic of a (semi-)ring, where the <br>\nring in question comes from a typeclass. The following is a slightly modified example taken from the \"GCD\" theory in the <br>\nHOL session in the Isabelle distribution:</p>\n<blockquote>\n<p>definition semiring_char :: \"'a :: semiring_1 itself ⇒ nat\"<br>\n  where \"semiring_char _ = Gcd {n. of_nat n = (0 :: 'a)}\"<br>\nHere, the dependence on the type parameter 'a was already made explicit by adding a dummy \"itself\" parameter. One could <br>\nalso have done without it:</p>\n</blockquote>\n<blockquote>\n<p>definition semiring_char :: \"nat\"<br>\n  where \"semiring_char = Gcd {n. of_nat n = (0 :: 'a :: semiring_1)}\"<br>\nIn this case, we get the same warning as above and Isabelle would add the \"itself\" parameter and the end result would be <br>\nthe same.</p>\n</blockquote>\n<p>In your example, the perhaps confusing bit is that Isabelle seems to have eliminated your \"dummy\" parameter (presumably <br>\nbecause nothing in your locale actually depends on the value of \"dummy\") and then, through the above mechanism, <br>\nintroduced its own dummy parameter of type \"'a itself\". The exact mechanism of elimination of this unnecessary parameter <br>\nis not clear to me, especially because it doesn't do this in other cases, such as \"locale foo = fixes x :: bool\". There <br>\nwe can do \"interpretation foo True\" without an error.</p>\n</blockquote>\n<p>One reason for the explicit \"dummy\" parameter is that I have a collection of related locales that need to ensure<br>\nthat the same type is referred to in each of them.  If the parameter is included, then the types are forced to be<br>\nthe same via the fact that the same parameter \"dummy\" is taken by all the locales.  If the parameter is<br>\nomitted, then a fresh type variable is introduced during type inference and this connection is not obtained.</p>\n<blockquote>\n<p>In any case, I would recommend just replacing your \"dummy :: 'a\" parameter with a \"dummy :: 'a itself\" parameter and <br>\ndoing the interpretation with \"TYPE('a)\" instead of \"undefined :: 'a\".</p>\n</blockquote>\n<p>I will think about this and try it -- thanks.</p>\n<blockquote>\n<p>By the way, your \"degenerate\" locale might as well be turned into a \"degenerate\" type class (you do get a \"additional <br>\ntype variables\" warning, but you can just ignore it):</p>\n<blockquote>\n<p>class nondegenerate =<br>\n  assumes is_nondegenerate: \"∃x :: 'a. x ≠ undefined\"</p>\n<p>instance bool :: nondegenerate<br>\n  by intro_classes blast</p>\n</blockquote>\n</blockquote>\n<p>I will also think about this.</p>\n<blockquote>\n<p>I for one would however phrase the axiom as \"∃x y. x ≠ y\" instead. Logically equivalent, of course, but I for one think <br>\nit's nicer.</p>\n<p>Hope that helps.</p>\n</blockquote>\n<p>Yes, thank you very much for taking the time to respond.  -- Gene Stark</p>\n<blockquote>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>For the nitpicks: \"'a itself\" is only a singleton type in the sense that we cannot prove it to have more than one value. <br>\nThe only way to construct values of type \"'a itself\" is through \"Pure.type\" and of course things like \"undefined\" and <br>\n\"SOME x. True\". There is no way to prove that it is a singleton type.</p>\n<p>On 17/09/2022 15:46, Eugene W. Stark wrote:</p>\n<blockquote>\n<p>(See attached theory file for full context.)</p>\n<p>I have a need to impose constraints on a type, as in the following locale declaration:</p>\n<p>locale nondegenerate =<br>\n  fixes dummy :: 'a<br>\n  assumes is_nondegenerate: \"∃x :: 'a. x ≠ undefined\"</p>\n<p>This works, and produces in the output window:</p>\n<blockquote>\n<p>locale nondegenerate<br>\n  fixes dummy :: \"'a\"<br>\n  assumes \"nondegenerate TYPE('a)\"</p>\n</blockquote>\n<p>I then make an interpretation of this locale (output shown as quotations):</p>\n<p>context<br>\n  begin</p>\n<p>interpretation nondegenerate ‹undefined :: bool›</p>\n<blockquote>\n<p>proof (prove)<br>\n  goal (1 subgoal):<br>\n   1. nondegenerate TYPE(bool)</p>\n</blockquote>\n<p>proof<br>\n      obtain f :: \"bool ⇒ bool\" where f: \"inj f\"<br>\n        using inj_on_id2 by blast<br>\n      show \"∃x :: bool. x ≠ undefined\"<br>\n        by blast<br>\n    qed</p>\n<p>So far, so good.  Then I try:</p>\n<p>lemma bool_is_nondegenerate:<br>\n    shows \"nondegenerate (undefined :: bool)\"</p>\n<blockquote>\n<p>Type unification failed: Clash of types \"bool\" and \"_ itself\"</p>\n<p>Type error in application: incompatible operand type</p>\n<p>Operator:  nondegenerate :: ??'a itself ⇒ bool<br>\n  Operand:   undefined :: bool</p>\n</blockquote>\n<p>Hmm... I try instead:</p>\n<p>lemma bool_is_nondegenerate:<br>\n    shows \"nondegenerate (undefined :: bool itself)\"<br>\n      using nondegenerate_axioms<br>\n      apply blast</p>\n<blockquote>\n<p>theorem bool_is_nondegenerate:<br>\n   nondegenerate undefined   Failed to apply initial proof method⌂:<br>\n  using this:<br>\n    nondegenerate TYPE(bool)<br>\n  goal (1 subgoal):<br>\n   1. nondegenerate undefined</p>\n</blockquote>\n<p>In this case, Ctrl-hover in the output window over the<br>\n\"undefined\" in the goal shows \"constant: HOL.undefined\".</p>\n<p>oops</p>\n<p>Now I try:</p>\n<p>lemma bool_is_nondegenerate:<br>\n    shows \"nondegenerate TYPE(bool)\"<br>\n      ..</p>\n<blockquote>\n<p>theorem bool_is_nondegenerate:<br>\n   nondegenerate TYPE(bool)</p>\n</blockquote>\n<p>This appears to succeed.  I now check that this fact allows me to<br>\nreinstantiate the locale:</p>\n<p>end</p>\n<p>context<br>\n  begin</p>\n<p>interpretation nondegenerate ‹undefined :: bool›<br>\n      using bool_is_nondegenerate by blast</p>\n<p>end</p>\n<p>This succeeds, so it seems that I have achieved what I wanted. But I don't have<br>\nthe slightest understanding of the failed cases, nor do I have a very clear idea of<br>\nwhat \"TYPE(T)\" and \"T itself\" really are.  I have looked on multiple occasions for<br>\nsome kind of documentation of these constructs, but I could not find any.</p>\n<p>Can someone explain how to understand the above?  Thanks.</p>\n<p>- Gene Stark</p>\n</blockquote>\n</blockquote>",
        "id": 299926087,
        "sender_full_name": "Email Gateway",
        "timestamp": 1663756753
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Eugene,</p>\n<p>One more addition to Manuel's excellent explanation: A locale <br>\ndeclaration defines a constant with the same name as the locale that <br>\ncollects all the assumptions of the locale in a predicate. As arguments, <br>\nthe constant takes those locale parameters that actually appear in the <br>\nassumptions. In your locale, the dummy parameter does not show up in the <br>\nlocale assumptions. Accordinglz, the generated constant nondegenerate is <br>\ndefined as</p>\n<p>\"nondegenerate == ∃x :: 'a. x ≠ undefined\"</p>\n<p>This definition depends on the type variable 'a very much similar to <br>\nManuel's foo. Therefore, Isabelle's definition facilities add the \"'a <br>\nitself\" parameter to make this dependence explicit.</p>\n<p>I'd recommend to avoid this roundabout way of introducing a type <br>\ndependency by adding a vacuous assumption involving dummy, for example</p>\n<p>locale nondegenerate = fixes dummy :: 'a<br>\n   assumes is_nondegenerate: \"∃x :: 'a. x ≠ undefined\"<br>\n     and dummy: \"dummy = dummy\"</p>\n<p>This will make the constant nondegenerate depend on the parameter dummy, <br>\nso its type is now \"'a =&gt; bool\" and there's no hidden polymorphism any <br>\nmore. You can of course change dummy's type to \"'a itself\" to make <br>\nexplicit that the locale does not care about the particular value chosen.</p>\n<p>The benefit of adding the dummy assumption can be seen when you have <br>\nmultiple such parameters in a locale:</p>\n<p>locale l = fixes dummy1 :: \"'a itself\" and dummy2 :: \"'b itself\"<br>\n   assumes \"∃x :: 'b. x ≠ undefined\" \"∃x :: 'a. x ≠ undefined\"</p>\n<p>Here, the order of the itself arguments to the generated constant l <br>\ndepends on the Isabelle internals for making the hidden polymorphism <br>\nexplicit. In particular, they are not controlled by the order of the <br>\nlocale arguments. This is brittle and possibly confusing. Instead, if <br>\nyou explicitly add the vacuous assumptions, you're in control of the <br>\norder of parameters.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 300182779,
        "sender_full_name": "Email Gateway",
        "timestamp": 1663859538
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nThank you, Andreas, your note is also very helpful.</p>\n<p>Though I can't say my understanding is crystal clear just yet, I've been able to rework things<br>\nusing what Manuel and you have said and arrive at something less obscure and redundant and<br>\nin general more to my taste.</p>\n<p>I have taken into consideration your \"dummy = dummy\" suggestion, but I am currently not liking<br>\nit so much, due to the extra trivial proof obligations that are introduced when the locales are<br>\ninterpreted.  But I might change my mind if I run into the brittleness that you indicate.</p>\n<p>-- Gene Stark</p>",
        "id": 300250765,
        "sender_full_name": "Email Gateway",
        "timestamp": 1663883237
    }
]