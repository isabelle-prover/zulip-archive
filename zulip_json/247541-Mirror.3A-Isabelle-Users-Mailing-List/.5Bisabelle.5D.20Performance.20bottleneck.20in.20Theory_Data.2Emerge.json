[
    {
        "content": "<p>From: Norbert Schirmer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>I try to track down a performance bottleneck in theory merge.</p>\n<p>I enabled timing information by</p>\n<p>ML “val _ = Context.timing := true”</p>\n<p>Unfortunately the position information of the “slow\" data slot is not available, I just get the message:</p>\n<p>Theory_Data.merge<br>\n44.390s elapsed time, 88.221s cpu time, 0.000s GC time</p>\n<p>Compared to other data slots where the position information is available as a link or a file reference:</p>\n<p>Theory_Data.merge⌂<br>\n0.016s elapsed time, 0.030s cpu time, 0.000s GC time</p>\n<p>Theory_Data.merge (file \"global_theory.ML\")<br>\n0.264s elapsed time, 0.523s cpu time, 0.000s GC time</p>\n<p>Any idea how to continue?</p>\n<p>What is the reason that the position information is lost? Could this be a hint which kind of data slot it could possibly be?</p>\n<p>Regards,<br>\nNorbert</p>",
        "id": 245838379,
        "sender_full_name": "Email Gateway",
        "timestamp": 1626188603
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nI think that the position information there boils down to<br>\nthat fetched by<br>\n   let val pos = Position.thread_data () in<br>\nin the definition of the function Theory_Data' in src/Pure.context.ML.</p>\n<p>I guess means that the data tables which don't have one are<br>\ndefined at points at which the local thread_data position<br>\nwasn't set. It seems to link to ML blocks and to the position<br>\nof ML_file commands pretty consistently for those kinds, so probably<br>\nthis is theory data defined in some special ML file, maybe one of the<br>\nones in Pure. That's not much help, is it?</p>\n<p>If you're very keen to figure it out, I'd be tempted to locally edit<br>\ncontext.ML to expose an alternative interface to Theory_Data that lets<br>\nthe client suggest a name which appears with the position info in <br>\ntiming.</p>\n<p>I was motivated to investigate this a little because I've had issues <br>\nwith<br>\nthis in the past.</p>\n<p>Best regards,<br>\n     Thomas.</p>",
        "id": 245844565,
        "sender_full_name": "Email Gateway",
        "timestamp": 1626191110
    },
    {
        "content": "<p>From: Norbert Schirmer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nI followed your advice and manually named all data. Here is what I found:</p>\n<ol>\n<li>\n<p>The inefficient data is in locale.ML, namely: structure Thms. Sets of theorems are represented as lists there. Changing this to Thmtab.set, and doing a pointer_eq test on merge seems to solve my performance issue.</p>\n</li>\n<li>\n<p>Whether position information is displayed or not seems to depend on how the structure is actually generated, ie.<br>\nvia. Theory_Data’, Theory_Data, or Generic_Data and also how the arguments are declared. Some observations:</p>\n</li>\n</ol>\n<ul>\n<li>Theory_Data’ seems to result in a filename as position</li>\n<li>Generic_Data(struct Type T = … end) seems to result in a link as position</li>\n<li>Generic_Data(Type T = …) (without the explicit struct) seems to have no position information.</li>\n</ul>\n<p>Regards,<br>\nNorbert</p>",
        "id": 245983767,
        "sender_full_name": "Email Gateway",
        "timestamp": 1626280003
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n(This rather old thread still requires more comments.)</p>\n<p>On 14/07/2021 18:26, Norbert Schirmer via Cl-isabelle-users wrote:</p>\n<blockquote>\n<p>On 13. Jul 2021, at 17:44, Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a></p>\n<blockquote>\n<p>&lt;mailto:<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;&gt; wrote:</p>\n<p>If you're very keen to figure it out, I'd be tempted to locally edit<br>\ncontext.ML to expose an alternative interface to Theory_Data that lets<br>\nthe client suggest a name which appears with the position info in timing.</p>\n</blockquote>\n<p>I followed your advice and manually named all data. Here is what I found:</p>\n<ol>\n<li>The inefficient data is in locale.ML, namely: structure Thms. Sets of<br>\ntheorems are represented as lists there. Changing this to Thmtab.set, and<br>\ndoing a pointer_eq test on merge seems to solve my performance issue.</li>\n</ol>\n</blockquote>\n<p>I have already changed that some weeks ago, to use more scalable data<br>\nstructures. See<br>\n<a href=\"https://isabelle-dev.sketis.net/rISABELLEc3b3517ef4ba\">https://isabelle-dev.sketis.net/rISABELLEc3b3517ef4ba</a></p>\n<p>Note that thm Item_Net.T preserves the original \"canonical order of<br>\ndeclarations\": it is an index structure paired with a plain list; thus I don't<br>\nhave to argue if the order matters or not. (A minor disadvantage is that the<br>\nnet produces more heap garbage, so in extreme applications it might need to be<br>\nrevisited.)</p>\n<blockquote>\n<ol start=\"2\">\n<li>Whether position information is displayed or not seems to depend on how the<br>\nstructure is actually generated, ie.<br>\nvia. Theory_Data’, Theory_Data, or Generic_Data and also how the arguments are<br>\ndeclared. Some observations:\n* Theory_Data’ seems to result in a filename as position\n* Generic_Data(struct Type T = … end) seems to result in a link as position\n* Generic_Data(Type T = …) (without the explicit struct) seems to have no<br>\nposition information.</li>\n</ol>\n</blockquote>\n<p>I could not reproduce this observation.</p>\n<p>Makarius</p>",
        "id": 254349080,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632308625
    },
    {
        "content": "<p>From: Norbert Schirmer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nBelow is some example output from my debug-version (based on Isabelle2021) were I have explicitly named the data slots (cf. \"name\" below). Note the difference in the output for <br>\nsign.ML, locale.ML (locale), classical.ML. My guess was that it might be related to how the data slot is declared. Or is it related to the build (bootstrap) process of the sessions?</p>\n<p>From context.ML:</p>\n<p>type kind =<br>\n {pos: Position.T,<br>\n  name: string, <br>\n  empty: Any.T,<br>\n  extend: Any.T -&gt; Any.T,<br>\n  merge: theory * theory -&gt; Any.T * Any.T -&gt; Any.T};</p>\n<p>fun invoke name f k x =<br>\n  (case Datatab.lookup (Synchronized.value kinds) k of<br>\n    SOME kind =&gt;<br>\n      if ! timing andalso name &lt;&gt; \"\" then<br>\n        Timing.cond_timeit true (\"Theory_Data.\" ^ name ^ <a href=\"http://Position.here\">Position.here</a> (#pos kind) ^ \" \" ^ (#name kind))<br>\n          (fn () =&gt; f kind x)<br>\n      else f kind x<br>\n  | NONE =&gt; raise Fail \"Invalid theory data identifier\");</p>\n<p>From sign.ML: </p>\n<p>structure Data = Theory_Data'<br>\n(<br>\n  type T = sign;<br>\n  val name = \"sign.ML\";<br>\n  val extend = I;<br>\n  val empty = make_sign (Syntax.empty_syntax, Type.empty_tsig, Consts.empty);<br>\n  fun merge old_thys (sign1, sign2) =<br>\n    let<br>\n      val Sign {syn = syn1, tsig = tsig1, consts = consts1} = sign1;<br>\n      val Sign {syn = syn2, tsig = tsig2, consts = consts2} = sign2;</p>\n<p>val syn = Syntax.merge_syntax (syn1, syn2);<br>\n      val tsig = Type.merge_tsig (Context.Theory (fst old_thys)) (tsig1, tsig2);<br>\n      val consts = Consts.merge (consts1, consts2);<br>\n    in make_sign (syn, tsig, consts) end;<br>\n);</p>\n<p>From locale.ML:</p>\n<p>structure Locales = Theory_Data<br>\n(<br>\n  type T = locale Name_Space.table;<br>\n  val name = \"locale.ML (locale)\";<br>\n  val empty : T = Name_Space.empty_table \"locale\";<br>\n  val extend = I;<br>\n  val merge = Name_Space.join_tables (K merge_locale);<br>\n);</p>\n<p>From classical.ML:</p>\n<p>structure Claset = Generic_Data<br>\n(<br>\n  type T = claset;<br>\n  val name = \"classical.ML\";<br>\n  val empty = empty_cs;<br>\n  val extend = I;<br>\n  val merge = merge_cs;<br>\n);</p>\n<p>=======================================<br>\nTheory_Data.merge (file \"sign.ML\") sign.ML<br>\n0.223s elapsed time, 1.291s cpu time, 0.707s GC time <br>\nTheory_Data.merge (file \"theory.ML\") theory.ML<br>\n0.017s elapsed time, 0.105s cpu time, 0.000s GC time <br>\nTheory_Data.merge (file \"thm.ML\") thm.ML<br>\n0.003s elapsed time, 0.020s cpu time, 0.000s GC time <br>\nTheory_Data.merge (file \"global_theory.ML\") global_theory.ML<br>\n0.073s elapsed time, 0.432s cpu time, 0.000s GC time <br>\nTheory_Data.merge (file \"raw_simplifier.ML\") raw_simplifier.ML (simpset)<br>\n0.005s elapsed time, 0.032s cpu time, 0.000s GC time <br>\nTheory_Data.merge (file \"ML/ml_env.ML\") ml_env.ML<br>\n0.000s elapsed time, 0.001s cpu time, 0.000s GC time <br>\nTheory_Data.merge attrib.ML (attribute)<br>\n0.000s elapsed time, 0.001s cpu time, 0.000s GC time <br>\nTheory_Data.merge context_rules.ML<br>\n0.006s elapsed time, 0.047s cpu time, 0.000s GC time <br>\nTheory_Data.merge locale.ML (locale)<br>\n0.000s elapsed time, 0.001s cpu time, 0.000s GC time <br>\nTheory_Data.merge locale.ML (idents)<br>\n0.017s elapsed time, 0.089s cpu time, 0.000s GC time <br>\nTheory_Data.merge locale.ML (global_registrations)<br>\n0.000s elapsed time, 0.006s cpu time, 0.000s GC time <br>\nTheory_Data.merge locale.ML (thms)<br>\n0.001s elapsed time, 0.004s cpu time, 0.000s GC time <br>\nTheory_Data.merge bundle.ML<br>\n0.000s elapsed time, 0.002s cpu time, 0.000s GC time <br>\nTheory_Data.merge axclass.ML<br>\n0.000s elapsed time, 0.005s cpu time, 0.000s GC time <br>\nTheory_Data.merge class.ML<br>\n0.000s elapsed time, 0.002s cpu time, 0.000s GC time <br>\nTheory_Data.merge code.ML<br>\n0.001s elapsed time, 0.014s cpu time, 0.000s GC time <br>\nTheory_Data.merge spec_rules.ML<br>\n0.002s elapsed time, 0.010s cpu time, 0.000s GC time <br>\nTheory_Data.merge named_theorems.ML<br>\n0.003s elapsed time, 0.011s cpu time, 0.000s GC time <br>\nTheory_Data.merge generated_files.ML<br>\n0.000s elapsed time, 0.001s cpu time, 0.000s GC time <br>\nTheory_Data.merge (line 788 of \"~~/src/HOL/HOL.thy\") classical.ML<br>\n0.002s elapsed time, 0.009s cpu time, 0.000s GC time <br>\nTheory_Data.merge (line 1529 of \"~~/src/HOL/HOL.thy\") induct.ML<br>\n0.001s elapsed time, 0.006s cpu time, 0.000s GC time <br>\nTheory_Data.merge (line 416 of \"~~/src/HOL/Inductive.thy\") inductive.ML<br>\n0.000s elapsed time, 0.001s cpu time, 0.000s GC time <br>\nTheory_Data.merge (line 13 of \"~~/src/HOL/Fun_Def_Base.thy\") function_common.ML<br>\n0.000s elapsed time, 0.006s cpu time, 0.000s GC time <br>\nTheory_Data.merge (line 14 of \"~~/src/HOL/Fun_Def_Base.thy\") function_context_tree.ML<br>\n0.000s elapsed time, 0.004s cpu time, 0.000s GC time <br>\nTheory_Data.merge (line 260 of \"~~/src/HOL/Transfer.thy\") transfer.ML<br>\n0.001s elapsed time, 0.007s cpu time, 0.000s GC time</p>\n<p>Regards,<br>\nNorbert</p>",
        "id": 255007519,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632729031
    }
]