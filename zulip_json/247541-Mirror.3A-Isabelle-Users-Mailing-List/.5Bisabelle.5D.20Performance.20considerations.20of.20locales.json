[
    {
        "content": "<p>From: Norbert Schirmer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>In our applications we have a wide spread use of locales, both on the Isar toplevel<br>\nas well as in Isabelle/ML were locales are auto generated and certain definitions are made and <br>\ntheorems are proved within these locales.</p>\n<p>Recently we hit the tipping point, where actually more cpu-time is used for the <br>\ndeclaration of locales compared to the actual proof load that is performed within the locales.<br>\nI did some analysis to get a better understanding what actually happens and<br>\nwant to initiate a discussion on how this situation might be improved in the<br>\nfuture.</p>\n<p>First some high level description of our use of locales which triggered the tipping point:</p>\n<ol>\n<li>Locales are used to structure and modularize our work. </li>\n<li>\n<p>We stay abstract: Our clear focus is on declaring new<br>\n  locales on the basis of existing locales rather then interpreting locales.</p>\n</li>\n<li>\n<p>Most of the time an abstract entity within a locale aka fixes x::'a stays the same in<br>\n  the complete locale hierarchy. It is neither renamed nor is it's type changed when being imported to<br>\n  another locale. It might be shared among multiple locales.</p>\n</li>\n<li>\n<p>Within a locale we make definitions and proof theorems which are noted. <br>\n  A typical right hand side (rhs) of a definition can be a sizeable term containing polymorphic constants. <br>\n  For example think of a sequence of about 100 monadic binds in a state-monad.</p>\n</li>\n<li>\n<p>We use attributes on definitions as well as theorems to maintain our data for proof automation. </p>\n</li>\n</ol>\n<p>Reading and digesting the excellent background papers on locales [1] and local theories [2] and <br>\nstudying and profiling the actual code, I come to the conclusion that the actual <br>\nhot-spot is the omnipresent instantiation of<br>\nlocales. This happens in the roundup of locale expressions, both when defining new locales as well as <br>\nwhen entering the context of a locale. Profiling highlights low-level functions like Term.fold_atyps,<br>\nTerm_Subst.generalizeT_same, Term_Subst.inst_same...</p>\n<p>This is not surprising as the implementation of locales and local theories always starts from the<br>\nglobal theory where all definitions / theorems (notes) are generalised with the 'fixes' being<br>\nschematic variables and the 'assumes' being explicit preconditions. When entering a target context<br>\nthe (term and type) variables get instantiated and the preconditions become hypothetical assumptions.</p>\n<p>This process becomes so costly in our application because of (4) and (5) and is especially unsatisfying<br>\nfor the user because of (3): From a user perspective nothing has to be instantiated.<br>\nIt turns out, that by using attributes (5) the optimisation of \"lazy notes\" is unfortunately <br>\nineffective (in contrast a theorem with no attributes is represented as a lazy value and hence <br>\nonly instantiated when it is actually used, this speeds up entering a locale or composing locales).</p>\n<p>I guess there is a huge design space to improve the situation. Here are some of my thoughts:</p>\n<p>I. Keep the terms small<br>\na) Manual workaround: Instead of a local definition we could manually make a global definition of the<br>\n   large rhs, and then only make a local definition having the (folded) global one as rhs. <br>\n   This is more or less the first half of what a local definition does anyway.<br>\nb) Infrastructure: have an option to the local definition that only introduces the abbreviation <br>\n   but does not note the instantiated equation in the target context.<br>\nII. Improve the use case for the \"canonical\" locale instances (points 2 + 3) by some <br>\n   sort of caching or pre-evaluated instances.<br>\nIII. Extending the lazy notes idea to \"lazy attributes\", giving user level control to what is already relevant<br>\n    for the declaration of new locales and what is only relevant for doing proofs later on.<br>\nIV. Make instantiation cheaper, e.g. by changing the low-level representation of cterms (like <br>\n   environment + term-skeleton instead of a fully instantiated term; ML antiquotations to<br>\n   match on cterms and construct cterms might bring the convenience of programming with <br>\n   terms to cterms, without having to fully convert between terms and cterms all the time).</p>\n<p>Manually keeping terms small (I.a) or avoiding attributes, feels like breaking the<br>\nnice and convenient abstraction and falling back to bare-metal error prone tool development. <br>\nI hope that some (maybe combination) of the ideas above or some other ideas materialise as a rescue.</p>\n<p>Find attached three benchmark theories illustrating some aspects:</p>\n<p>Benchmark_poly.thy: large terms within locale using polymorphic constants<br>\nBenchmark_mono.thy: monomorphic variant<br>\nBenchmark_global.thy: Workaround (I.a), keeping terms in definitions and theorems (notes) small.</p>\n<p>[1] Clemens Ballarin. Locales: a module system for mathematical theories. Journal of Automated Reasoning, 52(2):123–153, 2014.<br>\n[2] Florian Haftmann and Makarius Wenzel. Local theory specifications in Isabelle/Isar. In Stefano Berardi, <br>\n   Ferruccio Damiani, and Ugo de Liguoro, editors, Types for Proofs and Programs, TYPES 2008, <br>\n   volume 5497 of Lecture Notes in Computer Science. Springer, 2009.</p>\n<p>Regards,<br>\nNorbert</p>\n<p>--</p>\n<p>Norbert Schirmer (<a href=\"mailto:nschirmer@apple.com\">nschirmer@apple.com</a> &lt;mailto:<a href=\"mailto:nschirmer@apple.com\">nschirmer@apple.com</a>&gt;)<br>\n SEG Formal Verification<br>\nRegards,<br>\nNorbert</p>\n<p>--</p>\n<p>Norbert Schirmer (<a href=\"mailto:nschirmer@apple.com\">nschirmer@apple.com</a>)<br>\n SEG Formal Verification<br>\n<a href=\"/user_uploads/14278/63Lmv2aGYpfpu4i7lZzTa-KM/Benchmark_global.thy\">Benchmark_global.thy</a><br>\n<a href=\"/user_uploads/14278/3ZV2-SJ89wsO6hl2v-Eobb2s/Benchmark_mono.thy\">Benchmark_mono.thy</a><br>\n<a href=\"/user_uploads/14278/xbK8oxxQbKWqHzy9hoHI0a5f/Benchmark_poly.thy\">Benchmark_poly.thy</a></p>",
        "id": 246943482,
        "sender_full_name": "Email Gateway",
        "timestamp": 1627020757
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 23/07/2021 08:11, Norbert Schirmer via Cl-isabelle-users wrote:</p>\n<blockquote>\n<p>In our applications we have a wide spread use of locales, both on the Isar<br>\ntoplevel<br>\nas well as in Isabelle/ML were locales are auto generated and certain<br>\ndefinitions are made and <br>\ntheorems are proved within these locales.</p>\n<p>Recently we hit the tipping point, where actually more cpu-time is used for the <br>\ndeclaration of locales compared to the actual proof load that is performed<br>\nwithin the locales.</p>\n</blockquote>\n<p>In ancient times, we did have the understanding that proofs require most of<br>\nthe time, and the surrounding setup is neglectable. In recent years, our<br>\ntheory infrastructure has become so rich, that it often requires more time to<br>\nbuild than the proofs.</p>\n<p>So we need to take more care, to trim that down again.</p>\n<blockquote>\n<p>I did some analysis to get a better understanding what actually happens and<br>\nwant to initiate a discussion on how this situation might be improved in the<br>\nfuture.</p>\n<p>First some high level description of our use of locales which triggered the<br>\ntipping point:</p>\n<ol>\n<li>Locales are used to structure and modularize our work. </li>\n<li>We stay abstract: Our clear focus is on declaring new<br>\n  locales on the basis of existing locales rather then interpreting locales.</li>\n<li>Most of the time an abstract entity within a locale aka fixes x::'a stays<br>\nthe same in<br>\n  the complete locale hierarchy. It is neither renamed nor is it's type<br>\nchanged when being imported to<br>\n  another locale. It might be shared among multiple locales.</li>\n</ol>\n</blockquote>\n<p>Points 1 + 2 + 3 seem to suggest that most of the locale interpretation<br>\nadd-ons from the past 10-15 years are not required. They are nonetheless<br>\ncentral to how locales work today. \"Shortcuts\" might be possible, but it is<br>\ndifficult to say what really can or should be done: We need to resist from<br>\n\"improvements\" that move towards a terminal state where nobody understands how<br>\nthings work.</p>\n<blockquote>\n<ol start=\"4\">\n<li>Within a locale we make definitions and proof theorems which are noted. <br>\n  A typical right hand side (rhs) of a definition can be a sizeable term<br>\ncontaining polymorphic constants. <br>\n  For example think of a sequence of about 100 monadic binds in a state-monad.</li>\n<li>We use attributes on definitions as well as theorems to maintain our data<br>\nfor proof automation. </li>\n</ol>\n</blockquote>\n<p>Points 4 + 5 are more particular to your application, and look like the true<br>\nfocus of performance improvements.</p>\n<blockquote>\n<p>I come to the conclusion that the actual <br>\nhot-spot is the omnipresent instantiation of<br>\nlocales. This happens in the roundup of locale expressions, both when defining<br>\nnew locales as well as <br>\nwhen entering the context of a locale. Profiling highlights low-level<br>\nfunctions like Term.fold_atyps,<br>\nTerm_Subst.generalizeT_same, Term_Subst.inst_same...</p>\n</blockquote>\n<p>Instantiations --- especially of types within terms --- often show up<br>\nprominently in profiles. Over the years, we have made a lot of performance<br>\ntuning in this respect. My most recent attempt is here<br>\n<a href=\"https://isabelle-dev.sketis.net/phame/post/view/44/scalable_operations_for_thm.instantiate_and_thm.generalize\">https://isabelle-dev.sketis.net/phame/post/view/44/scalable_operations_for_thm.instantiate_and_thm.generalize</a><br>\nalthough it had hardly any measurable impact on your examples or other<br>\napplications. In the worst case, it can even become a bit slower, due to more<br>\nheap garbabe produced by the underlying 2-3 trees, in contrast to plain lists.</p>\n<p>In recent years, I have come to the conclusion that we could remove excessive<br>\nredundancy of types within terms, via the \"typargs\" representation of Consts.<br>\nE.g. instead of overloaded Const \"plus\" with type instance \"T =&gt; T =&gt; T\", it<br>\nwould be only \"plus\" applied to a single typearg T. We have already support<br>\nfor this view within Consts.T of the theory (or Proof.Context).</p>\n<p>What remains is a small exercise in cleaning up Isabelle/ML tools after &gt; 35<br>\nyears of Gordon-style Const term constructors, with their explicit type<br>\ninstances. The following ML antiquotations may help to get to that point<br>\nwithin a few years:<br>\n<a href=\"https://isabelle-dev.sketis.net/phame/post/view/46/ml_antiquotations_for_type_constructors_and_term_constants\">https://isabelle-dev.sketis.net/phame/post/view/46/ml_antiquotations_for_type_constructors_and_term_constants</a></p>\n<blockquote>\n<p>This process becomes so costly in our application because of (4) and (5) and<br>\nis especially unsatisfying<br>\nfor the user because of (3): From a user perspective nothing has to be<br>\ninstantiated.<br>\nIt turns out, that by using attributes (5) the optimisation of \"lazy notes\" is<br>\nunfortunately <br>\nineffective (in contrast a theorem with no attributes is represented as a lazy<br>\nvalue and hence <br>\nonly instantiated when it is actually used, this speeds up entering a locale<br>\nor composing locales).</p>\n</blockquote>\n<p>Note that attributes are just a special case of Local_Theory.declaration in<br>\nIsabelle/ML or 'declaration' in Isabelle/Isar: after applying a morphism, you<br>\nadd your own data to the context; your tools pick up the data later on.</p>\n<p>An attribute always has a visible \"thm\" parameter that is always transformed<br>\nby the morphism on the spot.</p>\n<p>In contrast, a declaration can control precisely what happens when. Here<br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/ex/Def.thy;f79dfc7656ae\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/ex/Def.thy;f79dfc7656ae</a><br>\nis an example where primitive definitions are stored by there LHS-term, while<br>\nthe thm LHS=RHS is only materialized via the morphism when required in a<br>\ncorresponding simproc.</p>\n<p>This demonstrates, how much flexibility the regular local theory user-space<br>\noffers, but it requires some understanding of the big picture.</p>\n<blockquote>\n<p>I guess there is a huge design space to improve the situation. Here are some<br>\nof my thoughts:</p>\n<p>I. Keep the terms small<br>\na) Manual workaround: Instead of a local definition we could manually make a<br>\nglobal definition of the<br>\n   large rhs, and then only make a local definition having the (folded) global<br>\none as rhs. <br>\n   This is more or less the first half of what a local definition does anyway.<br>\nb) Infrastructure: have an option to the local definition that only introduces<br>\nthe abbreviation <br>\n   but does not note the instantiated equation in the target context.<br>\nII. Improve the use case for the \"canonical\" locale instances (points 2 + 3)<br>\nby some <br>\n   sort of caching or pre-evaluated instances.<br>\nIII. Extending the lazy notes idea to \"lazy attributes\", giving user level<br>\ncontrol to what is already relevant<br>\n    for the declaration of new locales and what is only relevant for doing<br>\nproofs later on.<br>\nIV. Make instantiation cheaper, e.g. by changing the low-level representation<br>\nof cterms (like <br>\n   environment + term-skeleton instead of a fully instantiated term; ML<br>\nantiquotations to<br>\n   match on cterms and construct cterms might bring the convenience of<br>\nprogramming with <br>\n   terms to cterms, without having to fully convert between terms and cterms<br>\nall the time).</p>\n</blockquote>\n<p>My explanations and experiments should already correlate with most of these<br>\nideas, while avoiding huge upheavals in the underlying infrastructure.</p>\n<p>Your point IV sounds very ambitious: cterms could certainly benefit from many<br>\nreforms, like open bounds as frees (to simplify e.g. Thm.dest_abs). But most<br>\nof this will introduce a lot of extra complexity, and might never materialize.</p>\n<p>Right now, I hope that Const-typargs within terms would be sufficient for all<br>\nkinds of conceptual simplifications and performance improvements everywhere. I<br>\nleave it as an exercise for Isabelle/ML tool builders, to update their stuff<br>\nafter the next release, to use Type/Const antiquotations everywhere.</p>\n<blockquote>\n<p>Find attached three benchmark theories illustrating some aspects:</p>\n<p>Benchmark_poly.thy: large terms within locale using polymorphic constants<br>\nBenchmark_mono.thy: monomorphic variant<br>\nBenchmark_global.thy: Workaround (I.a), keeping terms in definitions and<br>\ntheorems (notes) small.</p>\n</blockquote>\n<p>I have experimented with these benchmarks a bit: often they did not even work<br>\nwith the regular 16 GB heap model of x86_64_32.</p>\n<p>Maybe you can rephrase most of this directly with the 'def' command from<br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/ex/Def.thy;f79dfc7656ae\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/ex/Def.thy;f79dfc7656ae</a><br>\n(it should also work with current Isabelle2021).</p>\n<p>Makarius</p>",
        "id": 254352344,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632310512
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nSee also the adjacent examples:<br>\n<a href=\"https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/ex/Def_Examples.thy;f79dfc7656ae\">https://isabelle-dev.sketis.net/source/isabelle/browse/default/src/Pure/ex/Def_Examples.thy;f79dfc7656ae</a></p>\n<p>Makarius</p>",
        "id": 254352913,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632310839
    },
    {
        "content": "<p>From: Norbert Schirmer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nThanks a lot for the explanations and examples and work into the direction to improve performance in the mid-term.</p>\n<p>I guess with some combination of hand-crafted declarations (instead of attributes) and implementing the ‘def’ idea above I can improve the performance for our applications.<br>\nThe tradeoff is between simplicity / readability vs. performance. Especially the neat thing about attributes (compared to declarations) is that you can already provide them to almost all relevant functions like definitions, derived specifications (like function package) and ’notes’. Note that we not only use plain definitions with large terms but also derived concepts like (partial) functions which besides the defining equation also result in a bunch of theorems (like induction) with large terms.</p>\n<p>My main working-horse is actually the ’named_theorems’ attribute which is only relevant in the body of the locale when doing proofs and not in the declaration of new locales. So I would reimplement this functionality with a declaration instead of the existing attribute, explicitly postponing the application of the morphism. Thats why I mentioned the idea of “lazy attributes” to implement an attribute like “lazy_named_theorems” that can be provided to all the already existing functions in Isabelle/ML.</p>\n<p>Regards,<br>\nNorbert</p>",
        "id": 255014259,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632732729
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nJust a general comment: locales have been around for a long time but we are still figuring out how to use them effectively in large developments. Papers on the locale methodology itself ought to be publishable, certainly at the Isabelle workshop (which we hope to hold next summer at flOC 2022).</p>\n<p>Larry</p>",
        "id": 255020986,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632736229
    }
]