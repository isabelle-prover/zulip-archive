[
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi all,</p>\n<p>(How) Is it possible to persist proof data in the surrounding theory?</p>\n<p>I'm logging (in ML) some dynamic data (mostly statistics) about custom <br>\ntactics, storing them in the <code>Proof_Context</code> via the <code>Proof_Data</code> <br>\nmechanism. This allows me to analyze a proof while still within its <br>\nproof block, which has been very useful. I'd now like to persist this <br>\ninformation in the surrounding theory to allow for multiple proofs (and <br>\neven theories) to be analyzed at once.</p>\n<p>The stored data type supports merging, but naively implementing it as <br>\n<code>Theory_Data</code> modified from within the proof does not work (or I'm doing <br>\nit wrong).</p>\n<p>Are there ways to merge back proof-data into the surrounding theory?</p>\n<p>Thanks!<br>\nHanno</p>",
        "id": 355029943,
        "sender_full_name": "Email Gateway",
        "timestamp": 1683005169
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nThis will be a little tricky.</p>\n<p>The design is set up so that no data escapes from a proof except for the final theorem. Proofs can then be run in parallel, since all their inputs are known without waiting for other proofs to complete (the theorem is handled specially). If you want to move stats out of a proof into the main context, you'll have to break out of this design somehow, e.g. by using stateful ML references to move data from place to place.</p>\n<p>The timing panel in jEdit gathers some stats. I guess that it works by having each proof step produce output on the PIDE protocol and having the Scala side gather the statistics. You could presumably implement something similar, but extending the inter-language protocol has always seemed far more daunting than adding some ML code. Maybe others have a better idea?</p>\n<p>Good luck,<br>\n    Thomas.</p>",
        "id": 355130276,
        "sender_full_name": "Email Gateway",
        "timestamp": 1683029491
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nGood answer --- as first approximation of a difficult problem.</p>\n<p>Conceptually, proofs are indeed formally isolated and strictly \"irrelevant\".</p>\n<p>You can't \"leak\" information from proofs, subproofs, proof blocks, without <br>\nviolating structural principles of Isabelle/Isar. In retrospect, I am rather <br>\nglad that we have such great principles, and not just an adhoc mess of <br>\nstateful commands as in ancient times.</p>\n<p>Note that within a proof context, you cannot even store anything, that is <br>\nmeant to persist outside the current local block.</p>\n<p>Instead, in order to oversee and analyze what is happening in Isabelle <br>\ntheories and proofs, the proper approach is to use Isabelle/Scala.</p>\n<p>The most basic mechanism to expose information from Isabelle/ML into the build <br>\ndatabase of Isabelle/Scala is via the ML function Export.export (and some <br>\nvariants of it).</p>\n<p>As usual, you will find examples via hypersearch over existing sources. This <br>\nreveals, e.g. src/HOL/Tools/Mirabelle/mirabelle.ML and the corresponding <br>\nmirabelle.scala.</p>\n<p>Here the approach is more advanced than strictly necessary, using a <br>\nuser-defined PIDE protocol handler. Alternatively, it is also possible to <br>\nretrieve theory exports from the session build database, like reading a zip <br>\nfile. E.g. see \"isabelle export\" and its Isabelle/Scala implementation in <br>\nsrc/Pure/Thy/export.scala</p>\n<p>Or you emit regular messages of a special form, e.g. \"writeln\" or \"tracing\" <br>\nand then use an approach like \"isabelle log\" to retrieve the collected <br>\ninformation in Isabelle/Scala.</p>\n<p>Exports and messages leave the ML world and cannot be retrieved from the <br>\nrunning ML session. If you need incremental access to your data within ML, the <br>\nIsabelle/Scala approach will not work.</p>\n<p>Instead, you can try to manage your own global state in Isabelle/ML, using <br>\nSynchronized.var or even weak references (together with locks). This requires <br>\nsubstantial understanding of threads and memory management in Isabelle/ML and <br>\nthe Poly/ML runtime system. (Not necessarily at the start of such a project, <br>\nbut as a consequence at the successful end of it.)</p>\n<p>Makarius</p>",
        "id": 355202721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1683044538
    },
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nThank you for the replies!</p>\n<p>If possible, I'd like to go into more detail on how this can be achieved <br>\nin ML, at the cost of breaking structural principles.</p>\n<p>The problem with updating state through references is that I would like <br>\nto be able to roll back state changes when looking at the state of a <br>\ntheory prior to a proof vs. after the proof. Within the proof itself, I <br>\nam currently achieving this by introducing a method-wrapper which <br>\ntemporarily enables proof-local state updates through references, <br>\nperformed by tactics called within the scope of this wrapper (whether <br>\nsuccessful or not). When the wrapper concludes, the state behind the <br>\nreference is then persisted into the proof context. I'd like to play a <br>\nsimilar 'trick' to persist the so-gathered proof local data into the <br>\nsurrounding theory when the proof concludes, but it's not clear where <br>\nexactly that should happen (without writing an adjusted 'lemma' <br>\ntop-level command, at least).</p>\n<p>Any further pointers would be most welcome,<br>\nThank you,<br>\nHanno</p>",
        "id": 355586873,
        "sender_full_name": "Email Gateway",
        "timestamp": 1683141011
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nBreaking structural principles will merely lead to a broken setup --- it is <br>\nnot going to work properly.</p>\n<p>It is certainly possible to go beyond the purely functional structures of <br>\nIsabelle/Isar, but it requires a lot of extra considerations about the <br>\nworkings of Isabelle/ML and Poly/ML.</p>\n<p>Makarius</p>",
        "id": 355596126,
        "sender_full_name": "Email Gateway",
        "timestamp": 1683143869
    },
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nThank you Makarius, I understand that it's easy to shoot myself in the <br>\nfoot here.<br>\nYet, in the proof-local situation, things have so far worked well for me <br>\ndespite<br>\nsomewhat tricky/hacky handling of references, leading to useful insights <br>\nbeing<br>\ngenerated. So if, following up on</p>",
        "id": 355598624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1683144635
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/05/2023 22:10, <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a> wrote:</p>\n<blockquote>\n<p>Thank you Makarius, I understand that it's easy to shoot myself in the foot here.<br>\nYet, in the proof-local situation, things have so far worked well for me despite<br>\nsomewhat tricky/hacky handling of references, leading to useful insights being<br>\ngenerated. So if, following up on</p>\n</blockquote>\n<p>As long as you merely shoot yourself privately, nobody will notice.</p>\n<p>Hopefully such experiments won't come back to the general public, e.g. <br>\nIsabelle/AFP.</p>\n<blockquote>\n<blockquote>\n<p>It is certainly possible to go beyond the purely functional structures<br>\nof Isabelle/Isar, but it requires a lot of extra considerations about<br>\nthe workings of Isabelle/ML and Poly/ML.</p>\n</blockquote>\n<p>you had some further pointers on how a ref-based, reversible migration of<br>\ndata from the proof context into the theory could work, I'd be grateful.<br>\nOtherwise, I'll likely stick with what I have.</p>\n</blockquote>\n<p>I can't say much on the spot, because I don't know anything about your <br>\napplication. The usual Question 0 is: Do you really need what you have in <br>\nmind? Question 1: What do you actually have in mind?</p>\n<p>Often there is a mismatch of what is possible vs. required vs. actually done.</p>\n<p>As a starting point to get acquainted with parallel ML, you can try to work <br>\nwith global Synchronized.var maybe together with weak references (to <br>\nparticipate in ML garbage collection properly). The latter is documented in <br>\nthe source: You get to the source by C-hover-click in Isabelle/PIDE on this text:</p>\n<p>ML ‹open Weak›</p>\n<p>Makarius</p>",
        "id": 355602150,
        "sender_full_name": "Email Gateway",
        "timestamp": 1683145914
    }
]