[
    {
        "content": "<p>From: Oleksandr Gavenko &lt;<a href=\"mailto:gavenkoa@gmail.com\">gavenkoa@gmail.com</a>&gt;<br>\nI'm translating Prover9 proof into Isabelle and I find it difficult to<br>\nwork with gigantic nesting expressions.</p>\n<p>To troubleshoot I'd like to have debugging tools:</p>\n<ul>\n<li>printing of substitution in expression</li>\n<li>finding MGU for a given expression and existing theorem</li>\n</ul>\n<p>=======</p>\n<p>Substitution printing is partially archivable via syntax:</p>\n<p>thm THM[where a=...]<br>\n  thm THM[of _ a _ \"(b+c)\"]</p>\n<p>But I'd like to write just something simple as:</p>\n<p>thm \"a~e=e~a\"[of \"x+1\" \"z-1\"]</p>\n<p>to see the result of substitution.</p>\n<p>I can define a temporary failed thm as a workaround:</p>\n<p>lemma x: \"(((A ~ B) ~ C ~ B) ~ C ~ A)\"<br>\n  sorry<br>\n  thm x[of \"A~A\" _ \"(B~A)~A\"]</p>\n<p>I tried something less invasive:</p>\n<p>notepad begin<br>\n  have x: \"(((A ~ B) ~ C ~ B) ~ C ~ A)\"<br>\n  sorry<br>\n  thm x<br>\nend</p>\n<p>but variables of the fact are not \"placeholders\", so substitution<br>\nresults in an error:</p>\n<p>thm x[of a]<br>\n  More instantiations than variables in theorem</p>\n<p>===============</p>\n<p>I defined some syntax in a theory and want Isabelle to find MGU for an<br>\nexpression to match against the existing theorem.</p>\n<p>For:</p>\n<p>op(520, infix_right, \"~\").<br>\nformulas(assumptions).<br>\n  % Rule Detachment.<br>\n  prop(P) &amp; prop(P~Q) -&gt; prop(Q)  #label(detachment).</p>\n<p>% Axioms<br>\n  prop((X~Y) ~ (Y~Z) ~ (X~Z))  #label(tran).<br>\n  prop((X~Y) ~ (Y~X))          #label(sym).<br>\nend_of_list.</p>\n<p>formulas(goals).<br>\n  prop(X~(X~Y)~Y).<br>\nend_of_list.</p>\n<p>Prover9 tells me:</p>\n<p>1 prop(A) &amp; prop(A ~ B) -&gt; prop(B) # label(detachment) #<br>\nlabel(non_clause).  [assumption].<br>\n2 prop(A ~ (A ~ B) ~ B) # label(non_clause) # label(goal).  [goal].<br>\n3 -prop(A) | -prop(A ~ B) | prop(B) # label(detachment).  [clausify(1)].<br>\n4 prop((A ~ B) ~ (B ~ C) ~ A ~ C) # label(tran).  [assumption].<br>\n5 prop((A ~ B) ~ B ~ A) # label(sym).  [assumption].<br>\n6 -prop(c1 ~ (c1 ~ c2) ~ c2).  [deny(2)].<br>\n8 prop(((A ~ B) ~ C ~ B) ~ C ~ A).  [hyper(3,a,4,a,b,5,a)].<br>\n15 prop(A ~ (A ~ B) ~ B).  [hyper(3,a,8,a,b,8,a)].<br>\n16 $F.  [resolve(15,a,6,a)].</p>\n<p>and I have a hard time understanding how hyperresolution happened at<br>\nline 15 (rule 3 applied on some instances of 8 2 times).</p>\n<p>hyperresolution is like Modus Ponens with <em>unification</em> and I'd like<br>\nto debug unifications of some expressions against some facts.</p>\n<p>I have no problems dealing with inline ML code, but Isabelle Cookbook<br>\nis gibberish for my level of knowledge of Isabelle - I cant find<br>\nfunctions I can call for printing substitution &amp; unification.</p>",
        "id": 502846282,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740911815
    },
    {
        "content": "<p>From: Lukas Bartl &lt;<a href=\"mailto:lukas.bartl@uni-a.de\">lukas.bartl@uni-a.de</a>&gt;<br>\nHi Oleksandr,</p>\n<blockquote>\n<p>but variables of the fact are not \"placeholders\"</p>\n</blockquote>\n<p>If you add \"for A B C\" after the proposition, they become placeholders <br>\n(called \"schematic variables\" in Isabelle).</p>\n<p>An easy way to do substitution printing might be to use \"let\":</p>\n<p>notepad<br>\nbegin<br>\n     let ?a = \"x+1\"<br>\n     let ?e = \"z-1\"<br>\n     term \"?a ~ ?e\"<br>\nend</p>\n<p>It can also do higher-order matching (but not full unification):</p>\n<p>notepad<br>\nbegin<br>\n     let \"(+) ?a ?b\" = \"0 + 1\"<br>\n     term ?a<br>\n     term ?b<br>\nend</p>\n<p>If this is not enough, the Isabelle Cookbook is indeed the place to <br>\nstart. Both substitution and unification are explained in Chapter 3 <br>\n(Isabelle Essentials).</p>\n<p>Best,<br>\nLukas</p>\n<p>Am 27.02.25 um 23:57 schrieb Oleksandr Gavenko:</p>\n<blockquote>\n<p>I'm translating Prover9 proof into Isabelle and I find it difficult to<br>\nwork with gigantic nesting expressions.</p>\n<p>To troubleshoot I'd like to have debugging tools:</p>\n<ul>\n<li>printing of substitution in expression</li>\n<li>finding MGU for a given expression and existing theorem</li>\n</ul>\n<p>=======</p>\n<p>Substitution printing is partially archivable via syntax:</p>\n<p>thm THM[where a=...]<br>\n   thm THM[of _ a _ \"(b+c)\"]</p>\n<p>But I'd like to write just something simple as:</p>\n<p>thm \"a~e=e~a\"[of \"x+1\" \"z-1\"]</p>\n<p>to see the result of substitution.</p>\n<p>I can define a temporary failed thm as a workaround:</p>\n<p>lemma x: \"(((A ~ B) ~ C ~ B) ~ C ~ A)\"<br>\n   sorry<br>\n   thm x[of \"A~A\" _ \"(B~A)~A\"]</p>\n<p>I tried something less invasive:</p>\n<p>notepad begin<br>\n   have x: \"(((A ~ B) ~ C ~ B) ~ C ~ A)\"<br>\n   sorry<br>\n   thm x<br>\nend</p>\n<p>but variables of the fact are not \"placeholders\", so substitution<br>\nresults in an error:</p>\n<p>thm x[of a]<br>\n   More instantiations than variables in theorem</p>\n<p>===============</p>\n<p>I defined some syntax in a theory and want Isabelle to find MGU for an<br>\nexpression to match against the existing theorem.</p>\n<p>For:</p>\n<p>op(520, infix_right, \"~\").<br>\nformulas(assumptions).<br>\n   % Rule Detachment.<br>\n   prop(P) &amp; prop(P~Q) -&gt; prop(Q)  #label(detachment).</p>\n<p>% Axioms<br>\n   prop((X~Y) ~ (Y~Z) ~ (X~Z))  #label(tran).<br>\n   prop((X~Y) ~ (Y~X))          #label(sym).<br>\nend_of_list.</p>\n<p>formulas(goals).<br>\n   prop(X~(X~Y)~Y).<br>\nend_of_list.</p>\n<p>Prover9 tells me:</p>\n<p>1 prop(A) &amp; prop(A ~ B) -&gt; prop(B) # label(detachment) #<br>\nlabel(non_clause).  [assumption].<br>\n2 prop(A ~ (A ~ B) ~ B) # label(non_clause) # label(goal).  [goal].<br>\n3 -prop(A) | -prop(A ~ B) | prop(B) # label(detachment).  [clausify(1)].<br>\n4 prop((A ~ B) ~ (B ~ C) ~ A ~ C) # label(tran).  [assumption].<br>\n5 prop((A ~ B) ~ B ~ A) # label(sym).  [assumption].<br>\n6 -prop(c1 ~ (c1 ~ c2) ~ c2).  [deny(2)].<br>\n8 prop(((A ~ B) ~ C ~ B) ~ C ~ A).  [hyper(3,a,4,a,b,5,a)].<br>\n15 prop(A ~ (A ~ B) ~ B).  [hyper(3,a,8,a,b,8,a)].<br>\n16 $F.  [resolve(15,a,6,a)].</p>\n<p>and I have a hard time understanding how hyperresolution happened at<br>\nline 15 (rule 3 applied on some instances of 8 2 times).</p>\n<p>hyperresolution is like Modus Ponens with <em>unification</em> and I'd like<br>\nto debug unifications of some expressions against some facts.</p>\n<p>I have no problems dealing with inline ML code, but Isabelle Cookbook<br>\nis gibberish for my level of knowledge of Isabelle - I cant find<br>\nfunctions I can call for printing substitution &amp; unification.</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/swGJMTP_goeb_GhaVJf7wNce/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 505367865,
        "sender_full_name": "Email Gateway",
        "timestamp": 1741858495
    }
]