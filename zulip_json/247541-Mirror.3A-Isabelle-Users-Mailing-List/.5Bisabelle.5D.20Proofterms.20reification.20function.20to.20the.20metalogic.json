[
    {
        "content": "<p>From: Nicolas Méric &lt;<a href=\"mailto:nicolas.meric@lri.fr\">nicolas.meric@lri.fr</a>&gt;<br>\nDear Isabelle's users,</p>\n<p>I try to use the Isabelle's Metalogic by Tobias Nipkow and Simon Roßkopf<br>\n(<a href=\"https://www.isa-afp.org/entries/Metalogic_ProofChecker.html\">https://www.isa-afp.org/entries/Metalogic_ProofChecker.html</a>)<br>\nwith Isabelle/DOF (<a href=\"https://zenodo.org/record/6810799\">https://zenodo.org/record/6810799</a>).</p>\n<p>I want to write a reification function of terms and proofterms in ML to<br>\nthis metalogic, to offer a kind of introspection over proofterms or<br>\nthe possibility to add metadata to proofterms to maybe make<br>\ntheir rewriting to other ITPs easier.</p>\n<p>But I do not understand some part of the definition of the proof<br>\ndatatype in proofterm.ML, the constructor PAxm for example,<br>\nand the implementation of PAxm in the metalogic.</p>\n<p>In Pure we have (in proofterm.ML):</p>\n<p>datatype proof =<br>\n      MinProof<br>\n    | PBound of int<br>\n    | Abst of string * typ option * proof<br>\n    | AbsP of string * term option * proof<br>\n    | % of proof * term option<br>\n    | %% of proof * proof<br>\n    | Hyp of term<br>\n    | PAxm of string * term * typ list option<br>\n    | PClass of typ * class<br>\n    | Oracle of string * term * typ list option<br>\n    | PThm of thm_header * thm_body<br>\n   and proof_body = PBody of<br>\n     {oracles: ((string * Position.T) * term option) Ord_List.T,<br>\n      thms: (serial * thm_node) Ord_List.T,<br>\n      proof: proof}</p>\n<p>Of what use is the typ list option for PAxm?</p>\n<p>In the metalogic, we have a similar contructor (in ProofTerm.thy):</p>\n<p>type_synonym tyinst = \"(variable × sort) × typ\"</p>\n<p>datatype proofterm = PAxm \"term\" \"tyinst list\"<br>\n   | PBound nat<br>\n   | Abst \"typ\" proofterm<br>\n   | AbsP \"term\" proofterm<br>\n   | Appt proofterm \"term\"<br>\n   | AppP proofterm proofterm<br>\n   | OfClass \"typ\" \"class\"<br>\n   | Hyp \"term\"</p>\n<p>variable in tyinst is defined in Core.thy:</p>\n<p>datatype variable = Free name | Var indexname</p>\n<p>So, for a proofterm in Pure,<br>\nit seems to me that the typ list option of the PAxm constructor<br>\nin ML should be translated to the tyinst list of the PAxm constructor<br>\nin the metalogic.<br>\nIs this the idea?<br>\nThen, for PAxm in the metalogic, are the variable and the sort in tyinst<br>\nan extract of the typ also in tyinst?<br>\nIf no, how are they linked?</p>\n<p>Best regards.</p>\n<p>Nicolas Méric</p>",
        "id": 307766222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1667491934
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHello,</p>\n<p>I am not aware of documentation on this, but during my own work in <br>\ntranslating proofterms, I found that the following seems consistent:</p>\n<p>The typ-list-option argument is the instantiation for the TVar's <br>\noccurring in the axiom's proposition (the term argument). The order of <br>\nthose arguments is the reverse order of what Term.add_tvars returns.</p>\n<p>So you should get the tyinst argument with roughly the following code:</p>\n<p>PAxm (name, prop, typ_args) =&gt; zip (rev (add_tvars prop []), typ_args)</p>\n<p>(up to a conversion to the type \"variable\" in the Metalogic, I don't <br>\nknow what it is exactly since I am not familiar with the Metalogic.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 307809563,
        "sender_full_name": "Email Gateway",
        "timestamp": 1667499525
    },
    {
        "content": "<p>From: Nicolas Méric &lt;<a href=\"mailto:nicolas.meric@lri.fr\">nicolas.meric@lri.fr</a>&gt;<br>\nHi Dominique,</p>\n<p>thanks for the info and the tip. It helped a lot.</p>\n<p>I have a related question.</p>\n<p>During my few tests, I did not find any schematic variables (Tvars) with <br>\na sort other than Nil in the PAxms' proposition (the term argument) or <br>\nin the PThms' prop (inside the thm_header argument).</p>\n<p>A basic example with Pure.symmetric:</p>\n<p>ML‹<br>\nval thm = @{thm \"Pure.symmetric\"}<br>\nval PAxm (name, term, typ_list_option) % t % u = Thm.proof_of thm<br>\nval tvars = rev (Term.add_tvars term [])<br>\n›</p>\n<p>Do you an idea of an axiom or theorem whose sort of Tvars of the <br>\nproposition will not be a Nil list, i.e, will have some classes?</p>\n<p>Best regards.</p>\n<p>Nicolas.</p>",
        "id": 308812497,
        "sender_full_name": "Email Gateway",
        "timestamp": 1668007997
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>again, what I'm saying now is purely based on my experiments:</p>\n<p>There are two ways to get proofterm. One is to get a theorem from the <br>\ntheory (e.g., Proof_Context.get_thm) and then get the proofterm from <br>\nthat (e.g., Thm.proof_of). I haven't checked right now, but I believe if <br>\nyou apply this to a theorem with sorts, you get sorts in the prop of <br>\nthat theorem.</p>\n<p>The second way is to take the proofterm gotten like this, and to descend <br>\nto the first PThm. This is always a very shallow proof, and you get a <br>\nPThm with the same name (in the header) as the name you gave to <br>\nProof_Context.get_thm. But that PThm contains a prop that has been <br>\nprocessed. All sorts have been removed and instead explicit <br>\n\"OFCLASS(...)\" assumptions have been added. This is logically <br>\nequivalent. The proof of the processed theorem has no sorts whatsoever <br>\n(all the typeclass-logic is encoded using explicit assumptions in the <br>\ntheorems). The advantage of this is that, if you want to check a proof, <br>\nyou will never have to export deal with sorts.</p>\n<p>The same seems to hold for axioms, too. They also do not contain sorts.</p>\n<p>I do not know whether it is possible for exceptions to this to occur or <br>\nwhether the kernel ensures that a pthm always contains a cleaned proof <br>\nand that an axiom does not contain a sort ever.</p>\n<p>The approach that I am taking is to ignore the unprocessed theorems <br>\naltogether and to implement proofterm translation without typeclasses.</p>\n<p>By the way: I did a quick check: all the axioms and theorems recursively <br>\nencountered when checking the proof of Nat.add_0_right do not contain <br>\nsorts.  (Assuming my check-code does not have a bug, of course.)</p>\n<p>Another note: constant types (gotten via Sign.const_typargs) sometimes <br>\nseem to have sorts (and not only HOL.type). Since the corresponding <br>\naxioms do not have sorts, these sorts seem to be more informative than <br>\nbinding. I am ignoring them.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 308822577,
        "sender_full_name": "Email Gateway",
        "timestamp": 1668011033
    },
    {
        "content": "<p>From: Nicolas Méric &lt;<a href=\"mailto:nicolas.meric@lri.fr\">nicolas.meric@lri.fr</a>&gt;<br>\nDear Dominique,</p>\n<p>I had some time to work on that again.</p>\n<p>Thanks again for the explanation.</p>\n<p>I have another question and maybe you'll accept to share your knowledge, <br>\none more time.</p>\n<p>In the metalogic, the PAxm constructor takes a typ list and not a typ <br>\nlist option as in the Isabelle PAxm.</p>\n<p>I was wondering how to deal with that, and I found the <br>\nProof_Syntax.standard_proof_of function in proof_syntax.ML. It seems <br>\nthat this function reconstructs the proofs (using, <br>\nThm.reconstruct_proof_of) and, in the case of a PAxm, updates the typ <br>\nlist option argument, at least if the list is NONE.</p>\n<p>An example with Pure.symmetric:</p>\n<p>ML‹<br>\nval full = false<br>\nval thm = @{thm \"Pure.symmetric\"}<br>\nval proof_of = Thm.proof_of thm</p>\n<p>val standard_proof = Proof_Syntax.standard_proof_of<br>\n           {full = full, expand_name = Thm.expand_name thm} thm<br>\n›</p>\n<p>Here, proof_of will have the value:</p>\n<p>val proof_of =<br>\n    PAxm (\"Pure.symmetric\",<br>\n          Const (\"Pure.imp\", \"prop ⇒ prop ⇒ prop\") $<br>\n            (Const (\"Pure.eq\", \"?'a::{} ⇒ ?'a::{} ⇒ prop\") $<br>\n              Var ((\"x\", 0), \"?'a::{}\") $ Var ((\"y\", 0), \"?'a::{}\")) $<br>\n            (Const (\"Pure.eq\", \"?'a::{} ⇒ ?'a::{} ⇒ prop\") $<br>\n              Var ((\"y\", 0), \"?'a::{}\") $ Var ((\"x\", 0), \"?'a::{}\")),<br>\n          NONE) %<br>\n      NONE % NONE:<br>\n    proof</p>\n<p>And standard_proof will have the value:</p>\n<p>val standard_proof =<br>\n    PAxm (\"Pure.symmetric\",<br>\n          Const (\"Pure.imp\", \"prop ⇒ prop ⇒ prop\") $<br>\n            (Const (\"Pure.eq\", \"?'a::{} ⇒ ?'a::{} ⇒ prop\") $<br>\n              Var ((\"x\", 0), \"?'a::{}\") $ Var ((\"y\", 0), \"?'a::{}\")) $<br>\n            (Const (\"Pure.eq\", \"?'a::{} ⇒ ?'a::{} ⇒ prop\") $<br>\n              Var ((\"y\", 0), \"?'a::{}\") $ Var ((\"x\", 0), \"?'a::{}\")),<br>\n          SOME [\"?'a::{}\"]) %<br>\n      NONE % NONE:<br>\n    proof</p>\n<p>We can see that the typ list option has been updated with a schematic <br>\nvariable.</p>\n<p>Do you think this is a good idea to deal with the typ list option <br>\nargument of a PAxm in the same way, and then be able to reify a PAxm <br>\neven when the typ list option is NONE, as the PAxm in the metalogic does <br>\nnot take and option as argument?</p>\n<p>Maybe standardizing the proof (I don't really know what Stefan Berghofer <br>\nmeans by that) with the standard_proof_of function will also deal with <br>\nthe other option types in the proof datatype, like the typ option <br>\nargument of the Abst constructor, or the term option of the % constructor.</p>\n<p>Best regards,</p>\n<p>Nicolas</p>",
        "id": 316932611,
        "sender_full_name": "Email Gateway",
        "timestamp": 1671537232
    },
    {
        "content": "<p>From: Simon Roßkopf &lt;<a href=\"mailto:rosskops@in.tum.de\">rosskops@in.tum.de</a>&gt;<br>\nHi,</p>\n<blockquote>\n<p>In the metalogic, the PAxm constructor takes a typ list and not a typ<br>\nlist option as in the Isabelle PAxm.</p>\n</blockquote>\n<p>This is mostly because the formalization does not support compressed <br>\nproof terms (where the typ instantiation info is omitted). In general, <br>\nall the _ option types in the proofterms are for information that could <br>\nbe omitted for compression. In my experience it is enough to get the <br>\nfully reconstructed proof terms using for example <br>\nThm.reconstruct_proof_of and work with them.</p>\n<p>Regards<br>\nSimon Roßkopf</p>",
        "id": 316933813,
        "sender_full_name": "Email Gateway",
        "timestamp": 1671537676
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHello,</p>\n<p>as I understand it, the option arguments in Isabelle proof terms are <br>\nused to omit redundant information. Basically, None can be inserted <br>\nwhenever it is possible to reconstruct what should be there if we know <br>\nwhat theorem the proofterm proves (basically type-inference on the <br>\nproofterm level). While if everything is filled in, then for any <br>\nproofterm, we can find out what it proves without additional <br>\ninformation. After Thm.reconstruct_proof_of, there should be no None <br>\nleft in the proofs.</p>\n<p>I do not know what Proof_Syntax.standard_proof_of does (or what a <br>\nstandard proof is) but I would be interested to know...</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 318054615,
        "sender_full_name": "Email Gateway",
        "timestamp": 1672131028
    }
]