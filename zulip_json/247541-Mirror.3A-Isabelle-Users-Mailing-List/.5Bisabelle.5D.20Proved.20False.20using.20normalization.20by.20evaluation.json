[
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nDear list,</p>\n<p>I just proved False using the normalization method in Isabelle/HOL, see <br>\nbelow. It seems like TYPE(T) arguments are generalized(?) to TYPE(?'a) <br>\narguments when running the method (even when dropping the code equation <br>\nfor the constant to be normalized).</p>\n<p>Is this a known problem and is there anything I can do to stop the <br>\nnormalizer from tinkering with TYPE(T) arguments?</p>\n<p>Background: I used normalization by evaluation to work on a large data <br>\nstructure in an Isabelle/HOL proof for which the performance of the <br>\nsimplifier is insufficient.</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span>\n<span class=\"w\">   </span><span class=\"kp\">imports</span>\n<span class=\"w\">     </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"n\">del</span><span class=\"o\">]:</span><span class=\"w\"> </span><span class=\"s\">\"test ≡ card (UNIV :: 'a set) = 1\"</span>\n\n<span class=\"c\">(*TYPE(unit) changes to TYPE('a) even though [code del] is used for test*)</span>\n<span class=\"kt\">value</span><span class=\"w\"> </span><span class=\"o\">[</span><span class=\"n\">nbe</span><span class=\"o\">]</span><span class=\"w\"> </span><span class=\"s\">\"test TYPE(unit)\"</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"n\">oh_oh</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s\">\"test TYPE(unit) = test TYPE(bool)\"</span>\n<span class=\"w\">   </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">normalization</span>\n<span class=\"w\">   </span><span class=\"k\">done</span>\n\n<span class=\"kn\">theorem</span><span class=\"w\"> </span><span class=\"s\">\"False\"</span>\n<span class=\"k\">proof</span><span class=\"w\"> </span><span class=\"o\">-</span>\n<span class=\"w\">   </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"test TYPE(unit) = True\"</span><span class=\"w\"> </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">test_def</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"w\">   </span><span class=\"k\">moreover</span><span class=\"w\"> </span><span class=\"k\">have</span><span class=\"w\"> </span><span class=\"s\">\"test TYPE(unit) = False\"</span><span class=\"w\"> </span><span class=\"k\">unfolding</span><span class=\"w\"> </span><span class=\"n\">oh_oh</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"o\">:</span>\n<span class=\"n\">test_def</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"k\">ultimately</span><span class=\"w\"> </span><span class=\"k\">show</span><span class=\"w\"> </span><span class=\"n\">False</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n<span class=\"k\">qed</span>\n\n\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 500932137,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740071887
    },
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nOops. Here is a direct illustration that \"normalization\" is contradictory:</p>\n<p>lemma \"card (UNIV :: 'a set) = card (UNIV :: 'b set)\"<br>\n   apply normalization ..</p>\n<p>Stepan</p>\n<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>\n<blockquote>\n<p>Dear list,</p>\n<p>I just proved False using the normalization method in Isabelle/HOL, <br>\nsee below. It seems like TYPE(T) arguments are generalized(?) to <br>\nTYPE(?'a) arguments when running the method (even when dropping the <br>\ncode equation for the constant to be normalized).</p>\n<p>Is this a known problem and is there anything I can do to stop the <br>\nnormalizer from tinkering with TYPE(T) arguments?</p>\n<p>Background: I used normalization by evaluation to work on a large data <br>\nstructure in an Isabelle/HOL proof for which the performance of the <br>\nsimplifier is insufficient.</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<p>```isabelle</p>\n<p>theory Scratch<br>\n  imports<br>\n    Main<br>\nbegin</p>\n<p>definition [code del]: \"test ≡ card (UNIV :: 'a set) = 1\"</p>\n<p>(*TYPE(unit) changes to TYPE('a) even though [code del] is used for <br>\ntest*)<br>\nvalue [nbe] \"test TYPE(unit)\"</p>\n<p>lemma oh_oh: \"test TYPE(unit) = test TYPE(bool)\"<br>\n  apply normalization<br>\n  done</p>\n<p>theorem \"False\"<br>\nproof -<br>\n  have \"test TYPE(unit) = True\" unfolding test_def by simp<br>\n  moreover have \"test TYPE(unit) = False\" unfolding oh_oh by (simp <br>\nadd: test_def)<br>\n  ultimately show False by simp<br>\nqed</p>\n<p>end</p>\n<p>```</p>\n</blockquote>",
        "id": 500937079,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740073518
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nJust for the benefit of readers on this mailing list who are not <br>\nfamiliar with the NBE method: this is <em>not</em> a proof method that goes <br>\nthrough the Isabelle kernel. It is an oracle, and one with a significant <br>\ntrusted code base. Moreover, I think it is used much less than the code <br>\ngenerator oracle (the \"eval\" method), so issues like this one can remain <br>\nunnoticed for a long time.</p>\n<p>So, although I do not think it was previously known that you could prove <br>\n\"False\" with NBE, it is not very surprising either. And it does <em>not</em> <br>\nmean that Isabelle as a system is broken.</p>\n<p>Unfortunately, I don't know enough about the internals of NBE to really <br>\ncomment on this issue otherwise. I just wanted to make sure this was <br>\nstated somewhere clearly on the mailing list.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing List) <br>\nwrote:</p>\n<blockquote>\n<p>Oops. Here is a direct illustration that \"normalization\" is <br>\ncontradictory:</p>\n<p>lemma \"card (UNIV :: 'a set) = card (UNIV :: 'b set)\"<br>\n  apply normalization ..</p>\n<p>Stepan</p>\n<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>\n<blockquote>\n<p>Dear list,</p>\n<p>I just proved False using the normalization method in Isabelle/HOL, <br>\nsee below. It seems like TYPE(T) arguments are generalized(?) to <br>\nTYPE(?'a) arguments when running the method (even when dropping the <br>\ncode equation for the constant to be normalized).</p>\n<p>Is this a known problem and is there anything I can do to stop the <br>\nnormalizer from tinkering with TYPE(T) arguments?</p>\n<p>Background: I used normalization by evaluation to work on a large <br>\ndata structure in an Isabelle/HOL proof for which the performance of <br>\nthe simplifier is insufficient.</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<p>```isabelle</p>\n<p>theory Scratch<br>\n  imports<br>\n    Main<br>\nbegin</p>\n<p>definition [code del]: \"test ≡ card (UNIV :: 'a set) = 1\"</p>\n<p>(*TYPE(unit) changes to TYPE('a) even though [code del] is used for <br>\ntest*)<br>\nvalue [nbe] \"test TYPE(unit)\"</p>\n<p>lemma oh_oh: \"test TYPE(unit) = test TYPE(bool)\"<br>\n  apply normalization<br>\n  done</p>\n<p>theorem \"False\"<br>\nproof -<br>\n  have \"test TYPE(unit) = True\" unfolding test_def by simp<br>\n  moreover have \"test TYPE(unit) = False\" unfolding oh_oh by (simp <br>\nadd: test_def)<br>\n  ultimately show False by simp<br>\nqed</p>\n<p>end</p>\n<p>```</p>\n</blockquote>\n</blockquote>",
        "id": 500940049,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740074500
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI went back to the paper we wrote about NBE 15 years ago <br>\n<a href=\"https://www21.in.tum.de/~nipkow/pubs/jfp12.html\">https://www21.in.tum.de/~nipkow/pubs/jfp12.html</a>. This is what it says about types:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">In</span><span class=\"w\"> </span><span class=\"n\">most</span><span class=\"w\"> </span><span class=\"n\">cases</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">these</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">reconstructions</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">unique</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">follows</span><span class=\"w\"> </span><span class=\"k\">from</span><span class=\"w\"> </span><span class=\"n\">the</span>\n<span class=\"kp\">structure</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">normal</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">simply</span><span class=\"o\">-</span><span class=\"n\">typed</span><span class=\"w\"> </span><span class=\"n\">lambda</span><span class=\"w\"> </span><span class=\"n\">calculus.</span><span class=\"w\"> </span><span class=\"n\">However</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">the</span>\n<span class=\"n\">presence</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">polymorphic</span><span class=\"w\"> </span><span class=\"n\">constants</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">most</span><span class=\"w\"> </span><span class=\"n\">general</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">could</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">general</span>\n<span class=\"n\">than</span><span class=\"w\"> </span><span class=\"n\">intended.</span><span class=\"w\"> </span><span class=\"n\">For</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"k\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">polymorphic</span><span class=\"w\"> </span><span class=\"kp\">constant</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">“</span><span class=\"o\">(</span><span class=\"n\">’a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">’a</span><span class=\"o\">)</span>\n<span class=\"o\">=</span><span class=\"n\">&gt;</span><span class=\"w\"> </span><span class=\"n\">bool”</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">say</span><span class=\"w\"> </span><span class=\"n\">without</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">rewrite</span><span class=\"w\"> </span><span class=\"n\">rule.</span><span class=\"w\"> </span><span class=\"n\">Then</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">untyped</span><span class=\"w\"> </span><span class=\"n\">normal</span><span class=\"w\"> </span><span class=\"n\">form</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">“f</span>\n<span class=\"o\">(</span><span class=\"n\">λu</span><span class=\"o\">::</span><span class=\"n\">bool.</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"n\">”</span><span class=\"w\"> </span><span class=\"n\">would</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">“f</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">λu.</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"n\">”</span><span class=\"w\"> </span><span class=\"k\">with</span><span class=\"w\"> </span><span class=\"n\">most</span><span class=\"w\"> </span><span class=\"n\">general</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">annotations</span><span class=\"w\"> </span><span class=\"n\">“f</span>\n<span class=\"o\">(</span><span class=\"n\">λu</span><span class=\"o\">::</span><span class=\"n\">’a.</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"o\">)</span><span class=\"n\">”.</span><span class=\"w\"> </span><span class=\"n\">To</span><span class=\"w\"> </span><span class=\"n\">avoid</span><span class=\"w\"> </span><span class=\"n\">such</span><span class=\"w\"> </span><span class=\"n\">widening</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">those</span><span class=\"w\"> </span><span class=\"n\">equations</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">be</span>\n<span class=\"n\">considered</span><span class=\"w\"> </span><span class=\"n\">as</span><span class=\"w\"> </span><span class=\"n\">being</span><span class=\"w\"> </span><span class=\"n\">proved</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">normalisation</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">typing</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"kp\">is</span>\n<span class=\"n\">completely</span><span class=\"w\"> </span><span class=\"n\">determined</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"n\">i.e.</span><span class=\"w\"> </span><span class=\"n\">those</span><span class=\"w\"> </span><span class=\"n\">equations</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">most</span><span class=\"w\"> </span><span class=\"n\">general</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">the</span>\n<span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">does</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">introduce</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">type</span><span class=\"w\"> </span><span class=\"n\">variables.</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"w\"> </span><span class=\"n\">should</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">noted</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"o\">,</span>\n<span class=\"kp\">in</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"kp\">is</span><span class=\"w\"> </span><span class=\"n\">always</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"k\">case</span><span class=\"w\"> </span><span class=\"kp\">if</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"n\">evaluates</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">True.</span>\n</code></pre></div>\n<p>Looking at Kevin's example (where unit becomes 'a), maybe we didn't implement <br>\nthe check at the end correctly. Florian?</p>\n<p>Tobias</p>\n<p>On 20/02/2025 19:01, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Just for the benefit of readers on this mailing list who are not familiar with <br>\nthe NBE method: this is <em>not</em> a proof method that goes through the Isabelle <br>\nkernel. It is an oracle, and one with a significant trusted code base. Moreover, <br>\nI think it is used much less than the code generator oracle (the \"eval\" method), <br>\nso issues like this one can remain unnoticed for a long time.</p>\n<p>So, although I do not think it was previously known that you could prove \"False\" <br>\nwith NBE, it is not very surprising either. And it does <em>not</em> mean that Isabelle <br>\nas a system is broken.</p>\n<p>Unfortunately, I don't know enough about the internals of NBE to really comment <br>\non this issue otherwise. I just wanted to make sure this was stated somewhere <br>\nclearly on the mailing list.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Oops. Here is a direct illustration that \"normalization\" is contradictory:</p>\n<p>lemma \"card (UNIV :: 'a set) = card (UNIV :: 'b set)\"<br>\n  apply normalization ..</p>\n<p>Stepan</p>\n<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>\n<blockquote>\n<p>Dear list,</p>\n<p>I just proved False using the normalization method in Isabelle/HOL, see <br>\nbelow. It seems like TYPE(T) arguments are generalized(?) to TYPE(?'a) <br>\narguments when running the method (even when dropping the code equation for <br>\nthe constant to be normalized).</p>\n<p>Is this a known problem and is there anything I can do to stop the normalizer <br>\nfrom tinkering with TYPE(T) arguments?</p>\n<p>Background: I used normalization by evaluation to work on a large data <br>\nstructure in an Isabelle/HOL proof for which the performance of the <br>\nsimplifier is insufficient.</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<p>```isabelle</p>\n<p>theory Scratch<br>\n  imports<br>\n    Main<br>\nbegin</p>\n<p>definition [code del]: \"test ≡ card (UNIV :: 'a set) = 1\"</p>\n<p>(<em>TYPE(unit) changes to TYPE('a) even though [code del] is used for test</em>)<br>\nvalue [nbe] \"test TYPE(unit)\"</p>\n<p>lemma oh_oh: \"test TYPE(unit) = test TYPE(bool)\"<br>\n  apply normalization<br>\n  done</p>\n<p>theorem \"False\"<br>\nproof -<br>\n  have \"test TYPE(unit) = True\" unfolding test_def by simp<br>\n  moreover have \"test TYPE(unit) = False\" unfolding oh_oh by (simp add: <br>\ntest_def)<br>\n  ultimately show False by simp<br>\nqed</p>\n<p>end</p>\n<p>```</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/mk6opHn28nS2ANja9PQc68iZ/smime.p7s\">smime.p7s</a></p>",
        "id": 500953661,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740079325
    },
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nNoting that UNIV is normalized to \" List.coset []\", one is tempted to <br>\nsuspect that the typing is careless in the most natural place to go <br>\nwrong, namely with Nil.<br>\n(sorry for meddling, out of curiosity, with something I know nothing about).</p>\n<p>Stepan</p>\n<p>On 20-Feb-25 8:21 PM, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>I went back to the paper we wrote about NBE 15 years ago <br>\n<a href=\"https://www21.in.tum.de/~nipkow/pubs/jfp12.html\">https://www21.in.tum.de/~nipkow/pubs/jfp12.html</a>. This is what it says <br>\nabout types:</p>\n<p><code>\nIn most cases, these type reconstructions are unique, as follows from \nthe structure of normal terms in the simply-typed lambda calculus. \nHowever, in the presence of polymorphic constants, the most general \ntype could be more general than intended. For example, let f be a \npolymorphic constant of type “(’a =&gt; ’a) =&gt; bool”, say without any \nrewrite rule. Then the untyped normal form of “f (λu::bool. u)” would \nbe “f (λu. u)” with most general type annotations “f (λu::’a. u)”. To \navoid such widening of types only those equations will be considered \nas being proved by normalisation where the typing of the result is \ncompletely determined, i.e. those equations where the most general \ntype for the result does not introduce any new type variables. It \nshould be noted that this, in particular, is always the case if an \nexpression evaluates to True.\n</code></p>\n<p>Looking at Kevin's example (where unit becomes 'a), maybe we didn't <br>\nimplement the check at the end correctly. Florian?</p>\n<p>Tobias</p>\n<p>On 20/02/2025 19:01, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Just for the benefit of readers on this mailing list who are not <br>\nfamiliar with the NBE method: this is <em>not</em> a proof method that goes <br>\nthrough the Isabelle kernel. It is an oracle, and one with a <br>\nsignificant trusted code base. Moreover, I think it is used much less <br>\nthan the code generator oracle (the \"eval\" method), so issues like <br>\nthis one can remain unnoticed for a long time.</p>\n<p>So, although I do not think it was previously known that you could <br>\nprove \"False\" with NBE, it is not very surprising either. And it does <br>\n<em>not</em> mean that Isabelle as a system is broken.</p>\n<p>Unfortunately, I don't know enough about the internals of NBE to <br>\nreally comment on this issue otherwise. I just wanted to make sure <br>\nthis was stated somewhere clearly on the mailing list.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing <br>\nList) wrote:</p>\n<blockquote>\n<p>Oops. Here is a direct illustration that \"normalization\" is <br>\ncontradictory:</p>\n<p>lemma \"card (UNIV :: 'a set) = card (UNIV :: 'b set)\"<br>\n  apply normalization ..</p>\n<p>Stepan</p>\n<p>On 20-Feb-25 6:10 PM, Kevin Kappelmann wrote:</p>\n<blockquote>\n<p>Dear list,</p>\n<p>I just proved False using the normalization method in Isabelle/HOL, <br>\nsee below. It seems like TYPE(T) arguments are generalized(?) to <br>\nTYPE(?'a) arguments when running the method (even when dropping the <br>\ncode equation for the constant to be normalized).</p>\n<p>Is this a known problem and is there anything I can do to stop the <br>\nnormalizer from tinkering with TYPE(T) arguments?</p>\n<p>Background: I used normalization by evaluation to work on a large <br>\ndata structure in an Isabelle/HOL proof for which the performance <br>\nof the simplifier is insufficient.</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<p>```isabelle</p>\n<p>theory Scratch<br>\n  imports<br>\n    Main<br>\nbegin</p>\n<p>definition [code del]: \"test ≡ card (UNIV :: 'a set) = 1\"</p>\n<p>(*TYPE(unit) changes to TYPE('a) even though [code del] is used for <br>\ntest*)<br>\nvalue [nbe] \"test TYPE(unit)\"</p>\n<p>lemma oh_oh: \"test TYPE(unit) = test TYPE(bool)\"<br>\n  apply normalization<br>\n  done</p>\n<p>theorem \"False\"<br>\nproof -<br>\n  have \"test TYPE(unit) = True\" unfolding test_def by simp<br>\n  moreover have \"test TYPE(unit) = False\" unfolding oh_oh by (simp <br>\nadd: test_def)<br>\n  ultimately show False by simp<br>\nqed</p>\n<p>end</p>\n<p>```</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 500955315,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740079967
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 20/02/2025 19:01, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Just for the benefit of readers on this mailing list who are not familiar with <br>\nthe NBE method: this is <em>not</em> a proof method that goes through the Isabelle <br>\nkernel. It is an oracle, and one with a significant trusted code base. <br>\nMoreover, I think it is used much less than the code generator oracle (the <br>\n\"eval\" method), so issues like this one can remain unnoticed for a long time.</p>\n<p>So, although I do not think it was previously known that you could prove <br>\n\"False\" with NBE, it is not very surprising either. And it does <em>not</em> mean <br>\nthat Isabelle as a system is broken.</p>\n<p>Unfortunately, I don't know enough about the internals of NBE to really <br>\ncomment on this issue otherwise. I just wanted to make sure this was stated <br>\nsomewhere clearly on the mailing list.</p>\n</blockquote>\n<p>Yes, it is very important to be careful about wording of statements, <br>\nespecially in informal language.</p>\n<p>The subject of this thread is wrong, because there is nothing formally proven <br>\nhere.</p>\n<p>Side-remark: We did not get a report of genuine problems in the Isabelle <br>\ninference kernel for so many years, that I begin to feel uneasy. In olden <br>\ntimes, there used to be reports approx. every 2 years.</p>\n<p>Makarius</p>",
        "id": 500964044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740083490
    },
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;</p>\n<blockquote>\n<p>The subject of this thread is wrong, because there is nothing formally <br>\nproven here.</p>\n</blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it contains <br>\nsome (very few) instances of normalization method (at least one <br>\n&lt;<a href=\"https://www.isa-afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|fact\">https://www.isa-afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|fact</a>&gt; <br>\nfollowed by \"qed\").</p>\n<p>Therefore, indeed, Manuel's warning is very important. A casual reader <br>\ncan be excused for not being able to make these fine distinctions.</p>\n<p>Stepan</p>\n<p>On 20-Feb-25 9:31 PM, Makarius wrote:</p>\n<blockquote>\n<p>On 20/02/2025 19:01, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Just for the benefit of readers on this mailing list who are not <br>\nfamiliar with the NBE method: this is <em>not</em> a proof method that goes <br>\nthrough the Isabelle kernel. It is an oracle, and one with a <br>\nsignificant trusted code base. Moreover, I think it is used much less <br>\nthan the code generator oracle (the \"eval\" method), so issues like <br>\nthis one can remain unnoticed for a long time.</p>\n<p>So, although I do not think it was previously known that you could <br>\nprove \"False\" with NBE, it is not very surprising either. And it does <br>\n<em>not</em> mean that Isabelle as a system is broken.</p>\n<p>Unfortunately, I don't know enough about the internals of NBE to <br>\nreally comment on this issue otherwise. I just wanted to make sure <br>\nthis was stated somewhere clearly on the mailing list.</p>\n</blockquote>\n<p>Yes, it is very important to be careful about wording of statements, <br>\nespecially in informal language.</p>\n<p>The subject of this thread is wrong, because there is nothing formally <br>\nproven here.</p>\n<p>Side-remark: We did not get a report of genuine problems in the <br>\nIsabelle inference kernel for so many years, that I begin to feel <br>\nuneasy. In olden times, there used to be reports approx. every 2 years.</p>\n<p>Makarius</p>\n</blockquote>",
        "id": 501047299,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740126369
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21/02/2025 09:25, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<blockquote>\n<p>The subject of this thread is wrong, because there is nothing formally <br>\nproven here.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it contains some <br>\n(very few) instances of normalization method (at least one &lt;<a href=\"https://www.isa-\">https://www.isa-</a> <br>\n<a href=\"http://afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|\">afp.org/sessions/registers/#Teleport.html#Teleport.teleport_locale.teleport|</a> <br>\nfact&gt; followed by \"qed\").</p>\n</blockquote>\n<p>The AFP title is correct, because almost everything is formally proven. There <br>\ncan be exceptions, when people are doing odd experiments. Or there can be <br>\nsituations where it is appropriate to use tools without proper proofs.</p>\n<p>One day we could render the formal status of results in HTML somehow, to make <br>\nthis more clear.</p>\n<p>And note that \"qed\" in Isar should not be read as \"this is formally proven\".</p>\n<blockquote>\n<p>Therefore, indeed, Manuel's warning is very important. A casual reader can be <br>\nexcused for not being able to make these fine distinctions.</p>\n</blockquote>\n<p>Indeed. That was his attempt to undo the error in the original subject by Kevin.</p>\n<p>Makarius</p>",
        "id": 501060607,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740130447
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 20/02/2025 18:45, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Here is a direct illustration that \"normalization\" is contradictory:</p>\n<p>lemma \"card (UNIV :: 'a set) = card (UNIV :: 'b set)\"<br>\n   apply normalization ..</p>\n</blockquote>\n<p>That is a good example. This is how to expose its implicit assumptions, in <br>\nterms of the inference kernel:</p>\n<p>lemma a: \"card (UNIV :: 'a set) = card (UNIV :: 'b set)\"<br>\n   apply normalization ..</p>\n<p>ML ‹Thm_Deps.all_oracles @{thms a}›</p>\n<p>(*<br>\nval it = [((\"Code_Generator.triv_of_class\", {}), NONE), <br>\n((\"Code_Generator.normalization_by_evaluation\", {}), NONE)]:<br>\n<a href=\"http://Proofterm.oracle\">Proofterm.oracle</a> list<br>\n*)</p>\n<p>Makarius</p>",
        "id": 501066604,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740132214
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>That is a good example. This is how to expose its implicit <br>\nassumptions, in terms of the inference kernel:</p>\n<p>lemma a: \"card (UNIV :: 'a set) = card (UNIV :: 'b set)\"<br>\n  apply normalization ..</p>\n<p>ML ‹Thm_Deps.all_oracles @{thms a}›</p>\n<p>(*<br>\nval it = [((\"Code_Generator.triv_of_class\", {}), NONE), <br>\n((\"Code_Generator.normalization_by_evaluation\", {}), NONE)]:<br>\n<a href=\"http://Proofterm.oracle\">Proofterm.oracle</a> list<br>\n*)</p>\n</blockquote>\n<p>There actually is the top-level command thm_oracles for that, too:</p>\n<p>thm_oracles a</p>\n<p>Prints:</p>\n<p>oracles:<br>\n     triv_of_class<br>\n     normalization_by_evaluation</p>\n<p>As oracles are tracked transitively, you can always do that to your <br>\nfinal theorems, if you want to know on what they depend.</p>\n<p>--</p>\n<p>Peter</p>\n<blockquote>\n<p>Makarius</p>\n</blockquote>",
        "id": 501068666,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740132683
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nOn 21/02/2025 10:33, Makarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>Therefore, indeed, Manuel's warning is very important. A casual <br>\nreader can be excused for not being able to make these fine <br>\ndistinctions.</p>\n</blockquote>\n<p>Indeed. That was his attempt to undo the error in the original subject <br>\nby Kevin.</p>\n</blockquote>\n<p>I would not go that far. I'm sure I have referred to things that I <br>\n\"proved\" with eval, for example, as \"proven\". Without quotation marks. A <br>\nreasonable argument can be made that oracles are evil and should not be <br>\nused in formal proof at all (or otherwise one should not call it \"formal <br>\nproof\" anymore). But I think some more nuance is appropriate and one has <br>\nto look at the oracle in question.</p>\n<p>I for one have sometimes wondered whether something like a \"numeral <br>\naddition and multiplication\" oracle that can only prove theorems of the <br>\nform \"(a :: num) + b = c\" and \"(a :: num) * b = c\" would be an <br>\ninteresting thing to have to speed up numerical computations without <br>\nresorting to full-on reflection. The trusted code base would be tiny, <br>\nand the soundness of Isabelle depends on trusting Poly/ML to be able to <br>\ndo arithmetic on integers already anyway. And I think it would be <br>\nthrowing out the baby with the bath water to say a proof using this <br>\noracle is no longer a proof.</p>\n<p>Something like \"eval\" or \"nbe\" is of course much more involved and there <br>\nare much greater dangers for introducing inconsistency (e.g. one can use <br>\n\"code_printing\" to make eval \"prove\" just about anything).</p>",
        "id": 501071208,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740133416
    },
    {
        "content": "<p>From: Roland Lutz &lt;<a href=\"mailto:rlutz@hedmen.org\">rlutz@hedmen.org</a>&gt;<br>\nOn Fri, 21 Feb 2025, Stepan Holub wrote:</p>\n<blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it contains <br>\nsome (very few) instances of normalization method (at least one followed <br>\nby \"qed\").</p>\n<p>Therefore, indeed, Manuel's warning is very important. A casual reader can<br>\nbe excused for not being able to make these fine distinctions.</p>\n</blockquote>\n<p>Isn't the actual underlying problem here the trust in oracles' results?</p>\n<p>I get that it isn't straightforward to reconstruct a proof from, e.g., an <br>\nSMT solver.  But the fact that Isabelle is used for formal proofs and <br>\nwording like \"qed\" should mean that Isabelle \"takes responsibility\" for <br>\noracle results.  So this really <em>is</em> an Isabelle bug, whether for the <br>\nactual bug or for the inclusion of the oracle, right?</p>\n<p>Ideally, the result from an oracle should be a proofterm.  How unrealistic <br>\nis it to implement this?  What places would need to be changed?</p>\n<p>Roland</p>",
        "id": 501077719,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740135548
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;<br>\nYou seem to be confusing terminology here.</p>\n<p>The concept of an oracle is that it must be trusted. SMT solvers are <br>\nnormally not trusted as oracles in Isabelle (and especially not in the <br>\nAFP) -- e.g., sledgehammer reconstructs all its proofs unless you <br>\nexplicitly ask it not to.</p>\n<p>It is not a surprise that using additional oracles in arbitrary ways <br>\nwill introduce inconsistencies -- you can also axiomatize \"False\", if <br>\nyou want.</p>\n<p>Also Isabelle is an LCF-style system which eliminates the need for proof <br>\nterms.</p>\n<p>Fabian</p>\n<p>On 2/21/25 11:38, Roland Lutz wrote:</p>\n<blockquote>\n<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>\n<blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it <br>\ncontains some (very few) instances of normalization method (at least <br>\none followed by \"qed\").</p>\n<p>Therefore, indeed, Manuel's warning is very important. A casual <br>\nreader can<br>\nbe excused for not being able to make these fine distinctions.</p>\n</blockquote>\n<p>Isn't the actual underlying problem here the trust in oracles' results?</p>\n<p>I get that it isn't straightforward to reconstruct a proof from, e.g., <br>\nan SMT solver.  But the fact that Isabelle is used for formal proofs <br>\nand wording like \"qed\" should mean that Isabelle \"takes <br>\nresponsibility\" for oracle results.  So this really <em>is</em> an Isabelle <br>\nbug, whether for the actual bug or for the inclusion of the oracle, <br>\nright?</p>\n<p>Ideally, the result from an oracle should be a proofterm. How <br>\nunrealistic is it to implement this?  What places would need to be <br>\nchanged?</p>\n<p>Roland</p>\n</blockquote>",
        "id": 501086047,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740138469
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21/02/2025 11:38, Roland Lutz wrote:</p>\n<blockquote>\n<p>I get that it isn't straightforward to reconstruct a proof from, e.g., an SMT <br>\nsolver.</p>\n</blockquote>\n<p>People have actually done that, and by default you get a proper proof for <br>\nIsabelle \"smt\" invocations.</p>\n<blockquote>\n<p>So this really <em>is</em> an Isabelle bug, whether for the actual bug or for the <br>\ninclusion of the oracle, right?</p>\n</blockquote>\n<p>The term \"bug\" is undefined in the Isabelle culture. I normally say <br>\n\"unexpected behaviour\". In the majority of cases this is then a <br>\nmisunderstanding of how things work, rather than a problem in the implementation.</p>\n<blockquote>\n<p>Ideally, the result from an oracle should be a proofterm.  How unrealistic is <br>\nit to implement this?  What places would need to be changed?</p>\n</blockquote>\n<p>Not necessarily a proofterm, but proper inferences in terms of the kernel. <br>\nThis is the normal way in the greater HOL community, and done properly most of <br>\nthe time.</p>\n<p>An alternative is CakeML: these guys have managed to to bootstrap a formally <br>\nproven stack of prover technology, such that things are fast and correct at <br>\nthe same time.</p>\n<p>Makarius</p>",
        "id": 501094521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740141218
    },
    {
        "content": "<p>From: Dominic Mulligan &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nFollowing Peter's post about <code>thm_oracles</code>, is there a way of invoking<br>\n<code>isabelle build</code> for a session so that it fails if any proof of a lemma<br>\nappearing within that session invokes a method that does not pass through<br>\nthe kernel?</p>\n<p>Thanks,<br>\nDom</p>\n<p>On Fri, 21 Feb 2025 at 12:33, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>\n<blockquote>\n<p>I get that it isn't straightforward to reconstruct a proof from, e.g.,<br>\nan SMT<br>\nsolver.</p>\n</blockquote>\n<p>People have actually done that, and by default you get a proper proof for<br>\nIsabelle \"smt\" invocations.</p>\n<blockquote>\n<p>So this really <em>is</em> an Isabelle bug, whether for the actual bug or for<br>\nthe<br>\ninclusion of the oracle, right?</p>\n</blockquote>\n<p>The term \"bug\" is undefined in the Isabelle culture. I normally say<br>\n\"unexpected behaviour\". In the majority of cases this is then a<br>\nmisunderstanding of how things work, rather than a problem in the<br>\nimplementation.</p>\n<blockquote>\n<p>Ideally, the result from an oracle should be a proofterm.  How<br>\nunrealistic is<br>\nit to implement this?  What places would need to be changed?</p>\n</blockquote>\n<p>Not necessarily a proofterm, but proper inferences in terms of the kernel.<br>\nThis is the normal way in the greater HOL community, and done properly<br>\nmost of<br>\nthe time.</p>\n<p>An alternative is CakeML: these guys have managed to to bootstrap a<br>\nformally<br>\nproven stack of prover technology, such that things are fast and correct<br>\nat<br>\nthe same time.</p>\n<p>Makarius</p>\n</blockquote>",
        "id": 501109242,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740145737
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nOthers have written good responses to this already, but let me just add <br>\nthis: Proof terms are not really something that is used very much in <br>\nIsabelle. When you have an \"oracle\" in Isabelle that can easily be made <br>\nto return a proof term (be it an Isabelle proof term or something more <br>\ndomain-specific, such as a SAT or SMT proof), the usual thing to do is <br>\nto just \"import\" the proof term by plugging together Isabelle theorems <br>\n(such that everything goes through the kernel). Or, better still, to <br>\njust have the \"oracle\" plug Isabelle theorems together directly.</p>\n<p>The \"generate some proof object and then push it through the kernel\" <br>\napproach is taken e.g. by Isabelle's \"smt\" tactic, by various tools to <br>\nimport SAT proofs in e.g. the DRUP format, and I think there was a proof <br>\nmethod for linear orders that does this as well (not sure whether it is <br>\nin the AFP or the distribution).</p>\n<p>The \"plug theorems together directly\" approach is taken e.g. by my <br>\nreal_asymp method for proving asymptotic properties like limits and \"Big <br>\nO\" statements. This is in the Isabelle distribution. The advantage here <br>\nis that you don't have to first compute a (possibly huge) proof object <br>\nand then process it (a bit like deforestation). The disadvantage might <br>\nbe that plugging together Isabelle theorems tends to be expensive, so if <br>\nyou're doing a lot of exploration where it's not clear whether a branch <br>\nof computation will actually lead to a result, this might not be the <br>\nright approach.</p>\n<p>But once you do any of that, it's not an oracle anymore (at least not in <br>\nIsabelle terminology), but a proof method. An oracle is by definition <br>\ntrusted code that need not justify what it does to the Isabelle kernel. <br>\nConsequently, one has to be very careful with these. Morally, I think a <br>\ngood argument can be made that oracles make sense for statements that, <br>\nif you were to see a proof for them on paper or in a proof term, it <br>\nwould feel like a waste of space: straightforward computations that take <br>\na lot of time but where it is completely clear <em>how</em> to do them. I think <br>\nthat is how people in systems such as Coq would often use reflection.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>\n<blockquote>\n<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>\n<blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it <br>\ncontains some (very few) instances of normalization method (at least <br>\none followed by \"qed\").</p>\n<p>Therefore, indeed, Manuel's warning is very important. A casual <br>\nreader can<br>\nbe excused for not being able to make these fine distinctions.</p>\n</blockquote>\n<p>Isn't the actual underlying problem here the trust in oracles' results?</p>\n<p>I get that it isn't straightforward to reconstruct a proof from, e.g., <br>\nan SMT solver.  But the fact that Isabelle is used for formal proofs <br>\nand wording like \"qed\" should mean that Isabelle \"takes <br>\nresponsibility\" for oracle results.  So this really <em>is</em> an Isabelle <br>\nbug, whether for the actual bug or for the inclusion of the oracle, <br>\nright?</p>\n<p>Ideally, the result from an oracle should be a proofterm.  How <br>\nunrealistic is it to implement this?  What places would need to be <br>\nchanged?</p>\n<p>Roland</p>\n</blockquote>",
        "id": 501109692,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740145878
    },
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nLet me dare and ask a different, but related, and possibly naively basic <br>\nquestion.</p>\n<p>Is there a clear answer to a logician who wants to know what is the <br>\naxiomatic system in which the theorem is proved if it \"passes through <br>\nthe kernel\"? When advertising Isabelle/HOL, I am often asked this <br>\nquestion, and I confess I am never sure I have a satisfactory answer. <br>\nThe answer should be Pure + HOL. But I am afraid that to explain what <br>\nthat means /exactly/, one should either refer to the actual ML code <br>\n(which is not satisfactory to the logician asking the question) or to <br>\nprovide quite some background literature, which will give only an <br>\napproximate answer anyway.</p>\n<p>Stepan</p>\n<p>On 21-Feb-25 2:50 PM, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Others have written good responses to this already, but let me just <br>\nadd this: Proof terms are not really something that is used very much <br>\nin Isabelle. When you have an \"oracle\" in Isabelle that can easily be <br>\nmade to return a proof term (be it an Isabelle proof term or something <br>\nmore domain-specific, such as a SAT or SMT proof), the usual thing to <br>\ndo is to just \"import\" the proof term by plugging together Isabelle <br>\ntheorems (such that everything goes through the kernel). Or, better <br>\nstill, to just have the \"oracle\" plug Isabelle theorems together <br>\ndirectly.</p>\n<p>The \"generate some proof object and then push it through the kernel\" <br>\napproach is taken e.g. by Isabelle's \"smt\" tactic, by various tools to <br>\nimport SAT proofs in e.g. the DRUP format, and I think there was a <br>\nproof method for linear orders that does this as well (not sure <br>\nwhether it is in the AFP or the distribution).</p>\n<p>The \"plug theorems together directly\" approach is taken e.g. by my <br>\nreal_asymp method for proving asymptotic properties like limits and <br>\n\"Big O\" statements. This is in the Isabelle distribution. The <br>\nadvantage here is that you don't have to first compute a (possibly <br>\nhuge) proof object and then process it (a bit like deforestation). The <br>\ndisadvantage might be that plugging together Isabelle theorems tends <br>\nto be expensive, so if you're doing a lot of exploration where it's <br>\nnot clear whether a branch of computation will actually lead to a <br>\nresult, this might not be the right approach.</p>\n<p>But once you do any of that, it's not an oracle anymore (at least not <br>\nin Isabelle terminology), but a proof method. An oracle is by <br>\ndefinition trusted code that need not justify what it does to the <br>\nIsabelle kernel. Consequently, one has to be very careful with these. <br>\nMorally, I think a good argument can be made that oracles make sense <br>\nfor statements that, if you were to see a proof for them on paper or <br>\nin a proof term, it would feel like a waste of space: straightforward <br>\ncomputations that take a lot of time but where it is completely clear <br>\n<em>how</em> to do them. I think that is how people in systems such as Coq <br>\nwould often use reflection.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>\n<blockquote>\n<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>\n<blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it <br>\ncontains some (very few) instances of normalization method (at least <br>\none followed by \"qed\").</p>\n<p>Therefore, indeed, Manuel's warning is very important. A casual <br>\nreader can<br>\nbe excused for not being able to make these fine distinctions.</p>\n</blockquote>\n<p>Isn't the actual underlying problem here the trust in oracles' results?</p>\n<p>I get that it isn't straightforward to reconstruct a proof from, <br>\ne.g., an SMT solver.  But the fact that Isabelle is used for formal <br>\nproofs and wording like \"qed\" should mean that Isabelle \"takes <br>\nresponsibility\" for oracle results.  So this really <em>is</em> an Isabelle <br>\nbug, whether for the actual bug or for the inclusion of the oracle, <br>\nright?</p>\n<p>Ideally, the result from an oracle should be a proofterm.  How <br>\nunrealistic is it to implement this?  What places would need to be <br>\nchanged?</p>\n<p>Roland</p>\n</blockquote>\n</blockquote>",
        "id": 501115759,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740147647
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;<br>\nYes, you can look at the transitive dependencies of your theorem that <br>\nare axioms (doable in a bit of Isabelle/ML programming). Your axiomatic <br>\nsystem consists of those + the metalogic itself, which has been <br>\nformalized e.g. by Simon Roßkopf and Tobias Nipkow [1] (their proof <br>\nchecker even verifies whether the extracted term is a proof for the <br>\ntheorem).</p>\n<p>The trouble is that you are going to find a lot of axioms, e.g., every <br>\nconstant or type definition will add some. Those axioms are also added <br>\ndirectly, without using the oracle mechanism. I'm not quite sure why <br>\n(possibly performance reasons), because the latter would mean that it'd <br>\nbe sufficient to only look at a few oracles instead of a linearly <br>\ngrowing set of axioms -- and we even have helpful tools such as the <br>\nthm_oracles command.</p>\n<p>Fabian</p>\n<p>[1]: Roßkopf, S., Nipkow, T. A Formalization and Proof Checker for <br>\nIsabelle’s Metalogic. /J Autom Reasoning/ <em>67</em>, 1 (2023). <br>\n<a href=\"https://doi.org/10.1007/s10817-022-09648-w\">https://doi.org/10.1007/s10817-022-09648-w</a></p>\n<p>On 2/21/25 15:20, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Let me dare and ask a different, but related, and possibly naively <br>\nbasic question.</p>\n<p>Is there a clear answer to a logician who wants to know what is the <br>\naxiomatic system in which the theorem is proved if it \"passes through <br>\nthe kernel\"? When advertising Isabelle/HOL, I am often asked this <br>\nquestion, and I confess I am never sure I have a satisfactory answer. <br>\nThe answer should be Pure + HOL. But I am afraid that to explain what <br>\nthat means /exactly/, one should either refer to the actual ML code <br>\n(which is not satisfactory to the logician asking the question) or to <br>\nprovide quite some background literature, which will give only an <br>\napproximate answer anyway.</p>\n<p>Stepan</p>\n<p>On 21-Feb-25 2:50 PM, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Others have written good responses to this already, but let me just <br>\nadd this: Proof terms are not really something that is used very much <br>\nin Isabelle. When you have an \"oracle\" in Isabelle that can easily be <br>\nmade to return a proof term (be it an Isabelle proof term or <br>\nsomething more domain-specific, such as a SAT or SMT proof), the <br>\nusual thing to do is to just \"import\" the proof term by plugging <br>\ntogether Isabelle theorems (such that everything goes through the <br>\nkernel). Or, better still, to just have the \"oracle\" plug Isabelle <br>\ntheorems together directly.</p>\n<p>The \"generate some proof object and then push it through the kernel\" <br>\napproach is taken e.g. by Isabelle's \"smt\" tactic, by various tools <br>\nto import SAT proofs in e.g. the DRUP format, and I think there was a <br>\nproof method for linear orders that does this as well (not sure <br>\nwhether it is in the AFP or the distribution).</p>\n<p>The \"plug theorems together directly\" approach is taken e.g. by my <br>\nreal_asymp method for proving asymptotic properties like limits and <br>\n\"Big O\" statements. This is in the Isabelle distribution. The <br>\nadvantage here is that you don't have to first compute a (possibly <br>\nhuge) proof object and then process it (a bit like deforestation). <br>\nThe disadvantage might be that plugging together Isabelle theorems <br>\ntends to be expensive, so if you're doing a lot of exploration where <br>\nit's not clear whether a branch of computation will actually lead to <br>\na result, this might not be the right approach.</p>\n<p>But once you do any of that, it's not an oracle anymore (at least not <br>\nin Isabelle terminology), but a proof method. An oracle is by <br>\ndefinition trusted code that need not justify what it does to the <br>\nIsabelle kernel. Consequently, one has to be very careful with these. <br>\nMorally, I think a good argument can be made that oracles make sense <br>\nfor statements that, if you were to see a proof for them on paper or <br>\nin a proof term, it would feel like a waste of space: straightforward <br>\ncomputations that take a lot of time but where it is completely clear <br>\n<em>how</em> to do them. I think that is how people in systems such as Coq <br>\nwould often use reflection.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>\n<blockquote>\n<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>\n<blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it <br>\ncontains some (very few) instances of normalization method (at <br>\nleast one followed by \"qed\").</p>\n<p>Therefore, indeed, Manuel's warning is very important. A casual <br>\nreader can<br>\nbe excused for not being able to make these fine distinctions.</p>\n</blockquote>\n<p>Isn't the actual underlying problem here the trust in oracles' results?</p>\n<p>I get that it isn't straightforward to reconstruct a proof from, <br>\ne.g., an SMT solver.  But the fact that Isabelle is used for formal <br>\nproofs and wording like \"qed\" should mean that Isabelle \"takes <br>\nresponsibility\" for oracle results.  So this really <em>is</em> an Isabelle <br>\nbug, whether for the actual bug or for the inclusion of the oracle, <br>\nright?</p>\n<p>Ideally, the result from an oracle should be a proofterm.  How <br>\nunrealistic is it to implement this?  What places would need to be <br>\nchanged?</p>\n<p>Roland</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 501131989,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740152295
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nStepan,</p>\n<p>There is no simple precise answer.</p>\n<p>Isabelle's meta-logic is clearly defined here:<br>\n<a href=\"https://link.springer.com/article/10.1007/s10817-022-09648-w\">https://link.springer.com/article/10.1007/s10817-022-09648-w</a><br>\nIt explains how propositions in Isabelle's term langage are combined (which is <br>\nhow you would expect an inference system to behave), includiung well-formedness, <br>\ntype class and overloading.</p>\n<p>The above paper presents a proof checker that takes an Isabelle proof term and <br>\nchecks that the axioms of whatever theory you are in (which may be <br>\nimplicational, i.e. rules) have been plugged together correctly. The proof <br>\nchecker was verified (in HOL itself).</p>\n<p>The Isabelle theory HOL is the result you obtain when you add a bunch of axioms <br>\nthat you can find in HOL.thy. It is meant to formalize<br>\nA. Church, A formulation of the simple theory of types, Journal of Symbolic <br>\nLogic 5 (1940) 56–68.<br>\nbut deviates in some aspects, esp the types. Same for all HOL-based systems.</p>\n<p>In the end there is always some source could you would need to read or trust to <br>\nmake sure that what you see (as a user) is what you get (internally).</p>\n<p>Tobias</p>\n<p>On 21/02/2025 15:20, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Let me dare and ask a different, but related, and possibly naively basic question.</p>\n<p>Is there a clear answer to a logician who wants to know what is the axiomatic <br>\nsystem in which the theorem is proved if it \"passes through the kernel\"? When <br>\nadvertising Isabelle/HOL, I am often asked this question, and I confess I am <br>\nnever sure I have a satisfactory answer. The answer should be Pure + HOL. But I <br>\nam afraid that to explain what that means /exactly/, one should either refer to <br>\nthe actual ML code (which is not satisfactory to the logician asking the <br>\nquestion) or to provide quite some background literature, which will give only <br>\nan approximate answer anyway.</p>\n<p>Stepan</p>\n<p>On 21-Feb-25 2:50 PM, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Others have written good responses to this already, but let me just add this: <br>\nProof terms are not really something that is used very much in Isabelle. When <br>\nyou have an \"oracle\" in Isabelle that can easily be made to return a proof <br>\nterm (be it an Isabelle proof term or something more domain-specific, such as <br>\na SAT or SMT proof), the usual thing to do is to just \"import\" the proof term <br>\nby plugging together Isabelle theorems (such that everything goes through the <br>\nkernel). Or, better still, to just have the \"oracle\" plug Isabelle theorems <br>\ntogether directly.</p>\n<p>The \"generate some proof object and then push it through the kernel\" approach <br>\nis taken e.g. by Isabelle's \"smt\" tactic, by various tools to import SAT <br>\nproofs in e.g. the DRUP format, and I think there was a proof method for <br>\nlinear orders that does this as well (not sure whether it is in the AFP or the <br>\ndistribution).</p>\n<p>The \"plug theorems together directly\" approach is taken e.g. by my real_asymp <br>\nmethod for proving asymptotic properties like limits and \"Big O\" statements. <br>\nThis is in the Isabelle distribution. The advantage here is that you don't <br>\nhave to first compute a (possibly huge) proof object and then process it (a <br>\nbit like deforestation). The disadvantage might be that plugging together <br>\nIsabelle theorems tends to be expensive, so if you're doing a lot of <br>\nexploration where it's not clear whether a branch of computation will actually <br>\nlead to a result, this might not be the right approach.</p>\n<p>But once you do any of that, it's not an oracle anymore (at least not in <br>\nIsabelle terminology), but a proof method. An oracle is by definition trusted <br>\ncode that need not justify what it does to the Isabelle kernel. Consequently, <br>\none has to be very careful with these. Morally, I think a good argument can be <br>\nmade that oracles make sense for statements that, if you were to see a proof <br>\nfor them on paper or in a proof term, it would feel like a waste of space: <br>\nstraightforward computations that take a lot of time but where it is <br>\ncompletely clear <em>how</em> to do them. I think that is how people in systems such <br>\nas Coq would often use reflection.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 21/02/2025 11:38, Roland Lutz wrote:</p>\n<blockquote>\n<p>On Fri, 21 Feb 2025, Stepan Holub wrote:</p>\n<blockquote>\n<p>Strictly speaking, then, even the title \"AFP\" is wrong, as it contains some <br>\n(very few) instances of normalization method (at least one followed by \"qed\").</p>\n<p>Therefore, indeed, Manuel's warning is very important. A casual reader can<br>\nbe excused for not being able to make these fine distinctions.</p>\n</blockquote>\n<p>Isn't the actual underlying problem here the trust in oracles' results?</p>\n<p>I get that it isn't straightforward to reconstruct a proof from, e.g., an SMT <br>\nsolver.  But the fact that Isabelle is used for formal proofs and wording <br>\nlike \"qed\" should mean that Isabelle \"takes responsibility\" for oracle <br>\nresults.  So this really <em>is</em> an Isabelle bug, whether for the actual bug or <br>\nfor the inclusion of the oracle, right?</p>\n<p>Ideally, the result from an oracle should be a proofterm.  How unrealistic is <br>\nit to implement this?  What places would need to be changed?</p>\n<p>Roland</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/FWmi7TFYRHhhaOX_AwUydCcJ/smime.p7s\">smime.p7s</a></p>",
        "id": 501135085,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740153208
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21/02/2025 14:50, Manuel Eberl wrote:</p>\n<blockquote>\n<p>But once you do any of that, it's not an oracle anymore (at least not in <br>\nIsabelle terminology), but a proof method.</p>\n</blockquote>\n<p>Your explanation was all fine, only this bit needs refinement:</p>\n<p>* \"proof method\" is goal refinement operation of the Isar proof language. <br>\nProof methods may appear as initial method in 'proof' or terminal method in <br>\n'qed'; the Isar language is parametric over the method language, these may do <br>\nwhatever is technically possible, even non-sense.</p>\n<p>* Above you could say \"derived inference rule (of the kernel)\".</p>\n<p>Makarius</p>",
        "id": 501141269,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740155077
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21/02/2025 15:20, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Is there a clear answer to a logician who wants to know what is the axiomatic <br>\nsystem in which the theorem is proved if it \"passes through the kernel\"? When <br>\nadvertising Isabelle/HOL, I am often asked this question, and I confess I am <br>\nnever sure I have a satisfactory answer. The answer should be Pure + HOL. But <br>\nI am afraid that to explain what that means /exactly/, one should either refer <br>\nto the actual ML code (which is not satisfactory to the logician asking the <br>\nquestion) or to provide quite some background literature, which will give only <br>\nan approximate answer anyway.</p>\n</blockquote>\n<p>There are many clear answers, but with some complexity involved in the <br>\nexplanations. I am not a aware of a single canonical answer that could be <br>\nobtained without an effort.</p>\n<p>When introducing Isabelle, I sometimes start with Pure and the Isar proof <br>\nlanguage, and eventually bootstrap HOL from that. Results of such exercises <br>\nare available in src/Pure/Examples. Quite a lot can be done from basic <br>\nprinciples, without a huge stack of addon proof tools getting involved. Thus <br>\nthe audience gets some sense how the formal game works.</p>\n<p>An alternatively approach is to export everything as a huge collection of <br>\nlambda terms. Despite many efforts in recent years, this is still not ready <br>\nfor prime time, but I would like to see this working eventually. For example, <br>\nthe Dedukti guys have volunteered to absorb whatever we throw at them, and <br>\nmake an independent integrity check of the theory content and the proof terms.</p>\n<p>Makarius</p>",
        "id": 501142887,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740155601
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21/02/2025 14:48, Dominic Mulligan (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Following Peter's post about <code>thm_oracles</code>, is there a way of invoking <br>\n<code>isabelle build</code> for a session so that it fails if any proof of a lemma <br>\nappearing within that session invokes a method that does not pass through the <br>\nkernel?</p>\n</blockquote>\n<p>There are various possibilities to do that. The Isabelle/ML operation <br>\nBuild.add_hook allows to install a function that gets invoked at the end of <br>\nthe ML session build. E.g. Mirabelle is using that to inspect all intermediate <br>\ngoal states, to see how automatic tools like them.</p>\n<p>You could use that to inspect the regular fact name space, to see if \"bad\" thm <br>\nvalues are stored. (Tools could still hide their own evil thms in pockets that <br>\nare invisible, and conjure up such bad results later.)</p>\n<p>To \"harden\" regular Isabelle builds, I would use a slightly different <br>\napproach: There is already \"isabelle build -o export_theory\". It could provide <br>\nsufficient information to analyze the overall thm dependency graph later on, <br>\nin Isabelle/Scala instead of Isabelle/ML. Isabelle/Scala has the advantage <br>\nthat it \"oversees\" the overall Isabelle/ML session. The Scala tool could cause <br>\nan error, or display results nicely as a report in the HTML presentation, for <br>\nexample, to say clearly \"how correct\" which theorem is, meaning what are its <br>\nextra dependencies on oracles, axioms, etc.</p>\n<p>Makarius</p>",
        "id": 501144741,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740156204
    },
    {
        "content": "<p>From: Frédéric Blanqui &lt;<a href=\"mailto:frederic.blanqui@inria.fr\">frederic.blanqui@inria.fr</a>&gt;</p>\n<p>Le 21/02/2025 à 17:32, Makarius a écrit :</p>\n<blockquote>\n<p>An alternatively approach is to export everything as a huge collection <br>\nof lambda terms. Despite many efforts in recent years, this is still <br>\nnot ready for prime time, but I would like to see this working <br>\neventually. For example, the Dedukti guys have volunteered to absorb <br>\nwhatever we throw at them, and make an independent integrity check of <br>\nthe theory content and the proof terms. </p>\n</blockquote>\n<p>Hi. Indeed, <a href=\"https://github.com/Deducteam/isabelle_dedukti\">https://github.com/Deducteam/isabelle_dedukti</a> is an Isabelle <br>\ncomponent that can convert Isabelle proof terms into Dedukti or Lambdapi <br>\nfiles. Current Dedukti and Lambdapi checkers (dkcheck, kontroli and <br>\nlambdapi) are quite fast, especially the first two. The main limitation <br>\ncurrently is rather on the Isabelle side: the current proof export is <br>\nquite slow. In the last Isabelle workshop (Tbilisi, 2024), Makarius gave <br>\na nice talk on proof export and his long-term project to improve it (see <br>\n<a href=\"https://files.sketis.net/Isabelle_Workshop_2024/Isabelle_2024_paper_6.pdf\">https://files.sketis.net/Isabelle_Workshop_2024/Isabelle_2024_paper_6.pdf</a>). <br>\nNote that isabelle_dedukti does not handle oracles. The Dedukti or <br>\nLambdapi representation provides another interesting way to see what <br>\nexactly is the logic implemented by Isabelle, and what is assumed by the <br>\nkernel.</p>",
        "id": 501160933,
        "sender_full_name": "Email Gateway",
        "timestamp": 1740161726
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt;<br>\nSee now</p>\n<p><a href=\"https://isabelle.in.tum.de/repos/isabelle/rev/5601f5cce4c6\">https://isabelle.in.tum.de/repos/isabelle/rev/5601f5cce4c6</a></p>\n<p>for the final piece of a series of improvements in nbe.ML.</p>\n<p>There were basically two things to put into shape:</p>\n<ul>\n<li>\n<p>Low-level type inference during term reconstruction was restored using <br>\nproof-context level type inference.</p>\n</li>\n<li>\n<p>Constants carry explicit type arguments, hence the underapproximation <br>\nfor equality used for non-left-linear patterns can distinguish different <br>\ntype instances. As a side effect, type reconstruction of terms is <br>\ncomplete now (although this never had been an issue an practice AFAIR).</p>\n<p>Florian</p>\n</li>\n</ul>\n<p><a href=\"/user_uploads/14278/6dRj2lH5yFDbI2xcK3nzBj2e/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/Wl9wZGNT0jHzm0ZQz_EWIG_4/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 512363375,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744733999
    }
]