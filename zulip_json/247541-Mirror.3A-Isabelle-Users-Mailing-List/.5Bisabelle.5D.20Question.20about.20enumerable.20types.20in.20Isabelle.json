[
    {
        "content": "<p>From: Guilherme Silva &lt;<a href=\"mailto:guilhermegfsilva@gmail.com\">guilhermegfsilva@gmail.com</a>&gt;<br>\nI think I might have made a mistake by sending this question to<br>\n<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>, so I'm trying this address instead.<br>\nSorry for the inconvenience.</p>\n<p>I'm trying to run the following code in Isabelle:</p>\n<hr>\n<p>typedecl type_a<br>\ntypedecl type_b</p>\n<p>consts set_a :: \"type_a set\"<br>\nconsts set_b :: \"type_b set\"<br>\nconsts pairs :: \"(type_a \\&lt;times&gt; type_b) set\"</p>\n<p>definition func_1:: \"bool\" where<br>\n  \"func_1 \\&lt;equiv&gt;<br>\n    \\&lt;forall&gt; a b .<br>\n     ((a, b) \\&lt;in&gt; pairs \\&lt;longrightarrow&gt; (a \\&lt;in&gt; set_a \\&lt;and&gt; b \\&lt;in&gt;<br>\nset_b))\"</p>\n<p>export_code<br>\n  func_1<br>\n    in SML module_name SML_func_1<br>\n    in Haskell module_name Haskell_func_1<br>\n    in OCaml module_name OCaml_func_1<br>\n    in Scala module_name Scala_func_1</p>\n<hr>\n<p>But I get a \"Wellsortedness error: Type type_a/type_b not of sort enum\"<br>\nerror when trying to export code because type_a and type_b are not defined<br>\nas enumerable types.</p>\n<p>How do I define a new, enumerable type to bypass this? I was under the<br>\nimpression that this was possible by using Enum.thy (<br>\n<a href=\"https://isabelle.in.tum.de/library/HOL/HOL/Enum.html\">https://isabelle.in.tum.de/library/HOL/HOL/Enum.html</a>), but I don't know how<br>\nexactly to use this theory to do this, or if there's another one than can<br>\nbe used to do it.</p>\n<p>Thanks,<br>\nG. Silva</p>",
        "id": 389963498,
        "sender_full_name": "Email Gateway",
        "timestamp": 1694216224
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nI don't think this is going to work.</p>\n<p>Isabelle/HOL lets you name types and constants that don't have any definition, as you have done. It also includes some logical operators (e.g. forall) which don't have any standard execution strategy. In these cases, the export mechanism will fail. If you want to generate code for some function, you need to use only the subset of Isabelle's constants and definitional mechanisms which map to concrete code.</p>\n<p>There are some extensions, which might be confusing the matter. If your type is enumerable (i.e. if there exists a list of its elements), it's obvious how to implement forall using filter. I guess this is the default strategy for forall, which the system is trying to use, and failing because there's no enumeration known for \"type_a\". But this is just the first error - nothing else is known about \"type_a\", so it seems inevitable that the system won't be able to encode any operations on it.</p>\n<p>Good luck,<br>\n    Thomas.</p>",
        "id": 390029069,
        "sender_full_name": "Email Gateway",
        "timestamp": 1694261096
    }
]