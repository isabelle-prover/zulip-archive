[
    {
        "content": "<p>From: Guilherme Silva &lt;<a href=\"mailto:guilhermegfsilva@gmail.com\">guilhermegfsilva@gmail.com</a>&gt;<br>\nI'm trying to run the following code in Isabelle:</p>\n<hr>\n<p>typedecl type_a<br>\ntypedecl type_b</p>\n<p>consts set_a :: \"type_a set\"<br>\nconsts set_b :: \"type_b set\"<br>\nconsts pairs :: \"(type_a \\&lt;times&gt; type_b) set\"</p>\n<p>definition func_1:: \"bool\" where<br>\n  \"func_1 \\&lt;equiv&gt;<br>\n    \\&lt;forall&gt; a b .<br>\n     ((a, b) \\&lt;in&gt; pairs \\&lt;longrightarrow&gt; (a \\&lt;in&gt; set_a \\&lt;and&gt; b \\&lt;in&gt;<br>\nset_b))\"</p>\n<p>export_code<br>\n  func_1<br>\n    in SML module_name SML_func_1<br>\n    in Haskell module_name Haskell_func_1<br>\n    in OCaml module_name OCaml_func_1<br>\n    in Scala module_name Scala_func_1</p>\n<hr>\n<p>But I get a \"Wellsortedness error: Type type_a/type_b not of sort enum\"<br>\nerror when trying to export code because type_a and type_b are not defined<br>\nas enumerable types.</p>\n<p>How do I define a new, enumerable type to bypass this? I was under the<br>\nimpression that this was possible by using Enum.thy (<br>\n<a href=\"https://isabelle.in.tum.de/library/HOL/HOL/Enum.html\">https://isabelle.in.tum.de/library/HOL/HOL/Enum.html</a>), but I don't know how<br>\nexactly to use this theory to do this, or if there's another one than can<br>\nbe used to do it.</p>\n<p>Thanks,<br>\nG. Silva</p>",
        "id": 390117944,
        "sender_full_name": "Email Gateway",
        "timestamp": 1694334405
    }
]