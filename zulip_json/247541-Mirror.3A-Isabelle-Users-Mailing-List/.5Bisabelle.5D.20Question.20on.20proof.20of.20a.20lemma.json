[
    {
        "content": "<p>From: Hongjian Jiang &lt;<a href=\"mailto:jianghongjian87@gmail.com\">jianghongjian87@gmail.com</a>&gt;<br>\nIn my project, I try to prove such a lemma:∀q. (∃x∈trans2LTS r v.<br>\nsingle_LTS_reachable_by_path q x) ⟶ q ∈ sem_reg r v ⟹ x ∈ star (trans2LTS r v)<br>\n⟹ single_LTS_reachable_by_path q x ⟹ q ∈ star (sem_reg r v)</p>\n<p>This is the definition of star:</p>\n<p>inductive_set star :: \"'v list set ⇒ 'v list set\"<br>\n  for r :: \"'v list set\" where<br>\nzero[intro!]:\"[] ∈ star r\"|<br>\nstep[intro!]:\"x ∈ r ∧ y ∈ star r ⟹ x @ y ∈ star r\"<br>\nThe definition of semantic :</p>\n<p>datatype ('v)regexp = ESet | LChr 'v| Concat \"'v regexp\" \"'v regexp\"|<br>\n                      Alter \"('v) regexp\" \"('v) regexp\"| Dot|<br>\n                      Star \"'v regexp\" |(* Plus \"('v) regexp\" |*) Ques \"('v)<br>\nregexp\" | ε</p>\n<p>primrec sem_reg :: \"('v) regexp =&gt; 'v set⇒ 'v list set\" where<br>\n\"sem_reg ESet v = {[]}\"| (<em>Empty Set</em>)<br>\n\"sem_reg (Dot) vset = (λx .[x]) ` vset\" |<br>\n\"sem_reg (Concat r1 r2) v ={q@p| q p. q ∈ sem_reg r1 v ∧ p ∈ sem_reg r2 v}\"|<br>\n\"sem_reg (LChr a) v = {[a]}\"|<br>\n\"sem_reg (Alter v1 v2) a = (sem_reg v1 a) ∪ (sem_reg v2 a)\"|<br>\n\"sem_reg (Star a) v = star (sem_reg a v)\"|<br>\n\"sem_reg (Ques v) a = {[]} ∪ (sem_reg v a)\"|<br>\n\"sem_reg ε v = {[]}\"<br>\nThe definition of LTS:</p>\n<p>fun concat_transition ::\"(('v regexp × 'v set × 'v regexp) set * 'v regexp *\n'v regexp) list set \\&lt;Rightarrow&gt; (('v regexp × 'v set × 'v regexp) set * 'v<br>\nregexp * 'v regexp) list set \\&lt;Rightarrow&gt; (('v regexp × 'v set × 'v regexp)<br>\nset * 'v regexp * 'v regexp) list set\" where<br>\n\"concat_transition lset1 lset2 = {x@y| x y. x\\&lt;in&gt; lset1 \\&lt;and&gt; y\\&lt;in&gt;lset2}\"</p>\n<p>primrec trans2LTS :: \"'v regexp ⇒ 'v set ⇒ (('v regexp × 'v set × 'v regexp)<br>\nset * 'v regexp * 'v regexp) list set\"  where<br>\n    \"trans2LTS (LChr v) alp_set= {[({(LChr v, {v}, \\&lt;epsilon&gt;)}, LChr v,<br>\n\\&lt;epsilon&gt;)]}\"|<br>\n    \"trans2LTS (ESet) alp_set= {[({(ESet, {} ,\\&lt;epsilon&gt;)},ESet,<br>\n\\&lt;epsilon&gt;)]}\"|<br>\n    \"trans2LTS (\\&lt;epsilon&gt;) alp_set = {[({},\\&lt;epsilon&gt;,\\&lt;epsilon&gt;)]}\"|<br>\n    \"trans2LTS (Dot) alp_set = {[({(Dot, alp_set, \\&lt;epsilon&gt;)},Dot,<br>\n\\&lt;epsilon&gt;)]}\"|<br>\n    \"trans2LTS (Alter r1 r2) alp_set = trans2LTS r1 alp_set \\&lt;union&gt;<br>\ntrans2LTS r2 alp_set\"|<br>\n    \"trans2LTS (Concat r1 r2) alp_set = concat_transition (trans2LTS r1<br>\nalp_set) (trans2LTS r2 alp_set)\" |<br>\n    \"trans2LTS (Star r) alp_set = star (trans2LTS r alp_set)\" |<br>\n    \"trans2LTS (Ques r) alp_set = {[({(Ques r, {}, \\&lt;epsilon&gt;)},Ques r,<br>\n\\&lt;epsilon&gt;)]} \\&lt;union&gt; trans2LTS r alp_set\"<br>\nAnd the definition of single_LTS_reahchable:</p>\n<p>type_synonym ('q,'a) LTS = \"('q * 'a set * 'q) set\"<br>\nprimrec single_LTS_reachable_by_path :: \"'a list ⇒ (('q,'a) LTS * 'q * 'q)<br>\nlist  ⇒ bool \" where<br>\n\"single_LTS_reachable_by_path w []= (w = [])\"|<br>\n\"single_LTS_reachable_by_path w (x# xs) = (∃p q. (w = p @ q ∧ LTS_is_reachable<br>\n(fst x) (fst (snd x)) p (snd (snd x)) ∧ single_LTS_reachable_by_path q xs))\"</p>\n<p>Basically, I try to use star induction help to prove this but failed. An<br>\nauxiliary lemma help to prove I think is on the single_LTS_reahchable, like<br>\nsome function on x, then get the result of the function on w. But I am new<br>\nIsabeller and couldn't think about any idea to prove it. Hope anyone could<br>\nhelp me solve it, thx a lot.</p>",
        "id": 339096841,
        "sender_full_name": "Email Gateway",
        "timestamp": 1677763383
    }
]