[
    {
        "content": "<p>From: Leon Hansen &lt;<a href=\"mailto:lhansen@uni-bremen.de\">lhansen@uni-bremen.de</a>&gt;<br>\nHello everybody,</p>\n<p>I am currently writing my master thesis and I am trying to fetch entries <br>\nfrom a list that fulfil some properties. Similar to a query on a <br>\ndatabase or an ontology.</p>\n<p>My first approach looked like this:</p>\n<p>datatype room = LivingRoom | Kitchen | SleepingRoom<br>\nconsts connectedRooms:: \"room ⇒ room ⇒ bool\"<br>\naxiomatization where<br>\n  a1: \"connectedRooms LivingRoom Kitchen\"</p>\n<p>lemma patheval2: \"connectedRooms X SleepingRoom\" <br>\nnitpick[satisfy,show_consts,user_axioms] oops</p>\n<p>In this case nitpick answers \"X = LivingRoom\" even though that is not <br>\ncorrect.</p>\n<p>What can i do about that?</p>\n<p>My other approach was to avoid axiomatisation completely and use <br>\ndatatypes like this:</p>\n<p>datatype ID = NewID nat<br>\ndatatype Thing = Bed (height: nat) ID<br>\ndefinition bed1 where<br>\n\"bed1 ≡ Bed 2 (NewID 1)\"<br>\ndefinition bed2 where<br>\n\"bed2 ≡ Bed 8 (NewID 3)\"<br>\ndefinition bed3 where<br>\n\"bed3 ≡ Bed 2 (NewID 5)\"<br>\ndefinition bedList where<br>\n\"bedList ≡ [bed1, bed2, bed3]\"<br>\nlemma \"List.filter (%c::Thing. ∃x. c = (Bed 2 (NewName x))) bedList = <br>\nres\" nitpick sorry</p>\n<p>However this becomes very slow for larger lists. Is there a way to do <br>\nthis more efficiently?</p>\n<p>Kind regards</p>\n<p>Leon Hansen</p>",
        "id": 219580976,
        "sender_full_name": "Email Gateway",
        "timestamp": 1607678651
    },
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nI believe that the problem here is that you've specified what<br>\n\"connectedRooms\" does <em>only</em> when applied to LivingRoom and Kitchen, but<br>\nhave not specified its value on any other pair of rooms. Nitpick says \"Hey,<br>\nassigning \"connectedRooms LivingRoom SleepingRoom\" to be \"true\" is<br>\nconsistent with all the axioms. I guess I'm done!\"</p>\n<p>So axiom 1 needs to be much richer --- either a complete enumeration of the<br>\n9 possibilities, or something with an \"if\" that says \"if we're in this one<br>\nspecial case, then true; otherwise false.\"</p>\n<p>NB: You could additionally specify a symmetry axiom ---</p>\n<p>connectedRooms a b =&gt; connectedRooms b a   [I'm forgetting the correct<br>\nsyntax here]</p>\n<p>and then safely have an enumeration of only 6 items instead of all 9.</p>\n<p>-John</p>",
        "id": 219597829,
        "sender_full_name": "Email Gateway",
        "timestamp": 1607688684
    },
    {
        "content": "<p>From: Leon Hansen &lt;<a href=\"mailto:lhansen@uni-bremen.de\">lhansen@uni-bremen.de</a>&gt;<br>\nI do have the reflexivity and transitivity in there already:</p>\n<p>axiomatization where<br>\n   refl: \"connectedRooms x x\" and<br>\n   trans: \"connectedRooms x y ∧ connectedRooms y z ⟶ connectedRooms x z\"</p>\n<p>I just shortend the example by a lot. For that reason it is not possible <br>\nto list every possibility as well.</p>\n<p>I would need to add something like the \"connectedRooms _ _ = False\" that <br>\nwould work if it were a function and not an axiomatisation.</p>\n<p>-Leon</p>",
        "id": 219599196,
        "sender_full_name": "Email Gateway",
        "timestamp": 1607689471
    },
    {
        "content": "<p>From: Jasmin Blanchette via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Leon,</p>\n<blockquote>\n<p>My first approach looked like this:</p>\n<p>datatype room = LivingRoom | Kitchen | SleepingRoom<br>\nconsts connectedRooms:: \"room ⇒ room ⇒ bool\"<br>\naxiomatization where<br>\n a1: \"connectedRooms LivingRoom Kitchen\"</p>\n<p>lemma patheval2: \"connectedRooms X SleepingRoom\" nitpick[satisfy,show_consts,user_axioms] oops</p>\n<p>In this case nitpick answers \"X = LivingRoom\" even though that is not correct.</p>\n</blockquote>\n<p>Although it doesn't correspond to your expectations, Nitpick's behavior is correct. Your \"nitpick\" command is asking for a model of the formula. Nitpick finds one. In that model, \"connectedRooms LivingRoom SleepingRoom\" is true. This is perfectly consistent with your axiomatization. It is not <em>entailed</em> by the axiomatization, but it is clearly consistent with it.</p>\n<p>If you want to find a value X such that \"connectedRooms X SleepingRoom\" is provable -- in other words, a witness for X in \"EX X. connectedRooms X SleepingRoom\", I'm afraid there's no tool that will reliably give you that in Isabelle. The existential formula would be a candidate for Sledgehammer, but in general you wouldn't get the witness out of the proof.</p>\n<blockquote>\n<p>Is there a way to do this more efficiently?</p>\n</blockquote>\n<p>The problem is that I don't clearly understand what \"this\" refers to. I'm starting to suspect that your axiomatization above is wrong; you probably also want to say \"~ connectedRooms LivingRoom SleepingRoom\" etc., if you mean that these are not connected. (Otherwise, they'll be connected in some models of the formulas and not in others.)</p>\n<p>Typically a better approach is to avoid low-level mechanisms such as \"consts\" and \"axiomatization\" and instead rely on the definitional mechanisms, like \"inductive\" (which is probably your best option here), \"fun\", and \"definition\". With \"inductive\", what you don't explicitly make true is automatically false, which is very convenient. You also don't need to worry about models; there's only one model.</p>\n<p>I hope this helps.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 220380837,
        "sender_full_name": "Email Gateway",
        "timestamp": 1608303308
    },
    {
        "content": "<p>From: Leon Hansen &lt;<a href=\"mailto:lhansen@uni-bremen.de\">lhansen@uni-bremen.de</a>&gt;<br>\nDear Jasmin,</p>\n<p>thank you for your detailed response.</p>\n<blockquote>\n<p>If you want to find a value X such that \"connectedRooms X SleepingRoom\" is provable -- in other words, a witness for X in \"EX X. connectedRooms X SleepingRoom\", I'm afraid there's no tool that will reliably give you that in Isabelle. The existential formula would be a candidate for Sledgehammer, but in general you wouldn't get the witness out of the proof.<br>\nThat confirmation is very helpful for me. I thought I was just doing it <br>\ncompletely wrong.<br>\nThe problem is that I don't clearly understand what \"this\" refers to.<br>\nMy goal is to embed knowledge from an owl ontology in an Isabelle theory <br>\nand be able to retrieve it again in reasonable time.<br>\nTypically a better approach is to avoid low-level mechanisms such as \"consts\" and \"axiomatization\" and instead rely on the definitional mechanisms, like \"inductive\" (which is probably your best option here), \"fun\", and \"definition\". With \"inductive\", what you don't explicitly make true is automatically false, which is very convenient. You also don't need to worry about models; there's only one model.</p>\n</blockquote>\n<p>That is more or less what i did in my second approach where i used <br>\n\"datatype\" and \"definition\" only. Thank you for the tip with <br>\n\"inductive\". For small theories nitpick returns the requested <br>\ninformation reliably and fast. For theories with a few hundred lines it <br>\nwas taking way to much time. I hoped there was a simple way to limit <br>\nnitpicks search space and speed up the search for witnesses for X in \"EX <br>\nX. connectedRooms X SleepingRoom\" for example.</p>\n<p>Kind regards,</p>\n<p>Leon</p>",
        "id": 220463116,
        "sender_full_name": "Email Gateway",
        "timestamp": 1608372194
    }
]