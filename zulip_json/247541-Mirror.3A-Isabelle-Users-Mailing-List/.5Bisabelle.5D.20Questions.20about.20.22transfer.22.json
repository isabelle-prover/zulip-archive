[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHello,</p>\n<p>I recently did some experiments with the \"transfer\" command, but there<br>\nare a few things that I don't quite understand, so here are a few questions:</p>\n<ol>\n<li>\n<p>It seems to me that \"transfer\" always transfers theorems<br>\n\"left-to-right\". For the \"transferred\" attribute, there is<br>\n\"untransferred\" – is there a similar thing for \"transfer\" as well?</p>\n</li>\n<li>\n<p>Relatedly, is there an easy idiomatic way to use \"flipped\" relators?<br>\nThe following does not work:</p>\n</li>\n</ol>\n<p>lemma<br>\n  assumes [transfer_rule]: \"rel_set r X Y\"<br>\n  shows   \"rel_set (λy x. r x y) Y X\"<br>\n  by transfer_prover</p>\n<ol start=\"3\">\n<li>Sometimes, it is more convenient to prove transfer rules for<br>\nfunctions following the pattern</li>\n</ol>\n<p>lemma<br>\n  assumes [transfer_rule]: \"r1 a b\" \"r2 c d\"<br>\n  shows   \"r3 (f a c) (f' b d)\"</p>\n<p>but if I declare that lemmas as a transfer_rule, it is not used. I have<br>\nto explicitly prove \"(r1 ===&gt; r2 ===&gt; r3) f f'\" from this for it to be<br>\nused. Is there some way around this?</p>\n<ol start=\"4\">\n<li>There is currently no relator for measures. I came up with the<br>\nfollowing one, which works well for my purposes, but I think it is not a<br>\ngood relator because it only makes sense for bi-unique relators on the<br>\nvalues.</li>\n</ol>\n<p>definition rel_measure :: \"('a ⇒ 'b ⇒ bool) ⇒ ('a measure ⇒ 'b measure ⇒<br>\nbool)\" where<br>\n  \"rel_measure r M1 M2 ⟷<br>\n     rel_set r (space M1) (space M2) ∧<br>\n     rel_set (rel_set r) (sets M1) (sets M2) ∧<br>\n     (rel_set r ===&gt; (=)) (emeasure M1) (emeasure M2)\"</p>\n<p>The definition of rel_pmf suggests something involving product measures<br>\nwould be the right way to go.</p>\n<p>On a related note: suppose I defined my simple relator and then later on<br>\nsomeone else defines another relator for measures. Would the rules then<br>\nclash? Would one have to remove all the rules for my relator for things<br>\nto still work smoothly?</p>\n<ol start=\"5\">\n<li>\n<p>Is there any trick for proving transfer rules for constants defined<br>\nby \"inductive\" or \"fun\" that I am unaware of? Doing the induction proofs<br>\nmanually is very tedious.</p>\n</li>\n<li>\n<p>The constant \"has_derivative\" is not parametric (I think) because<br>\ne.g. for \"(f has_derivative D) at_top\" you get \"Lim (λx. x)\", which<br>\nequal to \"THE x. False\". However, in practice, F is always of the form<br>\n\"at x within A\" and then has_derivative is parametric. But if I prove<br>\nthe transfer rule</p>\n<p>(r ===&gt; r) ===&gt; (r ===&gt; r) ===&gt; r ===&gt; rel_set r ===&gt; (=))<br>\n(λf D x A. (f has_derivative D) (at x within A))<br>\n(λf D x A. (f has_derivative D) (at x within A))</p>\n</li>\n</ol>\n<p>for some suitable relator r, it does not get used. The transfer package<br>\ninsists on a relator for \"has_derivative\". Of course, if I do an<br>\nauxiliary definition for this and fold it before applying transfer, it<br>\nworks, but then I have a useless auxiliary function cluttering the<br>\nnamespace.</p>\n<ol start=\"7\">\n<li>\n<p>In measure theory, there is the definition</p>\n<p>nn_integral :: 'a measure ⇒ ('a ⇒ ennreal) ⇒ ennreal<br>\nnn_integral M f =<br>\n  Sup (simple_integral M `<br>\n  {g. simple_function M g ∧ g ≤ f})</p>\n</li>\n</ol>\n<p>I was able to prove</p>\n<p>lemma transfer_nn_integral [transfer_rule]:<br>\n  assumes [transfer_rule]: \"bi_unique r\"<br>\n  shows \"(rel_measure r ===&gt; (r ===&gt; (=)) ===&gt; (=))<br>\n         nn_integral nn_integral\"</p>\n<p>but I needed some trickery to avoid \"bi_total r\" due to the use of<br>\n\"Collect\". The reason why it works is that \"simple_integral\" only<br>\nevaluates the function on values from \"space M\", so we can replace the<br>\nset in question by</p>\n<p>{g. simple_function M g ∧ (∀x. x ∉ space M ⟶ f x = 0) ∧<br>\n      ∀x∈space M. g x ≤ f x}</p>\n<p>which can be shown (with quite a bit of pain!) to be parametric.</p>\n<p>Is there some trick to make any of this easier?</p>\n<ol start=\"8\">\n<li>Is there any way of telling the transfer package that some rules have<br>\nhigher priority than others?</li>\n</ol>\n<p>Cheers,</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/hKPuCIz1IRTHQ_hjbu1gZaD0/smime.p7s\">smime.p7s</a></p>",
        "id": 221641577,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609850464
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Manuel Eberl/All,</p>\n<p>I will allow myself to provide a few remarks as a regular user of the<br>\ntransfer infrastructure. Certainly, my own understanding of the framework<br>\nis still somewhat limited. However, hopefully, my advice will help to get<br>\nrid of the questions that are less difficult.</p>\n<blockquote>\n<ol>\n<li>It seems to me that \"transfer\" always transfers theorems<br>\n\"left-to-right\". For the \"transferred\" attribute, there is<br>\n\"untransferred\" – is there a similar thing for \"transfer\" as well?</li>\n</ol>\n<p>Similar questions have been asked before and the answer seems to be<br>\nnegative (<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-July/msg00013.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-July/msg00013.html</a><br>\n).</p>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>Sometimes, it is more convenient to prove transfer rules for<br>\nfunctions following the pattern<br>\nlemma<br>\n  assumes [transfer_rule]: \"r1 a b\" \"r2 c d\"<br>\n  shows   \"r3 (f a c) (f' b d)\"<br>\nbut if I declare that lemmas as a transfer_rule, it is not used. I have<br>\nto explicitly prove \"(r1 ===&gt; r2 ===&gt; r3) f f'\" from this for it to be<br>\nused. Is there some way around this?</li>\n</ol>\n<p>In certain circumstances, the rules stated in a similar format can be used.<br>\nFor example,</p>\n</blockquote>\n<p>context<br>\n  includes lifting_syntax<br>\n  fixes r1 r2 r3 :: \"'a ⇒ 'b ⇒ bool\"<br>\n    and f :: \"'a ⇒ 'a ⇒ 'a\" and f' :: \"'b ⇒ 'b ⇒ 'b\"<br>\n  assumes [transfer_rule]: \"bi_unique r3\"<br>\n    and [transfer_rule]: \"r1 a b ⟹ r2 c d ⟹ r3 (f a c) (f' b d)\"<br>\nbegin</p>\n<p>lemma<br>\n  assumes [transfer_rule]: \"r1 a b\" \"r2 c d\"<br>\n  shows \"f' b d = f' b d\"<br>\n  by transfer (rule refl)</p>\n<p>end</p>\n<p>In this case, \"r1 a b\" and \"r2 c d\" are treated as side conditions, and the<br>\ntransfer infrastructure has some limited support for such unconventional<br>\nside conditions (however, I am not certain as to what is the extent of such<br>\nsupport).</p>\n<p>If it is more convenient to prove a transfer rule in the form that you have<br>\nstated, then you can always use (intro rel_funI) to perform the conversion,<br>\ne.g.</p>\n<p>lemma<br>\n  includes lifting_syntax<br>\n  shows \"(r1 ===&gt; r2 ===&gt; r3) f f'\"<br>\n  apply(intro rel_funI)<br>\n  (<em>⋀x y xa ya. r1 x y ⟹ r2 xa ya ⟹ r3 (f x xa) (f' y ya)</em>)</p>\n<blockquote>\n<ol start=\"5\">\n<li>Is there any trick for proving transfer rules for constants defined<br>\nby \"inductive\" or \"fun\" that I am unaware of? Doing the induction proofs<br>\nmanually is very tedious.</li>\n</ol>\n<p>Yes, there is: see<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html</a>.<br>\nI would like to add to the suggestion in the post that, technically, there<br>\nis little that is stopping one from recovering the original definitional<br>\naxiom in Isabelle/ML using Thm.axiom (e.g. see the implementation of UD in<br>\n<a href=\"https://gitlab.com/user9716869/Isabelle-Complement-Library\">https://gitlab.com/user9716869/Isabelle-Complement-Library</a>, but keep in<br>\nmind that it is still in a reasonably rough experimental state) instead of<br>\nusing the collection of theorems associated with nitpick. Providing further<br>\nautomation for this is on my own \"to do\" list, but it has a very low<br>\npriority. If you decide to make an attempt to generalize/automate this<br>\nidea, I would highly appreciate it if you could let me know about this to<br>\navoid possible duplication of efforts.</p>\n</blockquote>\n<blockquote>\n<ol start=\"7\">\n<li>In measure theory, there is the definition<br>\n  nn_integral :: 'a measure ⇒ ('a ⇒ ennreal) ⇒ ennreal<br>\n  nn_integral M f =<br>\n    Sup (simple_integral M `<br>\n    {g. simple_function M g ∧ g ≤ f})<br>\nI was able to prove<br>\nlemma transfer_nn_integral [transfer_rule]:<br>\n  assumes [transfer_rule]: \"bi_unique r\"<br>\n  shows \"(rel_measure r ===&gt; (r ===&gt; (=)) ===&gt; (=))<br>\n         nn_integral nn_integral\"<br>\nbut I needed some trickery to avoid \"bi_total r\" due to the use of<br>\n\"Collect\". The reason why it works is that \"simple_integral\" only<br>\nevaluates the function on values from \"space M\", so we can replace the<br>\nset in question by<br>\n  {g. simple_function M g ∧ (∀x. x ∉ space M ⟶ f x = 0) ∧<br>\n      ∀x∈space M. g x ≤ f x}<br>\nwhich can be shown (with quite a bit of pain!) to be parametric.<br>\nIs there some trick to make any of this easier?</li>\n</ol>\n<p>I cannot be certain, but it appears that a pattern similar to the one that<br>\nyou suggest was used in published work by those whom I would consider to be<br>\nwell-versed in the functionality of transfer (e.g. see the code associated<br>\nwith [1]). Thus, it is likely that the problem does not have a generic<br>\nsolution. However, I would be happy to be wrong about this, as my own work<br>\nwould benefit from having such a solution.</p>\n</blockquote>\n<p>In this context, I wonder if the types of algorithms used in the work of<br>\nPeter Lammich (e.g. [2] and other related articles) would handle this<br>\nscenario. I would certainly appreciate any comments from him.</p>\n<blockquote>\n<ol start=\"8\">\n<li>Is there any way of telling the transfer package that some rules have<br>\nhigher priority than others?</li>\n</ol>\n<p>A slightly hacky way would be to simply rearrange the transfer_raw<br>\nprogrammatically, as you need. Practically, in most circumstances, this<br>\nshould not be needed. One can always write lemmas [transfer_rule] =<br>\n(<em>relevant rules that need to have a higher priority</em>). The duplicates will<br>\nnot be produced: the theorems in transfer_raw will simply be rearranged<br>\nwith the restated rules at the top of the list.</p>\n</blockquote>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>[1]. Immler F, Zhan B. Smooth Manifolds and Types to Sets for Linear<br>\nAlgebra in Isabelle/HOL. In: 8th ACM SIGPLAN International Conference on<br>\nCertified Programs and Proofs. New York: ACM; 2019. p. 65–77. (CPP 2019).<br>\n[2]. Lammich P. Automatic Data Refinement. In: Blazy S, Paulin-Mohring C,<br>\nPichardie D, editors. Interactive Theorem Proving. Heidelberg: Springer;<br>\n2013. p. 84–99.</p>",
        "id": 221715334,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609888884
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi Manuel,</p>\n<blockquote>\n<ol>\n<li>It seems to me that \"transfer\" always transfers theorems<br>\n\"left-to-right\". For the \"transferred\" attribute, there is<br>\n\"untransferred\" – is there a similar thing for \"transfer\" as well?</li>\n</ol>\n<p>Not that I know of. Going from right to left is problematic with rules that have compound <br>\nterms on the right-hand side (see below).</p>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>Relatedly, is there an easy idiomatic way to use \"flipped\" relators?<br>\nNo. The capabilities of \"transfer\" are very much tailored to the needs of the lifting <br>\npackage. And there, you normally just go one way.</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>Sometimes, it is more convenient to prove transfer rules for<br>\nfunctions following the pattern</li>\n</ol>\n<p>lemma<br>\n   assumes [transfer_rule]: \"r1 a b\" \"r2 c d\"<br>\n   shows   \"r3 (f a c) (f' b d)\"</p>\n<p>but if I declare that lemmas as a transfer_rule, it is not used. I have<br>\nto explicitly prove \"(r1 ===&gt; r2 ===&gt; r3) f f'\" from this for it to be<br>\nused. Is there some way around this?</p>\n<p>Again, nothing that I'm aware of. But it shouldn't be too hard to write an attribute that <br>\ndoes the preprocessing.</p>\n</blockquote>\n<blockquote>\n<ol start=\"4\">\n<li>There is currently no relator for measures. I came up with the<br>\nfollowing one, which works well for my purposes, but I think it is not a<br>\ngood relator because it only makes sense for bi-unique relators on the<br>\nvalues.</li>\n</ol>\n<p>definition rel_measure :: \"('a ⇒ 'b ⇒ bool) ⇒ ('a measure ⇒ 'b measure ⇒<br>\nbool)\" where<br>\n   \"rel_measure r M1 M2 ⟷<br>\n      rel_set r (space M1) (space M2) ∧<br>\n      rel_set (rel_set r) (sets M1) (sets M2) ∧<br>\n      (rel_set r ===&gt; (=)) (emeasure M1) (emeasure M2)\"</p>\n<p>The definition of rel_pmf suggests something involving product measures<br>\nwould be the right way to go.</p>\n</blockquote>\n<p>Yours doesn't look right. The relators coming out of the BNF package are all defined via <br>\nthe product, namely find a value z over pairs whose projections are the original two <br>\nvalues x and y to be related such that the elements in z are contained in the relation r. <br>\nWhile these definitions are canonical, they are hardly intuitive for custom type <br>\nconstructors and usually unwieldy to work with. For probability spaces, this product is <br>\ncommonly called a probabilistic coupling and I believe this would also be the right <br>\nrelator definition for general measures.</p>\n<p>For rel_pmf, you find the characterization theorem in the AFP in <br>\nMFMC_Countable.Rel_PMF_Characterization. Essentially, it says that rel_pmf R p q iff <br>\nmeasure p A &lt;= measure q (R `` A) for all A. I'm pretty sure that such a characterization <br>\ncan be generalized to arbitrary measures. Strassen has proven a number of theorems in that <br>\ndirection (<a href=\"https://www.jstor.org/stable/2238148\">https://www.jstor.org/stable/2238148</a>).</p>\n<blockquote>\n<p>On a related note: suppose I defined my simple relator and then later on<br>\nsomeone else defines another relator for measures. Would the rules then<br>\nclash? Would one have to remove all the rules for my relator for things<br>\nto still work smoothly?</p>\n<p>You'd get a clash for some things. In general, you want to register a few theorems for a <br>\nrelator (e.g., [relator_eq], [relator_mono], [quot_map]) and some of these attributes <br>\nallow only one theorem per type constructor. So you can't register theorems for both <br>\nrelators. The plain transfer machinery can cope with several relators for the same type <br>\nconstructor (except for the function type) and I've used that occasionally. However, you <br>\nhave to be very careful to not end up with an exponentially large search space for transfer.</p>\n</blockquote>\n<blockquote>\n<ol start=\"5\">\n<li>Is there any trick for proving transfer rules for constants defined<br>\nby \"inductive\" or \"fun\" that I am unaware of? Doing the induction proofs<br>\nmanually is very tedious.</li>\n</ol>\n<p>I have looked into this previously. For inductive, I had a few ideas but eventually <br>\nrealized that it doesn't play well together with the current architecture of transfer. The <br>\nproblem is that like for the predicate compiler, an inductive definition may have <br>\ndifferent computational interpretations (modes in logic programming speak) and those <br>\ninterpretations lead to different relators in the resulting transfer rule (predicates vs. <br>\nsets). While it's possible to convert between predicates and sets, this requires <br>\nadditional assumptions about the relations (typically bi_totality). However, as transfer <br>\ndoes not really support multiple relators for the same type constructor, such a solution <br>\nwould be problematic. Moreover, there may be exponentially many transfer rules for an <br>\ninductive predicate, in particular if you do a higher-order mode analysis similar to <br>\nLukas' work for the predicate compiler, so we'd end up creating an exponential number of <br>\ntransfer rules.</p>\n</blockquote>\n<blockquote>\n<ol start=\"6\">\n<li>\n<p>The constant \"has_derivative\" is not parametric (I think) because<br>\ne.g. for \"(f has_derivative D) at_top\" you get \"Lim (λx. x)\", which<br>\nequal to \"THE x. False\". However, in practice, F is always of the form<br>\n\"at x within A\" and then has_derivative is parametric. But if I prove<br>\nthe transfer rule</p>\n<p>(r ===&gt; r) ===&gt; (r ===&gt; r) ===&gt; r ===&gt; rel_set r ===&gt; (=))<br>\n (λf D x A. (f has_derivative D) (at x within A))<br>\n (λf D x A. (f has_derivative D) (at x within A))</p>\n</li>\n</ol>\n<p>for some suitable relator r, it does not get used. The transfer package<br>\ninsists on a relator for \"has_derivative\". Of course, if I do an<br>\nauxiliary definition for this and fold it before applying transfer, it<br>\nworks, but then I have a useless auxiliary function cluttering the<br>\nnamespace.</p>\n<p>The transfer package's algorithm assumes that the transferred term preserves function <br>\napplications and abstractions, i.e., those are always transferred with rel_funI and <br>\nrel_funD. Therefore, you cannot have a compound term on the left-hand side of a transfer <br>\nrule; it will virtually never trigger. (The exception is if you have a constant on the <br>\nright-hand side and use the untransferred attribute.) So your only chance here is to <br>\nintroduce an auxiliary constant and fold the definition before applying transfer.</p>\n</blockquote>\n<p>There are other algorithms that one could use to support such compound terms. For example, <br>\nPeter Lammich's Autoref tool supports compound terms in transfer rules, but that's not <br>\nintegrated with transfer.</p>\n<blockquote>\n<ol start=\"7\">\n<li>\n<p>In measure theory, there is the definition</p>\n<p>nn_integral :: 'a measure ⇒ ('a ⇒ ennreal) ⇒ ennreal<br>\n nn_integral M f =<br>\n   Sup (simple_integral M `<br>\n   {g. simple_function M g ∧ g ≤ f})</p>\n</li>\n</ol>\n<p>I was able to prove</p>\n<p>lemma transfer_nn_integral [transfer_rule]:<br>\n   assumes [transfer_rule]: \"bi_unique r\"<br>\n   shows \"(rel_measure r ===&gt; (r ===&gt; (=)) ===&gt; (=))<br>\n          nn_integral nn_integral\"</p>\n<p>but I needed some trickery to avoid \"bi_total r\" due to the use of<br>\n\"Collect\". The reason why it works is that \"simple_integral\" only<br>\nevaluates the function on values from \"space M\", so we can replace the<br>\nset in question by</p>\n<p>{g. simple_function M g ∧ (∀x. x ∉ space M ⟶ f x = 0) ∧<br>\n       ∀x∈space M. g x ≤ f x}</p>\n<p>which can be shown (with quite a bit of pain!) to be parametric.</p>\n<p>Is there some trick to make any of this easier?</p>\n</blockquote>\n<p>I don't think so. These complications are very typical of proving transfer rules. More <br>\nprecisely, they just show how many shortcuts we're taking in our definitions in HOL <br>\nbecause HOL is a logic of total functions. In ordinary mathematics, we'd say that <code>f</code> and <br>\n<code>g</code> are only defined on <code>space M</code>. So the universal quantifier that's implicit in the <br>\noriginal definition's <code>g &lt;= f</code> would range only over <code>space M</code> anyway.</p>\n<blockquote>\n<ol start=\"8\">\n<li>Is there any way of telling the transfer package that some rules have<br>\nhigher priority than others?</li>\n</ol>\n<p>Finally something that I can answer positively. \"transfer\" uses the [transfer_rule]s in <br>\ninverse order, i.e., theorems that are declared as [transfer_rule] later have higher priority.</p>\n</blockquote>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 221821047,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609965989
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I would like to thank Andreas Lochbihler for providing a more elaborate<br>\nanswer in the following post:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2021-January/msg00038.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2021-January/msg00038.html</a>.<br>\nI believe that there is one notable difference in our answers. More<br>\nspecifically, the answer that was given by Andreas Lochbihler to question 5</p>\n<blockquote>\n<p>Is there any trick for proving transfer rules for constants defined<br>\nby \"inductive\" or \"fun\" that I am unaware of? Doing the induction proofs<br>\nmanually is very tedious.</p>\n<p>is as follows:</p>\n</blockquote>\n<blockquote>\n<p>I have looked into this previously. For inductive, I had a few ideas but<br>\neventually<br>\nrealized that it doesn't play well together with the current architecture<br>\nof transfer. The<br>\nproblem is that like for the predicate compiler, an inductive definition<br>\nmay have<br>\ndifferent computational interpretations (modes in logic programming speak)<br>\nand those<br>\ninterpretations lead to different relators in the resulting transfer rule<br>\n(predicates vs.<br>\nsets). While it's possible to convert between predicates and sets, this<br>\nrequires<br>\nadditional assumptions about the relations (typically bi_totality).<br>\nHowever, as transfer<br>\ndoes not really support multiple relators for the same type constructor,<br>\nsuch a solution<br>\nwould be problematic. Moreover, there may be exponentially many transfer<br>\nrules for an<br>\ninductive predicate, in particular if you do a higher-order mode analysis<br>\nsimilar to<br>\nLukas' work for the predicate compiler, so we'd end up creating an<br>\nexponential number of<br>\ntransfer rules.</p>\n<p>My own answer is also provided for reference:</p>\n</blockquote>\n<blockquote>\n<p>Yes, there is: see<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html</a>.<br>\nI would like to add to the suggestion in the post that, technically, there<br>\nis little that is stopping one from recovering the original definitional<br>\naxiom in Isabelle/ML using Thm.axiom (e.g. see the implementation of UD in<br>\n<a href=\"https://gitlab.com/user9716869/Isabelle-Complement-Library\">https://gitlab.com/user9716869/Isabelle-Complement-Library</a>, but keep in<br>\nmind that it is still in a reasonably rough experimental state) instead of<br>\nusing the collection of theorems associated with nitpick. Providing further<br>\nautomation for this is on my own \"to do\" list, but it has a very low<br>\npriority. If you decide to make an attempt to generalize/automate this<br>\nidea, I would highly appreciate it if you could let me know about this to<br>\navoid possible duplication of efforts.</p>\n<p>I would like to make an attempt to resolve any confusion that this<br>\ndiscrepancy may have caused. The scope of my answer was significantly more<br>\nnarrow. More specifically, my answer assumes that, given a constant c<br>\n(defined as an inductive predicate), there is a term t (normally, also<br>\ndefined with the help of an inductive predicate), a parametricity relation<br>\nR for the type of c, constructed under the assumption that the relators for<br>\nevery non-nullary type constructor are known in advance and some side<br>\nconditions on the involved relations, also known in advance. Then, if the<br>\ntransfer rule R t c exists under the aforementioned side conditions, then<br>\nits proof can often be automated using the transfer prover, assuming the<br>\nexistence of the transfer rules for the constant lfp under compatible side<br>\nconditions, as showcased in<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html</a>.<br>\nThe transfer rules for the lfp can often cover a significant number of<br>\nsimilar applications, possibly allowing for some degree of proof<br>\nautomation. However, of course, as can be inferred from the answer given by<br>\nAndreas Lochbihler, it is hardly a fundamental solution. After all, the OP<br>\nasked for a 'trick' that could help to reduce the size of the proof, and I<br>\ntried to oblige by providing a trick :-).</p>\n</blockquote>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>On Wed, Jan 6, 2021 at 1:20 AM Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nwrote:</p>\n<blockquote>\n<p>Dear Manuel Eberl/All,</p>\n<p>I will allow myself to provide a few remarks as a regular user of the<br>\ntransfer infrastructure. Certainly, my own understanding of the framework<br>\nis still somewhat limited. However, hopefully, my advice will help to get<br>\nrid of the questions that are less difficult.</p>\n<blockquote>\n<ol>\n<li>It seems to me that \"transfer\" always transfers theorems<br>\n\"left-to-right\". For the \"transferred\" attribute, there is<br>\n\"untransferred\" – is there a similar thing for \"transfer\" as well?</li>\n</ol>\n<p>Similar questions have been asked before and the answer seems to be<br>\nnegative (<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-July/msg00013.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-July/msg00013.html</a><br>\n).</p>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>Sometimes, it is more convenient to prove transfer rules for<br>\nfunctions following the pattern<br>\nlemma<br>\n  assumes [transfer_rule]: \"r1 a b\" \"r2 c d\"<br>\n  shows   \"r3 (f a c) (f' b d)\"<br>\nbut if I declare that lemmas as a transfer_rule, it is not used. I have<br>\nto explicitly prove \"(r1 ===&gt; r2 ===&gt; r3) f f'\" from this for it to be<br>\nused. Is there some way around this?</li>\n</ol>\n<p>In certain circumstances, the rules stated in a similar format can be<br>\nused. For example,</p>\n</blockquote>\n<p>context<br>\n  includes lifting_syntax<br>\n  fixes r1 r2 r3 :: \"'a ⇒ 'b ⇒ bool\"<br>\n    and f :: \"'a ⇒ 'a ⇒ 'a\" and f' :: \"'b ⇒ 'b ⇒ 'b\"<br>\n  assumes [transfer_rule]: \"bi_unique r3\"<br>\n    and [transfer_rule]: \"r1 a b ⟹ r2 c d ⟹ r3 (f a c) (f' b d)\"<br>\nbegin</p>\n<p>lemma<br>\n  assumes [transfer_rule]: \"r1 a b\" \"r2 c d\"<br>\n  shows \"f' b d = f' b d\"<br>\n  by transfer (rule refl)</p>\n<p>end</p>\n<p>In this case, \"r1 a b\" and \"r2 c d\" are treated as side conditions, and<br>\nthe transfer infrastructure has some limited support for such<br>\nunconventional side conditions (however, I am not certain as to what is the<br>\nextent of such support).</p>\n<p>If it is more convenient to prove a transfer rule in the form that you<br>\nhave stated, then you can always use (intro rel_funI) to perform the<br>\nconversion, e.g.</p>\n<p>lemma<br>\n  includes lifting_syntax<br>\n  shows \"(r1 ===&gt; r2 ===&gt; r3) f f'\"<br>\n  apply(intro rel_funI)<br>\n  (<em>⋀x y xa ya. r1 x y ⟹ r2 xa ya ⟹ r3 (f x xa) (f' y ya)</em>)</p>\n<blockquote>\n<ol start=\"5\">\n<li>Is there any trick for proving transfer rules for constants defined<br>\nby \"inductive\" or \"fun\" that I am unaware of? Doing the induction proofs<br>\nmanually is very tedious.</li>\n</ol>\n<p>Yes, there is: see<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00072.html</a>.<br>\nI would like to add to the suggestion in the post that, technically, there<br>\nis little that is stopping one from recovering the original definitional<br>\naxiom in Isabelle/ML using Thm.axiom (e.g. see the implementation of UD in<br>\n<a href=\"https://gitlab.com/user9716869/Isabelle-Complement-Library\">https://gitlab.com/user9716869/Isabelle-Complement-Library</a>, but keep in<br>\nmind that it is still in a reasonably rough experimental state) instead of<br>\nusing the collection of theorems associated with nitpick. Providing further<br>\nautomation for this is on my own \"to do\" list, but it has a very low<br>\npriority. If you decide to make an attempt to generalize/automate this<br>\nidea, I would highly appreciate it if you could let me know about this to<br>\navoid possible duplication of efforts.</p>\n</blockquote>\n<blockquote>\n<ol start=\"7\">\n<li>In measure theory, there is the definition<br>\n  nn_integral :: 'a measure ⇒ ('a ⇒ ennreal) ⇒ ennreal<br>\n  nn_integral M f =<br>\n    Sup (simple_integral M `<br>\n    {g. simple_function M g ∧ g ≤ f})<br>\nI was able to prove<br>\nlemma transfer_nn_integral [transfer_rule]:<br>\n  assumes [transfer_rule]: \"bi_unique r\"<br>\n  shows \"(rel_measure r ===&gt; (r ===&gt; (=)) ===&gt; (=))<br>\n         nn_integral nn_integral\"<br>\nbut I needed some trickery to avoid \"bi_total r\" due to the use of<br>\n\"Collect\". The reason why it works is that \"simple_integral\" only<br>\nevaluates the function on values from \"space M\", so we can replace the<br>\nset in question by<br>\n  {g. simple_function M g ∧ (∀x. x ∉ space M ⟶ f x = 0) ∧<br>\n      ∀x∈space M. g x ≤ f x}<br>\nwhich can be shown (with quite a bit of pain!) to be parametric.<br>\nIs there some trick to make any of this easier?</li>\n</ol>\n<p>I cannot be certain, but it appears that a pattern similar to the one that<br>\nyou suggest was used in published work by those whom I would consider to be<br>\nwell-versed in the functionality of transfer (e.g. see the code associated<br>\nwith [1]). Thus, it is likely that the problem does not have a generic<br>\nsolution. However, I would be happy to be wrong about this, as my own work<br>\nwould benefit from having such a solution.</p>\n</blockquote>\n<p>In this context, I wonder if the types of algorithms used in the work of<br>\nPeter Lammich (e.g. [2] and other related articles) would handle this<br>\nscenario. I would certainly appreciate any comments from him.</p>\n<blockquote>\n<ol start=\"8\">\n<li>Is there any way of telling the transfer package that some rules have<br>\nhigher priority than others?</li>\n</ol>\n<p>A slightly hacky way would be to simply rearrange the transfer_raw<br>\nprogrammatically, as you need. Practically, in most circumstances, this<br>\nshould not be needed. One can always write lemmas [transfer_rule] =<br>\n(<em>relevant rules that need to have a higher priority</em>). The duplicates will<br>\nnot be produced: the theorems in transfer_raw will simply be rearranged<br>\nwith the restated rules at the top of the list.</p>\n</blockquote>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>[1]. Immler F, Zhan B. Smooth Manifolds and Types to Sets for Linear<br>\nAlgebra in Isabelle/HOL. In: 8th ACM SIGPLAN International Conference on<br>\nCertified Programs and Proofs. New York: ACM; 2019. p. 65–77. (CPP 2019).<br>\n[2]. Lammich P. Automatic Data Refinement. In: Blazy S, Paulin-Mohring C,<br>\nPichardie D, editors. Interactive Theorem Proving. Heidelberg: Springer;<br>\n2013. p. 84–99.<br>\n</p>\n</blockquote>",
        "id": 221838197,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609975881
    }
]