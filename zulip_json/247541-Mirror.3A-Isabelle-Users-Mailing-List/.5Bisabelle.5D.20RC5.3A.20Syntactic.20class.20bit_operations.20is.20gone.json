[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi List.</p>\n<p>In 2020, there used to be a purely syntactic class for bitwise<br>\noperations: </p>\n<p>HOL/Word/Bits.bit_operations</p>\n<p>This class is gone in RC5, and the closest match seems to be the class<br>\nsemiring_bit_operations in Library/Bit_Operations.thy, but this has<br>\naxioms.</p>\n<p>This new class binds the infix syntax for (AND), (OR), (XOR) to these<br>\naxioms.</p>\n<p>I thought it would be standard to define syntactic type classes for<br>\ninfix syntax first, and then add the axioms.</p>\n<p>In my application, I cannot use the semiring_bit_operations class, as I<br>\ncannot define a mask function. However, I'd like to use the convenient<br>\nsyntax, which is now somewhat blocked.</p>",
        "id": 226138750,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613137966
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<p>In 2020, there used to be a purely syntactic class for bitwise<br>\noperations: </p>\n<p>HOL/Word/Bits.bit_operations</p>\n<p>This class is gone in RC5, and the closest match seems to be the class<br>\nsemiring_bit_operations in Library/Bit_Operations.thy, but this has<br>\naxioms.</p>\n<p>This new class binds the infix syntax for (AND), (OR), (XOR) to these<br>\naxioms.</p>\n<p>In my application, I cannot use the semiring_bit_operations class, as I<br>\ncannot define a mask function. However, I'd like to use the convenient<br>\nsyntax, which is now somewhat blocked.</p>\n</blockquote>\n<p>With Isabelle2021 you will be able to mixin bundles at every logically<br>\nrelevant position, so the canonical solution for re-using mixfix syntax is</p>\n<p>bundle and_or_xor_syntax<br>\nbegin</p>\n<p>no_notation \"and\" …<br>\nnotation \"and\" …</p>\n<p>…</p>\n<p>end</p>\n<p>Beyond that, what is your particular instance such that a mask operation<br>\nwould not be definable?</p>\n<blockquote>\n<p>I thought it would be standard to define syntactic type classes for<br>\ninfix syntax first, and then add the axioms.</p>\n</blockquote>\n<p>No.  In ancient times this was the only possibility, and hence there are<br>\nmany syntactic type classes in HOL like plus, minus, times etc.</p>\n<p>Sometimes they are necessary to accomplish a particular hierarchy, AFAIR<br>\nfor gcd, lcm etc.</p>\n<p>Syntax type classes typically forces many manual type constraints.  You<br>\ncan see the traces e.g. in the upcoming AFP, entry Word_Lib, theory<br>\nWord_Syntax.thy</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/hQA70cHvoSMskqnpO8IEivX4/signature.asc\">signature.asc</a></p>",
        "id": 226190580,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613161075
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi Florian,</p>\n<p>thanks for the response and pointers to the AFP word developments.</p>\n<blockquote>\n<p>With Isabelle2021 you will be able to mixin bundles at every<br>\nlogically<br>\nrelevant position, so the canonical solution for re-using mixfix<br>\nsyntax is</p>\n<p>bundle and_or_xor_syntax<br>\nbegin</p>\n<p>no_notation \"and\" …<br>\nnotation \"and\" …<br>\n</p>\n</blockquote>\n<p>So this will effectively build a linear stack that puts the syntax in<br>\norder. Such a bundle will only work if the conflicting theory that<br>\nfixes the syntax in the typeclass is also loaded. </p>\n<p>Another point against bundles is, that some notations like + or * are<br>\noverloaded many times, with different axioms holding on them.<br>\nFor example, in our separation logic for IMP/HOL, we use * as<br>\nseparating conjunction, that only fulfills the axioms when the two<br>\noperators are, additionally, disjoint, e.g.: a##b ==&gt; a<em>b=b</em>a</p>\n<blockquote>\n<p>…</p>\n<p>end</p>\n<p>Beyond that, what is your particular instance such that a mask<br>\noperation<br>\nwould not be definable?</p>\n</blockquote>\n<p>My llvm formalization uses words of variable but fixed bit-length.<br>\nI have the operation width :: ll_word =&gt; nat, that gives the width, and<br>\noperations are only defined between words of the same width ... but<br>\nthis is deeply embedded, rather than shallowly in the type system, such<br>\nthat I can store those words in my deeply embedded LLVM value model.</p>\n<p>I had instantiated all the syntactic word classes, but now, I cannot<br>\ndefine mask :: nat =&gt; ll_word, as it would have to 'guess' a width.<br>\nAlso, I doubt that the axioms hold unconditionally.</p>",
        "id": 226193510,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613162587
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<blockquote>\n<p>bundle and_or_xor_syntax<br>\nbegin</p>\n<p>no_notation \"and\" …<br>\nnotation \"and\" …<br>\n</p>\n</blockquote>\n<p>So this will effectively build a linear stack that puts the syntax in<br>\norder. Such a bundle will only work if the conflicting theory that<br>\nfixes the syntax in the typeclass is also loaded. </p>\n</blockquote>\n<p>I don't get this point.  What is the »conflicting theory«?</p>\n<blockquote>\n<p>Another point against bundles is, that some notations like + or * are<br>\noverloaded many times, with different axioms holding on them.<br>\nFor example, in our separation logic for IMP/HOL, we use * as<br>\nseparating conjunction, that only fulfills the axioms when the two<br>\noperators are, additionally, disjoint, e.g.: a##b ==&gt; a<em>b=b</em>a</p>\n</blockquote>\n<p>That's a different story.  I definitely don't argue to eliminate the<br>\ntraditional syntactic type classes from HOL.</p>\n<blockquote>\n<p>My llvm formalization uses words of variable but fixed bit-length.<br>\nI have the operation width :: ll_word =&gt; nat, that gives the width, and<br>\noperations are only defined between words of the same width ... but<br>\nthis is deeply embedded, rather than shallowly in the type system, such<br>\nthat I can store those words in my deeply embedded LLVM value model.</p>\n<p>I had instantiated all the syntactic word classes, but now, I cannot<br>\ndefine mask :: nat =&gt; ll_word, as it would have to 'guess' a width.<br>\nAlso, I doubt that the axioms hold unconditionally.</p>\n</blockquote>\n<p>Note that mask is logically a plain definition in this type class (see<br>\nthe Guide.thy in AFP session Word_Lib for the rationale behind).  So, it<br>\nmight be sufficient for a formal definition without a semantic<br>\nmeaningful content.</p>\n<p>But the main issue seems to me indeed the quasi-partiality of AND OR<br>\nXOR.  I don't see a way to make this compatible to the class specification.</p>\n<p>So, the bundle seems the way to go for now.  Since there is some<br>\nrationale to put the most important bit operations into HOL-Main, I once<br>\nthought to organize all infix syntax on bits in bundles anyway, to not<br>\nclutter the syntactic space of HOL-Main.  If this is once accomplished<br>\nafter the release, the infix syntax is completely free.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/9OhvxG9Hiccq_3sLP7NRfcl3/signature.asc\">signature.asc</a></p>",
        "id": 226235936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613207954
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>order. Such a bundle will only work if the conflicting theory that</p>\n<blockquote>\n<p>fixes the syntax in the typeclass is also loaded. </p>\n</blockquote>\n<p>I don't get this point.  What is the »conflicting theory«?<br>\n</p>\n</blockquote>\n<p>A theory that defines a bundle for its syntax, starting with<br>\nno_notation ... to erase potential conflicting syntax, automatically<br>\ndepends on the theory declaring the conflicting syntax, even if they<br>\nare logically independent. Otherwise, the user will be responsible to<br>\ndo such a declaration at the merge point of two theories declaring<br>\nconflicting syntax.</p>\n<blockquote>\n<p>So, the bundle seems the way to go for now.  Since there is some<br>\nrationale to put the most important bit operations into HOL-Main, I<br>\nonce<br>\nthought to organize all infix syntax on bits in bundles anyway, to<br>\nnot<br>\nclutter the syntactic space of HOL-Main.  If this is once<br>\naccomplished<br>\nafter the release, the infix syntax is completely free.</p>\n</blockquote>\n<p>Also, the bundling approach prevents you from using the same syntax for<br>\nthe two related concepts, e.g., I can no longer write the statement: </p>\n<p>width a = width b ==&gt; int_of (a AND b) = int_of a AND int_of b<br>\nfor a b :: ll_word</p>\n<p>In my solution, I now went for introducing a similar looking syntax,<br>\ni.e., a llAND b. But this approach will lead to cluttering the syntax<br>\nspace with many variations of the same syntax, just b/c you cannot<br>\nshare it where it would feel natural to share.</p>\n<p>It seems like there is no fits-everything solution to this question<br>\nyet.</p>",
        "id": 226236577,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613209105
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<p>A theory that defines a bundle for its syntax, starting with<br>\nno_notation ... to erase potential conflicting syntax, automatically<br>\ndepends on the theory declaring the conflicting syntax, even if they<br>\nare logically independent. Otherwise, the user will be responsible to<br>\ndo such a declaration at the merge point of two theories declaring<br>\nconflicting syntax.</p>\n</blockquote>\n<p>I don't see that point.  The syntax woule be totally organized in<br>\nbundles and hence there are no conflicts at theory merges.</p>\n<blockquote>\n<blockquote>\n<p>So, the bundle seems the way to go for now.  Since there is some<br>\nrationale to put the most important bit operations into HOL-Main, I<br>\nonce<br>\nthought to organize all infix syntax on bits in bundles anyway, to<br>\nnot<br>\nclutter the syntactic space of HOL-Main.  If this is once<br>\naccomplished<br>\nafter the release, the infix syntax is completely free.</p>\n</blockquote>\n<p>Also, the bundling approach prevents you from using the same syntax for<br>\nthe two related concepts, e.g., I can no longer write the statement: </p>\n<p>width a = width b ==&gt; int_of (a AND b) = int_of a AND int_of b<br>\nfor a b :: ll_word</p>\n<p>In my solution, I now went for introducing a similar looking syntax,<br>\ni.e., a llAND b. But this approach will lead to cluttering the syntax<br>\nspace with many variations of the same syntax, just b/c you cannot<br>\nshare it where it would feel natural to share.</p>\n<p>It seems like there is no fits-everything solution to this question<br>\nyet.</p>\n</blockquote>\n<p>Ok, now I understand that these operations are inherently partial and<br>\nhence there are no unguarded properties.</p>\n<p>In the current state of affairs most lemmas</p>\n<p>\"… AND … OR … XOR … = …\"</p>\n<p>are valid <em>without</em> any type annotation due to the algebraic foundation<br>\nof the underlying type class.  This should eliminate the felt need for<br>\nyet another infix syntax for word types only as seen in<br>\nWord_Lib/Word_Syntax.thy (which, by the way, is not found in typical<br>\nprogramming languages).  Hence I want to maintain that.</p>\n<p>A compromise could be to have a syntactic class but by default a<br>\nstronger constraint.  I will investigate that in the future.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Stj9ekO2CUw5cuWERcyNfYEF/signature.asc\">signature.asc</a></p>",
        "id": 227797222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614271222
    }
]