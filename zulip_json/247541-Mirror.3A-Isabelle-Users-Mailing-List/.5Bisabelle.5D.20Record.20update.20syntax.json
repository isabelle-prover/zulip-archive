[
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nHi,</p>\n<p>when using records a common theme is to just update some fields of a <br>\nrecord and leave the others at is. To this end, many functional <br>\nlanguages have a record update syntax, e.g. in OCaml you can write {bar <br>\nwith x = 1} to obtain a new record that has all the same values as bar <br>\nexcept for x. As far as I can see, Isabelle/ML currently has no such <br>\nsyntax which can lead to quite a bit of bloat. For a pathological <br>\nexample, see src/Provers/order.ML where multiple functions are declared <br>\nthat each just update one field of the record, but you still have to <br>\nexplicitly provide all the other fields. It would be nice to have this <br>\nbuild into the language. An even more flexible solution would be to <br>\nimplement this as an ML antiquotation; however, this requires the <br>\nability to introspect the type of a record to obtain a list of all the <br>\nrecord members. I am not sure if this is currently (or at all) possible.</p>\n<p>Is there any interest in having such a language construct?</p>\n<p>Lukas</p>",
        "id": 205220699,
        "sender_full_name": "Email Gateway",
        "timestamp": 1595932781
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 28/07/2020 12:39, Lukas Stevens wrote:</p>\n<blockquote>\n<p>when using records a common theme is to just update some fields of a record<br>\nand leave the others at is. To this end, many functional languages have a<br>\nrecord update syntax, e.g. in OCaml you can write {bar with x = 1} to obtain a<br>\nnew record that has all the same values as bar except for x. As far as I can<br>\nsee, Isabelle/ML currently has no such syntax which can lead to quite a bit of<br>\nbloat.</p>\n</blockquote>\n<p>The bloat is not just in the syntax, but also in the implementation: a bulky<br>\nrecord needs to be copied to change just one field.</p>\n<p>Further note that record update is not as exciting as it seems. More important<br>\nis the \"map\" combinator for each individual field. The pair of (selector, map)<br>\nis called a \"lense\" in Haskell context (but we can work with it directly in<br>\nIsabelle/ML without the categorical overhead around it, and just compose<br>\ncombinators via infix \"o\").</p>\n<p>Here is a canonical example to cope reasonably well in the absence of<br>\ncompiler-generated record operations:<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104</a></p>\n<p>Another possibility to trim down complexity of syntax (and runtime behaviour)<br>\nis to nest records/tuples in stages. E.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141</a></p>\n<p>Yet another variant is to use tuples, i.e. records with fields named 1, 2, 3,<br>\n... and use the Isabelle/ML antiquotations to inline map combinators like<br>\n@{apply (3)1}, e.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60</a></p>\n<blockquote>\n<p>For a pathological example, see src/Provers/order.ML where multiple&gt;<br>\nfunctions are declared that each just update one field of the record, but you<br>\nstill have to explicitly provide all the other fields.</p>\n</blockquote>\n<p>That merely looks like an odd example, so it is better not to imitate it. When<br>\ninspecting existing material, you need to develop a feeling who did it at<br>\nwhich time, and estimate how well it was actually done.</p>\n<p>The \"order\" prover is from an undergraduate student project from many years<br>\nago. It looks like the source text could be deflated a lot, by making it more<br>\n\"canonical\" in terms of Isabelle/ML style and orthography.<br>\n(MoreoverIsabelleSourcesDoNotUseCamelCaseToImproveReadability.)</p>\n<p>The somewhat awkward type less_arith with its many homogenous fields could be<br>\njust a table that maps a rule name (type string) to a rule (type thm). See our<br>\nbread-and-butter module Pure/src/General/table.ML</p>\n<p>An alternative is to use a 19-tuple and the @{apply} antiquotation.</p>\n<blockquote>\n<p>It would be nice to<br>\nhave this build into the language. An even more flexible solution would be to<br>\nimplement this as an ML antiquotation; however, this requires the ability to<br>\nintrospect the type of a record to obtain a list of all the record members. I<br>\nam not sure if this is currently (or at all) possible.</p>\n<p>Is there any interest in having such a language construct?</p>\n</blockquote>\n<p>\"Nice to have\" is often a bad reason to add new features. Languages tend to<br>\naccumulate a lot of cruft over the years, and after some decades the<br>\n\"must-haves\" from the past become a heavy burden. (OCaml has a lot of that<br>\nwith its object-oriented twists.)</p>\n<p>Isabelle/ML has its own balance of frugality and richness, both in the same<br>\nlanguage. The rather ancient SML substrate works surprisingly well with the<br>\nminor add-ons provided Isabelle/ML.</p>\n<p>I often find the balance of Isabelle/ML better than Scala, which has many good<br>\nideas, but also tons of extra weight and gravity to bog it down. In<br>\nparticular, Scala \"cases classes\" with their record-update notation (\"copy\"<br>\nmethod) are not as smooth as they should be.</p>\n<p>Makarius</p>",
        "id": 205285683,
        "sender_full_name": "Email Gateway",
        "timestamp": 1595967714
    },
    {
        "content": "<p>From: \"Norrish, Michael (Data61, Acton)\" &lt;<a href=\"mailto:Michael.Norrish@data61.csiro.au\">Michael.Norrish@data61.csiro.au</a>&gt;<br>\nSee also  </p>\n<p><a href=\"http://mlton.org/FunctionalRecordUpdate\">http://mlton.org/FunctionalRecordUpdate</a></p>\n<p>for an SML solution, of sorts.</p>\n<p>Michael</p>\n<p>ï»¿<br>\nOn 29/7/20, 06:23, \"<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> on behalf of Makarius\" &lt;<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> on behalf of <a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>On 28/07/2020 12:39, Lukas Stevens wrote:</p>\n<blockquote>\n<p>when using records a common theme is to just update some fields of a record<br>\nand leave the others at is. To this end, many functional languages have a<br>\nrecord update syntax, e.g. in OCaml you can write {bar with x = 1} to obtain a<br>\nnew record that has all the same values as bar except for x. As far as I can<br>\nsee, Isabelle/ML currently has no such syntax which can lead to quite a bit of<br>\nbloat.</p>\n</blockquote>\n<p>The bloat is not just in the syntax, but also in the implementation: a bulky<br>\nrecord needs to be copied to change just one field.</p>\n<p>Further note that record update is not as exciting as it seems. More important<br>\nis the \"map\" combinator for each individual field. The pair of (selector, map)<br>\nis called a \"lense\" in Haskell context (but we can work with it directly in<br>\nIsabelle/ML without the categorical overhead around it, and just compose<br>\ncombinators via infix \"o\").</p>\n<p>Here is a canonical example to cope reasonably well in the absence of<br>\ncompiler-generated record operations:<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104</a></p>\n<p>Another possibility to trim down complexity of syntax (and runtime behaviour)<br>\nis to nest records/tuples in stages. E.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141</a></p>\n<p>Yet another variant is to use tuples, i.e. records with fields named 1, 2, 3,<br>\n... and use the Isabelle/ML antiquotations to inline map combinators like<br>\n@{apply (3)1}, e.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60</a></p>\n<blockquote>\n<p>For a pathological example, see src/Provers/order.ML where multiple&gt;<br>\nfunctions are declared that each just update one field of the record, but you<br>\nstill have to explicitly provide all the other fields.</p>\n</blockquote>\n<p>That merely looks like an odd example, so it is better not to imitate it. When<br>\ninspecting existing material, you need to develop a feeling who did it at<br>\nwhich time, and estimate how well it was actually done.</p>\n<p>The \"order\" prover is from an undergraduate student project from many years<br>\nago. It looks like the source text could be deflated a lot, by making it more<br>\n\"canonical\" in terms of Isabelle/ML style and orthography.<br>\n(MoreoverIsabelleSourcesDoNotUseCamelCaseToImproveReadability.)</p>\n<p>The somewhat awkward type less_arith with its many homogenous fields could be<br>\njust a table that maps a rule name (type string) to a rule (type thm). See our<br>\nbread-and-butter module Pure/src/General/table.ML</p>\n<p>An alternative is to use a 19-tuple and the @{apply} antiquotation.</p>\n<blockquote>\n<p>It would be nice to<br>\nhave this build into the language. An even more flexible solution would be to<br>\nimplement this as an ML antiquotation; however, this requires the ability to<br>\nintrospect the type of a record to obtain a list of all the record members. I<br>\nam not sure if this is currently (or at all) possible.</p>\n<p>Is there any interest in having such a language construct?</p>\n</blockquote>\n<p>\"Nice to have\" is often a bad reason to add new features. Languages tend to<br>\naccumulate a lot of cruft over the years, and after some decades the<br>\n\"must-haves\" from the past become a heavy burden. (OCaml has a lot of that<br>\nwith its object-oriented twists.)</p>\n<p>Isabelle/ML has its own balance of frugality and richness, both in the same<br>\nlanguage. The rather ancient SML substrate works surprisingly well with the<br>\nminor add-ons provided Isabelle/ML.</p>\n<p>I often find the balance of Isabelle/ML better than Scala, which has many good<br>\nideas, but also tons of extra weight and gravity to bog it down. In<br>\nparticular, Scala \"cases classes\" with their record-update notation (\"copy\"<br>\nmethod) are not as smooth as they should be.</p>\n<p>Makarius</p>",
        "id": 205301479,
        "sender_full_name": "Email Gateway",
        "timestamp": 1595977693
    },
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nThanks for the answer and the additional practical hints.</p>\n<p>Of course, the example is, as I said, pathological but you will find<br>\nclumsy usage of records in other places as well.</p>\n<p>I agree with you that introducing a new language feature would not be a<br>\ngood idea. Lenses would probably be a nice and flexible solution. The<br>\nproblem with those is that you have to write quite a bit of boilerplate<br>\nif you can't generate them automatically. To generate them<br>\nautomatically, one could define an ML antiquotation that reads a record<br>\ntype definition and defines the record type while automatically<br>\ngenerating the code for the lens as well. Or is there a way to generate<br>\nthe lens for an existing record type (which would make it more flexible)?</p>",
        "id": 205576830,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596190809
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 31/07/2020 12:19, Lukas Stevens wrote:</p>\n<blockquote>\n<p>Of course, the example is, as I said, pathological but you will find<br>\nclumsy usage of records in other places as well.</p>\n</blockquote>\n<p>What is your own application like? Is it more like the 19-tuple in<br>\nsrc/Provers/order.ML or like the 8-tuple in src/Pure/variable.ML (or even less<br>\ncomplex)?</p>\n<p>I do see slight inconveniences in using records in SML and thus Isabelle/ML,<br>\nbut the overall balance is still quite good (compared to related or unrelated<br>\ninconveniences in Scala, Haskell, OCaml).</p>\n<blockquote>\n<p>I agree with you that introducing a new language feature would not be a<br>\ngood idea. Lenses would probably be a nice and flexible solution. The<br>\nproblem with those is that you have to write quite a bit of boilerplate<br>\nif you can't generate them automatically. To generate them<br>\nautomatically, one could define an ML antiquotation that reads a record<br>\ntype definition and defines the record type while automatically<br>\ngenerating the code for the lens as well. Or is there a way to generate<br>\nthe lens for an existing record type (which would make it more flexible)?</p>\n</blockquote>\n<p>In the meantime I have also spent more thoughts on the general problem of<br>\nrecords in SML.</p>\n<p>I don't want to see genuine language extensions: this would further weaken the<br>\nlanguage and its few implementations. SML is de-facto a dead language (like<br>\nclassical Latin), and hypothetical discussions and proposals like<br>\n<a href=\"https://smlfamily.github.io/successor-ml\">https://smlfamily.github.io/successor-ml</a> are not going to change that after<br>\nseveral decades.</p>\n<p>I also don't want to see fancy workarounds like in MLton<br>\n<a href=\"http://mlton.org/FunctionalRecordUpdate\">http://mlton.org/FunctionalRecordUpdate</a> --- that is a somewhat different<br>\nculture from Isabelle/ML. Why make a relatively simple problem harder than it<br>\nreally is?</p>\n<p>Nonetheless, I see a prospect of future refinements of Isabelle/ML as follows:</p>\n<p>* The very essence of a record in SML is the list (or set) of fields, not<br>\nthe concrete field types. Field names are global, without scope, but field<br>\ntypes are determined by type-inference in a particular scope of ML text.</p>\n<p>* There could be an antiquotation @{record RECORD = FIELDS ...} to define a<br>\nnamed set of fields within the Isabelle/ML compiler context.</p>\n<p>* The existing antiquotation @{apply m(n)} could be generalized to @{apply<br>\nRECORD(FIELD)}.</p>\n<p>* There could be a few more antiquotations, e.g. @{make RECORD} for a<br>\nfunction that composes a record from its fields.</p>\n<p>Makarius</p>",
        "id": 205785431,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596456044
    },
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nThe application is exactly src/Provers/order.ML but I'd like to refactor<br>\nthe interface of the prover to reduce boilerplate on the ML side of<br>\nthings. Reducing boilerplate when instantiating the prover would also be<br>\ngreat. One way is, as you suggested, to just use tables instead of<br>\nrecords. This would increase the opaqueness of the code since it hides<br>\nwhich theorems are needed exactly. Another way would be to use the<br>\nantiquotations you proposed. Especially the generalised antiquotation<br>\nwould be great and also make sense since records can be viewed as tuples<br>\nwith names instead of indices.</p>",
        "id": 205788507,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596458316
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/08/2020 14:38, Lukas Stevens wrote:</p>\n<blockquote>\n<p>The application is exactly src/Provers/order.ML but I'd like to refactor<br>\nthe interface of the prover to reduce boilerplate on the ML side of<br>\nthings. Reducing boilerplate when instantiating the prover would also be<br>\ngreat. One way is, as you suggested, to just use tables instead of<br>\nrecords. This would increase the opaqueness of the code since it hides<br>\nwhich theorems are needed exactly.</p>\n</blockquote>\n<p>In that case, I do propose to use a plain table that maps a thm name to thm<br>\nvalue: the Order_Tac module has already several operations that use (untyped)<br>\nstring \"tags\" instead of typed record fields, so it fits stylistically and<br>\nactually simplifies the current situation (notably operations like \"empty\" and<br>\n\"update\"; the odd dummy_thm will disappear, it is replaced by an undefined<br>\ntable entry).</p>\n<p>As you proceed to explore order.ML and learn idiomatic use of Isabelle/ML, you<br>\nwill find more and more ways to make the implementation  concise and to the point.</p>\n<p>(The file name should be actually order_tac.ML in correspondence to structure<br>\nOrder_Tac in it.)</p>\n<p>There is yet another perspective on the problem: type less_arith is like an<br>\nalgebraic structure with \"laws\" for operations (=), (&lt;=), (&lt;). This could in<br>\nprinciple become an axiomatic specification as a locale context, and the tool<br>\nthen operates \"under a morphisms\" to move it from the abstract context to<br>\napplication contexts.</p>\n<p>Then the record disappears altogether and is replaced by fancy operations on<br>\nlogical context elements (due to locale interpretation). An example for this<br>\napproach is src/HOL/Tools/semiring_normalizer.ML but it has its own added<br>\ncomplexity.</p>\n<blockquote>\n<p>Another way would be to use the<br>\nantiquotations you proposed. Especially the generalised antiquotation<br>\nwould be great and also make sense since records can be viewed as tuples<br>\nwith names instead of indices.</p>\n</blockquote>\n<p>Right now I recommend to concentrate on the core problems of the application,<br>\nand ignore accidental inconveniences of records in Isabelle/ML.</p>\n<p>Makarius</p>",
        "id": 205792188,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596460723
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:sewell@chalmers.se\">sewell@chalmers.se</a>&gt;<br>\nExcuse me. I haven't read all the emails in this discussion, but it doesn't look like anyone has</p>\n<p>pointed out the fact that the Isabelle equivalent of caml-style</p>\n<p>{bar with x = 1}</p>\n<p>is</p>\n<p>(bar (| x := 1 |) )</p>\n<p>The constant below the syntax is called x_update. Apologies if someone has said this and I missed it.</p>\n<p>There is no equivalent of row-typing, so there's no way to do this polymorphically across all records that have an x field.</p>\n<p>Best regards,</p>\n<p>Thomas.</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; on behalf of Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nSent: Monday, August 3, 2020 3:18:22 PM<br>\nTo: Lukas Stevens; <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nSubject: Re: [isabelle] Record update syntax</p>\n<p>On 03/08/2020 14:38, Lukas Stevens wrote:</p>\n<blockquote>\n<p>The application is exactly src/Provers/order.ML but I'd like to refactor<br>\nthe interface of the prover to reduce boilerplate on the ML side of<br>\nthings. Reducing boilerplate when instantiating the prover would also be<br>\ngreat. One way is, as you suggested, to just use tables instead of<br>\nrecords. This would increase the opaqueness of the code since it hides<br>\nwhich theorems are needed exactly.</p>\n</blockquote>\n<p>In that case, I do propose to use a plain table that maps a thm name to thm<br>\nvalue: the Order_Tac module has already several operations that use (untyped)<br>\nstring \"tags\" instead of typed record fields, so it fits stylistically and<br>\nactually simplifies the current situation (notably operations like \"empty\" and<br>\n\"update\"; the odd dummy_thm will disappear, it is replaced by an undefined<br>\ntable entry).</p>\n<p>As you proceed to explore order.ML and learn idiomatic use of Isabelle/ML, you<br>\nwill find more and more ways to make the implementation  concise and to the point.</p>\n<p>(The file name should be actually order_tac.ML in correspondence to structure<br>\nOrder_Tac in it.)</p>\n<p>There is yet another perspective on the problem: type less_arith is like an<br>\nalgebraic structure with \"laws\" for operations (=), (&lt;=), (&lt;). This could in<br>\nprinciple become an axiomatic specification as a locale context, and the tool<br>\nthen operates \"under a morphisms\" to move it from the abstract context to<br>\napplication contexts.</p>\n<p>Then the record disappears altogether and is replaced by fancy operations on<br>\nlogical context elements (due to locale interpretation). An example for this<br>\napproach is src/HOL/Tools/semiring_normalizer.ML but it has its own added<br>\ncomplexity.</p>\n<blockquote>\n<p>Another way would be to use the<br>\nantiquotations you proposed. Especially the generalised antiquotation<br>\nwould be great and also make sense since records can be viewed as tuples<br>\nwith names instead of indices.</p>\n</blockquote>\n<p>Right now I recommend to concentrate on the core problems of the application,<br>\nand ignore accidental inconveniences of records in Isabelle/ML.</p>\n<p>Makarius</p>",
        "id": 205798654,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596464065
    }
]