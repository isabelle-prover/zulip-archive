[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nDear Isabelle users,</p>\n<p>Isabelle2021 makes it easy to invoke Isabelle/Scala functions from<br>\nIsabelle/ML, but this requires a proper PIDE session for the underlying<br>\nprotocol of Isabelle/Scala.</p>\n<p>This works routinely in:</p>\n<p>isabelle build<br>\n  isabelle server<br>\n  isabelle jedit<br>\n  isabelle vscode<br>\n  ...</p>\n<p>but not in:</p>\n<p>isabelle process<br>\n  isabelle console</p>\n<p>What are remaining uses of the latter two, before they get removed for the<br>\nnext release?</p>\n<p>This should be seen as an opportunity to do \"Isabelle system programming\"<br>\nright in Isabelle/Scala --- using current Isabelle2021. There are many<br>\npossibilities, and I don't think that raw ML processes are still needed. Are<br>\nthere genuine counter examples to this claim?</p>\n<p>Makarius</p>",
        "id": 228064612,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614439631
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nMy scala-isabelle library currently uses 'isabelle process'. It uses it <br>\nin the following way:</p>\n<p>*  From a Scala application, the Isabelle process is invoked with '-e<br>\n    somefile.ML' where somefile.ML contains a loop that reads commands<br>\n    from one named pipe (or socket in Windows) and writes responses<br>\n    asynchronously to another named pipe (or socket).</p>\n<p>I would be happy to use Isabelle/Scala for this (or some other builtin <br>\nmethod), but I would like to keep the following features:</p>\n<p>* It should be possible that the Scala application starts Isabelle.<br>\n    (As opposed to the Scala application being invoked as a component in<br>\n    Isabelle.)</p>\n<p>* I do not want to have to install any components inside the Isabelle<br>\n    home / user home.<br>\n    (Because I want that an application that uses scala-isabelle can run<br>\n    with an existing Isabelle installation without the user having to do<br>\n    anything but tell the Scala application where Isabelle is located.<br>\n    In particular, I don't want to potentially mess up an existing<br>\n    installation.)</p>\n<p>* I do not want to use the PIDE protocol for communication between the<br>\n    Scala application and scala-isabelle (but instead my own binary<br>\n    protocol).<br>\n    (Because I got a factor 1000 or so in round-trip time when switching<br>\n    to my own minimalistic RPC protocol compared to libisabelle that<br>\n    used PIDE.)</p>\n<p>It may very well be that this can be easily achieved without 'isabelle <br>\nprocess' or Isabelle/Scala. For example, one idea would be to simply <br>\nload a theory in a headless noninteractive session that contains a <br>\n(nonterminating) ML_file command which contains the communication loop. <br>\n(Of course, this theory would never be included in a heap because it <br>\ndoes not terminate.) Or an ML_file command that forks the loop into a <br>\nseparate thread and then returns. But I would need some tips for that <br>\nbecause my experiments with these things has mainly lead to me getting <br>\nsome messages like \"invalid execution id\" etc.</p>\n<p>On the long run, I want to support Isabelle/Scala in scala-isabelle in <br>\nthe sense that the existing Isabelle/Scala infrastructure should be an <br>\noptional mechanism how an scala-isabelle application can interact with <br>\nIsabelle. But here also my initial attempts ran into \"invalid execution <br>\nid\" like problems.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 228214650,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614598173
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 01/03/2021 12:02, Dominique Unruh wrote:</p>\n<blockquote>\n<p>My scala-isabelle library currently uses 'isabelle process'. It uses it in the<br>\nfollowing way:</p>\n<p>* From a Scala application, the Isabelle process is invoked with '-e<br>\n    somefile.ML' where somefile.ML contains a loop that reads commands from<br>\n    one named pipe (or socket in Windows) and writes responses asynchronously<br>\n    to another named pipe (or socket).</p>\n</blockquote>\n<p>The proper way to invoke an Isabelle ML process in Scala is is via<br>\nisabelle.ML_Process() --- it has a lot of flexibility. At the same time I<br>\nreckon that this approach will not do the job, because it is not connected<br>\nproperly to Isabelle/Scala via the PIDE protocol.</p>\n<blockquote>\n<p>* I do not want to use the PIDE protocol for communication between the Scala<br>\n    application and scala-isabelle (but instead my own binary protocol).<br>\n    (Because I got a factor 1000 or so in round-trip time when switching to my<br>\n    own minimalistic RPC protocol compared to libisabelle that used PIDE.)</p>\n</blockquote>\n<p>The PIDE protocol is already very minimalistic and efficient. Maybe you have<br>\njust noticed the default delay that was there until recently (after<br>\nIsabelle2021):</p>\n<p>user:        wenzelm<br>\ndate:        Sat Feb 20 21:38:23 2021 +0100<br>\nfiles:       src/Pure/System/message_channel.ML<br>\ndescription:<br>\nmore reactive protocol messages, e.g. for Scala.function (relevant for<br>\nBash.process);</p>\n<p>Afterwards, the measured roundtrip for Scala.function is approx. 0..2ms.</p>\n<p>If there are remaining inconveniences, we can try to sort it out, but<br>\ndismissing PIDE is not an option.</p>\n<blockquote>\n<p>It may very well be that this can be easily achieved without 'isabelle<br>\nprocess' or Isabelle/Scala. For example, one idea would be to simply load a<br>\ntheory in a headless noninteractive session that contains a (nonterminating)<br>\nML_file command which contains the communication loop. (Of course, this theory<br>\nwould never be included in a heap because it does not terminate.) Or an<br>\nML_file command that forks the loop into a separate thread and then returns.<br>\nBut I would need some tips for that because my experiments with these things<br>\nhas mainly lead to me getting some messages like \"invalid execution id\" etc.</p>\n</blockquote>\n<p>How about using \"isabelle server\" or Headless.Session directly in<br>\nIsabelle/Scala? The rest is done declaratively within the PIDE document model,<br>\nwithout any homegrown protocols around it.</p>\n<p>There are many possibilities to do it correctly within the Isabelle framework,<br>\nwithout disrupting it.</p>\n<blockquote>\n<p>On the long run, I want to support Isabelle/Scala in scala-isabelle in the<br>\nsense that the existing Isabelle/Scala infrastructure should be an optional<br>\nmechanism how an scala-isabelle application can interact with Isabelle. But<br>\nhere also my initial attempts ran into \"invalid execution id\" like problems.</p>\n</blockquote>\n<p>Once more: Isabelle/Scala (with PIDE protocol) is non-optional for<br>\nIsabelle/ML. In the next release this will be even more noticeable in everyday<br>\nuse.</p>\n<p>Makarius</p>",
        "id": 228223496,
        "sender_full_name": "Email Gateway",
        "timestamp": 1614602726
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>My scala-isabelle library currently uses 'isabelle process'. It uses it in the<br>\nfollowing way:</p>\n<p>* From a Scala application, the Isabelle process is invoked with '-e<br>\n     somefile.ML' where somefile.ML contains a loop that reads commands from<br>\n     one named pipe (or socket in Windows) and writes responses asynchronously<br>\n     to another named pipe (or socket).<br>\nThe proper way to invoke an Isabelle ML process in Scala is is via<br>\nisabelle.ML_Process() --- it has a lot of flexibility. At the same time I<br>\nreckon that this approach will not do the job, because it is not connected<br>\nproperly to Isabelle/Scala via the PIDE protocol.</p>\n</blockquote>\n</blockquote>\n<p>I confirm that I got things to work this way. I am using the following code:</p>\n<p>override def startIsabelleProcess(cwd: Path, mlCode: String, logic: String,<br>\n                                         sessionRoots: Array[Path], build: Boolean,<br>\n                                         userDir: Optional[Path]): Process = {<br>\n    Isabelle_System.init(isabelle_root = isabelleRoot.toString)<br>\n         val channel = System_Channel()<br>\n         val options = Options.init()<br>\n         val channel_options = options.string.update(\"system_channel_address\", channel.address).<br>\n           string.update(\"system_channel_password\", channel.password)</p>\n<p>val sessionRoots2 = sessionRoots.map(p =&gt; isabelle.Path.explode(p.toString)).toList<br>\n         val sessions_structure = Sessions.load_structure(options = options, dirs = sessionRoots2)<br>\n         val store = Sessions.store(options)</p>\n<p>if (build) {<br>\n    Isabelle_Thread.fork(name =\"Build Isabelle\", daemon =true) {<br>\n             Build.build_logic(options = options, logic = logic, build_heap =true, dirs = sessionRoots2)<br>\n           }.join()<br>\n         }</p>\n<p>ML_Process(channel_options, sessions_structure, store, eval_main = mlCode, logic = logic, cwd = cwd.toFile)<br>\n       }</p>\n<p>Can you confirm that I am using the proper functions here? (Most of it <br>\nis guess work and try and error.)</p>\n<p>And one additional question: Is there a way to set the Isabelle user <br>\nhome? I tried the following code (inspired by some fragment I found in <br>\nthe Isabelle source somewhere), but it has no effect. Maybe there is a <br>\ndifferent way? (I do not want to require an environment variable to be <br>\nset outside the application. But I want to give Scala apps the <br>\npossibility to use a local setup that does not interfere with the <br>\nIsabelle config of the user, if needed.)</p>\n<p>val userDir2 = isabelle.File.standard_path(userDir.get().toString)<br>\n    val putenv = Class.forName(\"org.gjt.sp.jedit.MiscUtilities\")<br>\n       .getMethod(\"putenv\", classOf[String], classOf[String])<br>\n    putenv.invoke(null,\"ISABELLE_HOME_USER\", userDir2)<br>\n    putenv.invoke(null,\"USER_HOME\", userDir2)</p>\n<p>One more question: I am passing the session root directories both to <br>\nSessions.load_structure and to Build.build_logic. I am worried that this <br>\nmeans that the time-intensive scan of the session directories <br>\n(especially if AFP is loaded) happens twice. Is that correct? Can it be <br>\navoided?</p>\n<p>But these remaining questions notwithstanding, it seems that I will not <br>\nneed the command line \"isabelle process\" as long as ML_Process will be <br>\nthere.</p>\n<blockquote>\n<blockquote>\n<p>* I do not want to use the PIDE protocol for communication between the Scala<br>\n     application and scala-isabelle (but instead my own binary protocol).<br>\n     (Because I got a factor 1000 or so in round-trip time when switching to my<br>\n     own minimalistic RPC protocol compared to libisabelle that used PIDE.)</p>\n<p>Afterwards, the measured roundtrip for Scala.function is approx. 0..2ms.</p>\n</blockquote>\n</blockquote>\n<p>That is indeed better than what I experienced, but still is far from the <br>\nround-trip time of 0.03ms I measured with a minimalistic protocol. But I <br>\nwill explore a possible transition to PIDE / Isabelle/Scala as a backend <br>\nfurther in the future, as soon as time permits.</p>\n<p>(Maybe switching to named pipes on Linux instead of network sockets is <br>\nthe main reason for the speed difference. At least in my experiments, <br>\nthe round trip time was much faster with named pipes.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 229276475,
        "sender_full_name": "Email Gateway",
        "timestamp": 1615199163
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe named pipes were there until some years ago, when I made everything<br>\nuniform for the sake of Windows:<br>\n<a href=\"https://isabelle-dev.sketis.net/rISABELLEacba5d6fdb2\">https://isabelle-dev.sketis.net/rISABELLEacba5d6fdb2</a></p>\n<p>It might be possible to do named pipes again with current Java versions (we<br>\nare presently at Java 15, soon at Java 17), but I did not have time to<br>\ninvestigate (and no particular reason for doing it).</p>\n<p>Makarius</p>",
        "id": 229285989,
        "sender_full_name": "Email Gateway",
        "timestamp": 1615204184
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 08/03/2021 10:49, Dominique Unruh wrote:</p>\n<blockquote>\n<blockquote>\n<p>The proper way to invoke an Isabelle ML process in Scala is is via<br>\nisabelle.ML_Process() --- it has a lot of flexibility. At the same time I<br>\nreckon that this approach will not do the job, because it is not connected<br>\nproperly to Isabelle/Scala via the PIDE protocol.</p>\n</blockquote>\n<p>I confirm that I got things to work this way. I am using the following code:</p>\n<p>override def startIsabelleProcess(cwd: Path, mlCode: String, logic: String,<br>\n                                        sessionRoots: Array[Path], build: Boolean,<br>\n                                        userDir: Optional[Path]): Process = {<br>\n    Isabelle_System.init(isabelle_root = isabelleRoot.toString)<br>\n        val channel = System_Channel()<br>\n        val options = Options.init()<br>\n        val channel_options = options.string.update(\"system_channel_address\", channel.address).<br>\n          string.update(\"system_channel_password\", channel.password)</p>\n<p>val sessionRoots2 = sessionRoots.map(p =&gt; isabelle.Path.explode(p.toString)).toList<br>\n        val sessions_structure = Sessions.load_structure(options = options, dirs = sessionRoots2)<br>\n        val store = Sessions.store(options)</p>\n<p>if (build) {<br>\n    Isabelle_Thread.fork(name = \"Build Isabelle\", daemon = true) {<br>\n            Build.build_logic(options = options, logic = logic, build_heap = true, dirs = sessionRoots2)<br>\n          }.join()<br>\n        }</p>\n<p>ML_Process(channel_options, sessions_structure, store, eval_main = mlCode, logic = logic, cwd = cwd.toFile)<br>\n      }</p>\n<p>Can you confirm that I am using the proper functions here? (Most of it is<br>\nguess work and try and error.)</p>\n</blockquote>\n<p>It looks fine as a start. Just a few side-remarks:</p>\n<p>* It is better to invoke Isabelle_System.init() only once at the start of<br>\nthe application, not for each Isabelle process.</p>\n<p>* Likewise it is better to invoke Options.init() only once, and later pass<br>\naround (options: Options) in a purely functional manner.</p>\n<p>* sessionRoots: Array[Path] looks very strange. Are you trying to imitate<br>\nvery old Java conventions (or Eclipse)? Array is the worst data structure<br>\never. In recent Java, I see more and more uses of java.util.List, together<br>\nwith convenient List.of() functions to create adhoc instances. And Scala 2.13<br>\nhas good conversions asJava / asScala --- not that I using that myself, unless<br>\nthere is no way around it.</p>\n<p>* isabelle.Path.explode(p.toString) looks quite fragile; it is unlikely to<br>\nwork on Windows. Assuming that your Path type is java.nio.file.Path you can<br>\nuse isabelle.File.path(path.toFile)</p>\n<p>* cwd could be null (a rare exception in Isabelle/Scala signatures!) and<br>\nthus cwd.toFile could crash.</p>\n<p>* Instead of Isabelle_Thread.fork, I often use the more convenient<br>\nFuture.thread.</p>\n<p>Anyway, the above would merely replace the external \"isabelle process\" by<br>\ninternal Isabelle/Scala operations. It does not address the problem of a<br>\nmissing PIDE session context for Isabelle/ML/Scala function invocations ---<br>\nthe starting point of this thread.</p>\n<p>You can probably get through with isabelle.Isabelle_Process instead of<br>\nisabelle.ML_Process: that will also take care of the System_Channel.</p>\n<p>Note that a PIDE session/protocol context does not necessarily mean PIDE<br>\ndocument model: <a href=\"http://Build.build\">Build.build</a> does a regular batch-build within that context,<br>\nwithout any Document.update.</p>\n<p>The point of the whole exercise is to have official protocol commands and<br>\nprotocol messages, instead of low-level stream communication.</p>\n<blockquote>\n<p>And one additional question: Is there a way to set the Isabelle user home?</p>\n</blockquote>\n<p>You can do it indirectly by giving an alternative ISABELLE_IDENTIFIER, e.g.<br>\nlike this on the command-line:</p>\n<p>env ISABELLE_IDENTIFIER=My_Great_App_for_Isabelle2021<br>\nIsabelle2011/bin/isabelle getenv ISABELLE_HOME_USER<br>\nISABELLE_HOME_USER=/home/makarius/.isabelle/My_Great_App_for_Isabelle2021</p>\n<p>That environment needs to be present for Isabelle_System.init().</p>\n<blockquote>\n<p>One more question: I am passing the session root directories both to<br>\nSessions.load_structure and to Build.build_logic. I am worried that this means<br>\nthat the time-intensive scan of the session directories (especially if AFP is<br>\nloaded) happens twice. Is that correct? Can it be avoided?</p>\n</blockquote>\n<p>Sessions.load_structure alone is not very expensive: it merely traverses all<br>\nROOT files. This takes approx. 0.1s for Isabelle + AFP, after the first run of<br>\napprox. 0.3s.</p>\n<p>Build.build_logic does a rather expensive up-to-date check of the specified<br>\nlogic image (not other sessions). E.g. 1s for HOL, 3s for HOL-Analysis.</p>\n<p>The standard approach is to do it only once on application startup. (Existing<br>\n\"isabelle process\" or ML_Process(), Isabelle_Process() don't do a build either.)</p>\n<p>Makarius</p>",
        "id": 229291790,
        "sender_full_name": "Email Gateway",
        "timestamp": 1615207290
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>thanks for your feedback.</p>\n<p>The issues about invoking .init() are covered in my specific context <br>\nbecause the code fragment I wrote to you will be invoked only once <br>\n(global instance). And I am aware that Array[...] is a somewhat <br>\nun-Scala-like datastructure. The reason is again very specific to my <br>\napplication: Due to the fact that my library cannot guarantee that it <br>\nwill be invoked under the same Scala version as Isabelle is compiled <br>\nfor, I have to do some classloader trickery. The effect is that the <br>\nsignature of the wrapper method I use needs to use pure Java. (I can <br>\nprovide more details on that trick if desired.) Concerning <br>\nisabelle.File.path – I was prepared to do some manual conversion to <br>\ncygwin paths, but having a method that already takes care of this, great! :)</p>\n<blockquote>\n<p>Anyway, the above would merely replace the external \"isabelle <br>\nprocess\" by internal Isabelle/Scala operations. It does not address the <br>\nproblem of a missing PIDE session context for Isabelle/ML/Scala function <br>\ninvocations --- the starting point of this thread.</p>\n</blockquote>\n<p>True. Further transition is planned for the future, but time constraints <br>\nforce me to stick to this approach for now, at least. Is the ML_Process <br>\nclass that I am using planned to be discontinued soon?</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 230685253,
        "sender_full_name": "Email Gateway",
        "timestamp": 1615985947
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nScala certainly has its own problems concerning jar non-portability.</p>\n<p>My complaint of the data structure was actually about current Java practice.<br>\nStarting with Java 8, it has become a mostly functional/immutable environment;<br>\nthis trend has continued with Java 11 LTS, and Java 17 LTS (end of 2021) will<br>\ngo even further.</p>\n<p>Thus the speed of Java development has outpaced Scala in recent years.</p>\n<p>Makarius</p>",
        "id": 230698869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1615991247
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nNo, it remains the official way to start a low-level ML process from<br>\nIsabelle/Scala.</p>\n<p>The very point of the whole affair is that the process alone will no longer<br>\nsuffice to run Isabelle sessions, because more and more Isabelle/Scala/ML<br>\nfunctions are coming.</p>\n<p>A recent example is for remote ATPs in Sledgehammer:<br>\n<a href=\"https://isabelle-dev.sketis.net/phame/post/view/35/remote_provers_from_systemontptp_via_isabelle_scala\">https://isabelle-dev.sketis.net/phame/post/view/35/remote_provers_from_systemontptp_via_isabelle_scala</a></p>\n<p>Other examples: add-on file-system operations (Isabelle_System.rm_tree).<br>\nPotentially also SHA1.digest: instead of a low-level C module for Poly/ML it<br>\nmight be better to have a high-level Scala function.</p>\n<p>Makarius</p>",
        "id": 230704756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1615993427
    }
]