[
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nHello,</p>\n<p>suppose I have a locale foo_on that assumes that some predicate P holds <br>\non a carrier set A. Often, one wants to specialise this to a locale foo <br>\nwhere A is the UNIV. The problem is that theorems in foo_on often have <br>\nassumptions of the form \"X ⊆ A\" which are \"X ⊆ UNIV\" in the context of <br>\nfoo. Those assumptions are trivial so I want to get rid of them using <br>\nrewrites but this doesn't seem to work as the example below shows:</p>\n<p>axiomatization P :: \"'a ⇒ bool\"</p>\n<p>locale foo =<br>\n   fixes A :: \"'a set\"<br>\nbegin</p>\n<p>lemma bar: \"X ⊆ A ⟹ P X\"<br>\n   sorry</p>\n<p>end</p>\n<p>locale bar<br>\nbegin</p>\n<p>(* (True ==&gt; Q) ≡ Trueprop Q works for the theorem bar but not for theorems with multiple assumptions. *)<br>\nsublocale foo UNIV rewrites \"Y ⊆ UNIV ≡ True\" and \"(True ⟹ PROP Q) ≡ PROP Q\"<br>\n   by auto</p>\n<p>end</p>\n<p>What is going wrong here?</p>\n<p>Cheers,</p>\n<p>Lukas</p>",
        "id": 225296655,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612530962
    },
    {
        "content": "<p>From: \"YAMADA, Akihisa\" &lt;<a href=\"mailto:ayamada@trs.cm.is.nagoya-u.ac.jp\">ayamada@trs.cm.is.nagoya-u.ac.jp</a>&gt;<br>\nHello Lukas,</p>\n<p>I had the same question before but it was not concluded. As a <br>\nworkaround, I'm declaring the two rewrites and it works for any number <br>\nof assumptions.</p>\n<p>\"⋀Q. (True ⟹ PROP Q) ≡ Q\" and \"⋀Q. (True ⟹ Q) ≡ Trueprop Q\"</p>\n<p>Best regards,<br>\nAkihisa</p>",
        "id": 225441476,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612665489
    },
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nThat does not seem to work. See the example below:</p>\n<p>theory Scratch imports Main<br>\nbegin</p>\n<p>axiomatization P :: \"'a ⇒ bool\"<br>\naxiomatization Z :: \"'a ⇒ bool\"</p>\n<p>locale foo =<br>\n   fixes A :: \"'a set\"<br>\nbegin</p>\n<p>lemma bar: \"X ⊆ A ⟹ Z A  ⟹ P X\"<br>\n   sorry</p>\n<p>end</p>\n<p>locale bar<br>\nbegin</p>\n<p>sublocale foo UNIV<br>\n   rewrites \"Y ⊆ UNIV ≡ True\" and \"⋀Q. (True ⟹ PROP Q) ≡ Q\" and \"⋀Q. (True ⟹ Q) ≡ Trueprop Q\"<br>\n   by auto</p>\n<p>(* ⟦True; Z UNIV⟧ ⟹ P ?X<br>\n      instead of<br>\n    Z UNIV ⟹ P ?X *)<br>\nthm bar<br>\nend</p>\n<p>end</p>",
        "id": 225527050,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612781412
    },
    {
        "content": "<p>From: \"YAMADA, Akihisa\" &lt;<a href=\"mailto:ayamada@trs.cm.is.nagoya-u.ac.jp\">ayamada@trs.cm.is.nagoya-u.ac.jp</a>&gt;<br>\nDear Lukas,</p>\n<p>sorry indeed, the trick works only if you put trivial assumptions after <br>\nnontrivial ones like:</p>\n<p>lemma bar2: \"Z A ⟹ X ⊆ A ⟹ P X\"</p>\n<p>If you don't want to swap assumptions, I only know a terribly naive <br>\nworkaround to add such rewrites like<br>\n   \"⋀P1 P2. (True ⟹ PROP P1 ⟹ PROP P2) ≡ (PROP P1 ⟹ PROP P2)\"<br>\nas many as you need.</p>\n<p>Best,<br>\nAkihisa</p>",
        "id": 225533842,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612785724
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Lukas Stevens and Akihisa Yamada/All,</p>\n<p>I would like to make a side remark with regard to the discussion and ask a<br>\ncouple of related questions to the developers/maintainers of Isabelle.</p>\n<hr>\n<p>While I am also not certain whether and how one could construct a rewrite<br>\nsystem capable of coping with the problem outlined by Lukas Stevens<br>\n(although it seems like the application of the attribute \"simplified\" with<br>\nthe default simpset can remove \"True\" in most cases, so it may be worth<br>\ntrying to understand the principle employed), there is little that could<br>\nstop one from batch-processing the theorems after the locale<br>\ninterpretation: see the code listing in the appendix. Potentially, one can<br>\neven override the theorems that were produced during the interpretation in<br>\nthis manner. However, keep in mind that the code is merely a very rough<br>\nsketch of the idea, not a working implementation (e.g. one would need to<br>\nconsider how to propagate the effects of the attributes that were applied<br>\nto the original theorems and several other issues).</p>\n<hr>\n<p>In this context, I would like to ask two questions to the developers of<br>\nIsabelle:</p>\n<ol>\n<li>\n<p>I am curious as to what exactly is preventing from allowing users to<br>\nprovide more general/arbitrary theorem transformations during the locale<br>\ninterpretation, instead of plain rewriting.</p>\n</li>\n<li>\n<p>I am curious if there is a way to allow for an application of a given<br>\npredefined rewrite system repeatedly to different distinct interpretations.<br>\nFor example, if one was to develop a rewrite system for eliminating \"True\"<br>\nfrom theorems, it would be useful to allow for its repeated application<br>\nwithout code duplication. However, at the moment, it seems like one would<br>\nhave to restate the relevant terms explicitly for every interpretation<br>\n(unless I am mistaken, and there already exists an implementation of this<br>\nfunctionality).</p>\n</li>\n</ol>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>theory Scratch<br>\n  imports Main<br>\n  keywords \"attributes_for_qual\" :: thy_defn<br>\nbegin</p>\n<p>ML‹</p>\n<p>(*copied with amendments from the file Proof_Context.ML<br>\nin the main distribution of Isabelle2021-RC2*)<br>\nfun get_local_facts verbose ctxt =<br>\n  let<br>\n    val facts = Proof_Context.facts_of ctxt<br>\n    val props = map #1 (Facts.props facts)<br>\n    val local_facts =<br>\n      (if null props then [] else [(\"&lt;unnamed&gt;\", props)]) @<br>\n        Facts.dest_static<br>\n          verbose [Global_Theory.facts_of (Proof_Context.theory_of ctxt)]<br>\nfacts<br>\n  in local_facts end;</p>\n<p>fun append_local c = \"local.\" ^ c ^ \".\";<br>\nfun remove_local c = String.extract (c, 6, NONE);</p>\n<p>fun prep_attrb_facts ctxt attrbs (b, thms)  =<br>\n  let<br>\n    val facts' =<br>\n      ((b, attrbs) ||&gt; map (Attrib.check_src ctxt), single (thms, []))<br>\n      |&gt; single<br>\n      |&gt; Attrib.partial_evaluation ctxt<br>\n  in facts' end;</p>\n<p>fun process_simplify (qualc, attrbs) ctxt =<br>\n  let<br>\n    val mk_name = remove_local<br>\n      #&gt; curry (swap #&gt; op^) \"'\"<br>\n      #&gt; Binding.qualified_name<br>\n    val thmss = get_local_facts false ctxt<br>\n      |&gt; filter (fn (c, _) =&gt; String.isPrefix (append_local qualc) c)<br>\n      |&gt; map (apfst mk_name)<br>\n    val factss = thmss |&gt; map (prep_attrb_facts ctxt attrbs)<br>\n  in fold (curry (uncurry Local_Theory.notes #&gt; snd)) factss ctxt end;</p>\n<p>val _ = Outer_Syntax.local_theory<br>\n  \\&lt;^command_keyword&gt;‹attributes_for_qual›<br>\n    \"apply attributes to a set of theorems in the local context\"<br>\n  (Parse.string -- Parse.attribs &gt;&gt; process_simplify);</p>\n<p>›</p>\n<p>axiomatization P :: \"'a ⇒ bool\"<br>\naxiomatization Z :: \"'a ⇒ bool\"</p>\n<p>locale foo =<br>\n  fixes A :: \"'a set\"<br>\nbegin</p>\n<p>lemma bar: \"X ⊆ A ⟹ Z A ⟹ P X\"<br>\n  sorry</p>\n<p>end</p>\n<p>locale bar<br>\nbegin</p>\n<p>sublocale foo: foo UNIV<br>\n  rewrites \"Y ⊆ UNIV ≡ True\"<br>\n    and \"⋀Q. (True ⟹ PROP Q) ≡ Q\"<br>\n    and \"⋀Q. (True ⟹ Q) ≡ Trueprop Q\"<br>\n  by auto</p>\n<p>attributes_for_qual \"foo\" [simplified]</p>\n<p>thm <a href=\"http://foo.bar\">foo.bar</a>'</p>\n<p>end</p>\n<p>end</p>",
        "id": 225596373,
        "sender_full_name": "Email Gateway",
        "timestamp": 1612813115
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nThanks for sharing these observations.</p>\n<p>Rewrite morphisms are based on Pattern.rewrite_term. This is for <br>\nefficiency and robustness (morphisms are composed along the locale <br>\nhierarchy). That rewrite morphisms can be used to delete certain <br>\nassumptions could be considered a lucky coincident. They are not <br>\nintended to be used that way.</p>\n<p>Clemens</p>",
        "id": 226254771,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613235187
    },
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nYou can achieve the desired behaviour by adding a premise swapping rule:</p>\n<p>rewrites \"⋀P. (True ⟹ P) ≡ Trueprop P\"<br>\n             and \"⋀P Q. (True ⟹ PROP P ⟹ PROP Q) ≡ (PROP P ⟹ True ⟹ PROP Q)\"</p>\n<p>Since the rewrite mechanism is not intended to be used that way, would <br>\nyou recommend against it? What would be an alternative?</p>\n<p>Cheers,</p>\n<p>Lukas</p>",
        "id": 226497099,
        "sender_full_name": "Email Gateway",
        "timestamp": 1613471770
    }
]