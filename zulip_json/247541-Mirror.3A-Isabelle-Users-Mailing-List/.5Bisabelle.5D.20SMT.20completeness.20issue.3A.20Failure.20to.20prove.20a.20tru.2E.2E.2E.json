[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nHello,</p>\n<p>yesterday I had a proof obligation that boils down to a LIRA problem <br>\n(linear integer/real arithmetic). Usually \"linarith\" can solve these <br>\njust fine, but in this case it couldn't (at least not in a single step), <br>\nbut I know \"linarith\" is incomplete for mixed integer/real problems. I <br>\nthen turned to the \"smt\" method instead and to my surprise found that it <br>\ncouldn't do it either.</p>\n<p>I boiled it down to the following minimal example:</p>\n<p>lemma<br>\n   assumes \"0 ≤ x\" \"x ≤ 1 / 2\" \"x ≤ real_of_int m\" \"real_of_int m ≤ x + <br>\n1 / 2\"<br>\n   shows   \"real_of_int m = 2 * x\"<br>\nproof -<br>\n   have \"m = 0 ∨ m = 1\"<br>\n     using assms by linarith<br>\n   thus ?thesis<br>\n     using assms by linarith<br>\nqed</p>\n<p>As you can see, it's a LIRA problem, it's a true statement, and <br>\n\"linarith\" can solve it in two steps.</p>\n<p>However, \"apply smt\", \"apply (smt (cvc5))\" and \"apply (smt (z3))\" all <br>\nfail, and Z3 even claims there's a (possibly spurious) counterexample.</p>\n<p>Looking at the generated smtlib problem, I found to my surprise that <br>\nboth the division on the reals and the type conversion \"real_of_int\" are <br>\ntranslated to uninterpreted functions, so it's not surprising that the <br>\nSMT solvers fail to prove it. It's easy to get rid of the division, of <br>\ncourse, but that doesn't make it work either (presumable because the <br>\n\"of_int\" UF is still there).</p>\n<p>I would have expected an encoding like the following:</p>\n<p>(set-logic AUFLIRA)<br>\n(set-option :produce-proofs true)<br>\n(declare-fun x () Real)<br>\n(declare-fun m () Int)<br>\n(assert (and (&lt;= 0 x)  (&lt;= x (/ 1 2))  (&lt;= x m)  (&lt;= m (+ x (/ 1 2)))))<br>\n(assert (not (= m (* 2 x))))<br>\n(check-sat)<br>\n(get-proof)</p>\n<p>Both CVC5 and Z3 can do this and produce proofs.</p>\n<p>So, is this some known limitation of the smt method? Is there some <br>\nunresolved difficulty in replaying LIRA proofs?</p>\n<p>Manuel</p>",
        "id": 511668192,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744382294
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@ifi.lmu.de\">jasmin.blanchette@ifi.lmu.de</a>&gt;<br>\nHi Manuel,</p>\n<p>SMT was developed by Sascha Böhme, so I'm only partly qualified to answer.</p>\n<p>The fragment SMT solvers can decide is linear. Some SMT solvers also support division and have nonlinear solvers, but these are very slow. As a result, native division is not used, even when it's between constants like 1 and 2, apparently.</p>\n<p>As for \"real_of_int\", the uninterpreted symbol is definitely suboptimal. I'm not sure it's safe to just omit it everywhere and rely on implicit cast or subtyping. SMT-LIB seems to support overloading, so this is all rather scary.</p>\n<p>In \"smt_real.ML\", I'm seeing code like this:</p>\n<p>fun abstract abs t =<br>\n  (case t of<br>\n    (c as \\&lt;^term&gt;\\&lt;open&gt;Rings.divide :: real =&gt; _\\&lt;close&gt;) $ t1 $ t2 =&gt;<br>\n      abs t1 ##&gt;&gt; abs t2 #&gt;&gt; (fn (u1, u2) =&gt; SOME (c $ u1 $ u2))<br>\n  | (c as \\&lt;^term&gt;\\&lt;open&gt;Int.of_int :: int =&gt; _\\&lt;close&gt;) $ t =&gt;<br>\n      abs t #&gt;&gt; (fn u =&gt; SOME (c $ u))<br>\n  | _ =&gt; pair NONE)</p>\n<p>It seems to want to do something about division and Int.of_int, but maybe this setup is somehow bit-rotten or insufficient.</p>\n<p>I'm CC:ing Martin. Maybe he and I could look into both issues together, if he has time.</p>\n<p>Best,<br>\nJasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 11. Apr 2025, at 16:29, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Hello,</p>\n<p>yesterday I had a proof obligation that boils down to a LIRA problem (linear integer/real arithmetic). Usually \"linarith\" can solve these just fine, but in this case it couldn't (at least not in a single step), but I know \"linarith\" is incomplete for mixed integer/real problems. I then turned to the \"smt\" method instead and to my surprise found that it couldn't do it either.</p>\n<p>I boiled it down to the following minimal example:</p>\n<p>lemma<br>\n  assumes \"0 ≤ x\" \"x ≤ 1 / 2\" \"x ≤ real_of_int m\" \"real_of_int m ≤ x + 1 / 2\"<br>\n  shows   \"real_of_int m = 2 * x\"<br>\nproof -<br>\n  have \"m = 0 ∨ m = 1\"<br>\n    using assms by linarith<br>\n  thus ?thesis<br>\n    using assms by linarith<br>\nqed</p>\n<p>As you can see, it's a LIRA problem, it's a true statement, and \"linarith\" can solve it in two steps.</p>\n<p>However, \"apply smt\", \"apply (smt (cvc5))\" and \"apply (smt (z3))\" all fail, and Z3 even claims there's a (possibly spurious) counterexample.</p>\n<p>Looking at the generated smtlib problem, I found to my surprise that both the division on the reals and the type conversion \"real_of_int\" are translated to uninterpreted functions, so it's not surprising that the SMT solvers fail to prove it. It's easy to get rid of the division, of course, but that doesn't make it work either (presumable because the \"of_int\" UF is still there).</p>\n<p>I would have expected an encoding like the following:</p>\n<p>(set-logic AUFLIRA)<br>\n(set-option :produce-proofs true)<br>\n(declare-fun x () Real)<br>\n(declare-fun m () Int)<br>\n(assert (and (&lt;= 0 x)  (&lt;= x (/ 1 2))  (&lt;= x m)  (&lt;= m (+ x (/ 1 2)))))<br>\n(assert (not (= m (* 2 x))))<br>\n(check-sat)<br>\n(get-proof)</p>\n<p>Both CVC5 and Z3 can do this and produce proofs.</p>\n<p>So, is this some known limitation of the smt method? Is there some unresolved difficulty in replaying LIRA proofs?</p>\n<p>Manuel</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/46X-Pdmyz4kJE5vPRsQEPfWK/smime.p7s\">smime.p7s</a></p>",
        "id": 511779890,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744436869
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi Jasmin, Manuel and all,</p>\n<p>On 4/12/25 07:47, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>Hi Manuel,</p>\n<p>SMT was developed by Sascha Böhme, so I'm only partly qualified to answer.</p>\n<p>The fragment SMT solvers can decide is linear. Some SMT solvers also <br>\nsupport division and have nonlinear solvers, but these are very slow. <br>\nAs a result, native division is not used, even when it's between <br>\nconstants like 1 and 2, apparently.</p>\n</blockquote>\n<p>Getting the divide operator translated is easy to add actually.</p>\n<blockquote>\n<p>As for \"real_of_int\", the uninterpreted symbol is definitely <br>\nsuboptimal. I'm not sure it's safe to just omit it everywhere and rely <br>\non implicit cast or subtyping. SMT-LIB seems to support overloading, <br>\nso this is all rather scary.</p>\n</blockquote>\n<p>My understanding is that you cannot omit it due to equality requiring to <br>\nvariables of the same sort. But SMT-Lib has the constant <code>to_real</code> for <br>\ncasting. Some SMT solvers allow it.</p>\n<blockquote>\n<p>In \"smt_real.ML\", I'm seeing code like this:</p>\n<p>fun abstract abs t =<br>\n  (case t of<br>\n    (c as \\&lt;^term&gt;\\&lt;open&gt;Rings.divide :: real =&gt; _\\&lt;close&gt;) $ t1 $ t2 =&gt;<br>\n      abs t1 ##&gt;&gt; abs t2 #&gt;&gt; (fn (u1, u2) =&gt; SOME (c $ u1 $ u2))<br>\n  | (c as \\&lt;^term&gt;\\&lt;open&gt;Int.of_int :: int =&gt; _\\&lt;close&gt;) $ t =&gt;<br>\n      abs t #&gt;&gt; (fn u =&gt; SOME (c $ u))<br>\n  | _ =&gt; pair NONE)</p>\n<p>It seems to want to do something about division and Int.of_int, but <br>\nmaybe this setup is somehow bit-rotten or insufficient.</p>\n</blockquote>\n<p>That code is to abstract over division to stay in the LIRA fragment, <br>\ne.g., if you have <code>a = 1 / b</code> then you need to get rid of the <code>1/b</code>.</p>\n<p>The better solution is to add a translation of division:</p>\n<p>fun mk_divides ts = Term.list_comb (\\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, ts)<br>\n   fun divides _ _ (ts as [a,b]) =<br>\n      if SMT_Util.is_number a andalso SMT_Util.is_number b<br>\n      then SOME (\"/\", 2, ts, mk_divides) else NONE<br>\n     | divides _ _ _ = NONE</p>\n<p>val setup_builtins =<br>\n   (*the current things followed by *) #&gt;<br>\n   SMT_Builtin.add_builtin_fun SMTLIB_Interface.smtlibC<br>\n     (Term.dest_Const \\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, divides) #&gt;<br>\n   fold (SMT_Builtin.add_builtin_fun' SMTLIB_Interface.smtlibC)<br>\n     [(\\&lt;^Const&gt;‹of_int \\&lt;^Type&gt;‹real››, \"to_real\"),<br>\n      (\\&lt;^Const&gt;‹of_nat \\&lt;^Type&gt;‹real››, \"to_real\")]</p>\n<p>Division seems to work but the <code>to_real</code> currently breaks the <br>\nreconstruction of proofs: on the Isabelle side, <code>of_int</code> is ambiguous <br>\nwithout looking at the rest of the term. I will look into it.</p>\n<blockquote>\n<p>I'm CC:ing Martin. Maybe he and I could look into both issues <br>\ntogether, if he has time.</p>\n</blockquote>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at that <br>\ncode (for the BV translation -- even if our changes are all out of <br>\ntree). But feel free to do looking into it with Martin if you prefer.</p>\n<p>Mathias</p>\n<blockquote>\n<p>Best,<br>\nJasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 11. Apr 2025, at 16:29, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Hello,</p>\n<p>yesterday I had a proof obligation that boils down to a LIRA problem <br>\n(linear integer/real arithmetic). Usually \"linarith\" can solve these <br>\njust fine, but in this case it couldn't (at least not in a single <br>\nstep), but I know \"linarith\" is incomplete for mixed integer/real <br>\nproblems. I then turned to the \"smt\" method instead and to my <br>\nsurprise found that it couldn't do it either.</p>\n<p>I boiled it down to the following minimal example:</p>\n<p>lemma<br>\n  assumes \"0 ≤ x\" \"x ≤ 1 / 2\" \"x ≤ real_of_int m\" \"real_of_int m ≤ x <br>\n+ 1 / 2\"<br>\n  shows   \"real_of_int m = 2 * x\"<br>\nproof -<br>\n  have \"m = 0 ∨ m = 1\"<br>\n    using assms by linarith<br>\n  thus ?thesis<br>\n    using assms by linarith<br>\nqed</p>\n<p>As you can see, it's a LIRA problem, it's a true statement, and <br>\n\"linarith\" can solve it in two steps.</p>\n<p>However, \"apply smt\", \"apply (smt (cvc5))\" and \"apply (smt (z3))\" all <br>\nfail, and Z3 even claims there's a (possibly spurious) counterexample.</p>\n<p>Looking at the generated smtlib problem, I found to my surprise that <br>\nboth the division on the reals and the type conversion \"real_of_int\" <br>\nare translated to uninterpreted functions, so it's not surprising <br>\nthat the SMT solvers fail to prove it. It's easy to get rid of the <br>\ndivision, of course, but that doesn't make it work either (presumable <br>\nbecause the \"of_int\" UF is still there).</p>\n<p>I would have expected an encoding like the following:</p>\n<p>(set-logic AUFLIRA)<br>\n(set-option :produce-proofs true)<br>\n(declare-fun x () Real)<br>\n(declare-fun m () Int)<br>\n(assert (and (&lt;= 0 x)  (&lt;= x (/ 1 2))  (&lt;= x m)  (&lt;= m (+ x (/ 1 2)))))<br>\n(assert (not (= m (* 2 x))))<br>\n(check-sat)<br>\n(get-proof)</p>\n<p>Both CVC5 and Z3 can do this and produce proofs.</p>\n<p>So, is this some known limitation of the smt method? Is there some <br>\nunresolved difficulty in replaying LIRA proofs?</p>\n<p>Manuel</p>\n</blockquote>\n</blockquote>",
        "id": 511783219,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744439671
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@ifi.lmu.de\">jasmin.blanchette@ifi.lmu.de</a>&gt;<br>\nHi Mathias,</p>\n<blockquote>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at that code (for the BV translation -- even if our changes are all out of tree). But feel free to do looking into it with Martin if you prefer. </p>\n<p>By all means, you go ahead! Thank you so much. I knew you worked on reconstruction, but I didn't realize you had such extensive knowledge of the translation.</p>\n</blockquote>\n<p>Best,<br>\nJasmin<br>\n--</p>\n<p>Prof. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 12. Apr 2025, at 08:34, Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt; wrote:</p>\n<p>Hi Jasmin, Manuel and all,</p>\n<p>On 4/12/25 07:47, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>Hi Manuel,</p>\n<p>SMT was developed by Sascha Böhme, so I'm only partly qualified to answer.</p>\n<p>The fragment SMT solvers can decide is linear. Some SMT solvers also support division and have nonlinear solvers, but these are very slow. As a result, native division is not used, even when it's between constants like 1 and 2, apparently.<br>\nGetting the divide operator translated is easy to add actually.</p>\n</blockquote>\n<blockquote>\n<p>As for \"real_of_int\", the uninterpreted symbol is definitely suboptimal. I'm not sure it's safe to just omit it everywhere and rely on implicit cast or subtyping. SMT-LIB seems to support overloading, so this is all rather scary.<br>\nMy understanding is that you cannot omit it due to equality requiring to variables of the same sort. But SMT-Lib has the constant <code>to_real</code> for casting. Some SMT solvers allow it.</p>\n</blockquote>\n<blockquote>\n<p>In \"smt_real.ML\", I'm seeing code like this:</p>\n<p>fun abstract abs t =<br>\n  (case t of<br>\n    (c as \\&lt;^term&gt;\\&lt;open&gt;Rings.divide :: real =&gt; _\\&lt;close&gt;) $ t1 $ t2 =&gt;<br>\n      abs t1 ##&gt;&gt; abs t2 #&gt;&gt; (fn (u1, u2) =&gt; SOME (c $ u1 $ u2))<br>\n  | (c as \\&lt;^term&gt;\\&lt;open&gt;Int.of_int :: int =&gt; _\\&lt;close&gt;) $ t =&gt;<br>\n      abs t #&gt;&gt; (fn u =&gt; SOME (c $ u))<br>\n  | _ =&gt; pair NONE)</p>\n<p>It seems to want to do something about division and Int.of_int, but maybe this setup is somehow bit-rotten or insufficient.</p>\n</blockquote>\n<p>That code is to abstract over division to stay in the LIRA fragment, e.g., if you have <code>a = 1 / b</code> then you need to get rid of the <code>1/b</code>.</p>\n<p>The better solution is to add a translation of division:</p>\n<p>fun mk_divides ts = Term.list_comb (\\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, ts)<br>\n  fun divides _ _ (ts as [a,b]) = <br>\n     if SMT_Util.is_number a andalso SMT_Util.is_number b<br>\n     then SOME (\"/\", 2, ts, mk_divides) else NONE<br>\n    | divides _ _ _ = NONE</p>\n<p>val setup_builtins =<br>\n  (*the current things followed by *) #&gt;<br>\n  SMT_Builtin.add_builtin_fun SMTLIB_Interface.smtlibC<br>\n    (Term.dest_Const \\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, divides) #&gt;<br>\n  fold (SMT_Builtin.add_builtin_fun' SMTLIB_Interface.smtlibC)<br>\n    [(\\&lt;^Const&gt;‹of_int \\&lt;^Type&gt;‹real››, \"to_real\"),<br>\n     (\\&lt;^Const&gt;‹of_nat \\&lt;^Type&gt;‹real››, \"to_real\")]</p>\n<p>Division seems to work but the <code>to_real</code> currently breaks the reconstruction of proofs: on the Isabelle side, <code>of_int</code> is ambiguous without looking at the rest of the term. I will look into it.</p>\n<blockquote>\n<p>I'm CC:ing Martin. Maybe he and I could look into both issues together, if he has time.</p>\n</blockquote>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at that code (for the BV translation -- even if our changes are all out of tree). But feel free to do looking into it with Martin if you prefer. </p>\n<p>Mathias</p>\n<blockquote>\n<p>Best,<br>\nJasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 11. Apr 2025, at 16:29, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; &lt;mailto:<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Hello,</p>\n<p>yesterday I had a proof obligation that boils down to a LIRA problem (linear integer/real arithmetic). Usually \"linarith\" can solve these just fine, but in this case it couldn't (at least not in a single step), but I know \"linarith\" is incomplete for mixed integer/real problems. I then turned to the \"smt\" method instead and to my surprise found that it couldn't do it either.</p>\n<p>I boiled it down to the following minimal example:</p>\n<p>lemma<br>\n  assumes \"0 ≤ x\" \"x ≤ 1 / 2\" \"x ≤ real_of_int m\" \"real_of_int m ≤ x + 1 / 2\"<br>\n  shows   \"real_of_int m = 2 * x\"<br>\nproof -<br>\n  have \"m = 0 ∨ m = 1\"<br>\n    using assms by linarith<br>\n  thus ?thesis<br>\n    using assms by linarith<br>\nqed</p>\n<p>As you can see, it's a LIRA problem, it's a true statement, and \"linarith\" can solve it in two steps.</p>\n<p>However, \"apply smt\", \"apply (smt (cvc5))\" and \"apply (smt (z3))\" all fail, and Z3 even claims there's a (possibly spurious) counterexample.</p>\n<p>Looking at the generated smtlib problem, I found to my surprise that both the division on the reals and the type conversion \"real_of_int\" are translated to uninterpreted functions, so it's not surprising that the SMT solvers fail to prove it. It's easy to get rid of the division, of course, but that doesn't make it work either (presumable because the \"of_int\" UF is still there).</p>\n<p>I would have expected an encoding like the following:</p>\n<p>(set-logic AUFLIRA)<br>\n(set-option :produce-proofs true)<br>\n(declare-fun x () Real)<br>\n(declare-fun m () Int)<br>\n(assert (and (&lt;= 0 x)  (&lt;= x (/ 1 2))  (&lt;= x m)  (&lt;= m (+ x (/ 1 2)))))<br>\n(assert (not (= m (* 2 x))))<br>\n(check-sat)<br>\n(get-proof)</p>\n<p>Both CVC5 and Z3 can do this and produce proofs.</p>\n<p>So, is this some known limitation of the smt method? Is there some unresolved difficulty in replaying LIRA proofs?</p>\n<p>Manuel</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/iOzOj4KvyEXhImb6MyHnDyDc/smime.p7s\">smime.p7s</a></p>",
        "id": 511783516,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744439956
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nHello,</p>\n<p>thanks for the answers! The problem is not the least bit urgent for me, <br>\nso I don't really have much of a stake in this. I just wanted to know <br>\nwhether this was a known issue or not, and see if someone is interested <br>\nin fixing it.</p>\n<p>So if you have the time and energy to do this, that's great – but no <br>\npressure (at least not from me. :) ).</p>\n<p>I didn't know equality between integers and reals was a problem in SMT. <br>\nI do know that Nelson–Oppen doesn't like things like that, but I don't <br>\nknow enough about the internals of SMT solvers to understand whether it <br>\nis an issue, and I expected SMT solvers to just \"abstract away\" from <br>\nthis if need be and insert coercions like \"to_real\" in a preprocessing <br>\nstep. I mean, my smtlib problem went through just fine without any <br>\nerrors or warnings, and I even got a proof (although I don't understand <br>\nenough about SMT proof objects to be able to see whether it is actually <br>\na proof that makes sense and proves what I want).</p>\n<p>Manuel</p>\n<p>On 12/04/2025 08:38, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>Hi Mathias,</p>\n<blockquote>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at <br>\nthat code (for the BV translation -- even if our changes are all out <br>\nof tree). But feel free to do looking into it with Martin if you prefer.</p>\n<p>By all means, you go ahead! Thank you so much. I knew you worked on <br>\nreconstruction, but I didn't realize you had such extensive knowledge <br>\nof the translation.</p>\n</blockquote>\n<p>Best,<br>\nJasmin</p>\n<p>--</p>\n<p>Prof. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 12. Apr 2025, at 08:34, Mathias Fleury <br>\n&lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt; wrote:</p>\n<p>Hi Jasmin, Manuel and all,</p>\n<p>On 4/12/25 07:47, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>Hi Manuel,</p>\n<p>SMT was developed by Sascha Böhme, so I'm only partly qualified to <br>\nanswer.</p>\n<p>The fragment SMT solvers can decide is linear. Some SMT solvers also <br>\nsupport division and have nonlinear solvers, but these are very <br>\nslow. As a result, native division is not used, even when it's <br>\nbetween constants like 1 and 2, apparently.</p>\n</blockquote>\n<p>Getting the divide operator translated is easy to add actually.</p>\n<blockquote>\n<p>As for \"real_of_int\", the uninterpreted symbol is definitely <br>\nsuboptimal. I'm not sure it's safe to just omit it everywhere and <br>\nrely on implicit cast or subtyping. SMT-LIB seems to support <br>\noverloading, so this is all rather scary.</p>\n</blockquote>\n<p>My understanding is that you cannot omit it due to equality requiring <br>\nto variables of the same sort. But SMT-Lib has the constant <code>to_real</code> <br>\nfor casting. Some SMT solvers allow it.</p>\n<blockquote>\n<p>In \"smt_real.ML\", I'm seeing code like this:</p>\n<p>fun abstract abs t =<br>\n  (case t of<br>\n    (c as \\&lt;^term&gt;\\&lt;open&gt;Rings.divide :: real =&gt; _\\&lt;close&gt;) $ t1 $ t2 =&gt;<br>\n      abs t1 ##&gt;&gt; abs t2 #&gt;&gt; (fn (u1, u2) =&gt; SOME (c $ u1 $ u2))<br>\n  | (c as \\&lt;^term&gt;\\&lt;open&gt;Int.of_int :: int =&gt; _\\&lt;close&gt;) $ t =&gt;<br>\n      abs t #&gt;&gt; (fn u =&gt; SOME (c $ u))<br>\n  | _ =&gt; pair NONE)</p>\n<p>It seems to want to do something about division and Int.of_int, but <br>\nmaybe this setup is somehow bit-rotten or insufficient.</p>\n</blockquote>\n<p>That code is to abstract over division to stay in the LIRA fragment, <br>\ne.g., if you have <code>a = 1 / b</code> then you need to get rid of the <code>1/b</code>.</p>\n<p>The better solution is to add a translation of division:</p>\n<p>fun mk_divides ts = Term.list_comb (\\&lt;^Const&gt;‹divide <br>\n\\&lt;^Type&gt;‹real››, ts)<br>\n  fun divides _ _ (ts as [a,b]) =<br>\n     if SMT_Util.is_number a andalso SMT_Util.is_number b<br>\n     then SOME (\"/\", 2, ts, mk_divides) else NONE<br>\n    | divides _ _ _ = NONE</p>\n<p>val setup_builtins =<br>\n  (*the current things followed by *) #&gt;<br>\n  SMT_Builtin.add_builtin_fun SMTLIB_Interface.smtlibC<br>\n    (Term.dest_Const \\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, divides) #&gt;<br>\n  fold (SMT_Builtin.add_builtin_fun' SMTLIB_Interface.smtlibC)<br>\n    [(\\&lt;^Const&gt;‹of_int \\&lt;^Type&gt;‹real››, \"to_real\"),<br>\n     (\\&lt;^Const&gt;‹of_nat \\&lt;^Type&gt;‹real››, \"to_real\")]</p>\n<p>Division seems to work but the <code>to_real</code> currently breaks the <br>\nreconstruction of proofs: on the Isabelle side, <code>of_int</code> is ambiguous <br>\nwithout looking at the rest of the term. I will look into it.</p>\n<blockquote>\n<p>I'm CC:ing Martin. Maybe he and I could look into both issues <br>\ntogether, if he has time.</p>\n</blockquote>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at <br>\nthat code (for the BV translation -- even if our changes are all out <br>\nof tree). But feel free to do looking into it with Martin if you prefer.</p>\n<p>Mathias</p>\n<blockquote>\n<p>Best,<br>\nJasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<blockquote>\n<p>On 11. Apr 2025, at 16:29, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Hello,</p>\n<p>yesterday I had a proof obligation that boils down to a LIRA <br>\nproblem (linear integer/real arithmetic). Usually \"linarith\" can <br>\nsolve these just fine, but in this case it couldn't (at least not <br>\nin a single step), but I know \"linarith\" is incomplete for mixed <br>\ninteger/real problems. I then turned to the \"smt\" method instead <br>\nand to my surprise found that it couldn't do it either.</p>\n<p>I boiled it down to the following minimal example:</p>\n<p>lemma<br>\n  assumes \"0 ≤ x\" \"x ≤ 1 / 2\" \"x ≤ real_of_int m\" \"real_of_int m ≤ <br>\nx + 1 / 2\"<br>\n  shows   \"real_of_int m = 2 * x\"<br>\nproof -<br>\n  have \"m = 0 ∨ m = 1\"<br>\n    using assms by linarith<br>\n  thus ?thesis<br>\n    using assms by linarith<br>\nqed</p>\n<p>As you can see, it's a LIRA problem, it's a true statement, and <br>\n\"linarith\" can solve it in two steps.</p>\n<p>However, \"apply smt\", \"apply (smt (cvc5))\" and \"apply (smt (z3))\" <br>\nall fail, and Z3 even claims there's a (possibly spurious) <br>\ncounterexample.</p>\n<p>Looking at the generated smtlib problem, I found to my surprise <br>\nthat both the division on the reals and the type conversion <br>\n\"real_of_int\" are translated to uninterpreted functions, so it's <br>\nnot surprising that the SMT solvers fail to prove it. It's easy to <br>\nget rid of the division, of course, but that doesn't make it work <br>\neither (presumable because the \"of_int\" UF is still there).</p>\n<p>I would have expected an encoding like the following:</p>\n<p>(set-logic AUFLIRA)<br>\n(set-option :produce-proofs true)<br>\n(declare-fun x () Real)<br>\n(declare-fun m () Int)<br>\n(assert (and (&lt;= 0 x)  (&lt;= x (/ 1 2)) (&lt;= x m)  (&lt;= m (+ x (/ 1 2)))))<br>\n(assert (not (= m (* 2 x))))<br>\n(check-sat)<br>\n(get-proof)</p>\n<p>Both CVC5 and Z3 can do this and produce proofs.</p>\n<p>So, is this some known limitation of the smt method? Is there some <br>\nunresolved difficulty in replaying LIRA proofs?</p>\n<p>Manuel</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 511812538,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744465312
    },
    {
        "content": "<p>From: Haniel Barbosa &lt;<a href=\"mailto:hbarbosa@dcc.ufmg.br\">hbarbosa@dcc.ufmg.br</a>&gt;<br>\nHello,</p>\n<p>Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; writes:</p>\n<blockquote>\n<p>I didn't know equality between integers and reals was a problem in SMT. I do know that Nelson–Oppen<br>\ndoesn't like things like that, but I don't know enough about the internals of SMT solvers to understand<br>\nwhether it is an issue, and I expected SMT solvers to just \"abstract away\" from this if need be and insert<br>\ncoercions like \"to_real\" in a preprocessing step. I mean, my smtlib problem went through just fine without<br>\nany errors or warnings, and I even got a proof (although I don't understand enough about SMT proof objects<br>\nto be able to see whether it is actually a proof that makes sense and proves what I want).</p>\n</blockquote>\n<p>To clarify this point, internally SMT solvers do overlead arithmetic<br>\noperations to mix ints and reals. They are only (generally...) strict<br>\nfor the input because SMT-LIB does not allow this overloading. And<br>\nsome can be strict for the output because otherwise it can lead to<br>\nissues with some proof checkers or reconstruction in proof assistants.</p>\n<p>As soon as the problem is parsed solvers generally do not care about<br>\nmixing these types anymore. Which makes it a pain to <em>undo</em> these<br>\nimplicit mixing if one wants to output proofs that have the explicit<br>\ncasts, which are added in post-processing. With cvc5 this is done via<br>\nthe option --proof-elim-subtypes, for example, which is not on by<br>\ndefault.</p>\n<p>Best,</p>\n<blockquote>\n<p>Manuel</p>\n<p>On 12/04/2025 08:38, Jasmin Blanchette wrote:</p>\n<p>Hi Mathias, </p>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at that code (for the BV translation --<br>\n even if our changes are all out of tree). But feel free to do looking into it with Martin if you prefer. </p>\n<p>By all means, you go ahead! Thank you so much. I knew you worked on reconstruction, but I didn't realize<br>\n you had such extensive knowledge of the translation.</p>\n<p>Best,<br>\n Jasmin</p>\n<p>--</p>\n<p>Prof. Dr. Jasmin Blanchette<br>\n Chair of Theoretical Computer Science and Theorem Proving<br>\n Ludwig-Maximilians-Universität München<br>\n Oettingenstr. 67, 80538 München, Germany<br>\n Tel.: +49 (0)89 2180 9341<br>\n Web: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<p>On 12. Apr 2025, at 08:34, Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt; wrote:</p>\n<p>Hi Jasmin, Manuel and all,</p>\n<p>On 4/12/25 07:47, Jasmin Blanchette wrote:</p>\n<p>Hi Manuel, </p>\n<p>SMT was developed by Sascha Böhme, so I'm only partly qualified to answer.</p>\n<p>The fragment SMT solvers can decide is linear. Some SMT solvers also support division and have<br>\n nonlinear solvers, but these are very slow. As a result, native division is not used, even when it's<br>\n between constants like 1 and 2, apparently.</p>\n<p>Getting the divide operator translated is easy to add actually.</p>\n<p>As for \"real_of_int\", the uninterpreted symbol is definitely suboptimal. I'm not sure it's safe to just<br>\n omit it everywhere and rely on implicit cast or subtyping. SMT-LIB seems to support overloading,<br>\n so this is all rather scary.</p>\n<p>My understanding is that you cannot omit it due to equality requiring to variables of the same sort.<br>\n But SMT-Lib has the constant <code>to_real</code> for casting. Some SMT solvers allow it.</p>\n<p>In \"smt_real.ML\", I'm seeing code like this:</p>\n<p>fun abstract abs t =<br>\n   (case t of<br>\n     (c as \\&lt;^term&gt;\\&lt;open&gt;Rings.divide :: real =&gt; _\\&lt;close&gt;) $ t1 $ t2 =&gt;<br>\n       abs t1 ##&gt;&gt; abs t2 #&gt;&gt; (fn (u1, u2) =&gt; SOME (c $ u1 $ u2))<br>\n   | (c as \\&lt;^term&gt;\\&lt;open&gt;Int.of_int :: int =&gt; _\\&lt;close&gt;) $ t =&gt;<br>\n       abs t #&gt;&gt; (fn u =&gt; SOME (c $ u))<br>\n   | _ =&gt; pair NONE)</p>\n<p>It seems to want to do something about division and Int.of_int, but maybe this setup is somehow<br>\n bit-rotten or insufficient.</p>\n<p>That code is to abstract over division to stay in the LIRA fragment, e.g., if you have <code>a = 1 / b</code> then<br>\n you need to get rid of the <code>1/b</code>.</p>\n<p>The better solution is to add a translation of division:</p>\n<p>fun mk_divides ts = Term.list_comb (\\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, ts)<br>\n   fun divides _ _ (ts as [a,b]) = <br>\n      if SMT_Util.is_number a andalso SMT_Util.is_number b<br>\n      then SOME (\"/\", 2, ts, mk_divides) else NONE<br>\n     | divides _ _ _ = NONE</p>\n<p>val setup_builtins =<br>\n   (*the current things followed by *) #&gt;<br>\n   SMT_Builtin.add_builtin_fun SMTLIB_Interface.smtlibC<br>\n     (Term.dest_Const \\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, divides) #&gt;<br>\n   fold (SMT_Builtin.add_builtin_fun' SMTLIB_Interface.smtlibC)<br>\n     [(\\&lt;^Const&gt;‹of_int \\&lt;^Type&gt;‹real››, \"to_real\"),<br>\n      (\\&lt;^Const&gt;‹of_nat \\&lt;^Type&gt;‹real››, \"to_real\")]</p>\n<p>Division seems to work but the <code>to_real</code> currently breaks the reconstruction of proofs: on the Isabelle<br>\n side, <code>of_int</code> is ambiguous without looking at the rest of the term. I will look into it.</p>\n<p>I'm CC:ing Martin. Maybe he and I could look into both issues together, if he has time.</p>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at that code (for the BV translation --<br>\n even if our changes are all out of tree). But feel free to do looking into it with Martin if you prefer. </p>\n<p>Mathias</p>\n<p>Best,<br>\n Jasmin</p>\n<p>--<br>\n Prof. Dr. Jasmin Blanchette<br>\n Chair of Theoretical Computer Science and Theorem Proving<br>\n Ludwig-Maximilians-Universität München<br>\n Oettingenstr. 67, 80538 München, Germany<br>\n Tel.: +49 (0)89 2180 9341<br>\n Web: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<p>On 11. Apr 2025, at 16:29, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Hello,</p>\n<p>yesterday I had a proof obligation that boils down to a LIRA problem (linear integer/real<br>\n arithmetic). Usually \"linarith\" can solve these just fine, but in this case it couldn't (at least not<br>\n in a single step), but I know \"linarith\" is incomplete for mixed integer/real problems. I then<br>\n turned to the \"smt\" method instead and to my surprise found that it couldn't do it either.</p>\n<p>I boiled it down to the following minimal example:</p>\n<p>lemma<br>\n   assumes \"0 ≤ x\" \"x ≤ 1 / 2\" \"x ≤ real_of_int m\" \"real_of_int m ≤ x + 1 / 2\"<br>\n   shows   \"real_of_int m = 2 * x\"<br>\n proof -<br>\n   have \"m = 0 ∨ m = 1\"<br>\n     using assms by linarith<br>\n   thus ?thesis<br>\n     using assms by linarith<br>\n qed</p>\n<p>As you can see, it's a LIRA problem, it's a true statement, and \"linarith\" can solve it in two<br>\n steps.</p>\n<p>However, \"apply smt\", \"apply (smt (cvc5))\" and \"apply (smt (z3))\" all fail, and Z3 even claims<br>\n there's a (possibly spurious) counterexample.</p>\n<p>Looking at the generated smtlib problem, I found to my surprise that both the division on the<br>\n reals and the type conversion \"real_of_int\" are translated to uninterpreted functions, so it's not<br>\n surprising that the SMT solvers fail to prove it. It's easy to get rid of the division, of course, but<br>\n that doesn't make it work either (presumable because the \"of_int\" UF is still there).</p>\n<p>I would have expected an encoding like the following:</p>\n<p>(set-logic AUFLIRA)<br>\n (set-option :produce-proofs true)<br>\n (declare-fun x () Real)<br>\n (declare-fun m () Int)<br>\n (assert (and (&lt;= 0 x)  (&lt;= x (/ 1 2))  (&lt;= x m)  (&lt;= m (+ x (/ 1 2)))))<br>\n (assert (not (= m (* 2 x))))<br>\n (check-sat)<br>\n (get-proof)</p>\n<p>Both CVC5 and Z3 can do this and produce proofs.</p>\n<p>So, is this some known limitation of the smt method? Is there some unresolved difficulty in<br>\n replaying LIRA proofs?</p>\n<p>Manuel</p>\n</blockquote>\n<p>-- <br>\nHaniel Barbosa<br>\n<a href=\"https://hanielbarbosa.com/\">https://hanielbarbosa.com/</a></p>",
        "id": 512079407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744637150
    },
    {
        "content": "<p>From: Hanna Elif Lachnitt &lt;<a href=\"mailto:lachnitt@stanford.edu\">lachnitt@stanford.edu</a>&gt;<br>\nHi everyone,</p>\n<p>as Mathias wrote, we have been working on extending the translation of machine word problems to SMT-LIB. Our end goal is to support cvc5's proof certificates including those with bit-vectors. I hope we can make this functionality available soon.</p>\n<p>Recently, I have been looking into extending the embedding of natural numbers into integers to include not only constants but also variables and functions, so I have been learning a lot about the translation code.</p>\n<p>Thus, if you have any other benchmarks for which the translation is suboptimal, I'd be very grateful if you could send them to me (<a href=\"mailto:lachnitt@cs.stanford.edu\">lachnitt@cs.stanford.edu</a>) or Mathias. Same with anything you think should be solvable by an SMT solver but isn't. The cvc5 team is eager to offer good integration with ITPs.</p>\n<p>Best,<br>\nHanna</p>\n<p>TL;DR: please sent me your SMT benchmarks so I can add them to my test suite</p>\n<hr>\n<p>From: Jasmin Blanchette<br>\nSent: Friday, April 11, 2025 23:38<br>\nTo: Mathias Fleury<br>\nCc: Manuel Eberl; <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>; Martin Desharnais; Hanna Elif Lachnitt<br>\nSubject: Re: [isabelle] SMT completeness issue: Failure to prove a true LIRA formula</p>\n<p>Hi Mathias,</p>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at that code (for the BV translation -- even if our changes are all out of tree). But feel free to do looking into it with Martin if you prefer.</p>\n<p>By all means, you go ahead! Thank you so much. I knew you worked on reconstruction, but I didn't realize you had such extensive knowledge of the translation.</p>\n<p>Best,<br>\nJasmin</p>\n<p>--</p>\n<p>Prof. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<p>On 12. Apr 2025, at 08:34, Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt; wrote:</p>\n<p>Hi Jasmin, Manuel and all,</p>\n<p>On 4/12/25 07:47, Jasmin Blanchette wrote:<br>\nHi Manuel,</p>\n<p>SMT was developed by Sascha Böhme, so I'm only partly qualified to answer.</p>\n<p>The fragment SMT solvers can decide is linear. Some SMT solvers also support division and have nonlinear solvers, but these are very slow. As a result, native division is not used, even when it's between constants like 1 and 2, apparently.</p>\n<p>Getting the divide operator translated is easy to add actually.</p>\n<p>As for \"real_of_int\", the uninterpreted symbol is definitely suboptimal. I'm not sure it's safe to just omit it everywhere and rely on implicit cast or subtyping. SMT-LIB seems to support overloading, so this is all rather scary.</p>\n<p>My understanding is that you cannot omit it due to equality requiring to variables of the same sort. But SMT-Lib has the constant <code>to_real</code> for casting. Some SMT solvers allow it.</p>\n<p>In \"smt_real.ML\", I'm seeing code like this:</p>\n<p>fun abstract abs t =<br>\n  (case t of<br>\n    (c as \\&lt;^term&gt;\\&lt;open&gt;Rings.divide :: real =&gt; _\\&lt;close&gt;) $ t1 $ t2 =&gt;<br>\n      abs t1 ##&gt;&gt; abs t2 #&gt;&gt; (fn (u1, u2) =&gt; SOME (c $ u1 $ u2))<br>\n  | (c as \\&lt;^term&gt;\\&lt;open&gt;Int.of_int :: int =&gt; _\\&lt;close&gt;) $ t =&gt;<br>\n      abs t #&gt;&gt; (fn u =&gt; SOME (c $ u))<br>\n  | _ =&gt; pair NONE)</p>\n<p>It seems to want to do something about division and Int.of_int, but maybe this setup is somehow bit-rotten or insufficient.</p>\n<p>That code is to abstract over division to stay in the LIRA fragment, e.g., if you have <code>a = 1 / b</code> then you need to get rid of the <code>1/b</code>.</p>\n<p>The better solution is to add a translation of division:</p>\n<p>fun mk_divides ts = Term.list_comb (\\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, ts)<br>\n  fun divides _ _ (ts as [a,b]) =<br>\n     if SMT_Util.is_number a andalso SMT_Util.is_number b<br>\n     then SOME (\"/\", 2, ts, mk_divides) else NONE<br>\n    | divides _ _ _ = NONE</p>\n<p>val setup_builtins =<br>\n  (*the current things followed by *) #&gt;<br>\n  SMT_Builtin.add_builtin_fun SMTLIB_Interface.smtlibC<br>\n    (Term.dest_Const \\&lt;^Const&gt;‹divide \\&lt;^Type&gt;‹real››, divides) #&gt;<br>\n  fold (SMT_Builtin.add_builtin_fun' SMTLIB_Interface.smtlibC)<br>\n    [(\\&lt;^Const&gt;‹of_int \\&lt;^Type&gt;‹real››, \"to_real\"),<br>\n     (\\&lt;^Const&gt;‹of_nat \\&lt;^Type&gt;‹real››, \"to_real\")]</p>\n<p>Division seems to work but the <code>to_real</code> currently breaks the reconstruction of proofs: on the Isabelle side, <code>of_int</code> is ambiguous without looking at the rest of the term. I will look into it.</p>\n<p>I'm CC:ing Martin. Maybe he and I could look into both issues together, if he has time.</p>\n<p>In all likelihood, Hanna (CC-ed) and I have looked more recently at that code (for the BV translation -- even if our changes are all out of tree). But feel free to do looking into it with Martin if you prefer.</p>\n<p>Mathias</p>\n<p>Best,<br>\nJasmin</p>\n<p>--<br>\nProf. Dr. Jasmin Blanchette<br>\nChair of Theoretical Computer Science and Theorem Proving<br>\nLudwig-Maximilians-Universität München<br>\nOettingenstr. 67, 80538 München, Germany<br>\nTel.: +49 (0)89 2180 9341<br>\nWeb: <a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette_de.html</a></p>\n<p>On 11. Apr 2025, at 16:29, Manuel Eberl &lt;manuel@pruvisto.org&gt;&lt;mailto:<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Hello,</p>\n<p>yesterday I had a proof obligation that boils down to a LIRA problem (linear integer/real arithmetic). Usually \"linarith\" can solve these just fine, but in this case it couldn't (at least not in a single step), but I know \"linarith\" is incomplete for mixed integer/real problems. I then turned to the \"smt\" method instead and to my surprise found that it couldn't do it either.</p>\n<p>I boiled it down to the following minimal example:</p>\n<p>lemma<br>\n  assumes \"0 ≤ x\" \"x ≤ 1 / 2\" \"x ≤ real_of_int m\" \"real_of_int m ≤ x + 1 / 2\"<br>\n  shows   \"real_of_int m = 2 * x\"<br>\nproof -<br>\n  have \"m = 0 ∨ m = 1\"<br>\n    using assms by linarith<br>\n  thus ?thesis<br>\n    using assms by linarith<br>\nqed</p>\n<p>As you can see, it's a LIRA problem, it's a true statement, and \"linarith\" can solve it in two steps.</p>\n<p>However, \"apply smt\", \"apply (smt (cvc5))\" and \"apply (smt (z3))\" all fail, and Z3 even claims there's a (possibly spurious) counterexample.</p>\n<p>Looking at the generated smtlib problem, I found to my surprise that both the division on the reals and the type conversion \"real_of_int\" are translated to uninterpreted functions, so it's not surprising that the SMT solvers fail to prove it. It's easy to get rid of the division, of course, but that doesn't make it work either (presumable because the \"of_int\" UF is still there).</p>\n<p>I would have expected an encoding like the following:</p>\n<p>(set-logic AUFLIRA)<br>\n(set-option :produce-proofs true)<br>\n(declare-fun x () Real)<br>\n(declare-fun m () Int)<br>\n(assert (and (&lt;= 0 x)  (&lt;= x (/ 1 2))  (&lt;= x m)  (&lt;= m (+ x (/ 1 2)))))<br>\n(assert (not (= m (* 2 x))))<br>\n(check-sat)<br>\n(get-proof)</p>\n<p>Both CVC5 and Z3 can do this and produce proofs.</p>\n<p>So, is this some known limitation of the smt method? Is there some unresolved difficulty in replaying LIRA proofs?</p>\n<p>Manuel</p>",
        "id": 512140343,
        "sender_full_name": "Email Gateway",
        "timestamp": 1744652812
    }
]