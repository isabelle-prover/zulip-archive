[
    {
        "content": "<p>From: Florian Sextl &lt;<a href=\"mailto:sextl@in.tum.de\">sextl@in.tum.de</a>&gt;<br>\nDear all,</p>\n<p>I am currently formalizing the base logic of the Iris separation logic <br>\nframework in Isabelle and found that some theoretic constructs can be <br>\nexpressed quite well as semantic subtypes (mostly some specialized <br>\nfunction types). After reading about how to work with subtypes, quotient <br>\ntypes and the lifting/transfer packages as well as experimenting with a <br>\nfew simple logical extensions to the base logic I am a bit unsure, <br>\nwhether it would be easier to express the subtype semantics as simple <br>\npredicates over the raw type.</p>\n<p>My use cases for subtpyes are on the one hand for defining the assertion <br>\nlanguage and on the other hand for the underlying generic structure (so <br>\ncalled cameras).<br>\nI found that subtypes and lifting seem to be a rather standard technique <br>\nfor formalizing assertions (e.g. the separation logic of Imperativ HOL <br>\nuses them). Yet, this approach requires to also lift many lemmas <br>\nnecessary for a good automation. This might be even worse than for <br>\nImperative HOL as the Iris assertions contain more custom connectives. <br>\nThe subtype in question can be found at [1] and a \"paper formalization\" <br>\nof the assertion language can be found at [2] in section 5.<br>\nThe other use case might be similar to some mathematical constructions. <br>\nI defined the camera structure as a type class which requires functions <br>\nthat are of a specific subtype, see [3]. In this case, the lifting and <br>\nlowering seems to only decrease the readability without providing better <br>\nusability.</p>\n<p>I'd love to hear some opinions on whether these use cases make sense for <br>\nsemantic subtypes with lifting or whether the necessary overhead could <br>\nbe too much in the long run. On a related note, what are the experiences <br>\nof others with semantic subtpyes and are there any good rules of thumb <br>\nfor when to use them?</p>\n<p>Thanks a lot in advance and sorry for the horrific WIP proofs in other <br>\nparts of the work.<br>\n<a href=\"/user_uploads/14278/gzkTIJls1rID5PD-HSbW3r2J/smime.p7s\">smime.p7s</a></p>",
        "id": 264281156,
        "sender_full_name": "Email Gateway",
        "timestamp": 1639045600
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi Florian,</p>\n<p>I agree with your observation that, when using subtypes, a lot of<br>\nboilerplate can be generated by having to transfer all necessary<br>\nconcepts from the base-type. There are two exterme approaches here<br>\n(that, of course, can be combined):</p>\n<p>1) try to be minimalistic, only lift/transfer the very basic facts, and<br>\nprove everything else without breaking the subtype barrier again.</p>\n<p>2) prove everything on the rep-type, and then lift/transfer everything.</p>\n<p>while 1 definitely causes less boilerplate, setting up automation when<br>\nthe automation for the rep-type is already well established (like for<br>\nsets) can be a pain. On the other hand, for things like separation<br>\nlogic, there usually is a not-too-big set of basic rules, from which<br>\nyou can derive the others. This can even be done generically, using<br>\ntype-classes like in <br>\n<a href=\"https://www.isa-afp.org/entries/Separation_Algebra.html\">https://www.isa-afp.org/entries/Separation_Algebra.html</a> (and a few<br>\nextensions of that here: <br>\n<a href=\"https://www21.in.tum.de/~lammich/isabelle_llvm/Isabelle_LLVM/Sep_Algebra_Add.html\">https://www21.in.tum.de/~lammich/isabelle_llvm/Isabelle_LLVM/Sep_Algebra_Add.html</a><br>\n)</p>\n<p>Moreover, 1) has the advantage that one gains a better understanding of<br>\nthe logic one is formalizing, basically finding a minimal (small)<br>\ncomplete set of rules, rather than producing ad-hoc rules from the<br>\nunderlying rep-type.</p>\n<p>Finally, considering the alternative of not using subtypes at all, but<br>\nkeeping the invariants in predicates: while this may seem to be easier<br>\nfor proving/developing in an early stage, as it reduces lift/transfer<br>\nboilerplate in particular at an early stage of the development,<br>\nrules with explicit invariants are much harder to use. So you are<br>\npushing technical debt to later stages of the development, when you<br>\nstart to use your own rules more frequently.</p>\n<p>Thus, while an explicit invariant approach might be the way to get<br>\nstarted quickly and with less overhead (which gives you more<br>\nflexibility to play around and try things), at some point you want to<br>\ntransition to subtypes (ideally when you have your small complete set<br>\nof rules). Of course, you can lift/transfer the concepts at this stage<br>\nat only boilerplate cost, keeping the initial development intact.</p>",
        "id": 264288061,
        "sender_full_name": "Email Gateway",
        "timestamp": 1639049636
    }
]