[
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I have several questions about the availability of certain types of proof<br>\nmethods for Isabelle (I guess, these questions can also be seen as<br>\nreference requests).</p>\n<p>I am working on a certain applied formalization study. This work is carried<br>\nout in the object logic ZFC in HOL. The type of reasoning that it requires<br>\nis very similar to the type of reasoning that is used in HOL-Algebra. When<br>\nI started my work on this project, I relied, primarily, on the tools that<br>\ncombine classical reasoning with simplification, such as <em>auto</em>. However, I<br>\nfound myself struggling more and more in my attempts to provide appropriate<br>\nsets of simp/intro/dest/elim rules that would not cause significant delays<br>\nand loops when solving typical set-based goals. Besides, my proof code<br>\nseemed to be unnecessarily verbose. However, please do not view this as a<br>\ncriticism of the aforementioned proof tools: I can hardly claim to have an<br>\nextensive knowledge of the analytical properties of the involved algorithms.</p>\n<hr>\n<p>Problem 1</p>\n<p>From the manual of the simplifier: \"conditions in conditional rewrite rules<br>\nare solved recursively before the rewrite rule is applied\". Empirically, I<br>\nhave established that it could be useful to be able to treat rewriting in<br>\nthe same manner as intro-resolution, allowing the side conditions of the<br>\nrewrite rules to be resolved both using rewriting or intro-resolution after<br>\nthe application of the rewrite rule to a given goal (of course, this is<br>\nalso meant to be done recursively). I devised a prototype method based on<br>\nthis algorithm (CS in<br>\n<a href=\"https://gitlab.com/user9716869/Isabelle-Complement-Library\">https://gitlab.com/user9716869/Isabelle-Complement-Library</a>). For my own<br>\nneeds, practically, I found this type of 'coupling' of rewriting and<br>\nintro-resolution to be exceptionally capable at solving complex goals in<br>\ncomparison with some of the existing tools that seem to combine<br>\nsimplification and classical reasoning that I tried before (by now, for my<br>\nown needs, I rely on the methods provided by CS almost exclusively in a<br>\nreasonably sizeable development).</p>\n<p>Unfortunately, my formal background in the area of the algorithms that are<br>\nused in the common proof tools is, somewhat, limited (I have always been<br>\nfar more interested in the applications of the proof assistants to the<br>\ndevelopment of formally verified software and applied formalization of<br>\nmathematics, rather than the technology behind them). Thus, I have little<br>\ndoubt that I have reinvented the wheel. My primary question is whether any<br>\nof the existing proof tools already provide access to the algorithm that I<br>\nhave described.</p>\n<hr>\n<p>Problem 2</p>\n<p>I would like to know if there exist any reasonably generic proof tools for<br>\nIsabelle that would take into account associativity implicitly. Somehow,<br>\nwhen performing rewriting, I would like to be able to treat ((ab)c)d,<br>\n(ab)(cd), ... as members of the same equivalence class with respect to the<br>\nrelation induced by the associativity. Therefore, if there is an additional<br>\nrewrite rule b(cd)=e (again, treated with respect to the same equivalence<br>\nrelation), it would be immediately applicable to any form of abcd,<br>\nimmediately yielding ae. Intuitively, it seems that this strategy could<br>\nwork rather well for the types of problems that I am facing regularly, and<br>\nI am considering implementing it within the scope of the aforementioned<br>\nproof tools. However, I am slightly concerned about whether there already<br>\nexist canonical implementations or better alternative solutions (please<br>\nnote, however, that my setting is, effectively, a partial semigroup).</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 221013422,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609084734
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nDear Mikhail, this sounds intriguing, though intro-resolution and conditional rewriting will behave similarly in many cases. Do you have simple examples to demonstrate where intro-rewriting works better? I imagine they may involve variable instantiation (i.e. P(x) ==&gt; l=r, where x is not mentioned in l).</p>\n<p>Larry</p>",
        "id": 221053708,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609153659
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Lawrence Paulson,</p>\n<blockquote>\n<p>this sounds intriguing, though intro-resolution and conditional rewriting<br>\nwill behave similarly in many cases.</p>\n<p>Would it possible to suggest a reference that explains this in more detail?<br>\nI have a certain degree of familiarity with the conventional theory of<br>\nabstract/term rewriting, but I am not certain how would one go about<br>\nestablishing analytical properties of a set of intro+simp rules for a<br>\nmethod like auto.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Do you have simple examples to demonstrate where intro-rewriting works<br>\nbetter? I imagine they may involve variable instantiation (i.e. P(x) ==&gt;<br>\nl=r, where x is not mentioned in l).</p>\n<p>Effectively, you have already proposed one such example. An expanded<br>\nvariant stated in Isabelle/HOL can be found in Appendix A after my<br>\nsignature.</p>\n</blockquote>\n<p>Indeed, I use this type of pattern quite frequently in my work. For<br>\nexample, I have introduced predicates that indicate that a given entity is<br>\na function from a to b. Also, similar predicates exist for<br>\ninjective/surjective/bijective functions and, even more generally, for<br>\nvarious specific arrows in arbitrary categories. Practically, I found it<br>\nunwieldy to use different predicates to distinguish the arrows with a<br>\nspecified domain or codomain only, or stating their domain/codomain<br>\nexplicitly in the statements of theorems, or using additional<br>\n'composability' predicates: when using the latter two methodologies it also<br>\nseems to be difficult to establish a good set of rewriting/introduction<br>\nrules for reasons unrelated to the choice of the method/strategy for<br>\nrewriting/introduction. Besides, the chosen methodology leads to (what I<br>\nwould consider being) a very natural textbook-like style of presentation.<br>\nFor example, to state that the horizontal composition of (horizontally<br>\ncomposable) natural isomorphisms is a natural isomorphism, I may use<br>\nsomething similar to (Î± is a size parameter; see<br>\n<a href=\"https://en.wikipedia.org/wiki/Strict_2-category\">https://en.wikipedia.org/wiki/Strict_2-category</a> for the source of the<br>\ninspiration for the notation):</p>\n<p>assumes \"ğ” : ğ”‰' â†¦iso ğ”Š' : ğ”… â†¦â†¦â‡˜Î±â‡™ â„­\"<br>\n    and \"ğ”‘ : ğ”‰ â†¦iso ğ”Š : ğ”„ â†¦â†¦â‡˜Î±â‡™ ğ”…\"<br>\n  shows \"ğ” âˆ˜ ğ”‘ : ğ”‰' âˆ˜ ğ”‰ â†¦iso ğ”Š' âˆ˜ ğ”Š : ğ”„ â†¦â†¦â‡˜Î±â‡™ â„­\"</p>\n<p>However, given these conventions, a natural form of the associativity law<br>\nfor the horizontal transformations now looks like</p>\n<p>assumes \"ğ” : ğ”‰'' â†¦ ğ”Š'' : â„­ â†¦â†¦â‡˜Î±â‡™ ğ”‡\"<br>\n    and \"ğ” : ğ”‰' â†¦ ğ”Š' : ğ”… â†¦â†¦â‡˜Î±â‡™ â„­\"<br>\n    and \"ğ”‘ : ğ”‰ â†¦ ğ”Š : ğ”„ â†¦â†¦â‡˜Î±â‡™ ğ”…\"<br>\n  shows \"(ğ” âˆ˜ ğ”) âˆ˜ ğ”‘ = ğ” âˆ˜ (ğ” âˆ˜ ğ”‘)\"</p>\n<p>This does cause a problem when trying to use it in conjunction with<br>\nintro-resolution and conditional rewriting. However, cs_concl copes with it<br>\nreasonably well for relatively complex use cases.</p>\n<hr>\n<p>There is another practical aspect that may lead to problems when using<br>\nintro-resolution + simp: I am not certain whether it is a good idea to<br>\nmaintain a large collection of theorems that state how various predicates<br>\nare related to each other in the form of a simpset. Consider the following<br>\nexample:</p>\n<p>context<br>\n  fixes P Q R f b<br>\n  assumes [intro, cs_intros]: \"P x âŸ¹ Q x\"<br>\n    and [intro, cs_intros]: \"Q x âŸ¹ R x\"<br>\n    and [simp, intro, cs_simps]: \"R x âŸ¹ f x = b\"<br>\n    and Qb: \"Q b\"<br>\nbegin</p>\n<p>lemma<br>\n  assumes \"P x\"<br>\n  shows \"Q (f x)\"<br>\n  using assms Qb oops (<em>by simp, auto, force, fast, fastforce, blast</em>)</p>\n<p>lemma<br>\n  assumes \"P x\"<br>\n  shows \"Q (f x)\"<br>\n  using assms Qb by (cs_concl cs_simp: cs_simps cs_intro: cs_intros)</p>\n<p>end</p>\n<p>In this case, if  \"P x âŸ¹ Q x\" and \"Q x âŸ¹ R x\" are part of the simpset, then<br>\nthe example works. However, I am not certain whether one can always<br>\nreplace/augment intro with simp in this way and how practical is it in<br>\ngeneral. Is it possible to build upon this example to ensure that<br>\nsimp rules cannot be used instead of introduction? Could simp eliminate the<br>\nside conditions that one does not want to be eliminated when proving other<br>\ntheorems? I thought that I have observed such problems with this<br>\nmethodology when working with simp/auto, but I cannot find a way to produce<br>\na minimal example in this instance. Perhaps, there was a way around them.<br>\nHowever, one of the most pleasant aspects of the strategy employed in<br>\ncs_concl is that one no longer needs to think about whether a rule should<br>\nbe declared as simp, intro, or both. Effectively, intro-resolution is used<br>\nexclusively, making it easier to predict how the method will behave with a<br>\ngiven set of rules.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>Appendix A</p>\n<p>named_theorems cs_simps<br>\nnamed_theorems cs_intros</p>\n<p>definition surj_from_to<br>\n  where \"surj_from_to a b f = (f ` a = b)\"</p>\n<p>context<br>\n  fixes f c P<br>\n  assumes f[intro, simp, cs_simps]: \"surj_from_to a b f âŸ¹ x âˆˆ a âŸ¹ f x = c +<br>\nx\"<br>\n    and [intro, simp, cs_intros]: \"P a b x âŸ¹ surj_from_to a b f\"<br>\n    and [intro, simp, cs_intros]: \"P a b x âŸ¹ c + x = x\"<br>\nbegin</p>\n<p>lemma<br>\n  assumes \"P a b x\" and \"x âˆˆ a\"<br>\n  shows \"f x = x\"<br>\n  using assms oops (<em>by simp, auto, force, fast, fastforce, blast</em>)</p>\n<p>lemma<br>\n  assumes \"P a b x\" and \"x âˆˆ a\"<br>\n  shows \"f x = x\"<br>\n  using assms by (cs_concl cs_simp: cs_simps cs_intro: cs_intros)</p>\n<p>end</p>\n<p>On Mon, Dec 28, 2020 at 1:07 PM Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Mikhail, this sounds intriguing, though intro-resolution and<br>\nconditional rewriting will behave similarly in many cases. Do you have<br>\nsimple examples to demonstrate where intro-rewriting works better? I<br>\nimagine they may involve variable instantiation (i.e. P(x) ==&gt; l=r, where x<br>\nis not mentioned in l).</p>\n<p>Larry</p>\n<p>On 27 Dec 2020, at 15:58, Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nwrote:</p>\n<blockquote>\n<p>From the manual of the simplifier: \"conditions in conditional rewrite<br>\nrules are solved recursively before the rewrite rule is applied\".<br>\nEmpirically, I have established that it could be useful to be able to treat<br>\nrewriting in the same manner as intro-resolution, allowing the side<br>\nconditions of the rewrite rules to be resolved both using rewriting or<br>\nintro-resolution after the application of the rewrite rule to a given goal<br>\n(of course, this is also meant to be done recursively). I devised a<br>\nprototype method based on this algorithm (CS in<br>\n<a href=\"https://gitlab.com/user9716869/Isabelle-Complement-Library\">https://gitlab.com/user9716869/Isabelle-Complement-Library</a>). For my own<br>\nneeds, practically, I found this type of 'coupling' of rewriting and<br>\nintro-resolution to be exceptionally capable at solving complex goals in<br>\ncomparison with some of the existing tools that seem to combine<br>\nsimplification and classical reasoning that I tried before (by now, for my<br>\nown needs, I rely on the methods provided by CS almost exclusively in a<br>\nreasonably sizeable development).</p>\n</blockquote>\n</blockquote>",
        "id": 221070448,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609171578
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Lawrence Paulson/All,</p>\n<p>Once again, I apologize for my haste. It seems that I have developed a bad<br>\nhabit of trying to minimize the time spent on writing the replies for the<br>\nmailing list, leading to various embarrassing misprints and mistakes. Of<br>\ncourse, the excerpt \"a natural form of the associativity law for the<br>\nhorizontal transformations\" should read \"a natural form of the<br>\nassociativity law for the horizontal composition of natural<br>\ntransformations\". I noticed that there is quite a number of other minor<br>\ninconsistencies and misprints in my last email. However, hopefully, they do<br>\nnot interfere with the meaning that I was trying to convey.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 221131249,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609245520
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIt sounds like youâ€™ve been able to combine your proof method with Isabelle2020 in order to create your category theory development. And a usable formalisation of category theory would be an impressive achievement.</p>\n<p>Maybe the way forward is for you to complete your example and contribute it to the AFP. Material from AFP entries sometimes finds its way into the Isabelle sources, and a fully-worked example would give us a good basis for evaluating this idea.</p>\n<p>Larry</p>",
        "id": 221358181,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609518573
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Lawrence Paulson,</p>",
        "id": 221366087,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609530943
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Lawrence Paulson/All,</p>\n<p>I would like to make one minor remark with regard to the last quoted<br>\nstatement. The method that I was referring to in my original post (albeit,<br>\nfor now, in a very rough zero-order form) is available from the, so-called,<br>\nIsabelle Complement Library (<br>\n<a href=\"https://gitlab.com/user9716869/Isabelle-Complement-Library\">https://gitlab.com/user9716869/Isabelle-Complement-Library</a>). It is likely<br>\nthat I will be looking to submit this library to the AFP in a reasonable<br>\ntime frame as part of another project, not related to my work on the<br>\nformalization of category theory. Thus, I anticipate that it will be<br>\npossible to evaluate the idea related to the method fairly soon. However, I<br>\nwould be extremely surprised if there was anything original about it: to<br>\nme, it seems like it combines rewriting and introduction in the simplest<br>\nand the most natural manner. Thus, I am still hopeful that a more mature<br>\nimplementation of this algorithm is already available somewhere.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 221370488,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609537532
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nWell, obviously auto and force combine rewriting and introduction, but not as I think you intend (to support conditional rewriting).</p>\n<p>Larry</p>",
        "id": 221395479,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609586082
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nHi Mikhail.</p>\n<p>I think it's worth mentioning a simple trick relevant to associativity.</p>\n<p>As you say, the problem is, how do you apply a rewrite of the form<br>\n\"b . c = r\" to a goal \"a . b . c . d\"? It's annoying to have to instruct<br>\nIsabelle to somehow gather the b and c together. Let's suppose \".\" is<br>\nassociative and that \"a . b . c . d\" is syntax for \"a . (b . (c . d))\".<br>\nThe simple trick is to also derive the rule \"b . c . x = r . x\".<br>\nThis modified rule will apply to the original goal in normal form <br>\nwithout<br>\nhaving to first gather \"(b . c)\" together.</p>\n<p>The variant form of each rule can usually be derived as a one-liner, <br>\nsince<br>\nit just amounts to generalising via some congruence and then rewriting <br>\ninto<br>\nnormal form. Here's a worked example for conjunction, which works in <br>\nIsabelle/HOL:</p>\n<p>lemma less_and_greater:<br>\n   fixes x :: nat<br>\n   shows \"(x &lt; y âˆ§ x &gt; y) = False\"<br>\n   by auto</p>\n<p>lemmas conj_left_cong = conj_cong[OF _ refl]</p>\n<p>lemmas less_and_greater2 = less_and_greater[THEN conj_left_cong, <br>\nsimplified conj_assoc]</p>\n<p>lemma<br>\n   fixes x :: nat<br>\n   shows<br>\n   \"~ (A âˆ§ (B âˆ§ x &lt; y) âˆ§ (x &gt; y âˆ§ x â‰¤ Suc 12) âˆ§ C)\"<br>\n   apply (simp only: conj_assoc)<br>\n   apply (simp only: less_and_greater2)<br>\n   apply simp<br>\n   done</p>\n<p>From time to time somebody asks about rewriting modulo associativity<br>\nand commutativity, which might sometimes be really useful. My <br>\nunderstanding<br>\nis that this problem has been studied in other tools, that solutions <br>\nexist,<br>\nthat performance is a major issue, and that no implementation for<br>\nIsabelle currently exists.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 221553032,
        "sender_full_name": "Email Gateway",
        "timestamp": 1609781013
    }
]