[
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHello everyone,</p>\n<p>We observed that pretty printing is slow when you have an abbreviation that is deeply nested in a term.<br>\nConsider e.g. the abbreviation <code>int == of_nat</code> in <code>iterate_bind</code>, where</p>\n<p>iterate_bind n = do {<br>\n      x ← Some x;<br>\n      ...;<br>\n      x ← Some x;<br>\n      Some (int x)<br>\n    }</p>\n<p>For <code>n = 1500</code> (a term size not uncommon in program verification), pretty printing takes about 60s.<br>\nThis is due to the fact that abbreviations are contracted top-down<br>\n(Proof_Context.standard_term_uncheck-&gt;contract_abbrevs-&gt;Pattern.rewrite_term_top).<br>\nBottom-up rewriting (Pattern.rewrite_term) takes less than a second (and obviously produces the same result in this case).</p>\n<p>Interestingly, <code>contract_abbrevs</code> used to do bottom-up rewriting prior to 5d2fe4e09354.<br>\nAnd while I am sure there must have been a reason for this change, the changeset unfortunately does not give a justification.</p>\n<p>Concrete explorations are below, with <code>contract_abbrevs'</code> as a parameterized variant of<br>\n<code>contract_abbrevs</code>.</p>\n<p>This is certainly a very delicate business, but does anyone have insights if or how this situation<br>\ncould be improved?</p>\n<p>Best wishes,<br>\nFabian</p>\n<p>—<br>\nFabian Immler<br>\n<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a> &lt;mailto:<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a>&gt;<br>\n SEG Formal Verification</p>\n<p>Scratch.thy:<br>\n=========</p>\n<p>theory Scratch<br>\n  imports<br>\n    Main<br>\n(* \"HOL-Library.Monad_Syntax\" *)<br>\nbegin</p>\n<p>ML ‹<br>\nfun iterate_bind 0 = Abs (\"x\", @{typ \"nat\"}, @{const Some(\"int\")} $ (@{term int} $ Bound 0))<br>\n  | iterate_bind i =<br>\n    Abs (\"x\", @{typ nat},<br>\n      @{const Option.bind(nat, int)} $ (@{const Some(nat)} $ Bound 0) $<br>\n      iterate_bind (i - 1))</p>\n<p>(* when including \"HOL-Library.Monad_Syntax\"<br>\niterate_bind 3 =  @{term \"λx. do {<br>\n    x ← Some x;<br>\n    x ← Some x;<br>\n    x ← Some x;<br>\n    Some (int x)<br>\n  }\"}<br>\n*)<br>\n›</p>\n<p>ML ‹<br>\n(* Pretty printing such a term with \"show_abbrevs\" is slow: *)<br>\nlocal<br>\nval ctxt = @{context}<br>\nval t = iterate_bind 1500<br>\nval ct = Thm.cterm_of ctxt t<br>\nval _ = timeap_msg \"show_abbrevs=true\"  (Syntax.string_of_term ctxt) t<br>\nval ctxt' = Config.put Proof_Context.show_abbrevs false ctxt<br>\nval _ = timeap_msg \"show_abbrevs=false\" (Syntax.string_of_term ctxt') t<br>\nin<br>\n  val t = t<br>\nend<br>\n›</p>\n<p>ML ‹<br>\nfun contract_abbrevs' ctxt rewrite_term t =<br>\n  let<br>\n    val thy = Proof_Context.theory_of ctxt;<br>\n    val consts = Proof_Context.consts_of ctxt;<br>\n    val abbrev = false;<br>\n    val retrieve = Consts.retrieve_abbrevs consts (print_mode_value () @ [\"\"]);<br>\n    fun match_abbrev u = <a href=\"http://Option.map\">Option.map</a> #1 (get_first (Pattern.match_rew thy u) (retrieve u));<br>\n  in<br>\n    if abbrev orelse not (Config.get ctxt show_abbrevs) orelse not (can Term.type_of t) then t<br>\n    else rewrite_term thy [] [match_abbrev] t<br>\n  end;<br>\n›<br>\nML ‹val t1 = timeap_msg \"top-down\" (contract_abbrevs' @{context} Pattern.rewrite_term_top) t›<br>\nML ‹val t2 = timeap_msg \"bot-up\"   (contract_abbrevs' @{context} Pattern.rewrite_term    ) t›<br>\nML ‹t1 = t2›</p>\n<p>end</p>",
        "id": 434138731,
        "sender_full_name": "Email Gateway",
        "timestamp": 1713455476
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThere has been more than one reason to slow down pretty-printing of terms.</p>\n<p>In Isabelle2025-RC1 this should all be much better, and hopefully without <br>\nnewly introduced problems.</p>\n<p>Now is the time for testing ...</p>\n<p>Makarius</p>\n<p>On 18/04/2024 16:50, Fabian Immler (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Hello everyone,</p>\n<p>We observed that pretty printing is slow when you have an abbreviation that is <br>\ndeeply nested in a term.<br>\nConsider e.g. the abbreviation <code>int == of_nat</code> in <code>iterate_bind</code>, where</p>\n<p>iterate_bind n = do {<br>\n       x ← Some x;<br>\n       ...;<br>\n       x ← Some x;<br>\n       Some (int x)<br>\n     }</p>\n<p>For <code>n = 1500</code> (a term size not uncommon in program verification), pretty <br>\nprinting takes about 60s.<br>\nThis is due to the fact that abbreviations are contracted top-down<br>\n(Proof_Context.standard_term_uncheck-&gt;contract_abbrevs-&gt;Pattern.rewrite_term_top).<br>\nBottom-up rewriting (Pattern.rewrite_term) takes less than a second (and <br>\nobviously produces the same result in this case).</p>\n<p>Interestingly, <code>contract_abbrevs</code> used to do bottom-up rewriting prior to <br>\n5d2fe4e09354.<br>\nAnd while I am sure there must have been a reason for this change, the <br>\nchangeset unfortunately does not give a justification.</p>\n<p>Concrete explorations are below, with <code>contract_abbrevs'</code> as a parameterized <br>\nvariant of<br>\n<code>contract_abbrevs</code>.</p>\n<p>This is certainly a very delicate business, but does anyone have insights if <br>\nor how this situation<br>\ncould be improved?</p>\n<p>Best wishes,<br>\nFabian</p>\n<p>—<br>\nFabian Immler<br>\n<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a> &lt;mailto:<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a>&gt;<br>\n SEG Formal Verification</p>\n<p>Scratch.thy:<br>\n=========</p>\n<p>theory Scratch<br>\n   imports<br>\n     Main<br>\n(* \"HOL-Library.Monad_Syntax\" *)<br>\nbegin</p>\n<p>ML ‹<br>\nfun iterate_bind 0 = Abs (\"x\", @{typ \"nat\"}, @{const Some(\"int\")} $ (@{term <br>\nint} $ Bound 0))<br>\n   | iterate_bind i =<br>\n     Abs (\"x\", @{typ nat},<br>\n       @{const Option.bind(nat, int)} $ (@{const Some(nat)} $ Bound 0) $<br>\n       iterate_bind (i - 1))</p>\n<p>(* when including \"HOL-Library.Monad_Syntax\"<br>\niterate_bind 3 =  @{term \"λx. do {<br>\n     x ← Some x;<br>\n     x ← Some x;<br>\n     x ← Some x;<br>\n     Some (int x)<br>\n   }\"}<br>\n*)<br>\n›</p>\n<p>ML ‹<br>\n(* Pretty printing such a term with \"show_abbrevs\" is slow: *)<br>\nlocal<br>\nval ctxt = @{context}<br>\nval t = iterate_bind 1500<br>\nval ct = Thm.cterm_of ctxt t<br>\nval _ = timeap_msg \"show_abbrevs=true\"  (Syntax.string_of_term ctxt) t<br>\nval ctxt' = Config.put Proof_Context.show_abbrevs false ctxt<br>\nval _ = timeap_msg \"show_abbrevs=false\" (Syntax.string_of_term ctxt') t<br>\nin<br>\n   val t = t<br>\nend<br>\n›</p>\n<p>ML ‹<br>\nfun contract_abbrevs' ctxt rewrite_term t =<br>\n   let<br>\n     val thy = Proof_Context.theory_of ctxt;<br>\n     val consts = Proof_Context.consts_of ctxt;<br>\n     val abbrev = false;<br>\n     val retrieve = Consts.retrieve_abbrevs consts (print_mode_value () @ [\"\"]);<br>\n     fun match_abbrev u = <a href=\"http://Option.map\">Option.map</a> #1 (get_first (Pattern.match_rew thy u) <br>\n(retrieve u));<br>\n   in<br>\n     if abbrev orelse not (Config.get ctxt show_abbrevs) orelse not (can <br>\nTerm.type_of t) then t<br>\n     else rewrite_term thy [] [match_abbrev] t<br>\n   end;<br>\n›<br>\nML ‹val t1 = timeap_msg \"top-down\" (contract_abbrevs' @{context} <br>\nPattern.rewrite_term_top) t›<br>\nML ‹val t2 = timeap_msg \"bot-up\"   (contract_abbrevs' @{context} <br>\nPattern.rewrite_term    ) t›<br>\nML ‹t1 = t2›</p>\n<p>end</p>\n</blockquote>",
        "id": 497533241,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738617455
    },
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nThank you, this looks great from what I can tell.</p>\n<p>The pathological example from this thread is much improved (from about 60s to 1s).<br>\nPretty printing the pathological example with \"HOL-Library.Monad_Syntax\" is also much improved:<br>\n<code>iterate_bind 600</code> took 20s in Isabelle2024, now this is down to 0.2s.</p>\n<p>In regular usage over the past weeks (since Isabelle2025-RC0), I did not notice any problems with the speed of pretty printing.</p>\n<p>Best wishes,<br>\nFabian</p>\n<p>—<br>\nFabian Immler<br>\n<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a><br>\n SEG Formal Verification</p>\n<blockquote>\n<p>On 3. Feb 2025, at 22:09, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>There has been more than one reason to slow down pretty-printing of terms.</p>\n<p>In Isabelle2025-RC1 this should all be much better, and hopefully without newly introduced problems.</p>\n<p>Now is the time for testing ...</p>\n<p>Makarius</p>\n<p>On 18/04/2024 16:50, Fabian Immler (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Hello everyone,<br>\nWe observed that pretty printing is slow when you have an abbreviation that is deeply nested in a term.<br>\nConsider e.g. the abbreviation <code>int == of_nat</code> in <code>iterate_bind</code>, where<br>\n    iterate_bind n = do {<br>\n      x ← Some x;<br>\n      ...;<br>\n      x ← Some x;<br>\n      Some (int x)<br>\n    }<br>\nFor <code>n = 1500</code> (a term size not uncommon in program verification), pretty printing takes about 60s.<br>\nThis is due to the fact that abbreviations are contracted top-down<br>\n(Proof_Context.standard_term_uncheck-&gt;contract_abbrevs-&gt;Pattern.rewrite_term_top).<br>\nBottom-up rewriting (Pattern.rewrite_term) takes less than a second (and obviously produces the same result in this case).<br>\nInterestingly, <code>contract_abbrevs</code> used to do bottom-up rewriting prior to 5d2fe4e09354.<br>\nAnd while I am sure there must have been a reason for this change, the changeset unfortunately does not give a justification.<br>\nConcrete explorations are below, with <code>contract_abbrevs'</code> as a parameterized variant of<br>\n<code>contract_abbrevs</code>.<br>\nThis is certainly a very delicate business, but does anyone have insights if or how this situation<br>\ncould be improved?<br>\nBest wishes,<br>\nFabian<br>\n—<br>\nFabian Immler<br>\n<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a> &lt;mailto:<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a>&gt; &lt;mailto:<a href=\"mailto:fimmler@apple.com\">fimmler@apple.com</a>&gt;<br>\n SEG Formal Verification<br>\nScratch.thy:<br>\n=========<br>\ntheory Scratch<br>\n  imports<br>\n    Main<br>\n(* \"HOL-Library.Monad_Syntax\" *)<br>\nbegin<br>\nML ‹<br>\nfun iterate_bind 0 = Abs (\"x\", @{typ \"nat\"}, @{const Some(\"int\")} $ (@{term int} $ Bound 0))<br>\n  | iterate_bind i =<br>\n    Abs (\"x\", @{typ nat},<br>\n      @{const Option.bind(nat, int)} $ (@{const Some(nat)} $ Bound 0) $<br>\n      iterate_bind (i - 1))<br>\n(* when including \"HOL-Library.Monad_Syntax\"<br>\niterate_bind 3 =  @{term \"λx. do {<br>\n    x ← Some x;<br>\n    x ← Some x;<br>\n    x ← Some x;<br>\n    Some (int x)<br>\n  }\"}<br>\n*)<br>\n›<br>\nML ‹<br>\n(* Pretty printing such a term with \"show_abbrevs\" is slow: *)<br>\nlocal<br>\nval ctxt = @{context}<br>\nval t = iterate_bind 1500<br>\nval ct = Thm.cterm_of ctxt t<br>\nval _ = timeap_msg \"show_abbrevs=true\"  (Syntax.string_of_term ctxt) t<br>\nval ctxt' = Config.put Proof_Context.show_abbrevs false ctxt<br>\nval _ = timeap_msg \"show_abbrevs=false\" (Syntax.string_of_term ctxt') t<br>\nin<br>\n  val t = t<br>\nend<br>\n›<br>\nML ‹<br>\nfun contract_abbrevs' ctxt rewrite_term t =<br>\n  let<br>\n    val thy = Proof_Context.theory_of ctxt;<br>\n    val consts = Proof_Context.consts_of ctxt;<br>\n    val abbrev = false;<br>\n    val retrieve = Consts.retrieve_abbrevs consts (print_mode_value () @ [\"\"]);<br>\n    fun match_abbrev u = <a href=\"http://Option.map\">Option.map</a> #1 (get_first (Pattern.match_rew thy u) (retrieve u));<br>\n  in<br>\n    if abbrev orelse not (Config.get ctxt show_abbrevs) orelse not (can Term.type_of t) then t<br>\n    else rewrite_term thy [] [match_abbrev] t<br>\n  end;<br>\n›<br>\nML ‹val t1 = timeap_msg \"top-down\" (contract_abbrevs' @{context} Pattern.rewrite_term_top) t›<br>\nML ‹val t2 = timeap_msg \"bot-up\"   (contract_abbrevs' @{context} Pattern.rewrite_term    ) t›<br>\nML ‹t1 = t2›<br>\nend</p>\n</blockquote>\n</blockquote>",
        "id": 498124468,
        "sender_full_name": "Email Gateway",
        "timestamp": 1738849640
    }
]