[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear all,</p>\n<p>I stumbled over a fundamental structural issue in the AFP (referring to<br>\nthe 2021 release):</p>\n<ul>\n<li>\n<p>There is entry Efficient_Merge_Sort, with obvious content.</p>\n</li>\n<li>\n<p>There is theory Automatic_Refinement.Misc, which provides both a quick<br>\nsort and a merge sort specification tailored for efficient execution.</p>\n</li>\n<li>\n<p>There are a couple of references to Automatic_Refinement.Misc<br>\nthroughout the AFP:</p>\n</li>\n</ul>\n<p>I have not yet visited all of them in detail but already this overview<br>\nsuggests that a significant amount of those references makes use of the<br>\nsorting algorithms.</p>\n<p>It seems worth a try whether those applications can be changed to use<br>\nsession Efficient_Merge_Sort instead.  But maybe the authors /<br>\nmaintainers of Automatic_Refinement can say more on this.</p>\n<p>In any case, the sorting part of Automatic_Refinement.Misc should be<br>\nmade more explicit using a separate theory.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/BIbYMgqK90Rny0HE6rpiRVVs/OpenPGP_signature\">OpenPGP_signature</a></p>",
        "id": 242866180,
        "sender_full_name": "Email Gateway",
        "timestamp": 1623842414
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nThe quicksort and mergesort algorithms in AFP have been developed by<br>\nThomas Tuerk, for the CAVA model checker.</p>\n<p>It is slightly different from the mergesort afp entry:</p>\n<p>Efficient_Merge_Sort uses a key function ('a =&gt; 'key::linorder), while<br>\nthe Automatic_Refinement version accepts a relation. While this is<br>\ntheoretically the same (both define weak linear orderings), practically<br>\nthe introduction of an additional linearly ordered key type and type-<br>\nclass can be cumbersome. In CAVA, we have had type-class conflicts<br>\nbefore, which do not affect our typeclass-less sorting definitions.</p>\n<p>The efficiency of the existing algorithms should be benchmarked. To my<br>\nknowledge, we have never benchmarked our sorting algorithms. <br>\nThe comments in Efficient_Merge_Sort suggests, however, that the<br>\nperformance may also be language independent.</p>",
        "id": 242869480,
        "sender_full_name": "Email Gateway",
        "timestamp": 1623844702
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:kleing@unsw.edu.au\">kleing@unsw.edu.au</a>&gt;<br>\nHi Florian,</p>\n<p>I don't understand what the fundamental issue is there.</p>\n<p>Do you mean that all entries should use only one specific sort implementation? (Why?) Or is it that the one in Automatic_Refinement is hard to reference?</p>\n<p>Cheers,<br>\nGerwin<br>\n<a href=\"/user_uploads/14278/aPG_qvp90qQ4O4CjhM587Eqp/signature.asc\">signature.asc</a></p>",
        "id": 242954142,
        "sender_full_name": "Email Gateway",
        "timestamp": 1623884512
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear all,</p>\n<p>after Peter’s and Gerwin’s replies I recognize that there is a<br>\nsignificant difference between the sort implementations in<br>\nAutomatic_Refinement and that in Efficient_Merge_Sort.</p>\n<p>So the situation appears to me as follows:</p>\n<ul>\n<li>\n<p>The implementation in Efficient_Merge_Sort depends on a type class,<br>\nwhich is not general enough for all applications.</p>\n</li>\n<li>\n<p>The implementations in Automatic_Refinement.Misc should be made<br>\navailable more explicitly, either a) using a specific theory name or b)<br>\nseperately in a distinct AFP entry.</p>\n</li>\n<li>\n<p>In the long run, analysis and potential unification of the algorithms<br>\ncould be undertaken.</p>\n</li>\n</ul>\n<p>Hopefully this clarifies the situation.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/1x4EHeUL4Sesa_uI4365PdJW/OpenPGP_signature\">OpenPGP_signature</a></p>",
        "id": 243749599,
        "sender_full_name": "Email Gateway",
        "timestamp": 1624519283
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Florian,</p>\n<p>On 6/24/21 9:20 AM, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>after Peter’s and Gerwin’s replies I recognize that there is a<br>\nsignificant difference between the sort implementations in<br>\nAutomatic_Refinement and that in Efficient_Merge_Sort.</p>\n<p>So the situation appears to me as follows:</p>\n<ul>\n<li>The implementation in Efficient_Merge_Sort depends on a type class,<br>\nwhich is not general enough for all applications.</li>\n</ul>\n</blockquote>\n<p>Well, there is a key-function that maps elements into a linorder. That <br>\nis, in my opinion not as severe a dependency as directly depending on a <br>\ntype class. Anyway</p>\n<p>sorry for the late reply,</p>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<ul>\n<li>\n<p>The implementations in Automatic_Refinement.Misc should be made<br>\navailable more explicitly, either a) using a specific theory name or b)<br>\nseperately in a distinct AFP entry.</p>\n</li>\n<li>\n<p>In the long run, analysis and potential unification of the algorithms<br>\ncould be undertaken.</p>\n</li>\n</ul>\n</blockquote>\n<p>That would be nice.</p>\n<blockquote>\n<p>Hopefully this clarifies the situation.</p>\n<p>Cheers,<br>\n  Florian</p>\n<p>Am 16.06.21 um 13:19 schrieb Florian Haftmann:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>I stumbled over a fundamental structural issue in the AFP (referring to<br>\nthe 2021 release):</p>\n<ul>\n<li>\n<p>There is entry Efficient_Merge_Sort, with obvious content.</p>\n</li>\n<li>\n<p>There is theory Automatic_Refinement.Misc, which provides both a quick<br>\nsort and a merge sort specification tailored for efficient execution.</p>\n</li>\n<li>\n<p>There are a couple of references to Automatic_Refinement.Misc<br>\nthroughout the AFP:</p>\n</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>thys/AI_Planning_Languages_Semantics/PDDL_STRIPS_Semantics.thy:7:  \"Automatic_Refinement.Misc\"<br>\n   thys/CAVA_Automata/Digraph_Basic.thy:4:  \"Automatic_Refinement.Misc\"<br>\n   thys/Kruskal/UGraph.thy:5:    \"Automatic_Refinement.Misc\"<br>\n   thys/Kruskal/Kruskal_Misc.thy:5:    \"Automatic_Refinement.Misc\"<br>\n   thys/Separation_Logic_Imperative_HOL/Assertions.thy:7:  Automatic_Refinement.Misc<br>\n   thys/Separation_Logic_Imperative_HOL/ROOT:19:    Automatic_Refinement.Misc<br>\n   thys/IP_Addresses/WordInterval_Sorted.thy:3:        Automatic_Refinement.Misc (<em>Mergesort. TODO: dependnecy! we need a mergesort afp entry!!</em>)<br>\n   thys/IP_Addresses/ROOT:9:    Automatic_Refinement.Misc (* mergesort *)<br>\n   thys/Refine_Imperative_HOL/Lib/Pf_Add.thy:2:imports Automatic_Refinement.Misc \"HOL-Library.Monad_Syntax\"<br>\n   thys/DFS_Framework/Misc/DFS_Framework_Misc.thy:2:imports Automatic_Refinement.Misc<br>\n   thys/Flow_Networks/Lib/Fofu_Abs_Base.thy:5:  Automatic_Refinement.Misc<br>\n   thys/Network_Security_Policy_Verification/Lib/Efficient_Distinct.thy:3:  Automatic_Refinement.Misc (<em>mergesort</em>)<br>\n   thys/Collections/Lib/Dlist_add.thy:5:  Automatic_Refinement.Misc<br>\n   thys/Collections/Lib/Sorted_List_Operations.thy:3:imports Main Automatic_Refinement.Misc<br>\n   thys/Collections/Iterator/SetIterator.thy:8:  Automatic_Refinement.Misc<br>\n   thys/LOFT/LinuxRouter_OpenFlow_Translation.thy:3:  Automatic_Refinement.Misc (<em>TODO@Peter: rename and make available at better place :)</em>)<br>\n   thys/Tree-Automata/Ta.thy:7:imports Main Automatic_Refinement.Misc Tree<br>\n   thys/Iptables_Semantics/Primitive_Matchers/Ipassmt.thy:6:        Automatic_Refinement.Misc (<em>dependnecy!</em>)</p>\n</blockquote>\n</blockquote>\n<p>I have not yet visited all of them in detail but already this overview<br>\nsuggests that a significant amount of those references makes use of the<br>\nsorting algorithms.</p>\n<p>It seems worth a try whether those applications can be changed to use<br>\nsession Efficient_Merge_Sort instead.  But maybe the authors /<br>\nmaintainers of Automatic_Refinement can say more on this.</p>\n<p>In any case, the sorting part of Automatic_Refinement.Misc should be<br>\nmade more explicit using a separate theory.</p>\n<p>Cheers,<br>\n Florian</p>\n</blockquote>\n</blockquote>",
        "id": 245478954,
        "sender_full_name": "Email Gateway",
        "timestamp": 1625854803
    }
]