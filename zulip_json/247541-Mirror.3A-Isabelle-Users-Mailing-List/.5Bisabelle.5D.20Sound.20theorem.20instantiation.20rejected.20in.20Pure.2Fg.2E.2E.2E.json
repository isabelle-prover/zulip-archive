[
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nDear list,</p>\n<p>I am using Isabelle2025 and want to report an unexpected behaviour of a <br>\ncheck in Pure/goal.ML, function \"prove_common\" and in <br>\nPure/Isar/proof.ML, function \"conclude_goal\".</p>\n<p>Both functions try to check if the proven theorem is an instance of the <br>\noriginally passed theorem statement using \"Unify.matcher\". However, <br>\nUnify.matcher is incomplete for higher-order matching, e.g. it fails on <br>\nthe matching problem<br>\n\"(?f :: prop ⇒ prop) ((?x :: prop ⇒ prop) y) ≡ ?f y\"<br>\n(one solution: ?x |-&gt; λ_. y).</p>\n<p>As a consequence, sound proofs get rejected e.g. when using Goal.prove <br>\nand when writing a proof in Isar. Below I append an example theory file <br>\nshowcasing this, including a minimised version of a lemma that triggered <br>\nthis behaviour in my development.</p>\n<p>Optimally, one would like to have a complete higher-order matcher, but I <br>\nam not aware of a simple algorithm for that (though I am by no means an <br>\nexpert in this area). Checking the history of goal.ML and proof.ML <br>\nindicates that both have seen iterations trying to improve the <br>\ncompleteness of the instance check, i.e. this behaviour has been <br>\nconsidered and refined in the past.</p>\n<p>Since the check happens in goal.ML and proof.ML, it affects users of <br>\nIsabelle/ML and Isabelle/Isar.<br>\n(1) I wonder if the check in goal.ML is necessary at all?<br>\n(2) Would it be conceivable to temporarily disable the check (e.g. with <br>\na configuration option) in goal.ML and/or proof.ML for users?</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span>\n<span class=\"w\">   </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span>\n<span class=\"k\">begin</span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"∃f. set (case xs of [] ⇒ [] | _ ⇒ f xs) = set []\"</span>\n<span class=\"w\">   </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">exI</span><span class=\"o\">)</span>\n<span class=\"w\">   </span><span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"> </span><span class=\"c\">(*error: Proved a different theorem*)</span>\n<span class=\"w\">   </span><span class=\"gr\">oops</span>\n\n<span class=\"k\">ML</span><span class=\"s\">‹</span>\n<span class=\"s\">   val ctxt = @{context}</span>\n<span class=\"s\">   val read = Proof_Context.read_term_pattern ctxt</span>\n<span class=\"s\">   val [t1, t2] = Syntax.read_terms (Proof_Context.set_mode</span>\n<span class=\"s\">Proof_Context.mode_schematic ctxt)</span>\n<span class=\"s\">     [\"(?f :: prop ⇒ prop) ((?x :: prop ⇒ prop) y)\", \"?f y\"]</span>\n<span class=\"s\">   val can_unif = Unify.matcher (Context.Proof ctxt) [t1] [t2] |&gt;</span>\n<span class=\"s\">is_some (*false; no matcher found*)</span>\n<span class=\"s\">›</span>\n\n<span class=\"k\">ML</span><span class=\"s\">‹</span>\n<span class=\"s\">let</span>\n<span class=\"s\">   val ctxt = @{context}</span>\n<span class=\"s\">   val goal = read \"(?f :: bool ⇒ bool) ((?x :: bool ⇒ bool) y) ≡ ?f (?x y)\"</span>\n<span class=\"s\">   val insts = [</span>\n<span class=\"s\">       (((\"x\", 0), @{typ \"bool ⇒ bool\"}), read \"λ_ :: bool. (y :: bool)\")</span>\n<span class=\"s\">     ] |&gt; map (apsnd (Thm.cterm_of ctxt))</span>\n<span class=\"s\">in</span>\n<span class=\"s\">  (*error: Proved a different theorem*)</span>\n<span class=\"s\">   Goal.prove ctxt [] [] goal</span>\n<span class=\"s\">     (fn _ =&gt; PRIMITIVE (Thm.instantiate (TVars.empty, Vars.make insts))</span>\n<span class=\"s\">       THEN HEADGOAL (resolve0_tac @{thms reflexive}))</span>\n<span class=\"s\">end</span>\n<span class=\"s\">›</span>\n\n<span class=\"n\">schematic_goal</span><span class=\"w\"> </span><span class=\"s\">\"(?f :: bool ⇒ bool) ((?x :: bool ⇒ bool) y) ≡ ?f (?x y)\"</span>\n<span class=\"kp\">apply</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"s\">‹</span>\n<span class=\"s\">let</span>\n<span class=\"s\">   val ctxt = @{context}</span>\n<span class=\"s\">   val read = Proof_Context.read_term_pattern ctxt</span>\n<span class=\"s\">   val insts = [</span>\n<span class=\"s\">       (((\"x\", 0), @{typ \"bool ⇒ bool\"}), read \"λ_ :: bool. (y :: bool)\")</span>\n<span class=\"s\">     ] |&gt; map (apsnd (Thm.cterm_of ctxt))</span>\n<span class=\"s\">in PRIMITIVE (Thm.instantiate (TVars.empty, Vars.make insts)) end›</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">(*OK*)</span>\n<span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">rule</span><span class=\"w\"> </span><span class=\"n\">reflexive</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"c\">(*error: Proved a different theorem*)</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 534306172,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755120098
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nDear Kevin,</p>\n<p>Higher-order matching is undecidable. The check is necessary because a tactic replaces the proof state by a new proof state and could easily replace the goal by a different one. Matching is only necessary if the original goal contains schematic variables, which is these days extremely rare. Most of the time we only have to check for identity.</p>\n<blockquote>\n<p>lemma \"∃f. set (case xs of [] ⇒ [] | _ ⇒ f xs) = set []\"<br>\n apply (rule exI)<br>\n apply simp (<em>error: Proved a different theorem</em>)<br>\n oops</p>\n</blockquote>\n<p>I tried your example, but that proof didn't work. I proved the theorem in a couple of different ways and did not get an error.</p>\n<p>Larry</p>\n<blockquote>\n<p>On 13 Aug 2025, at 22:21, Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt; wrote:</p>\n<p>Optimally, one would like to have a complete higher-order matcher, but I am not aware of a simple algorithm for that (though I am by no means an expert in this area). Checking the history of goal.ML and proof.ML indicates that both have seen iterations trying to improve the completeness of the instance check, i.e. this behaviour has been considered and refined in the past.</p>\n<p>Since the check happens in goal.ML and proof.ML, it affects users of Isabelle/ML and Isabelle/Isar.<br>\n(1) I wonder if the check in goal.ML is necessary at all?<br>\n(2) Would it be conceivable to temporarily disable the check (e.g. with a configuration option) in goal.ML and/or proof.ML for users?</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n</blockquote>",
        "id": 534455166,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755169097
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHigher-Order matchig modulo beta+eta (this is important) is decidable. This was <br>\nproved by Stirling in 2007 but is beside the point (partly because of the <br>\ncomplexity). The point that Kevin is making is this: the check has no logical <br>\nrelevance, it is a sanity check, but it rules out perfectly sound proofs. Thus <br>\nthere should be some way to say \"the incomplete sanity check prevents this <br>\noperation, but trust me, I know what I am doing and you don't need to protect me <br>\nagainst doing something silly\".</p>\n<p>Tobias</p>\n<p>On 14/08/2025 12:57, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>Dear Kevin,</p>\n<p>Higher-order matching is undecidable. The check is necessary because a tactic replaces the proof state by a new proof state and could easily replace the goal by a different one. Matching is only necessary if the original goal contains schematic variables, which is these days extremely rare. Most of the time we only have to check for identity.</p>\n<blockquote>\n<p>lemma \"∃f. set (case xs of [] ⇒ [] | _ ⇒ f xs) = set []\"<br>\n  apply (rule exI)<br>\n  apply simp (<em>error: Proved a different theorem</em>)<br>\n  oops</p>\n</blockquote>\n<p>I tried your example, but that proof didn't work. I proved the theorem in a couple of different ways and did not get an error.</p>\n<p>Larry</p>\n<blockquote>\n<p>On 13 Aug 2025, at 22:21, Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt; wrote:</p>\n<p>Optimally, one would like to have a complete higher-order matcher, but I am not aware of a simple algorithm for that (though I am by no means an expert in this area). Checking the history of goal.ML and proof.ML indicates that both have seen iterations trying to improve the completeness of the instance check, i.e. this behaviour has been considered and refined in the past.</p>\n<p>Since the check happens in goal.ML and proof.ML, it affects users of Isabelle/ML and Isabelle/Isar.<br>\n(1) I wonder if the check in goal.ML is necessary at all?<br>\n(2) Would it be conceivable to temporarily disable the check (e.g. with a configuration option) in goal.ML and/or proof.ML for users?</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/UNJZjjXNHzR64uUreFeIBdeg/smime.p7s\">smime.p7s</a></p>",
        "id": 534457121,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755169862
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nWhat do you mean by “no logical reference”? The check is what rules out the following “proof”:</p>\n<p>lemma \"False\"<br>\n  by (tactic ‹PRIMITIVE (fn thm =&gt; TrueI RS Drule.protectI)›)</p>\n<p>The tactic does what Larry suggested: replace the goal False by True.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 14 Aug 2025, at 13.10, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<p>Higher-Order matchig modulo beta+eta (this is important) is decidable. This was proved by Stirling in 2007 but is beside the point (partly because of the complexity). The point that Kevin is making is this: the check has no logical relevance, it is a sanity check, but it rules out perfectly sound proofs. Thus there should be some way to say \"the incomplete sanity check prevents this operation, but trust me, I know what I am doing and you don't need to protect me against doing something silly\".</p>\n<p>Tobias</p>\n<p>On 14/08/2025 12:57, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>Dear Kevin,<br>\nHigher-order matching is undecidable. The check is necessary because a tactic replaces the proof state by a new proof state and could easily replace the goal by a different one. Matching is only necessary if the original goal contains schematic variables, which is these days extremely rare. Most of the time we only have to check for identity.</p>\n<blockquote>\n<p>lemma \"∃f. set (case xs of [] ⇒ [] | _ ⇒ f xs) = set []\"<br>\n apply (rule exI)<br>\n apply simp (<em>error: Proved a different theorem</em>)<br>\n oops<br>\nI tried your example, but that proof didn't work. I proved the theorem in a couple of different ways and did not get an error.<br>\nLarry<br>\nOn 13 Aug 2025, at 22:21, Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt; wrote:</p>\n<p>Optimally, one would like to have a complete higher-order matcher, but I am not aware of a simple algorithm for that (though I am by no means an expert in this area). Checking the history of goal.ML and proof.ML indicates that both have seen iterations trying to improve the completeness of the instance check, i.e. this behaviour has been considered and refined in the past.</p>\n<p>Since the check happens in goal.ML and proof.ML, it affects users of Isabelle/ML and Isabelle/Isar.<br>\n(1) I wonder if the check in goal.ML is necessary at all?<br>\n(2) Would it be conceivable to temporarily disable the check (e.g. with a configuration option) in goal.ML and/or proof.ML for users?</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 534525767,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755191282
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;<br>\nIn meta-programming it is not relevant; in an Isar proof, one indeed <br>\nexpect that the stated term was proven.</p>\n<p>But there could be a way to supply the correct instantiation manually: <br>\nFor instance, via syntax like \"qed[where ?x=...]\".</p>\n<p>Fabian</p>\n<p>On 8/14/25 19:07, Dmitriy Traytel (via cl-isabelle-users Mailing List) <br>\nwrote:</p>\n<blockquote>\n<p>What do you mean by “no logical reference”? The check is what rules out the following “proof”:</p>\n<p>lemma \"False\"<br>\n   by (tactic ‹PRIMITIVE (fn thm =&gt; TrueI RS Drule.protectI)›)</p>\n<p>The tactic does what Larry suggested: replace the goal False by True.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 14 Aug 2025, at 13.10, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<p>Higher-Order matchig modulo beta+eta (this is important) is decidable. This was proved by Stirling in 2007 but is beside the point (partly because of the complexity). The point that Kevin is making is this: the check has no logical relevance, it is a sanity check, but it rules out perfectly sound proofs. Thus there should be some way to say \"the incomplete sanity check prevents this operation, but trust me, I know what I am doing and you don't need to protect me against doing something silly\".</p>\n<p>Tobias</p>\n<p>On 14/08/2025 12:57, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>Dear Kevin,<br>\nHigher-order matching is undecidable. The check is necessary because a tactic replaces the proof state by a new proof state and could easily replace the goal by a different one. Matching is only necessary if the original goal contains schematic variables, which is these days extremely rare. Most of the time we only have to check for identity.</p>\n<blockquote>\n<p>lemma \"∃f. set (case xs of [] ⇒ [] | _ ⇒ f xs) = set []\"<br>\n  apply (rule exI)<br>\n  apply simp (<em>error: Proved a different theorem</em>)<br>\n  oops<br>\nI tried your example, but that proof didn't work. I proved the theorem in a couple of different ways and did not get an error.<br>\nLarry<br>\nOn 13 Aug 2025, at 22:21, Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt; wrote:</p>\n<p>Optimally, one would like to have a complete higher-order matcher, but I am not aware of a simple algorithm for that (though I am by no means an expert in this area). Checking the history of goal.ML and proof.ML indicates that both have seen iterations trying to improve the completeness of the instance check, i.e. this behaviour has been considered and refined in the past.</p>\n<p>Since the check happens in goal.ML and proof.ML, it affects users of Isabelle/ML and Isabelle/Isar.<br>\n(1) I wonder if the check in goal.ML is necessary at all?<br>\n(2) Would it be conceivable to temporarily disable the check (e.g. with a configuration option) in goal.ML and/or proof.ML for users?</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 534526721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755191609
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Fabian,</p>\n<p>I’m not sure what you mean by “in meta-programming it is not relevant”. The same (ruled-out) example:</p>\n<p>ML ‹<br>\n  Goal.prove @{context} [] [] (HOLogic.mk_Trueprop @{term False})<br>\n    (fn _ =&gt; PRIMITIVE (fn thm =&gt; TrueI RS Drule.protectI))<br>\n›</p>\n<p>Regarding the qed syntax proposal: Kevin’s original goal has no schematic variables, so there is nothing to instantiate.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 14 Aug 2025, at 19.12, Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt; wrote:</p>\n<p>In meta-programming it is not relevant; in an Isar proof, one indeed expect that the stated term was proven.</p>\n<p>But there could be a way to supply the correct instantiation manually: For instance, via syntax like \"qed[where ?x=...]\".</p>\n<p>Fabian</p>\n<p>On 8/14/25 19:07, Dmitriy Traytel (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>What do you mean by “no logical reference”? The check is what rules out the following “proof”:</p>\n<p>lemma \"False\"<br>\n  by (tactic ‹PRIMITIVE (fn thm =&gt; TrueI RS Drule.protectI)›)</p>\n<p>The tactic does what Larry suggested: replace the goal False by True.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 14 Aug 2025, at 13.10, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<p>Higher-Order matchig modulo beta+eta (this is important) is decidable. This was proved by Stirling in 2007 but is beside the point (partly because of the complexity). The point that Kevin is making is this: the check has no logical relevance, it is a sanity check, but it rules out perfectly sound proofs. Thus there should be some way to say \"the incomplete sanity check prevents this operation, but trust me, I know what I am doing and you don't need to protect me against doing something silly\".</p>\n<p>Tobias</p>\n<p>On 14/08/2025 12:57, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>Dear Kevin,<br>\nHigher-order matching is undecidable. The check is necessary because a tactic replaces the proof state by a new proof state and could easily replace the goal by a different one. Matching is only necessary if the original goal contains schematic variables, which is these days extremely rare. Most of the time we only have to check for identity.</p>\n<blockquote>\n<p>lemma \"∃f. set (case xs of [] ⇒ [] | _ ⇒ f xs) = set []\"<br>\n apply (rule exI)<br>\n apply simp (<em>error: Proved a different theorem</em>)<br>\n oops<br>\nI tried your example, but that proof didn't work. I proved the theorem in a couple of different ways and did not get an error.<br>\nLarry<br>\nOn 13 Aug 2025, at 22:21, Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt; wrote:</p>\n<p>Optimally, one would like to have a complete higher-order matcher, but I am not aware of a simple algorithm for that (though I am by no means an expert in this area). Checking the history of goal.ML and proof.ML indicates that both have seen iterations trying to improve the completeness of the instance check, i.e. this behaviour has been considered and refined in the past.</p>\n<p>Since the check happens in goal.ML and proof.ML, it affects users of Isabelle/ML and Isabelle/Isar.<br>\n(1) I wonder if the check in goal.ML is necessary at all?<br>\n(2) Would it be conceivable to temporarily disable the check (e.g. with a configuration option) in goal.ML and/or proof.ML for users?</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 534607257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755241104
    },
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nFor my original proof (and the one in the shared theory file using <br>\n\"simp\"), I discovered in the meantime that the list to set comprehension <br>\nsimproc in List.thy creates the instance that does not pass the matching <br>\nsanity check. The simproc can be modified to use Goal.prove_internal <br>\n(which uses no matching check) instead of Goal.prove. I shared a patch <br>\nwith Tobias which will be published soon.</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<p>On 13.08.25 23:21, Kevin Kappelmann wrote:</p>\n<blockquote>\n<p>Dear list,</p>\n<p>I am using Isabelle2025 and want to report an unexpected behaviour of a <br>\ncheck in Pure/goal.ML, function \"prove_common\" and in Pure/Isar/ <br>\nproof.ML, function \"conclude_goal\".</p>\n<p>Both functions try to check if the proven theorem is an instance of the <br>\noriginally passed theorem statement using \"Unify.matcher\". However, <br>\nUnify.matcher is incomplete for higher-order matching, e.g. it fails on <br>\nthe matching problem<br>\n\"(?f :: prop ⇒ prop) ((?x :: prop ⇒ prop) y) ≡ ?f y\"<br>\n(one solution: ?x |-&gt; λ_. y).</p>\n<p>As a consequence, sound proofs get rejected e.g. when using Goal.prove <br>\nand when writing a proof in Isar. Below I append an example theory file <br>\nshowcasing this, including a minimised version of a lemma that triggered <br>\nthis behaviour in my development.</p>\n<p>Optimally, one would like to have a complete higher-order matcher, but I <br>\nam not aware of a simple algorithm for that (though I am by no means an <br>\nexpert in this area). Checking the history of goal.ML and proof.ML <br>\nindicates that both have seen iterations trying to improve the <br>\ncompleteness of the instance check, i.e. this behaviour has been <br>\nconsidered and refined in the past.</p>\n<p>Since the check happens in goal.ML and proof.ML, it affects users of <br>\nIsabelle/ML and Isabelle/Isar.<br>\n(1) I wonder if the check in goal.ML is necessary at all?<br>\n(2) Would it be conceivable to temporarily disable the check (e.g. with <br>\na configuration option) in goal.ML and/or proof.ML for users?</p>\n<p>Best wishes,</p>\n<p>Kevin</p>\n<p>```isabelle<br>\ntheory Scratch<br>\n   imports Main<br>\nbegin</p>\n<p>lemma \"∃f. set (case xs of [] ⇒ [] | _ ⇒ f xs) = set []\"<br>\n   apply (rule exI)<br>\n   apply simp (<em>error: Proved a different theorem</em>)<br>\n   oops</p>\n<p>ML‹<br>\n   val ctxt = @{context}<br>\n   val read = Proof_Context.read_term_pattern ctxt<br>\n   val [t1, t2] = Syntax.read_terms (Proof_Context.set_mode <br>\nProof_Context.mode_schematic ctxt)<br>\n     [\"(?f :: prop ⇒ prop) ((?x :: prop ⇒ prop) y)\", \"?f y\"]<br>\n   val can_unif = Unify.matcher (Context.Proof ctxt) [t1] [t2] |&gt; <br>\nis_some (<em>false; no matcher found</em>)<br>\n›</p>\n<p>ML‹<br>\nlet<br>\n   val ctxt = @{context}<br>\n   val goal = read \"(?f :: bool ⇒ bool) ((?x :: bool ⇒ bool) y) ≡ ?f (?x <br>\ny)\"<br>\n   val insts = [<br>\n       (((\"x\", 0), @{typ \"bool ⇒ bool\"}), read \"λ_ :: bool. (y :: bool)\")<br>\n     ] |&gt; map (apsnd (Thm.cterm_of ctxt))<br>\nin<br>\n  (<em>error: Proved a different theorem</em>)<br>\n   Goal.prove ctxt [] [] goal<br>\n     (fn _ =&gt; PRIMITIVE (Thm.instantiate (TVars.empty, Vars.make insts))<br>\n       THEN HEADGOAL (resolve0_tac @{thms reflexive}))<br>\nend<br>\n›</p>\n<p>schematic_goal \"(?f :: bool ⇒ bool) ((?x :: bool ⇒ bool) y) ≡ ?f (?x y)\"<br>\napply (tactic ‹<br>\nlet<br>\n   val ctxt = @{context}<br>\n   val read = Proof_Context.read_term_pattern ctxt<br>\n   val insts = [<br>\n       (((\"x\", 0), @{typ \"bool ⇒ bool\"}), read \"λ_ :: bool. (y :: bool)\")<br>\n     ] |&gt; map (apsnd (Thm.cterm_of ctxt))<br>\nin PRIMITIVE (Thm.instantiate (TVars.empty, Vars.make insts)) end›) (<em>OK</em>)<br>\nby (rule reflexive) (<em>error: Proved a different theorem</em>)</p>\n<p>end<br>\n```</p>\n</blockquote>",
        "id": 534615130,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755245364
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis thread is already concluded, being mostly based on misunderstandings how <br>\nthings work.</p>\n<p>I merely want to report the situation concerning the regular documentation of <br>\nIsabelle/ML, which is a combination of \"isabelle doc implementation\" + reading <br>\nthe sources:</p>\n<p>* The implementation manual for talks conceptually about a \"prove\" <br>\noperation and then refers concretely to Goal.prove and Goal.prove_common. The <br>\ntext for \"prove\" is this:</p>\n<p>The ‹prove› operation provides an interface for structured backwards<br>\n   reasoning under program control, with some explicit sanity checks of the<br>\n   result. [...]</p>\n<p>* The documentation in ML is as follows: src/Pure/goal.ML defines things <br>\nclearly from the bottom up. Before introducing Goal.prove_common (and more <br>\n\"prove variations\"), there is this notable explanation:</p>\n<p>(* prove_internal -- minimal checks, no normalization of result! *)</p>\n<p>fun prove_internal ctxt casms cprop tac =<br>\n   (case SINGLE (tac (map (Assumption.assume ctxt) casms)) (init cprop) of<br>\n     SOME th =&gt; Drule.implies_intr_list casms (finish ctxt th)<br>\n   | NONE =&gt; error \"Tactic failed\");</p>\n<p>A quick \"induction over the sources\" (via hypersearch in Isabelle/jEdit) shows <br>\nthat Goal.prove_internal is only used in very few situations. So there is no <br>\nneed to emphasize it in the LaTeX-based documentation; the ML-based <br>\ndocumentation is sufficient.</p>\n<p>That's it. Thread closed.</p>\n<p>Makarius</p>",
        "id": 534638066,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755257442
    }
]