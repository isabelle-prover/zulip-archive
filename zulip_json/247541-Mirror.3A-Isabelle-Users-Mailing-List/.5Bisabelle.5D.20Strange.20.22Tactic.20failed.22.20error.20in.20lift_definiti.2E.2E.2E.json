[
    {
        "content": "<p>From: Florian Märkl &lt;<a href=\"mailto:isabelle-users@florianmaerkl.de\">isabelle-users@florianmaerkl.de</a>&gt;<br>\nHello,</p>\n<p>I just encountered some strange behavior when using the (code_dt) flag<br>\nof lift_definition as in this example:</p>\n<p>typedef imc = \"{mc :: nat. True ∧ True}\" by simp<br>\nsetup_lifting type_definition_imc<br>\nlift_definition (code_dt) lift_imco :: \"nat ⇒ imc option\" is Some by simp</p>\n<p>This throws the following error at the \"by simp\" of the lift_definition<br>\n(even sorry does the same):</p>\n<p>Tactic failed<br>\nThe error(s) above occurred for the goal statement⌂:<br>\nrel_fun (eq_onp (pred_option (λmc. True ∧ True))) (eq_onp (λmc. True ∧<br>\nTrue)) (case_option (Rep_imc undefined) (λx2. x2)) (case_option (Rep_imc<br>\nundefined) (λx2. x2))</p>\n<p>I'm not really sure what it is trying to tell me, the only suspicious<br>\nthing I can spot are the two \"undefined\"s in the goal.<br>\nWhat's funny is that if I make the predicate for the imc type just<br>\n\"True\" instead of \"True ∧ True\", it works. Is that a bug or maybe just a<br>\nlimitation of how the lifting works there?</p>\n<p>For a bit of context, I am using something similar to this in a project<br>\nwhere I have to construct an abstract type with invariants directly from<br>\nits base representation. I do this by checking the invariants on the<br>\nbase type and returning an option type of the abstract type that will be<br>\nNone whenever the invariants are not fulfilled. I also need (code_dt) to<br>\ngenerate code from it.<br>\nThere, my typedef initially looked something like this:</p>\n<p>typedef imc = \"{mc :: nat. invar_a mc ∧ invar_b mc ∧ ...}</p>\n<p>I just fixed it there by wrapping the conjunction in a single definition<br>\nso it's not a blocker for me but I would still be interested whether<br>\nthere is a solution or if it's a bug.</p>",
        "id": 222216326,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610275087
    }
]