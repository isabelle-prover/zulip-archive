[
    {
        "content": "<p>From: <a href=\"mailto:hannobecker@posteo.de\">hannobecker@posteo.de</a><br>\nHi,</p>\n<p>The following is about surprisingly (to me) strict behavior of <br>\n<code>adhoc_overloading</code> w.r.t. locale hierarchies.</p>\n<p>Suppose <code>adhoc_overloading</code> is used in the context of locale A:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">consts</span><span class=\"w\"> </span><span class=\"n\">foo_const</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span>\n<span class=\"k\">declare</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"n\">show_variants</span><span class=\"o\">]]</span>\n\n<span class=\"k\">locale</span><span class=\"w\"> </span><span class=\"n\">constA</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">   </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">some_nat</span><span class=\"o\">::</span><span class=\"n\">nat</span>\n<span class=\"k\">begin</span>\n<span class=\"w\">   </span><span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">‹some_nat_x2 ≡ some_nat + some_nat›</span>\n<span class=\"w\">   </span><span class=\"k\">adhoc_overloading</span><span class=\"w\"> </span><span class=\"n\">foo_const</span><span class=\"w\"> </span><span class=\"n\">some_nat_x2</span>\n\n<span class=\"w\">   </span><span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">‹foo_const + (0 :: nat)›</span><span class=\"w\"> </span><span class=\"c\">(* OK: \"some_nat_x2 + 0\" *)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Now, we inherit from A in the definition of another locale B and check <br>\nif the <code>adhoc_overloading</code> is inherited as well:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">locale</span><span class=\"w\"> </span><span class=\"n\">constB</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">constA</span><span class=\"w\"> </span><span class=\"n\">some_nat</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">some_nat</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">   </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">another_nat</span><span class=\"o\">::</span><span class=\"n\">nat</span>\n<span class=\"k\">begin</span>\n<span class=\"w\">   </span><span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">‹foo_const + (0 :: nat)›</span><span class=\"w\"> </span><span class=\"c\">(* OK: \"A.some_nat_x2 + 0\" *)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>This looks good. But it turns out that it only works if the locale <br>\nparameter names for A exactly match. The following does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">locale</span><span class=\"w\"> </span><span class=\"n\">constC</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">constA</span><span class=\"w\"> </span><span class=\"n\">some_other_nat</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">some_other_nat</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">   </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">another_nat</span><span class=\"o\">::</span><span class=\"n\">nat</span>\n<span class=\"k\">begin</span>\n<span class=\"w\">   </span><span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">‹foo_const + (0 :: nat)›</span><span class=\"w\"> </span><span class=\"c\">(* FAIL? Surprising! *)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>This is very surprising to me. It is also different from how <br>\nlocale-local named theorem list amendments are inherited, which works in <br>\nthe constC case as well.</p>\n<p>Is <code>adhoc_overloading</code>'s behaviorintentional here?</p>\n<p>I looked into the source code and noted that the adhoc_overloading <br>\ndeclaration goes through a very strict term filter when morphisms are <br>\napplied:</p>\n<div class=\"codehilite\" data-code-language=\"Standard ML\"><pre><span></span><code><span class=\"kr\">fun</span> <span class=\"nf\">adhoc_overloading_cmd'</span> <span class=\"n\">add</span> <span class=\"n\">args</span> <span class=\"n\">phi</span> <span class=\"p\">=</span>\n   <span class=\"kr\">let</span> <span class=\"kr\">val</span> <span class=\"nv\">args'</span> <span class=\"p\">=</span> <span class=\"n\">args</span>\n     <span class=\"n\">|&gt;</span> <span class=\"n\">map</span> <span class=\"p\">(</span><span class=\"n\">apsnd</span> <span class=\"p\">(</span><span class=\"n\">map_filter</span> <span class=\"p\">(</span><span class=\"kr\">fn</span> <span class=\"n\">t</span> <span class=\"p\">=&gt;</span>\n          <span class=\"kr\">let</span> <span class=\"kr\">val</span> <span class=\"nv\">t'</span> <span class=\"p\">=</span> <span class=\"nn\">Morphism</span><span class=\"p\">.</span><span class=\"n\">term</span> <span class=\"n\">phi</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n          <span class=\"kr\">in</span> <span class=\"kr\">if</span> <span class=\"nn\">Term</span><span class=\"p\">.</span><span class=\"n\">aconv_untyped</span> <span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">t'</span><span class=\"p\">)</span> <span class=\"kr\">then</span> <span class=\"n\">SOME</span> <span class=\"n\">t'</span> <span class=\"kr\">else</span> <span class=\"n\">NONE</span> <span class=\"kr\">end</span><span class=\"p\">)));</span>\n   <span class=\"kr\">in</span> <span class=\"n\">generic_adhoc_overloading_cmd</span> <span class=\"n\">add</span> <span class=\"n\">args'</span> <span class=\"kr\">end</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>If, for the sake of experiment only, I always return <code>SOME t'</code> (which is <br>\nalmost certainly not the right thing in general, of course), the <br>\nrigidity observed above goes away, and inheritance works as expected in <br>\nthe specific example. Should the term filter be weakened? Or is there a <br>\nreason why the rigidity of adhoc_overloading is deliberate here?</p>\n<p>Cheers,<br>\nHanno</p>\n<p>PS: Here's the complete standalone example</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Locales</span>\n<span class=\"w\">   </span><span class=\"kp\">imports</span><span class=\"w\"> </span><span class=\"n\">Main</span><span class=\"w\"> </span><span class=\"s\">\"HOL-Library.Adhoc_Overloading\"</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">consts</span><span class=\"w\"> </span><span class=\"n\">foo_const</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n n-Type\">'a</span>\n<span class=\"k\">declare</span><span class=\"w\"> </span><span class=\"o\">[[</span><span class=\"n\">show_variants</span><span class=\"o\">]]</span>\n\n<span class=\"k\">locale</span><span class=\"w\"> </span><span class=\"n\">constA</span><span class=\"w\"> </span><span class=\"o\">=</span>\n<span class=\"w\">   </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">some_nat</span><span class=\"o\">::</span><span class=\"n\">nat</span>\n<span class=\"k\">begin</span>\n<span class=\"w\">   </span><span class=\"k\">definition</span><span class=\"w\"> </span><span class=\"s\">‹some_nat_x2 ≡ some_nat + some_nat›</span>\n<span class=\"w\">   </span><span class=\"k\">adhoc_overloading</span><span class=\"w\"> </span><span class=\"n\">foo_const</span><span class=\"w\"> </span><span class=\"n\">some_nat_x2</span>\n\n<span class=\"w\">   </span><span class=\"k\">text</span><span class=\"s\">‹Inside the context of the locale, this works fine›</span>\n<span class=\"w\">   </span><span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">‹foo_const + (0 :: nat)›</span><span class=\"w\"> </span><span class=\"c\">(* \"some_nat_x2 + 0\" *)</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">text</span><span class=\"s\">‹Outside of the locale, the overloading is not visible, as</span>\n<span class=\"s\">expected:›</span>\n<span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">‹foo_const + (0 :: nat)›</span><span class=\"w\"> </span><span class=\"c\">(* fail *)</span>\n\n<span class=\"k\">text</span><span class=\"s\">‹Let's see if it inherits to sublocales:›</span>\n<span class=\"k\">locale</span><span class=\"w\"> </span><span class=\"n\">constB</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">constA</span><span class=\"w\"> </span><span class=\"n\">some_nat</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">some_nat</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">   </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">another_nat</span><span class=\"o\">::</span><span class=\"n\">nat</span>\n<span class=\"k\">begin</span>\n<span class=\"w\">   </span><span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">‹foo_const + (0 :: nat)›</span><span class=\"w\"> </span><span class=\"c\">(* OK: \"A.some_nat_x2 + 0\" *)</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">text</span><span class=\"s\">‹This looked good, but now for the weird bit: Try renaming the</span>\n<span class=\"s\">parameter to A!›</span>\n<span class=\"k\">locale</span><span class=\"w\"> </span><span class=\"n\">constC</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">constA</span><span class=\"w\"> </span><span class=\"n\">some_other_nat</span><span class=\"w\"> </span><span class=\"kp\">for</span><span class=\"w\"> </span><span class=\"n\">some_other_nat</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"n\">nat</span><span class=\"w\"> </span><span class=\"o\">+</span>\n<span class=\"w\">   </span><span class=\"kp\">fixes</span><span class=\"w\"> </span><span class=\"n\">another_nat</span><span class=\"o\">::</span><span class=\"n\">nat</span>\n<span class=\"k\">begin</span>\n<span class=\"w\">   </span><span class=\"kt\">term</span><span class=\"w\"> </span><span class=\"s\">‹foo_const + (0 :: nat)›</span><span class=\"w\"> </span><span class=\"c\">(* FAIL? Surprising! *)</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>",
        "id": 418015030,
        "sender_full_name": "Email Gateway",
        "timestamp": 1706163148
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Hanno,</p>\n<p>this behavior occurs similarly for notations:</p>\n<p>locale A =<br>\n   fixes f :: ‹'a ⇒ 'a›<br>\nbegin</p>\n<p>notation f (‹⦇_⦈›)</p>\n<p>term ‹f x›</p>\n<p>end</p>\n<p>locale B = A f for f<br>\nbegin</p>\n<p>term ‹f x›</p>\n<p>end</p>\n<p>locale C = A g for g<br>\nbegin</p>\n<p>term ‹g x›</p>\n<p>end</p>\n<p>The corresponding code presumably is <br>\n<a href=\"https://isabelle.in.tum.de/repos/isabelle/file/Isabelle2023/src/Pure/Isar/proof_context.ML#l1174\">https://isabelle.in.tum.de/repos/isabelle/file/Isabelle2023/src/Pure/Isar/proof_context.ML#l1174</a></p>\n<p>Personally, I would be inclined to attribute that extra-logical behavior <br>\nto a specific tradition in Isabelle how syntax is handled and <br>\napproximated. But this might be illusive.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p><a href=\"/user_uploads/14278/paFHgx0kWKqmXMwvb0BfrLwb/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/tH-rgshK2CeI9YNlfACPu_M5/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 419239907,
        "sender_full_name": "Email Gateway",
        "timestamp": 1706792022
    }
]