[
    {
        "content": "<p>From: Thomas Melham &lt;<a href=\"mailto:tom.melham@cs.ox.ac.uk\">tom.melham@cs.ox.ac.uk</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>Please excuse me for a beginners’ question!</p>\n<p>My student Dapeng Gao and I are looking into using Isabelle for symbolic execution of large microprocessor instruction set specifications. Our starting point is the translation into Isabelle definitions of the SAIL specification for the CHERI RSIC-V ISA:</p>\n<p><a href=\"https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-risc-v.html\">https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-risc-v.html</a></p>\n<p>This consists of a large number of function definitions that define the effect on visible architectural state of each of the CHERI RISC-V machine instructions – functions of the form</p>\n<p>InstructionX ins1 ins2 ... insn = &lt;effect on an architectural state monad&gt;</p>\n<p>where ins1, ins2, ... insn are variables raging over fields of the machine instruction X. E.g. register addresses, immediate data, etc.</p>\n<p>We want to be able to use Isabelle in “forward proof” mode, in which we specialise some or all of the variables ins1, ins2, ... insn to data structures containing some variables  (for example a list of Boolean bits, each represented by a variable). And then use rewriting and simplification to compute a kind of normal form effect on machine state as a function of the inputs. I.e. get a simplified logical expression on the RHS – which we can then traverse and translate into another language outside the logic.</p>\n<p>Is this kind of thing possible in Isabelle? We don’t want to have to type the right-and sides in, so goal directed proof is no use to us.</p>\n<p>Best regards,</p>\n<p>Tom</p>",
        "id": 235058655,
        "sender_full_name": "Email Gateway",
        "timestamp": 1618738148
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nTom,</p>\n<p>I’m sure there are a variety of ways to do this at the ML level, e.g. using the mechanisms the <code>subst</code> and <code>simp</code> methods leverage. This is likely to be the way to go for robustness. Look at the (Pure/)<code>Conv</code> structure for instance, which I expect is similar to what’s in HOL(4).</p>\n<p>At the Isar (surface) level you can try to use <code>schematic_goal</code>. There is some documentation somewhere — try the Isar reference manual. Thomas Sewell helped me with this:</p>\n<p><a href=\"https://www.isa-afp.org/browser_info/current/AFP/ConcurrentGC/Tactics.html\">https://www.isa-afp.org/browser_info/current/AFP/ConcurrentGC/Tactics.html</a><br>\n-&gt; <code>schematic_goal system_responds_actionE</code></p>\n<p>Note that schematic variables are sometimes aggressively instantiated by some tools. For instance I’d expect</p>\n<p>schematic_goal “1 + 2 = ?x” by simp</p>\n<p>to instantiate <code>?x</code> to <code>1 + 2</code>. Hence the very ginger small steps (mostly resolution) taken in the above theory. IIRC this behaviour is in the default simplifier solver setup, which you should be able to tweak without too much hassle but may result in breaking other things.</p>\n<p>cheers,<br>\npeter</p>",
        "id": 235115366,
        "sender_full_name": "Email Gateway",
        "timestamp": 1618794254
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe attached Scratch.thy provides some entry points that might actually help<br>\nto the original questions on this thread: to be explored in Isabelle/jEdit<br>\nwith C-hover-click on the various embedded items. If you also open<br>\n$ISABELLE_HOME/src/Pure/ROOT.ML (e.g. via the Documentation panel) you get IDE<br>\nmarkup for the Isabelle/Pure implementation: this is important to understand them.</p>\n<p>These are just some abstract hints to get started with the correct mindset and<br>\ntoolset.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/S3NwQpJcFjl1WQGESCKG1Slx/Scratch.thy\">Scratch.thy</a></p>",
        "id": 235157202,
        "sender_full_name": "Email Gateway",
        "timestamp": 1618827284
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYes, the classic way to \"drive the prover\" in ML following the LCF paradigm<br>\nworks very well in Isabelle. You merely need to keep in mind that Isabelle/ML<br>\nis always embedded into Isabelle/Isar, with a formal theory or proof context<br>\naround it. Even the toplevel ML bindings are stored in the formal context.</p>\n<p>As a start, just take Isabelle/jEdit and produce a theory file with some 'ML'<br>\nsnippets, e.g. copied from the sources of the manuals in<br>\n$ISABELLE_HOME/src/Doc or other examples.</p>\n<p>By expanding such Isabelle/ML snippets, they eventually become your tool<br>\nimplementation: experimentation and implementation is intertwined.</p>\n<p>Isabelle/ML text that grows too large becomes its own ML file eventually. See<br>\nalso the isar-ref manual on commands like 'ML', 'ML_file', but also 'ML_val'<br>\nfor exploring proof states.</p>\n<p>Makarius</p>",
        "id": 235163946,
        "sender_full_name": "Email Gateway",
        "timestamp": 1618831327
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:tals4@cam.ac.uk\">tals4@cam.ac.uk</a>&gt;<br>\nHi Thomas.</p>\n<p>I think it's worth adding that there are two sides to this story.</p>\n<p>Isabelle is a fairly flexible tool. You can probably use the simplifier,<br>\nin some form or another, to help you doing this rewriting, and it's<br>\npossible that it gets the job done easily.</p>\n<p>However, it's not clear to me from your explanation that Isabelle is the<br>\nright tool for the job. Isabelle is an interactive theorem prover, so <br>\nI'd<br>\nexpect you to be using it if you want to prove some theorem, and you <br>\naccept<br>\nsome interactive work as a cost of doing that. If you're just <br>\npreprocessing<br>\na function definition to pass to some other tool, perhaps you don't need<br>\nthat? If Isabelle doesn't turn out to solve your problems easily, <br>\nperhaps<br>\nyou could investigate some of the other SAIL backends.</p>\n<p>To extend on Pete Gammie's remark, you can also run the simplifier as a<br>\nrewriter from within a theory file like this:</p>\n<p>ML {*<br>\nSimplifier.rewrite<br>\n   (@{context} addsimps @{thms id_def})<br>\n   @{cterm \"f x\"}<br>\n*}</p>\n<p>Working within a theory file can be very convenient for experimentation.<br>\nI've used the old ASCII syntax above for reasons to do with email <br>\nformatting.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 235243012,
        "sender_full_name": "Email Gateway",
        "timestamp": 1618863846
    }
]