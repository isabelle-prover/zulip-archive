[
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;<br>\nI want to run the mirabelle try0 action in a larger session, e.g. HOL-ex.</p>\n<p>However, this doesn't quite work: the tools invoked by try0 can <br>\nsometimes run out of control and fill up the stack, so the thread gets <br>\nterminated:</p>\n<p>Warning - Unable to increase stack - interrupting thread<br>\n   HOL-ex FAILED (see also \"isabelle build_log -H Error HOL-ex\")<br>\n   *** exception Interrupt_Breakdown raised (line 77 of <br>\n\"./basis/PolyMLException.sml\")</p>\n<p>So my solution would be to wrap the try0 call in a separate thread, and <br>\ncount any exceptions within that thread as 'error' (see attached patch).</p>\n<p>This does work well in principle, but after a few thousand try0 calls <br>\n(with the invocation 'isabelle mirabelle -A try0 HOL-ex'), the Isabelle <br>\nprocess gets stuck: There is no further progress (judged by <br>\nprintline-debugging), and several CPU cores stay at 100% usage. This <br>\nhappens with both Isabelle2024 and current devel (and my actual <br>\napplication, which does not use mirabelle).</p>\n<p>Any ideas? From  My guess would be that this has to do with thread-local <br>\nmemory that is not properly deallocated, so the system is stuck in a GC <br>\nloop. From further experimentation I can conclude that the thread is <br>\nstarted, but the system never wakes up from the 'OS.Process.sleep' call <br>\nthat happens in 'Isabelle_Thread.join'. I've let the process run for <br>\nseveral days but it did not make any progress.</p>\n<p>Fabian</p>\n<p><a href=\"/user_uploads/14278/fovRWCBR1xdrNduQA3zIDkMs/try0_problem.patch\">try0_problem.patch</a></p>",
        "id": 486929455,
        "sender_full_name": "Email Gateway",
        "timestamp": 1733732014
    },
    {
        "content": "<p>From: Yutaka Nagashima &lt;<a href=\"mailto:united.reasoning@gmail.com\">united.reasoning@gmail.com</a>&gt;<br>\nHi Fabian,</p>\n<p>I’ve encountered similar issues and explored approaches along the same<br>\nlines.<br>\nFor some reason, Isabelle_Thread.joinand Isabelle_Thread.fork didn’t behave<br>\nas I expected. However, leveraging Future helped me resolve these issues in<br>\nmy tests so far.</p>\n<p>Jonathan’s code snippet appears straightforward and easy to use.<br>\n<a href=\"https://github.com/yonoteam/DeepIsaHOL/blob/292aa8ca66db998b98c49aec9a8b630c96fda656/src/main/ml/ops.ML#L202\">https://github.com/yonoteam/DeepIsaHOL/blob/292aa8ca66db998b98c49aec9a8b630c96fda656/src/main/ml/ops.ML#L202</a></p>\n<p>I’d be interested to hear Makarius’ thoughts on this, as it seems to<br>\naddress a common challenge faced by those integrating Isabelle’s subtools<br>\ninto larger automation workflows.</p>\n<p>Regards,<br>\nYutaka</p>\n<p>On Mon, Dec 9, 2024 at 1:43 PM Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>I want to run the mirabelle try0 action in a larger session, e.g. HOL-ex.</p>\n<p>However, this doesn't quite work: the tools invoked by try0 can<br>\nsometimes run out of control and fill up the stack, so the thread gets<br>\nterminated:</p>\n<p>Warning - Unable to increase stack - interrupting thread<br>\n   HOL-ex FAILED (see also \"isabelle build_log -H Error HOL-ex\")<br>\n   *** exception Interrupt_Breakdown raised (line 77 of<br>\n\"./basis/PolyMLException.sml\")</p>\n<p>So my solution would be to wrap the try0 call in a separate thread, and<br>\ncount any exceptions within that thread as 'error' (see attached patch).</p>\n<p>This does work well in principle, but after a few thousand try0 calls<br>\n(with the invocation 'isabelle mirabelle -A try0 HOL-ex'), the Isabelle<br>\nprocess gets stuck: There is no further progress (judged by<br>\nprintline-debugging), and several CPU cores stay at 100% usage. This<br>\nhappens with both Isabelle2024 and current devel (and my actual<br>\napplication, which does not use mirabelle).</p>\n<p>Any ideas? From  My guess would be that this has to do with thread-local<br>\nmemory that is not properly deallocated, so the system is stuck in a GC<br>\nloop. From further experimentation I can conclude that the thread is<br>\nstarted, but the system never wakes up from the 'OS.Process.sleep' call<br>\nthat happens in 'Isabelle_Thread.join'. I've let the process run for<br>\nseveral days but it did not make any progress.</p>\n<p>Fabian</p>\n</blockquote>",
        "id": 486940016,
        "sender_full_name": "Email Gateway",
        "timestamp": 1733734980
    },
    {
        "content": "<p>From: Lukas Bartl &lt;<a href=\"mailto:L.Bartl@campus.lmu.de\">L.Bartl@campus.lmu.de</a>&gt;<br>\nHi Fabian,</p>\n<p>I can confirm this issue. I also encountered these exceptions and Isabelle also got stuck when I used the mirabelle sledgehammer action. This happened with the default option \"try0\" which tries different proof methods similar to the try0 command (there were no errors when only the \"metis\" proof method was used).</p>\n<p>Lukas</p>\n<p>Am 9. Dezember 2024 09:07:09 MEZ schrieb Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;:</p>\n<blockquote>\n<p>I want to run the mirabelle try0 action in a larger session, e.g. HOL-ex.</p>\n<p>However, this doesn't quite work: the tools invoked by try0 can sometimes run out of control and fill up the stack, so the thread gets terminated:</p>\n<p>Warning - Unable to increase stack - interrupting thread<br>\n  HOL-ex FAILED (see also \"isabelle build_log -H Error HOL-ex\")<br>\n  *** exception Interrupt_Breakdown raised (line 77 of \"./basis/PolyMLException.sml\")</p>\n<p>So my solution would be to wrap the try0 call in a separate thread, and count any exceptions within that thread as 'error' (see attached patch).</p>\n<p>This does work well in principle, but after a few thousand try0 calls (with the invocation 'isabelle mirabelle -A try0 HOL-ex'), the Isabelle process gets stuck: There is no further progress (judged by printline-debugging), and several CPU cores stay at 100% usage. This happens with both Isabelle2024 and current devel (and my actual application, which does not use mirabelle).</p>\n<p>Any ideas? From  My guess would be that this has to do with thread-local memory that is not properly deallocated, so the system is stuck in a GC loop. From further experimentation I can conclude that the thread is started, but the system never wakes up from the 'OS.Process.sleep' call that happens in 'Isabelle_Thread.join'. I've let the process run for several days but it did not make any progress.</p>\n<p>Fabian<br>\n</p>\n</blockquote>",
        "id": 486956965,
        "sender_full_name": "Email Gateway",
        "timestamp": 1733739807
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nI don't use Mirabelle, but since a thread has appeared on this type of issue I will add<br>\nmy observations (which I have posted about in the past) about continuing issues of this nature:</p>\n<p>(*)  It is possible, during a normal session with Isabelle/JEdit, for the system to go unstable,<br>\n    consume memory up to any limits I have set (I have generally been using 64GB for Poly/ML),<br>\n    and then (often) for Poly/ML to be killed by the Linux OOM killer.  As best as I can tell,<br>\n    the actual culprits may be external provers that are invoked via \"smt\", rather than Poly/ML<br>\n    itself, which usually ends up being the victim.  The situation usually occurs when, due to<br>\n    changes earlier in the proof document, a subsequent proof \"by smt\" is rendered non-terminating<br>\n    and gets triggered by the normal continuous checking feature.  It is quite often the case<br>\n    that I get up from the computer and come back to find that this has occurred.  I try to<br>\n    work around this issue by making sure there are no proof methods with a \"purple\" color<br>\n    if I am going to leave the session alone for some time.</p>\n<p>(*)  It appears that under certain conditions Poly/ML can leak heap.  Symptoms are that the heap<br>\n    size gets closer and closer to the limit over time (again, I typically use 64GB), until<br>\n    useful work becomes impossible and it is necessary to restart and reload everything<br>\n    (after which the heap is much smaller).<br>\n    Sometimes the system will go into an \"infinite GC\" as the limit is neared, which sounds<br>\n    very much like what others on this thread are posting about.  Note that my workflow involves<br>\n    frequent invocations of sledgehammer.  Lately I have been using the sledgehammer panel<br>\n    \"Apply\" button for this, whereas in the past I was in the habit of using \"try\" and \"try0\",<br>\n    but the behavior seems similar.</p>\n<p>I speculate that this issue may be related to the frequent abrupt terminations of external<br>\n    provers -- possibly there are weak references or something to stuff in the Poly/ML heap<br>\n    that do not get freed sometimes when an external provers terminate abruptly.<br>\n    Usually during a session I get several pop-ups from the Linux \"apparmor\" reporting on the<br>\n    abrupt termination of cvc4, etc. via a signal.  These do not always seem to indicate errors<br>\n    in the external provers, but rather may derive from incorrect signal handling in glue code<br>\n    that causes the underlying system to report on the occurrence of these signals.</p>\n<p>(*)  Poly/ML can embark on full GC's that take <em>many</em>, <em>many</em> minutes (this with a 64GB heap limit,<br>\n    running on a machine with 128GB RAM -- no thrashing is occurring).  Sometimes the GC<br>\n    will not terminate after an hour or more, in which case it is necessary to restart the<br>\n    session and reload everything.  Symptoms while this is occurring usually seems to be<br>\n    cores pegged at 100% utilization (according to \"top\"), with no change for a long time.<br>\n    Usually GC's that are making progress will switch back and forth between 100% on one core<br>\n    and 100% on multiple cores, as opposed to appearing stagnant.</p>\n<p>System details: Intel i9/10850K (10 cores) with 128GB RAM, running Ubuntu 22.04.5 LTS<br>\n(GNU/Linux 6.8.0-49-generic x86_64).</p>\n<p>- Gene Stark</p>\n<p>On 12/9/24 05:19, Lukas Bartl wrote:</p>\n<blockquote>\n<p>Hi Fabian,</p>\n<p>I can confirm this issue. I also encountered these exceptions and Isabelle also got stuck when I used the mirabelle sledgehammer action. This happened with the default option \"try0\" which tries different proof methods similar to the try0 command (there were no errors when only the \"metis\" proof method was used).</p>\n<p>Lukas</p>\n<p>Am 9. Dezember 2024 09:07:09 MEZ schrieb Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;:</p>\n<blockquote>\n<p>I want to run the mirabelle try0 action in a larger session, e.g. HOL-ex.</p>\n<p>However, this doesn't quite work: the tools invoked by try0 can sometimes run out of control and fill up the stack, so the thread gets terminated:</p>\n<p>Warning - Unable to increase stack - interrupting thread<br>\n  HOL-ex FAILED (see also \"isabelle build_log -H Error HOL-ex\")<br>\n  *** exception Interrupt_Breakdown raised (line 77 of \"./basis/PolyMLException.sml\")</p>\n<p>So my solution would be to wrap the try0 call in a separate thread, and count any exceptions within that thread as 'error' (see attached patch).</p>\n<p>This does work well in principle, but after a few thousand try0 calls (with the invocation 'isabelle mirabelle -A try0 HOL-ex'), the Isabelle process gets stuck: There is no further progress (judged by printline-debugging), and several CPU cores stay at 100% usage. This happens with both Isabelle2024 and current devel (and my actual application, which does not use mirabelle).</p>\n<p>Any ideas? From  My guess would be that this has to do with thread-local memory that is not properly deallocated, so the system is stuck in a GC loop. From further experimentation I can conclude that the thread is started, but the system never wakes up from the 'OS.Process.sleep' call that happens in 'Isabelle_Thread.join'. I've let the process run for several days but it did not make any progress.</p>\n<p>Fabian<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 486970529,
        "sender_full_name": "Email Gateway",
        "timestamp": 1733743695
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;</p>\n<p>On 12/9/24 09:53, Yutaka Nagashima wrote:</p>\n<blockquote>\n<p>I’ve encountered similar issues and explored approaches along the same <br>\nlines.<br>\nFor some reason, Isabelle_Thread.joinand Isabelle_Thread.fork didn’t <br>\nbehave as I expected. However, leveraging Future helped me resolve <br>\nthese issues in my tests so far.</p>\n<p>Jonathan’s code snippet appears straightforward and easy to use. <br>\n<a href=\"https://github.com/yonoteam/DeepIsaHOL/blob/292aa8ca66db998b98c49aec9a8b630c96fda656/src/main/ml/ops.ML#L202\">https://github.com/yonoteam/DeepIsaHOL/blob/292aa8ca66db998b98c49aec9a8b630c96fda656/src/main/ml/ops.ML#L202</a></p>\n</blockquote>\n<p>This works better because Future uses a \"worker\" thread that stays alive <br>\nduring the whole execution.</p>\n<p>Curiously, when I run my real application with Futures, it does finish <br>\nall the work (after a few days) -- but the Isabelle process never stops <br>\nand there are two CPU cores at full load still (though my application <br>\ncalls sledgehammer, which does spawn its own threads).</p>\n<p>Best,</p>\n<p>Fabian</p>",
        "id": 488123113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1733930256
    }
]