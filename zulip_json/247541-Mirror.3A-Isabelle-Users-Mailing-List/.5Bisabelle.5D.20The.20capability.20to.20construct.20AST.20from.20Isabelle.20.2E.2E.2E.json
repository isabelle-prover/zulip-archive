[
    {
        "content": "<p>From: Alex Meyer &lt;<a href=\"mailto:alex153@outlook.lv\">alex153@outlook.lv</a>&gt;<br>\nHello!</p>\n<p>Group of scientists (I am not connected with them, of course) has published today the important preprint <a href=\"https://arxiv.org/abs/2112.15594\">https://arxiv.org/abs/2112.15594</a> in Arxiv:<br>\n\"A Neural Network Solves and Generates Mathematics Problems by Program Synthesis: Calculus, Differential Equations, Linear Algebra, and More\"<br>\nThey are using OpenAI Codex (automation of software synthesis from the natural language commands) and the pretrained neural language model GPT-3 to solve the math problems and to generate new problems.</p>\n<p>The most interesting technical aspect is that they encoded the math problems and their solutions as python or smth like that  (industrial programming language) expressions (I am still tryig to grasp). I.e. they are just using calculus (analysis - differential equations, algebra - polynomials, etc.) and they are not actually doing the full math (i.e. the invention of calculus and the proof of their correctness) that is possible with Isabelle.</p>\n<p>Last year I asked here several questions about the possibility to construct full AST from the Isabelle expressions and here was quite a scepticism about the possibility to do this. I am including example of my construction at the end of this message to show what I mean.</p>\n<p>The most important obstacle against the construction of AST from Isabelle expresions (that can be encoded/embedded by Graph Neural Networks as a vectors for the further processing - e.g. Isabelle specification/theorem can be encoded and used as a input to the neural solver (to search for the solution and search for the proof of the solution and use Isabelle estimation of the proof status as the reward that guides reinforcement learning search)) - as I understand - is the necessity to expand every node towards the first types (i, o) un the most primitive applications. E.g. my AST contains Orderings.ord_class.less, HOL.eq that can be expanded in such a way.</p>\n<p>But I am not sure whether this is a problem indeed. E.g. one can do such expansion, it can be costly, but one can do such expansion and create embedding vectors for Orderings.ord_class.less, HOL.eq and us them hierarchical fashion further, in more abstract reasoning. I.e. there may be no need to create fully expanded ASTs in every single case. On can construct partially expanded ASTs and assign precomputed embeddings to the leafs/nodes that nodes the complex notions (like function Orderings.ord_class.less).</p>\n<p>In any case, my aim with this message was to raise the importance of possibility to extract ASTs from Isabelle and to give back ASTs to Isabelle, to extract Isabelle expressions in some languages (JSON, Python, XML) that can be used for the embedding of those expressions into neural networks and for construction of language models. This interoperability aspect can be the Gutenberg factor for adoption of one or another proof asistant in the AI systems. There are Scala-Isabelle and Isabelle-MMT projects and I read about them half a year ago, maybe they are the foundations for the building this integration capability or (if it already exists) for raising awareness about it. Thanks!</p>\n<p>Alex</p>\n<p>{<br>\n    \"data\": {<br>\n        \"elementType\": \"term\",<br>\n        \"termType\": \"App\",<br>\n        \"pretty1\": \"(⟹) (b &lt; a)\",<br>\n        \"term1\": {<br>\n            \"elementType\": \"term\",<br>\n            \"termType\": \"App\",<br>\n            \"pretty1\": \"(⟹)\",<br>\n            \"term1\": {<br>\n                \"elementType\": \"term\",<br>\n                \"termType\": \"Const\",<br>\n                \"name\": \"Pure.imp\",<br>\n                \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" }<br>\n            },<br>\n            \"pretty2\": \"b &lt; a\",<br>\n            \"term2\": {<br>\n                \"elementType\": \"term\",<br>\n                \"termType\": \"App\",<br>\n                \"pretty1\": \"Trueprop\",<br>\n                \"term1\": {<br>\n                    \"elementType\": \"term\",<br>\n                    \"termType\": \"Const\",<br>\n                    \"name\": \"HOL.Trueprop\",<br>\n                    \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" }<br>\n                },<br>\n                \"pretty2\": \"b &lt; a\",<br>\n                \"term2\": {<br>\n                    \"elementType\": \"term\",<br>\n                    \"termType\": \"App\",<br>\n                    \"pretty1\": \"(&lt;) b\",<br>\n                    \"term1\": {<br>\n                        \"elementType\": \"term\",<br>\n                        \"termType\": \"App\",<br>\n                        \"pretty1\": \"(&lt;)\",<br>\n                        \"term1\": {<br>\n                            \"elementType\": \"term\",<br>\n                            \"termType\": \"Const\",<br>\n                            \"name\": \"Orderings.ord_class.less\",<br>\n                            \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" }<br>\n                        },<br>\n                        \"pretty2\": \"b\",<br>\n                        \"term2\": {<br>\n                            \"elementType\": \"term\",<br>\n                            \"termType\": \"Free\",<br>\n                            \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" },<br>\n                            \"name\": \"b\"<br>\n                        }<br>\n                    },<br>\n                    \"pretty2\": \"a\",<br>\n                    \"term2\": {<br>\n                        \"elementType\": \"term\",<br>\n                        \"termType\": \"Free\",<br>\n                        \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" },<br>\n                        \"name\": \"a\"<br>\n                    }<br>\n                }<br>\n            }<br>\n        },<br>\n        \"pretty2\": \"two_integer_max_case_def a b = a\",<br>\n        \"term2\": {<br>\n            \"elementType\": \"term\",<br>\n            \"termType\": \"App\",<br>\n            \"pretty1\": \"Trueprop\",<br>\n            \"term1\": {<br>\n                \"elementType\": \"term\",<br>\n                \"termType\": \"Const\",<br>\n                \"name\": \"HOL.Trueprop\",<br>\n                \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" }<br>\n            },<br>\n            \"pretty2\": \"two_integer_max_case_def a b = a\",<br>\n            \"term2\": {<br>\n                \"elementType\": \"term\",<br>\n                \"termType\": \"App\",<br>\n                \"pretty1\": \"(=) (two_integer_max_case_def a b)\",<br>\n                \"term1\": {<br>\n                    \"elementType\": \"term\",<br>\n                    \"termType\": \"App\",<br>\n                    \"pretty1\": \"(=)\",<br>\n                    \"term1\": {<br>\n                        \"elementType\": \"term\",<br>\n                        \"termType\": \"Const\",<br>\n                        \"name\": \"HOL.eq\",<br>\n                        \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" }<br>\n                    },<br>\n                    \"pretty2\": \"two_integer_max_case_def a b\",<br>\n                    \"term2\": {<br>\n                        \"elementType\": \"term\",<br>\n                        \"termType\": \"App\",<br>\n                        \"pretty1\": \"two_integer_max_case_def a\",<br>\n                        \"term1\": {<br>\n                            \"elementType\": \"term\",<br>\n                            \"termType\": \"App\",<br>\n                            \"pretty1\": \"two_integer_max_case_def\",<br>\n                            \"term1\": {<br>\n                                \"elementType\": \"term\",<br>\n                                \"termType\": \"Free\",<br>\n                                \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" },<br>\n                                \"name\": \"two_integer_max_case_def\"<br>\n                            },<br>\n                            \"pretty2\": \"a\",<br>\n                            \"term2\": {<br>\n                                \"elementType\": \"term\",<br>\n                                \"termType\": \"Free\",<br>\n                                \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" },<br>\n                                \"name\": \"a\"<br>\n                            }<br>\n                        },<br>\n                        \"pretty2\": \"b\",<br>\n                        \"term2\": {<br>\n                            \"elementType\": \"term\",<br>\n                            \"termType\": \"Free\",<br>\n                            \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" },<br>\n                            \"name\": \"b\"<br>\n                        }<br>\n                    }<br>\n                },<br>\n                \"pretty2\": \"a\",<br>\n                \"term2\": {<br>\n                    \"elementType\": \"term\",<br>\n                    \"termType\": \"Free\",<br>\n                    \"type\": { \"elementType\" : \"type\", \"typeType\" : \"MLValueTyp\" },<br>\n                    \"name\": \"a\"<br>\n                }<br>\n            }<br>\n        }<br>\n    }<br>\n}</p>",
        "id": 266669302,
        "sender_full_name": "Email Gateway",
        "timestamp": 1641204273
    }
]