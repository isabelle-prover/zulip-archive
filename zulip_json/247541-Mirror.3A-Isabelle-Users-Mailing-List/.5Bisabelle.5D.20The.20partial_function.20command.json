[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nHello,</p>\n<p>I am a fan of the partial_function command, but I noticed two small <br>\ntechnical shortcomings:</p>\n<ol>\n<li>Despite working with chain-complete partial orders, it can only <br>\ndefine <em>functions</em> that return a CCPO, not <em>values</em> of a CCPO. If you <br>\ntry to do something like</li>\n</ol>\n<p>partial_function (option) foo :: \"'a option\" where \"foo = foo\"</p>\n<p>you simply get: exception Empty raised (line 357 of \"library.ML\")</p>\n<p>You might think using partial_function to define a constant is silly, <br>\nbut there <em>are</em> settings where it makes sense, e.g. probabilistic ones:</p>\n<p>partial_function (spmf) foo :: \"nat spmf\"<br>\n   where \"foo = do {b ← coin_spmf; if b then return_spmf 0 else map_spmf <br>\nSuc foo}\"</p>\n<p>Of course, the problem can be avoided by simply adding a dummy parameter <br>\nof type unit.</p>\n<p>So is there any reason for why this is not supported? If one wanted to <br>\nsupport it, would one have to implement the \"unit abstraction hack\" or <br>\nis there a more direct way?</p>\n<ol start=\"2\">\n<li>The internal definition is not only not exposed to the user level <br>\n(i.e. \"thm foo_def\" does not work) but there also seems to be no way to <br>\naccess it from ML. The only thing that is returned is the term itself <br>\n(foo) and the recurrence (foo.simps). This makes it hard (if not <br>\nimpossible) to use partial_function as a component in other tools.</li>\n</ol>\n<p>Of course one could always write down the fixed point explicitly, but <br>\nthe partial_function command provides nice automation for e.g. <br>\nmonotonicity proofs that one would have to do manually.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 350474609,
        "sender_full_name": "Email Gateway",
        "timestamp": 1681728394
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nManuel,</p>\n<blockquote>\n<p>On 17 Apr 2023, at 20:46, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>I am a fan of the partial_function command, but I noticed two small technical shortcomings:</p>\n<ol>\n<li>Despite working with chain-complete partial orders, it can only define <em>functions</em> that return a CCPO, not <em>values</em> of a CCPO. If you try to do something like</li>\n</ol>\n<p>partial_function (option) foo :: \"'a option\" where \"foo = foo\"</p>\n<p>you simply get: exception Empty raised (line 357 of \"library.ML\")</p>\n<p>You might think using partial_function to define a constant is silly, but there <em>are</em> settings where it makes sense, e.g. probabilistic ones:</p>\n<p>partial_function (spmf) foo :: \"nat spmf\"<br>\n  where \"foo = do {b ← coin_spmf; if b then return_spmf 0 else map_spmf Suc foo}\"</p>\n<p>Of course, the problem can be avoided by simply adding a dummy parameter of type unit.</p>\n<p>So is there any reason for why this is not supported? If one wanted to support it, would one have to implement the \"unit abstraction hack\" or is there a more direct way?</p>\n</blockquote>\n<p>I’d like to see that too but it strikes me as not too much bother to just use the fixed-point combinator directly in these cases.</p>\n<blockquote>\n<ol start=\"2\">\n<li>The internal definition is not only not exposed to the user level (i.e. \"thm foo_def\" does not work) but there also seems to be no way to access it from ML. The only thing that is returned is the term itself (foo) and the recurrence (foo.simps). This makes it hard (if not impossible) to use partial_function as a component in other tools.</li>\n</ol>\n</blockquote>\n<p>Try</p>\n<p>context<br>\n  notes [[function_internals]]<br>\nbegin</p>\n<p>partial_function (spmf) ….<br>\n(* put a valid def here *)</p>\n<p>print_theorems</p>\n<p>end</p>\n<p>(see e.g. CryptHOL in the AFP)</p>\n<p>I tend to feel that <code>partial_function</code> should always yield a def.</p>\n<blockquote>\n<p>Of course one could always write down the fixed point explicitly, but the partial_function command provides nice automation for e.g. monotonicity proofs that one would have to do manually.</p>\n</blockquote>\n<p>Is there really much gained for recursively-defined CAFs (Haskell terminology)? No parameters, no interesting monotonicity.</p>\n<p>regards,<br>\nPeter</p>",
        "id": 350479263,
        "sender_full_name": "Email Gateway",
        "timestamp": 1681729666
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;</p>\n<blockquote>\n<p>context<br>\n   notes [[function_internals]]<br>\nbegin</p>\n</blockquote>\n<p>Aha, good to know! Thanks. I wasn't aware that worked for <br>\npartial_function as well.</p>\n<blockquote>\n<p>I tend to feel that <code>partial_function</code> should always yield a def.<br>\nI feel so, too. Especially in ML. Calling a command and then making a <br>\nstring and accessing a generated theorem by name seems hacky to me.</p>\n</blockquote>\n<blockquote>\n<p>Is there really much gained for recursively-defined CAFs (Haskell terminology)? No parameters, no interesting monotonicity.</p>\n</blockquote>\n<p>Honestly I haven't given that much thought. For me it's mainly a matter <br>\nof uniformity: if you want to build some automation on top of <br>\npartial_function (which I have very vague mid-term plans to do) it's <br>\nannoying if you have to add a case distinction like that.</p>\n<p>Manuel</p>",
        "id": 350480189,
        "sender_full_name": "Email Gateway",
        "timestamp": 1681729947
    }
]