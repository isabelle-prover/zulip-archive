[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHello List.</p>\n<p>I ran into the following unexpected (for me) behaviour:</p>\n<p>consts f :: \"'a ⇒ bool\"</p>\n<p>lemmas foo1 = conjI[where P=\"f A\", OF _ conjI[where Q=\"f A\"]] for A</p>\n<p>Yields: ⟦f ?A; ?P; f ?Aa⟧ ⟹ f ?A ∧ ?P ∧ f ?Aa<br>\n  Expected: ⟦f ?A; ?P; f ?A⟧ ⟹ f ?A ∧ ?P ∧ f ?A</p>\n<p>(Note the duplication of ?A into ?A and ?Aa)</p>\n<p>Question to the experts:<br>\nIs this behaviour intentional? If yes, why does it differ from what <br>\ncontext fixes A would do (see below)?</p>\n<p>Analysis:<br>\n  The \"for\" fixes the variable A, but not its type, which remains<br>\nschematic. As soon as an operation changes schematic names, like, e.g.,<br>\nthe incr_indexes in OF, we have <em>two</em> variables A, with the same name<br>\nbut different types. The export that happens afterwards will<br>\ndisambiguate the names.</p>\n<p>Workarounds:<br>\n  Possibility 1: Specify the type of A <em>completely</em>. <br>\n  Wildcards <em>cannot</em> be used!</p>\n<p>lemmas foo3 = conjI[where P=\"f A\", OF _ conjI[where Q=\"f A\"]] for A<br>\n:: 'a<br>\n  (* ⟦f ?A; ?P; f ?A⟧ ⟹ f ?A ∧ ?P ∧ f ?A *)</p>\n<p>Wildcards don't work:<br>\n  lemmas foo2 = conjI[where P=\"f A\", OF _ conjI[where Q=\"f A\"]] for A<br>\n:: \"'a * _\"<br>\n  (* ⟦f ?A; ?P; f ?Aa⟧ ⟹ f ?A ∧ ?P ∧ f ?Aa *)</p>\n<p>Possibility 2: Use context fixes:</p>\n<p>context fixes A begin<br>\n    lemmas foo4 = conjI[where P=\"f A\", OF _ conjI[where Q=\"f A\"]]<br>\n    (* ⟦f A; ?P; f A⟧ ⟹ f A ∧ ?P ∧ f A *)<br>\n  end<br>\n  thm foo4<br>\n  (* ⟦f ?A; ?P; f ?A⟧ ⟹ f ?A ∧ ?P ∧ f ?A *)</p>\n<p>Best<br>\n  Peter</p>",
        "id": 205346996,
        "sender_full_name": "Email Gateway",
        "timestamp": 1596024175
    }
]