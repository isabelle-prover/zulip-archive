[
    {
        "content": "<p>From: Johannes Neubrand &lt;<a href=\"mailto:neubrand@in.tum.de\">neubrand@in.tum.de</a>&gt;<br>\nHi all,</p>\n<p>I'm trying to call an Isar method entirely from ML. Does anyone have <br>\npointers to looking up the method in ML and giving it Isabelle/HOL terms <br>\nas arguments (that would usually be passed in in parentheses such as in <br>\n<code>(measure \"my_term_here\")</code>)?</p>\n<p>I'd like to avoid rebuilding the method in ML and continue using the <br>\npresent Eisbach definition for readability.</p>\n<p>The cookbook seems not to cover this topic. I'd be glad if someone could <br>\nlink me to a theory where this is accomplished.</p>\n<p>Thanks,<br>\nJohannes</p>",
        "id": 304652089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1666089756
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 18/10/2022 12:42, Johannes Neubrand wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I'm trying to call an Isar method entirely from ML. Does anyone have pointers <br>\nto looking up the method in ML and giving it Isabelle/HOL terms as arguments <br>\n(that would usually be passed in in parentheses such as in <code>(measure \n\"my_term_here\")</code>)?</p>\n</blockquote>\n<p>The proper way is to use the ML type tactic directly, together with its many <br>\ncombinators (tacticals).</p>\n<p>The result can be easily integrated into the Isar proof language via the proof <br>\nmethod \"tactic\" (for experimentation) or the command 'method_setup' (for <br>\nproduction quality). See also the \"isar-ref\" and \"implementation\" manual, <br>\nwhich contains general explanations and tiny examples.</p>\n<p>The remaining exercise is to look at the real Isabelle sources, and learn <br>\nwhich applications/examples are good and which are bad, outdated etc.</p>\n<p>Sometimes, tool authors have forgotten to expose proper ML interfaces to their <br>\nproof methods: this is an error, and needs to be sorted out in the tool <br>\nimplementation.</p>\n<blockquote>\n<p>I'd like to avoid rebuilding the method in ML and continue using the present<br>\nEisbach definition for readability.</p>\n</blockquote>\n<p>Readability is relative to what the reader knows. After learning about ML type <br>\ntactic, that is readable, robust, maintainable.</p>\n<p>Embedded \"scripts\" are not: there is a whole lot of extra complexity to make <br>\nsomething like Eisbach work most of the time (but not always).</p>\n<blockquote>\n<p>The cookbook seems not to cover this topic. I'd be glad if someone could link <br>\nme to a theory where this is accomplished.</p>\n</blockquote>\n<p>The cookbook is unofficial \"fan fiction\", and not the first place to look.</p>\n<p>Makarius</p>",
        "id": 304664026,
        "sender_full_name": "Email Gateway",
        "timestamp": 1666094797
    },
    {
        "content": "<p>From: Yutaka Nagashima &lt;<a href=\"mailto:united.reasoning@gmail.com\">united.reasoning@gmail.com</a>&gt;<br>\nHi Johannes,</p>\n<p>As Makarius wrote, using the corresponding ML tactic directly is usually a<br>\ngood idea.</p>\n<p>But for some reason I had to make a \"tactic\" out of a string such as \"auto<br>\nsimp: my_lemma\" sometimes.<br>\nSo, I wrote this function:<br>\n<a href=\"https://github.com/data61/PSL/blob/a6f2de70be57339ba9c9f89ddf6409a453398037/SeLFiE/Util.ML#L1198\">https://github.com/data61/PSL/blob/a6f2de70be57339ba9c9f89ddf6409a453398037/SeLFiE/Util.ML#L1198</a></p>\n<p>Note that here I am not using the word \"tactic\" accurately.<br>\nThat is, tactics in Isabelle are functions takes a value of type Thm.thm<br>\nand returns a lazy sequence of thms (thm seq),<br>\nbut my \"tactic\"s are functions, each of which takes a value of type<br>\nProof.state and returns a lazy sequence of Proof.states.</p>\n<p>It allows us to do something like \"Repeat (Hammer)\".</p>\n<p>Regards,<br>\nYutaka</p>",
        "id": 305704624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1666556402
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<blockquote>\n<p>Note that here I am not using the word \"tactic\" accurately.</p>\n</blockquote>\n<p>and if an actual <em>tactic</em> is needed, I found this function in my code:</p>\n<p><a href=\"https://github.com/dominique-unruh/qrhl-tool/blob/c4cbb6a2f92e05d7562953b8c34ebf5974cd2a66/isabelle-thys/qrhl_operations.ML#L338\">https://github.com/dominique-unruh/qrhl-tool/blob/c4cbb6a2f92e05d7562953b8c34ebf5974cd2a66/isabelle-thys/qrhl_operations.ML#L338</a></p>\n<p>(I wrote it quite a while ago, so I cannot say much about the pros and <br>\ncons of it. I think one disadvantage is definitely that it reparses the <br>\nmethod on each invocation when you have it in some loop. But it may be a <br>\nstarting point for experiments.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 305759993,
        "sender_full_name": "Email Gateway",
        "timestamp": 1666595795
    },
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nI just ran into the same question. Here's a simple working example:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span><span class=\"w\"> </span><span class=\"n\">Scratch</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kp\">imports</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">Main</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"s\">\"HOL-Eisbach.Eisbach\"</span><span class=\"w\"></span>\n<span class=\"k\">begin</span><span class=\"w\"></span>\n\n<span class=\"n\">method</span><span class=\"w\"> </span><span class=\"n\">my_simp</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">simp</span><span class=\"w\"></span>\n\n<span class=\"k\">ML</span><span class=\"s\">‹</span>\n<span class=\"s\">   fun my_simp_tac ctxt =</span>\n<span class=\"s\">     Method_Closure.apply_method @{context} @{method \"my_simp\"} [] [] []</span>\n<span class=\"s\">ctxt []</span>\n<span class=\"s\">     |&gt; Context_Tactic.NO_CONTEXT_TACTIC @{context}</span>\n<span class=\"s\">›</span><span class=\"w\"></span>\n\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"(1 :: nat) + 1 = 2\"</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">tactic</span><span class=\"w\"> </span><span class=\"s\">‹my_simp_tac @{context}›</span><span class=\"o\">)</span><span class=\"w\"></span>\n\n<span class=\"k\">end</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 322092550,
        "sender_full_name": "Email Gateway",
        "timestamp": 1674058507
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:xs@xaph.net\">xs@xaph.net</a>&gt;<br>\nNot sure how useful you'll find it, but you can build up a stack of<br>\nthese, i.e. if you have a method that takes another method as an<br>\nargument, you can invoke it with one of these, e.g.</p>\n<p>val solves_wpsimp =<br>\n   let<br>\n     fun wpsimp st = Method_Closure.apply_method st @{method wpsimp} [] [] [] st<br>\n     fun solves_wpsimp_tac st = Method_Closure.apply_method st @{method solves} [] [] [wpsimp] st<br>\n   in solves_wpsimp_tac end</p>\n<p>If you have a tac but need to give it to a method:</p>\n<p>fun rtac st = METHOD (HEADGOAL o Method.rule_tac st [thm]);<br>\nfun mr_sh_tac st = Method_Closure.apply_method st @{method monadic_rewrite_solve_head}<br>\n                                                [] [] [rtac] st;</p>\n<p>As you already indicated, if you have a method but need a tac,<br>\nNO_CONTEXT_TACTIC seems the way to go.</p>\n<p>Raf.</p>",
        "id": 322184769,
        "sender_full_name": "Email Gateway",
        "timestamp": 1674091219
    }
]