[
    {
        "content": "<p>From: Matthys Grobbelaar &lt;<a href=\"mailto:m.grobbelaar@uq.net.au\">m.grobbelaar@uq.net.au</a>&gt;<br>\nI'm currently creating new syntax translations for a project I'm working on however I'm having issues with incorrect contexts being passed into the parse_translation function.</p>\n<p>For context, I've added the new syntax as follows:<br>\n    syntax \"_myrelation\" :: \"args =&gt; 'a set\" (\"&lt;\\lrel&gt;_&lt;\\rrel&gt;\")<br>\nwhere &lt;\\lrel&gt;  and &lt;\\rrel&gt; are new symbols which have been added.</p>\n<p>The translation is then done via:<br>\n    parse_translation &lt;\\open&gt;[(@{syntax_const \"_myrelation\"}, translate_relation)]</p>\n<p>Essentially what this translation will be doing is taking an expression like<br>\n    &lt;\\lrel&gt;x &gt; x'&lt;/rrel&gt;<br>\nand converting it into<br>\n   {((x, y), (x', y')) | x &gt; x'}<br>\nwhere the variables in the tuples (i.e. (x,y), (x', y')) are dynamic from the context wherein the translation takes place.</p>\n<p>At the moment, I've been able to add these variables into a queue stored in the global context using the following:<br>\n    structure VarList: VAR_LIST =<br>\n    struct</p>\n<p>structure Terms = Theory_Data<br>\n    (<br>\n        type T = term Queue.T;<br>\n        val empty = Queue.empty;<br>\n        val extend = I;<br>\n        fun merge (ts1, ts2) =<br>\n                fold Queue.enqueue (Library.merge (op =) (Queue.content ts1, Queue.content ts2)) Queue.empty;<br>\n    );</p>\n<p>val get = Terms.get</p>\n<p>fun add raw_t thy =<br>\n        let<br>\n            val t = Sign.cert_term thy raw_t<br>\n        in<br>\n<a href=\"http://Terms.map\">Terms.map</a> (Queue.enqueue t) thy<br>\n        end;<br>\n    end;</p>\n<p>With this structure, I have then been able to update the context using setup:<br>\n    setup &lt;\\open&gt;<br>\n        VarList.add (@{term \"x::int\"}) #&gt;<br>\n        VarList.add (@{term \"y::int\"})<br>\n    &lt;/close&gt;</p>\n<p>To test out whether the context is in fact being updated, I created a dummy translation function which prints out the values stored in the queue.</p>\n<p>ML &lt;\\open&gt;<br>\n        fun translate_relation_test ctxt [trm] =<br>\n            let<br>\n                val varlist = VarList.get (Context.theory_of (Context.Proof ctxt))<br>\n                val _ = VarList.print_vars varlist ctxt<br>\n            in undefined<br>\n    &lt;/close&gt;</p>\n<p>If I call this dummy function right below the setup, the variables are printed correctly:<br>\n        &lt;end of setup&gt;<br>\n        translate_relation_test (Context.the_local_context ()) [@{term \"x &gt; x'\"}];    -- queue has the added variables</p>\n<p>However, when I try to do a translation, the queue remains empty:<br>\n       &lt;lrel&gt;x &gt; x'&lt;/rrel&gt;  -- added variables are not printed</p>\n<p>This leaves me with a lot of questions. Is there something I'm missing about contexts? Is a different context being used for syntax translations? Is this the correct way to go about doing a translation like this?</p>\n<p>Any help would be greatly appreciated.<br>\nAlso, this is the first time I'm sending something to this mailing list so please let me know if I'm asking in the correct place.</p>\n<p>Kind regards and thank you in advance,<br>\nMatthys Grobbelaar</p>",
        "id": 236051418,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619342251
    }
]