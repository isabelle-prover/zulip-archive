[
    {
        "content": "<p>From: Jakub Kądziołka &lt;<a href=\"mailto:kuba@kadziolka.net\">kuba@kadziolka.net</a>&gt;<br>\nGreetings,</p>\n<p>currently, generate_pow_card assumes \"finite (carrier G)\". This is<br>\nunnecessary, as evidenced by the modified proof I'm including below.<br>\nI modified two lemmas above it to only assume that a relevant subgroup<br>\nis finite, instead of the entire group. Also, the removed assumption<br>\nleads to a simpler proof of ord_dvd_group_order.</p>\n<p>Regards,<br>\nJakub Kądziołka</p>\n<p>theory Scratch<br>\n  imports \"HOL-Algebra.Algebra\"<br>\nbegin</p>\n<p>context group begin</p>\n<p>lemma ord_elems_inf_carrier:<br>\n  assumes \"a ∈ carrier G\" \"ord a ≠ 0\"<br>\n  shows \"{a[^]x | x. x ∈ (UNIV :: nat set)} = {a[^]x | x. x ∈ {0 .. ord a - 1}}\" (is \"?L = ?R\")<br>\nproof<br>\n  show \"?R ⊆ ?L\" by blast<br>\n  { fix y assume \"y ∈ ?L\"<br>\n    then obtain x::nat where x: \"y = a[^]x\" by auto<br>\n    define r q where \"r = x mod ord a\" and \"q = x div ord a\"<br>\n    then have \"x = q * ord a + r\"<br>\n      by (simp add: div_mult_mod_eq)<br>\n    hence \"y = (a[^]ord a)[^]q ⊗ a[^]r\"<br>\n      using x assms by (metis mult.commute nat_pow_mult nat_pow_pow)<br>\n    hence \"y = a[^]r\" using assms by simp<br>\n    have \"r &lt; ord a\" using assms by (simp add: r_def)<br>\n    hence \"r ∈ {0 .. ord a - 1}\" by (force simp: r_def)<br>\n    hence \"y ∈ {a[^]x | x. x ∈ {0 .. ord a - 1}}\" using ‹y=a[^]r› by blast<br>\n  }<br>\n  thus \"?L ⊆ ?R\" by auto<br>\nqed</p>\n<p>lemma generate_pow_nat:<br>\n  assumes a: \"a ∈ carrier G\" and \"ord a ≠ 0\"<br>\n  shows \"generate G { a } = { a [^] k | k. k ∈ (UNIV :: nat set) }\"<br>\nproof<br>\n  show \"{ a [^] k | k. k ∈ (UNIV :: nat set) } ⊆ generate G { a }\"<br>\n  proof<br>\n    fix b assume \"b ∈ { a [^] k | k. k ∈ (UNIV :: nat set) }\"<br>\n    then obtain k :: nat where \"b = a [^] k\" by blast<br>\n    hence \"b = a [^] (int k)\"<br>\n      by (simp add: int_pow_int)<br>\n    thus \"b ∈ generate G { a }\"<br>\n      unfolding generate_pow[OF a] by blast<br>\n  qed<br>\nnext<br>\n  show \"generate G { a } ⊆ { a [^] k | k. k ∈ (UNIV :: nat set) }\"<br>\n  proof<br>\n    fix b assume \"b ∈ generate G { a }\"<br>\n    then obtain k :: int where k: \"b = a [^] k\"<br>\n      unfolding generate_pow[OF a] by blast<br>\n    show \"b ∈ { a [^] k | k. k ∈ (UNIV :: nat set) }\"<br>\n    proof (cases \"k &lt; 0\")<br>\n      assume \"¬ k &lt; 0\"<br>\n      hence \"b = a [^] (nat k)\"<br>\n        by (simp add: k)<br>\n      thus ?thesis by blast<br>\n    next<br>\n      assume \"k &lt; 0\"<br>\n      hence b: \"b = inv (a [^] (nat (- k)))\"<br>\n        using k a by (auto simp: int_pow_neg)<br>\n      obtain m where m: \"ord a * m ≥ nat (- k)\"<br>\n        by (metis assms(2) dvd_imp_le dvd_triv_right le_zero_eq mult_eq_0_iff not_gr_zero)<br>\n      hence \"a [^] (ord a * m) = 𝟭\"<br>\n        by (metis a nat_pow_one nat_pow_pow pow_ord_eq_1)<br>\n      then obtain k' :: nat where \"(a [^] (nat (- k))) ⊗ (a [^] k') = 𝟭\"<br>\n        using m a nat_le_iff_add nat_pow_mult by auto<br>\n      hence \"b = a [^] k'\"<br>\n        using b a by (metis inv_unique' nat_pow_closed nat_pow_comm)<br>\n      thus \"b ∈ { a [^] k | k. k ∈ (UNIV :: nat set) }\" by blast<br>\n    qed<br>\n  qed<br>\nqed</p>\n<p>lemma generate_pow_card:<br>\n  assumes a: \"a ∈ carrier G\"<br>\n  shows \"ord a = card (generate G { a })\"<br>\nproof (cases \"ord a = 0\")<br>\n  case True<br>\n  then have \"infinite (carrier (subgroup_generated G {a}))\"<br>\n    using infinite_cyclic_subgroup_order[OF a] by auto<br>\n  then have \"infinite (generate G {a})\"<br>\n    unfolding subgroup_generated_def<br>\n    using a by simp<br>\n  then show ?thesis<br>\n    using <code>ord a = 0</code> by auto<br>\nnext<br>\n  case False<br>\n  note finite_subgroup = this<br>\n  then have \"generate G { a } = (([^]) a) ` {0..ord a - 1}\"<br>\n    using generate_pow_nat ord_elems_inf_carrier a by auto<br>\n  hence \"card (generate G {a}) = card {0..ord a - 1}\"<br>\n    using ord_inj[OF a] card_image by metis<br>\n  also have \"... = ord a\" using finite_subgroup by auto<br>\n  finally show ?thesis.. <br>\nqed</p>\n<p>lemma ord_dvd_group_order: <br>\n  assumes \"a ∈ carrier G\"<br>\n  shows \"(ord a) dvd (order G)\"<br>\nproof -<br>\n  show ?thesis<br>\n    using lagrange[OF generate_is_subgroup[of \"{a}\"]] assms<br>\n    unfolding generate_pow_card[OF assms]<br>\n    by (metis dvd_triv_right empty_subsetI insert_subset)<br>\nqed</p>\n<p>end<br>\nend</p>",
        "id": 216652420,
        "sender_full_name": "Email Gateway",
        "timestamp": 1605292203
    }
]