[
    {
        "content": "<p>From: \"\\\"Putti, Edoardo (UT-EEMCS)\\\"\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear list,</p>\n<p>I am writing a verification condition generation tactic and I have two questions.</p>\n<ol>\n<li>Using match focuses the goal and instantiate schematic variables. Is there a way to control this behavior?</li>\n<li>Is there a way to have match abstract over terms of different types?</li>\n</ol>\n<p>The problem with 1 is that irrespective of the matchin pattern (for fixes, schematics, _)  match<br>\nalways instantiates the schematics by focusing on the subgoal. This happens even when the names introduced<br>\nare not used/bound in the match body.  A matching goal like \"hoare ?P C ?Q\" gets instantiated to \"hoare P C Q\"<br>\nand this cannot match any specification I have. Is there a way to control this focusing behavior, e.g. an option?</p>\n<p>The second issue becomes clearer with an example. The following is a pattern for guiding the tactic to use a specific lemma for verification condition generation. The precondition P is tagged with a marker, i.e. STATE P, the vcg_lemma can be used as<br>\nan elimination rule to remove it from the premises.</p>\n<p>definition STATE :: \"('s ⇒ bool) ⇒ 's ⇒ bool\"<br>\n― ‹tagging of state predicates for use in preconditions›<br>\n  where<br>\n\"STATE P ≡ P\"</p>\n<p>lemma STATE_vcg:<br>\n  assumes pre: \"STATE P s\" and spec: \"hoare P' M Q'\"<br>\n  and pre_framing: \"⋀ s. P s ⟹  (P' ** F) s\"<br>\n  and post_framing: \"⋀ x s. STATE (Q' x ** F) s ⟹  Q x s\"<br>\nshows \"wp_cnres M Q s\"</p>\n<p>If I want to extend this pattern with more markers, .e.g. LOCK lid, I add a LOCK_vcg lemma. I can make the<br>\nvcg tactic more generic by adding all my vcg lemmas into one fact abstraction but this is not enough.</p>\n<p>I don't have a way to abstract over the marker terms and I need to repeat the same pattern as long as I introduce more markers.<br>\nMy tactic is not really extensible.</p>\n<p>(match premises in marker [thin]: \"STATE P s\" for P ⇒ ‹(rule vcg_lemmas[OF marker])›)<br>\n| (match premises in marker [thin]: \"LOCK lid\" for lid ⇒ ‹(rule vcg_lemmas[OF marker])›)</p>\n<p>Is there a simple solution that I am missing? I know I can abstract over terms but the type-checking does not allow me to mix<br>\nthem as I would like.</p>\n<p>The obvious solution to me is to have an overloadable constant but using that as the marker in the tactic does not work as<br>\nI expected. The tactic never matches over the overloadable marker. Is there a way to obtain this behavior from Eisbach?</p>\n<p>Wishful thinking example below.</p>\n<p>consts marker :: \"('s ⇒ bool) ⇒ ('s ⇒ bool)\"<br>\noverloading<br>\n  marker_state ≡ marker<br>\n  marker_lock  ≡ marker<br>\n...</p>\n<p>lemma STATE_vcg [vcg_lemmas]:<br>\n  assumes pre: \"marker_state P s\" and spec: \"hoare P' M Q'\"<br>\n  ...</p>\n<p>lemma LOCK_vcg [vcg_lemmas]:<br>\n  assumes pre: \"marker_lock lid\" and spec: \"hoare P' M Q'\"<br>\n  ...</p>\n<p>method vcg = ... (match premises in marker [thin]: \"marker P\" for P ⇒ ‹(rule vcg_lemmas[OF marker])›)</p>\n<p>Thanks for the help</p>\n<p>Edoardo</p>",
        "id": 527473587,
        "sender_full_name": "Email Gateway",
        "timestamp": 1751892862
    }
]