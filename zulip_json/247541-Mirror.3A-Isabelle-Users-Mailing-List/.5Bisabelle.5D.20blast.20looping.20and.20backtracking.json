[
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nDear list,</p>\n<p>I like to tag unconditional facts (<code>0 &lt; 1</code>, <code>X ⊆ X</code>, <code>x ∈ {x}</code>) as<br>\n[intro!] rules. In combination with a suitable elim rule and goal<br>\nstatement, this lead to a looping behaviour of blast that I did not<br>\nexpect. Here is a minimal, contrived example:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">definition</span> <span class=\"s\">\"P x ≡ True\"</span>\n\n<span class=\"kn\">lemma</span> <span class=\"o\">[</span><span class=\"n\">intro</span><span class=\"o\">]:</span> <span class=\"s\">\"P x\"</span>\n  <span class=\"k\">unfolding</span> <span class=\"n\">P_def</span> <span class=\"ow\">..</span>\n\n<span class=\"kn\">lemma</span> <span class=\"o\">[</span><span class=\"n\">elim</span><span class=\"o\">]:</span>\n  <span class=\"kp\">assumes</span> <span class=\"s\">\"True\"</span>\n  <span class=\"kp\">obtains</span> <span class=\"s\">\"¬(P x)\"</span> <span class=\"o\">|</span> <span class=\"s\">\"P x\"</span>\n  <span class=\"c\">(*if we were to swap the order of the cases, blast does not loop*)</span>\n  <span class=\"c\">(*obtains \"P x\" | \"¬(P x)\"*)</span>\n  <span class=\"k\">by</span> <span class=\"n\">blast</span>\n\n<span class=\"kn\">lemma</span> <span class=\"s\">\"True ⟹ False\"</span>\n  <span class=\"k\">by</span> <span class=\"n\">blast</span> <span class=\"c\">(*loops*)</span>\n</code></pre></div>\n<p>Looking at the output of blast (<code>setup \"Config.put_global Blast.trace\ntrue\"</code>), it seems to me that</p>\n<ol>\n<li>the elim rule is applied</li>\n<li>the first subgoal closed by the intro rule</li>\n<li>the second subgoal cannot be closed and backtracking occurs</li>\n<li>repeat with 1.</li>\n</ol>\n<p>If, as written in the comment above, we were to swap the order of the<br>\ncases in the elim-rule, blast will not loop. Is this the expected<br>\nbehaviour of blast? I would have expected that the elim-rule will not be<br>\napplied again after backtracking occurs.</p>\n<p>For the sake of completeness, here is a more realistic example of the<br>\nsame problem:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">declare</span> <span class=\"n\">insertI1</span><span class=\"o\">[</span><span class=\"n\">intro</span><span class=\"o\">]</span> <span class=\"c\">(*\"a ∈ insert a A\"*)</span>\n<span class=\"c\">(*subsetCE is already declared as [elim] in the distro*)</span>\n<span class=\"k\">declare</span> <span class=\"n\">subsetCE</span><span class=\"o\">[</span><span class=\"n\">elim</span><span class=\"o\">]</span> <span class=\"c\">(*A ⊆ B ⟹ (c ∉ A ⟹ Q) ⟹ (c ∈ B ⟹ Q) ⟹ Q*)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"s\">\"(∀X. X ⊆ X) ⟹ 1 + 1 = 2\"</span>\n  <span class=\"k\">by</span> <span class=\"n\">blast</span> <span class=\"c\">(*loops*)</span>\n</code></pre></div>\n<p>Best wishes,</p>\n<p>Kevin</p>",
        "id": 262776212,
        "sender_full_name": "Email Gateway",
        "timestamp": 1637919313
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nDear Kevin, thanks for an interesting email. In fact it turns out that</p>\n<p>lemma \"(∀X. X ⊆ X) ⟹ 1 + 1 = 2\"<br>\n by blast </p>\n<p>loops right out of the box. Why is this?</p>\n<p>Blast doesn’t know anything about arithmetic, so it’s unable to prove 1 + 1 = 2. It will look at the assumptions and see that quantified formula, which it will try to use, creating instances of the form ?A ⊆ ?A, which are in effect other quantified formulas, giving blast lots of things to try. But of course, the assumption is equivalent to true and can’t prove anything.</p>\n<p>Blast isn’t a decision procedure and you should kill it if it doesn’t succeed in a couple of seconds.</p>\n<p>You should be cautious about tagging facts like the ones you list (<code>0 &lt; 1</code>, <code>X ⊆ X</code>, <code>x ∈ {x}</code>), simply because they refer to built-in primitives where the existing setup has undergone years of tuning (the set primitives in particular). By all means tag facts related to constants that lie further from the core, if that makes sense. But in fact it is quite easy to get blast to loop.</p>\n<p>Larry Paulson</p>",
        "id": 262783854,
        "sender_full_name": "Email Gateway",
        "timestamp": 1637924302
    },
    {
        "content": "<p>From: Kevin Kappelmann &lt;<a href=\"mailto:kevin.kappelmann@tum.de\">kevin.kappelmann@tum.de</a>&gt;<br>\nThanks Larry - do you also happen to know why blast stops looping if we<br>\nwere to swap the cases in the first example I posted? That would maybe<br>\nhelp me to tag lemmas in a way that makes auto and blast more predictable.</p>\n<p>Kevin</p>",
        "id": 262784756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1637924884
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI don’t think that there is a simple explanation. In general, blast is an instance of a sort of technology that will keep trying if there is anything it can do, and therefore can be expected to loop rather than to terminate with failure.</p>\n<p>It would be more concerning to see examples that loop even though there is a proof (in logic, not something involving arithmetic say). And I am sure such examples also exist.</p>\n<p>Larry Paulson</p>",
        "id": 262785718,
        "sender_full_name": "Email Gateway",
        "timestamp": 1637925599
    }
]