[
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:holub@karlin.mff.cuni.cz\">holub@karlin.mff.cuni.cz</a>&gt;<br>\nHello,</p>\n<p>we need to check simple (humanly trivial) properties of factors <br>\n(contiguous sublists) of limited length in a language generated by a <br>\ngiven set of lists. Something like this:</p>\n<p>lemma<br>\n   assumes \"w ∈ lists {[0,1],[1,0,1]}\" and \"length w = 4\"<br>\n   shows   \"\"fs ≤f concat w ⟹ P fs\"</p>\n<p>where ≤f denotes the factor relation and P is some predicate that is <br>\neasy to check<br>\n(a toy example would be \"length fs &lt; 13\").</p>\n<p>We developed a relatively simple mechanism which is able to prove such <br>\nclaims uniformly by a brute force search. It is based on a bunch of <br>\nelimination rules that create a long list of goals  for all possible <br>\nfactors (it is 904 in the above example). Goals are ultimately <br>\ndischarged by a single simp_all.</p>\n<p>My question is whether our approach is reasonable, whether there is some <br>\nobvious way how to do this (it reminds of Nitpick), and whether there <br>\nare some existing examples of similar tasks.</p>\n<p>Thanks.</p>\n<p>Stepan Holub</p>",
        "id": 222217727,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610277414
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nDear Stepan,</p>\n<p>in principle, that sounds quite reasonable. However, let me show you an<br>\nalternative:</p>\n<p>A simple way to check something like this would be to use the code<br>\ngenerator, using either the \"eval\" tactic or a specialised \"code<br>\nconversion\" similar to what e.g. the AFP entry on Pratt certificates does.</p>\n<p>This is typically orders of magnitude faster than evaluating things with<br>\nsimp_all. On the down side, it does not go through the Isabelle kernel<br>\nbut relies on computational reflection (i.e. the code generator)<br>\ninstead, and the code generator is a fairly big chunk of trusted code.<br>\nSo purists might object.</p>\n<p>However, this approach is widely used and people usually don't complain<br>\nabout it.</p>\n<p>Even the \"naïve\" brute force approach should work fine for simple examples:</p>\n<p>primrec lists_of_length where<br>\n    \"lists_of_length A 0 = {[]}\"<br>\n  | \"lists_of_length A (Suc n) = (λ(x,xs). x # xs) ` (A ×<br>\nlists_of_length A n)\"</p>\n<p>lemma lists_of_length_altdef: \"lists_of_length A n = {xs. xs ∈ lists A ∧<br>\nlength xs = n}\"<br>\n  sorry</p>\n<p>notepad<br>\nbegin<br>\n  define A :: \"int list set\" where<br>\n    \"A ≡ Set.bind (concat ` lists_of_length {[0,1],[1,0,1]} 4) (set ∘<br>\nsublists)\"<br>\n  have \"∀w∈A. length w ≤ 13\"<br>\n    unfolding A_def by eval<br>\nend</p>\n<p>For bigger examples where performance becomes an issue, one could trie a<br>\nmore sophisticated approach (using a trie, perhaps?)</p>\n<p>One down side of this, however, is that it only works for concrete types<br>\n(like \"int\" above), not for free type variables. However, I think<br>\ntheorems and operations in the field of combinatorics on words are<br>\ntypically of a nature where if it works for a sufficiently large set of<br>\nsymbols (e.g. some subset of the natural numbers), it works everywhere<br>\nelse as well, so one could just run it on \"nat\" and then lift the result.</p>\n<p>Cheers,</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/KkaBxj6Sm6o_ti-PCv6yTT7I/smime.p7s\">smime.p7s</a></p>",
        "id": 222268825,
        "sender_full_name": "Email Gateway",
        "timestamp": 1610352693
    }
]