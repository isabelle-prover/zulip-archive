[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI am trying to generate code from this inductive definition:</p>\n<p>inductive nullable :: \"(int * int list) list ⇒ int ⇒ bool\"<br>\nfor ps where<br>\n   \"⟦ mem ps (A, w); ∀s ∈ set w. nullable ps s⟧<br>\n   ⟹ nullable ps A\"</p>\n<p>where mem is the auxiliary definition</p>\n<p>inductive mem :: \"'a list ⇒ 'a ⇒ bool\" where<br>\n   \"mem (x#xs) x\" |<br>\n   \"mem xs y ⟹ mem (x#xs) y\"</p>\n<p>(I thought List.member does the job but that didn't work)</p>\n<p>Back to nullable: this evaluation diverges:</p>\n<p>values \"{s. nullable [(1,[1, 0])] s}\"</p>\n<p>How can I fix this?</p>\n<p>Alternatively, for my purposes it may be simpler to use the lfp-definition of <br>\nnullable. However, I can only find</p>\n<p>HOL.nitpick_unfold(176):<br>\nnullable ≡ λps. lfp (λp x. ∃A w. x = A ∧ mem ps (A, w) ∧ (∀s∈set w. p s))</p>\n<p>Is there no direct access to this def (not needing nitpick_unfold)? I seem to <br>\nremember it is hidden, but maybe there is a switch?</p>\n<p>Tobias</p>\n<p><a href=\"/user_uploads/14278/h0sQwy_XigAbJxf1fhXjmmHV/smime.p7s\">smime.p7s</a></p>",
        "id": 500353270,
        "sender_full_name": "Email Gateway",
        "timestamp": 1739870579
    },
    {
        "content": "<p>From: Jan van Brügge &lt;<a href=\"mailto:jan@vanbruegge.de\">jan@vanbruegge.de</a>&gt;<br>\nHi Tobias,</p>\n<p>if you do <code>declare [inductive_internals]</code> before the definition of <br>\nnullable, the lfp definition will be available as \"nullable_def\"</p>\n<p>Cheers,<br>\nJan</p>\n<p>Am 18.02.25 um 09:22 schrieb Tobias Nipkow:</p>\n<blockquote>\n<p>I am trying to generate code from this inductive definition:</p>\n<p>inductive nullable :: \"(int * int list) list ⇒ int ⇒ bool\"<br>\nfor ps where<br>\n  \"⟦ mem ps (A, w); ∀s ∈ set w. nullable ps s⟧<br>\n  ⟹ nullable ps A\"</p>\n<p>where mem is the auxiliary definition</p>\n<p>inductive mem :: \"'a list ⇒ 'a ⇒ bool\" where<br>\n  \"mem (x#xs) x\" |<br>\n  \"mem xs y ⟹ mem (x#xs) y\"</p>\n<p>(I thought List.member does the job but that didn't work)</p>\n<p>Back to nullable: this evaluation diverges:</p>\n<p>values \"{s. nullable [(1,[1, 0])] s}\"</p>\n<p>How can I fix this?</p>\n<p>Alternatively, for my purposes it may be simpler to use the <br>\nlfp-definition of nullable. However, I can only find</p>\n<p>HOL.nitpick_unfold(176):<br>\nnullable ≡ λps. lfp (λp x. ∃A w. x = A ∧ mem ps (A, w) ∧ (∀s∈set w. p s))</p>\n<p>Is there no direct access to this def (not needing nitpick_unfold)? I <br>\nseem to remember it is hidden, but maybe there is a switch?</p>\n<p>Tobias</p>\n</blockquote>",
        "id": 500354601,
        "sender_full_name": "Email Gateway",
        "timestamp": 1739871003
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThanks Jan, that's what I as looking for (and couldn't find in the Ref Man ...).</p>\n<p>Tobias</p>\n<p>On 18/02/2025 10:24, Jan van Brügge wrote:</p>\n<blockquote>\n<p>Hi Tobias,</p>\n<p>if you do <code>declare [inductive_internals]</code> before the definition of nullable, the <br>\nlfp definition will be available as \"nullable_def\"</p>\n<p>Cheers,<br>\nJan</p>\n<p>Am 18.02.25 um 09:22 schrieb Tobias Nipkow:</p>\n<blockquote>\n<p>I am trying to generate code from this inductive definition:</p>\n<p>inductive nullable :: \"(int * int list) list ⇒ int ⇒ bool\"<br>\nfor ps where<br>\n  \"⟦ mem ps (A, w); ∀s ∈ set w. nullable ps s⟧<br>\n  ⟹ nullable ps A\"</p>\n<p>where mem is the auxiliary definition</p>\n<p>inductive mem :: \"'a list ⇒ 'a ⇒ bool\" where<br>\n  \"mem (x#xs) x\" |<br>\n  \"mem xs y ⟹ mem (x#xs) y\"</p>\n<p>(I thought List.member does the job but that didn't work)</p>\n<p>Back to nullable: this evaluation diverges:</p>\n<p>values \"{s. nullable [(1,[1, 0])] s}\"</p>\n<p>How can I fix this?</p>\n<p>Alternatively, for my purposes it may be simpler to use the lfp-definition of <br>\nnullable. However, I can only find</p>\n<p>HOL.nitpick_unfold(176):<br>\nnullable ≡ λps. lfp (λp x. ∃A w. x = A ∧ mem ps (A, w) ∧ (∀s∈set w. p s))</p>\n<p>Is there no direct access to this def (not needing nitpick_unfold)? I seem to <br>\nremember it is hidden, but maybe there is a switch?</p>\n<p>Tobias</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/LErOvYqd0azRKHX4GRE71M8B/smime.p7s\">smime.p7s</a></p>",
        "id": 500355110,
        "sender_full_name": "Email Gateway",
        "timestamp": 1739871165
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nA related question: I need to convert between fixpoints on predicates and on <br>\nsets and am using</p>\n<p>lemma \"mono P ⟹ lfp (λS. {x. P (λx. x ∈ S) x}) = {s. lfp (λp x. P p x) s}\"</p>\n<p>One direction of the proof is easy:</p>\n<p>apply (simp add: lfp_fixpoint lfp_lowerbound)</p>\n<p>but in the other direction I only have an ugly smt proof. Any clever <br>\nsuggestions, including \"transfer\"?</p>\n<p>Tobias</p>\n<p>On 18/02/2025 10:24, Jan van Brügge wrote:</p>\n<blockquote>\n<p>Hi Tobias,</p>\n<p>if you do <code>declare [inductive_internals]</code> before the definition of nullable, the <br>\nlfp definition will be available as \"nullable_def\"</p>\n<p>Cheers,<br>\nJan</p>\n<p>Am 18.02.25 um 09:22 schrieb Tobias Nipkow:</p>\n<blockquote>\n<p>I am trying to generate code from this inductive definition:</p>\n<p>inductive nullable :: \"(int * int list) list ⇒ int ⇒ bool\"<br>\nfor ps where<br>\n  \"⟦ mem ps (A, w); ∀s ∈ set w. nullable ps s⟧<br>\n  ⟹ nullable ps A\"</p>\n<p>where mem is the auxiliary definition</p>\n<p>inductive mem :: \"'a list ⇒ 'a ⇒ bool\" where<br>\n  \"mem (x#xs) x\" |<br>\n  \"mem xs y ⟹ mem (x#xs) y\"</p>\n<p>(I thought List.member does the job but that didn't work)</p>\n<p>Back to nullable: this evaluation diverges:</p>\n<p>values \"{s. nullable [(1,[1, 0])] s}\"</p>\n<p>How can I fix this?</p>\n<p>Alternatively, for my purposes it may be simpler to use the lfp-definition of <br>\nnullable. However, I can only find</p>\n<p>HOL.nitpick_unfold(176):<br>\nnullable ≡ λps. lfp (λp x. ∃A w. x = A ∧ mem ps (A, w) ∧ (∀s∈set w. p s))</p>\n<p>Is there no direct access to this def (not needing nitpick_unfold)? I seem to <br>\nremember it is hidden, but maybe there is a switch?</p>\n<p>Tobias</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/mrfkctt0gAHayY7pap6wXmHn/smime.p7s\">smime.p7s</a></p>",
        "id": 500497620,
        "sender_full_name": "Email Gateway",
        "timestamp": 1739907881
    },
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHow about this:</p>\n<p>lemma \"{s. lfp (λp x. P p x) s} ⊆ lfp (λS. {x. P (λx. x ∈ S) x})\"<br>\n     by (rule lfp_greatest)<br>\n      (simp add: less_eq_set_def lfp_lowerbound)</p>\n<p>Stepan</p>\n<p>On 18-Feb-25 8:44 PM, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>A related question: I need to convert between fixpoints on predicates <br>\nand on sets and am using</p>\n<p>lemma \"mono P ⟹ lfp (λS. {x. P (λx. x ∈ S) x}) = {s. lfp (λp x. P p x) <br>\ns}\"</p>\n<p>One direction of the proof is easy:</p>\n<p>apply (simp add: lfp_fixpoint lfp_lowerbound)</p>\n<p>but in the other direction I only have an ugly smt proof. Any clever <br>\nsuggestions, including \"transfer\"?</p>\n<p>Tobias</p>\n<p>On 18/02/2025 10:24, Jan van Brügge wrote:</p>\n<blockquote>\n<p>Hi Tobias,</p>\n<p>if you do <code>declare [inductive_internals]</code> before the definition of <br>\nnullable, the lfp definition will be available as \"nullable_def\"</p>\n<p>Cheers,<br>\nJan</p>\n<p>Am 18.02.25 um 09:22 schrieb Tobias Nipkow:</p>\n<blockquote>\n<p>I am trying to generate code from this inductive definition:</p>\n<p>inductive nullable :: \"(int * int list) list ⇒ int ⇒ bool\"<br>\nfor ps where<br>\n  \"⟦ mem ps (A, w); ∀s ∈ set w. nullable ps s⟧<br>\n  ⟹ nullable ps A\"</p>\n<p>where mem is the auxiliary definition</p>\n<p>inductive mem :: \"'a list ⇒ 'a ⇒ bool\" where<br>\n  \"mem (x#xs) x\" |<br>\n  \"mem xs y ⟹ mem (x#xs) y\"</p>\n<p>(I thought List.member does the job but that didn't work)</p>\n<p>Back to nullable: this evaluation diverges:</p>\n<p>values \"{s. nullable [(1,[1, 0])] s}\"</p>\n<p>How can I fix this?</p>\n<p>Alternatively, for my purposes it may be simpler to use the <br>\nlfp-definition of nullable. However, I can only find</p>\n<p>HOL.nitpick_unfold(176):<br>\nnullable ≡ λps. lfp (λp x. ∃A w. x = A ∧ mem ps (A, w) ∧ (∀s∈set w. <br>\np s))</p>\n<p>Is there no direct access to this def (not needing nitpick_unfold)? <br>\nI seem to remember it is hidden, but maybe there is a switch?</p>\n<p>Tobias</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 500509877,
        "sender_full_name": "Email Gateway",
        "timestamp": 1739912487
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nCool!</p>\n<p>Tobias</p>\n<p>On 18/02/2025 22:01, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>How about this:</p>\n<p>lemma \"{s. lfp (λp x. P p x) s} ⊆ lfp (λS. {x. P (λx. x ∈ S) x})\"<br>\n     by (rule lfp_greatest)<br>\n      (simp add: less_eq_set_def lfp_lowerbound)</p>\n<p>Stepan</p>\n<p>On 18-Feb-25 8:44 PM, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>A related question: I need to convert between fixpoints on predicates and on <br>\nsets and am using</p>\n<p>lemma \"mono P ⟹ lfp (λS. {x. P (λx. x ∈ S) x}) = {s. lfp (λp x. P p x) s}\"</p>\n<p>One direction of the proof is easy:</p>\n<p>apply (simp add: lfp_fixpoint lfp_lowerbound)</p>\n<p>but in the other direction I only have an ugly smt proof. Any clever <br>\nsuggestions, including \"transfer\"?</p>\n<p>Tobias</p>\n<p>On 18/02/2025 10:24, Jan van Brügge wrote:</p>\n<blockquote>\n<p>Hi Tobias,</p>\n<p>if you do <code>declare [inductive_internals]</code> before the definition of nullable, <br>\nthe lfp definition will be available as \"nullable_def\"</p>\n<p>Cheers,<br>\nJan</p>\n<p>Am 18.02.25 um 09:22 schrieb Tobias Nipkow:</p>\n<blockquote>\n<p>I am trying to generate code from this inductive definition:</p>\n<p>inductive nullable :: \"(int * int list) list ⇒ int ⇒ bool\"<br>\nfor ps where<br>\n  \"⟦ mem ps (A, w); ∀s ∈ set w. nullable ps s⟧<br>\n  ⟹ nullable ps A\"</p>\n<p>where mem is the auxiliary definition</p>\n<p>inductive mem :: \"'a list ⇒ 'a ⇒ bool\" where<br>\n  \"mem (x#xs) x\" |<br>\n  \"mem xs y ⟹ mem (x#xs) y\"</p>\n<p>(I thought List.member does the job but that didn't work)</p>\n<p>Back to nullable: this evaluation diverges:</p>\n<p>values \"{s. nullable [(1,[1, 0])] s}\"</p>\n<p>How can I fix this?</p>\n<p>Alternatively, for my purposes it may be simpler to use the lfp-definition <br>\nof nullable. However, I can only find</p>\n<p>HOL.nitpick_unfold(176):<br>\nnullable ≡ λps. lfp (λp x. ∃A w. x = A ∧ mem ps (A, w) ∧ (∀s∈set w. p s))</p>\n<p>Is there no direct access to this def (not needing nitpick_unfold)? I seem <br>\nto remember it is hidden, but maybe there is a switch?</p>\n<p>Tobias</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/lc294gmHtZ89S7YRk6cKeGvV/smime.p7s\">smime.p7s</a></p>",
        "id": 500514513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1739914277
    }
]