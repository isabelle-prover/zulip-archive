[
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:holub@karlin.mff.cuni.cz\">holub@karlin.mff.cuni.cz</a>&gt;<br>\nDear all,</p>\n<p>in need (of a particular instance of) the following obvious fact:</p>\n<p>lemma (in order) fin_max: \"finite A ⟹ a ∈ A ⟹ ∃ s ∈ A. a ≤ s ∧  (∀ b ∈ <br>\nA. s ≤ b ⟶ s = b)\"</p>\n<p>I have proved it for myself (see below). I wonder whether it can be <br>\nobtained somehow more directly from Main.</p>\n<p>Best regards</p>\n<p>Stepan</p>\n<p>proof (induct \"card {b ∈ A. a &lt; b}\" arbitrary: a rule: nat_less_induct)<br>\n   case 1<br>\n   have IH: \"⋀ x. x ∈ A ⟹ card {b ∈ A. x &lt; b} &lt; card {b ∈ A. a &lt; b} ⟹ <br>\n∃s∈A. x ≤ s ∧ (∀b∈A. s ≤ b ⟶ s = b)\"<br>\n     by (simp add: \"1.hyps\" ‹finite A›)<br>\n   then show ?case<br>\n   proof (cases \"∀b∈A. a ≤ b ⟶ a = b\")<br>\n     assume \"∀b∈A. a ≤ b ⟶ a = b\"<br>\n     thus ?thesis<br>\n       using ‹a ∈ A› by blast<br>\n   next<br>\n     assume \"¬ (∀b∈A. a ≤ b ⟶ a = b)\"<br>\n     then obtain a' where \"a' ∈ A\" and \"a &lt; a'\"<br>\n       using local.antisym_conv1 by blast<br>\n     have \"{b ∈ A. a' &lt; b} ⊂ {b ∈ A. a &lt; b}\" (is \"?Ma' ⊂  ?Ma\")<br>\n     proof-<br>\n       have \"a' ∈ ?Ma\" and \"a' ∉ ?Ma'\" and \"⋀ c. c ∈ ?Ma' ⟹ c ∈ ?Ma\"<br>\n         using ‹a &lt; a'› ‹a' ∈ A› by auto<br>\n       thus \"?Ma' ⊂  ?Ma\"<br>\n         by blast<br>\n     qed<br>\n     hence card: \"card {b ∈ A. a' &lt; b} &lt; card {b ∈ A. a &lt; b}\"<br>\n       by (simp add: ‹finite A› psubset_card_mono)<br>\n     then obtain s where \"s ∈ A\" \"a' ≤ s ∧ (∀b∈A. s ≤ b ⟶ s = b)\"<br>\n       using IH[OF ‹a' ∈ A› card] by blast<br>\n     hence \"a ≤ s ∧ (∀b∈A. s ≤ b ⟶ s = b)\"<br>\n       using ‹a &lt; a'› by auto<br>\n     thus ?thesis<br>\n       using ‹s ∈ A› by blast<br>\n   qed<br>\nqed</p>",
        "id": 212160920,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601714306
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@di.ku.dk\">traytel@di.ku.dk</a>&gt;<br>\nHi Stepan,</p>\n<p>an alternative is to use the well-foundedness of &gt; restricted to the finite set A. This gives one maximal elements via wf_eq_minimal. Not sure if this qualifies as “more direct”, but at least no explicit induction is needed.</p>\n<p>Dmitriy</p>\n<p>lemma (in order) fin_max:<br>\n  assumes \"finite A\" \"a ∈ A\"<br>\n  shows \"∃s ∈ A. a ≤ s ∧ (∀b ∈ A. s ≤ b ⟶ s = b)\"<br>\nproof -<br>\n  from ‹finite A› have \"wf {(x,y). x ∈ A ∧ y ∈ A ∧ x &gt; y}\"<br>\n    by (intro finite_acyclic_wf[OF finite_subset[of _ \"A × A\"]]) (auto intro!: acyclicI_order)<br>\n  with ‹a ∈ A› show ?thesis<br>\n    unfolding wf_eq_minimal using order.trans order.order_iff_strict<br>\n    by (elim allE[of _ \"{x ∈ A. a ≤ x}\"] allE[of _ a]) (auto 7 0)<br>\nqed</p>",
        "id": 212221345,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601814739
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nMaybe Min/Max (on finite sets) could be defined for arbitrary orders instead of <br>\njust linear orders as currently? Florian?</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/gneu29ypkkBHjgsJ7yQM7oU2/smime.p7s\">smime.p7s</a></p>",
        "id": 212323358,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601915020
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nNote that Min/Max as of course no longer unique for non-linear orders.</p>\n<p>Also note that Min/Max are instances of the more general arg_min/arg_max.</p>\n<p>There are quite a few missing lemmas for arg_max that do exist for<br>\narg_min, otherwise I would have replied to just use arg_max to the<br>\noriginal question.</p>\n<p>Manuel</p>",
        "id": 212324283,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601915448
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 03/10/2020 10:37, Stepan Holub wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>in need (of a particular instance of) the following obvious fact:</p>\n<p>lemma (in order) fin_max: \"finite A ⟹ a ∈ A ⟹ ∃ s ∈ A. a ≤ s ∧  (∀ b ∈ A. s ≤ b <br>\n⟶ s = b)\"</p>\n</blockquote>\n<p>This is a useful theorem and I am happy to add it. However, it seems more <br>\nmodular to prove the simpler</p>\n<p>lemma (in order) finite_has_max: \"finite A ⟹ A ≠ {} ⟹ ∃ s ∈ A. (∀ b ∈ A. s ≤ b ⟶ <br>\ns = b)\"</p>\n<p>first and derive</p>\n<p>lemma (in order) finite_has_max2: \"finite A ⟹ a ∈ A ⟹ ∃ s ∈ A. a ≤ s ∧ (∀ b ∈ A. <br>\ns ≤ b ⟶ s = b)\"</p>\n<p>from it in one line. In fact, I wonder if the second one is basic enough to go <br>\ninto Main, but probably yes.</p>\n<p>I would add the lemma(s) to Finite_Set using Stepan's proof because that way <br>\nthey are added at the earliest point.</p>\n<p>Comments, please.</p>\n<p>Tobias</p>\n<blockquote>\n<p>I have proved it for myself (see below). I wonder whether it can be obtained <br>\nsomehow more directly from Main.</p>\n<p>Best regards</p>\n<p>Stepan</p>\n<p>proof (induct \"card {b ∈ A. a &lt; b}\" arbitrary: a rule: nat_less_induct)<br>\n   case 1<br>\n   have IH: \"⋀ x. x ∈ A ⟹ card {b ∈ A. x &lt; b} &lt; card {b ∈ A. a &lt; b} ⟹ ∃s∈A. x ≤ <br>\ns ∧ (∀b∈A. s ≤ b ⟶ s = b)\"<br>\n     by (simp add: \"1.hyps\" ‹finite A›)<br>\n   then show ?case<br>\n   proof (cases \"∀b∈A. a ≤ b ⟶ a = b\")<br>\n     assume \"∀b∈A. a ≤ b ⟶ a = b\"<br>\n     thus ?thesis<br>\n       using ‹a ∈ A› by blast<br>\n   next<br>\n     assume \"¬ (∀b∈A. a ≤ b ⟶ a = b)\"<br>\n     then obtain a' where \"a' ∈ A\" and \"a &lt; a'\"<br>\n       using local.antisym_conv1 by blast<br>\n     have \"{b ∈ A. a' &lt; b} ⊂ {b ∈ A. a &lt; b}\" (is \"?Ma' ⊂  ?Ma\")<br>\n     proof-<br>\n       have \"a' ∈ ?Ma\" and \"a' ∉ ?Ma'\" and \"⋀ c. c ∈ ?Ma' ⟹ c ∈ ?Ma\"<br>\n         using ‹a &lt; a'› ‹a' ∈ A› by auto<br>\n       thus \"?Ma' ⊂  ?Ma\"<br>\n         by blast<br>\n     qed<br>\n     hence card: \"card {b ∈ A. a' &lt; b} &lt; card {b ∈ A. a &lt; b}\"<br>\n       by (simp add: ‹finite A› psubset_card_mono)<br>\n     then obtain s where \"s ∈ A\" \"a' ≤ s ∧ (∀b∈A. s ≤ b ⟶ s = b)\"<br>\n       using IH[OF ‹a' ∈ A› card] by blast<br>\n     hence \"a ≤ s ∧ (∀b∈A. s ≤ b ⟶ s = b)\"<br>\n       using ‹a &lt; a'› by auto<br>\n     thus ?thesis<br>\n       using ‹s ∈ A› by blast<br>\n   qed<br>\nqed</p>\n<p><a href=\"/user_uploads/14278/68rLSJummeWq4WS-YilrzugM/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 212391053,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601967830
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThe names should be “maximal” rather than “max”. The latter would suggest the Max function, which is only meaningful for linear orderings. </p>\n<p>Larry</p>",
        "id": 212404438,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601977122
    },
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:holub@karlin.mff.cuni.cz\">holub@karlin.mff.cuni.cz</a>&gt;<br>\nDear Tobias,</p>\n<p>the absence of the simpler lemma is even more surprising. It seems to me <br>\nmoreover that the version for minimum is not easily obtained either.</p>\n<p>Nevertheless, I understood two things, thank to this mailing list:</p>\n<ol>\n<li>\n<p>Dmitriy pointed out that any acyclic relation on a finite list is <br>\nknown to be wf, whence both maxima and minima are obtained. Which leads <br>\nmuch better proof (posted by Dmitriy up the thread) than the mine is.</p>\n</li>\n<li>\n<p>Manuel pointed out that arg_max/arg_min can be used. Indeed, for <br>\nminima we have ex_min_if_finite in Lattices_Big:<br>\nlemma \"⟦ finite S; S ≠ {} ⟧ ⟹ ∃m∈S. ¬(∃x∈S. x &lt; (m::'a::order))\"<br>\n(a side issue: I do not understand why I cannot get alternative<br>\nlemma (in order) \"⟦ finite S; S ≠ {} ⟧ ⟹ ∃m∈S. ¬(∃x∈S. x &lt; m)\"<br>\n)<br>\nwhile for maxima a similar claim is missing at the moment.</p>\n</li>\n</ol>\n<p>Altogether, it seems to me that a lacking synchronization between <br>\n\"order\" \"relation\" and possibly \"Lattices_Big\" is somehow at play here. <br>\nTherefore, I really cannot tell<br>\nwhether adding the lemma is the cleanest solution strategically, <br>\nalthough, of course, it would be handy practically.</p>\n<p>Stepan</p>",
        "id": 212405754,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601978020
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<p>Maybe Min/Max (on finite sets) could be defined for arbitrary orders<br>\ninstead of just linear orders as currently?</p>\n</blockquote>\n<p>See Manuel's answer.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/N7y82I_EFhlRgI4YtSY56fCe/signature.asc\">signature.asc</a></p>",
        "id": 212406240,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601978362
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>(a side issue: I do not understand why I cannot get alternative<br>\nlemma (in order) \"⟦ finite S; S ≠ {} ⟧ ⟹ ∃m∈S. ¬(∃x∈S. x &lt; m)\"<br>\n)</p>\n</blockquote>\n<p>Welcome to the wonderfully frustrating world of Isabelle typeclasses!<br>\nUnfortunately, arg_min etc. are defined with an \"ord\" sort constraint.<br>\nHowever, inside the context of the \"ord\" typeclass itself, you do not<br>\nyet have this sort \"ord\" attached to the type variable. Therefore, this<br>\ngives you a type error due to the missing sort.</p>\n<p>In this particular case, this issue could be fixed by defining the<br>\nconstants inside the typeclass:</p>\n<blockquote>\n<p>definition (in ord) is_arg_min :: \"('b ⇒ 'a) ⇒ ('b ⇒ bool) ⇒ 'b ⇒<br>\nbool\" where<br>\n\"is_arg_min f P x = (P x ∧ ¬(∃y. P y ∧ f y &lt; f x))\"</p>\n<p>definition (in ord) arg_min :: \"('b ⇒ 'a) ⇒ ('b ⇒ bool) ⇒ 'b\" where<br>\n\"arg_min f P = (SOME x. is_arg_min f P x)\"</p>\n</blockquote>\n<p>Indeed I would suggest we do it that way.</p>\n<p>There are, however, cases where this does not work: for instance, any<br>\ndefinition of theorem involving two different types of that type class.</p>\n<p>This is a very annoying technical limitation of Isabelle's type classes.<br>\nUsually, there is no big downside to just defining/proving stuff outside<br>\nthe typeclass using explicit sort constraints, but one situation where<br>\nit gets really annoying is when want to use constants defined outside<br>\nthe typeclass in the assumptions of a new subclass (e.g. something<br>\nbuilting on top of euclidean_space that makes some assumptions about the<br>\nlimit of some function. Limits are not defined in the type class.)</p>\n<p>Manuel</p>",
        "id": 212411098,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601981859
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI have now added some lemmas with succinct proofs (avoiding cardinalities) and <br>\nfollowed Manuel's suggestions concerning arg_min.<br>\nSee here: <a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/b037517c815b\">http://isabelle.in.tum.de/repos/isabelle/rev/b037517c815b</a></p>\n<p>If anybody has additional suggestions...</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/fCjVbge-YZgc1Thbvp8QaCie/smime.p7s\">smime.p7s</a></p>",
        "id": 212475866,
        "sender_full_name": "Email Gateway",
        "timestamp": 1602013652
    },
    {
        "content": "<p>From: \"Bisping, Benjamin\" &lt;<a href=\"mailto:benjamin.bisping@tu-berlin.de\">benjamin.bisping@tu-berlin.de</a>&gt;<br>\nAdding these facts to Fnite_Set already would be great!</p>\n<p>I also once spent an afternoon trying to figure out how to directly obtain such maxima browsing theorems around Finite_Set, order, Max and wf, because I assumed it would be somewhere in Main/Finite_Set. (And then I gave up and proved the instance I needed by an ugly detour through lists ... <a href=\"https://coupledsim.bbisping.de/isabelle/Finite_Partial_Order.html\">https://coupledsim.bbisping.de/isabelle/Finite_Partial_Order.html</a> ) The lemmas you propose look as if they would have saved me the afternoon back then! :)</p>\n<p>Kind regards,</p>\n<p>Benjamin Bisping<br>\n<a href=\"/user_uploads/14278/uffXjInkne9puMahIEJFOqmk/smime.p7s\">smime.p7s</a></p>",
        "id": 212530801,
        "sender_full_name": "Email Gateway",
        "timestamp": 1602061239
    },
    {
        "content": "<p>From: Jakub Kądziołka &lt;<a href=\"mailto:kuba@kadziolka.net\">kuba@kadziolka.net</a>&gt;<br>\nAre these lemmas missing for any other reason than \"nobody bothered<br>\nyet\"? I happened to need the arg_max variants of those today, so I<br>\nadjusted some proofs:</p>\n<p>theory Scratch<br>\n  imports<br>\n    HOL.Lattices_Big<br>\nbegin</p>\n<p>lemma ex_max_if_finite:<br>\n  \"⟦ finite S; S ≠ {} ⟧ ⟹ ∃m∈S. ¬(∃x∈S. x &gt; (m::'a::order))\"<br>\nby(induction rule: finite.induct) (auto intro: order.strict_trans)</p>\n<p>lemma ex_is_arg_max_if_finite: fixes f :: \"'a ⇒ 'b :: order\"<br>\nshows \"⟦ finite S; S ≠ {} ⟧ ⟹ ∃x. is_arg_max f (λx. x ∈ S) x\"<br>\nunfolding is_arg_max_def<br>\nusing ex_max_if_finite[of \"f ` S\"]<br>\nby auto</p>\n<p>lemma arg_max_SOME_Max:<br>\n  \"finite S ⟹ arg_max_on f S = (SOME y. y ∈ S ∧ f y = Max(f ` S))\"<br>\nunfolding arg_max_on_def arg_max_def is_arg_max_linorder<br>\napply(rule arg_cong[where f = Eps])<br>\napply (auto simp: fun_eq_iff intro: Max_eqI[symmetric])<br>\ndone</p>\n<p>lemma arg_max_if_finite: fixes f :: \"'a ⇒ 'b :: order\"<br>\nassumes \"finite S\" \"S ≠ {}\"<br>\nshows  \"arg_max_on f S ∈ S\" and \"¬(∃x∈S. f x &gt; f (arg_max_on f S))\"<br>\nusing ex_is_arg_max_if_finite[OF assms, of f]<br>\nunfolding arg_max_on_def arg_max_def is_arg_max_def<br>\nby(auto dest!: someI_ex)</p>\n<p>lemma arg_max_greatest: fixes f :: \"'a ⇒ 'b :: linorder\"<br>\nshows \"⟦ finite S;  S ≠ {};  y ∈ S ⟧ ⟹ f(arg_max_on f S) ≥ f y\"<br>\nby(simp add: arg_max_SOME_Max inv_into_def2[symmetric] f_inv_into_f)</p>\n<p>lemma arg_max_inj_eq: fixes f :: \"'a ⇒ 'b :: order\"<br>\nshows \"⟦ inj_on f {x. P x}; P a; ∀y. P y ⟶ f a ≥ f y ⟧ ⟹ arg_max f P = a\"<br>\napply(simp add: arg_max_def is_arg_max_def)<br>\napply(rule someI2[of _ a])<br>\n apply (simp add: less_le_not_le)<br>\nby (metis inj_on_eq_iff less_le mem_Collect_eq)<br>\nend</p>\n<p>It might've been cleaner to prove these using the equivalent arg_min<br>\ntheorems by defining an 'inverse' order, but I have no idea how to do<br>\nthat...</p>\n<p>Regards,<br>\nJakub Kądziołka</p>",
        "id": 212610446,
        "sender_full_name": "Email Gateway",
        "timestamp": 1602100243
    }
]