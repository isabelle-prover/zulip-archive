[
    {
        "content": "<p>From: Matthys Grobbelaar &lt;<a href=\"mailto:m.grobbelaar@uq.net.au\">m.grobbelaar@uq.net.au</a>&gt;<br>\nI'm currently attempting to do syntax translations which require data (a queue) from the current theory context.<br>\nI've been able to add the queue into the theory context using the Theory_Data functor, however I can't seem to access that data in my translation function (called via parse_translation). For reference, I've been using the \"Isabelle/Isar Implementation\" (implementation.pdf (tum.de)&lt;<a href=\"https://isabelle.in.tum.de/dist/Isabelle2021/doc/implementation.pdf\">https://isabelle.in.tum.de/dist/Isabelle2021/doc/implementation.pdf</a>&gt; Chapter 1.1 as a basis for adding data into the context.</p>\n<p>Am I adding the data into the wrong place? What's the correct way of doing this?</p>\n<p>Kind regards and thank you in advance,<br>\nMatthys Grobbelaar</p>",
        "id": 236772958,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619746501
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>how are you accessing the theory inside your parse translation? If you <br>\nuse the ML antiquotation \\&lt;^theory&gt; (rendered /<em>theory</em>/), then you get <br>\nthe theory that you had at compile time of the parse translation. (And <br>\ntheories are immutable, so changing the theory data will not affect that <br>\ntheory.) The correct way is to use the context that is given to the <br>\nparse translation as an argument, and then get the theory via <br>\n\"Proof_Context.theory_of ctxt\". (If this is already what you are doing, <br>\nsorry for pointing out the obvious.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 236813754,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619778134
    },
    {
        "content": "<p>From: Matthys Grobbelaar &lt;<a href=\"mailto:m.grobbelaar@uq.net.au\">m.grobbelaar@uq.net.au</a>&gt;<br>\nHi Dominique,</p>\n<p>Thank you for your quick response.<br>\nAt the moment, I've been accessing the theory with the following: Context.theory_of (Context.proof ctxt) where ctxt is the context given to the parse translation.<br>\nI've since changed it to be Proof_Context.theory_of ctxt which looks cleaner and appears to yield identical results.</p>\n<p>At the moment, I've been testing this as follows:</p>\n<p>*   Making a duplicate translation function in the file where I'm modifying the theory context (via setup and using the functor) and called it directly: val _ = parse_val (Context.the_local_context ()) [@{term \"...\"}]<br>\n  *   Making a direct call to my original translation function (which lives in another theory) with the same parameters: val _ = parse_val_orig (Context.the_local_context ()) [@{term \"...\"}]<br>\n  *   Using the syntax directly in the file where I'm modifying the theory context: &lt;\\lrel&gt;...&lt;/rrel&gt; where &lt;\\lrel&gt; and &lt;\\rrel&gt; is the new syntax (just a pair of parentheses essentially)</p>\n<p>The dummy translation function is as follows (essentially just printing out the content of the queue):<br>\n    fun parse_val ctxt [trm] =<br>\n        let<br>\n            val data = VarList.get (Proof_Context.theory_of ctxt)    (* VarList is the structure using the functor which stores the data *)<br>\n            val _ = VarList.print_vars data ctxt<br>\n        in undefined end;</p>\n<p>The duplicate function in the file where the I'm modifying the context prints out the values in the queue correctly. The direct call to the translation function in the other theory and the use of syntax (which also uses this other function) prints nothing (an empty queue). Note that the printing function does not modify the queue passed in for printing.</p>\n<p>Why would the same argument, given to identical methods in different files, have different results? It seems a bit strange to me.</p>\n<p>Kind regards and thank you in advance,<br>\nMatthys Grobbelaar</p>",
        "id": 236918467,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619826722
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI find it hard to follow what you are actually doing. Can you show the formal<br>\nexplanation written in Isabelle/ML?</p>\n<p>A lot of details are non-standard in the small snipptes (e.g. use of<br>\nContext.the_local_context, undefined, trm as name for a term), so it is likely<br>\nthat the overall approach is somehow wrong.</p>\n<p>Further note that in functional programming, functions are called \"functions\",<br>\nnot methods.</p>\n<p>Makarius</p>",
        "id": 236952264,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619860549
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;</p>\n<blockquote>\n<p>Why would the same argument, given to identical methods in different <br>\nfiles, have different results? It seems a bit strange to me.</p>\n</blockquote>\n<p>That does seem very strange to me, too. My best hypothesis is that they <br>\nare not, actually, identical methods. (They might have the exact same <br>\ncode but, due to different namespaces, call different functions in their <br>\ncode.)</p>\n<p>What I would try:</p>\n<p>* Write \\&lt;^context&gt; instead of \"Context.the_local_context ()\" in your<br>\n    experiments (shouldn't change much, but if you want to refer to the<br>\n    current context at compile time of a given code snippet, that's the<br>\n    right thing to use).</p>\n<p>* Ctrl-click on both of VarList.get and VarList.print_vars to see<br>\n    where jEdit jumps. If it jumps to different places, then you have<br>\n    accidentally defined VarList twice. (Also check whether you might<br>\n    include the same ML-file twice.)</p>\n<p>* Try and print theory you got, to see if it's the right one (val _ =<br>\n    Proof_Context.theory_of ctxt |&gt; \\&lt;^print&gt; or something like that).<br>\n    \\&lt;^print&gt; is useful generally for debugging because it can be<br>\n    applied to anything, not just strings.</p>\n<p>* Instead of \"undefined\", you can also as a hack return debug output<br>\n    from a parse translation via: HOLogic.mk_literal string_to_return<br>\n    (this will then give you a string literal inside your parsed<br>\n    output). Not sure it helps specifically with your current problem,<br>\n    but it might be useful in general.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 236953596,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619862071
    },
    {
        "content": "<p>From: Matthys Grobbelaar &lt;<a href=\"mailto:m.grobbelaar@uq.net.au\">m.grobbelaar@uq.net.au</a>&gt;<br>\nHi Makarius,</p>\n<p>My overall approach is as follows:<br>\nIn order to add my queue of data into the theory context I have the following structure defined in a file structures.ML:</p>\n<p>--- BEGIN structures.ML ---<br>\nsignature VAR_LIST =<br>\nsig<br>\n    val get: theory -&gt; term Queue.T<br>\n    val add: term -&gt; theory -&gt; theory<br>\n    val reset: theory -&gt; theory<br>\nend;</p>\n<p>structure VarList: VAR_LIST =<br>\nstruct</p>\n<p>structure Terms = Theory_Data (<br>\n    type T = term Queue.T;<br>\n    val empty = Queue.empty;<br>\n    val extend = I;<br>\n    fun merge (ts1, ts2) = fold Queue.enqueue (Library.merge (op =) (Queue.content ts1, Queue.content ts2)) Queue.empty;<br>\n);</p>\n<p>val get = Terms.get;</p>\n<p>fun add raw_t thy = <br>\n    let<br>\n        val t = Sign.cert_term thy raw_t;<br>\n    in <a href=\"http://Terms.map\">Terms.map</a> (Queue.enqueue t) thy end;</p>\n<p>fun reset thy = Terms.put (Queue.empty) thy;</p>\n<p>end;</p>\n<p>--- END structures.ML ---</p>\n<p>Then, in a separate theory file, I have my syntax definition and translation function:</p>\n<p>--- BEGIN MyRelations.thy ---<br>\ntheory MyRelations<br>\n  imports Main  (* I'm not sure if there's a more appropriate theory to import *)<br>\nbegin</p>\n<p>ML_file \\&lt;open&gt; structures.ML \\&lt;close&gt;</p>\n<p>syntax<br>\n    \"_myrelation\" :: \"args =&gt; 'a set\" (\"\\&lt;lrel&gt;_\\&lt;rrel&gt;\")  (* lrel and rrel are new symbols I've defined *)</p>\n<p>ML \\&lt;open&gt;<br>\nfun translate_relation ctxt [trm] =<br>\n    let<br>\n        val data = VarList.get (Proof_Context.theory_of ctxt)  (* Retrieve the data in the theory context *)<br>\n        val _ = print_var_list data ctxt  (* Just prints out the terms in the list with the given context *) <br>\n        (* My actual translation uses the data stored to build a set of tuples satisfying a predicate *)<br>\n        val translation = @{term \"{((x, y),(x', y')). x &gt; x'}\"}   (* Just a dummy value for demo purposes *)<br>\n    in<br>\n        translation<br>\n    end<br>\n\\&lt;close&gt;</p>\n<p>parse_translation \\&lt;open&gt;[(@{syntax_const \"_myrelation\"}, translate_relation)] \\&lt;close&gt;<br>\nend<br>\n--- END MyRelations.thy ---</p>\n<p>Finally, I have a theory file used for testing the translation:</p>\n<p>--- BEGIN TestRelation.thy ---<br>\ntheory TestRelation<br>\n  imports \"MyRelations\"<br>\nbegin</p>\n<p>(* Update the theory context with the necessary data for translation *)<br>\nsetup \\&lt;open&gt;<br>\n  VarList.add (@{term \"x\"}) #&gt;<br>\n  VarList.add (@{term \"y\"}) #&gt;<br>\n  VarList.add (@{term \"z\"})<br>\n\\&lt;close&gt;</p>\n<p>(* See if the syntax creates the correct result *)<br>\n(* Note that the variables added create the tuples in the set comprehension *)<br>\n(* Here, the queue data is not printed out *)<br>\nlemma test_relation: \"\\&lt;lrel&gt; x &gt; x' \\&lt;rrel&gt;\" = \"{((x,y,z), (x',y',z')). x &gt; x'}\"</p>\n<p>(* We also create a duplicate of the translation function to see if it works differently *)<br>\nML \\&lt;open&gt;<br>\nfun translate_relation_dup ctxt [trm] =<br>\n    let<br>\n        val data = VarList.get (Proof_Context.theory_of ctxt) <br>\n        val _ = print_var_list data ctxt  <br>\n        val translation = @{term \"{((x, y),(x', y')). x &gt; x'}\"}   <br>\n    in<br>\n        translation<br>\n    end</p>\n<p>(* We call the duplicate translation function directly - the data is printed *)<br>\nval res = translate_relation_dup (Context.the_local_context ()) [@{term \"x &gt; x'\"}]<br>\n\\&lt;close&gt;<br>\nend<br>\n--- END TestRelation.thy ---</p>\n<p>So essentially, when the translation function is called via the syntax, the data stored<br>\nin the theory context is not passed into the function. However, when I call a duplicate<br>\ntranslation function with what I would think are identical arguments, the stored data<br>\nis present. </p>\n<p>I'm not sure where I'm going wrong.  Any help is much appreciated. I'm quite new<br>\nto Isabelle so I'm certain that there are better ways to go about this.</p>\n<p>Kind regards and thank you in advance,<br>\nMatthys Grobbelaar</p>\n<p>I find it hard to follow what you are actually doing. Can you show the formal explanation written in Isabelle/ML?</p>\n<p>A lot of details are non-standard in the small snipptes (e.g. use of Context.the_local_context, undefined, trm as name for a term), so it is likely that the overall approach is somehow wrong.</p>\n<p>Further note that in functional programming, functions are called \"functions\", not methods.</p>\n<p>Makarius</p>",
        "id": 237023894,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619928068
    },
    {
        "content": "<p>From: Matthys Grobbelaar &lt;<a href=\"mailto:m.grobbelaar@uq.net.au\">m.grobbelaar@uq.net.au</a>&gt;<br>\nHi Dominique,</p>\n<p>Thank you for your advice.<br>\nLearning about \\&lt;^context&gt;, &lt;\\^print&gt; and mk_literal has been very useful and has made debugging a lot easier.</p>\n<p>With regards to looking where JEdit jumps to, both jump to the same structure so the code is the same there. Also printing the theory appears to give the same output as well. It may well be that there is something happening with the namespaces.</p>\n<p>Kind regards,<br>\nMatthys Grobbelaar</p>\n<p>From: Dominique Unruh &lt;<a href=\"mailto:d.unruh@gmail.com\">d.unruh@gmail.com</a>&gt; On Behalf Of Dominique Unruh<br>\nSent: Saturday, 1 May 2021 7:41 PM<br>\nTo: Matthys Grobbelaar &lt;<a href=\"mailto:m.grobbelaar@uq.net.au\">m.grobbelaar@uq.net.au</a>&gt;<br>\nCc: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nSubject: Re: [isabelle] parse_translation does not detect changes in theory data</p>\n<blockquote>\n<p>Why would the same argument, given to identical methods in different files, have different results? It seems a bit strange to me.</p>\n</blockquote>\n<p>That does seem very strange to me, too. My best hypothesis is that they are not, actually, identical methods. (They might have the exact same code but, due to different namespaces, call different functions in their code.)</p>\n<p>What I would try:</p>\n<p>*   Write \\&lt;^context&gt; instead of \"Context.the_local_context ()\" in your experiments (shouldn't change much, but if you want to refer to the current context at compile time of a given code snippet, that's the right thing to use).<br>\n  *   Ctrl-click on both of VarList.get and VarList.print_vars to see where jEdit jumps. If it jumps to different places, then you have accidentally defined VarList twice. (Also check whether you might include the same ML-file twice.)<br>\n  *   Try and print theory you got, to see if it's the right one (val _ = Proof_Context.theory_of ctxt |&gt; \\&lt;^print&gt; or something like that). \\&lt;^print&gt; is useful generally for debugging because it can be applied to anything, not just strings.<br>\n  *   Instead of \"undefined\", you can also as a hack return debug output from a parse translation via: HOLogic.mk_literal string_to_return (this will then give you a string literal inside your parsed output). Not sure it helps specifically with your current problem, but it might be useful in general.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 237024341,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619928542
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThese theory and ML sources are the main means of communication, both with the<br>\nsystem and between humans.</p>\n<p>I've put everything into \"canonical form\", such it tells the story on its own<br>\naccount, using standard \"style and orthography\": see the attached<br>\nMy_Relation.thy. Doing this, it magically worked in the end, while your<br>\noriginal sources did not even type-check (maybe something was missing here and<br>\nthere).</p>\n<p>Of course, it requires some practice to do things in the proper way. It helps<br>\nto look around in documentation and existing implementations, and eventually<br>\ndevelop a taste for good and bad approaches.</p>\n<p>Here are also some concrete hints for your attempt so far:</p>\n<p>* There is no point to have many small files to obscure the structure of the<br>\nproject. Instead, I've written just one \"theory document\" with various<br>\nsections. (As the project grows and matures, it will of course have more files<br>\nat some later stage, e.g. at a healthy size of 5-25 KByte each.)</p>\n<p>* A theory name should consist of several words separated by underscore,<br>\ndescribing the main concept of your theory in singular. Plural is only used if<br>\nyou have multiple concepts, or multiple examples. E.g. theory<br>\n\"My_Great_Concept\" vs. theory \"My_Great_Concept_Examples\". Moreover,<br>\nWeDontUseCamelCaseAnymore, because Underscore_has_been_discovered_decades_ago.</p>\n<p>* For Isabelle/HOL the canonical import is indeed theory \"Main\"; you should<br>\nnot import anything more primitive inside HOL, because that would mean to<br>\ndepend on its rather complex bootstrap. Sometimes you need more base material,<br>\ne.g. types rat, real, complex: then you import \"Complex_Main\" or a different<br>\nlibrary entry point (beyond Main).</p>\n<p>* Theory data: Instead of the slightly odd Queue.T you can use a plain list<br>\nin \"canonical reverse order\" as shown in my version. To add means to \"cons\",<br>\nand to merge means to use the standard operation \"Library.merge\": with proper<br>\nequality on type term (aconv).</p>\n<p>* Symbols \\&lt;lrel&gt; and \\&lt;rrel&gt;: it is OK to experiment with newly allocated<br>\nsymbols in the infinite space of possibilities, but to get anything into the<br>\nofficial Isabelle release (e.g. for Isabelle/AFP entries with more than one<br>\nuser), it needs to be really convincing. (I've done that with some Z guys<br>\nrecently, and it required 2 weeks to get everything right: fonts, latex<br>\nmacros, symbol names and groups.)</p>\n<p>It is often better to use variants of pre-allocated symbols, e.g. together<br>\nwith \\&lt;^bold&gt; or other decoration to avoid conflicts. It is easy to define<br>\nspecific input methods for Isabelle/jEdit in the theory header using<br>\n\"abbrevs\", e.g. see theory HOL-Library.Finite_Map.</p>\n<p>Side-remark: the Isabelle Prover IDE is called Isabelle/jEdit, while \"jEdit\"<br>\nis a plain text editor used as a basis for that. Nobody would call an Emacs<br>\nmode for Isabelle just \"Emacs\", or a VSCode extension for Isabelle just \"VSCode\".</p>\n<p>It is important to treat the jEdit project honestly as something separate (and<br>\nquite different). It deserves its original name for itself, and not confuse it<br>\nwith our Prover IDE add-ons.</p>\n<p>(An alternative is to call Isabelle/jEdit abstractly \"PIDE\".)</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/C35RAh5d7JUt0-WaVYZA9lFl/My_Relation.thy\">My_Relation.thy</a></p>",
        "id": 237042281,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619949787
    },
    {
        "content": "<p>From: Matthys Grobbelaar &lt;<a href=\"mailto:m.grobbelaar@uq.net.au\">m.grobbelaar@uq.net.au</a>&gt;<br>\nHi Makarius,</p>\n<p>Thank you for the great advice, I appreciate it! It will really help improve my programming in Isabelle.<br>\nWith regards to structuring theories, I am constructing a framework of syntax translations (as part of a larger project) and would like to have a single top-level entry point which the other theories in the project can include if they would like to use the framework. </p>\n<p>At the moment I have the following entry point:</p>\n<p>--- BEGIN Translations_Main.thy ---<br>\ntheory Translations_Main<br>\n    imports<br>\n        \"core/My_Relation\"<br>\n        \"core/My_Predicate\"<br>\n        (* More imports are added here as the framework evolves *)<br>\nbegin</p>\n<p>end<br>\n--- END Translations_Main ---</p>\n<p>Then any other theory can simply use the framework by importing Translations_Main.<br>\nIs this the correct way to go about structuring such a framework? Are there things I should watch out for?</p>\n<p>Kind regards and thank you in advance,<br>\nMatthys Grobbelaar</p>\n<p>These theory and ML sources are the main means of communication, both with the system and between humans.</p>\n<p>I've put everything into \"canonical form\", such it tells the story on its own account, using standard \"style and orthography\": see the attached My_Relation.thy. Doing this, it magically worked in the end, while your original sources did not even type-check (maybe something was missing here and there).</p>\n<p>Of course, it requires some practice to do things in the proper way. It helps to look around in documentation and existing implementations, and eventually develop a taste for good and bad approaches.</p>\n<p>Here are also some concrete hints for your attempt so far:</p>\n<p>* There is no point to have many small files to obscure the structure of the project. Instead, I've written just one \"theory document\" with various sections. (As the project grows and matures, it will of course have more files at some later stage, e.g. at a healthy size of 5-25 KByte each.)</p>\n<p>* A theory name should consist of several words separated by underscore, describing the main concept of your theory in singular. Plural is only used if you have multiple concepts, or multiple examples. E.g. theory \"My_Great_Concept\" vs. theory \"My_Great_Concept_Examples\". Moreover, WeDontUseCamelCaseAnymore, because Underscore_has_been_discovered_decades_ago.</p>\n<p>* For Isabelle/HOL the canonical import is indeed theory \"Main\"; you should not import anything more primitive inside HOL, because that would mean to depend on its rather complex bootstrap. Sometimes you need more base material, e.g. types rat, real, complex: then you import \"Complex_Main\" or a different library entry point (beyond Main).</p>\n<p>* Theory data: Instead of the slightly odd Queue.T you can use a plain list in \"canonical reverse order\" as shown in my version. To add means to \"cons\", and to merge means to use the standard operation \"Library.merge\": with proper equality on type term (aconv).</p>\n<p>* Symbols \\&lt;lrel&gt; and \\&lt;rrel&gt;: it is OK to experiment with newly allocated symbols in the infinite space of possibilities, but to get anything into the official Isabelle release (e.g. for Isabelle/AFP entries with more than one user), it needs to be really convincing. (I've done that with some Z guys recently, and it required 2 weeks to get everything right: fonts, latex macros, symbol names and groups.)</p>\n<p>It is often better to use variants of pre-allocated symbols, e.g. together with \\&lt;^bold&gt; or other decoration to avoid conflicts. It is easy to define specific input methods for Isabelle/jEdit in the theory header using \"abbrevs\", e.g. see theory HOL-Library.Finite_Map.</p>\n<p>Side-remark: the Isabelle Prover IDE is called Isabelle/jEdit, while \"jEdit\"<br>\nis a plain text editor used as a basis for that. Nobody would call an Emacs mode for Isabelle just \"Emacs\", or a VSCode extension for Isabelle just \"VSCode\".</p>\n<p>It is important to treat the jEdit project honestly as something separate (and quite different). It deserves its original name for itself, and not confuse it with our Prover IDE add-ons.</p>\n<p>(An alternative is to call Isabelle/jEdit abstractly \"PIDE\".)</p>\n<p>Makarius</p>",
        "id": 237051299,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619960322
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIt is correct, merely some possibilities for fine-tuning:</p>\n<p>* No need for \"_Main\" in the name, just use a theory name that describes<br>\nyour framework, and potentially let it coincide with the session name. For<br>\nexample: session \"My_Great_Framework\" with main theory \"My_Great_Framework\"<br>\n(and \"_Framework\" does not have to be literally in the name).</p>\n<p>* Sub-directories for sessions are possible, but somehow confusing: it<br>\ncomplicates the mapping of the per-session theory name space to files, both<br>\nfor the system and the user.</p>\n<p>* Did you actually have a proper ROOT file with session definition already?<br>\nIf not, you can start with \"isabelle mkroot\" and then remove the generated<br>\ndocument setup; or you just look at example ROOT files (and strip the \"HOL-\"<br>\nname prefix).</p>\n<p>Makarius</p>",
        "id": 237052918,
        "sender_full_name": "Email Gateway",
        "timestamp": 1619962178
    }
]