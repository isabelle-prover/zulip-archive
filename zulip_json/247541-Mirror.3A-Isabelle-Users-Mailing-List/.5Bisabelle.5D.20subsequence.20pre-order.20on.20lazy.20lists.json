[
    {
        "content": "<p>From: Peter &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear List,</p>\n<p>does anyone know if the subsequence preorder on lazy lists has been <br>\nformalized in Isabelle:</p>\n<p>lsubseq :: 'a llist =&gt; 'a llist =&gt; bool</p>\n<p>xs <code>lsubseq</code> ys, iff xs can be obtained by erasing an arbitrary number <br>\nof elements from ys</p>\n<p>It should be reflexive and transitive, but is not antisymmetric:</p>\n<p>1212... <code>lsubseq</code> 2121... <code>lsubseq</code> 1212...</p>\n<p>I'm trying with the following definition:</p>\n<p>definition \"lsubseq a b ≡ ∃i. a = lmap snd (lfilter fst (lzip i b))\"</p>\n<p>reflexivity is straightforward, but proving transitivity seems <br>\nnon-straightforward (with my limited knowledge of coinductive).</p>\n<p>Any ideas, pointers to formalizations, etc?</p>\n<p>--</p>\n<p>Peter</p>",
        "id": 534248407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755096943
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nYes. It's called \"subseq\" and it is available in HOL-Library.Sublist.</p>\n<p>It's a special case of the notion of the \"homoeomorphic embedding\" <br>\nlist_emb, which lifts a relation R on list elements to a relation R on <br>\nlists, which basically works like the \"list_all2\" relator except that <br>\nyou're also allowed to ignore elements in the second list entirely.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 13/08/2025 16:55, Peter (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Dear List,</p>\n<p>does anyone know if the subsequence preorder on lazy lists has been <br>\nformalized in Isabelle:</p>\n<p>lsubseq :: 'a llist =&gt; 'a llist =&gt; bool</p>\n<p>xs <code>lsubseq</code> ys, iff xs can be obtained by erasing an arbitrary number <br>\nof elements from ys</p>\n<p>It should be reflexive and transitive, but is not antisymmetric:</p>\n<p>1212... <code>lsubseq</code> 2121... <code>lsubseq</code> 1212...</p>\n<p>I'm trying with the following definition:</p>\n<p>definition \"lsubseq a b ≡ ∃i. a = lmap snd (lfilter fst (lzip i b))\"</p>\n<p>reflexivity is straightforward, but proving transitivity seems <br>\nnon-straightforward (with my limited knowledge of coinductive).</p>\n<p>Any ideas, pointers to formalizations, etc?</p>\n<p>-- </p>\n<p>Peter</p>\n</blockquote>",
        "id": 534249838,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755097336
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n@Manuel: That one is on ordinary lists, whereas Peter asked for lazy lists.</p>\n<p>@Peter: There is the emb function on lazy lists here:</p>\n<p><a href=\"https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%23Lazy_List_Chain.emb|const&lt;https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%2523Lazy_List_Chain.emb%7Cconst\">https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%23Lazy_List_Chain.emb|const&lt;https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%2523Lazy_List_Chain.emb%7Cconst</a>&gt;</p>\n<p>This one has the extra feature that finite lazy lists are only embedded in other finite lazy lists. To omit that one could simply drop the lfinite assumption in the first introduction rule.</p>\n<p>I don’t think we proved transitivity or reflexivity, but both should hold.</p>\n<p>Dmitriy</p>\n<p>On 13 Aug 2025, at 17.01, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Yes. It's called \"subseq\" and it is available in HOL-Library.Sublist.</p>\n<p>It's a special case of the notion of the \"homoeomorphic embedding\" list_emb, which lifts a relation R on list elements to a relation R on lists, which basically works like the \"list_all2\" relator except that you're also allowed to ignore elements in the second list entirely.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 13/08/2025 16:55, Peter (via cl-isabelle-users Mailing List) wrote:<br>\nDear List,</p>\n<p>does anyone know if the subsequence preorder on lazy lists has been formalized in Isabelle:</p>\n<p>lsubseq :: 'a llist =&gt; 'a llist =&gt; bool</p>\n<p>xs <code>lsubseq</code> ys, iff xs can be obtained by erasing an arbitrary number of elements from ys</p>\n<p>It should be reflexive and transitive, but is not antisymmetric:</p>\n<p>1212... <code>lsubseq</code> 2121... <code>lsubseq</code> 1212...</p>\n<p>I'm trying with the following definition:</p>\n<p>definition \"lsubseq a b ≡ ∃i. a = lmap snd (lfilter fst (lzip i b))\"</p>\n<p>reflexivity is straightforward, but proving transitivity seems non-straightforward (with my limited knowledge of coinductive).</p>\n<p>Any ideas, pointers to formalizations, etc?</p>\n<p>--</p>\n<p>Peter</p>",
        "id": 534251371,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755097771
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nIndeed:</p>\n<p>lemma emb_refl: \"emb lxs lxs\"<br>\nproof (coinduction arbitrary: lxs)<br>\n  case (emb lxs)<br>\n  then show ?case<br>\n    by (cases lxs) (auto intro!: exI[of _ \"[]\"])<br>\nqed</p>\n<p>lemma emb_prepedD: \"emb (prepend xs lxs) lys ⟹ emb lxs lys\"<br>\n  by (induct xs arbitrary: lys)<br>\n    (auto elim!: emb_LConsE simp add: emb_prepend prepend_LCons)</p>\n<p>lemma emb_trans: \"emb lxs lys ⟹ emb lys lzs ⟹ emb lxs lzs\"<br>\nproof (coinduction arbitrary: lxs lys lzs)<br>\n  case (emb lxs lys lzs)<br>\n  then show ?case<br>\n  proof (cases lxs rule: llist.exhaust)<br>\n    case LNil<br>\n    then show ?thesis<br>\n      using emb emb_lfinite by auto<br>\n  next<br>\n    case (LCons x lxs')<br>\n    with emb show ?thesis<br>\n      unfolding LCons<br>\n      by (auto dest!: emb_prepedD elim!: emb_LConsE)<br>\n  qed<br>\nqed</p>\n<p>Dmitriy</p>\n<p>On 13 Aug 2025, at 17.09, Dmitriy Traytel &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; wrote:</p>\n<p>@Manuel: That one is on ordinary lists, whereas Peter asked for lazy lists.</p>\n<p>@Peter: There is the emb function on lazy lists here:</p>\n<p><a href=\"https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%23Lazy_List_Chain.emb%7Cconst&lt;https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%2523Lazy_List_Chain.emb%7Cconst\">https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%23Lazy_List_Chain.emb%7Cconst&lt;https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%2523Lazy_List_Chain.emb%7Cconst</a>&gt;</p>\n<p>This one has the extra feature that finite lazy lists are only embedded in other finite lazy lists. To omit that one could simply drop the lfinite assumption in the first introduction rule.</p>\n<p>I don’t think we proved transitivity or reflexivity, but both should hold.</p>\n<p>Dmitriy</p>\n<p>On 13 Aug 2025, at 17.01, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Yes. It's called \"subseq\" and it is available in HOL-Library.Sublist.</p>\n<p>It's a special case of the notion of the \"homoeomorphic embedding\" list_emb, which lifts a relation R on list elements to a relation R on lists, which basically works like the \"list_all2\" relator except that you're also allowed to ignore elements in the second list entirely.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 13/08/2025 16:55, Peter (via cl-isabelle-users Mailing List) wrote:<br>\nDear List,</p>\n<p>does anyone know if the subsequence preorder on lazy lists has been formalized in Isabelle:</p>\n<p>lsubseq :: 'a llist =&gt; 'a llist =&gt; bool</p>\n<p>xs <code>lsubseq</code> ys, iff xs can be obtained by erasing an arbitrary number of elements from ys</p>\n<p>It should be reflexive and transitive, but is not antisymmetric:</p>\n<p>1212... <code>lsubseq</code> 2121... <code>lsubseq</code> 1212...</p>\n<p>I'm trying with the following definition:</p>\n<p>definition \"lsubseq a b ≡ ∃i. a = lmap snd (lfilter fst (lzip i b))\"</p>\n<p>reflexivity is straightforward, but proving transitivity seems non-straightforward (with my limited knowledge of coinductive).</p>\n<p>Any ideas, pointers to formalizations, etc?</p>\n<p>--</p>\n<p>Peter</p>",
        "id": 534260526,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755100790
    },
    {
        "content": "<p>From: Peter &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nNice, thank you!</p>\n<p>your proof works without adaptation on the version without lfinite.</p>\n<p>--</p>\n<p>Peter</p>\n<p>p.s.</p>\n<p>I was almost there, but didn't see that I needed to generalize over <br>\nlzs ... lack of experience with coinductive, as said ;)</p>\n<p>On 13/08/2025 17:59, Dmitriy Traytel (via cl-isabelle-users Mailing <br>\nList) wrote:</p>\n<blockquote>\n<p>Indeed:</p>\n<p>lemma emb_refl: \"emb lxs lxs\"<br>\nproof (coinduction arbitrary: lxs)<br>\n  case (emb lxs)<br>\n  then show ?case<br>\n    by (cases lxs) (auto intro!: exI[of _ \"[]\"])<br>\nqed</p>\n<p>lemma emb_prepedD: \"emb (prepend xs lxs) lys ⟹ emb lxs lys\"<br>\n  by (induct xs arbitrary: lys)<br>\n    (auto elim!: emb_LConsE simp add: emb_prepend prepend_LCons)</p>\n<p>lemma emb_trans: \"emb lxs lys ⟹ emb lys lzs ⟹ emb lxs lzs\"<br>\nproof (coinduction arbitrary: lxs lys lzs)<br>\n  case (emb lxs lys lzs)<br>\n  then show ?case<br>\n  proof (cases lxs rule: llist.exhaust)<br>\n    case LNil<br>\n    then show ?thesis<br>\n      using emb emb_lfinite by auto<br>\n  next<br>\n    case (LCons x lxs')<br>\n    with emb show ?thesis<br>\n      unfolding LCons<br>\n      by (auto dest!: emb_prepedD elim!: emb_LConsE)<br>\n  qed<br>\nqed</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 13 Aug 2025, at 17.09, Dmitriy Traytel <br>\n&lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; wrote:</p>\n<p>@Manuel: That one is on ordinary lists, whereas Peter asked for lazy <br>\nlists.</p>\n<p>@Peter: There is the emb function on lazy lists here:</p>\n<p><a href=\"https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%23Lazy_List_Chain.emb|const\">https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%23Lazy_List_Chain.emb|const</a> <br>\n&lt;<a href=\"https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%2523Lazy_List_Chain.emb%7Cconst\">https://www.isa-afp.org/sessions/ordered_resolution_prover/#Lazy_List_Chain.html%2523Lazy_List_Chain.emb%7Cconst</a>&gt;</p>\n<p>This one has the extra feature that finite lazy lists are only <br>\nembedded in other finite lazy lists. To omit that one could simply <br>\ndrop the lfinite assumption in the first introduction rule.</p>\n<p>I don’t think we proved transitivity or reflexivity, but both should <br>\nhold.</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>On 13 Aug 2025, at 17.01, Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt; wrote:</p>\n<p>Yes. It's called \"subseq\" and it is available in HOL-Library.Sublist.</p>\n<p>It's a special case of the notion of the \"homoeomorphic embedding\" <br>\nlist_emb, which lifts a relation R on list elements to a relation R <br>\non lists, which basically works like the \"list_all2\" relator except <br>\nthat you're also allowed to ignore elements in the second list entirely.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 13/08/2025 16:55, Peter (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Dear List,</p>\n<p>does anyone know if the subsequence preorder on lazy lists has been <br>\nformalized in Isabelle:</p>\n<p>lsubseq :: 'a llist =&gt; 'a llist =&gt; bool</p>\n<p>xs <code>lsubseq</code> ys, iff xs can be obtained by erasing an arbitrary <br>\nnumber of elements from ys</p>\n<p>It should be reflexive and transitive, but is not antisymmetric:</p>\n<p>1212... <code>lsubseq</code> 2121... <code>lsubseq</code> 1212...</p>\n<p>I'm trying with the following definition:</p>\n<p>definition \"lsubseq a b ≡ ∃i. a = lmap snd (lfilter fst (lzip i b))\"</p>\n<p>reflexivity is straightforward, but proving transitivity seems <br>\nnon-straightforward (with my limited knowledge of coinductive).</p>\n<p>Any ideas, pointers to formalizations, etc?</p>\n<p>-- </p>\n<p>Peter</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 534263970,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755101986
    }
]