[
    {
        "content": "<p>From: Stepan Holub &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHello,</p>\n<p>today I happened to compile \"HOL-Analysis.Abstract_Topological_Spaces\" <br>\nwhich takes about 5 minutes on my notebook.<br>\nOut of curiosity, I looked at the longest \"by metis\" which takes about<br>\n20 s. It is</p>\n<blockquote>\n<p>by (metis (no_types) assms closed_real_atLeastAtMost closed_closedin<br>\ncontinuous_map_closedin)</p>\n</blockquote>\n<p>on line 3310.</p>\n<p>A trivial transformation (guessed easily without understanding what is <br>\ngoing on in the proof) to</p>\n<blockquote>\n<p>using closed_real_atLeastAtMost[unfolded closed_closedin]<br>\nassms[unfolded continuous_map_closedin]  by blast</p>\n</blockquote>\n<p>brings it down to practically zero.</p>\n<p>This is not very interesting in itself but it raises for me following <br>\nquestions:</p>\n<ul>\n<li>\n<p>I suspect that (at least) HOL-Analysis could be drastically sped up by <br>\nsimilar interventions. Is that a reasonable assumption?</p>\n</li>\n<li>\n<p>If so, is it something the community cares about?</p>\n</li>\n<li>If so, could the optimization be somehow automated? Since my <br>\nimprovement, as I said, was immediate, AI should be able to do the same <br>\nin similar cases.</li>\n</ul>\n<p>Stepan</p>",
        "id": 534043903,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755027402
    },
    {
        "content": "<p>From: Martin Desharnais &lt;<a href=\"mailto:martin.desharnais@posteo.de\">martin.desharnais@posteo.de</a>&gt;<br>\nHi Stepan,</p>\n<p>On 12.08.25 21:28, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Out of curiosity, I looked at the longest \"by metis\" which takes about<br>\n20 s. It is</p>\n<blockquote>\n<p>by (metis (no_types) assms closed_real_atLeastAtMost closed_closedin<br>\ncontinuous_map_closedin)</p>\n</blockquote>\n<p>on line 3310.</p>\n<p>A trivial transformation (guessed easily without understanding what is <br>\ngoing on in the proof) to</p>\n<blockquote>\n<p>using closed_real_atLeastAtMost[unfolded closed_closedin]<br>\nassms[unfolded continuous_map_closedin]  by blast</p>\n</blockquote>\n<p>brings it down to practically zero.</p>\n</blockquote>\n<p>I checked the mentioned theory and found two duplicates of the proof you <br>\npresented, each of which taking approximately 7.5 seconds on my laptop. <br>\nI (very slightly) generalized the proof step, proved it with your <br>\nsuggested proof, and reused the generalized proof step in both places <br>\n(See Isabelle/7ac70210d12c).</p>\n<blockquote>\n<p>This is not very interesting in itself but it raises for me following <br>\nquestions:</p>\n<ul>\n<li>I suspect that (at least) HOL-Analysis could be drastically sped up by <br>\nsimilar interventions. Is that a reasonable assumption?</li>\n<li>If so, is it something the community cares about?</li>\n</ul>\n</blockquote>\n<p>I suspect that many the verification of many formalizations could be <br>\nsped up by tuning some of the proofs.</p>\n<p>As for caring about it, opinions may vary. I believe that one should <br>\nstrive for a balance between readability, maintainability, and <br>\nverification performance; verification performance not only reduce the <br>\nrunning time, but also the energy consumption.</p>\n<p>I believe the change you proposed was a good one, because it improved <br>\nboth readability and performance.</p>\n<blockquote>\n<ul>\n<li>If so, could the optimization be somehow automated? Since my <br>\nimprovement, as I said, was immediate, AI should be able to do the same <br>\nin similar cases.</li>\n</ul>\n</blockquote>\n<p>Yes, some proof refactoring could be automated if one was to invest the <br>\ntime into writing a tool. Many heuristics could be used including AI, <br>\nSledgehammer, try0, and metis_instantiate. I personally like to use <br>\nmetis_instantiate and select some simple fact instantiation that <br>\nsimplify the proof search.</p>\n<p>Regards,<br>\nMartin</p>",
        "id": 534172281,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755069944
    },
    {
        "content": "<p>From: Gergely Buday &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nStepan Holub wrote:</p>\n<blockquote>\n<p>today I happened to compile \"HOL-Analysis.Abstract_Topological_Spaces\"<br>\nwhich takes about 5 minutes on my notebook.<br>\nOut of curiosity, I looked at the longest \"by metis\" which takes about<br>\n20 s. It is</p>\n<blockquote>\n<p>by (metis (no_types) assms closed_real_atLeastAtMost closed_closedin<br>\ncontinuous_map_closedin)</p>\n</blockquote>\n<p>on line 3310.</p>\n<p>A trivial transformation (guessed easily without understanding what is<br>\ngoing on in the proof) to</p>\n<blockquote>\n<p>using closed_real_atLeastAtMost[unfolded closed_closedin]<br>\nassms[unfolded continuous_map_closedin]  by blast</p>\n</blockquote>\n<p>brings it down to practically zero.</p>\n<p>This is not very interesting in itself but it raises for me following<br>\nquestions:</p>\n</blockquote>\n<p>I think this is indeed interesting, and shows that while low level<br>\nmassaging is frowned upon but it is actually useful, it reduces the<br>\nsearch space much. I would love to see a write up on this. Is there<br>\none?</p>\n<ul>\n<li>Gergely</li>\n</ul>",
        "id": 534172847,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755070197
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI tuned another slow proof in HOL-Analysis.<br>\nUsing the timimg panel, I was surprised that this showed up:</p>\n<ul>\n<li>HOL-Analysis.Infinite_Sum<ul>\n<li>91.8 command \"text\"</li>\n</ul>\n</li>\n</ul>\n<p>Does that have anything to do with the cite command in that text block?</p>\n<p>Tobias</p>\n<p>On 12/08/2025 21:28, Stepan Holub (via cl-isabelle-users Mailing List) wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>today I happened to compile \"HOL-Analysis.Abstract_Topological_Spaces\" which <br>\ntakes about 5 minutes on my notebook.<br>\nOut of curiosity, I looked at the longest \"by metis\" which takes about<br>\n20 s. It is</p>\n<blockquote>\n<p>by (metis (no_types) assms closed_real_atLeastAtMost closed_closedin<br>\ncontinuous_map_closedin)</p>\n</blockquote>\n<p>on line 3310.</p>\n<p>A trivial transformation (guessed easily without understanding what is going <br>\non in the proof) to</p>\n<blockquote>\n<p>using closed_real_atLeastAtMost[unfolded closed_closedin]<br>\nassms[unfolded continuous_map_closedin]  by blast</p>\n</blockquote>\n<p>brings it down to practically zero.</p>\n<p>This is not very interesting in itself but it raises for me following questions:</p>\n<ul>\n<li>I suspect that (at least) HOL-Analysis could be drastically sped up by similar <br>\ninterventions. Is that a reasonable assumption?</li>\n<li>If so, is it something the community cares about?</li>\n<li>If so, could the optimization be somehow automated? Since my improvement, as I <br>\nsaid, was immediate, AI should be able to do the same in similar cases.</li>\n</ul>\n<p>Stepan</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/hSHHQMk2J7e0dqri8DiOs7Fa/smime.p7s\">smime.p7s</a></p>",
        "id": 534173677,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755070549
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nHello,</p>\n<p>as a big user of HOL-Analysis: yes, getting rid of a metis call that <br>\nruns for this long is definitely a valuable improvement. This timing <br>\ninformation has to be taken with a grain of salt, but 20s seems <br>\nexcessive even for an outlier.</p>\n<p>As Martin pointed out, performance is not the only concern, but as far <br>\nas readability and maintainability are concerned, metis calls are <br>\nalready pretty bad in my opinion, so anything you replace them with is <br>\nunlikely to be worse in those regards.</p>\n<p>@Martin: You mention \"metis_instantiate\". What is that? I couldn't find <br>\nanything about it.</p>\n<p>Manuel</p>",
        "id": 534182781,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755074069
    },
    {
        "content": "<p>From: Martin Desharnais &lt;<a href=\"mailto:martin.desharnais@posteo.de\">martin.desharnais@posteo.de</a>&gt;<br>\nHi Manuel,</p>\n<p>On 13.08.25 10:32, Manuel Eberl wrote:</p>\n<blockquote>\n<p>@Martin: You mention \"metis_instantiate\". What is that? I couldn't find <br>\nanything about it.</p>\n</blockquote>\n<p>Fact instantiation is a new feature in Isabelle2025 implemented by Lukas <br>\nBartl both in Metis and Sledgehammer. It is described in the <br>\nSledgehammer documentation.</p>\n<p>The metis option is documented in § 6.2:</p>\n<blockquote>\n<p>The metis method also supports the Isabelle option<br>\n[[metis_instantiate]], which tells metis to infer and suggest<br>\ninstantiations of facts using of from a successful proof.</p>\n</blockquote>\n<p>The Sledgehammer option is documented in § 7.4:</p>\n<blockquote>\n<p>instantiate [= smart_bool]<br>\nSpecifies whether Metis should try to infer variable instantiations<br>\nbe fore proof reconstruction, which results in instantiations of facts<br>\nusing of (e.g. map_prod_surj_on[of f A \"f <code>A\" g B \"g </code>B\"]). This can<br>\nmake the proof methods faster and more intelligible. If the option is<br>\nset to smart (the default), variable instantiations are inferred only<br>\nif proof reconstruction failed or timed out. (</p>\n</blockquote>\n<p>See the following CADE-30 paper for details:</p>\n<p>Lukas Bartl, Jasmin Blanchette and Tobias Nipkow. Exploiting <br>\nInstantiations from Paramodulation Proofs in Isabelle/HOL.</p>\n<p>Regards,<br>\nMartin</p>",
        "id": 534184787,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755074799
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nmetis_instantiate:<br>\n<a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette/inst.pdf\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette/inst.pdf</a></p>\n<p>It is the new secret weapon to simplify metis proofs. Once you have a metis <br>\nproof, you precede it with \"using [[metis_instantiate]]\" and it spits out a <br>\nmetis proof where the facts are instantiated (with \"of\") as much as possible. <br>\nThat proof tends to run more quickly, but you can also try to turn it into a <br>\nsimp/auto/etc proof by trying something like</p>\n<p>using &lt;key instantiated facts&gt; by simp/auto/etc</p>\n<p>and leaving out all the trivial lemmas that cluter up the metis proof.</p>\n<p>Sometimes it helps...</p>\n<p>Tobias</p>\n<p>On 13/08/2025 10:32, Manuel Eberl wrote:</p>\n<blockquote>\n<p>@Martin: You mention \"metis_instantiate\". What is that? I couldn't find anything <br>\nabout it.</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/y0yfzCgZeV8EXnyFJrFNwBel/smime.p7s\">smime.p7s</a></p>",
        "id": 534184994,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755074874
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:manuel@pruvisto.org\">manuel@pruvisto.org</a>&gt;<br>\nOkay, that's exactly what I thought it would be and it's amazing. Well, <br>\nI assume it is, I haven't tried it yet. But I've been wanting something <br>\nlike this for a long time.</p>\n<p>Thanks to you all!</p>\n<p>Manuel</p>\n<p>On 13/08/2025 10:47, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>metis_instantiate:<br>\n<a href=\"https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette/inst.pdf\">https://www.tcs.ifi.lmu.de/mitarbeiter/jasmin-blanchette/inst.pdf</a></p>\n<p>It is the new secret weapon to simplify metis proofs. Once you have a <br>\nmetis proof, you precede it with \"using [[metis_instantiate]]\" and it <br>\nspits out a metis proof where the facts are instantiated (with \"of\") <br>\nas much as possible. That proof tends to run more quickly, but you can <br>\nalso try to turn it into a simp/auto/etc proof by trying something like</p>\n<p>using &lt;key instantiated facts&gt; by simp/auto/etc</p>\n<p>and leaving out all the trivial lemmas that cluter up the metis proof.</p>\n<p>Sometimes it helps...</p>\n<p>Tobias</p>\n<p>On 13/08/2025 10:32, Manuel Eberl wrote:</p>\n<blockquote>\n<p>@Martin: You mention \"metis_instantiate\". What is that? I couldn't <br>\nfind anything about it.<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 534192208,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755077551
    },
    {
        "content": "<p>From: Fabian Huch &lt;<a href=\"mailto:huch@in.tum.de\">huch@in.tum.de</a>&gt;</p>\n<p>On 8/13/25 09:19, Martin Desharnais wrote:</p>\n<blockquote>\n<p>Hi Stepan,</p>\n<p>On 12.08.25 21:28, Stepan Holub (via cl-isabelle-users Mailing List) <br>\nwrote:</p>\n<blockquote>\n<p>Out of curiosity, I looked at the longest \"by metis\" which takes about<br>\n20 s. It is</p>\n<blockquote>\n<p>by (metis (no_types) assms closed_real_atLeastAtMost closed_closedin<br>\ncontinuous_map_closedin)</p>\n</blockquote>\n<p>on line 3310.</p>\n<p>A trivial transformation (guessed easily without understanding what <br>\nis going on in the proof) to</p>\n<blockquote>\n<p>using closed_real_atLeastAtMost[unfolded closed_closedin]<br>\nassms[unfolded continuous_map_closedin]  by blast</p>\n</blockquote>\n<p>brings it down to practically zero.</p>\n</blockquote>\n<p>I checked the mentioned theory and found two duplicates of the proof <br>\nyou presented, each of which taking approximately 7.5 seconds on my <br>\nlaptop. I (very slightly) generalized the proof step, proved it with <br>\nyour suggested proof, and reused the generalized proof step in both <br>\nplaces (See Isabelle/7ac70210d12c).</p>\n<blockquote>\n<p>This is not very interesting in itself but it raises for me following <br>\nquestions:</p>\n<ul>\n<li>I suspect that (at least) HOL-Analysis could be drastically sped up <br>\nby similar interventions. Is that a reasonable assumption?</li>\n<li>If so, is it something the community cares about?</li>\n</ul>\n</blockquote>\n<p>I suspect that many the verification of many formalizations could be <br>\nsped up by tuning some of the proofs.</p>\n<p>As for caring about it, opinions may vary. I believe that one should <br>\nstrive for a balance between readability, maintainability, and <br>\nverification performance; verification performance not only reduce the <br>\nrunning time, but also the energy consumption.</p>\n<p>I believe the change you proposed was a good one, because it improved <br>\nboth readability and performance.</p>\n<blockquote>\n<ul>\n<li>If so, could the optimization be somehow automated? Since my <br>\nimprovement, as I said, was immediate, AI should be able to do the <br>\nsame in similar cases.</li>\n</ul>\n</blockquote>\n<p>Yes, some proof refactoring could be automated if one was to invest <br>\nthe time into writing a tool.</p>\n</blockquote>\n<p>I wrote a tool for this once, but wasn't fully satisfied by the <br>\napproach: It uses a build hook, which makes it very difficult to obtain <br>\nlocal facts used in a proof. A better (but even less scalable) approach <br>\nwould be to use an interactive session for this. The second problem was <br>\nan issue with threading, where after starting a large number of threads <br>\n(to process many goals) the system became unresponsive.</p>\n<p>To obtain a good ranking for proofs, one also needs to obtain data on <br>\nwhich proofs are preferred. I attempted to get responses for this once <br>\n(from the AFP editors) but didn't receive too many.</p>\n<p>If someone wants to pick this up, I am happy to share the prototype.</p>\n<p>Fabian</p>",
        "id": 534193974,
        "sender_full_name": "Email Gateway",
        "timestamp": 1755078203
    }
]