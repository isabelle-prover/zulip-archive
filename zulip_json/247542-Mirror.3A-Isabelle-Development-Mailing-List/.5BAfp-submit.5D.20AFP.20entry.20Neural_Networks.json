[
    {
        "content": "<p><strong>From:</strong> Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<p>It looks like what has changed is the pretty-printing. I think (just did <br>\na quick check with Java) as a IEEE-32 value, both numbers are the same <br>\n(the closest IEEE-32 floating point number to this decimal <br>\nrepresentation is the same, namely 3be810c5).</p>\n<p>--</p>\n<p>Peter</p>\n<p>On 20/11/2025 12:35, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I find it surprising that the meaning of a specific bit pattern as a real number according to an established floating-point standard can change from year to year. How do we know it won't change again?</p>\n<p>Larry</p>\n<blockquote>\n<p>On 19 Nov 2025, at 22:37, Achim D. Brucker &lt;<a href=\"mailto:adbrucker@0x5f.org\">adbrucker@0x5f.org</a>&gt; wrote:</p>\n<p>Hi,<br>\nI did a first investigation. Overall, this part of the theory is intended to serve as regression test. Thus, it worked as it should: acting as early warning for subtle changes that otherwise would go undetected, potentially creating \"bit rot\".</p>\n<p>The change is actually due to a difference in Poly/ML used in Isabelle 2025 vs the current development version (and, 2025-1, for that matter). Namely:</p>\n<p>ML\\&lt;open&gt;<br>\n     PackReal32Little.fromBytes (Word8Vector.fromList [0wxC5, 0wx10, 0wxE8, 0wx3B])<br>\n\\&lt;close&gt;</p>\n<p>returns a different value, namely:</p>\n<ul>\n<li>Isabelle 2025:                                  val it = 0.007082077209: PackReal32Little.real</li>\n<li>Isabelle development/2025-1:      val it = 0.007082077: PackReal32Little.real</li>\n</ul>\n<p>As the rule-of-thumb regarding the precision of 32 IEEE-745 floating point numbers is around 7-8 decimal digits, the new behaviour is OK. Hence, the fix to get the AFP entry working again is to update the theories to reflect the new values.<br>\nWe will take care of this tomorrow.</p>\n<p>Best,<br>\nAchim (and Amy)</p>\n<p>On 19/11/2025 16:25, Lawrence Paulson via isabelle-dev wrote:</p>\n<blockquote>\n<p>Neural_Networks is badly broken. I took a look and the failure is in a proof that tests whether a certain generated construction is equal to an explicit construction. They are supposed to be literally identical and are not. I think we should get back to the authors to find out why it failed and how it can be made robust.</p>\n<p>Larry</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>Afp-submit mailing list<br>\n<a href=\"mailto:Afp-submit@mailman.proof.cit.tum.de\">Afp-submit@mailman.proof.cit.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/afp-submit\">https://mailman46.in.tum.de/mailman/listinfo/afp-submit</a></p>\n</blockquote>",
        "id": 558414648,
        "sender_full_name": "Email Gateway",
        "timestamp": 1763640894
    },
    {
        "content": "<p><strong>From:</strong> \"Achim D. Brucker\" &lt;<a href=\"mailto:adbrucker@0x5f.org\">adbrucker@0x5f.org</a>&gt;</p>\n<p>Hi,<br>\nThis is also my assumption.  The values used by me in the below example <br>\nare after pretty printing (i.e., convertio to strings).</p>\n<p>The actually value stored is 0.070820772089064121246337890625 (decoding <br>\nit \"manually\", following the standard). Trying to print it in a small C <br>\nprogramm gives 0.00708207720890641212, which seems to be the offical <br>\ndecimal represenation according to the standard. IEEE754  is not easy ...</p>\n<p>Achim</p>\n<p>On 20/11/2025 12:14, Peter Lammich wrote:</p>\n<blockquote>\n<p>It looks like what has changed is the pretty-printing. I think (just <br>\ndid a quick check with Java) as a IEEE-32 value, both numbers are the <br>\nsame (the closest IEEE-32 floating point number to this decimal <br>\nrepresentation is the same, namely 3be810c5).</p>\n<p>-- </p>\n<p>Peter</p>\n<p>On 20/11/2025 12:35, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I find it surprising that the meaning of a specific bit pattern as a <br>\nreal number according to an established floating-point standard can <br>\nchange from year to year. How do we know it won't change again?</p>\n<p>Larry</p>\n<blockquote>\n<p>On 19 Nov 2025, at 22:37, Achim D. Brucker &lt;<a href=\"mailto:adbrucker@0x5f.org\">adbrucker@0x5f.org</a>&gt; wrote:</p>\n<p>Hi,<br>\nI did a first investigation. Overall, this part of the theory is <br>\nintended to serve as regression test. Thus, it worked as it should: <br>\nacting as early warning for subtle changes that otherwise would go <br>\nundetected, potentially creating \"bit rot\".</p>\n<p>The change is actually due to a difference in Poly/ML used in <br>\nIsabelle 2025 vs the current development version (and, 2025-1, for <br>\nthat matter). Namely:</p>\n<p>ML\\&lt;open&gt;<br>\n     PackReal32Little.fromBytes (Word8Vector.fromList [0wxC5, 0wx10, <br>\n0wxE8, 0wx3B])<br>\n\\&lt;close&gt;</p>\n<p>returns a different value, namely:</p>\n<ul>\n<li>Isabelle 2025:                                  val it = <br>\n0.007082077209: PackReal32Little.real</li>\n<li>Isabelle development/2025-1:      val it = 0.007082077: <br>\nPackReal32Little.real</li>\n</ul>\n<p>As the rule-of-thumb regarding the precision of 32 IEEE-745 floating <br>\npoint numbers is around 7-8 decimal digits, the new behaviour is OK. <br>\nHence, the fix to get the AFP entry working again is to update the <br>\ntheories to reflect the new values.<br>\nWe will take care of this tomorrow.</p>\n<p>Best,<br>\nAchim (and Amy)</p>\n<p>On 19/11/2025 16:25, Lawrence Paulson via isabelle-dev wrote:</p>\n<blockquote>\n<p>Neural_Networks is badly broken. I took a look and the failure is <br>\nin a proof that tests whether a certain generated construction is <br>\nequal to an explicit construction. They are supposed to be <br>\nliterally identical and are not. I think we should get back to the <br>\nauthors to find out why it failed and how it can be made robust.</p>\n<p>Larry</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>Afp-submit mailing list<br>\n<a href=\"mailto:Afp-submit@mailman.proof.cit.tum.de\">Afp-submit@mailman.proof.cit.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/afp-submit\">https://mailman46.in.tum.de/mailman/listinfo/afp-submit</a></p>\n</blockquote>\n</blockquote>",
        "id": 558428269,
        "sender_full_name": "Email Gateway",
        "timestamp": 1763644913
    },
    {
        "content": "<p><strong>From:</strong> Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;</p>\n<p>On 20/11/2025 14:21, Achim D. Brucker wrote:</p>\n<blockquote>\n<p>The actually value stored is 0.070820772089064121246337890625 (decoding it <br>\n\"manually\", following the standard). Trying to print it in a small C programm <br>\ngives 0.00708207720890641212, which seems to be the offical decimal <br>\nrepresenation according to the standard. IEEE754  is not easy ...<br>\nNote that there have been changes on reals in polyml-5.9.1 (Isabelle2025) to <br>\npolyml-5.9.2 (Isabelle2025-1).</p>\n</blockquote>\n<p>An example changeset by David Matthews is here <br>\n<a href=\"https://github.com/polyml/polyml/commit/cc497eb585b0\">https://github.com/polyml/polyml/commit/cc497eb585b0</a></p>\n<p>Maybe someone who understands the fine points can check if it has become more <br>\ncorrect or less correct.</p>\n<p>Makarius</p>",
        "id": 558442449,
        "sender_full_name": "Email Gateway",
        "timestamp": 1763648477
    },
    {
        "content": "<p><strong>From:</strong> Lawrence Paulson via isabelle-dev &lt;<a href=\"mailto:isabelle-dev@mailman.proof.cit.tum.de\">isabelle-dev@mailman.proof.cit.tum.de</a>&gt;</p>\n<p>I know that converting a floating point number to decimal notation is tricky, but we must've had correct algorithms for decades now. I wonder whether anybody has formalised one :-)</p>\n<p>Larry<br>\nOn 20 Nov 2025 at 13:21 +0000, Achim D. Brucker &lt;<a href=\"mailto:adbrucker@0x5f.org\">adbrucker@0x5f.org</a>&gt;, wrote:</p>\n<p>This is also my assumption.  The values used by me in the below example<br>\nare after pretty printing (i.e., convertio to strings).</p>\n<p>The actually value stored is 0.070820772089064121246337890625 (decoding<br>\nit \"manually\", following the standard). Trying to print it in a small C<br>\nprogramm gives 0.00708207720890641212, which seems to be the offical<br>\ndecimal represenation according to the standard. IEEE754  is not easy ...</p>",
        "id": 558447497,
        "sender_full_name": "Email Gateway",
        "timestamp": 1763649685
    },
    {
        "content": "<p><strong>From:</strong> Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<p>I remember having seen a talk about that ... but I cannot find any <br>\nmatching papers :(</p>\n<p>On 20/11/2025 15:40, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I know that converting a floating point number to decimal notation is <br>\ntricky, but we must've had correct algorithms for decades now. I <br>\nwonder whether anybody has formalised one :-)</p>\n<p>Larry<br>\nOn 20 Nov 2025 at 13:21 +0000, Achim D. Brucker &lt;<a href=\"mailto:adbrucker@0x5f.org\">adbrucker@0x5f.org</a>&gt;, <br>\nwrote:</p>\n<blockquote>\n<p>This is also my assumption.  The values used by me in the below example<br>\nare after pretty printing (i.e., convertio to strings).</p>\n<p>The actually value stored is 0.070820772089064121246337890625 (decoding<br>\nit \"manually\", following the standard). Trying to print it in a small C<br>\nprogramm gives 0.00708207720890641212, which seems to be the offical<br>\ndecimal represenation according to the standard. IEEE754  is not easy ...</p>\n</blockquote>\n</blockquote>",
        "id": 558459890,
        "sender_full_name": "Email Gateway",
        "timestamp": 1763652507
    }
]