[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is an intermediate report on the state of support for the ARM64 platform,<br>\naccording to Isabelle/694d0a315d0a.</p>\n<p>Presently, its main hardware representative is my new Raspberry Pi 4B (4 CPU<br>\ncores at 1.5 GHz, 8 GB RAM), running Ubuntu Linux 20.04 LTS. I've purchased<br>\nthat for a bit less than 100 EUR; a suitable micro SD storage card needs to be<br>\nadded (e.g. 128 GB for 20 EUR).</p>\n<p>The most relevant Isabelle components already include arm64-linux parts, but<br>\njdk is still missing. This works e.g. via the Ubuntu package \"openjdk-11-jdk\"<br>\nand the following $ISABELLE_HOME_USER/etc/settings:</p>\n<p>ISABELLE_JDK_HOME=\"/usr/lib/jvm/java-11-openjdk-arm64\"</p>\n<p>An alternative is to download/unpack JDK 11 from <a href=\"https://adoptopenjdk.net\">https://adoptopenjdk.net</a><br>\n(platform aarch64) and point to that directory. I will include that in the<br>\nnext official update of the jdk component, probably at the end of October.</p>\n<p>Now most Isabelle/Scala tools should work properly, as well as Isabelle/ML<br>\nbased on the existing interpreter by David Matthews for that platform: it is<br>\napprox. 50-100 times slower than the standard code-generator for x86_64.</p>\n<p>Consequently, \"isabelle jedit\" might require some hours to build the Scala<br>\njars + ML logic image for HOL (while ZF only requires minutes). To reduce<br>\nheat, it might require to disable the display and run \"isabelle build -b HOL\"<br>\nfirst via ssh.</p>\n<p>At this stage we can already use sledgehammer with prover \"e\", e.g. in<br>\n$ISABELLE_HOME/src/HOL/Metis_Examples/BigO.thy on many of the metis proofs.<br>\nThis requires some patience, but it is fun to see it all work on this tiny<br>\nlittle device.</p>\n<p>Overall the experiment is not just for fun: Apple might ship fancy new ARM<br>\nMacBooks within a few months.</p>\n<p>So we need to think about collecting some money for David Mattews to produce a<br>\nproper code generator for Poly/ML eventually. People who have some ideas<br>\nshould contact me or David via private mail.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 212175385,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601736229
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI have now found a beta version of Pi OS 64bit:<br>\n<a href=\"https://downloads.raspberrypi.org/raspios_arm64/images\">https://downloads.raspberrypi.org/raspios_arm64/images</a></p>\n<p>Pi OS appears to support this special hardware better than Ubuntu, e.g.<br>\ngraphics and CPU power regulation (less heating).</p>\n<p>Consequently, I have rebuilt the polyml component in Isabelle/3e84f4e9651a; it<br>\nnow works both with Pi OS (Debian 10) and Ubuntu 20.04.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 212188507,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601756992
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere are some timings for Isabelle/3e84f4e9651a on Pi OS 64bit beta (Debian 10.6):</p>\n<p>Finished Pure (0:07:01 elapsed time, 0:07:01 cpu time, factor 1.00)<br>\nFinished HOL (3:04:18 elapsed time, 8:52:18 cpu time, factor 2.89)<br>\nFinished HOL-Word (0:28:07 elapsed time, 1:33:39 cpu time, factor 3.33)<br>\nFinished HOLCF (0:11:18 elapsed time, 0:26:53 cpu time, factor 2.38)</p>\n<p>It is good to see that our huge HOL image already works on this tiny machine,<br>\nwith interpreted Poly/ML.</p>\n<p>HOL-Analysis and HOL-Library failed, due some to odd timeouts and missing z3<br>\nfor arm64-linux.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 212237221,
        "sender_full_name": "Email Gateway",
        "timestamp": 1601838965
    },
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nHi,</p>\n<p>I was revisiting this thread about the arm64 backend for Poly/ML. <br>\nUnfortunately, I don't have any ideas about the funding but more of a <br>\ntechnical remark. When implementing a new backend, I think one should <br>\nthink about using LLVM due to the following reasons:</p>\n<ul>\n<li>\n<p>It supports amd64 and arm64 (and more).</p>\n</li>\n<li>\n<p>It comes with useful tooling including a debugger and a profiler.</p>\n</li>\n</ul>\n<p>On the other hand, I am not very well versed about the costs and <br>\nbenefits of using LLVM as a backend for a functional language. Haskell <br>\nhas an LLVM backend [1]  that seems to work quite well [2] which <br>\nconfirms that it can work.</p>\n<p>Kind regards,</p>\n<p>Lukas</p>\n<p>[1] <br>\n<a href=\"https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/backends/llvm\">https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/compiler/backends/llvm</a></p>\n<p>[2] <br>\n<a href=\"https://andreaspk.github.io/posts/2019-08-25-Opinion%20piece%20on%20GHC%20backends.html\">https://andreaspk.github.io/posts/2019-08-25-Opinion%20piece%20on%20GHC%20backends.html</a></p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 215590791,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604501542
    },
    {
        "content": "<p>From: Florian Märkl &lt;<a href=\"mailto:isabelle-dev@florianmaerkl.de\">isabelle-dev@florianmaerkl.de</a>&gt;<br>\nHello,</p>\n<p>I am planning to write my Master's thesis at TUM in the coming summer<br>\nsemester and I wonder whether implementing this backend for Poly/ML<br>\nwould be a fitting topic for this.</p>\n<p>I have recently bought myself a PineBook Pro, which is a small aarch64<br>\nlaptop, maybe slightly faster than a Raspberry Pi 4, and I have actually<br>\nbeen using this as my main laptop for a few months now.<br>\nI use it mostly for programming C and Haskell, but could also play<br>\naround with Isabelle a bit and can confirm that the only blocker there<br>\nseems to be that it is just unbearably slow, so I do have some<br>\nmotivation to fix this.</p>\n<p>About GHC's llvm backend, I can also confirm that it indeed works very<br>\nwell, with the main issue being the fact that llvm is generally quite<br>\nbig and resource-hungry.<br>\nIn fact, while compiling GHC itself and many other Haskell libraries<br>\n(which I had to do all by myself because Arch Linux ARM, which I use,<br>\ndoes not provide any Haskell packages), I ran out of memory multiple<br>\ntimes, had to reduce concurrency and eventually set up a Raspberry Pi 4<br>\nwith 8GB of RAM and a lot of swap space as an external build server for<br>\nthis. For reference, a build of GHC takes about one full night.<br>\nThis blog post also mentions that it would still be desirable to have a<br>\nnative arm backend in GHC:<br>\n<a href=\"https://www.haskell.org/ghc/blog/20200515-ghc-on-arm.html\">https://www.haskell.org/ghc/blog/20200515-ghc-on-arm.html</a></p>\n<p>So I think this is an important aspect, especially considering that<br>\nIsabelle compiles code on the fly while using it. However I don't know<br>\nhow much ML code is actually being compiled during a usual Isabelle<br>\nsession, so I can't say how strongly this will affect the experience in<br>\nthe end.</p>\n<p>On the other hand, there are of course the obvious benefits of llvm,<br>\nincluding that it already has a huge set of well-tested optimization<br>\npasses, and even if these optimizations won't fit as well to ML as they<br>\ndo to classic imperative languages, in the worst case, it would be<br>\ndegraded to a simple code generator for arbitrary architectures and some<br>\nlanguage-specific optimization could be done before translating to LLVM IR.</p>\n<p>It would be nice if someone from Prof. Nipkow's or related chairs could<br>\ngive me some feedback whether this could theoretically fit for a<br>\nMaster's thesis.</p>\n<p>Florian</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 215614791,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604510997
    },
    {
        "content": "<p>From: David Matthews &lt;<a href=\"mailto:dm@prolingua.co.uk\">dm@prolingua.co.uk</a>&gt;<br>\nLlvm has come up as a suggestion a number of times.  I did look at it <br>\nsome years ago as a possible back-end for Poly/ML and came to the <br>\nconclusion that it wouldn't work in the way that was needed.  I read the <br>\nblog post about GHC and thought it was interesting that they still felt <br>\nthe need to have their own back-end as well.</p>\n<p>The problem I could see was that Llvm seems to have its own ideas about <br>\ndata representation and that wouldn't fit with the way Poly/ML works <br>\nespecially in Isabelle.  I could see a possible use for it as a back-end <br>\nwhen Poly/ML was batch-compiling some ML code to be executed as a <br>\nseparate program.</p>\n<p>However, interactive theorem proving in Isabelle is more like <br>\nmanipulating data structures some of whose elements happen to be blobs <br>\nof executable code.  This fits with the view of a functional language in <br>\nwhich functions are just another kind of value.  The Poly/ML compiler, <br>\njust another function in the environment, builds code in the heap and if <br>\nthe heap is saved to disc only then will the code be written out.  That <br>\nis quite different from the conventional view of a compiler.</p>\n<p>I'm quite happy to provide any information needed if someone wants to <br>\nlook at an Llvm back-end but I don't see it working with Isabelle.</p>\n<p>David</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 215700924,
        "sender_full_name": "Email Gateway",
        "timestamp": 1604576903
    }
]