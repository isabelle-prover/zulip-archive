[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n<strong>* ML </strong>*</p>\n<ul>\n<li>ML antiquotations for type constructors and term constants:<p>\\&lt;^Type&gt;‹c›<br>\n  \\&lt;^Type&gt;‹c T …›       ― ‹same with type arguments›<br>\n  \\&lt;^Type&gt;_fn‹c T …›    ― ‹fn abstraction, failure via exception TYPE›<br>\n  \\&lt;^Const&gt;‹c›<br>\n  \\&lt;^Const&gt;‹c T …›      ― ‹same with type arguments›<br>\n  \\&lt;^Const&gt;‹c for t …›  ― ‹same with term arguments›<br>\n  \\&lt;^Const_&gt;‹c …›       ― ‹same for patterns: case, let, fn›<br>\n  \\&lt;^Const&gt;_fn‹c T …›   ― ‹fn abstraction, failure via exception TERM›</p>\n</li>\n</ul>\n<p>Examples in HOL:</p>\n<p>val natT = \\&lt;^Type&gt;‹nat›;<br>\n  fun mk_funT (A, B) = \\&lt;^Type&gt;‹fun A B›;<br>\n  val dest_funT = fn \\&lt;^Type&gt;‹fun A B› =&gt; (A, B);<br>\n  fun mk_conj (A, B) = \\&lt;^Const&gt;‹conj for A B›;<br>\n  val dest_conj = fn \\&lt;^Const_&gt;‹conj for A B› =&gt; (A, B);<br>\n  fun mk_eq T (t, u) = \\&lt;^Const&gt;‹HOL.eq T for t u›;<br>\n  val dest_eq = fn \\&lt;^Const_&gt;‹HOL.eq T for t u› =&gt; (T, (t, u));</p>\n<p>This refers to Isabelle/4974c3697fee.</p>\n<p>The question of how to represent outlines for type and term expressions<br>\nadequately and robustly in Isabelle/ML has remained open for a long time.<br>\nAfter 2007/2008, I always thought that we should use more concrete syntax<br>\n(namely inner syntax).</p>\n<p>After rethinking it thoroughly, the outcome is now as above. The key idea is<br>\nto nest ML source inside antiquotations: this has become possible in recent<br>\nantiquotations \\&lt;^try&gt;‹expr› and \\&lt;^can&gt;‹expr›.</p>\n<p>The result looks a bit like enhanced S-expressions from the old LISP days:<br>\nthis fits perfectly well into the idea of antiquotations and nesting of<br>\nsublanguages via cartouches --- instead of lots of silly parentheses.</p>\n<p>Another motivation: the Const antiquotations already use \"typargs\", e.g. just<br>\none type T for overloaded \"plus\", instead of \"T =&gt; T =&gt; T\". When all<br>\nIsabelle/ML have been upgraded to use that form, we may have a chance to trim<br>\ndown the redundant type information in datatype term for Const (within a few<br>\nyears).</p>\n<p>This has the potential to speed-up term/type<br>\ninstantiation/matching/unification considerably: profiles always show a lot of<br>\nactivity on types, rather than actual term structure.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 254347902,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632307818
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi,<br>\nnice that term handling from ML gets some attention now.Just as a<br>\nremark, and maybe \"feature request\" of what I would like to see, I'm<br>\nusing the following antiquotations for several years now. They are in<br>\nthe AFP. <br>\n<a href=\"https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html\">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html</a><br>\n<a href=\"https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html\">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html</a></p>\n<p>There is an antiquotation @{mpat} that generates a ML matching pattern<br>\nfrom a term, and one @{mk_term} that constructs a term. mk_term also<br>\ntries hard to infer types from the arguments (examples below). <br>\nThese are definitely not include-in-distribution quality yet, as they<br>\nuse a hack of identifying term-variables (?x) with ML variables.<br>\nHowever, I use them a lot, and would like to ultimately see robust and<br>\nclean means to efficiently match against and constructs complex terms<br>\nfrom ML level in a readable way.<br>\n--  Peter<br>\nExamples to generate matching patterns from terms:<br>\n  fun dest_pair_singleton @{mpat \"{(?a,_)}\"} = (a)<br>\n    | dest_pair_singleton t = raise TERM (\"dest_pair_singleton\",[t])</p>\n<p>fun dest_nat_pair_singleton @{mpat (typs) \"{(?a::nat,?b::nat)}\"} =<br>\n(a,b)<br>\n    | dest_nat_pair_singleton t = raise TERM<br>\n(\"dest_nat_pair_singleton\",[t])</p>\n<p>fun dest_pair_singleton_T @{mpat (typs) \"{(?a::_ ⇒<br>\n?'v_Ta,?b::?'v_Tb)}\"} = <br>\n    ((a,Ta),(b,Tb))<br>\n    | dest_pair_singleton_T t = raise TERM<br>\n(\"dest_pair_singleton_T\",[t])</p>\n<p>fun dest_pair_lambda @{mpat \"{(λa _ _. ?Ta, λb. ?Tb)}\"} =<br>\n(a,a_T,b,b_T,Ta,Tb)<br>\n    | dest_pair_lambda t = raise TERM (\"dest_pair_lambda\",[t])</p>\n<p>fun foo @{mpat \"[?a,?b AS⇩s mpaq_Bound ?i,?c AS⇩p [?n]]\"} = <br>\n    (a,b,i,c,n)<br>\n  | foo t = raise TERM (\"foo\",[t])</p>\n<p>Examples to generate term templates:  fun mk_2elem_list a b = @{mk_term<br>\n\"[?a,?b]\"}<br>\n  fun mk_compr s P = @{mk_term \"{ x∈?s. ?P x}\"}</p>\n<p>val test1 = mk_2elem_list @{term \"1::nat\"} @{term \"2::nat\"} |&gt;<br>\nThm.cterm_of @{context}<br>\n  val test2 = mk_compr @{term \"{1,2,3::nat}\"} @{term \"(&lt;) (2::nat)\"} |&gt;<br>\nThm.cterm_of @{context}</p>\n<p>val test3 = let <br>\n    val x = Bound 0 <br>\n    val env = [@{typ nat}]<br>\n  in <br>\n    @{mk_term env: \"?x+?x\"}<br>\n  end</p>",
        "id": 254350344,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632309379
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 22/09/2021 13:16, Peter Lammich wrote:</p>\n<blockquote>\n<p>Just as a remark, and maybe \"feature request\" of what I would like to see, I'm<br>\nusing the following antiquotations for several years now. They are in the AFP. <br>\n<a href=\"https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html\">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mpat_Antiquot.html</a><br>\n<a href=\"https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html\">https://www.isa-afp.org/browser_info/current/AFP/Automatic_Refinement/Mk_Term_Antiquot.html</a></p>\n<p>There is an antiquotation @{mpat} that generates a ML matching pattern from a<br>\nterm, and one @{mk_term} that constructs a term. <br>\nmk_term also tries hard to infer types from the arguments (examples below). </p>\n<p>These are definitely not include-in-distribution quality yet, as they use a<br>\nhack of identifying term-variables (?x) with ML variables. However, I use them<br>\na lot, and would like to <br>\nultimately see robust and clean means to efficiently match against and<br>\nconstructs complex terms from ML level in a readable way.</p>\n</blockquote>\n<p>This looks like enormous complexity, with remaining open questions and<br>\nproblems. It is like an attempt to implement my postulates from many years<br>\nago, to connect inner syntax somehow to ML.</p>\n<p>My current move deviates from that, returning to a more basic and more robust<br>\nscheme. Recall these explanations:</p>\n<blockquote>\n<p>On Wed, 2021-09-22 at 12:50 +0200, Makarius wrote:</p>\n<blockquote>\n<p>The question of how to represent outlines for type and term expressions<br>\nadequately and robustly in Isabelle/ML has remained open for a long time.<br>\nAfter 2007/2008, I always thought that we should use more concrete syntax<br>\n(namely inner syntax).</p>\n<p>After rethinking it thoroughly, the outcome is now as above. The key idea is<br>\nto nest ML source inside antiquotations: this has become possible in recent<br>\nantiquotations \\&lt;^try&gt;‹expr› and \\&lt;^can&gt;‹expr›.</p>\n<p>The result looks a bit like enhanced S-expressions from the old LISP days:<br>\nthis fits perfectly well into the idea of antiquotations and nesting of<br>\nsublanguages via cartouches --- instead of lots of silly parentheses.</p>\n</blockquote>\n</blockquote>\n<p>So my counter feature request: Can you upgrade your applications to the new ML<br>\nantiquotations, and remove your attempt?</p>\n<p>Looking briefly at actual uses of @{mpat} in AFP, most of them look very basic.</p>\n<p>Here is an example at the upper end in complexity, translated into the new<br>\nType/Const/Const_ scheme:</p>\n<p>ML ‹<br>\n(*<br>\n  fun constraints_of_goal i st =<br>\n    case Logic.concl_of_goal (Thm.prop_of st) i of<br>\n      @{mpat \"Trueprop ((_,?a)∈_)\"} =&gt; constraints_of_term a<br>\n    | _ =&gt; raise THM (\"constraints_of_goal\",i,[st])<br>\n*)</p>\n<p>val constraints_of_term: term -&gt; (term * term) list = undefined;</p>\n<p>fun constraints_of_goal i st =<br>\n    case Logic.concl_of_goal (Thm.prop_of st) i of<br>\n      \\&lt;^Const_&gt;‹Trueprop for ‹\\&lt;^Const_&gt;‹Set.member _ for ‹\\&lt;^Const_&gt;‹Pair _\n_ for _ a›› _››› =&gt;<br>\n        constraints_of_term a<br>\n    | _ =&gt; raise THM (\"constraints_of_goal\",i,[st])<br>\n›</p>\n<p>Most other uses will be even easier to rephrase.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 254354783,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632311972
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Here is an example at the upper end in complexity, translated into<br>\nthe new<br>\nType/Const/Const_ scheme:</p>\n<p>ML ‹<br>\n(*<br>\n  fun constraints_of_goal i st =<br>\n    case Logic.concl_of_goal (Thm.prop_of st) i of<br>\n      @{mpat \"Trueprop ((_,?a)∈_)\"} =&gt; constraints_of_term a<br>\n    | _ =&gt; raise THM (\"constraints_of_goal\",i,[st])<br>\n*)</p>\n<p>val constraints_of_term: term -&gt; (term * term) list = undefined;</p>\n<p>fun constraints_of_goal i st =<br>\n    case Logic.concl_of_goal (Thm.prop_of st) i of<br>\n      \\&lt;^Const_&gt;‹Trueprop for ‹\\&lt;^Const_&gt;‹Set.member _ for<br>\n‹\\&lt;^Const_&gt;‹Pair _\n_ for _ a›› _››› =&gt;<br>\n        constraints_of_term a<br>\n    | _ =&gt; raise THM (\"constraints_of_goal\",i,[st])<br>\n›<br>\n</p>\n</blockquote>\n<p>Unfortunately, the translation sacrifices quite some readability. In my<br>\nlatest developments (not yet in AFP), I'd use @{mprop \"(_,?a)∈_\"} for<br>\nthe above pattern, which is even more concise.</p>\n<p>Btw, the upper end of complexity for term creation @{mk_term} is<br>\nsomething like:</p>\n<p>@{mk_term \"Refine_Basic.bind$(RETURN$(COPY$?p))$?t'\"}</p>\n<p>which looks like a lot of effort to write down in plain ML, or with<br>\nbasic Const antiquotations. In particular, note that all types in the<br>\nterm need to be inferred from the types of ?p and ?t'.</p>",
        "id": 254356646,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632312917
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is the direct correspondence to the new antiquotations:</p>\n<p>theory Scratch<br>\n  imports Refine_Imperative_HOL.Sepref_Rules Refine_Imperative_HOL.Sepref_Monadify<br>\nbegin</p>\n<p>ML ‹<br>\n  fn p =&gt; fn t' =&gt;<br>\n    @{mk_term \"Refine_Basic.bind$(RETURN$(COPY$?p))$?t'\"}›</p>\n<p>ML ‹<br>\n  fn A =&gt; fn B =&gt; fn p =&gt; fn t' =&gt;<br>\n    \\&lt;^Const&gt;‹Refine_Basic.bind A B for<br>\n      ‹\\&lt;^Const&gt;‹RETURN A for ‹\\&lt;^Const&gt;‹COPY A for p›››› t'›<br>\n›</p>\n<p>end</p>\n<p>Of course, this needs to be viewed in Isabelle/jEdit, to make the \\&lt;^Const&gt;<br>\nsymbol look nice.</p>\n<p>Note that the explicit data-flow concerning the type parameters (for Type and<br>\nConst likewise) is intentional: it is the key information without extra<br>\nredundancy; it is provided statically from the program structure, instead of<br>\ndoing Term.fastype_of again at run-time (like your mk_term antiquotation).<br>\nThat operation is actually called \"fastype_of\", because re-checking the type<br>\nof a term is very slow, but here a few extra checks are omitted compared to<br>\nfull Term.type_of (this works under the assumption that the term is well-typed).</p>\n<p>If we do manage to brush-up our thinking and working with types and terms, we<br>\ncould get a somewhat smoother system within a few years. See also the thread<br>\non locale performance opened by Norber Schirmer<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2021-September/msg00034.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2021-September/msg00034.html</a></p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 254389892,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632325814
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nExcellent!</p>\n<p>The abstraction form syntax is not so trivial to grasp, maybe one<br>\nexample coulde be added to the NEWS, e. g.</p>\n<p>val dest_add_nat = \\&lt;^Const_fn&gt;‹Groups.plus \\&lt;^Type&gt;‹nat› for a b =&gt;<br>\n‹(a, b)››</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/MQdBamWAqWBJFGctkLzhm2o4/OpenPGP_signature\">OpenPGP_signature</a></p>",
        "id": 255370011,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632908629
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIn Isabelle/b9331caf92c3, I have updated the above examples using<br>\nType_fn/Const_fn (they were from an earlier stage, before these extra<br>\nantiquotations).</p>\n<p>Also note that in Isabelle/e585e5a906ba, I have tune the syntax to allow the<br>\n\\&lt;^Type&gt;‹nat› in your example stand on its own, without an extra cartouche<br>\naround it.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 255371820,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632909501
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nUpdate for Isabelle/e585e5a906ba:</p>\n<p>theory Scratch<br>\n  imports Refine_Imperative_HOL.Sepref_Rules Refine_Imperative_HOL.Sepref_Monadify<br>\nbegin</p>\n<p>ML ‹<br>\n  fn p =&gt; fn t' =&gt;<br>\n    @{mk_term \"Refine_Basic.bind$(RETURN$(COPY$?p))$?t'\"}›</p>\n<p>ML ‹<br>\n  fn A =&gt; fn B =&gt; fn p =&gt; fn t' =&gt;<br>\n    \\&lt;^Const&gt;‹Refine_Basic.bind A B for<br>\n      \\&lt;^Const&gt;‹RETURN A for \\&lt;^Const&gt;‹COPY A for p›› t'›<br>\n›</p>\n<p>end</p>\n<p>Thus it is a bit more concise and to the point: no extra nesting of cartouches.</p>\n<p>Are there any remaining uses of your alternative antiquotations that are not<br>\ncovered properly by the new official scheme?</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 255374410,
        "sender_full_name": "Email Gateway",
        "timestamp": 1632910807
    },
    {
        "content": "<p>From: Norbert Schirmer &lt;<a href=\"mailto:nschirmer@apple.com\">nschirmer@apple.com</a>&gt;<br>\nIn AutoCorres there are also alternative antiquotations for matching and building terms, similar to the ones presented by Peter:<br>\n<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy</a> &lt;<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy</a>&gt;<br>\n<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy</a> &lt;<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy</a>&gt;<br>\n<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy</a> &lt;<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy</a>&gt;<br>\n<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy</a> &lt;<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy</a>&gt;</p>\n<p>Also I see great potential for providing similar antiquotations also for cterms, offering the possibility to ‘match’ sub-cterms and build cterms from certified sub-cterms. In contrast to terms also the matching part will result in a matching function, as cterms are an abstract data type.</p>\n<p>In my experience recertifying cterms in proof tools like simprocs or tactics can easily become a performance hot-spot when terms become large.</p>\n<p>As taking apart and recombining cterms manually with functions like Thm.dest_comb / Thm.apply is quite verbose and hard to maintain it rarely is used in practise. Instead terms are decomposed by ML-matching, recombined and recertified. In the presence of your new antiquotations this idiom is likely to become even more attractive and commonplace. </p>\n<p>Having antiquotations for cterms can be a powerful show-case for the potential of antiquotations, bringing together readability / conciseness as well as scalability.</p>\n<p>Regards,<br>\nNorbert</p>",
        "id": 255854524,
        "sender_full_name": "Email Gateway",
        "timestamp": 1633164685
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 02/10/2021 10:51, Norbert Schirmer wrote:</p>\n<blockquote>\n<p>In AutoCorres there are also alternative antiquotations for matching and<br>\nbuilding terms, similar to the ones presented by Peter:<br>\n<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote.thy</a><br>\n<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/MkTermAntiquote_Tests.thy</a><br>\n<a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote.thy</a> &gt; <a href=\"https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy\">https://github.com/seL4/l4v/blob/master/lib/ml-helpers/TermPatternAntiquote_Tests.thy</a></p>\n</blockquote>\n<p>I have looked through this a bit, with the same questions in mind: What are<br>\nthe remaining uses of these @{mk_term} and @{term_pat} antiquotations? Would<br>\nthese antiquotations be introduced today, as replacement or improvement over<br>\nthe new \\&lt;^Type&gt; and \\&lt;^Const&gt; forms?</p>\n<p>My impressions so far:</p>\n<p>* @{term_pat} is potentially more relevant, but hardly used in that code<br>\nbase at all. Most applications are actually tests, to demonstrate what it is<br>\nsupposed to be. It could be very easily eliminated and simplified, using the<br>\nnew antiquotations from Isabelle2021-1.</p>\n<p>* @{mk_term} has more actual applications, but about 30% very basic that<br>\ncould be done with the same amount of text with \\&lt;^Type&gt; and \\&lt;^Const&gt;; 30%<br>\ninvolve relatively complex terms like this:</p>\n<p>@{mk_term \"ran (RangeMap.lookup_range_tree ?tree)\" (tree)} tree_const<br>\n  |&gt; Thm.cterm_of ctxt</p>\n<p>It might be actually better to produce a closed @{cterm} with lambdas inside,<br>\nand use cterm application in ML --- it would avoid rechecking the whole cterm.</p>\n<p>Moreover, the antiquotation itself contains hidden Term.fastype_of: another<br>\nrelatively costly operation (for complex terms).</p>\n<p>The whole point of the new \\&lt;^Const&gt; antiquotation is to cultivate a view of<br>\nConsts.typargs almost everywhere, with very little recomputation of types for<br>\nsubterms (no more Term.fastype_of).</p>\n<p>This technique also has the potential to simplify the ML source complexity, at<br>\nleast in the most common cases. Sometimes there are tough situations seen in<br>\nthe wild, where ML operates in rather non-standard ways on terms, like working<br>\nmorally ill-typed constants.</p>\n<blockquote>\n<p>Also I see great potential for providing similar antiquotations also for<br>\ncterms, offering the possibility to ‘match’ sub-cterms and build cterms from<br>\ncertified sub-cterms. In contrast to terms also the matching part will result<br>\nin a matching function, as cterms are an abstract data type.</p>\n<p>In my experience recertifying cterms in proof tools like simprocs or tactics<br>\ncan easily become a performance hot-spot when terms become large.</p>\n</blockquote>\n<p>That is a separate concern, independent of the question of concrete term<br>\nsyntax vs. abstract ML syntax.</p>\n<p>We do waste a lot in frequent ctyp_of/cterm_of operations, but doing it<br>\ndifferently is quite a lot of work.</p>\n<p>Also note that the cterm destructors are not for free either. In particular,<br>\nThm.dest_abs needs to replace a de-Bruijn Bound by a fresh Free. Over the<br>\nyears I have fine-tuned this a lot, with measurable impact; the latest update<br>\nis here:<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/annotate/21a20b990724/src/Pure/term.ML#l966\">https://isabelle.sketis.net/repos/isabelle/annotate/21a20b990724/src/Pure/term.ML#l966</a></p>\n<p>(Staring at this again, I immediately see further potential for improvement,<br>\nlike an explicit Name.context as argument, taken from the implicit<br>\nProof.context of the application.)</p>\n<blockquote>\n<p>As taking apart and recombining cterms manually with functions like<br>\nThm.dest_comb / Thm.apply is quite verbose and hard to maintain it rarely is<br>\nused in practise. Instead terms are decomposed by ML-matching, recombined and<br>\nrecertified. In the presence of your new antiquotations this idiom is likely<br>\nto become even more attractive and commonplace. </p>\n</blockquote>\n<p>The state-of-the art is to decompose the Thm.term_of view of cterms and<br>\nre-certify. The cost for that is well-known, but could be trimmed down a bit<br>\nby treating the types within terms more carefully (or by reducing them via<br>\nConsts.typargs as hinted above).</p>\n<blockquote>\n<p>Having antiquotations for cterms can be a powerful show-case for the potential<br>\nof antiquotations, bringing together readability / conciseness as well as<br>\nscalability.</p>\n</blockquote>\n<p>This sounds like marketing-speak.</p>\n<p>Note that too much complexity in ML antiquotations can degrade the robustness<br>\nand maintainability of ML tools. For example, too much concrete syntax will<br>\nlead to surprises after inevitable changes of abbreviations, translations etc.<br>\nover the years / decades.</p>\n<p>With \\&lt;^Type&gt; / \\&lt;^Const&gt; everything is clear and well-defined.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 257437799,
        "sender_full_name": "Email Gateway",
        "timestamp": 1634159144
    },
    {
        "content": "<p>From: Norbert Schirmer &lt;<a href=\"mailto:nschirmer@apple.com\">nschirmer@apple.com</a>&gt;</p>\n<blockquote>\n<p>On 13. Oct 2021, at 23:05, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>My impressions so far:</p>\n<ul>\n<li>\n<p>@{term_pat} is potentially more relevant, but hardly used in that code<br>\nbase at all. Most applications are actually tests, to demonstrate what it is<br>\nsupposed to be. It could be very easily eliminated and simplified, using the<br>\nnew antiquotations from Isabelle2021-1.</p>\n</li>\n<li>\n<p>@{mk_term} has more actual applications, but about 30% very basic that<br>\ncould be done with the same amount of text with \\&lt;^Type&gt; and \\&lt;^Const&gt;; 30%<br>\ninvolve relatively complex terms like this:</p>\n</li>\n</ul>\n<p>@{mk_term \"ran (RangeMap.lookup_range_tree ?tree)\" (tree)} tree_const<br>\n |&gt; Thm.cterm_of ctxt</p>\n<p>It might be actually better to produce a closed @{cterm} with lambdas inside,<br>\nand use cterm application in ML --- it would avoid rechecking the whole cterm.</p>\n<p>Moreover, the antiquotation itself contains hidden Term.fastype_of: another<br>\nrelatively costly operation (for complex terms).<br>\n</p>\n</blockquote>\n<p>Meanwhile there are many more applications of the two antiquotations.<br>\nWe plan to release these extensions of the AutoCorres code-base following Isabelle2021-1.</p>\n<blockquote>\n<p>The whole point of the new \\&lt;^Const&gt; antiquotation is to cultivate a view of<br>\nConsts.typargs almost everywhere, with very little recomputation of types for<br>\nsubterms (no more Term.fastype_of).</p>\n<p>You are right with the cost of Term.fastype_of. But many use-cases of<br>\n@{mk_term} are situations where the term size is under control of the actual code. <br>\nThere is no additional user-space input coming in. E.g. think of something like the<br>\n@{command record} where you have to generate lots of lemmas about <br>\nfield lookup / update etc. There something like @{mk_term} leads to very readable and compact code<br>\nto generate the terms for the propositions.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Having antiquotations for cterms can be a powerful show-case for the potential<br>\nof antiquotations, bringing together readability / conciseness as well as<br>\nscalability.</p>\n</blockquote>\n<p>This sounds like marketing-speak.</p>\n</blockquote>\n<p>What I like about the application here is that the antiquation in a sense stretches the type-system of ML. <br>\nWhat results in a sequence of combinator applications becomes an atomic entity.</p>\n<blockquote>\n<p>Note that too much complexity in ML antiquotations can degrade the robustness<br>\nand maintainability of ML tools. For example, too much concrete syntax will<br>\nlead to surprises after inevitable changes of abbreviations, translations etc.<br>\nover the years / decades.</p>\n<p>With \\&lt;^Type&gt; / \\&lt;^Const&gt; everything is clear and well-defined.</p>\n<p>That is certainly true. The more syntax is involved the more can go wrong. But in my experience with these antiquotation so far this<br>\nfalls in the category of “benign” issues. Meaning that you will hit the problem quite early. In the best case<br>\nalready at compile time. Or if that does not work the problem manifests upon every and thus already the first actual usage of the antiquotation.<br>\nIn those situations the benefits of a readable and concise term overweight.</p>\n</blockquote>\n<p>Norbert</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 257489379,
        "sender_full_name": "Email Gateway",
        "timestamp": 1634195249
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi all.</p>\n<blockquote>\n<blockquote>\n<p>The whole point of the new \\&lt;^Const&gt; antiquotation is to cultivate<br>\na view of<br>\nConsts.typargs almost everywhere, with very little recomputation of<br>\ntypes for<br>\nsubterms (no more Term.fastype_of).</p>\n<p>You are right with the cost of Term.fastype_of. But many use-cases of<br>\n@{mk_term} are situations where the term size is under control of the<br>\nactual code. <br>\nThere is no additional user-space input coming in. E.g. think of<br>\nsomething like the<br>\n@{command record} where you have to generate lots of lemmas about <br>\nfield lookup / update etc. There something like @{mk_term} leads to<br>\nvery readable and compact code<br>\nto generate the terms for the propositions.</p>\n</blockquote>\n</blockquote>\n<p>I'm also, in many cases, in favour of clear and readable code over<br>\nefficient and less readable. (That's the reason why we use functional<br>\nprogramming for Isabelle, in first place!)</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Having antiquotations for cterms can be a powerful show-case for<br>\nthe potential<br>\nof antiquotations, bringing together readability / conciseness as<br>\nwell as<br>\nscalability.</p>\n</blockquote>\n<p>This sounds like marketing-speak.</p>\n</blockquote>\n<p>What I like about the application here is that the antiquation in a<br>\nsense stretches the type-system of ML. <br>\nWhat results in a sequence of combinator applications becomes an<br>\natomic entity.</p>\n<blockquote>\n<p>Note that too much complexity in ML antiquotations can degrade the<br>\nrobustness<br>\nand maintainability of ML tools. For example, too much concrete<br>\nsyntax will<br>\nlead to surprises after inevitable changes of abbreviations,<br>\ntranslations etc.<br>\nover the years / decades.</p>\n<p>With \\&lt;^Type&gt; / \\&lt;^Const&gt; everything is clear and well-defined.</p>\n<p>That is certainly true. The more syntax is involved the more can go<br>\nwrong. But in my experience with these antiquotation so far this<br>\nfalls in the category of “benign” issues. Meaning that you will hit<br>\nthe problem quite early. In the best case<br>\nalready at compile time. Or if that does not work the problem<br>\nmanifests upon every and thus already the first actual usage of the<br>\nantiquotation.<br>\nIn those situations the benefits of a readable and concise term<br>\noverweight.</p>\n</blockquote>\n</blockquote>\n<p>I agree here. </p>\n<p>Me, personally, am not yet convinced to switch from the very consise<br>\nand high-level mk_term / mpat to the still more verbose and low-level<br>\nType/Const. Obviously, I would like to improve these high-level<br>\nconcepts, but not at the cost of readability or conciseness, which is<br>\nexactly what makes them so appealing.</p>\n<p>Peter</p>\n<blockquote>\n<p>Norbert</p>\n</blockquote>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 257493639,
        "sender_full_name": "Email Gateway",
        "timestamp": 1634197761
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe new \\&lt;^Type&gt; / \\&lt;^Const&gt; antiquotations are designed to be both<br>\nefficient in the runtime, and efficient in the source text (readable,<br>\nmaintainable).</p>\n<p>As usual, it is just a matter to get used to a new way of thinking,<br>\nwhich is actually closer to the old way of direct use of datatype<br>\nconstructors.</p>\n<p>Moreover, the treatment of type arguments is much more concise: the term<br>\n(patterns) are rather awkward in that respect: both in the text and at<br>\nruntime (fastype_of).</p>\n<p>This thread was mainly meant to figure out shortcomings that can be<br>\nimproved further: this often becomes apparent in concrete use, e.g.<br>\nwhile converting an application to the new format.</p>\n<p>(Doing that here and there, I did already see another are of reform,<br>\nnamely \"instantiate\" forms for thm, cterm, maybe even term.)</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 257495580,
        "sender_full_name": "Email Gateway",
        "timestamp": 1634198794
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nOn Thu, 2021-10-14 at 10:06 +0200, Makarius wrote:</p>\n<blockquote>\n<p>On 14.10.21 09:49, Peter Lammich wrote:</p>\n<blockquote>\n<p>I'm also, in many cases, in favour of clear and readable code over<br>\nefficient and less readable. (That's the reason why we use<br>\nfunctional<br>\nprogramming for Isabelle, in first place!)</p>\n</blockquote>\n<p>The new \\&lt;^Type&gt; / \\&lt;^Const&gt; antiquotations are designed to be both<br>\nefficient in the runtime, and efficient in the source text (readable,<br>\nmaintainable).</p>\n</blockquote>\n<p>but they are clearly less concise than mk_term/pat, at least for some<br>\napplications.</p>\n<p>The usage of mk_term/pat, and the fact that it has been invented at<br>\nleast twice independently, indicates that there is some sweet spot<br>\nhere, which, at least for some use cases, allows a very concise<br>\nnotation.</p>\n<p>This still has some problems in other cases (e.g., treatment of types).<br>\nHowever, this should not be a reason for abandoning this promising<br>\nfind, but to try to understand it further: in what cases is use of<br>\nmk_term/pat adequate, and in what cases do we have to fall back to the<br>\nmore low-level but robust/general Type/Const. Can we even have both:<br>\nthe benefit of concise treatment of type arguments AND the benefit of<br>\nconcise, high-level notation?</p>",
        "id": 257497434,
        "sender_full_name": "Email Gateway",
        "timestamp": 1634199768
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAll these attempts are rather fragile and incomplete. Over a long time, I used<br>\nto tell the story myself, that we should use inner syntax for term patterns<br>\nand it never quite worked out.</p>\n<p>There are various dimensions in the problem that should not be collapsed:</p>\n<p>* Patterns should be considered separately from expressions (but: the new<br>\n\\&lt;^Type&gt;/\\&lt;^Const&gt; antiquotations are so elementary and close to ML that they<br>\ncan do both).</p>\n<p>* Expressions can be easily used with concrete syntax, e.g. a version of<br>\n@{term} / @{cterm} / @{thm} combined with instantiation (Thm.instantiate): I<br>\nhave started to think about that some weeks ago, and might manage to do<br>\nsomething for the release. This will supersede earlier attempts like @{mk_term}.</p>\n<p>* Genuine cterms are probably better treated like the core logic does, e.g.<br>\nwith Thm.match / Thm.first_order_match. Instead of raw decomposition of cterms<br>\n(with awkward invention of frees for bounds), regular matching can treat<br>\nbinders directly.</p>\n<p>Makarius</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev\">https://mailman46.in.tum.de/mailman/listinfo/isabelle-dev</a></p>",
        "id": 257532419,
        "sender_full_name": "Email Gateway",
        "timestamp": 1634217338
    }
]