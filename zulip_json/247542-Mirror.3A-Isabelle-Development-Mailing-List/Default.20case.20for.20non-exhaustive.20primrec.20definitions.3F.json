[
    {
        "content": "<p>From: Elliot Bobrow &lt;<a href=\"mailto:ebobrow@g.hmc.edu\">ebobrow@g.hmc.edu</a>&gt;<br>\nHello Isabelle developers,</p>\n<p>I've noticed that Isabelle's logic for <code>case</code> statements and <code>fun</code><br>\ndefinitions automatically defaults to returning <code>undefined</code> for unspecified<br>\ninputs:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a option </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"f x = (case x of Some _</span>\n<span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> 1)\"</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"f None = undefined\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a option </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"f' (Some _) = 1\"</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"f' None = undefined\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">meson</span><span class=\"w\"> </span><span class=\"n\">f'.elims</span><span class=\"w\"> </span><span class=\"n\">option.distinct</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>However, the same does not hold for <code>primrec</code> definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">primrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nonexhaustive</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f''</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a option </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"f''</span>\n<span class=\"s\">(Some _) = 0\"</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"f'' None = undefined\"</span><span class=\"w\"> </span><span class=\"gr\">oops</span>\n</code></pre></div>\n<p>Is there a reason for this? It seems it would be good to be consistent<br>\nhere, and the functions would still be primitive recursive. Having<br>\n<code>undefined</code> as a default case seems like a good idea for the sake of<br>\nclarity and explicitness.</p>\n<p>This has come up in a research project (collaborators CC'd) which involves<br>\nproving a number of functions primitive recursive according to a<br>\nuser-defined predicate. We are doing this by constructing equivalent<br>\nfunctions out of known primitive recursive functions and proving them<br>\nequivalent on all inputs. However, it is impossible to do this for e.g.<br>\n<code>nth</code> because an equivalent function must always return <code>[] ! n</code> for<br>\nout-of-bounds inputs. This is a function of n and we do not know it to be<br>\nprimitive recursive, so we're stuck. If instead we had that <code>[] ! n</code><br>\nevaluates to undefined, the problem becomes trivial by returning the<br>\nconstant <code>undefined</code> on out-of-bounds inputs, which we know to be primitive<br>\nrecursive because it is a constant. This might not be the only instance<br>\nwhere the current behavior makes it more difficult/impossible to reason<br>\nabout equality.</p>\n<p>Elliot</p>",
        "id": 529699789,
        "sender_full_name": "Email Gateway",
        "timestamp": 1753029953
    },
    {
        "content": "<p>From: Dmitriy Traytel via isabelle-dev &lt;<a href=\"mailto:isabelle-dev@mailman.proof.cit.tum.de\">isabelle-dev@mailman.proof.cit.tum.de</a>&gt;<br>\nHi Elliot,</p>\n<p>For your simplified example the property actually holds:</p>\n<p>primrec (nonexhaustive) f'' :: \"'a option \\&lt;Rightarrow&gt; nat\" where \"f'' (Some _) = 0\"<br>\nlemma \"f'' None = undefined\"<br>\n  unfolding f''_def by simp</p>\n<p>This is not exported to the user on purpose, but still available.</p>\n<p>With nth it is more subtle because of the extra argument. Primrec choses to let the unspecified value depend on the additional parameter (therefore \"[] ! 42 = [] ! 43” will not be provable as “[] ! 42 = undefined 42” and “[] ! 43 = undefined 43” unless the element type is a singleton).</p>\n<p>lemma \"nth [] n = undefined n\"<br>\n  unfolding nth_def by simp</p>\n<p>The “fun” command indeed makes a different choice (which would make \"[] ! 42 = [] ! 43” and \"[] ! 42 = undefined\" true, if nth was defined using fun).</p>\n<p>I think it depends on the application which choice is good or bad (the latter gives you “accidental\" equalities such as \"[] ! 42 = [] ! 43” or “hd [] = [] ! 43” which may raise some questions about your model but might eliminate some side conditions from lemmas). If you don’t like a particular choice you can always wrap the function in question to correct it.</p>\n<p>Best wishes,<br>\nDmitriy</p>\n<p>On 20 Jul 2025, at 18.45, Elliot Bobrow &lt;<a href=\"mailto:ebobrow@g.hmc.edu\">ebobrow@g.hmc.edu</a>&gt; wrote:</p>\n<p>Hello Isabelle developers,</p>\n<p>I've noticed that Isabelle's logic for <code>case</code> statements and <code>fun</code> definitions automatically defaults to returning <code>undefined</code> for unspecified inputs:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a option </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"f x = (case x of Some _ </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> 1)\"</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"f None = undefined\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"n\">simp</span>\n\n<span class=\"k\">fun</span><span class=\"w\"> </span><span class=\"n\">f'</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a option </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"f' (Some _) = 1\"</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"f' None = undefined\"</span><span class=\"w\"> </span><span class=\"k\">by</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">meson</span><span class=\"w\"> </span><span class=\"n\">f'.elims</span><span class=\"w\"> </span><span class=\"n\">option.distinct</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>However, the same does not hold for <code>primrec</code> definitions:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">primrec</span><span class=\"w\"> </span><span class=\"o\">(</span><span class=\"n\">nonexhaustive</span><span class=\"o\">)</span><span class=\"w\"> </span><span class=\"n\">f''</span><span class=\"w\"> </span><span class=\"o\">::</span><span class=\"w\"> </span><span class=\"s\">\"'a option </span><span class=\"ss\">\\&lt;Rightarrow&gt;</span><span class=\"s\"> nat\"</span><span class=\"w\"> </span><span class=\"kp\">where</span><span class=\"w\"> </span><span class=\"s\">\"f'' (Some _) = 0\"</span>\n<span class=\"kn\">lemma</span><span class=\"w\"> </span><span class=\"s\">\"f'' None = undefined\"</span><span class=\"w\"> </span><span class=\"gr\">oops</span>\n</code></pre></div>\n<p>Is there a reason for this? It seems it would be good to be consistent here, and the functions would still be primitive recursive. Having <code>undefined</code> as a default case seems like a good idea for the sake of clarity and explicitness.</p>\n<p>This has come up in a research project (collaborators CC'd) which involves proving a number of functions primitive recursive according to a user-defined predicate. We are doing this by constructing equivalent functions out of known primitive recursive functions and proving them equivalent on all inputs. However, it is impossible to do this for e.g. <code>nth</code> because an equivalent function must always return <code>[] ! n</code> for out-of-bounds inputs. This is a function of n and we do not know it to be primitive recursive, so we're stuck. If instead we had that <code>[] ! n</code> evaluates to undefined, the problem becomes trivial by returning the constant <code>undefined</code> on out-of-bounds inputs, which we know to be primitive recursive because it is a constant. This might not be the only instance where the current behavior makes it more difficult/impossible to reason about equality.</p>\n<p>Elliot</p>",
        "id": 533817198,
        "sender_full_name": "Email Gateway",
        "timestamp": 1754925824
    }
]