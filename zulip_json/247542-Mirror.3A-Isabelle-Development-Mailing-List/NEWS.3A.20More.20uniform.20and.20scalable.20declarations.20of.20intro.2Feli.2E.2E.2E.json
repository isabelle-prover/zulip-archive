[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n<strong>* General </strong>*</p>\n<ul>\n<li>Declarations of intro/elim/dest rules for Pure and the Classical<br>\nReasoner (e.g. HOL) are handled more uniformly and efficiently: the<br>\norder of rule declarations is maintained accurately, regardless of<br>\nintermediate [rule del] declarations. Furthermore, [dest] is now a<br>\nproper declaration on its own account, instead of the former expansion<br>\n[elim_format, elim]. Consequently, [rule del] no longer deletes the<br>\n[elim_format] of the given rule, only the original rule. Very rare<br>\nINCOMPATIBILITY: tools like \"blast\" and \"auto\" may fail in unusual<br>\nsituations.</li>\n</ul>\n<p>This refers to Isabelle/372273ab6ebb and AFP/eae86974a665.</p>\n<p>That is the notable point, where all Isabelle + AFP applications essentially <br>\nwork unchanged. Intermediately, in my desparation to get it done, I had <br>\nadjusted a few odd proofs. See this already backed-out changeset:</p>\n<p>changeset:   15842:d06954e7388a<br>\nuser:        wenzelm<br>\ndate:        Sun Jul 13 04:21:58 2025 +0200<br>\nfiles:       thys/Buchi_Complementation/Complementation_Implement.thy <br>\nthys/Tree_Enumeration/Rooted_Tree.thy<br>\ndescription:<br>\nadapted proofs to Isabelle/df2d774bcf21: spurious failures due to unclear reasons;</p>\n<p>diff -r ba30fe0ad97c -r d06954e7388a <br>\nthys/Buchi_Complementation/Complementation_Implement.thy<br>\n--- a/thys/Buchi_Complementation/Complementation_Implement.thy  Fri Jul 11 <br>\n15:02:29 2025 +0200<br>\n+++ b/thys/Buchi_Complementation/Complementation_Implement.thy  Sun Jul 13 <br>\n04:21:58 2025 +0200<br>\n@@ -597,7 +597,9 @@<br>\n      fix a f g<br>\n      assume \"g \\&lt;in&gt; expand_map (get_4 A (bounds_3 A a (refresh_1 f)))\"<br>\n      then show \"g \\&lt;in&gt; expand_map (get_3 A (bounds_3 A a (refresh_1 f)))\"</p>\n<ul>\n<li>\n<p>unfolding get_4_def get_3_def items_4_def items_3_def <br>\nexpand_map_alt_def by blast</p>\n</li>\n<li>\n<p>unfolding get_4_def get_3_def items_4_def items_3_def <br>\nexpand_map_alt_def mem_Collect_eq</p>\n</li>\n<li>\n<p>supply not_None_eq [iff del] by blast<br>\n+<br>\n    qed<br>\n    lemma complement_4_language_2: \"language (complement_4 A) \\&lt;subseteq&gt; <br>\nlanguage (complement_3 A)\"<br>\n      using language_mono complement_4_less by (auto dest: monoD)<br>\ndiff -r ba30fe0ad97c -r d06954e7388a thys/Tree_Enumeration/Rooted_Tree.thy<br>\n--- a/thys/Tree_Enumeration/Rooted_Tree.thy Fri Jul 11 15:02:29 2025 +0200<br>\n+++ b/thys/Tree_Enumeration/Rooted_Tree.thy Sun Jul 13 04:21:58 2025 +0200<br>\n@@ -554,7 +554,7 @@<br>\n  abbreviation \"ltree_stree_subtrees ts \\&lt;equiv&gt; SOME xs. fset_of_list xs = <br>\nltree_stree |`| ts \\&lt;and&gt; distinct xs \\&lt;and&gt; sorted_wrt (\\&lt;lambda&gt;t s. <br>\ntree_ltree t \\&lt;le&gt; tree_ltree s) xs\"</p>\n<p>lemma fset_of_list_ltree_stree_subtrees[simp]: \"fset_of_list <br>\n(ltree_stree_subtrees ts) = ltree_stree |`| ts\"</p>\n</li>\n<li>\n<p>using someI_ex[OF distinct_sorted_wrt_list] by fast</p>\n</li>\n<li>\n<p>using someI_ex[OF distinct_sorted_wrt_list] by force</p>\n<p>lemma set_ltree_stree_subtrees[simp]: \"set (ltree_stree_subtrees ts) = <br>\nltree_stree ` fset ts\"<br>\n  using fset_of_list_ltree_stree_subtrees by (metis (mono_tags, lifting) <br>\nfset.set_map fset_of_list.rep_eq)</p>\n</li>\n</ul>\n<p>A bit later, the hidden failure of smt proof reconstruction prompted me to <br>\nrevisit the whole affair once again, comparing netpair content more carefully, <br>\nand reconstructing/eliminating reasons for remaining deviations.</p>\n<p>Some of these oddities had been around for approx. 30 years: Delicate <br>\ndiversions from the intention written as prose comments wrt. the actual <br>\nimplementation in ML. I made the mistake to take the prose text more seriously <br>\nthan the formal ML text. Ultimately, real-world applications found in AFP <br>\ndetermine what is right or wrong, and don't care about good intentions written <br>\nas comments.</p>\n<p>Here are some notable points in history, together with my present <br>\ninterpretation of the archeological findings. This is going back to the depths <br>\nof time, when Isabelle was still an odd research experiment.</p>\n<ul>\n<li>b3f190995bc9 lcp 28-Apr-1995 \"Recoded addSIs, etc., so that nets are built <br>\nincrementally instead of from scratch each time.  The old approach used <br>\nexcessive time (&gt;1 sec for adding a rule to ZF_cs) and probably excessive <br>\nspace.  Now rep_claset includes all record fields.  joinrules no longer sorts <br>\nthe rules on number of subgoals, since it does not see the full set of them; <br>\ninstead the number of subgoals modifies the priority.\"</li>\n</ul>\n<p>That is an early attempt to make things scale better. That version is notable <br>\nto assign integer \"tags\" for sorting rules according to the following <br>\ncalculation of the length of intro vs. elim rules:</p>\n<p>fun insert (nI,nE) = insert_tagged_list o (tag_brls (~(2*nI+nE))) o joinrules;</p>\n<p>Still a bit inefficient (based on list length) and not quite correct, as <br>\nexplained below.</p>\n<ul>\n<li>c06d01f75764 paulson 01-May-1996: \"Provides merge_cs to support default <br>\nclasets\".</li>\n</ul>\n<p>Here the comment says:</p>\n<p>(*Merge works by adding all new rules of the 2nd claset into the 1st claset.<br>\n   Merging the term nets may look more efficient, but the rather delicate<br>\n   treatment of priority might get muddled up.*)</p>\n<p>But the ML source says something different: It effectively orders all <br>\ndeclarations from the RHS of the merge according to their \"rule kind\" (using <br>\ncurrent terminology). That is no problem for disjoint netpairs, but within a <br>\nsingle netpair, newly introduced elim rules now take precedence over intro rules.</p>\n<p>That odd ordering from 1996 made smt reconstruction fail now, because I <br>\nreimplemented the prose specification instead of the actual ML story.</p>\n<p>Further note that we still see quadratic complexity for the merge, because it <br>\nis based on plain lists (which implicitly retains the order of declarations).</p>\n<ul>\n<li>2425068fe13a wenzelm 14-May-2011: \"slightly more efficient claset <br>\noperations, using Item_Net to maintain rules in canonical order\".</li>\n</ul>\n<p>That was my attempt to address the complexity of extending/merging claset rule <br>\ndeclarations, but not a fully successful one. Its use of Item_Net.T instead of <br>\na plain list was fine, because that is a scalable data structure with n*log(n) <br>\ncomplexity instead of n^2. My oversight in 2011 was the remaining linear <br>\noperation Item_Net.length to imitate the allocation of a \"fresh\" declaration <br>\nindex for each rule.</p>\n<ul>\n<li>ca600cbfd4bf wenzelm 10-Jul-2025 \"more accurate \"next\" counter for each <br>\ninsert operation: subtle change of semantics wrt. Item_Net.length, due to <br>\ndelete operation; avoid costly Item_Net.length, which is linear in size;\"</li>\n</ul>\n<p>Approx. 2 weeks ago, I realized the core problem of inefficiency of the <br>\nclaset, only after cleaning up the sources and saying clearly in ML what <br>\nreally happens, instead of trusting odd comments. Apart from inefficiency of <br>\nlength-based allocation of a \"fresh\" index, it was also wrong due to the <br>\npresence of \"rule del\" declarations: thus an old index could have been reused <br>\nlater on --- it is not really fresh. Luckily, the more correct implementation <br>\nin this changeset did not affect any applications in Isabelle + AFP. So <br>\nca600cbfd4bf remained the \"stable status-quo\" in subsequent struggles to <br>\nfinish this renovation project.</p>\n<ul>\n<li>8aa1c98b948b wenzelm 11-Jul-2025 \"maintain collective rule declarations via <br>\ntype Bires.decls, with netpair operations derived from it;\"</li>\n</ul>\n<p>This is where I switched over to a quite different background store for the <br>\nclaset rules, with subtle differences in ordering of declarations (and a few <br>\nother problems that I introduced on the spot). The idea is plain and simple: <br>\nall rules are maintained in one scalable data structure Bires.decls, and the <br>\nnetpairs derived from it can count on precise weight and index information for <br>\nthe ordering. The reality turned out rather ugly, though: applications from <br>\nAFP that did not quite work yet.</p>\n<p>All these problems are resolved in Isabelle/372273ab6ebb and AFP/eae86974a665, <br>\nas far as I can tell. It recovers all visible applications, without odd <br>\nchanges of proofs.</p>\n<p>We could still be a bit more ambitious, though, and eliminate the strange <br>\nBires.decl_merge_ord that is there to imitate the merge ordering from 30 years <br>\nago. Changing that would mean to take the user-provided declaration order <br>\nseriously, even for newly added rules in a merge.</p>\n<p>That further detail would require to go into the smt proof reconstruction, to <br>\nsee where its invocations of fast_tac/blast_tac/auto_tac etc. actually fail, <br>\nor rather consume much more time than before --- and thus break (line 6705 of <br>\n\"$AFP/Modular_arithmetic_LLL_and_HNF_algorithms/HNF_Mod_Det_Soundness.thy\"), <br>\nfor example.</p>\n<p>Makarius</p>",
        "id": 529918278,
        "sender_full_name": "Email Gateway",
        "timestamp": 1753112792
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@cit.tum.de\">florian.haftmann@cit.tum.de</a>&gt;<br>\nJust a side-remark:</p>\n<blockquote>\n<p>That further detail would require to go into the smt proof <br>\nreconstruction, to see where its invocations of fast_tac/blast_tac/ <br>\nauto_tac etc. actually fail, or rather consume much more time than <br>\nbefore --- and thus break (line 6705 of \"$AFP/ <br>\nModular_arithmetic_LLL_and_HNF_algorithms/HNF_Mod_Det_Soundness.thy\"), <br>\nfor example.</p>\n</blockquote>\n<p>I also stumbled over that proof and it can be dramatically simplified:</p>\n<blockquote>\n<ul>\n<li>have \"A <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>A</mi><mrow><mo mathvariant=\"normal\">′</mo><mo mathvariant=\"normal\">′</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\"> (0, 0) = A&#x27;&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′′</span></span></span></span></span></span></span></span></span></span></span></span> (0, 0)\"</li>\n<li>by (smt (verit) add_gr_0 append_rows_def A_def A'' carrier_matD index_mat_four_block(1) mn n0 nat_SN.compat)</li>\n<li>from \\&lt;open&gt;0 &lt; n\\&lt;close&gt; \\&lt;open&gt;0 &lt; m\\&lt;close&gt; A'' have \\&lt;open&gt;A <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>A</mi><mrow><mo mathvariant=\"normal\">′</mo><mo mathvariant=\"normal\">′</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\"> (0, 0) = A&#x27;&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′′</span></span></span></span></span></span></span></span></span></span></span></span> (0, 0)\\&lt;close&gt;</li>\n<li>by (simp add: A_def append_rows_def)</li>\n</ul>\n</blockquote>\n<p>I will leave it »as it is« for the moment as long as it serves as an <br>\nimportant indicator for smt proof reconstruction.</p>\n<p>Florian</p>\n<p><a href=\"/user_uploads/14278/wuB8c8JYeBHHJdomaScQLIww/OpenPGP_0xA707172232CFA4E9.asc\">OpenPGP_0xA707172232CFA4E9.asc</a><br>\n<a href=\"/user_uploads/14278/U1c91Ml8YABQSqSU3nTq6YCe/OpenPGP_signature.asc\">OpenPGP_signature.asc</a></p>",
        "id": 530576515,
        "sender_full_name": "Email Gateway",
        "timestamp": 1753367203
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21/07/2025 17:45, Makarius wrote:</p>\n<blockquote>\n<p><strong>* General </strong>*</p>\n<ul>\n<li>Declarations of intro/elim/dest rules for Pure and the Classical<br>\nReasoner (e.g. HOL) are handled more uniformly and efficiently: the<br>\norder of rule declarations is maintained accurately, regardless of<br>\nintermediate [rule del] declarations. Furthermore, [dest] is now a<br>\nproper declaration on its own account, instead of the former expansion<br>\n[elim_format, elim]. Consequently, [rule del] no longer deletes the<br>\n[elim_format] of the given rule, only the original rule. Very rare<br>\nINCOMPATIBILITY: tools like \"blast\" and \"auto\" may fail in unusual<br>\nsituations.</li>\n</ul>\n<p>This refers to Isabelle/372273ab6ebb and AFP/eae86974a665.</p>\n</blockquote>\n<p>After a few days of accumulating Isabelle + AFP \"flight telemetry data\", I <br>\nhave inspected <br>\n<a href=\"https://isatest.sketis.net/devel/build_status/AFP_macOS_(macOS_14_Sonoma_Apple_Silicon)/index.html\">https://isatest.sketis.net/devel/build_status/AFP_macOS_(macOS_14_Sonoma_Apple_Silicon)/index.html</a> <br>\nclosely, if anything good or bad is to be seen there.</p>\n<p>Conclusion: this change has now overall measurable effect on Isabelle/AFP, <br>\ndespite significant lack of scalability.</p>\n<p>I found other performance changes elsewhere, and will report them separately.</p>\n<p>Makarius</p>",
        "id": 530959752,
        "sender_full_name": "Email Gateway",
        "timestamp": 1753542662
    }
]