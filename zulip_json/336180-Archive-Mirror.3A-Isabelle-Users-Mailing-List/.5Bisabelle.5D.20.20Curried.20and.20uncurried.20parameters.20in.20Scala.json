[
    {
        "content": "<p>From: \"C. Diekmann\" &lt;<a href=\"mailto:diekmann@in.tum.de\">diekmann@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>there seems to be a problem with curried and uncurried parameters, in<br>\nparticular in Scala.</p>\n<p>For example, in the collections framework, the function parameters are<br>\nnormally omitted. rs_iteratei serves as example. It is defined as<br>\nfollows:<br>\n  rs_iteratei ≡ s_iteratei rm_iteratei</p>\n<p>The type is<br>\n  ('a, unit) RBT.rbt =&gt; ('b =&gt; bool) =&gt; ('a =&gt; 'b =&gt; 'b) =&gt; 'b =&gt; 'b</p>\n<p>Often, I just want to apply the first four parameters and just get the<br>\nresult back. For example in the following definition<br>\n  definition do_something :: \"(nat, unit) RBT.rbt ⇒ nat\" where<br>\n  \"do_something tree = rs_iteratei tree (%x. True) (%x y. x) (0::nat)\"</p>\n<p>This yields the following Scala code<br>\n  def do_something(tree: RBT.rbt[Nat.nat, Unit]): Nat.nat =<br>\n    RBTSetImpl.rs_iteratei[Nat.nat,<br>\n                          Nat.nat].apply(tree).apply((_: Nat.nat) =&gt;<br>\n               true).apply((x: Nat.nat) =&gt;<br>\n                             (_: Nat.nat) =&gt; x).apply(Nat.Zero_nat())</p>\n<p>As rs_iteratei is exported as curried function, the code looks really<br>\nugly because of all those apply calls. The signature of rs_iteratei is<br>\n  (RBT.rbt[A, Unit]) =&gt; (B =&gt; Boolean) =&gt; (A =&gt; B =&gt; B) =&gt; B =&gt; B</p>\n<p>There are some problems with that. First, it looks scary. Second, it<br>\ncreates those long class files during compilation. Third, applying<br>\napply four times is way more inefficient than passing just four<br>\nparameters at once. And finally, IDEs might have problems with those<br>\nscary long function types.</p>\n<p>The following code lemma adds the parameters to rs_iteratei<br>\n  lemma[code]: \"rs_iteratei t sfun mfun strt = s_iteratei rm_iteratei<br>\nt sfun mfun strt\"</p>\n<p>Now, in the exported Scala code, the signature looks as follows.<br>\n  (t: RBT.rbt[A, Unit], sfun: B =&gt; Boolean, mfun: A =&gt; B =&gt; B, strt: B): B</p>\n<p>This is very beautiful, provides a good documentation, and helps the<br>\nIDE to use the function. The do_something also looks better now.<br>\n  def do_something(tree: RBT.rbt[Nat.nat, Unit]): Nat.nat =<br>\n    RBTSetImpl.rs_iteratei<a href=\"http://tree,%20(_:%20Nat.nat)%20=&gt;%20true,%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(x:%20Nat.nat)%20=&gt;%20(_:%20Nat.nat)%20=&gt;%20x,%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Nat.Zero_nat()\">Nat.nat,\n                          Nat.nat</a></p>\n<p>I heard that one does not want the parameters explicitly listed in e.g. SML.</p>\n<p>It would be a great feature if for certain languages, the function<br>\nparameters and a useful name for them could be added.</p>\n<p>Regards<br>\n  Cornelius</p>",
        "id": 294240449,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906749
    }
]