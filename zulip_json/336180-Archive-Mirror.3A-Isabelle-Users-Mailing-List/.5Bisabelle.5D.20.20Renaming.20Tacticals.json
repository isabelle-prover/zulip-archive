[
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nHi Peter,</p>\n<p>I am not an expert in this but here is some information.</p>\n<p>Peter Chapman writes:</p>\n<blockquote>\n<p>Hi</p>\n<p>I have a series of methods to apply which looks something like this</p>\n<p>apply (rule ((basic)+)?, ((conjL)+)?, ((disjR)+)?, ...)</p>\n<p>Is there anyway that I can rename the above to something, say  <br>\nbigRule, so that</p>\n<p>apply (rule bigRule)</p>\n</blockquote>\n<p>Yes, this can be done, but must be done on the ML-level.</p>\n<p>Judging from your apply-line, you want to apply rule basic as often as <br>\npossible (possibly not at all), after this you want to do the same <br>\nwith rule conjL, and so on. To keep things in line with Isabelle-<br>\nterminology (and for understanding the documentation), let's call <br>\nbasic, conjL, disjR.... <em>theorems</em>. I guess they are axioms or lemmas <br>\nin your proof-script and such things are in Isabelle called <br>\ntheorems, or short thm ;o)</p>\n<blockquote>\n<p>executes the first line?  I had an attempt using ML as</p>\n<p>ML {* fun PETER (basic, impR, impL, conjL, disjR, false, conjR,  <br>\ndisjL) = REPEAT (EVERY [basic, impR, impL, conjL, disjR, false,  <br>\nconjR, disjL]); *}</p>\n</blockquote>\n<p>This already goes in the right direction. You have to write what<br>\nis called in Isabelle a tactical. EVERY and REPEAT are building<br>\nblocks for tacticals. This is described in chapter 4 of the Isabelle-<br>\nreference and also in 3.2 (look at the Isabelle webpage). First <br>\napplying a theorem, like basic and disjL, is done with rtac. For <br>\nexample, for </p>\n<p>lemma \"A /\\ B\"<br>\n    apply(rule conjI)    </p>\n<p>you can also do the following </p>\n<p>lemma \"A /\\ B\"<br>\n    apply(tactic {* rtac conjI 1 *})</p>\n<p>to achieve pretty much the same on the ML-level (conjI is the theorem<br>\nthat is applied, 1 refers to the first subgoal and \"tactic {* *}\" is a <br>\nwrapper to call some ML-code from a proof-script). </p>\n<p>You want to apply \"rtac conjI 1\" as often as possible including<br>\nthe possibility of not at all. For this you have to use REPEAT. For<br>\nexample</p>\n<p>lemma \"(A /\\ B) /\\ C\"<br>\n    apply(tactic {* REPEAT (rtac conjI 1) *})</p>\n<p>applies theorem conjI twice producing the goals A, B and C. Next you<br>\nwant to do such things with a sequence of theorems. For this you<br>\ncan use EVERY (this takes a list of tactics and applies them one<br>\nafter the other. For example</p>\n<p>lemma \"(A \\/ B) /\\ C\"<br>\n    apply(tactic {* EVERY [REPEAT (rtac conjI 1), REPEAT (rtac disjI2 1)] *})</p>\n<p>first takes apart the conjunction and then applies theorem disjI2,<br>\ni.e. produces goals B and C. With a bit of ML-hackery you can <br>\nscale this up to your example and introduce some bigrule-shorthand. </p>\n<p>However, from what you are writing I guess you just want to try out<br>\nsome rules on a goal and take it apart when a safe rule applies;<br>\nand repeat this process recursively with all the subgoals. This is not <br>\nquite what your apply-line achieves (because of the imposed ordering). <br>\nIf this is what you want, I would write </p>\n<p>REPEAT (FIRST [rtac conjI1 1,.....])</p>\n<p>Hope this is helpful. The code above only works on the first subgoal. <br>\nYou might, however, like to apply your tactical to all subgoals that<br>\nhave arisen in this process of taking goals apart. This can all be done <br>\nwith tacticals. However, be aware that writing tacticals can be a bit <br>\nof a black art. ;o) Good luck</p>\n<p>Christian</p>",
        "id": 294047444,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817892
    }
]