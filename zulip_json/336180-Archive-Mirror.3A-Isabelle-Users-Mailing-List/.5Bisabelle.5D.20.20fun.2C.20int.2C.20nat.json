[
    {
        "content": "<p>From: Perry James &lt;<a href=\"mailto:perry@dsrg.org\">perry@dsrg.org</a>&gt;<br>\nHi all,<br>\n   I'm having trouble with functions, integers and nats.  In the theory<br>\nbelow, a \"product\" function is defined that takes the bounds as integers and<br>\nevaluates it using the \"prod\" function, which is based on the nat that is<br>\ntheir difference.  In both cases, the \"body\" parameter is a function to<br>\ngenerate each factor from its index.  In the examples it is always the<br>\nidentity function.<br>\n   I had hoped that all of the lemmas would go though automatically, but<br>\nthat's not the case for \"test\" and \"lemma_3\".</p>\n<p>test leaves the subgoal<br>\n      6 = prod 3 1 (%x. x)</p>\n<p>lemma_3 leaves the subgoal<br>\n      0 &lt; i ==&gt; i * prod (nat (i - 1)) 1 (%x. x) = prod (nat i) 1 (%x. x)</p>\n<p>1) Is there a way to see the value of a function? For example, to see the<br>\nresult of evaluating \"prod 3 1 (%x. x)\" ?<br>\n       If it is not 6, it would explain why the 2 lemmas don't go through,<br>\nbut I'm also not able to prove \"6 ~= prod 3 1 (%x. x)\".<br>\n   2) Is there better form for these functions that would let the proofs go<br>\nthough automatically?<br>\n   3) If this is the standard way of writing such functions, how can I get<br>\nthe proofs to go through?  (hopefully with something similar to simp or<br>\nauto)<br>\n   4) Assuming they can be proved, would it be safe to mark these five<br>\nlemmas as \"[simp]\" for use in later theories?<br>\n   Thanks for your help,<br>\n   Perry</p>\n<p>========= fact.thy =========<br>\ntheory fact<br>\nimports Main<br>\nbegin</p>\n<p>fun prod :: \"nat =&gt; int =&gt; (int =&gt; int) =&gt; int\"<br>\nwhere<br>\n  \"prod 0       lo body = 1\"<br>\n| \"prod (Suc n) lo body = (body (int n + lo)) * (prod n lo body)\"</p>\n<p>fun product :: \"int =&gt; int =&gt; (int =&gt; int) =&gt; int\"<br>\nwhere<br>\n\"product lo hi body = prod (nat (hi - lo + 1)) lo body\"</p>\n<p>lemma test:<br>\n  \"6 == product 1 3 (%x. x)\"<br>\n  apply auto<br>\n  oops</p>\n<p>lemma lemma_1:<br>\n  \"[|(i::int) &gt; 0 ; nat(-1 + i) = n |] ==&gt;<br>\n   (prod (nat(-1 + i)) 1 (%x. x) * i=<br>\n    prod (Suc n)       1 (%x. x))\"<br>\n  by auto</p>\n<p>lemma lemma_2:<br>\n  \"[|(i::int) &gt; 0 ; nat(-1 + i) = n |] ==&gt;<br>\n   (i * prod (nat(-1 + i)) 1 (%x. x) =<br>\n        prod (Suc n)       1 (%x. x))\"<br>\n  by auto</p>\n<p>lemma nat_Suc_i_Min_1_eq_i:<br>\n  \"0 &lt; i --&gt; (Suc (nat (-1 + i))) = (nat i)\"<br>\n  by auto</p>\n<p>lemma lemma_3:<br>\n\"[| 0 &lt; (i::int) |] ==&gt;<br>\n   (i * prod (nat(i - 1)) 1 (%x. x) =<br>\n        prod (nat i     ) 1 (%x. x))\"<br>\n  apply auto<br>\n  oops</p>\n<p>end</p>",
        "id": 294064785,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825070
    }
]