[
    {
        "content": "<p>From: Mario Alvarez &lt;<a href=\"mailto:mmalvare@eng.ucsd.edu\">mmalvare@eng.ucsd.edu</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>Let me apologize in advance if this question reflects some fundamental<br>\nmisunderstandings about Isabelle's Lifting and Transfer facilities. I am<br>\nstill new to them and, while I've read the documentation about them, I<br>\nstill feel shaky about my intuitions.</p>\n<p>My mental model of the Lifting package is the following: if for some types<br>\ntypeb and typea I can prove</p>\n<p>\"type_definition Rep Abs A\" (for Rep :: typeb =&gt; typea, Abs : typea =&gt;<br>\ntypeb, A :: typea set)</p>\n<p>then I can feed this theorem to the Lifting tool to lift definitions that<br>\ntalks about the concrete type A to definitions that talk about the abstract<br>\ntype B. (And I can use Transfer to assist in proving theorems about the<br>\nfunctions I derive this way).</p>\n<p>My question is whether Isabelle contains any support for automated lifting<br>\nwhen the relationship is reversed. That is, suppose I have a suite of<br>\ndefinitions for the \"abstract\" type B and I want to \"lower\" them to<br>\ndefinitions on type A (where we know the same type_definition fact<br>\nindicated above).</p>\n<p>It seemed to me that there probably wasn't a way to do this in general.<br>\nAlthough in some concrete cases it does seem that there is something sane<br>\nyou can do - for instance, we could prove \"type_definition Some<br>\n(case_option undefined id) {x . ∃ y . x = Some y}\". And then map_option<br>\nwould seem to be the \"lowering\" function we'd be looking for.</p>\n<p>However, I saw the description of the \"Transfer.transferred\" attribute in<br>\nisar-ref, and, while I did not fully understand it, it seemed like it might<br>\nbe something akin to what I was looking for. It at least made me question<br>\nwhether there is something sane that can be done in the \"reverse\" direction<br>\nin the general case.</p>\n<p>So my question is basically</p>\n<ol>\n<li>\n<p>Is there anything sane that can be done in general when it comes to this<br>\nsort of \"lowering\"?</p>\n</li>\n<li>\n<p>Does Isabelle have any automation that supports such \"lowering\" in a<br>\nsimilar way to its support for Lifting?</p>\n</li>\n<li>\n<p>Regardless of the answers to 1 and 2, what exactly does<br>\n\"Transfer.transferred\" do?</p>\n</li>\n</ol>\n<p>Thanks,<br>\nMario</p>",
        "id": 294830276,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246295
    },
    {
        "content": "<p>From: \"Thiemann, René\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear Mario,</p>\n<p>I’m not an export on transfer on my own, but merely a user.</p>\n<p>From my experience transfer-lifting mostly works uni-directional.<br>\nHowever, there is an attribute “untransferred” that permits to go in<br>\nthe other direction. Example:</p>\n<p>typedef large_nat = \"{ x :: nat. x ≥ 5 }\" by auto</p>\n<p>setup_lifting type_definition_large_nat</p>\n<p>lift_definition sq_large_nat :: \"large_nat ⇒ large_nat\" is \"λ x. x * x\"<br>\n  by (meson leD leI le_less_trans le_square)</p>\n<p>lift_definition get_nat :: \"large_nat ⇒ nat\" is \"λ x. x\" .</p>\n<p>lemma sq_20: \"get_nat (sq_large_nat x) ≥ 20\" <br>\nproof (transfer)<br>\n  (* this is the standard direction *)<br>\n  fix x :: nat<br>\n  assume \"5 ≤ x\" <br>\n  hence \"5 * 5 ≤ x * x\"<br>\n    using mult_le_mono by blast<br>\n  thus \"20 ≤ x * x\" by auto <br>\nqed</p>\n<p>(* and now we can go in the other direction *)<br>\nthm sq_20[untransferred] (* results in 5 ≤ x ⟹ 20 ≤ x * x *)</p>\n<p>Best,<br>\nRené</p>",
        "id": 294830330,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246329
    },
    {
        "content": "<p>From: Mario Alvarez &lt;<a href=\"mailto:mmalvare@eng.ucsd.edu\">mmalvare@eng.ucsd.edu</a>&gt;<br>\nHi René,</p>\n<p>Thanks for your help. I guess perhaps I was confused about the difference<br>\nbetween \"transferred\" and \"untransferred\" (although I have to admit I'm<br>\nstill not clear on what \"untransferred\" does, since I had thought that it<br>\ndid more or less what you described \"transferred\" as doing in your example.)</p>\n<p>I'd still appreciate it if anyone could help me out with an intuition for<br>\nwhat \"untransferred\" does, but I think I've gotten the main thing I wanted<br>\nto know from René's reply; namely, that I can only lift definitions one way<br>\n(using Lifting) but that (at least under some circumstances) I can transfer<br>\n<em>facts</em> about my lifted constants in the reverse direction.</p>\n<p>Thanks,<br>\nMario</p>",
        "id": 294830407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246358
    }
]