[
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi all,</p>\n<p>I was a bit surprised to discover that \"code_pred\" introduces axioms with strange names in some circumstances. I've checked the behavior with a recent repository version of Isabelle but it has been around for several weeks and should be in Isabelle2013-1-RC1 as well (and probably Isabelle2013).</p>\n<p>In \"Jinja/Common/TypeRel.thy\", there is the following command</p>\n<p>code_pred <br>\n      (modes: i ⇒ i × o ⇒ bool, i ⇒ i × i ⇒ bool)<br>\n      [inductify]<br>\n      subcls1 <br>\n    .</p>\n<p>Right after it,</p>\n<p>ML {* Theory.axioms_of @{theory} |&gt; map fst |&gt; rev |&gt; take 2 *}</p>\n<p>will produce somehting like</p>\n<p>val it = [\"TypeRel.unnamed_axiom_2088252\", \"TypeRel.unnamed_axiom_2088251\"]: string list</p>\n<p>where the numbers change on each invocation.</p>\n<p>(1) Is it desirable that \"code_pred\" introduces axioms for something that could (from what I can tell) easily be done using a definition?<br>\n(2) If the answer yes, shouldn't it provide some decent names to them rather than unpredictable, ever changing ones?</p>\n<p>Jasmin</p>",
        "id": 294252792,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911413
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jasmin,</p>\n<p>When Lukas told me about the axioms about three years ago, he said that indeed these <br>\naxioms only specify new constants which the inductify option of code_pred introduces for <br>\ncode generation. He wanted to somewhen implement proper definitions for these constants, <br>\nbut never found the time. So no, it is not desirable to have axioms instead of <br>\ndefinitions, even in code_pred [inductify].</p>\n<p>However a simple definition will not work, one would have to build quite some machinery, <br>\nbecause the definitions can be recursive. The following example illustrates the problem:</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>definition Id :: \"('a =&gt; 'a) =&gt; 'a =&gt; 'a\" where \"Id f x = f x\"</p>\n<p>lemma [fundef_cong]: \"[| x = y; f y = g y |] ==&gt; Id f x = Id g y\"<br>\nby(simp add: Id_def)</p>\n<p>fun bar :: \"nat =&gt; nat\" where<br>\n   bar0: \"bar 0 = 1\"<br>\n| bar1: \"bar (Suc n) = Id bar n\" (* higher-order recursion through Id *)</p>\n<p>inductive foo :: \"nat =&gt; bool\"<br>\nwhere \"foo 0\" | \"foo (bar k)\"</p>\n<p>code_pred [inductify] foo .</p>\n<p>The invocation of code_pred introduces two new constants IdP and barP and specified the <br>\nfollowing three axioms:</p>\n<p>IdP barP p res ==&gt; barP (Suc p) res<br>\nbarP 0 1<br>\nh z res ==&gt; IdP h z res</p>\n<p>The introduction rules for barP are recursive and go through the higher-order predicate <br>\nIdP (just like the definition of bar higher-order-recurses throuch Id). If one wants to do <br>\nthis definitionally (e.g., with the inductive package), then one also has to prove the <br>\nmonotonicity rule for IdP. I am not sure whether one should spent that much effort, as <br>\n[inductify] itself is very flaky anyway.</p>\n<p>With respect to the names of the axioms, I don't care what they are called. I have never <br>\nwanted to use them, because they are really internal constructions of the code generator. <br>\nOnly the generated .equation theorem is of interest. But if you want to implement stable <br>\nnames, how about &lt;predicate name&gt;.intros?</p>\n<p>Andreas</p>",
        "id": 294252810,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911422
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<p>Thank you for the (as usual) very thorough explanation.</p>\n<blockquote>\n<p>The introduction rules for barP are recursive and go through the higher-order predicate IdP (just like the definition of bar higher-order-recurses throuch Id). If one wants to do this definitionally (e.g., with the inductive package), then one also has to prove the monotonicity rule for IdP. I am not sure whether one should spent that much effort, as [inductify] itself is very flaky anyway.</p>\n</blockquote>\n<p>I believe Lars Hupel is trying to attack similar problems, also in the context of the code generator.</p>\n<blockquote>\n<p>With respect to the names of the axioms, I don't care what they are called. I have never wanted to use them, because they are really internal constructions of the code generator. Only the generated .equation theorem is of interest. But if you want to implement stable names, how about &lt;predicate name&gt;.intros?</p>\n</blockquote>\n<p>I did something a bit simpler -- \".intros\" doesn't quite work with \"Specification.axiom\", which does one axiom at a time. It's not that I care so much about the names, but for a tool like MaSh it's a bit worrying when the fact names change each time you reload the theory.</p>\n<p>Jasmin</p>",
        "id": 294252822,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911428
    }
]