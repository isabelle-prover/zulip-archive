[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nHello,</p>\n<p>I want to write a function that takes a partial-order as a parameter. Specifically, I want the following function...</p>\n<p>fun interleave :: \"'a list =&gt; 'a list =&gt; 'a partialorder =&gt; 'a list set\"</p>\n<p>... which takes two lists and a partialorder, and returns the set of all interleavings of the elements of those lists which respect the partial order.</p>\n<p>I know that I could replace \"'a partialorder\" above with \"('a \\&lt;times&gt; 'a) set\", and then prove a lemma saying \"if that parameter is a partial-order then interleave has such-and-such a property\". But it would be rather nice just to put the partial-order-ness of that parameter straight into its type. Can I do that, and if so how?</p>\n<p>Thanks very much,<br>\njohn</p>",
        "id": 294148084,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848254
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nJohn,</p>\n<p>You can use a type class. See the lattice theories in the HOL distribution, i.e. HOL/Lattices.thy, or the partial order setup in HOLCF.</p>\n<p>The problem (in general) with this approach is that it only allows each type to be partially ordered in one way. If this is an issue then I suggest you use a locale instead, or your original approach.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294148110,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848265
    },
    {
        "content": "<p>From: Steven Obua &lt;<a href=\"mailto:steven.obua@googlemail.com\">steven.obua@googlemail.com</a>&gt;<br>\nyou can also define a new type ala</p>\n<p>typedef 'a partial_order = those \"('a \\&lt;times&gt; 'a) set\" which correspond to partial orders</p>\n<p>I don't have the exact syntax at hand right now, but that should point you in the right direction, and it will work. Not sure if it is worth the effort though, you might be better off using an explicit assumption.</p>\n<p>Cheers,</p>\n<p>Steven</p>",
        "id": 294148138,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848277
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Sun, Nov 13, 2011 at 9:45 PM, John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Thanks very much Brian, that all makes sense to me. I was expecting you to tell me to tap into the type class \"order\" in some way (which is defined in <a href=\"http://isabelle.in.tum.de/dist/library/HOL/Orderings.html\">http://isabelle.in.tum.de/dist/library/HOL/Orderings.html</a>). Which is to say: do I really have to define my own \"is_partialorder\" predicate from scratch?</p>\n</blockquote>\n<p>[I forgot to reply also to the list with my first response; now we're<br>\nback on the list again.]</p>\n<p>Now to answer your follow-up question: If you want to avoid defining<br>\nan is_partialorder predicate from scratch, you can use the locale<br>\npredicates that come from the existing type classes. The only<br>\ncomplication here is that the locale predicate for class order takes<br>\n<em>two</em> arguments, one for \"op &lt;=\" and one for \"op &lt;\":</p>\n<p>\"class.order\"<br>\n  :: \"('a =&gt; 'a =&gt; bool) =&gt; ('a =&gt; 'a =&gt; bool) =&gt; bool\"</p>\n<p>(Also note that the relations are modeled as binary predicates, rather<br>\nthan as sets of pairs.)</p>\n<p>So you could define your type in terms of pairs of relations, like this:</p>\n<p>typedef 'a partialorder = \"{(le :: 'a =&gt; 'a =&gt; bool, lt :: 'a =&gt; 'a =&gt;<br>\nbool). class.order le lt}\"</p>\n<p>The definition of a partial order is still simple enough that I'm not<br>\nsure if using the class predicate like this is worth the trouble. For<br>\nother, more complicated type classes it would probably be worth it,<br>\nthough.</p>\n<p>If your main concern is getting copies of all the theorems that exist<br>\nin class \"order\", then you could achieve this with a locale<br>\ninstantiation. Specifically, you could define parameterized versions<br>\nof \"op &lt;=\" and \"op &lt;\" with these types:</p>\n<p>my_le :: 'a partialorder =&gt; 'a =&gt; 'a =&gt; bool<br>\nmy_lt :: 'a partialorder =&gt; 'a =&gt; 'a =&gt; bool</p>\n<p>And then do a locale instantiation like this:</p>\n<p>instantiation my_partialorder: order \"my_le r\" \"my_lt r\"<br>\n  &lt;proof&gt;</p>\n<p>after which you would have copies of all the theorems from the order class.</p>\n<ul>\n<li>Brian</li>\n</ul>\n<blockquote>\n<p>On 13 Nov 2011, at 18:58, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Sun, Nov 13, 2011 at 7:26 PM, John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I want to write a function that takes a partial-order as a parameter. Specifically, I want the following function...</p>\n<p>fun interleave :: \"'a list =&gt; 'a list =&gt; 'a partialorder =&gt; 'a list set\"</p>\n<p>... which takes two lists and a partialorder, and returns the set of all interleavings of the elements of those lists which respect the partial order.</p>\n<p>I know that I could replace \"'a partialorder\" above with \"('a \\&lt;times&gt; 'a) set\", and then prove a lemma saying \"if that parameter is a partial-order then interleave has such-and-such a property\". But it would be rather nice just to put the partial-order-ness of that parameter straight into its type. Can I do that, and if so how?</p>\n</blockquote>\n<p>Hi John,</p>\n<p>Yes, you certainly can do this. You just need to define the type 'a<br>\npartialorder with a typedef, something like this:</p>\n<p>typedef 'a partialorder = \"{r::('a * 'a) set. is_partialorder r}\"</p>\n<p>where \"is_partialorder\" should be defined ahead of time as a predicate<br>\nasserting that the given relation is a partial order. The typedef will<br>\nrequire a nonemptiness proof, but that should be easy since the<br>\nequality relation on any type is always a partial order.</p>\n<p>For an example of this kind of definition, have a look at<br>\nsrc/HOL/Multivariate_Analysis/Topology_Euclidean_Space, which defines<br>\na type called 'a topology consisting of all the possible topologies on<br>\ntype 'a.</p>\n<p>Hope this helps,<br>\n- Brian</p>\n</blockquote>\n</blockquote>",
        "id": 294148158,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848286
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi John,</p>\n<blockquote>\n<p>I want to write a function that takes a partial-order as a parameter.<br>\nSpecifically, I want the following function...</p>\n<p>fun interleave :: \"'a list =&gt; 'a list =&gt; 'a partialorder =&gt; 'a list set\"</p>\n<p>... which takes two lists and a partialorder, and returns the set of<br>\nall interleavings of the elements of those lists which respect the<br>\npartial order.</p>\n</blockquote>\n<p>here a short overview of the design space which combines everything said<br>\non that here (@all: please comment if you think I've missed something)<br>\nwith Isabelle folklore:</p>\n<p>a) use (existing) type classes</p>\n<p>+ lightweight<br>\n  + code can be generated directly<br>\n  - only one instantiation per type<br>\n  - no explicit carrier</p>\n<p>b) use locales abstracting over the algebraic structure (which is<br>\ntypically represented as a record)</p>\n<p>+ explicit carrier<br>\n  + more flexible due to parametrisation<br>\n  - more involved in application<br>\n  - no direct code generation</p>\n<p>c) use abstract type definition which encapsulates the properties of the<br>\nstructure</p>\n<p>+ combines nicely with b) via interpretation<br>\n  + explicit carrier<br>\n  + code generation possible</p>\n<p>Examples for a) can be found in the HOL standard theories, for b) in the<br>\nHOL-Algebra session.</p>\n<p>For b) and c), the locale predicates for existing type classes can be<br>\nreused of course.</p>\n<p>c) is quite a recent thought which I have not yet thought of thoroughly,<br>\nso I do not know about pitfalls etc.  It seems worth exploring.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/fb6oBdA2_UOsgjrUrCCyMFXc/signature.asc\">signature.asc</a></p>",
        "id": 294148234,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848310
    }
]