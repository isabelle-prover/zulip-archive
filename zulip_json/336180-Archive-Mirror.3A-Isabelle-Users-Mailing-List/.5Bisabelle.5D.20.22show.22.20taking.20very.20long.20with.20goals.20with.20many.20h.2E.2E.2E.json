[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>I have an inductive proof where the induction rule has a lot of very<br>\nsimilar assumptions, due to the Nominal machinery: (Don’t worry about<br>\nthe details, this is just to give an impression of what I mean by<br>\n„many“).</p>\n<ol>\n<li>⋀n Γ Γ' Δ Δ' x e y Θ Θ' z e' u xa.<br>\n       atom n ♯ xa ⟹<br>\n       atom z ♯ xa ⟹<br>\n       atom n ♯ Γ ⟹<br>\n       atom n ♯ Γ' ⟹<br>\n       atom n ♯ Δ ⟹<br>\n       atom n ♯ Δ' ⟹<br>\n       atom n ♯ x ⟹<br>\n       atom n ♯ e ⟹<br>\n       atom n ♯ y ⟹<br>\n       atom n ♯ Θ ⟹<br>\n       atom n ♯ Θ' ⟹<br>\n       atom n ♯ z ⟹<br>\n       atom z ♯ Γ ⟹<br>\n       atom z ♯ Γ' ⟹<br>\n       atom z ♯ Δ ⟹<br>\n       atom z ♯ Δ' ⟹<br>\n       atom z ♯ x ⟹<br>\n       atom z ♯ e ⟹<br>\n       atom z ♯ y ⟹<br>\n       atom z ♯ Θ ⟹<br>\n       atom z ♯ Θ' ⟹<br>\n       distinctVars (((x, App e y) # Γ') @ Γ) ⟹<br>\n       distinctVars (((n, e) # (x, App (Var n) y) # Γ') @ Γ) ⟹<br>\n       distinctVars (((n, Lam [z]. e') # (x, App (Var n) y) # Δ') @ Δ) ⟹<br>\n       distinctVars (((x, e'[z::=y]) # Δ') @ Δ) ⟹<br>\n       distinctVars (Θ' @ Θ) ⟹<br>\n       Γ : (n, e) # (x, App (Var n) y) # Γ' ⇓⇧×⇧u⇧d Δ : (n, Lam [z]. e') # (x, App (Var n) y) # Δ' ⟹<br>\n       (⋀b. atom b ♯ (Γ, snd (hd ((n, e) # (x, App (Var n) y) # Γ'))) ⟹<br>\n            atom b ♯ (Δ, snd (hd ((n, Lam [z]. e') # (x, App (Var n) y) # Δ'))) ∨ b ∈ heapVars Δ) ⟹<br>\n       Δ : (x, e'[z::=y]) # Δ' ⇓⇧×⇧u⇧d Θ : Θ' ⟹<br>\n       (⋀b. atom b ♯ (Δ, snd (hd ((x, e'[z::=y]) # Δ'))) ⟹<br>\n            atom b ♯ (Θ, snd (hd Θ')) ∨ b ∈ heapVars Θ) ⟹<br>\n       atom xa ♯ (Γ, snd (hd ((x, App e y) # Γ'))) ⟹ atom xa ♯ (Θ, snd (hd Θ')) ∨ xa ∈ heapVars Θ</li>\n</ol>\n<p>I handle the case using a named case:</p>\n<p>case (DApplicationInd n Γ Γ' Δ Δ' xa e y Θ Θ' z e' u x)<br>\n  [..]<br>\n  thus ?case<br>\n  proof [..]<br>\n  qed</p>\n<p>At the \"thus\", as well as at the \"qed\", Isabelle sits there for a long<br>\ntime (minutes) before continuing.</p>\n<p>My guess is that there are many ways to unify my assumptions with the<br>\nassumptions of the goal, and Isabelle tries a lot of wrong ones before<br>\nruling them out according to the statement shown and the other<br>\nassumptions.</p>\n<p>Is there a way to help out Isabelle here? And coudn’t the \"case Foo\"<br>\ncommand somehow ensure that Isabelle will try the „right“ unification<br>\nfirst?</p>\n<p>Thanks,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/ofGDxrru9LIofxo30HXcUeFa/signature.asc\">signature.asc</a></p>",
        "id": 294242857,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907717
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>this does not seem to be the problem here, as I do prove the subgoals in<br>\nthe order they occur: Even if I discharge all other cases before, the<br>\nshow takes long. So I still believe it is a problem with the large(?)<br>\nnumber of variables and similar assumptions.</p>\n<p>Sorry for not providing a minimal example, but the real code is, for<br>\nexample, here:<br>\n<a href=\"http://afp.sourceforge.net/browser_info/current/HOL/HOLCF/Nominal2/Launchbury/LaunchburyStacked.html\">http://afp.sourceforge.net/browser_info/current/HOL/HOLCF/Nominal2/Launchbury/LaunchburyStacked.html</a><br>\n(Lemma reds_fresh', case DApplication, first \"thus\").</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/BJP5i8KP3qFAs_3oCkQI8VOK/signature.asc\">signature.asc</a></p>",
        "id": 294242894,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907735
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>here is one:</p>\n<p>theory Scratch imports Main begin</p>\n<p>consts foo :: \"nat =&gt; bool\"<br>\nconsts bar :: \"nat =&gt; nat =&gt; nat =&gt; nat =&gt; nat =&gt; nat =&gt; nat =&gt; nat =&gt; bool\"<br>\nconsts A :: bool<br>\nconsts B :: bool</p>\n<p>lemma ind_rule[case_names CaseName]: \"(⋀a b c d e f g h .<br>\n  foo a ⟹<br>\n  foo b ⟹<br>\n  foo c ⟹<br>\n  foo d ⟹<br>\n  foo e ⟹<br>\n  foo f ⟹<br>\n  foo g ⟹<br>\n  foo h ⟹<br>\n  bar a b c d e f g h ⟹<br>\n  A) ⟹ B\" sorry</p>\n<p>lemma B<br>\nproof (induction rule: ind_rule)<br>\ncase (CaseName a b c d e f g h)<br>\n  show A (* This takes very long *)<br>\n  apply (rule ccontr)<br>\n  sorry (* This also *)<br>\nqed</p>\n<p>end</p>\n<p>Adding another parameter makes it take longer than I’d like to wait,<br>\nwhile after removing a parameter, things are fast enough so that I<br>\nwoudn’t bother.</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/lUsa1R99SDY3nhoE2vI9Vozb/signature.asc\">signature.asc</a></p>",
        "id": 294242939,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907760
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Joachim,</p>\n<p>I think you are right that unification is the bottle neck. In your minimal example, you <br>\ncan speed things up by using a different order of the assumptions. If \"bar ...\" comes <br>\nfirst, show is instantaneous. This might also work your application with Nominal2, but you <br>\neither have to adjust the induction rule (such that the freshness constraints come at the <br>\nend) or use the manual \"fix-assume-show\" style instead of \"case\".</p>\n<p>Andreas</p>",
        "id": 294242992,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907765
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nApart from that publicly visible application, Larry has shown me his <br>\nprivate project which is all very huge and slow due to Nominal2.  There <br>\nare Simplifier invocations that take minutes due to all these small <br>\nNominal2 freshness particles.</p>\n<p>We should probably move over this thread over to isabelle-dev, to sort out <br>\nboth the performance issues of Nominal2 and the question if it manages <br>\nbecome part of the next Isabelle release, which will happen quite soon <br>\nafter the summer.  (I am myself not an active participant of the nominal <br>\nmailing list.)</p>\n<p>Makarius</p>",
        "id": 294246159,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908987
    }
]