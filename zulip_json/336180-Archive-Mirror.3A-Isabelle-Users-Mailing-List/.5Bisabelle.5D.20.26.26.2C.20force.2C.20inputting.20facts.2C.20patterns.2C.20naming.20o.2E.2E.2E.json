[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nConsider the following example (in Isabelle 2008):</p>\n<p>consts<br>\n    Req :: \"nat =&gt; bool\"</p>\n<p>lemma lemmaName:<br>\n    assumes h:<br>\n    \"!!(S::nat set) (s::nat).<br>\n       (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n       (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n    shows first:\"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n      and second:<br>\n        \"(ALL s. ((EX  z. P z s) --&gt; (EX z'. P' z' s))) | (ALL u. Req u)\"<br>\n    using h[where S=\"{}\"] proof force<br>\n    show \"(ALL s. (EX z. P z s) --&gt; (EX z'. P' z' s)) | (ALL u. Req u)\"<br>\n      using h[where S =\"UNIV::nat set\"] by force<br>\n  qed</p>\n<p>The informal proof is:</p>\n<p>first goal by classical reasoning taking S={} in h, <br>\n  second goal by classical reasoning taking S=nat.</p>\n<p>My Isar proof is ugly and asymetrical, forcing me to restate the<br>\nsecond conclusion, but not the first conclusion.</p>\n<p>Another Isar proof is:</p>\n<p>using h[where S=\"{}\"] h[where S =\"UNIV::nat set\"] by (force, force)</p>\n<p>This succeeds but is also ugly because we give both facts to both<br>\ngoals.  This is also very much slower.</p>\n<p>How can I express the proof I want in Isar without restating the<br>\nsecond goal?</p>\n<p>In both proofs it seems that the first \"force\" neither fails nor<br>\nfinishes the goal, which disagrees with what the HOL tutorial says<br>\nabout \"force\".</p>\n<p>Using patterns, we can slightly improve the first presentation</p>\n<p>lemma lemmaName:<br>\n    assumes h:<br>\n    \"!!(S::nat set) (s::nat).<br>\n       (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n       (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n    shows first:\"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n    and second:<br>\n      \"(ALL s. ((EX  z. P z s) --&gt; (EX z'. P' z' s))) | (ALL u. Req u)\"<br>\n          (is \"?snd\")<br>\n    using h[where S=\"{}\"] proof force<br>\n    show \"?snd\" using h[where S =\"UNIV::nat set\"] by force<br>\n  qed</p>\n<p>But syntax</p>\n<p>lemma lemmaName:<br>\n   assumes h:<br>\n   \"!!(S::nat set) (s::nat).<br>\n      (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n      (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n   shows first:\"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n                      (is \"?fst\")<br>\n                -- \"  ^^^^^^^^^^^ \"<br>\n   and second:<br>\n     \"(ALL s. ((EX  z. P z s) --&gt; (EX z'. P' z' s))) | (ALL u. Req u)\"<br>\n                      (is \"?snd\")</p>\n<p>is rejected: \"Pattern match failed!\" (Bug?)</p>\n<p>Names: I guessed that one can name the two conclusions, \"first\" and<br>\n\"second\", but I guessed their top-level names would be<br>\n\"lemmaName.first\" and \"lemmaName.second\", while in fact their<br>\ntop-level names are \"first\" and \"second\".  Any comment Makarius?</p>\n<p>Finally, the following is also rejected:</p>\n<p>lemma <br>\n    assumes h:<br>\n    \"!!(S::nat set) (s::nat).<br>\n       (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n       (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n    shows \"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n    using h[where S=\"{}\"] proof force<br>\n    show \"(ALL s. (EX z. P z s) --&gt; (EX z'. P' z' s)) | (ALL u. Req u)\"<br>\n      using h[where S =\"UNIV::nat set\"] by force</p>\n<p>*** empty result sequence -- proof command failed<br>\n*** At command \"proof\".</p>\n<p>I only removed the second goal from the statement of the lemma, and<br>\ntried to use the proof of the first goal that worked before.  Bug?</p>\n<p>Thanks,<br>\nRandy</p>",
        "id": 294063644,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824636
    },
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nSorry, that last example should be</p>\n<p>lemma <br>\n    assumes h:<br>\n    \"!!(S::nat set) (s::nat).<br>\n       (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n       (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n    shows \"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n    using h[where S=\"{}\"] proof force</p>\n<p>^^^^^^^^^^^ <br>\n         this worked before on the first goal, but fails now</p>\n<p>*** empty result sequence -- proof command failed<br>\n*** At command \"proof\".</p>\n<p>Randy</p>",
        "id": 294063659,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824641
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 10 Jul 2008, Randy Pollack wrote:</p>\n<blockquote>\n<p>Consider the following example (in Isabelle 2008):</p>\n<p>consts<br>\n    Req :: \"nat =&gt; bool\"</p>\n<p>lemma lemmaName:<br>\n    assumes h:<br>\n    \"!!(S::nat set) (s::nat).<br>\n       (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n       (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n    shows first:\"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n      and second:<br>\n        \"(ALL s. ((EX  z. P z s) --&gt; (EX z'. P' z' s))) | (ALL u. Req u)\"<br>\n    using h[where S=\"{}\"] proof force<br>\n    show \"(ALL s. (EX z. P z s) --&gt; (EX z'. P' z' s)) | (ALL u. Req u)\"<br>\n      using h[where S =\"UNIV::nat set\"] by force<br>\n  qed</p>\n<p>The informal proof is:</p>\n<p>first goal by classical reasoning taking S={} in h, <br>\n  second goal by classical reasoning taking S=nat.</p>\n<p>My Isar proof is ugly and asymetrical, forcing me to restate the<br>\nsecond conclusion, but not the first conclusion.</p>\n</blockquote>\n<blockquote>\n<p>How can I express the proof I want in Isar without restating the<br>\nsecond goal?</p>\n</blockquote>\n<p>Here is a more symmetric proof without repeating statements:</p>\n<p>using h[where S=\"{}\"] apply force<br>\n    using h[where S =\"UNIV::nat set\"] apply force<br>\n    done</p>\n<p>This works because 'using' can be given any number of times in the <br>\nrefinement part of a proof, and 'apply' resets the current facts <br>\naltogether. While this is not fully orthodox \"Isar\", I would say it is <br>\nbetter than the other variants.</p>\n<blockquote>\n<p>Another Isar proof is:</p>\n<p>using h[where S=\"{}\"] h[where S =\"UNIV::nat set\"] by (force, force)</p>\n<p>This succeeds but is also ugly because we give both facts to both<br>\ngoals.  This is also very much slower.</p>\n</blockquote>\n<p>Here you can avoid the duplicate use of facts like this:</p>\n<p>by<br>\n      (insert h[where S=\"{}\"], force,<br>\n       insert h[where S =\"UNIV::nat set\"], force)</p>\n<p>In the form</p>\n<p>using facts by initial_method terminal_method</p>\n<p>the constituents of initial_method all see the facts, for \"force\" they are <br>\ninserted into the goal state before emarking on the automated proof <br>\nsearch.</p>\n<p>Note that a similar unwanted effect of duplicating irrelevant facts <br>\nhappens in the popular pattern</p>\n<p>using facts by (cases, auto)   -- BAD</p>\n<p>which is spelled out properly like this</p>\n<p>using facts by cases auto</p>\n<p>Here only the initial method is exposed to the original list of facts.  <br>\nAs you have noted, this canonical Isar step does not work equally well <br>\nwith multiple goal statements, though.</p>\n<blockquote>\n<p>In both proofs it seems that the first \"force\" neither fails nor <br>\nfinishes the goal, which disagrees with what the HOL tutorial says about <br>\n\"force\".</p>\n</blockquote>\n<p>The tutorial speaks about a single subgoal only, but here you have two of <br>\nthem.  The first force solves the first one, the second is remaining.</p>\n<blockquote>\n<p>Using patterns, we can slightly improve the first presentation<br>\nBut syntax</p>\n<p>lemma lemmaName:<br>\n   assumes h:<br>\n   \"!!(S::nat set) (s::nat).<br>\n      (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n      (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n   shows first:\"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n                      (is \"?fst\")<br>\n                -- \"  ^^^^^^^^^^^ \"<br>\n   and second:<br>\n     \"(ALL s. ((EX  z. P z s) --&gt; (EX z'. P' z' s))) | (ALL u. Req u)\"<br>\n                      (is \"?snd\")</p>\n<p>is rejected: \"Pattern match failed!\"</p>\n</blockquote>\n<p>This is because the pattern matches only object-logic statements (bool): <br>\nthe proposition ?fst is actually the term \"Trueprop ?fst\". To match <br>\nagainst a structured rule statement you need something like (is \"PROP <br>\n?fst\"); using that whole thing later will be a bit cumbersome, though.  <br>\nIn particular, show \"PROP ?fst\" is a bit flaky, bacause it does not <br>\nenforce unification of the premise part, only the conclusion.  In general <br>\nsub-structured</p>\n<p>show \"!!x. A x ==&gt; B x\"</p>\n<p>should be replaced by</p>\n<p>fix x<br>\n  assume A x<br>\n  show B x</p>\n<p>This means in the worst case one needs to introduce separate abbreviations <br>\nfor the premises and the conclusion, abstracted over the parameters.  It <br>\nis usually better to try hard writing the statement and proof in a way <br>\nthat avoids such term references altogether.</p>\n<blockquote>\n<p>Names: I guessed that one can name the two conclusions, \"first\" and <br>\n\"second\", but I guessed their top-level names would be \"lemmaName.first\" <br>\nand \"lemmaName.second\", while in fact their top-level names are \"first\" <br>\nand \"second\".  Any comment Makarius?</p>\n</blockquote>\n<p>Hard to say what is the form with least surprise.  Back then, when <br>\nintroducing this form of ``long'' statements I did not come up with the <br>\nidea of qualified names here.</p>\n<p>Anyway, you can approximate the desired effect by omitting \"first\" and <br>\n\"second\" and merely use lemmaName(1) and lemmaName(2) later.</p>\n<blockquote>\n<p>Finally, the following is also rejected:</p>\n<p>lemma <br>\n    assumes h:<br>\n    \"!!(S::nat set) (s::nat).<br>\n       (!!z. P' z s ==&gt; (Q' z t &amp; (Ball S Req))) ==&gt; <br>\n       (!!z. P z s ==&gt; (Q z t &amp; (Ball S Req)))\"<br>\n    shows \"(!!z. P' z s ==&gt; Q' z t) ==&gt; (!!z. P z s ==&gt; Q z t)\"<br>\n    using h[where S=\"{}\"] proof force<br>\n    show \"(ALL s. (EX z. P z s) --&gt; (EX z'. P' z' s)) | (ALL u. Req u)\"<br>\n      using h[where S =\"UNIV::nat set\"] by force</p>\n<p>*** empty result sequence -- proof command failed<br>\n*** At command \"proof\".</p>\n<p>I only removed the second goal from the statement of the lemma, and<br>\ntried to use the proof of the first goal that worked before.  Bug?</p>\n</blockquote>\n<p>As usual: whenever something fails to work but really should work, it is <br>\ndue to unexpectedly general typing.  With less text in the statement, the <br>\ninferred types can come out more general; and indeed the arguments of Q <br>\nnow get types of Pure's topsort {}, not HOL's \"type\" class.</p>\n<p>Makarius</p>",
        "id": 294063680,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824648
    }
]