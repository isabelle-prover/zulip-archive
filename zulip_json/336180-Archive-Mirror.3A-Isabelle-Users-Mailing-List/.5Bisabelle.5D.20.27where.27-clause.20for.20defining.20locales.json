[
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:rene.neumann@in.tum.de\">rene.neumann@in.tum.de</a>&gt;<br>\nDear all,</p>\n<p>given I have some locale foo with a myriad of parameters. Now I want to<br>\nextend this into a locale bar, which should add some parameters. Also<br>\n(for convenience) the new parameters should go to the end and the old<br>\norder of parameters should not change. In general such a thing is<br>\npossible with:</p>\n<p>locale bar = foo +<br>\n    fixes param_b1 :: \"'v =&gt; 's\"<br>\n    and param_b2 :: \"'v =&gt; 's =&gt; 's\"</p>\n<p>But, if I want to unify the types of foo and bar, I get a problem:</p>\n<p>locale bar = foo param_f1 param_f2<br>\n     for param_f1 and param_f2 :: \"'s =&gt; 'v\" +<br>\n     fixes param_b1 :: \"'v =&gt; 's\"<br>\n     and param_b2 :: \"'v =&gt; 's =&gt; 's\"</p>\n<p>This now has a different order of parameters:<br>\nparams_f3 … param_fn param_f1 param_f2 param_b1 param_b2</p>\n<p>The only way to keep the order is to list all n parameters in the<br>\nimport-part -- which quickly gets nasty, especially if you have a larger<br>\nlocale hierarchy.</p>\n<p>Are there any means to specify type signatures without changing the<br>\norder of arguments? Something along the lines of:</p>\n<p>locale bar = foo where param_f2 :: \"'v =&gt; 's\" +<br>\n       fixes ...</p>\n<p>(or, as 'where' is used for equations, other keywords like 'constraining')</p>\n<p>or using the record-way (though then the question arises on how to<br>\nspecify the order of the types in the annotation):</p>\n<p>locale bar = ('v,'s) foo +<br>\n     fixes ...</p>\n<p>Any hints are very much appreciated.</p>\n<p>Thanks,<br>\nRené</p>\n<p>P.S.: The same problem arises, when the only parameter using all<br>\nrelevant type variables is the very last one of the imported locale.<br>\n<a href=\"/user_uploads/14278/VfgIdRMrsI5Ri8Iut0bMRPJw/smime.p7s\">smime.p7s</a></p>",
        "id": 294279869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919987
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi René,</p>\n<p>IMHO you should consider one of these:<br>\na) What is the matter of your order?  To have uniform appearance of<br>\nlocale expressions?  In that case, you might consider specification of<br>\nparameters by <em>name</em>.  See the Isar reference manual for the syntactic<br>\ndetails.<br>\nb) If you really want to have structural control, consider grouping your<br>\nparameters to records.  HOL-Algebra is a nice example how this is<br>\naccomplished in practice.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/-384EBKYzr93ZI9pf6tiMtXS/signature.asc\">signature.asc</a></p>",
        "id": 294279971,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920012
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi René,</p>\n<p>there is the context element \"constrains\" that can achieve this to some extend. This works <br>\nbest if you constrain the types of all parameters of the imported locale that are <br>\naffected. Here's an example:</p>\n<p>locale l1 =<br>\n   fixes p1 :: 'b<br>\n   and p2 :: 'b<br>\n   and p3 :: 'a<br>\n   assumes \"p1 = p2\"</p>\n<p>locale l2 =<br>\n   l1<br>\n   +<br>\n   constrains p1 :: \"'c\"<br>\n   and p2 :: \"'c\"<br>\n   fixes p4 :: \"'c\"<br>\n   assumes \"p4 = p2\"</p>\n<blockquote>\n<p>P.S.: The same problem arises, when the only parameter using all<br>\nrelevant type variables is the very last one of the imported locale.<br>\nIn that case, there is a simple trick using the wildcard _ in the import expression. These <br>\nwildcards are treated like parameters not mentioned and are therefore added implicitly to <br>\nthe head of the for clause, as you desire.</p>\n</blockquote>\n<p>locale l3 = fixes p1 :: 'a and p2 :: 'b and p3 :: \"'a + 'b\"<br>\nlocale l4 = l3 _ _ p3<br>\n   for p3 :: \"'b + 'b\"<br>\n   +<br>\n   fixes p4 :: 'b</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294279985,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920019
    },
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:rene.neumann@in.tum.de\">rene.neumann@in.tum.de</a>&gt;<br>\nAm 30.06.2014 20:35, schrieb Florian Haftmann:</p>\n<blockquote>\n<p>Hi René,</p>\n<blockquote>\n<p>given I have some locale foo with a myriad of parameters. Now I<br>\nwant to extend this into a locale bar, which should add some<br>\nparameters. Also (for convenience) the new parameters should go<br>\nto the end and the old order of parameters should not change.</p>\n</blockquote>\n<p>IMHO you should consider one of these: a) What is the matter of<br>\nyour order?  To have uniform appearance of locale expressions?  In<br>\nthat case, you might consider specification of parameters by<br>\n<em>name</em>.  See the Isar reference manual for the syntactic details.</p>\n</blockquote>\n<p>Ah, I wasn't aware that I can also use the where-clause in locale<br>\nspecifications. This actually turns out to be (nearly) what I want: If<br>\none specifies the _last_ parameter with a 'where'-clause, also the<br>\norder is kept the same (of course, this is only useful when all<br>\nnecessary type variables are part of it):</p>\n<p>locale bar = foo<br>\n    where param_fn = param_fn<br>\n    for param_fn :: \"...\" +<br>\n    ...</p>\n<blockquote>\n<p>b) If you really want to have structural control, consider grouping<br>\nyour parameters to records.  HOL-Algebra is a nice example how this<br>\nis accomplished in practice.</p>\n</blockquote>\n<p>Our \"problem\" arose from the fact that we had to abolish our setup<br>\nwith records, as this gave rise to other problems with multiple<br>\ninheritance (if locale A specifies record rA<br>\nand locale B has record rB = rA + B_ext<br>\nand locale C has record rC = rA + C_ext<br>\nand I now want to have a locale BC which implements both B and C, I am<br>\nstuck, as I can't have a record rBC = rB + rC)</p>\n<blockquote>\n<p>Hope this helps,</p>\n</blockquote>\n<p>It did, thanks!</p>\n<ul>\n<li>René<br>\n<a href=\"/user_uploads/14278/V6JwrHfmlqcWbtdw_yXamWOU/smime.p7s\">smime.p7s</a></li>\n</ul>",
        "id": 294281757,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920594
    },
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:rene.neumann@in.tum.de\">rene.neumann@in.tum.de</a>&gt;<br>\nAm 30.06.2014 21:27, schrieb Andreas Lochbihler:</p>\n<blockquote>\n<p>Hi René,</p>\n<p>there is the context element \"constrains\" that can achieve this to some<br>\nextend. This works best if you constrain the types of all parameters of<br>\nthe imported locale that are affected. </p>\n</blockquote>\n<p>Unfortunately, all parameters are affected, so there is no gain here.<br>\nBut the 'constrains' provided the idea for the 'constraining'-thing in<br>\nmy email.</p>\n<p>(Also: 'constrains' is marked as deprecated, so I'd better avoid it in<br>\nnew developments)</p>\n<blockquote>\n<blockquote>\n<p>P.S.: The same problem arises, when the only parameter using all<br>\nrelevant type variables is the very last one of the imported locale.<br>\nIn that case, there is a simple trick using the wildcard _ in the import<br>\nexpression. These wildcards are treated like parameters not mentioned<br>\nand are therefore added implicitly to the head of the for clause, as you<br>\ndesire.</p>\n</blockquote>\n<p>locale l3 = fixes p1 :: 'a and p2 :: 'b and p3 :: \"'a + 'b\"<br>\nlocale l4 = l3 _ _ p3<br>\n  for p3 :: \"'b + 'b\"<br>\n  +<br>\n  fixes p4 :: 'b</p>\n</blockquote>\n<p>Ah, forgot about those.</p>\n<p>Thanks a lot,<br>\nRené<br>\n<a href=\"/user_uploads/14278/ITuwhaeQP8VBbFvFYTgrFVVm/smime.p7s\">smime.p7s</a></p>",
        "id": 294284092,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921275
    }
]