[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>I was porting some code from v2005 to v2007. I encountered just few<br>\nproblems, I'll describe one of them here, perhaps someone knows if this<br>\nbehaviour is intended:</p>\n<p>I have the following inductive set definitions:</p>\n<p>text {* Transitive reflexive closure of labelled transition system *}<br>\ninductive_set<br>\n  trcl :: \"('c<em>'a</em>'c) set \\&lt;Rightarrow&gt; ('c<em>'a list</em>'c) set\"<br>\n  for t<br>\n  where<br>\n  empty[simp]: \"(c,[],c) \\&lt;in&gt; trcl t\"<br>\n  | cons[simp]: \"\\&lt;lbrakk&gt; (c,a,c') \\&lt;in&gt; t; (c',w,c'') \\&lt;in&gt; trcl t<br>\n\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; (c,a#w,c'') \\&lt;in&gt; trcl t\"</p>\n<p>inductive_set<br>\n  foo :: \"(('c<em>'c)</em>'a<em>('c</em>'c)) set\"<br>\nwhere<br>\n  \"((s,c),a,(s,c'))\\&lt;in&gt;foo\"</p>\n<p>consts P :: \"'a \\&lt;Rightarrow&gt; bool\"</p>\n<p>inductive_set<br>\n  bar :: \"('c<em>'a list list</em>'c) set\"<br>\n  where<br>\n  \"\\&lt;lbrakk&gt;((s,c),a,(s',c'))\\&lt;in&gt;trcl foo; (s,w,s')\\&lt;in&gt;bar\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; (c,a#w,c')\\&lt;in&gt;bar\"</p>\n<p>foo and bar are just some artifical definitions, the point seems to be,<br>\nthat the definition of bar contains trcl applied to an LTS over <em>pairs</em>,<br>\nwhile trcl is defined over arbitrary states, not just pairs. The last<br>\ndefinition of bar creates strange induction, intro and elim theorems:<br>\nthm bar.intros<br>\n(* \\&lt;lbrakk&gt;((?s, ?c), ?a, ?s', ?c') \\&lt;in&gt; trcl {((xa, x), xd, xc, xb).<br>\n((xa, x), xd, xc, xb) \\&lt;in&gt; foo}; (?s, ?w, ?s') \\&lt;in&gt; bar\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; (?c, ?a # ?w, ?c') \\&lt;in&gt; bar*)</p>\n<p>The expression \"{((xa, x), xd, xc, xb). ((xa, x), xd, xc, xb) \\&lt;in&gt;<br>\nfoo}\" is obviously the same as just \"foo\", the simplifier knows that, too:</p>\n<p>thm bar.intros[simplified]<br>\n(* \\&lt;lbrakk&gt;((?s, ?c), ?a, ?s', ?c') \\&lt;in&gt; trcl foo; (?s, ?w, ?s') \\&lt;in&gt;<br>\nbar\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; (?c, ?a # ?w, ?c') \\&lt;in&gt; bar *)</p>\n<p>I would have expected the latter version of the theorems being generated<br>\n(as the old inductive package of v2005 did). My current workaround is to<br>\nuse the simplified attribute or some<br>\n    (simp)-steps where the altered definitions cause problems.</p>\n<p>My question is: Is this the intended behaviour ? If yes: Why? And can I<br>\nget it to generate the simplified lemmas?</p>\n<p>regards and thanks in advance for any hints<br>\n    Peter</p>",
        "id": 294053499,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820605
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nPeter Lammich wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I was porting some code from v2005 to v2007. I encountered just few<br>\nproblems, I'll describe one of them here, perhaps someone knows if this<br>\nbehaviour is intended:</p>\n<p>I have the following inductive set definitions: [...]</p>\n<p>foo and bar are just some artifical definitions, the point seems to be,<br>\nthat the definition of bar contains trcl applied to an LTS over <em>pairs</em>,<br>\nwhile trcl is defined over arbitrary states, not just pairs. The last<br>\ndefinition of bar creates strange induction, intro and elim theorems:<br>\nthm bar.intros<br>\n(* \\&lt;lbrakk&gt;((?s, ?c), ?a, ?s', ?c') \\&lt;in&gt; trcl {((xa, x), xd, xc, xb).<br>\n((xa, x), xd, xc, xb) \\&lt;in&gt; foo}; (?s, ?w, ?s') \\&lt;in&gt; bar\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; (?c, ?a # ?w, ?c') \\&lt;in&gt; bar*)</p>\n</blockquote>\n<p>Hi Peter,</p>\n<p>in Isabelle 2007, inductive_set is just a wrapper for the inductive<br>\ncommand, which now defines predicates rather than sets of n-tuples.<br>\nThis means that the introduction rules specified in an inductive_set<br>\ndefinition are translated to predicate notation internally. Then,<br>\nan inductive predicate is defined, and the resulting rules (introduction,<br>\nelimination, and induction) are translated back to set notation. In<br>\norder to translate a set of n-tuples to a predicate, its \"arity\" (i.e. the n)<br>\nhas to be inferred, which is done by inspecting the introduction rules.<br>\nUnfortunately, due to the encoding of tuples in Isabelle/HOL, it is<br>\nsometimes difficult to find out whether the user wanted to define a<br>\n5-ary relation, or a 3-ary relation, whose first and third component is<br>\na pair. In your example, Isabelle infers that the argument t of trcl has<br>\narity 3, whereas the inferred arity for foo is 5. More precisely, the<br>\nintroduction rules for the predicate trclp corresponding to the set trcl are</p>\n<p>trclp t c [] c<br>\n   [| t c a c'; trclp t c' w c'' |] ==&gt; trclp t c (a # w) c''</p>\n<p>and the introduction rule for the predicate foop corresponding to the<br>\nset foo is</p>\n<p>foop s c a s c'</p>\n<p>Due to this arity mismatch, the conversion back to set notation is only<br>\ndone in an incomplete way, which leads to the abovementioned \"strange\"<br>\nrules.</p>\n<blockquote>\n<p>The expression \"{((xa, x), xd, xc, xb). ((xa, x), xd, xc, xb) \\&lt;in&gt;<br>\nfoo}\" is obviously the same as just \"foo\", the simplifier knows that, too:</p>\n</blockquote>\n<p>I'll try to add the required simplification rules to the conversion function<br>\nin the development snapshot.<br>\nNote that this problem would not have occurred if you had defined foo as follows:</p>\n<p>inductive_set<br>\n     foo :: \"(('c<em>'c)</em>'a<em>('c</em>'c)) set\"<br>\n   where<br>\n     \"(sc,a,sc') : foo\"</p>\n<p>In this case, the arity inferred for foo is the same as the one inferred for<br>\nthe argument of trcl.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294053657,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820673
    }
]