[
    {
        "content": "<p>From: Miguel Pagano &lt;<a href=\"mailto:miguel.pagano@gmail.com\">miguel.pagano@gmail.com</a>&gt;<br>\nOn Fri, 1 May 2020 at 17:59, Miguel Pagano &lt;<a href=\"mailto:miguel.pagano@gmail.com\">miguel.pagano@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>On Fri, 1 May 2020 at 17:58, Richard Waldinger &lt;<a href=\"mailto:waldinger@ai.sri.com\">waldinger@ai.sri.com</a>&gt;<br>\nwrote:</p>\n<blockquote>\n<p>isn’t the “size” theorem true for any function, not just size?  or am i<br>\nmissing something?</p>\n<p>It shouldn't be true for non-injective functions.</p>\n</blockquote>\n<p>I'm embarrased, please discard my stupid answer.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>On May 1, 2020, at 1:51 PM, Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<blockquote>\n<p>Firstly, I don't think these theorem is especially useful. You might<br>\nhave planned to add this to the simplifier, but its term net doesn't do<br>\nany magic here. It will end up checking every term that matches \"Cons x<br>\nxs = ys\" for whether \"xs\" can match \"ys\". I'm not sure if that matching<br>\nis equality, alpha-equivalent or unifiable.</p>\n</blockquote>\n<p>I honestly never think /that/ much about the performance implications of<br>\nsimp rules (as long as they're unconditional). At least for lists, by<br>\nthe way, this is already a simp rule by default though, and lists are<br>\nprobably by far the most prevalent data type in the Isabelle universe.</p>\n<p>But you're certainly right that it would make sense to keep a look at<br>\nthis performance impact if one wanted to add these to the simp set for<br>\nall datatypes by default, and I agree that the rules are probably not<br>\nhelpful /that/ often. Still, it might be nice to have them available<br>\nnonetheless.</p>\n<blockquote>\n<p>Secondly, you can prove these theorems by using this handy trivial<br>\ntheorem : \"size x ~= size y ==&gt; x ~= y\". Apparently that theorem has<br>\nthe<br>\nname  Sledgehammer.size_ne_size_imp_ne - presumably the sledgehammer<br>\nuses it to prove such inequalities.</p>\n</blockquote>\n<p>It's even easier to prove it by induction. Plus, in fact, the \"size\"<br>\nthing only works if the data type even has a sensible size function.<br>\nThat is not always the case, e.g. when you nest the datatype through a<br>\nfunction.</p>\n<p>My main point however is that when you have a datatype with a dozen<br>\nbinary constructors, there's quite a bit of copying &amp; pasting involved<br>\nbefore you've proven all those theorems. Since it can (probably) be<br>\nautomated very easily, why not do that? Whether or not these should be<br>\nsimp lemmas by default is another question.</p>\n<p>Manuel</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294827752,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245258
    },
    {
        "content": "<p>From: Richard Waldinger &lt;<a href=\"mailto:waldinger@AI.SRI.COM\">waldinger@AI.SRI.COM</a>&gt;<br>\nisn’t the “size” theorem true for any function, not just size?  or am i missing something?</p>",
        "id": 294828837,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245651
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nYes, it is true for any function (even if it isn't injective, although<br>\nthen it's not an \"if-and-only-if\").</p>\n<p>The point is that if you actually want it to use this to prove that two<br>\nlists (or data type values in general) are not equal, you need to plug<br>\nin a concrete function f. And \"size\" happens to be one that is good for<br>\nthis particular case.</p>\n<p>Sometimes less general theorems can achieve more because they guide the<br>\nautomation more (and us humans, too!). That is particularly true for<br>\ninduction rules.</p>\n<p>Manuel</p>",
        "id": 294829004,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245718
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHey, don't worry about it. I had to think for a few seconds to be sure<br>\nmyself.</p>\n<p>A colleague of mine who shall not be named once spent an embarrassingly<br>\nlong time trying to prove that the \"fst\" function is injective. ;)</p>\n<p>Happens to all of us!</p>\n<p>Manuel</p>",
        "id": 294829133,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245786
    },
    {
        "content": "<p>From: Miguel Pagano &lt;<a href=\"mailto:miguel.pagano@gmail.com\">miguel.pagano@gmail.com</a>&gt;<br>\nOn Fri, 1 May 2020 at 17:58, Richard Waldinger &lt;<a href=\"mailto:waldinger@ai.sri.com\">waldinger@ai.sri.com</a>&gt; wrote:</p>\n<blockquote>\n<p>isn’t the “size” theorem true for any function, not just size?  or am i<br>\nmissing something?</p>\n<p>It shouldn't be true for non-injective functions.</p>\n</blockquote>\n<blockquote>\n<p>On May 1, 2020, at 1:51 PM, Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<blockquote>\n<p>Firstly, I don't think these theorem is especially useful. You might<br>\nhave planned to add this to the simplifier, but its term net doesn't do<br>\nany magic here. It will end up checking every term that matches \"Cons x<br>\nxs = ys\" for whether \"xs\" can match \"ys\". I'm not sure if that matching<br>\nis equality, alpha-equivalent or unifiable.</p>\n</blockquote>\n<p>I honestly never think /that/ much about the performance implications of<br>\nsimp rules (as long as they're unconditional). At least for lists, by<br>\nthe way, this is already a simp rule by default though, and lists are<br>\nprobably by far the most prevalent data type in the Isabelle universe.</p>\n<p>But you're certainly right that it would make sense to keep a look at<br>\nthis performance impact if one wanted to add these to the simp set for<br>\nall datatypes by default, and I agree that the rules are probably not<br>\nhelpful /that/ often. Still, it might be nice to have them available<br>\nnonetheless.</p>\n<blockquote>\n<p>Secondly, you can prove these theorems by using this handy trivial<br>\ntheorem : \"size x ~= size y ==&gt; x ~= y\". Apparently that theorem has the<br>\nname  Sledgehammer.size_ne_size_imp_ne - presumably the sledgehammer<br>\nuses it to prove such inequalities.</p>\n</blockquote>\n<p>It's even easier to prove it by induction. Plus, in fact, the \"size\"<br>\nthing only works if the data type even has a sensible size function.<br>\nThat is not always the case, e.g. when you nest the datatype through a<br>\nfunction.</p>\n<p>My main point however is that when you have a datatype with a dozen<br>\nbinary constructors, there's quite a bit of copying &amp; pasting involved<br>\nbefore you've proven all those theorems. Since it can (probably) be<br>\nautomated very easily, why not do that? Whether or not these should be<br>\nsimp lemmas by default is another question.</p>\n<p>Manuel</p>\n</blockquote>\n</blockquote>",
        "id": 294829415,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245921
    }
]