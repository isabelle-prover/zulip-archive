[
    {
        "content": "<p>From: <a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a><br>\nNo sure what happened to the quoting in my email client, sorry. This is the relevant part:</p>\n<blockquote>\n<p>Can you point to the sources of a few such big record definitions?</p>\n</blockquote>\n<p>They get produced by the C parser, e.g. at this call:</p>\n<p><a href=\"https://github.com/seL4/l4v/blob/3d225cde694ba60a/spec/cspec/X64/Kernel_C.thy#L78\">https://github.com/seL4/l4v/blob/3d225cde694ba60a/spec/cspec/X64/Kernel_C.thy#L78</a></p>\n<p>The record becomes large, because Norbert's SIMPL framework expects one record field per local variable in the union of all functions of the program. The final state record is an extension of a default state record + these local variables.</p>\n<p>We could synthesise a manual definition that simulates this situation if it helps.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294727347,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186824
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 15/02/18 00:46, <a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a> wrote:</p>\n<blockquote>\n<blockquote>\n<p>Can you point to the sources of a few such big record definitions?</p>\n</blockquote>\n<p>They get produced by the C parser, e.g. at this call:</p>\n<p><a href=\"https://github.com/seL4/l4v/blob/3d225cde694ba60a/spec/cspec/X64/Kernel_C.thy#L78\">https://github.com/seL4/l4v/blob/3d225cde694ba60a/spec/cspec/X64/Kernel_C.thy#L78</a></p>\n<p>The record becomes large, because Norbert's SIMPL framework expects one record field per local variable in the union of all functions of the program. The final state record is an extension of a default state record + these local variables.<br>\n</p>\n</blockquote>\n<p>I now recall that Norbert Schirmer made the first major scalability<br>\nchanges for the record package.</p>\n<p>Earlier it was actually based on datatypes, since I did not want to<br>\nfiddle with typedefs manually, but that was very slow (as expected).</p>\n<blockquote>\n<p>We could synthesise a manual definition that simulates this situation if it helps.</p>\n</blockquote>\n<p>For the moment it is sufficient to get an idea about:</p>\n<p>(1) typical number of record fields<br>\n  (2) typical number of record extensions (i.e. the depth of the hierarchy)</p>\n<p>Makarius</p>",
        "id": 294727409,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186838
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThomas Bauereiß from Peter Sewell's group in Cambridge sent me his experience <br>\nwith the record package:</p>\n<p>\"I have not really had major problems with records so far.  I'm currently <br>\nworking on the translation of specifications of Instruction Set Architectures of <br>\nprocessors from a language called Sail to Isabelle (via Lem). The Sail language <br>\n(<a href=\"https://github.com/rems-project/sail\">https://github.com/rems-project/sail</a>) supports user-defined record types, and <br>\nthe translation generates a few (e.g. for processor register state), but most of <br>\nthe records I've seen in the specs we have are rather small.  There are just a <br>\nfew cases where the size becomes mildly annoying.  For example, the record that <br>\nwe generate for the register state of the ARMv8 spec has ~120 fields, which <br>\ntakes ~20s to process on my machine, and we have another ISA spec (not public) <br>\nwhere the register state record has ~300 fields, and this takes a few minutes to <br>\nparse.  I wouldn't say this is a major problem, though, as these record types do <br>\nnot change very often, so we can put them into a separate theory and build a <br>\nheap image.</p>\n<p>Our main concern at the moment is scalability, I would say.  Whatever record <br>\npackage we use, it should be able to handle records with possibly hundreds of <br>\nfields.\"</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/thq-iVLrcwpAHsbDL7udISKs/smime.p7s\">smime.p7s</a></p>",
        "id": 294727801,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186972
    },
    {
        "content": "<p>From: <a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a><br>\nTom has answered most of it already, the short version:</p>\n<blockquote>\n<blockquote>\n<p>We could synthesise a manual definition that simulates this situation if it helps.</p>\n</blockquote>\n<p>For the moment it is sufficient to get an idea about:</p>\n<p>(1) typical number of record fields</p>\n</blockquote>\n<p>700 to about 1000</p>\n<blockquote>\n<p>(2) typical number of record extensions (i.e. the depth of the hierarchy)</p>\n</blockquote>\n<p>The large records are not extended, but there are a few smaller ones. I don’t think we have more than a depth of 2 extensions anywhere.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294727899,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187001
    }
]