[
    {
        "content": "<p>From: 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt;<br>\nDear Sirs/Madams,</p>\n<p>My name is Yuki Goto and I am a graduate school student in Kwansei Gakuin University in Japan.<br>\nThe reason why I am writing this email to you is I'd like to ask some questions about Isabelle/hol.</p>\n<p>datatype<br>\n  char = A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z |Dot</p>\n<p>type_synonym str = \"char list\"</p>\n<p>fun str_eq :: \"str =&gt; str =&gt; bool\" where<br>\n\"str_eq [] _ = True\" |<br>\n\"str_eq _ [] = True\" |<br>\n\"str_eq (x#xs) (y#ys) = ( (x=y) &amp; (str_eq xs ys))\"</p>\n<p>fun simp_hd_eq :: \"str list =&gt; str =&gt; bool\" where<br>\n\"simp_hd_eq [] y = False\" |<br>\n\"simp_hd_eq (x#xs) y = (if (str_eq x y) then True else (simp_hd_eq xs y) )\"</p>\n<p>lemma simp_add_nq : \"(simp_hd_eq xs y) = False &amp; (simp_hd_eq ys y) = False ==&gt; (simp_hd_eq (xs @ ys) y) = False\"</p>\n<p>This is the first question and I cannot prove this lemma.<br>\nProbably I think that I am self-evident, how can you prove it?</p>\n<p>lemma simp_hd_eq_app[simp] : \"(simp_hd_eq xs y) = True ==&gt; (simp_hd_eq (xs @ ys) y) = True\"<br>\napply simp</p>\n<p>When I was going to carry out \"apply simp\" in this \"lemma\", the second question is why \"Proof General\" freezes.<br>\nCan you shed any light on this?<br>\nIn addition, I want to know whether Isabelle/hol is suitable for \"String\" and whether there is an example using \"String\".<br>\nI wish to thank you in advance for answering these questions,</p>\n<p>Sincerely,</p>\n<p>Yuki Goto</p>\n<hr>\n<p>Yuki Goto<br>\nInformation Technology Major<br>\nKwansei Gakuin University<br>\nHyogo, Japan<br>\nE-mail: <a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a></p>\n<hr>",
        "id": 294162805,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853764
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Thu, Jun 28, 2012 at 3:38 AM, 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>datatype<br>\n char = A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z |Dot</p>\n<p>type_synonym str = \"char list\"</p>\n<p>fun simp_hd_eq :: \"str list =&gt; str =&gt; bool\" where<br>\n\"simp_hd_eq [] y = False\" |<br>\n\"simp_hd_eq (x#xs) y = (if (str_eq x y) then True else (simp_hd_eq xs y) )\"</p>\n<p>lemma simp_add_nq : \"(simp_hd_eq xs y) = False &amp; (simp_hd_eq ys y) = False ==&gt; (simp_hd_eq (xs @ ys) y) = False\"</p>\n<p>This is the first question and I cannot prove this lemma.<br>\nProbably I think that I am self-evident, how can you prove it?</p>\n</blockquote>\n<p>This lemma cannot be proved by simplification alone; it requires<br>\ninduction: \"apply (induct xs) apply auto\" should do it.</p>\n<blockquote>\n<p>lemma simp_hd_eq_app[simp] : \"(simp_hd_eq xs y) = True ==&gt; (simp_hd_eq (xs @ ys) y) = True\"<br>\napply simp</p>\n</blockquote>\n<p>\"apply (induct xs) apply auto\" should work here too.</p>\n<blockquote>\n<p>When I was going to carry out \"apply simp\" in this \"lemma\", the second question is why \"Proof General\" freezes.<br>\nCan you shed any light on this?</p>\n</blockquote>\n<p>It doesn't freeze for me. You might try turning off \"auto quickcheck\"<br>\nor similar tools if they are enabled.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294162818,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853769
    },
    {
        "content": "<p>From: 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt;<br>\nDear Mr. Huffman,</p>\n<p>Thank you very much for your help. <br>\nThe cause of the \"simp freeze\" seemed to be \"lemma\" before it.<br>\nThis later proof was proved by a method according to advice well</p>\n<p>Causative \"lemma\" is the following thing.</p>\n<p>lemma app_test_n[simp] : <br>\n\"~ ( (simp_hd_eq xs y) = True |  (simp_hd_eq ys y) = True ) <br>\n==&gt; ((simp_hd_eq xs y) = False) &amp; ( (simp_hd_eq ys y) = False) \"<br>\napply simp<br>\ndone</p>\n<p>I think that \"lemma\" which caused it cannot be established.<br>\nIn spite of it, the proof is completed.<br>\nWhich point will it be if caused by a definition of \"simp_hd_eq\"?</p>\n<p>It would be nice if you could reply.</p>\n<p>Yuki Goto</p>\n<hr>\n<p>Yuki Goto<br>\nInformation Technology Major<br>\nKwansei Gakuin University<br>\nHyogo, Japan<br>\nE-mail: <a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a></p>\n<hr>\n<p>On Thu, Jun 28, 2012 at 3:38 AM, 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>datatype<br>\n char = A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z |Dot</p>\n<p>type_synonym str = \"char list\"</p>\n<p>fun simp_hd_eq :: \"str list =&gt; str =&gt; bool\" where<br>\n\"simp_hd_eq [] y = False\" |<br>\n\"simp_hd_eq (x#xs) y = (if (str_eq x y) then True else (simp_hd_eq xs y) )\"</p>\n<p>lemma simp_add_nq : \"(simp_hd_eq xs y) = False &amp; (simp_hd_eq ys y) = False ==&gt; (simp_hd_eq (xs @ ys) y) = False\"</p>\n<p>This is the first question and I cannot prove this lemma.<br>\nProbably I think that I am self-evident, how can you prove it?</p>\n</blockquote>\n<p>This lemma cannot be proved by simplification alone; it requires<br>\ninduction: \"apply (induct xs) apply auto\" should do it.</p>\n<blockquote>\n<p>lemma simp_hd_eq_app[simp] : \"(simp_hd_eq xs y) = True ==&gt; (simp_hd_eq (xs @ ys) y) = True\"<br>\napply simp</p>\n</blockquote>\n<p>\"apply (induct xs) apply auto\" should work here too.</p>\n<blockquote>\n<p>When I was going to carry out \"apply simp\" in this \"lemma\", the second question is why \"Proof General\" freezes.<br>\nCan you shed any light on this?</p>\n</blockquote>\n<p>It doesn't freeze for me. You might try turning off \"auto quickcheck\"<br>\nor similar tools if they are enabled.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294163173,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853940
    },
    {
        "content": "<p>From: 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt;<br>\nI am sorry for the delay in my response.<br>\nI am grateful for all the help you game me while we were try to fix the issue.</p>\n<p>I ask you a question about proof of \"'a list list\" this time.<br>\nI want to prove that there is not overlap even if I append it in each top on the list when \"'a list list\" does not have overlap.</p>\n<p>fun prefix_app :: \"'a list list =&gt; 'a list =&gt; 'a list list\" where<br>\n\"prefix_app [] y = []\" |<br>\n\"prefix_app xs [] = xs\" |<br>\n\"prefix_app (x#xs) y =  (y @ x) # (prefix_app xs y)\"</p>\n<p>lemma \"(distinct xs) ==&gt; (distinct (prefix_app xs y))\"<br>\napply (induct_tac y)</p>\n<p>It does not occur to a proof method of this lemma.<br>\nIf there is a solution, would you teach it?</p>\n<p>Yuki</p>\n<hr>\n<p>Yuki Goto<br>\nInformation Technology Major<br>\nKwansei Gakuin University<br>\nHyogo, Japan<br>\nE-mail: <a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a></p>\n<hr>",
        "id": 294216839,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895354
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nI would probably proceed by proving that</p>\n<p>\"prefix_app xs y = map (%z. y @ z) xs\"</p>\n<p>holds and that \"%z. y @ z\" is injective. Then the proposition follows<br>\nfrom List.distinct_map.</p>\n<p>-- Lars</p>",
        "id": 294217010,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895444
    },
    {
        "content": "<p>From: 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt;<br>\nThank you for an answer.</p>\n<p>According to the indication,</p>\n<p>definition<br>\n\"prefix_app xs y = map (%x. y @ x) xs\"</p>\n<p>lemma \"(distinct xs) ==&gt; (distinct (prefix_app xs y))\"<br>\nunfolding prefix_app_def by (auto simp add: distinct_map inj_on_def)</p>\n<p>by the above, I was able to solve a problem.</p>\n<p>It is the question about applying \"map\" to \"Datatype\" definition this time.</p>\n<p>datatype<br>\n  char = A | B | C | D | E | F</p>\n<p>type_synonym str = \"char list\"</p>\n<p>type_synonym FileName = str<br>\ndatatype Gvar = GV Type str<br>\ntype_synonym GvarList = \"Gvar list\"</p>\n<p>type_synonym Prog = \"(FileName * GvarList * Funcs * Main)\"</p>\n<p>fun gvar_changename :: \"Prog =&gt;GvarList =&gt; GvarList\" where<br>\n\"gvar_changebname pr1 xs = map (%(GV x y). (GV x (fst pr1)@y)) xs\"</p>\n<p>It is the expansion of having had you teach it, but this \"fun\" is displayed with \"Syntax error\".<br>\nWhy will you be?<br>\nPlease reply it if possible.</p>\n<p>\"Funcs\" and \"Main\" define it at other places, but do not use it here.</p>\n<hr>\n<p>Yuki Goto<br>\nInformation Technology Major<br>\nKwansei Gakuin University<br>\nHyogo, Japan<br>\nE-mail: <a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a></p>\n<hr>",
        "id": 294218053,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896001
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Goto-san,</p>\n<p>On 07/28/2012 12:30 PM, 後藤　裕貴 wrote:</p>\n<blockquote>\n<p>It is the question about applying \"map\" to \"Datatype\" definition this time.</p>\n<p>datatype<br>\n   char = A | B | C | D | E | F</p>\n<p>type_synonym str = \"char list\"</p>\n<p>type_synonym FileName = str<br>\ndatatype Gvar = GV Type str<br>\nHere Type is not defined. so I use</p>\n</blockquote>\n<p>datatype Gvar = GV str</p>\n<p>instead.</p>\n<blockquote>\n<p>type_synonym GvarList = \"Gvar list\"</p>\n<p>type_synonym Prog = \"(FileName * GvarList * Funcs * Main)\"<br>\nHere I just removed Funcs and Main, i.e.,</p>\n</blockquote>\n<p>type_synonym Prog = \"(FileName * GvarList)\"</p>\n<p>Now your function-definition still results in a syntax error.</p>\n<blockquote>\n<p>fun gvar_changename :: \"Prog =&gt;GvarList =&gt; GvarList\" where<br>\n\"gvar_changebname pr1 xs = map (%(GV x y). (GV x (fst pr1)@y)) xs\"<br>\nThe point is that pattern matching does not work in general as part of<br>\nlambda abstractions (only for special cases, like pairs). So you have to<br>\nuse a case-expression, e.g., as follows:</p>\n</blockquote>\n<p>fun gvar_changename :: \"Prog =&gt; GvarList =&gt; GvarList\" where<br>\n    \"gvar_changename pr1 xs =<br>\n      map (%x. case x of GV y =&gt; GV (fst pr1 @ y)) xs\"</p>\n<p>(Also note that the paranthesization in your original definition is not<br>\nright, it should be \"GV x (fst pr1 @ y)\"; and you have to use the same<br>\nname for your function at every occurrence, cf. \"gvar_changename\" vs.<br>\n\"gvar_changebname\".)</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294218115,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896007
    },
    {
        "content": "<p>From: 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt;<br>\nThank you for an answer.</p>\n<p>According to the indication,</p>\n<p>fun gvar_changename :: \"Prog =&gt; GvarList =&gt; GvarList\" where<br>\n\"gvar_changename pr1 xs = map (%x. case x of GV a b =&gt; GV a (fst pr1 @ b)) xs\"</p>\n<p>by the above, I was able to describe a definition without a problem.</p>\n<p>However, in proof, a problem happened.</p>\n<p>lemma pre_lim_gl:<br>\n\"(distinct (Prog_GvarList pr2)) ==&gt; (distinct (gvar_changename pr2 (Prog_GvarList pr2)))\"<br>\nthm gvar_changename.simps<br>\nunfolding gvar_changename.simps<br>\napply (simp add:distinct_map)<br>\napply (simp add:inj_on_def)</p>\n<p>\"case\" emerged in subgoal, and proof did not advance.<br>\nI think that I asked you a question many times that I am sorry, but please instruct it.</p>\n<p>&gt;</p>\n<p>datatype  Type = PInt | PDouble</p>\n<p>datatype<br>\n  char = A | B | C | D | E | F</p>\n<p>type_synonym str = \"char list\"</p>\n<p>type_synonym FileName = str<br>\ndatatype Gvar = GV Type str<br>\ntype_synonym GvarList = \"Gvar list\"</p>\n<p>type_synonym Prog = \"(FileName * GvarList * Funcs * Main)\"</p>\n<p>\"Funcs\" and \"Main\" , define it at other places, but do not use it here.</p>\n<p>Yuki</p>\n<hr>\n<p>Yuki Goto<br>\nInformation Technology Major<br>\nKwansei Gakuin University<br>\nHyogo, Japan<br>\nE-mail: <a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a></p>\n<hr>",
        "id": 294218474,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896174
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nI think that the problem is that your lemma \"app_test_n\" has been<br>\ndeclared [simp]. This rule is looping the simplifier (causing it to do<br>\nbusy-work with no progress). Note that Isabelle making no progress is<br>\ndifferent to Proof General crashing. You can probably still interrupt<br>\nIsabelle and carry on.</p>\n<p>When rules of the form \"P ==&gt; Q &amp; R\" are added with [simp], the<br>\nsimplifier sees that as a recipe for showing Q or R by attempting to<br>\nshow P. In your case, Q == R and P can be simplified back to Q, which<br>\ncan then be attempted with the rule again, thus the loop. Care needs to<br>\nbe taken when adding \"conditional rewrite rules\" of the form \"P ==&gt; Q\"<br>\nto the simplifier.</p>\n<p>In this case, what was the point? Why make this a [simp] rule when the<br>\nsimplifier knows how to show this anyway?</p>\n<p>Yours,<br>\nThomas.</p>",
        "id": 294218949,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896400
    },
    {
        "content": "<p>From: 後藤　裕貴 &lt;<a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a>&gt;<br>\nIt was a question of the other day, but was settled by oneself by using \"case_tac\".<br>\nI am sorry if I had you already reply it.<br>\nI will keep trying my best.</p>\n<hr>\n<p>Yuki Goto<br>\nInformation Technology Major<br>\nKwansei Gakuin University<br>\nHyogo, Japan<br>\nE-mail: <a href=\"mailto:auf75646@kwansei.ac.jp\">auf75646@kwansei.ac.jp</a></p>\n<hr>\n<blockquote>\n<p>lemma pre_lim_gl:<br>\n\"(distinct (Prog_GvarList pr2)) ==&gt; (distinct (gvar_changename pr2 (Prog_GvarList pr2)))\"<br>\nthm gvar_changename.simps<br>\nunfolding gvar_changename.simps<br>\napply (simp add:distinct_map)<br>\napply (simp add:inj_on_def)</p>\n</blockquote>\n<blockquote>\n<p>\"case\" emerged in subgoal, and proof did not advance.<br>\nI think that I asked you a question many times that I am sorry, but please instruct it.</p>\n</blockquote>\n<blockquote>\n<p>datatype  Type = PInt | PDouble</p>\n</blockquote>\n<blockquote>\n<p>datatype<br>\nchar = A | B | C | D | E | F</p>\n</blockquote>\n<blockquote>\n<p>type_synonym str = \"char list\"</p>\n</blockquote>\n<blockquote>\n<p>type_synonym FileName = str<br>\ndatatype Gvar = GV Type str<br>\ntype_synonym GvarList = \"Gvar list\"</p>\n</blockquote>\n<blockquote>\n<p>type_synonym Prog = \"(FileName * GvarList * Funcs * Main)\"</p>\n</blockquote>\n<blockquote>\n<p>\"Funcs\" and \"Main\" , define it at other places, but do not use it here.</p>\n</blockquote>\n<blockquote>\n<p>Yuki</p>\n</blockquote>",
        "id": 294221339,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897659
    }
]