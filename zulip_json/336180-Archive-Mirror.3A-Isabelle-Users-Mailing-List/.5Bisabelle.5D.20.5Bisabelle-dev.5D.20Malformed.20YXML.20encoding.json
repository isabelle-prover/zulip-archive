[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 26 Aug 2011, Steve Wong wrote:</p>\n<blockquote>\n<p>I'm trying to generate a proof goal from string using the following:</p>\n</blockquote>\n<p>I am answering this on isabelle-users, because it is a perfectly normal <br>\nuser question.  (Using ML alone does not mean it is relevant for <br>\nisabelle-dev.)</p>\n<blockquote>\n<p>fun generate x lthy =<br>\n   let<br>\n       val thy = Local_Theory.exit_global lthy<br>\n       val ctxt = ProofContext.init_global thy<br>\n   in</p>\n</blockquote>\n<p>This is a bit odd.  You can use lthy, which is called \"auxiliary context\" <br>\nin local theory parlance directly as your context for the subsequent <br>\noperations.  A lthy: local_theory is a semantic subtype of ctxt: <br>\nProof.context, and the lthy naming convention is used whenever actual <br>\nlocal theory operations follow, like the subsequent <br>\nSpecification.theorem_cmd.</p>\n<blockquote>\n<p>(Specification.theorem_cmd<br>\n            Thm.lemmaK NONE (K I)<br>\n            (<a href=\"http://Binding.name\">Binding.name</a> \"\", []) []</p>\n<p>(Element.Shows [(Attrib.empty_binding,<br>\n                             [(Syntax.string_of_term ctxt @{term \"F\"} ^ \" =<br>\n\" ^<br>\n                               Syntax.string_of_term ctxt @{term \"G\"}</p>\n<p>, [])])]) x lthy)<br>\n   end</p>\n</blockquote>\n<blockquote>\n<p>*** Malformed YXML encoding: multiple results<br>\n*** At command \"verify_with\"</p>\n</blockquote>\n<p>Syntax.string_of_term turns internal formal entities (terms) into external <br>\ntext representation for user-consumption.  For historic reasons the string <br>\ntype is used here, but it is in fact some kind of quasi-abstract datatype <br>\nfor marked-up document content.  In general it is not allowed either to <br>\nsplit text input that is passed in or paste together text that is passed <br>\nout of the formal environment.</p>\n<p>Working with string interfaces for formal entities was never robust, even <br>\n20 years ago, but now the fragility has become immediately apparent. <br>\nWhen \"generating\" things, you should always use the regular non-text <br>\nversions of tools and packages.  (Sometines people forget to provide them, <br>\nbut for almost everything in the regular Isabelle distribution there is <br>\nsuch a proper non-text version, taking directly typ and term values etc.)</p>\n<p>Anyway, instead of Specification.theorem it is probably easier to use <br>\nProof.theorem, although you need to store the result yourself in the <br>\n\"after_qed\" continuation.</p>\n<p>Makarius</p>",
        "id": 294143047,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846543
    },
    {
        "content": "<p>From: Steve Wong &lt;<a href=\"mailto:s.wong.731@gmail.com\">s.wong.731@gmail.com</a>&gt;<br>\nOn Fri, Aug 26, 2011 at 12:26 PM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>On Fri, 26 Aug 2011, Steve Wong wrote:</p>\n<p>Syntax.string_of_term turns internal formal entities (terms) into external<br>\ntext representation for user-consumption.  For historic reasons the string<br>\ntype is used here, but it is in fact some kind of quasi-abstract datatype<br>\nfor marked-up document content.  In general it is not allowed either to<br>\nsplit text input that is passed in or paste together text that is passed out<br>\nof the formal environment.</p>\n<p>Working with string interfaces for formal entities was never robust, even<br>\n20 years ago, but now the fragility has become immediately apparent. When<br>\n\"generating\" things, you should always use the regular non-text versions of<br>\ntools and packages.  (Sometines people forget to provide them, but for<br>\nalmost everything in the regular Isabelle distribution there is such a<br>\nproper non-text version, taking directly typ and term values etc.)</p>\n<p>Anyway, instead of Specification.theorem it is probably easier to use<br>\nProof.theorem, although you need to store the result yourself in the<br>\n\"after_qed\" continuation.</p>\n<p>Thanks a lot for that. So, which are the tools recommended for constructing<br>\nnew terms (based on some existing terms)? Are you referring to functions<br>\nlike dest_Free in term.ML, i.e. destruct a term into parts and then create a<br>\nnew term from ground up?</p>\n</blockquote>\n<p>Thanks again.</p>\n<p>Steve</p>\n<blockquote>\n<p>Makarius</p>\n</blockquote>",
        "id": 294143074,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846555
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nEither using directly the datype constructors of typ/term (e.g. in pattern <br>\nmatching) or some derived functions from src/Pure/term.ML, <br>\nsrc/Pure/logic.ML, src/HOL/Tools/hologic.ML.</p>\n<p>The \"tools and packages\" that I mentioned above are more complex things <br>\nlike Function_Fun.add_fun (the regular ML version) instead of the <br>\nadd_fun_cmd as string version for end-users.</p>\n<p>Makarius</p>",
        "id": 294143316,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846629
    }
]