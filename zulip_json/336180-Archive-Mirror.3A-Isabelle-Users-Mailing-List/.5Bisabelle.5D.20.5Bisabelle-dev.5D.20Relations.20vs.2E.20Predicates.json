[
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Thu, Mar 22, 2012 at 9:26 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>currently there are two constants</p>\n<p>op ^ Â :: \"'b =&gt; nat =&gt; 'b\"<br>\nop ^^ :: \"'b =&gt; nat =&gt; 'b\"</p>\n<p>making it a bit difficult for the user to choose the correct one in all<br>\nsituations. As far as I see \"op ^^\" is just syntax for the overloaded<br>\n\"compow\". Shouldn't it be possible to unify this (and also relpow) by using<br>\nadhoc overloading, so that only one operator, e.g., \"op ^\" remains?</p>\n</blockquote>\n<p>Hi Chris,</p>\n<p>I assume that by \"currently\", you refer to Isabelle 2011-1. I am<br>\ntherefore replying to the isabelle-users list.</p>\n<p>Here's why \"op ^\" and \"op ^^\" are separate constants since 2009-1: \"op<br>\n^^\" is an ad hoc overloaded function, with a separate definition for<br>\neach type instance. On the other hand, \"op ^\" has a single generic<br>\ndefinition:</p>\n<p>\"a ^ 0 = 1\"<br>\n\"a ^ Suc n = a * a ^ n\"</p>\n<p>Having a single generic definition for \"op ^\" makes it possible to<br>\nprove generic lemmas about exponents, which are applicable to<br>\narbitrary rings and semirings.</p>\n<blockquote>\n<p>To come back to the subject, I'm missing \"iteration\" of predicates, i.e.,<br>\nwhat \"_^^n\" is on relations but for predicates (\"'a =&gt; 'a =&gt; bool\"). (Why<br>\nare predicates \"less developed\" than relations anyway?)</p>\n</blockquote>\n<p>I think this is historical. Before the big set/predicate merge<br>\nexperiment started in Isabelle 2008, predicates were not supported<br>\nvery well by either the libraries or the definition tools (e.g.<br>\n\"inductive\" could only be used to define sets, not predicates).<br>\nSupport for predicates has steadily improved since, and I see no<br>\nreason why we couldn't add \"op ^^\" for predicates now; I guess you're<br>\nthe first to ask for it.</p>\n<ul>\n<li>Brian</li>\n</ul>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<p>PS: I suggest to rename \"rel_comp\" into \"relcomp\" (to be consistent with<br>\n\"relpow\"). In @{theory Relation} there is a typo in the lemma name<br>\n\"prod_comp_bot1\".</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailmanbroy.informatik.tu-muenchen.de/mailman/listinfo/isabelle-dev\">https://mailmanbroy.informatik.tu-muenchen.de/mailman/listinfo/isabelle-dev</a></p>\n</blockquote>",
        "id": 294154044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850451
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nOn 03/22/2012 06:42 PM, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Thu, Mar 22, 2012 at 9:26 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;  wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>currently there are two constants</p>\n<p>op ^  :: \"'b =&gt;  nat =&gt;  'b\"<br>\nop ^^ :: \"'b =&gt;  nat =&gt;  'b\"</p>\n<p>making it a bit difficult for the user to choose the correct one in all<br>\nsituations. As far as I see \"op ^^\" is just syntax for the overloaded<br>\n\"compow\". Shouldn't it be possible to unify this (and also relpow) by using<br>\nadhoc overloading, so that only one operator, e.g., \"op ^\" remains?</p>\n</blockquote>\n<p>Hi Chris,</p>\n<p>I assume that by \"currently\", you refer to Isabelle 2011-1. I am<br>\ntherefore replying to the isabelle-users list.<br>\nThanks,</p>\n</blockquote>\n<p>actually I was talking about the development version (hence the dev <br>\nlist) but the situation is essentially the same in Isabelle2011-1 I <br>\nguess. By \"adhoc overloading\" I was referring to the theory <br>\nAdhoc_Overloading (e.g., used for do-notation) which could (I think) be <br>\nused to unify the syntax (independently from what you said about generic <br>\nlemmas) of funpow, relpow, compow, and what is more.</p>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<p>Here's why \"op ^\" and \"op ^^\" are separate constants since 2009-1: \"op<br>\n^^\" is an ad hoc overloaded function, with a separate definition for<br>\neach type instance. On the other hand, \"op ^\" has a single generic<br>\ndefinition:</p>\n<p>\"a ^ 0 = 1\"<br>\n\"a ^ Suc n = a * a ^ n\"</p>\n<p>Having a single generic definition for \"op ^\" makes it possible to<br>\nprove generic lemmas about exponents, which are applicable to<br>\narbitrary rings and semirings.</p>\n<blockquote>\n<p>To come back to the subject, I'm missing \"iteration\" of predicates, i.e.,<br>\nwhat \"_^^n\" is on relations but for predicates (\"'a =&gt;  'a =&gt;  bool\"). (Why<br>\nare predicates \"less developed\" than relations anyway?)</p>\n</blockquote>\n<p>I think this is historical. Before the big set/predicate merge<br>\nexperiment started in Isabelle 2008, predicates were not supported<br>\nvery well by either the libraries or the definition tools (e.g.<br>\n\"inductive\" could only be used to define sets, not predicates).<br>\nSupport for predicates has steadily improved since, and I see no<br>\nreason why we couldn't add \"op ^^\" for predicates now; I guess you're<br>\nthe first to ask for it.</p>\n<ul>\n<li>Brian</li>\n</ul>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<p>PS: I suggest to rename \"rel_comp\" into \"relcomp\" (to be consistent with<br>\n\"relpow\"). In @{theory Relation} there is a typo in the lemma name<br>\n\"prod_comp_bot1\".</p>\n<hr>\n<p>isabelle-dev mailing list<br>\n<a href=\"mailto:isabelle-dev@in.tum.de\">isabelle-dev@in.tum.de</a><br>\n<a href=\"https://mailmanbroy.informatik.tu-muenchen.de/mailman/listinfo/isabelle-dev\">https://mailmanbroy.informatik.tu-muenchen.de/mailman/listinfo/isabelle-dev</a></p>\n</blockquote>\n</blockquote>",
        "id": 294154057,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850457
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<p>this won't work: Adhoc_Overloading can only disambiguate disjoint type<br>\nsignatures (neglecting sort constraints).  But the generic power operation</p>\n<p>nat =&gt; 'a =&gt; 'a</p>\n<p>and the set-relational one</p>\n<p>nat =&gt; 'a set =&gt; 'a set</p>\n<p>do overlap (subst 'a := 'a set).</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/AKKDU-g_YWixUp_VRvaLS5ke/signature.asc\">signature.asc</a></p>",
        "id": 294154409,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850623
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nI think this isn't quite accurate.</p>\n<p>IIRC, Adhoc_Overloading does respect sort constraints as expected, since <br>\nit runs in tandem with the normal type inference.</p>\n<p>So the approach suggested by Chris could in fact work, with the effect that</p>\n<ul>\n<li>\n<p>\"op ^ :: 'nat =&gt; ('a * 'a) set =&gt; ('a * 'a) set\" would become \"relpow\"</p>\n</li>\n<li>\n<p>\"op ^ :: 'nat =&gt; 'a::power =&gt; 'a::power\" would become \"power\"</p>\n</li>\n<li>\n<p>\"op ^ :: nat =&gt; 'a =&gt; 'a =&gt; 'a =&gt; 'a\" would become \"funpow\"</p>\n</li>\n<li>\n<p>\"op ^ :: nat =&gt; 'a =&gt; 'a\" without further constraints would be <br>\nambiguous and generate an error during the term check phase.</p>\n</li>\n<li>\n<p>compow would disappear and the (few) facts about it would be <br>\nduplicated for the two instances funpow and relpow.</p>\n</li>\n</ul>\n<p>This effectively moves the existing ad-hoc oveloading from the logic <br>\nback into the syntax layer, where it can now be handled rather smoothly. <br>\nThe good thing would be that there is just one power operation (if we <br>\nforget about the reals for the moment :-) )</p>\n<p>When introducing Adhoc_Overloading, I was aware of this possibility, but <br>\nI hesitated, because</p>\n<ul>\n<li>\n<p>Throwing more code into HOL-Main needs great care, especially when <br>\nsyntax is involved.</p>\n</li>\n<li>\n<p>The whole check/uncheck business is highly non-compositional. When <br>\nmaking Adhoc_Overloading part of HOL-Main, we would have to make sure <br>\nthat it coexists nicely with other extensions, such as the class-related <br>\ntype refinement, or coercive subtyping. I am sure there are a number of <br>\nunforeseen effects hidden here.</p>\n</li>\n<li>\n<p>...and actually, the current situation is not too bad.</p>\n</li>\n</ul>\n<p>Alex</p>",
        "id": 294154423,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850628
    }
]