[
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nHi Moez,</p>\n<p>Moez A. Abdel-Gawad writes:</p>\n<blockquote>\n<p>However, my own personal attempt to prove the substitution<br>\nlemma in Coq - with very minor resort to the variable con-<br>\nvention and alpha-conversion equivalence - seemed to tell<br>\nthat the substitution lemma may not be the best example to<br>\nuse for <em>motivating</em> the need for the 'isabelle-nominal'<br>\npackage and project, as is done for example on this web-<br>\npage <a href=\"http://isabelle.in.tum.de/nominal/main.html\">http://isabelle.in.tum.de/nominal/main.html</a></p>\n</blockquote>\n<p>I agree: The substitution lemma is not the most exciting <br>\nproof to formalise. On the other hand, it is very small<br>\nand everyone knows about it and about the issues. I like <br>\nit, since one can explain the nominal Isar-proof of this <br>\nlemma in 5 minutes to people who never have touched a <br>\ntheorem prover in their lives. That is why I presented it <br>\non the nominal web-page.</p>\n<blockquote>\n<p>While I do not discount the possibility of the package<br>\nbeing useful - and even necessary - for other proofs, my<br>\nexperiment gave me the feeling that a much simpler app-<br>\nroach may be possible (may be even as simple as adding a<br>\nnew tactic), which may work in fact for many similar pr-<br>\noofs as well, and - if not - is very likely to work at<br>\nleast for the purpose of proving the substitution lemma.</p>\n</blockquote>\n<p>Would you mind sharing your proof? In the experience I obtained<br>\nwith the nominal package is that the techniques (strong<br>\ninduction principles) which we use to prove the substitution<br>\nlemma have proved most valuable in all formalisations we did <br>\nso far. Nowadays I would refuse to do any formalisation, if <br>\nI did not have them. </p>\n<blockquote>\n<p>PS: I was wondering if there is a Coq package and/or<br>\nproject similar to the 'isabelle-nominal' ones.</p>\n</blockquote>\n<p>There is </p>\n<p>B. Aydemir, A. Bohannon and S. Weirich, Nominal Reasoning <br>\n  Techniques in Coq. In Proc. of LFMTP 2006</p>\n<p>and Xavier Leroy used some lightweight nominal techniques<br>\nin his solution of the PoplMark-challenge. </p>\n<p>Best wishes,<br>\nChristian</p>",
        "id": 294052785,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820278
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nDear Moez,</p>\n<p>Moez A. Abdel-Gawad writes:</p>\n<blockquote>\n<p>First, I would think thus that something simpler than the new nom-<br>\ninal-isabelle constructs (nominal_datatype, nominal_induction,<br>\navoiding, fresh_fact, forget, etc) maybe more intuitive, and also<br>\nmore straight-forward to add (to Isabelle, or other semi-automated<br>\ntheorem provers). </p>\n</blockquote>\n<p>I completely agree with your view that matters with formalising<br>\nthe lambda-calculus <em>should</em> be simple, but I often found that<br>\nthey aren't.</p>\n<blockquote>\n<p>Next, I also concluded that the substitution lemma, even though<br>\nwell-known to many PL researchers, may NOT be a very convincing<br>\nexample to cite (eg, on the webpage) for developing the new 'nom-<br>\ninal-isabelle' package. </p>\n</blockquote>\n<p>I am open for your suggestions! However it seems you have inadvertently<br>\ngiven a good reason that it <em>is</em> a good example. </p>\n<p>My Coq-abilities are not very good, but reading</p>\n<blockquote>\n<p>Require Import String.</p>\n<p>Inductive LCterm: Set :=<br>\n  | Var : string -&gt; LCterm<br>\n  | Abs:  string -&gt; LCterm -&gt; LCterm<br>\n  | App: LCterm -&gt; LCterm -&gt; LCterm.</p>\n<p>Require Import Ensembles.</p>\n<p>Fixpoint FV(t: LCterm): Ensemble string :=<br>\n  match t with<br>\n    | Var x =&gt; Singleton string x<br>\n    | Abs x t1 =&gt; Subtract string (FV t1) x<br>\n    | App t1 t2 =&gt; Union string (FV t1) (FV t2)<br>\n  end.<br>\n...</p>\n</blockquote>\n<blockquote>\n<p>Fixpoint subs(x: string) (t: LCterm) (t': LCterm){struct t}: LCterm :=<br>\n  match t with<br>\n    | Var y =&gt; if string_dec y x then t' else t<br>\n    | Abs y t1 =&gt; if string_dec y x then t else Abs y (subs x t1 t')<br>\n    | App t1 t2 =&gt; App (subs x t1 t') (subs x t2 t')<br>\n  end.</p>\n</blockquote>\n<p>you defined <em>possibly-capturing</em> substitution , namely</p>\n<p>(Var y)[x:=t] = (if x=y then t else (Var y))<br>\n  (Abs y t1)[x:=t] = (if x=y then (Abs y t1) else (Abs y (t1[x:=t]))) <br>\n  (App t1 t2)[x:=t] = App (t1[x:=t]) (t2[x:=t])</p>\n<p>In the second clause you will capture any free occurrence of y <br>\nin t by moving the substitution under the binder. </p>\n<p>If I am not mistaken and you indeed defined possibly-capturing <br>\nsubstitution and also used a concrete representation of lambda-terms, <br>\nthen your substitution lemma</p>\n<blockquote>\n<p>Lemma subs_lemma: forall x y: string, forall M N L: LCterm,<br>\n  x &lt;&gt;y -&gt; ~ In string (FV L) x -&gt;<br>\n  subs y (subs x M N) L = subs x (subs y M L) (subs y N L).</p>\n</blockquote>\n<p>is not true. James Cheney just did a few calculations and found <br>\nthe following counter-example</p>\n<p>(Abs y (Var x))[x:=y][y:=z]  &lt;&gt; (Abs y (Var x))[y:=z][x:=y[y:=z]]</p>\n<p>Disregarding this counter-example, the point of the substitution<br>\nlemma is, however, to show this property for capture-avoiding <br>\nsubstitution. The trouble then starts: your substitution<br>\noperation needs a precondition (I am not sure whether one can<br>\nstate such a precondition of in Coq) or one needs to do a renaming <br>\n(I am also not sure how to define this cleanly in Coq). Also, if <br>\nyou insist on a concrete representation, you need to state it not <br>\nas an equality, but an <em>alpha-equivalence</em>. You would also need<br>\nto define this in Coq.   </p>\n<p>Best wishes,<br>\nChristian</p>",
        "id": 294052853,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820293
    }
]