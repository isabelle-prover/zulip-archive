[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThese slightly odd \"atomize\" and \"rulify\" things are mainly for internal <br>\nuse of tools to make them work on regular rule statements given by the <br>\nuser. When you write statements yourself, you normally do it the way it <br>\nworks best for you from the start.  Then you don't need to apply <br>\natomize/rulify at all.</p>\n<p>With a little bit of practice, it is easy to know what is best: usually an <br>\nopen rule-format that can be applied readily later on.</p>\n<p>This practice is a bit like currying in functional programming: looks odd <br>\nto totally new users, but is fairly natural after getting used to it.</p>\n<p>Makarius</p>",
        "id": 294634656,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159643
    },
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;<br>\n(1) I am having trouble understanding why Isar permits both \\forall <br>\nand \\And, seeing that they appear to do exactly the same thing. I <br>\nunderstand that \\And is for the statement of a theorem or lemma, and <br>\nis not supposed to be used in a proof. But what would happen if we <br>\nused \\forall in the statement of a lemma, rather than \\And? How would <br>\nthis affect the rest of the proof?<br>\n(2) Am I to understand that, just as \\And is the universal quantifier <br>\nat the meta-level, \\Or is the existential quantifier at the <br>\nmeta-level? Certainly \\Or x. P(x) appears to do the same thing as <br>\n\\exists x. P(x) . Further confusing me here is that a number of <br>\nexample Isar proof statements do use \\exists instead of \\Or, such as <br>\nlemma assumes Pf: \"\\exists x. P(f x)\" shows \"\\exists y. P y\" (p. 10 <br>\nof \"A Tutorial Introduction To Structured Isar Proofs\").<br>\n(3) In Whats In Main, under Orderings, under Syntax, there is given <br>\nsome syntax for \\forall and for \\exists, such as \\forall x \\leq y. P <br>\n\\equiv \\forall x. x \\leq y --&gt; P . There are eight rules given here, <br>\nfour for \\forall and four for \\exists . Do these rules also work for <br>\n\\And and \\Or ?<br>\n(4) Am I understanding correctly that \\And applied to the null set is <br>\nTrue, while \\Or applied to the null set is False?</p>",
        "id": 294637941,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160932
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 07.04.2015 05:27, W. Douglas Maurer wrote:</p>\n<blockquote>\n<p>(1) I am having trouble understanding why Isar permits both \\forall and<br>\n\\And, seeing that they appear to do exactly the same thing. I understand<br>\nthat \\And is for the statement of a theorem or lemma, and is not<br>\nsupposed to be used in a proof. But what would happen if we used \\forall<br>\nin the statement of a lemma, rather than \\And? How would this affect the<br>\nrest of the proof?</p>\n</blockquote>\n<p>The short answer is: Isabelle cannot reason about the HOL quantifiers<br>\n(and boolean connectives) directly, only by referring to their<br>\ncharacterisation in terms of the Pure (ore meta) counterparts &lt;\\And&gt; and<br>\n\\&lt;Longrightarrow&gt;.</p>\n<p>So for lemmas you want to use into a proof (as opposed to maybe the<br>\nfinal theorem of a large development, which should just read nice),<br>\nyou express it in terms of the meta operations as much as possible.<br>\nOtherwise, you can expect a lot of manual fiddling around, bringing the<br>\ntheorem into a useful shape everytime you use it (although this depends<br>\non the tools you use: metis for example doesn't care at all).</p>\n<p>Some background:</p>\n<p>In a way, \\&lt;And&gt; is an artifact of Isabelle's Design. Isabelle was<br>\ndesigned as a generic theorem prover which one can use to formalise and<br>\nreason in various logics.</p>\n<p>As such, Isabelle's kernel knows how to reason about a few primitive<br>\nconstants, namely:</p>\n<p>Pure.all :: ('a =&gt; prop) =&gt; prop (written as \\&lt;And&gt;)<br>\n  Pure.imp :: prop =&gt; prop =&gt; prop (written as \\&lt;Longrightarrow&gt;)</p>\n<p>We can use this logical framework (also refered to as Isabelle/Pure)<br>\nto formalise a logic (e.g. HOL) by declaring new constants and adding<br>\nrules (made from the primitive constants) as axioms (this is called an<br>\n\"object logic\" in Isabelle's notation). So implementing a new logic in<br>\nIsabelle does not involve writing code or changing the kernel, but just<br>\nwriting a few rules in the logical framework.</p>\n<p>Now, Isabelle/HOL has its own variants of the above operators,</p>\n<p>HOL.All :: ('a =&gt; bool) =&gt; bool (written as \\&lt;forall&gt;)<br>\n  HOL.implies :: bool =&gt; bool =&gt; bool (written as \\&lt;longrightarrow&gt;)</p>\n<p>Note the different types and that bool and prop are not isomorphic (as<br>\nIsabelle/Pure does not have the law of the exluced middle).</p>\n<blockquote>\n<p>(2) Am I to understand that, just as \\And is the universal quantifier at<br>\nthe meta-level, \\Or is the existential quantifier at the meta-level?</p>\n</blockquote>\n<p>There is no existential quantifier at the meta level. I'm not sure,<br>\nwhere \\&lt;Or&gt; comes from (I don't have a current Isabelle at hand, at the<br>\nmoment), but \\&lt;exists&gt; is the common way to write an existential in<br>\nIsabell/HOL.</p>\n<blockquote>\n<p>(3) In Whats In Main, under Orderings, under Syntax, there is given some<br>\nsyntax for \\forall and for \\exists, such as \\forall x \\leq y. P \\equiv<br>\n\\forall x. x \\leq y --&gt; P . There are eight rules given here, four for<br>\n\\forall and four for \\exists . Do these rules also work for \\And and \\Or ?</p>\n</blockquote>\n<p>There is no such syntax for \\&lt;And&gt;.</p>\n<blockquote>\n<p>(4) Am I understanding correctly that \\And applied to the null set is<br>\nTrue, while \\Or applied to the null set is False?</p>\n</blockquote>\n<p>As HOL types are never empty, \\&lt;And&gt; can never be applied \"to the null<br>\nset\". If you talk about \"\\&lt;forall&gt; x \\&lt;in&gt; S. P x\", yes, this is true if<br>\nS is empty.</p>\n<p>-- Lars</p>",
        "id": 294637947,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160937
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou should not think of !! as the same as ALL, and ==&gt; as the same as<br>\n--&gt; etc.</p>\n<p>Just a few notes on this, to overcome common misunderstandings.</p>\n<ul>\n<li>\n<p>Isabelle/Pure is minimal higher-order logic with connectives !! and ==&gt;<br>\n   used to describe natural deduction rules declaratively.  The<br>\n   Isabelle/Isar proof languages uses the same rule format to produce<br>\n   structured proofs.  These concepts are integral to Isabelle, and big<br>\n   assets of its approach; schematic variables also belong here.</p>\n</li>\n<li>\n<p>Isabelle/HOL is full higher-order logic with the whole zoo of<br>\n   connectives (ALL, EX, --&gt;, &lt;--&gt;, ~ etc.) and much more, to work with<br>\n   applications.  HOL statements may occur in Pure rules naturally.</p>\n</li>\n<li>\n<p>The view of Pure as \"meta-logic\" and HOL as \"object-logic\" is OK in the<br>\n   historical understanding of Isabelle as \"logical framework\" to declare<br>\n   other logics, but it has little practical relevance today.</p>\n</li>\n<li>\n<p>The view of Pure as \"rule framework for structured reasoning\" is very<br>\n   relevant today.  It is the canonical way how I usually explain that to<br>\n   beginners.</p>\n<p>Makarius</p>\n</li>\n</ul>",
        "id": 294637970,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160943
    },
    {
        "content": "<p>From: Andrew Gacek &lt;<a href=\"mailto:andrew.gacek@gmail.com\">andrew.gacek@gmail.com</a>&gt;<br>\nHow do schematic variables relate to \\And quantified variables? I know<br>\nthat sometimes I need to use 'case' and sometimes 'case_tac' for<br>\nexample, but it's not clear to me why I can't freely move a variable<br>\nfrom being \\And quantified to being schematic and vice-versa.</p>\n<p>-Andrew</p>",
        "id": 294638138,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160998
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 7 Apr 2015, Andrew Gacek wrote:</p>\n<blockquote>\n<p>How do schematic variables relate to \\And quantified variables?</p>\n</blockquote>\n<p>The Pure quantifier !!x. B x provides a local context to B x inside the <br>\nlanguage of propositions. When you positively establish !!x. B x as a <br>\nfact, the system puts it into a standard form B ?x with schematic x. There <br>\nis normally no choice here: if facts with outermost !!x. B x persist, <br>\nsomething is usually wrong somewhere.</p>\n<p>Negatively, on the assumption side, the !! quantier is not optional, <br>\naccording to how the logic works.</p>\n<blockquote>\n<p>but it's not clear to me why I can't freely move a variable <br>\nfrom being \\And quantified to being schematic and vice-versa.</p>\n</blockquote>\n<p>To develop an intuition about quantifier scoping rules, I recommend to <br>\nprove or disprove propositions involving ALL and --&gt; in FOL or HOL (!) and <br>\nlet \"blast\" or \"iprover\" or something else work on that.  Then you <br>\ntransfer the results mentally to !! and ==&gt; in Pure.</p>\n<blockquote>\n<p>I know that sometimes I need to use 'case' and sometimes 'case_tac' for <br>\nexample</p>\n</blockquote>\n<p>That is a slightly different situation.  If you have a subgoal with local <br>\n!! quantification, these goal parameters are not part of the proof <br>\ncontext, so you can't refer to them directly.</p>\n<p>Nonetheless case_tac and friends do that unofficially, and until <br>\nIsabelle2014 in a rather messy way. In Isabelle2015 this will be much <br>\nbetter, with extra colors to indicate the hidden goal scope that is <br>\ninvolved here.</p>\n<p>As part of the Eisbach project, these old dark corners of the system have <br>\nbecome a bit lighter, and we might even get rid of rule_tac, case_tac etc. <br>\neventually. They are stemming from very ancient times, before the proof <br>\ncontext was fully understood.</p>\n<p>Makarius</p>",
        "id": 294638150,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161004
    },
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;<br>\nIt looks as though you can always use lemma atomize_all to go back <br>\nand forth between !! (that is, \\And) and ALL, so you can use <br>\nwhichever one you need:<br>\nlemma atomize_all [atomize]: (!!x. P x) == Trueprop (ALL x. P x )<br>\nproof assume !!x. P x then show ALL x. P x ..<br>\nnext assume ALL x. P x then show !!x. P x by (rule allE) qed<br>\n(section 2.2.17 of \"Isabelle/HOL --- Higher-Order Logic\")</p>\n<p>-Douglas</p>",
        "id": 294638174,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161016
    }
]