[
    {
        "content": "<p>From: Wim Vanhoof &lt;<a href=\"mailto:wva@info.fundp.ac.be\">wva@info.fundp.ac.be</a>&gt;<br>\n(apologies for multiple postings)</p>\n<hr>\n<p>The University of Namur, Belgium, is seeking a young researcher<br>\n(no PhD) for a 1 year research project entitled</p>\n<p>\"Automatic program analysis for refactoring logic programs\".</p>\n<p>A short description follows. Interested candidates should send their CV <br>\nbefore September 15, 2008 to Wim Vanhoof (<a href=\"mailto:wva@info.fundp.ac.be\">wva@info.fundp.ac.be</a>).</p>\n<hr>\n<p>Program refactoring [3] is the process of systematically changing the <br>\nstructure of a<br>\nprogram without changing its semantics. The goal of refactoring is to <br>\nimprove the design<br>\nof the code after it has been written, in order to facilitate <br>\nmaintenance (including further<br>\ndevelopment) of the software. Emerged from the OO and XP communities, <br>\nprogram<br>\nrefactoring has recently gained attention in the fields of functional <br>\n[8] and logic<br>\nprogramming [11]. Within the software engineering community, the process of<br>\nrefactoring is considered important and has been identified as central <br>\nto software<br>\ndevelopment and maintenance [3].</p>\n<p>At the basis of the refactoring process is a catalogue of available <br>\nsource-to-source<br>\ntransformations - the so-called refactorings. For each refactoring, a <br>\nset of conditions is<br>\nspecified under which the transformation is correct in the sense that it <br>\npreserves the<br>\nsemantics of the program. The activity of refactoring consists then in <br>\nrepeatedly searching<br>\nthrough the source code, looking for a code fragment of which the design <br>\ncould be<br>\nimproved by a particular refactoring from the catalogue. The refactoring <br>\nis subsequently<br>\napplied, and the whole process is repeated. Although each transformation <br>\ncan have an<br>\nimpact (positive or negative) on the performance of the program, the <br>\nprimary aim of each<br>\ntransformation is to improve the readability and maintainability of the <br>\ncode.<br>\nEven if refactoring is basically a manual process that is performed by <br>\nthe programmer, the<br>\nneed for automation is recognized due to the time-consuming and <br>\nerror-prone nature of<br>\nthe refactoring activity [3, 8, 10]. Although tools do exist that aid <br>\nthe developer with<br>\nperforming a particular refactoring on a selected fragment of source <br>\ncode - an example<br>\nbeing the Refactoring Browser that was developed for Smalltalk [10] - <br>\nidentifying where<br>\nto perform (a particular) refactoring in the code remains essentially a <br>\nnon-trivial, creative<br>\nand therefore manual process.</p>\n<p>Although a substantial number of different refactorings has been <br>\nidentified in the<br>\nliterature, the primary indication for where to perform refactoring <br>\nseems to be the<br>\npresence of duplicated code [3]. The notion of duplicated code is not <br>\nlimited to literally<br>\ncopied code, but refers to fragments of code that have the same <br>\ninput/output behaviour.<br>\nThe goal of refactoring is then to transform the source code in such a <br>\nway that the<br>\nduplication is removed. This generally requires to extract the <br>\nduplicated input/output<br>\nbehaviour into a new subroutine (be it a method, function or predicate), <br>\nwhich may<br>\nrequire a generalisation of the concerned code fragments and a possible <br>\nreorganisation of<br>\nthe code as a whole [3, 11].</p>\n<p>Code duplication can be caused by a number of reasons. First of all, <br>\nunfamiliarity of the<br>\ndeveloper with the existing code body may result in reimplementation of <br>\nroutines that<br>\nalready exist in the application under development. Second, the “copy <br>\nand paste”<br>\ntechnique is commonly used when the existing functionality has to be <br>\nslightly adapted.<br>\nEven if in this case one usually does not end up literally duplicating <br>\ninput/output<br>\nbehaviour, the changes introduced by adaptation are usually relatively <br>\nminor and a<br>\ngeneralization of the original and the adapted fragments could be often <br>\nproposed. Finally,<br>\ncode duplication might result from a polyvariant program analysis.</p>\n<p>The problem of deciding whether two code fragments implement the same <br>\nfunctionality is<br>\nwell-known to be undecidable. Nevertheless, automatic program analysis <br>\ntechniques have<br>\nbeen developed, notably in the context of imperative and object-oriented <br>\nlanguages, that<br>\nare capable to detect such equivalence under particular circumstances <br>\nand within a certain<br>\nerror margin, e.g. [1, 5, 6, 7, 9]. Also related is the work on <br>\nplagiarism detection for<br>\nprograms written in such languages, e.g. [4, 14, 13].</p>\n<p>In this project, we will investigate the automatic detection of <br>\nduplicated code in<br>\ndeclarative programming languages, in particular logic programming <br>\nlanguages such as<br>\nProlog and Mercury. Declarative languages allow the developer to program <br>\nat a much<br>\nhigher level of abstraction than it is the case with most imperative <br>\nlanguages. In a<br>\ndeclarative language, one describes properties of the desired solution <br>\nrather than the<br>\nactual algorithm that should be used to find the solution.</p>\n<p>We aim to develop an analysis that allows to find, without user <br>\nintervention, duplicated<br>\ncode fragments into a logic program and we will study if and how the <br>\nresults of this<br>\nanalysis can be used to drive a number of refactorings to remove the <br>\nunwanted<br>\nduplication from the program. These refactorings include predicate <br>\nextraction (replacing<br>\nduplicated code fragments by a call to a newly defined predicate), the <br>\nremoval of<br>\npredicates implementing the same relation as another predicate and the <br>\ngeneralization of<br>\nduplicated code fragments into calls to newly generated higher-order <br>\npredicate [11, 12].<br>\nThe development of such a duplicated code analysis for logic programs, <br>\nand its<br>\nintegration with refactoring, presents some interesting research <br>\nopportunities. Firstly, the<br>\ndeclarative nature of logic programs makes it not straightforward to <br>\nadapt the methods<br>\ndeveloped in an imperative (or object-oriented) setting. Secondly, the <br>\nfact that logic<br>\nprograms have a small and formally well-defined semantics and use an <br>\nexplicit symbolic<br>\ndata representation makes the use of advanced analyses possible. <br>\nTherefore it might well<br>\nbe possible to obtain more fine-grained results than is the case for <br>\nimperative languages.<br>\nFinally, it might be worthwhile to investigate how the developed <br>\nanalysis could be used in<br>\nthe context of plagiarism detection for logic programs.</p>\n<p>References</p>\n<hr>\n<p>[1] B. S. Baker. On finding duplication and near-duplication in large <br>\nsoftware systems. In Proc. Second<br>\nIEEE Working Conference on Reverse Engineering, pages 86-95, July 1995.<br>\n[2] F. Degrave and W. Vanhoof. Towards a normal form for Mercury <br>\nprograms. In A. King, ed. LOPSTR<br>\n2007, volume 4915 of Lecture notes in computer science, pages 43-58. <br>\nSpringer-Verlag, 2007.<br>\n[3] M. Fowler, K. Beck, J. Brant, W. Opdyke, and D. Roberts. Refactoring <br>\n: Improving the Design of<br>\nExisting Code. Object Technology Series. Addison-Wesley, 1999.<br>\n[4] S. Horwitz. Identifying the semantic and textual differences between <br>\ntwo versions of a program. ACM<br>\nSIGPLAN Notices, 25(6) :234-245, 1990.<br>\n[5] T. Kamiya, S. Kusumoto, and K. Inoue. Ccfinder : A multilinguistic <br>\ntoken-based code clone detection<br>\nsystem for large scale source code. IEEE Trans. Software Eng., 28(7): <br>\n654-670, 2002.<br>\n[6] R. Komondoor and S. Horwitz. Using slicing to identify duplication <br>\nin source code. In Static Analysis<br>\nSymposium, pages 40-56, 2001.<br>\n[7] K. Kontogiannis, R. de Mori, E. Merlo, M. Galler, and M. Bernstein. <br>\nPattern matching for clone and<br>\nconcept detection. Autom. Softw. Eng., 3(1/2) :77-108, 1996.<br>\n[8] H. Li, C. Reinke, and S. Thompson. Tool support for refactoring <br>\nfunctional programs. In J. Jeuring,<br>\neditor, ACM SIGPLAN 2003 Haskell Workshop. ACM 2003.<br>\n[9] J. Mayrand, C. Leblanc, and E. Merlo. Experiment on the automatic <br>\ndetection of function clones in a<br>\nsoftware system using metrics. In Intl. Conf. on Software Maintenance, <br>\npages 244-253, 1996.<br>\n[10] D. Roberts, J. Brant, and R. E. Johnson. A refactoring tool for <br>\nSmalltalk. Theory and Practice of Object<br>\nSystems (TAPOS), 3(4) :253-263, 1997.<br>\n[11] A. Serebrenik, T. Schrijvers and B. Demoen. Improving Prolog <br>\nprograms: Refactoring for Prolog.<br>\nTheory and practice of logic programming (Accepted) 2008.<br>\n[12] W. Vanhoof. Searching semantically equivalent code fragments in <br>\nlogic programs. In S. Etalle, editor,<br>\nLOPSTR 2004, volume 3573 of Lecture notes in computer science, pages <br>\n1-18. Springer-Verlag, 2005.<br>\n[13] J. Winstead and D. Evans. Towards differential program analysis. In <br>\nProceedings of the 2003<br>\nWorkshop on Dynamic Analysis, 2003.<br>\n[14] W. Yang. Identifying syntactic differences between two programs. <br>\nSoftware Practice and Experience,<br>\n21(7): 739-755, 1991.</p>",
        "id": 294064666,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825021
    }
]