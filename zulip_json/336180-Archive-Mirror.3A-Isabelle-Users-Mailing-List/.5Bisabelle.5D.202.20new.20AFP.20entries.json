[
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\n[http://afp.sourceforge.net/entries/Refine_Monadic.shtml]<br>\nRefinement for Monadic Programs<br>\nby Peter Lammich</p>\n<p>Abstract:<br>\nWe provide a framework for program and data refinement in Isabelle/HOL. The framework is based on a nondeterminism-monad with assertions, i.e., the monad carries a set of results or an assertion failure. Recursion is expressed by fixed points. For convenience, we also provide while and foreach combinators.</p>\n<p>The framework provides tools to automatize canonical tasks, such as verification condition generation, finding appropriate data refinement relations, and refine an executable program to a form that is accepted by the Isabelle/HOL code generator.</p>\n<p>This submission comes with a collection of examples and a user-guide, illustrating the usage of the framework.</p>\n<p>[http://afp.sourceforge.net/entries/Dijkstra_Shortest_Path.shtml]<br>\nDijkstra's Shortest Path Algorithm<br>\nby Benedikt Nordhoff and Peter Lammich</p>\n<p>Abstract:<br>\nWe implement and prove correct Dijkstra's algorithm for the single source shortest path problem, conceived in 1956 by E. Dijkstra. The algorithm is implemented using the data refinement framework for monadic, nondeterministic programs. An efficient implementation is derived using data structures from the Isabelle Collection Framework.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294151858,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849591
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nTwo new AFP entries are available from [http://afp.sf.net]:</p>\n<p>Gödel's Incompleteness Theorems<br>\nby Larry Paulson</p>\n<p>Gödel's two incompleteness theorems are formalised, following a careful presentation by Swierczkowski, in the theory of hereditarily finite sets. This represents the first ever machine-assisted proof of the second incompleteness theorem. Compared with traditional formalisations using Peano arithmetic (see e.g. Boolos), coding is simpler, with no need to formalise the notion of multiplication (let alone that of a prime number) in the formalised calculus upon which the theorem is based. However, other technical problems had to be solved in order to complete the argument.</p>\n<p>The Hereditarily Finite Sets<br>\nby Larry Paulson</p>\n<p>The theory of hereditarily finite sets is formalised, following the development of Swierczkowski. An HF set is a finite collection of other HF sets; they enjoy an induction principle and satisfy all the axioms of ZF set theory apart from the axiom of infinity, which is negated. All constructions that are possible in ZF set theory (Cartesian products, disjoint sums, natural numbers, functions) without using infinite sets are possible here. The definition of addition for the HF sets follows Kirby. This development forms the foundation for the Isabelle proof of Gödel's incompleteness theorems, which has been formalised separately.</p>\n<p>Enjoy,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294255212,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912325
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nTransitive closure according to Roy-Floyd-Warshall<br>\nby Makarius Wenzel</p>\n<p>This formulation of the Roy-Floyd-Warshall algorithm for the<br>\ntransitive closure bypasses matrices and arrays, but uses a more direct<br>\nmathematical model with adjacency functions for immediate predecessors and<br>\nsuccessors. This can be implemented efficiently in functional programming<br>\nlanguages and is particularly adequate for sparse relations.</p>\n<p>[http://afp.sf.net/entries/Roy_Floyd_Warshall.shtml]</p>\n<p>Noninterference Security in Communicating Sequential Processes<br>\nby Pasquale Noce</p>\n<p>An extension of classical noninterference security for deterministic<br>\nstate machines, as introduced by Goguen and Meseguer and elegantly<br>\nformalized by Rushby, to nondeterministic systems should satisfy two<br>\nfundamental requirements: it should be based on a mathematically precise<br>\ntheory of nondeterminism, and should be equivalent to (or at least not<br>\nweaker than) the classical notion in the degenerate deterministic case.</p>\n<p>This paper proposes a definition of noninterference security applying<br>\nto Hoare's Communicating Sequential Processes (CSP) in the general case of<br>\na possibly intransitive noninterference policy, and proves the<br>\nequivalence of this security property to classical noninterference<br>\nsecurity for processes representing deterministic state machines.</p>\n<p>Furthermore, McCullough's generalized noninterference security is shown<br>\nto be weaker than both the proposed notion of CSP noninterference security<br>\nfor a generic process, and classical noninterference security for processes<br>\nrepresenting deterministic state machines. This renders CSP noninterference<br>\nsecurity preferable as an extension of classical noninterference security<br>\nto nondeterministic systems.</p>\n<p>[http://afp.sf.net/entries/Noninterference_CSP.shtml]</p>\n<p>Enjoy!<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294278636,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919607
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nRelaxing Safely: Verified On-the-Fly Garbage Collection for x86-TSO<br>\nby Peter Gammie, Tony Hosking, and Kai Engelhardt</p>\n<p>Abstract:<br>\n  We use ConcurrentIMP to model Schism, a state-of-the-art real-time<br>\n  garbage collection scheme for weak memory, and show that it is safe<br>\n  on x86-TSO.</p>\n<p>This development accompanies the PLDI 2015 paper of the same name.</p>\n<p><a href=\"http://afp.sf.net/entries/ConcurrentGC.shtml\">http://afp.sf.net/entries/ConcurrentGC.shtml</a></p>\n<p>Concurrent IMP<br>\nby Peter Gammie</p>\n<p>Abstract:<br>\n  ConcurrentIMP extends the small imperative language IMP with control<br>\n  non-determinism and constructs for synchronous message passing.</p>\n<p><a href=\"http://afp.sf.net/entries/ConcurrentIMP.shtml\">http://afp.sf.net/entries/ConcurrentIMP.shtml</a></p>\n<p>Enjoy!<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294634432,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159563
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nTwo new entries are available at <a href=\"http://isa-afp.org/\">http://isa-afp.org/</a></p>\n<p>POSIX Lexing with Derivatives of Regular Expressions<br>\nby Fahad Ausaf, Roy Dyckhoff, and Christian Urban</p>\n<p>Brzozowski introduced the notion of derivatives for regular<br>\nexpressions. They can be used for a very simple regular expression<br>\nmatching algorithm. Sulzmann and Lu cleverly extended this algorithm<br>\nin order to deal with POSIX matching, which is the underlying<br>\ndisambiguation strategy for regular expressions needed in lexers. In<br>\nthis entry we give our inductive definition of what a POSIX value is<br>\nand show (i) that such a value is unique (for given regular expression<br>\nand string being matched) and (ii) that Sulzmann and Lu's<br>\nalgorithm always generates such a value (provided that the regular<br>\nexpression matches the string). We also prove the correctness of an<br>\noptimised version of the POSIX matching algorithm.</p>\n<p>Cardinality of Equivalence Relations<br>\nby Lukas Bulwahn</p>\n<p>This entry provides formulae for counting the number of equivalence<br>\nrelations and partial equivalence relations over a finite carrier set<br>\nwith given cardinality.  To count the number of equivalence relations,<br>\nwe provide bijections between equivalence relations and set<br>\npartitions, and then transfer the main results of the two AFP entries,<br>\nCardinality of Set Partitions and Spivey's Generalized Recurrence<br>\nfor Bell Numbers, to theorems on equivalence relations. To count the<br>\nnumber of partial equivalence relations, we observe that counting<br>\npartial equivalence relations over a set A is equivalent to counting<br>\nall equivalence relations over all subsets of the set A. From this<br>\nobservation and the results on equivalence relations, we show that the<br>\ncardinality of partial equivalence relations over a finite set of<br>\ncardinality n is equal to the n+1-th Bell number.</p>\n<p>Enjoy!<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294675419,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174783
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nTwo new entries are available from <a href=\"https://isa-afp.org\">https://isa-afp.org</a> :</p>\n<p>Category Theory with Adjunctions and Limits<br>\nby Eugene W. Stark</p>\n<p>This article attempts to develop a usable framework for doing category theory in Isabelle/HOL. Our point of view, which to some extent differs from that of the previous AFP articles on the subject, is to try to explore how category theory can be done efficaciously within HOL, rather than trying to match exactly the way things are done using a traditional approach. To this end, we define the notion of category in an \"object-free\" style, in which a category is represented by a single partial composition operation on arrows. This way of defining categories provides some advantages in the context of HOL, including the ability to avoid the use of records and the possibility of defining functors and natural transformations simply as certain functions on arrows, rather than as composite objects. We define various constructions associated with the basic notions, including: dual category, product category, functor category, discrete category, free category, functor composition, and horizontal and vertical composite of natural transformations. A \"set category\" locale is defined that axiomatizes the notion \"category of all sets at a type and all functions between them,\" and a fairly extensive set of properties of set categories is derived from the locale assumptions. The notion of a set category is used to prove the Yoneda Lemma in a general setting of a category equipped with a \"hom embedding,\" which maps arrows of the category to the \"universe\" of the set category. We also give a treatment of adjunctions, defining adjunctions via left and right adjoint functors, natural bijections between hom-sets, and unit and counit natural transformations, and showing the equivalence of these definitions. We also develop the theory of limits, including representations of functors, diagrams and cones, and diagonal functors. We show that right adjoint functors preserve limits, and that limits can be constructed via products and equalizers. We characterize the conditions under which limits exist in a set category. We also examine the case of limits in a functor category, ultimately culminating in a proof that the Yoneda embedding preserves limits.</p>\n<p>Cardinality of Multisets<br>\nby Lukas Bulwahn</p>\n<p>This entry provides three lemmas to count the number of multisets of a given size and finite carrier set. The first lemma provides a cardinality formula assuming that the multiset's elements are chosen from the given carrier set. The latter two lemmas provide formulas assuming that the multiset's elements also cover the given carrier set, i.e., each element of the carrier set occurs in the multiset at least once.</p>\n<p>The proof of the first lemma uses the argument of the recurrence relation for counting multisets. The proof of the second lemma is straightforward, and the proof of the third lemma is easily obtained using the first cardinality lemma. A challenge for the formalization is the derivation of the required induction rule, which is a special combination of the induction rules for finite sets and natural numbers. The induction rule is derived by defining a suitable inductive predicate and transforming the predicate's induction rule.</p>\n<p>Enjoy!</p>\n<p>Gerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294675909,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174934
    },
    {
        "content": "<p>From: <a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a><br>\nThere are two new entries available in the AFP:</p>\n<p>Source Coding Theorem<br>\nby Quentin Hibon and Lawrence Paulson</p>\n<p>This document contains a proof of the necessary condition on the code<br>\n  rate of a source code, namely that this code rate is bounded by the<br>\n  entropy of the source. This represents one half of Shannon's source<br>\n  coding theorem, which is itself an equivalence.</p>\n<p><a href=\"https://www.isa-afp.org/entries/Source_Coding_Theorem.shtml\">https://www.isa-afp.org/entries/Source_Coding_Theorem.shtml</a></p>\n<p>A formal model for the SPARCv8 ISA and a proof of non-interference for the LEON3 processor<br>\nby Zhe Hou, David Sanan, Alwen Tiu, and Yang Liu</p>\n<p>We formalise the SPARCv8 instruction set architecture (ISA) which is<br>\n  used in processors such as LEON3. Our formalisation can be specialised<br>\n  to any SPARCv8 CPU, here we use LEON3 as a running example. Our model<br>\n  covers the operational semantics for all the instructions in the<br>\n  integer unit of the SPARCv8 architecture and it supports Isabelle code<br>\n  export, which effectively turns the Isabelle model into a SPARCv8 CPU<br>\n  simulator. We prove the language-based non-interference property for<br>\n  the LEON3 processor.  Our model is based on deterministic monad, which<br>\n  is a modified version of the non-deterministic monad from NICTA/l4v.</p>\n<p><a href=\"https://www.isa-afp.org/entries/SPARCv8.shtml\">https://www.isa-afp.org/entries/SPARCv8.shtml</a></p>\n<p>Enjoy!<br>\nGerwin</p>",
        "id": 294691279,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177879
    }
]