[
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>in some cases, duplicate annotations occur in terms in proof_methods.<br>\nConsider the theory:</p>\n<p>lemma P<br>\n  apply (simp add: exI[of _ 1])</p>\n<p>and hover over the 1, which now has a duplicate set of annotations.</p>\n<p>Duplicate annotations also occur in locale expressions:</p>\n<p>locale A = fixes x<br>\nlocale B = A z for z + assumes False</p>\n<p>Here, the \"z\" has a duplicate set of annotations from Syntax.check_term<br>\n(but only a single one from Syntax.read_term).</p>\n<p>I tried to dig into what triggers this behaviour:</p>\n<p>For proof methods, this is related to the introduction of a method<br>\nclosure (which executes every proof method twice). The use of e.g. the<br>\nArgs.term parser is fine; but if one uses Args.name_inner_syntax and<br>\nSyntax.read_term later, annotations are duplicated:</p>\n<p>method_setup foo1 = ‹<br>\n  Args.term &gt;&gt; (fn _ =&gt; fn _ =&gt; SIMPLE_METHOD' (K all_tac))<br>\n›</p>\n<p>vs.</p>\n<p>method_setup foo2 = ‹<br>\n  Scan.peek (fn ctxt =&gt; Args.name_inner_syntax &gt;&gt; Syntax.read_term<br>\n(Context.proof_of ctxt)) &gt;&gt;<br>\n  (fn _ =&gt; fn _ =&gt; SIMPLE_METHOD' (K all_tac))<br>\n›</p>\n<p>except if the method errors out unconditionally (and hence is called<br>\nonly once):</p>\n<p>method_setup foo3 = ‹<br>\n  Args.term -- Scan.peek (fn ctxt =&gt; Args.name_inner_syntax &gt;&gt;<br>\nSyntax.read_term (Context.proof_of ctxt)) &gt;&gt;<br>\n  (fn _ =&gt; raise Match)<br>\n›</p>\n<p>-- Lars</p>",
        "id": 294289749,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923054
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is a careful analysis of this particular situation in <br>\nIsabelle2014-RC1, which was the result of spending several weeks this year <br>\nto make refinements over Isabelle2013-2.</p>\n<p>Here is another example:</p>\n<p>lemma \"x = x\" \"x = x\" \"x = x\" by (rule refl [of x])+</p>\n<p>If you C-hover over the fact \"refl\" and the variable \"x\" in either <br>\nIsabelle version, you see how often the system traverses that spot to make <br>\na PIDE markup report.</p>\n<p>It is the very concept of PIDE that markup is produced as a trace from <br>\ninternal aspects of the prover.  It is then left as an exercise to rework <br>\nthe prover that this information makes sense to the user.  Attendants of <br>\nthe UITP2014 workshop in Vienna may remember the brief discussion we've <br>\nhad about that for Coq PIDE in particular.</p>\n<p>In the example above, the rule method is already in a pretty good state: <br>\nits main argument outline is processed exactly once in its \"static phase\", <br>\nbefore actually applying it to the goal state.  The attribute \"of\" <br>\nnotoriously suffers from dynamic evaluation, though, and causes redundant <br>\nmultiplication of markup.</p>\n<p>The static closure of proof methods has made progress in Isabelle2014-RC1, <br>\nbut it is not fully finished yet.  Even in that partial stage, I can <br>\nforesee complaints by proof tool authors about that sanitation.  See also <br>\nthe NEWS:</p>\n<p>* More static checking of proof methods, which allows the system to<br>\n   form a closure over the concrete syntax.  Method arguments should be<br>\n   processed in the original proof context as far as possible, before<br>\n   operating on the goal state.  In any case, the standard discipline for<br>\n   subgoal-addressing needs to be observed: no subgoals or a subgoal<br>\n   number that is out of range produces an empty result sequence, not an<br>\n   exception.  Potential INCOMPATIBILITY for non-conformant tactical<br>\n   proof tools.</p>\n<p>The requirements for tactics or Isar proof methods are described in the <br>\n\"implementation\" manual, as usual.</p>\n<p>The relative silence in that respect of \"potential incompatibility\" is <br>\nprobably a proof that only few people have tested their own tools with<br>\nIsabelle2014-RC1 so far.</p>\n<p>Makarius</p>",
        "id": 294290205,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923195
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 01.08.2014 21:19, Makarius wrote:<br>\nHere is another example:</p>\n<blockquote>\n<p>In the example above, the rule method is already in a pretty good<br>\nstate: its main argument outline is processed exactly once in its<br>\n\"static phase\", before actually applying it to the goal state.  The<br>\nattribute \"of\" notoriously suffers from dynamic evaluation, though,<br>\nand causes redundant multiplication of markup.</p>\n<p>The static closure of proof methods has made progress in<br>\nIsabelle2014-RC1, but it is not fully finished yet.  Even in that<br>\npartial stage, I can foresee complaints by proof tool authors about<br>\nthat sanitation.  See also the NEWS:</p>\n<p>* More static checking of proof methods, which allows the system to<br>\n  form a closure over the concrete syntax.  Method arguments should be<br>\n  processed in the original proof context as far as possible, before<br>\n  operating on the goal state.  In any case, the standard discipline for<br>\n  subgoal-addressing needs to be observed: no subgoals or a subgoal<br>\n  number that is out of range produces an empty result sequence, not an<br>\n  exception.  Potential INCOMPATIBILITY for non-conformant tactical<br>\n  proof tools.<br>\nAfter looking carefully at args.ML I know now how e.g. Args.term<br>\nprevents a term from being parsed twice.</p>\n</blockquote>\n<p>I am in a more complicated situation: I have a parser which read_term-s<br>\nthe terms in a different order than they appear in the source and<br>\nmodifies the context (by fixing some of the term variables), so I need<br>\nto use Parse.term instead of Args.term. It is static in the sense that<br>\nthe interpretation of the terms does not depend on the goal state.</p>\n<p>Some questions arise from that and my new understanding of<br>\nstatic/dynamic phase separation:</p>\n<p>* Does it make sense at this point to mimic the Token.assign machinery<br>\n    used in Args? Or is it likely that the need to do this manually will<br>\n    go away with say 2014+1?</p>\n<p>If yes:</p>\n<p>* Is it ok for a context_parser to modify the context? (probably not,<br>\n    since most of the parser will be short-circuited after the static phase)</p>\n<blockquote>\n<p>The relative silence in that respect of \"potential incompatibility\" is<br>\nprobably a proof that only few people have tested their own tools with<br>\nIsabelle2014-RC1 so far.<br>\nI had to convert a few methods already; mostly by wrapping them into<br>\nSUBGOAL.</p>\n</blockquote>",
        "id": 294292095,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923791
    }
]