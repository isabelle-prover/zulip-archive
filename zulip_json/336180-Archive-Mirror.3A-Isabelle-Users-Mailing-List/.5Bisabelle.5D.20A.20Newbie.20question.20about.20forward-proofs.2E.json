[
    {
        "content": "<p>From: Joe Fredette &lt;<a href=\"mailto:jfredett@gmail.com\">jfredett@gmail.com</a>&gt;<br>\nHello Isabelle Theorem Provers!</p>\n<p>First of all, let me say, this is my first post to the list, hopefully  <br>\nI'm not committing any sins-of-form-or-content, but I claim ignorance,  <br>\nand thus innocence, if I do.</p>\n<p>My question is as such:</p>\n<p>I have a theory which has the following class definition</p>\n<p>class Group =<br>\n    fixes oper :: \"'a ⇒ 'a ⇒ 'a\" (infixl \"[*]\" 65)<br>\n      and ivr  :: \"'a ⇒ 'a\"<br>\n      and e    :: \"'a\"<br>\n    assumes grp_assoc            : \"a [<em>] (b [</em>] c) = (a [<em>] b) [</em>] c\"<br>\n        and grp_id_propR  [simp] : \"a [*] e = a\"<br>\n        and grp_inv_propR [simp] : \"(ivr a [<em>] a) [</em>] b = b\";<br>\n    notation oper (infixl \"⨂\" 65);</p>\n<p>This (obviously) aims to represent a group. You'll of course notice  <br>\nthat I didn't provide the left-handed<br>\nanalog of grp_id_propR, since it can be proved as a lemma, given the  <br>\nfollowing lemma, which is where I'm getting stuck, my goal is to prove  <br>\n(in standard notation):</p>\n<p>a = c =&gt; (b [<em>] a = b [</em>] c) /\\ (a [<em>] b = c [</em>] b)</p>\n<p>which is easy, simply note:</p>\n<p>b [<em>] a = b [</em>] a</p>\n<p>and</p>\n<p>a = c</p>\n<p>so substituting</p>\n<p>b [<em>] a = b [</em>] c</p>\n<p>And similar. My issue is that while I can get these assumptions \"into\"  <br>\nthe system (so that they're under the <code>using this</code> spot) I can't seem  <br>\nto figure out the correct incantation to get a to be replaced with b  <br>\non one side (or any side, for that matter). My intuition is that I  <br>\nneed something like <code>ssubst</code>, but I'm not sure how to do it in the  <br>\nforward-proof mode.</p>\n<p>For reference, my current lemma:</p>\n<p>lemma (in Group) grp_mult_id :<br>\n      assumes a_eq_c: \"a = c\"<br>\n      shows \"(a [<em>] b = c [</em>] b) ∧ (b [<em>] a = b [</em>] c)\";<br>\n    proof<br>\n      assume refl: \"a [<em>] b = a [</em>] b\";<br>\n      from refl and a_eq_c obtain \"a [<em>] b = a [</em>] c\"; (* the <code>obtain</code>  <br>\nbit (I think) is wrong,<br>\n                                * or at least incomplete... *)</p>\n<p>Thanks for any help any of you could provide. I'm really enjoying  <br>\nIsabelle, especially forward proof, it makes theorem proving less eye- <br>\nstraining and more fun!</p>\n<p>/Joe Fredette</p>",
        "id": 294091778,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832104
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Joe,</p>\n<blockquote>\n<p>class Group =<br>\n  fixes oper :: \"'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; 'a\" (infixl \"[*]\" 65)<br>\n  and ivr :: \"'a \\&lt;Rightarrow&gt; 'a\"<br>\n  and e :: \"'a\"<br>\n  assumes grp_assoc: \"a [<em>] (b [</em>] c) = (a [<em>] b) [</em>] c\"<br>\n  and grp_id_propR [simp]: \"a [*] e = a\"<br>\n  and grp_inv_propR [simp]: \"(ivr a [<em>] a) [</em>] b = b\"<br>\nbegin</p>\n</blockquote>\n<p>What I would recommend from a pragmatic point of view is to use the simp<br>\nmethod:</p>\n<blockquote>\n<p>lemma grp_mult_id:<br>\n  assumes a_eq_c: \"a = c\"<br>\n  shows \"(a [<em>] b = c [</em>] b) \\&lt;and&gt; (b [<em>] a = b [</em>] c)\"<br>\nproof<br>\n  have refl: \"b [<em>] a = b [</em>] a\" ..<br>\n  from refl and a_eq_c have \"b [<em>] a = b [</em>] c\" by simp</p>\n</blockquote>\n<p>\"simp\" invokes an automated proof tool which performs equational<br>\nrewriting using assumptions in a goal and a predefined set of rewrite<br>\nrules (see the Isabelle tutorial for more information on this).</p>\n<p>Intermediate results in a proof are stated using \"have\".  Assumptions<br>\n\"assume\" are part the resulting theorem of a proof and therefore must<br>\nfit to an outer proof obligation, which is not the case in your proof<br>\nbecause \"b [<em>] a = b [</em>] a\" is not part of the assumptions of the lemma.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/bDibTrBGznMwPpZyB2dP3DpB/signature.asc\">signature.asc</a></p>",
        "id": 294091800,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832112
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Joe,</p>\n<blockquote>\n<p>If I can bother you with another question. I wanted to get <code>ivr</code> to have<br>\na prefix unary syntax (or a postfix, the problem (I imagine) is<br>\nisomorphic), once again, I just can't seem to find a suitable<br>\nincantation. The big tutorial (the 200+ page one) talks about using<br>\ndatatypes somewhere for this purpose, But I don't see how that helps me<br>\nhere.</p>\n</blockquote>\n<p>You can attach syntax to constants using \"notation\", e.g.</p>\n<p>notation ivr (\"INV _\")</p>\n<p>C.f. the Isabelle Reference Manual, keyword \"notation\".</p>\n<blockquote>\n<p>Further, another (semi-related) question. In Haskell (which is where my<br>\nbackground lies), one can do associated datatypes, eg</p>\n<p>class Foo a where<br>\n        data Bar a :: * -&gt; *\n        bar :: Bar a b -&gt; b -&gt; (a,b)<br>\n        --whatever</p>\n<p>is there an analog in Isabelle?</p>\n</blockquote>\n<p>Isabelle's type classes are, compared to Haskell, very simplistic:<br>\noperations of type classes are polymorphic in <em>exactly</em> one variable;<br>\nall those fancy Haskell extensions (multiple parameters, polymorphism,<br>\nconstructor classes, associated types) are not present.</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/k3CWHgJ6-4vglwHHhZno5RjP/signature.asc\">signature.asc</a></p>",
        "id": 294091817,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832118
    },
    {
        "content": "<p>From: Joe Fredette &lt;<a href=\"mailto:jfredett@gmail.com\">jfredett@gmail.com</a>&gt;<br>\nYou know what it was, I just had the goal wrong. I mistyped and put \"a  <br>\n[<em>] b = a [</em>] c\". You're advice worked perfectly after I saw that...</p>\n<p>Teach me to try to prove stuff in the wee hours of the morning!</p>\n<p>Thanks so much for your help.</p>\n<p>If I can bother you with another question. I wanted to get <code>ivr</code> to  <br>\nhave a prefix unary syntax (or a postfix, the problem (I imagine) is  <br>\nisomorphic), once again, I just can't seem to find a suitable  <br>\nincantation. The big tutorial (the 200+ page one) talks about using  <br>\ndatatypes somewhere for this purpose, But I don't see how that helps  <br>\nme here.</p>\n<p>Further, another (semi-related) question. In Haskell (which is where  <br>\nmy background lies), one can do associated datatypes, eg</p>\n<p>class Foo a where<br>\n        data Bar a :: * -&gt; *\n        bar :: Bar a b -&gt; b -&gt; (a,b)<br>\n        --whatever</p>\n<p>is there an analog in Isabelle?</p>",
        "id": 294091833,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832124
    }
]