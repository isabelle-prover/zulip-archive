[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust one note on the \"The sad fact of life\" about SML semantics.<br>\nThe reference implementation <a href=\"http://www.mpi-sws.org/~rossberg/hamlet/\">http://www.mpi-sws.org/~rossberg/hamlet/</a> by <br>\nAndreas Rossberg can be understood as an executable version of that. <br>\nNonetheless there are problems with it, because the static phase merely <br>\nchecks that the problem is type-correct, without producing the resulting <br>\ntype-assignment.  As a consequence, the dynamic phase needs to be <br>\nimplemented like a LISP interpreter, with explicit tags everywhere.</p>\n<p>Makarius</p>",
        "id": 294120120,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839545
    },
    {
        "content": "<p>From: Francisco Ferreira &lt;<a href=\"mailto:ferrerif@iro.umontreal.ca\">ferrerif@iro.umontreal.ca</a>&gt;<br>\nHello all,</p>\n<p>I am just starting with Isabelle, my intention is to prove some simple <br>\ntheorems of simply-typed lambda (from Pierce's TAPL book) calculus using <br>\nNominal Isabelle.<br>\nI am using the tutorial and the isar reference as guides (and the <br>\nnominal_datatype_reference too)<br>\nI am starting nice and easy trying to do the determinism proof for a <br>\nvery simple language of arithmetic expressions.<br>\nSo far I have defined my datatype and the step by step semantics <br>\nrelation, and I have formulated my theorem (I've attached the code as I <br>\nhave it so far).</p>\n<p>On my paper proof, I would proceed by induction on the structure of the <br>\nstep relation but I don't know how to proceed in this case (apply (rule <br>\nstep.induct) confuses me).</p>\n<p>What I need is some help to start, and hopefully be able to keep the <br>\nmomentum going.<br>\nHow do I approach this proof? (are there any examples that I should check?)</p>\n<p>Thanks in advance,<br>\nFrancisco<br>\n<a href=\"/user_uploads/14278/NOBfzs2fnHe1FJMCIKeq63xC/arith.thy\">arith.thy</a></p>",
        "id": 294122500,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840272
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nHi Francisco,</p>\n<p>Below I have started your proof in the style<br>\nof Isabelle/Isar. Maybe this is of help for how<br>\napproaching this kind of proofs. However, once<br>\nI attempted the second case, I found out that<br>\nthe lemma for your definition is not true. You<br>\nadded a rule to Pierce's rules, which breaks the<br>\nproperty you are after. The counter example is<br>\nalso included.</p>\n<p>Hope this helps,<br>\nChristian</p>\n<p>Quoting Francisco Ferreira &lt;<a href=\"mailto:ferrerif@iro.umontreal.ca\">ferrerif@iro.umontreal.ca</a>&gt;:<br>\n<a href=\"/user_uploads/14278/dCGcXBAGYmhp9G1t_2Yc_Alj/Arith.thy\">Arith.thy</a></p>",
        "id": 294122514,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840276
    },
    {
        "content": "<p>From: Francisco Ferreira &lt;<a href=\"mailto:ferrerif@iro.umontreal.ca\">ferrerif@iro.umontreal.ca</a>&gt;<br>\nThank you! <br>\nThat was really helpful! But I am still having problems, I've checked the tutorial and the reference manual, but in the tutorial the Proof commands are not discussed, and I find the reference manual a bit too advanced, is there a tutorial on the proof command?</p>\n<p>Regarding my example I eliminated the problematic rule, and now when I reach the proof of the Pred(Z) rule, I don't know how I prove that Z↓m' is not possible as no rule matches Z</p>\n<p>Sorry for the continuos questions, and thanks again for your help,</p>\n<p>Francisco<br>\n<a href=\"/user_uploads/14278/sI0A3vWcu1gcxribG-7wSRDn/Arith2.thy\">Arith2.thy</a></p>",
        "id": 294122640,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840305
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThe \"Tutorial on Isar\"[1] covers the proof command.</p>\n<p>-- Lars</p>\n<p>[1] <a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/isar-overview.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/isar-overview.pdf</a></p>",
        "id": 294122662,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840311
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nStart with proving which form the \"n\" in \"n↓m\" has (i.e.<br>\n\"Succ n'\" or \"Pred n'\"), instead of proving which form it does not have (Z).</p>\n<p>-- Lars</p>",
        "id": 294122687,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840317
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nFor beginners I would recommend some material I have just put together<br>\nfor my Semantics course, where I use Isabelle:<br>\n<a href=\"http://www4.in.tum.de/lehre/vorlesungen/semantik/WS1011/\">http://www4.in.tum.de/lehre/vorlesungen/semantik/WS1011/</a><br>\nUnder \"Slides and files\" you find a proof-pattern-oriented introduction<br>\nto Isabelle proofs. Simply stop reading when the Isabelle intro stops<br>\nand the Semantics material starts.</p>\n<p>This is work in progress and any feedback is warmly appreciated!</p>\n<p>Thanks<br>\nTobias</p>\n<p>Lars Noschinski schrieb:</p>",
        "id": 294122761,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840330
    },
    {
        "content": "<p>From: Francisco Ferreira &lt;<a href=\"mailto:ferrerif@iro.umontreal.ca\">ferrerif@iro.umontreal.ca</a>&gt;<br>\nThank you all for your comments, the documents are really useful.<br>\nI really liked the slides, it seems to be a great course, I would totally enrol in such a course.<br>\nThe first part with the motivation and the objectives  presents the subject in an attractive, yet realistic way (with the \"The Sad Facts of Life\" slides). Additionally I liked the fact that the language that will be studied (IMP) is not a form lambda calculus, that is interesting<br>\nIsabelle is a powerful tool, no-one will deny it, but it is also very complex. To illustrate this, one of the demos(Isar_Demo.thy) uses the following tactic</p>\n<p>let ?ys = \"take n xs\"<br>\n  have \"xs = ?ys @ xs!n # rev ?ys\"<br>\n    by (metis Suc_le_lessD <code>length xs = Suc (n + n)</code> add_Suc_right add_Suc_shift append_take_drop_id assms diff_add_inverse le_add1 nth_drop' rev_take)<br>\n  thus ?thesis by blast<br>\nqed</p>\n<p>That metis tactic is really scary (I hope that line is automatically generated by sledgehammer or something like that).</p>\n<p>That said, I am sure all the complexity problems won't be such in a live course with demos and office hours. As I said, I'd enjoy the course. I am highly interested in the subject, and Isabelle seems like a great tool.</p>\n<p>But, even with the documentation, and the fact that I am really trying to understand Isabelle, I just don't get it.</p>\n<p>I can't even prove that \"step (Pred Z) m ==&gt; m = Z\", probably I am just saturated and tired of going in circles.<br>\nThanks,</p>\n<p>Francisco<br>\n<a href=\"/user_uploads/14278/58U0-Gew7PHohy2RFbF4coeE/Arith2.thy\">Arith2.thy</a></p>",
        "id": 294122900,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840373
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>let ?ys = \"take n xs\"<br>\n  have \"xs = ?ys @ xs!n # rev ?ys\"<br>\n    by (metis Suc_le_lessD <code>length xs = Suc (n + n)</code> add_Suc_right add_Suc_shift append_take_drop_id assms diff_add_inverse le_add1 nth_drop' rev_take)<br>\n  thus ?thesis by blast<br>\nqed</p>\n<p>That metis tactic is really scary (I hope that line is automatically generated by sledgehammer or something like that).</p>\n</blockquote>\n<p>Yes, it was found automatically by s/h.</p>\n<blockquote>\n<p>That said, I am sure all the complexity problems won't be such in a live course with demos and office hours. As I said, I'd enjoy the course. I am highly interested in the subject, and Isabelle seems like a great tool.</p>\n<p>But, even with the documentation, and the fact that I am really trying to understand Isabelle, I just don't get it.</p>\n<p>I can't even prove that \"step (Pred Z) m ==&gt; m = Z\", probably I am just saturated and tired of going in circles.</p>\n</blockquote>\n<p>This lemma is trivial, on one level:</p>\n<p>by(blast elim: step.cases)</p>\n<p>My slides have carefully avoided explaining this idiom in the beginning,<br>\nbecause elimination rules (this is what \"elim\" stands for) and how to<br>\nmodify blast, are advanced concepts. You find some of this under \"Rule<br>\ninversion\" in the IMP part of my slides. What I fail to explain there is<br>\n\"step.cases\". The latter is a case distinction rule: how can \"step x y\"<br>\nhave been derived, i.e. like an induction but without the induction<br>\nhypothesis.</p>\n<p>But my impression from your failed proof attempts is that you did not<br>\nquite realize that a case distinction on which rules derived \"step (Pred<br>\nZ) m\" is needed to perform the proof. Here is the structured proof that<br>\nexposes the 2 case distinctions you need:</p>\n<p>lemma assumes \"step (Pred Z) m\" shows \"m = Z\"<br>\nusing assms<br>\nproof cases<br>\n  case s_pred_zero thus \"m=Z\" by simp<br>\nnext<br>\n  case (s_pred m')<br>\n  from <code>step Z m'</code> have False<br>\n    by cases --\"there is no rule with conclusion step Z m\"<br>\n  thus \"m=Z\" by blast<br>\nqed</p>\n<p>The \"cases\" proof method figures out which rules could have been used to<br>\nderive the incoming \"step x y\".</p>\n<p>The assumes-shows-using contortion seems necessary, I could not get the<br>\nproof to work with \"step (Pred Z) m ==&gt; m = Z\", except by making it an<br>\ninduction instead of a case distinction, which would be misleading.</p>\n<p>As a preview of coming attractions: The lemma can now be proved<br>\nautomatically by s/h, but only with the latest link to smt solvers,<br>\nthanks to Jasmin, Sascha, Lukas and Z3!</p>\n<p>by (smt arith.simps(5) arith.simps(2) arith.simps(4) arith.simps(8)<br>\nstep.simps)</p>\n<p>Yes, awesome!</p>\n<p>Tobias</p>\n<blockquote>\n<p>Thanks,</p>\n<p>Francisco</p>\n<hr>\n<p>On 2010-11-24, at 3:02 AM, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>For beginners I would recommend some material I have just put together<br>\nfor my Semantics course, where I use Isabelle:<br>\n<a href=\"http://www4.in.tum.de/lehre/vorlesungen/semantik/WS1011/\">http://www4.in.tum.de/lehre/vorlesungen/semantik/WS1011/</a><br>\nUnder \"Slides and files\" you find a proof-pattern-oriented introduction<br>\nto Isabelle proofs. Simply stop reading when the Isabelle intro stops<br>\nand the Semantics material starts.</p>\n<p>This is work in progress and any feedback is warmly appreciated!</p>\n<p>Thanks<br>\nTobias</p>\n<p>Lars Noschinski schrieb:</p>\n<p>On 24.11.2010 05:26, Francisco Ferreira wrote:</p>\n<blockquote>\n<blockquote>\n<p>Thank you!<br>\nThat was really helpful! But I am still having problems, I've checked<br>\nthe tutorial and the reference manual, but in the tutorial the Proof<br>\ncommands are not discussed, and I find the reference manual a bit too<br>\nadvanced, is there a tutorial on the proof command?<br>\nThe \"Tutorial on Isar\"[1] covers the proof command.</p>\n</blockquote>\n<p>-- Lars</p>\n<p>[1] <a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/isar-overview.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/isar-overview.pdf</a></p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294122927,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840379
    }
]