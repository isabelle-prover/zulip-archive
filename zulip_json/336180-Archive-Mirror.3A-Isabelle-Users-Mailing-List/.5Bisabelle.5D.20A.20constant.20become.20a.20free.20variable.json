[
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nPlanning to rework an SML application I did three years ago, I wanted to  <br>\nhave a start trying something in a sample theory, attached to this message  <br>\nand pasted below in case the attachment disappears.</p>\n<p>On the last line of the simple lemma proof, at “from 4 show \"t1 ≅ t2\" by  <br>\n(simp add: 3)”, if I move the mouse cursor over “≅” while Ctrl is pressed,  <br>\nI get a tool‑tip which tells me it's a fixed variable as well as a free  <br>\nvariable. Surprising, as to me it's a fixed variable, but I don't mind  <br>\nmore. More disturbing, is what I see in the Output pan when I move the  <br>\ncaret to the end of the same line ; it displays “t1 ≅ t2” and if I move  <br>\nthe mouse cursor over it while Ctrl is pressed, it says it's a free  <br>\nvariable, and just a free variable, and it draws the “≅” in blue instead  <br>\nof black. Why does it become a free variable in the Output pan ?</p>\n<p>As a question aside, is there a more explicit way to substitute the second  <br>\n“t1” in 4 using the equivalence from 3 ? I feel I already came a similar  <br>\nquestion one year ago, but I'm not able to remember what I did (I'm  <br>\nseasoned with Isabelle).</p>\n<p>-----%&lt;----------&gt;%-----</p>\n<p>theory Sample<br>\nimports Main<br>\nbegin</p>\n<p>typedecl atom;<br>\n   typedecl variable;</p>\n<p>datatype \"term\" =<br>\n     Any                  (\"ε\")<br>\n   | Atom atom            (\"α\")<br>\n   | Variable variable    (\"υ\")<br>\n   | Compound \"term list\" (\"ω\")<br>\n   ;</p>\n<p>locale unification =<br>\n     fixes<br>\n       unifies :: \"[term, term] ⇒ bool\"       (infix \"≅\" 500) and<br>\n       \"interpretation\" :: \"variable ⇒ term\"  (\"⊢\")<br>\n     assumes<br>\n       self: \"t ≅ t\" and<br>\n       comm: \"t1 ≅ t2 ⟷ t2 ≅ t1\" and<br>\n       inter: \"(υ v) ≅ t ⟷ (⊢ v) ≅ t\" and<br>\n       rec: \"(ω (t1 # r1)) ≅ (ω (t2 # r2)) ⟷ t1 ≅ t2 ∧ (ω r1) ≅ (ω r2)\"<br>\n   ;</p>\n<p>lemma (in unification) l1: \"t1 = t2 ⟹ t1 ≅ t2\"<br>\n     proof -<br>\n       assume 1: \"t1 = t2\"<br>\n       have 2: \"t1 = t2 ⟹ t1 ≡ t2\" by (fact HOL.eq_reflection[of t1 t2])<br>\n       have 3: \"t1 ≡ t2\" by (fact 2[OF 1])<br>\n       have 4: \"t1 ≅ t1\" by (fact self[of t1])<br>\n       from 4 show \"t1 ≅ t2\" by (simp add: 3)<br>\n     qed<br>\n   ;</p>\n<p>end</p>\n<p>-----%&lt;----------&gt;%-----<br>\n<a href=\"/user_uploads/14278/wRX1bD4L1mFh8dSlcxV1XdTi/Sample.thy\">Sample.thy</a></p>",
        "id": 294261967,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914716
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 4 Dec 2013, Yannick Duchêne (Hibou57) wrote:</p>\n<blockquote>\n<p>On the last line of the simple lemma proof, at “from 4 show \"t1 ≅ t2\" <br>\nby (simp add: 3)”, if I move the mouse cursor over “≅” while Ctrl is <br>\npressed, I get a tool‑tip which tells me it's a fixed variable as well <br>\nas a free variable. Surprising, as to me it's a fixed variable, but I <br>\ndon't mind more. More disturbing, is what I see in the Output pan when I <br>\nmove the caret to the end of the same line ; it displays “t1 ≅ t2” and <br>\nif I move the mouse cursor over it while Ctrl is pressed, it says it's a <br>\nfree variable, and just a free variable, and it draws the “≅” in blue <br>\ninstead of black. Why does it become a free variable in the Output pan ?</p>\n</blockquote>\n<p>I don't see an actual constant in the example, although a fixed variable <br>\nis better understood as \"local constant\".</p>\n<p>The PIDE markup seen in the input or output represents certain aspects of <br>\nthe formal processing by the prover.  This sometimes exposes more internal <br>\ndetails than make sense to the user.  It needs some further refinements, <br>\nbut that is part of the concept: more and more useful markup information <br>\nis provided and rendered -- this is a continuous process over the years.</p>\n<blockquote>\n<p>As a question aside, is there a more explicit way to substitute the <br>\nsecond “t1” in 4 using the equivalence from 3 ? I feel I already came a <br>\nsimilar question one year ago, but I'm not able to remember what I did</p>\n</blockquote>\n<blockquote>\n<p>lemma (in unification) l1: \"t1 = t2 ⟹ t1 ≅ t2\"<br>\n  proof -<br>\n    assume 1: \"t1 = t2\"<br>\n    have 2: \"t1 = t2 ⟹ t1 ≡ t2\" by (fact HOL.eq_reflection[of t1 t2])<br>\n    have 3: \"t1 ≡ t2\" by (fact 2[OF 1])<br>\n    have 4: \"t1 ≅ t1\" by (fact self[of t1])<br>\n    from 4 show \"t1 ≅ t2\" by (simp add: 3)<br>\n  qed</p>\n</blockquote>\n<p>The use of Pure equality and HOL.eq_reflection looks a bit strange: you <br>\nshould bever need that in HOL applications, unless some old forms are <br>\nsomehow ported.</p>\n<p>A more imminent proof just normalizes wrt. \"t1 = t2\" and the solves via <br>\nreflexivity (\"self\"):</p>\n<p>lemma (in unification) \"t1 = t2 ⟹ t1 ≅ t2\"<br>\n     by (simp add: self)</p>\n<p>More explicit reasoning can be done by calculations in Isar, but its <br>\nsubstitution steps will always replace all occurrences of the subterm in <br>\nquestion (according to the standard policy of Larry's implementation of <br>\nHuet).  Going from \"t1 ≅ t1\" to \"t1 ≅ t2\" is not immediate in this <br>\nscheme.</p>\n<p>Maybe some experts on hand-crafted substitution can point out frequently <br>\nused patterns, without too much \"term surgery\".</p>\n<p>Makarius</p>",
        "id": 294262081,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914741
    },
    {
        "content": "<p>From: Yannick &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nOn Wed, 04 Dec 2013 13:22:15 +0100, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>The PIDE markup seen in the input or output represents certain aspects of<br>\nthe formal processing by the prover.  This sometimes exposes more  <br>\ninternal<br>\ndetails than make sense to the user.  It needs some further refinements,<br>\nbut that is part of the concept: more and more useful markup information<br>\nis provided and rendered -- this is a continuous process over the years.</p>\n</blockquote>\n<p>OK, so may be it says it's a free variable when it does not already know  <br>\nit's fixed.</p>\n<blockquote>\n<p>The use of Pure equality and HOL.eq_reflection looks a bit strange: you<br>\nshould bever need that in HOL applications, unless some old forms are<br>\nsomehow ported.</p>\n</blockquote>\n<p>I've just checked, and “HOL.thy” indeed says “(<em>admissible axiom</em>)”. Will  <br>\ntry to learn to do without it.</p>\n<p>Thanks for the pointers you gave on both topics.</p>",
        "id": 294262163,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914777
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIn some sense this belongs to the \"implementation\" of Isabelle/HOL on top <br>\nof the Isabelle/Pure framework.</p>\n<p>These days you should hardly ever need == in Isabelle/HOL applications.</p>\n<p>This is different to !! and ==&gt;, which have a specific purpose to outline <br>\nNatural Deduction rule schemes in a declarative manner, independently of <br>\nthe object-logic.</p>\n<p>Makarius</p>",
        "id": 294262184,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914783
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nDoes that mean substitution/simplification is not expressed with “==” but  <br>\n“=” instead ? I always though “==” was the standard for that purpose with  <br>\nlogic.</p>",
        "id": 294262206,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914790
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe basic substitution rules of Isabelle/HOL directly refer to =, not ==. <br>\nThis is also relevant to calculational reasoning, e.g. see <br>\nprint_trans_rules.  (That gives only very limited support for some basic <br>\nPure reasoning with ==).</p>\n<p>Some other tools go to the bottom of Pure and use == internally, such as <br>\nthe Simplifier itself (which is somewhat independent of the object-logic). <br>\nThis is also one of several points in the system where both = and == are <br>\nallowed in user input, but this duplication of interfaces is not <br>\nuniversal.</p>\n<p>That was important in the past, because the primite 'defs' command was <br>\nused routinely in user theories, and thus there was considerable mix-up of <br>\nconnectives.  For many years already, the 'definition' command allows to <br>\nuse = of Isabelle/HOL, just like other specification elements that are <br>\nproper to HOL.</p>\n<p>Makarius</p>",
        "id": 294262242,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914801
    }
]