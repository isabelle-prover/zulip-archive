[
    {
        "content": "<p>From: Tambet &lt;<a href=\"mailto:qtvali@gmail.com\">qtvali@gmail.com</a>&gt;<br>\nType-safety of variables in Java is related to type constraints, but one can<br>\nalways emulate variables (say, as strings), which aren't type-safe.</p>\n<p>Variables in Java are also mutexes. Say that mutexes are safe by<br>\ncomposition, then one can emulate mutexes, which are not - also, one could<br>\ncreate livelocks.</p>\n<p>I am not sure if livelocks can be avoided by strong types, but deadlocks can</p>\n<ul>\n<li>and deadlocks are the main problem.</li>\n</ul>\n<p>In Java, taking lock is achieved by synchronized method:<br>\nsynchronized (a) {<br>\n  ...<br>\n}</p>\n<p>One can also take class lock by having it in function signature.</p>\n<p>First problem - it's impossible to atomically take two locks like this:<br>\nsynchronized (a, b) {<br>\n  ...<br>\n}</p>\n<p>These run to deadlock if they are in different threads:<br>\nsynchronized (a) { synchronized (b) { ... }}<br>\nsynchronized (b) { synchronized (a) { ... }}</p>\n<p>This is easy to see, why - order differs.</p>\n<p>Say that we have \"then synchronized\" keyword.<br>\nsynchronized (a) {<br>\n  then synchronized (b) {<br>\n    ...<br>\n  }<br>\n  ...<br>\n}</p>\n<p>This should take two locks atomically, then release one of them.</p>\n<p>Taking many locks at once, then releasing them in arbitrary order - this<br>\nwont run to deadlocks.</p>\n<p>Then, imagine this:<br>\nsynchronized (a) { synchronized (b) { ... }}<br>\nsynchronized (a) { ... } then synchronized (b) { ... }</p>\n<p>First one takes lock b after a, second one will take b atomically when<br>\nreleasing a. As long as locks are taken in same order, it's impossible to<br>\nforce system to deadlock. There is a difference between forcing it to<br>\ndeadlock and allowing deadlock - it has different constraints to<br>\nthread-safety of types.</p>\n<p>Say that some type is ordered in regard to locks:<br>\nclass A {<br>\n  seq Integer[] b;<br>\n}<br>\nclass B {}<br>\nseq { A, B }</p>\n<p>In other file, there might be:<br>\nseq { A, C }<br>\nmerging to previous sequence as { A, B, C }</p>\n<p>Sequencing locks is one rather powerful way to avoid deadlocks. Also,<br>\nintegers inside A should be a sub-sequence of A.</p>\n<p>For lock of A, we have a few considerable possibilities:</p>\n<ul>\n<li>\n<p>It's last lock of it's inner sequence, then it's possible to lock it after<br>\nany lock there.</p>\n</li>\n<li>\n<p>It's first lock of it's inner sequence.</p>\n</li>\n<li>It's a covering lock of whole it's sequence, locking all Integers in b.</li>\n</ul>\n<p>We could have this goal:</p>\n<ul>\n<li>Lock whole A, get some data</li>\n<li>Work on it</li>\n<li>Lock A again, write it</li>\n</ul>\n<p>We can mark this data as being worked on or we can try to write and retry if<br>\nit's changed meanwhile. We could also have queues, which is my favorite, but<br>\nthis is not interesting here.</p>\n<p>So having A at end of sequence, it is no problem to take lock of A and b[n]<br>\nat once, then release A, then work on b[n] and take A again:<br>\nsynchronized (b[n]) {<br>\n  then synchronized (A) {<br>\n    // Read data.<br>\n  }<br>\n  // Work on data.<br>\n} then synchronized (A) {<br>\n  // Write data.<br>\n}</p>\n<p>This relies on fact that locking all at once we can not run to deadlock -<br>\nthen, we release A and one lock left, go sequentially.</p>\n<p>Method, then, should look something like that:<br>\nint m(n) locks [(A, b[n]), A] {<br>\n  synchronized (b[n]) {<br>\n    then synchronized (A) {<br>\n      // Read data.<br>\n    }<br>\n    // Work on data.<br>\n  } then synchronized (A) {<br>\n    // Write data.<br>\n  }<br>\n}</p>\n<p>Eclipse could generate the lock signature. It contains locking path - and<br>\nchallence is to make it short.</p>\n<p>For having more complex use cases - where we want to read several items,<br>\nwhen changing one - it's needed to have independent handler for items in b -<br>\nthis handler will take internal locks. From such handler, no calls can be<br>\nmade to parent (this is, by the way, most hard-to-debug deadlock case) from<br>\nlocked functions. In such case, the functions are kind of \"atomic\" - you<br>\ncall them, they have inherently good lock structure, they exit and this<br>\nmakes no difference what locks you use from your own scope.</p>\n<p>This locking, to be usable, must be tightly integrated to the rest of type<br>\nsystem - otherwise it's unimaginable that you create all those connections<br>\nbetween variables (as variable structure itself is dynamic, you can always<br>\nadd element to an array or reference something from some other class).</p>\n<p>Summary:</p>\n<p>Sequence structure, defined in several files, is directed and can fork/join.</p>\n<p>Each locking sequence can start by taking many locks at once, then release<br>\nall locks except connected slice of lock sequence, then progress.</p>\n<p>Independent sequences of subsystems work ok as long as one can make calls to<br>\nanother, which locks things with allowed structure and then releases it's<br>\nown internal locks and returns. That other can not make back-calls to<br>\nmethods, which use caller-scope locks in relation to it.</p>\n<p>I am sure that this structure can be worked on to allow more cases, but this<br>\nis a simple and proven methodology, which allows a lot. I suggest also<br>\nlooking at lock structure in Google Go-lang, which basically has only<br>\nchannels and no locks (and is fast compiled language - someday with a<br>\ngarbage collector). The Go-lang suggestion is precisely because proving at<br>\nleast one structure, which allows sending messages in two directions, to be<br>\ndeadlock-safe, would cover all common needs. This is - everyone tries to<br>\nsend something, reader can at any moment read the array or next message in<br>\nand process it. Sending messages back from many to one could be simple<br>\nmethod call, then. This would allow to emulate something similar to Go's<br>\nmessage-sending structure, which allows all important use cases (as they<br>\nsay).</p>\n<p>Tambet</p>",
        "id": 294113403,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837558
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Tambet,</p>\n<p>in Isabelle, I have formalized a notion of type safety for the Java <br>\nmultithreading model with deadlocks in the JinjaThreads article in the <br>\nArchive of Formal Proofs <br>\n(<a href=\"http://afp.sourceforge.net/entries/JinjaThreads.shtml\">http://afp.sourceforge.net/entries/JinjaThreads.shtml</a>).</p>\n<p>There, I do allow deadlocks in showing type safety in the style of <br>\nprogress and preservation: The progress is restricted to non-deadlocked <br>\ncases. Note that not only deadlocks via locking violate the progress <br>\nproperty. Java's wait-notify-mechanism and joining of threads can <br>\nsimilarly cause problems with progress. Suppose a thread is in a wait <br>\nset - waiting to be notified or interrupted - but there is only one <br>\nother thread which joins on the thread in the wait set. I would also <br>\ncall this a deadlock.</p>\n<p>Andreas</p>",
        "id": 294113456,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837564
    }
]