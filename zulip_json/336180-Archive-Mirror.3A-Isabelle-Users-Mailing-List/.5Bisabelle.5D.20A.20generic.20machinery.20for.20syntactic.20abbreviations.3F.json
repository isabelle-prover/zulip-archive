[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear all,</p>\n<p>recently, I stumbled over three related but separately implemented<br>\nabbreviation-like mechanisms:</p>\n<ul>\n<li>abbreviations;</li>\n<li>\n<p>the »user space type system« for class operations which parses global<br>\nf as local ones and prints them the other way round;</p>\n</li>\n<li>\n<p>ad-hoc overloading from ~~/src/Tools/Adhoc_Overloading.thy.</p>\n</li>\n</ul>\n<p>All three accomplish a similar thing, the systematic (un)folding of<br>\nsyntactic abbreviations according to syntactic equations \"(c :: T) ==<br>\nrhs\". All three are delicate, since there is no logic foundation to<br>\nguide them and details are abysmal. One of the details is that, during<br>\nreading of abbreviation rhses, abbreviations on the rhses themselves<br>\nmust not be unfolded. Hence, they somehow participate in the same game;<br>\nhowever, all three have different implementations.</p>\n<p>My impression is that only a unified mechanism can work out the subtle<br>\nfailures occasionally but stubbornly observed. It would operate somehow<br>\nlike that:</p>\n<ul>\n<li>\n<p>Generalize the existing abbreviations to a machinery which allows<br>\nregistration of syntactic abbreviation equations \"(c :: T) == rhs\" –<br>\nwhether as bare term or ML function, has to be worked out.</p>\n</li>\n<li>\n<p>The class target and ad-hoc overloading would simply reuse that<br>\nabbreviation machinery and stop tinkering with self-baken solutions.</p>\n</li>\n</ul>\n<p>Surely still some time to be invested there, but maybe essential to<br>\nsurvive in the middle run.</p>\n<p>Does this sound reasonable?<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/HqLj26P8GmU_nv1K-O9NvXQR/signature.asc\">signature.asc</a></p>",
        "id": 294645570,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163918
    }
]