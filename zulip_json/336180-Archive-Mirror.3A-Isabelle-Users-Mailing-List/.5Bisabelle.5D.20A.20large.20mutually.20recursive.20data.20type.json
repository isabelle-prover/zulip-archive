[
    {
        "content": "<p>From: Victor Gomes &lt;<a href=\"mailto:vb358@cam.ac.uk\">vb358@cam.ac.uk</a>&gt;<br>\nDear Isabelle experts,</p>\n<p>As part of the Cerberus project, a formalisation of the de-facto C semantics, I was trying to import the model into Isabelle/HOL.</p>\n<p>One of the first files (attached a simplified version) contains a very large mutually recursive data type (with 30 different types, around 5 or 10 constructors each).<br>\nAfter a few minutes waiting a response from Isabelle, I realised there was no hope to try to wait in JEdit.<br>\nTherefore, I decided to build an Isabelle heap file.</p>\n<p>Isabelle took around 40 min to give me the following error:<br>\nISABELLE_BUILD_OPTIONS=\"\"</p>\n<p>ISABELLE_BUILD_JAVA_OPTIONS=\"-Djava.awt.headless=true -Xms512m -Xmx2560m -Xss4m\"</p>\n<p>ML_PLATFORM=\"x86-darwin\"<br>\nML_HOME=\"/Applications/Isabelle2016.app/Contents/Resources/Isabelle2016/contrib/polyml-5.6-1/x86-darwin\"<br>\nML_SYSTEM=\"polyml-5.6\"<br>\nML_OPTIONS=\"-H 500\"</p>\n<p>Session Pure/Pure<br>\nSession HOL/HOL (main)<br>\nSession Unsorted/isabelle_generated<br>\nBuilding isabelle_generated ...<br>\nisabelle_generated: theory Cabs<br>\nRun out of store - interrupting threads<br>\nRun out of store - interrupting threads<br>\nFailed to recover - exiting<br>\nisabelle_generated FAILED</p>\n<p>Since the default ML_OPTIONS is “-H 500”, I increased it to “-H 4000” and gave Isabelle another try.<br>\nThis time I waited for 4 hours… at that point I gave up.</p>\n<p>I’ve decided to give HOL4 a try and the same datatype was handled by HOL4 in minutes (around 2 min, I think).<br>\nI know Isabelle is quite heavy (for good reasons) compared to HOL4, but the difference is astonishing.<br>\nI was wondering if there is any optimisation issue in the Isabelle datatype package.</p>\n<p>Isabelle probably produces a lot more lemmas \"for free\" when defining a datatype, but a slowdown in processing seems to be the price you pay. </p>\n<p>The main question is: <br>\nIs there any hope of definitions like this being practicable within Isabelle/HOL in the future?</p>\n<p>Note that:</p>\n<ul>\n<li>My machine is a MacBook Pro 2015 16GB</li>\n<li>I’ve used Isabelle 2016</li>\n<li>The version of polyml used in both cases (Isabelle and HOL4) are the same, polyml-5.6.</li>\n</ul>\n<p>Best wishes,<br>\nVictor</p>",
        "id": 294669673,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173018
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Victor,</p>\n<p>Isabelle’s new package for datatypes works quite differently from HOL4’s package (and from Isabelle’s old package which was much closer to HOL4’s).</p>\n<p>The new package is known to be slower for mutual types, than the old construction. It is much faster for nested recursion (in “‘a tree = Node ‘a \"‘a tree list” ‘a tree is nested in ‘a list) though, such that in most applications we saw so far the new package was actually faster. I don’t think we ever tried it with more than 15 mutually recursive types.</p>\n<p>I’m quite curious to see you concrete datatype to say if it still might be feasible. (I don’t see any attachment in your mail.)</p>\n<p>Cheers,<br>\nDmitriy</p>",
        "id": 294669685,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173021
    },
    {
        "content": "<p>From: Victor Gomes &lt;<a href=\"mailto:vb358@cam.ac.uk\">vb358@cam.ac.uk</a>&gt;<br>\nHi Dmitriy,</p>\n<p>Thanks for the answer. I have also tried Isabelle2013-2 (which I believe uses the old Isabelle’s package) with no success, although I didn’t wait much longer.</p>\n<p>Please find attached the isabelle theory with the concrete datatype.<br>\nCheers,</p>\n<p>Victor<br>\n<a href=\"/user_uploads/14278/4sYNnhJQ0p3D-AMuRyy2t2D4/Cabs.thy\">Cabs.thy</a></p>",
        "id": 294669707,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173028
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nDear Victor,</p>\n<blockquote>\n<p>Thanks for the answer. I have also tried Isabelle2013-2 (which I believe uses the old Isabelle’s package) with no success, although I didn’t wait much longer.</p>\n</blockquote>\n<p>In principle, we know how to handle such large datatypes. Mutually recursive definitions can be rephrased as nested definitions. For example, instead of</p>\n<p>datatype<br>\n        'a tree_list = Nil | Cons \"'a tree\" \"'a tree_list\" and<br>\n        'a tree = Node 'a \"'a tree_list\"</p>\n<p>one can define</p>\n<p>datatype 'a list = Nil | Cons 'a \"'a list\"<br>\n    datatype 'a tree = Node 'a \"'a tree list\"</p>\n<p>(We call this \"nesting\" because \"'a tree\" occurs recursively nested under \"list\", but this is not standard terminology.) The nested version scales much better than mutual one with modern versions of Isabelle (but much worse in old versions) -- nesting basically comes for free, whereas an n-ary mutual construction is O(n^3) or O(n^4) (Dmitriy might know).</p>\n<p>Given your specification, I see two options:</p>\n<ol>\n<li>\n<p>You could introduce nesting manually, in a more or less ad hoc fashion, inspired by the \"tree_list\" example above. Although this sometimes leads to satisfactory results (as in the \"tree list\" example above), in your case the result surely wouldn't be pretty.</p>\n</li>\n<li>\n<p>We could internally reduce large mutual specifications to nested ones. We already have much of the machinery in place to do this (see the \"Nested-to-Mutual Reduction\" paragraph, starting on p. 5, in our ITP 2014 paper [*]), but some more engineering would be necessary to (1) heuristically generalize some of the types in some groups (i.e. automatizing part 1) and (2) lifting all the results across isomorphisms, so that this is completely invisible to the user (except that it scales much better).</p>\n</li>\n</ol>\n<p>I would expect that point 2 would take us up to one week of work to get it right. It is unfortunately rather technical work. How important is this to you? What are your deadlines? And how acceptable is Option 1?</p>\n<p>Cheers,</p>\n<p>Jasmin</p>\n<p>[*] <a href=\"http://www.loria.fr/~jablanch/co-data-impl.pdf\">http://www.loria.fr/~jablanch/co-data-impl.pdf</a></p>",
        "id": 294669728,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173034
    },
    {
        "content": "<p>From: Victor Gomes &lt;<a href=\"mailto:vb358@cam.ac.uk\">vb358@cam.ac.uk</a>&gt;<br>\nDear Jasmin,</p>\n<p>Thanks for the prompt reply.</p>\n<p>Cerberus is an ongoing project written in Lem [1], which can automatically export to executable code (OCaml), and to interactive theorem provers (HOL4 and Isabelle). Currently, we are able to export the model to OCaml and execute C programs [2]. </p>\n<p>We would like to export the model to a theorem prover and prove some properties about it, but we have not decided each theorem prover yet. We would prefer to use Isabelle, because I have more experience with it. </p>\n<p>The option 1 is clearly not viable, since it would imply change all the current Cerberus code. It would be great if we could try the second option. Since I am still deciding how to proceed, I don’t have firm deadlines yet.</p>\n<p>Cheers,</p>\n<p>Victor</p>\n<p>[1] <a href=\"http://www.cl.cam.ac.uk/~pes20/lem/\">http://www.cl.cam.ac.uk/~pes20/lem/</a><br>\n[2] <a href=\"http://conf.researchr.org/event/pldi-2016/pldi-2016-papers-into-the-depths-of-c-elaborating-the-de-facto-standards\">http://conf.researchr.org/event/pldi-2016/pldi-2016-papers-into-the-depths-of-c-elaborating-the-de-facto-standards</a></p>",
        "id": 294669744,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173040
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nDear Victor,</p>\n<blockquote>\n<p>The option 1 is clearly not viable, since it would imply change all the current Cerberus code. It would be great if we could try the second option. Since I am still deciding how to proceed, I don’t have firm deadlines yet.</p>\n</blockquote>\n<p>The lack of scalability of the \"(co)datatype\" package in terms of mutual recursion has been an annoyance for many years. I believe we have 80% or 90% of the work done towards a scalable solution, thanks to the nested-to-mutual reduction I mentioned in my previous email.</p>\n<p>I hope to be able to come back to you in the next weeks with some good news.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294669983,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173106
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nDear Victor,</p>\n<p>I wrote:</p>\n<p>Dmitriy and I have made some progress on this front, and things look promising, but it might still take two or three weeks before we can push something to Isabelle.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294671525,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173530
    }
]