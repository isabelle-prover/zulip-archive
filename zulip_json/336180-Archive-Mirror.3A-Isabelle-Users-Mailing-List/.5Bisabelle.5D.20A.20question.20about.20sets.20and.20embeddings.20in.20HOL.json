[
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nIs it possible, in HOL, to prove that for any I-indexed collection of sets<br>\n{F i: i ∈ I} there exists a set S that embeds (via injective maps) all of<br>\nthe sets F i and furthermore is weakly universal for this property, so that<br>\nif S' is any other set that embeds all the F i then S' embeds S?<br>\nIn more detail, I am thinking of something like the following:</p>\n<p>definition embeds<br>\n  where \"embeds A B ≡ ∃f. f ∈ B → A ∧ inj_on f B\"</p>\n<p>lemma \"∀F. ∃S. (∀x. embeds S (F x)) ∧ (∀S'. (∀x. embeds S' (F x)) ⟶ embeds S' S)\"</p>\n<p>In ZFC I suppose it would just be possible to take as S the least cardinal<br>\ngreater than the cardinals of all the F i, but I don't have a very clear<br>\nidea of how/whether something similar could be done in HOL.</p>\n<p>Before I spend a lot of time rummaging through the well ordering stuff in<br>\nthe Isabelle library I thought I would risk asking to see if somebody on<br>\nthis list knows the answer instantly.  Thanks for any help you can give.</p>\n<p>- Gene Stark</p>",
        "id": 294671805,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173616
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Gene, </p>\n<p>You can use the disjoint union (which is of course not only weakly, but also strongly universal). <br>\nSearch for the text \"Disjoint union of a family of sets\" in <a href=\"https://isabelle.in.tum.de/dist/library/HOL/HOL/Product_Type.html\">https://isabelle.in.tum.de/dist/library/HOL/HOL/Product_Type.html</a></p>\n<p>All the best, <br>\n  Andrei</p>",
        "id": 294671825,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173623
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Gene,</p>\n<p>while Andrei is right on the high level, I should point out that your lemma does not hold in HOL as stated.</p>\n<p>For instance the type of the existentially quantified \"S :: ‘c set\" might simply be not large enough to embed \"(F :: ‘a =&gt; ‘b set) i” (counterexample: ‘c = unit, ‘a = ‘b = nat, F = %_. UNIV).</p>\n<p>Here is a theorem, which I can prove easily using our cardinals library [1]. It fixes ‘c to be a large enough type to use Sigma as the witness (as Andrei suggested). It also requires the index type ‘a to be infinite and S’ to be larger than the index type as well.</p>\n<p>theory Scratch<br>\nimports<br>\n  \"~~/src/HOL/Library/Cardinal_Notations\"<br>\n  \"~~/src/HOL/Library/FuncSet\"<br>\nbegin</p>\n<p>definition embeds<br>\n where \"embeds A B ≡ ∃f. f ∈ B → A ∧ inj_on f B\"</p>\n<p>lemma embeds_ordLeq: \"embeds A B ⟷ |B| ≤o |A|\"<br>\n  unfolding card_of_ordLeq[symmetric] embeds_def by auto</p>\n<p>lemma<br>\n  fixes F :: \"'a ⇒ 'b set\"<br>\n  assumes \"infinite (UNIV :: 'a set)\"<br>\n  shows \"∃S :: ('a × 'b) set.<br>\n    (∀x. embeds S (F x)) ∧<br>\n    (∀S'. (∀x. embeds S' (F x)) ⟶ embeds S' (UNIV :: 'a set) ⟶ embeds S' S)\"<br>\n  unfolding embeds_ordLeq using assms<br>\n  by (auto simp: image_iff card_of_ordLeq_finite<br>\n   intro!: exI[of _ \"Sigma UNIV F\"] surj_imp_ordLeq[of _ snd] card_of_Sigma_ordLeq_infinite)</p>\n<p>end</p>\n<p>I did not think thoroughly if all my modifications are necessary. I.e., what happens if the index type ‘a is finite?</p>\n<p>Best wishes,<br>\nDmitriy</p>\n<p>[1] Cardinals in Isabelle/HOL<br>\nJasmin Christian Blanchette, Andrei Popescu, Dmitriy Traytel<br>\nITP 2014, <a href=\"http://people.inf.ethz.ch/trayteld/papers/itp14-card/card.pdf\">http://people.inf.ethz.ch/trayteld/papers/itp14-card/card.pdf</a></p>",
        "id": 294671863,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173632
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nAndrei, the disjoint union was not what I wanted, because although it<br>\ndoes in fact embed all the sets, it separates them and thus produces a set that<br>\nis not minimal with respect to embeddings.  If we make identifications we<br>\ncan get a more economical union.  For example if A = {*}, then the disjoint<br>\nunion A+A of A and A is a two-element set, but A itself already embeds A<br>\nand has only one element, so is itself embedded in A+A.</p>\n<p>- Gene Stark</p>",
        "id": 294671897,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173647
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:a.popescu@mdx.ac.uk\">a.popescu@mdx.ac.uk</a>&gt;<br>\nHi Dmitriy and Gene, </p>\n<p>Sorry, I lost sight of the word \"embedding\" in Gene's email... </p>\n<p>Indeed, disjoint union does not fully work, as shown by Dmitriy's need for extra hypotheses. In particular, the size of the index causes trouble. <br>\nFor a full solution, we really need cardinal suprema. In HOL, this is a bit more bureaucratic than in ZFC, but it works. <br>\nWe can fix a well-order on 'b (where the family F has type 'a =&gt; 'b set). <br>\nFor each i::'a, there exists a restriction of this fixed well-order, say, \"k i\", representing the cardinal of \"F i\".<br>\nThe desired weakly universal set is the union of the fields of all these cardinals \"k i\".  </p>\n<p>All the best, <br>\n   Andrei</p>",
        "id": 294671919,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173654
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:a.popescu@mdx.ac.uk\">a.popescu@mdx.ac.uk</a>&gt;<br>\nHi Gene, </p>\n<p>Correct. In my other email I sketch such a (most) economical union, namely, on cardinal representatives. <br>\nThis is useful result in our cardinal library, so I can add it myself. </p>\n<p>Best, <br>\n  Andrei</p>",
        "id": 294671952,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173663
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nThat sounds like the answer I was looking for.  Thank you both for your replies.</p>\n<p>- Gene Stark</p>",
        "id": 294671971,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173669
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Gene,</p>\n<p>Thank you for your question -- this theorem was an important fact missing in our cardinal library, <br>\nand it triggered some further useful infrastructure lemmas. </p>\n<p>A polished version of it will be part of the next distribution. In the meantime, attached is a theory file <br>\nthat has the theorem at the end (also included in this message).  </p>\n<p>All the best, <br>\n  Andrei </p>\n<p>theory Embed imports Main<br>\nbegin</p>\n<p>(* Some order-filter infrastructure *)</p>\n<p>lemma ofilter_embed2:<br>\nassumes r: \"Well_order r\" and e: \"embed r r' f\" and o: \"ofilter r A\"<br>\nshows \"embed (Restr r A) r' f\"<br>\nusing assms Field_Restr_ofilter[OF r o] ofilter_Restr_under[OF r o] <br>\nunfolding embed_def ofilter_embed[OF r] by auto</p>\n<p>lemma ofilter_incl_embed: <br>\nassumes r: \"Well_order r\" and oA: \"ofilter r A\" and oB: \"ofilter r B\"<br>\nand e: \"embed (Restr r A) r' f\" and i: \"B ⊆ A\"<br>\nshows \"embed (Restr r B) r' f\"<br>\nusing Well_order_Restr[OF r] ofilter_Restr_subset[OF r oB i] ofilter_embed2[OF _ e] Restr_subset[OF i] <br>\nby fastforce</p>\n<p>lemma ofilter_int: <br>\nassumes r: \"Well_order r\" and oA: \"ofilter r A\" and oB: \"ofilter r B\"<br>\nshows \"ofilter r (A ∩ B)\"<br>\nby (metis Int_absorb1 Int_absorb2 oA oB r wo_rel.intro wo_rel.ofilter_linord)</p>\n<p>lemma ofilter_UNION: <br>\nassumes \"∀ i ∈ I. ofilter r (A i)\"<br>\nshows \"ofilter r (⋃ i ∈ I. A i)\"<br>\nusing assms unfolding ofilter_def under_def by blast</p>\n<p>lemma Restr_UNION_ofilter: <br>\nassumes \"∀ i ∈ I. ofilter r (A i)\"<br>\nshows \"Restr r (⋃ i ∈ I. A i) = (⋃ i ∈ I. Restr r (A i))\"<br>\nusing assms unfolding ofilter_def under_def by blast</p>\n<p>lemma ofilter_ordLeq_UNION:<br>\nassumes r: \"Well_order r\" and r': \"Well_order r'\"<br>\nand ofl: \"∀ i ∈ I. ofilter r (A i) ∧ ordLeq3 (Restr r (A i)) r'\"<br>\nshows \"ordLeq3 (Restr r (⋃ i ∈ I. A i)) r'\"<br>\nproof-<br>\n  let ?U = \"⋃ i ∈ I. A i\"<br>\n  {fix i assume i: \"i ∈ I\"<br>\n   have \"Well_order (Restr r (A i))\" using Well_order_Restr r by fastforce<br>\n   have \"∃ gi. embed (Restr r (A i)) r' gi\" using ofl i unfolding ordLeq_def by auto<br>\n  }<br>\n  then obtain g where g: \"∀ i ∈ I. embed (Restr r (A i)) r' (g i)\" by metis<br>\n  def ii ≡ \"λ a. SOME i. i ∈ I ∧ a ∈ A i\"<br>\n  def gg ≡ \"λ a. g (ii a) a\"<br>\n  have \"ofilter r ?U\" using ofilter_UNION ofl by metis<br>\n  hence F: \"Field (Restr r ?U) = ?U\" using Field_Restr_ofilter[OF r] by auto<br>\n  have \"embed (Restr r ?U) r' gg\" unfolding embed_def proof<br>\n    fix a let ?i = \"ii a\"<br>\n    assume \"a ∈ Field (Restr r ?U)\"<br>\n    hence \"∃ i. i ∈ I ∧ a ∈ A i\" unfolding F by auto<br>\n    hence i: \"?i ∈ I\" and aa: \"a ∈ A ?i\" unfolding ii_def by (metis (no_types, lifting) someI_ex)+<br>\n    hence a: \"a∈Field (Restr r (A ?i))\" using Field_Restr_ofilter[OF r] ofl by auto<br>\n    hence 1: \"bij_betw (g ?i) (under (Restr r (A ?i)) a) (under r' (g ?i a))\" using g i unfolding embed_def by auto<br>\n    have 2: \"under (Restr r ?U) a = under (Restr r (A ?i)) a\"<br>\n    using aa ofl i aa unfolding under_def ofilter_def by auto<br>\n    {fix b assume 0: \"b ∈ under (Restr r (A ?i)) a\"<br>\n     let ?j = \"ii b\"<br>\n     have \"b ∈ Field (Restr r ?U)\" using 2 subsetCE under_Field 0 by fastforce<br>\n     hence \"∃ i. i ∈ I ∧ b ∈ A i\" unfolding F by auto<br>\n     hence j: \"?j ∈ I\" and bb: \"b ∈ A ?j\" unfolding ii_def by (metis (no_types, lifting) someI_ex)+<br>\n     hence b: \"b ∈ Field (Restr r (A ?j))\" using Field_Restr_ofilter[OF r] ofl by auto<br>\n     hence 1: \"embed (Restr r (A ?j)) r' (g ?j)\" using g j by auto<br>\n     let ?B = \"A ?i ∩ A ?j\"<br>\n     have b: \"b ∈ ?B\" by (metis 0 Int_iff bb mem_Collect_eq mem_Sigma_iff under_def)<br>\n     have 11: \"embed (Restr r (A ?i)) r' (g ?i)\" using g i by auto<br>\n     have oB: \"ofilter r ?B\" using ofl i j ofilter_int r by fastforce<br>\n     hence B1: \"embed (Restr r ?B) r' (g ?i)\" using 11 i inf_le1 ofilter_incl_embed ofl r by fastforce  <br>\n     have B2: \"embed (Restr r ?B) r' (g ?j)\" using 1 j by (metis oB inf_commute inf_le1 ofilter_incl_embed ofl r)<br>\n     have B: \"Well_order (Restr r ?B)\" using Well_order_Restr r by blast<br>\n     have \"g ?i b = g ?j b\" using b B1 B2 embed_unique[OF B r' B1 B2] Field_Restr_ofilter i j ofilter_int ofl r by blast<br>\n    }<br>\n    thus \"bij_betw gg (under (Restr r ?U) a) (under r' (gg a))\" using 1 2 unfolding gg_def <br>\n    unfolding bij_betw_def inj_on_def image_def by auto<br>\n  qed<br>\n  thus ?thesis unfolding ordLeq_def using Restr_UNION_ofilter ofl r' <br>\n  by (auto simp: Well_order_Restr r)<br>\nqed</p>\n<p>(* Cardinal suprema (for a family of cardinals on the same host type) *)</p>\n<p>context fixes I :: \"'i set\" and k :: \"'i ⇒ 'a rel\" <br>\nbegin</p>\n<p>definition K::\"'a rel\" where \"K = card_of UNIV\"</p>\n<p>lemma card_order_K: \"card_order K\"<br>\nby (simp add: Embed.K_def card_of_card_order_on)</p>\n<p>lemma ordLeq_K: <br>\nassumes \"Card_order (k i)\" shows \"ordLeq3 (k i) K\"<br>\nby (metis Card_order_iff_ordLeq_card_of Embed.K_def UNIV_I assms card_of_mono1 <br>\n          ordLeq_transitive subsetI)</p>\n<p>definition f :: \"'i ⇒ 'a ⇒ 'a\" where <br>\n\"f i ≡ SOME f. embed (k i) K f\"</p>\n<p>lemma embed_f: <br>\nassumes \"Card_order (k i)\"<br>\nshows \"embed (k i) K (f i)\"<br>\nunfolding f_def<br>\napply(rule someI_ex[of \"%f. embed (k i) K f\"])<br>\nunfolding K_def <br>\nby (metis Cnotzero_UNIV K_def assms card_order_on_def not_ordLess_ordLeq ordLeq_K ordLess_iff)</p>\n<p>definition A :: \"'i ⇒ 'a set\" where <br>\n\"A i ≡ f i ` (Field (k i))\"</p>\n<p>lemma iso_A: <br>\nassumes \"Card_order (k i)\"<br>\nshows \"iso (k i) (Restr K (A i)) (f i)\"<br>\nby (metis A_def Embed.K_def Embed.card_order_K Embed.embed_f Field_card_of <br>\n          assms card_order_on_def embed_implies_iso_Restr)</p>\n<p>lemma ordIso2_A: <br>\nassumes \"Card_order (k i)\"<br>\nshows \"ordIso2 (k i) (Restr K (A i))\"<br>\nusing iso_A[OF assms] assms card_order_on_def unfolding ordIso_def <br>\nby (auto simp: K_def Well_order_Restr card_of_Well_order)</p>\n<p>lemma Card_order_A: <br>\nassumes \"Card_order (k i)\"<br>\nshows \"Card_order (Restr K (A i))\"<br>\nusing Card_order_ordIso2 ordIso2_A[OF assms] assms by blast</p>\n<p>definition csupr :: \"'a rel\" where <br>\n\"csupr ≡ card_of (⋃ i ∈ I. A i)\"   </p>\n<p>lemma Card_order_csupr: <br>\n\"Card_order csupr\"<br>\nby (simp add: csupr_def card_of_Card_order)</p>\n<p>lemma ordLeq_csupr:<br>\nassumes c:  \"∀ i ∈ I. Card_order (k i)\"  and i: \"i ∈ I\" <br>\nshows \"ordLeq3 (k i) csupr\"<br>\nproof-<br>\n  let ?k = \"card_of (Field (k i))\"<br>\n  have \"ordIso2 (k i) (Restr K (A i))\" using ordIso2_A c i by auto<br>\n  also have \"ordIso2 (Restr K (A i)) (card_of (A i))\" <br>\n  by (metis Card_order_A Embed.A_def c card_of_unique i iso_A iso_Field)<br>\n  also have \"ordLeq3 (card_of (A i)) csupr\" unfolding csupr_def <br>\n  by (meson UN_I assms(2) card_of_mono1 subsetI)<br>\n  finally show ?thesis .<br>\nqed</p>\n<p>lemma ofilter_A: <br>\nassumes ci: \"Card_order (k i)\" <br>\nshows \"ofilter K (A i)\"<br>\nusing ci iso_A[OF ci] unfolding A_def<br>\nby (metis Cnotzero_UNIV embed_f K_def card_order_on_well_order_on embed_Field_ofilter)</p>\n<p>lemma csupr_ordLeq:<br>\nassumes ci: \"∀ i ∈ I. Card_order (k i)\" <br>\nand c: \"Card_order r\"<br>\nand ord: \"⋀ i. i ∈ I ⟹ ordLeq3 (k i) r\" <br>\nshows \"ordLeq3 csupr r\"<br>\nproof-<br>\n  let ?U = \"⋃ i ∈ I. A i\"<br>\n  let ?restr = \"Restr K ?U\"<br>\n  have 0: \"∀i ∈ I. ofilter K (A i)\" using ofilter_A ci by auto<br>\n  have restr: \"Well_order ?restr\" and K: \"Well_order K\" and r: \"Well_order r\"<br>\n  using c card_order_on_def by (auto simp: Field_card_of K_def Well_order_Restr card_of_well_order_on)<br>\n  have \"Field ?restr = ?U\" <br>\n  using ofilter_A ofilter_UNION 0 by (intro Field_Restr_ofilter) (auto simp: K_def Field_card_of card_of_well_order_on)<br>\n  hence 1: \"well_order_on ?U ?restr\" using restr by auto<br>\n  have restr: \"?restr = (⋃ i ∈ I. Restr K (A i))\" using Restr_UNION_ofilter[OF 0] by auto<br>\n  have 2: \"⋀ i. i ∈ I ⟹ ordLeq3 (Restr K (A i)) r\" <br>\n  using ord by (metis ordIso2_A ci ordIso_iff_ordLeq ordLeq_transitive)<br>\n  have \"ordLeq3 (card_of ?U) ?restr\" using 1 card_of_least by blast<br>\n  also have \"ordLeq3 ?restr r\" using ofilter_ordLeq_UNION[OF K r] 0 2 by metis<br>\n  finally show ?thesis unfolding csupr_def .<br>\nqed</p>\n<p>end (* context *)</p>\n<p>hide_const A K f</p>\n<p>term csupr<br>\nthm Card_order_csupr<br>\nthm ordLeq_csupr<br>\nthm csupr_ordLeq</p>\n<p>definition \"embeds A B ≡ ∃ f. f ` B ⊆ A ∧ inj_on f B\"</p>\n<p>lemma embeds_ordLeq: \"embeds A B ⟷ ordLeq3 (card_of B) (card_of A)\"<br>\nunfolding card_of_ordLeq[symmetric] embeds_def by auto</p>\n<p>lemma embeds_universal: <br>\nfixes I :: \"'i set\" and F :: \"'i ⇒ 'a set\" <br>\ndefines \"S ≡ Field (csupr I (card_of o F))\"<br>\nshows \"(∀ i. i ∈ I ⟶ embeds S (F i)) ∧<br>\n       (∀ S'. (∀ i. i ∈ I ⟶ embeds S' (F i)) ⟶ embeds S' S)\"<br>\nproof-  <br>\n  have 1: \"∀ i ∈ I. Card_order ((card_of o F) i)\"<br>\n  by (simp add: Field_card_of card_of_card_order_on)<br>\n  have \"ordIso2 (card_of S) (csupr I (card_of o F))\" <br>\n  unfolding S_def using card_of_Field_ordIso[OF Card_order_csupr] .<br>\n  with ordLeq_csupr[OF 1] csupr_ordLeq[OF 1]<br>\n  show ?thesis unfolding S_def embeds_ordLeq o_def <br>\n  by safe (simp add: Field_card_of csupr_def, <br>\n           simp add: card_of_Card_order csupr_ordLeq ordIso_ordLeq_trans)<br>\nqed</p>\n<p>end<br>\n<a href=\"/user_uploads/14278/HqLeVj2OdcFbnB2M4VZz_qSY/Embed.thy\">Embed.thy</a></p>",
        "id": 294672079,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173691
    }
]