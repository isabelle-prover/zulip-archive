[
    {
        "content": "<p>From: Jesus Aransay &lt;<a href=\"mailto:jesus-maria.aransay@unirioja.es\">jesus-maria.aransay@unirioja.es</a>&gt;<br>\nDear all,</p>\n<p>I was trying to introduce some additional notation for linear<br>\nfunctionals in vector spaces; the idea is to use:</p>\n<p>\"[x, f]\" as an alternative notation for \"f x\", where \"f\" is a linear<br>\nfunctional (let's say, type \"'a =&gt; 'b\") and \"x\" is an element of type<br>\n\"'a\" (note that the arguments f and x are interchanged in the proposed<br>\nnotation).</p>\n<p>I would like that all notation available for \"f x\" would still work<br>\nfor the new notation \"[x, f]\", in such a way that</p>\n<p>[x, f] \\oplus [y, f]</p>\n<p>would be equivalent to (without unfolding any particular definition):</p>\n<p>f x \\oplus f y</p>\n<p>Is it possible to reach these behavior? How? Maybe brackets are<br>\nalready a bit overloaded in terms of notation (lists, propositions...)<br>\nso a notation based for instance in \"&lt;x, f &gt;\" would be also<br>\nacceptable.</p>\n<p>I tried the following approach (which does not interchange arguments)</p>\n<p>abbreviation<br>\n  app :: \"('b =&gt; 'a) =&gt; 'b =&gt; 'a\" (\"&lt;(_),(_)&gt;\" 90)<br>\n  where \"&lt;f, x&gt; == f x\"</p>\n<p>but then when I write, for instance, \"term &lt;f, x&gt;\" the system does not<br>\nseem to find the correct type of the expression.</p>\n<p>Thanks for any hint,</p>\n<p>Jesus</p>",
        "id": 294143352,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846643
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Jesus,</p>\n<p>do you need your notation only as input syntax or do you want Isabelle to print <br>\nfunction application this way, too? If it is for input only, you just have to <br>\nrestrict your abbreviation to the input parser and it works fine:</p>\n<p>abbreviation (input)<br>\n    app :: \"('b =&gt;  'a) =&gt;  'b =&gt;  'a\" (\"&lt;(_),(_)&gt;\" 90)<br>\n    where \"&lt;f, x&gt; == f x\"</p>\n<p>term \"&lt;f, x&gt;\"</p>\n<p>Without the (input) restriction, Isabelle's pretty printer loops when it tries <br>\nto display the term again. I do not recommend that you use such syntax <br>\ntranslations for output, because such a translation would apply to all function <br>\napplications, which is probably not what you want. You could, however, restrict <br>\nyour translation to certain type classes (e.g., arbitrary functions from vector <br>\nspaces to vector spaces). Still, you will have to install your own print <br>\ntranslation to guarantee termination of the pretty printer.</p>\n<p>By the way, any notation that works for \"f x\" also works for \"[x, f]\" even \"[x, <br>\nf]\" is a proper constant instead of an abbreviation.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294143578,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846712
    }
]