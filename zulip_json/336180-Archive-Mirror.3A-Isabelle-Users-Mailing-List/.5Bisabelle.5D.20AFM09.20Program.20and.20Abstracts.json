[
    {
        "content": "<p>From: Sam Owre &lt;<a href=\"mailto:owre@csl.sri.com\">owre@csl.sri.com</a>&gt;<br>\nFourth Workshop on Automated Formal Methods<br>\n       (<a href=\"http://fm.csl.sri.com/afm09\">http://fm.csl.sri.com/afm09</a>)<br>\n       In association with CAV 2009 (<a href=\"http://www-cav2009.imag.fr/\">http://www-cav2009.imag.fr/</a>)<br>\n         June 27, 2009<br>\n         Grenoble, France</p>\n<p>9:00   :  Empty (SPIN has invited talk by Joseph Sifakis;<br>\n                 RV has invited talk by Sriram Rajamani)</p>\n<p>10:30  :  Alwyn Goodloe, Corina Pasareanu, David Bushnell and Paul Miner.<br>\n          A Test Generation Framework for Distributed Fault-Tolerant<br>\n          Algorithms<br>\n10:55  :  Luca Chiarabini.<br>\n          Automatic Synthesis of an Efficient Algorithm for the<br>\n      Similarity of Strings Problem<br>\n11:20  :  Anduo Wang and Boon Thau Loo.<br>\n          Formalizing Meta-Routing in PVS<br>\n11:45  :  Hassen Saidi<br>\n          Challenges in analyzing binary programs (Invited tutorial)</p>\n<p>12:30  :  Lunch</p>\n<p>2:00   :  Susanne Graf<br>\n          Contracts for the component-based design of embedded and<br>\n          distributed systems (Invited tutorial)<br>\n2:45   :  Bernhard Steffen<br>\n          Continuous Model.Driven Engineering -<br>\n        Formal Methods at the Application  (Invited tutorial)<br>\n3:30   :  Coffee<br>\n4:00   :  Ilya Lopatkin, Daniel Plagge, Alexei Iliasov, Michael Leuschel and<br>\n             Alexander Romanovsky.<br>\n      SAL, Kodkod, and BDDs for Validation of B Models<br>\n4:25   :  Silvio Ghilardi and Silvio Ranise<br>\n          Model-Checking Modulo Theories at Work: The integration of Yices<br>\n          in MCMT<br>\n4:50   :  Jean-Francois Couchot, Alain Giorgetti and Nicolas Stouls<br>\n          Graph-based Reduction of Program Verification Conditions<br>\n5:15   :  Jean-Francois Filliatre<br>\n          Why - an intermediate language for deductive program verification<br>\n        (Invited tutorial)<br>\n6:00   :  Close of Workshop</p>\n<p>Abstracts<br>\nTitle: Challenges in analyzing binary programs<br>\nSpeaker: Hassen Saidi (SRI Computer Science Laboratory)</p>\n<p>Abstract: Program analysis is an enough challenging task<br>\nwhen source code is available. It is even more challenging when<br>\nneither the source code nor debug information is present.  The<br>\nanalysis task is further hindered when the available<br>\nbinary code has been obfuscated to prevent the analysis from being<br>\ncarried out.  In this presentation, we review the main challenges when<br>\nanalyzing binary programs and explore techniques for recovery of<br>\ninformation that allows program understanding and<br>\nreverse-engineering. We illustrate these techniques on the Conficker<br>\nworm that has plagued the Internet in the past few months.</p>\n<p>Title: Contracts for the component-based design of embedded and distributed<br>\n       systems <br>\nSpeaker: Susanne Graf</p>\n<p>Abstract: Distributed, real-time and embedded systems usually multiple<br>\nlayers from the high-level functional layers down to the interaction with<br>\nhardware. The design of such systems leads to complex hierachical<br>\narchitectures with components subject to multiple constraints.  The BIP<br>\ncomposition operators allow specifying complex multi-party interactions<br>\nbetween components in a hierarchical fashion, and by separating component<br>\nbehaviour and interaction between components. It is expressive enough to<br>\ndescribe the interaction of a set of peers so as to abstract lower layers as<br>\ncomposition operator represented by a set of connectors and their<br>\ninteractions.  We define a notion of contract associated with components<br>\nwhich strictly separates an expectation which it may have on the<br>\nenvironment, called &lt;&lt;assumption&gt;&gt;, and a &lt;&lt;promise&gt;&gt; which is behaviour of<br>\nthe component under consideration that the environment may take for granted<br>\nas long as it respects the component's expectation. Contrary to most notions<br>\nof contracts, it does not express the assumptions directly on the<br>\ncomponent's interface but as a constraint on it's peers to which it is<br>\nconnected by a rich connectors as in BIP.  We do not intend contracts to be<br>\nused for compositional verification but rather for compositional design and<br>\nindependent implementation of components. Assumptions allow simplifying<br>\ncomponent implementations by relying on properties ensured by the<br>\nenvironment. An interesting of our kind of contracts is to allow expressing<br>\nalso assumptions which need not to be expressible on the component's<br>\ninterface. This means that the component interfaces need not to be<br>\n\"artificially\" enriched with analysis related attributes. Moreover,<br>\nknowledge about peers and about lower layers is clearly separated, and<br>\nspecifications of lower layers, represented by a set of connectors, may be<br>\nrefined independently of components.  So far, we have shown that this<br>\ngeneral contract framework is indeed a generalisation of all existing<br>\nnotions of interface specifications or contracts that we have studied and<br>\nproposed some general methodology. Here, we propose also a set of useful<br>\nconcepts which can be used to actually express contracts for components<br>\nwhich must comply to safey and progress constraints.</p>\n<p>Title: Continuous Model.Driven Engineering - Formal Methods at the<br>\n       Application Level <br>\nSpeaker: Bernhard Steffen</p>\n<p>Abstract: Agility is a must, in particular for business-critical<br>\napplications.  Complex systems and processes must be continuously updated in<br>\norder to meet the ever changing market conditions. Continuous Model Driven<br>\nEngineering addresses this need by by continuously involving the<br>\ncustomer/application expert throughout the whole systems? life cycle<br>\nincluding maintenance and evolution. Conceptually, it is based on the One<br>\nThing Approach (OTA), which combines the simplicity of the waterfall<br>\ndevelopment paradigm with a maximum of agility. The key to OTA is to view<br>\nthe whole development process simply as a complex hierarchical and<br>\ninteractive decision process, where each stakeholder, including the<br>\napplication expert, is allowed to continuously place his/her decisions in<br>\nterm of constraints. Thus semantically, at any time, the state of the<br>\ndevelopment or evolution process can simply be regarded as the current set<br>\nof constraints, and each development or evolution step can be regarded<br>\nsimply as a transformation of this very constraint set. This approach,<br>\nconceptually, allows one 1) to monitor globally and at any time the<br>\nconsistency of the development or evolution process simply via constraint<br>\nchecking, and 2) to impose a kind of decision hierarchy by mapping areas of<br>\nompetencies to roles of individuals, in order to identify required actions<br>\nin case of constraint violation. The essence and power of this approach,<br>\nwhich is technically supported by the jABC development and execution<br>\nframework, will be illustrated along real life application scenarios.</p>\n<p>Title: Why - an intermediate language for deductive program verification<br>\nSpeaker: Jean Christophe Filliatre</p>\n<p>Abstract: This tutorial is an introduction to the Why tool, an intermediate<br>\nlanguage for deductive program verification. The purpose of the Why tool is<br>\ntwo-fold: first, it computes weakest preconditions for a small alias-free<br>\nprogramming language, which is designed to be the target of other<br>\nverification tools for languages such as C or Java; second, it translates<br>\nverification conditions into the native languages of several existing<br>\ntheorem provers, either automatic such as Simplify, Alt-Ergo, Yices, Z3,<br>\netc. or interactive such as Coq, PVS, Isabelle, etc. Why is currently used<br>\nin several verification frameworks such as Caduceus, Krakatoa, or Frama-C.</p>",
        "id": 294078620,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829891
    }
]