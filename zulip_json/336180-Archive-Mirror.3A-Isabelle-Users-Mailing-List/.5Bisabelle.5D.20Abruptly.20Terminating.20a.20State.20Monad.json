[
    {
        "content": "<p>From: scott constable &lt;<a href=\"mailto:sdconsta@syr.edu\">sdconsta@syr.edu</a>&gt;<br>\nHi All,</p>\n<p>I'm currently trying to reason in AutoCorres about a bit of code which may<br>\nabruptly terminate. What I'm trying to prove is something like this:</p>\n<p>{| &lt;\\lambda&gt; s. True |}<br>\ninteresting_function() {<br>\n    global_flag = 0;<br>\n    if (condition)<br>\n        reboot();<br>\n    else<br>\n        global_flag = 1;<br>\n    return;<br>\n}<br>\n{| &lt;\\lambda&gt; s _. global_flag = 1 |}</p>\n<p>Clearly, interesting_function() will only return with global_flag set to 1,<br>\nbut I'm not sure how a state monadic framework could possibly model the<br>\nreboot() call. After interesting_function() returns, another function, say<br>\ninteresting_function2() will be called with global_flag=1 as a<br>\nprecondition.</p>\n<p>At a high level, I'm trying to prove reachability. That is,<br>\ninteresting_function2() is reachable only if condition=false in<br>\ninteresting_function1(). So it's also possible that I'm using entirely the<br>\nwrong approach here.</p>\n<p>Thanks in advance for any feedback.</p>\n<p>~Scott Constable</p>",
        "id": 294329898,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929882
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nHi Scott,</p>\n<p>you’re right that this will not be properly representable in the monadic framework AutoCorres uses, because that wants termination for everything.</p>\n<p>It’s conceivable that you might be able get away with manually defining (axiomatising) reboot as MAGIC, i.e. the function that returns the empty set and does not fail. Should be equivalent to a C-level specification that claims the function terminates with post condition False.</p>\n<p>You’ll need to think about what that really means, though, and if that agrees with what you want to prove. I haven’t thought too much about this, might be that this is a more general way to deal with non-termination, or it might break down at some point.</p>\n<p>Depending on if it would be Ok to propagate “condition” up through your preconditions, you could also model “reboot()” as “unreachable”, i.e. a function with precondition False, which will require you to prove that it is never called. (This is what we use for “halt()”, since we never want that to happen.)</p>\n<p>Cheers,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294330551,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930084
    },
    {
        "content": "<p>From: scott constable &lt;<a href=\"mailto:sdconsta@syr.edu\">sdconsta@syr.edu</a>&gt;<br>\nThanks Gerwin,</p>\n<p>We've been toying with your ideas and a few others over the past week, and<br>\nhave observed that both techniques you've described (MAGIC and making<br>\nreboot() \"unreachable\") amount to the same thing: stating preconditions<br>\nwhich ensure that reboot() is never called. While this helps us to reason<br>\nabout program behavior when reboot() is called, it also prevents us from<br>\nreasoning about program behavior when reboot() is called. For example, we<br>\ncould prove something like the following:</p>\n<p>{ P s }<br>\nentire_program<br>\n{ True }!</p>\n<p>where P is the conjunction of all the assumptions which need to hold in<br>\norder for entire_program to terminate properly (i.e. not call reboot()).</p>\n<p>This, I believe, is essentially stating that \"if P s holds, then<br>\nentire_program() terminates properly.\" But what we are more interested in<br>\nis proving the statement \"entire_program will terminate properly *only if *P<br>\ns holds.\"</p>\n<p>~Scott</p>",
        "id": 294632129,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661158720
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nI guess the short summary here is that there won't be a quick fix. The<br>\ntype of the state monad has to change.</p>\n<p>Some kind of exception/state monad combination will be an appropriate<br>\ntype for your function. So reboot() will be able to abort all subsequent<br>\nactions (exception monad) but keep the current state (state monad).</p>\n<p>The problem is that AutoCorres won't produce such a monad, and the<br>\nbigger problem is that the C-parser won't assign appropriate semantics.<br>\nWe've had this discussion at NICTA before - there was a fast abort<br>\nmechanism that would be useful in seL4 - but the problem is that<br>\nanything like this isn't really C. The only C approximation is<br>\nsetjmp/longjmp which is horrible and isn't going to be supported.</p>\n<p>In short, we don't really know what to do about this. It's clear there's<br>\na lot of C code out there with nonreturning functions, so maybe we<br>\nshould think about how to support it at the C semantics level. Having<br>\nAutoCorres deal with this by returning a more general monad type won't<br>\nbe too difficult. But I think this is low priority for NICTA at the moment.</p>\n<p>Cheers,<br>\n     Thomas.</p>\n<p>P.S. The reason we had this discussion at NICTA before is to do with<br>\nseL4's design. It uses a syscall stack model, where every OS entry lives<br>\non a newly created stack. This makes a convenient operation possible (if<br>\nwritten in assembly): a function which discards the running stack<br>\nentirely and either reenters the OS with new toplevel arguments or<br>\nreturns to user level. I guess it's a lot like a reboot, only it happens<br>\nto be really fast. Supporting this would allow us to shrink the kernel<br>\ncode a lot - there's lots of caller/callee pairs where the caller has to<br>\ncheck for failure, and where the callee could instead call the failure<br>\nhandling mechanism then abort everything.</p>\n<p>it would be convenient in OS's such as seL4 to implement the action that<br>\naborts everything in the current system call stack, and either re-enters<br>\nthe kernel or returns to user mode. A bit like rebooting, I suppose,<br>\nalthough much faster. The SIMPL semantics that the C semantics builds on<br>\nhas an exception mechanism that would work for this purpose, but the<br>\nproblem is that it isn't really C.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294633612,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159281
    }
]