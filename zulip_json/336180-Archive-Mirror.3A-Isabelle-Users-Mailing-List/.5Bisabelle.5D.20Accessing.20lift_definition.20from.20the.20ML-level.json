[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>playing a little bit further, I could establish part of what I wanted by using lift_def_cmd and<br>\nconverting types and terms back to strings (which are immediately parsed again in lift_def_cmd)</p>\n<p>fun lift_def_ml (binding,mixfix) ty rhs ctxt tactic = <br>\n        let val ctxt' = Config.put show_markup false ctxt<br>\n            val term_to_string = Print_Mode.setmp [] (Syntax.string_of_term ctxt')<br>\n            val typ_to_string = Print_Mode.setmp [] (Syntax.string_of_typ ctxt')<br>\n            val state = Lifting_Def.lift_def_cmd <br>\n                 ((binding, SOME (typ_to_string ty), mixfix), term_to_string rhs, []) ctxt<br>\n        in <br>\n          state<br>\n        end</p>\n<p>However, now I am left with turning a Proof.state into a context again (which should be done<br>\nvia the provided tactic). So, is there some common function of type</p>\n<p>state -&gt; tactic -&gt; context</p>\n<p>In proof.ML I only found functions like </p>\n<p>global_qed which take \"Method.text_range option * bool\", but no tactics.</p>\n<p>Kind regards,<br>\nRené</p>",
        "id": 294316430,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925613
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust syntactically, this one works out, but I did not try it on concrete<br>\nexamples:</p>\n<p>val term_to_string = YXML.string_of_body o Term_XML.Encode.term;<br>\n   val typ_to_string = YXML.string_of_body o Term_XML.Encode.typ;</p>\n<p>fun lift_def_ml (binding, mx) ty rhs tactic lthy =<br>\n     let<br>\n       val method = (Method.Basic (SIMPLE_METHOD o tactic), Position.no_range);<br>\n     in<br>\n       lthy<br>\n       |&gt; Lifting_Def.lift_def_cmd<br>\n         ((binding, SOME (typ_to_string ty), mx), term_to_string rhs, [])<br>\n      |&gt; Proof.global_terminal_proof (method, NONE)<br>\n     end</p>\n<p>I have made this a bit more canonical according to Isabelle/ML standards, <br>\nconcerning names and argument order. In particular, a lthy: local_theory <br>\nvalue should not be called \"ctxt\".  See the \"implementation\" manual for <br>\nfurther important information on Isabelle/ML.</p>\n<p>The YXML representation of typ/term values should help to circumvent the <br>\naccidental omission of proper ML programming interfaces: the inner syntax <br>\nparser understands that funny machine-oriented notation.  Printing terms <br>\nfor parsing them again should never be done in real life.</p>\n<p>The Proof.global_terminal_proof is \"by method\" in Isar syntax.</p>\n<p>You've put the term \"ML-level of Isabelle\" into the subject line.  This is <br>\nleading to bad things as encountered here: people then wrongly think that <br>\nIsabelle/ML somehow happens in a cold and damp cellar, and \"users\" are <br>\nonly found in Isar syntax (but I call the second category \"end-users\").</p>\n<p>The comments in $ISABELLE_HOME/src/HOL/Tools/Lifting/lifting.ML use the <br>\nterm \"user-friendly\" for lift_def_cmd in this defective sense: only a <br>\nsource text interface, without a regular ML entry point (without the <br>\n\"_cmd\" suffix). It is quite awkward to imitate surface Isar syntax <br>\nwrapping in ML.</p>\n<p>Isabelle/ML programming is a normal Isabelle user activity, happing at the <br>\nmain user-level of Isabelle.  Any package should provide normal ML <br>\nprogramming interfaces in parallel to the end-user version -- there are <br>\nstandard patterns to fold the two implementations into one.</p>\n<p>Makarius</p>\n<hr>\n<p><a href=\"http://stop-ttip.org\">http://stop-ttip.org</a></p>\n<hr>",
        "id": 294317173,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925803
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Makarius,</p>\n<blockquote>\n<blockquote>\n<p>However, now I am left with turning a Proof.state into a context again (which should be done via the provided tactic). So, is there some common function of type</p>\n<p>state -&gt; tactic -&gt; context</p>\n<p>In proof.ML I only found functions like</p>\n<p>global_qed which take \"Method.text_range option * bool\", but no tactics.</p>\n</blockquote>\n<p>Just syntactically, this one works out, but I did not try it on concrete<br>\nexamples:</p>\n<p>val term_to_string = YXML.string_of_body o Term_XML.Encode.term;<br>\n val typ_to_string = YXML.string_of_body o Term_XML.Encode.typ;</p>\n<p>fun lift_def_ml (binding, mx) ty rhs tactic lthy =<br>\n   let<br>\n     val method = (Method.Basic (SIMPLE_METHOD o tactic), Position.no_range);<br>\n   in<br>\n     lthy<br>\n     |&gt; Lifting_Def.lift_def_cmd<br>\n       ((binding, SOME (typ_to_string ty), mx), term_to_string rhs, [])<br>\n    |&gt; Proof.global_terminal_proof (method, NONE)<br>\n   end</p>\n</blockquote>\n<p>thanks a lot, that works perfectly in my setting.</p>\n<blockquote>\n<p>I have made this a bit more canonical according to Isabelle/ML standards, concerning names and argument order. In particular, a lthy: local_theory value should not be called \"ctxt\".  See the \"implementation\" manual for further important information on Isabelle/ML.<br>\ndone.</p>\n</blockquote>\n<blockquote>\n<p>You've put the term \"ML-level of Isabelle\" into the subject line.  </p>\n</blockquote>\n<p>I'll try to use Isabelle/ML the next time.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294317318,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925858
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I have a question regarding the lifting package.<br>\nIs there some canonical way of simulating</p>\n<p>lift_definition name :: typ is term &lt;proof&gt; </p>\n<p>on the ML-level (where &lt;proof&gt; might be replaced by some tactic)</p>\n<p>In the current interface I only found</p>\n<p>val add_lift_def:<br>\n    (binding * mixfix) -&gt; typ -&gt; term -&gt; thm -&gt; thm list -&gt; local_theory -&gt; local_theory</p>\n<p>val lift_def_cmd:<br>\n    (binding * string option * mixfix) * string * (Facts.ref * Args.src list) list -&gt; local_theory -&gt; Proof.state</p>\n<p>where add_list_def seems more closely to what I need, but I have no clue what \"thm\" and \"thm list\" are good for.<br>\nIf there would be something like the following, then everything is clear,</p>\n<p>val add_lift_def:<br>\n    (binding * mixfix) -&gt; typ -&gt; term -&gt; tactic -&gt; local_theory -&gt; local_theory</p>\n<p>but with the current add_lift_def and passing some thm and an empty thm list, I got complaints that</p>\n<p>exception THM 1 raised (line 332 of \"drule.ML\"):<br>\n  RSN: no unifiers<br>\n  P defau<br>\n  rel_fun (eq_onp (λx. x ∈ {(b, c). c ⟶ P b})) (eq_onp P) ?c ?c ⟹<br>\n  ?c' ≡ map_fun Test.Rep_restricted_cond Abs_restricted ?c ⟹<br>\n  rel_fun Test.cr_restricted_cond cr_restricted ?c ?c'</p>\n<p>Do I really have to create a theorem that unifies against internals in the lifting construction?</p>\n<p>rel_fun (eq_onp (λx. x ∈ {(b, c). c ⟶ P b})) (eq_onp P) ?c ?c ⟹<br>\n  ?c' ≡ map_fun Test.Rep_restricted_cond Abs_restricted ?c ⟹<br>\n  rel_fun Test.cr_restricted_cond cr_restricted ?c ?c' ?</p>\n<p>To compare with, if I invoke the lift_definition command manually, the proof goal is</p>\n<p>⋀prod. prod ∈ {(b, c). c ⟶ P b} ⟹ P (case prod of (b, c) ⇒ if c then b else defau)</p>\n<p>so, some proof goal that I can easily discharge using \"P defau\" by (simp split: prod.splits)</p>\n<p>Kind regards,<br>\nRené</p>",
        "id": 294318406,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926189
    }
]