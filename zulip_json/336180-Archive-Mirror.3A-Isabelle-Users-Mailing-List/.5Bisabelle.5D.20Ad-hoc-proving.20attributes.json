[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\n(My apologies for the somewhat mysterious subject line.)</p>\n<p>I was wondering whether it'd make sense to unify the mechanisms behind<br>\n\"inductive_cases\", \"inductive_simps\", \"fun_cases\" etc.; namely, commands<br>\nwhich prove some theorems on the spot, but apart from binding them to a<br>\nname, have no further side effects on the theory.</p>\n<p>My main motivation for this is that, sometimes, I need \"ad hoc\"<br>\nelimination rules, and since \"inductive_cases\" doesn't work in proof<br>\nblocks, I end up with the rather awkward pattern of declaring them<br>\noutside the proof and hiding them afterwards again. My initial thought<br>\nwas to make a variant of the command which works in a proof block (c.f.<br>\n\"lemmas\" vs \"note\", \"interpretation\" vs \"interpret\"), but if<br>\nIsabelle/HOL doesn't need more of one things, it's keywords.</p>\n<p>So, here's my proposal: Instead of an \"inductive_cases\" command, have an<br>\n\"inductive_cases\" attribute. It could be used like this:</p>\n<p>lemmas fooE[elim] = [[inductive_cases \"R (T x) (T y)\"]]</p>\n<p>or this:</p>\n<p>then have \"R a b\"<br>\n    using [[inductive_cases \"R (T x) (T y)\"]]</p>\n<p>This would already work out of the box by declaring a \"rule_attribute\"<br>\nwhich ignores its incoming \"thm\" argument.</p>\n<p>Is that something people would be interested in?</p>\n<p>(NB: What follows are some technical details which would probably belong<br>\nto [isabelle-dev], but I don't want to split this thread.)</p>\n<p>Cheers<br>\nLars</p>\n<hr>\n<p>Making my case for \"inductive_cases\" is easy, because I could implement<br>\nit with the existing tools, because it always proves a single theorem.<br>\nIf we want to be fully general though, it gets more complicated, because<br>\nthe current \"attribute\" mechanism doesn't allow to return more than one<br>\ntheorem.</p>\n<p>Looking at how attributes are implemented, I found this:</p>\n<p>type attribute =<br>\n    Context.generic * thm -&gt; Context.generic option * thm option</p>\n<p>Modifying this to return a \"thm list option\" would certainly allow<br>\nmultiple theorems. To make it easy to use, one could create a new \"smart<br>\nconstructor\" for that type, e.g.</p>\n<p>val ad_hoc_proof_attribute: (Context.generic -&gt; thm list) -&gt; attribute</p>\n<p>which leaves the incoming context untouched and ignores the incoming<br>\ntheorem.</p>\n<p>I couldn't predict what more needed to be changed, so I decided to<br>\n\"apply some pressure and see what starts wobbling\". I changed the type<br>\nin \"more_thm.ML\". Then, the tricky bit is \"apply_attributes\", which is<br>\nin some way a glorified fold left over a list of attributes. There, I<br>\nran into a problem: suppose we have</p>\n<p>thm _[inductive_cases \"...\", simp]</p>\n<p>In this case, the first part of the attribute sequence might produce<br>\nmore than theorem, which means that the second part needs to be applied<br>\nto all of them. Peter pointed out to me that we already have precendent<br>\nfor that:</p>\n<p>thm foo.intros[simp]</p>\n<p>... works in exactly the same way: \"simp\" is applied to all theorems in<br>\n\"foo.intros\" (this is handled in \"Isar/attrib.ML\"). However, so far the<br>\nfull \"attribute pipeline\" only transformed one pair of theorem and<br>\ncontext into another pair of theorem and context, and now it would need<br>\nto deal with potentially multiple and traverse them in some manner<br>\n(Depth first? Breadth first? That choice matters for non-commutative<br>\nattributes, e.g. [simp, simplified]).</p>\n<p>I have attached a patch which _only_ attempts to change the definition<br>\nin \"more_thm.ML\" and fix what breaks in \"global_theory.ML\" and<br>\n\"Isar/proof_context.ML\" (in both files only minor changes were needed).<br>\nA bit more thought is required for \"Isar/attrib.ML\", where I aborted my<br>\nexploration.<br>\n<a href=\"/user_uploads/14278/fIEc6VDRB_xVlIWcF_tTn_eK/patch\">patch</a></p>",
        "id": 294320518,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926736
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>I understand that your proposal is more general than the proof method ind_cases, but could <br>\nyou comment on how they relate to each other?</p>\n<p>Andreas</p>",
        "id": 294321046,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926888
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi,</p>\n<blockquote>\n<p>I understand that your proposal is more general than the proof method<br>\nind_cases, but could you comment on how they relate to each other?</p>\n</blockquote>\n<p>I actually didn't know about that proof method, but it looks similar.<br>\nThe difference is that I would actually need to spell out the rule I<br>\nwant, and then continue to prove it with that method. With my proposal,<br>\nyou just get the theorem generated on the spot, without having to spell<br>\nit out. It's very nice in proofs where you obtain variables. From my<br>\ncurrent work:</p>\n<p>obtain x1 x2<br>\n  where \"x = x1 $ x2\"<br>\n    and \"rs, compile rs ⊢ x1 ≈ t1\"<br>\n    and \"rs, compile rs ⊢ x2 ≈ t2\"<br>\n  by (auto elim: [[summon_ind_cases \"rs, compile rs ⊢ x ≈ t1 $$ t2\"]])</p>\n<p>I could have expressed that equally well with</p>\n<p>inductive_cases need_to_make_up_a_name: \"rs, compile rs ...\"</p>\n<p>lemma ...<br>\nproof ...</p>\n<p>obtain ...<br>\n    by (auto elim: ...)</p>\n<p>qed</p>\n<p>hide_fact ...</p>\n<p>The reason why I prefer an attribute over a command is that I don't need<br>\nto make up a name for something which only makes sense in the context of<br>\na particular proof. Here, the \"compile rs\" is an artifact from the lemma<br>\nI'm proving. Another reason is that I think attributes are vastly<br>\nunderrated – as opposed to commands, they can be used uniformly in a lot<br>\nof different situations.</p>\n<p>I have attached a working example of that \"summon_ind_cases\" attribute.<br>\n(As an aside, I realize that my handling of variables is not canonical<br>\nhere; presumably, I need to parse \"for\" fixes as well. Grepping the<br>\nsources for occurrences of \"Parse.for_fixes\" didn't reveal any canonical<br>\nuse cases, though.)</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/8zG6yYB4cll_b1KyLASpWj3Y/Summon.thy\">Summon.thy</a></p>",
        "id": 294321112,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926914
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nLars just pointed out another candidate: \"case_of_simps\",<br>\n\"simps_of_case\". With my proposal, one could write</p>\n<p>thm foo_case = [[case_of_simps foo.simps]]<br>\n  note foo_case = [[case_of_simps foo.simps]]</p>\n<p>instead of using the specialized command</p>\n<p>case_of_simps foo_case: foo.simps</p>\n<p>This attribute could be implemented right now, but not \"simps_of_case\",<br>\nbecause the latter would need to return multiple theorems.</p>",
        "id": 294321131,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926919
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nI would appreciate an attribute [[inductive_cases &lt;term&gt;]] instead of<br>\nthe command.</p>",
        "id": 294321149,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926925
    }
]