[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHello,</p>\n<p>I want to write a checking phase that runs at the same stage as type<br>\ninference. The purpose of that phase is to constrain the type of certain<br>\nconstants under certain conditions.</p>\n<p>Suppose I encounter a certain constant c during checking with some<br>\npolymorphic type attached to it. I now want to add a constraint that<br>\nthis type conforms to a certain pattern (whose variables are supposed to<br>\nbe disjoint from everything else in the context).</p>\n<p>Error messages arising from this constraint should appear to the user<br>\njust like normal type unification errors during type checking.</p>\n<p>For instance, if I see a constant \"coeff :: 'a poly ⇒ 'b ⇒ 'c\", I would<br>\nlike to unify its type with the pattern \"'a list ⇒ nat ⇒ 'a\" (after<br>\nrenaming the variables in the latter).</p>\n<p>I see two ways of doing this:</p>\n<ol>\n<li>add a constraint (using Type.constraint) to the list of terms</li>\n<li>unify the types manually and propagate the resulting substitution</li>\n</ol>\n<p>The first one seems easier to me, although I would probably have to<br>\nensure I don't add constraints that are already there (or can I assume<br>\nthat by the time my phase is called, all constraints have already been<br>\nresolved?).</p>\n<p>In both cases, I am not sure what I have to do to make sure the<br>\nvariables in my type pattern are fresh.</p>\n<p>There are probably some established patterns to follow here</p>\n<p>Manuel</p>",
        "id": 294830123,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246234
    }
]