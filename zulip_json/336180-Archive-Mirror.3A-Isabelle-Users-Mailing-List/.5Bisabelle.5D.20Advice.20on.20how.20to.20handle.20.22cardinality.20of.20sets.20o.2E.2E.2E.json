[
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:uuomul@yahoo.com\">uuomul@yahoo.com</a>&gt;<br>\nGreetings, </p>\n<p>Larry wrote: </p>\n<blockquote>\n<blockquote>\n<p>I think that \"card (A \\&lt;rightarrow&gt;\\&lt;^sub&gt;E B) = card B ^ card A\" might work</p>\n</blockquote>\n</blockquote>\n<p>Actually, the theorem is almost there, disguised under the constant PiE---it can be proved as follows: </p>\n<p>lemma card_Func:<br>\nassumes A: \"finite (A::'a set)\"<br>\nshows \"card (A \\&lt;rightarrow&gt;\\&lt;^sub&gt;E B) = card B ^ card A\"<br>\nunfolding card_PiE[OF A] setprod_constant[OF A] ..</p>\n<p>Andrei</p>",
        "id": 294271263,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917320
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nDialogue is optional, I have found, and though <code>finite</code> is tempting, I <br>\nhave thought for a while it would not be a good first choice, since <br>\ndefining and using typedefs is never a one-liner, unlike how defining <br>\nand using sets can be.</p>\n<p>My contribution from listening and looking a little at FuncSet is this:</p>\n<p>definition frule :: \"'a set =&gt; 'b set =&gt; ('a =&gt; 'b) =&gt; ('a * 'b) set\" where<br>\n   \"frule D C f == if (!x. x \\&lt;in&gt; D --&gt; f x \\&lt;in&gt; C) then {(x,y). x <br>\n\\&lt;in&gt; D &amp; y = f x}<br>\n                   else {}\"</p>\n<p>Or maybe it's this, where these eliminate a need for a predicate I <br>\nthought I would need, with related things in the past:</p>\n<p>definition frule2 :: \"'a set =&gt; 'b set =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'b\" where<br>\n   \"frule2 D C f x == if (!x. x \\&lt;in&gt; D --&gt; f x \\&lt;in&gt; C)<br>\n                     then (if x \\&lt;in&gt; D then f x else undefined) else <br>\nundefined\"</p>\n<p>The value of listening was the <br>\n\"definition-acid-test-did-you-forget-to-remember-that-HOL-is-total-cause-that-will-haunt-you-dude-if-you-do-or-did-do-that\".</p>\n<p>That test is, \"the cardinality of the set of all f such that...\". If the <br>\nconditions aren't built in to the definition, it seems I should fail the <br>\ntest.</p>\n<p>There are these people and culture, call them, and it, Z. They almost <br>\nalways try to teach you something about the math they produce, but they <br>\nconsider a 5mm mechanical pencil high tech.</p>\n<p>There are these other people and culture, call them, and it, H. They're <br>\nhigh tech when it comes to math, but they teach you nothing about the <br>\nmath they produce, the last phrase being only a slight exaggeration.</p>\n<p>There being a certain amount of animosity between Z and H, I figure if I <br>\noffend them equally then the sum total of my offenses will be zero.</p>\n<p>When I have to teach myself, it's can be easier to go on tangents, and <br>\neven try to build things from the ground up.</p>\n<p>I could enlighten some users, from some info I have, about why it's <br>\nnormal for nitpick to find counterexamples when things are <br>\nunderspecificed, but I'll do that and ask some more question about that <br>\nsome other day. There's one of those below in relation to <code>card</code>.</p>\n<p>Feel free to jump on my <code>frule</code> and <code>frule2</code> and work the details out.</p>\n<p>Regards,<br>\nGB</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***) </p>\n<p>(<strong>Src_0</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>****)</p>\n<p>definition frule :: \"'a set =&gt; 'b set =&gt; ('a =&gt; 'b) =&gt; ('a * 'b) set\" where<br>\n   \"frule D C f == if (!x. x \\&lt;in&gt; D --&gt; f x \\&lt;in&gt; C) then {(x,y). x <br>\n\\&lt;in&gt; D &amp; y = f x}<br>\n                   else {}\"</p>\n<p>abbreviation (input) fruleA :: \"('a =&gt; 'b) =&gt; 'a set =&gt; 'b set =&gt; ('a * <br>\n'b) set\"<br>\n   where \"fruleA f D C == frule D C f\"<br>\nnotation (input)<br>\n   fruleA (\"'(_|_=&gt;_')\")</p>\n<p>lemma \"(x,y) \\&lt;in&gt; (f|D =&gt; C) ==&gt; y = f x\"<br>\nby(simp add: frule_def, metis (lifting, full_types)<br>\n   all_not_in_conv mem_Collect_eq splitD)</p>\n<p>lemma temp01: \"{A. EX f. A = (f|{0::nat} =&gt; {0::nat})} = {{(0,0)},{}}\"<br>\nby(auto simp add: frule_def)</p>\n<p>lemma \"card{A. EX f. A = (f|{0::nat} =&gt; {0::nat})} = 2\"<br>\n   (<em>nitpick finds a counterexample. Underspecified goin ons somewhere.</em>)<br>\nby(simp only: temp01, auto)</p>\n<p>abbreviation (input) fruleF :: \"('a =&gt; 'b) =&gt; 'a set =&gt; 'b set =&gt; 'a =&gt; 'b\"<br>\n   where \"fruleF f D C x == f x\"<br>\nnotation (input)<br>\n   fruleF (\"'(_|_=&gt;_')[_]\")</p>\n<p>lemma \"(id|D =&gt; C)[x] = x &amp;<br>\n    x \\&lt;in&gt; D --&gt; (x, (id|D =&gt; D)[x]) \\&lt;in&gt; (id|D =&gt; D)\"<br>\nby(simp add: frule_def)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***) </p>\n<p>(<strong>Src_1</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>****)</p>\n<p>definition frule2 :: \"'a set =&gt; 'b set =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'b\" where<br>\n   \"frule2 D C f x == if (!x. x \\&lt;in&gt; D --&gt; f x \\&lt;in&gt; C)<br>\n                     then (if x \\&lt;in&gt; D then f x else undefined) else <br>\nundefined\"</p>\n<p>abbreviation (input) frule2Map :: \"('a =&gt; 'b) =&gt; 'a set =&gt; 'b set =&gt; 'a <br>\n=&gt; 'b\"<br>\n   where \"frule2Map f D C == frule2 D C f\"<br>\nnotation (input)<br>\n   frule2Map (\"'(_|_=&gt;_')\")</p>\n<p>lemma<br>\n   \"x \\&lt;in&gt; D ==&gt; (id|D =&gt; D)(x) = x\"<br>\n   \"EX z. z \\&lt;in&gt; D &amp; f z ~: C ==&gt; (f|D =&gt; C)(x) = undefined\"<br>\nby(auto simp add: frule2_def)</p>\n<p>abbreviation (input) frule2Set :: \"('a =&gt; 'b) =&gt; 'a set =&gt; 'b set =&gt; ('a </p>\n<ul>\n<li>'b) set\"<br>\n   where \"frule2Set f D C == {(x,y). x \\&lt;in&gt; D &amp; (f|D =&gt; C)(x) \\&lt;in&gt; C}\"<br>\nnotation (input)<br>\n   frule2Set (\"{_|_=&gt;_}\")</li>\n</ul>\n<p>lemma \"x \\&lt;in&gt; D ==&gt; (x, (id|D =&gt; D)(x)) \\&lt;in&gt; {id|D =&gt; D}\"<br>\n   by(auto simp add: frule2_def)</p>",
        "id": 294271544,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917386
    },
    {
        "content": "<p>From: Josh Tilles &lt;<a href=\"mailto:merelyapseudonym@gmail.com\">merelyapseudonym@gmail.com</a>&gt;<br>\nDoes anyone have any recommendations for how to go about solving a problem like “How many functions are there between a set of three elements and a set of two elements”? (I’ve attached a page from Lawvere &amp; Schanuel’s “Conceptual Mathematics”, the source of this exercise, in case the extra context is helpful in answering my question)</p>\n<p>I’ve found three different ways of phrasing the exercise in Isabelle/HOL:</p>\n<p>theory Article_I<br>\nimports Main \"~~/src/HOL/Library/FuncSet\"<br>\nbegin</p>\n<p>datatype person = John | Mary | Sam<br>\ndatatype food = coffee | eggs<br>\nlemma \"card (UNIV :: (person ⇒ food) set) = 8\"<br>\n  oops</p>\n<p>lemma<br>\n  assumes \"card A = 3\" and \"card B = 2\"<br>\n  shows \"card {F. ∀a∈A. ∃!b∈B. (a,b) ∈ F} = 8\"<br>\n  (* quickcheck finds a counterexample. I don't know what to make of that... *)<br>\n  oops</p>\n<p>lemma<br>\n  assumes \"card A = 3\" and \"card B = 2\"<br>\n  shows \"card (A → B) = 8\"<br>\n  oops</p>\n<p>Are there different, better approaches that I should know about? Is one of the methods a known anti-pattern? I’d appreciate any thoughts.<br>\n--Josh<br>\n<a href=\"/user_uploads/14278/bJW16cFfV5SUJSwhgbVKdZmg/signature.asc\">signature.asc</a></p>",
        "id": 294271874,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917480
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI suggest proving the general case </p>\n<p>\"card (A → B) = card B ^ card A”</p>\n<p>(where A and B are both finite) by induction on A.</p>\n<p>Your second lemma fails because F could contain junk elements outside A.</p>\n<p>Larry Paulson</p>",
        "id": 294272089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917544
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHi Josh,</p>\n<p>what you want is card_PiE:</p>\n<p>lemma card_PiE:<br>\n  \"finite S ⟹ card (PIE i : S. T i) = (∏ i∈S. card (T i))\"</p>\n<p>Where (PIE i : S. T i) is the set of all functions f with<br>\n  (I) f i : T i for all i : S, and<br>\n  (II) f i = undefined for i ~: S.<br>\nThis is necessary in HOL, as the functions are always total.</p>\n<p>This is proved by induction over S, see ~~/src/HOL/Library/FuncSet.</p>\n<p>You might wonder why there is no assumption \"finite (T i)\". In this case<br>\nboth sides of the equation are 0, as card S = 0 for an infinite S.</p>\n<p>It should be easy to prove \"(PIE i : S. T i :: (person ⇒ food) set) =<br>\nUNIV\".</p>\n<p>Greetings,<br>\n  Johannes</p>",
        "id": 294272250,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917587
    },
    {
        "content": "<p>From: Josh Tilles &lt;<a href=\"mailto:merelyapseudonym@gmail.com\">merelyapseudonym@gmail.com</a>&gt;<br>\nI had expected that proving some particular cases first would be easier, but I’ll give what you recommend a shot.<br>\nThanks!<br>\n<a href=\"/user_uploads/14278/G4iu3hZhkruUitGNZT5ZTbB-/signature.asc\">signature.asc</a></p>",
        "id": 294272386,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917616
    },
    {
        "content": "<p>From: Josh Tilles &lt;<a href=\"mailto:merelyapseudonym@gmail.com\">merelyapseudonym@gmail.com</a>&gt;<br>\nHuh. Auto-Quickcheck also finds a counterexample for:</p>\n<p>lemma<br>\n  assumes \"finite A\" and \"finite B\"<br>\n  shows \"card (A → B) = (card B) ^ (card A)”</p>\n<p>Apparently when A and B are both empty, there are four members to the set “A → B”. That doesn’t make any sense to me, but I haven’t spent a lot of time with the implementation of FuncSet yet.<br>\n<a href=\"/user_uploads/14278/4pREeF7uwmqLhh9JYso1WLE7/signature.asc\">signature.asc</a></p>",
        "id": 294272577,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917679
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nWell, Larry's suggestion runs into the same problem as your original attempts:<br>\nfunctions that behave the same on A may still differ outside A. You need to<br>\nrestrict A -&gt; B to those functions that map values outside A to some fixed<br>\nvalue. The theory offers function \"restrict\" for that purpose, but the theorem<br>\ndoesn't look quite as nice anymore. I guess it is something like</p>\n<p>... ==&gt; card {g. EX f : A → B. g = restrict f A} = card B ^ card A</p>\n<p>Tobias</p>",
        "id": 294272826,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917749
    },
    {
        "content": "<p>From: Elsa L Gunter &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nI have know AUto-Quickcheck to \"find\" counterexamples that weren't.<br>\nSet-theoretically, there is exactly one function from the empty set to<br>\nanything, namely the empty function (represented by the empty set).<br>\nThere cannot be any other, for it would have to have a pair in its<br>\nrepresentation and that pair would have to have a first element that was<br>\nin the empty set.<br>\n---Elsa</p>",
        "id": 294273018,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917816
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI think that </p>\n<p>\"card ((A → B) ∩ extensional A) = (card B) ^ (card A)”</p>\n<p>might work, but the proof looks non-trivial.</p>\n<p>Larry Paulson</p>",
        "id": 294273235,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917882
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nAfter reading the other replies, and looking at FuncSet.thy, it gives me <br>\nan appreciation for the <code>finite</code> type class.</p>\n<p>The type class <code>finite</code> and <code>UNIV</code> are a standard part of HOL, but I <br>\nhaven't found much magic when it comes to <code>card UNIV</code>, so maybe you'll <br>\ntake the route I show below, and create some magic, and post it.</p>\n<p>Using <code>finite</code> and <code>UNIV</code>, the following seems like it should work, <br>\nbased on Larry's initial suggestion:</p>\n<p>lemma \"card(UNIV::('a =&gt; 'b) set)  = card(UNIV::'b::finite set) ^ <br>\ncard(UNIV::'a::finite set)\"</p>\n<p>Maybe I have fundamental misunderstanding of what <code>card(UNIV::'a::finite \nset)</code> is, but <code>nitpick</code> gives a counterexample. However, I'm guessing <br>\nthat's okay, since there could be some underspecified things involved.</p>\n<p>I can't even prove a simple example like this:</p>\n<p>datatype dataT = OneT | TwoT | ThreeT</p>\n<p>lemma dataT_set: \"(UNIV::dataT set) = {OneT, TwoT, ThreeT}\"<br>\n   by(auto, metis dataT.exhaust)</p>\n<p>lemma dataT_card: \"card (UNIV::dataT set) = 3\"<br>\n   by(simp add: dataT_set)</p>\n<p>lemma dataT_27: \"card(UNIV::dataT set) ^ card(UNIV::dataT set) = 27\"<br>\n   by(simp add: dataT_card)</p>\n<p>lemma \"card(UNIV::(dataT =&gt; dataT) set) = 27\"<br>\n   oops</p>\n<p>I've only briefly looked at Finite_Set.thy, but it seems to me the <br>\nsolution could be in defining a bijective function to use, from <br>\n<code>UNIV::'a::finite set</code> to nat, something like this:</p>\n<p>definition ftype2nat :: \"'a::finite =&gt; nat\" where<br>\n   \"ftype2nat = (SOME f. EX n. f ` (UNIV::'a::finite set) = {i. i &lt; n}<br>\n&amp; bij_betw f (UNIV::'a::finite set) {i. i &lt; n})\"</p>\n<p>You then have a set, {i. i &lt; n}, and the cardinality of that set is the <br>\ncardinality of <code>UNIV::'a::finite set</code>, and another  {i. i &lt; n} for <br>\n<code>card(UNIV::'b::finite set)</code>. With a lot of work that might give you the <br>\nright numbers.</p>\n<p>I guess it would need to be shown that some <code>f = ftype2nat</code> exists. I do <br>\nthe easy part, and show the injective part:</p>\n<p>lemma injective_f_UNIV_to_nset_exists:<br>\n   \"EX(n::nat) f. {i. i &lt; n} = f <code> (UNIV::'a::finite set) &amp; inj_on f UNIV\"\nproof-\nhave \"EX(n::nat) f. (UNIV::'a::finite set) = f </code> {i. i &lt; n} &amp; inj_on f <br>\n{i. i &lt; n}\"<br>\n   proof-<br>\n   have \"finite (UNIV::'a::finite set)\" by(metis finite_code)<br>\n   thus ?thesis by(simp add: finite_imp_nat_seg_image_inj_on) qed<br>\nthus ?thesis<br>\n   by(metis inj_on_the_inv_into the_inv_into_onto)<br>\nqed</p>\n<p>It seems like proving \"card(UNIV::(dataT =&gt; dataT) set) = 27\" should be <br>\neasy. Everything might be all there in Fun.thy and Finite_Set.thy. I'd <br>\nlike to know.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294273461,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917949
    }
]