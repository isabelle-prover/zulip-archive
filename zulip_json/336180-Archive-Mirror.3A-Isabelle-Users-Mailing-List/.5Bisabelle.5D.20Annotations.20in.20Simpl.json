[
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nHi everyone,</p>\n<p>I am working on formalizing some algorithms using Simpl from the AFP.<br>\nIs there some lightweight way (in a procedures definition) to annotate a <br>\nloop with the property that a variable stays unchanged? For procedures, <br>\nthere is the may-not-modify-globals syntax; but a similar thing does not <br>\nseem to exist for loops (and it is not clear, how this would fit in). At <br>\nthe moment, I am using the ANNO command for this purpose:</p>\n<p>procedures mult1 (n :: nat, m :: nat | r :: nat)<br>\n\"<br>\n   ANNO τ.<br>\n   {τ}<br>\n     ´r :== (0 :: nat) ;;<br>\n     WHILE ´n ≠ 0<br>\n     INV ⦃ ´m = ⇗τ⇖m ∧ ´m * ⇗τ⇖n = ´r + ´m * ´n  ⦄<br>\n     DO<br>\n       ´r :== ´r + ´m ;;<br>\n       ´n :== ´n - 1<br>\n       OD<br>\n   ⦃ ´r = ⇗τ⇖m * ⇗τ⇖n ⦄<br>\n\"</p>\n<p>lemma (in mult1_impl) mult1:<br>\n   \"∀m n. Γ ⊢ ⦃´m = m ∧ ´n = n⦄ ´r :== PROC mult1(´m, ´n) ⦃´r = m * n⦄\"<br>\n   apply vcg<br>\n   apply (simp_all add: mult_Suc_right[symmetric])<br>\n   done</p>\n<p>Here I need a full write down a full specification already in the <br>\nprocedure definition. This is particularly annoying for ANNO statements <br>\ndeeper in the procedure definition.</p>\n<p>The only other solution I have found would be adding the invariants only <br>\nin the proof:</p>\n<p>procedures mult2 (n :: nat, m :: nat | r :: nat)<br>\n\"<br>\n   ´r :== (0 :: nat) ;;<br>\n   WHILE ´n ≠ 0<br>\n   DO<br>\n     ´r :== ´r + ´m ;;<br>\n     ´n :== ´n - 1<br>\n   OD<br>\n\"</p>\n<p>lemma (in mult2_impl) mult2:<br>\n   \"∀m n. Γ ⊢ ⦃´m = m ∧ ´n = n⦄ ´r :== PROC mult2(´m, ´n) ⦃´r = m * n⦄\"<br>\n   apply vcg_step<br>\n   apply (hoare_rule HoarePartial.Seq)<br>\n    defer<br>\n    apply (hoare_rule I=\"⦃ ´m = m ∧ ´m * n = ´r + ´m * ´n  ⦄\" in<br>\n      HoarePartial.reannotateWhileNoGuard)<br>\n    apply vcg<br>\n    apply (simp_all add: mult_Suc_right[symmetric])<br>\n   apply vcg<br>\n   apply simp<br>\n   done</p>\n<p>Here, it is harder to see which invariants are actually used for which <br>\nloop (and I can only use the full vcg after I reached the loop), so I <br>\nwould like to know about nicer solutions (if there are any).</p>\n<p>-- Lars</p>",
        "id": 294219132,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896493
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nHi Lars,</p>\n<p>This is what we used for the kernel proof. It doesn't look nice and has the disadvantages you explain. It does have the advantage that you can pick different invariants/annotations for each proof about that function.</p>\n<p>Slight side rant: It's strange that Hoare logic insists that one would only ever prove one property about a function, have one invariant, and one annotation that fits them all. In theory this is all equivalent and there is a \"complete specification\", but in practise that is not how things are proved or should be proved. </p>\n<p>Just think about what we do for functional programs in Isabelle. Nothing is more cumbersome and useless than having to state one lemma that says everything about one function.</p>\n<p>From that point of view, I'm fairly convinced that annotations and invariants belong with the proof, not with the program (or everything belongs with the program). It would be nice to have a better notation for connecting them, though.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294219171,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896517
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nHi Lars.</p>\n<p>You may not necessarily need to single-step the vcg. Have a look at <br>\nwhileAnno_def: \"whileAnno b I V c == While b c\". Since this is full <br>\nequality, you can add or remove annotations with fold/unfold if this is <br>\nuseful.</p>\n<p>The annotations are really just hints to the vcg, not elements of the <br>\nsyntax or semantics of SIMPL.</p>\n<p>So, one thing you could do is annotate the loops with names, and then <br>\nsubstitute them on the spot.</p>\n<p>definition \"name_loop v = UNIV\"</p>\n<p>(in proc defn):<br>\n\"</p>\n<p>WHILE ´n ≠ 0<br>\n      INV name_loop ''foo''<br>\n      DO ... OD</p>\n<p>\"</p>\n<p>lemma annotate_named_loop:<br>\n   \"whileAnno b (name_loop v) V c = whileAnno b I V c\"<br>\n   by (simp add: whileAnno_def)</p>\n<p>(in unfolding)<br>\napply (simp add: annotate_named_loop[where name=\"''foo''\" and I=\"...\"])</p>\n<p>Not a lot nicer, but maybe a bit less fiddly.</p>\n<p>I guess it would be nicer if SIMPL provided a facility by which you <br>\ncould add such invariant declarations/redeclarations into the context <br>\nand have the vcg notice them as necessary. There might even be a way to <br>\ndo this already, though I can't think what it would be.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294219187,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896529
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>On 10.07.2012 03:27, Thomas Sewell wrote:</p>\n<blockquote>\n<p>You may not necessarily need to single-step the vcg. Have a look at<br>\nwhileAnno_def: \"whileAnno b I V c == While b c\". Since this is full<br>\nequality, you can add or remove annotations with fold/unfold if this is<br>\nuseful.<br>\n[...]<br>\ndefinition \"name_loop v = UNIV\"<br>\n[...]<br>\nlemma annotate_named_loop:<br>\n\"whileAnno b (name_loop v) V c = whileAnno b I V c\"<br>\nby (simp add: whileAnno_def)<br>\n[...]<br>\n(in unfolding)<br>\napply (simp add: annotate_named_loop[where name=\"''foo''\" and I=\"...\"])<br>\n[...]</p>\n</blockquote>\n<p>thank you both for your answers! This renaming indeed provides a less <br>\nfiddly solution (somehow I did not think about using the simplifier on <br>\nSimpl programs ...).</p>\n<p>-- Lars</p>",
        "id": 294219230,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896566
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nActually, this fails if the invariant needs to meta-quantified variables <br>\n-- I don't think we have a substitution variant of (rule_tac x=... in ...).</p>\n<p>-- Lars</p>",
        "id": 294219246,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896579
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;</p>\n<blockquote>\n<p>Slight side rant: It's strange that Hoare logic insists that one would only ever prove one property about a function, have one invariant, and one annotation that fits them all. In theory this is all equivalent and there is a \"complete specification\", but in practise that is not how things are proved or should be proved. </p>\n</blockquote>\n<p>I think it's fine in Hoare logic to prove multiple properties of a function C, like {P1}C{Q1} and {P2}C{Q2}. The point of the rules of conjunction</p>\n<p>{P1}C{Q1}  {P2}C{Q2}</p>\n<hr>\n<p>{P1∧P2}C{Q1∧Q2}</p>\n<p>and disjunction</p>\n<p>{P1}C{Q1}  {P2}C{Q2}</p>\n<hr>\n<p>{P1∨P2}C{Q1∨Q2}</p>\n<p>are to allow these multiple properties to be combined. But in the \"proof outline\" representation of a Hoare logic proof, where the program text is interspersed with assertions, you can't really represent this without writing out the program text multiple times, which is a hassle.</p>\n<p>John</p>",
        "id": 294219254,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896584
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nThis observation motivated me back in 2007 to NOT define a Hoare logic <br>\nfor Imperative-HOL, but to do all the case studies just with a simple <br>\npredicate capturing the operational semantics. Composition of facts of <br>\nthe same program therefore does not even require any special rule and <br>\nuse of object connectives, but can be done with resolution, e.g. the OF <br>\nattribute.</p>\n<p>As that was so non-standard, other people seem to have defined a Hoare <br>\nlogic for Imperative-HOL nevertheless.</p>\n<p>I tried to prove properties of the imperative programs separately.<br>\nIn my case studies, the properties of the functions relied heavily one <br>\non the previous one, which required me to re-state properties again and <br>\nagain.</p>\n<p>The solution I then came up with is still quite adhoc: I came up with <br>\nricher induction rules to obtain already proved facts in the context <br>\nwith names.</p>\n<p>With the infrastructure at the moment, I think proving all the facts at <br>\nonce would have been simpler in my case.<br>\nThe most difficult case study, the imperative unification algorithm, is <br>\nstill managable by proving all properties at once, and the most <br>\nreasoning of the different properties overlap in various places in the <br>\nproof.</p>\n<p>Kernel functions in seL4 have probably a different flavor.</p>\n<p>Lukas</p>",
        "id": 294219262,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896590
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nOn 10/07/2012, at 6:26 PM, John Wickerson wrote:</p>\n<blockquote>\n<blockquote>\n<p>Slight side rant: It's strange that Hoare logic insists that one would only ever prove one property about a function, have one invariant, and one annotation that fits them all. In theory this is all equivalent and there is a \"complete specification\", but in practise that is not how things are proved or should be proved. </p>\n</blockquote>\n<p>I think it's fine in Hoare logic to prove multiple properties of a function C, like {P1}C{Q1} and {P2}C{Q2}. The point of the rules of conjunction</p>\n<p>{P1}C{Q1}  {P2}C{Q2}</p>\n<hr>\n<p>{P1∧P2}C{Q1∧Q2}</p>\n<p>and disjunction</p>\n<p>{P1}C{Q1}  {P2}C{Q2}</p>\n<hr>\n<p>{P1∨P2}C{Q1∨Q2}</p>\n<p>are to allow these multiple properties to be combined.</p>\n</blockquote>\n<p>Sure. Maybe I should clarify: I'm not objecting to Hoare logic as such, it's perfectly capable of showing multiple independent properties about a program (that's what we've used in the seL4 proofs I was mentioning, precisely with rules as above). I'm objecting to how it is usually used and presented, and to what tools in turn usually imply for your workflow.</p>\n<p>The fact that there is precisely one specification statement and one invariant that you can annotate for each procedure/loop in usual tools and presentations is the problem. This is hard to avoid if these annotations go into the program, because it is awkward to differentiate between multiple proofs in one invariant annotation (possible, but very annoying). </p>\n<blockquote>\n<p>But in the \"proof outline\" representation of a Hoare logic proof, where the program text is interspersed with assertions, you can't really represent this without writing out the program text multiple times, which is a hassle.</p>\n</blockquote>\n<p>That is the direction I meant, only that this is already the case with just invariants (which will need to be provided somehow, at least if there is automation/vcg support in some form). It is perfectly possible to mention these annotations in the proof only, and I'm arguing that this is where they belong.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294219274,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896597
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nOn 10/07/2012, at 6:53 PM, Lukas Bulwahn wrote:</p>\n<blockquote>\n<p>On 07/10/2012 01:09 AM, Gerwin Klein wrote:</p>\n<blockquote>\n<p>This is what we used for the kernel proof. It doesn't look nice and has the disadvantages you explain. It does have the advantage that you can pick different invariants/annotations for each proof about that function.</p>\n<p>Slight side rant: It's strange that Hoare logic insists that one would only ever prove one property about a function, have one invariant, and one annotation that fits them all. In theory this is all equivalent and there is a \"complete specification\", but in practise that is not how things are proved or should be proved.</p>\n<p>Just think about what we do for functional programs in Isabelle. Nothing is more cumbersome and useless than having to state one lemma that says everything about one function.<br>\nThis observation motivated me back in 2007 to NOT define a Hoare logic for Imperative-HOL, but to do all the case studies just with a simple predicate capturing the operational semantics. Composition of facts of the same program therefore does not even require any special rule and use of object connectives, but can be done with resolution, e.g. the OF attribute.</p>\n</blockquote>\n<p>As that was so non-standard, other people seem to have defined a Hoare logic for Imperative-HOL nevertheless.</p>\n<p>I tried to prove properties of the imperative programs separately.</p>\n</blockquote>\n<p>I'd argue that Hoare logic or not is a separate issue from proving properties separately or not. Any combination of these is possible. It's just that most Hoare logic frameworks practically force you in one direction (and they shouldn't).</p>\n<blockquote>\n<p>In my case studies, the properties of the functions relied heavily one on the previous one, which required me to re-state properties again and again.</p>\n</blockquote>\n<p>We have seen some of that effect in our proofs as well, but not everywhere. Some loops for instance need a fairly complex invariant just to be able to say anything about them, and in this case it can be easier to get the strongest statement you can come up with and be done with it. This can be awkward to use, because you will either get a fairly large precondition with many cases or one that is fairly strong and may be harder to establish than necessary, but it may still be worth it overall. </p>\n<p>On the other hand, depending on the use context you might just be interested in the fact that a certain function doesn't change certain parts of the state. This can be a completely automatic proof where you don't even have to state the specification, because a tool can figure it out for you. But if you are only allowed to have precisely one specification per function, you can't make use of such simple automatic side proofs.</p>\n<p>In the functional world, the first case is similar to a complex recursion that you may only want to go through once with a specific complex induction, strong induction hypothesis etc. You can be better off proving everything you'll ever need about that function in one go. The second case are the many simple, small functions that make up the bulk of the program. For these you want nice, clean simp and other rules to set up automation.</p>\n<p>The point is, you should have the choice to do what fits best.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294219342,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896609
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nI guess, Simpl accounts for this case with the _modifies specifications?</p>\n<p>-- Lars</p>",
        "id": 294219352,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896615
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nIt turns out that this is fairly easy to implement:</p>\n<p>fun eqsubst_inst_tac ctxt occL insts thm =<br>\n     Subgoal.FOCUS (fn {context=ctxt,...} =&gt; let<br>\n       val thm' = thm |&gt; Rule_Insts.read_instantiate ctxt insts<br>\n     in EqSubst.eqsubst_tac ctxt occL [thm'] 1 end) ctxt</p>\n<p>fun subst_method inst_tac tac =<br>\n     Args.goal_spec --<br>\n     Scan.lift (Scan.optional (Args.parens (Scan.repeat Parse.nat)) [0]) --<br>\n     Scan.optional (Scan.lift<br>\n       (Parse.and_list1 (Args.var -- (Args.$$$ \"=\" |-- Parse.!!! <br>\nArgs.name_source)) --|<br>\n         Args.$$$ \"in\")) [] --<br>\n     Attrib.thms &gt;&gt;<br>\n     (fn (((quant, occL), insts), thms) =&gt; fn ctxt =&gt; METHOD (fn facts =&gt;<br>\n       if null insts then quant (Method.insert_tac facts THEN' tac ctxt <br>\noccL thms)<br>\n       else<br>\n         (case thms of<br>\n           [thm] =&gt; quant (Method.insert_tac facts THEN' inst_tac ctxt <br>\noccL insts thm)<br>\n         | _ =&gt; error \"Cannot have instantiations with multiple rules\")));</p>\n<p>val eqsubst_inst_meth = subst_method<br>\n     eqsubst_inst_tac EqSubst.eqsubst_tac</p>\n<p>So now I can do:</p>\n<p>lemma (in mult3_impl) mult3:<br>\n   \"∀m n. Γ ⊢ ⦃´m = m ∧ ´n = n⦄ ´r :== PROC mult3(´m, ´n) ⦃´r = m * n⦄\"<br>\n   apply vcg_step<br>\n   apply (subst_tac I=\"⦃ ´m = m ∧ ´m * n = ´r + ´m * ´n  ⦄\" in<br>\n     annotate_named_loop[where name=\"''mult3_loop''\"])</p>",
        "id": 294219367,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896622
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nYes, Simpl does, and a few other frameworks have the same special case, because it occurs so often that it can't be ignored. There is nothing in between, though. If your memory model has separate heap framing conditions, you're already out of luck.</p>\n<p>Simpl can easily be extended to allow the vcg to use an arbitrary lemma as spec for a function to get all that (not sure if we've pushed that change to the AFP yet -- we should). With that, there is only the problem of nice syntax for annotations left.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294219381,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896627
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\n[...]</p>\n<p>I've refined this now to a specialized tactic, so I can just write</p>\n<p>apply (anno_loop_tac my_named_loop=\"{...}\").</p>\n<p>Now this aspect feels quite natural.</p>\n<p>-- Lars</p>",
        "id": 294219502,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896701
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nThat does indeed look quite nice. Would you be happy to include your tactic in the AFP Simpl entry?</p>\n<p>Gerwin</p>",
        "id": 294219508,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896707
    }
]