[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nSuppose I have a theorem of the form \"A ?x ⟹ B ?x ⟹ C ?x ⟹ D ?x\" and the<br>\nthree theorems \"eventually A F\", \"eventually B F\", \"eventually C F\".</p>\n<p>I now want to get the theorem \"eventually D F\" in ML, but not just for<br>\nthree theorems, but for an arbitrary number of premises. In the end, I'd<br>\nlike a function that takes a theorem that is an n-ary implication (like<br>\nabove) and a list of n elements, each corresponding to one of the premises.</p>\n<p>This is a bit like the \"eventually_elim\" method, but in a forward<br>\nmanner. My current solution is as outlined below, but it strikes me as<br>\nsomewhat ugly and fragile. In particular, I dislike the \"Thm.assumption\"<br>\nin the end, but I don't know how to avoid it.</p>\n<p>Manuel</p>\n<p>fun eventually_mono_OF _ thm [] = thm<br>\n  | eventually_mono_OF ctxt thm thms =<br>\n      let<br>\n        val conv = Conv.rewr_conv @{thm conj_imp_eq_imp_imp [symmetric]}<br>\n        fun go conv' n =<br>\n          if n &lt;= 0 then conv' else go (conv then_conv conv') (n - 1)<br>\n        val conv = go Conv.all_conv (length thms - 1)<br>\n        val thm' = Conv.fconv_rule conv thm<br>\n        fun go' thm [] = thm<br>\n          | go' thm (thm' :: thms) = go' (@{thm eventually_conj} OF<br>\n[thm, thm']) thms<br>\n        val thm'' = go' (hd thms) (tl thms)<br>\n      in<br>\n        (@{thm eventually_mono} OF [thm'', thm'])<br>\n        |&gt; Thm.assumption (SOME ctxt) 1<br>\n        |&gt; Seq.list_of<br>\n        |&gt; the_single<br>\n      end</p>",
        "id": 294729057,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187376
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe included Scratch.thy is what I made out of it, just trying to<br>\nunderstand it formally and writing it down again with the means of<br>\nhuman-readable Isabelle/Isar and Isabelle/ML (see also \"implementation\"<br>\nmanual section \"0.1 Style and orthography\").</p>\n<p>It is getting late and I need to postpone investigating the actual<br>\ntechnical question behind it. Or maybe someone else can see it now on<br>\nthe spot.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/jQqneHlhQwbA7wuom-efwW9F/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294729159,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187408
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is another version of both the proof method from theory HOL.Filter<br>\nand the above forward inference in ML (which could be an attribute).</p>\n<p>Apart from further fine-tuning of Isabelle/ML \"style and orthography\", I<br>\ndid not change anything significant. So for now I would say that your<br>\noriginal approach to go from rule: \"A x ⟹ B x ⟹ C x ⟹ D x\" for x to the<br>\n\"eventually\" rule is fine -- including the Thm.assumption operation.<br>\n(Incidently the same happens in the Isar proof snippet given at the<br>\nbottom, to fit the result of fix/assume/show into the pending goal;<br>\nsimilarly in the \"by fact\" step).</p>\n<p>Of course, it implicitly depends on well-behaved HO-unification problems<br>\ngiven to this operation.</p>\n<p>Where does the situation \"Suppose I have a theorem of the form ...\"<br>\nactually emerge?</p>\n<p>That rule is in Isabelle standard form, as HO Horn clause with removed<br>\nouter quantification. So fitting it into a goal usually requires<br>\nunification to recover the lost information of the quantifier prefix. In<br>\nprinciple, the rule could be made a closed form (in HOL or non-standard<br>\nPure form) and applied with some low-level inference. It does not get<br>\nautomatically better, though, but depends on the actual application.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/HBSSo0l0NYeAjA5-7e_EGbOi/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294729257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187438
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI now think that the best way is probably having a HOL-forall quantifier<br>\nto explicitly select the variable we're talking about and then have an<br>\nattribute to lift the theorem.</p>\n<p>The situation where I need this is the following: I have a theorem like<br>\nthis:</p>\n<p>∀x. 0 ≤ l1 x ⟶<br>\n    0 ≤ l2 x ⟶<br>\n    f x ∈ {l1 x..u1 x} ⟶<br>\n    g x ∈ {l2 x..u2 x} ⟶<br>\n    f x * g x ∈ {l1 x * l2 x..u1 x * u2 x}</p>\n<p>And I am now in a situation (in ML) where I know that all of these<br>\npreconditions hold for large enough x. I then want to use that to get<br>\nthe theorem \"eventually (%x. f x * g x ∈ {l1 x * l2 x..u1 x * u2 x})<br>\nat_top\". I packaged this in an attribute called \"eventuallized\".</p>\n<p>Since this is all HOL quantifiers and HOL implication, I avoid these<br>\nhigher-order problems entirely.</p>\n<p>My application is still very experimental, so I'll continue working on<br>\nit before I decide how to tackle this specific issue exactly. But what I<br>\nhave seems sufficient for now.</p>\n<p>Manuel</p>",
        "id": 294729275,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187444
    }
]