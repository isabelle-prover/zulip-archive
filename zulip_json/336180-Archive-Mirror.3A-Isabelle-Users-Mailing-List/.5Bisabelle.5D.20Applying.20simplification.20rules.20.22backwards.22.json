[
    {
        "content": "<p>From: Juan Antonio Navarro Pérez &lt;<a href=\"mailto:juannavarroperez@gmail.com\">juannavarroperez@gmail.com</a>&gt;<br>\nHi all,</p>\n<p>I'm rather new in the world of Isabelle, and just started doing some<br>\nof my first few interesting proofs with it.</p>\n<p>So far, I have found myself often in the situation when I want to<br>\napply some kind of simplification rule, but in the inverse order as<br>\nI've stated it in a previous lemma. Say I have proved something like<br>\n-- lemma name [simp]: \"complex = simple\" -- but, during some<br>\nparticular proof, I would like to replace _some_ occurrences of<br>\n\"simple\" with \"complex\".</p>\n<p>Now, when I am this situations, I write a second -- lemma name_inv:<br>\n\"simple = complex\" by (auto) -- and then selectively apply (simp only:<br>\nname_inv) whenever I need it. But I'm, wondering if there is an<br>\neasier, more clean way of doing this.</p>\n<p>Also how can I apply the simplification rule only to _some_<br>\noccurrences of an expression and not all of them (or all in the<br>\nconclusion, or all in the premises)??</p>\n<p>To explain things a bit more precisely, consider for example that I<br>\nhave already proved the following</p>\n<p>lemma stack_append_assoc: \"stack_append a (stack_append b c) =<br>\nstack_append (stack_append a b) c\"</p>\n<p>lemma push_append_cmt [simp]: \"push_updates delta (stack_append st<br>\nst') = stack_append (push_updates delta st) st'\"</p>\n<p>which prove associativity of my \"stack_append\" function, and some sort<br>\nof commutativity between \"stack_append\" and some other \"push_updates\"</p>\n<p>Now I'm trying to prove a lemma that looks like</p>\n<p>lemma \"stack_append (stack_eval c x bh) (stack_eval c x bt) =<br>\nstack_eval c x (stack_append bh bt)\"<br>\n    apply (induct bh)<br>\n    apply (simp)</p>\n<p>after starting the proof by induction and simplifications I end up<br>\nwith a subgoal like</p>\n<ol>\n<li>!!fun list bh.<br>\n       stack_append (stack_eval c x bh) (stack_eval c x bt) =<br>\nstack_eval c x (stack_append bh bt)<br>\n       ==&gt; stack_append (stack_append (push_updates list (c x fun))<br>\n(stack_eval c x bh)) (stack_eval c x bt) =<br>\n           stack_append (push_updates list (c x fun)) (stack_eval c x<br>\n(stack_append bh bt))</li>\n</ol>\n<p>I would like, on the left-hand side of the equation, to move<br>\n\"push_updates\" before the \"stack_append\" (using the inverse of my<br>\npush_append_cmt) and then by associativity of the \"stack_append\"s<br>\n(again applied in the reverse direction of my original lemma) build<br>\nthe expression \"stack_append (stack_eval c x bh) (stack_eval c x bt)\"<br>\nfound in the inductive hypothesis to finally prove this subgoal.</p>\n<p>Indeed, after defining some \"stack_append_assoc_inv\" and<br>\n\"push_append_cmt_inv\" lemmas, the proof of this subgoal succeeds by<br>\napplying<br>\n    apply (simp only: push_append_cmt_inv)<br>\n    apply (simp only: stack_append_assoc_inv)</p>\n<p>But all this looks rather ugly. Is there a better/nicer way to do this?</p>\n<p>Cheers,</p>\n<p>Juan</p>",
        "id": 294082055,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831001
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Juan,</p>\n<blockquote>\n<p>So far, I have found myself often in the situation when I want to<br>\napply some kind of simplification rule, but in the inverse order as<br>\nI've stated it in a previous lemma. Say I have proved something like<br>\n-- lemma name [simp]: \"complex = simple\" -- but, during some<br>\nparticular proof, I would like to replace _some_ occurrences of<br>\n\"simple\" with \"complex\".</p>\n</blockquote>\n<p>apply (simp only: name[symmetric])</p>\n<blockquote>\n<p>[...]<br>\nAlso how can I apply the simplification rule only to _some_<br>\noccurrences of an expression and not all of them (or all in the<br>\nconclusion, or all in the premises)??</p>\n</blockquote>\n<p>Have a look at the \"subst\" method (cf. Isabelle/Isar ref manual, sect. <br>\n9.2.2). Sometimes it is also helpful to instantiate the rule manually, <br>\nsuch that it applies only at certain positions:</p>\n<p>apply (simp only: name[where x=\"foo\"]</p>\n<p>Then, of course, if you find out that you often have to apply your rules <br>\n\"backwards\", you may simply have written them in the \"wrong\" direction. <br>\nIt often takes some experimentation to find out what works best...</p>\n<p>Hope this helps<br>\nAlex</p>",
        "id": 294082259,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831069
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIf you need to do a lot of these low level term manipulations, in most<br>\ncases something is wrong. For example, the direction</p>\n<blockquote>\n<p>lemma \"stack_append (stack_eval c x bh) (stack_eval c x bt) =<br>\nstack_eval c x (stack_append bh bt)\"</p>\n</blockquote>\n<p>looks wrong. As a programmer you would orient it the other way around.<br>\nSince your application is close to programming, you should think like a<br>\nprogrammer (better: term rewriter).</p>\n<p>If you don't know how to avoid this low-level term surgery, you should<br>\nuse structured proofs and especially the</p>\n<p>also have \"... = rhs\"</p>\n<p>idiom. For apply proofs the \"subst\" method may help because it allows<br>\nyou to specify which occurrences should be replaced. But structured<br>\nproofs are less brittle.</p>\n<p>Regards<br>\nTobias</p>\n<blockquote>\n<p>apply (induct bh)<br>\n    apply (simp)</p>\n<p>after starting the proof by induction and simplifications I end up<br>\nwith a subgoal like</p>\n<ol>\n<li>!!fun list bh.<br>\n       stack_append (stack_eval c x bh) (stack_eval c x bt) =<br>\nstack_eval c x (stack_append bh bt)<br>\n       ==&gt; stack_append (stack_append (push_updates list (c x fun))<br>\n(stack_eval c x bh)) (stack_eval c x bt) =<br>\n           stack_append (push_updates list (c x fun)) (stack_eval c x<br>\n(stack_append bh bt))</li>\n</ol>\n<p>I would like, on the left-hand side of the equation, to move<br>\n\"push_updates\" before the \"stack_append\" (using the inverse of my<br>\npush_append_cmt) and then by associativity of the \"stack_append\"s<br>\n(again applied in the reverse direction of my original lemma) build<br>\nthe expression \"stack_append (stack_eval c x bh) (stack_eval c x bt)\"<br>\nfound in the inductive hypothesis to finally prove this subgoal.</p>\n<p>Indeed, after defining some \"stack_append_assoc_inv\" and<br>\n\"push_append_cmt_inv\" lemmas, the proof of this subgoal succeeds by<br>\napplying<br>\n    apply (simp only: push_append_cmt_inv)<br>\n    apply (simp only: stack_append_assoc_inv)</p>\n<p>But all this looks rather ugly. Is there a better/nicer way to do this?</p>\n<p>Cheers,</p>\n<p>Juan<br>\n</p>\n</blockquote>",
        "id": 294082372,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831095
    },
    {
        "content": "<p>From: Juan Antonio Navarro Pérez &lt;<a href=\"mailto:juannavarroperez@gmail.com\">juannavarroperez@gmail.com</a>&gt;<br>\nAlexander and Tobias!</p>\n<p>Thank you very much for the hints and pointers! Indeed reversing the<br>\norder of some of my simplifications has made the proofs go much<br>\nsmoother.</p>\n<p>I'll keep an eye on the commands that you suggested me to check.</p>\n<p>Best,</p>\n<p>Juan</p>",
        "id": 294082393,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831106
    }
]