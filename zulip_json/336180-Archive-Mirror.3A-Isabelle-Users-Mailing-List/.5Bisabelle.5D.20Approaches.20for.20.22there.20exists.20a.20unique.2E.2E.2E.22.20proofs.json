[
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nI want to show that in the Euclidean plane, there is a unique line between<br>\nany two distinct points. I want to show this is a particular way, so that I<br>\ncan later show that my notion of a point in the Euclidean plane being on a<br>\nline matches the requirements for defining a (more general) affine plane,<br>\ni.e., I want to show that the Euclidean plane is an affine plane. To get<br>\nthere, I define a function \"a2meets P l\" that is true when P is a point on<br>\nthe line l, false otherwise. Points are pairs of reals, lines are either<br>\nvertical or \"ordinary\" (i.e., have an equation like y = mx + b). I want to<br>\nprove this:</p>\n<p>\"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"</p>\n<p>To keep things simple, I proved existence and uniqueness separately:<br>\n  theorem a1a:<br>\n    fixes P :: a2pt<br>\n    fixes Q<br>\n    assumes \"P ≠ Q\"<br>\n    shows \"∃ ls . a2meets P ls ∧ a2meets Q ls\"</p>\n<p>lemma a1b:<br>\n    fixes P :: a2pt<br>\n    fixes Q<br>\n    fixes l<br>\n    fixes m<br>\n    assumes pq: \"P ≠ Q\"<br>\n    assumes pl : \"a2meets P l\"<br>\n    assumes ql : \"a2meets Q l\"<br>\n    assumes pm : \"a2meets P m\"<br>\n    assumes qm : \"a2meets Q m\"<br>\n    shows \"l = m\"</p>\n<p>I'd now like to conclude the overall theorem.  It's pretty clear (to me!)<br>\nthat a1a and a1b imply the result, but the only way I can coax Isar to get<br>\nthere seems needlessly convoluted:<br>\ntheorem a1 : \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"<br>\nproof -<br>\n  assume \"P ≠ Q\"<br>\n  show ?thesis<br>\n  proof (cases P)<br>\n    case (A2Point x0 y0)<br>\n    then show ?thesis<br>\n    proof (cases Q)<br>\n      case (A2Point x1 y1)<br>\n      have ?thesis using ‹P ≠ Q› a1a a1b by blast<br>\n      show ?thesis by (simp add: ‹∃!l. a2meets P l ∧ a2meets Q l›)<br>\n    qed<br>\n  qed<br>\nqed</p>\n<p>Of course, a1a and a1b do appear in there, but are the nested cases really<br>\nnecessary? (I wouldn't ask if I hadn't tried about 15 other approaches)</p>\n<p>More generally, is there  structure for proofs of existence of a unique<br>\nitem satisfying some criteria, analogous to the nice structures we have for<br>\nproof-by-cases, or proof-by-various-forms-of-induction? Complete .thy file<br>\nfollows.</p>\n<p>--John</p>\n<p>theory Small<br>\n  imports Complex_Main</p>\n<p>begin<br>\n  section {* The real affine plane *}<br>\n  datatype a2pt = A2Point \"real\" \"real\"</p>\n<p>datatype a2ln = A2Ordinary \"real\" \"real\"<br>\n                | A2Vertical \"real\"<br>\n  text \"Ordinary m b represents the line y = mx+b; Vertical xo is the line<br>\nx = xo \"</p>\n<p>fun a2meets :: \"a2pt ⇒ a2ln ⇒ bool\" where<br>\n    \"a2meets (A2Point x y) (A2Ordinary m b) = (y = m*x + b)\" |<br>\n    \"a2meets (A2Point x y) (A2Vertical xi) = (x = xi)\"</p>\n<p>text{* Now show a basic property: through any two distinct points,<br>\nthere's a unique line,<br>\n      which, for consistency with the main theory, we want to write as<br>\n      \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\" *}<br>\n  text{* Start with just existence *}</p>\n<p>theorem a1a:<br>\n    fixes P :: a2pt<br>\n    fixes Q<br>\n    assumes \"P ≠ Q\"<br>\n    shows \"∃ ls . a2meets P ls ∧ a2meets Q ls\"<br>\n  proof (cases P)<br>\n    case P: (A2Point x0 y0)<br>\n    then show ?thesis<br>\n    proof (cases Q)<br>\n      case Q: (A2Point x1 y1)<br>\n      then show ?thesis<br>\n      proof (cases \"(x0 = x1)\")<br>\n        case True<br>\n        assume f: \"x0 = x1\"<br>\n        have x1x0: \"x1 = x0\" by (simp add: True)<br>\n        let ?ll = \"A2Vertical x0\"<br>\n        have m1:  \"a2meets P ?ll\" using P  by simp<br>\n        have m2:  \"a2meets Q ?ll\" using Q  by (simp add: x1x0)<br>\n        thus ?thesis using m1 by blast (* We've proved the theorem...in the<br>\ncase where x0 = x1 *)<br>\n      next<br>\n        case False (* Now on to the other case, where x0 ≠ x1; it's clear<br>\nwhat the answer is,<br>\n                      but tought to coax Isabelle along to see it. *)<br>\n        assume f: \"x0 ≠ x1\"<br>\n        have x01 : \"x1 - x0  ≠ 0\" using f by simp<br>\n        let ?ll = \"A2Ordinary ((y1-y0)/(x1-x0))  (y0 -<br>\n((y1-y0)/(x1-x0))*x0) \"<br>\n          (* we want to show that P and Q are both on ll; P is easy for<br>\nsome reason; Q is not *)<br>\n        have m3:  \"a2meets P ?ll\" using P  by simp<br>\n            (* Now address the case of Q by doing all the algebra one step<br>\nat a time *)<br>\n        have s2: \"((y1-y0)/(x1 - x0))* x1 + (y0 - ((y1-y0)/(x1 - x0) )*x0)<br>\n= ((y1-y0) * x1/(x1 - x0)) + (y0 - ((y1-y0)/(x1 - x0) )*x0)\" by simp<br>\n        also have s3 : \"... =  ((y1-y0) * x1/(x1 - x0)) + (y0 -<br>\n((y1-y0)*x0/(x1 - x0) ))\" by simp<br>\n        also have s4 : \"... =  ((y1<em>x1-y0</em>x1) /(x1 - x0)) + (y0 -<br>\n((y1<em>x0-y0</em>x0)/(x1 - x0) ))\" by argo<br>\n        also have s5 : \"... =  ((y1<em>x1-y0</em>x1) /(x1 - x0)) + (y0*(x1 -<br>\nx0)/(x1-x0) - ((y1<em>x0-y0</em>x0)/(x1 - x0) ))\" using x01 by simp<br>\n        also have s6 : \"... =  ((y1<em>x1-y0</em>x1) /(x1 - x0)) + ((y0*x1 -<br>\ny0<em>x0)/(x1-x0) - ((y1</em>x0-y0*x0)/(x1 - x0) ))\" by argo<br>\n        also have s7 : \"... =  (y1<em>x1-y0</em>x1) /(x1 - x0) + ((y0<em>x1 - y0</em>x0)</p>\n<ul>\n<li>\n<p>(y1<em>x0-y0</em>x0))/(x1 - x0) \" by argo<br>\n        also have s8 : \"... =  ((y1<em>x1-y0</em>x1) + (y0<em>x1 - y0</em>x0) -<br>\n(y1<em>x0-y0</em>x0))/(x1 - x0) \" by argo<br>\n        also have s9 : \"... =  (y1<em>x1-y0</em>x1 + y0<em>x1 - y0</em>x0 -<br>\ny1<em>x0+y0</em>x0)/(x1 - x0) \" by argo<br>\n        also have s10 : \"... =  (y1<em>x1 - y0</em>x0 - y1<em>x0+y0</em>x0)/(x1 - x0) \"<br>\nby argo<br>\n        also have s11 : \"... =  (y1<em>x1  - y1</em>x0)/(x1 - x0) \" by argo<br>\n        also have s12 : \"... =  (y1*(x1  - x0))/(x1 - x0) \" by argo<br>\n        also have s13 : \"... =  y1 \" using x01 by simp<br>\n        finally have s14: \"((y1-y0)/(x1 - x0))* x1 + (y0 - ((y1-y0)/(x1 -<br>\nx0) )*x0) = y1\" .<br>\n        moreover have m4:  \"a2meets Q ?ll\" using s14 by (simp add: Q)<br>\n        show ?thesis using m3 m4 by auto<br>\n      qed<br>\n    qed<br>\n  qed</p>\n<p>text{*For this next theorem, it might make sense to phrase it as<br>\nlemma a1b: \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\", i.e., as the final<br>\nresult,<br>\nbut that would require proving the existence of l (which we just did in the<br>\nprevious lemma) and<br>\nthen proving that it's unique. Instead, we can just say that if l and m<br>\nboth contain the<br>\ndistinct points P and Q, then l must equal m. From this, and the previous<br>\nlemma, we can then<br>\nconclude that axiom 1 is true (which we'll do in a final theorem).<br>\n *}</p>\n<p>lemma a1b:<br>\n  fixes P :: a2pt<br>\n  fixes Q<br>\n  fixes l<br>\n  fixes m<br>\n  assumes pq: \"P ≠ Q\"<br>\n  assumes pl : \"a2meets P l\"<br>\n  assumes ql : \"a2meets Q l\"<br>\n  assumes pm : \"a2meets P m\"<br>\n  assumes qm : \"a2meets Q m\"<br>\n  shows \"l = m\"<br>\nproof (cases P)<br>\n  case (A2Point x0 y0)<br>\n  then show ?thesis<br>\n  proof (cases Q)<br>\n    case (A2Point x1 y1)<br>\n    have ?thesis<br>\n    proof (cases l)<br>\n      case (A2Ordinary s1 b1) (* l is ordinary *)<br>\n      assume lo: \"l = A2Ordinary s1 b1\"<br>\n      then show ?thesis<br>\n      proof (cases m) (* Handle m ordinary, vertical in two steps *)<br>\n        case (A2Ordinary s2 b2)<br>\n        then show ?thesis by (smt A2Point a2ln.inject(1) a2meets.elims(2)<br>\na2meets.simps(1) a2pt.inject crossproduct_noteq lo pl pm pq ql qm)<br>\n      next<br>\n        case (A2Vertical x2)<br>\n        then have ?thesis using A2Point a2meets.elims(2) pl pm pq ql qm<br>\nby fastforce<br>\n        show ?thesis by (simp add: ‹l = m›)<br>\n      qed<br>\n    next<br>\n      case (A2Vertical x2) (* l is vertical *)<br>\n      then show ?thesis by (smt a2ln.inject(1) a2meets.elims(2)<br>\na2meets.simps(2) pl pm pq ql qm)<br>\n    qed<br>\n    show ?thesis by (simp add: ‹l = m›)<br>\n  qed<br>\nqed</p>\n</li>\n</ul>\n<p>theorem a1 : \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"<br>\nproof -<br>\n  assume \"P ≠ Q\"<br>\n  show ?thesis<br>\n  proof (cases P)<br>\n    case (A2Point x0 y0)<br>\n    then show ?thesis<br>\n    proof (cases Q)<br>\n      case (A2Point x1 y1)<br>\n      have ?thesis using ‹P ≠ Q› a1a a1b by blast<br>\n      show ?thesis by (simp add: ‹∃!l. a2meets P l ∧ a2meets Q l›)<br>\n    qed<br>\n  qed<br>\nqed</p>",
        "id": 294761814,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199962
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:sewell@chalmers.se\">sewell@chalmers.se</a>&gt;<br>\nI think that your nested proof of theorem a1 is just a long version of this:</p>\n<p>theorem a1 : \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"<br>\n  using a1a a1b by blast</p>\n<p>The core of your proof is that blast knows how to show exists-unique properties if you give it both a1a and a1b.</p>\n<p>I think that blast solves this using a default introduction rule for exists-unique, which is either ex1I or ex_ex1I. Here's a more Isar approach to the problem using ex_ex1I. I think that this style of using goal_cases is considered standard:</p>\n<p>theorem a1 : \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"<br>\nproof (rule ex_ex1I, goal_cases)<br>\n  case 1<br>\n  assume \"P ≠ Q\"<br>\n  then show ?case by (rule a1a)<br>\nnext<br>\n  case (2 l y)<br>\n  then show ?case by (simp add: a1b)<br>\nqed</p>\n<p>I'm not sure what else to say. Perhaps you're looking for a particular style of proof?</p>\n<p>Cheers,<br>\n    Thomas.</p>",
        "id": 294761829,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199966
    },
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nThanks, Thomas. that \"using a1a a1b by blast\" thing was exactly what I was<br>\nlooking for. In particular, it gives me confidence that my phrasing of a1b<br>\nwasn't getting the way of things; I find it's easy to say (for real<br>\nnumbers, for instance) something like \"x1 != x2\" instead of \"x1 - x2 != 0\"<br>\n(which seem completely equivalent to me), and have it make a huge<br>\ndifference to the complexity of a proof, so knowing that this pattern makes<br>\nthings work is great.</p>\n<p>I now see that using \"try\" right after the statement of the theorem<br>\nproduces your \"blast\" proof. Instead of doing that, I had tried</p>\n<p>theorem a1 : \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"<br>\nproof -<br>\n   try</p>\n<p>and gotten a \"tried in vain\" result. I'm not sure I understand why there's<br>\na difference.</p>\n<p>But more generally, you recommend an alternate Isar-idiomatic proof using<br>\n\"ex_ex1I, goal_cases\", and (like the \"blast\" case), I'm wondering how I can<br>\nlearn<br>\n(a) that these rules/provers exist at all, and<br>\n(b) what each of these rules or provers is actually good at.</p>\n<p>Looking at \"Programming and Proving\", for instance, the word \"metis\"<br>\nappears exactly four times, once with a brief description that suggests<br>\nthat IT should be the tool used here rather than \"blast\". As a new user,<br>\nI'm constantly being surprised by new tools like \"goal_cases\" and<br>\n\"ex_ex1l\", neither of which is mentioned at all in P&amp;P.</p>\n<p>--John</p>",
        "id": 294761840,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199972
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nI would add:</p>\n<p>theorem a1 :<br>\nassumes \"P ≠ Q\"<br>\nshows \"∃! l . a2meets P l ∧ a2meets Q l\"<br>\nproof -<br>\n  have \"∃l. a2meets P l ∧ a2meets Q l\"<br>\n    using assms a1a by simp<br>\n  moreover have \"⋀l l'. ⟦ a2meets P l ∧ a2meets Q l; a2meets P l' ∧ a2meets Q l' ⟧ ⟹ l' = l\"<br>\n    using assms a1b by simp<br>\n  ultimately show ?thesis by blast<br>\nqed</p>\n<p>Maybe this is more the structure John is looking for.</p>\n<p>The default method for ∃! demands that the witness be exhibited:</p>\n<p>theorem a1 :<br>\nassumes \"P ≠ Q\"<br>\nshows \"∃! l . a2meets P l ∧ a2meets Q l\"<br>\nproof<br>\n  show \"a2meets P XXX ∧ a2meets Q XXX\"<br>\n    sorry<br>\n  show \"⋀l. a2meets P l ∧ a2meets Q l ⟹ l = XXX\"<br>\n    sorry<br>\nqed</p>\n<p>so it is not very convenient with the lemmas that have already been set up.</p>",
        "id": 294761847,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199978
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:sewell@chalmers.se\">sewell@chalmers.se</a>&gt;<br>\nOK, let's clarify a bit. The ex_ex1I here is a theorem, not a mechanism. It's being used as an introduction rule here via \"rule\".</p>\n<p>I'd recommend people learning Isabelle to learn (roughly) what the rule-application calculus is, what intro/dest/elim rules do, and thus how to use them manually and also how to supply them to some tools, e.g. (clarsimp dest!: ...) or (blast intro: ...). Unfortunately I don't actually know where in the reference material to point you.</p>\n<p>Since it's a rule, you can search for it with find_theorems. I found the theorem by searching for rules that can prove exists-unique properties, like so:</p>\n<p>find_theorems \"_ ⟹ ∃!_. _\"</p>\n<p>I actually didn't know what goal_cases did until an hour or two ago. I was looking for a way to use ex_ex1I  in an Isar-like way, and I vaguely recalled that there was a new feature with cases in its name, and managed to figure it out from there. Roughly speaking, it sets you up to continue in an Isar structured proof from some goal state, which I created here by applying a rule.</p>\n<p>I think it is a real problem of a big complex system like this that there are features out there which you have likely forgotten about. In a long former Isabelle project, I famously forgot about a feature that I had implemented myself. You can find rules with both the sledgehammer and try, but there's no equivalent gadget for finding tools or understanding what they do.</p>\n<p>Quick primer: blast and metis are both first-order solvers. Blast does a search which involves introduction/elimination steps similar to Isabelle rule steps, and it uses the default rule sets. That's how it knew how to prove an exists-unique without being told a rule about it, ex_ex1I is a global default introduction rule. Metis doesn't have that global setup, but it understand equality better and generally has a smarter search strategy, if it's given enough information. There are, of course, many other variants.</p>\n<p>Asking the list: is there a good cheat-sheet or primer for commonly used methods/tactics and quick intuitions of when they're likely to be useful?</p>\n<p>Cheers,</p>\n<p>Thomas.</p>",
        "id": 294761854,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199983
    },
    {
        "content": "<p>From: Karn Kallio &lt;<a href=\"mailto:tierpluspluslists@skami.org\">tierpluspluslists@skami.org</a>&gt;<br>\nWith respect to this comment:</p>\n<p>I have been making an on and off investigation into Isabelle, and have<br>\nfound the only practical way to learn these sorts of things is to spend<br>\na lot of time reading the developments in the AFP.  The you will<br>\ndiscover them, and by the context of use get an idea of when they may<br>\nbe helpful.</p>",
        "id": 294761985,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200055
    }
]