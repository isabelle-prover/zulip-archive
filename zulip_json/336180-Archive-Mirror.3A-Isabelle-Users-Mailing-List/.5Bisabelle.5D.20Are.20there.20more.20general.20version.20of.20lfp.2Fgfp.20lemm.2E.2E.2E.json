[
    {
        "content": "<p>From: Alexander Kogtenkov via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Isabelle users,</p>\n<p>Theory While_Combinator proves lemmas for least fixed point (e.g. lfp_while) using finite sets (BTW, the dual versions for gfp are missing for some reason). Are there more general versions of the lemmas that use finite lattices instead?</p>\n<p>Regards,<br>\nAlexander Kogtenkov</p>",
        "id": 294678167,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175710
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nReminds me of kleene fp iteration.</p>\n<p>This one might help in proving the lemma you have in mind:<br>\n Nat.lfp_Kleene_iter: <br>\n    ⟦mono ?f; (?f ^^ Suc ?k) bot = (?f ^^ ?k) bot⟧ <br>\n    ⟹ lfp ?f = (?f ^^ ?k) bot</p>",
        "id": 294678175,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175714
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nAlexander, Peter:</p>\n<p>I recently had a similar need and bashed out the lemmas below.</p>\n<p>I’m hoping Andreas L. will commit these and others to the Isabelle repository when he gets some time.</p>\n<p>If you’re going to go down the chain-finite route, give me a shout and I’ll send you some boilerplate.</p>\n<p>cheers,<br>\npeter</p>\n<p>subsection\\&lt;open&gt; Relate @{const \"gfp\"} and @{const \"while\"} \\&lt;close&gt;</p>\n<p>text\\&lt;open&gt;</p>\n<p>We adapt and generalise the lemmas relating @{const \"lfp\"} to @{const<br>\n\"while\"} in \\&lt;open&gt;While_Combinator\\&lt;close&gt; to an arbitrary finite<br>\ncomplete lattice and play the same game for @{const \"gfp\"}. This story<br>\ncould be generalized from finite types to chain-finite lattices.</p>\n<p>\\&lt;close&gt;</p>\n<p>(* Nat, Kleene iteration for gfp. *)<br>\nsubsection \\&lt;open&gt;Kleene iteration\\&lt;close&gt;</p>\n<p>lemma Kleene_iter_gpfp:<br>\nassumes \"mono f\" and \"p \\&lt;le&gt; f p\" shows \"p \\&lt;le&gt; (f^^k) (top::'a::order_top)\"<br>\nproof(induction k)<br>\n  case 0 show ?case by simp<br>\nnext<br>\n  case Suc<br>\n  from monoD[OF assms(1) Suc] assms(2)<br>\n  show ?case by simp<br>\nqed</p>\n<p>lemma gfp_Kleene_iter: assumes \"mono f\" and \"(f^^Suc k) top = (f^^k) top\"<br>\nshows \"gfp f = (f^^k) top\"<br>\nproof(rule antisym)<br>\n  show \"(f^^k) top \\&lt;le&gt; gfp f\"<br>\n  proof(rule gfp_upperbound)<br>\n    show \"(f^^k) top \\&lt;le&gt; f ((f^^k) top)\" using assms(2) by simp<br>\n  qed<br>\nnext<br>\n  show \"gfp f \\&lt;le&gt; (f^^k) top\"<br>\n    using Kleene_iter_gpfp[OF assms(1)] gfp_unfold[OF assms(1)] by simp<br>\nqed</p>\n<p>(* While_Combinator *)</p>\n<p>lemma wf_finite_less:<br>\n  assumes \"finite (C :: 'a::order set)\"<br>\n  shows \"wf {(x, y). {x, y} \\&lt;subseteq&gt; C \\&lt;and&gt; x &lt; y}\"<br>\nby (rule wf_measure[where f=\"\\&lt;lambda&gt;b. card {a. a \\&lt;in&gt; C \\&lt;and&gt; a &lt; b}\", THEN wf_subset])<br>\n   (fastforce simp: less_eq assms intro: psubset_card_mono)</p>\n<p>lemma wf_finite_greater:<br>\n  assumes \"finite (C :: 'a::order set)\"<br>\n  shows \"wf {(x, y). {x, y} \\&lt;subseteq&gt; C \\&lt;and&gt; y &lt; x}\"<br>\nby (rule wf_measure[where f=\"\\&lt;lambda&gt;b. card {a. a \\&lt;in&gt; C \\&lt;and&gt; b &lt; a}\", THEN wf_subset])<br>\n   (fastforce simp: less_eq assms intro: psubset_card_mono)</p>\n<p>lemma while_option_finite_increasing_Some:<br>\n  fixes f :: \"'a::order \\&lt;Rightarrow&gt; 'a\"<br>\n  assumes \"mono f\" and \"finite (UNIV :: 'a set)\" and \"s \\&lt;le&gt; f s\"<br>\n  shows \"\\&lt;exists&gt;P. while_option (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f s = Some P\"<br>\nby (rule wf_rel_while_option_Some[where R=\"{(x, y). y &lt; x}\" and P=\"\\&lt;lambda&gt;A. A \\&lt;le&gt; f A\" and s=\"s\"])<br>\n   (auto simp: assms monoD intro: wf_finite_greater[where C=\"UNIV::'a set\", simplified])</p>\n<p>lemma lfp_the_while_option:<br>\n  fixes f :: \"'a::complete_lattice \\&lt;Rightarrow&gt; 'a\"<br>\n  assumes \"mono f\" and \"finite (UNIV :: 'a set)\"<br>\n  shows \"lfp f = the(while_option (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f bot)\"<br>\nproof -<br>\n  obtain P where \"while_option (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f bot = Some P\"<br>\n    using while_option_finite_increasing_Some[OF assms, where s=bot] by simp blast<br>\n  with while_option_stop2[OF this] lfp_Kleene_iter[OF assms(1)]<br>\n  show ?thesis by auto<br>\nqed</p>\n<p>lemma lfp_while:<br>\n  fixes f :: \"'a::complete_lattice \\&lt;Rightarrow&gt; 'a\"<br>\n  assumes \"mono f\" and \"finite (UNIV :: 'a set)\"<br>\n  shows \"lfp f = while (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f bot\"<br>\nunfolding while_def using assms by (rule lfp_the_while_option)</p>\n<p>(* gfp *)</p>\n<p>lemma while_option_finite_decreasing_Some:<br>\n  fixes f :: \"'a::order \\&lt;Rightarrow&gt; 'a\"<br>\n  assumes \"mono f\" and \"finite (UNIV :: 'a set)\" and \"f s \\&lt;le&gt; s\"<br>\n  shows \"\\&lt;exists&gt;P. while_option (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f s = Some P\"<br>\nby (rule wf_rel_while_option_Some[where R=\"{(x, y). x &lt; y}\" and P=\"\\&lt;lambda&gt;A. f A \\&lt;le&gt; A\" and s=\"s\"])<br>\n   (auto simp add: assms monoD intro: wf_finite_less[where C=\"UNIV::'a set\", simplified])</p>\n<p>lemma gfp_the_while_option:<br>\n  fixes f :: \"'a::complete_lattice \\&lt;Rightarrow&gt; 'a\"<br>\n  assumes \"mono f\" and \"finite (UNIV :: 'a set)\"<br>\n  shows \"gfp f = the(while_option (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f top)\"<br>\nproof -<br>\n  obtain P where \"while_option (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f top = Some P\"<br>\n    using while_option_finite_decreasing_Some[OF assms, where s=top] by simp blast<br>\n  with while_option_stop2[OF this] gfp_Kleene_iter[OF assms(1)]<br>\n  show ?thesis by auto<br>\nqed</p>\n<p>lemma gfp_while:<br>\n  fixes f :: \"'a::complete_lattice \\&lt;Rightarrow&gt; 'a\"<br>\n  assumes \"mono f\" and \"finite (UNIV :: 'a set)\"<br>\n  shows \"gfp f = while (\\&lt;lambda&gt;A. f A \\&lt;noteq&gt; A) f top\"<br>\nunfolding while_def using assms by (rule gfp_the_while_option)</p>",
        "id": 294678192,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175720
    },
    {
        "content": "<p>From: Alexander Kogtenkov via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Peter,</p>\n<p>Looks promising indeed. And I'm both hands for including these in the repository so that other people who need something like that can benefit from your work.</p>\n<p>I'll come back to you if I encounter any issues/questions when using the lemmas in my context.</p>\n<p>Best regards,<br>\nAlexander Kogtenkov</p>",
        "id": 294678241,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175726
    }
]