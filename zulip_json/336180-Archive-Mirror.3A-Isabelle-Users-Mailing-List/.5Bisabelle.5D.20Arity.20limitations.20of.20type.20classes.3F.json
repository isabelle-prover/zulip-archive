[
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nGreetings,</p>\n<p>I am working with a situation where I want to state that words with <br>\ncertain properties on their lengths are members of a type class. <br>\nHowever, there seems to be no way to state that a type constructor (in <br>\nthis case bit0) takes a type class into two different ones.</p>\n<p>So if we have words_of_length_2, we can say that:</p>\n<p>instance bit0 :: (words_of_length_4) words_of_length_2</p>\n<p>If the length is 4, then we know it's divisible by 4:</p>\n<p>instance bit0 :: (words_of_length_2) words_div_4</p>\n<p>but also</p>\n<p>instance bit0 :: (words_div_2) words_div_4</p>\n<p>at this point, we are stuck, as the above line will have problems with <br>\narity.</p>\n<p>In general, anything of this form doesn't seem to work:<br>\naxclass a<br>\naxclass b<br>\naxclass c<br>\ninstance bit0 :: (a) b sorry<br>\ninstance bit0 :: (c) b oops (* FAIL *)</p>\n<p>Looking at the papers didn't really enlighten. Is this a fundamental <br>\nlimitation on type classes? Is there any way to get around it?</p>\n<p>Yours Sincerely,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294068620,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826377
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThis is an inherent limitation which allows to infer unique most general <br>\ntypes. The technical details are explained for example here:<br>\n<a href=\"http://www4.informatik.tu-muenchen.de/~nipkow/pubs/lf91.html\">http://www4.informatik.tu-muenchen.de/~nipkow/pubs/lf91.html</a></p>\n<p>Sorry about that.<br>\nTobias</p>\n<p>Rafal Kolanski wrote:</p>",
        "id": 294068635,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826387
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Rafal,</p>\n<p>I can suggest a few workarounds for your type arity conflicts. Here is  <br>\nyour basic example:</p>\n<blockquote>\n<p>axclass a<br>\naxclass b<br>\naxclass c<br>\ninstance bit0 :: (a) b sorry<br>\ninstance bit0 :: (c) b oops (* FAIL *)</p>\n</blockquote>\n<p>If class \"a\" can be proven to be a subclass of class \"c\", (or  <br>\nvice-versa) then the conflict will be avoided. For example, this  <br>\nsequence of commands will work:<br>\naxclass a<br>\naxclass b<br>\naxclass c<br>\ninstance a &lt; c sorry<br>\ninstance bit0 :: (a) b sorry<br>\ninstance bit0 :: (c) b sorry</p>\n<p>In your case, I would expect that you should be able to prove that  <br>\nwords_of_length_2 is a subclass of words_div_2; maybe this will solve  <br>\nyour problem.</p>\n<p>If proving a subclass relationship is not possible, then another  <br>\nworkaround is possible by declaring a new class whose axioms are a  <br>\ndisjunction of two other classes. For example:<br>\naxclass a<br>\naxclass b<br>\naxclass c<br>\naxclass a_or_c<br>\ninstance a &lt; a_or_c<br>\ninstance c &lt; a_or_c<br>\ninstance bit0 :: (a_or_c) b sorry<br>\ninstance bit0 :: (a) b sorry<br>\ninstance bit0 :: (c) b sorry</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>\n<p>Quoting Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;:</p>\n<blockquote>\n<p>Greetings,</p>\n<p>I am working with a situation where I want to state that words with<br>\ncertain properties on their lengths are members of a type class.<br>\nHowever, there seems to be no way to state that a type constructor (in<br>\nthis case bit0) takes a type class into two different ones.</p>\n<p>So if we have words_of_length_2, we can say that:</p>\n<p>instance bit0 :: (words_of_length_4) words_of_length_2</p>\n<p>If the length is 4, then we know it's divisible by 4:</p>\n<p>instance bit0 :: (words_of_length_2) words_div_4</p>\n<p>but also</p>\n<p>instance bit0 :: (words_div_2) words_div_4</p>\n<p>at this point, we are stuck, as the above line will have problems with arity.</p>\n<p>In general, anything of this form doesn't seem to work:<br>\naxclass a<br>\naxclass b<br>\naxclass c<br>\ninstance bit0 :: (a) b sorry<br>\ninstance bit0 :: (c) b oops (* FAIL *)</p>\n<p>Looking at the papers didn't really enlighten. Is this a fundamental<br>\nlimitation on type classes? Is there any way to get around it?</p>\n<p>Yours Sincerely,</p>\n<p>Rafal Kolanski.</p>\n</blockquote>",
        "id": 294068829,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826453
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nHi Brian,</p>\n<p>Your work-arounds (especially the second one) are very interesting, and <br>\nwill probably prove useful in the future. I experimented with what you <br>\nsuggested however, for what I'm doing, Tobias' explanation seems to be <br>\nthe limit.</p>\n<p>What I really want is a type class representing words of length 8, 16 or <br>\n32. I would then be able to show that words of this class are \"storable\" <br>\n  (another class) in the C sense (byte, short, int). However, once I <br>\ndeclare word_len8 to be storable, I can't do that for word_len16 because <br>\nbit0 takes word_len8 to word_len16. Sadly, I don't think there is a way <br>\nto get around this nicely.</p>\n<p>Thank you very much for the suggestions though! I can feel they will get <br>\nme out of trouble at some point in the future :)</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>\n<p>Brian Huffman wrote:</p>",
        "id": 294068872,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826469
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nQuoting Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;:</p>\n<p>If I understand you correctly, what you need is a type class like this  <br>\none, which includes only types of size 8, 16, or 32:</p>\n<p>axclass card_8_16_32 &lt; finite<br>\n   card_8_16_32: \"CARD('a) = 8 | CARD('a) = 16 | CARD('a) = 32\"</p>\n<p>However, you also want to be able to show that the type (bit0 'a) is  <br>\nan instance of this class, for appropriate argument types. I.e., you  <br>\nneed to have a class instance of the form</p>\n<p>instance bit0 :: (???) card_8_16_32</p>\n<p>Now the question is, what is the most general type class you need to  <br>\nput in place of the question marks? Since bit0 doubles the cardinality  <br>\nof its argument type, what you need is a type class that includes only  <br>\ntypes of size 4, 8, or 16:</p>\n<p>axclass card_4_8_16 &lt; finite<br>\n   card_4_8_16: \"CARD('a) = 4 | CARD('a) = 8 | CARD('a) = 16\"</p>\n<p>Now you can prove the following:<br>\ninstance bit0 :: (card_4_8_16) card_8_16_32</p>\n<p>Of course, now we need to provide another instance to show that bit0  <br>\n'a :: card_4_8_16 for appropriate argument types. So we just repeat  <br>\nthe process, adding more type classes until we get to class card_1,  <br>\nwhich serves as a base case.</p>\n<p>axclass card_2_4_8 &lt; finite<br>\n   card_2_4_8: \"CARD('a) = 2 | CARD('a) = 4 | CARD('a) = 8\"</p>\n<p>axclass card_1_2_4 &lt; finite<br>\n   card_1_2_4: \"CARD('a) = Suc 0 | CARD('a) = 2 | CARD('a) = 4\"</p>\n<p>axclass card_1_2 &lt; finite<br>\n   card_1_2: \"CARD('a) = Suc 0 | CARD('a) = 2\"</p>\n<p>axclass card_1 &lt; finite<br>\n   card_1: \"CARD('a) = Suc 0\"</p>\n<p>instance bit0 :: (card_2_4_8) card_4_8_16<br>\ninstance bit0 :: (card_1_2_4) card_2_4_8<br>\ninstance bit0 :: (card_1_2) card_1_2_4<br>\ninstance bit0 :: (card_1) card_1_2<br>\ninstance num1 :: card_1_2_4<br>\ninstance num1 :: card_1_2<br>\ninstance num1 :: card_1</p>\n<p>We can show that these instance declarations are sufficient by  <br>\ndeclaring the following constant:<br>\nconsts<br>\n   store :: \"'a::card_8_16_32 =&gt; int list\"</p>\n<p>term \"store (x::32)\" (* OK *)<br>\nterm \"store (x::16)\" (* OK *)<br>\nterm \"store (x::8)\" (* OK *)<br>\nterm \"store (x::64)\" (* type error *)<br>\nterm \"store (x::20)\" (* type error *)</p>\n<p>Hopefully these type classes will work for you. However, I expect that  <br>\ndefining overloaded operations on these type classes might be a bit  <br>\ntricky. Constant definitions would probably need to do case analysis  <br>\non the cardinality of the type argument, but I haven't tried this.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294068926,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826489
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Rafal,</p>\n<p>I have barely to add anything to Brian's excellent solution proposal<br>\nexcept that you should consider using Isabelle's class / instantiation<br>\ninstead of the primitive axclass / instance.  A short tutorial can be<br>\nfound at <a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/classes.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/classes.pdf</a>.</p>\n<p>Perhaps it is sufficent to provide a combinator like</p>\n<p>definition bit_length_case :: \"'b itself =&gt; 'a =&gt; 'a =&gt; 'a =&gt; 'a\" where<br>\n  \"bit_length_case TYPE('b) f g h = (if CARD('b) = 16 then f else if<br>\nCARD ('b) = 8 then g else ...\"</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/uotuh0YQq0qaUeKGveJToQQ6/signature.asc\">signature.asc</a></p>",
        "id": 294068982,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826512
    }
]