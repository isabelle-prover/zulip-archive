[
    {
        "content": "<p>From: <a href=\"mailto:munddr@gmail.com\">munddr@gmail.com</a><br>\nHi,</p>\n<p>I'm trying to prove a very simple lemma in the following simple example:</p>\n<p>axiomatization<br>\nf :: \"nat =&gt; nat\" and<br>\nSet :: \"nat set\" and<br>\ni1 :: nat and<br>\ni2 :: nat<br>\nwhere<br>\nf1 : \"f i1 = 1\" and<br>\nf2 : \"f i2 = 2\" and<br>\ns1 : \"Set = {i1,i2}\"</p>\n<p>lemma \"{i2} = {x : {i2,i1}. fx = 2}\"<br>\nusing f1 f2 s1<br>\nby auto</p>\n<p>It works and I know s1 is redundant here. Now, let's try:</p>\n<p>lemma \"{i2} = {x : {i1,i2}. fx = 2}\"<br>\nusing f1 f2 s1<br>\nby auto</p>\n<p>Auto doesn't work. However, if s1 was removed, it works. So how come using  <br>\nthe redundant fact \"s1\" requires the set to be ordered in a particular way?  <br>\nIt doesn't seem intuitive.</p>\n<p>Help will be appreciated!</p>\n<p>Thanks<br>\nJohn</p>",
        "id": 294130209,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842535
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi John,</p>\n<p>I tried this example with \"trace simplifier\" enabled, and it reveals<br>\nwhat the problem is. Here is the first part of the tracing output:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\n⟦f i1 = 1; f i2 = 2; Set = {i1, i2}⟧ ⟹ {i2} = {x ∈ {i1, i2}. f x = 2}</p>\n<p>[1]Adding rewrite rule \"??.unknown\":<br>\nf i2 ≡ 2</p>\n<p>[1]Adding rewrite rule \"??.unknown\":<br>\n{i1, i2} ≡ Set</p>\n<p>Note the orientation of the rule in the last line.</p>\n<p>Usually, when you have an assumption of the form \"lhs = rhs\", the<br>\nsimplifier will add the rewrite rule \"lhs == rhs\" to the local<br>\nsimpset. But depending on some heuristic, the simplifier may decide to<br>\nadd the rewrite \"rhs == lhs\", or even \"(lhs = rhs) == True\" instead. I<br>\nhave seen this behavior before in situations where the rule \"lhs ==<br>\nrhs\" would obviously loop, so it only makes sense to use the opposite<br>\norientation. \"(lhs = rhs) == True\" is used when either orientation<br>\nwould obviously loop.</p>\n<p>Apparently the heuristic also reorients rules like \"Set = {i1, i2}\",<br>\nwhere the lhs is a top-level constant. Usually this reorientation<br>\nmakes sense (for example, with the assumption \"[] = xs\", it is better<br>\nto replace each occurrence of \"xs\" with \"[]\" than vice-versa) since<br>\nfor most top-level constants, there will be further applicable simp<br>\nrules in the simpset.</p>\n<p>Note that the heuristic does not apply to locally-fixed variables. So<br>\nthe following proof works:</p>\n<p>lemma<br>\n  fixes f :: \"nat =&gt; nat\" and Set :: \"nat set\" and i1 :: nat and i2 :: nat<br>\n  assumes f1 : \"f i1 = 1\" and f2 : \"f i2 = 2\" and s1 : \"Set = {i1, i2}\"<br>\n  shows \"{i2} = {x : {i1, i2}. f x = 2}\"<br>\nusing f1 f2 s1<br>\nby auto</p>\n<p>I expect that if you changed your axiomatization to a locale, the<br>\nreorientation would similarly go away.</p>\n<p>Also, if you use \"simp add\" instead of \"using\", the reorientation does<br>\nnot happen:</p>\n<p>lemma \"{i2} = {x : {i1, i2}. f x = 2}\"<br>\nby (auto simp add: f1 f2 s1)</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294130215,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842538
    }
]