[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear list,</p>\n<p>I have the following datatype:</p>\n<p>datatype \"term\" =<br>\n  Const string |<br>\n  Free string |<br>\n  Abs \"term\" (\"Λ _\" [71] 71) |<br>\n  Bound nat |<br>\n  App \"term\" \"term\" (infixl \"$\" 70)</p>\n<p>I define a sub-term relation:</p>\n<p>inductive direct_sub_term :: \"term ⇒ term ⇒ bool\" where<br>\nleft: \"direct_sub_term t (t $ u)\" |<br>\nright: \"direct_sub_term u (t $ u)\" |<br>\nabs: \"direct_sub_term t (Λ t)\"</p>\n<p>abbreviation sub_term :: \"term ⇒ term ⇒ bool\" (infix \"◃\" 50) where<br>\n\"sub_term ≡ direct_sub_term⇧+⇧+\"</p>\n<p>I have no idea whether this is in fact a proper well-ordering, but I'd<br>\nlike to at least prove the induction principle:</p>\n<p>lemma sub_term_induct[case_names sub]:<br>\n  assumes \"⋀t. (⋀u. u ◃ t ⟹ P u) ⟹ P t\"<br>\n  shows \"P t\"</p>\n<p>The proof is rather mechanical, but it took me a while to figure out (by<br>\nlooking at the corresponding proof for natural numbers).</p>\n<p>I wonder if there's existing automation to derive the \"◃\" predicate and<br>\nthe corresponding proof.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294672153,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173714
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>AFAIK there is no automation support for this.</p>\n<p>For finitely branching, tree-like data structures, the subterm relation is well-founded <br>\n(as a proof, just take the size of the tree as a measure). So I'd expect that you can <br>\nprove the induction statement using induction_schema and lexicographic_order (after some <br>\nsetup for tranclp and direct_sub_term).</p>\n<p>If you have an infinitely branching tree (or recursion through other BNFs without a size <br>\nfunction), then well-foundedness of the subterm relation cannot be proven with measures. <br>\nIn these cases, I normally manually write definitions similar to yours and prove <br>\nwell-foundedness, which I can then use in termination proofs for the function package.</p>\n<p>So if you have the time to automate these steps, I'd be all in favour of it. I guess that <br>\nthis should not be too hard with the new datatype package, but it definitely requires some <br>\nwork, but Dmitriy and Jasmin are in a better position to estimate the effort needed.</p>\n<p>Andreas</p>",
        "id": 294672173,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173720
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Lars and Andreas, </p>\n<p>Yes, it would be nice to have this automated. Back in the days when designing the new datatype package, we thought of adding this as well, <br>\nbut eventually renounced in order to keep the effort size manageable.    </p>\n<p>Here is my pattern for proving this for finitely branching datatypes (which constitute 99 percent of those in current use). <br>\nThe following lemma transports well-foundedness back from the order on naturals: </p>\n<p>lemma wfP_lt: <br>\nassumes \"∀ x y. r x y ⟶ (f x::nat) &lt; f y\"<br>\nshows \"wfP r\"<br>\nproof-<br>\n  have \"{(x, y). r x y} ⊆ inv_image {(x,y) . x &lt; y} f\" <br>\n  using assms unfolding inv_image_def by auto<br>\n  thus ?thesis unfolding wfP_def<br>\n  using wf_inv_image wf_less wf_subset by blast<br>\nqed</p>\n<p>Then the following are absolute routine (and are presumably not hard to automate, but have the usual <br>\ncomplications coming from \"mutual\" and \"nested\"): </p>\n<p>lemma size_direct_sub_term[simp]: <br>\nassumes \"direct_sub_term t u\" shows \"size t &lt; size u\"<br>\nusing assms by induction auto</p>\n<p>lemma sub_term[simp]: <br>\nassumes \"sub_term t u\" shows \"size t &lt; size u\"<br>\nusing assms apply(induction, simp_all)<br>\nusing dual_order.strict_trans size_direct_sub_term by blast</p>\n<p>lemma wfP_sub_term: \"wfP sub_term\"<br>\nusing sub_term wfP_lt by blast</p>\n<p>lemma sub_term_induct[case_names sub]:<br>\n  assumes \"⋀t. (⋀u. u ◃ t ⟹ P u) ⟹ P t\"<br>\n  shows \"P t\"<br>\nusing assms wfP_sub_term by (metis wfP_induct_rule)</p>\n<p>All the best, <br>\n  Andrei</p>",
        "id": 294672197,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173727
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>thanks everyone. Also, Peter pointed out to me that it's actually rather<br>\nsimple, so automation is already there (with \"auto\", \"induction_schema\"<br>\netc.) I should've asked yesterday ... Now I feel stupid :-)</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294672216,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173732
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>this would be useful indeed. Here is my pattern for proving this for arbitrary datatypes (which constitute 100 percent of those in current use ;-) ).</p>\n<p>Note that my definitions and proofs are done on what we call the low-level (where there is only one constructor).</p>\n<p>Jasmin is usually the one lifting lemmas (in particular the intro rules and the induction principle of ◃⇩1) to multiple constructors. But I presume this should not be harder than usual in this case.</p>\n<p>Dmitriy</p>\n<p>theory Scratch<br>\nimports \"~~/src/HOL/Library/BNF_Axiomatization\"<br>\nbegin</p>\n<p>declare [[typedef_overloaded]]</p>\n<p>bnf_axiomatization 'a F [wits: \"'a F\"]</p>\n<p>datatype T = C \"T F\"</p>\n<p>inductive direct_sub_term :: \"T ⇒ T ⇒ bool\" (infix \"◃⇩1\" 50) where<br>\n  \"y ∈ set_F x ⟹ y ◃⇩1 C x\"</p>\n<p>abbreviation sub_term :: \"T ⇒ T ⇒ bool\" (infix \"◃\" 50) where<br>\n  \"sub_term ≡ direct_sub_term⇧+⇧+\"</p>\n<p>inductive_cases direct_sub_termE[elim!]: \"y ◃⇩1 C x\"<br>\ninductive_cases sub_termE[elim!]: \"y ◃ C x\"</p>\n<p>lemma sub_term_induct_aux[THEN spec, THEN mp, rotated]:<br>\n  assumes [intro]: \"⋀t. (⋀u. u ◃ t ⟹ P u) ⟹ P t\"<br>\n  shows \"∀u. u ◃ t ⟶ P u\"<br>\n  apply (induct t)<br>\n  apply auto<br>\n  done</p>\n<p>lemma sub_term_induct[case_names sub]:<br>\n  assumes IH: \"⋀t. (⋀u. u ◃ t ⟹ P u) ⟹ P t\"<br>\n  shows \"P t\"<br>\n  apply (cases t; hypsubst_thin)<br>\n  apply (rule IH)<br>\n  apply (erule sub_term_induct_aux)<br>\n  by (rule IH)</p>\n<p>end</p>",
        "id": 294672261,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173745
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nOn set-based relations, there is a constant \"measure\", such that the<br>\nproof could be done by showing </p>\n<p>inductive_set direct_sub_term :: \"(term × term) set\" where<br>\nleft: \"(t, t $ u) ∈ direct_sub_term \" |<br>\nright: \"(u, t $ u) ∈ direct_sub_term\" |<br>\nabs: \"(t, (Λ t)) ∈ direct_sub_term\"</p>\n<p>abbreviation sub_term :: \"(term × term) set\" where<br>\n\"sub_term ≡ direct_sub_term⇧+\"</p>\n<p>lemma wf: \"wf direct_sub_term\"<br>\n  apply (rule wf_subset)<br>\n  apply (rule wf_measure[where f=size])<br>\n  by (auto elim: direct_sub_term.cases)</p>\n<p>lemmas induct_rl = wf_induct[OF wf_trancl[OF wf]]<br>\n  (* Produces (⋀x. ∀y. (y, x) ∈ sub_term ⟶ ?P y ⟹ ?P x) ⟹ ?P ?a *)</p>\n<p>On predicates, the concept of \"measure\" seems to be missing in the<br>\nlibrary, but there is also a wfP_trancl-lemma in the library, which<br>\ncould simplify Andrei's proof a bit.</p>",
        "id": 294672289,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173751
    }
]