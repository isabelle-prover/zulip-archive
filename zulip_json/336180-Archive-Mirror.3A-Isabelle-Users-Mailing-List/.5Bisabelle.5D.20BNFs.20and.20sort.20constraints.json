[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear BNF developers,</p>\n<p>I'm looking for some information about the way the BNF package treats<br>\nsort constraints. This is going to be a footnote in a paper, maybe a bit<br>\nmore.</p>\n<p>Consider this typedef:</p>\n<p>typedef (overloaded) 'a::plus id = \"UNIV :: 'a set\" by auto</p>\n<p>(Please ignore for a moment that the sort constraint is entirely<br>\nunnecessary here.)</p>\n<p>Observation #1:</p>\n<p>\"copy_bnf 'a id\" fails with tactic errors and a THM exception. Should<br>\nthis produce a better error message?</p>\n<p>Observation #2:</p>\n<p>\"copy_bnf (dead 'a :: plus) id\" gives a better error message, namely \"No<br>\nlive variables\".</p>\n<p>At this point I'm assuming that \"copy_bnf\" can't deal with sort constraints.</p>\n<p>So let's try with raw \"bnf\".</p>\n<p>Observation #3:</p>\n<p>Some setup:</p>\n<p>lift_definition map_id :: \"('a::plus ⇒ 'b::plus) ⇒ 'a id ⇒ 'b id\" is \"λf<br>\nx. f x\" .<br>\nlift_definition set_id :: \"'a::plus id ⇒ 'a set\" is \"λx. {x}\" .</p>\n<p>bnf \"'a::plus id\"<br>\nbnf \"'a id\"</p>\n<p>Both produce identical proof obligations. First subgoal after applying<br>\n\"rule ext\":</p>\n<ol>\n<li>⋀x. map_id id x = id x</li>\n</ol>\n<p>\"x\" does not have any sort constraints. So it is not provable (?).</p>\n<p>Observation #4:</p>\n<p>I can define</p>\n<p>datatype ('a::plus) id = Id 'a</p>\n<p>just fine, but \"map_id\" does not have any sort constraints (whereas \"Id\"<br>\nand \"case_id\" have them).</p>\n<p>Could somebody shed some light onto how this works? I looked at some of<br>\nthe papers but didn't find anything.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294732905,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188733
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nHi Lars,</p>\n<blockquote>\n<p>Could somebody shed some light onto how this works? I looked at some of<br>\nthe papers but didn't find anything.</p>\n</blockquote>\n<p>I can answer Observation 4, which involves some of my code.</p>\n<p>BNF type variables may not have sort constraints. \"map_id\" is part of the BNF structure, so it accordingly doesn't have sort constraints. More high-level theorems and constants are declared with the sort constraints. To overgeneralize a bit, Dmitriy's low-level BNF code doesn't like sort constraints, whereas my higher-level \"(co)datatype\" code copes with them to the extent possible. In the code, you'll see this by grepping for \"unsorted_As\" in \"bnf_fp_def_sugar.ML\".</p>\n<p>I presume there's no deep reason for not supporting syntactic type class constraints in BNFs. It would complicate the composition operators for sure, and in a bunch of places we'd have to discharge 0 goals arising from syntactic type class instantiations. If you're up for putting in the effort, we won't stop you.</p>\n<p>Incidentally, what is the motivation for your example? Is your application related to item 5 in the \"Known Bugs and Limitations\" of the \"datatypes\" document?</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294732919,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188739
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Jasmin,</p>\n<blockquote>\n<p>BNF type variables may not have sort constraints. \"map_id\" is part of<br>\nthe BNF structure, so it accordingly doesn't have sort constraints.<br>\nMore high-level theorems and constants are declared with the sort<br>\nconstraints. To overgeneralize a bit, Dmitriy's low-level BNF code<br>\ndoesn't like sort constraints, whereas my higher-level \"(co)datatype\"<br>\ncode copes with them to the extent possible. In the code, you'll see<br>\nthis by grepping for \"unsorted_As\" in \"bnf_fp_def_sugar.ML\".</p>\n</blockquote>\n<p>that sounds basically like what I guessed from my observations. Thanks <br>\nfor the clarification!</p>\n<blockquote>\n<p>Incidentally, what is the motivation for your example? Is your<br>\napplication related to item 5 in the \"Known Bugs and Limitations\" of<br>\nthe \"datatypes\" document?</p>\n</blockquote>\n<p>I don't intend to use this in any way. I'm merely trying to \"tie up <br>\nloose ends\":</p>\n<p>My dictionary construction will just ignore sort constraints from data <br>\nconstructors, and I was trying to figure out to what extent they might <br>\nbe introduced in datatypes, e.g. by having a constrained BNF through <br>\nwhich recursion occurs.</p>\n<p>The \"meta-theorem\" I am aiming for is that by dropping the sort <br>\nconstraints you'll still end up with exactly the same datatype; i.e., I <br>\nwant to argue that not supporting constraints in constructors is not a <br>\nproblem because I can always ask the user to remove the constraints.</p>\n<p>NB, because you mentioned \"limitation 5\": The fact that the overloaded 0 <br>\nis a constructor for \"nat\" is the bane of my existence. It messes with <br>\nso many things and it is surprising that it works at all :-)</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294732945,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188745
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>let me refine Jasmin's anwer.</p>\n<p><em>Live</em> BNF type variables may not have sort constraints.</p>\n<p>This is inherent: live variables indicate where we may recurse through. Imagine a BNF \"'a :: foo F\" with 'a live. Then we should be able to define:</p>\n<p>datatype X = N | C \"X F\"</p>\n<p>which in turn would require X to be an instance foo. Suddenly the datatype command would need to instantiate arbitrary type classes simultaneously with defining the type, which sounds quite ambitious even for syntactic type classes (e.g., one might get the \"wrong\" instance).</p>\n<p>In contrast, <em>dead</em> BNF type variables may carry sort constraints. Consider e.g.,</p>\n<p>datatype (dead 'a::plus, 'b) X = N 'b | C 'a \"('a, 'b) X\"<br>\nterm map_X</p>\n<p>where the first type argument of X in map_X has the sort constraint.</p>\n<p>Sometimes one can even use the sort constraints on dead type variables to prove that some type is a BNF. My favorite example that uses this trick are arity-correct first-order terms:</p>\n<p>declare [[typedef_overloaded]]</p>\n<p>class arity =<br>\n fixes arity :: \"'a ⇒ nat\"</p>\n<p>instantiation unit :: arity begin<br>\ndefinition arity_unit :: \"unit ⇒ nat\" where \"arity_unit x = 0\"<br>\ninstance proof qed</p>\n<p>typedef (overloaded) ('c :: arity, 'ty) comb (infixr \"$\" 65) =<br>\n \"{(s :: 'c, Ts :: 'ty list). arity s = length Ts}\"<br>\n morphisms Rep_comb comb<br>\n by (auto intro!: exI[of _ \"replicate _ undefined\"])</p>\n<p>lift_bnf (no_warn_wits) (dead 'c :: arity, 'ty) comb by auto</p>\n<p>setup_lifting type_definition_comb</p>\n<p>lift_definition \"fun\" :: \"'c :: arity $ 'ty ⇒ 'c\" is fst .<br>\nlift_definition \"args\" :: \"'c :: arity $ 'ty ⇒ 'ty list\" is snd .</p>\n<p>datatype ('x, 'c :: arity) \"term\" = Var 'x | App  \"'c $ ('x, 'c) term\"</p>\n<p>Dmitriy</p>\n<p>PS: For sure, copy_bnf should emit a proper failure instead of the tactic failure in \"observation 1\". I will have a look eventually.</p>",
        "id": 294733006,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188769
    }
]