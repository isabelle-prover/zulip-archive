[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nDe-facto it was an Isabelle/ML users workshop, with a little bit of <br>\noutlook towards Isabelle/Scala (but in 2009 the latter was still very <br>\nthin). Maybe we should make some \"Isabelle proof development workshop\" <br>\nnext time.</p>\n<p>Anyway, I've just returned from one that was very interesting: mostly <br>\nFrench Coq users learning about HOL specifications and Isar proofs.  See <br>\nalso <a href=\"http://www.lri.fr/~wenzel/Isabelle_Orleans_2012/\">http://www.lri.fr/~wenzel/Isabelle_Orleans_2012/</a> and feel free to <br>\nre-use material you might want for your own courses next time.</p>\n<p>Makarius</p>",
        "id": 294224297,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899160
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi, </p>\n<p>my understanding of conversions is, that \"conv ct\" either throws an<br>\nexception or returns a theorem of the form \"ct == ...\". Here is a<br>\nminimal example where rewr_conv actually returns a theorem that does not<br>\nsatisfy this condition, and thus, a subsequent then_conv fails<br>\nunexpectedly.</p>\n<p>definition \"I x \\&lt;equiv&gt; x\"<br>\ndefinition \"A f x \\&lt;equiv&gt; f x\"</p>\n<p>ML_val {*<br>\n  let<br>\n    open Conv</p>\n<p>val cv1 = fun_conv (rewr_conv @{thm I_def}) <br>\n    val cv2 = rewr_conv (@{thm A_def[symmetric]})<br>\n  in<br>\n    (cv1 then_conv cv2) @{cterm \"I (\\&lt;lambda&gt;s::bool. s) True\"}<br>\n  end</p>\n<p>(*<br>\n*** exception THM 0 raised (line 835 of \"thm.ML\"):<br>\n*** transitive: middle term<br>\n*** I (\\&lt;lambda&gt;s\\&lt;Colon&gt;bool. s) True \\&lt;equiv&gt; True<br>\n*** True \\&lt;equiv&gt; A (\\&lt;lambda&gt;s\\&lt;Colon&gt;bool. s) True<br>\n  *)</p>\n<p>*}</p>\n<p>The reason is, that the term after applying cv1 is not beta-reduced, and<br>\ncv2 returns a theorem with a beta-reduced left-hand side. The exception<br>\nis thrown when then_conv tries to put the two theorems together.</p>\n<p>The issue can be observed when instrumenting then_conv, e.g. as attached<br>\nto the end of this mail.</p>\n<p>I consider this a bug, because it is nowhere documented that the user of<br>\nconversions has to take care of beta-normalization manually. My proposal<br>\nfor solution is as follows:<br>\n  What is the status of beta-equality within Isabelle?<br>\n    Alternative 1) beta-equivalent terms are considered equal: then_conv<br>\nshould just work modulo beta-equivalence<br>\n    Alternative 2) They are not considered equal on this low-level:<br>\nrewr_conv should be forced to return an equal term.</p>\n<p>Anyway, if none of the two alternatives is appropriate, the rules for<br>\ncomposing conversions should be CLEANLY documented.</p>\n<p>Regards,<br>\n  Peter</p>\n<hr>\n<p>ML_val {*<br>\nlet<br>\n  open Conv</p>\n<p>(* Instrumenting then_conv to make the reason for the error visible:<br>\n*)<br>\n  fun (cv1 then_conv cv2) ct =<br>\n    let<br>\n      val eq1 = cv1 ct;<br>\n      val eq2 = cv2 (Thm.rhs_of eq1);<br>\n    in<br>\n      if Thm.is_reflexive eq1 then eq2<br>\n      else if Thm.is_reflexive eq2 then eq1<br>\n      else (<br>\n        tracing (\"RHS1: \"^PolyML.makestring (Thm.rhs_of eq1 |&gt;<br>\nterm_of));<br>\n        tracing (\"LHS2: \"^PolyML.makestring (Thm.lhs_of eq2 |&gt;<br>\nterm_of));<br>\n        Thm.transitive eq1 eq2<br>\n      )<br>\n    end;<br>\nin<br>\n  let<br>\n    val cv1 = fun_conv (rewr_conv @{thm I_def}) <br>\n    val cv2 = rewr_conv (@{thm A_def[symmetric]})<br>\n  in<br>\n    (cv1 then_conv cv2) @{cterm \"I (\\&lt;lambda&gt;s::bool. s) True\"}<br>\n  end<br>\nend</p>\n<p>(* TRACE:</p>\n<p>RHS1: Abs (\"s\", \"bool\", Bound 0) $ Const (\"HOL.True\", \"bool\")</p>\n<p>LHS2: Const (\"HOL.True\", \"bool\")<br>\n*)</p>\n<p>*}</p>",
        "id": 294225345,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899695
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 22 Oct 2012, Peter Lammich wrote:</p>\n<blockquote>\n<p>my understanding of conversions is, that \"conv ct\" either throws an <br>\nexception or returns a theorem of the form \"ct == ...\". Here is a <br>\nminimal example where rewr_conv actually returns a theorem that does not <br>\nsatisfy this condition, and thus, a subsequent then_conv fails <br>\nunexpectedly.</p>\n<p>definition \"I x \\&lt;equiv&gt; x\"<br>\ndefinition \"A f x \\&lt;equiv&gt; f x\"</p>\n<p>ML_val {*<br>\n let<br>\n   open Conv</p>\n<p>val cv1 = fun_conv (rewr_conv @{thm I_def})<br>\n   val cv2 = rewr_conv (@{thm A_def[symmetric]})<br>\n in<br>\n   (cv1 then_conv cv2) @{cterm \"I (\\&lt;lambda&gt;s::bool. s) True\"}<br>\n end</p>\n<p>(*<br>\n*** exception THM 0 raised (line 835 of \"thm.ML\"):<br>\n*** transitive: middle term<br>\n*** I (\\&lt;lambda&gt;s\\&lt;Colon&gt;bool. s) True \\&lt;equiv&gt; True<br>\n*** True \\&lt;equiv&gt; A (\\&lt;lambda&gt;s\\&lt;Colon&gt;bool. s) True<br>\n *)</p>\n<p>*}</p>\n<p>The reason is, that the term after applying cv1 is not beta-reduced, and<br>\ncv2 returns a theorem with a beta-reduced left-hand side. The exception<br>\nis thrown when then_conv tries to put the two theorems together.</p>\n</blockquote>\n<p>(ML <em>raises</em> exceptions, other languages like Java <em>throw</em> them.)</p>\n<p>What happens here is that cv2 gets a cterm with beta redex, but it is <br>\nrather well-known in Isabelle practice, that this can cause all kinds of <br>\ntroubles.  So one could argue that the behaviour is correctly undefined.</p>\n<blockquote>\n<p>I consider this a bug, because it is nowhere documented that the user of <br>\nconversions has to take care of beta-normalization manually.</p>\n</blockquote>\n<p>Despite tons of manuals, which are often hard to keep in overview anyway, <br>\nthe real documentaion is the ML source:</p>\n<p>(* single rewrite step, cf. REWR_CONV in HOL *)</p>\n<p>fun rewr_conv rule ct =<br>\n   let<br>\n     val rule1 = Thm.incr_indexes (#maxidx (Thm.rep_cterm ct) + 1) rule;<br>\n     val lhs = Thm.lhs_of rule1;<br>\n     val rule2 = Thm.rename_boundvars (Thm.term_of lhs) (Thm.term_of ct) rule1;<br>\n   in<br>\n     Drule.instantiate_normalize (Thm.match (lhs, ct)) rule2<br>\n       handle Pattern.MATCH =&gt; raise CTERM (\"rewr_conv\", [lhs, ct])<br>\n   end;</p>\n<p>This says excplitly that your resulting rule instance will be produced by <br>\nDrule.instantiate_normalize, and thus in beta-normal form.  So you loose <br>\nif you try to make a plain then_conv step based on something that is not <br>\nin beta-normal form.</p>\n<p>If this is good or bad, or a \"bug\" is a completely different question. <br>\nFurther judgement would require careful studies how a change would impact <br>\nexisting application, and potential interaction with the Simplifier and <br>\nthe rule composition mechanisms (RS etc.)  I can't say much on the spot, <br>\napart from quoting the well-known \"Mahabharata\" software development <br>\nprinciple: \"Dharma eva hato hanti / Dharmo rakshati rakshitah\". In other <br>\nwords, it might be easier to change your expectation about what the system <br>\nshould do for you.</p>\n<p>Seriously: I am now working a lot with Scala on the JVM platform.  What <br>\nthese industrial-strength guys usually do is to declare odd behaviour <br>\nofficial rather quickly, because too many applications depend on it.</p>\n<blockquote>\n<p>What is the status of beta-equality within Isabelle?<br>\n   Alternative 1) beta-equivalent terms are considered equal: then_conv<br>\nshould just work modulo beta-equivalence<br>\n   Alternative 2) They are not considered equal on this low-level:<br>\nrewr_conv should be forced to return an equal term.</p>\n</blockquote>\n<ul>\n<li>\n<p>The system knows alpha, beta, eta conversion.</p>\n</li>\n<li>\n<p>Some layers use alpha (kernel).</p>\n</li>\n<li>\n<p>Some layers use alpha + beta + eta (simplifier, resolution) but<br>\n   normalize in different directions.</p>\n</li>\n<li>\n<p>Insisting too much in one way or the other causes trouble.</p>\n</li>\n<li>\n<p>It is possible not to insist too much.</p>\n</li>\n<li>\n<p>What is your concrete application anyway?</p>\n<p>Makarius</p>\n</li>\n</ul>",
        "id": 294225351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899701
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThis module was written long ago for a specific, internal purpose and was never intended for general use, so it's hard to say what is a bug and what isn't. The beauty of conversions is that they are highly modular, so you can write your own primitives that do exactly what you want.</p>\n<p>Larry Paulson</p>",
        "id": 294225365,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899707
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nAn additional beauty of the Isabelle library is how often you get to <br>\nbuild your own primitives because none of the existing ones do what you <br>\nwould expect.</p>\n<p>I have this sitting around somewhere:</p>\n<p>fun fix_conv conv ct = let<br>\n     val thm = conv ct<br>\n     val eq = Logic.mk_equals (term_of ct, term_of ct) |&gt; head_of<br>\n   in if (term_of (Thm.lhs_of thm) aconv term_of ct)<br>\n     then thm<br>\n     else thm RS trivial<br>\n       (Thm.mk_binop (cterm_of (theory_of_cterm ct) eq) ct (Thm.rhs_of <br>\nthm)) end</p>\n<p>That fixes the problem with rewr_conv, so fix_conv Conv.rewr_conv does <br>\nwhat you would expect Conv.rewr_conv to do.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294225372,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899713
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nWe should not interpret Peter's original post as the question, \"how<br>\ncan I make my concrete application work\"; rather, we should treat it<br>\nas a proposal to refine the behavior of the Isabelle conversion<br>\nlibrary.</p>\n<p>Peter neatly stated the behavior that we all expect of conversions:</p>\n<p>On Mon, 22 Oct 2012, Peter Lammich wrote:</p>\n<blockquote>\n<p>my understanding of conversions is, that \"conv ct\" either throws an<br>\nexception or returns a theorem of the form \"ct == ...\".</p>\n</blockquote>\n<p>The current situation is this: Conv.rewr_conv only satisfies this<br>\nproperty if a side-condition is met, namely that the input cterm must<br>\nbe already in beta-normal form.</p>\n<p>The proposal is to modify rewr_conv to remove the side-condition: It<br>\nshould satisfy the basic property also for non-beta-normal cterms. On<br>\nbeta-normal cterms, rewr_conv should behave exactly as it did before.<br>\n(Thomas's fix_conv would be one possible implementation of this<br>\nproposal.)</p>\n<p>So far, I haven't seen any good arguments against this change.</p>\n<p>On Mon, Oct 22, 2012 at 9:27 PM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>What happens here is that cv2 gets a cterm with beta redex, but it is rather<br>\nwell-known in Isabelle practice, that this can cause all kinds of troubles.<br>\nSo one could argue that the behaviour is correctly undefined.</p>\n</blockquote>\n<p>Makarius argues that it is reasonable to have low expectations of the<br>\nconversion library. Yes, but this is no argument against making the<br>\nlibrary exceed his low expectations of it.</p>\n<blockquote>\n<p>Despite tons of manuals, which are often hard to keep in overview anyway,<br>\nthe real documentaion is the ML source:</p>\n</blockquote>\n<p>Reading the ML source, we also find various low-level conversions in thm.ML:</p>\n<p>val beta_conversion: bool -&gt; conv<br>\n  val eta_conversion: conv<br>\n  val eta_long_conversion: conv</p>\n<p>Their existence clearly indicates that conversions are not intended to<br>\nwork modulo beta- or eta-equivalence.</p>\n<blockquote>\n<p>If this is good or bad, or a \"bug\" is a completely different question.<br>\nFurther judgement would require careful studies how a change would impact<br>\nexisting application, and potential interaction with the Simplifier and the<br>\nrule composition mechanisms (RS etc.)<br>\n[...]<br>\nSeriously: I am now working a lot with Scala on the JVM platform.  What<br>\nthese industrial-strength guys usually do is to declare odd behaviour<br>\nofficial rather quickly, because too many applications depend on it.</p>\n</blockquote>\n<p>A quick search reveals that very little code within Isabelle depends<br>\non rewr_conv; in particular, the simplifier and rule composition<br>\nmechanisms like RS predate the conversion library.</p>\n<p>Furthermore, remember that we are only proposing to change the<br>\nbehavior of rewr_conv on <em>non-beta-normal</em> input. I seriously doubt<br>\nthat any existing code actually depends on the current behavior of<br>\nrewr_conv on non-beta-normal cterms. In any case, it is easy enough to<br>\nrun the usual test suite before committing a change.</p>\n<blockquote>\n<ul>\n<li>\n<p>The system knows alpha, beta, eta conversion.</p>\n</li>\n<li>\n<p>Some layers use alpha (kernel).</p>\n</li>\n<li>\n<p>Some layers use alpha + beta + eta (simplifier, resolution) but<br>\n  normalize in different directions.</p>\n</li>\n</ul>\n</blockquote>\n<p>As I pointed out above, the existence of Thm.{beta,eta}_conversion<br>\nmakes it clear that conversions do not use beta + eta.</p>\n<blockquote>\n<ul>\n<li>\n<p>Insisting too much in one way or the other causes trouble.</p>\n</li>\n<li>\n<p>It is possible not to insist too much.</p>\n</li>\n<li>\n<p>What is your concrete application anyway?</p>\n</li>\n</ul>\n</blockquote>\n<p>This is good advice for <em>users</em> of Isabelle/ML libraries: Don't expect<br>\ntoo much. For <em>developers</em> of Isabelle/ML libraries, this is no<br>\nargument against making improvements.</p>\n<p>On 23/10/12 07:40, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>This module was written long ago for a specific, internal purpose and was<br>\nnever intended for general use, so it's hard to say what is a bug and what<br>\nisn't. The beauty of conversions is that they are highly modular, so you can<br>\nwrite your own primitives that do exactly what you want.</p>\n</blockquote>\n<p>If the module was never intended for general use, then we shouldn't be<br>\nso worried about breaking user code by modifying the module. I would<br>\nread this as an argument in favor of updating the conversion library<br>\n(or at least an argument against <em>not</em> updating it).</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294225380,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899720
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>I consider this a bug, because it is nowhere documented that the user of <br>\nconversions has to take care of beta-normalization manually.</p>\n</blockquote>\n<p>Despite tons of manuals, which are often hard to keep in overview anyway, <br>\nthe real documentaion is the ML source:</p>\n<p>(* single rewrite step, cf. REWR_CONV in HOL *)</p>\n<p>fun rewr_conv rule ct =<br>\n   let<br>\n     val rule1 = Thm.incr_indexes (#maxidx (Thm.rep_cterm ct) + 1) rule;<br>\n     val lhs = Thm.lhs_of rule1;<br>\n     val rule2 = Thm.rename_boundvars (Thm.term_of lhs) (Thm.term_of ct) rule1;<br>\n   in<br>\n     Drule.instantiate_normalize (Thm.match (lhs, ct)) rule2<br>\n       handle Pattern.MATCH =&gt; raise CTERM (\"rewr_conv\", [lhs, ct])<br>\n   end;</p>\n<p>This says excplitly that your resulting rule instance will be produced by <br>\nDrule.instantiate_normalize, and thus in beta-normal form.  So you loose <br>\nif you try to make a plain then_conv step based on something that is not <br>\nin beta-normal form.</p>\n</blockquote>\n<p>So what normalizations does instantiate_normalize do (beta?, eta?,<br>\nbeta-eta?, how deep?). Looking at the source code does not really help<br>\nhere:</p>\n<p>fun instantiate_normalize instpair th =<br>\n  Thm.adjust_maxidx_thm ~1 (Thm.instantiate instpair th COMP_INCR<br>\nasm_rl);</p>\n<p>Even if looking 4 levels deep from here (COMP_INCR -&gt; COMP -&gt; compose -&gt;<br>\nbicompose), one finds no comment mentioning normal forms, nor any<br>\nfunction whose name would suggest any particular kind of normalization.</p>\n<blockquote>\n<p>If this is good or bad, or a \"bug\" is a completely different question. <br>\nFurther judgement would require careful studies how a change would impact <br>\nexisting application, and potential interaction with the Simplifier and <br>\nthe rule composition mechanisms (RS etc.)  I can't say much on the spot, <br>\napart from quoting the well-known \"Mahabharata\" software development <br>\nprinciple: \"Dharma eva hato hanti / Dharmo rakshati rakshitah\". In other <br>\nwords, it might be easier to change your expectation about what the system <br>\nshould do for you.</p>\n</blockquote>\n<p>As Brian already mentioned: If there is an easy change that does not<br>\nbreak too much, and makes the system arguably more elegant, why not just<br>\napplying it?</p>\n<blockquote>\n<ul>\n<li>Insisting too much in one way or the other causes trouble.</li>\n</ul>\n</blockquote>\n<p>As my example shows, I have to insist on one way or the other (either<br>\nusing something like fix-conv, or manually inserting beta_conv after all<br>\nconversions that may produce beta-redexes). </p>\n<blockquote>\n<ul>\n<li>\n<p>It is possible not to insist too much.</p>\n</li>\n<li>\n<p>What is your concrete application anyway?<br>\nSomething similar as the minimal example. I need to do some<br>\ncontrollable rewriting in a term, replacing patterns like <br>\n\"fun_upd f k (Some v)\" by \"op_map_update$k$v$f\" if certain<br>\nside-conditions on f, k, and v are met (infixr $ is a custom constant<br>\ndefined as f$x == f x). Another pattern was <br>\n\"insert\" by \"\\lambda x s. op_insert$x$s\", which caused the beta-redex,<br>\nas I first replaced it by \"\\lambda x s. op_insert x s\", and then wanted<br>\nto insert the $.<br>\nIn my concrete case, it was easy to fix by applying beta_conv at the<br>\nright places, however, I wondered why conversions do not meet the simple<br>\nexpectation that most of us seem to have (see Brian's mail). Indeed, it<br>\nrequired me more than an hour to track down why my code did not work, as<br>\nI implicitly assumed that the standard conversions behave as expected,<br>\nsuch that I searched at the wrong places first.</p>\n</li>\n</ul>\n</blockquote>",
        "id": 294225426,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899725
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nPeter's point is that the <em>given</em> conversions are not as modular as one may wish<br>\nthem to be and that it would be nice to improve on that. And as Thomas pointed<br>\nout, improvement in user space is suboptimal.</p>\n<p>Tobias</p>",
        "id": 294225433,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899731
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nPeter has already mentioned it but I want to do it more explicitly <br>\nbecause this thread clearly shows how the canonical \"look at the ML <br>\nsource\"-approach fails.<br>\nML source is not the real documentation!</p>\n<p>How should I know that instantiate_normalize do beta-normalization?</p>\n<p>By looking at this?</p>\n<p>fun bicompose_aux flatten match (state, (stpairs, Bs, Bi, C), lifted)<br>\n                         (eres_flg, orule, nsubgoal) =<br>\n  let val Thm (sder, {maxidx=smax, shyps=sshyps, hyps=shyps, ...}) = state<br>\n      and Thm (rder, {maxidx=rmax, shyps=rshyps, hyps=rhyps,<br>\n              tpairs=rtpairs, prop=rprop,...}) = orule<br>\n          (<em>How many hyps to skip over during normalization</em>)<br>\n      and nlift = Logic.count_prems (strip_all_body Bi) + (if eres_flg <br>\nthen ~1 else 0)<br>\n      val thy = Theory.deref (merge_thys2 state orule);<br>\n      (<strong> Add new theorem with prop = '[| Bs; As |] ==&gt; C' to thq </strong>)<br>\n      fun addth A (As, oldAs, rder', n) ((env, tpairs), thq) =<br>\n        let val normt = Envir.norm_term env;<br>\n            (<em>perform minimal copying here by examining env</em>)<br>\n            val (ntpairs, normp) =<br>\n              if Envir.is_empty env then (tpairs, (Bs @ As, C))<br>\n              else<br>\n              let val ntps = map (pairself normt) tpairs<br>\n              in if Envir.above env smax then<br>\n                   (<em>no assignments in state; normalize the rule only</em>)<br>\n                   if lifted<br>\n                   then (ntps, (Bs @ map (norm_term_skip env nlift) As, C))<br>\n                   else (ntps, (Bs @ map normt As, C))<br>\n                 else if match then raise COMPOSE<br>\n                 else (<em>normalize the new rule fully</em>)<br>\n                   (ntps, (map normt (Bs @ As), normt C))<br>\n              end<br>\n            val th =<br>\n              Thm (deriv_rule2<br>\n                    ((if Envir.is_empty env then I<br>\n                      else if Envir.above env smax then<br>\n                        (fn f =&gt; fn der =&gt; f (Proofterm.norm_proof' env <br>\nder))<br>\n                      else<br>\n                        curry op oo (Proofterm.norm_proof' env))<br>\n                     (Proofterm.bicompose_proof flatten Bs oldAs As A n <br>\n(nlift+1))) rder' sder,<br>\n                 {tags = [],<br>\n                  maxidx = Envir.maxidx_of env,<br>\n                  shyps = Envir.insert_sorts env (Sorts.union rshyps <br>\nsshyps),<br>\n                  hyps = union_hyps rhyps shyps,<br>\n                  tpairs = ntpairs,<br>\n                  prop = Logic.list_implies normp,<br>\n                  thy_ref = Theory.check_thy thy})<br>\n         in  Seq.cons th thq  end  handle COMPOSE =&gt; thq;<br>\n      val (rAs,B) = Logic.strip_prems(nsubgoal, [], rprop)<br>\n        handle TERM _ =&gt; raise THM(\"bicompose: rule\", 0, [orule,state]);<br>\n      (<em>Modify assumptions, deleting n-th if n&gt;0 for e-resolution</em>)<br>\n      fun newAs(As0, n, dpairs, tpairs) =<br>\n        let val (As1, rder') =<br>\n          if not lifted then (As0, rder)<br>\n          else<br>\n            let val rename = rename_bvars dpairs tpairs B As0<br>\n            in (map (rename strip_apply) As0,<br>\n              deriv_rule1 (Proofterm.map_proof_terms (rename K) I) rder)<br>\n            end;<br>\n        in (map (if flatten then (Logic.flatten_params n) else I) As1, <br>\nAs1, rder', n)<br>\n           handle TERM _ =&gt;<br>\n           raise THM(\"bicompose: 1st premise\", 0, [orule])<br>\n        end;<br>\n      val env = Envir.empty(Int.max(rmax,smax));<br>\n      val BBi = if lifted then strip_assums2(B,Bi) else (B,Bi);<br>\n      val dpairs = BBi :: (rtpairs@stpairs);</p>\n<p>(<em>elim-resolution: try each assumption in turn</em>)<br>\n      fun eres [] = raise THM (\"bicompose: no premises\", 0, [orule, state])<br>\n        | eres (A1 :: As) =<br>\n            let<br>\n              val A = SOME A1;<br>\n              val (close, asms, concl) = Logic.assum_problems (nlift + <br>\n1, A1);<br>\n              val concl' = close concl;<br>\n              fun tryasms [] _ = Seq.empty<br>\n                | tryasms (asm :: rest) n =<br>\n                    if Term.could_unify (asm, concl) then<br>\n                      let val asm' = close asm in<br>\n                        (case Seq.pull (Unify.unifiers (thy, env, (asm', <br>\nconcl') :: dpairs)) of<br>\n                          NONE =&gt; tryasms rest (n + 1)<br>\n                        | cell as SOME ((_, tpairs), _) =&gt;<br>\n                            Seq.it_right (addth A (newAs (As, n, [BBi, <br>\n(concl', asm')], tpairs)))<br>\n                              (Seq.make (fn () =&gt; cell),<br>\n                               Seq.make (fn () =&gt; Seq.pull (tryasms rest <br>\n(n + 1)))))<br>\n                      end<br>\n                    else tryasms rest (n + 1);<br>\n            in tryasms asms 1 end;</p>\n<p>(<em>ordinary resolution</em>)<br>\n      fun res () =<br>\n        (case Seq.pull (Unify.unifiers (thy, env, dpairs)) of<br>\n          NONE =&gt; Seq.empty<br>\n        | cell as SOME ((_, tpairs), _) =&gt;<br>\n            Seq.it_right (addth NONE (newAs (rev rAs, 0, [BBi], tpairs)))<br>\n              (Seq.make (fn () =&gt; cell), Seq.empty));<br>\n  in<br>\n    if eres_flg then eres (rev rAs) else res ()<br>\n  end;</p>",
        "id": 294225446,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899738
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI think you refer to an even older version of the module, before my time <br>\nworking on the Isabelle code base.  The current src/Pure/conv.ML is a <br>\nreconstruction from historic sources and the HOL counterparts that was <br>\ninitiated by Amine Chaieb some years ago, and where I engaged myself as <br>\nwell in doing research on the old LCF/HOL sources.  The we tried to push <br>\nit forward in time into contemporary Isabelle use.</p>\n<p>Makarius</p>",
        "id": 294225459,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899743
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou should explain what \"_ RS trivial\" does.  It is the conventional way <br>\nto let Larry's rule composition calculus do its normalization for you.</p>\n<p>Thinking in terms of \"broken\" and \"fixed\" is unwise.  Which is actually my <br>\nmain complaint on this thread.</p>\n<p>Makarius</p>",
        "id": 294225484,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899756
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThis is the essence: rewr_conv only satisfies</p>\n<p>\"A conversion is any function that maps a term t to a theorem |-t==u.\"<br>\nLCP, 1983</p>\n<p>up to beta-equivalence. Since conversions are low-level proof methods which are<br>\nsensitive to the precise term structure, this is a wart that causes<br>\nnon-modularity. This non-modularity only shows up (to refine Brian's analysis)<br>\nif the lhs of the rewrite rule has a free variable F in an applied position: F<br>\nt. This does not happen very often, but if it does, rewr_conv should still<br>\nbehave nicely. It should do a non-normalizing instantiation followed by a<br>\nbeta-normalization.</p>\n<p>Tobias</p>",
        "id": 294225492,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899762
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 23 Oct 2012, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Mon, 22 Oct 2012, Peter Lammich wrote:</p>\n<blockquote>\n<p>my understanding of conversions is, that \"conv ct\" either throws an<br>\nexception or returns a theorem of the form \"ct == ...\".</p>\n</blockquote>\n<p>The current situation is this: Conv.rewr_conv only satisfies this<br>\nproperty if a side-condition is met, namely that the input cterm must<br>\nbe already in beta-normal form.</p>\n<p>The proposal is to modify rewr_conv to remove the side-condition: It<br>\nshould satisfy the basic property also for non-beta-normal cterms. On<br>\nbeta-normal cterms, rewr_conv should behave exactly as it did before.<br>\n(Thomas's fix_conv would be one possible implementation of this<br>\nproposal.)</p>\n</blockquote>\n<p>This is the point where one would have to start thinking and looking <br>\ncarefully.  So far the attitudes towards the system were far too crude, to <br>\neven think of it.</p>\n<blockquote>\n<p>Makarius argues that it is reasonable to have low expectations of the <br>\nconversion library. Yes, but this is no argument against making the <br>\nlibrary exceed his low expectations of it.</p>\n</blockquote>\n<p>Misunderstanding again.  Wrong attitudes towards \"good or bad\", \"wrong or <br>\nright\", \"broken or fixed\" means.  The incident is rather trivial here, but <br>\nthe general principles are very important.</p>\n<blockquote>\n<p>Reading the ML source, we also find various low-level conversions in thm.ML:</p>\n<p>val beta_conversion: bool -&gt; conv<br>\n val eta_conversion: conv<br>\n val eta_long_conversion: conv</p>\n<p>Their existence clearly indicates that conversions are not intended to<br>\nwork modulo beta- or eta-equivalence.</p>\n</blockquote>\n<p>Here you also need to look at the history.  When the type conv was <br>\nre-introduced after a long time, I merely tried to re-integrate many <br>\nexisting functions into the framework, without assuming too much semantics <br>\nbehind it.</p>\n<blockquote>\n<p>Furthermore, remember that we are only proposing to change the behavior <br>\nof rewr_conv on <em>non-beta-normal</em> input. I seriously doubt that any <br>\nexisting code actually depends on the current behavior of rewr_conv on <br>\nnon-beta-normal cterms. In any case, it is easy enough to run the usual <br>\ntest suite before committing a change.</p>\n</blockquote>\n<p>It will be probably not too hard, but such things have to be done with the <br>\nproper attitude and care.  The \"bug\" fraction on this thread lacks that.</p>\n<blockquote>\n<p>This is good advice for <em>users</em> of Isabelle/ML libraries: Don't expect <br>\ntoo much.</p>\n</blockquote>\n<p>I never said said.  You should get your expectations right and realistic. <br>\nThe code base is generally not so bad, but after &gt; 25 years it defines it <br>\nown rules.  So as long as you are standing outside somewhere and <br>\npretending to know how to \"fix\" it, it wont work for you.</p>\n<p>Makarius</p>",
        "id": 294225497,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899768
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou also need to include its history.</p>\n<p>It is a matter of long practice and endurance to make sense out of all <br>\nthat.  It is important to make a serious start, by giving up what you <br>\nthink about it in the first impulse.</p>\n<p>Makarius</p>",
        "id": 294225509,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899774
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAlternatively one could do the normalization before on the input term. <br>\nEmpirically, higher-order matching can produce surprises if applied to <br>\nterms with beta redexes, it normally is never used like that in the <br>\nexisting tools.  So it is better not to give non-normal stuff to the match <br>\noperation.</p>\n<p>Again, I don't expect too many fundamental problems in this rather small <br>\nincident, but one has to approach it with the proper mindset about how the <br>\nIsabelle code base (and its history) works.</p>\n<p>(Next time I will tell a story how an efficient and fully verified <br>\nmerge-sort function included in the core sources caused several days of <br>\nworries.)</p>\n<p>Makarius</p>",
        "id": 294225519,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899780
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI just tried my suggestion and it seems to break HOL. I'll investigate more.</p>\n<p>Tobias</p>",
        "id": 294225533,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899787
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nLarry should be able to tell you.</p>\n<p>It is again the same technique to let rule composition perform some <br>\nnormalization.  The above function goes back to Stefan Berghofer, IIRC. <br>\nI merely changed its name Drule.instantiate ~&gt; Drule.instantiate_normalize <br>\nrecently, to make it a bit more explicit what was meant here.</p>\n<p>Makarius</p>",
        "id": 294225540,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899793
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI would have given it a &gt; 50% chance of not breaking immediately, since <br>\nrewrite_conv is relatively new back in Isabelle/HOL.</p>\n<p>Anyway, whoever thinks something needs to be changed in a certain way, the <br>\nfirst move is to make some empirical studies to test the hypothesis <br>\nagainst historical reality.</p>\n<p>Makarius</p>",
        "id": 294225548,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899798
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMy guess (I don't have time to study the code) is that this will perform beta-eta normalisation.</p>\n<p>As a historical remark, I'm quite attached to conversions, which were the topic of my very first journal article:</p>\n<p>L. C. Paulson. <br>\nA higher-order implementation of rewriting. Science of Computer Programming 3 (1983), 119–149.</p>\n<p>They made a lot of sense in the context of LCF and HOL, where users routinely wrote code as part of the verification process. Although I included this code in Isabelle, it didn't have a central role and I thought it'd got deleted. Obviously it would be sensible to correct any deficiencies or omissions. But I'm still intrigued regarding what sort of application you could have for them.</p>\n<p>Larry</p>",
        "id": 294225559,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899805
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThey found again some uses in relatively small-scale tinkering with <br>\nsub-term structure, things that would be hard with the Simplifier engine <br>\nand its builtin strategies.  This is not so much compared to the<br>\nancient times and past glory of LCF conversions.</p>\n<p>What I found quite interesting was the presentation by Stefan Berghofer of <br>\nIsabelle conversions at the 2009 isabelle-dev workshop at Munich.  He <br>\nfirst showed how to make a simplifier with a few conversions and <br>\nconversion combinators, then showed how to make it a little faster using a <br>\n\"Boultonized\" version of the same (like \"Q\" conversions in HOL), and then <br>\nshowed how to make it really fast using the Isabelle Simplifier techniques <br>\nthat came after conversions so many years ago.</p>\n<p>Makarius</p>",
        "id": 294225568,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899811
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nI can't speak for Peter, but I am currently using conversions in a few places.</p>\n<p>My main application is for writing simprocs: See e.g.<br>\nHOL/Tools/group_cancel.ML or nat_arith.ML. Rewriting these<br>\ncancellation simprocs to use conversions made the code significantly<br>\nshorter, simpler, more efficient, and more reliable. There used to be<br>\na few simprocs that would sometimes return an equation whose<br>\nleft-hand-side did not match the input term; using conversions ensures<br>\nthat this will not happen.</p>\n<p>I would definitely recommend conversions to anyone thinking about<br>\nwriting a simproc.</p>\n<p>I am also using conversions inside the transfer package, to do some<br>\npreprocessing steps. For this purpose, conversions are more<br>\npredictable and more customizable than using the simplifier.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294225589,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899823
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThat application is very interesting! And one can argue that a simproc is a very similar concept as a conversion, anyway.</p>\n<p>Larry</p>",
        "id": 294225599,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899829
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThe problem comes from my matching code that eta-expands even if it does not<br>\nneed to. Substituting such a matcher back into the pattern creates new<br>\nbeta-redexes that were not there beforehand. This is more subtle than expected.</p>\n<p>In contrast, it seems that Thomas' solution (fix_conv) does the job, but it is a<br>\nbit on the brutal side. I'll see if I can come up with something less brutal.</p>\n<p>Tobias</p>",
        "id": 294225647,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899842
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>fun fix_conv conv ct = let<br>\n    val thm = conv ct<br>\n    val eq = Logic.mk_equals (term_of ct, term_of ct) |&gt;  head_of<br>\n  in if (term_of (Thm.lhs_of thm) aconv term_of ct)<br>\n    then thm<br>\n    else thm RS trivial<br>\n      (Thm.mk_binop (cterm_of (theory_of_cterm ct) eq) ct (Thm.rhs_of thm))<br>\nend<br>\nYou should explain what \"_ RS trivial\" does.  It is the conventional way<br>\nto let Larry's rule composition calculus do its normalization for you.<br>\nAdmittedly this is not beautiful code. I just happened to have it.</p>\n</blockquote>\n</blockquote>\n<p>What \"thm RS trivial P\" does is constructs the trivial theorem \"P ==&gt; P\" <br>\nand then discharges its assumption using thm.</p>\n<p>The point here is to specify the conclusion we want (Thm.mk_binop ...) <br>\nwith the original cterm on the left hand side, construct a theorem with <br>\nthat conclusion, and then \"prove\" it by resolution with a theorem we <br>\nhave (which is alpha-beta-eta- equivalent). Yes, that is a big hammer to <br>\napply, but it won't be applied all that often. The major cost here is <br>\nchecking whether it is needed all the time.</p>\n<blockquote>\n<p>Thinking in terms of \"broken\" and \"fixed\" is unwise.  Which is actually my<br>\nmain complaint on this thread.</p>\n</blockquote>\n<p>Some things are neither broken nor fixed, they are just surprising, but <br>\nsurprising for good reason. This is broken. As others have pointed out, <br>\nthere is a clear contract for convs to follow so that then_conv can <br>\nchain them using Thm.transitive. This contract is not followed by rewr_conv.</p>\n<p>This is one solution. An alternative would be to broaden the contract by <br>\nhaving then_conv catch the exception from Thm.transitive and switch to a <br>\nmore general mechanism (possibly by doing the above). This might create <br>\nproblems for some other consumers of convs, which I have not taken time <br>\nto investigate.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294225672,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899848
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDoes anybody know whether slides/thy-files of this talk are still <br>\naround? (I did not manage to find a website for any of the Isabelle <br>\nUsers Workshops besides 2012.) - cheers chris</p>",
        "id": 294225691,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899868
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Christian,</p>\n<p>the website still has the theory files.</p>\n<p><a href=\"http://isabelle.in.tum.de/nominal/activities/tphols09/idw.html\">http://isabelle.in.tum.de/nominal/activities/tphols09/idw.html</a></p>\n<p>Andreas</p>",
        "id": 294225699,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899872
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nThanks!</p>\n<p>No wonder that searching for \"Isabelle Users Workshop\" did not give the <br>\ndesired result ;)... I forgot that in 2009 it was a \"Developers Workshop\".</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294225705,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899878
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:christian.urban@kcl.ac.uk\">christian.urban@kcl.ac.uk</a>&gt;<br>\nI do not have the slides of this talk it seems, but <br>\nthe theory Stefan presented in 2009 is here:</p>\n<p><a href=\"http://isabelle.in.tum.de/nominal/activities/tphols09/IDW/Conversions.thy\">http://isabelle.in.tum.de/nominal/activities/tphols09/IDW/Conversions.thy</a></p>\n<p>The workshops in 2009 and 2010 have their webpage here:</p>\n<p><a href=\"http://isabelle.in.tum.de/nominal/activities/tphols09/idw.html\">http://isabelle.in.tum.de/nominal/activities/tphols09/idw.html</a><br>\n<a href=\"http://isabelle.in.tum.de/nominal/activities/idw10/idw.html\">http://isabelle.in.tum.de/nominal/activities/idw10/idw.html</a></p>\n<p>Christian</p>",
        "id": 294225728,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899895
    },
    {
        "content": "<p>From: Mathieu Giorgino &lt;<a href=\"mailto:Mathieu.Giorgino@irit.fr\">Mathieu.Giorgino@irit.fr</a>&gt;<br>\nIt seems most of the links on this page are broken. An easy fix is to <br>\nreplace all occurences of<br>\n   \"<a href=\"http://tphols.in.tum.de\">tphols.in.tum.de</a>\"<br>\nby<br>\n   \"<a href=\"http://isabelle.in.tum.de/nominal/activities/tphols09/\">isabelle.in.tum.de/nominal/activities/tphols09/</a>\"<br>\nin the html file.</p>\n<p>Thanks for the link.</p>\n<ul>\n<li>Mathieu</li>\n</ul>",
        "id": 294225792,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899925
    }
]