[
    {
        "content": "<p>From: Daniel Horne &lt;<a href=\"mailto:d.horne@danielhorne.co.uk\">d.horne@danielhorne.co.uk</a>&gt;<br>\nI have the following function:</p>\n<p>function (domintros) index:: \"int ⇒ int\" where<br>\n\"index a = (if (a&lt;0) then (index (a+5)) else (a mod 5))\"</p>\n<p>and have been trying to prove the result is always &gt;=0 and &lt;= 4. Ran <br>\ninto a bit of trouble and after some investigation found that it was <br>\nbecause Isabelle couldn't automatically prove termination..</p>\n<p>The intention is to prove that this condition is true for all ints, so I <br>\nneed to prove \"∀ a. index_dom a\".</p>\n<p>Print_theorems gives the following:</p>\n<p>index.cases: (⋀a. ?x = a ⟹ ?P) ⟹ ?P<br>\n   index.domintros: (?a &lt; 0 ⟹ index_dom (?a + 5)) ⟹ index_dom ?a<br>\n   index.pelims: index ?x = ?y ⟹ index_dom ?x ⟹ (⋀a. ?x = a ⟹ ?y = (if a <br>\n&lt; 0 then index (a + 5) else a mod 5) ⟹ index_dom a ⟹ ?P) ⟹ ?P<br>\n   index.pinduct: index_dom ?a0.0 ⟹ (⋀a. index_dom a ⟹ (a &lt; 0 ⟹ ?P (a + <br>\n5)) ⟹ ?P a) ⟹ ?P ?a0.0<br>\n   index.psimps: index_dom ?a ⟹ index ?a = (if ?a &lt; 0 then index (?a + <br>\n5) else ?a mod 5)</p>\n<p>with which I've managed to prove this inductive rule:</p>\n<p>lemma ddda: \"index_dom a ⟹ index_dom (a-5)\"<br>\napply(induction a rule:index.pinduct)<br>\napply(simp add:index.domintros)<br>\ndone</p>\n<p>Which is well and good for negative numbers as long as I have an <br>\nappropriate base case. I'd been thinking of doing<br>\n1: index_dom (a) /\\ a&lt;5 /\\ a&gt;=0 as a base case. Can do for each <br>\nindividual value of a, as it's a small enough range<br>\n2: index_dom a ⟹ index_dom (a-5) to extend over negative numbers<br>\n3: a &gt;= 0  ==&gt; index_dom a ==&gt; index_dom a+5  to extend over positives <br>\nusing cyclic nature of mod operation.</p>\n<p>The problem is that I don't see any way in the theorems that mention <br>\nindex_dom that I could establish index_dom 0, for example.<br>\nI can assume it and succeed in calculating the result - which would be <br>\nsufficient to prove to a human that it terminates for that value, but I <br>\ndon't know how I'd mechanise that reasoning.</p>\n<p>Any clues?</p>",
        "id": 294671512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173527
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Daniel,</p>\n<p>if you use the \"function\" command, Isabelle doesn't even attempt to<br>\nprove termination. Only the \"fun\" command performs automatic proofs<br>\n(which fail in this case, however).</p>\n<p>If your function is total (it is), you can use the \"termination\" command<br>\nto establish a termination proof.</p>\n<p>Here's how it works for your example:</p>\n<p>termination index<br>\n  by (relation \"measure (λn. nat (- n))\") auto</p>\n<p>As you can see, you just have to specify a suitable measure function<br>\nunder which the function arguments decrease on each call. The rest is<br>\nautomatic.</p>\n<p>You can then use the total induction rule for your lemmas:</p>\n<p>lemma \"index n ≥ 0\"<br>\n  by (induct n rule: index.induct) auto</p>\n<p>lemma \"index n ≤ 4\"<br>\n  by (induct n rule: index.induct) auto</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294671562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173543
    },
    {
        "content": "<p>From: Daniel Horne &lt;<a href=\"mailto:d.horne@danielhorne.co.uk\">d.horne@danielhorne.co.uk</a>&gt;<br>\nOn 03/04/2016 22:16, Lars Hupel wrote:</p>\n<blockquote>\n<p>Hi Daniel,</p>\n<blockquote>\n<p>and have been trying to prove the result is always &gt;=0 and &lt;= 4. Ran<br>\ninto a bit of trouble and after some investigation found that it was<br>\nbecause Isabelle couldn't automatically prove termination..<br>\nif you use the \"function\" command, Isabelle doesn't even attempt to<br>\nprove termination. Only the \"fun\" command performs automatic proofs<br>\n(which fail in this case, however).</p>\n</blockquote>\n</blockquote>\n<p>Yes. I initially tried defining it as fun, but switched it over to <br>\nfunction when one of the automatic proofs failed, and had auto do the <br>\ncompleteness proof like this:</p>\n<p>function (domintros) index:: \"int ⇒ int\" where<br>\n\"index a = (if (a&lt;0) then (index (a+5)) else (a mod 5))\"<br>\napply(auto)<br>\ndone</p>\n<blockquote>\n<p>If your function is total (it is), you can use the \"termination\" command<br>\nto establish a termination proof.</p>\n<p>Here's how it works for your example:</p>\n<p>termination index<br>\n   by (relation \"measure (λn. nat (- n))\") auto</p>\n<p>As you can see, you just have to specify a suitable measure function<br>\nunder which the function arguments decrease on each call. The rest is<br>\nautomatic.</p>\n</blockquote>\n<p>Ah. I did see in the \"Defining Recursive Functions in Isabelle/HOL\" <br>\nmanual that fun is equivalent to function with \"termination by <br>\nlexicographic_order\".<br>\nSomehow I completely missed the section \"the relation method\" section <br>\nfurther down the same page.</p>\n<p>Thanks for the assist.</p>",
        "id": 294671576,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661173549
    }
]