[
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nHi all,</p>\n<p>I must miss something obvious, I can't get a simple sample class  <br>\ninstatiation working, and that's many hours I try to guess, but failed,  <br>\nthus this message.</p>\n<p>Here is the sample:</p>\n<p>class cls1 =<br>\n     fixes<br>\n       cls1_x :: \"'a\" and<br>\n       cls1_f :: \"'a ⇒ 'a\" and<br>\n       cls1_g :: \"nat ⇒ 'a\"<br>\n     assumes<br>\n       cls1_fg_prop: \"(cls1_f (cls1_g 0)) = (cls1_g 0)\"</p>\n<p>fun f :: \"int ⇒ int\" where<br>\n     \"f i = i\"</p>\n<p>fun g :: \"nat ⇒ int\" where<br>\n     \"g n = (int n)\"</p>\n<p>instantiation int :: cls1<br>\n     begin<br>\n       definition df: \"cls1_f n = f n\"<br>\n       definition dg: \"cls1_g n = g n\"<br>\n       instance proof<br>\n         have \"cls1_f 0 = f 0\" unfolding df by simp -- #1<br>\n         have \"cls1_g 0 = g 0\" unfolding dg by simp -- #2<br>\n         have \"f (g 0) = g 0\" by simp               -- #3<br>\n         then show \"cls1_f (cls1_g 0) = cls1_g 0\"   -- #4<br>\n           unfolding df and dg by simp<br>\n       qed<br>\n     end</p>\n<p>Cls1 is just for testing, it does not pretend to be useful in any way. F  <br>\nand g, are supposed to play the role of cls1_f and cls1_g, respectively.</p>\n<p>In the instantiation, putting the cursor on Show, which is underlined in  <br>\nred, Isabelle insist on complaining:</p>\n<p>Local statement will fail to refine any pending goal<br>\n   Failed attempt to solve goal by exported rule:<br>\n   cls1_f (cls1_g 0) = cls1_g 0</p>\n<p>However, putting the cursor right after Instance Proof, Isabelle says:</p>\n<p>proof (state): step 1<br>\n   goal (1 subgoal):</p>\n<p>1. cls1_f (cls1_g 0) = cls1_g 0</p>\n<p>… which is exactly what's in the expression to be shown.</p>\n<p>Line #1 and #2 are for testing, after this failure, and both are OK.  <br>\nHovering the cursor above cls1_f and cls1_g in line #1 and #2, says they  <br>\nare cls1_class.cls1_f and cls1_class.cls1_g, which makes Isabelle's  <br>\ncomplains even less clear to me.</p>\n<p>Line #3 is OK too.</p>\n<p>So what's wrong? Must be obvious, but honestly, I completely miss it.</p>\n<p>P.S. By the way, what's the name of the default proof method Isabelle uses  <br>\nin Instance Proof? Does not seems to be unfold_classes (as there is an  <br>\nunfold_locales method) or any similar names I've tested.</p>",
        "id": 294220316,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897124
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nI haven't looked at your problem in detail, but this sounds like a type problem. Try \"using [show_types]\" before the failing proof step. \"show_sorts\" and \"show_consts\" might also be useful.</p>",
        "id": 294220331,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897130
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nAm 14.08.2012 um 05:34 schrieb Lars Noschinski:</p>\n<blockquote>\n<p>I haven't looked at your problem in detail, but this sounds like a type problem. Try \"using [show_types]\"</p>\n</blockquote>\n<p>Or rather \"using [[show_types]]\", with two layers of brackets.</p>\n<blockquote>\n<p>before the failing proof step. \"show_sorts\" and \"show_consts\" might also be useful.</p>\n</blockquote>\n<p>Jasmin</p>",
        "id": 294220353,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897140
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nAt least, I've found an answer to this one. That's intro_classes; thus,  <br>\n“instance proof” do the same as “instance proof intro_classes”.</p>",
        "id": 294220361,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897142
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nAfter Lars Noschinski's suggestion, I added (already posted, but never  <br>\nshown up in the thread, so I'm re‑posting it)</p>\n<p>declare [[show_types]]<br>\n   declare [[show_consts]]<br>\n   declare [[show_sorts]]</p>\n<p>… before the Instantiation</p>\n<p>Moving the cursor after “instance proof”, the Output pan of  <br>\njEdit/Isabelle, shows this:</p>\n<p>proof (state): step 1</p>\n<p>goal (1 subgoal):</p>\n<p>1. cls1_f (cls1_g (0∷nat)) = cls1_g (0∷nat)<br>\n   constants:<br>\n     TYPE(int) :: int itself<br>\n     cls1_class :: int itself ⇒ prop<br>\n     prop :: prop ⇒ prop<br>\n     0∷nat :: nat<br>\n     cls1_g :: nat ⇒ int<br>\n     cls1_f :: int ⇒ int<br>\n     op = :: int ⇒ int ⇒ bool<br>\n     Trueprop :: bool ⇒ prop<br>\n     op ⟹ :: prop ⇒ prop ⇒ prop</p>\n<p>Types seems correctly applied/inferred. I attempted to replace</p>\n<p>then show \"(cls1_f (cls1_g 0)) = (cls1_g 0)\"</p>\n<p>with</p>\n<p>then show \"(cls1_f (cls1_g (0::nat))) = (cls1_g (0::nat))\"</p>\n<p>… but this solved nothing.</p>\n<p>At this stage, as I have no idea, I wonder if it's me who is missing  <br>\nsomething, or else if my assumption that this should be OK is right, and  <br>\nso, that this would be an error from Isabelle. This would not be proving  <br>\nsomething which is wrong, but failing to allow to prove something which is  <br>\nright; which in turn is not the worst, but annoying. That doubts are  <br>\nblocking for me (I can't avoid thinking about this topic).</p>",
        "id": 294220424,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897180
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Yannick,</p>\n<p>without having really tried, I guess that the type of these definitions<br>\nis too general; try something like \"cls1_f n = (f n :: int)\".</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/iYCW6eUlwY2ct6UZfSh_zxl5/signature.asc\">signature.asc</a></p>",
        "id": 294220433,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897186
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nFlorian, thanks for your reply,</p>\n<p>I tried to add type annotations everywhere I could, which gave:</p>\n<p>class cls1 =<br>\n     fixes<br>\n       cls1_x :: \"'a\" and<br>\n       cls1_f :: \"'a ⇒ 'a\" and<br>\n       cls1_g :: \"nat ⇒ 'a\"<br>\n     assumes<br>\n       cls1_fg_prop: \"(cls1_f (cls1_g (0::nat))) = (cls1_g (0::nat))\"</p>\n<p>fun f :: \"int ⇒ int\" where<br>\n     \"f (i::int) = (i::int)\"</p>\n<p>fun g :: \"nat ⇒ int\" where<br>\n     \"g (n::nat) = (int (n::nat))\"</p>\n<p>declare [[show_types]] -- Testing<br>\n   declare [[show_consts]] -- Testing<br>\n   declare [[show_sorts]] -- Testing</p>\n<p>instantiation int :: cls1<br>\n     begin<br>\n       definition df: \"(cls1_f (i::int)) = (f (i::int))\"<br>\n       definition dg: \"(cls1_g (n::nat)) = (g (n::nat))\"<br>\n       instance proof<br>\n         have \"(cls1_f (0::int)) = (f (0::int))\" using df by simp -- Testing<br>\n         have \"(cls1_g (0::nat)) = (g (0::nat))\" using dg by simp -- Testing<br>\n         have \"(f (g (0::nat))) = (g (0::nat))\" by simp<br>\n         then show \"(cls1_f (cls1_g (0::nat))) = (cls1_g (0::nat))\"<br>\n           using df and dg by simp<br>\n       qed<br>\n     end</p>\n<p>The result is the same. May be that's finally a bug, or else don't see why  <br>\nit can't unify the expression to be shown with the pending goal.</p>\n<p>By the way, is there a recommended way to submit bug reports (if that's  <br>\nreally one) about Isabelle?</p>\n<p>I wondered if this could be due to the absence of a universal  <br>\nquantification in the pending goal, but Isabelle is OK with this in other  <br>\ncontext, and there's no variables to Fix here. I will try something  <br>\nsimilar with a Locale, as a Class has similarities with a Locale, to see  <br>\nif it ends with the same.</p>",
        "id": 294220440,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897191
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<p>class cls1 =<br>\n    fixes<br>\n      cls1_x :: \"'a\" and<br>\n      cls1_f :: \"'a ⇒ 'a\" and<br>\n      cls1_g :: \"nat ⇒ 'a\"<br>\n    assumes<br>\n      cls1_fg_prop: \"(cls1_f (cls1_g (0::nat))) = (cls1_g (0::nat))\"</p>\n</blockquote>\n<p>…</p>\n<blockquote>\n<p>then show \"(cls1_f (cls1_g (0::nat))) = (cls1_g (0::nat))\"<br>\n          using df and dg by simp</p>\n</blockquote>\n<p>you don't have a type constraint on the <em>result</em> type here, e.g.</p>\n<blockquote>\n<p>then show \"(cls1_f (cls1_g (0::nat)) :: int) = (cls1_g (0::nat))\"</p>\n</blockquote>\n<p>If this does not help, please boil down your example to something<br>\nsimpler until it work, and post the last non-working version.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/CzALn8uGhM-d2CJVsxyxmui9/signature.asc\">signature.asc</a></p>",
        "id": 294220458,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897198
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 16 Aug 2012, Yannick Duchêne (Hibou57) wrote:</p>\n<blockquote>\n<p>I tried to add type annotations everywhere I could, which gave:</p>\n<p>class cls1 =<br>\n  fixes<br>\n    cls1_x :: \"'a\" and<br>\n    cls1_f :: \"'a ⇒ 'a\" and<br>\n    cls1_g :: \"nat ⇒ 'a\"<br>\n  assumes<br>\n    cls1_fg_prop: \"(cls1_f (cls1_g (0::nat))) = (cls1_g (0::nat))\"</p>\n<p>fun f :: \"int ⇒ int\" where<br>\n  \"f (i::int) = (i::int)\"</p>\n<p>fun g :: \"nat ⇒ int\" where<br>\n  \"g (n::nat) = (int (n::nat))\"</p>\n<p>declare [[show_types]] -- Testing<br>\ndeclare [[show_consts]] -- Testing<br>\ndeclare [[show_sorts]] -- Testing</p>\n<p>instantiation int :: cls1<br>\n  begin<br>\n    definition df: \"(cls1_f (i::int)) = (f (i::int))\"<br>\n    definition dg: \"(cls1_g (n::nat)) = (g (n::nat))\"<br>\n    instance proof<br>\n      have \"(cls1_f (0::int)) = (f (0::int))\" using df by simp -- Testing<br>\n      have \"(cls1_g (0::nat)) = (g (0::nat))\" using dg by simp -- Testing<br>\n      have \"(f (g (0::nat))) = (g (0::nat))\" by simp<br>\n      then show \"(cls1_f (cls1_g (0::nat))) = (cls1_g (0::nat))\"<br>\n        using df and dg by simp<br>\n    qed<br>\n  end</p>\n</blockquote>\n<p>Try this one:</p>\n<p>show \"(cls1_f (cls1_g (0::nat) :: int)) = (cls1_g (0::nat))\"<br>\n                                  ^^^^^^</p>\n<p>The Prover IDE helped to expose the type of cls1_f and cls2_g in the text, <br>\nusing CTRL/COMMAND hover.</p>\n<blockquote>\n<p>The result is the same. May be that's finally a bug, or else don't see <br>\nwhy it can't unify the expression to be shown with the pending goal.</p>\n<p>By the way, is there a recommended way to submit bug reports (if that's <br>\nreally one) about Isabelle?</p>\n</blockquote>\n<p>As a rule of thumb there are hardly any bugs, only unexpected behaviour,<br>\nand that is best discussed on the mailing list.</p>\n<p>Makarius</p>",
        "id": 294220504,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897204
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nOn Thu, 16 Aug 2012 16:44:43 +0200, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>Try this one:</p>\n<p>show \"(cls1_f (cls1_g (0::nat) :: int)) = (cls1_g (0::nat))\"<br>\n                                  ^^^^^^</p>\n</blockquote>\n<p>And yes, this solves the unification! (Makarius is a genius :-P )</p>\n<p>Any of this three ones do:</p>\n<p>then show \"(cls1_f (cls1_g 0)) = ((cls1_g 0) :: int)\"<br>\n   then show \"((cls1_f (cls1_g 0)) :: int) = (cls1_g 0)\"<br>\n   then show \"(cls1_f ((cls1_g 0) :: int)) = (cls1_g 0)\"</p>\n<blockquote>\n<p>The Prover IDE helped to expose the type of cls1_f and cls2_g in the  <br>\ntext,<br>\nusing CTRL/COMMAND hover.</p>\n</blockquote>\n<p>I often use it, but well, missed that. I did it again, and for cls1_f it  <br>\nsays “'a::cls1 ⇒ 'a::cls1”, and for cls1_f it says “'nat ⇒ 'a::cls1”.</p>\n<p>So the type inference did not applied (while I was so much sure it did),  <br>\nand I have to understand why. What could have been the way to solve the  <br>\ntype inference as I expected it to be? I see only one:</p>\n<p>definition df: \"(cls1_f i) = (f i)\"<br>\n   definition dg: \"(cls1_g n) = (g n)\"</p>\n<p>May be because that's just definitions? So I tried to replace the above  <br>\nwith:</p>\n<p>fun cls1_f :: \"int ⇒ int\"<br>\n     where \"(cls1_f i) = (f i)\"</p>\n<p>fun cls1_g :: \"nat ⇒ int\"<br>\n     where \"(cls1_g n) = (g n)\"</p>\n<p>Now ctrl/command + mouse‑hovering on cls1_f and cls1_g in:</p>\n<p>then show \"(cls1_f (cls1_g 0)) = (cls1_g 0)\" by simp</p>\n<p>… shows type inference applies in this case, as it says “int ⇒ int” and  <br>\n“nat ⇒ int”. But unification does not works for another reason; it now  <br>\ncomplains instead:</p>\n<p>Local statement will fail to refine any pending goal<br>\n   Failed attempt to solve goal by exported rule:<br>\n     local.cls1_f (local.cls1_g (0∷nat)) = local.cls1_g (0∷nat)</p>\n<p>while before it was complaining:</p>\n<p>Local statement will fail to refine any pending goal<br>\n   Failed attempt to solve goal by exported rule:<br>\n     cls1_f (cls1_g (0∷nat)) = cls1_g (0∷nat)</p>\n<p>The difference is the “local.” prefix.</p>\n<p>Another attempt with:</p>\n<p>abbreviation \"(cls1_f i) ≡ (f i)\"<br>\n   abbreviation \"(cls1_g n) ≡ (g n)\"</p>\n<p>… ends into the same similar issue as with Definition, but even worst, as  <br>\nadding a type annotation does not solve anything now.</p>\n<p>Conclusion so far: Definition (and Abbreviation) do not provides hints for  <br>\ntype inference, even if the Definition provides type annotations, and  <br>\nusing fun/function, which provides hints for type inference, is not OK, as  <br>\nthis create a plain new entity (of the same name, but still another  <br>\nentity), which cannot be unified with the expected one.</p>\n<p>These are things to keep in mind about Isar.</p>\n<p>Now to come back to an above comment I've made, which is “I often use it,  <br>\nbut well, missed that” (talking about ctrl/command + mouse‑hovering over  <br>\nan item), may be an idea: show_types/consts/sorts, could still display  <br>\nsomething even when there is error to display. The Output pan did not show  <br>\nanything, as there was an error message instead, which replaced report  <br>\nmessages. If both have been displayed together, may be I won't have missed  <br>\nit, as what's always displayed is less likely to be missed as I did.</p>\n<blockquote>\n<blockquote>\n<p>By the way, is there a recommended way to submit bug reports (if that's<br>\nreally one) about Isabelle?</p>\n</blockquote>\n<p>As a rule of thumb there are hardly any bugs, only unexpected behaviour,</p>\n</blockquote>\n<p>I believe the same (thus my doubts), and surprised myself to come to the  <br>\nbug hypothesis.</p>\n<blockquote>\n<p>and that is best discussed on the mailing list.</p>\n</blockquote>\n<p>OK</p>",
        "id": 294220521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897210
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 16 Aug 2012, Yannick Duchêne (Hibou57) wrote:</p>\n<blockquote>\n<blockquote>\n<p>Try this one:</p>\n<p>show \"(cls1_f (cls1_g (0::nat) :: int)) = (cls1_g (0::nat))\"<br>\n                                 ^^^^^^<br>\nAny of this three ones do:</p>\n</blockquote>\n<p>then show \"(cls1_f (cls1_g 0)) = ((cls1_g 0) :: int)\"<br>\nthen show \"((cls1_f (cls1_g 0)) :: int) = (cls1_g 0)\"<br>\nthen show \"(cls1_f ((cls1_g 0) :: int)) = (cls1_g 0)\"</p>\n</blockquote>\n<p>Yes.  In this context the argument type of cls1_g is always nat, so there <br>\nis no need for that constraint.</p>\n<blockquote>\n<blockquote>\n<p>The Prover IDE helped to expose the type of cls1_f and cls2_g in the text,<br>\nusing CTRL/COMMAND hover.</p>\n</blockquote>\n<p>I often use it, but well, missed that. I did it again, and for cls1_f it says <br>\n“'a::cls1 ⇒ 'a::cls1”, and for cls1_f it says “'nat ⇒ 'a::cls1”.</p>\n<p>So the type inference did not applied (while I was so much sure it did), <br>\nand I have to understand why.</p>\n</blockquote>\n<p>There is something like a standard portfolio of getting confused with type <br>\ninference.  I will try harder next time to provide some visual clues in <br>\nthe Prover IDE markup about such situations, so that errors are easier to <br>\nunderstand, or avoided in the first place.</p>\n<blockquote>\n<p>What could have been the way to solve the type <br>\ninference as I expected it to be? I see only one:</p>\n<p>definition df: \"(cls1_f i) = (f i)\"<br>\ndefinition dg: \"(cls1_g n) = (g n)\"</p>\n<p>May be because that's just definitions? So I tried to replace the above with:</p>\n<p>fun cls1_f :: \"int ⇒ int\"<br>\n  where \"(cls1_f i) = (f i)\"</p>\n<p>fun cls1_g :: \"nat ⇒ int\"<br>\n  where \"(cls1_g n) = (g n)\"</p>\n</blockquote>\n<p>There is no fundamental difference of 'definition' vs. 'fun', only an <br>\naccidental one: 'definition' (like 'abbreviation') allows a short form <br>\nwhere the defined entity is not explicitly bound but just mentioned in the <br>\nproper place on the LHS of the defining equation.  You can call that <br>\nfeature a bug, but I usually use neither of these meaningless words.  It <br>\nis just a convenience to write short definitions, even if it can lead to <br>\nslightly different situations concerning type-inference.</p>\n<p>So what happens here is that</p>\n<p>definition df: \"(cls1_f i) = (f i)\"</p>\n<p>refers to a particilar instance of the overloaded constant cls1_f for type <br>\nint, because that is special in the instantiation context.  The context is <br>\nalso responsible for exchanging that instance internally with a formal <br>\nparameter cls1_f_int that needs to be defined here for the sake of the <br>\ninstantiation.  The 'print_context' command right after 'instantiation' <br>\ntells that story in extreme brevity.</p>\n<p>So here is the fun version of your example:</p>\n<p>class cls1 =<br>\n   fixes cls1_x :: \"'a\"<br>\n     and cls1_f :: \"'a ⇒ 'a\"<br>\n     and cls1_g :: \"nat ⇒ 'a\"<br>\n   assumes cls1_fg_prop: \"(cls1_f (cls1_g 0)) = (cls1_g 0)\"</p>\n<p>fun f :: \"int ⇒ int\" where \"f i = i\"<br>\nfun g :: \"nat ⇒ int\" where \"g n = (int n)\"</p>\n<p>instantiation int :: cls1<br>\nbegin</p>\n<p>print_context</p>\n<p>fun cls1_f_int where \"cls1_f_int n = f n\"<br>\nfun cls1_g_int where \"cls1_g_int n = g n\"</p>\n<p>instance<br>\nproof<br>\n   have \"cls1_f 0 = f 0\" by simp<br>\n   have \"cls1_g 0 = g 0\" by simp<br>\n   have \"f (g 0) = g 0\" by simp<br>\n   then show \"cls1_f (cls1_g 0 :: int) = cls1_g 0\" by simp<br>\nqed</p>\n<p>end</p>\n<p>Another obvious improvement of the Prover IDE would be to turn the <br>\nprint_context above into some kind of template for the consecutive text.</p>\n<blockquote>\n<p>Now ctrl/command + mouse‑hovering on cls1_f and cls1_g in:</p>\n<p>then show \"(cls1_f (cls1_g 0)) = (cls1_g 0)\" by simp</p>\n<p>… shows type inference applies in this case, as it says “int ⇒ int” and “nat <br>\n⇒ int”. But unification does not works for another reason; it now complains <br>\ninstead:</p>\n<p>Local statement will fail to refine any pending goal<br>\nFailed attempt to solve goal by exported rule:<br>\n  local.cls1_f (local.cls1_g (0∷nat)) = local.cls1_g (0∷nat)</p>\n<p>while before it was complaining:</p>\n<p>Local statement will fail to refine any pending goal<br>\nFailed attempt to solve goal by exported rule:<br>\n  cls1_f (cls1_g (0∷nat)) = cls1_g (0∷nat)</p>\n<p>The difference is the “local.” prefix.</p>\n</blockquote>\n<p>You've just fallen on you nose by defining unrelated cls1_f and cls2_g. <br>\nSee the fun clauses above, with cls1_f_int and cls2_g_int.</p>\n<blockquote>\n<p>Another attempt with:</p>\n<p>abbreviation \"(cls1_f i) ≡ (f i)\"<br>\nabbreviation \"(cls1_g n) ≡ (g n)\"</p>\n<p>… ends into the same similar issue as with Definition, but even worst, <br>\nas adding a type annotation does not solve anything now.</p>\n</blockquote>\n<p>Another trap here.  This is how it works:</p>\n<p>abbreviation (input) f :: \"int ⇒ int\" where \"f i ≡ i\"<br>\nabbreviation (input) g :: \"nat ⇒ int\" where \"g n ≡ (int n)\"</p>\n<p>Abbreviations try to be smart folding back by default, but the first line <br>\ncan do that indefinitely, so an attempt to print something integer will <br>\nloop later on.</p>\n<p>Makarius</p>",
        "id": 294220536,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897222
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is just an area that is not fully covered by the Prover IDE markup <br>\nyet.  Just for Isabelle2012 I managed to get the inferred types into the <br>\nannotations of the source text in the succesful case, which used to be an <br>\nopen problem for many years.  The error case still needs to be refined in <br>\nthat respect, and then everyone will rightly take that for granted, so one <br>\nneeds to move further on to exhibit even more in the theory source.</p>\n<p>Makarius</p>",
        "id": 294220549,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897228
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nThe case is in the practical way solved, but something still holds  <br>\nmysterious things. With or without the “::int” annotation, at the  <br>\nbeginning of the proof, there was this:</p>\n<p>proof (state): step 1</p>\n<p>goal (1 subgoal):</p>\n<p>1. cls1_f (cls1_g (0∷nat)) = cls1_g (0∷nat)<br>\n   constants:<br>\n     […]<br>\n     cls1_g :: nat ⇒ int<br>\n     cls1_f :: int ⇒ int<br>\n     […]</p>\n<p>Types are correctly inferred at the beginning, but later forgotten? That's  <br>\nstrange. I will stay with this for now, but wish to understand it deeper a  <br>\nlater time.</p>",
        "id": 294220563,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897234
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is because there is no formal syntactic relationship between the goal <br>\nstate in the background and the Isar proof body in the foreground that is <br>\nmeant to address it (fix/assume/show clause).  This principle allows to <br>\ngeneralize what you are drafting in the proof text on the spot, without <br>\nhaving your nose directly on the goal.</p>\n<p>Makarius</p>",
        "id": 294220576,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897241
    }
]