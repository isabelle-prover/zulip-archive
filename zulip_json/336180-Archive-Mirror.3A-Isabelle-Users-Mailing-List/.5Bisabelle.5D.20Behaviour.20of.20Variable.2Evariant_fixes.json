[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear list,</p>\n<p>consider this snippet:</p>\n<p>ML{*<br>\n  val constr = (((Binding.empty, @{binding Constr}), []), NoSyn)<br>\n  val datatyp = (([], @{binding test}), NoSyn)</p>\n<p>val lthy = Named_Target.init \"\" @{theory}</p>\n<p>val (x, lthy) = Variable.variant_fixes [\"x\"] lthy</p>\n<p>val lthy =<br>\n    BNF_FP_Def_Sugar.co_datatypes<br>\n      BNF_Util.Least_FP BNF_LFP.construct_lfp<br>\n      ((false, false), [(((datatyp, [constr]), (Binding.empty,<br>\nBinding.empty)), [])]) lthy</p>\n<p>val (x', lthy) = Variable.variant_fixes [\"x\"] lthy<br>\n*}</p>\n<p>The results for x and x' are somewhat unexpected to me:</p>\n<p>val x = [\"x\"]: string list<br>\n  val x' = [\"x\"]: string list</p>\n<p>I expected them to be different. Indeed, they are different when I move<br>\nthe BNF definition to the front, before the calls to <code>variant_fixes</code>.</p>\n<p>In my use case, I'm translating between a foreign AST and Isabelle's<br>\nterm language. This AST contains type and value definitions, but the<br>\nrespective translations do not depend on each other, so they can be done<br>\nin parallel (this is an actual parallelized algorithm -- the definitions<br>\nare presented to the Isabelle system in some unordered way).</p>\n<p>I can't even declare my newly-fixed variables immediately inside the<br>\ncontext, because I don't know their types in advance. (I tried doing<br>\nthat in my above example nonetheless by inserting the line</p>\n<p>val lthy = Variable.declare_term (Free (x, @{typ int})) lthy</p>\n<p>after the first <code>variant_fixes</code>, but that didn't change the outcome at all.)</p>\n<p>Do I need to sequentialize my algorithm?</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294290030,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923141
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nOne more thing: this doesn't happen for other kinds of operations, e.g.<br>\n<code>Function.add_function</code>. Executing</p>\n<p>val fun_config = Function_Common.FunctionConfig<br>\n    {sequential=true, default=NONE, domintros=false, partials=false}<br>\n  fun pat_completeness_auto ctxt =<br>\n    Pat_Completeness.pat_completeness_tac ctxt 1 THEN auto_tac ctxt</p>\n<p>val (_, lthy) = Function.add_function<br>\n    [(@{binding foo}, NONE, NoSyn)]<br>\n    ([(Attrib.empty_binding, @{term \"Trueprop (foo (Suc r) = r)\"})])<br>\n    fun_config pat_completeness_auto lthy</p>\n<p>between two calls of <code>variant_fixes</code> doesn't exhibit this behaviour<br>\n(i.e. fixed variables are preserved). That makes me wonder whether it is<br>\nsome oddity in BNF, or for type definitions in general.</p>",
        "id": 294290475,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923275
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nReviving this old thread, because Dmitriy and Ondrej were asking me<br>\nabout the workaround I found, so I figured I should post it publicly.</p>\n<p>Anyway, it turns out that if the definition of a datatype is carried out<br>\nin a local theory created using Local_Theory.init, the variable names<br>\nare preserved.</p>\n<p>ML{*<br>\n  fun init ctxt = ctxt<br>\n    |&gt; Local_Theory.init (Sign.naming_of @{theory})<br>\n       {define = Generic_Target.define Generic_Target.theory_foundation,<br>\n        notes = Generic_Target.notes Generic_Target.theory_notes,<br>\n        abbrev = Generic_Target.abbrev Generic_Target.theory_abbrev,<br>\n        declaration = K Generic_Target.theory_declaration,<br>\n        subscription = Generic_Target.theory_registration,<br>\n        pretty = K [],<br>\n        exit = Local_Theory.target_of #&gt; Sign.change_end_local}</p>\n<p>val ctxt = @{theory}<br>\n    |&gt; Sign.change_begin<br>\n    |&gt; Proof_Context.init_global</p>\n<p>val (x, ctxt) = Variable.variant_fixes [\"x\"] ctxt<br>\n  val lthy = init ctxt</p>\n<p>val constr = (((Binding.empty, @{binding Constr}), []), NoSyn)<br>\n  val datatyp = (([], @{binding test}), NoSyn)</p>\n<p>val lthy =<br>\n    BNF_FP_Def_Sugar.co_datatypes<br>\n      BNF_Util.Least_FP BNF_LFP.construct_lfp<br>\n      ((false, false), [(((datatyp, [constr]), (Binding.empty,<br>\nBinding.empty)), [])]) lthy</p>\n<p>val ctxt = Local_Theory.exit lthy</p>\n<p>val (x', ctxt) = Variable.variant_fixes [\"x\"] ctxt<br>\n*}</p>\n<p>The only difference to the previous code is that all other operations<br>\napart from datatype definition happens in a regular proof context, not<br>\nin a local theory, and that a local theory is created and exited on the<br>\nspot when a datatype is to be defined.</p>",
        "id": 294322028,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927207
    }
]