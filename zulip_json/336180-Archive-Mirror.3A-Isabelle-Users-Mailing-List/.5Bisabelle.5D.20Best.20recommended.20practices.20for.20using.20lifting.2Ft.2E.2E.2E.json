[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I would like to ask a technical question with regard to the<br>\nbest-recommended practices for using the lifting/transfer capabilities of<br>\nIsabelle/HOL in one particular scenario.</p>\n<p>Suppose there exist 4 distinct types: AS, AT, BQ, BT. The type AS is a<br>\nsubtype of the type AT and the type BQ is a quotient type of the type BT<br>\n(the specific relationships between the pairs “AS and AT” and “BQ and BT”<br>\nare of secondary importance). Furthermore, suppose that the types AS and BQ<br>\nare isomorphic. Suppose, for a certain application, it would be useful to<br>\ntransfer results/definitions from BQ to AS. I would like to understand what<br>\nis the best practice for performing the transfer.</p>\n<p>At the moment, I use the following solution:</p>\n<p>1. I provide functions BQ_of_AS (“representation”) and AS_of_BQ<br>\n   (“abstraction”) that allow for conversion between the types and show that<br>\n   these functions are bijective and are inverses of each other.</p>\n<p>2. I provide all lemmas similar to those that are automatically<br>\n   generated during the definition of a type copy, e.g.  BQ_of_AS_cases,<br>\n   BQ_of_AS_induct, …, type_definition_BQ_AS, etc</p>\n<p>3. I use “setup_lifting type_definition_BQ_AS” to automatically generate<br>\n   further lemmas.</p>\n<p>4. For each pair of functions (of interest) of BQ and AS, I provide<br>\n   transfer rules explicitly.</p>\n<p>This approach seems to work well for my application. However, I have<br>\nconcerns about whether or not this approach is considered to be a good<br>\npractice and whether or not it is optimal for the application. In<br>\nparticular, I would like to ask the following questions:</p>\n<p>1. In step 2 in my solution, is it necessary to provide the lemmas<br>\n   explicitly, i.e. is it possible to, somehow, automate the process of the<br>\n   generation of the lemmas?</p>\n<p>2. In step 3 in my solution, is it considered to be a good practice to<br>\n   use setup_lifting, given that AS was not ‘derived’ from BQ? Could this<br>\n   cause conflicts if setup_lifting has already been used for the type AS in a<br>\n   different context?</p>\n<p>3. In relation to step 4, is it possible to automate the process of<br>\n   transfer further, i.e. beyond proving each transfer relation explicitly,<br>\n   given that there exists a bijective transformation between the types?</p>\n<p>Any other comments with regard to my solution and proposals for better<br>\nalternatives will be appreciated.</p>\n<p>I provide an example that is closely related to my application. In the<br>\nexample, the type AS is the type fmap from HOL-Library, the type AT is the<br>\ntype map from HOL, the type BQ is my own type fmaplist and the type BT is<br>\nthe type alist from HOL-Library. The subsections that are named &lt;Step N&gt; in<br>\nthe code correspond to the steps in the outline of my solution above.</p>\n<hr>\n<p>theory ml_example</p>\n<p>imports</p>\n<p>Complex_Main</p>\n<p>\"HOL-Library.Finite_Map\"</p>\n<p>\"HOL-Library.DAList\"</p>\n<p>\"HOL-Library.Permutation\"</p>\n<p>begin</p>\n<p>subsection ‹Auxiliary›</p>\n<p>abbreviation \"dmf ≡ distinct ∘ map fst\"</p>\n<p>lift_definition aperm ::</p>\n<p>\"('key, 'val) alist ⇒ ('key, 'val) alist ⇒ bool\"  (\"_ &lt;~~&gt;a _\"  [50, 50]<br>\n50)</p>\n<p>is Permutation.perm .</p>\n<p>lemma aperm_trans [intro]: \"xs &lt;<del>&gt;a ys ⟹ ys &lt;</del>&gt;a zs ⟹ xs &lt;~~&gt;a zs\"</p>\n<p>by transfer auto</p>\n<p>lemma aperm_sym: \"xs &lt;<del>&gt;a ys ⟹ ys &lt;</del>&gt;a xs\"</p>\n<p>by transfer (rule perm_sym)</p>\n<p>lemma map_of_eq_mset:</p>\n<p>assumes \"dmf xs\" and \"dmf ys\"</p>\n<p>shows \"map_of xs = map_of ys ⟷ mset xs = mset ys\"</p>\n<p>apply(insert assms, rule)</p>\n<p>apply(simp add: distinct_map map_of_inject_set<br>\nset_eq_iff_mset_eq_distinct)</p>\n<p>using map_of_inject_set mset_eq_setD by fastforce</p>\n<p>lemma map_of_eq_perm:</p>\n<p>assumes \"dmf xs\" and \"dmf ys\"</p>\n<p>shows \"map_of xs = map_of ys ⟷ xs &lt;~~&gt; ys\"</p>\n<p>using assms map_of_eq_mset mset_eq_perm by auto</p>\n<p>lemma perm_eq_fmap_of_list:</p>\n<p>assumes \"dmf xs\" and \"dmf ys\"</p>\n<p>shows \"xs &lt;~~&gt; ys ⟷ fmap_of_list xs = fmap_of_list ys\"</p>\n<p>proof</p>\n<p>assume \"xs &lt;~~&gt; ys\"</p>\n<p>with assms have \"map_of xs = map_of ys\"</p>\n<p>by (simp add: map_of_inject_set perm_set_eq)</p>\n<p>then have \"fmlookup (fmap_of_list xs) = fmlookup (fmap_of_list ys)\"</p>\n<p>by (simp add: fmlookup_of_list)</p>\n<p>thus \"fmap_of_list xs = fmap_of_list ys\" by (rule fmlookup_inject[THEN<br>\niffD1])</p>\n<p>next</p>\n<p>assume \"fmap_of_list xs = fmap_of_list ys\"</p>\n<p>then have \"fmlookup (fmap_of_list xs) = fmlookup (fmap_of_list ys)\" by<br>\nsimp</p>\n<p>then have \"map_of xs = map_of ys\" by (simp add: fmlookup_of_list)</p>\n<p>with assms show \"xs &lt;~~&gt; ys\"  by (rule map_of_eq_perm[THEN iffD1])</p>\n<p>qed</p>\n<p>lemma exists_distinct_fst_fmap_of_list:</p>\n<p>\"∃xa. (distinct ∘ <a href=\"http://list.map\">list.map</a> fst) xa ∧ fmap_of_list xa = m\"</p>\n<p>including fmap.lifting</p>\n<p>by transfer (metis comp_def distinct_clearjunk exists_map_of<br>\nmap_of_clearjunk)</p>\n<p>subsection ‹Type Definition›</p>\n<p>quotient_type ('a, 'b) fmaplist = \"('a, 'b) alist\" / \"aperm\"</p>\n<p>morphisms impl_of FMapList</p>\n<p>proof(rule equivpI)</p>\n<p>show \"reflp aperm\" by (simp add: aperm.rep_eq reflp_def)</p>\n<p>show \"symp aperm\" unfolding symp_def using aperm_sym by blast</p>\n<p>show \"transp aperm\" by (metis aperm_trans transpI)</p>\n<p>qed</p>\n<p>lift_definition fml_lookup :: \"('key, 'val) fmaplist ⇒ 'key ⇒ 'val option\"</p>\n<p>is DAList.lookup</p>\n<p>by transfer (simp add: map_of_inject_set perm_set_eq)</p>\n<p>(* ... *)</p>\n<p>subsection ‹Step 1›</p>\n<p>subsubsection ‹Step 1.1 - Auxiliary›</p>\n<p>lift_definition fmap_of_alist :: \"('a, 'b) alist ⇒ ('a, 'b) fmap\"</p>\n<p>is fmap_of_list .</p>\n<p>lemma perm_eq_fmap_of_alist:</p>\n<p>\"xs &lt;~~&gt;a ys ⟷ fmap_of_alist xs = fmap_of_alist ys\"</p>\n<p>by transfer (rule perm_eq_fmap_of_list)</p>\n<p>lemma exists_distinct_fst_fmap_of_alist: \"∃xs. fmap_of_alist xs = m\"</p>\n<p>by transfer (insert exists_distinct_fst_fmap_of_list, auto)</p>\n<p>lemma surj_fmap_of_alist: \"surj fmap_of_alist\"</p>\n<p>unfolding image_def by (auto, metis exists_distinct_fst_fmap_of_alist)</p>\n<p>subsubsection ‹Step 1.2 - Definitions›</p>\n<p>lift_definition fmap_of_fmaplist :: \"('a, 'b) fmaplist ⇒ ('a, 'b) fmap\"</p>\n<p>is fmap_of_alist</p>\n<p>by (rule perm_eq_fmap_of_alist[THEN iffD1])</p>\n<p>definition fmaplist_of_fmap :: \"('a, 'b) fmap ⇒ ('a, 'b) fmaplist\" where</p>\n<p>\"fmaplist_of_fmap = the_inv_into UNIV fmap_of_fmaplist\"</p>\n<p>lemma inj_fmap_of_fmaplist: \"inj fmap_of_fmaplist\"</p>\n<p>by (rule, simp, transfer) (simp add: perm_eq_fmap_of_alist)</p>\n<p>lemma surj_fmap_of_fmaplist: \"surj fmap_of_fmaplist\"</p>\n<p>by transfer (auto simp add: surj_fmap_of_alist)</p>\n<p>lemma bij_fmap_of_fmaplist: \"bij fmap_of_fmaplist\"</p>\n<p>by (insert inj_fmap_of_fmaplist surj_fmap_of_fmaplist, rule bijI)</p>\n<p>lemma bij_fmaplist_of_fmap: \"bij fmaplist_of_fmap\"</p>\n<p>unfolding fmaplist_of_fmap_def using bij_fmap_of_fmaplist</p>\n<p>by (simp add: bij_fmap_of_fmaplist bij_betw_the_inv_into)</p>\n<p>lemma inj_fmaplist_of_fmap: \"inj fmaplist_of_fmap\"</p>\n<p>using bij_betw_def bij_fmaplist_of_fmap by auto</p>\n<p>lemma surj_fmaplist_of_fmap: \"surj fmaplist_of_fmap\"</p>\n<p>by (simp add: bij_fmaplist_of_fmap bij_betw_imp_surj_on)</p>\n<p>subsection ‹Step 2›</p>\n<p>lemma fmap_of_fmaplist_cases:</p>\n<p>\"(⋀y. x = fmap_of_fmaplist y ⟹ y ∈ UNIV ⟹ P) ⟹ P\"</p>\n<p>by (metis UNIV_I bij_fmap_of_fmaplist f_the_inv_into_f_bij_betw)</p>\n<p>lemma fmap_of_fmaplist_induct:</p>\n<p>\"(⋀y. y ∈ UNIV ⟹ P (fmap_of_fmaplist y)) ⟹ P x\"</p>\n<p>by (metis fmap_of_fmaplist_cases iso_tuple_UNIV_I)</p>\n<p>lemma fmap_of_fmaplist_inject:</p>\n<p>\"x ∈ UNIV ⟹</p>\n<p>y ∈ UNIV ⟹</p>\n<p>(fmap_of_fmaplist x = fmap_of_fmaplist y) = (x = y)\"</p>\n<p>by (meson inj_fmap_of_fmaplist inj_onD)</p>\n<p>lemma fmap_of_fmaplist_inverse:</p>\n<p>\"y ∈ UNIV ⟹ fmaplist_of_fmap (fmap_of_fmaplist y) = y\"</p>\n<p>by (simp add: fmaplist_of_fmap_def inj_fmap_of_fmaplist the_inv_f_f)</p>\n<p>lemma fmaplist_of_fmap: \"fmaplist_of_fmap x ∈ UNIV\" ..</p>\n<p>lemma fmaplist_of_fmap_cases:</p>\n<p>\"y ∈ UNIV ⟹ (⋀x. y = fmaplist_of_fmap x ⟹ P) ⟹ P\"</p>\n<p>by (metis fmap_of_fmaplist_inverse)</p>\n<p>lemma fmaplist_of_fmap_induct:</p>\n<p>\"y ∈ UNIV ⟹ (⋀x. P (fmaplist_of_fmap x)) ⟹ P y\"</p>\n<p>by (metis fmap_of_fmaplist_inverse)</p>\n<p>lemma fmaplist_of_fmap_inject:</p>\n<p>\"(fmaplist_of_fmap x = fmaplist_of_fmap y) = (x = y)\"</p>\n<p>by (meson injD inj_fmaplist_of_fmap)</p>\n<p>lemma fmaplist_of_fmap_inverse: \"fmap_of_fmaplist (fmaplist_of_fmap x) = x\"</p>\n<p>using fmap_of_fmaplist_inverse fmaplist_of_fmap_inject by auto</p>\n<p>lemma type_definition_fmaplist_fmap:</p>\n<p>\"type_definition fmaplist_of_fmap fmap_of_fmaplist UNIV\"</p>\n<p>unfolding type_definition_def</p>\n<p>by (simp add: fmap_of_fmaplist_inverse fmaplist_of_fmap_inverse)</p>\n<p>subsection ‹Step 3›</p>\n<p>setup_lifting type_definition_fmaplist_fmap</p>\n<p>subsection ‹Step 4›</p>\n<p>context includes lifting_syntax</p>\n<p>begin</p>\n<p>lemma fmlookup_fml_lookup_transfer_1:</p>\n<p>\"((λ m ml. m = fmap_of_fmaplist ml) ===&gt; (=) ===&gt; (=)) fmlookup<br>\nfml_lookup\"</p>\n<p>unfolding rel_fun_def by (transfer, auto, transfer, simp add:<br>\nfmlookup_of_list)</p>\n<p>lemma fmlookup_fml_lookup_transfer_2 [transfer_rule]:</p>\n<p>\"((λ m ml. cr_fmap ml m) ===&gt; (=) ===&gt; (=)) fmlookup fml_lookup\"</p>\n<p>unfolding rel_fun_def cr_fmap_def</p>\n<p>by auto</p>\n<p>(metis (mono_tags, lifting)</p>\n<p>fmaplist_of_fmap_inverse</p>\n<p>fmlookup_fml_lookup_transfer_1</p>\n<p>rel_funD)</p>\n<p>lemma fml_lookup_fmlookup_transfer_2 [transfer_rule]:</p>\n<p>\"((λ ml m. cr_fmap ml m) ===&gt; (=) ===&gt; (=)) fml_lookup fmlookup\"</p>\n<p>unfolding rel_fun_def cr_fmap_def</p>\n<p>by auto</p>\n<p>(metis (mono_tags, lifting)</p>\n<p>fmaplist_of_fmap_inverse</p>\n<p>fmlookup_fml_lookup_transfer_1</p>\n<p>rel_funD)</p>\n<p>lemma fml_fm_transfer_forall_transfer [transfer_rule]:</p>\n<p>\"((cr_fmap ===&gt; (=)) ===&gt; (=)) transfer_forall transfer_forall\"</p>\n<p>unfolding transfer_forall_def rel_fun_def cr_fmap_def</p>\n<p>using fmaplist_of_fmap_induct by auto</p>\n<p>(* ... *)</p>\n<p>end</p>\n<p>end</p>",
        "id": 294748244,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194391
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi there,</p>\n<p>Your approach looks sensible. There is nothing wrong with manually providing transfer <br>\nrules. But you should be careful with which rules are declared as [transfer_rule] at a <br>\ngiven point in time. The transfer proof method (and its friends) can easily get confused <br>\nwhen you have several rules for the same constant. Often, transfer just tries all <br>\ncombinations until it finds a suitable one, but this can quickly exceed one's patience for <br>\nlarger goals. One way to do so is to prove all rules between the isomorphic types' <br>\nconstants in a locale (without parameters) and locally \"interpret\" the locale whenever <br>\nthese rules are needed. Example:</p>\n<p>locale AS_BQ begin</p>\n<p>lemma fml_lookup_fmlookup_transfer_2 [transfer_rule]: ...</p>\n<p>end</p>\n<p>context begin<br>\ninterpretation AS_BQ ..</p>\n<p>lemma ...<br>\n   by transfer ... (* uses the isomorphism rules *)</p>\n<p>end</p>\n<p>lemma ...<br>\n    by transfer ... (* does not use the isomorphism rules *)</p>\n<p>Moreover, I think that you can simplify things a bit by eliminating one of the isomorphic <br>\ntypes AS or BQ completely. In your example, you do not seem to exploit anything from the <br>\nquotient package. Rather, you simply prove that the quotiented definition of alist <br>\ncorrespond to the definitions on fmap. You should be able to prove this refinement <br>\ndirectly between the operations on alist and fmap.</p>\n<p>That is, manually define a representation function corresponding to the abstraction <br>\nfunction fmap_of_alist and prove the Quotient theorem that quotient_type generates under <br>\nthe name Quotient_fmaplist. Then, declare a locale to collect all the transfer rules <br>\nbetween fmap and alist:</p>\n<p>locale fmap_as_alist begin</p>\n<p>setup_lifting Quotient_fmaplist</p>\n<p>In this locale, you can prove all the transfer rules that the various lift_definitions for <br>\nfmaplist generate, but for the functions on fmap. When you need the quotient view on fmap, <br>\nthen you can interpret fmap_as_alist in a local context as shown above and use it.</p>\n<p>Now to your remaining questions:</p>\n<ul>\n<li>\n<p>Once you have proven the type_definition theorems, then the other theorems that you'd <br>\nget from a typedef can be obtained by interpreting the locale type_definition.</p>\n</li>\n<li>\n<p>For quotients, there is unfortunately no such locale. But once you've proven the <br>\nQuotient theorem, you can get the desired theorems by instantiating the abstract theorems <br>\nfrom theory Quotient (lemma Quotient_abs_rep and below), e.g.</p>\n</li>\n</ul>\n<p>lemmas fmaplist_abs_rep = Quotient_abs_rep[OF Quotient_fmaplist]<br>\n   and fmaplist_rep_reflp = Quotient_rep_reflp[OF Quotient_fmaplist]<br>\n   and ...</p>\n<ul>\n<li>There is no way around manually proving the transfer rules in step 4, because the <br>\nfunctions have been defined independently. The transfer rules show that the functions <br>\nrespect the isomorphism between the types.</li>\n</ul>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294748289,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194410
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Andreas Lochbihler,</p>\n<p>Thank you for your reply. Indeed, I found your advice very helpful.</p>\n<p>In fact, you have also answered a question that I was going to include in<br>\nmy email, but for some reason forgotten about after I started writing the<br>\nemail. Indeed, I was not entirely certain how to ensure that the most<br>\nrelevant transfer rules are applied upon calling the transfer proof method.</p>\n<p>Thank you</p>",
        "id": 294748331,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194427
    }
]