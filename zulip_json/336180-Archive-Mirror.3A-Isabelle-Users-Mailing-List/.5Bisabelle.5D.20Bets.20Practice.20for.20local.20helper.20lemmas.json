[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIt might be surprising, but it is according to the documented meaning of <br>\n'private' (or 'qualified').  Only name space accesses are affected, <br>\neverything else is unchanged, e.g. fact declarations in the context.</p>\n<p>Makarius</p>",
        "id": 294640153,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161765
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis excessive \"local.\" prefix in the output has always been there in <br>\n\"context begin ... end\" blocks since their introduction in 2013, but it is <br>\nnot necessary.</p>\n<p>I've refined that detail in <br>\n<a href=\"https://bitbucket.org/isabelle_project/isabelle-release/commits/014b86186c49\">https://bitbucket.org/isabelle_project/isabelle-release/commits/014b86186c49</a> <br>\nwhich will be in the next release candidate.</p>\n<p>Makarius</p>",
        "id": 294640197,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161790
    },
    {
        "content": "<p>From: \"C. Diekmann\" &lt;<a href=\"mailto:diekmann@in.tum.de\">diekmann@in.tum.de</a>&gt;<br>\nDear Isabelle List,</p>\n<p>what is the best practice to state some temporary helper lemmas? I<br>\ndon't want to pollute the global namespace.</p>\n<p>For example, I want to have a collection of lemmas about foo and bar<br>\n(called foobar).</p>\n<p>Try 1)</p>\n<p>lemma help1: \"foo X\"<br>\nlemma help2: \"bar X\"<br>\nlemmas foobar = help1 help2<br>\nhide_const help1 help2</p>\n<p>It is rather unpleasant to list help1 and help2 in hide_const again.</p>\n<p>Try 2)</p>\n<p>context<br>\nbegin<br>\n  private lemma help1: \"foo X\"<br>\n  private lemma help2: \"bar X\"<br>\n  lemmas foobar = help1 help2<br>\nend</p>\n<p>Are there any downsides with this approach? Do help1 and help2 exist<br>\noutside of the context?</p>\n<p>For me as a user, are approach 1 and 2 equivalent?<br>\nIf so, why does a theory file not introduce a context by default so<br>\nthat I can use the private keyword everywhere?</p>\n<p>Are hide_cost(open) and qualified equivalent?</p>\n<p>Try 3)</p>\n<p>lemma foobar shows \"foo X\" and \"bar X\"<br>\nproof -<br>\n  show \"foo X\"<br>\n  show \"bar X\"<br>\nqed</p>\n<p>Two downsides of this approach: Only applicable if those two X are of<br>\nthe same type and I need to repeat the two theses again.</p>\n<p>Are there better possibilities? Which one is preferred?</p>\n<p>Cheers,<br>\n  Cornelius</p>",
        "id": 294642517,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162715
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 4 May 2015, C. Diekmann wrote:</p>\n<blockquote>\n<p>what is the best practice to state some temporary helper lemmas? I don't <br>\nwant to pollute the global namespace.</p>\n<p>For example, I want to have a collection of lemmas about foo and bar<br>\n(called foobar).</p>\n<p>Try 1)</p>\n<p>lemma help1: \"foo X\"<br>\nlemma help2: \"bar X\"<br>\nlemmas foobar = help1 help2<br>\nhide_const help1 help2</p>\n<p>It is rather unpleasant to list help1 and help2 in hide_const again.</p>\n<p>Try 2)</p>\n<p>context<br>\nbegin<br>\n private lemma help1: \"foo X\"<br>\n private lemma help2: \"bar X\"<br>\n lemmas foobar = help1 help2<br>\nend</p>\n</blockquote>\n<p>You probably mean hide_fact instead of hide_const above -- Isabelle is not <br>\nCoq.</p>\n<p>For the coming Isabelle2015 release, form 2) is considered canonical.  At <br>\nleast it had been virutally canonical over a long time in the pipeline. <br>\nThe implementation suddendly popped out as a result of the work on the <br>\nEisbach release, just before the Isabelle2015-RC phase started.  This also <br>\nmeans there might be fine points to be reconsidered later.</p>\n<p>E.g. there is a slightly different notion of \"concealed\" name space <br>\nentries that is used internally.  Its relation to \"private\" still needs to <br>\nbe clarified.</p>\n<blockquote>\n<p>Do help1 and help2 exist outside of the context?</p>\n</blockquote>\n<p>The 'private' keyword only affects name space entries.  Everything else is <br>\nas before.  E.g. in</p>\n<p>private lemma help [simp]: ...</p>\n<p>the [simp] declaration is unchanged, it is not subject to name space <br>\nmanagement.</p>\n<p>There is also a new 'experimentation' target, which combines a private <br>\ncontext with an anonymous locale.  Thus it is as private and local as <br>\npossible, but nothing can be exported from it (at least not without <br>\nspecial tricks).</p>\n<blockquote>\n<p>For me as a user, are approach 1 and 2 equivalent?</p>\n</blockquote>\n<p>No.  The 'hide' variants are old workarounds: the system first produces <br>\nname space entries, and the user marks them as hidden later.  The <br>\n'private' keyword suppresses the name space entries from the outset, there <br>\nis no hiding happening at all. There are certain corner cases where this <br>\ncan make a difference, e.g. with merges of name spaces.</p>\n<p>Moreover, 'private' affects all name space bindings of the specification <br>\ncommand in question, not just the isolated entities that are hidden by <br>\nseparate hide_type / hide_const / hide_fact etc.  This makes a difference <br>\nfor more complex specifications, e.g. 'definition', 'inductive', <br>\n'function'.</p>\n<p>Note that 'datatype' does not work with 'private' yet: something to be <br>\nrefined for the next release.</p>\n<blockquote>\n<p>If so, why does a theory file not introduce a context by default so<br>\nthat I can use the private keyword everywhere?</p>\n</blockquote>\n<p>Here is some more text from the isar-ref manual:</p>\n<p>Neither a global @{command theory} nor a @{command locale} target provides<br>\n   a local scope by itself: an extra unnamed context is required to use<br>\n   @{keyword \"private\"} or @{keyword \"qualified\"} here.</p>\n<p>It means that the new notion of a formal \"scope\" is missing.  It is <br>\nunclear how that would interact with theory imports or locale <br>\ninterpretation.  So instead of making a mess of features in the last <br>\nmoment before the release, I made a conceptually clear thing.</p>\n<p>In fact, the relatively new \"context begin ... end\" form made the new <br>\n'private' / 'concealed' very easy to provide, bypassing many historic <br>\nproblems.</p>\n<blockquote>\n<p>Are hide_cost(open) and qualified equivalent?</p>\n</blockquote>\n<p>Similar, but not equivalent.  Like full 'hide' and 'private'.</p>\n<p>In practice, it should be possible to replace most uses of \"hide (open)\" <br>\nby \"qualified\" and \"hide\" by \"private\", together with an enclosing context <br>\nblock, at least that is the plan.</p>\n<blockquote>\n<p>Try 3)</p>\n<p>lemma foobar shows \"foo X\" and \"bar X\"<br>\nproof -<br>\n show \"foo X\"<br>\n show \"bar X\"<br>\nqed</p>\n<p>Two downsides of this approach: Only applicable if those two X are of<br>\nthe same type and I need to repeat the two theses again.</p>\n</blockquote>\n<p>There are more disadvantages of putting local things into the proof body: <br>\nyou don't get the full flexibility of specification mechanisms like <br>\n'inductive', 'function', etc.</p>\n<p>There are logical and technical obstacles, and I am very glad that we have <br>\nsuch a relatively simple logical framework.  In Coq you can do arbitrary <br>\nthings inside a proof (I think), and it bogs down the whole system a lot.</p>\n<blockquote>\n<p>Are there better possibilities? Which one is preferred?</p>\n</blockquote>\n<p>Users of Isabelle2015-RC versions are welcome to post further <br>\nobservations.  This is new and might need further polishing (after the <br>\nrelease).</p>\n<p>Makarius</p>",
        "id": 294642537,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162728
    },
    {
        "content": "<p>From: \"C. Diekmann\" &lt;<a href=\"mailto:diekmann@in.tum.de\">diekmann@in.tum.de</a>&gt;<br>\n2015-05-04 22:39 GMT+02:00 Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;:</p>\n<blockquote>\n<p>On Mon, 4 May 2015, C. Diekmann wrote:</p>\n<blockquote>\n<p>what is the best practice to state some temporary helper lemmas? I don't<br>\nwant to pollute the global namespace.</p>\n<p>For example, I want to have a collection of lemmas about foo and bar<br>\n(called foobar).</p>\n<p>Try 1)</p>\n<p>lemma help1: \"foo X\"<br>\nlemma help2: \"bar X\"<br>\nlemmas foobar = help1 help2<br>\nhide_const help1 help2</p>\n<p>It is rather unpleasant to list help1 and help2 in hide_const again.</p>\n<p>Try 2)</p>\n<p>context<br>\nbegin<br>\n private lemma help1: \"foo X\"<br>\n private lemma help2: \"bar X\"<br>\n lemmas foobar = help1 help2<br>\nend</p>\n</blockquote>\n<p>You probably mean hide_fact instead of hide_const above -- Isabelle is not<br>\nCoq.</p>\n<p>For the coming Isabelle2015 release, form 2) is considered canonical.  At<br>\nleast it had been virutally canonical over a long time in the pipeline. The<br>\nimplementation suddendly popped out as a result of the work on the Eisbach<br>\nrelease, just before the Isabelle2015-RC phase started.  This also means<br>\nthere might be fine points to be reconsidered later.</p>\n</blockquote>\n<p>Very nice, I like 2).</p>\n<p>However, sometimes the current proof obligation appears a bit<br>\nunnecessarily crowded (in my opinion) if local definitions are<br>\nprefixed with \"local.\"</p>\n<blockquote>\n<p>E.g. there is a slightly different notion of \"concealed\" name space entries<br>\nthat is used internally.  Its relation to \"private\" still needs to be<br>\nclarified.</p>\n<blockquote>\n<p>Do help1 and help2 exist outside of the context?</p>\n</blockquote>\n<p>The 'private' keyword only affects name space entries.  Everything else is<br>\nas before.  E.g. in</p>\n<p>private lemma help [simp]: ...</p>\n<p>the [simp] declaration is unchanged, it is not subject to name space<br>\nmanagement.</p>\n</blockquote>\n<p>I found a behavior (2015-RC3) which I found rather surprising:</p>\n<p>context<br>\nbegin<br>\n  private fun give0 :: \"nat ⇒ nat\" where<br>\n    \"give0 _ = 0\"</p>\n<p>fun is_zero :: \"nat ⇒ bool\" where<br>\n    \"is_zero n ⟷ n = give0 8\"</p>\n<p>lemma \"is_zero 0\" by simp</p>\n<p>declare is_zero.simps[simp del]</p>\n<p>lemma \"is_zero 0\" by simp (<em>fails</em>)<br>\n  lemma \"is_zero 0\" using is_zero.simps by simp (<em>success</em>)<br>\nend</p>\n<p>lemma \"is_zero 0\" by simp (<em>fails</em>)<br>\nlemma \"is_zero 0\" using is_zero.simps by simp (<em>success</em>)</p>\n<p>Why does the proof of the final lemma succeed? Now I understand that<br>\nthe give0.simps are in the global simp set and hence the proof<br>\nsucceeds. Doesn't this somehow pollute the simp set with facts about<br>\nthings which are private?</p>\n<p>Regards,<br>\n  Cornelius</p>",
        "id": 294642814,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162842
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI currently have the following problem:</p>\n<p>i have a helper lemma A and a locale in which I use that lemma. The <br>\nlemma, however, is of no interest other than the use in that locale, so <br>\nI would like to make it private. However, the following fails with an <br>\nerror message:</p>\n<p>context<br>\nbegin</p>\n<p>private lemma A: \"...\"</p>\n<p>locale foo = ...<br>\nbegin</p>\n<p>end<br>\nend</p>\n<p>Do I /have/ to put A inside the locale to make this work or is there <br>\nanother way?</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294642998,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162906
    }
]