[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Dmitriy,</p>\n<p>thanks for explaining this.</p>\n<p>The matter has many facets, and I'll attempt to structure it a little:</p>\n<ol>\n<li>\n<p>The mentioned syntax fiddling in Product_Type.thy is inoperative and<br>\nobsolete.  A restored version should plugin into the check/uncheck phases.</p>\n</li>\n<li>\n<p>It is a fact of the Isabelle system »as it is« that »spontaneous<br>\nη-expansion« may occur any time while conducting proofs.</p>\n</li>\n</ol>\n<p>IMHO, these two aspects are facts.</p>\n<ol start=\"3\">\n<li>\n<p>There should be an effective device to retain product patterns for<br>\nbinders despite (2) for the sake of readability (what (1) was originally<br>\nsupposed to be).  I. e.</p>\n<p>lemma<br>\n  \"(∑(a, b)∈R. f a (∑(c, d)∈Q. g d c)) = s\"<br>\n  apply simp --<br>\n    ‹@{prop \"(∑x∈R. case x of (a, b) ⇒<br>\n      f a (∑x∈Q. case x of (c, d) ⇒ g d c)) = s\"}›</p>\n</li>\n</ol>\n<p>reveals a considerable decline in readability, particularly when the<br>\nnewly introduced variable names shadow previously essential names.</p>\n<ol start=\"4\">\n<li>\n<p>Accepting this yields further questions how to deal with patterns in<br>\ngeneral.  E. g. in the current state of affairs it is not desirable to<br>\nη-contract expressions at binding positions unconditionally, i.e.</p>\n<p>\"(∑p∈P. case p of Ident x ⇒ x) = s\"</p>\n</li>\n</ol>\n<p>which is internally just</p>\n<p>\"setsum (λp. case_ident (λx. x) p) P = s\"</p>\n<p>under eta-contraction would collapse to</p>\n<p>\"setsum (case_ident (λx. x)) P = s\"</p>\n<p>which seems not desired here.</p>\n<p>When the syntax »λC x ⇒ … | D y ⇒ …« has been introduced, I suggested<br>\nthat any surjective constructor (like »Ident« above) should be treated<br>\nlike »Pair«, allow patterns like</p>\n<p>\"(∑(Ident x∈P). x) = s\"</p>\n<p>which would again perfectly be apt to η-contraction again.</p>\n<p>If 3. is generally accepted, I am willing to undertake an implementation<br>\nat the current state of the art (check/uncheck and local everything (!)).</p>\n<p>Any opinion concerning (4)?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/qUVsZh8kqr8DUkydy_yRsBJb/signature.asc\">signature.asc</a></p>",
        "id": 294291306,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923549
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nHi Florian,</p>\n<p>On 28.08.2014 18:17, Florian Haftmann wrote:</p>\n<blockquote>\n<p>The matter has many facets, and I'll attempt to structure it a little:</p>\n<ol>\n<li>The mentioned syntax fiddling in Product_Type.thy is inoperative and<br>\nobsolete.  A restored version should plugin into the check/uncheck phases.</li>\n</ol>\n<p>[...]</p>\n<ol start=\"3\">\n<li>\n<p>There should be an effective device to retain product patterns for<br>\nbinders despite (2) for the sake of readability (what (1) was originally<br>\nsupposed to be).  I. e.</p>\n<p>lemma<br>\n   \"(∑(a, b)∈R. f a (∑(c, d)∈Q. g d c)) = s\"<br>\n   apply simp --<br>\n     ‹@{prop \"(∑x∈R. case x of (a, b) ⇒<br>\n       f a (∑x∈Q. case x of (c, d) ⇒ g d c)) = s\"}›</p>\n</li>\n</ol>\n<p>reveals a considerable decline in readability, particularly when the<br>\nnewly introduced variable names shadow previously essential names.</p>\n<p>[...]</p>\n<p>If 3. is generally accepted, I am willing to undertake an implementation<br>\nat the current state of the art (check/uncheck and local everything (!)).<br>\nNo objections, of course.</p>\n</blockquote>\n<p>You would base your implementation on the code from Product_Type <br>\nmentioned in 1. and plug it in before the \"case\"-uncheck-phase, right?</p>\n<p>Why are you also mentioning check? I think the parse translations are <br>\ngood enough here.</p>\n<blockquote>\n<ol start=\"4\">\n<li>\n<p>Accepting this yields further questions how to deal with patterns in<br>\ngeneral.  E. g. in the current state of affairs it is not desirable to<br>\nη-contract expressions at binding positions unconditionally, i.e.</p>\n<p>\"(∑p∈P. case p of Ident x ⇒ x) = s\"</p>\n</li>\n</ol>\n<p>which is internally just</p>\n<p>\"setsum (λp. case_ident (λx. x) p) P = s\"</p>\n<p>under eta-contraction would collapse to</p>\n<p>\"setsum (case_ident (λx. x)) P = s\"</p>\n<p>which seems not desired here.</p>\n<p>When the syntax »λC x ⇒ … | D y ⇒ …« has been introduced, I suggested<br>\nthat any surjective constructor (like »Ident« above) should be treated<br>\nlike »Pair«, allow patterns like</p>\n<p>\"(∑(Ident x∈P). x) = s\"</p>\n<p>which would again perfectly be apt to η-contraction again.<br>\nHow often does this situation occur with constructors different from <br>\nPair? Also using the selectors (as provided by datatype_new) might be <br>\nthe better way to express \"case p of Ident x =&gt; x\".</p>\n</blockquote>\n<p>Dmitriy</p>",
        "id": 294294602,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924203
    }
]