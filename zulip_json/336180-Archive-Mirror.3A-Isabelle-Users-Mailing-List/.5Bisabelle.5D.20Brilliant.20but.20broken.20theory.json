[
    {
        "content": "<p>From: Victor Porton &lt;<a href=\"mailto:porton@narod.ru\">porton@narod.ru</a>&gt;<br>\nI have written my first Isabelle theory. It does not verify and my Isar<br>\nproofs are a monkey-nonsense. Indeed (after being corrected) this will<br>\nbe a very important theory for Isabelle/ZF project. The idea is<br>\nbrilliant, the implementation is poor.</p>\n<p>My theory defines (bijective) modification (\"newbig\") of a set (\"big\")<br>\nin such a way that an another set \"small\" becomes it subset. \"small\" is<br>\nembedded into big by an injection \"embed\".</p>\n<p>Example: We may modify the set of integers (\"big\") into an another<br>\nexemplar (\"newbig\") (that is bijective image) of integers which will<br>\ncontain the set of naturals (\"small\"); \"embed\" is the correspondence of<br>\nnaturals to integers. (In the current Isabelle/ZF naturals are not a<br>\nsubset of integers and this needs to be corrected.)</p>\n<p>We can further extend it to rational, real, and complex numbers, so that<br>\nour exemplars of these would contain each previous set.</p>\n<p>Another example: We may want to identify the set of principal filters<br>\nwith the corresponding lattice elements. Then filters is \"big\", our<br>\nlattice is \"small\" and \"embed\" is the function which maps a lattice<br>\nelement into the corresponding principla filter.</p>\n<p>I ask you several things:</p>\n<ol>\n<li>\n<p>Edit my broken theory in such the way that it would become good<br>\nquality (first, it should verify). I even ask you to create a perfect<br>\nexample of Isar proofs. I would learn from this example.</p>\n</li>\n<li>\n<p>Put the theory into the Isabelle package.</p>\n</li>\n<li>\n<p>Decide how we will deal and how we will name sets produces using my<br>\ntheory. (The bijective copy of the set \"int\" could become \"int_obj\",<br>\n\"int_gen\", \"int_over_nat\", etc. We need to chose a naming convention.)</p>\n</li>\n</ol>\n<p>My theory follows:</p>\n<hr>\n<p>theory Generalization<br>\n  imports ZF Perm upair<br>\nbegin</p>\n<p>locale generalization =<br>\n  fixes big::i and small::i<br>\n  fixes embed::i<br>\n  assumes is_inj: \"embded: inj(small, big)\"<br>\nbegin</p>\n<p>definition \"small2 == range(embed)\"<br>\ndefinition converse_embed: \"spec == converse(embed)\"</p>\n<p>theorem spec_bij: \"spec: bij(small2, small)\"<br>\n  by auto</p>\n<p>definition \"token == Pow(Union(Union(small)))\"</p>\n<p>lemma token_not_small: \"&lt;token,x&gt;~: small\"<br>\nproof<br>\n  assume \"&lt;token,x&gt;: small\"<br>\n  have \"{{token,token}, {token,x}}: small\"<br>\n    then \"{{token}, {token,x}}: small\"<br>\n    then \"{token}: Union(small)\"<br>\n    then \"token &lt;= Union(Union(small))\"<br>\n    then \"token: Pow(Union(Union(small)))\"<br>\n    then \"token: token\"<br>\n    then show False by mem_not_refl<br>\nqed</p>\n<p>definition move_fun::\"i=&gt;i\" where \"move_fun(x) == if x: small2 then<br>\nspec`x else &lt;token,x&gt;\"<br>\ndefinition \"move == (lam x:big. move_fun(x))\"</p>\n<p>definition \"newbig == range(move)\"</p>\n<p>definition ret_def: \"ret == converse(move)\"</p>\n<p>theorem \"small &lt;= newbig\"<br>\nproof<br>\n  assume \"x: small\"<br>\n  have \"embed<code>x: small2\"\n    then \"move</code>(embed<code>x) = spec</code>(embed<code>x)\"\n    then \"move</code>(embed`x) = x\"<br>\n    then \"x: range(move)\"<br>\n    show \"x: newbig\"<br>\nqed</p>\n<p>theorem move_inj: \"move: inj(big, newbig)\"<br>\nproof<br>\n  assume \"a: big\" \"b:big\" and \"move<code>a = move</code>b\"<br>\n  proof cases<br>\n    assume \"a: small2\" \"b: small2\"<br>\n    have \"move<code>a = spec</code>a\"<br>\n    have \"move<code>b = spec</code>b\"<br>\n    have \"spec<code>a = spec</code>b\"<br>\n    using spec_bij show \"a = b\"<br>\n  next<br>\n    assume \"a: small2\" \"b~: small2\"<br>\n    have \"move<code>a = spec</code>a\"<br>\n    have \"move<code>b = &lt;token,b&gt;\"\n    have \"move</code>a: small\"<br>\n    have \"move<code>b~: small\" by token_not_small\n    show \"False\"\n  next\n    assume \"a~: small2\" \"b: small2\"\n    have \"move</code>a = &lt;token,a&gt;\"<br>\n    have \"move<code>b = spec</code>b\"<br>\n    have \"move<code>a~: small\"\n    have \"move</code>b: small\" by token_not_small<br>\n    show \"False\"<br>\n  next<br>\n    assume \"a~: small2\" \"b~: small2\"<br>\n    have \"move<code>a = &lt;token,a&gt;\"\n    have \"move</code>b = &lt;token,b&gt;\"<br>\n    have \"&lt;token,a&gt;=&lt;token,b&gt;\"<br>\n    show \"a = b\"<br>\n  qed<br>\n  show \"a = b\"<br>\nqed</p>\n<p>theorem move_surj: \"move: surj(big, newbig)\"<br>\n  by auto</p>\n<p>theorem move_bij: \"move: bij(big, newbig)\"<br>\n  by auto</p>\n<p>theorem ret_bij: \"ret: bij(newbig, big)\"<br>\nunfolding ret_def<br>\nusing move_bij bij_converse_bij by simp</p>\n<p>theorem embed_move: \"move O embded = id(small)\"<br>\nproof<br>\n  assume \"x: small\"<br>\n  have \"embed<code>x: small2\"\n  have \"move</code>(embed<code>x) = spec</code>(embed<code>x)\"\n  from converse_embed have \"move</code>(embed`x) = x\"<br>\n  show \"move O embded = id(small)\"<br>\nqed</p>\n<p>end</p>\n<p>end;</p>",
        "id": 294074582,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828358
    }
]