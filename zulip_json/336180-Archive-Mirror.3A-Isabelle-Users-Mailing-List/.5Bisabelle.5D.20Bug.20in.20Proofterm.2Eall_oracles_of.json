[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>this is the current implementation (Isabelle2018 stable) of all_oracles_of:</p>\n<p>val all_oracles_of =<br>\n  let<br>\n    fun collect (PBody {oracles, thms, ...}) =<br>\n      tap join_thms thms |&gt; fold (fn (i, thm_node) =&gt; fn (x, seen) =&gt;<br>\n        if Inttab.defined seen i then (x, seen)<br>\n        else<br>\n          let<br>\n            val body = Future.join (thm_node_body thm_node);<br>\n            val (x', seen') = collect body (x, Inttab.update (i, ()) seen);<br>\n          in (if null oracles then x' else oracles :: x', seen') end);<br>\n  in fn body =&gt; unions_oracles (#1 (collect body ([], Inttab.empty))) end;</p>\n<p>The function collect here collects oracles from two places: the argument<br>\noracles, and the recursive collect calls on thms. However, the oracles from<br>\nthe argument oracles are added inside the fold that iterates over (not yet<br>\nseen) thms. That is, if thms has more than one element, the same oracles<br>\nare added several times (not critical since they will be filtered later),<br>\nand if thms is empty (or all seen), then the oracles from the argument<br>\noracles will never been added. (Or, to say it shorter: collect<br>\n(PBody{oracles, []}) does nothing.) The effect is that some oracles get<br>\nmissed.</p>\n<p>Here is a fixed function:</p>\n<p>val all_oracles_of =<br>\n  let<br>\n    fun collect_inner thms =<br>\n        tap join_thms thms |&gt; fold (fn (i, thm_node) =&gt; fn (x, seen) =&gt;<br>\n          if Inttab.defined seen i then (x, seen)<br>\n          else<br>\n            let<br>\n              val body = Future.join (thm_node_body thm_node);<br>\n              val (x', seen') = collect body (x, Inttab.update (i, ())<br>\nseen);<br>\n            in (x', seen') end)<br>\n    and collect (PBody {oracles, thms, ...}) seen = case collect_inner thms<br>\nseen of (x,seen) =&gt;<br>\n            (if null oracles then x else oracles :: x, seen)<br>\n  in fn body =&gt; unions_oracles (#1 (collect body ([], Inttab.empty))) end;</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294747051,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661193930
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI will look at this in further detail later.</p>\n<p>Just note that whenever you find some odd function in the Isabelle<br>\nsources you need to figure out its overall context and status:</p>\n<p>* by looking at its definition in ML</p>\n<p>* by looking at its uses in application</p>\n<p>* by looking through the documentation</p>\n<p>Doing this briefly shows that all_oracles_of is an isolated point that<br>\nis not connected anywhere. Thus it has formally no meaning, and words<br>\nlike \"bug\" or \"fix\" are even less meaningful than usual.</p>\n<p>Moreover there is a more profound omission in the tracking of oracles in<br>\nIsabelle: certain kernel operations don't record anything. This is just<br>\nan incomplete implementation and TODO-item over many years. We don't<br>\nadvertize oracle tracking anywhere --  and if some document claims that<br>\nwe need to change the text to avoid confusion.</p>\n<p>Makarius</p>",
        "id": 294747066,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661193937
    }
]