[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>I have an executable decision procedure, say \"frobnicate\", that takes<br>\nsome parameters and yields a result. When I run</p>\n<p>value \"frobnicate x\"</p>\n<p>I get some result \"y\". I would now like to turn this into a proof method<br>\nthat proves the statement \"frobnicate x = y\", ideally by deduction,<br>\nwithout relying on oracles. (I dimly remember the \"eval\" method that, if<br>\nI recall correctly, uses the code generator and ML as an oracle, doing<br>\nbasically the same thing as the \"value\" command)</p>\n<p>What is the best way to do this? At the moment, I use the CONVERSION<br>\ntactical and Code_Runtime.static_holds_conv, but I am not sure what this<br>\ndoes internally (oracle or deduction) and it is quite slow.<br>\nAdditionally, I have to pass a number of constants by hand as a list of<br>\n@{code_name … } and I am not sure which of these I really need in order<br>\nfor it to work reliably.</p>\n<p>So, how does one normally do these things? Ifi the conversion with<br>\nstatic_holds_conv is the way to go, is there some way to make it faster?</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294248556,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909888
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>Florian is the expert on Code_Runtime, but here's what I know. Can you make precise which <br>\nexecution model evaluates the \"frobnicate x\" in the value example? In principle, you can <br>\nuse [code] with the code generator, [nbe] for normalization by evaluation and [simp] for <br>\nrewriting with the simplifier. For each of these options, there's a separate method: eval, <br>\nnormalization and code_simp.</p>\n<p>The eval method generates ML code for the statement, runs it and checks that it returns <br>\nTrue. It cannot deal with variables in the statement.</p>\n<p>normalization converts the statement into an intermediate language and symbolically <br>\nexecutes it in the intermediate language.</p>\n<p>code_simp produces a simpset with only the code equations as rewrite rules and invokes the <br>\nsimplifier with this simpset on the goal after preprocessing with the code_unfold rules. <br>\nThis meets your criteria for \"no oracle\", but is the slowest of the three.</p>\n<p>In the code generator tutorial, Code_Runtime.static_holds_conv is listed under the column <br>\ncode, so I expect that it involves code generation and the ML oracle. Isabelle has no <br>\nexecution engine for HOL, I only know that the simplifier can be used to normalise <br>\nfunctions, which corresponds to executing when the rewrite system are the code equations. <br>\nIf this is what you want, then you should try code_simp.</p>\n<p>Andreas</p>",
        "id": 294248763,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909955
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nInterestingly Coq has such a builtin execution engine, and the French have <br>\ninvested a lot of energy into it (conceptually and performance wise).</p>\n<p>Nonetheless, some Coq expert users have told me that they like the <br>\nIsabelle/HOL approach better for certain applications, e.g. what <br>\nIsabelle/IsaFoR does with native Haskell compared to Coq/CoLoR with the<br>\non-board execution engine.</p>\n<p>Doing actual LCF proofs via computation is a different thing, though.</p>\n<p>Makarius</p>",
        "id": 294248810,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909973
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>ah, very good, I did not know about the code generator tutorial.</p>\n<p>I tried to use Code_Simp now, but it does not terminate even after quite<br>\nsome time. I then tried \"value [simp]\" with some examples and found the<br>\nfollowing:</p>\n<p>value [simp] \"[:1:] - [:1, 2::real :]\"<br>\nResult: \"[:1:] + - [:1, 2:]\" :: \"real poly\"</p>\n<p>That is obviously not what I wanted. Does this mean that there is some<br>\nproblem with the way the code equations in Polynomial.thy are set up?</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294248955,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910019
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>What Isabelle version are you using? And what are your imports? In Isabelle2013, I get the <br>\nfollowing results (imports Complex_Main and Polynomial):</p>\n<p>value [code] =&gt; \"[:0, -2:]\"<br>\nvalue [nbe]  =&gt; \"[:0, -2:]\"<br>\nvalue [simp] =&gt; \"[: real_of_rat (1 - 1), real_of_rat (- 2) :]\"</p>\n<p>With the development version f6629734dd2b, I get:</p>\n<p>value [code] =&gt; \"Poly [0, -2]\"<br>\nvalue [nbe]  =&gt; \"Poly [0, -2]\"<br>\nvalue [simp] =&gt; \"[:1:] + - [:1, 2:]\"</p>\n<p>Two months ago, Florian changed in 3cc46b8cca5e the code setup for polynomials from <br>\nexplicit constructors 0 and pCons to an abstract type with constructor Poly and destructor <br>\ncoeffs. This explains why the syntax [: and :] is lost.</p>\n<p>Since poly is now an abstract datatype, the code generator transforms the [code abstract] <br>\nequations for code generation from \"Rep (f x) = ...\" to \"f x = Abs (...)\" where Rep is the <br>\ndestructor and Abs is the constructor (following the usual typedef terminology). For <br>\ncode_simp, however, no such preprocessing happens, i.e., the simplifier is fed directly <br>\nwith \"Rep (f x) = ...\". Therefore, evaluation with [simp] will be delayed until you <br>\ndestruct the values. This is only a problem for value [simp], but not for proofs by <br>\ncode_simp, because code_simp can only be called on terms of type bool, i.e., all <br>\npolynomials in the statement will be deconstructed if needed.</p>\n<p>Maybe Florian can say more how one could use change value [simp] to address this issue, <br>\npossibly before the next release makes all this public.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294248964,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910023
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThanks for the explanations so far.</p>\n<p>I use the development version because, if I remember correctly, it<br>\ncontains some theorems that I need.</p>\n<p>The reason why I asked about \"value [simp]\" is that code_simp seems to<br>\ntake a very, very long time, in fact, so long that I think it either<br>\nloops or builds up some enormously big term. Other expressions involving<br>\npolynomials also lead to unpleasant results, such as:</p>\n<p>value [simp] \"gcd [:1, 2::real :] [:3:]\"<br>\nResult: \"smult (real_of_rat (inverse 3)) [:3:]\" :: \"real poly\"</p>\n<p>If I try to use Poly instead of [: and :], I get the following error<br>\nmessage.</p>\n<p>value \"Poly [0::real]\"<br>\n*** Abstraction violation:<br>\n*** constant Poly</p>\n<p>Attempting to use any of the evaluation conversions on the ML level<br>\nresults in the same error message, so apparently, switching from [: … :]<br>\nto Poly does not solve the problem either, it seems to make things even<br>\nworse.</p>\n<p>I can, of course, use evaluation instead of code_simp, but I do prefer<br>\ndeduction within the logic over trusted prove such as the code<br>\ngenerator, and apart from that, I really would like to understand what<br>\nis going wrong here and why.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294248989,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910035
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>Evaluation in the simplifier is a tricky beast to debug! Recently (8e8941fea278), Florian <br>\nadded a tracing option code_simp_trace to see what's happening. I expect that in your <br>\napplication, the abstract datatypes cause the trouble. When you use polynomials of reals, <br>\nyou have the following types stacked into one another:</p>\n<ul>\n<li>Numerals with constructors One, Bit0, Bit1</li>\n<li>int with constructors 0, Pos, Neg</li>\n<li>Rationals as abstract datatype with constructor Frct and destructor quotient_of</li>\n<li>Reals with constructor Ratreal</li>\n<li>Polynomials as abstract datatype with constructor Poly and destructor coeffs</li>\n</ul>\n<p>Evaluation with the simplifier does not obey the call-by-value strategy of ML. There are <br>\nsome congruence rules for some functions like op &amp; and op | that prevent execution of the <br>\nsecond argument, but nothing more. For normal code_datatypes like Numerals, int and Reals, <br>\nthis is OK, because the simplifier works bottom-up, i.e., it will first simplify the <br>\narguments of a constant (from left to right) and only then try to rewrite with the <br>\nconstant's code equation. For abstract datatypes, this breaks down as can be seen in your <br>\nexamples:</p>\n<p>\"inverse 3 :: rat\" is not evaluated because rat is an abstract type, a quotient_of <br>\ndestructor would be necessary to trigger evaluation. Instead, the simplifier continues the <br>\nexecution with the code equations for outer constants. If these do not destruct \"inverse <br>\n3\", this term will be passed around unevaluated. As may code equation duplicate <br>\nparameters, this can yield exponentially large terms. Even worse, the duplicates are not <br>\nshared (in terms of execution), i.e., if \"inverse 3\" is destructed later, it will be <br>\ndestructed and evaluated each time. In summary: evaluation in the simplifier currently <br>\ndoes not work well for abstract datatypes. Maybe Florian has some ideas to mitigate the issue.</p>\n<p>Now to your next question with Poly: 'a poly is an abstract datatype with constructor Poly <br>\nand destructor quotient_of. The abstract means that the constructor Poly must not occur in <br>\nanything that you execute. Otherwise, you will get an abstraction violation. For normal <br>\ncode generation, this check is essential for soundness, because the code generator <br>\ntransforms all the [code abstract] equations from destructor style to constructor style.<br>\nFor code_simp, however, this check is bogus because it does not do the transformation and <br>\nsoundness is not endangered. Nevertheless, the check currently is there. Maybe you can <br>\nconvince Florian to drop this check for code_simp. But this will not stop the blow-up that <br>\nI have described above.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294249009,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910041
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nPlease, just one more attempt to get rid of this wrong idea of \"the ML <br>\nlevel of Isabelle\".</p>\n<p>The proper terminology is \"Isabelle/ML\".  You don't have to understand the <br>\nreasons for that, just use the correct term as a habit.</p>\n<p>Makarius</p>",
        "id": 294249062,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910046
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nSo all in all, at the moment, the only way to do something like what I<br>\nam trying to do is to rely on the code generator? Is this what all the<br>\nother decision procedure in Isabelle (such as, off the top of my head,<br>\nPresburger arithmetic) do?</p>",
        "id": 294249104,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910066
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;</p>\n<blockquote>\n<p>So all in all, at the moment, the only way to do something like what I<br>\nam trying to do is to rely on the code generator? Is this what all the<br>\nother decision procedure in Isabelle (such as, off the top of my head,<br>\nPresburger arithmetic) do?<br>\nI do not have a complete overview over all the Isabelle decision procedures, but I know of <br>\nthree approaches:</p>\n</blockquote>\n<ol>\n<li>\n<p>Formalise the algorithm in Isabelle, prove it correct, compile the algorithm to ML with <br>\nthe code generator and use it as a decision procedure. I expect that all the proof methods <br>\nthat use reflection rely on the code generator. Amine and Tobias have describe this <br>\napproach for linear arithmetic in [1].</p>\n</li>\n<li>\n<p>Do the proof search outside the kernel, record it if you find one, and then replay that <br>\nprove inside the kernel. IIRC, blast uses this approach and sledgehammer/metis probably, <br>\ntoo. This is only sensible if the proof itself requires much less inferences than the <br>\nsearch. In any case, you do not have to formalise and verify your algorithm for soundness, <br>\nthe kernel takes care of that.</p>\n</li>\n<li>\n<p>Do everything within the kernel like the simplifier does. In your case, you could code <br>\nyour own execution engine for the kernel, but that's probably overkill.</p>\n</li>\n</ol>\n<p>Best,<br>\nAndreas</p>\n<p>[1] Amine Chaieb and Tobias Nipkow. Proof Synthesis and Reflection for Linear Arithmetic. <br>\nJournal of Automated Reasoning, April 2008</p>",
        "id": 294249158,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910084
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 04/09/2013 17:31, schrieb Manuel Eberl:</p>\n<blockquote>\n<p>So all in all, at the moment, the only way to do something like what I<br>\nam trying to do is to rely on the code generator?</p>\n</blockquote>\n<p>If you want the execution speed of ML, you use the code generator. If you want<br>\nto go through the kernel, you use some form of the simplifier.</p>\n<blockquote>\n<p>Is this what all the<br>\nother decision procedure in Isabelle (such as, off the top of my head,<br>\nPresburger arithmetic) do?</p>\n</blockquote>\n<p>All the default decision procedures go through the kernel and use ad-hoc<br>\ncombinations of inference rules, including the simplifier. Those in<br>\nDecision_Procs use reflection and the code generator. The big advantage of<br>\nreflection is speed and the ability to prove both soundness and completeness of<br>\nyour algorithm.</p>\n<p>Tobias</p>\n<blockquote>\n<p>On 09/04/2013 04:29 PM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Hi Manuel,</p>\n<p>Evaluation in the simplifier is a tricky beast to debug! Recently<br>\n(8e8941fea278), Florian added a tracing option code_simp_trace to see<br>\nwhat's happening. I expect that in your application, the abstract<br>\ndatatypes cause the trouble. When you use polynomials of reals, you<br>\nhave the following types stacked into one another:</p>\n<ul>\n<li>Numerals with constructors One, Bit0, Bit1</li>\n<li>int with constructors 0, Pos, Neg</li>\n<li>Rationals as abstract datatype with constructor Frct and destructor<br>\nquotient_of</li>\n<li>Reals with constructor Ratreal</li>\n<li>Polynomials as abstract datatype with constructor Poly and<br>\ndestructor coeffs</li>\n</ul>\n<p>Evaluation with the simplifier does not obey the call-by-value<br>\nstrategy of ML. There are some congruence rules for some functions<br>\nlike op &amp; and op | that prevent execution of the second argument, but<br>\nnothing more. For normal code_datatypes like Numerals, int and Reals,<br>\nthis is OK, because the simplifier works bottom-up, i.e., it will<br>\nfirst simplify the arguments of a constant (from left to right) and<br>\nonly then try to rewrite with the constant's code equation. For<br>\nabstract datatypes, this breaks down as can be seen in your examples:</p>\n<p>\"inverse 3 :: rat\" is not evaluated because rat is an abstract type, a<br>\nquotient_of destructor would be necessary to trigger evaluation.<br>\nInstead, the simplifier continues the execution with the code<br>\nequations for outer constants. If these do not destruct \"inverse 3\",<br>\nthis term will be passed around unevaluated. As may code equation<br>\nduplicate parameters, this can yield exponentially large terms. Even<br>\nworse, the duplicates are not shared (in terms of execution), i.e., if<br>\n\"inverse 3\" is destructed later, it will be destructed and evaluated<br>\neach time. In summary: evaluation in the simplifier currently does not<br>\nwork well for abstract datatypes. Maybe Florian has some ideas to<br>\nmitigate the issue.</p>\n<p>Now to your next question with Poly: 'a poly is an abstract datatype<br>\nwith constructor Poly and destructor quotient_of. The abstract means<br>\nthat the constructor Poly must not occur in anything that you execute.<br>\nOtherwise, you will get an abstraction violation. For normal code<br>\ngeneration, this check is essential for soundness, because the code<br>\ngenerator transforms all the [code abstract] equations from destructor<br>\nstyle to constructor style.<br>\nFor code_simp, however, this check is bogus because it does not do the<br>\ntransformation and soundness is not endangered. Nevertheless, the<br>\ncheck currently is there. Maybe you can convince Florian to drop this<br>\ncheck for code_simp. But this will not stop the blow-up that I have<br>\ndescribed above.</p>\n<p>Best,<br>\nAndreas<br>\n</p>\n</blockquote>\n<p>On 04/09/13 15:38, Manuel Eberl wrote:</p>\n<blockquote>\n<blockquote>\n<p>Thanks for the explanations so far.</p>\n<p>I use the development version because, if I remember correctly, it<br>\ncontains some theorems that I need.</p>\n<p>The reason why I asked about \"value [simp]\" is that code_simp seems to<br>\ntake a very, very long time, in fact, so long that I think it either<br>\nloops or builds up some enormously big term. Other expressions involving<br>\npolynomials also lead to unpleasant results, such as:</p>\n<p>value [simp] \"gcd [:1, 2::real :] [:3:]\"<br>\nResult: \"smult (real_of_rat (inverse 3)) [:3:]\" :: \"real poly\"</p>\n<p>If I try to use Poly instead of [: and :], I get the following error<br>\nmessage.</p>\n<p>value \"Poly [0::real]\"<br>\n*** Abstraction violation:<br>\n*** constant Poly</p>\n<p>Attempting to use any of the evaluation conversions on the ML level<br>\nresults in the same error message, so apparently, switching from [: … :]<br>\nto Poly does not solve the problem either, it seems to make things even<br>\nworse.</p>\n<p>I can, of course, use evaluation instead of code_simp, but I do prefer<br>\ndeduction within the logic over trusted prove such as the code<br>\ngenerator, and apart from that, I really would like to understand what<br>\nis going wrong here and why.</p>\n<p>Cheers,<br>\nManuel<br>\n</p>\n</blockquote>\n<p>On 09/04/2013 03:28 PM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi Manuel,</p>\n<blockquote>\n<p>I tried to use Code_Simp now, but it does not terminate even after<br>\nquite<br>\nsome time. I then tried \"value [simp]\" with some examples and found<br>\nthe<br>\nfollowing:</p>\n<p>value [simp] \"[:1:] - [:1, 2::real :]\"<br>\nResult: \"[:1:] + - [:1, 2:]\" :: \"real poly\"</p>\n<p>That is obviously not what I wanted. Does this mean that there is some<br>\nproblem with the way the code equations in Polynomial.thy are set up?<br>\nWhat Isabelle version are you using? And what are your imports? In<br>\nIsabelle2013, I get the following results (imports Complex_Main and<br>\nPolynomial):</p>\n</blockquote>\n<p>value [code] =&gt; \"[:0, -2:]\"<br>\nvalue [nbe]  =&gt; \"[:0, -2:]\"<br>\nvalue [simp] =&gt; \"[: real_of_rat (1 - 1), real_of_rat (- 2) :]\"</p>\n<p>With the development version f6629734dd2b, I get:</p>\n<p>value [code] =&gt; \"Poly [0, -2]\"<br>\nvalue [nbe]  =&gt; \"Poly [0, -2]\"<br>\nvalue [simp] =&gt; \"[:1:] + - [:1, 2:]\"</p>\n<p>Two months ago, Florian changed in 3cc46b8cca5e the code setup for<br>\npolynomials from explicit constructors 0 and pCons to an abstract type<br>\nwith constructor Poly and destructor coeffs. This explains why the<br>\nsyntax [: and :] is lost.</p>\n<p>Since poly is now an abstract datatype, the code generator transforms<br>\nthe [code abstract] equations for code generation from \"Rep (f x) =<br>\n...\" to \"f x = Abs (...)\" where Rep is the destructor and Abs is the<br>\nconstructor (following the usual typedef terminology). For code_simp,<br>\nhowever, no such preprocessing happens, i.e., the simplifier is fed<br>\ndirectly with \"Rep (f x) = ...\". Therefore, evaluation with [simp]<br>\nwill be delayed until you destruct the values. This is only a problem<br>\nfor value [simp], but not for proofs by code_simp, because code_simp<br>\ncan only be called on terms of type bool, i.e., all polynomials in the<br>\nstatement will be deconstructed if needed.</p>\n<p>Maybe Florian can say more how one could use change value [simp] to<br>\naddress this issue, possibly before the next release makes all this<br>\npublic.</p>\n<p>Best,<br>\nAndreas<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294249188,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910094
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:Jeremy.Dawson@anu.edu.au\">Jeremy.Dawson@anu.edu.au</a>&gt;<br>\nWhy is it wrong?  It seems a perfectly good description as I understand <br>\nthe structure of the system.</p>\n<p>Anyone who doesn't understand the reasons for what you say isn't likely <br>\nto see the expression \"the ML level of Isabelle\" as a \"wrong idea\", or <br>\n\"Isabelle/ML\" as the only correct term.</p>\n<p>Cheers,</p>\n<p>Jeremy</p>\n<p>Makarius wrote:</p>",
        "id": 294249220,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910104
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Manuel,</p>\n<p>(first, thanks to Andreas for the thorough analysis).</p>\n<p>the short answer is that code_simp indeed in its current state does not<br>\nperform well with abstract datatypes.  To mitigate this, it would need<br>\nto be enriched with a non-trivial machinery to do bookkeeping on<br>\ninvariants at runtime, to be able to reduce redexes rep (Abs x) = x when<br>\nneeded.  This is definitely nothing to be done in the short run.</p>\n<p>To come to your particular issue.  Usually when using the simplifier you<br>\nfirst determine an appropriate set of rewrite rules in order to solve<br>\nyour problem by rewriting and then just do a specific simplifier setup<br>\nsuited for your problem.  Cf. the following minimalistic example</p>\n<p>ML {*<br>\nval numeral_syms = @{thms numeral_1_eq_1 [symmetric] numeral_2_eq_2<br>\n[symmetric]};</p>\n<p>fun subst_numerals ctxt =<br>\n  simplify (ctxt |&gt; put_simpset HOL_basic_ss |&gt; fold<br>\n(Simplifier.add_simp o mk_meta_eq) numeral_syms) o Thm.transfer<br>\n(Proof_Context.theory_of ctxt)<br>\n*}</p>\n<p>ML {* subst_numerals @{context} @{thm nat_mult_1} *}</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/hUK8fZjc8DqACgU4JQn8BcIs/signature.asc\">signature.asc</a></p>",
        "id": 294249330,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910152
    }
]