[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>I recently needed something like a \"cancellation lemma\" for setprod but<br>\nwas unable to find anyting like it in the libraries.</p>\n<p>The lemma I needed and proved was the following:<br>\nlemma setprod_cancel: fixes A::\"nat set\" and B::\"nat set\"<br>\nassumes \"B ⊆ A\" and \"finite A\" and \"0 ∉ B\" shows \"∏A / ∏B = ∏(A-B)\"</p>\n<p>Is there a lemma like this somewhere? If yes, what is it called? If not,<br>\nit might be a good idea to add this (or a generalised version of this)<br>\nand a version for setsum to the libraries, since it seems like something<br>\none needs quite often when dealing with products and sums.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294220180,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897063
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nDid you mean \"div\" instead of \"/\" or do you an implicit conversion to <br>\nreal in there?</p>\n<blockquote>\n<p>Is there a lemma like this somewhere? If yes, what is it called? If not,<br>\nit might be a good idea to add this (or a generalised version of this)<br>\nand a version for setsum to the libraries, since it seems like something<br>\none needs quite often when dealing with products and sums.</p>\n</blockquote>\n<p>For sums, there is setsum_diff. For products, there is the question what <br>\nthe type class of the base type of A,B should be -- probably would need <br>\nto be a field, to be useful (which then excludes the naturals).</p>\n<p>Maybe one could generically prove \"∏A = ∏(A-B) * ∏B\" and derive your <br>\nvariant from there for specific types.</p>\n<p>-- Lars</p>",
        "id": 294220204,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897077
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI agree that this looks like the right approach. Your suggested lemma in<br>\n(generalized form) is a direct consequence of setprod_Un_disjoint:</p>\n<p>[| finite A; finite B; A Int B = {} |]<br>\n==&gt; setprod f (A Un B) = setprod f A * setprod f B</p>\n<p>because A-B and B are disjoint.</p>\n<p>Tobias</p>",
        "id": 294220255,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897087
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\n(Replied directly at first instead of to the list, sorry about that)</p>\n<p>No, I really meant /. I have coercions from nat to real in there. But<br>\nyes, the generalisation you proposed seems like a good idea, that should<br>\nwork for any abelian semigroup with multiplication, I think. (as long as<br>\nthe underlying lemmas for setprod are that general as well)</p>\n<p>I was just very surprised that something like this didn't exist already.<br>\nWho is responsible for maintaining these libraries, i.e. whom do I have<br>\nto contact if I have a lemma that I think should be included in the library?</p>",
        "id": 294220265,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897095
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 13/08/2012 12:51, schrieb Manuel Eberl:</p>\n<blockquote>\n<p>(Replied directly at first instead of to the list, sorry about that)</p>\n<p>No, I really meant /. I have coercions from nat to real in there. But<br>\nyes, the generalisation you proposed seems like a good idea, that should<br>\nwork for any abelian semigroup with multiplication, I think. (as long as<br>\nthe underlying lemmas for setprod are that general as well)</p>\n<p>I was just very surprised that something like this didn't exist already.<br>\nWho is responsible for maintaining these libraries, i.e. whom do I have<br>\nto contact if I have a lemma that I think should be included in the library?</p>\n</blockquote>\n<p>You can try to send it to one of the people who created the theory. Which would<br>\nbe me in this case.</p>\n<p>Tobias</p>\n<blockquote>\n<p>On 13/08/12 11:44, Lars Noschinski wrote:</p>\n<blockquote>\n<p>On 12.08.2012 23:59, Manuel Eberl wrote:</p>\n<blockquote>\n<p>Hallo,</p>\n<p>I recently needed something like a \"cancellation lemma\" for setprod but<br>\nwas unable to find anyting like it in the libraries.</p>\n<p>The lemma I needed and proved was the following:<br>\nlemma setprod_cancel: fixes A::\"nat set\" and B::\"nat set\"<br>\nassumes \"B ⊆ A\" and \"finite A\" and \"0 ∉ B\" shows \"∏A / ∏B = ∏(A-B)\"</p>\n</blockquote>\n<p>Did you mean \"div\" instead of \"/\" or do you an implicit conversion to<br>\nreal in there?</p>\n<blockquote>\n<p>Is there a lemma like this somewhere? If yes, what is it called? If<br>\nnot,<br>\nit might be a good idea to add this (or a generalised version of this)<br>\nand a version for setsum to the libraries, since it seems like<br>\nsomething<br>\none needs quite often when dealing with products and sums.</p>\n</blockquote>\n<p>For sums, there is setsum_diff. For products, there is the question<br>\nwhat the type class of the base type of A,B should be -- probably<br>\nwould need to be a field, to be useful (which then excludes the<br>\nnaturals).</p>\n<p>Maybe one could generically prove \"∏A = ∏(A-B) * ∏B\" and derive your<br>\nvariant from there for specific types.</p>\n<p>-- Lars</p>\n</blockquote>\n</blockquote>",
        "id": 294220279,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897100
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nIt can indeed be proven for comm_monoid_mult in a rather straightforward<br>\nfashion:</p>\n<p>lemma setprod_diff: \"⟦B ⊆ A; finite A⟧ ⟹<br>\n    setprod f A = setprod f (A - B) * setprod f B\"<br>\nby (subgoal_tac \"A - B ∪ B = A\", subst setprod_Un_disjoint[symmetric],<br>\n    auto intro: finite_subset)</p>\n<p>And the corresponding cancellation lemmas for products over nat, int and<br>\nreal. I was unable to prove a general version of this with arbitrary<br>\ntypes because the correctness lemmas for the real type coercion seem to<br>\nbe only available for specific types such as nat and int. (note the<br>\nimplicit coercion to real)</p>\n<p>lemma setprod_cancel_nat: fixes f::\"'a ⇒ nat\"<br>\n    assumes \"B ⊆ A\" and \"finite A\" and \"∀x∈B. f x ≠ 0\"<br>\n    shows \"setprod f A / setprod f B = setprod f (A - B)\" (is \"?A / ?B =<br>\n?C\")<br>\nproof-<br>\n  from setprod_diff[OF assms(1,2)] have \"?A = ?C * ?B\" by auto<br>\n  moreover have \"?B ≠ 0\" using assms by (simp add: finite_subset)<br>\n  ultimately show ?thesis by simp<br>\nqed</p>\n<p>(and similarly for int and real)</p>\n<p>To be more precise, if I tried to prove this for arbitrary types with<br>\nsome sort constraint, i.e. 'b::comm_monoid_mult, I always got stuck at<br>\nsome subgoal like \"real (a * b) = real a * real b\" which seemed to be<br>\nunprovable. Do I really have to write three separate lemmas for nat, int<br>\nand real or is there a way to do this once for arbitrary types?</p>",
        "id": 294220288,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897106
    }
]