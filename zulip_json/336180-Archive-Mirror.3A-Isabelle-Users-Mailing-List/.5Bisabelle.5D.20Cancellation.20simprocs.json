[
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHello list,</p>\n<p>there are several simprocs that are able to cancel terms, i.e. simplify<br>\n\"a + b + c = b + d\" to \"a + c = d\".</p>\n<p>Current problem: none of the simprocs is activated on<br>\ncancel_comm_monoid_add (i.e., the earliest point where the cancellation<br>\nis possible).</p>\n<p>Here is the situation as far as I can tell:</p>\n<p>Simproc<br>\n    _L_arry _P_aulson's cancellation _s_improc on nat/int/...<br>\n    Brian Huffman's _G__r_oup cancellation _s_improc<br>\n    My _M_ultiset cancellation _s_improc<br>\n    My _G__e_neralised _m_ultiset cancellation _s_improc<br>\nAbbreviation<br>\nused in this email<br>\n    LPS<br>\n    GrS<br>\n    MS<br>\n    GeMS<br>\nfile<br>\n    ~~/src/Provers/Arith/cancel_numerals.ML<br>\n~~/Provers/Arith/cancel_numeral_factor.ML<br>\n    ~~/src/HOL/Tools/group_cancel.ML<br>\n    - (2016-1 only) ~~/src/HOL/Library/multiset*.ML</p>\n<p>- (devel only) ~~/src/HOL/Library/Cancellation.thy<br>\n~~/src/HOL/Library/Cancellation/cancel*.ML<br>\nWorks on:<br>\n    nat / int / ...<br>\n    cancel_comm_monoid_add, but activated only on groups<br>\n    cancel_comm_monoid_add, but activated only on multisets<br>\ncancel_comm_monoid_add, but activated only on multisets<br>\nSpecial feature<br>\n    - support the product</p>\n<ul>\n<li>does additional simplification on the output<p>- support repeat_mset, replicate_mset,...<br>\n  - support an iterate_add operator (for multisets: repeat_mset,<br>\nreplicate_mset,...; for natural numbers, it would be the product)</p>\n</li>\n</ul>\n<p>There are some points to notice:</p>\n<p>(1) The aim behind generalising the MS to GeMS is to support multiset<br>\nvariants with constructors and special operators (like signed multisets<br>\nin $AFP/Nested_Multisets_Ordinals/Signed_Multiset.thy). There might be<br>\nother types that have a operator that behaves like a multiplication by nat.</p>\n<p>(2) We cannot activate the simprocs on cancel_comm_monoid_add.<br>\nOtherwise, tactics like linarith fails: linarith relies on the<br>\nadditional simplification done by LPS (like replacing ‹-1 * x› by ‹- x›).</p>\n<p>(3) I am not sure that GrS and GeMS do the exact same thing on the same<br>\nformula.</p>\n<p>To solve the problem, I have locally activated GeMS where I have<br>\nhard-coded that the simproc does not apply on types where LPS applies.<br>\nIt worked without problem. However, I am not sure that testing the AFP<br>\nand the Isabelle distribution is sufficient to declare that (3) does not<br>\ncause problems.</p>\n<p>Does somebody have an opinion on the matter? Or should I just proceed<br>\nand activate my GeMS simproc on all cancel_comm_monoid_add types (except<br>\nthose where LPS applies)?</p>\n<p>Best,</p>\n<p>Mathias</p>",
        "id": 294706966,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180922
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHello Florian,</p>\n<p>On 02/03/2017 10:47, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Hi Mathias,</p>\n<blockquote>\n<p>To solve the problem, I have locally activated GeMS where I have<br>\nhard-coded that the simproc does not apply on types where LPS applies.<br>\nIt worked without problem. However, I am not sure that testing the AFP<br>\nand the Isabelle distribution is sufficient to declare that (3) does not<br>\ncause problems.<br>\nDoes somebody have an opinion on the matter? Or should I just proceed<br>\nand activate my GeMS simproc on all cancel_comm_monoid_add types (except<br>\nthose where LPS applies)?<br>\noperationally this should be OK.  But the overall design seems not very<br>\nconvincing.</p>\n</blockquote>\n<p>I have no ready-to-proceed suggestion at hand, but a few thoughts:</p>\n<ul>\n<li>LPS is the only one to operate on nat / int directly rather than an<br>\nalgebraic structure.  Can this be lifted, and how would the overall<br>\npicture then look like?<br>\nFor nat: it cannot be lifted. The replacement from Suc to +1 is done<br>\nwhile iterating over the term. So no simple way to do lifting.</li>\n</ul>\n</blockquote>\n<p>For int: it already works on linordered_idom.</p>\n<p>I have to think about the general picture if we really want to reduce<br>\nduplication (with the risk of breaking proofs).</p>\n<blockquote>\n<ul>\n<li>Can there be <em>one</em> implementation of GeMS and LPS with a case<br>\ndistinction or something like that?  That would still be better two<br>\nconcurring implementations.<br>\nI tried that. It should work but getting full compatibility is very <em>hard</em>:</li>\n</ul>\n</blockquote>\n<ul>\n<li>\n<p>the code is non-trivial (e.g., whether Suc is replaced by +1 is<br>\nhandled internally).</p>\n</li>\n<li>\n<p>there is some normalisation done after cancellation (I don't really<br>\nknow why).</p>\n</li>\n<li>\n<p>the simprocs on natural numbers are crucial for the linarith, meaning<br>\nthat even small differences can have huge consequences.</p>\n</li>\n<li>\n<p>LPS does not always do what people would expect, e.g.<br>\n~~/HOL/ex/Simproc_Tests.thy:<br>\n       (* FIXME \"Suc (i + 3) \\&lt;equiv&gt; i + 4\" *)<br>\n       assume \"4 * Suc 0 + i = u\" have \"Suc (i + 3) = u\"<br>\n          by (tactic \\&lt;open&gt;test @{context} [@{simproc<br>\nnat_combine_numerals}]\\&lt;close&gt;) fact</p>\n</li>\n</ul>\n<p>If we want to replace LPS, should we aim at full compatibility to avoid<br>\nbreaking proofs or try to fix the FIXMEs from Simproc_Test?</p>\n<blockquote>\n<ul>\n<li>Note that technically the cancellation simproc implementations are<br>\nnotoriously outdated;  the state of the are is to implement such a<br>\nsimproc in a locale and then interpret it onto the desired instances.<br>\nDetail can be found in Amine Chaieb and Makarius Wenzel: Context aware<br>\nCalculation and Deduction --- Ring Equalities via Gröbner Bases in<br>\nIsabelle.  And in src/HOL/Semiring_Normalization.thy<br>\nThat should make the implementation a bit cleaner. I'll look into that.</li>\n</ul>\n</blockquote>\n<p>Best,<br>\nMathias</p>\n<blockquote>\n<p>Best,<br>\n  Florian<br>\n</p>\n</blockquote>",
        "id": 294707382,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181040
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nHistorical remark: this code was written possibly before axiomatic type classes even existed and certainly before they were used to streamline our formalisation of arithmetic theories. And it’s still possible that the natural numbers are sufficiently distinctive to need their own dedicated simproc.</p>\n<p>I don’t remember for sure, quite possibly, rewriting i+4 to Suc(i+3) is intentional, with the idea that a subsequent rewrite step will involve something of the form f(Suc k) = …k….</p>\n<p>Streamlining and generalising this code will be a big job for somebody.</p>\n<p>Larry Paulson</p>",
        "id": 294707433,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181057
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHello all,</p>\n<p>On 03/03/2017 12:39, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>And it’s still possible that the natural numbers are sufficiently<br>\ndistinctive to need their own dedicated simproc.<br>\nNot really. It should be possible to have a simproc that replaces the<br>\nSuc by ‹+1› where needed. Then the normal cancellation simproc should be<br>\nable to do the job.</p>\n</blockquote>\n<blockquote>\n<p>I don’t remember for sure, quite possibly, rewriting i+4 to Suc(i+3)<br>\nis intentional, with the idea that a subsequent rewrite step will<br>\ninvolve something of the form f(Suc k) = …k….<br>\nI think you misunderstood the comment: the simprocs simplifies ‹Suc (i +<br>\n3)› in ‹4 * Suc 0 + i›. It does not do anything on ‹i+4›.</p>\n</blockquote>\n<p>However, what you said explains why ‹Suc (i  + 1)› is not simplified to<br>\n‹i+2›.</p>\n<blockquote>\n<p>Streamlining and generalising this code will be a big job for somebody.<br>\nI agree.</p>\n</blockquote>\n<p>Mathias</p>\n<blockquote>\n<p>Larry Paulson</p>\n<p>On 3 Mar 2017, at 08:30, Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a></p>\n<blockquote>\n<p>&lt;mailto:<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;&gt; wrote:</p>\n<blockquote>\n<ul>\n<li>Can there be <em>one</em> implementation of GeMS and LPS with a case<br>\ndistinction or something like that?  That would still be better two<br>\nconcurring implementations.<br>\nI tried that. It should work but getting full compatibility is very<br>\n<em>hard</em>:</li>\n<li>the code is non-trivial (e.g., whether Suc is replaced by +1 is<br>\nhandled internally).</li>\n<li>there is some normalisation done after cancellation (I don't really<br>\nknow why).</li>\n<li>the simprocs on natural numbers are crucial for the linarith, meaning<br>\nthat even small differences can have huge consequences.<br>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294707448,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181063
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Matthias,</p>\n<blockquote>\n<ul>\n<li>the simprocs on natural numbers are crucial for the linarith, meaning<br>\nthat even small differences can have huge consequences.</li>\n<li>LPS does not always do what people would expect, e.g.<br>\n~~/HOL/ex/Simproc_Tests.thy:<br>\n       (* FIXME \"Suc (i + 3) \\&lt;equiv&gt; i + 4\" *)<br>\n       assume \"4 * Suc 0 + i = u\" have \"Suc (i + 3) = u\"<br>\n          by (tactic \\&lt;open&gt;test @{context} [@{simproc<br>\nnat_combine_numerals}]\\&lt;close&gt;) fact</li>\n</ul>\n<p>If we want to replace LPS, should we aim at full compatibility to avoid<br>\nbreaking proofs or try to fix the FIXMEs from Simproc_Test?</p>\n</blockquote>\n<p>linarith is indeed a world on its own and IMHO it would be OK if<br>\nlinarith would retain its current simproc, even if that is not used any<br>\nwhere else.</p>\n<p>For a generalized simproc it would be fine if some proofs have to be<br>\namended, if the number of breaking proofs does not rise to high; this<br>\nhappens routinely when maintaining proof automation.  The usual approach<br>\nto figure out is:</p>\n<ul>\n<li>Make the intended change.</li>\n<li>See whether HOL can get run with reasonable effort.</li>\n<li>\n<p>Build as much as possible from distro and AFP.  Iterate over breaking<br>\nproofs.</p>\n</li>\n<li>\n<p>Over time you get an idea what the impact of the change is:</p>\n<ul>\n<li>How many breaking proofs?</li>\n<li>\n<p>How big is the amount of »awkward« breaking proofs compared to<br>\n»streamlined« breaking proofs?</p>\n</li>\n<li>\n<p>Is there are recurring pattern how proofs can be repaired?</p>\n</li>\n<li>\n<p>Is there yet another thing to change e.g. concerning the simplifier<br>\nsetup to get to a cleaner situation again?</p>\n</li>\n<li>\n<p>…</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<blockquote>\n<ul>\n<li>Note that technically the cancellation simproc implementations are<br>\nnotoriously outdated;  the state of the are is to implement such a<br>\nsimproc in a locale and then interpret it onto the desired instances.<br>\nDetail can be found in Amine Chaieb and Makarius Wenzel: Context aware<br>\nCalculation and Deduction --- Ring Equalities via Gröbner Bases in<br>\nIsabelle.  And in src/HOL/Semiring_Normalization.thy<br>\nThat should make the implementation a bit cleaner. I'll look into that.</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>I'll appreciate that.</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<p>Best,<br>\nMathias</p>\n<blockquote>\n<p>Best,<br>\n Florian<br>\n</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/TVHnfJviRyaTtdxTDvMafxMb/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294707501,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181082
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nAnd preferably, take the opportunity to clean up untidy proofs that are difficult to maintain. <br>\nLarry</p>",
        "id": 294707512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181087
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Mathias,</p>\n<p>operationally this should be OK.  But the overall design seems not very<br>\nconvincing.</p>\n<p>I have no ready-to-proceed suggestion at hand, but a few thoughts:</p>\n<ul>\n<li>\n<p>LPS is the only one to operate on nat / int directly rather than an<br>\nalgebraic structure.  Can this be lifted, and how would the overall<br>\npicture then look like?</p>\n</li>\n<li>\n<p>Can there be <em>one</em> implementation of GeMS and LPS with a case<br>\ndistinction or something like that?  That would still be better two<br>\nconcurring implementations.</p>\n</li>\n<li>\n<p>Note that technically the cancellation simproc implementations are<br>\nnotoriously outdated;  the state of the are is to implement such a<br>\nsimproc in a locale and then interpret it onto the desired instances.<br>\nDetail can be found in Amine Chaieb and Makarius Wenzel: Context aware<br>\nCalculation and Deduction --- Ring Equalities via Gröbner Bases in<br>\nIsabelle.  And in src/HOL/Semiring_Normalization.thy</p>\n</li>\n</ul>\n<p>Best,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/GxvJRYtb5seV4Io0jSec4v8R/signature.asc\">signature.asc</a></p>",
        "id": 294707913,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181214
    }
]