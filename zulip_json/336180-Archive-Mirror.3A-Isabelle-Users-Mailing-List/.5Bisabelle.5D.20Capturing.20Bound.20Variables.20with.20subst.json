[
    {
        "content": "<p>From: scott constable &lt;<a href=\"mailto:sdconsta@syr.edu\">sdconsta@syr.edu</a>&gt;<br>\nHi All,</p>\n<p>I'm currently trying to simplify a subgoal via a substitution. What I would<br>\nlike to do is the following:</p>\n<p>apply (subst whileLoop_add_inv [where M=\"\\&lt;lambda&gt; (n', _). ptr_val n'\" and<br>\nI =\"\\&lt;lambda&gt; n' _. n' &lt; p\"])</p>\n<p>The problem is that \"p\" is bound by all (!!) to the entire scope of the<br>\ncurrent subgoal, and subst apparently cannot express instantiations that<br>\nrefer to such bound variables. The other alternative is to use an erule_tac<br>\napplied to subst. But I cannot figure out a way to invoke this rule while<br>\nalso defining the schematic variables required by the rule<br>\nwhileLoop_add_inv.</p>\n<p>So it looks like I need something like a \"subst_tac\", which is not<br>\ncurrently a feature of Isabelle/HOL. Is there a way around this?</p>\n<p>Many thanks in advance,</p>\n<p>~Scott Constable</p>",
        "id": 294632422,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661158815
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Unfortunatelz, there is no subst_tac method that would allow you to refer to the parameters of the goal as the old-style tactic emulations *rule_tac.</p>\n</blockquote>\n<p>There is a subst_tac in AFP/Automatic_Refinement/Lib/Refine_Util.<br>\nUnfortunately, those things are unlikely to end up in the official<br>\nIsabelle Release, as apply-style reasoning is considered ancient style,<br>\nand the official philosophy seems to be trying to abandon all<br>\napply-style reasoning in favour of Isar-proofs. </p>\n<p>For the domain of verification condition generation/discharging, and<br>\nprogram synthesis, however, I'm not yet aware of viable Isar<br>\nalternatives. However, Lars Noschinski has done some initial work there.</p>\n<p>For subst_tac, you can either include the Refine_Util-theory, or use the<br>\nfollowing code snippet:</p>\n<p>ML ‹<br>\n  local<br>\n    (* Substitution with dynamic instantiation of parameters.<br>\n       By Lars Noschinski. *)<br>\n    fun eqsubst_tac' ctxt asm =<br>\n      if asm then EqSubst.eqsubst_asm_tac ctxt else EqSubst.eqsubst_tac<br>\nctxt</p>\n<p>fun subst_method inst_tac tac =<br>\n      Args.goal_spec --<br>\n      Scan.lift (Args.mode \"asm\" -- Scan.optional (Args.parens<br>\n(Scan.repeat Parse.nat)) [0]) --<br>\n      Scan.optional (Scan.lift<br>\n        (Parse.and_list1 <br>\n          (Args.var -- (Args.$$$ \"=\" |-- Parse.!!!<br>\nArgs.name_inner_syntax)) --|<br>\n          Args.$$$ \"in\")) [] --<br>\n      Attrib.thms &gt;&gt;<br>\n      (fn (((quant, (asm, occL)), insts), thms) =&gt; fn ctxt =&gt; METHOD <br>\n        (fn facts =&gt;<br>\n          if null insts then <br>\n            quant (Method.insert_tac facts THEN' tac ctxt asm occL thms)<br>\n          else<br>\n            (case thms of<br>\n              [thm] =&gt; quant (<br>\n                Method.insert_tac facts THEN' inst_tac ctxt asm occL<br>\ninsts thm)<br>\n            | _ =&gt; error \"Cannot have instantiations with multiple<br>\nrules\")));</p>\n<p>in<br>\n    fun eqsubst_inst_tac ctxt asm occL insts thm = <br>\n      Subgoal.FOCUS (<br>\n        fn {context=ctxt,...} =&gt; let<br>\n          val ctxt' = ctxt |&gt; Proof_Context.set_mode<br>\nProof_Context.mode_schematic  (* FIXME !? *)<br>\n          val thm' = thm |&gt; Rule_Insts.read_instantiate ctxt' insts []<br>\n        in eqsubst_tac' ctxt asm occL [thm'] 1 end<br>\n      ) ctxt</p>\n<p>val eqsubst_inst_meth = subst_method eqsubst_inst_tac eqsubst_tac'<br>\n  end<br>\n›</p>\n<p>setup ‹ Method.setup @{binding subst_tac} eqsubst_inst_meth<br>\n           \"single-step substitution (dynamic instantiation)\"›</p>\n<blockquote>\n<p>Hope this helps,<br>\nAndreas</p>\n<hr>\n<p>Von: <a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> [cl-isabelle-users-bounces@lists.cam.ac.uk]&quot; im Auftrag von &quot;scott constable [sdconsta@syr.edu]<br>\nGesendet: Dienstag, 3. März 2015 18:09<br>\nAn: <a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a><br>\nCc: Akash Waran<br>\nBetreff: [isabelle] Capturing Bound Variables with subst</p>\n<p>Hi All,</p>\n<p>I'm currently trying to simplify a subgoal via a substitution. What I would<br>\nlike to do is the following:</p>\n<p>apply (subst whileLoop_add_inv [where M=\"\\&lt;lambda&gt; (n', _). ptr_val n'\" and<br>\nI =\"\\&lt;lambda&gt; n' _. n' &lt; p\"])</p>\n<p>The problem is that \"p\" is bound by all (!!) to the entire scope of the<br>\ncurrent subgoal, and subst apparently cannot express instantiations that<br>\nrefer to such bound variables. The other alternative is to use an erule_tac<br>\napplied to subst. But I cannot figure out a way to invoke this rule while<br>\nalso defining the schematic variables required by the rule<br>\nwhileLoop_add_inv.</p>\n<p>So it looks like I need something like a \"subst_tac\", which is not<br>\ncurrently a feature of Isabelle/HOL. Is there a way around this?</p>\n<p>Many thanks in advance,</p>\n<p>~Scott Constable<br>\n</p>\n</blockquote>",
        "id": 294632634,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661158896
    },
    {
        "content": "<p>From: Lochbihler  Andreas &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Scott,</p>\n<p>In Isabelle2014, the instantiation attributes \"of\" and \"where\" support a \"for\" clause. This allows you to generalise over the variables in the instantiation expressions. For example, in the theorem</p>\n<p>whileLoop_add_inv [where M=\"\\&lt;lambda&gt; (n', _). ptr_val n'\" and I =\"\\&lt;lambda&gt; n' _. n' &lt; p\" for p]</p>\n<p>the variable p is a schematic again, which the normal subst method can then unify with the parameter of the goal. In most cases, this is sufficient. Unfortunatelz, there is no subst_tac method that would allow you to refer to the parameters of the goal as the old-style tactic emulations *rule_tac.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294632637,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661158896
    },
    {
        "content": "<p>From: scott constable &lt;<a href=\"mailto:sdconsta@syr.edu\">sdconsta@syr.edu</a>&gt;<br>\nWorked like a charm. Thanks so much!</p>\n<p>~Scott Constable</p>",
        "id": 294632640,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661158897
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;</p>\n<blockquote>\n<p>On 4 Mar 2015, at 9:46 pm, Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Unfortunatelz, there is no subst_tac method that would allow you to refer to the parameters of the goal as the old-style tactic emulations *rule_tac.</p>\n</blockquote>\n<p>There is a subst_tac in AFP/Automatic_Refinement/Lib/Refine_Util.<br>\nUnfortunately, those things are unlikely to end up in the official<br>\nIsabelle Release, as apply-style reasoning is considered ancient style,<br>\nand the official philosophy seems to be trying to abandon all<br>\napply-style reasoning in favour of Isar-proofs.</p>\n</blockquote>\n<p>I don’t agree with that. First of all, apply-style is Isar as well, it’s just not structured proof. The actually ancient proof style is ML script, pasted manually from your editor into the ML top-level in a shell ;-) Second, there are quite a few situations where apply style is entirely adequate.</p>\n<p>Structured proof is nicer and more readable for many, maybe even most situations, but not for everything.</p>\n<blockquote>\n<p>For the domain of verification condition generation/discharging, and<br>\nprogram synthesis, however, I'm not yet aware of viable Isar<br>\nalternatives.</p>\n</blockquote>\n<p>Precisely :-)</p>\n<p>Regarding subst_tac, the upcoming Eisbach will have a few language mechanisms that should make it easier to treat name bindings more nicely and naturally (and to further reduce long apply scripts). It’s not quite there yet, but Dan is working on it.</p>\n<p>Cheers,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294632668,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661158910
    }
]