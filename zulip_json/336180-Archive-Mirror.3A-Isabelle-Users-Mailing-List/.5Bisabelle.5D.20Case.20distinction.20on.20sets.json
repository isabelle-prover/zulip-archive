[
    {
        "content": "<p>From: \"C. Diekmann\" &lt;<a href=\"mailto:diekmann@in.tum.de\">diekmann@in.tum.de</a>&gt;<br>\nHi everyone,</p>\n<p>with lists, I can do case distinctions, which I cannot do with sets.<br>\nIs there any good advice to express case distinctions on sets?</p>\n<p>Here is my example. With lists, I can write the following:</p>\n<p>case [x←xs. P x] of [] =&gt; None<br>\n                            | [y] =&gt; Some y<br>\n                            | _ =&gt; undefined</p>\n<p>I would like to write this down for xs being a set. To prove<br>\nequivalence, I will use \"set xs\". Unfortunately, I cannot use \"case\"<br>\nwith a set. The best I could come up with is the following:</p>\n<p>let matching_entries = {x ∈ set xs. P x} in<br>\n    if matching_entries = {} then None else<br>\n    if ∃y. matching_entries = {y} then Some (the_elem matching_entries) else<br>\n       undefined</p>\n<p>Is there a nicer and better way to express this?</p>\n<p>If xs is distinct, both versions are equivalent (though the proof was<br>\nhorrible). For the proof I needed some helper lemmas, for example the<br>\nfollowing:</p>\n<p>lemma \"distinct xs ⟹ {x. x ∈ set xs ∧ P x} = {x} ⟹<br>\n       [x←xs . P x] = [x]\"<br>\napply(induction xs)<br>\n apply(simp)<br>\napply(simp)<br>\napply(case_tac \"x=a\")<br>\n apply simp_all<br>\n apply (smt DiffD2 Diff_insert_absorb filter_False insert_compr mem_Collect_eq)<br>\nby (smt Collect_cong ball_empty insert_iff mem_Collect_eq)</p>\n<p>The lemma seems pretty obvious to me so I didn't want to invest much<br>\ntime into it. This was the best proof I could come up with. Why can't<br>\nthe built-in tools such as blast solve this lemma instantly? I could<br>\nnot replace those two smt calls with other one-line methods. What is<br>\nit that makes this lemma so hard for Isabelle?</p>\n<p>Thanks for your advice,<br>\n  Cornelius</p>",
        "id": 294648756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165242
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Cornelius,</p>\n<p>You can simplify your definitions if you split the filtering from the section of the <br>\nelements. It looks as if you are trying to lift the operation \"pick the unique element in <br>\na set\" into the option monad. So just lift this operaton:</p>\n<p>definition the_elem_option :: \"'a set =&gt; 'a option\"<br>\nwhere \"the_elem_option A = (if EX1 x. x : A then Some (the_elem A) else None)\"</p>\n<p>Note that this specification is tighter than yours as the result is None if there are <br>\nseveral elements in the set. If you wanted the function to be undefined in a mathematical <br>\nsense, then this approach is likely to make your life hard anyway, because working with <br>\nunderspecified functions usually causes quite some pain.</p>\n<p>Moreover, I've replaces EX x. A = {x} with EX1 x. x : A, because the latter involves more <br>\nprimitive operations on sets than the former. Intuitively, I'd expect better automation <br>\nfor the latter, but I have not tested it.</p>\n<p>In general, I recommend that you work only at the level of abstraction that fits your <br>\nneeds. If you want sets (without order on the elements), then stick to the type set (or <br>\nfset, if you need finiteness) and never talk about lists. If you need the order of the <br>\nelements in the list, then work with lists and convert them to sets when needed, but do <br>\nnot try to lift the operations from lists to sets when they rely on the order---this <br>\nnormally directly leads to ugly, messy, tedious proofs.</p>\n<p>Picking an element from a set is hard for the automated tools, because it involves a <br>\ntricky mix of rewriting and resolution. Blast can only deal with resolution, but not <br>\nrewriting, so blast usually does not work well for proofs involving equality. Conversely, <br>\nthe simplifier cannot deal well with underspecified functions (like the_elem).</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294648769,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165248
    }
]