[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Angeliki,</p>\n<p>I don't know if transfer can help here, but it does not surprise me that the <br>\nproofs are harder for nat than for int as soon as \"-\" is involved because it <br>\ndoes not obey the same nice algebraic properties on nat as on int. See, for <br>\nexample, add_diff_assoc.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/RJds2q525MgMn1nVuN0vg45_/smime.p7s\">smime.p7s</a></p>",
        "id": 294829587,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245995
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear Tobias,<br>\nthank you for your answer.</p>\n<p>Update: I found a different, slightly longer proof of A in my context<br>\nwith (2::nat) .<br>\nI still need B with (2::nat), but also in general, it would be<br>\nvery useful to be able to convert types somewhat automatically.</p>\n<p>Any general tips wrt type conversion anyone?</p>\n<p>Thanks in advance,<br>\nAngeliki</p>",
        "id": 294829601,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246001
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Angeliki Koutsoukou-Argyraki/All,</p>\n<p>This is merely a side remark for the question \"Change the type from int to<br>\nnat -lifting/transfer?\": I do not, necessarily, anticipate that it contains<br>\nany new information for the OP.</p>\n<p>The theory HOL-ex.Transfer_Int_Nat provides an experimental infrastructure<br>\nfor the transfer between the types 'int' and 'nat'. With small amendments<br>\nto the infrastructure, it is possible to perform the transfer of the goals<br>\nassociated with the theorems A and B stated for nat to int (the other<br>\ndirection is more difficult). For example,</p>\n<p>theory Scratch<br>\n  imports<br>\n    \"HOL-ex.Transfer_Int_Nat\"<br>\nbegin</p>\n<p>lemma [transfer_rule]:<br>\n  includes lifting_syntax<br>\n  shows \"(ZN ===&gt; ZN ===&gt; ZN) (λx y. x ^ nat y) (^)\"<br>\n  by (intro rel_funI) (simp add: ZN_def)</p>\n<p>lemma B:<br>\n  includes lifting_syntax<br>\n  assumes \"k&gt;l\" \"l≥1\"<br>\n  shows<br>\n    \"(2::nat)^k<br>\n*(((2::nat)^(k-l)<em>f)</em>((2^k)*f)-((2^k)*f)-((2::nat)^(k-l)*f)+((2::nat)^(2<em>k-l))</em>f^2)<br>\n=<br>\n      (2::nat)^k *(((2::nat)^(2<em>k-l+1)</em>(f^2))-((2^k)*f)-((2::nat)^(k-l)*f))\"<br>\n  using assms<br>\n  apply transfer<br>\n  oops</p>\n<p>(*<br>\n 0 ≤ l ⟹<br>\n       0 ≤ k ⟹<br>\n       l &lt; k ⟹<br>\n       1 ≤ l ⟹<br>\n       0 ≤ f ⟹<br>\n       2 ^ nat k * (tsub (tsub (2 ^ nat (tsub k l) * f * (2 ^ nat k * f))<br>\n(2 ^ nat k * f)) (2 ^ nat (tsub k l) * f) + 2 ^ nat (tsub (2 * k) l) * f ^<br>\nnat 2) =<br>\n       2 ^ nat k * tsub (tsub (2 ^ nat (tsub (2 * k) l + 1) * f ^ nat 2) (2<br>\n^ nat k * f)) (2 ^ nat (tsub k l) * f)<br>\n*)</p>\n<p>However, as you can see, transfer can hardly help to overcome the problem<br>\nrelated to the fact that minus behaves differently on nat and the subset of<br>\nnatural numbers in the type int (as already communicated in the previous<br>\nreply:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2020-June/msg00009.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2020-June/msg00009.html</a>).<br>\nTherefore, even if the theorem that involves minus holds both on int and<br>\nnat, transferring the results will not be trivial. If, for some reason, it<br>\nis easier to prove a theorem on int with minus replaced by \"tsub=max 0 (k -<br>\nl)\", then, of course, it is sensible to use transfer. However, I doubt that<br>\nthis will be the case very often. Nonetheless, this remark does not exhaust<br>\nall possibilities of how transfer can be used to attack the problem.<br>\nPerhaps, someone else will be able to provide a more creative approach to<br>\nthe solution of this problem (I guess, ideally, one would wish to build the<br>\ninfrastructure around transfer in a manner such that it provides additional<br>\ngoals that indicate that all applications of binary minus remain<br>\nnon-negative while preserving the original minus operation on the type int<br>\nin the primary goal after the application of transfer).</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 294829610,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246007
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear Mikhail Chekhov/ All,</p>\n<p>Many thanks for your comments on transfer.<br>\nIndeed, it seems that the way \"-\" is defined for naturals makes transfer <br>\nnot work here.</p>\n<p>I have now solved my issues in the following way:</p>\n<p>to prove various algebraic expressions involving something of the form <br>\nx-y where x, y are naturals, I first showed that x&gt;y so that I could <br>\nstick to naturals instead of switching to integers.<br>\nAfter including all these proofs which happened to work in my context, <br>\nnow everything works.</p>\n<p>(perhaps this might be of help to someone else!)</p>\n<p>Best wishes,<br>\nAngeliki</p>",
        "id": 294829656,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246031
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>Could someone please help with<br>\nlifting/transfer of types- there should be some way to do this <br>\nautomatically?</p>\n<p>In particular, I need a couple of simple algebraic equalities (A, B <br>\nbelow)<br>\nthe proofs of which here (surprisingly) only work if the constant 2 is <br>\ndefined<br>\nas type integer. How do I get these with the type changed to natural <br>\n(2::nat) ?</p>\n<p>lemma A:<br>\n   assumes \"k&gt;l\" \"l≥1\"<br>\nshows \" ( 2::int)^k *( (( 2::int)^(k-l)  * f )*(( 2^k ) * f) -(( 2^k ) * <br>\nf)<br>\n-(( 2::int)^(k-l)* f -(1::int))<br>\n+(( 2::int)^(2*k -l) ) *f^2 -1 ) =<br>\n( 2::int)^k *\n( (( 2::int)^(k-l)  * f )*(( 2^k ) * f) -(( 2^k ) * f) -(( 2::int)^(k-l) </p>\n<p>* f) +(1::int)<br>\n+(( 2::int)^(2*k -l) ) *f^2 -1 ) \"<br>\n   using assms<br>\n   by (simp add: )</p>\n<p>lemma B:<br>\n   assumes \"k&gt;l\" \"l≥1\"<br>\nshows \"( 2::int)^k *( (( 2::int)^(k-l)  * f )*(( 2^k ) * f) -(( 2^k ) * <br>\nf)<br>\n-(( 2::int)^(k-l)  * f) +(( 2::int)^(2*k -l) ) *f^2 )<br>\n=  ( 2::int)^k *( (( 2::int)^(2*k-l+1)  *( f^2 )) -(( 2^k ) * f) -(( <br>\n2::int)^(k-l)  * f))\"<br>\n   using assms<br>\napply (simp add: algebra_simps power2_eq_square )<br>\n   by (metis Nat.add_diff_assoc Suc_1 less_imp_le_nat mult.right_neutral <br>\nmult_Suc_right power_add)</p>\n<p>Thank you,<br>\nBest,<br>\nAngeliki</p>",
        "id": 294830144,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246246
    }
]