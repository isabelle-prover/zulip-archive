[
    {
        "content": "<p>From: Sigurd Torkel Meldgaard &lt;<a href=\"mailto:stm@cs.au.dk\">stm@cs.au.dk</a>&gt;<br>\nI am trying to use Isabelle as a part of a verification tool (for<br>\ncrypto multi-party protocols).</p>\n<p>The basic idea is that my analysis tool reads a source file, and<br>\noutputs a proof burden in Isabelle (using the Simpl library).<br>\nNow it should be possible to write a proof, and have that checked<br>\nbefore the program runs.</p>\n<p>What is the best way to call Isabelle from the command-line and have a<br>\nbinary result (proof verified or not)?<br>\nAre there any projects with a similar structure that I could learn from?</p>\n<p>Thanks<br>\nSigurd Meldgaard</p>",
        "id": 294081936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830964
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:Christian.Sternagel@uibk.ac.at\">Christian.Sternagel@uibk.ac.at</a>&gt;<br>\nA different way of doing that would be the following:</p>\n<p>1) formalize a function (let's call it 'cert') within Isabelle, that reads some<br>\nrepresentation your prove burdon (in our project we use XML) and returns True<br>\nof False.</p>\n<p>2) prove the lemmas 'cert input = True' implies a positive answer and 'cert<br>\ninput = False' implies a negative answer</p>\n<p>3) Use Isabelle's code-generator to get a program that uses the function 'cert'<br>\non it's input.</p>\n<p>cheers</p>\n<p>christian</p>\n<p>We used this workflow in <a href=\"http://cl-informatik.uibk.ac.at/software/ceta\">http://cl-informatik.uibk.ac.at/software/ceta</a></p>\n<p>Quoting Sigurd Torkel Meldgaard &lt;<a href=\"mailto:stm@cs.au.dk\">stm@cs.au.dk</a>&gt;:</p>\n<p>Christian Sternagel</p>",
        "id": 294081976,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830974
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nChristian Sternagel wrote:</p>\n<blockquote>\n<p>A different way of doing that would be the following:</p>\n<p>1) formalize a function (let's call it 'cert') within Isabelle, that reads some<br>\nrepresentation your prove burdon (in our project we use XML) and returns True<br>\nof False.</p>\n</blockquote>\n<p>If I understood Sigurd correctly, he meant that the Isabelle proof <br>\nshould be an interactive one, read from some theory file. Is that right?</p>\n<p>Quoting Sigurd Torkel Meldgaard &lt;<a href=\"mailto:stm@cs.au.dk\">stm@cs.au.dk</a>&gt;:</p>\n<blockquote>\n<blockquote>\n<p>What is the best way to call Isabelle from the command-line and have a<br>\nbinary result (proof verified or not)?</p>\n</blockquote>\n</blockquote>\n<p>The usual way to run proofs in batch-mode is \"isabelle usedir\". You can <br>\nget a basic setup by following the instructions for setting up document <br>\npreparation in the tutorial. But instead of the latex document, you <br>\nwould just be interested in the result, which you can read from the <br>\nreturn code of the \"isabelle usedir\" or \"isabelle make\" invocation.</p>\n<p>However, the problem is that you must also make sure that the theory <br>\nreally proves the statement that you are interested in... an empty <br>\ntheory will always be checked without errors...</p>\n<p>Alex</p>",
        "id": 294081981,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830977
    },
    {
        "content": "<p>From: Sigurd Torkel Meldgaard &lt;<a href=\"mailto:stm@cs.au.dk\">stm@cs.au.dk</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>A different way of doing that would be the following:</p>\n</blockquote>\n</blockquote>\n<p>Thank you for the advice, it seems to be not quite what I want - but<br>\nan interesting project you have going - thanks for the link</p>\n<blockquote>\n<p>If I understood Sigurd correctly, he meant that the Isabelle proof should be<br>\nan interactive one, read from some theory file. Is that right?</p>\n</blockquote>\n<p>Yes, that was something more in that direction that I thought about.</p>\n<blockquote>\n<p>The usual way to run proofs in batch-mode is \"isabelle usedir\". You can get<br>\na basic setup by following the instructions for setting up document<br>\npreparation in the tutorial. But instead of the latex document, you would<br>\njust be interested in the result, which you can read from the return code of<br>\nthe \"isabelle usedir\" or \"isabelle make\" invocation.</p>\n<p>However, the problem is that you must also make sure that the theory really<br>\nproves the statement that you are interested in... an empty theory will<br>\nalways be checked without errors...</p>\n</blockquote>\n<p>Oh yes - this is gonna be a problem - I will need a way to force it to<br>\nbe a proof of a certain statement ...<br>\nOne could concatenate the statement with the supposed proof before<br>\nfeeding it to Isabelle, but it seems inelegant, and not very robust.</p>\n<p>Would it be possible to script isabelle to do this via the ML-interface?</p>\n<p>Maybe I just need to leave it up to the user to not change the<br>\nstatement before he prove it ... that is not really what I want<br>\nthough.</p>\n<p>Thanks for the help</p>\n<p>Sigurd</p>",
        "id": 294081999,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830983
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Sigurd,</p>\n<blockquote>\n<blockquote>\n<p>However, the problem is that you must also make sure that the theory really<br>\nproves the statement that you are interested in... an empty theory will<br>\nalways be checked without errors...</p>\n</blockquote>\n<p>Oh yes - this is gonna be a problem - I will need a way to force it to<br>\nbe a proof of a certain statement ...<br>\nOne could concatenate the statement with the supposed proof before<br>\nfeeding it to Isabelle, but it seems inelegant, and not very robust.</p>\n</blockquote>\n<p>...and does not work:</p>\n<p>lemma main_thm: \"very hard to prove\"<br>\n(* end of proof obligation *)<br>\n(* start of \"proof\" *)<br>\noops</p>\n<p>lemma main_thm: \"True\"<br>\nby simp</p>\n<blockquote>\n<p>Would it be possible to script isabelle to do this via the ML-interface?<br>\nYes. In ML you can do pretty much everything.</p>\n</blockquote>\n<p>Alex</p>",
        "id": 294082039,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830995
    },
    {
        "content": "<p>From: Sigurd Torkel Meldgaard &lt;<a href=\"mailto:stm@cs.au.dk\">stm@cs.au.dk</a>&gt;<br>\nHi again</p>\n<p>I have dived into the ML of Isabelle, and I think that I have made<br>\nsomething that works, but would love your comments.<br>\nThe idea is that the user supplies the proof of the wanted theorem in<br>\nProof.thy, and that is imported into TestProofExists.thy that will<br>\nsearch for a proof of the wanted theorem using the FindTheorems.Solves<br>\nmechanism, and exit Isabelle with the proper exit code.</p>\n<p>Does it sound sound?</p>\n<p>Here is code checking that rev_rev_ident (or something like it) is<br>\nactually proved somewhere:</p>\n<hr>\n<p>theory TestProofExists<br>\nimports Main<br>\nbegin</p>\n<p>ML {*<br>\n  case FindTheorems.find_theorems<br>\n      (ProofContext.init @{theory})<br>\n      (SOME (Goal.init @{cterm \"True ‚üπ rev (rev xs) = xs\"}))<br>\n      (NONE)<br>\n      (true)<br>\n      [(true, FindTheorems.Solves)]<br>\n  of (NONE, _) =&gt; exit 127 (* Should never happen, as we remove duplicates *)<br>\n   | (SOME 0, _) =&gt; exit 1 (* Nothing was found *)<br>\n   | (SOME _, _) =&gt; exit 0 (* One ore more theorems can prove the statement! *)<br>\n  *}</p>\n<p>end</p>\n<hr>\n<p>What is the general way of turning a general term like \"rev (rev xs) =<br>\nxs\" into a proposition that Goal.init accepts like \"True ==&gt; rev (rev<br>\nxs) = xs\"?</p>\n<ul>\n<li>Sigurd</li>\n</ul>",
        "id": 294082128,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831020
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Sigurd,</p>\n<p>as far as I see the problem of \"rev (rev xs) = xs\" is that it is parsed<br>\nas type bool whereas a proposition must have type prop;  for this sake<br>\nthe judgement Trueprop :: bool =&gt; prop must be inserted (which is<br>\ntypically not printed explicitly).  The easiest way to achieve this is<br>\nto use the prop/cprop antiquotation instead of term/cterm.</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/I8QK8zYA4S5Pgb0FK4D3c6e0/signature.asc\">signature.asc</a></p>",
        "id": 294082163,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831032
    }
]