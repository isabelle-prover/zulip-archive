[
    {
        "content": "<p>From: Brandon Bohrer &lt;<a href=\"mailto:bbohrer@cs.cmu.edu\">bbohrer@cs.cmu.edu</a>&gt;<br>\nHello All,</p>\n<p>I've been trying to generate code for functions that are defined inside a<br>\nlocale, but Isabelle is refusing and the error suggests it is related to<br>\nthe type variables fixed by my locale. Here is a toy example of the problem:</p>\n<p>theory \"Codegen_Example\"<br>\n  imports Complex_Main<br>\nbegin<br>\n  locale Foo =<br>\n  fixes x::\"'type_param::finite\"<br>\n  fixes y::\"'type_param::finite\"</p>\n<p>context Foo begin<br>\nfun test1 :: \"int \\&lt;Rightarrow&gt; int\" where<br>\n  \"test1 n = n\"</p>\n<p>fun test2 :: \"'a \\&lt;Rightarrow&gt; 'a\" where<br>\n  \"test2 n = n\"</p>\n<p>fun test3 :: \"int \\&lt;Rightarrow&gt; 'type_param \\&lt;Rightarrow&gt; int\" where<br>\n  \"test3 n _= n\"<br>\nend</p>\n<p>interpretation bb: Foo Enum.finite_2.a\\&lt;^sub&gt;1 Enum.finite_2.a\\&lt;^sub&gt;2<br>\ndone</p>\n<p>(* Works *)<br>\nexport_code \"bb.test1\" in SML<br>\nexport_code \"bb.test2\" in SML</p>\n<p>(* Does Not Work*)<br>\nexport_code \"bb.test3\" in SML<br>\nend</p>\n<p>The last \"export_code\" line gives the error:</p>\n<p>Type<br>\nint ⇒ Enum.finite_2 ⇒ int<br>\nof constant \"Codegen_Example.Foo.test3\"<br>\nis too specific compared to declared type<br>\nint ⇒ ?'type_param::{} ⇒ int</p>\n<p>I don't understand this error, because generating code for a specific<br>\ninstance 'type_param = Enum.finite_2 seems like something that ought to<br>\nwork (and Enum.finite_2 supports the finite typeclass).</p>\n<p>Does anyone know a way to convince Isabelle to generate code in such a<br>\nsituation (or fix my confusion as to why this is not supported?). It would<br>\nactually be more convenient in my case to generate polymorphic code instead<br>\nof fixing 'type_param = Enum.finite_2, but of course that's cheating in the<br>\nsense that SML knows nothing about the finite typeclass thus cannot enforce<br>\nit.</p>\n<p>Incidentally, in the real code, the reason for fixing the type parameters<br>\nlike this are (1) I use the assumption 'type_param::finite very frequently<br>\nand it's nicer to only write it down once and (2) I frequently construct<br>\nvalues based on x and y (and a number of other arguments) so it would be<br>\nquite unwieldy if they were not locale parameters.</p>\n<p>Thanks in advance,<br>\nBrandon<br>\n<a href=\"/user_uploads/14278/CPdQqdNS5YmzbDmd89wqhZAP/Codegen_Example.thy\">Codegen_Example.thy</a></p>",
        "id": 294706334,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180753
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Brandon,</p>\n<p>The underlying reason is not related to type classes. It is simply that you must do some <br>\nwork to get the code generator work on interpretations of locales. You have three options:</p>\n<ol>\n<li>Export the code for the general constant Foo.test3 after having re-declared the code <br>\nequations on the theory level:</li>\n</ol>\n<p>lemmas [code] = Foo.test1.simps Foo.test2.simps Foo.test3.simps</p>\n<p>export_code Foo.test3 in SML</p>\n<p>In addition, if you want to get the specialisation for the interpretation, you must define <br>\na constant instead of the abbreviation:</p>\n<p>definition \"bb_test3 = bb.test3\"<br>\nexport_code bb_test3 in SML</p>\n<p>This option works only if your locale does not contain or inherit any \"assumes\" parts.</p>\n<ol start=\"2\">\n<li>You define at the time of interpretation new constants for all the terms you ever want <br>\nto execute. You must use global_interpretation instead of interpretation.</li>\n</ol>\n<p>global_interpretation bb: Foo Enum.finite_2.a⇩1 Enum.finite_2.a⇩2<br>\n   defines bb_test1 = bb.test1<br>\n     and bb_test2 = bb.test2<br>\n     and bb_test3 = bb.test3</p>\n<ol start=\"3\">\n<li>You use one of Peter Lammich's tools from Autoref or Monadic Refinement Framework that <br>\nautomates step 2. He can tell you more about this.</li>\n</ol>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294706340,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180756
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<ol start=\"3\">\n<li>You use one of Peter Lammich's tools from Autoref or Monadic<blockquote>\n<p>Refinement Framework that <br>\nautomates step 2. He can tell you more about this.</p>\n</blockquote>\n</li>\n</ol>\n<p>Unfortunately, the Locale_Code tool Andreas probably refers to does not<br>\nwork for this particular case. </p>\n<p>This tool was specifically developed for the needs of the Isabelle<br>\nCollection Framework. It's a workaround, and after being told that this<br>\nhack is of no general interest as it should be done properly, I did not<br>\ninvest more work to make it usable in more general cases.</p>\n<p>Anyway, 5 years later, the problem of generating code from locale<br>\ninterpretations <em>without</em> writing tons of boilerplate seems still not<br>\nsolved.</p>\n<p>So again, here the idea of my hack:</p>\n<p>Before and after interpreting a locale, record the existing Spec_Rules.<br>\nAfter interpreting the locale, make a diff to find the new spec rules,<br>\nand process them to automatically set up new code equations.</p>\n<p>However, as far as I can remember, the current implementation only<br>\ndeclares new code equations, without defining new constants. </p>\n<p>See \"$AFP/Collections/ICF/tools/Locale_Code_Ex\" and the Isabelle<br>\nCollection Framework for examples where it actually works and the three<br>\nlines </p>\n<p>setup Locale_Code.open_block<br>\ninterpretation ...<br>\nsetup Locale_Code.close_block</p>\n<p>declare dozens of code theorems, thus saving dozens of boilerplate declarations as would be required for method 1 or 2.</p>",
        "id": 294706396,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180763
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Brandon,</p>\n<blockquote>\n<ol start=\"2\">\n<li>You define at the time of interpretation new constants for all the<br>\nterms you ever want to execute. You must use global_interpretation<br>\ninstead of interpretation.</li>\n</ol>\n<p>global_interpretation bb: Foo Enum.finite_2.a⇩1 Enum.finite_2.a⇩2<br>\n  defines bb_test1 = bb.test1<br>\n    and bb_test2 = bb.test2<br>\n    and bb_test3 = bb.test3</p>\n</blockquote>\n<p>this approach is indeed canonical.</p>\n<p>CU,<br>\n    Florian</p>\n<blockquote>\n<ol start=\"3\">\n<li>You use one of Peter Lammich's tools from Autoref or Monadic<br>\nRefinement Framework that automates step 2. He can tell you more about<br>\nthis.</li>\n</ol>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>On 16/02/17 14:55, Brandon Bohrer wrote:</p>\n<blockquote>\n<p>Hello All,</p>\n<p>I've been trying to generate code for functions that are defined inside a<br>\nlocale, but Isabelle is refusing and the error suggests it is related to<br>\nthe type variables fixed by my locale. Here is a toy example of the<br>\nproblem:</p>\n<p>theory \"Codegen_Example\"<br>\n  imports Complex_Main<br>\nbegin<br>\n  locale Foo =<br>\n  fixes x::\"'type_param::finite\"<br>\n  fixes y::\"'type_param::finite\"</p>\n<p>context Foo begin<br>\nfun test1 :: \"int \\&lt;Rightarrow&gt; int\" where<br>\n  \"test1 n = n\"</p>\n<p>fun test2 :: \"'a \\&lt;Rightarrow&gt; 'a\" where<br>\n  \"test2 n = n\"</p>\n<p>fun test3 :: \"int \\&lt;Rightarrow&gt; 'type_param \\&lt;Rightarrow&gt; int\" where<br>\n  \"test3 n _= n\"<br>\nend</p>\n<p>interpretation bb: Foo Enum.finite_2.a\\&lt;^sub&gt;1 Enum.finite_2.a\\&lt;^sub&gt;2<br>\ndone</p>\n<p>(* Works *)<br>\nexport_code \"bb.test1\" in SML<br>\nexport_code \"bb.test2\" in SML</p>\n<p>(* Does Not Work*)<br>\nexport_code \"bb.test3\" in SML<br>\nend</p>\n<p>The last \"export_code\" line gives the error:</p>\n<p>Type<br>\nint ⇒ Enum.finite_2 ⇒ int<br>\nof constant \"Codegen_Example.Foo.test3\"<br>\nis too specific compared to declared type<br>\nint ⇒ ?'type_param::{} ⇒ int</p>\n<p>I don't understand this error, because generating code for a specific<br>\ninstance 'type_param = Enum.finite_2 seems like something that ought to<br>\nwork (and Enum.finite_2 supports the finite typeclass).</p>\n<p>Does anyone know a way to convince Isabelle to generate code in such a<br>\nsituation (or fix my confusion as to why this is not supported?). It<br>\nwould<br>\nactually be more convenient in my case to generate polymorphic code<br>\ninstead<br>\nof fixing 'type_param = Enum.finite_2, but of course that's cheating<br>\nin the<br>\nsense that SML knows nothing about the finite typeclass thus cannot<br>\nenforce<br>\nit.</p>\n<p>Incidentally, in the real code, the reason for fixing the type parameters<br>\nlike this are (1) I use the assumption 'type_param::finite very<br>\nfrequently<br>\nand it's nicer to only write it down once and (2) I frequently construct<br>\nvalues based on x and y (and a number of other arguments) so it would be<br>\nquite unwieldy if they were not locale parameters.</p>\n<p>Thanks in advance,<br>\nBrandon<br>\n</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/zB33v_rCKy4L6tTQOTAzoCeb/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294706428,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180771
    },
    {
        "content": "<p>From: Brandon Bohrer &lt;<a href=\"mailto:bbohrer@cs.cmu.edu\">bbohrer@cs.cmu.edu</a>&gt;<br>\nHi Andreas,</p>\n<p>Thank you for such a detailed response! Solution #2 got export_code to work<br>\n(my locale has assumptions, so #1 was not an option). I don't mind the<br>\nboilerplate code so long as it works.</p>\n<p>My locale also has some inductive predicates for which I would like to<br>\ngenerate code. Am I correct that the predicate compiler doesn't work inside<br>\nlocales that have assumptions? The following thread seems to suggest so:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-January/msg00063.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-January/msg00063.html</a></p>\n<p>If that's the case, it shouldn't be too hard to turn all my predicates into<br>\nfunctions. It just looks cleaner when they're written as inductive<br>\npredicates, so it would be nice if code generation for predicates happens<br>\nto work.</p>",
        "id": 294706517,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180801
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Brandon,</p>\n<p>code_pred does not work inside the locale, but you can use it with global_interpretation. <br>\nHere's an example:</p>\n<p>locale l = fixes x :: 'a assumes \"x = x\"<br>\ninductive (in l) is_x where \"is_x x\"<br>\nglobal_interpretation i: l \"0 :: nat\" defines i_is_x = \"i.is_x\" by unfold_locales simp</p>\n<p>declare i.is_x.intros[code_pred_intro]<br>\ncode_pred i_is_x by(rule i.is_x.cases)<br>\nthm i_is_x.equation</p>\n<p>The crucial line is the re-declaration of the intro rules.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294706531,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180806
    }
]