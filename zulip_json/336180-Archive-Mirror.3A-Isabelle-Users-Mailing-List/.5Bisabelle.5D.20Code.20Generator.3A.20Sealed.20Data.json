[
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:rene.neumann@in.tum.de\">rene.neumann@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>I have an algorithm that needs to receive state information to be passed<br>\ninbetween invocations from outside code. To actually prove something<br>\nmeaningful about this, I need this state data to preserve certain<br>\ninvariants. Now, as outside code is involved, I must also make sure,<br>\nthat this code has no way to tamper with the state.</p>\n<p>First I thought to use the approach given in Library/Dlist.thy: a<br>\nstructure annotated with an invariant. Unfortunately, the code generator<br>\nexports the constructor as part of signature. Hence, in outside code, I<br>\nsimply can write \"Dlist [1,2,2,2,2]\" -- and any code exported from<br>\nIsabelle is convinced that the underlying list is distinct, while in<br>\nfact it is not.</p>\n<p>Of course, in my code, I could enforce the invariant explictly, but this<br>\nis not feasible.</p>\n<p>So I need something similar to how the Isabelle core guarantees<br>\ntamper-free proofs: Do not export constructors you don't control.</p>\n<p>Is something like this possible with the code generator? Is it somehow<br>\npossible to say \"export definition, but not into signature\", and, more<br>\nimportant, \"export datatype, but in signature only as 'type'\".</p>\n<p>Thanks,<br>\nRené<br>\n<a href=\"/user_uploads/14278/Ni3DCJOgQHam99I6GESjYAVV/smime.p7s\">smime.p7s</a></p>",
        "id": 294268374,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916386
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi René,</p>\n<blockquote>\n<p>First I thought to use the approach given in Library/Dlist.thy: a<br>\nstructure annotated with an invariant.</p>\n</blockquote>\n<p>this is how you have to start anyway to deal with invariants.</p>\n<p>Unfortunately, the code generator</p>\n<blockquote>\n<p>exports the constructor as part of signature. Hence, in outside code, I<br>\nsimply can write \"Dlist [1,2,2,2,2]\" -- and any code exported from<br>\nIsabelle is convinced that the underlying list is distinct, while in<br>\nfact it is not.</p>\n</blockquote>\n<p>Currently it is indeed assumed that »client code« knows how to deal with<br>\ngenerated code.</p>\n<p>As a workaround, you can do something like (e.g. in SML):</p>\n<p>structure Generated_Code =<br>\nstruct<br>\n  &lt;generated code&gt;<br>\nend</p>\n<p>signature FOO =<br>\nsig<br>\n  &lt;what is really needed for client code without abstract constructors&gt;<br>\nend</p>\n<p>structure Foo: FOO =<br>\nstruct<br>\n  open Generated_Code<br>\nend</p>\n<p>Future Isabelle releases will minimize their exports.  In the more<br>\nremote future this could also be used as a vehicle to prevent export of<br>\nabstract constructors entirely.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/ORMGEy0SKRwq7Ckn1pTX2OkS/signature.asc\">signature.asc</a></p>",
        "id": 294268745,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916496
    }
]