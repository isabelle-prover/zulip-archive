[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<blockquote>\n<p>So my question is: Is it possible to introduce different 'code_unfolds'<br>\nfor different target languages?</p>\n</blockquote>\n<p>this is not possible.  In case you need different preprocessor setups,<br>\nyou can provide separate theories which tweak the standard setup by<br>\nmeans of code_unfold / code_unfold del, and (not) import them as desired.</p>\n<p>Personally I am sceptical whether such specialised optimisations are<br>\nworth the effort -- but don't take this remark too seriously.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/AMpR3eWQO3aVlom_qL1GIPnd/signature.asc\">signature.asc</a></p>",
        "id": 294099285,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833265
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHi,</p>\n<p>if I understand correctly, the attribute 'code_unfold' introduces <br>\nsomething like a (pre)compiler optimization, that is, some <br>\neasy-to-reason-about but inefficient code is replaced by a more <br>\nefficient one.</p>\n<p>Now, there are maybe different \"efficiency\"-concerns for different <br>\nprogramming languages. Lets take the example of 'concat(map xs)'. In <br>\ntheory List we have</p>\n<p>lemma concat_map_code[code_unfold]:<br>\n   \"concat(map f xs) = concat_map f xs\" ...</p>\n<p>where 'concat_map' is defined by</p>\n<p>primrec<br>\n   concat_map :: \"('a =&gt; 'b list) =&gt; 'a list =&gt; 'b list\"<br>\nwhere<br>\n   \"concat_map f [] = []\" |<br>\n   \"concat_map f (x#xs) = f x @ concat_map f xs\"</p>\n<p>While I think that this is perfectly okay (and maybe even preferable in <br>\norder to exploit lazyness) for Haskell, for a strict language (like <br>\nOCaml) I would prefer the following implementation:</p>\n<p>primrec<br>\n   rev_append :: \"'a list =&gt; 'a list =&gt; 'a list\"<br>\nwhere<br>\n   \"rev_append [] ys = ys\" |<br>\n   \"rev_append (x#xs) ys = rev_append xs (x#ys)\"</p>\n<p>primrec<br>\n   concat_map' :: \"('a =&gt; 'b list) =&gt; 'b list =&gt; 'a list =&gt; 'b list\"<br>\nwhere<br>\n   \"concat_map' f res [] = rev res\" |<br>\n   \"concat_map' f res (x#xs) = concat_map' f (rev_append (f x) res) xs\"</p>\n<p>lemma rev_append_rev: \"rev_append xs ys = rev xs @ ys\" by (induct xs <br>\narbitrary: ys) auto</p>\n<p>lemma concat_map'_conv: \"concat_map' f xs ys = rev xs @ concat(map f ys)\"<br>\nby (induct ys arbitrary: xs) (simp_all add: rev_append_rev)</p>\n<p>lemma concat_map_code_strict[code_unfold]:<br>\n   \"concat(map f xs) = concat_map' f [] xs\"<br>\nunfolding concat_map'_conv by simp</p>\n<p>So my question is: Is it possible to introduce different 'code_unfolds' <br>\nfor different target languages?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294102175,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834116
    }
]