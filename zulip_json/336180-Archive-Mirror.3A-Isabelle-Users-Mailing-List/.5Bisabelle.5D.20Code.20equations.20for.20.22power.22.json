[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>I just noticed that the \"power\" function is exported as</p>\n<p>power :: forall a. (Power a) =&gt; a -&gt; Nat -&gt; a;<br>\npower a n =<br>\n   (if equal_nat n zero_nat then one<br>\n     else times a (power a (minus_nat n one_nat)));</p>\n<p>This looks pretty inefficient to me; something like iterated squaring <br>\nshould be much faster, and it's pretty easy to do. However, this only <br>\nworks in the type class mult_monoid; power, on the other hand, is <br>\ndefined in the type class \"power\". (the difference is essentially that <br>\nthe latter does not demand associativity, if I am not mistaken)</p>\n<p>Is it still possible to use the more efficient iterative squaring when <br>\napplicable? I attached something using code_unfold, but I'm not sure if <br>\nthat really does what one would want it to do.</p>\n<p>Moreover, for rational numbers, one could optimise this even futher: <br>\nmultiplication on rational numbers reduces the numerator and denominator <br>\nafter the multiplication. In the case of \"power\", this is unnecessary, <br>\nsince the numerator and denominator of the result will always be coprime <br>\nif they were coprime before. Perhaps this would be a worthwhile <br>\noptimisation?</p>\n<p>Lastly, I was wondering whether there was something like \"divmod\" in <br>\nIsabelle, i.e. an operation that returns both the quotient and the <br>\nremainder, since most languages have a corresponding operation that is <br>\nmore efficient than computing the two separately.</p>\n<p>Cheers,</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/VwnyElQEWtKvOL9rAijddBvn/MyPower.thy\">MyPower.thy</a></p>",
        "id": 294664615,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171261
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Manuel,</p>\n<blockquote>\n<p>I just noticed that the \"power\" function is exported as</p>\n<p>power :: forall a. (Power a) =&gt; a -&gt; Nat -&gt; a;<br>\npower a n =<br>\n   (if equal_nat n zero_nat then one<br>\n     else times a (power a (minus_nat n one_nat)));</p>\n<p>This looks pretty inefficient to me; something like iterated squaring should be much<br>\nfaster, and it's pretty easy to do. However, this only works in the type class<br>\nmult_monoid; power, on the other hand, is defined in the type class \"power\". (the<br>\ndifference is essentially that the latter does not demand associativity, if I am not<br>\nmistaken)<br>\nmult_monoid assumes associativity of and neutrality of 1 for times. power does not impose <br>\nany constraints; it is a superclass of mult_monoid.</p>\n</blockquote>\n<blockquote>\n<p>Is it still possible to use the more efficient iterative squaring when applicable? I<br>\nattached something using code_unfold, but I'm not sure if that really does what one would<br>\nwant it to do.<br>\nThe code_unfold works if the call to power in the code equations is types with something <br>\nof sort mult_monoid. So if the code equation uses power on one of the standard numeric <br>\ntypes, everything is fine. But if you use power polymorphically for some 'a, then this <br>\ndoes not work if mult_monoid is not a supersort of 'a's sort. For example, if you have <br>\nsomething like</p>\n</blockquote>\n<p>definition map_power :: \"'a :: power list =&gt; 'a list\"<br>\n   where \"map_power = map power\"</p>\n<p>then if you use map_power, you will end up with the original slow implementation.</p>\n<blockquote>\n<p>Moreover, for rational numbers, one could optimise this even futher: multiplication on<br>\nrational numbers reduces the numerator and denominator after the multiplication. In the<br>\ncase of \"power\", this is unnecessary, since the numerator and denominator of the result<br>\nwill always be coprime if they were coprime before. Perhaps this would be a worthwhile<br>\noptimisation?<br>\nCustom implementations for power are not possible with the current setup. You can have <br>\ntype-dependent implementations for a function only if that function is a type class <br>\nparameter (unless you play some sophisticated tricks like in the Containers AFP entry). <br>\n From what I can see, it does not seem reasonable to make power a type class parameter, <br>\nbecause then power cannot be a superclass of mult_monoid any more (you'd have to add power <br>\nas a type class parameter to the whole algebraic type class hierarchy). But you could <br>\nachieve something similar like this:</p>\n</blockquote>\n<p>class power_impl = power +<br>\n   fixes power_impl :: \"'a =&gt; nat =&gt; 'a\"<br>\n   assumes power_impl: \"power = power_impl\"</p>\n<p>declare power_impl [code]</p>\n<p>Then, of course, you have to instantiate the new class power_impl for all types that <br>\ninstantiate power and all users have to do the same for their own types. Unfortunately, we <br>\ndo not (yet) have a mechanism to instantiate such definitional type classes automatically. <br>\nWith this approach, you could declare custom code equations for instances like rat.</p>\n<blockquote>\n<p>Lastly, I was wondering whether there was something like \"divmod\" in Isabelle, i.e. an<br>\noperation that returns both the quotient and the remainder, since most languages have a<br>\ncorresponding operation that is more efficient than computing the two separately.<br>\nThere are various specialised divmod constants in HOL, e.g., divmod_integer, <br>\nsemiring_numeral_div_class.divmod and Divides.divmod_nat, but no systematic, algebraic <br>\ntreatment.</p>\n</blockquote>\n<p>Best,<br>\nAndreas</p>",
        "id": 294664715,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171285
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI guess that's a pretty good compromise, isn't it? Most of the time, <br>\nexported code using the \"power\" operation will probably be dealing with <br>\ntypes that fulfil at least monoid_mult, and then this fast variant could <br>\nbe used.</p>\n<p>Perhaps this should be put in the library?</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294664737,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171297
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>I think that this can work for power, but it can also lead to surprises because the <br>\nrewrite does not trigger always and users then have to understand the whole setup to find <br>\nout. I had experimented with such rewrites for subset tests (end of theory <br>\nLibrary/Cardinality), but this never worked as well as I had hoped, because the rewrite <br>\nneeded the sort card_UNIV, which was hardly present in any code equation.</p>\n<p>René Thiemann and Christian Sternagel faced the same problem for linorders and <br>\ncomparators. They have implemented a custom function in ML that transforms the code <br>\nequations, but users have to call this manually (see their ITP2015 paper). This approach <br>\nis less convenient, but more robust.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294664757,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171303
    },
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear Manuel,</p>\n<p>If you care about efficiency, you might also have a look at improved code equations for divmod, e.g., under</p>\n<p><a href=\"http://afp.sourceforge.net/browser_info/current/AFP/Algebraic_Numbers/Improved_Code_Equations.html\">http://afp.sourceforge.net/browser_info/current/AFP/Algebraic_Numbers/Improved_Code_Equations.html</a></p>\n<p>for Isabelle 2015</p>\n<p>and under </p>\n<p><a href=\"http://afp.sourceforge.net/browser_info/devel/AFP/Algebraic_Numbers/Improved_Code_Equations.html\">http://afp.sourceforge.net/browser_info/devel/AFP/Algebraic_Numbers/Improved_Code_Equations.html</a><br>\n<a href=\"http://afp.sourceforge.net/browser_info/devel/AFP/Algebraic_Numbers/Divmod_Int.html\">http://afp.sourceforge.net/browser_info/devel/AFP/Algebraic_Numbers/Divmod_Int.html</a></p>\n<p>for Isabelle 2016-RC0.</p>\n<p>Best,<br>\nRené</p>",
        "id": 294664874,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171371
    }
]