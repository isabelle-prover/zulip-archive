[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHello,</p>\n<p>Generation of ML code from Isabelle mimics type classes by passing <br>\naround explicit records containing the functions specific to the type class.</p>\n<p>E.g., you might get a function \"inner_product A_ a b = map (#times A_) <br>\n(zip a b)\" (roughly).</p>\n<p>This works well, however, I noticed that the resulting code can be very <br>\ninefficient because the same records are constructed over and over. For <br>\nexample, the term \"[enumhd,enumhd,enumhd,enumhd,enumhd,enumhd] :: <br>\n(bool<em>bool</em>bool<em>bool</em>bool) list\" (where enumhd is some constant we <br>\ndefined using typeclass enum, the details are immaterial here) generates <br>\nthe code</p>\n<p>val code = [ enumhd<br>\n      (Enum.enum_prod Enum.enum_bool<br>\n        (Enum.enum_prod Enum.enum_bool<br>\n          (Enum.enum_prod Enum.enum_bool<br>\n            (Enum.enum_prod Enum.enum_bool Enum.enum_bool)))),</p>\n<p>... repeated six times ... ]</p>\n<p>(Demonstrated in the attached Scratch.thy)</p>\n<p>The effect of this is two-fold:</p>\n<p>* The generated code becomes much longer and thus compiles potentially<br>\n    very slowly (I had a term in my application that was ~2500 lines of<br>\n    code, and became ~150 lines after removing the repeated type class<br>\n    generation code. The 2500 lines took ~40-60 seconds to compile which<br>\n    means that a simple \"by eval\" takes that long.)</p>\n<p>* A runtime overhead is incurred. E.g., the Enum.enum_prod function<br>\n    above is internally producing products of lists over an over again.<br>\n    This could be prohibitive if the Enum.enum_prod (or similar) occurs<br>\n    in a function that is used in a loop.</p>\n<p>I would have expected code like this:</p>\n<p>val code = let val enum1 = (Enum.enum_prod Enum.enum_bool<br>\n            (Enum.enum_prod Enum.enum_bool<br>\n              (Enum.enum_prod Enum.enum_bool<br>\n                (Enum.enum_prod Enum.enum_bool Enum.enum_bool))))</p>\n<p>val enumhd1 = enumhd enum1</p>\n<p>in [enumhd1,enumhd1,enumhd1,enumhd1,enumhd1,enumhd1] end</p>\n<p>This would compute every class only once (and if enumhd creates <br>\ntypeclasses, this would also be done only once during the computation of <br>\nenumhd1).</p>\n<p>(The general case would be: \"f::args=&gt;result\" becomes \"fun f <br>\n&lt;typeclasses&gt; = let &lt;compute type classes and instantiate constants&gt; in <br>\nfn args =&gt; &lt;code&gt; end\". This way, invoking \"val f1 = f &lt;typeclasses&gt;\" <br>\nalready computes all recursively type classes, and then \"f1 args\" can be <br>\nused several times without recomputing the type classes.)</p>\n<p>My questions:</p>\n<p>* Is there a way to tell the code generator to do things more<br>\n    efficiently? (E.g., the way I described.)</p>\n<p>* Perhaps future versions of the code generator could do this? (I<br>\n    don't know if the code generator is still being developed.)</p>\n<p>Best wishes,<br>\nDominique.<br>\n<a href=\"/user_uploads/14278/4yQo3xTPUSlhVGLHobK_1Ldi/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294757327,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198081
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Dominique,</p>\n<p>Am 21.05.19 um 12:08 schrieb Dominique Unruh:</p>\n<blockquote>\n<p>Generation of ML code from Isabelle mimics type classes by passing<br>\naround explicit records containing the functions specific to the type<br>\nclass.</p>\n<p>This works well, however, I noticed that the resulting code can be very<br>\ninefficient because the same records are constructed over and over.</p>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p>My questions:</p>\n<p>* Is there a way to tell the code generator to do things more<br>\n   efficiently? (E.g., the way I described.)</p>\n</blockquote>\n<p>one approach is to provide explicit local definitions in code equations,<br>\ne. g.</p>\n<p>lemma [code]:<br>\n  ‹f x = let e = (enum :: …) in …›</p>\n<p>Another possibility is to provide monomorphic abbreviations, e. g.</p>\n<p>definition min_int :: ‹int =&gt; int =&gt; int›<br>\n  [code_abbrev]: \"min_int = min\"</p>\n<p>lemma [code]:<br>\n  \"min_int k l = …\"</p>\n<p>Or a combination of both.  It depends on the context what is actually<br>\napplicable.</p>\n<blockquote>\n<p>* Perhaps future versions of the code generator could do this? (I<br>\n   don't know if the code generator is still being developed.)</p>\n</blockquote>\n<p>Ocassionally there are still things happening.  But not with a big<br>\nagenda in mind.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/JHXnvo-4L2qwwxVRNV62jkGp/signature.asc\">signature.asc</a></p>",
        "id": 294757401,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198112
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi Florian,</p>\n<p>thank you for your suggestions. Unfortunately, after a lot of <br>\nexperiments I conclude that both approaches do not work in my case:</p>\n<blockquote>\n<p>lemma [code]:<br>\n   ‹f x = let e = (enum :: …) in …›</p>\n</blockquote>\n<p>I have written a conversation that does this automatically and added it <br>\nto the codegeneration preprocessor. While that works (meaning, the code <br>\nresulting code, by manual inspection, has less duplication), it does not <br>\nhelp if the subgoal that is to be solved by \"by eval\" is large and thus <br>\ncontains a lot of recomputation of type classes. (In my case, the <br>\nsubgoal is the result from running the simplifier and there is no way to <br>\nmanually make a better subgoal.) I tried applying the aforementioned <br>\nconversion directly to the subgoal (via \"apply (tactic ...)\") but <br>\napplied to that eval just fails without error message (which is <br>\nsurprising since the goal before conversion could be solved by eval, <br>\nalbeit slowly). (I also tried \"by normalization\" which, to my surprise, <br>\ngives an exception related to the allocation of a string above the <br>\nmaximum supported size.)</p>\n<blockquote>\n<p>definition min_int :: ‹int =&gt; int =&gt; int›<br>\n   [code_abbrev]: \"min_int = min\"</p>\n<p>lemma [code]:<br>\n   \"min_int k l = …\"<br>\nThis approach does not work because there are a lot of different types <br>\nthat occur. (I am working with typed matrices, so types would be, e.g., <br>\n\"('a,'b) bounded\" (standing for bounded operator) with 'a,'b ranging <br>\nover a number of different types like bit, bit<em>bit, bit</em>(bit*bit), <br>\n(bit<em>bit)</em>bit etc. even within a single calculation (tensor products are <br>\ninvolved).</p>\n</blockquote>\n<p>Overall, my conclusion is that I see nothing that can be done on the <br>\nuser level. To the best of my understanding, a change in the serializer <br>\nwould be the best solution (because an inspection of the thingol values <br>\nthat are produced do not compute the type class instances, this happens <br>\nafter serialization). I assume that these inefficiencies will crop up <br>\nwhenever whenever the enum type class is used, although possibly not to <br>\nas extreme a degree as in my case. (It may be that most use cases will <br>\ntherefore not suffer from this.)</p>\n<p>Best wishes,<br>\nDominique.</p>\n<p>Best wishes,<br>\nDominique.</p>\n<p>On 5/21/19 10:36 PM, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Hi Dominique,</p>\n<p>Am 21.05.19 um 12:08 schrieb Dominique Unruh:</p>\n<blockquote>\n<p>Generation of ML code from Isabelle mimics type classes by passing<br>\naround explicit records containing the functions specific to the type<br>\nclass.</p>\n<p>This works well, however, I noticed that the resulting code can be very<br>\ninefficient because the same records are constructed over and over.<br>\n[...]</p>\n</blockquote>\n<blockquote>\n<p>My questions:</p>\n<p>* Is there a way to tell the code generator to do things more<br>\n    efficiently? (E.g., the way I described.)<br>\none approach is to provide explicit local definitions in code equations,<br>\ne. g.</p>\n</blockquote>\n<p>lemma [code]:<br>\n   ‹f x = let e = (enum :: …) in …›</p>\n<p>Another possibility is to provide monomorphic abbreviations, e. g.</p>\n<p>definition min_int :: ‹int =&gt; int =&gt; int›<br>\n   [code_abbrev]: \"min_int = min\"</p>\n<p>lemma [code]:<br>\n   \"min_int k l = …\"</p>\n<p>Or a combination of both.  It depends on the context what is actually<br>\napplicable.</p>\n<blockquote>\n<p>* Perhaps future versions of the code generator could do this? (I<br>\n    don't know if the code generator is still being developed.)<br>\nOcassionally there are still things happening.  But not with a big<br>\nagenda in mind.</p>\n</blockquote>\n<p>Hope this helps,<br>\n  Florian<br>\n</p>\n</blockquote>",
        "id": 294757778,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198272
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Dominique,</p>\n<p>I was not aware that you are using the eval method here.</p>\n<p>Maybe something can be done by avoiding enum somehow altogether; is your<br>\nspecification somewhere available for inspection?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/fGaTeb6cJmbMbItWNtutcUzm/signature.asc\">signature.asc</a></p>",
        "id": 294758031,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198364
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi Florian,</p>\n<p>sorry, I wasn't clear about my use of eval...</p>\n<p>Yes, the code is available on GitHub. But it is part of a rather complex <br>\nwhole.</p>\n<p>The repository is <a href=\"https://github.com/dominique-unruh/qrhl-tool\">https://github.com/dominique-unruh/qrhl-tool</a>, the most <br>\nrecent commit (6978604) shows the problem.</p>\n<p>The file with the problematic eval is examples/Teleport_Terse.thy <br>\n(besides others).</p>\n<p>The types on which I operate (('a,'b) Bounded and 'a linear_space) are <br>\ndefined in Bounded_Operators.thy and Complex_Inner_Product.thy, <br>\nrespectively (in the submodule isabelle-thys/Bounded_Operators).</p>\n<p>Those types represent bounded operators from Hilbert space 'a to Hilbert <br>\nspace 'b, and closed subspaces of 'a, respectively. Furthermore, a <br>\nconcrete Hilbert space is 'a ell2 (for any type 'a), the type of square <br>\nsummable functions 'a=&gt;complex.</p>\n<p>This is the general setting. In the specific case where 'a,'b are finite <br>\n(more specifically, enum), ('a ell2,'b ell2) Bounded can be represented <br>\nby matrices (and 'a ell2 subspace as a span of vectors).  For this <br>\nspecific case, I developed the theory QRHL_Code.thy to automate <br>\ncomputations in this finite case (using the matrix code from <br>\nAFP/Jordan_Normal_Form under the hood). Since the types Bounded and <br>\nlinear_space are not just for the finite case but a general theory of <br>\nHilbert spaces (and similar), I cannot replace them by something simpler <br>\njust for the sake of code generation (e.g., the goal in <br>\nTeleport_Terse.thy is a verification condition that arises from the <br>\nsemantics of a quantum language).</p>\n<p>The line \"apply (simp add: prepare_for_code)\" rewrites the verification <br>\ncondition (which is not directly computable because it refers to <br>\noperators operating on variables in an infinite-dimensional quantum <br>\nmemory) into an expression involving only operators on finite <br>\ndimensional Hilbert spaces. Unfortunately, this rewriting leads to a <br>\nvery large term because a lot of auxiliary operators are introduced to <br>\n\"move\" the applied operations to the right quantum variables (operators <br>\nfor swapping registers and for \"doing associativity\").</p>\n<p>The resulting eval then struggles with a very large term. But most of <br>\nthe runtime for compiling and running the code actually comes from the <br>\nduplication. (This I know because I tried generating the code for that <br>\nsubgoal using export_code, and then edited the code manually to avoid <br>\nduplications, and the result was much shorter and faster.)</p>\n<p>I have tried the following solutions:</p>\n<p>* Writing simplification rules that rewrite the monster goal into one<br>\n    that directly uses only the operations from AFP/Jordan_Normal_Form<br>\n    (i.e., direct matrix operations). That is, I don't have any code<br>\n    equations for Bounded and linear_space any more. I committed this in<br>\n    branch experiment-code-rewrite. Unfortunately, this leads to a term<br>\n    that contains lots of enum-constructions again, and running eval on<br>\n    that term takes ages (or doesn't terminate). Also, even if that<br>\n    approach would work, it is somewhat unsatisfactory because it means<br>\n    that, if the enduser of my theories writes a new definition of a<br>\n    function involving operators (e.g., definition square x = x * x),<br>\n    then they have to also add a simplification rule for expanding it.<br>\n    The automatic \"[code]\" that is part of the definition command won't<br>\n    work.</p>\n<p>* I wrote a conversion that removed duplications from terms (using<br>\n    let) and applied it to the monster subgoal. I committed this in<br>\n    branch experiment-code-hacks. This has two problems: First, the code<br>\n    does not get much better because I can only avoid duplication it the<br>\n    same constant is reused, but not if different constants use the same<br>\n    type class. Second, it doesn't work: \"by eval\" fails without giving<br>\n    an error message (even though before applying the conversion, by<br>\n    eval succeeded). And \"by normalization\" (which is usually a goto<br>\n    point for debugging failing \"by eval\"s) fails with \"exception Size<br>\n    raised (line 171 of \"./basis/LibrarySupport.sml\")\" which if I am not<br>\n    mistaken, means that it tries to allocate a very large string.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294758118,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198394
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nA few things I forgot to mention:</p>\n<p>* There is a lot of Scala code etc in that repository, but for the<br>\n    problem at hand, only the Isabelle theories are relevant (in<br>\n    isabelle-thys, isabelle-thys/Bounded_Operators, examples).</p>\n<p>* The root of the repository contains a ROOTS file that can be used to<br>\n    open all those theories in Isabelle/jEdit.</p>\n<p>* The theories assume Isabelle2019, and AFP should be configured.<br>\n    (Tested with RC4)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294758136,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198400
    }
]