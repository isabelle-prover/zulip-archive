[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda,</p>\n<p>When certification fails, you can either call a slow implementation or abort with an <br>\nerror. The latter option occurs quite frequently in more advanced code setups. There is <br>\nthe constant Code.abort. Logically, \"Code.abort msg f\" is defined as \"f ()\", but during <br>\ncode generation, it raises an exception with msg as error message instead of evaluating f. <br>\nIn your case, the code equation could look like the following:</p>\n<p>lemma gcd_int_code [code]:<br>\n   \"gcd a b =<br>\n   (let (c,a',b') = untrusted_gcd a b<br>\n    in if valid_gcd_rel a b (c,a',b') then c<br>\n       else Code.abort (STR ''gcd: certification failed'' (%_. gcd a b)))\"</p>\n<p>Code.abort works well with code generation and evaluation with code_simp, but not with <br>\nnormalisation by evaluation. If you need the latter, you should declare your own constant <br>\nfor this specific error case and duplicate the setup for Code.abort.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294633715,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159305
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear code generation experts,</p>\n<p>Suppose I have a highly efficient greatest common divisor implementation <br>\nfor integers (based on modular arithmetic, subresultants, bit-shifting <br>\netc.), and I want to use it to boost our default gcd computation in <br>\nIsabelle. A good thing about gcd is that it can produce a certificate <br>\n(i.e. Bezout's identity) such that an untrusted result can be easily <br>\nverified. Therefore, I am thinking about building a certificate-based <br>\ncode equation for gcd:</p>\n<p>definition valid_gcd_rel :: \"int =&gt; int =&gt; int × int × int =&gt; bool\" <br>\nwhere<br>\n   \"valid_gcd_rel a b r= (let (c,a',b') =r in<br>\n     a≠0 ∧ b≠0 ∧ c&gt;0 ∧ c dvd ¦a¦ ∧ c dvd ¦b¦ ∧ ¦a¦<em>a' + ¦b¦</em>b'=c)\"</p>\n<p>lemma gcd_valid:<br>\n   fixes a b c a' b' :: int<br>\n   assumes \"valid_gcd_rel a b (c,a',b')\"<br>\n   shows \"gcd a b = c\"<br>\nsorry</p>\n<p>(*suppose this is an untrusted but very efficient implementation which<br>\n   produces gcd together with a certificate*)<br>\ndefinition untrusted_gcd :: \"int =&gt; int =&gt; int × int × int\" where<br>\n   \"untrusted_gcd a b = (if a=6 ∧ b=5 then (1,1,-1) else undefined)\"</p>\n<p>declare gcd_code_int [code del]</p>\n<p>lemma gcd_code[code]:<br>\n   \"gcd a b = (let<br>\n       (c,a',b') = untrusted_gcd a b<br>\n     in if valid_gcd_rel a b (c,a',b') then c else (SOME c. c=gcd a b)) \"<br>\nsorry</p>\n<p>Lemma gcd_valid and gcd_code should both be provable. And the value <br>\ncommand works just as expected:</p>\n<p>value \"gcd (6::int) 5\" (<em>1</em>)<br>\nvalue \"gcd (6::int) 4\" (<em>gcd 6 4</em>)</p>\n<p>That is, when \"valid_gcd_rel a b (c,a',b')\" is evaluated to be true, we <br>\nuse the result from untrusted_gcd, otherwise we leave the expression <br>\nunchanged. However, when I want to boost the gcd computation further <br>\nusing code_reflect:</p>\n<p>code_reflect Foo<br>\n   datatypes int=\"_\"<br>\n   functions \"gcd::int=&gt;int=&gt;int\"</p>\n<p>an error occurs because Eps has no code equation. Of course, in this <br>\ncase, I can resolve this problem by replacing \"(SOME c. c=gcd a b)\" with <br>\na \"slow\" but executable version of gcd (e.g. the default version), but <br>\nin general it is not convenient to build and certify even a slow version <br>\nevery time. Is there any way to cope with this problem?</p>\n<p>In general, there are many operations, such as ideal membership test, <br>\nwhose results can be easily verified by some certificates while a direct <br>\nimplementation (even a naive one) is very hard to verify within <br>\nIsabelle. I was wondering if this certificate-based approach can be a <br>\nway to improve execution efficiency of functions within Isabelle.</p>\n<p>Any comment/suggestion is greatly appreciated,<br>\nWenda</p>",
        "id": 294638704,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161225
    }
]