[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>I have a problem when I try to generate code from constants/functions<br>\ndefined inside a locale that fixes some parameter of function type.</p>\n<p>Consider the following (synthetic) example:</p>\n<p>locale test =<br>\n  fixes a::\"nat =&gt; nat\"<br>\nbegin<br>\n  fun test where<br>\n    \"test [] = (0::nat)\" |<br>\n    \"test (x#xs) = a(x + test xs)\"</p>\n<p>definition \"c = a (7::nat)\"<br>\nend</p>\n<p>(* Now I interpret this locale with some function: *)<br>\ndefinition \"nf x = x\"<br>\ninterpretation t: test nf .</p>\n<p>(* And use the resulting instance in some further definitions*)<br>\ndefinition \"some_fun l == t.c + t.test l\"</p>\n<p>(* Now I want to generate code for some_fun: *)</p>\n<p>(* First try: *)<br>\nexport_code some_fun in SML<br>\n*** No code equations for test.test, test.c<br>\n*** At command \"export_code\".</p>\n<p>(* Second try: *)<br>\nlemmas [code] = t.c_def t.test.simps<br>\n*** Partially applied constant on left hand side of equation<br>\n*** \"test.c nf ยบ<br>\n***  nf (number_nat_inst.number_of_nat<br>\n***       (Int.Bit1 (Int.Bit1 (Int.Bit1 Int.Pls))))\"<br>\n*** At command \"lemmas\".</p>\n<p>(* Finally I had to manually insert new constants and adjust the lemmas<br>\nfor the code-generator: *)<br>\ndefinition \"t=t.test\"<br>\ndefinition \"c = t.c\"</p>\n<p>lemmas [code] = t.test.simps[folded t_def]<br>\nlemmas [code] = t.c_def[folded c_def]</p>\n<p>lemmas [code unfold] = t_def[symmetric] c_def[symmetric]</p>\n<p>export_code some_fun in SML</p>\n<p>The final approach worked, but it is somewhat cumbersome to manually<br>\ninsert constants for each definition and interpretation of the locale.<br>\nIs there a simpler (i.e. more automatic) way ?</p>\n<p>Regards + Many thanks in advance for any hints<br>\n  Peter</p>",
        "id": 294075469,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828683
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Peter,</p>\n<p>the bad news are that there is no direct way to accomplish code<br>\ngeneration from equations stemming from interpretation.  The good news<br>\nare that you can use the optional \"where\" part of interpretation to<br>\nmanually accomplish this:</p>\n<p>locale test =<br>\n  fixes a :: \"nat =&gt; nat\"<br>\nbegin</p>\n<p>primrec test where<br>\n    \"test [] = (0::nat)\" |<br>\n    \"test (x#xs) = a(x + test xs)\"</p>\n<p>definition \"c = a (7::nat)\"</p>\n<p>end</p>\n<p>definition \"nf x = x\"</p>\n<p>(* define constants corresponding to the local specifications *)<br>\ndefinition \"t = test.test nf\"<br>\ndefinition \"c = test.c nf\"</p>\n<p>interpretation t: test nf where<br>\n  (* give these as equations *)<br>\n  \"test.test nf = t\"<br>\n  and \"test.c nf = c\"<br>\nproof<br>\nqed (simp_all add: t_def c_def)</p>\n<p>lemmas [code] = t.c_def t.test.simps</p>\n<p>definition \"some_fun l = t.c + t.test l\"</p>\n<p>export_code some_fun in SML file -</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Wt4gMUJRX7pfjG_PYix6eD_J/signature.asc\">signature.asc</a></p>",
        "id": 294075483,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828689
    }
]