[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>I tried out code generation for inductive predicates, and wonder when<br>\nthe generated code will terminate.</p>\n<p>In the code below, I inductively formulate the reflexive, transitive<br>\nclosure of a transition relation.<br>\nNo I want code to enumerate all the words that lead from one state to<br>\nanother. This works well<br>\nif there exists such words. However, if there exists no such word, the<br>\ngenerated code simply does not terminate.<br>\nThis is the same for the predicate w_nempty, that checks whether there<br>\nexists a word between two given states.</p>\n<p>So what happens here? When does the generated code terminate? And is<br>\nthere a simple way to generate code for \"w_nempty\" that terminates?</p>\n<p>Many thanks in advance for any hints,<br>\n  Peter</p>\n<p>-- \"A transition relation\"<br>\n  inductive_set d1 :: \"(nat * char * nat) set\" where<br>\n    \"(1,CHR ''a'',2) : d1\" |<br>\n    \"(2,CHR ''b'',2) : d1\"</p>\n<p>-- \"Reflexive, transitive closure\"<br>\n  inductive word where<br>\n    \"word \\&lt;delta&gt; q [] q\" |<br>\n    \"[| (q,a,qh):\\&lt;delta&gt;; word \\&lt;delta&gt; qh w q' |] ==&gt; word \\&lt;delta&gt; q<br>\n(a#w) q'\"</p>\n<p>-- \"Whether a word from q to q' exists\"<br>\n  inductive w_nempty where<br>\n    \"word \\&lt;delta&gt; q w q' ==&gt; w_nempty \\&lt;delta&gt; q q'\"</p>\n<p>code_module test<br>\n    contains<br>\n      test1 = \"word d1 1 _ 2\"<br>\n      test2 = \"word d1 2 _ 1\"<br>\n      test3 = \"%d q q'. w_nempty d q q'\"<br>\n  (*<br>\n    test4 = \"w_nempty d1 2 1\"  However, with this, code generation does<br>\nnot terminate.<br>\n  *)</p>\n<p>-- \"These behave as expected: \"<br>\n  ML {*<br>\n    DSeq.pull (test.test1);<br>\n    *}</p>\n<p>ML {*<br>\n    let val d = [(0,(#\"a\",1)), (1,(#\"b\",1))] in<br>\n      test.test3 d 0 1<br>\n    end<br>\n    *}</p>\n<p>-- \"These does not terminate:\"<br>\n  ML {*<br>\n    DSeq.pull (test.test2);<br>\n    *}<br>\n  ML {*<br>\n    let val d = [(0,(#\"a\",1)), (1,(#\"b\",1))] in<br>\n      test.test3 d 1 0<br>\n    end<br>\n    *}</p>",
        "id": 294076119,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828953
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHi Peter,</p>\n<p>The simple answer is, that code generation for inductive definitions<br>\nyields a functional version of what Prolog would give you, except that<br>\nthere is no unification, only matching. If you give your clauses to<br>\nProlog, you should see the same (non)termination behaviour as in Isabelle.</p>\n<p>Your example 2 does not terminate because there is no path from 2 to 1,<br>\nbut there is an edge from 2 to 2 and thus a recursive call with 2 and 1<br>\nis made etc. The fact that you don't need to answer the same query twice<br>\non the same branch is not part of a Prolog interpreter because you need<br>\nto tabulate your queries, which can be expensive. If you want it, you<br>\nwant \"tabled logic programming\", which Isabelle does not (yet?) provide.<br>\nHowever, you are not the only one who would like this, and Stefan<br>\nBerghofer has recently provided a theory of tabled transitive closure,<br>\nwhich can be used for code generation to avoid nontermination where the<br>\nanswer should be No. Unfortunately it did not quite make it into<br>\nIsabelle 2009, out any day now. But Stefan can send you a copy and it<br>\nshould solve your problem. (It is a little bit involved because you<br>\nessentially need to prove that it suffices to consider paths without loops).</p>\n<p>Tobias</p>\n<p>Peter Lammich wrote:</p>",
        "id": 294076169,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828978
    }
]