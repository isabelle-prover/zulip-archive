[
    {
        "content": "<p>From: Mark Wassell &lt;<a href=\"mailto:mpwassell@gmail.com\">mpwassell@gmail.com</a>&gt;<br>\nHello Andreas and Isabelle list,</p>\n<p>Thank you for your help with my last question. I have a follow up question:</p>\n<p>I would like to be able to generate code for inductive predicates that have<br>\nclauses with variable number of premises that mention the inductive<br>\npredicate being defined.</p>\n<p>A simple case:</p>\n<p>datatype D =<br>\n   DSingle nat | DMany \"nat list\"</p>\n<p>inductive S :: \"D ⇒ D ⇒ bool\" where<br>\n  \"S (DSingle x) (DSingle x)\" |<br>\n  \"List.list_all (λ(x,y). S (DSingle x) (DSingle y)) (zip xs ys) ⟹ S (DMany<br>\nxs) (DMany ys)\"</p>\n<p>For this I would like to generate a function S_i_o. Intuitively this should<br>\nbe possible.</p>\n<p>However the mode inference for S is only passing i-&gt;i-&gt;bool as a valid<br>\nmode. My rough understanding of how mode inference works (for example from<br>\n\"Turning inductive into equational specifications\") indicates i-&gt;o-&gt;bool is<br>\nconsistent. However I can see that the appearance of 'zip xs ys' is mixing<br>\nknown data (the xs) with unknown data (ys). Also its possible that<br>\nList.list_all is being considered as a side condition where, I believe, all<br>\nvariables need to be known.</p>\n<p>So my question is this: Why doesn't it infer i-&gt;o-&gt;bool where according to<br>\nthe mode inference rules it should?</p>\n<p>One solution is to by-pass this completely and define the predicate as:</p>\n<p>inductive S' :: \"D ⇒ D ⇒ bool\" where<br>\n  \"S' (DSingle x) (DSingle x)\" |<br>\n  \"S' (DMany []) (DMany [])\" |<br>\n  \"S' (DMany xs) (DMany ys) ==&gt; S' (DSingle x) (DSingle y) ==&gt;  S' (DMany<br>\n(x#xs)) (DMany (y#ys))\"</p>\n<p>However I would like to see if it can be made to work without doing this.</p>\n<p>I have also tried to define a version of list_all as an inductive predicate<br>\nand also a list_all_pair, as in</p>\n<p>inductive T :: \"D ⇒ D ⇒ bool\" where<br>\n  \"T (DSingle x) (DSingle x)\" |<br>\n  \"list_all_pair (λx y. T (DSingle x) (DSingle y)) xs ys ⟹ T (DMany xs)<br>\n(DMany ys)\"</p>\n<p>but without too much success. I could have missed something though.</p>\n<p>Cheers</p>\n<p>Mark</p>",
        "id": 294699092,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178585
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nDear Mark,</p>\n<p>There is already</p>\n<p>list_all2 :: \"('a ⇒ 'b ⇒ bool) ⇒ 'a list ⇒ 'b list ⇒ bool\"</p>\n<p>I'm not sure if this has the right setup.</p>\n<p>But be aware that there is a difference btw</p>\n<p>(1)  list_all (%(x, y). P x y) (zip xs ys) and<br>\n(2)  list_all2 P xs ys</p>\n<p>While (1) allows xs and ys to have different length, and P only needs<br>\nto hold on the smaller length, (2) enforces that both lists have the<br>\nsame length.</p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294699126,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178597
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThe predicate compiller cannot invert arbitrary functions or expressions, that <br>\nwould be magic. You need to be explicit about how ys is computed from xs. Your <br>\ncurrent specification is not even a function, for any xs, my suitable ys exist <br>\nbecause zip will truncate longer ys's. You have to phrase your precondition in <br>\nterms of relations that have the right mode (or via functions that compute the <br>\nys's, but that will not be possible because that involves S again. However, <br>\nthere is the predefined predicate</p>\n<p>listrel1p :: \"('a ⇒ 'a ⇒ bool) ⇒ 'a list ⇒ 'a list ⇒ bool\"</p>\n<p>for exactly this purpose in List.thy. You could now write</p>\n<p>listrel1p (λ(x,y). S (DSingle x) (DSingle y)) xs ys</p>\n<p>That should be executable. In the end, you should formulate the precondition in <br>\nthe most abstract style (eg via quantifiers) and prove the listrel1p version as <br>\na consequence for code generation.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/0EwfeEeclDl3oVpvivbQ_hmm/smime.p7s\">smime.p7s</a></p>",
        "id": 294699166,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178604
    },
    {
        "content": "<p>From: Mark Wassell &lt;<a href=\"mailto:mpwassell@gmail.com\">mpwassell@gmail.com</a>&gt;<br>\nTobias and Johannes, thank you for your responses.</p>\n<p>Unfortunately I haven't had much success today using List.list_all2 or<br>\nlistrel1p.</p>\n<p>I am a little puzzled as to how these were going to work as mode inference<br>\nwould have needed to 'pass though' these functions to make use of the mode<br>\ninformation for S (DSingle x) (DSingle y) occurrence inside the function.</p>\n<p>I am thinking that I might need to have an equivalent of List.list_all2<br>\ndefined as an inductive predicate so that mode information for this can be<br>\nused in the mode inference of S.</p>\n<p>For example:</p>\n<p>inductive list_all2_ind :: \"('a ⇒ 'b ⇒ bool) ⇒ 'a list ⇒ 'b list ⇒ bool\"<br>\nwhere<br>\n  \"list_all2_ind P [] []\" |<br>\n  \"list_all2_ind P xs ys ⟹ P x y ⟹  list_all2_ind P (x#xs) (y#ys)\"</p>\n<p>When I do code_pred for list_all2_ind it does tell me that the mode<br>\n(i -&gt; o -&gt; bool) -&gt; i -&gt; o -&gt; bool is consistent (the elimination rule for<br>\nthis being called list_all2_ind_FioB_i_o).</p>\n<p>Cheers</p>\n<p>Mark</p>",
        "id": 294699208,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178617
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYour solution should work. I though listrel1p was set up like that, but it is <br>\nslightly different.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/J8oMGMZDmcTU3KC1ApFbEH0m/smime.p7s\">smime.p7s</a></p>",
        "id": 294699223,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178622
    },
    {
        "content": "<p>From: Mark Wassell &lt;<a href=\"mailto:mpwassell@gmail.com\">mpwassell@gmail.com</a>&gt;<br>\nHi,</p>\n<p>Thank you for your help. If I add the following to the end of your<br>\nListall2.thy</p>\n<p>datatype D =<br>\n   DSingle nat | DMany \"nat list\"</p>\n<p>inductive S :: \"D ⇒ D ⇒ bool\" where<br>\n \"S (DSingle x) (DSingle (x+1))\" |<br>\n \"list_all2 (λx y. S (DSingle x) (DSingle y)) xs ys ⟹ S (DMany xs) (DMany<br>\nys)\"</p>\n<p>code_pred  [show_steps,  show_mode_inference,  show_invalid_clauses] S .</p>\n<p>I don't get the mode of (i-&gt;o-&gt;bool) which is the one that I am after. I<br>\nsee in the output that (o =&gt; i =&gt; bool) =&gt; o =&gt; i =&gt; bool is inferred for<br>\nlist_all2 however clause 2 of S violates i-&gt;o-&gt;bool.</p>\n<p>Is it ok to use the predicate that I am defining in the occurrence of<br>\nlist_all2? I am passing to list_all2 the function (λx y. S (DSingle x)<br>\n(DSingle y))</p>\n<p>I am also getting the following at the end of the output:</p>\n<p>exception Fail raised (line 74 of \"~~/src/HOL/Tools/Predicate_<br>\nCompile/predicate_compile_proof.ML\"): prove_param: No valid parameter term.</p>\n<p>Cheers</p>\n<p>Mark</p>",
        "id": 294701145,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179217
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:lukas.bulwahn@gmail.com\">lukas.bulwahn@gmail.com</a>&gt;<br>\nDear Mark,</p>\n<p>For higher-order predicates, we only allow single variables or<br>\nconstants as higher-order arguments.</p>\n<p>This might be mentioned in the ITP 2009 paper, and this certainly<br>\nshould be mentioned in my diploma thesis.</p>\n<p>I could reformulate your inductive predicate as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">datatype</span> <span class=\"n\">D</span> <span class=\"o\">=</span>\n   <span class=\"n\">DSingle</span> <span class=\"n\">nat</span> <span class=\"o\">|</span> <span class=\"n\">DMany</span> <span class=\"s\">\"nat list\"</span>\n\n<span class=\"k\">inductive</span> <span class=\"n\">S_aux</span> <span class=\"o\">::</span> <span class=\"s\">\"nat ⇒ nat ⇒ bool\"</span>\n<span class=\"kp\">and</span> <span class=\"n\">S</span> <span class=\"o\">::</span> <span class=\"s\">\"D ⇒ D ⇒ bool\"</span> <span class=\"kp\">where</span>\n <span class=\"s\">\"S (DSingle x) (DSingle y) ⟹ S_aux x y\"</span> <span class=\"o\">|</span>\n <span class=\"s\">\"S (DSingle x) (DSingle (x+1))\"</span> <span class=\"o\">|</span>\n <span class=\"s\">\"list_all2 S_aux xs ys ⟹ S (DMany xs) (DMany ys)\"</span>\n\n\n<span class=\"kn\">code_pred</span>  <span class=\"o\">[</span><span class=\"n\">show_steps</span><span class=\"o\">,</span>  <span class=\"n\">show_mode_inference</span><span class=\"o\">,</span>  <span class=\"n\">show_invalid_clauses</span><span class=\"o\">]</span> <span class=\"n\">S</span> <span class=\"ow\">.</span>\n\n<span class=\"kt\">thm</span> <span class=\"n\">S.equation</span>\n</code></pre></div>\n<p>So you can either use this definition and derive your introduction<br>\nrules from that, or you define it with your definition, introduce the<br>\nS_aux constant with the first introduction rule, and then derive the<br>\nintroduction rules from my definition and annotate them with<br>\ncode_pred_intro,</p>\n<p>For code generation, you can then unfold the S_aux_i_o constant in the<br>\nS_i_o equation and you will get a recursive equation for S_i_o that<br>\nlazily enumerates all solutions.</p>\n<p>Logically, there is no difference between your and my definition of S;<br>\ntechnically, the automatically derived induction rule probably looks<br>\ndifferent, and hence, one definition might be better suited than the<br>\nother (but that's something you must find out).</p>\n<p>Lukas</p>",
        "id": 294702113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179511
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:lukas.bulwahn@gmail.com\">lukas.bulwahn@gmail.com</a>&gt;<br>\nDear Mark,</p>\n<p>Tobias pointed out to me that list_all2 actually existed long before<br>\nthe new datatype package, which just happens to define the constant<br>\nnow automatically as it is the natural relator for lists.</p>\n<p>As I found out by a more precise look at the history, Tobias defined<br>\nthe list_all2 constant already in January 2000, i.e., in changeset<br>\n8115:c802042066e8 [1]. So the reason that there is no setup for<br>\nlist_all2 is probably due to the fact that I did not come across an<br>\nexample for the predicate compiler that uses list_all2 in 2009-2012;<br>\neven though Andreas Lochbihler and I used the predicate compiler<br>\nheavily for making the Jinja with threads semantics executable.</p>\n<p>I have put it on my todo list to add the setup for list_all2 for the<br>\npredicate compiler in HOL-Main; it will happen eventually.</p>\n<p>[1] <a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/c802042066e8\">http://isabelle.in.tum.de/repos/isabelle/rev/c802042066e8</a></p>\n<p>Lukas</p>",
        "id": 294702325,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179579
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Mark and Lukas,</p>\n<p>I did use list_all2 in JinjaThreads a lot, and the setup is already there. It's just not <br>\nin List.thy, but in ~~/src/HOL/Library/Predicate_Compile_Alternative_Defs.thy.</p>\n<p>Andreas</p>",
        "id": 294702927,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179781
    }
]