[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear all,</p>\n<p>for those of you who do not regularly check stackoverflow but might have<br>\nan answer to my question there (yes I am looking at you Florian ;) ) I'm<br>\nbrazenly posting the link to my question here</p>\n<p><a href=\"http://stackoverflow.com/q/32926842/476803\">http://stackoverflow.com/q/32926842/476803</a></p>\n<p>In short, my question is: What is the easiest way to generate code for a<br>\nsorting algorithm that sorts its argument in reverse order, while<br>\nbuilding on top of the existing List.sort?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294656368,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168174
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Christian,</p>\n<p>Here are my thoughts about List.sort &amp; friends:</p>\n<p>a) The first problem with List.sort and friends is that they are defined in the type class <br>\nlinorder, although their definitions could be made as well in the type class ord. Three <br>\nyears ago (2ada2be850cb), I have moved all the operations for red-black trees (RBT) into <br>\nthe linorder type class, precisely because I wanted to use them with other ordering <br>\nrelations. Ideally, the same should be done for List.sort and friends.</p>\n<p>For the time being, you can still avoid some of the overheads by using the foundational <br>\nconstant linorder.sort_key, which takes the order as an additional argument. So, you can <br>\npass in the dual order. With a single interpretation for the dual order, you should get <br>\nall the theorems you need. You can even define an abbreviation for it:</p>\n<p>interpretation dual!: linorder \"op ≥\" \"op &gt; :: _ :: linorder ⇒ _\" by(rule dual_linorder)<br>\nabbreviation \"rsort == linorder.sort_key op ≥ (λx. x)\"</p>\n<p>Unfortunately, code generation does not work out of the box, because the code setup has <br>\nonly been done for the type-class based instance. If List.sort was defined in the type <br>\nclass ord, one could simply re-declare the code equations (as I did for the RBT operations <br>\nin my AFP entry Containers). Alternatively, you can prove that sort &amp; friends are <br>\nparametric (as Peter did for RBT operations in his AFP entry Collections) and exploit <br>\nparametricity like he does, but my feeling is that this again requires unconditional <br>\nequations, i.e., a definition in ord.</p>\n<p>b) The second problem is that we want to implement List.sort with different algorithms <br>\nduring code generation. For linear orders, this is no problem, because the result is <br>\nunique. However, if we pass in a non-linear order, the outcome might depend on the <br>\nalgorithm. Thus, we can only do program refinement for linear orders. In that view, even <br>\nif we move List.sort to the type class ord, we still have problems, because we cannot <br>\nprove the code equations for arbitrary ordering relations any more.</p>\n<p>Ideally, we should separate the proving part from the code generation part. AFAICS, the <br>\nfollowing should work.</p>\n<ol>\n<li>\n<p>Move List.sort and friends to type class ord. For ease of use and compatibility, we can <br>\nadd sign constraints such that type inference infers the linorder sort constraints for <br>\nList.sort.</p>\n</li>\n<li>\n<p>Define a type 'a linorder of linear orders using typedef and an embedding</p>\n<p>linorder_of :: \"'a :: linorder itself =&gt; 'a linorder\"</p>\n</li>\n<li>\n<p>Define operations for sorting lists that are parametrised with the order from the type <br>\n'a linorder. Prove equations like \"List.sort_key == sort_key_impl TYPE('a)\".</p>\n</li>\n<li>\n<p>Adapt all the implementations for sorting such that they refine sort_key_impl rather <br>\nthan List.sort_key.</p>\n</li>\n</ol>\n<p>Apart from sorting, such a setup could be used for further improvements to the generated <br>\ncode. For example, one could refine the type 'a linorder to provide a comparator instead <br>\nof a comparison operation.</p>\n<p>I guess such a change requires quite a lot of work to be carried out on the whole <br>\nrepository. At the moment, I do not have the time to carry all this out, but if the issue <br>\nis pressing for you, you might want to try it yourself. But before you start, we should <br>\nalso ask Florian on his opinion.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294656925,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168413
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian, hi Andreas,</p>\n<p>I think there is one misperception concerning sort_key – it is not<br>\nparametrized by an order, but by a morphism:</p>\n<p>\"sort_key\" :: \"('a ⇒ 'b) ⇒ 'a list ⇒ 'a list\"</p>\n<p>Hence reverse sorting is difficult to accomplish unless you have a<br>\nstructure where each element has a dual wrt. the underlying order.</p>\n<p>Hence the only way possible I see with the matter »as it is« is indeed a<br>\nseparate interpretation of the linorder to its dual, together with<br>\nsuitable mixins:</p>\n<p>theory Sort<br>\nimports Main \"~~/src/Tools/Permanent_Interpretation\"<br>\nbegin</p>\n<p>context linorder<br>\nbegin</p>\n<p>permanent_interpretation dual!: linorder greater_eq greater for dummy :: 'b<br>\n  defining<br>\n    insort_rev_key = \"dual.insort_key :: ('b ⇒ 'a) ⇒ 'b ⇒ 'b list ⇒ 'b list\"<br>\n    and sort_rev_key = \"dual.sort_key :: ('b ⇒ 'a) ⇒ 'b list ⇒ 'b list\"<br>\n  by default auto</p>\n<p>end</p>\n<p>export_code sort_rev_key in Haskell</p>\n<p>(Note that you need more mixins if you use the quicksort implementation<br>\nfrom Multiset.thy)</p>\n<p>Surely not very convincing due to all the mess generated by the dual order.</p>\n<p>IMHO the best way to continue from here is to develope a <em>algorithmic</em><br>\ntheory on sorting, which is specifically designed for executability.  I<br>\nguess this should follow the spirit of the Isabelle collection<br>\nframework.  The sort in List.thy then could stand as it is.</p>\n<p>All the best,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/azNwTw5-__5ZFXFnlej_JLzI/signature.asc\">signature.asc</a></p>",
        "id": 294657694,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168726
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<blockquote>\n<p>I think there is one misperception concerning sort_key – it is not<br>\nparametrized by an order, but by a morphism:</p>\n<p>\"sort_key\" :: \"('a ⇒ 'b) ⇒ 'a list ⇒ 'a list\"</p>\n<p>The morphism is not the parametrisation I was referring to. I meant the implicit <br>\nparametrisation with the order coming from the type class linorder. Obviously, this <br>\nparameter can only be seen by looking at the foundational constant for sort_key.</p>\n</blockquote>\n<blockquote>\n<p>IMHO the best way to continue from here is to develope a <em>algorithmic</em><br>\ntheory on sorting, which is specifically designed for executability.  I<br>\nguess this should follow the spirit of the Isabelle collection<br>\nframework.  The sort in List.thy then could stand as it is.<br>\nI am also in favour of separating reasoning and code generation. But ultimately, you want <br>\nto connect the two kinds of sorting.</p>\n</blockquote>\n<p>Best,<br>\nAndreas</p>\n<blockquote>\n<p>Am 05.10.2015 um 09:17 schrieb Andreas Lochbihler:</p>\n<blockquote>\n<p>Hi Christian,</p>\n<p>Here are my thoughts about List.sort &amp; friends:</p>\n<p>a) The first problem with List.sort and friends is that they are defined<br>\nin the type class linorder, although their definitions could be made as<br>\nwell in the type class ord. Three years ago (2ada2be850cb), I have moved<br>\nall the operations for red-black trees (RBT) into the linorder type<br>\nclass, precisely because I wanted to use them with other ordering<br>\nrelations. Ideally, the same should be done for List.sort and friends.</p>\n<p>For the time being, you can still avoid some of the overheads by using<br>\nthe foundational constant linorder.sort_key, which takes the order as an<br>\nadditional argument. So, you can pass in the dual order. With a single<br>\ninterpretation for the dual order, you should get all the theorems you<br>\nneed. You can even define an abbreviation for it:</p>\n<p>interpretation dual!: linorder \"op ≥\" \"op &gt; :: _ :: linorder ⇒ _\"<br>\nby(rule dual_linorder)<br>\nabbreviation \"rsort == linorder.sort_key op ≥ (λx. x)\"</p>\n<p>Unfortunately, code generation does not work out of the box, because the<br>\ncode setup has only been done for the type-class based instance. If<br>\nList.sort was defined in the type class ord, one could simply re-declare<br>\nthe code equations (as I did for the RBT operations in my AFP entry<br>\nContainers). Alternatively, you can prove that sort &amp; friends are<br>\nparametric (as Peter did for RBT operations in his AFP entry<br>\nCollections) and exploit parametricity like he does, but my feeling is<br>\nthat this again requires unconditional equations, i.e., a definition in<br>\nord.</p>\n<p>b) The second problem is that we want to implement List.sort with<br>\ndifferent algorithms during code generation. For linear orders, this is<br>\nno problem, because the result is unique. However, if we pass in a<br>\nnon-linear order, the outcome might depend on the algorithm. Thus, we<br>\ncan only do program refinement for linear orders. In that view, even if<br>\nwe move List.sort to the type class ord, we still have problems, because<br>\nwe cannot prove the code equations for arbitrary ordering relations any<br>\nmore.</p>\n<p>Ideally, we should separate the proving part from the code generation<br>\npart. AFAICS, the following should work.</p>\n<ol>\n<li>\n<p>Move List.sort and friends to type class ord. For ease of use and<br>\ncompatibility, we can add sign constraints such that type inference<br>\ninfers the linorder sort constraints for List.sort.</p>\n</li>\n<li>\n<p>Define a type 'a linorder of linear orders using typedef and an<br>\nembedding</p>\n<p>linorder_of :: \"'a :: linorder itself =&gt; 'a linorder\"</p>\n</li>\n<li>\n<p>Define operations for sorting lists that are parametrised with the<br>\norder from the type 'a linorder. Prove equations like \"List.sort_key ==<br>\nsort_key_impl TYPE('a)\".</p>\n</li>\n<li>\n<p>Adapt all the implementations for sorting such that they refine<br>\nsort_key_impl rather than List.sort_key.</p>\n</li>\n</ol>\n<p>Apart from sorting, such a setup could be used for further improvements<br>\nto the generated code. For example, one could refine the type 'a<br>\nlinorder to provide a comparator instead of a comparison operation.</p>\n<p>I guess such a change requires quite a lot of work to be carried out on<br>\nthe whole repository. At the moment, I do not have the time to carry all<br>\nthis out, but if the issue is pressing for you, you might want to try it<br>\nyourself. But before you start, we should also ask Florian on his opinion.</p>\n<p>Best,<br>\nAndreas</p>\n</blockquote>\n<p>On 03/10/15 21:59, Christian Sternagel wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear all,</p>\n<p>for those of you who do not regularly check stackoverflow but might have<br>\nan answer to my question there (yes I am looking at you Florian ;) ) I'm<br>\nbrazenly posting the link to my question here</p>\n<p><a href=\"http://stackoverflow.com/q/32926842/476803\">http://stackoverflow.com/q/32926842/476803</a></p>\n<p>In short, my question is: What is the easiest way to generate code for a<br>\nsorting algorithm that sorts its argument in reverse order, while<br>\nbuilding on top of the existing List.sort?</p>\n<p>cheers</p>\n<p>chris<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294657707,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168732
    }
]