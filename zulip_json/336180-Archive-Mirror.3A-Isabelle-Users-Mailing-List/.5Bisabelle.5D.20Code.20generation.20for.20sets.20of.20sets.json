[
    {
        "content": "<p>From: Martin STRECKER &lt;<a href=\"mailto:strecker@irit.fr\">strecker@irit.fr</a>&gt;<br>\nDear all,</p>\n<p>I have a problem with code generation using Executable_Set.thy for sets <br>\nof sets. Take the following definition (also see attached file):</p>\n<p>definition<br>\n   inter_partition :: \"'a set set \\&lt;Rightarrow&gt; 'a set set \\&lt;Rightarrow&gt; <br>\n'a set set\" where<br>\n   \"inter_partition P Q = ((\\&lt;lambda&gt; (a,b). a \\&lt;inter&gt; b) ` (P \\&lt;times&gt; <br>\nQ))\"</p>\n<p>The generated Ocaml code does not typecheck:</p>\n<p>let rec inter_partition (_A1, _A2)  p q =<br>\n     image (equal_fun _A1 equal_bool) (fun (a, b) -&gt; inter _A2 a b)  <br>\n(exTimes p q);;</p>\n<p>The problem is the equality function: whereas on the level of Isabelle, <br>\n'a set and 'a =&gt; bool are synonymous, they are not so on the level of <br>\nthe generated Ocaml code, where the code generator has introduced a <br>\ndatatype 'a set which is not compatible with 'a =&gt; bool. Therefore, the <br>\nequality function should not be (equal_fun _A1 equal_bool), but <br>\nsomething like (equal_set _A1). Any idea how to tweak the code generator <br>\ninto doing that?</p>\n<p>If Executable_Set.thy is considered legacy: which other code generation <br>\nto use for sets? The disadvantage of Cset.thy, for example, is that it <br>\nuses a functional representation which is not \"printable\".</p>\n<p>Thanks for your suggestions,</p>\n<p>Martin<br>\n<a href=\"/user_uploads/14278/38ycdCvOftxChROWYQSF1B9O/SetOfSet.thy\">SetOfSet.thy</a></p>",
        "id": 294132352,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843272
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nOn 03/09/2011 04:40 PM, Martin STRECKER wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>I have a problem with code generation using Executable_Set.thy for <br>\nsets of sets. Take the following definition (also see attached file):</p>\n<p>definition<br>\n  inter_partition :: \"'a set set \\&lt;Rightarrow&gt; 'a set set <br>\n\\&lt;Rightarrow&gt; 'a set set\" where<br>\n  \"inter_partition P Q = ((\\&lt;lambda&gt; (a,b). a \\&lt;inter&gt; b) ` (P <br>\n\\&lt;times&gt; Q))\"</p>\n<p>The generated Ocaml code does not typecheck:</p>\n<p>let rec inter_partition (_A1, _A2)  p q =<br>\n    image (equal_fun _A1 equal_bool) (fun (a, b) -&gt; inter _A2 a b)  <br>\n(exTimes p q);;</p>\n<p>The problem is the equality function: whereas on the level of <br>\nIsabelle, 'a set and 'a =&gt; bool are synonymous, they are not so on the <br>\nlevel of the generated Ocaml code, where the code generator has <br>\nintroduced a datatype 'a set which is not compatible with 'a =&gt; bool. <br>\nTherefore, the equality function should not be (equal_fun _A1 <br>\nequal_bool), but something like (equal_set _A1). Any idea how to tweak <br>\nthe code generator into doing that?</p>\n<p>These are the known deficiencies of the adhoc translations by <br>\nExecutable_Set.<br>\nA sound solution is provided by Cset.<br>\nIf Executable_Set.thy is considered legacy: which other code <br>\ngeneration to use for sets? The disadvantage of Cset.thy, for example, <br>\nis that it uses a functional representation which is not \"printable\".</p>\n<p>Nesting CSet.set in CSet.set should be possible and should allow to <br>\ngenerate code.<br>\nBut the basic definitions in the CSet theory is still incomplete <br>\ncompared to the Set theory.</p>\n</blockquote>\n<p>Actually, we envisage a mechanism to transport definitions from <br>\nIsabelle's set to the special-purpose type CSet.set for code generation.</p>\n<p>Values of type ('a CSet.set) CSet.set should be \"printable\".</p>\n<p>Hope this helps.</p>\n<p>Lukas</p>\n<blockquote>\n<p>Thanks for your suggestions,</p>\n<p>Martin</p>\n</blockquote>",
        "id": 294132356,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843274
    }
]