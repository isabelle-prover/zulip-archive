[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Jesus,</p>\n<blockquote>\n<ol>\n<li>I had to edit \"by hand\" the obtained module, where functions on<br>\nIsabelle \"iarray\"s were generated, including an additional import<br>\nstatement:</li>\n</ol>\n<p>import Data.Vector</p>\n<p>How could this statement be included \"automatically\"?</p>\n</blockquote>\n<p>in Imperative-HOL this is done the following way:</p>\n<blockquote>\n<p>code_include Haskell \"Heap\"<br>\n{*import qualified Control.Monad;<br>\nimport qualified Control.Monad.ST;<br>\nimport qualified Data.STRef;<br>\nimport qualified Data.Array.ST;</p>\n<p>type RealWorld = Control.Monad.ST.RealWorld;<br>\ntype ST s a = Control.Monad.ST.ST s a;<br>\ntype STRef s a = Data.STRef.STRef s a;<br>\ntype STArray s a = Data.Array.ST.STArray s Integer a;</p>\n<p>newSTRef = Data.STRef.newSTRef;<br>\nreadSTRef = Data.STRef.readSTRef;<br>\nwriteSTRef = Data.STRef.writeSTRef;</p>\n<p>newArray :: Integer -&gt; a -&gt; ST s (STArray s a);<br>\nnewArray k = Data.Array.ST.newArray (0, k);</p>\n<p>newListArray :: [a] -&gt; ST s (STArray s a);<br>\nnewListArray xs = Data.Array.ST.newListArray (0, (fromInteger . toInteger . length) xs) xs;</p>\n<p>newFunArray :: Integer -&gt; (Integer -&gt; a) -&gt; ST s (STArray s a);<br>\nnewFunArray k f = Data.Array.ST.newListArray (0, k) (map f [0..k-1]);</p>\n<p>lengthArray :: STArray s a -&gt; ST s Integer;<br>\nlengthArray a = Control.Monad.liftM snd (Data.Array.ST.getBounds a);</p>\n<p>readArray :: STArray s a -&gt; Integer -&gt; ST s a;<br>\nreadArray = Data.Array.ST.readArray;</p>\n<p>writeArray :: STArray s a -&gt; Integer -&gt; a -&gt; ST s ();<br>\nwriteArray = Data.Array.ST.writeArray;*}</p>\n</blockquote>\n<p>I. e. you setup a include which includes everything you need and brings<br>\nthat into its own name space.  This include is always imported, and you<br>\ncan access the ingredients from generate code then.</p>\n<blockquote>\n<ol start=\"2\">\n<li>Additionally, in order to compile the obtained code, I had to<br>\ninstall \"cabal\" in my computer and install the following library:</li>\n</ol>\n<p>cabal install vector</p>\n<p><a href=\"http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial#Importing_the_library\">http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial#Importing_the_library</a></p>\n<p>Is \"Data.Vector\" a \"canonical\" library? Can it be used \"reliably\"<br>\n(with respect to future behavior or methods modifications)?</p>\n</blockquote>\n<p>I have no idea how »canonical« this is.  Roughly I know that Haskell<br>\nprovides also »frozen« arrays which do not allow modifications unless<br>\n»thawed« (which then results in a copy at runtime, I guess).  Note that<br>\nusing includes also enables you to write your own types on top of<br>\nexisting target language libraries, cf. the setup for Scala in<br>\nImperative_HOL/Heap_Monad.thy</p>\n<blockquote>\n<p>As an additional question, does anybody know of a suitable OCaml data<br>\ntype to which \"iarray\" can be serialised?</p>\n</blockquote>\n<p>In the worst case, write an include in which you define your own<br>\nimmutable arrays on top of mutable ones, using an abstract datatype.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/jgnfeT_DpdK3yZ7UVbU7Uzaj/signature.asc\">signature.asc</a></p>",
        "id": 294250845,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910662
    }
]