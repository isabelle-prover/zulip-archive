[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHello all,</p>\n<p>since the code generator now can also handle invariants, I encapsulated <br>\nthe associative lists in the Isabelle/HOL library with the distinctness <br>\npredicate as an abstract type</p>\n<p>typedef (open) ('k, 'v) assoc_list =<br>\n   \"{xs :: ('k Ã— 'v) list. distinct (map fst xs)}\"<br>\n   morphisms impl_of Assoc_List<br>\nby(rule exI[where x=\"[]\"]) simp</p>\n<p>and lifted all primitive operations and their correctness statements <br>\nfrom ('k * 'v) list to ('k, 'v) assoc_list. Now, I would like to go one <br>\nstep further and define a trie which uses these associative lists to <br>\nmanage the successor nodes:</p>\n<p>datatype ('k, 'v) trie =<br>\n   Trie \"'v option\" \"('k, ('k, 'v) trie) assoc_list\"</p>\n<p>However, the datatype package complains that ('k, ('k, 'v) trie) <br>\nassoc_list is a non-admissible type expression which must not be used in <br>\na nested recursion.</p>\n<p>How can I define tries where all lists for the successor nodes are <br>\ndistinct? Do I really have to go back to lists and explicit data <br>\nstructure invariants and do the lifting all over again? I hope there is <br>\na much more elegant solution to this.</p>\n<p>Best regards,<br>\nAndreas</p>",
        "id": 294112182,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837195
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>datatype ('k, 'v) trie =<br>\n  Trie \"'v option\" \"('k, ('k, 'v) trie) assoc_list\"</p>\n<p>However, the datatype package complains that ('k, ('k, 'v) trie)<br>\nassoc_list is a non-admissible type expression which must not be used in<br>\na nested recursion.</p>\n</blockquote>\n<p>this restriction is not just a technical one: to be able to construct<br>\nthe datatype representation, the datatype package must how to recurse<br>\nthrough other types involving recursion, and therefore these must<br>\nsatisfay a couple of properties (which assoc_list doesn't).</p>\n<blockquote>\n<p>How can I define tries where all lists for the successor nodes are<br>\ndistinct? Do I really have to go back to lists and explicit data<br>\nstructure invariants and do the lifting all over again? I hope there is<br>\na much more elegant solution to this.</p>\n</blockquote>\n<p>Without having an example at hand, I would deem that this is largely a<br>\nmatter whether you are able to organize your proofs in a way that you<br>\ncan reuse the already proven properties of assoc_list representations.<br>\nExperience however shows that fundamental constructions over datatypes<br>\nmust consider the construction of the datatype anyway, so this might be<br>\nillusory.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/KfrNXrgsI2GwqQRordBOvTJC/signature.asc\">signature.asc</a></p>",
        "id": 294112436,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837270
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Florian,</p>\n<blockquote>\n<blockquote>\n<p>datatype ('k, 'v) trie =<br>\n  Trie \"'v option\" \"('k, ('k, 'v) trie) assoc_list\"</p>\n<p>However, the datatype package complains that ('k, ('k, 'v) trie)<br>\nassoc_list is a non-admissible type expression which must not be used in<br>\na nested recursion.</p>\n</blockquote>\n<p>this restriction is not just a technical one: to be able to construct<br>\nthe datatype representation, the datatype package must how to recurse<br>\nthrough other types involving recursion, and therefore these must<br>\nsatisfay a couple of properties (which assoc_list doesn't).<br>\nYou are right, the datatype definition unfolds nested recursion into <br>\nmutual recursion. However, since assoc_list builds on the list and <br>\nproduct datatypes, the manual unfolding and repackaging could be <br>\nautomated some time. Essentially, assoc_list is just a (degenerated) <br>\nquotient type over list with the PER xs ~ ys &lt;--&gt; xs = ys &amp; distinct <br>\n(map fst ys). The quotient package already offers some support for <br>\nlifting quotients over other type constructors, but this still has to be <br>\ndone manually. Are there any plans to integrate more tightly datatypes, <br>\nabstract code generator types and the quotient package?</p>\n</blockquote>\n<blockquote>\n<p>Without having an example at hand, I would deem that this is largely a<br>\nmatter whether you are able to organize your proofs in a way that you<br>\ncan reuse the already proven properties of assoc_list representations.<br>\nExperience however shows that fundamental constructions over datatypes<br>\nmust consider the construction of the datatype anyway, so this might be<br>\nillusory.<br>\nSince the above quotient construction can be lifted over to the trie <br>\ndatatype, I think the datatype as mentions above can be constructed <br>\nmanually with the free constructor Trie and an induction rule. However, <br>\ndoing all this manually is probably not worth the effort.</p>\n</blockquote>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294112469,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837281
    }
]