[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear list,</p>\n<p>I am trying to work with the code generator and an abstract datatype<br>\nwith invariants. What I learned so far is:</p>\n<ul>\n<li>\n<p>Code equations for functions returning values of the abstract type <br>\n   are written in terms of the representation of the returned value and</p>\n</li>\n<li>\n<p>if I have functions that return the abstract type in a container, I <br>\n   need to introduce new abstract types that express the invariant for<br>\n   all members.</p>\n</li>\n</ul>\n<p>But I am stuck with higher order functions. Say abs is my abstract type,<br>\nabs_list the abstract type for lists of abs representations. How would I<br>\nwrite the code equation for a combinator like</p>\n<p>definition abs_list_all :: \"(abs ⇒ bool) ⇒ abs_list ⇒ bool\"<br>\n          where \"abs_list_all P l = list_all (λx. P (abs x)) (Rep_small_list l)\"</p>\n<p>when I cannot mention the abstraction morphism \"abs\" in the equation?</p>\n<p>Example code for this can be found on<br>\n<a href=\"http://stackoverflow.com/questions/16273812/working-with-isabelles-code-generator-data-refinement-and-sets\">http://stackoverflow.com/questions/16273812/working-with-isabelles-code-generator-data-refinement-and-sets</a></p>\n<p>Thanks in advance,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/LrzcwYCeKw_GhkDcHDJ8V12i/signature.asc\">signature.asc</a></p>",
        "id": 294239107,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906175
    }
]