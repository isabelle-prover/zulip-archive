[
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nI'm trying to understand how to safely generate Haskell code from HOL,  <br>\nwhere I want the Haskell code to be an instance of the Eq class, but  <br>\nwith my own definition of the (==) method. I want Isabelle to enforce  <br>\nthat my definition of (==) is sound, i.e. it implements logical  <br>\nequality.</p>\n<p>So I'm trying to make my datatype an instance of the eq class, but I'm  <br>\nrunning into an error when using the function package to make the  <br>\ncorresponding definition. Here's an example theory file:</p>\n<p>theory Silly<br>\nimports Main<br>\nbegin</p>\n<p>datatype silly = Silly int</p>\n<p>instantiation silly :: eq<br>\nbegin</p>\n<p>fun \"eq_class.eq\" where<br>\n   \"eq (Silly n) (Silly m) = (m - n = 0)\"</p>\n<p>instance ..</p>\n<p>end</p>\n<p>The \"fun\" command returns the error</p>\n<p>*** Bad name binding \"eq_class.eq\"<br>\n   *** At command \"fun\".</p>\n<p>Am I, in fact, doing something silly here?</p>\n<p>Thanks,<br>\n-john<br>\n<a href=\"/user_uploads/14278/cx1aLc9tmgs2DGCrUaa4-f4h/smime.p7s\">smime.p7s</a></p>",
        "id": 294109870,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836454
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi John,</p>\n<blockquote>\n<p>I'm trying to understand how to safely generate Haskell code from HOL,<br>\nwhere I want the Haskell code to be an instance of the Eq class, but<br>\nwith my own definition of the (==) method. I want Isabelle to enforce<br>\nthat my definition of (==) is sound, i.e. it implements logical equality.</p>\n</blockquote>\n<p>the system is setup in a way that instantiation of the eq class happens<br>\nin exectly that manner automatically on each datatype statements (c.f.<br>\nÂ§2.6 of the code generation tutorial):</p>\n<blockquote>\n<p>So I'm trying to make my datatype an instance of the eq class, but I'm<br>\nrunning into an error when using the function package to make the<br>\ncorresponding definition. Here's an example theory file:</p>\n<p>theory Silly<br>\nimports Main<br>\nbegin</p>\n<p>datatype silly = Silly int</p>\n</blockquote>\n<p>Try here,  e.g.</p>\n<p>export_code \"HOL.eq :: silly =&gt; _\" in Haskell file -</p>\n<blockquote>\n<p>instantiation silly :: eq<br>\nbegin</p>\n<p>fun \"eq_class.eq\" where<br>\n  \"eq (Silly n) (Silly m) = (m - n = 0)\"</p>\n<p>instance ..</p>\n<p>end</p>\n</blockquote>\n<p>The conventions how to write down specifications in an instantiation<br>\nblock are a little bit unconventional (c.f. class tutorial):</p>\n<ul>\n<li>\n<p>In a binding (the name with optional type after fun, definition,<br>\nprimrec, ...), you must write \"f_typeconstructor\" instead of \"f\" (in<br>\nyour case, eq_silly -- the names can be inspected using the \"show me<br>\ncontext\" button in PG).</p>\n</li>\n<li>\n<p>In the specification terms, you may simply use \"f\" and have to make<br>\nsure that typing will it make refer to the particular type instance.</p>\n</li>\n</ul>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/euBgCpABEwQ78rLdk4y5O2dm/signature.asc\">signature.asc</a></p>",
        "id": 294109890,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836464
    },
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nThanks Florian, that helps my understanding.</p>\n<p>What I'm really trying to do is generate a specialized equality method  <br>\nfor your amortized queue code generation example. So I've defined the  <br>\nabstract version of the queue type as a single linked list, with the  <br>\ncorresponding queue method definitions:</p>\n<p>theory Queue<br>\n   imports Main<br>\n   begin</p>\n<p>datatype 'a queue = Queue \"('a list)\"</p>\n<p>definition empty :: \"'a queue\" where ...</p>\n<p>primrec enqueue :: \"'a =&gt; 'a queue =&gt; 'a queue\" where ...</p>\n<p>fun dequeue :: \"'a queue =&gt; 'a option * 'a queue\" where ...</p>\n<p>end</p>\n<p>Then I have another theory file where I'm trying to generate code for  <br>\nthe concrete instance of the queue type with two constructor arguments:</p>\n<p>theory AQueue<br>\n   imports Queue<br>\n   begin</p>\n<p>definition<br>\n     AQueue :: \"'a list =&gt; 'a list =&gt; 'a queue\" where<br>\n    \"AQueue xs ys = Queue (ys @ rev xs)\"</p>\n<p>code_datatype AQueue</p>\n<p>lemma eq_AQueue[code]:<br>\n     \"eq_class.eq (AQueue xs ys) (AQueue xs' ys') = (ys @ rev xs = ys'  <br>\n@ rev xs')\"<br>\n   by (auto simp add: AQueue_def eq_class.eq)</p>\n<p>export_code \"eq_class.eq :: 'a queue =&gt; 'a queue =&gt; bool\" in Haskell<br>\n     module_name AQueue<br>\n     file AQueueCode</p>\n<p>end</p>\n<p>I'm trying to use lemma eq_AQueue to tell the code generator to use my  <br>\nspecialized (==) method definition on the AQueue constructors when  <br>\ngenerating Haskell code. But then Isabelle gives me this error when it  <br>\ntries to generate the Haskell program:</p>\n<p>*** \"Queue.queue.Queue\" is not a constructor, on left hand side of  <br>\nequation<br>\n   *** eq_queue_inst.eq_queue (Queue ?list1) (Queue ?list'1) ==  <br>\neq_list_inst.eq_list ?list1 ?list'1<br>\n   *** At command \"export_code\".</p>\n<p>Should I be doing something differently here?</p>\n<p>Thanks,<br>\n-john<br>\n<a href=\"/user_uploads/14278/cY76cuLMOa2qGFD_p1Ozlh1D/smime.p7s\">smime.p7s</a></p>",
        "id": 294110022,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836499
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi John,</p>\n<p>the problem is that the old equation using Queue is still kept as code<br>\nequations;  you can either delete it explicitly:</p>\n<p>lemma [code del]:<br>\n    \"eq_class.eq (Queue xs) (Queue ys) &lt;--&gt; xs = ys\"</p>\n<p>Or, which is perhaps more elegant, define an explicit conversion from<br>\nqueues to lists:</p>\n<p>primrec list_of_queue :: \"'a queue \\&lt;Rightarrow&gt; 'a list\" where<br>\n    \"list_of_queue (Queue xs) = xs\"</p>\n<p>lemma list_of_AQueue [code]:<br>\n    \"list_of_queue (AQueue xs ys) = ys @ rev xs\"<br>\n    by (simp add: AQueue_def)</p>\n<p>lemma [code]:<br>\n    \"HOL.eq q1 q2 \\&lt;longleftrightarrow&gt;<br>\n      HOL.eq (list_of_queue q1) (list_of_queue q2)\"<br>\n    by (auto simp add: eq intro: queue_eqI)</p>\n<p>Then the old code equation is dropped since it is syntactically subsumed.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/lmvCqtP_pnMdNGiL5o5uITiy/signature.asc\">signature.asc</a></p>",
        "id": 294110073,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836519
    },
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nHi Florian,</p>\n<p>That makes sense, thanks.</p>\n<p>In Section 2.5 (\"Datatypes\") of the codegen tutorial, when you talk  <br>\nabout the code_datatype command you might want to mention that the  <br>\nuser has to explicitly [code del] any definitions that use the old  <br>\nversions of the constructors, including automatically generated  <br>\ndefinitions like eq_class.eq. You might even want to consider adding  <br>\nsome text showing how to add the concrete equality method for the  <br>\nAQueue example, but that would be more work. :)</p>\n<p>Also, in the isar_ref manual, the syntax diagram for code_datatype is  <br>\nincorrect: It should take a list of consts, not a single const.</p>\n<p>Cheers,<br>\n-john<br>\n<a href=\"/user_uploads/14278/UD3BPiQinxlZyYxazpVmiSGH/smime.p7s\">smime.p7s</a></p>",
        "id": 294110164,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836552
    },
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nHi Florian,</p>\n<p>I may have spoke too soon: trying your [code del] trick didn't work.  <br>\nHere's the exact lemma I used:</p>\n<p>lemma [code del]:<br>\n   \"eq_class.eq (Queue xs) (Queue ys) \\&lt;longleftrightarrow&gt; xs = ys\"<br>\nby (simp add: eq_equals)</p>\n<p>But I still get the same error when trying to generate Haskell code.  <br>\nI've also attached the two theory files.</p>\n<p>Thanks,<br>\n-john<br>\n<a href=\"/user_uploads/14278/Ety8eUTY3sXYN9dOtrPBQ48H/Queue.thy\">Queue.thy</a><br>\n<a href=\"/user_uploads/14278/Z-hFh0cfw2aUksIO3pM8Bq-O/AQueue.thy\">AQueue.thy</a><br>\n<a href=\"/user_uploads/14278/A3d_SOkVBeTziU8k0mquAkqt/smime.p7s\">smime.p7s</a></p>",
        "id": 294110173,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836558
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi John,</p>\n<blockquote>\n<p>Also, in the isar_ref manual, the syntax diagram for code_datatype is<br>\nincorrect: It should take a list of consts, not a single const.</p>\n</blockquote>\n<p>thanks for pointing this out.</p>\n<blockquote>\n<p>I may have spoke too soon: trying your [code del] trick didn't work. Here's the exact lemma I used:</p>\n<p>lemma [code del]:<br>\n  \"eq_class.eq (Queue xs) (Queue ys) \\&lt;longleftrightarrow&gt; xs = ys\"<br>\nby (simp add: eq_equals)</p>\n<p>But I still get the same error when trying to generate Haskell code. I've also attached the two theory files. </p>\n</blockquote>\n<p>Unfortunately I did not give names to those theorems (but I have<br>\nconvinced myself that it should be done) -- identifying theorems by<br>\nproposition only is brittle.  In such situations use the following:</p>\n<p>lemma [code, code del]:<br>\n  \"(eq_class.eq :: 'a queue =&gt; _) = eq_class.eq\"<br>\n  by (rule refl)</p>\n<p>This inserts a code equations which will subsume all others<br>\nsyntactically, and deletes it immediately afterwards, leaving no code<br>\nequations at all.</p>\n<p>An alternative is the list_of_queue approach I described in an earlier<br>\ne-mail:</p>\n<blockquote>\n<blockquote>\n<p>Or, which is perhaps more elegant, define an explicit conversion from<br>\nqueues to lists:</p>\n<p>primrec list_of_queue :: \"'a queue \\&lt;Rightarrow&gt; 'a list\" where<br>\n   \"list_of_queue (Queue xs) = xs\"</p>\n<p>lemma list_of_AQueue [code]:<br>\n   \"list_of_queue (AQueue xs ys) = ys @ rev xs\"<br>\n   by (simp add: AQueue_def)</p>\n<p>lemma [code]:<br>\n   \"HOL.eq q1 q2 \\&lt;longleftrightarrow&gt;<br>\n     HOL.eq (list_of_queue q1) (list_of_queue q2)\"<br>\n   by (auto simp add: eq intro: queue_eqI)</p>\n<p>Then the old code equation is dropped since it is syntactically subsumed.</p>\n</blockquote>\n</blockquote>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/NxKS30q7b7CsUNwe8sizlSBu/signature.asc\">signature.asc</a></p>",
        "id": 294110207,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836577
    }
]