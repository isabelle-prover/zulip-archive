[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear all,</p>\n<p>I am wondering how I can efficiently implement a conversion function list_of <br>\nbetween the subset of finite lists from the type of possibly infinite lists (as <br>\ndefined in AFP-Coinductive) and ordinary lists from the HOL image.</p>\n<p>At present, the code equations for list_of are as follows in the AFP:</p>\n<p>list_of LNil = []<br>\nlist_of (LCons x xs) = (if lfinite xs then x # list_of xs else undefined)</p>\n<p>This way, the finiteness test is executed once for every element of the list, <br>\nwhich makes conversion quadratic in the length of the list. Now, I would like to <br>\nexecute the finiteness test at most a constant number of times by exploiting <br>\nthat finiteness is preserved through all recursive calls. I hope that I can do <br>\nthis with the code generator's support for invariants. So far, I came up with <br>\nthe following:</p>\n<p>(* Identify the subset of the type that is of interest *)<br>\ntypedef (open) 'a llist_fin = \"{xs :: 'a llist. lfinite xs}\"<br>\n   morphisms llist_of_fin Abs_llist_fin<br>\nproof<br>\n   show \"LNil : ?llist_fin\" by simp<br>\nqed</p>\n<p>(* Setup the abstype *)<br>\nlemma llist_of_fin_Abs_llist_fin [simp, code abstype]:<br>\n   \"Abs_llist_fin (llist_of_fin xs) = xs\"<br>\nby(rule llist_fin.llist_of_fin_inverse)</p>\n<p>(* Define the abstract operation *)<br>\ndefinition list_of2 :: \"'a llist_fin =&gt; 'a list\"<br>\nwhere \"list_of2 xs = list_of (llist_of_fin xs)\"</p>\n<p>(* Prove a new code equation for list_of that uses the abstract operation *)<br>\nlemma list_of_code [code]:<br>\n   \"list_of xs = (if lfinite xs then list_of2 (Abs_llist_fin xs) else undefined)\"<br>\nby(simp add: list_of2_def Abs_llist_fin_inverse list_of_def Abs_llist_fin2_def)</p>\n<p>Now, I am stuck at two problems:</p>\n<ol>\n<li>\n<p>list_of_code uses the abstraction function Abs_llist_fin, which the code <br>\ngenerator does not allow. But from the calling context, I know that all <br>\nassumptions are satisfied.</p>\n</li>\n<li>\n<p>I have no idea how to state the code equations for list_of2. I would imagine <br>\nsomething like</p>\n</li>\n</ol>\n<p>\"list_of2 (Abs_llist_fin LNil) = []\"<br>\n\"lfinite xs ==&gt; list_of2 (Abs_llist_fin (LCons x xs)) = x # llist_of2 <br>\n(Abs_llist_fin xs)\"</p>\n<p>I have been going in circles here for quite some time. Can someone point me in <br>\nthe right direction how to do this? Do I have the right approach? Or is it <br>\nimpossible in general?</p>\n<p>Thanks in advance,<br>\nAndreas</p>",
        "id": 294144388,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846978
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Andreas,</p>\n<p>I have some suggestions that follow a different approach: Instead of<br>\ndefining any new types or using invariants, you could just define an<br>\nauxiliary function to use with code generation for list_of.</p>\n<p>My first idea was to define a variation of list_of that returns an<br>\noption type instead of using the \"undefined\" value:</p>\n<p>definition opt_list_of :: \"'a llist =&gt; 'a list option\"<br>\n  where [code del]: \"opt_list_of xs = (if lfinite xs then Some<br>\n(list_of xs) else None)\"</p>\n<p>The code equations for opt_list_of are more efficient than the<br>\nstandard ones for list_of, because they replace the expensive lfinite<br>\ntest with a simple pattern match:</p>\n<p>lemma opt_list_of_code [code]:<br>\n  \"opt_list_of LNil = Some Nil\"<br>\n  \"opt_list_of (LCons x xs) =<br>\n    (case opt_list_of xs of None =&gt; None | Some xs' =&gt; Some (x # xs'))\"<br>\n  unfolding opt_list_of_def by simp_all</p>\n<p>Now you can declare a code equation for list_of so that it calls opt_list_of:</p>\n<p>lemma list_of_code [code]:<br>\n  \"list_of xs = (case opt_list_of xs of None =&gt; undefined | Some xs' =&gt; xs')\"<br>\n  unfolding list_of_def opt_list_of_def by simp</p>\n<p>My second idea is to define a function list_of_aux that uses an<br>\naccumulating parameter to store the list of elements seen so far:</p>\n<p>definition list_of_aux :: \"'a list =&gt; 'a llist =&gt; 'a list\" where<br>\n  \"list_of_aux xs ys = (if lfinite ys then rev xs @ list_of ys else undefined)\"</p>\n<p>lemma list_of_aux_code [code]:<br>\n  \"list_of_aux xs LNil = rev xs\"<br>\n  \"list_of_aux xs (LCons y ys) = list_of_aux (y # xs) ys\"<br>\n  unfolding list_of_aux_def by simp_all</p>\n<p>lemma list_of_eq_list_of_aux [code]:<br>\n  \"list_of = list_of_aux []\"<br>\n  unfolding fun_eq_iff list_of_def list_of_aux_def by simp</p>\n<p>I suppose that list_of_aux is more efficient than opt_list_of, since<br>\nit is actually tail-recursive.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294144436,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846991
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Brian,</p>\n<p>thanks for your ideas, they are much simpler and more elegant than what I had in <br>\nmind. I'll add it to the AFP when I update Coinductive the next time.</p>\n<p>Andreas</p>",
        "id": 294144458,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846997
    }
]