[
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nHello,</p>\n<p>Thank you so much for your help Fabian, now it works.</p>\n<p>One remark for the rest of the users of the list. It's worth noting the<br>\nimportance of the order when we are importing theories involving code<br>\ngeneration. In my case, I work using the Multivariate_Analysis session.</p>\n<p>If one creates a new file importing both the Multivariate Analysis files<br>\nand the file \"Code_Rational\" that Fabian has sent previously, then an<br>\nexception is got when the code is exported. This is an example:</p>\n<p>theory Code_Rational_Problem<br>\nimports<br>\n  \"~~/src/HOL/Multivariate_Analysis/Multivariate_Analysis\"<br>\n  Code_Rational<br>\nbegin</p>\n<p>definition \"test11 = [[273/2::rat,7],[28/2,7]]\"</p>\n<p>export_code test11<br>\n  in Haskell<br>\n  module_name \"Gauss_Haskell\"<br>\n  file \"haskell\"<br>\nend</p>\n<p>The exception is: exception BAD_THM \"Not an abstract type: Rat.rat\" raised<br>\n(line 436 of \"Isar/code.ML\")\"</p>\n<p>To solve it, in my case, I have had to import<br>\n\"~~/src/HOL/Multivariate_Analysis/Multivariate_Analysis\" at the beginning<br>\nof the theory Code_Rational attached by Fabian.</p>\n<p>Thanks again.</p>\n<p>Best,<br>\nJose</p>",
        "id": 294271169,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917287
    },
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nDear all,</p>\n<p>attached you can find an attempt to serialise the rat type in Isabelle to<br>\nthe Rational type in Haskell. It works, but I think that there are better<br>\nways to do that.</p>\n<p>For the moment, I have serialised the operations \"Frct\" and \"quotient_of\"<br>\nin the following way:</p>\n<p>constant \"Frct\" ⇀ (Haskell) \"(let (x,y) = _ in (Rational.fract<br>\n(integer'_of'_int x) (integer'_of'_int y)))\"<br>\n | constant \"quotient_of\" ⇀ (Haskell) \"(let x = _ in (Int'_of'_integer<br>\n(Rational.numerator x), Int'_of'_integer (Rational.denominator x)))\"</p>\n<p>I would like to avoid the use of integer_of_int and Int_of_integer in those<br>\nlines (because they are Isabelle functions and then, sometimes, if I don't<br>\nexport them they are not automatically generated to Haskell).</p>\n<p>I have tried to work out that problem by means of a function \"Frct_integer\"<br>\nand a code lemma, but it doesn't work:</p>\n<p>lift_definition Frct_integer :: \"integer × integer =&gt; rat\"<br>\n  is \"Frct :: int × int =&gt; rat\" .</p>\n<p>lemma [code]:<br>\n\"Frct a = Frct_integer ((of_int (fst a)), (of_int (snd a)))\"<br>\n  by (transfer, simp)</p>\n<p>code_printing<br>\n constant \"Frct_integer\" ⇀ (Haskell) \"Rational.fract (_)\"</p>\n<p>The problem arises in the code lemma, because the output says that there is<br>\nan \"abstractor as head in equation\". So I can prove it but not use it as a<br>\ncode lemma.</p>\n<p>I have a similar problem working with \"quotient_of\".</p>\n<p>definition numerator :: \"rat =&gt; int\"<br>\nwhere \"numerator x = fst (quotient_of x)\"</p>\n<p>definition denominator :: \"rat =&gt; int\"<br>\nwhere \"denominator x = snd (quotient_of x)\"</p>\n<p>lemma quotient_of_num_den: \"quotient_of x = ((numerator x), (denominator<br>\nx))\"<br>\nunfolding numerator_def denominator_def<br>\nby simp</p>\n<p>lift_definition numerator_integer :: \"rat =&gt; integer\"<br>\n  is \"numerator\" .</p>\n<p>lift_definition denominator_integer :: \"rat =&gt; integer\"<br>\n  is \"denominator\" .</p>\n<p>lemma [code]: \"quotient_of x = (int_of_integer (numerator_integer x),<br>\nint_of_integer(denominator_integer x))\"<br>\nby (transfer, simp add: quotient_of_num_den)</p>\n<p>code_printing<br>\n constant \"numerator_integer\" ⇀ (Haskell) \"Rational.numerator (_)\"<br>\n  | constant \"denominator_integer\" ⇀ (Haskell) \"Rational.denominator (_)\"</p>\n<p>The code lemma can't be proven because there is a \"Projection as head in<br>\nequation\".</p>\n<p>I think that all comes from this theorem, which is in the file HOL/Rat.thy:</p>\n<p>lemma [code abstype]:<br>\n  \"Frct (quotient_of q) = q\"<br>\n  by (cases q) (auto intro: quotient_of_eq)</p>\n<p>But I don't know if it is possible to remove that tag [code abstype], or<br>\nmaybe there is another way to avoid the use of integer_of_int and<br>\nint_of_integer in the serialisation.</p>\n<p>Thanks in advance for any advice.</p>\n<p>Best,<br>\nJose<br>\n<a href=\"/user_uploads/14278/-ft9O4ojfnp5NdH2zWJCn5Cv/Code_Rational.thy\">Code_Rational.thy</a></p>",
        "id": 294272909,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917777
    },
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:immler@in.tum.de\">immler@in.tum.de</a>&gt;<br>\nHi Jose,</p>\n<p>Apparently, you can delete Frct as abstractor by declaring any other constant as code_datatype (should not matter, because you map type rat to Haskell type Prelude.Rational):</p>\n<p>consts Foo::rat<br>\ncode_datatype Foo</p>\n<p>With some minor tweaks and additional code equations, the setup you had commented out generates valid Haskell-code.<br>\n(See also the attached file).</p>\n<p>Best regards,<br>\nFabian<br>\n<a href=\"/user_uploads/14278/6jarcV0F9qVqU06kBAFxEP_Y/Code_Rational.thy\">Code_Rational.thy</a></p>",
        "id": 294272951,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917790
    }
]