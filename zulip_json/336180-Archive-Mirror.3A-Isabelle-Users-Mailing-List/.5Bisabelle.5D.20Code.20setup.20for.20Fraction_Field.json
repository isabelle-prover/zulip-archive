[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>We noticed that the code setup for the theory Fraction_Field in HOL/Library is broken, at <br>\nleast since Isabelle2013. We would like to use code generation in his formalisation of <br>\nknot theory where the elements of the fraction fields are polynomials over integers. I had <br>\na brief look at the theory Fraction_Field and noticed that there is a smart <br>\npseudo-constructor Fract, which is declared as code_datatype. So this feels as if the code <br>\ngeneration was working at some time in the distant past and got broken somewhen.</p>\n<p>Does anyone know about the status of Fraction_Field?</p>\n<p>I believe that it would be fairly easy to \"fix\" the problem of code generator setup by <br>\nderiving a few code equation from the lemmas, but this will clearly result in suboptimal <br>\ncode for two reasons. First, we need tests whether the denominator is 0 all over the <br>\nplace. Second, the elements of the fraction fields will not be normalised automatically. <br>\nFor the application on polynomials, this means that we would need some Euclidean algorithm <br>\nfor cancelling common factors of polynomials. I dimly remember that there is some support <br>\nfor the Euclidean algorithm in the pipeline. What is the status there?</p>\n<p>Best,<br>\nAndreas and Prathamesh</p>",
        "id": 294650740,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166000
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nIt's all there in ~~/src/HOL/Number_Theory/Euclidean_Algorithm. However,<br>\nif you want to do this for polynomials with integer coefficients, that<br>\nis not going to work: polynomials over the integers are /not/ a<br>\nEuclidean ring; they are not even a principal ideal domain.</p>\n<p>The Euclidean algorithm can be adapted to work; the easiest way is<br>\nprobably to use subresultants, because this way, all intermediate<br>\nresults are also integer polynomials, whereas the classic Euclidean<br>\nalgorithm would have fractional coefficients.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294650846,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166021
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas and Prathamesh,</p>\n<blockquote>\n<p>We noticed that the code setup for the theory Fraction_Field in<br>\nHOL/Library is broken, at least since Isabelle2013. We would like to use<br>\ncode generation in his formalisation of knot theory where the elements<br>\nof the fraction fields are polynomials over integers. I had a brief look<br>\nat the theory Fraction_Field and noticed that there is a smart<br>\npseudo-constructor Fract, which is declared as code_datatype. So this<br>\nfeels as if the code generation was working at some time in the distant<br>\npast and got broken somewhen.</p>\n<p>Does anyone know about the status of Fraction_Field?</p>\n</blockquote>\n<p>I dimly remember that initially Fraction_Field just took over the<br>\nthen-used code setup from the rationals, and maybe it never worked as<br>\nintended (would need a closer investigation to find out actually).</p>\n<p>When code generation had been equipped with invariants, I revisited<br>\nFraction_Field to make a code setup close to the rationals but soon<br>\nrealized that…</p>\n<blockquote>\n<p>I believe that it would be fairly easy to \"fix\" the problem of code<br>\ngenerator setup by deriving a few code equation from the lemmas, but<br>\nthis will clearly result in suboptimal code for two reasons. First, we<br>\nneed tests whether the denominator is 0 all over the place. Second, the<br>\nelements of the fraction fields will not be normalised automatically.</p>\n</blockquote>\n<p>…I need a generalized gcd for that, and so I let everything stand as it is.</p>\n<blockquote>\n<p>For the application on polynomials, this means that we would need some<br>\nEuclidean algorithm for cancelling common factors of polynomials. I<br>\ndimly remember that there is some support for the Euclidean algorithm in<br>\nthe pipeline. What is the status there?</p>\n</blockquote>\n<p>I think you can build on the corresponding theory in Number_Theory, but<br>\nthat needs some further rounds of polishing before I would recommend to<br>\nturn it into a »hard« dependency.  Instead I suggest to put the code<br>\nsetup into a separate theory »Executable_Fraction_Field«.  This is what<br>\nwe did 8 years ago when code generation was still highly experimental…</p>\n<p>Hope this helps,<br>\n    Florian</p>\n<blockquote>\n<p>Best,<br>\nAndreas and Prathamesh</p>\n<p><a href=\"/user_uploads/14278/k3l-3DnPCwpZ_Fv-vaeb3qPZ/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294650868,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166034
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Manuel and Florian,</p>\n<p>Thank you for your quick replies. Let me summarise how I see the situation:</p>\n<ol>\n<li>\n<p>Fraction fields are defined over integral domains (type class idom). With little <br>\neffort, we could get a horribly inefficient setup for code generation by just massaging <br>\nthe existing equations a bit.</p>\n</li>\n<li>\n<p>For euclidean rings, we can get with reasonable effort a working code setup with <br>\nreasonable efficiency. If we take that route, code generation only works for euclidean <br>\nrings, but polynomials over integers are not such a ring (which is our application at the <br>\nmoment).</p>\n</li>\n<li>\n<p>For fraction fields over polynomials over rings (rather than fields), one can use <br>\nsubresultants, but I have not been able to find them formalised in Isabelle. Are they <br>\nhidden somewhere? If not, are there any plans to formalise them?</p>\n</li>\n</ol>\n<p>Even if we had subresultants, I do not yet see how they can be integrated with the <br>\nIsabelle type classes. Obviously, we should have a uniform code setup for fraction fields, <br>\ni.e., it should work for all instances the same way. AFAICS, this means that we need <br>\nanother type class which provides some sort of normalisation function normalise :: 'a =&gt; <br>\n'a =&gt; 'a * 'a. For euclidean rings, this could just be delegated to Euclid's algorithm. <br>\nFor polynomials, the situation is not as clear. Either the instantiation always implements <br>\nsome normalisation algorithm (e.g. using subresultants) or it tests whether the base type <br>\nis a field and if so, it uses Euclid's algorithm again. I do not know which of these is <br>\npreferable in terms of efficiency. Do you have any idea?</p>\n<p>What's your take on this?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294650944,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166065
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Andreas,</p>\n<p>Are subresultants really necessary for this? From my understanding, <br>\nsubresultant remainder sequences are just an improved version of <br>\npseudo-remainder sequences, by controlling coefficients growth. However, <br>\nif not implemented properly (i.e. merely calculating subresultants <br>\nthrough determinants), I don't think there is any advantage for <br>\nsubresultants over pseudo-divisions, while pseudo-divisions on <br>\npolynomials are much easier to formalize. In fact, I did a formalization <br>\nof polynomial pseudo-divisions by imitating Euclidean divisions in <br>\nLibrary/Polynomial.thy, and the relation looks like:</p>\n<p>definition ppdivmod_rel :: \"'a::idom poly ⇒ 'a poly ⇒ 'a poly ⇒ 'a poly <br>\n⇒ 'a ⇒ bool\"<br>\nwhere<br>\n   \"ppdivmod_rel x y q r m ⟷ (<br>\n       smult m x = q * y + r ∧ (if y = 0 then q = 0 else r = 0 ∨ degree r <br>\n&lt; degree y)<br>\n       ∧  ( m= (if x=0 ∨ y=0 then 1 else (lead_coeff y) ^ (degree x + 1 - <br>\ndegree y))))\"</p>\n<p>Hope this helps,<br>\nWenda</p>",
        "id": 294650975,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166076
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda,</p>\n<p>I am not an expert on computer algebra, so I am happy to use whatever seems reasonable. <br>\nDoes your formalisation of pseudo-division also include an executable algorithm? Is your <br>\nformalisation available?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294651130,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166129
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nThe formalization is executable. Please give me a day or two, I will <br>\nclean it a little bit and then upload it to my Sturm-Tarski Theorem <br>\nentry in AFP.</p>\n<p>Wenda</p>",
        "id": 294651137,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166131
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian and Manuel,</p>\n<p>I have experimented a bit with a normalisation function to be used in the operations over <br>\nfraction fields and had a look at Euclidean_Algorithm in Number_Theory.</p>\n<ol>\n<li>\n<p>I noticed that there are the type classes euclidean_ring and euclidean_ring_gcd. Most <br>\nof the theorems about gcd which I need are in euclidean_ring_gcd, but not in <br>\neuclidean_ring itself. Unfortunately, the instantiations for nat, int, etc. are only done <br>\nfor euclidean_ring, not for euclidean_ring_gcd. What are the plans for these type classes? <br>\nShould I spend any effort on adding instances for euclidean_ring_gcd? Or will this become <br>\nobsolete with the polishing that is still due?</p>\n</li>\n<li>\n<p>I am no longer sure that an invariant-based approach is the optimal thing for fraction <br>\nfield. In the code equation for the arithmetic operation, I don't see any big <br>\nopportunities to exploit the invariant that nominator and denominator are normalised in <br>\nsome unspecified form. Only the equality tests become simpler (as normal forms are unique <br>\nand we thus save two multiplications). Instead, it seems much simpler to treat <br>\ncancellation of common factors as an optimisation without logical significance. For <br>\nexample, we could just add a call to a simplification function before calls to the Fract <br>\nconstructor. The simplification function only has to return an element of the same <br>\nequivalence class, so for nat and int, we could use a normalisation function based on <br>\nEuclid's algorithm. For other types, the simplification function could also just be the <br>\nidentity. What do you think?</p>\n</li>\n</ol>\n<p>Best,<br>\nAndreas</p>",
        "id": 294654354,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167401
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>On 04/09/15 11:44, Manuel Eberl wrote:</p>\n<blockquote>\n<blockquote>\n<ol>\n<li>I noticed that there are the type classes euclidean_ring and<br>\neuclidean_ring_gcd. Most of the theorems about gcd which I need are in<br>\neuclidean_ring_gcd, but not in euclidean_ring itself. Unfortunately,<br>\nthe instantiations for nat, int, etc. are only done for<br>\neuclidean_ring, not for euclidean_ring_gcd. What are the plans for<br>\nthese type classes? Should I spend any effort on adding instances for<br>\neuclidean_ring_gcd? Or will this become obsolete with the polishing<br>\nthat is still due?</li>\n</ol>\n</blockquote>\n<p>euclidean_ring_gcd is nothing but euclidean_ring with the additional<br>\nassumption that gcd and Gcd (which are introduced in a syntactical<br>\ntypeclass and therefore have no a priori properties associated with<br>\nthem) are the same as the euclidean GCD (and the same for LCM).</p>\n<p>So, in a sense, there is usually no proof work to be done to make<br>\nanything an instance of euclidean_ring_gcd if you already have<br>\neuclidean_ring; you can just define \"gcd = gcd_eucl\", \"Gcd = Gcd_eucl\"<br>\nand so on and you get the instance for free.<br>\nThat's clear. However, nat and int already have their own implementation of the GCD...</p>\n</blockquote>\n<blockquote>\n<p>If there is already an existing definition of gcd, you have to prove its<br>\nequivalence to the Euclidean GCD etc., which you can do by showing that<br>\nit fulfils the defining properties of the GCD and that it returns a<br>\nnormalised GCD, i.e. \"1\" and not \"-1\" for integers.<br>\nWell, it is exactly this equivalence proof of which I am uncertain. If Florian <br>\nrestructures the whole hierarchy such that gcd/lcm definitions for int and nat are done in <br>\nterms of gcd_eucl, then the equivalence proof becomes irrelevant.</p>\n</blockquote>\n<p>In fact, from what I can see, the equivalences are not provable at all in Isabelle2015, <br>\nbecause euclidean_ring_gcd also talks about the set versions Gcd and Lcm. And in <br>\nEuclidean_Algorithm, Lcm_eucl and Gcd_eucl are defined such that they also work for <br>\ninfinite sets whereas in GCD, Lcm for nat is defined to be 0 for infinite sets. So what is <br>\nthe plan here?</p>\n<p>Best,<br>\nAndreas</p>\n<blockquote>\n<p>On 04/09/15 11:32, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Hi Florian and Manuel,</p>\n<p>I have experimented a bit with a normalisation function to be used in<br>\nthe operations over fraction fields and had a look at<br>\nEuclidean_Algorithm in Number_Theory.</p>\n<ol start=\"2\">\n<li>I am no longer sure that an invariant-based approach is the optimal<br>\nthing for fraction field. In the code equation for the arithmetic<br>\noperation, I don't see any big opportunities to exploit the invariant<br>\nthat nominator and denominator are normalised in some unspecified<br>\nform. Only the equality tests become simpler (as normal forms are<br>\nunique and we thus save two multiplications). Instead, it seems much<br>\nsimpler to treat cancellation of common factors as an optimisation<br>\nwithout logical significance. For example, we could just add a call to<br>\na simplification function before calls to the Fract constructor. The<br>\nsimplification function only has to return an element of the same<br>\nequivalence class, so for nat and int, we could use a normalisation<br>\nfunction based on Euclid's algorithm. For other types, the<br>\nsimplification function could also just be the identity. What do you<br>\nthink?</li>\n</ol>\n<p>Best,<br>\nAndreas</p>\n</blockquote>\n<p>On 27/08/15 12:02, Florian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi Andreas and Prathamesh,</p>\n<blockquote>\n<p>We noticed that the code setup for the theory Fraction_Field in<br>\nHOL/Library is broken, at least since Isabelle2013. We would like to<br>\nuse<br>\ncode generation in his formalisation of knot theory where the elements<br>\nof the fraction fields are polynomials over integers. I had a brief<br>\nlook<br>\nat the theory Fraction_Field and noticed that there is a smart<br>\npseudo-constructor Fract, which is declared as code_datatype. So this<br>\nfeels as if the code generation was working at some time in the distant<br>\npast and got broken somewhen.</p>\n<p>Does anyone know about the status of Fraction_Field?</p>\n</blockquote>\n<p>I dimly remember that initially Fraction_Field just took over the<br>\nthen-used code setup from the rationals, and maybe it never worked as<br>\nintended (would need a closer investigation to find out actually).</p>\n<p>When code generation had been equipped with invariants, I revisited<br>\nFraction_Field to make a code setup close to the rationals but soon<br>\nrealized that…</p>\n<blockquote>\n<p>I believe that it would be fairly easy to \"fix\" the problem of code<br>\ngenerator setup by deriving a few code equation from the lemmas, but<br>\nthis will clearly result in suboptimal code for two reasons. First, we<br>\nneed tests whether the denominator is 0 all over the place. Second, the<br>\nelements of the fraction fields will not be normalised automatically.</p>\n</blockquote>\n<p>…I need a generalized gcd for that, and so I let everything stand as<br>\nit is.</p>\n<blockquote>\n<p>For the application on polynomials, this means that we would need some<br>\nEuclidean algorithm for cancelling common factors of polynomials. I<br>\ndimly remember that there is some support for the Euclidean<br>\nalgorithm in<br>\nthe pipeline. What is the status there?</p>\n</blockquote>\n<p>I think you can build on the corresponding theory in Number_Theory, but<br>\nthat needs some further rounds of polishing before I would recommend to<br>\nturn it into a »hard« dependency.  Instead I suggest to put the code<br>\nsetup into a separate theory »Executable_Fraction_Field«.  This is what<br>\nwe did 8 years ago when code generation was still highly experimental…</p>\n<p>Hope this helps,<br>\n     Florian</p>\n<blockquote>\n<p>Best,<br>\nAndreas and Prathamesh</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294654371,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167413
    },
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nDear all,</p>\n<p>Some months ago I noticed the same thing. As Manuel says,<br>\neuclidean_ring_gcd is just euclidean_ring + gcd = gcd_euclid (and the same<br>\nfor Gcd, lcm and Lcm).</p>\n<p>Anyway, in my AFP entry called Echelon_Form there is another variant of the<br>\nManuel's file (see<br>\n<a href=\"http://afp.sourceforge.net/browser_info/current/AFP/Echelon_Form/Euclidean_Algorithm.html\">http://afp.sourceforge.net/browser_info/current/AFP/Echelon_Form/Euclidean_Algorithm.html</a>).</p>\n<p>I just slighly modified his version to move most of theorems presented in<br>\nthe euclidean_ring_gcd class to the euclidean_ring one. In other file (<br>\n<a href=\"http://afp.sourceforge.net/browser_info/current/AFP/Echelon_Form/Euclidean_Algorithm_Extension.html\">http://afp.sourceforge.net/browser_info/current/AFP/Echelon_Form/Euclidean_Algorithm_Extension.html</a>),<br>\nthe following instances were also proven:</p>\n<p>instantiation nat :: euclidean_semiring_gcd<br>\ninstantiation int :: euclidean_ring_gcd<br>\ninstantiation poly :: (field) euclidean_ring<br>\ninstantiation poly :: (field) euclidean_ring_gcd</p>\n<p>Nevertheless, it's worth noting that my files are independent with respect<br>\nthe Manuel's one (which is the one presented in the stardard library). In<br>\naddition, my changes were done with respect to an old version of the<br>\nManuel's file, so probably there have been some<br>\nimprovements/restructurations on his file.</p>\n<p>Best,<br>\nJose</p>",
        "id": 294654412,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167431
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI just looked at all of this again and found the situation to be much <br>\nmore painful than I had remembered. In the long run, we definitely want <br>\nto replace the definitions of the gcd for natural numbers and integers <br>\nwith the gcd_eucl, and then add the current definitions as alternative <br>\ndefinitions and code equations.</p>\n<blockquote>\n<p>I just slighly modified his version to move most of theorems presented in<br>\nthe euclidean_ring_gcd class to the euclidean_ring one.<br>\nI also concluded that that is pretty much the only viable option (other <br>\nthan doing the change I mentioned above, which is probably also what <br>\nAndreas meant initially).</p>\n</blockquote>\n<p>I guess Florian had planned to do this anyway in the course of his <br>\nrefactoring of algebraic type classes, but I don't know what his current <br>\nstatus is on that.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294654421,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167437
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>I am somehow lost how the »algebraic stack« is supposed to look like in<br>\nthe whole example.  Something like Fraction over Poly over Int?<br>\nSince Poly over Int forms a factorial ring but not an euclidean ring,<br>\nthe question is how to generalize normalization of quotients a / b<br>\naccordingly.  It won't work naturally with type classes:</p>\n<p>Poly over Rat --&gt; normalization via gcd / eucl<br>\n    Poly over Poly over Rat --&gt; somehow different</p>\n<p>Hence, some type class magic would be needed to detect whether to use<br>\nthe rather efficient euclidean algorithm or something different – or<br>\neven refrain from normalization at all!?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/YdawJ_l3EOHRWRbzxufiwRzn/signature.asc\">signature.asc</a></p>",
        "id": 294654589,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167515
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nThis discussion is leaving the scope of isabelle-users since we are<br>\ntalking about ongoing developments in the Isabelle repository,<br>\nnevertheless here a short preview:</p>\n<ul>\n<li>\n<p>The next Isabelle release will (in Complex-Main) contain type classes<br>\nfor generic gcd, lcm, Gcd, Lcm with the most fundamental instances<br>\n(hence no euquivalence problems).</p>\n</li>\n<li>\n<p>Before we can continue to move the euclidean algorithm itself to<br>\nComplex-Main, the existing theories must be cleaned-up by removing<br>\nduplicates, generalizing what can be generalized etc concerning<br>\ngcd/lcm/Gcd/Lcm.</p>\n</li>\n<li>\n<p>After that, the euclidean algorithm can be absorbed into Complex-Main.</p>\n</li>\n</ul>\n<p>I have this on my agenda, but not prioritized.  Any help concerning the<br>\nGCD cleanup is appreciated.</p>\n<p>Detaisl could be discussed on isabelle-dev.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/zX02UxEeMLIl76pYD0e1oOhN/signature.asc\">signature.asc</a></p>",
        "id": 294654641,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167536
    }
]