[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi,</p>\n<p>We are trying to use the dynamic evaluation facility of the code generator to evaluate <br>\nIsabelle terms in different target languages. The theory below (also attached) shows our <br>\nreduced setup, which follows Quickcheck's narrowing engine, and a minimal example. <br>\nUnfortunately, we keep getting exceptions during the serialisation. Apparently, we are not <br>\nusing the functions correctly, but we have no clue what could be wrong.</p>\n<p>Can anyone spot the mistake or provide some background how Code_Target.evaluator is <br>\nsupposed to be used?</p>\n<p>theory Scratch imports \"~~/src/HOL/Main\" begin</p>\n<p>datatype foo = Foo</p>\n<p>ML {*<br>\nfun do_something _ = true;<br>\nfun test target =<br>\n   Code_Thingol.dynamic_value @{theory} (fn _ =&gt; I)<br>\n     (fn naming =&gt; fn program =&gt; fn ((_, vs_ty), t) =&gt; fn deps =&gt;<br>\n        do_something<br>\n          (Code_Target.evaluator @{theory} target naming program deps (vs_ty, t)))<br>\n     @{term \"Foo\"}<br>\n*}</p>\n<p>ML {* test \"Scala\" <em>}    --{</em> Match  (line 176 of \"~~/src/Tools/Code/code_scala.ML\") *}<br>\nML {* test \"SML\" <em>}      --{</em> Option (line 81 of \"General/basics.ML\") *}<br>\nML {* test \"Haskell\" <em>}  --{</em> Match  (line 137 of \"~~/src/Tools/Code/code_symbol.ML\") *}</p>\n<p>end</p>\n<p>Thanks in advance for any suggestions,<br>\nAndreas<br>\n<a href=\"/user_uploads/14278/63BKIB0JGum3Y5xmN6mHxinj/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294280979,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920355
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>Can anyone spot the mistake or provide some background how<br>\nCode_Target.evaluator is supposed to be used?</p>\n</blockquote>\n<p>this is indeed a very uncomfortable corner of the system.  The<br>\nevaluation stack has to accomplish a couple of issues at the same time:</p>\n<ul>\n<li>consistent embedding into the pre-/postprocessor infrastructure</li>\n<li>sane separation of static and dynamic context</li>\n<li>dealing with extralogical questions »how to compile strings to values«<br>\nand such.</li>\n</ul>\n<p>When building similar thing, it is best to follow structure<br>\nCode_Runtime.  The Quickcheck Narrowing engine is an experimental<br>\n(though apparently operative) ad-hoc approach toward code generation and<br>\ndefinitely nothing I recommend to glimpse from in that respect.</p>\n<blockquote>\n<p>theory Scratch imports \"~~/src/HOL/Main\" begin</p>\n<p>datatype foo = Foo</p>\n<p>ML {*<br>\nfun do_something _ = true;<br>\nfun test target =<br>\n  Code_Thingol.dynamic_value @{theory} (fn _ =&gt; I)<br>\n    (fn naming =&gt; fn program =&gt; fn ((_, vs_ty), t) =&gt; fn deps =&gt;<br>\n       do_something<br>\n         (Code_Target.evaluator @{theory} target naming program deps<br>\n(vs_ty, t)))<br>\n    @{term \"Foo\"}<br>\n*}</p>\n</blockquote>\n<p>Formally, this does not look bad.  A slightly refined version:</p>\n<blockquote>\n<p>datatype foo = Foo<br>\ndefinition \"bar x = x\"</p>\n<p>ML {*<br>\nval t = @{term \"Foo\"}; </p>\n<p>fun do_something ([(_, s)], _) = (writeln s; true);<br>\nfun test thy target =<br>\n  Code_Thingol.dynamic_value thy (fn _ =&gt; I)<br>\n    (fn naming =&gt; fn program =&gt; fn ((_, vs_ty), t) =&gt; fn deps =&gt;<br>\n       do_something<br>\n         (Code_Target.evaluator thy target naming program deps (vs_ty, t)))<br>\n    t<br>\n*}</p>\n<p>ML {* test @{theory} \"Scala\" *}<br>\nML {* test @{theory} \"SML\" *}<br>\nML {* test @{theory} \"Eval\" *}<br>\nML {* test @{theory} \"Haskell\" *} </p>\n</blockquote>\n<p>Two observations:<br>\na) Scala will choke always.  As of Isabelle2013-2, Scala just does not<br>\ncarry on for evaluation.<br>\nb) The problems with the other invocations vanish as soon as you replace<br>\nterm \"Foo\" by the logically identical \"bar Foo\".  Don't ask me exactly<br>\nwhy, but it could be a misbehaviour wrt. dependencies which for subtle<br>\nreasons does not show up in the existing applications.</p>\n<p>Both problems cannot be reproduced on the ongoing development branch.<br>\nSince we are converging towards a release, you might consider basing<br>\nyour work on a particular source code revision until the next release.</p>\n<p>The whole evaluation stack has seen considerable reworking and<br>\nclarification during the last months and subtle misbehaviours are likely<br>\nto have been eliminated.</p>\n<p>I'm not giving this advice light-minded but I trust your experience.  In<br>\ncase, we should continue the discussion on isabelle-dev.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/gB-AiAIJudiU6iOSUgOiBosQ/signature.asc\">signature.asc</a></p>",
        "id": 294281063,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920373
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>Thank you for the quick response.</p>\n<blockquote>\n<p>When building similar thing, it is best to follow structure<br>\nCode_Runtime.  The Quickcheck Narrowing engine is an experimental<br>\n(though apparently operative) ad-hoc approach toward code generation and<br>\ndefinitely nothing I recommend to glimpse from in that respect.<br>\nIn Code_Runtime, we have not found anything related to actually writing out the files, <br>\ncompiling and executing them and reading back the input. This is essentially what we take <br>\nfrom Quickcheck_Narrowing. We am aware that the whole setup with narrowing_engine.hs is ad <br>\nhoc and we avoid that.</p>\n</blockquote>\n<p>There is also something in both Code_Runtime and Quickcheck_Narrowing that we have not yet <br>\nunderstood. What is the purpose of the cookies that appear everywhere? So far, our <br>\nsolution seems to work without them, but maybe our testcases are too simple.</p>\n<blockquote>\n<p>Both problems cannot be reproduced on the ongoing development branch.<br>\nSince we are converging towards a release, you might consider basing<br>\nyour work on a particular source code revision until the next release.</p>\n<p>The whole evaluation stack has seen considerable reworking and<br>\nclarification during the last months and subtle misbehaviours are likely<br>\nto have been eliminated.</p>\n<p>I'm not giving this advice light-minded but I trust your experience.  In<br>\ncase, we should continue the discussion on isabelle-dev.<br>\nThe problem is that it is not just me, but also a student working on this. We'll think <br>\nabout this and let you know if we switch.</p>\n</blockquote>\n<p>Best,<br>\nAndreas</p>",
        "id": 294281150,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920403
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi again,</p>\n<blockquote>\n<blockquote>\n<p>When building similar thing, it is best to follow structure<br>\nCode_Runtime.  The Quickcheck Narrowing engine is an experimental<br>\n(though apparently operative) ad-hoc approach toward code generation and<br>\ndefinitely nothing I recommend to glimpse from in that respect.<br>\nIn Code_Runtime, we have not found anything related to actually writing<br>\nout the files, compiling and executing them and reading back the input.<br>\nThis is essentially what we take from Quickcheck_Narrowing. We am aware<br>\nthat the whole setup with narrowing_engine.hs is ad hoc and we avoid that.</p>\n</blockquote>\n</blockquote>\n<p>the actual compiler invocation is in these lines in Code_Runtime:</p>\n<blockquote>\n<p>fun exec verbose code =<br>\n  (if ! trace then tracing code else ();<br>\n  ML_Context.exec (fn () =&gt; Secure.use_text ML_Env.local_context (0, \"generated code\") verbose code));</p>\n</blockquote>\n<blockquote>\n<p>There is also something in both Code_Runtime and Quickcheck_Narrowing<br>\nthat we have not yet understood. What is the purpose of the cookies that<br>\nappear everywhere? So far, our solution seems to work without them, but<br>\nmaybe our testcases are too simple.</p>\n</blockquote>\n<p>The cookies are a device to connect to ML more or less raw compiler to<br>\nthe runtime system.</p>\n<p>In an ideal world, the ML compiler could provide a function</p>\n<p>evaluate : ml_program -&gt; ml_expr -&gt; tau</p>\n<p>where ml_program is an abstract representation of an ML program, ml_expr<br>\nis an abstract representation of an ML expression, and tau is the<br>\nexpected result type.  The compiler would then compile the program,<br>\nevaluate the expression against it and return the internalized value<br>\n(raising and exception on type mismatch).</p>\n<p>But we do not have this in ML as used by Isabelle (I do not know whether<br>\nparticular compilers provided such extensions).  What we have else is<br>\nsomething like</p>\n<p>compile : string -&gt; unit</p>\n<p>where string is ML source code which is compiled resulting in a side<br>\neffect on the underlying ML environment.</p>\n<p>Here the cookie comes in.  It has three fields get, put, put_ml.  The<br>\nplain string put_ml is a reference by name to a slot which can be filled<br>\nwith an evaluation result.  After compilation, the internalized<br>\nevaluation result can be obtained using get.  The put is just a security<br>\ndevice to make sure that the connection between put and put_ml has not<br>\nbeen broken by name space shadowing etc.  Thus:</p>\n<p>val _ put error_evaluation<br>\n    val _ = compile (»compiled program, containing a value which is<br>\nstored using put_ml (by name)«)<br>\n    val result = get ctxt;</p>\n<p>I have spent a lot of thought for alternative patterns here, but have<br>\nnot been able to find any.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/_UfIqTINoS1HRMUhitgsqoKT/signature.asc\">signature.asc</a></p>",
        "id": 294281180,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920413
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nWhat went out well in the past in such borderline situations:</p>\n<ol>\n<li>\n<p>start with a certain revision where you have the impression that its<br>\npotential oddities do not hinder you project proper</p>\n</li>\n<li>\n<p>stick to that revision<br>\n  a) until a new release (candidate) is approaching<br>\n  b) until you realise that the assumption from 1. is not valid.</p>\n</li>\n</ol>\n<p>But don't miss 2. a) finally.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/FzoCAhcx4NnMzjqfv-4nGIFQ/signature.asc\">signature.asc</a></p>",
        "id": 294281191,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920420
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<blockquote>\n<blockquote>\n<p>In Code_Runtime, we have not found anything related to actually writing<br>\nout the files, compiling and executing them and reading back the input.<br>\nThis is essentially what we take from Quickcheck_Narrowing. We am aware<br>\nthat the whole setup with narrowing_engine.hs is ad hoc and we avoid that.</p>\n</blockquote>\n<p>the actual compiler invocation is in these lines in Code_Runtime:</p>\n<blockquote>\n<p>fun exec verbose code =<br>\n   (if ! trace then tracing code else ();<br>\n   ML_Context.exec (fn () =&gt; Secure.use_text ML_Env.local_context (0, \"generated code\") verbose code));<br>\nThis is a compiler invocation, but within Isabelle's PolyML process. That is not what I <br>\nmeant in the above. We need to write out the files and compile and run them using external <br>\nprograms such as GHC.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>There is also something in both Code_Runtime and Quickcheck_Narrowing<br>\nthat we have not yet understood. What is the purpose of the cookies that<br>\nappear everywhere? So far, our solution seems to work without them, but<br>\nmaybe our testcases are too simple.</p>\n</blockquote>\n<p>The cookies are a device to connect to ML more or less raw compiler to<br>\nthe runtime system.<br>\nThanks for the explanation. That confirms my feeling that we probably do not need these <br>\ncookies, because our application do not invoke the ML compiler inside Isabelle's ML <br>\nprocess any more.</p>\n</blockquote>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294281256,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920441
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nThen your life is easy: just invoke your external process and return<br>\nyour result.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/Q-yJjIEmgjFGQ_uU4oNXmjS-/signature.asc\">signature.asc</a></p>",
        "id": 294281489,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920508
    }
]