[
    {
        "content": "<p>From: Fabian Hellauer &lt;<a href=\"mailto:hellauer@in.tum.de\">hellauer@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>in this example</p>\n<p>theory Scratch<br>\n     imports Main \"~~/src/HOL/Library/Code_Target_Nat\"<br>\n   begin</p>\n<p>fun foo :: \"'a list ⇒ 'a list ⇒ nat ⇒ bool\" where<br>\n       \"foo (t#ts) (s#ss) 0 ⟷ False\" |<br>\n       \"foo (t#ts) ss (Suc i) ⟷ False\" |<br>\n       \"foo ts [] 0 ⟷ False\" |<br>\n       \"foo [] ss _ ⟷ False\"</p>\n<p>export_code foo in SML</p>\n<p>end</p>\n<p>the code export fails with the message:<br>\n     \"Nat.zero_nat_inst.zero_nat\" is not a constructor, on left hand <br>\nside of equation, in theorem: foo ?ts [] zero_nat_inst.zero_nat ≡ False</p>\n<p>If I remove any of the three arguments, it works fine.<br>\nDo you have an idea what is going on?</p>\n<p>Cheers,<br>\nFabian<br>\n<a href=\"/user_uploads/14278/n1_KynQptiIDFRWtqerpaAkP/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294710860,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182149
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Fabian,</p>\n<p>The problem is that your function has been defined with pattern-matching on natural <br>\nnumbers and lists, but by importing Code_Target_Nat, you have instructed the code <br>\ngenerator to implement natural numbers as target-language integers, so pattern matching on <br>\nnatural numbers cannot be done any more. This is what the error message tells you.</p>\n<p>In most of the cases, you do not notice this problem because Code_Target_Nat installs a <br>\npreprocessor for code equations that eliminates pattern matches on natural numbers. <br>\nUnfortunately, this preprocessor does not work in all cases. Basically, whenever there is <br>\nan equation</p>\n<p>foo pat1 pat2 0 = rhs1</p>\n<p>then there must also be an equation</p>\n<p>foo pat1 pat2 (Suc n) = rhs2 n</p>\n<p>with the same patterns pat1 and pat2 such that they can be combined to</p>\n<p>foo pat1 pat2 x = if x = 0 then rhs1 else rhs (x - 1)</p>\n<p>For your function foo, this is not the case, as there is the pattern</p>\n<p>foo ts [] 0 = False</p>\n<p>but no corresponding</p>\n<p>foo ts [] (Suc n) = ...</p>\n<p>This problem is well-known [1]. A student of mine and I are currently working on a proper <br>\nsolution for this. For the time being, you can manually complete the missing patterns in <br>\nthe code equations as follows:</p>\n<p>lemmas foo_code [code] =<br>\n   foo.simps(1)<br>\n   foo.simps(2)[of _ _ \"[]\"]<br>\n   foo.simps(2)[of _ _ \"_ # _\"]<br>\n   foo.simps(3)[of \"_ # _\"]<br>\n   foo.simps(4)[of _ _ \"0\"]<br>\n   foo.simps(5)</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>[1] <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-September/msg00078.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-September/msg00078.html</a></p>",
        "id": 294710870,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182155
    }
]