[
    {
        "content": "<p>From: \"C.A. Watt\" &lt;<a href=\"mailto:caw77@cam.ac.uk\">caw77@cam.ac.uk</a>&gt;<br>\nHi Andreas</p>\n<p>Thanks for your detailed answer! It was a steep learning curve, but I <br>\nnow have the proofs I want. The secret ingredient was the function using <br>\nHilbert choice in the style of the JinjaThreads Runs_into_Runs_table.</p>\n<p>Thanks again for your help!</p>\n<p>Best wishes<br>\nConrad</p>",
        "id": 294733748,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189040
    },
    {
        "content": "<p>From: \"C.A. Watt\" &lt;<a href=\"mailto:caw77@cam.ac.uk\">caw77@cam.ac.uk</a>&gt;<br>\nHello</p>\n<p>I've been attempting some coinductive proofs, and I've hit a situation <br>\nwhere I'm not sure to proceed. Any help would be greatly appreciated. <br>\nI've tried to make the situation as abstract as possible in the attached <br>\ntheory file.</p>\n<p>In this setting, I have a predicate P defined in terms of two <br>\ncoinductive predicates. I would like to be able to perform coinduction <br>\non it. I can define a variant of P, P_co, directly as a coinduction, <br>\neffectively unfolding the two underlying predicates simultaneously, and <br>\nthis allows me to prove everything I want to coinductively.</p>\n<p>In other areas of my proof, I would strongly prefer to use P's <br>\nrepresentation. I want to either derive a coinduction rule for P so that <br>\nI no longer need P_co, or to prove that P_co implies P, whichever is <br>\neasier. However I've not been able to complete either proof.</p>\n<p>I imagine this has some relation to the discussion/solutions presented <br>\nbelow, but I've not been able to follow through the connection myself.<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-November/msg00045.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-November/msg00045.html</a><br>\n<a href=\"https://isabelle.in.tum.de/dist/Isabelle2017/doc/corec.pdf\">https://isabelle.in.tum.de/dist/Isabelle2017/doc/corec.pdf</a></p>\n<p>Thanks in advance for any comments or suggestions. I'm new to <br>\ncoinduction in Isabelle (and in general), so apologies if there is <br>\nsomething fundamental that I've missed.</p>\n<p>Best wishes<br>\nConrad Watt<br>\n<a href=\"/user_uploads/14278/M35M64Odx6scmau-0bhIaIL0/Test_Coinduction.thy\">Test_Coinduction.thy</a></p>",
        "id": 294736474,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189980
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Conrad,</p>\n<p>Let me first summarize how I understand your abstract example. transition describes a <br>\ntransition system between states, and state_abs is an abstraction function on states. <br>\nabs_equiv is a relation on abstract states (possibly an equivalence relation).</p>\n<p>The relation abs_trace associates with a start state all complete runs of the transition <br>\nsystem starting in this state, as a sequence of abstracted states. P is then the relation <br>\ncomposition of the abs_trace relation with the lifted abs_equiv relation.</p>\n<p>All the functions and predicates in here are \"primitively corecursive\" in that they only <br>\npeel off one constructor at a time. So you don't need coinduction upto friends here. I'd <br>\nrecommend to actually split the abs_trace definition into two. (Warning: I haven't worked <br>\nout the following in detail; it's just a sketch.)</p>\n<ol>\n<li>\n<p>Define a relation \"trace\" from states to complete runs of concrete states. Then prove that</p>\n<p>trace s l' ==&gt; EX l. abs_trace s l &amp; l = lmap state_abs l'</p>\n</li>\n</ol>\n<p>and</p>\n<p>abs_trace s l ==&gt; EX l'. trace s l' &amp; l = lmap state_abs l'</p>\n<p>For the second implication, you want to define a primitively recursive function that <br>\nconstruct a concrete run from an abstract run using Hilbert choice. In my AFP entry <br>\nJinjaThreads, the theory LTS provides a bunch of examples in a similar context, e.g., the <br>\nlemma Runs_into_Runs_table.</p>\n<ol start=\"2\">\n<li>\n<p>The property l = lmap state_abs l' is equivalent to saying \"llist_all2 (BNF_Def.Grp <br>\nUNIV state_abs) l l'\". So we have</p>\n<p>P s l ==&gt;<br>\n EX l'. trace s l' &amp;<br>\n   (llist_all2 (BNF_Def.Grp UNIV state_abs) OO llist_all2 abs_equiv) l l'</p>\n</li>\n</ol>\n<p>and vice versa.</p>\n<ol start=\"3\">\n<li>\n<p>Now, the crucial bit is the lemma llist.rel_Grp. With that, you can transform</p>\n<p>llist_all2 (BNF_Def.Grp UNIV state_abs) OO llist_all2 abs_equiv</p>\n</li>\n</ol>\n<p>into</p>\n<p>llist_all2 (BNF_Def.Grp UNIV state_abs OO abs_equiv)</p>\n<p>i.e., the equivalence closure of the abstraction function. With that characterisation, you <br>\nshould be able to prove a suitable coinduction rule for starting from trace's.</p>\n<p>As I mentioned earlier, my theory LTS in JinjaThreads does many such hops (except for the <br>\nllist.rel_Grp part), so you may go and look for some inspiration there.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294736487,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189985
    }
]