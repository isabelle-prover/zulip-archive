[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I am trying to convert the Coinductive entry in the AFP to use the new <br>\nBNF package for the type definitions. So far, the type the type ('a, 'b) <br>\ntlist has been defined as a quotient of ('a llist * 'b), where 'a llist <br>\nhas been constructed directly in a coinductive style. Most definitions <br>\nand lemmas about tllist are simply lifted versions of their 'a llist <br>\ncounterparts.</p>\n<p>Now, I am wondering whether it is sensible to convert this to BNF or <br>\nwhether I should better stick to the current setup. Or can I have it <br>\nboth ways? Can I define tllist with the BNF package and then setup the <br>\nquotient package manually (similar to what setup_lifting does for <br>\ntypedefs)? Or can I define the type via quotient_type and then declare <br>\nto the BNF package that tllist is actually</p>\n<p>codata ('a, b) tllist = TNil 'b | TCons 'a \"('a, b') tllist\"</p>\n<p>(this would be similar to rep_datatype)? How could I achieve this? Is <br>\nthere some documentation or example around?</p>\n<p>Thanks in advance for any suggestions,<br>\nAndreas</p>",
        "id": 294237825,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905569
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<p>You can setup the Lifting package manually even for quotient types. <br>\nAgain by setup_lifting by providing the Quotient theorem (and optionally <br>\nreflp theorem). See the documentation in The Isabelle/Isar Reference <br>\nManual. An example is in Word.thy. The command setup_lifting is not only <br>\nfor typedefs.</p>\n<p>If you mean the Quotient package by Kaliszyk, Urban, I think you would <br>\nhave to go to the ML level (which doesn't exist, I know ;)) to setup the <br>\npackage manually.</p>\n<p>Ondrej</p>",
        "id": 294237855,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905585
    },
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<p>If you go for the \"quotient -&gt; BNF\" direction, there are a couple of things you can do.</p>\n<ol>\n<li>The \"wrap_data\" command derives all the characteristic lemmas that are common for datatypes and codatatypes. It is somewhat similar to \"rep_datatype\" but not quite, because it has nothing to do with (co)induction and (co)recursion, only constructors, discriminators, and selectors. Here's an example of its use<p>wrap_data [Nil, Cons] list_case [] [[], [hd, tl]] [[hd: undefined, tl: Nil]]<br>\n  apply -<br>\n  apply (erule list.exhaust, assumption)<br>\n  apply (rule list.inject)<br>\n  apply (rule list.distinct)<br>\n  apply (rule list.cases)+<br>\n  done</p>\n<p>print_theorems</p>\n</li>\n</ol>\n<p>Here \"Nil\", \"Cons\", and \"list_case\" must already exist, whereas \"hd\" and \"tl\" are defined by the command. The syntax is</p>\n<p>wrap_data &lt;constructors&gt; &lt;case&gt; &lt;discriminator names&gt; &lt;selector names&gt; &lt;default values&gt;</p>\n<p>(see \"bnf_wrap.ML\" for details). With a bit of ML, you could export the properties of codatatypes and their (co)iterators/recursors under the familiar names given by \"codata\". Ideally, we would rename \"wrap_data\" to, say, \"wrap_pre_data\" and provide additionally \"wrap_data\" and \"wrap_codata\" to finish the job. Perhaps you could help us design good interfaces for this pair, since you apparently would need \"wrap_codata\".</p>\n<ol start=\"2\">\n<li>If you want to do (co)recursion through one of the \"tllist\" type arguments, you will need to register the type as a BNF. For this there currently is only one way, namely \"bnf_def\", which you already used before for the \"option\" type IIRC.</li>\n</ol>\n<p>I hope this helps.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294237860,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905587
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nCan some of the quotient guys please clarify the situation.</p>\n<p>How many quotient packages are there at the moment in Isabelle? Are there <br>\nplans to converge them, and remove old stuff?</p>\n<p>I know that this is a lot of extra work, but this is how we usually <br>\nmanaged to keep things going (and moving forward) over so many years.</p>\n<p>Makarius</p>",
        "id": 294237873,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905592
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nThere is one Quotient package and there is Lifting and Transfer, which <br>\nalmost subsume the functionality of the Quotient package regarding <br>\ndefining new constants and transferring goals. When Lifting and Transfer <br>\nsubsume the Quotient package completely, the Quotient package will be <br>\nprobably outdated and eventually removed. Only the quotient_type command <br>\nwill be preserved. It's on my todo list but not really on the top <br>\nbecause there are more important things to be done.</p>\n<p>As far as I know, the only place where some extra features of the <br>\nQuotient package (that are not covered by Lifting and Transfer) are used <br>\nis Nominal2.</p>\n<p>Ondrej</p>",
        "id": 294237900,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905598
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Ondřej and Jasmin,</p>\n<p>thanks for the feedback.</p>",
        "id": 294238001,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905635
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 7 Mar 2013, Cezary Kaliszyk wrote:</p>\n<blockquote>\n<p>On Thu, Mar 7, 2013 at 2:12 PM, Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt; wrote:</p>\n<p>On 03/07/2013 12:58 PM, Makarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>On Thu, 7 Mar 2013, Ondřej Kunčar wrote:</p>\n<blockquote>\n<p>If you mean the Quotient package by Kaliszyk, Urban, I think you would<br>\nhave to go to the ML level (which doesn't exist, I know ;)) to setup<br>\nthe package manually.</p>\n</blockquote>\n<p>Can some of the quotient guys please clarify the situation.</p>\n<p>How many quotient packages are there at the moment in Isabelle? Are<br>\nthere plans to converge them, and remove old stuff?</p>\n<p>I know that this is a lot of extra work, but this is how we usually<br>\nmanaged to keep things going (and moving forward) over so many years.</p>\n<p>Makarius</p>\n</blockquote>\n<p>There is one Quotient package and there is Lifting and Transfer, which<br>\nalmost subsume the functionality of the Quotient package regarding defining<br>\nnew constants and transferring goals.<br>\nAs far as I know, the only place where some extra features of the Quotient<br>\npackage (that are not covered by Lifting and Transfer) are used is Nominal2.</p>\n</blockquote>\n<p>Right, at some point we tried to define a simple nominal datatype<br>\nusing Lifting/Transfer in Nominal2, but it cannot transfer all the<br>\ntheorems that Quotient can.</p>\n<p>For example the exhausts theorems for many datatypes fail to transfer<br>\nwith the Transfer package. It is possible to reprove them using the<br>\ntheorems that Transfer is able to use, but the purpose of the Quotient<br>\npackage is automating such tasks...</p>\n<p>I do not know if the issue would be the same for the co-datatypes.</p>\n</blockquote>\n<p>Thanks, this sheds more light on the situation.  It also helps Isabelle <br>\nusers to keep an overview.</p>\n<p>Concerning Nomimal2, someone was asking about it on the Nominal mailing <br>\nlist recently: to include some Isabelle application in AFP that depends on <br>\nNomimal2, it has to be available in some official manner.  AFP already has <br>\na \"temporary\" copy of Nominal2 now, but what is its relation to the main <br>\nNominal2 repository, and its relation to Nominal1 that is part of <br>\nIsabelle2013 (and earlier)?</p>\n<blockquote>\n<p>As for the differences between Quotient and Lifting+Transfer, apart<br>\nfrom missing regulatization (the above), Quotient has been designed to<br>\nbe used not only interactively, but also from the ML level.</p>\n</blockquote>\n<p>Proper Isabelle/ML interfaces are indeed very important for <em>any</em> package. <br>\nIt is the first thing a tool author should do, before adding some conrete <br>\nsyntax icing on the cake (for end-users who won't build their own tools on <br>\ntop of other tools).</p>\n<p>Generally, I hope that the misleading terminology of Isabelle \"ML level\" <br>\nand \"Scala layer\" (which was introduced myself) will eventually disappear. <br>\nIt is just Isabelle/ML, Isabelle/Scala, Isabelle/Isar, Isabelle/Pure, <br>\nIsabelle/HOL, Isabelle/....  Many aspects of a system, and many of them <br>\ncannot be assigned to a \"level\" or \"layer\" at all, because they are <br>\nintertwined.</p>\n<p>The term \"ML level\" is particularly bad, because it sounds like something <br>\nalien and inaccessible at the bottom of the pit.  If that were the case, <br>\nthe Prover IDE would not provide so much support for editing Isabelle/ML <br>\nas part of regular theory sources.</p>\n<p>Makarius</p>",
        "id": 294238009,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905641
    }
]