[
    {
        "content": "<p>From: Dominic Mulligan via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi all,</p>\n<p>I have a problem with a development that I am working on (in Isabelle<br>\n2015).  A slimmed down and simplified version of the problematic code<br>\nhas been attached in a dedicated theory file to this e-mail with the<br>\nproblem annotated with an (* XXX *) comment.</p>\n<p>The problem arises when trying to prove termination of recursive<br>\nfunctions that follow a fairly natural monadic programming style,<br>\nnamely recursively calling your function on a decreasing argument that<br>\nis produced by earlier monadic code, hence lambda-bound following a<br>\nbind.  Here, the termination machinery seems to generate proof<br>\nobligations that are not solveable, demanding one prove that an<br>\narbitrary list is shorter (according to the measure) than a non-empty<br>\nlist, like so:</p>\n<p>⋀xs xa. xs ≠ [] ⟹ length xa &lt; length xs</p>\n<p>Interestingly, HOL4's termination machinery also seems to behave<br>\nsimilarly, and with the help of Anthony Fox the issue has been<br>\nreported to Konrad Slind.</p>\n<p>Does anybody have any suggestions on how to proceed other than<br>\ncompletely rewriting all of my monadic code?  The problematic code is<br>\nautomatically generated, and comes from a rather large model, so I'd<br>\nrather not have to rewrite everything.</p>\n<p>Many thanks for any help proffered,<br>\nDominic<br>\n<a href=\"/user_uploads/14278/kVxrncODgGk-NSJJUC74pirf/Strange_Termination.thy\">Strange_Termination.thy</a></p>",
        "id": 294655870,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168002
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThe problem is that you have a recursive call in an argument of the <br>\n‘bind’ function, and the function package has no idea what kind of <br>\nparameter this call will get.</p>\n<p>For instance, the ‘bind’ function could simply double the list it gets <br>\nas the first input and call the function it gets as second input on it – <br>\nthen your function would never terminate.</p>\n<p>So, what you need to do is you need to tell the function package a <br>\nlittle bit about what kinds of inputs the ‘bind’ function will give to <br>\nits function parameter. You can do that with a congruence rule:</p>\n<p>lemma error_bind_cong [fundef_cong]:<br>\n   \"(map_error f x = map_error f' x') ⟹ error_bind x f = error_bind x' f'\"<br>\n   by (cases x; cases x') simp_all</p>\n<p>This essentially implies that bind only calls the function you give it <br>\nwith a value contained in the error object you give it. Once you have <br>\nproven this lemma and declared it as [fundef_cong], your proof <br>\nobligation in the termination proof will look a lot saner.</p>\n<p>Add two more simp lemmas…</p>\n<p>lemma set_error_fail [simp]: \"set_error (error_fail m) = {}\"<br>\n   by (simp add: error_fail_def)</p>\n<p>lemma set_error_return [simp]: \"set_error (error_return s) = {s}\"<br>\n   by (simp add: error_return_def)</p>\n<p>…and everything works automagically.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>the function package does not know anything about your ‘bind’ function.</p>",
        "id": 294655888,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168008
    },
    {
        "content": "<p>From: Dominic Mulligan via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Manuel,</p>\n<p>Thanks for your help.  The fundef_cong attribute is what I had been missing!</p>\n<p>Dominic</p>",
        "id": 294655901,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168014
    },
    {
        "content": "<p>From: Dominic Mulligan via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>Actually, after returning to this subject after unfortunately getting<br>\ndistracted doing something else, I'm afraid that the lemmas that<br>\nManuel suggested do not seem to work in transforming the termination<br>\nconditions generated by Isabelle into something that looks provable.<br>\nI've attached the same stripped down Isabelle theory file as last time<br>\nwith the suggested lemmas added, marked as fundef_cong, and the issue<br>\nremains at the point marked XXX.  This persists after trying to use<br>\nsome alternative congruence rules, also.</p>\n<p>Part of the issue is that I have no idea what the need for the rather<br>\nmysterious set_error_fail and set_error_return lemmas is in Manuel's<br>\nprevious e-mail, or how I would even go about finding the need for<br>\nthose lemmas.  From what I understand the \"set_error\" constant is<br>\nautomatically generated by the new datatype machinery, but how this<br>\ninteracts with termination is not clearly documented in either of the<br>\nDatatype or Function PDFs bundled with Isabelle.</p>\n<p>Lastly, is there any way to get Isabelle to spit out which congruence<br>\nrules it is trying to apply when constructing these proof obligations,<br>\nor which congruence rules it at least has knowledge of other than<br>\ngrepping the Isabelle library source?</p>\n<p>Many thanks for any help,<br>\nDominic<br>\n<a href=\"/user_uploads/14278/4oGUTgCrLxV_8Ywrpywz74p5/Strange_Termination.thy\">Strange_Termination.thy</a></p>",
        "id": 294656242,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168124
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Dominic.</p>\n<p>The congruence rules must be declared as [fundef_cong] before the function definition <br>\ntakes place. In your example, they are declared between the definition and the termination <br>\nproof.</p>\n<p>The theorems about set_error help to automate the termination proof. You can discover such <br>\nlemmas when you try to do the proof manually.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294656269,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168137
    },
    {
        "content": "<p>From: Dominic Mulligan via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Andreas,</p>\n<p>Thanks!  That was obvious in hindsight.  I now have termination<br>\nconditions that look much more amenable.</p>\n<p>Many thanks,<br>\nDominic</p>",
        "id": 294656285,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168147
    }
]