[
    {
        "content": "<p>From: Eg Gloor &lt;<a href=\"mailto:egglue@gmail.com\">egglue@gmail.com</a>&gt;<br>\nHello</p>\n<p>With the \"=\" operator, I can do comparisons like:</p>\n<p>consts<br>\nf :: \"'a1 =&gt; 'a2\"<br>\ng :: \"'a1 =&gt; 'a2 =&gt; 'a3\"</p>\n<p>lemma \"f = g\"<br>\n...</p>\n<p>But in HOL.thy, it's defined as</p>\n<p>eq            :: \"['a, 'a] =&gt; bool\"               (infixl \"=\" 50)</p>\n<p>Since Isabelle/HOL is only simply typed with type variables, how come 'a can<br>\nbe instantiated to 'a1 =&gt; 'a2 and 'b can be instantiated to 'a1 =&gt; 'a2 =&gt;<br>\n'a3, even they are of different arities? However, if f was</p>\n<p>f :: \"real =&gt; real\"</p>\n<p>then type unification fails with \"f = g\".</p>\n<p>Thx</p>",
        "id": 294126636,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660841501
    },
    {
        "content": "<p>From: Eg Gloor &lt;<a href=\"mailto:egglue@gmail.com\">egglue@gmail.com</a>&gt;<br>\nOn Thu, Jan 27, 2011 at 11:42 AM, Christian Maeder &lt;<a href=\"mailto:Christian.Maeder@dfki.de\">Christian.Maeder@dfki.de</a></p>\n<blockquote>\n<p>wrote:</p>\n</blockquote>\n<blockquote>\n<p>Am 27.01.2011 11:24, schrieb Eg Gloor:</p>\n<blockquote>\n<p>Hello</p>\n<p>With the \"=\" operator, I can do comparisons like:</p>\n<p>consts<br>\nf :: \"'a1 =&gt; 'a2\"<br>\ng :: \"'a1 =&gt; 'a2 =&gt; 'a3\"</p>\n<p>lemma \"f = g\"<br>\n...</p>\n<p>But in HOL.thy, it's defined as</p>\n<p>eq            :: \"['a, 'a] =&gt; bool\"               (infixl \"=\" 50)</p>\n<p>Since Isabelle/HOL is only simply typed with type variables, how come 'a<br>\ncan<br>\nbe instantiated to 'a1 =&gt; 'a2 and 'b can be instantiated to 'a1 =&gt; 'a2 =&gt;<br>\n'a3, even they are of different arities?</p>\n</blockquote>\n<p>type variables of polymorphic functions are implicitly quantified and<br>\nare instantiated with fresh variables for each occurrence in<br>\napplications. Therefore the type of f \"'a1 =&gt; 'a2\" with fresh (aka new)<br>\nvariables is unified to say \"'b1 =&gt; 'b2 =&gt; 'b3\" of g (with \"'a2\" being<br>\nspecialized to \"b2 =&gt; 'b3).</p>\n<p>Thanks for the reply. So it seems like it isn't simply-typed afterall, since<br>\n\"'a2\" can be specialised to \"'b2 =&gt; 'b3\". Or is that limited to type<br>\nvariables? If I do something similar with schematic types:</p>\n</blockquote>\n<p>schematic_lemma test: \"(x::?'a=&gt;?'b=&gt;?'c) = (y::?'d=&gt;?'e)\"</p>\n<p>I get a type unification error there. It seems ?'e can't be specialised to<br>\n\"?'b =&gt; ?'c\" in this case.</p>\n<p>Eg</p>\n<p>HTH Christian</p>\n<blockquote>\n<blockquote>\n<p>However, if f was</p>\n<p>f :: \"real =&gt; real\"</p>\n<p>then type unification fails with \"f = g\".</p>\n<p>Thx</p>\n</blockquote>\n</blockquote>",
        "id": 294126656,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660841507
    },
    {
        "content": "<p>From: Christian Maeder &lt;<a href=\"mailto:Christian.Maeder@dfki.de\">Christian.Maeder@dfki.de</a>&gt;<br>\nI'm no Isabelle expert, but I suspect that the types are already<br>\nspecialized differently. Does \"(x::?'a) = (y::?'d)\" work?</p>\n<p>Cheers Christian</p>",
        "id": 294126761,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660841529
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFor the logical framework, schematic variables are arbitrary (can be <br>\ninstantiated), while free variables are fixed (local constant that might <br>\nbecome arbitrary after leaving the scope).</p>\n<p>Type inference has a third category of \"parameters\" that can get unified <br>\nin the type checking process.  There is no user notation for that, apart <br>\nfrom nameless dummies \"_\".  Otherwise type-inference insists that <br>\nschematic and free variables work out as they are written, no <br>\ninstantiation of schematic variables here.</p>\n<p>The above 'schematic_lemma' would give you a chance to instantiate <br>\nschematic variables in the course of reasoning, after type-checking has <br>\nalready succeeded.  Further confusion might be causes by proof tools that <br>\nchoke on schematic type variables in a goal.</p>\n<p>Makarius</p>",
        "id": 294129434,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842286
    },
    {
        "content": "<p>From: <a href=\"mailto:egglue@gmail.com\">egglue@gmail.com</a><br>\nThanks for the reply.</p>\n<p>Could someone please add to why schematic type variables can't be  <br>\nspecialised? Why don't they behave like type variables?</p>\n<p>Thanks</p>\n<p>Eg</p>",
        "id": 294130673,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842689
    },
    {
        "content": "<p>From: Eg Gloor &lt;<a href=\"mailto:egglue@gmail.com\">egglue@gmail.com</a>&gt;<br>\nOn Tue, Feb 1, 2011 at 3:18 PM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>For the logical framework, schematic variables are arbitrary (can be<br>\ninstantiated), while free variables are fixed (local constant that might<br>\nbecome arbitrary after leaving the scope).</p>\n<p>Type inference has a third category of \"parameters\" that can get unified in<br>\nthe type checking process.  There is no user notation for that, apart from<br>\nnameless dummies \"_\".  Otherwise type-inference insists that schematic and<br>\nfree variables work out as they are written, no instantiation of schematic<br>\nvariables here.</p>\n</blockquote>\n<blockquote>\n<p>The above 'schematic_lemma' would give you a chance to instantiate<br>\nschematic variables in the course of reasoning, after type-checking has<br>\nalready succeeded.  Further confusion might be causes by proof tools that<br>\nchoke on schematic type variables in a goal.</p>\n<p>If I understand this correctly, schematic variables can be instantiated but<br>\nschematic <em>type</em> variables cannot due to a restriction of type-inference.<br>\nThus, there's no polymorphism of any kind at the meta-level. Likewise, with<br>\ntype variables because they are free variables. So it's expected that this<br>\nwouldn't work:</p>\n</blockquote>\n<p>lemma \"(x::'a) = (y::'b)\"</p>\n<p>Because both 'a and 'b are free variables. But this works fine:</p>\n<p>const<br>\nx :: 'a</p>\n<p>lemma \"x = (y::'b)\"</p>\n<p>Isn't 'a regarded as a free variable? How come it can be instantiated?</p>\n<p>Thanks again<br>\nEg</p>\n<blockquote>\n<p>Makarius<br>\n</p>\n</blockquote>",
        "id": 294130681,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842691
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOne way to interpret a top-level declaration like \"const x :: 'a\",<br>\nwhose type has a free type variable, is that it actually declares an<br>\ninfinite family of top-level constants. In this case, you get an<br>\ninfinite number of different constants, all named \"x\", but each with a<br>\ndifferent type.</p>\n<p>Later, when you state a lemma like \"x = (y::'b)\", type inference must<br>\nselect which one of this family of constants named \"x\" you mean: Here,<br>\nit concludes that you must have meant \"x::'b\", since that is the only<br>\none that makes the lemma type-correct.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294130748,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842715
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 3 Feb 2011, Eg Gloor wrote:</p>\n<blockquote>\n<p>If I understand this correctly, schematic variables can be instantiated <br>\nbut schematic <em>type</em> variables cannot due to a restriction of <br>\ntype-inference.</p>\n</blockquote>\n<p>Not quite so.  Here is another attempt to summarize the main aspects.</p>\n<p>* Term and type variables can be either \"arbitrary\" (schematic) or<br>\n     \"fixed\" (non-schematic, free).</p>\n<p>* Schematic term/type variables can be instantiated.  For type variables<br>\n     this effectively means some kind of naive polymorphism.</p>\n<p>* Schematic term variables can be explicitly bound via quantification<br>\n     (!! / \\&lt;And&gt;) with arbitrary nesting; type variables cannot be bound<br>\n     like that.</p>\n<p>* Type inference never instantiates schematic term/type variables<br>\n     written by the user.</p>\n<p>* Instead, syntactic type-inference parameters get unified during type<br>\n     inference, but there is no end-user notation for that (the system<br>\n     sometimes prints ??'a).</p>\n<p>* Goal states with schematic type variables are theoretically OK, but<br>\n     often break existing proof tools.</p>\n<blockquote>\n<p>Thus, there's no polymorphism of any kind at the meta-level.</p>\n</blockquote>\n<p>The Pure framework indeed lacks proper polymorphism.  You only have global <br>\ntypes/consts/theorems that can mention arbitrary types ?'a effectivily <br>\ngiving you some outermost quantification here.  The rest are conjuring <br>\ntricks, in the spirit of original Hindley-Milner polymorphism.</p>\n<p>Before this is getting more complicated: What is your actual application?</p>\n<p>Makarius</p>",
        "id": 294130765,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842721
    },
    {
        "content": "<p>From: Eg Gloor &lt;<a href=\"mailto:egglue@gmail.com\">egglue@gmail.com</a>&gt;<br>\nThanks for the explanation.</p>\n<blockquote>\n<ul>\n<li>Schematic term/type variables can be instantiated.  For type variables<br>\n   this effectively means some kind of naive polymorphism.</li>\n</ul>\n<p>I see. But why do you call it naive? If the variables can be instantiated,<br>\nthen that's polymorphism -- is it not?</p>\n</blockquote>\n<blockquote>\n<p>Before this is getting more complicated: What is your actual application?</p>\n<p>Basically, I'm puzzled by two things:</p>\n</blockquote>\n<p>1) If we look at the following:</p>\n<p>axiomatization<br>\nfunc1 :: \"nat =&gt; nat\" and<br>\nfunc2 :: \"(nat =&gt; nat) =&gt; nat\" and<br>\nfunc3 :: \"'a =&gt; 'b =&gt; 'c\"<br>\nwhere<br>\n*: \"func2 func1 = 0\"</p>\n<p>schematic_lemma lem: \"EX f (c::?'a). f c = 0\"<br>\napply (intro exI)<br>\napply (rule_tac[!] *)<br>\ndone</p>\n<p>thm lem</p>\n<p>EX (f::nat =&gt; nat) c::nat. f c = (0::nat)</p>\n<p>I wasn't expecting c to be of type \"nat\". Since it uses *, c should be<br>\ninstantiated to \"func1\", which is of type \"nat =&gt; nat\". According to the<br>\nprf:</p>\n<p>protectI % EX f c. f c = 0 %%<br>\n (exI % (%x. EX c. x c = 0) % (%a. a) %% (OfClass type_class % TYPE(nat =&gt;<br>\nnat)) %% (exI % (%x. x = 0) % func2 func1 %% (OfClass type_class %<br>\nTYPE(nat)) ...</p>\n<p>f is instantiated to func2 and c is instantiated to func1. How come ?'a is<br>\ninstantiated to \"nat\" and not \"nat =&gt; nat\"?</p>\n<p>2) For the following:</p>\n<p>declare [[unify_search_bound=5]]</p>\n<p>ML {*<br>\nval p = term_of @{cpat \"?f (?c::?'a) = ?v\"};<br>\nval t = @{term \"x (y::nat=&gt;nat) (z::nat=&gt;nat) = (0::nat)\"};<br>\nval mtchers = Unify.matchers @{theory} [(p,t)] |&gt; Seq.list_of;<br>\npretty_insts @{context} (map (fn x =&gt; (x,0)) mtchers)<br>\n*}</p>\n<p>It returns 3 matchers:<br>\n(1) [?c::nat := (x::(nat =&gt; nat) =&gt; (nat =&gt; nat) =&gt; nat) (y::nat =&gt; nat)<br>\n(z::nat =&gt; nat), ?f::nat =&gt; nat := %a::nat. a, ?v::nat := 0::nat]</p>\n<p>[?'a := nat, ?'a1 := nat]</p>\n<p>(2) [?c::?'a := ?c::?'a, ?f::?'a =&gt; nat := %a::?'a. (x::(nat =&gt; nat) =&gt; (nat<br>\n=&gt; nat) =&gt; nat) (y::nat =&gt; nat) (z::nat =&gt; nat), ?v::nat := 0::nat]</p>\n<p>[?'a1 := nat]</p>\n<p>(3) [?c::?'a := z::nat =&gt; nat, ?f::?'a =&gt; ?'a1 := (x::(nat =&gt; nat) =&gt; (nat<br>\n=&gt; nat) =&gt; nat) (y::nat =&gt; nat), ?v::?'a1 := 0::nat]</p>\n<p>[?'a := nat =&gt; nat, ?'a1 := nat]</p>\n<p>How come \"?c\" can't be instantiated to \"z\" but can be instantiated to<br>\n\"y\"? It can do that only if the type of ?c is changed from ?'a to, e.g.,<br>\n?'a=&gt;?'b. Since the schematic type variables, e.g., ?'a can be instantiated,<br>\ne.g., to \"nat\" in (1) and to \"nat =&gt; nat\" in (3), why does the type of ?c<br>\nneed to be explicitly rewritten to, e.g., ?a=&gt;?'b, in order for ?c to be<br>\ninstantiated to functions like \"y\" or %x.x? Is this what you mean by \"naive<br>\npolymorphism\"?</p>\n<p>Note that even when ?c::?'a=&gt;?'b, there are 2 matchers with ?c := z whereas<br>\nthere's only 1 matcher with ?c := y. Do you know what's behind<br>\nthis asymmetry?</p>\n<p>Thanks, again, and look forward to your reply!</p>\n<p>Eg</p>\n<blockquote>\n<p>Makarius<br>\n</p>\n</blockquote>",
        "id": 294130827,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842731
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI've only had time for a brief look at your problem. And I'm not an expert at reading proof objects. But it appears to me that in your first example, the first proof that is found instantiates f to the identity function, so naturally c must be a natural number.</p>\n<p>The other point is that unification cannot always be expected to instantiate a type variable to a function type, as the search space would become too large.</p>\n<p>Larry Paulson</p>",
        "id": 294130977,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842789
    },
    {
        "content": "<p>From: <a href=\"mailto:egglue@gmail.com\">egglue@gmail.com</a><br>\nOn Feb 7, 2011 12:25pm, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>I've only had time for a brief look at your problem. And I'm not an  <br>\nexpert at reading proof objects. But it appears to me that in your first  <br>\nexample, the first proof that is found instantiates f to the identity  <br>\nfunction, so naturally c must be a natural number.</p>\n</blockquote>\n<p>Thanks. I should note that the schematic_lemma lem: \"EX f (c::?'a). fc =  <br>\n(0::nat)\", but the proof object is right. I think you're right -- f is  <br>\ninstantiated to the identity function. If I explicitly instantiate each  <br>\nvariable explicitly, I get the right type.</p>\n<blockquote>\n<p>The other point is that unification cannot always be expected to  <br>\ninstantiate a type variable to a function type, as the search space would  <br>\nbecome too large.</p>\n</blockquote>\n<p>Is this a limitation of the logic or is it a restriction intended by the  <br>\nimplementation? Do you know in what circumstances does the unification not  <br>\ninstantiate a type variable to a function type?</p>\n<p>Thanks<br>\nEg</p>\n<blockquote>\n<p>Larry Paulson</p>\n</blockquote>\n<blockquote>\n<p>On 5 Feb 2011, at 01:22, Eg Gloor wrote:</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Thanks for the explanation.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>Schematic term/type variables can be instantiated. For type variables</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>this effectively means some kind of naive polymorphism.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I see. But why do you call it naive? If the variables can be  <br>\ninstantiated,</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>then that's polymorphism -- is it not?</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Before this is getting more complicated: What is your actual  <br>\napplication?</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Basically, I'm puzzled by two things:</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>1) If we look at the following:</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>axiomatization</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>func1 :: \"nat =&gt; nat\" and</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>func2 :: \"(nat =&gt; nat) =&gt; nat\" and</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>func3 :: \"'a =&gt; 'b =&gt; 'c\"</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>where</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>*: \"func2 func1 = 0\"</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>schematic_lemma lem: \"EX f (c::?'a). fc = 0\"</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>apply (intro exI)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>apply (rule_tac[!] *)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>done</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>thm lem</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>EX (f::nat =&gt; nat) c::nat. fc = (0::nat)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I wasn't expecting c to be of type \"nat\". Since it uses *, c should be</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>instantiated to \"func1\", which is of type \"nat =&gt; nat\". According to the</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>prf:</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>protectI % EX f c. fc = 0 %%</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>(exI % (%x. EX c. xc = 0) % (%a. a) %% (OfClass type_class % TYPE(nat =&gt;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>nat)) %% (exI % (%x. x = 0) % func2 func1 %% (OfClass type_class %</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>TYPE(nat)) ...</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>f is instantiated to func2 and c is instantiated to func1. How come ?'a  <br>\nis</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>instantiated to \"nat\" and not \"nat =&gt; nat\"?</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>2) For the following:</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>declare [[unify_search_bound=5]]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>ML {*</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>val p = term_of @{cpat \"?f (?c::?'a) = ?v\"};</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>val t = @{term \"x (y::nat=&gt;nat) (z::nat=&gt;nat) = (0::nat)\"};</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>val mtchers = Unify.matchers @{theory} [(p,t)] |&gt; Seq.list_of;</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>pretty_insts @{context} (map (fn x =&gt; (x,0)) mtchers)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>*}</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>It returns 3 matchers:</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>(1) [?c::nat := (x::(nat =&gt; nat) =&gt; (nat =&gt; nat) =&gt; nat) (y::nat =&gt; nat)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>(z::nat =&gt; nat), ?f::nat =&gt; nat := %a::nat. a, ?v::nat := 0::nat]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>[?'a := nat, ?'a1 := nat]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>(2) [?c::?'a := ?c::?'a, ?f::?'a =&gt; nat := %a::?'a. (x::(nat =&gt; nat)  <br>\n=&gt; (nat</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>=&gt; nat) =&gt; nat) (y::nat =&gt; nat) (z::nat =&gt; nat), ?v::nat := 0::nat]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>[?'a1 := nat]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>(3) [?c::?'a := z::nat =&gt; nat, ?f::?'a =&gt; ?'a1 := (x::(nat =&gt; nat) =&gt;  <br>\n(nat</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>=&gt; nat) =&gt; nat) (y::nat =&gt; nat), ?v::?'a1 := 0::nat]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>[?'a := nat =&gt; nat, ?'a1 := nat]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>How come \"?c\" can't be instantiated to \"z\" but can be instantiated to</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>\"y\"? It can do that only if the type of ?c is changed from ?'a to, eg,</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>?'a=&gt;?'b. Since the schematic type variables, eg, ?'a can be  <br>\ninstantiated,</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>eg, to \"nat\" in (1) and to \"nat =&gt; nat\" in (3), why does the type of ?c</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>need to be explicitly rewritten to, eg, ?a=&gt;?'b, in order for ?c to be</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>instantiated to functions like \"y\" or %xx? Is this what you mean  <br>\nby \"naive</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>polymorphism\"?</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Note that even when ?c::?'a=&gt;?'b, there are 2 matchers with ?c := z  <br>\nwhereas</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>there's only 1 matcher with ?c := y. Do you know what's behind</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>this asymmetry?</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Thanks, again, and look forward to your reply!</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Eg</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Makarius</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>&gt;</p>\n</blockquote>\n</blockquote>",
        "id": 294131021,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842808
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIt isn't imposed by the logic, but it is more or less essential in any practical implementation.</p>\n<p>Your example (with a function variable) hits the most difficult aspect of higher-order unification, namely, the creation of possible functions to solve a constraint involving a function variable. The restriction prevents transforming a variable of type ?'a into one of some function type.</p>\n<p>Larry Paulson</p>",
        "id": 294131069,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842826
    }
]