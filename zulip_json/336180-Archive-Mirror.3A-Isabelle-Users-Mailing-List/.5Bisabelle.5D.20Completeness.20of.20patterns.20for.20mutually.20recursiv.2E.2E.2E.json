[
    {
        "content": "<p>From: Amy Furniss &lt;<a href=\"mailto:mjf29@leicester.ac.uk\">mjf29@leicester.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>I have a pair of mutually-recursive functions which are defined using<br>\nthe function command, and I'm struggling to prove the completeness of<br>\npatterns for the definition. If I remove one of the recursive calls (so<br>\nthat they are no longer mutually recursive) and separate out the<br>\nfunctions, the completeness of patterns for both functions is easily<br>\nsolved by atomize_elim, auto, but when they are defined together this no<br>\nlonger works. Can anybody please suggest how I might go about solving<br>\nthis pattern completeness subgoal?</p>\n<p>Thanks,</p>\n<p>Amy</p>\n<hr>\n<p>theory Example<br>\nimports Main<br>\nbegin</p>\n<p>datatype type1 = CON | ABS type2 type1<br>\nand type2 = FCON | FAPP type2 type1</p>\n<p>definition regular1 :: \"(type1 \\&lt;Rightarrow&gt; type1) \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n\"regular1 \\&lt;equiv&gt; \\&lt;lambda&gt;z. (z = (\\&lt;lambda&gt;x. x))<br>\n  | (z = (\\&lt;lambda&gt;x. CON))<br>\n  | (\\&lt;exists&gt;f t. z = (\\&lt;lambda&gt;x. ABS (t x) (f x)))\"</p>\n<p>definition regular2:: \"(type1 \\&lt;Rightarrow&gt; type2) \\&lt;Rightarrow&gt; bool\" where<br>\n\"regular2 \\&lt;equiv&gt; \\&lt;lambda&gt;z. (z = (\\&lt;lambda&gt;x. FCON))<br>\n  | (\\&lt;exists&gt;f t. z = (\\&lt;lambda&gt;x. FAPP (t x) (f x)))\"</p>\n<p>function fun1 :: \"(type1 \\&lt;Rightarrow&gt; type1) \\&lt;Rightarrow&gt; type1\"<br>\nand fun2 :: \"(type1 \\&lt;Rightarrow&gt; type2) \\&lt;Rightarrow&gt; type2\" where<br>\n\"fun1 (\\&lt;lambda&gt;x. x) = CON\"<br>\n| \"fun1 (\\&lt;lambda&gt;x. CON) = CON\"<br>\n| \"fun1 (\\&lt;lambda&gt;x. ABS (t x) (f x)) = ABS (fun2 t) (fun1 f)\"<br>\n| \"\\&lt;not&gt;regular1 i \\&lt;Longrightarrow&gt; fun1 i = CON\"<br>\n| \"fun2 (\\&lt;lambda&gt;x. FCON) = FCON\"<br>\n| \"fun2 (\\&lt;lambda&gt;x. FAPP (t x) (f x)) = FAPP (fun2 t) (fun1 f)\"<br>\n| \"\\&lt;not&gt;regular2 i \\&lt;Longrightarrow&gt; fun2 i = FCON\"<br>\napply(unfold regular1_def regular2_def)<br>\napply(atomize_elim)<br>\napply(auto)<br>\nsorry</p>\n<p>end</p>",
        "id": 294238486,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905881
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Amy,</p>\n<p>For mutual recursive definitions, the function package combines the two <br>\nfunctions into one using a sum type. For your proof, you therefore first <br>\nhave to distinguish whether you are in the left or right branch, e.g., <br>\nby case distinction on x. For the completeness part (first subgoal), the <br>\nfollowing works:</p>\n<p>apply(unfold regular1_def regular2_def)<br>\napply(atomize_elim)<br>\napply(case_tac x) (* new *)<br>\napply(auto)</p>\n<p>Mutual recursion also adds four new cases where you have to prove <br>\nconsistency of the projections from the sum type. In your case,<br>\nthe following solves all of them:</p>\n<p>apply(auto simp add: fun_eq_iff intro: arg_cong)</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294238506,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905896
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Amy,</p>\n<p>If you prefer to do it manually, you can instead use the following proof via fun_cong.</p>\n<p>proof -<br>\n  fix t f assume \"(λx. CON) = (λx. ABS (t x) (f x))\"<br>\n  from fun_cong[OF this] show False by simp<br>\nnext<br>\n  fix t f assume \"(λx. FCON) = (λx. FAPP (t x) (f x))\"<br>\n  from fun_cong[OF this] show False by simp<br>\nnext<br>\n  fix t f assume \"(λx. x) = (λx. ABS (t x) (f x))\"<br>\n  from fun_cong[OF this, of CON] show False by simp<br>\nnext<br>\n  fix t :: \"type1 ⇒ type2\" and f ta fa<br>\n  assume \"(λx. FAPP (t x) (f x)) = (λx. FAPP (ta x) (fa x))\"<br>\n  from fun_cong[OF this] have id: \"t = ta\" \"f = fa\" by (intro ext, auto)<br>\n  from id show \"Sum_Type.Projl (fun1_fun2_sumC (Inl f)) = Sum_Type.Projl (fun1_fun2_sumC (Inl fa))\" by simp<br>\n  from id show \"Sum_Type.Projr (fun1_fun2_sumC (Inr t)) = Sum_Type.Projr (fun1_fun2_sumC (Inr ta))\" by simp<br>\nnext<br>\n  fix t :: \"type1 ⇒ type2\" and f ta fa<br>\n  assume \"(λx. ABS (t x) (f x)) = (λx. ABS (ta x) (fa x))\"<br>\n  from fun_cong[OF this] have id: \"t = ta\" \"f = fa\" by (intro ext, auto)<br>\n  from id show \"Sum_Type.Projr (fun1_fun2_sumC (Inr t)) = Sum_Type.Projr (fun1_fun2_sumC (Inr ta))\" by simp<br>\n  from id show \"Sum_Type.Projl (fun1_fun2_sumC (Inl f)) = Sum_Type.Projl (fun1_fun2_sumC (Inl fa))\" by simp<br>\nqed</p>\n<p>But of course, Andreas' proof is easier to type and maintain.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294238508,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905899
    }
]