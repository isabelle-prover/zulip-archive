[
    {
        "content": "<p>From: Denis Nikiforov &lt;<a href=\"mailto:denis.nikif@gmail.com\">denis.nikif@gmail.com</a>&gt;<br>\nHi</p>\n<p>I'm trying to describe semantics of the Object Constraint Language:<br>\n<a href=\"https://github.com/AresEkb/Simple_OCL\">https://github.com/AresEkb/Simple_OCL</a></p>\n<p>I've almost described its type system. The last lemma I can't prove is that<br>\nthe typing rules are deterministic:<br>\n<a href=\"https://github.com/AresEkb/Simple_OCL/blob/master/OCL_Typing.thy\">https://github.com/AresEkb/Simple_OCL/blob/master/OCL_Typing.thy</a></p>\n<p>lemma<br>\n  typing_det: \"Γ1 ⊢ expr : τ1 ⟹ Γ1 ⊢ expr : σ1 ⟹ τ1 = σ1\" and<br>\n  collection_parts_typing_det:<br>\n    \"collection_parts_typing Γ2 prts τ2 ⟹<br>\n     collection_parts_typing Γ2 prts σ2 ⟹ τ2 = σ2\" and<br>\n  iterator_typing_det:<br>\n    \"iterator_typing Γ3 src its body τ31 σ31 ρ31 ⟹<br>\n     iterator_typing Γ3 src its body τ32 σ32 ρ32 ⟹<br>\n     τ31 = τ32 ∧ σ31 = σ32 ∧ ρ31 = ρ32\"</p>\n<p>The problem is that I can't apply any of the following induction rules to<br>\nmy lemmas:<br>\n  apply (induct expr and prts and src body)<br>\n  apply (induct rule:<br>\ntyping_collection_parts_typing_iterator_typing.inducts)</p>\n<p>These answers doesn't help me:<br>\n<a href=\"https://stackoverflow.com/questions/53905744/how-to-prove-lemmas-for-mutually-recursive-types/53906944\">https://stackoverflow.com/questions/53905744/how-to-prove-lemmas-for-mutually-recursive-types/53906944</a><br>\n<a href=\"https://stackoverflow.com/questions/33020622/how-to-fix-illegal-schematic-variables-in-mutually-recursive-rule-induction\">https://stackoverflow.com/questions/33020622/how-to-fix-illegal-schematic-variables-in-mutually-recursive-rule-induction</a></p>\n<p>Everithing works fine on simple examples. But my predicates are more<br>\ncomplicated. And I can't localize what's wrong with my definitions. I can't<br>\nreproduce the problem on a simpler example.</p>\n<p>Could you help me to understand what induction rule I should apply to this<br>\nlemma?</p>",
        "id": 294747933,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194281
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi Denis,</p>\n<p>I haven't tried out your example, but I've seen that your typing <br>\njudgements contain type variables in their types. So I suspect that the <br>\ntypes in your lemma are too general: All three statements contain <br>\ndifferent variables, so Isabelle will type-check them with different <br>\ntype variables. The induct proof method then cannot apply the rule, <br>\nwhich requires all type variables to match like in the inductive <br>\ndefinition. I suggest that you constrain all contexts to the same type, <br>\ne.g., using</p>\n<p>lemma fixes Γ1 Γ2 Γ3 :: \"'a :: semilatice_sup type env\" shows</p>\n<p>Hope this helps<br>\nAndreas</p>",
        "id": 294747954,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194288
    },
    {
        "content": "<p>From: Denis Nikiforov &lt;<a href=\"mailto:denis.nikif@gmail.com\">denis.nikif@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<p>Thanks! It was one of the problems. As I see now I can use the same<br>\nvariables (just Γ instead of Γ1 Γ2 Γ3) in these lemmas. Also I should<br>\nspecify all variables used in the induction rule.<br>\nThe following works:</p>\n<p>lemma<br>\n  typing_det: \"Γ ⊢ expr : τ ⟹ Γ ⊢ expr : σ ⟹ τ = σ\" and<br>\n  collection_parts_typing_det:<br>\n    \"collection_parts_typing Γ prts τ ⟹<br>\n     collection_parts_typing Γ prts σ ⟹ τ = σ\" and<br>\n  iterator_typing_det:<br>\n    \"iterator_typing Γ src its body τ⇩1 σ⇩1 ρ⇩1 ⟹<br>\n     iterator_typing Γ src its body τ⇩2 σ⇩2 ρ⇩2 ⟹<br>\n     τ⇩1 = τ⇩2 ∧ σ⇩1 = σ⇩2 ∧ ρ⇩1 = ρ⇩2\"<br>\nproof (induct Γ expr τ and Γ prts τ and Γ src its body τ⇩1 σ⇩1 ρ⇩1<br>\n       arbitrary: σ and σ and τ⇩2 σ⇩2 ρ⇩2<br>\n       rule: typing_collection_parts_typing_iterator_typing.inducts)</p>\n<p>It was very tricky for me to understand that I should specify both<br>\ninduction rule and all induction variables. Non-mutual induction doesn't<br>\nrequire it.</p>\n<p>вт, 25 дек. 2018 г. в 21:44, Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a></p>",
        "id": 294747959,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194293
    }
]