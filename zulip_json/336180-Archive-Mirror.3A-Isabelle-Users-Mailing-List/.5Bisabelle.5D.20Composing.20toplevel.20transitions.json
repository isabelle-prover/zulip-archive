[
    {
        "content": "<p>From: <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a><br>\nMy understanding is that the function declaration process can be split, <br>\nwith definitions in one place and proofs of termination to follow.</p>\n<p>The function is fully defined in the intermediate state, but key facts <br>\nfor proving anything about it are not present.</p>\n<p>If that is still the case, you can make progress on your problem by <br>\nhaving your package perform all definitions (with all polymorphic type <br>\nmagic) and then have a collective second phase of termination requirements.</p>\n<p>You could either require multiple \"termination\" steps to conclude, each <br>\nprovoking its own proof, or it might be possible to pack all the proof <br>\nobligations into a single proof.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 294709241,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181613
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Thomas,</p>\n<p>I've been arguing about a scheme similar to that with Peter and Ondrej.<br>\nThe theory updates in my command are function definitions. Before I can<br>\ncontinue defining functions, I need to prove termination and congruence<br>\nrules of the earlier ones. Especially the cong rules cannot be proven<br>\nwithout termination. So it's difficult to make progress without having the<br>\ntheorems at hand.</p>\n<p>Another option would be to do a \"trial run\", where I would invoke the<br>\nfunction package beforehand, ignore the updated theory, but look at the<br>\nresulting proof obligations. I can collect and present those to the user<br>\nand perform the actual definitions in the \"after_qed\" step. This would work<br>\nbut also slow down the command by a factor of two.</p>\n<p>I'm a bit reluctant to introduce two commands (let's call them \"embed\" and<br>\n\"embed_termination\"), because in principle, there could be arbitrarily many<br>\ninvocations of the latter before the process is concluded. To me it seems a<br>\nlittle strange to require that.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294709274,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181620
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nMy impression is that this is going into the right direction.</p>\n<p>Conceptually, a definitional package with a proof can indirectly get<br>\nhold of that via the after_qed continuation, which is part of all<br>\nrelevant Isabelle/ML interfaces.</p>\n<p>The function/termination package merely needs to expose this in the<br>\nusual way, with after_qed and after_qed_termination arguments in the<br>\ninitial function command.</p>\n<p>Thus a user-defined command can make a function definition in<br>\nIsabelle/ML, such that its corresponding 'termination' command produces<br>\nfurther function definitions, again with corresponding 'termination'<br>\nproofs by the user. Thus several 'termination' commands (each with its<br>\nown Isar proof) can be somehow chained together.</p>\n<p>There is certainly a challenge here, because of the loose coupling of<br>\n'function' and 'termination': termination commands might follow in any<br>\norder and there might be unrelated function/termination commands in<br>\nbetween. Additional care is required to cope with a potential change of<br>\nlocal_theory targets between 'function' and 'termination' parts, but<br>\nthat situation can already happen in the existing package setup.</p>\n<p>Makarius</p>",
        "id": 294709310,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181627
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>The function/termination package merely needs to expose this in the<br>\nusual way, with after_qed and after_qed_termination arguments in the<br>\ninitial function command.</p>\n</blockquote>\n<p>It seems to me that implementing that wouldn't be very complicated.<br>\nThere are not many occurrences of \"Function.*\" in the distribution/AFP,<br>\nso this might be feasible to do in a day or two. I will investigate this.</p>\n<blockquote>\n<p>There is certainly a challenge here, because of the loose coupling of<br>\n'function' and 'termination': termination commands might follow in any<br>\norder and there might be unrelated function/termination commands in<br>\nbetween. Additional care is required to cope with a potential change of<br>\nlocal_theory targets between 'function' and 'termination' parts, but<br>\nthat situation can already happen in the existing package setup.</p>\n</blockquote>\n<p>That's true. In my case, I'm interacting with the code generator, which<br>\nhas a global setup anyway. I don't have a good story yet about what I'd<br>\ndo if the code setup changed in between.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294709397,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181658
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear list,</p>\n<p>I'm trying to define a command that needs to emit multiple proof<br>\nobligations to the user. The catch is that these proof obligations can<br>\nonly be generated after some interspersed theory updates. More concretely:</p>\n<p>I need to call the function package to define some functions. Of course,<br>\nthis means that in general I have to ask the user for a proof<br>\nobligation. That by itself is not a problem â€“ I could just use<br>\n\"Outer_Syntax.local_theory_to_proof\".</p>\n<p>However, I need to define multiple functions one after the other,<br>\naccording to some specific ordering. In general, because of<br>\npolymorphism, I can't define them all at once and then ask the user to<br>\nproof all obligations, but I need to \"open_target\"/\"close_target\" in<br>\nbetween.</p>\n<p>A possible trace of my command could be:</p>\n<ul>\n<li>define polymorphic function \"f\"</li>\n<li>termination proof</li>\n<li>define function \"g\" that uses \"f[nat]\"</li>\n<li>define function \"h\" that uses \"f[int]\"</li>\n<li>termination proofs</li>\n</ul>\n<p>Because \"Outer_Syntax.command\" requires a transition transformer of type<br>\n\"Toplevel.transition -&gt; Toplevel.transition\", I naively tried to compose<br>\nmultiple of these, like so:</p>\n<p>val multi_proof =<br>\n  Toplevel.local_theory_to_proof NONE NONE<br>\n    (Proof.theorem NONE (K I) [[(@{prop True}, [])]])<br>\n  #&gt; Toplevel.local_theory_to_proof NONE NONE<br>\n    (Proof.theorem NONE (K I) [[(@{prop \"id True\"}, [])]])</p>\n<p>When I execute the command, I get the initial proof obligation as<br>\nexpected. After typing \"done\", I don't get another proof state.</p>\n<p>After studying the sources and isar-ref I have formed the understanding<br>\nthat I have only constructed a single transition that may try multiple<br>\ndifferent things (in this case: two), of which the first one succeeds.</p>\n<p>Is there any way to achieve what I want?</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294710376,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181977
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/04/17 17:01, Lars Hupel wrote:</p>\n<blockquote>\n<p>I'm trying to define a command that needs to emit multiple proof<br>\nobligations to the user. The catch is that these proof obligations can<br>\nonly be generated after some interspersed theory updates.</p>\n</blockquote>\n<blockquote>\n<p>Is there any way to achieve what I want?</p>\n</blockquote>\n<p>This is not going to work. Isar commands can have 0 or 1 Isar proofs.<br>\nYou need to come up with a different approach, i.e. disprove your \"I<br>\nneed\" and \"I want\" statements.</p>\n<blockquote>\n<p>Because \"Outer_Syntax.command\" requires a transition transformer of type<br>\n\"Toplevel.transition -&gt; Toplevel.transition\", I naively tried to compose<br>\nmultiple of these, like so:</p>\n<p>val multi_proof =<br>\n  Toplevel.local_theory_to_proof NONE NONE<br>\n    (Proof.theorem NONE (K I) [[(@{prop True}, [])]])<br>\n  #&gt; Toplevel.local_theory_to_proof NONE NONE<br>\n    (Proof.theorem NONE (K I) [[(@{prop \"id True\"}, [])]])</p>\n<p>When I execute the command, I get the initial proof obligation as<br>\nexpected. After typing \"done\", I don't get another proof state.</p>\n</blockquote>\n<p>Toplevel.transition transformers compose a sequential union of<br>\ntransactions; see also the \"implementation\" manual section 9.1.2.</p>\n<p>Also note that the canonical composition operator for transition<br>\ntransformers is \"o\" instead of \"#&gt;\".</p>\n<p>Makarius</p>",
        "id": 294710392,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181983
    }
]