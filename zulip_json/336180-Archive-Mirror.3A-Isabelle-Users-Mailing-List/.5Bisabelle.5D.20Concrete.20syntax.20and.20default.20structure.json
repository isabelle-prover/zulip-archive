[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nI have two records, defining some unrelated concepts, e.g. Labeled <br>\ntransition systems and partial orders.<br>\n  Each of this record defines some concrete syntax, e.g. \"a -l-&gt; b\" for <br>\ntransitions and a\\&lt;sqsubseteq&gt;b for the order relation.</p>\n<p>theory Scratch<br>\nimports Main \"$ISABELLE_HOME/src/HOL/Algebra/Lattice\"<br>\nbegin</p>\n<p>record ('s,'l) LTS =<br>\n    S :: \"'s\"<br>\n    T :: \"'s \\&lt;Rightarrow&gt; 'l \\&lt;Rightarrow&gt; 's \\&lt;Rightarrow&gt; bool\" (\"_ <br>\n-_\\&lt;rightarrow&gt;\\&lt;index&gt; _\")</p>\n<p>Now I have some structure that relates this two concepts, for example a <br>\npartial order on the transition labels.<br>\nOne possibility to write this down might be:</p>\n<p>locale Combined = struct lts + complete_lattice L +<br>\n    constrains lts :: \"('a,'l) LTS\"<br>\n    constrains L :: \"'l order\"<br>\n    assumes ...</p>\n<p>But now the problem is, that the default structural parameter is only <br>\napplied to the concrete syntax of one of the both concepts. For the <br>\nother, I have to explicitely specify the structural index parameter, <br>\nwhich is annoying because of its writing overhead and because it makes <br>\nproof texts more difficult to read. In my case, the concrete syntax <br>\n\"-_-&gt;\" for LTS and \\&lt;sqsubseteq&gt; for partial order is completely <br>\ndisjunct so that it is always clear what structural parameter to apply <br>\nwhere.</p>\n<p>lemma (in Combined) shows \"\\&lt;lbrakk&gt;a -l\\&lt;rightarrow&gt; b; b <br>\n-l'\\&lt;rightarrow&gt;c\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt; l \\&lt;sqsubseteq&gt; l'\"<br>\n    this does not work, because it tries to index \\&lt;sqsubseteq&gt; with lts <br>\nas structural parameter.</p>\n<p>Is there any possibility to work around this problem and get a setting <br>\nwhere one can omit the indices to concrete syntax of both concepts.</p>\n<p>A dirty hack would obviously be to define<br>\n  record ('s,'l) LTS = 'l order +<br>\n    S :: \"'s\"<br>\n    T :: \"'s \\&lt;Rightarrow&gt; 'l \\&lt;Rightarrow&gt; 's \\&lt;Rightarrow&gt; bool\" (\"_ <br>\n-_\\&lt;rightarrow&gt;\\&lt;index&gt; _\")<br>\nbut this would merge the two unrelated concepts of LTS and partial_order.</p>\n<p>Is there any 'cleaner' solution. (Perhaps I'm misusing the concepts of <br>\nrecords/locales here, but how should it be done then ?)</p>\n<p>Greetings and thanks in advance for any suggestions<br>\n  Peter Lammich</p>",
        "id": 294040598,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815098
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nDear Peter,</p>\n<p>records are not flexible enough to achieve what you want since they <br>\ndon't provide multiple inheritance on structures.  Your \"dirty hack\" is <br>\na way of simulating this.  (My formalisation of additive groups in <br>\nHOL-Algebra uses an extension of the record for multiplicative groups <br>\nand ignores the unnecessary fields, so that's quite similar.)</p>\n<p>An alternative would be not to use structural parameters and records, <br>\nbut make each of the operations (that is, record entries) a separate <br>\nparameter.  Renaming and syntax annotations in locale expressions then <br>\ngive you full control over the syntax.</p>\n<p>Clemens</p>",
        "id": 294040718,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815134
    }
]