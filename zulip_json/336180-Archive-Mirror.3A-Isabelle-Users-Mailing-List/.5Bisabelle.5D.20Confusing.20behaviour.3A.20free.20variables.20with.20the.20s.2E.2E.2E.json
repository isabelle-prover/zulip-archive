[
    {
        "content": "<p>From: <a href=\"mailto:Thibaut.Perami@data61.csiro.au\">Thibaut.Perami@data61.csiro.au</a><br>\nHello Isabelle users,</p>\n<p>I just found a strange behaviour in Isabelle/HOL using notes which allow to create to different free variables with different types but the same name. This is very confusing for a user which doesn't work with [[show_types]] (Which I think is mostly everyone). Here is a minimal example:</p>\n<p>lemma<br>\n  notes hyp = refl[where t=a]<br>\n  shows \"a = a\"<br>\n  apply (insert hyp)<br>\n  subgoal by assumption<br>\n  done</p>\n<p>The notes introduces a free variable named \"a\" with schematic type \"?'a1\". Then shows introduces another free variable \"a\" with a fixed type \" 'a \". If you do by (rule hyp) right after the shows, the schematic type will be unified with \"'a\" and from now on both variables will be the same (same name + same type ⟹ same variable). However if you add hyp to your premises and then use the subgoal command, all schematics (here only \"?'a\") are instantiated with fresh free variables (here \" 'b \"). Therefore, right after the subgoal command, your context is:</p>\n<p>(a :: 'b) = (a :: 'b) ⟹ (a :: 'a) = (a :: 'a)</p>\n<p>but without type annotations it looks like:</p>\n<p>a = a ⟹ a = a</p>\n<p>which one would expect to be solved by assumption. In practice, the variables are different and thus assumption fails.</p>\n<p>If this is not considered as a bug, I think there should at least be either:</p>\n<p>*   a warning that two different variables with different types but same name have appeared in the context<br>\n  *   or an even simpler change: when two variables have the same name but different types, print the types in the pretty printer for those specific variables even when we are in a printing mode where types are hidden</p>\n<p>In both cases the current type printing mode (when using [[show_types]]) assumes that such name conflicts cannot exist. The previous goal gets printed as</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>a = a ⟹ a = a<br>\nvariables:<br>\n  a :: 'a<br>\n  a :: 'b</li>\n</ol>\n<p>which is not very informative about which \"a\" is which.</p>\n<p>For extra information: This behaviour can also be obtained with the lemmas command:</p>\n<p>lemmas hyp = refl[where t=a]<br>\nlemma<br>\n  \"a = a\"<br>\n  apply (insert hyp)<br>\n  subgoal by assumption<br>\n  done</p>\n<p>it can also be obtained without subgoal by manually instantiating the type variable:</p>\n<p>lemmas hyp = refl[where t=a]<br>\nlemma<br>\n  \"a = a\"<br>\n  apply (insert hyp[where 'a = int)<br>\n  by assumption</p>\n<p>Thank you for your attention,</p>\n<p>Thibaut Perami</p>",
        "id": 294741066,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191556
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 01/08/18 09:07, <a href=\"mailto:Thibaut.Perami@data61.csiro.au\">Thibaut.Perami@data61.csiro.au</a> wrote:</p>\n<blockquote>\n<p>I just found a strange behaviour in Isabelle/HOL using notes which allow to create to different free variables with different types but the same name. This is very confusing for a user which doesn't work with [[show_types]] (Which I think is mostly everyone). Here is a minimal example:</p>\n<p>lemma<br>\n  notes hyp = refl[where t=a]<br>\n  shows \"a = a\"<br>\n  apply (insert hyp)<br>\n  subgoal by assumption<br>\n  done</p>\n<p>The notes introduces a free variable named \"a\" with schematic type \"?'a1\". Then shows introduces another free variable \"a\" with a fixed type \" 'a \". If you do by (rule hyp) right after the shows, the schematic type will be unified with \"'a\" and from now on both variables will be the same (same name + same type ⟹ same variable). However if you add hyp to your premises and then use the subgoal command, all schematics (here only \"?'a\") are instantiated with fresh free variables (here \" 'b \"). Therefore, right after the subgoal command, your context is:</p>\n<p>(a :: 'b) = (a :: 'b) ⟹ (a :: 'a) = (a :: 'a)</p>\n<p>but without type annotations it looks like:</p>\n<p>a = a ⟹ a = a</p>\n<p>which one would expect to be solved by assumption. In practice, the variables are different and thus assumption fails.</p>\n</blockquote>\n<p>Such things can happen: Isabelle is a very complex system with many<br>\nimplicit conveniences, but in rare situations it is possible to shoot<br>\noneself into the foot.</p>\n<p>Incidents like above occur approx. every 2 years on this mailing list,<br>\nwhich I would consider very rare.</p>\n<blockquote>\n<p>If this is not considered as a bug, I think there should at least be either:</p>\n<p>*   a warning that two different variables with different types but same name have appeared in the context<br>\n  *   or an even simpler change: when two variables have the same name but different types, print the types in the pretty printer for those specific variables even when we are in a printing mode where types are hidden</p>\n</blockquote>\n<p>Nothing of this is as simple as it might seem on the surface. After some<br>\ndecades with this inherent challenge, we are already at a local minimum<br>\nof potential confusion.</p>\n<blockquote>\n<p>For extra information: This behaviour can also be obtained with the lemmas command:</p>\n<p>lemmas hyp = refl[where t=a]</p>\n</blockquote>\n<p>Note that \"a\" is out-of-scope here, and bad things are to be expected<br>\nlater on.</p>\n<p>In current Isabelle2018-RC3 the above command is even rejected. Such<br>\ntightening of the system usually causes other problems elsewhere, and I<br>\nam actually surprised that nobody has complained about it in the past<br>\nweeks of testing Isabelle2018 release candidates.</p>\n<p>Makarius</p>",
        "id": 294741566,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191734
    },
    {
        "content": "<p>From: Lars-Henrik Eriksson &lt;<a href=\"mailto:lhe@it.uu.se\">lhe@it.uu.se</a>&gt;<br>\nOn 2 aug. 2018 at 16:34:42 CEST  Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:<br>\nThis kind of thing happens frequently to me. I do use [[show_types]] to figure things out when I suspect this is the problem but it would still help considerably if Isabelle could provide some kind of heuristic that could warn the user.</p>\n<p>Lars-Henrik Eriksson</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>",
        "id": 294741750,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191814
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nCan you illustrate it by typical examples?</p>\n<p>Everything shown on this thread so far was quite a-typical in the use of<br>\ncontexts (lack of explicit declarations, 'notes' in odd places etc.).</p>\n<p>Makarius</p>",
        "id": 294741760,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191820
    },
    {
        "content": "<p>From: Lars-Henrik Eriksson &lt;<a href=\"mailto:lhe@it.uu.se\">lhe@it.uu.se</a>&gt;<br>\n5 aug. 2018 kl. 13:02 skrev Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;:<br>\nI work with bounded sets (HOL/Cardinals/Bounded_Set.thy). Isabelle can not always infer the bounding type. A typical proof would look like this:</p>\n<p>lemma Act_in_tau_steps: \"bmember (tAct τ x) (map_bset (tau_steps_Tree x) (Abs_bset UNIV::nat set['idx]))\"<br>\nproof -<br>\n  have \"Suc 0 ∈ set_bset (Abs_bset UNIV::nat set['idx])\"<br>\n    by auto<br>\n  then have \"bmember (tau_steps_Tree x (Suc 0)) (map_bset (tau_steps_Tree x) (Abs_bset UNIV::nat set['idx]))\"<br>\n     by (metis bmember.rep_eq imageI map_bset.rep_eq)<br>\n  then show ?thesis<br>\n    by simp<br>\nqed</p>\n<p>All three type annotations are necessary. In this particular case it is pretty clear where type annotations are likely to be needed, but there are cases which are not so clear (sorry, I can't dig one up right now). Also, I don't want to include unnecessary type annotations as they clutter up the proof.</p>\n<p>Lars-Henrik Eriksson</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>",
        "id": 294741776,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191826
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThat is a slightly different problem. The examples at the start of this<br>\nthread were about free (undeclared) variables, but here it is about<br>\npolymorphic constants.</p>\n<p>The logic can handle both variables and constants of the same name and<br>\ndifferent types: they are just different formal entities. In contrast,<br>\nthe higher concepts of abstract syntax and type-checking within a local<br>\ncontext ensure that variables always coincide on their types, as long as<br>\nthe name is equal. For constants this is not done: it is normal to have<br>\ndifferent type instances of the same constant family in the same context<br>\n(e.g. the equality constant).</p>\n<p>More precisely, the built-in Hindley-Milner type inference for Isar<br>\nproof texts connects the types of sub-expressions via locally fixed term<br>\nvariables from the context, but connecting via constants alone does not<br>\nwork. For example:</p>\n<p>notepad<br>\nbegin<br>\n  fix a b c d<br>\n  { have \"a + b = c + d\" sorry ― ‹type ‹'a›› }<br>\n  {<br>\n    have 1: \"a + b = 0\" sorry  ― ‹type ‹'a››<br>\n    have 2: \"0 = c + d\" sorry  ― ‹type ‹'b››<br>\n    thm trans [OF 1 2] ― ‹fails›<br>\n  }<br>\nend</p>\n<p>Makarius</p>",
        "id": 294742241,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661192010
    },
    {
        "content": "<p>From: Lars-Henrik Eriksson &lt;<a href=\"mailto:lhe@it.uu.se\">lhe@it.uu.se</a>&gt;<br>\n7 aug. 2018 kl. 22:16 skrev Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;:<br>\nYes, there is a difference but the two problems have the common issue that expressions that \"look\" identical are in fact not.</p>\n<p>Lars-Henrik Eriksson</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>",
        "id": 294742389,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661192066
    }
]