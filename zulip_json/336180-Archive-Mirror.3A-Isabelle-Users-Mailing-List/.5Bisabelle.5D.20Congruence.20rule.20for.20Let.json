[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi all,</p>\n<p>using the function package, I'd like to define a function whose <br>\ndefinition contains a number of Let expressions. In the generated <br>\ninduction rule, a term \"Let t (%x. y)\" yields the induction hypothesis <br>\n\"!!x. x = t ==&gt; P (y x)\"<br>\nHowever, I would like to get \"P (y t)\" directly. How do I have to change <br>\nthe congruence rule for Let to achieve this?</p>\n<p>I tried two alternatives with fundef_cong:</p>\n<ul>\n<li>\n<p>\"[| M = N; f N = g N |] ==&gt; Let M f = Let N g\" raises an exception:</p>\n<p>*** exception THM 1 raised (line 421 of \"drule.ML\"): COMP<br>\n *** At command \"function\".</p>\n</li>\n<li>\n<p>\"[| M = N; f M = g N |] ==&gt; Let M f = Let N g\" eliminates the <br>\nquantifier, but produces far to many induction hypotheses.</p>\n</li>\n</ul>\n<p>What is the right congruence rule for this?</p>\n<p>Andreas</p>",
        "id": 294116606,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838503
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nAndreas Lochbihler wrote:<br>\nAndreas,</p>\n<p>This seems easy enough using the functions in ch 5 of the Reference Manual</p>\n<p>val iax = \"!!x. x = t ==&gt; P (y x)\" : Thm.thm</p>\n<blockquote>\n<p>val ax' = forall_elim_var 0 iax ;<br>\nval ax' = \"?x = t ==&gt; P (y ?x)\" : Thm.thm<br>\nrefl RS ax' ;<br>\nval it = \"P (y t)\" : Thm.thm</p>\n</blockquote>\n<p>Cheers,</p>\n<p>Jeremy</p>",
        "id": 294116764,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838533
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>using the function package, I'd like to define a function whose <br>\ndefinition contains a number of Let expressions. In the generated <br>\ninduction rule, a term \"Let t (%x. y)\" yields the induction hypothesis <br>\n\"!!x. x = t ==&gt; P (y x)\"<br>\nHowever, I would like to get \"P (y t)\" directly. How do I have to change <br>\nthe congruence rule for Let to achieve this?</p>\n<p>I tried two alternatives with fundef_cong:<br>\n- \"[| M = N; f N = g N |] ==&gt; Let M f = Let N g\" raises an exception:</p>\n<p>*** exception THM 1 raised (line 421 of \"drule.ML\"): COMP<br>\n  *** At command \"function\".</p>\n<ul>\n<li>\"[| M = N; f M = g N |] ==&gt; Let M f = Let N g\" eliminates the <br>\nquantifier, but produces far to many induction hypotheses.</li>\n</ul>\n<p>What is the right congruence rule for this?</p>\n</blockquote>\n<p>Actually, I had expected that the first rule works. I need to dig into <br>\nthis again. The rule that should definitely work is the following</p>\n<p>\"f M = g N ==&gt; Let M f = Let N g\"</p>\n<p>It has the same effect on the induction rule as unfolding all lets. Can <br>\nyou try if it works for your function?</p>\n<p>Jeremy Dawson wrote:</p>\n<blockquote>\n<p>This seems easy enough using the functions in ch 5 of the Reference Manual</p>\n<p>val iax = \"!!x. x = t ==&gt; P (y x)\" : Thm.thm</p>\n<blockquote>\n<p>val ax' = forall_elim_var 0 iax ;<br>\nval ax' = \"?x = t ==&gt; P (y ?x)\" : Thm.thm<br>\nrefl RS ax' ;<br>\nval it = \"P (y t)\" : Thm.thm <br>\nThe ind.hyp. Andreas is referring to appears nested inside the induction <br>\nrule, where it cannot be easily manipulated by hand...</p>\n</blockquote>\n</blockquote>\n<p>Alex</p>",
        "id": 294116820,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838552
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Alex,</p>\n<blockquote>\n<p>Actually, I had expected that the first rule works. I need to dig into <br>\nthis again. The rule that should definitely work is the following</p>\n<p>\"f M = g N ==&gt; Let M f = Let N g\"</p>\n<p>It has the same effect on the induction rule as unfolding all lets. Can <br>\nyou try if it works for your function?<br>\nNo, it doesn't. This produces the same effect like the congruence rule <br>\n\"[| M = N; f M = g N |] ==&gt; Let M f = Let N g\", it produces too many <br>\ninduction hypotheses.</p>\n</blockquote>\n<p>For example, with your congruence rule declared as fundef_cong, the <br>\nfollowing equation in the definition of compE2 generates this induction <br>\ncase:</p>\n<p>\"compE2 L ins pcs (if (e) e\\&lt;^isub&gt;1 else e\\&lt;^isub&gt;2) =<br>\n    (let els   = compE2 L ins pcs e\\&lt;^isub&gt;2;<br>\n         thn   = compE2 L ins ((length els + 1) # pcs) e\\&lt;^isub&gt;1;<br>\n         cnd   = compE2 L ins ((length thn + length els + 2) # pcs) e;<br>\n         test  = IfFalse (int (length thn) + 2);<br>\n         thnex = Goto (int (length els) + 1)<br>\n     in cnd @ [test] @ thn @ [thnex] @ els)\"</p>\n<p>!!L ins pcs e e\\&lt;^isub&gt;1 e\\&lt;^isub&gt;2.<br>\n       [| ?P L ins pcs e\\&lt;^isub&gt;2;<br>\n          ?P L ins ((length (compE2 L ins pcs e\\&lt;^isub&gt;2) + 1) # pcs)<br>\n           e\\&lt;^isub&gt;1;<br>\n          ?P L ins pcs e\\&lt;^isub&gt;2;<br>\n          ?P L ins<br>\n           ((length<br>\n              (compE2 L ins<br>\n                ((length (compE2 L ins pcs e\\&lt;^isub&gt;2) + 1) # pcs)<br>\n                e\\&lt;^isub&gt;1) +<br>\n             length (compE2 L ins pcs e\\&lt;^isub&gt;2) +<br>\n             2) #<br>\n            pcs)<br>\n           e;<br>\n          ?P L ins pcs e\\&lt;^isub&gt;2;<br>\n          ?P L ins ((length (compE2 L ins pcs e\\&lt;^isub&gt;2) + 1) # pcs)<br>\n           e\\&lt;^isub&gt;1;<br>\n          ?P L ins pcs e\\&lt;^isub&gt;2;<br>\n          ?P L ins ((length (compE2 L ins pcs e\\&lt;^isub&gt;2) + 1) # pcs)<br>\n           e\\&lt;^isub&gt;1;<br>\n          ?P L ins pcs e\\&lt;^isub&gt;2; ?P L ins pcs e\\&lt;^isub&gt;2 |]<br>\n       ==&gt; ?P L ins pcs (if (e) e\\&lt;^isub&gt;1 else e\\&lt;^isub&gt;2);</p>\n<blockquote>\n<blockquote>\n<p>This seems easy enough using the functions in ch 5 of the Reference <br>\nManual<br>\n[...]<br>\nThe ind.hyp. Andreas is referring to appears nested inside the induction <br>\nrule, where it cannot be easily manipulated by hand...<br>\nWell, I managed to transform it, but it is not a satisfactory solution:</p>\n</blockquote>\n</blockquote>\n<p>lemma meta_all_eq_conv:<br>\n   \"!!P b. (!!a. a = b ==&gt; PROP P a) == PROP P b\"<br>\n   \"!!P c. (!!a b. a = c ==&gt; PROP P a b) == PROP P c b\"<br>\n   \"!!P d. (!!a b c. a = d ==&gt; PROP P a b c) == PROP P d b c\"<br>\n   \"!!P e. (!!a b c d. a = e ==&gt; PROP P a b c d) == PROP P e b c d\"</p>\n<p>thm compE2_compEs2.induct[unfolded meta_all_eq_conv]</p>\n<p>I need one rewrite rule for every nesting level of let expressions.</p>\n<p>Andreas</p>",
        "id": 294116837,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838558
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jlcaadawson@netspeed.com.au\">jlcaadawson@netspeed.com.au</a>&gt;<br>\nYes, I see.  How deeply is it nested ? If it is simply a hypothesis to <br>\nthe theorem, rather than being nested more deeply, could you get what <br>\nyou need in this way ?</p>\n<p>val th = \"(!!x. x = t ==&gt; ?P (?y x)) ==&gt; ?Q\" : Thm.thm</p>\n<blockquote>\n<p>val th' = rule_by_tactic (hyp_subst_tac 1) th ;<br>\nval th' = \"(!!x. ?P (?y t)) ==&gt; ?Q\" : Thm.thm</p>\n</blockquote>\n<p>Regards,</p>\n<p>Jeremy</p>",
        "id": 294117046,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838613
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<p>After playing the complete example that you provided off-list, I think I <br>\nnow understood the problem.</p>\n<p>The let binding itself contains recursive calls. Using the above <br>\ncongruence rule is equivalent to inlining all lets for the purpose of <br>\nthe analysis. This automatically duplicates recursive calls, if the <br>\nlet-bound variable occurs more than once. I think there is no way to <br>\navoid this using congruence rules.</p>\n<p>The transformation you would like to see could in fact be done as a <br>\npost-processing step on the induction rule. Would you (and other users) <br>\nthink it is a good idea to inline assumptions of the form \"x = t\" in <br>\ngeneral?</p>\n<p>Alex</p>",
        "id": 294117701,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838773
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Alex,</p>\n<p>Inlining might increase the size of the induction rule exponentially, so it <br>\ndefinitely is not optimal in all cases, i.e. you want to include an option to <br>\ndeactivate this. In my cases, this increase does not happend in the induction <br>\nrule because contains fewer occurrences of the let-bound variable than the <br>\ndefining equations. If postprocessing is needed anyway, I would recommend to <br>\nprovide an attribute which perform this. Then, it might also be available for <br>\nother rules (e.g. the .cases rule for (co)inductive predicates/sets).</p>\n<p>Since the function package does not generate sensible case names for the <br>\ninduction rule (even without the sequential and every equation being given a <br>\nname), I have to do some postprocessing with attributes anyway, so I would not <br>\nmind adding an explicit postprocessing attribute there. Unfortunately, inside a <br>\nlocal context, IIRC, such an attribute would be reexecuted whenever the context <br>\nis opened.</p>\n<p>Thanks for looking into this,<br>\nAndreas</p>",
        "id": 294117721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838779
    }
]