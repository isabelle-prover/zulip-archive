[
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nHi,</p>\n<p>I'm trying to use congruence rules to simplify modular arithmetic  <br>\nexpressions. For example, I'd like to automatically prove the following:</p>\n<p>lemma test1: \"((x::int) * y mod 2) mod 2 = (x * y) mod 2\"</p>\n<p>lemma test2: \"((x::int) + y mod 2) mod 2 = (x + y) mod 2\"</p>\n<p>To do this, I made a special definition</p>\n<p>definition<br>\n     cong_zmod :: \"int =&gt; int =&gt; int\" where<br>\n    \"cong_zmod p x == x mod p\"</p>\n<p>and then the following congruence rules (among others):</p>\n<p>lemma zmod_cong:<br>\n     assumes \"p = p'\"<br>\n         and \"cong_zmod p' x = cong_zmod p' x'\"<br>\n     shows \"x mod p = x' mod p'\"</p>\n<p>lemma cong_zmod_mod[simp]:<br>\n     \"p dvd q ==&gt; cong_zmod p (x mod q) = cong_zmod p x\"</p>\n<p>lemma cong_zmod_plus[cong]:<br>\n     assumes A1: \"p = p'\"<br>\n         and A2: \"cong_zmod p' x = cong_zmod p' x'\"<br>\n         and A3: \"cong_zmod p' y = cong_zmod p' y'\"<br>\n         and A4: \"x' + y' = z\"<br>\n     shows \"cong_zmod p (x + y) = cong_zmod p' z\"</p>\n<p>lemma cong_zmod_mult[cong]:<br>\n     assumes A1: \"cong_zmod p x = cong_zmod p x'\"<br>\n         and A2: \"cong_zmod p y = cong_zmod p y'\"<br>\n         and A3: \"x' * y' = z\"<br>\n     shows \"cong_zmod p (x * y) = cong_zmod p z\"</p>\n<p>With these congruence rules, I can get Isabelle to prove the first  <br>\nlemma:</p>\n<p>lemma test1: \"((x::int) * y mod 2) mod 2 = (x * y) mod 2\"<br>\n   by (simp cong: zmod_cong)</p>\n<p>but not the second:</p>\n<p>lemma test2: \"((x::int) + y mod 2) mod 2 = (x + y) mod 2\"<br>\n   by (simp cong: zmod_cong)</p>\n<p>[Isabelle's response:  *** Terminal proof method failed<br>\n                          *** At command \"by\".]</p>\n<p>Since Isabelle only stores one congruence rule for any given function  <br>\nsymbol, the congruence rule cong_zmod_mult clobbers cong_zmod_plus.</p>\n<p>Is there any way to fix this so Isabelle can have multiple congruence  <br>\nrules for a function symbol, when the left-hand-sides are distinct?  <br>\nThe alternative of coding this up as a simproc wouldn't interact well  <br>\nwith other modular arithmetic simplification rules that users may  <br>\nwant to add later on.</p>\n<p>I'm appending the complete theory below.</p>\n<p>Thanks,<br>\n-john</p>\n<hr>\n<p>theory \"zmod_cong_plus_example\"<br>\nimports \"~~/src/HOL/Word/WordGenLib\"<br>\nbegin</p>\n<p>definition<br>\n   cong_zmod :: \"int \\&lt;Rightarrow&gt; int \\&lt;Rightarrow&gt; int\" where<br>\n  \"cong_zmod p x \\&lt;equiv&gt; x mod p\"</p>\n<p>lemma zmod_cong:<br>\n   assumes \"p = p'\"<br>\n       and \"cong_zmod p' x = cong_zmod p' x'\"<br>\n   shows \"x mod p = x' mod p'\"<br>\nby (cut_tac prems, simp add: cong_zmod_def)</p>\n<p>lemma cong_zmod_mod[simp]:<br>\n   \"p dvd q \\&lt;Longrightarrow&gt; cong_zmod p (x mod q) = cong_zmod p x\"<br>\nby (simp add: cong_zmod_def zmod_zmod_cancel)</p>\n<p>lemma cong_zmod_plus[cong]:<br>\n   assumes A1: \"p = p'\"<br>\n       and A2: \"cong_zmod p' x = cong_zmod p' x'\"<br>\n       and A3: \"cong_zmod p' y = cong_zmod p' y'\"<br>\n       and A4: \"x' + y' = z\"<br>\n   shows \"cong_zmod p (x + y) = cong_zmod p' z\"<br>\napply (cut_tac prems)<br>\nby (simp add: cong_zmod_def cong: mod_plus_cong)</p>\n<p>-- \"REVISIT: Submit to WordGenLib.thy\"<br>\nlemma mod_mult_cong:<br>\n   assumes A1: \"b = b'\"<br>\n       and A2: \"(x::int) mod b' = x' mod b'\"<br>\n       and A3: \"(y\\&lt;Colon&gt;int) mod b' = y' mod b'\"<br>\n       and A4: \"x' * y' = z'\"<br>\n   shows \"(x * y) mod b = z' mod b'\"<br>\napply (simp add: A1)<br>\napply (subst pull_mods(2)[symmetric])<br>\nby (simp add: A2 A3 A4 pull_mods(2))</p>\n<p>lemma cong_zmod_mult[cong]:<br>\n   assumes A1: \"cong_zmod p x = cong_zmod p x'\"<br>\n       and A2: \"cong_zmod p y = cong_zmod p y'\"<br>\n       and A3: \"x' * y' = z\"<br>\n   shows \"cong_zmod p (x * y) = cong_zmod p z\"<br>\napply (cut_tac prems)<br>\nby (simp add: cong_zmod_def cong: mod_mult_cong)</p>\n<p>lemma test1:<br>\n   \"((x::int) * y mod 2) mod 2 = (x * y) mod 2\"<br>\napply (simp cong: zmod_cong)<br>\ndone</p>\n<p>lemma test2:<br>\n   \"((x::int) + y mod 2) mod 2 = (x + y) mod 2\"<br>\napply (simp cong: zmod_cong)<br>\ndone</p>\n<p>end</p>",
        "id": 294057711,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822292
    },
    {
        "content": "<p>From: Amine Chaieb &lt;<a href=\"mailto:chaieb@in.tum.de\">chaieb@in.tum.de</a>&gt;<br>\nHi John,</p>\n<p>Sorry for the late answer (I have actually just noticed the mail).</p>\n<p>The two lemmas can be proved automatically by presburger.</p>\n<p>But you still might want to prove them once for all for arbitrary n, not <br>\njust 2. the method algebra actually proves such problems, but <br>\nunfortunately it is not yet set up properly.</p>\n<p>Attached is a theory that shows how to use it. The auxiliary lemmas are <br>\nactually proved in libraries (Prime numbers and Pocklington). We should <br>\nmaybe move them to HOL and set up algebra properly to prove such simple <br>\ntheorems.</p>\n<p>Best Regards,<br>\nAmine.</p>\n<p>John Matthews wrote:<br>\n<a href=\"/user_uploads/14278/ou11B-dy4ZQ6UaemPuHFh6nf/Test.thy\">Test.thy</a></p>",
        "id": 294058097,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822431
    },
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nHi Amine,</p>\n<p>Thanks for looking into this. The examples I gave were simple, but in  <br>\nmy application the terms I'm trying to simplify are much larger. Here  <br>\nis a very small instance:</p>\n<p>uint v0 mod 256 * (uint v1 mod 256) mod 256 =<br>\n     (((uint_sliceLH 0 0 v1 mod 256 *\n          (uint v0 mod 256) mod 256 +<br>\n        uint_sliceLH 1 1 v1 mod 256 *\n          (2 * (uint v0 mod 256) mod 256) mod 256) mod 256 +<br>\n        uint_sliceLH 2 2 v1 mod 256 *\n          (uint v0 mod 256 * 4 mod 256) mod 256) mod 256 +<br>\n        uint_sliceLH 3 3 v1 mod 256 *\n          (uint v0 mod 256 * 8 mod 256) mod 256) mod 256</p>\n<p>where (uint_sliceLH n m w) = uint (sliceLH n m w).</p>\n<p>Also, I need Isabelle to simplify the term itself, as I don't know  <br>\nbeforehand what the term should simplify to. This is why I need to use  <br>\ncongruence rules, rather than decision procedures like presburger. Can  <br>\nthe algebra method perform simplification, especially when given extra  <br>\ndefinitions such as uint_sliceLH?</p>\n<p>Thanks,<br>\n-john</p>",
        "id": 294059069,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822817
    },
    {
        "content": "<p>From: Amine Chaieb &lt;<a href=\"mailto:chaieb@in.tum.de\">chaieb@in.tum.de</a>&gt;<br>\nHi John,</p>\n<p>It would be helpful if you could provide a rough description of the <br>\nclass of terms you want to simplify.</p>\n<p>As for the example (I assumed the variables have type int!) you could <br>\nsimplify it to e.g.</p>\n<p>uint v0 * uint v1 mod 256 =<br>\n     (uint (sliceLH 0 0 v1) * uint v0 +<br>\n      uint (sliceLH 1 1 v1) * (2 * uint v0) +<br>\n      uint (sliceLH 2 2 v1) * (uint v0 * 4) +<br>\n      uint (sliceLH 3 3 v1) * (uint v0 * 8)) mod<br>\n     256</p>\n<p>automatically using (simp add: zmod_simps H). Here H is a premise saying <br>\nthat (uint_sliceLH n m w) = uint (sliceLH n m w).</p>\n<p>If you only need to gather terms together under mod/div this should not <br>\nbe very difficult, provided that the constants also (not only subterms) <br>\nare of the form a mod m, for the same modulus. But I doubt your examples <br>\nare as simple as this.</p>\n<p>For e.g. (x mod 256 + 8) mod 256 = (x + 8) mod 256</p>\n<p>one would need more than simple rewriting with zmod_simps (maybe a <br>\nspecial simproc or tactic to convert 8 into 8 mod 256 or generally y <br>\ninto y mod m provided we can prove y &lt; m and m &gt;= 0 for the integers).</p>\n<p>Unfortunately the algebra method can not prove the statement above which <br>\nboils down to</p>\n<p>EX q1 q2.<br>\n        uint v0 * uint v1 + 256 * q1 =<br>\n        uint (sliceLH 0 0 v1) * uint v0 +<br>\n        uint (sliceLH 1 1 v1) * (2 * uint v0) +<br>\n        uint (sliceLH 2 2 v1) * (uint v0 * 4) +<br>\n        uint (sliceLH 3 3 v1) * (uint v0 * 8) +<br>\n        256 * q2</p>\n<p>I guess it does not hold in all rings.</p>\n<p>Apart from that, the method algebra does not perform simplification, it <br>\nis only meant for decision. You can however give it extra theorems for <br>\ndefinitions or the like to be expanded before the core procedure is called.</p>\n<p>I hope this helps.</p>\n<p>Amine.</p>\n<p>John Matthews wrote:</p>",
        "id": 294059072,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822820
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nAmine Chaieb wrote:<br>\nFor integers, the statement above doesn't depend on 8 being equal to 8 <br>\nmod 256.</p>\n<p>In fact it is one of the simplifications in the list rdmods, in <br>\nNum_Lemmas.thy in src/HOL/Word.</p>\n<p>Incidentally, the stuff I put into Num_Lemmas.thy was stuff I thought <br>\nwas of more general interest than just to be used within the <br>\nmachine-word library.</p>\n<p>Jeremy Dawson</p>",
        "id": 294059150,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822857
    }
]