[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>Tobias and I have recently examined the two traditional simplifier<br>\ncongruence rules</p>\n<p>INF_cong_simp:<br>\n  A = B ⟹<br>\n  (⋀x. x ∈ B =simp=&gt; C x = D x) ⟹<br>\n  ⨅ (C <code> A) = ⨅ (D </code> B)</p>\n<p>SUP_cong_simp:<br>\n  A = B ⟹<br>\n  (⋀x. x ∈ B =simp=&gt; C x = D x) ⟹<br>\n  ⨆ (C <code> A) = ⨆ (D </code> B)</p>\n<p>Those rules (in their particular specialization on sets named INTER and<br>\nUNION) date back to those times when INTER and UNION were dedicated<br>\nconstants up until Isabelle2016.</p>\n<p>The problem with those rules is that they destroy the potential redex ‹C<br>\n<code> A›, preventing trivial rewrites like ‹C </code> insert x A = …›.</p>\n<p>We would suggest to replace those by the more general</p>\n<p>image_cong_simp:<br>\n  M = N ⟹<br>\n  (⋀x. x ∈ N =simp=&gt; f x = g x) ⟹<br>\n  f <code> M = g </code> N</p>\n<p>which essentially leaves out the leading big operator from any of the<br>\nrules above.</p>\n<p>After some experiments I think this can be done, and proofs in general<br>\ntake benefit.  But, depending on the application, the proof text<br>\nmigration can be involved.</p>\n<p>For single entries the former situation can be (almost) restored by<br>\nremoving image_cong_simp as congruence rule.</p>\n<p>I drop this note here</p>\n<p>a) to excite feedback before going ahead</p>\n<p>b) to set a memory anchor that potentially painstaking migration of<br>\nfuture AFP entries would be simplified by using a declare … [cong del]<br>\nworkaround.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/ysNsu3iHEITUn3H_69BMPQfW/signature.asc\">signature.asc</a></p>",
        "id": 294749194,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194759
    }
]