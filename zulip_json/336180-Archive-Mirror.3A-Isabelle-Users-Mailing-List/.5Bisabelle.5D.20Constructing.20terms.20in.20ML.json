[
    {
        "content": "<p>From: Steve Wong &lt;<a href=\"mailto:s.wong.731@gmail.com\">s.wong.731@gmail.com</a>&gt;<br>\nHi all,</p>\n<p>I'm trying to construct the term for \"ALL x y. x = y\". I know I could just<br>\nuse Syntax.read_term, but what if I want to construct it term by term using<br>\nthe constructor functions? I see that the term should look something like:</p>\n<p>Const (\"HOL.All\", \"('a =&gt; HOL.bool) =&gt; HOL.bool\") $<br>\n     Abs (\"x\", \"'a\",<br>\n       Const (\"HOL.All\", \"('a =&gt; HOL.bool) =&gt; HOL.bool\") $<br>\n         Abs (\"y\", \"'a\",<br>\n           Const (\"HOL.eq\", \"'a =&gt; 'a =&gt; HOL.bool\") $ Bound 1 $ Bound 0))</p>\n<p>Without fixing the types of x and y, HOLogic.mk_eq (Bound 0, Bound 1) gives<br>\nan error, because it can't find the type of Bound terms. I was just thinking<br>\nto create the mk_eq term first, then wrap it inside a mk_all and itself<br>\ninside another mk_all. Is there a better way to go about this?</p>\n<p>Thanks a lot in advance.</p>\n<p>Steve</p>",
        "id": 294145090,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847187
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nHello Steve.</p>\n<p>HOLogic.eq_const might be able to help you. You need to supply it the <br>\ntype, which is expected.</p>\n<p>For instance<br>\nML {* let val T = @{typ 'a} in<br>\n     HOLogic.mk_all (\"x\", T, HOLogic.mk_all (\"y\", T, HOLogic.eq_const T <br>\n$ Bound 1 $ Bound 0)) end<br>\n*}</p>\n<p>Or the slightly shorter<br>\nML {* let val T = @{typ 'a} in<br>\n     HOLogic.list_all ([(\"x\", T), (\"y\", T)], HOLogic.eq_const T $ Bound <br>\n1 $ Bound 0) end<br>\n*}</p>\n<p>There are usually many different ways to do things.</p>\n<p>Here is another one, which may come as something of a surprise:</p>\n<p>ML {* let val T = @{typ 'a} in<br>\n     HOLogic.mk_all (\"x\", T, HOLogic.mk_all (\"y\", T, HOLogic.eq_const T <br>\n$ Free (\"x\", T) $ Free (\"y\", T))) end<br>\n*}</p>\n<p>A number of the functions that construct lambda-terms call absfree, <br>\nwhich will captrue Free variables with the same name and type as the <br>\nvariable being bound. It happens that mk_all calls this, but list_all <br>\ndoesn't. Obviously.</p>\n<p>As for whether there's a better way to go about this, well, the example <br>\nis too limited. Usually you don't use ML to build any single thing, <br>\nrather to encode a recipe for producing many terms, theorems, etc.</p>\n<p>If you really do just want to produce this term once, you might as well <br>\njust quote it with @{term \"ALL x y. x = y\"}. Otherwise it depends what <br>\nyou parameters really are. If you want to produce this term for various <br>\ntypes T, for instance, you could use the code above. In more complex <br>\ncases, you tend to end up tearing apart your input terms and thinking <br>\ncarefully about which parts you can be certain are type-carrying. This <br>\nis not a lot of fun. The approach of using Free variables to represent <br>\nBound variables whenever the Abs is not yet closed may help sometimes, <br>\nbut requires some additional machinery for picking them at the right <br>\ntime and making sure their names are fresh.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294145103,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847193
    }
]