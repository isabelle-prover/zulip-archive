[
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Florian,</p>\n<p>Sure:</p>\n<p>ML {*<br>\nMeson_Clausify.introduce_combinators_in_cterm @{cterm \"%x::'a. Suc 0\"}<br>\n*}</p>\n<p>Jasmin</p>",
        "id": 294315766,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925414
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI am scpetical about using combinators in practice. There was a time when<br>\npeople thought that is a good idea, but I don't think aybody does it anymore.<br>\nI find it a bit worrying that lambda's should be a problem in code generation.</p>\n<p>Tobias</p>",
        "id": 294315949,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925478
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nThe combinators, if relevant at all, would only be introduced in the<br>\n<em>outermost</em> term to be evaluated and save considerable trusted code<br>\nthere.  Details still to be awaited…</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/m9i-pf8HgHBPFWsrQ2yPHfG3/signature.asc\">signature.asc</a></p>",
        "id": 294316179,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925546
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>in HOL, is there any conversion turning a term t into an equivalent t'<br>\nwith all abstractions turned into expressions of combinatory logic? E.g.</p>\n<p>comblogic_conv «%x. Suc 0» ~&gt; «K (Suc 0)»</p>\n<p>I dimly remember that metis and/or sledgehammer once used to have<br>\nsomething like this, and maybe it is still there somewhere.</p>\n<p>The reason is that I collect some ideas how to implement a more robust<br>\napproach towards evaluation using code generation, and a preliminary is<br>\nthat the terms to be evaluated are lambda-free.  Hence such a conversion<br>\nwould make a convenient preprocessor.</p>\n<p>Thanks a lot,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Bs-GrHTBs2gNPRaa9eBAnxo2/signature.asc\">signature.asc</a></p>",
        "id": 294318197,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926122
    }
]