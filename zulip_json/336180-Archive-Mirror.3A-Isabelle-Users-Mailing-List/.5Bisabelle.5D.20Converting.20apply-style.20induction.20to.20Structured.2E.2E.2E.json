[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHow about</p>\n<p>lemma cata_uniq:<br>\n   assumes \"cata c f b\"<br>\n   shows \"c as = catafunc f b as\"<br>\nproof (induct as)<br>\n   case (Singleton a)<br>\n   from assms show ?case<br>\n     by (simp add: catafunc_def cata_def)<br>\nnext<br>\n   case (Snoc as a)<br>\n   from assms show ?case<br>\n     by (simp only: Snoc cata_def cons_rewrite) simp<br>\nqed</p>\n<p>The fact that I need to split the final step into 2 parts (one only <br>\nusing cons_rewrite cata_def and the induction hypothesis, and the other <br>\nusing all the simplification rules that are around) indicates that some <br>\nof your equations may be oriented in the wrong direction (without the <br>\nsplit, the simplifier loops). But I didn't have closer look. Another <br>\nthing that I find strange in your original proof is the use of <br>\ncatafunc_def which was defined via \"fun\" an hence provides <br>\nsimplification rules catafunc.simps.</p>\n<p>A few words on the above proof: Fixing local variables and stating <br>\nassumptions (e.g., the IH) is done automatically when using \"case\", e.g.,</p>\n<p>case (Snoc as a)</p>\n<p>is a kind of abbreviation for</p>\n<p>fix as a<br>\n   assume \"c as = catafunc f b as\"</p>\n<p>I hope this helps.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294131857,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843102
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Donnerstag, den 31.03.2011, 13:29 +0200 schrieb Søren Haagerup:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have a hard time going from Apply-style induction proofs to the<br>\nStructured Isar-style.</p>\n<p>In the apply-style case, the proof of \"cata_uniq\" is a mere 4 lines:<br>\n<a href=\"http://gawis.dk/misc/apply_sample.thy\">http://gawis.dk/misc/apply_sample.thy</a></p>\n<p>In the structured style, I need to write much more:<br>\n<a href=\"http://gawis.dk/misc/structured_sample.thy\">http://gawis.dk/misc/structured_sample.thy</a></p>\n</blockquote>\n<ul>\n<li>\n<p>Do not add catafunc_def, this is the wrong simp rule. The rules<br>\n  catafunc.simps are automatically added to the simpset by primrec.</p>\n<p>This also adds the rules for \"app\" to the simp set, which is the<br>\ninverse of cata_rewrite, and hence when you add cata_rewrite without<br>\nremoving app.simps, like \"simp add: cata_rewrite\" the simplifier does<br>\nnot terminate. Instead use \"simp add: cata_rewrite del: app.simps\"</p>\n</li>\n<li>\n<p>You cata_helper lemma is always a good idea to add. Probably named<br>\n  added to the simplifier. However adding rules to the automatization<br>\n  needs some experience, but you should try to play with it. (they also <br>\n  look like nice dest rules)</p>\n</li>\n<li>\n<p>The \"case\" command lets you specify the fixed variables no need to<br>\n  add \"fix\" and \"assume\".</p>\n</li>\n<li>\n<p>If you use \"case\" with the method \"induct\" the thesis is not <br>\n  named ?thesis but ?case, the facts are named after the case name (look<br>\nat Isabelle / Show me / Facts) :</p>\n<p>proof (induct c)<br>\n  case (Cons1 a b c) then show ?case ...<br>\nnext<br>\n  case (Cons2 a b c) then show ?case ...<br>\nqed</p>\n</li>\n<li>\n<p>In your structured cata_uniq you do not need the additional<br>\n    show \"\" proof -  ...  qed<br>\n  command.</p>\n</li>\n<li>\n<p>My solution would be:</p>\n<p>lemma cata_uniq:<br>\n  \"cata c f b ==&gt; c as = catafunc f b as\"<br>\nproof (induct as)<br>\n  case (Snoc as a)<br>\n  then have \"c (app as (Singleton a)) = b (catafunc f b as) (f a)\"<br>\n    by (simp_all add: cata_def del: app.simps)<br>\n  then show ?case<br>\n    by simp<br>\nqed (simp add: cata_def)<br>\n  (** the method supplied to \"qed\" is applied to the remaining goals.<br>\n      Here it is the Singleton case. **)</p>\n</li>\n<li>\n<p>Another possible solution would be:</p>\n<p>lemma cata_uniq:<br>\n  \"cata c f b ==&gt; c as = catafunc f b as\"<br>\nproof (induct as)<br>\n  case (Snoc as a) then show ?case<br>\n    by (simp add: cata_def cons_rewrite del: app.simps) simp<br>\nqed (simp add: cata_def)</p>\n</li>\n</ul>\n<p>This is shorted but probably not as readable and stable as the previous<br>\nproof.</p>\n<p>The lines</p>\n<p>by (simp add: cata_def cons_rewrite del: app.simps)<br>\n         simp</p>\n<p>are the same as</p>\n<p>proof (simp add: cata_def cons_rewrite del: app.simps)<br>\n qed simp</p>\n<p>Hope this helps,<br>\n  Johannes</p>\n<blockquote>\n<p>Is there a way to make a concise structured proof of this fact?</p>\n<p>Best regards,<br>\nSøren</p>\n</blockquote>",
        "id": 294131873,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843112
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nQuoting Søren Haagerup &lt;<a href=\"mailto:shaagerup@gmail.com\">shaagerup@gmail.com</a>&gt;:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have a hard time going from Apply-style induction proofs to the<br>\nStructured Isar-style.</p>\n<p>In the apply-style case, the proof of \"cata_uniq\" is a mere 4 lines:<br>\n<a href=\"http://gawis.dk/misc/apply_sample.thy\">http://gawis.dk/misc/apply_sample.thy</a></p>\n<p>In the structured style, I need to write much more:<br>\n<a href=\"http://gawis.dk/misc/structured_sample.thy\">http://gawis.dk/misc/structured_sample.thy</a></p>\n<p>Is there a way to make a concise structured proof of this fact?</p>\n</blockquote>\n<p>Well, you have to keep in mind that a 'good' Isar proof conveys more<br>\ninformation than an apply-script. In a 'good' Isar proof you should<br>\nbe able to easily read off the proof idea. This means in practice<br>\nthat an Isar proof is sometimes a bit more verbose.</p>\n<p>However looking at your proof, I would formulate it as follows.</p>\n<p>lemma cata_uniq :<br>\n    assumes a: \"cata c f b\"<br>\n    shows \"c as = catafunc f b as\"<br>\n  proof (induct as)<br>\n    case (Singleton a)<br>\n    show \"c (Singleton a) = catafunc f b (Singleton a)\"<br>\n      using a by (simp add: catafunc_def cata_def)<br>\n  next<br>\n    case (Snoc as a)<br>\n    have hyp: \"c as = catafunc f b as\" by fact<br>\n    have \"c (Snoc as a) = c (app as (Singleton a))\" by (simp only:  <br>\ncons_rewrite)<br>\n    also have \"... = b (c as) (f a)\"<br>\n      using cata_helper(3)[OF a, of as \"Singleton a\"]  <br>\ncata_helper(2)[OF a, of a] by auto<br>\n    also have \"... = b (catafunc f b as) (f a)\" using hyp by auto<br>\n    finally show \"c (Snoc as a) = catafunc f b (Snoc as a)\"<br>\n      by simp<br>\nqed</p>\n<p>1.) As suggested before, I fix the variables at the case-level. This  <br>\ngets rid of the explicit fix lines.</p>\n<p>2.) Also often I start with a proof like yours (which contains forward  <br>\nand backward reasoning steps). If possible, I then reformulate these  <br>\nproofs to<br>\nbe completely forward proofs, which tend to be slightly shorter (you  <br>\ncan save the lines about opening and closing subproofs).</p>\n<p>3.) If you think that the Singleton-case is too trivial and should not  <br>\nbe shown<br>\nexplicitly, you can 'hide' it by discharging it at the qed-statement,  <br>\nlike this:</p>\n<p>lemma cata_uniq :<br>\n  assumes a: \"cata c f b\"<br>\n  shows \"c as = catafunc f b as\"<br>\nproof (induct as)<br>\n   case (Snoc as a)<br>\n   have hyp: \"c as = catafunc f b as\" by fact<br>\n   have \"c (Snoc as a) = c (app as (Singleton a))\" by (simp only: cons_rewrite)<br>\n   also have \"... = b (c as) (f a)\"<br>\n     using cata_helper(3)[OF a, of as \"Singleton a\"] cata_helper(2)[OF  <br>\na, of a] by auto<br>\n   also have \"... = b (catafunc f b as) (f a)\" using hyp by auto<br>\n   finally show \"c (Snoc as a) = catafunc f b (Snoc as a)\"<br>\n     by simp<br>\nqed (simp add: a[unfolded cata_def])</p>\n<p>OK, this is not as short as your apply-script and the two solutions,<br>\nbut as said above the purpose of an Isar proof is not to be as concise as<br>\nan apply-script, but to easily read off the proof idea (your calculation).<br>\nThis might mean in this case that the proof is a bit more verbose (but this<br>\nis not always the case).</p>\n<blockquote>\n<p>I have a hard time going from Apply-style induction proofs to the<br>\nStructured Isar-style.</p>\n</blockquote>\n<p>My experience is also that going from an apply script to an Isar proof<br>\nis not that easy. Fiddling with an apply script usually completely buries<br>\nthe proof idea. Constructing then the corresponding Isar proof means that<br>\none has to think again about what are the important steps in the proof are.<br>\nThat can sometimes be non-obvious.</p>\n<p>Hope this helps,<br>\nChristian</p>",
        "id": 294131881,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843115
    },
    {
        "content": "<p>From: Søren Haagerup &lt;<a href=\"mailto:shaagerup@gmail.com\">shaagerup@gmail.com</a>&gt;<br>\nThis really made my day -- I have been craving for such a feature for<br>\nvery long :-)<br>\nThank you for all your suggestions and solutions - it sped up my<br>\nlearning process a lot!</p>\n<p>Best,<br>\nSøren</p>",
        "id": 294131902,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843124
    },
    {
        "content": "<p>From: Søren Haagerup &lt;<a href=\"mailto:shaagerup@gmail.com\">shaagerup@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I have a hard time going from Apply-style induction proofs to the<br>\nStructured Isar-style.</p>\n<p>In the apply-style case, the proof of \"cata_uniq\" is a mere 4 lines:<br>\n<a href=\"http://gawis.dk/misc/apply_sample.thy\">http://gawis.dk/misc/apply_sample.thy</a></p>\n<p>In the structured style, I need to write much more:<br>\n<a href=\"http://gawis.dk/misc/structured_sample.thy\">http://gawis.dk/misc/structured_sample.thy</a></p>\n<p>Is there a way to make a concise structured proof of this fact?</p>\n<p>Best regards,<br>\nSøren</p>",
        "id": 294133987,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843768
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nHi,</p>\n<p>While drinking tea, I took a quick stab at it too, here's what I ended <br>\nup with:</p>\n<p>lemma cata_uniq2: \"cata c f b ==&gt; c as = catafunc f b as\"<br>\n   unfolding cata_def<br>\nproof (induct as)<br>\n   case (Singleton a) thus ?case by simp<br>\nnext<br>\n   case (Snoc as a)<br>\n   thus ?case<br>\n     by (subst catafunc.simps)<br>\n        (simp add: cons_rewrite del: app.simps)<br>\nqed</p>\n<p>The \"cons_rewrite\" lemma is in direct conflict with app.simps, so they <br>\ncan't both be in the simpset at the same time.</p>\n<p>If you repeatedly run into this type of conflict, you might want to <br>\nremove the function equations from the simpset using:</p>\n<p>declare app.simps[simp del]</p>\n<p>Then you can always add them back in to the simplifier when needed.</p>\n<p>By now, you should have a nice collection of various people's proving <br>\nstyles in Isar :)</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294134005,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843774
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nI've found metis quite handy in similar situations.  metis knows about<br>\nsymmetry, so (unlike simp) it may still succeed when equalities are<br>\noriented the wrong way.</p>\n<p>Kind regards,<br>\nTjark</p>",
        "id": 294134936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844040
    }
]