[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nAssume I have some lemma in a locale</p>\n<p>locale test = fixes A::\"'a list set\"<br>\nassumes [...]<br>\nbegin<br>\n  [...]</p>\n<p>lemma test[simp]: \"a@b\\&lt;in&gt;A &lt;--&gt; a\\&lt;in&gt;A &amp; b\\&lt;in&gt;A\"</p>\n<p>in order to apply this lemma also to lists of the form \"a#as\", outside a <br>\nlocale, I would usually do<br>\n  lemmas test'[simp] = test[of \"[x]\", simplified, standard]</p>\n<p>the problem is, that standard does not only convert the fixed variable x <br>\nto a wildcard variable ?x, but it also prefixes the lemma with an <br>\nassumption \"test A\", because we are inside the locale. Instead of the <br>\ndesired<br>\n  \"?x#?b\\&lt;in&gt;A &lt;--&gt; [?x]\\&lt;in&gt;A &amp; b\\&lt;in&gt;A\",<br>\nI get<br>\n  \"test A ==&gt; ?x#?b\\&lt;in&gt;A &lt;--&gt; [?x]\\&lt;in&gt;A &amp; b\\&lt;in&gt;A\"<br>\nand this lemma won't work as a simplification rule inside the locale <br>\ncontext.</p>\n<p>Is there a way to the fixed variables replaced by wildcards, but not <br>\ngetting this locale-assumption in front of the lemma (of course, without <br>\nretyping and proving the special version of the lemma ;) ) ?</p>\n<p>Regards,<br>\n  Peter</p>",
        "id": 294062044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824077
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 11 Jun 2008, Peter Lammich wrote:</p>\n<blockquote>\n<p>Assume I have some lemma in a locale</p>\n<p>locale test = fixes A::\"'a list set\"<br>\nassumes [...]<br>\nbegin<br>\n [...]</p>\n<p>lemma test[simp]: \"a@b\\&lt;in&gt;A &lt;--&gt; a\\&lt;in&gt;A &amp; b\\&lt;in&gt;A\"</p>\n<p>in order to apply this lemma also to lists of the form \"a#as\", outside a<br>\nlocale, I would usually do<br>\n lemmas test'[simp] = test[of \"[x]\", simplified, standard]</p>\n</blockquote>\n<p>Such forward inferences via \"simplified\" and \"standard\" as part of fact <br>\ndeclarations do not work well within general local theory targets.  You <br>\nhave already encountered the inherent global nature of \"standard\".  The <br>\n\"simplified\" rule has other potential problems, when transforming locale <br>\nresults by interpretation, or even just when re-entering the locale <br>\ncontext in a different theory, because the simplification process is <br>\nrepeated within different dynamic contexts each time!</p>\n<blockquote>\n<p>Is there a way to the fixed variables replaced by wildcards, but not <br>\ngetting this locale-assumption in front of the lemma (of course, without <br>\nretyping and proving the special version of the lemma ;) ) ?</p>\n</blockquote>\n<p>I am not aware of any sane way, apart from the canonical one:</p>\n<p>lemma test': \"x # b : A &lt;-&gt; [x] : A &amp; b : A\"<br>\n  by (rule test [of \"[x]\", simplified])</p>\n<p>Makarius</p>",
        "id": 294062069,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824083
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nPeter Lammich wrote:<br>\nPeter,</p>\n<p>I've never tried doing this inside a locale, but, to turn free variables <br>\ninto ?-variables,<br>\nwithout doing the other stuff that standard does,  I have used</p>\n<p>(gen_all o forall_intr_frees), thus</p>\n<p>val mp' = \"[| P --&gt; Q; P |] ==&gt; Q\" : Thm.thm</p>\n<blockquote>\n<p>(gen_all o forall_intr_frees) mp';<br>\nval it = \"[| ?P --&gt; ?Q; ?P |] ==&gt; ?Q\" : Thm.thm</p>\n</blockquote>\n<p>Jeremy</p>",
        "id": 294062116,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824101
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nQuoting Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;:</p>\n<blockquote>\n<p>Peter Lammich wrote:</p>\n<blockquote>\n<p>Is there a way to the fixed variables replaced by wildcards, but   <br>\nnot getting this locale-assumption in front of the lemma (of   <br>\ncourse, without retyping and proving the special version of the   <br>\nlemma ;) ) ?</p>\n<p>Regards,<br>\nPeter</p>\n<p>Peter,</p>\n</blockquote>\n<p>I've never tried doing this inside a locale, but, to turn free<br>\nvariables into ?-variables,<br>\nwithout doing the other stuff that standard does,  I have used</p>\n<p>(gen_all o forall_intr_frees), thus</p>\n<p>val mp' = \"[| P --&gt; Q; P |] ==&gt; Q\" : Thm.thm</p>\n<blockquote>\n<p>(gen_all o forall_intr_frees) mp';<br>\nval it = \"[| ?P --&gt; ?Q; ?P |] ==&gt; ?Q\" : Thm.thm</p>\n</blockquote>\n<p>Jeremy</p>\n</blockquote>\n<p>If you want to use this from Isar, it is actually pretty easy to  <br>\ndefine your own theorem attributes, given a function of type thm -&gt; thm:</p>\n<p>setup {*<br>\nAttrib.add_attributes<br>\n   [(\"wildcard\",<br>\n     Attrib.no_args (Thm.rule_attribute (K (gen_all o forall_intr_frees))),<br>\n     \"replace fixed variables by wildcards\")];<br>\n*}</p>\n<p>You can use it like this:</p>\n<p>thm mp [of R S]</p>\n<blockquote>\n<p>\"[| R --&gt; S; R |] ==&gt; S\"</p>\n</blockquote>\n<p>thm mp [of R S, wildcard]</p>\n<blockquote>\n<p>\"[| ?R --&gt; ?S; ?R |] ==&gt; ?S\"</p>\n</blockquote>\n<p>thm mp [of \"x = y\", wildcard]</p>\n<blockquote>\n<p>\"[| ?x2 = ?y2 --&gt; ?Q; ?x2 = ?y2 |] ==&gt; ?Q\"</p>\n</blockquote>\n<p>The \"standard\" attribute is defined very similarly to this; the code  <br>\nis in Pure/Isar/attrib.ML:</p>\n<p>val standard = no_args (Thm.rule_attribute (K Drule.standard));</p>\n<p>It refers to the function Drule.standard from Pure/drule.ML:</p>\n<p>val standard' =<br>\n   implies_intr_hyps<br>\n   #&gt; forall_intr_frees<br>\n   #&gt; `Thm.maxidx_of<br>\n   #-&gt; (fn maxidx =&gt;<br>\n     Thm.forall_elim_vars (maxidx + 1)<br>\n     #&gt; Thm.strip_shyps<br>\n     #&gt; zero_var_indexes<br>\n     #&gt; Thm.varifyT);</p>\n<p>val standard =<br>\n   flexflex_unique<br>\n   #&gt; standard'<br>\n   #&gt; Thm.close_derivation;</p>\n<p>As you can see, the \"standard\" attribute does quite a few things. One  <br>\nother feature of \"standard\" you might want to add to \"wildcard\" would  <br>\nbe to zero the variable indexes, to avoid the problem with the third  <br>\nexample above.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294062128,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824108
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nNote that anything modeled after the old \"standard\" only works in a global <br>\ncontext.  In fact, fixed variables cannot be generalized without leaving <br>\nthe context, which is not allowed an attribute anyway.  So strictly <br>\nspeaking, the \"standard\" attribute is a legacy feature, despite its rather <br>\nmisleading name.</p>\n<p>Going back to the original motivation, the demand for generalizing <br>\nvariables was coming from fact declarations like this:</p>\n<p>lemmas a = b [of x]</p>\n<p>Here x is an undeclared free variable, and there is no official way to <br>\never get rid of it.  What you actually want is to say that x should be <br>\nfixed in the context of the statement, such that it becomes arbitrary in <br>\nthe result.  I.e. something analogous to</p>\n<p>lemma a: fixes x shows B x ...</p>\n<p>or</p>\n<p>lemma a: shows B x ...</p>\n<p>where the fixing is implicit.</p>\n<p>Neither form is available for compact fact expressions, without an <br>\nexplicit statement.  There are some plans for a more uniform way to put <br>\narbitrary statements (definitions and theorems) into a auxiliary context, <br>\nwith local fixes and assumes just like the special form for long theorem <br>\nstatements.  At the moment we are still very busy to struggle with <br>\nold-style global operations showing up in unexpected corners ...</p>\n<p>Makarius</p>",
        "id": 294062140,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824113
    }
]