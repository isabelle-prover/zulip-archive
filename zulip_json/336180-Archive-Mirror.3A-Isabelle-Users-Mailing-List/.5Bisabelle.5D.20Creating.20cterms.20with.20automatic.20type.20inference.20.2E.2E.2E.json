[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I would like to understand if there exists a canonical method for creating<br>\ncterms with automatic type inference from several distinct terms in<br>\nIsabelle/ML, given that some of these distinct terms are supplied by the<br>\nuser.  Unfortunately, given that some of the consts that are used in the<br>\nterms provided by the user are not known in advance, the methods that I am<br>\naware of do not seem to be directly applicable or may, potentially, result<br>\nin certain malpractices.</p>\n<p>For example, I would like to perform an automatic type inference and create<br>\na certified term in the context of the following (significantly) simplified<br>\nuse case:</p>\n<p>ML ‹</p>\n<p>val A = @{term \"A::'al⇒'ar⇒bool\"};<br>\nval B = @{term \"B::'bl⇒'br⇒bool\"};<br>\nval RF = @{term rel_fun} (*in the use case, RF can represent an arbitrary<br>\nconst accepting an arbitrary number of arguments, as supplied by the user*)</p>\n<p>val uterm = RF $ A $ B;<br>\n(* fails because type inference is not applicable: *)<br>\nval cterm = Thm.cterm_of @{context} uterm;</p>\n<p>›</p>\n<p>Of course, the default names of the 'TFree' types that are generated for<br>\nrel_fun in the example above are not suitable when $ is used for combining<br>\nterms. *It is very important to note that <strong>in my use case </strong>RF is provided<br>\nby the user and, therefore, it may be different from rel_fun.*</p>\n<p>I am aware of two methods that can be used for the solution of the problem.<br>\nHowever, these methods do not seem to be ideal for my application, given<br>\nthat the consts are provided by the user:</p>\n<ol>\n<li>\n<p>Provide \"tailor-made\" type inference for each const, similar to the<br>\nmethodology used in <a href=\"http://hologic.ml\">hologic.ml</a>, e.g. HOLogic.mk_eq. Unfortunately, in my<br>\nuse case, functions like HOLogic.mk_eq need to be generated 'on the fly'<br>\nbased on the user input. This solution seems to require an investment of a<br>\ncertain amount of effort.</p>\n</li>\n<li>\n<p>Define terms as strings and use Syntax.read_term to generate terms from<br>\nthe strings. This solution does not seem to be safe, although, its<br>\nimplementation is almost trivial.</p>\n</li>\n</ol>\n<p>I provide a code that demonstrates the methods that I am referring to in<br>\nthe clauses above after my signature. However, please note that the code is<br>\nmerely an example that is meant for the demonstration of the problem and it<br>\ndoes not contain (almost) any parts of the intended solution. Therefore,<br>\nplease ignore various malpractices that are not related to the problem (in<br>\nparticular, the code does not provide guarantees that unique names are used<br>\nand omits all error checks).</p>\n<p>*Lastly, I would like to provide a summary of the question : *</p>\n<p>- If there is a canonical method for combining arbitrary terms with type<br>\n   inference that is different from the methods suggested in clauses 1 and 2<br>\n   above, then I would highly appreciate if you could let me know about it. If<br>\n   such a method does not exist, then I would like to know whether the<br>\n   solution in clause 2 above is considered to be a standard practice or not.</p>\n<p>Thank you</p>\n<p>ML ‹</p>\n<p>(* -------------------------------------------- *)<br>\n(* auxiliary functions - provided for completeness *)</p>\n<p>fun delete_elem _ [] = []<br>\n  | delete_elem a (x::xs) =<br>\n    if (a = x) then (delete_elem a xs) else x::(delete_elem a xs);</p>\n<p>(* remove duplicates from a list *)<br>\nfun remdups [] = []<br>\n  | remdups (x::xs) = x::(remdups (delete_elem x xs));</p>\n<p>(* get unique free type variables *)<br>\nfun get_unique_tfree t =<br>\n  remdups(<br>\n    rev(<br>\n      fold_atyps<br>\n        (fn t =&gt; fn ts =&gt; case t of TFree td =&gt; (TFree td)::ts | _ =&gt; ts) t<br>\n[]<br>\n      )<br>\n    );</p>\n<p>val A = @{term \"A::'al⇒'ar⇒bool\"};<br>\nval B = @{term \"B::'bl⇒'br⇒bool\"};</p>\n<p>(* -------------------------------------------- *)</p>\n<p>(*</p>\n<p>Solution 1: the solution was inferred from the method suggested in section<br>\n3.2<br>\n(and other sections) in the document \"The Isabelle Cookbook\"<br>\n(May 28, 2015 draft) by Christian Urban. According to this solution,<br>\na tailor-made type inference procedure needs to be provided for each const.<br>\nOf course, for many existing standard consts this functionality has<br>\nalready been provided in hologic.ML (e.g. HOLogic.mk_eq).</p>\n<p>The solution is difficult to implement because the consts are<br>\nsupplied by the user. Therefore, functions similar to HOLogic.mk_eq need to<br>\nbe<br>\ngenerated 'on the fly'. Effectively, this would require the development of<br>\nthe functionality<br>\nthat would enable automatic generation of a significant part of the content<br>\nof <a href=\"http://hologic.ml\">hologic.ml</a>.</p>\n<p>*)</p>\n<p>val boolT = Type (\"HOL.bool\", []);<br>\nfun rel_fun_const (A, B, C, D) =<br>\n  Const<br>\n    (\\&lt;^const_name&gt;‹BNF_Def.rel_fun›,<br>\n    (A --&gt; B --&gt; boolT) --&gt;<br>\n    (C --&gt; D --&gt; boolT) --&gt;<br>\n    (A --&gt; C) --&gt;<br>\n    (B --&gt; D) --&gt;<br>\n    boolT);</p>\n<p>fun get_types_rel_fun fts gts = (nth fts 0, nth fts 1, nth gts 0, nth gts<br>\n1);</p>\n<p>fun mk_rel_fun (R1, R2) =<br>\n  (<br>\n  (get_types_rel_fun<br>\n  (R1 |&gt; type_of |&gt; get_unique_tfree)<br>\n  (R2 |&gt; type_of |&gt; get_unique_tfree)) |&gt; rel_fun_const<br>\n  )<br>\n  $ R1 $ R2;</p>\n<p>val cterm = Thm.cterm_of @{context} (mk_rel_fun (A, B));</p>\n<p>(*<br>\nSolution 2: inferred from the code on page 118 in<br>\nthe document \"The Isabelle/Isar Implementation\" by Makarius Wenzel.</p>\n<p>Can be implemented with ease, but requires the construction of terms<br>\nfrom strings. I am not certain if this is considered to be a standard<br>\npractice.<br>\n*)<br>\nval ctxt' = @{context} |&gt; Variable.declare_term A |&gt; Variable.declare_term<br>\nB;<br>\nval uterm' = Syntax.read_term ctxt' \"BNF_Def.rel_fun A B\";<br>\nval cterm' = Thm.cterm_of @{context} uterm';</p>\n<p>›</p>",
        "id": 294755439,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661197265
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nDear MLA,</p>\n<p>(re-sending as I forgot to Cc the list)</p>\n<p>I there is not really a well-established canonical method, since the<br>\nneeds of tools are quite different in the details.</p>\n<p>What tools usually do is try to get to a \"fully typed\" stage as soon as<br>\npossible in the outermost layers, and then work with full type<br>\ninformation internally, which means that you must usually carry types<br>\naround everywhere.</p>\n<p>What I would try is this:</p>\n<ul>\n<li>\n<p>Make sure you get the user-provided constants / terms in a polymorphic<br>\nversion, i.e., with schematic type variables. Here, the function<br>\n\"Variable.polymorphic\" should help.</p>\n</li>\n<li>\n<p>Then, construct the combined terms as you need them, and run type<br>\nchecking on this. (-&gt; Syntax.check_terms). I think this should<br>\ninstantiate the type variables properly.</p>\n</li>\n<li>\n<p>Then you should get terms on which Thm.cterm_of should work.</p>\n</li>\n</ul>\n<p>Note that Syntax.check_terms includes several specific things like<br>\ninsertion of coercions etc. But it is the most general answer to \"how do<br>\nI check / infer types\".</p>\n<p>Hope this helps.</p>\n<p>Alex</p>",
        "id": 294756491,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661197731
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Alexander Krauss,</p>\n<p>Thank you for your email. Indeed, your reply pointed me in the right<br>\ndirection.</p>\n<p>It seems that there is a nearly canonical solution for my problem (without<br>\nthe explicit use of the schematic type variables). The solution involves<br>\nthe use of the “place-holder” type dummyT, which is defined in term.ML (I<br>\ncan only assume it was defined specifically for this use case), e.g.</p>\n<p>ML ‹<br>\nval f = Const (\"HOL.eq\", dummyT);<br>\nval A = @{term \"A::'b\"};<br>\nval q = (f $ A $ A)<br>\n  |&gt; Syntax.check_term @{context}<br>\n  |&gt; Thm.cterm_of @{context};<br>\n›</p>\n<p>This method is presented in Section 3.5 in \"The Isabelle Cookbook\" (May 28,<br>\n2015 draft) by Christian Urban. I can hardly believe that I missed the<br>\nrelevant example upon the first reading. Regretfully, I only have several<br>\ndays of experience in Isabelle/ML coding, therefore, please accept my<br>\napologies for the naive question.</p>\n<p>Thank you</p>",
        "id": 294756634,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661197798
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nGlad you got it to work. Yes, dummyT is treated like a type variable by<br>\ntype inference, so this is the simplest solution if you just have a<br>\nsingle constant and must figure out the correct type.</p>\n<p>Alex</p>",
        "id": 294756815,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661197865
    }
]