[
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nLawrence Paulson wrote:</p>\n<blockquote>\n<p>Isabelle/HOL provides fold functionals for sets, which can be used  <br>\nprovided the result does not depend on the order in which set elements <br>\nare considered.</p>\n</blockquote>\n<p>Hello Jesper,</p>\n<p>this is probably not the case for your \"+\" function. If it is a<br>\nconstructor of the datatype of processes of the Pi-calculus, it<br>\nis neither associative nor commutative (at least with respect to<br>\nthe \"ordinary\" equality).</p>\n<blockquote>\n<p>On 2 Apr 2007, at 13:27, Jesper Bengtson wrote:</p>\n<blockquote>\n<p>On paper, the function would look like this:</p>\n<p>SUM {} = Nil<br>\nSUM (insert P S) = P + (SUM S).</p>\n<p>Not too complex, but what is the best way to do this in isabelle?  Is <br>\nthere a way to create this function, or is inductively defined  <br>\nrelations the best way to do this?</p>\n</blockquote>\n</blockquote>\n<p>Since there may be many ways of forming a sum from the elements<br>\nof a set, using an inductive definition is probably the best option.<br>\nYou could either define</p>\n<p>consts sum :: \"proc set =&gt; proc set\"</p>\n<p>inductive \"sum S\"<br>\n   intros<br>\n     Nil: \"Nil : sum S\"<br>\n     Plus: \"p : S ==&gt; q : sum S ==&gt; (p + q) : sum S\"</p>\n<p>if you don't care how many elements of S are used in the process, or</p>\n<p>consts sum' :: \"(proc set * proc) set\"</p>\n<p>inductive \"sum'\"<br>\n   intros<br>\n     Nil: \"({}, Nil) : sum'\"<br>\n     Plus: \"p : S ==&gt; (S - {p}, q) : sum' ==&gt; (S, p + q) : sum'\"</p>\n<p>if you want each element in S to be used exactly once.<br>\nThe fold functional for sets mentioned by Larry, which is defined in<br>\nFinite_Set.thy, is itself based on an inductively defined relation<br>\ncalled foldSet, which works similarly to the sum' relation described<br>\nabove.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294048201,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818201
    },
    {
        "content": "<p>From: Jesper Bengtson &lt;<a href=\"mailto:jesperb@it.uu.se\">jesperb@it.uu.se</a>&gt;<br>\nStefan Berghofer wrote:</p>\n<blockquote>\n<p>Lawrence Paulson wrote:</p>\n<blockquote>\n<p>Isabelle/HOL provides fold functionals for sets, which can be used  <br>\nprovided the result does not depend on the order in which set <br>\nelements are considered.</p>\n</blockquote>\n<p>Hello Jesper,</p>\n<p>this is probably not the case for your \"+\" function. If it is a<br>\nconstructor of the datatype of processes of the Pi-calculus, it<br>\nis neither associative nor commutative (at least with respect to<br>\nthe \"ordinary\" equality). </p>\n</blockquote>\n<p>The equality we are interested in is equality with respect to the <br>\naxiomatisation. I am then proving that this axiomatisation is sound and <br>\ncomplete with respect to strong late bisimilarity. For both of these <br>\nequality classes the +-operator is both associative and commutative, so <br>\nI think Larry's suggestion will do exactly what I want.</p>\n<blockquote>\n<p>On 2 Apr 2007, at 13:27, Jesper Bengtson wrote:</p>\n<blockquote>\n<blockquote>\n<p>On paper, the function would look like this:</p>\n<p>SUM {} = Nil<br>\nSUM (insert P S) = P + (SUM S).</p>\n<p>Not too complex, but what is the best way to do this in isabelle?  <br>\nIs there a way to create this function, or is inductively defined  <br>\nrelations the best way to do this?<br>\n</p>\n</blockquote>\n</blockquote>\n<p>Since there may be many ways of forming a sum from the elements<br>\nof a set, using an inductive definition is probably the best option.<br>\nYou could either define</p>\n<p>consts sum :: \"proc set =&gt; proc set\"</p>\n<p>inductive \"sum S\"<br>\n  intros<br>\n    Nil: \"Nil : sum S\"<br>\n    Plus: \"p : S ==&gt; q : sum S ==&gt; (p + q) : sum S\"</p>\n<p>if you don't care how many elements of S are used in the process, or</p>\n<p>consts sum' :: \"(proc set * proc) set\"</p>\n<p>inductive \"sum'\"<br>\n  intros<br>\n    Nil: \"({}, Nil) : sum'\"<br>\n    Plus: \"p : S ==&gt; (S - {p}, q) : sum' ==&gt; (S, p + q) : sum'\"</p>\n<p>if you want each element in S to be used exactly once.<br>\nThe fold functional for sets mentioned by Larry, which is defined in<br>\nFinite_Set.thy, is itself based on an inductively defined relation<br>\ncalled foldSet, which works similarly to the sum' relation described<br>\nabove.</p>\n</blockquote>\n<p>I had a few definitions such as these. I haven't implemented anything <br>\nconcretely yet, but these are good sugestions.</p>\n<p>Many thanks</p>\n<p>/Jesper</p>",
        "id": 294048214,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818207
    },
    {
        "content": "<p>From: Jesper Bengtson &lt;<a href=\"mailto:jesperb@it.uu.se\">jesperb@it.uu.se</a>&gt;<br>\nGreetings all</p>\n<p>I am currently working on proving soundness and completeness for the <br>\naxiomatisation of strong late bisimilarity of the pi calculus. A key <br>\nnotion here is that of summands which basically is a set of all subterms <br>\nwhich are constructed from the +-operator. I would, however, need a <br>\nfunction which creates a term from the set of its summands, i.e. <br>\nSUM(summands P) = P.</p>\n<p>On paper, the function would look like this:</p>\n<p>SUM {} = Nil<br>\nSUM (insert P S) = P + (SUM S).</p>\n<p>Not too complex, but what is the best way to do this in isabelle? Is <br>\nthere a way to create this function, or is inductively defined relations <br>\nthe best way to do this?</p>\n<p>Thank you for your time</p>\n<p>/Jesper</p>",
        "id": 294048642,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818397
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIsabelle/HOL provides fold functionals for sets, which can be used  <br>\nprovided the result does not depend on the order in which set  <br>\nelements are considered.</p>\n<p>For details, see this paper:</p>\n<p>Tobias Nipkow and L. C. Paulson. Proof Pearl: Defining Functions Over  <br>\nFinite Sets. In: Joe Hurd and Tom Melham (editors),Theorem Proving in  <br>\nHigher Order Logics (Springer LNCS 3603, 2005), 385â€“396.</p>\n<p>&lt;<a href=\"http://www.cl.cam.ac.uk/~lp15/papers/Reports/TPHOLs05.pdf\">http://www.cl.cam.ac.uk/~lp15/papers/Reports/TPHOLs05.pdf</a>&gt;</p>\n<p>Larry Paulson</p>",
        "id": 294048806,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818465
    }
]