[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I have large subgoals with operators that bind variables like let, bind and integrals.<br>\nThese operators are just higher-order functions which use the standard function <br>\nabstraction to implement the binding. Unfortunately, lemmas about these operators no <br>\nlonger apply when the bound variable is a tuple which is split up into its components <br>\nusing patterns (internally implemented via case_prod), because the case_prod destroys the <br>\npattern. Here is an example to illustrate the problem (also attached as a theory file). <br>\nThe bind operation on option commutes.</p>\n<p>notation Option.bind (infixr \"»=\" 54)</p>\n<p>lemma bind_commute: \"x »= (λx. y »= (λy. f x y)) = y »= (λy. x »= (λx. f x y))\"<br>\n   by(cases \"x = None ∨ y = None\") auto</p>\n<p>Now, I would like to apply this lemma in a situation where the \"x\" is a tupled option and <br>\nthe \"λx\" splits the tuple into its components say \"λ((b, c), d)\". For example,</p>\n<p>have \"f x »= (λ((b, c), d). g x »= h b d) = foo\"<br>\n   apply(subst bind_commute)</p>\n<p>Of course, the subst method fails here, because between the two binds there are the <br>\ncase_prod functions, i.e., the pattern does not match. I have not been able to find a <br>\nsatisfactory solution for this problem. I expect that others have the same problem and <br>\nhope that they share their solutions with me.</p>\n<p>Here are my attempts so far:</p>\n<ol>\n<li>\n<p>apply(unfold split_def)<br>\nThis works but the resulting subgoal is</p>\n<p>\"g x »= (λy. f x »= (λx. h (fst (fst x)) (snd x) y)) = foo</p>\n</li>\n</ol>\n<p>which is much harder to read than the desired</p>\n<p>\"g x »= (λy. f x »= (λ((b, c), d). h b d y)) = foo\"</p>\n<p>(Think of f, g, and h being huge terms with many occurrences of b and d.) Moreover, the <br>\nvariable names b and d get lost,</p>\n<ol start=\"2\">\n<li>Derive a commutativity rule for each way of splitting:</li>\n</ol>\n<p>lemma bind_commute_ss:<br>\n   \"x »= (λ((a, b), c). y »= h a b c) = y »= (λy. x »= (λ((a, b), c). h a b c y))\"<br>\n   unfolding split_def by(rule bind_commute)</p>\n<p>Now, I can use apply(subst bind_commute_ss), but the variable names are still lost. The <br>\nnew subgoal is<br>\n   \"g x »= (λy. f x »= (λ((a, b), c). h a c y)) = foo\"<br>\ninstead of<br>\n   \"g x »= (λy. f x »= (λ((b, c), d). h b d y)) = foo\"<br>\nMoreover, I have to derive a new rule for each way in which the tuples are split up.</p>\n<ol start=\"3\">\n<li>\n<p>State the desired result as an intermediate step:</p>\n<p>have \"f x »= (λ((b, c), d). g x »= h b d) = g x »= (λy. f x »= (λ((b, c), d). h b d y))\"<br>\n   by(unfold split_def)(rule bind_commute)<br>\n also have \"... = foo\"</p>\n</li>\n</ol>\n<p>When f, g, and h are huge terms, this is very inconvenient, especially when I am in the <br>\nmiddle of an apply script.</p>\n<p>Thanks in advance for any pointers and ideas,<br>\nAndreas<br>\n<a href=\"/user_uploads/14278/J5eKZT-2wDK6QViF2hXTBkDo/Split.thy\">Split.thy</a></p>",
        "id": 294327708,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929134
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:michael.norrish@nicta.com.au\">michael.norrish@nicta.com.au</a>&gt;<br>\nMy experience with this sort of situation is that sometimes you are just doomed.<br>\n However, Konrad Slind and I did have a proof pearl in TPHOLs 2005</p>\n<p><a href=\"http://nicta.com.au/people/norrishm/attachments/bibliographies_and_papers/2005/tphols2005-pearl.pdf\">http://nicta.com.au/people/norrishm/attachments/bibliographies_and_papers/2005/tphols2005-pearl.pdf</a></p>\n<p>where we presented a solution to a pretty similar problem.</p>\n<p>I don't know if the Isabelle simplifier will preserve variable names when it<br>\napplies the relevant rules, but at least the approach doesn't require anything<br>\nmore than standard h.o pattern rewriting.</p>\n<p>Michael<br>\n<a href=\"/user_uploads/14278/7dvJrIkPZlZiXHjO-WarZ637/signature.asc\">signature.asc</a></p>",
        "id": 294327754,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929146
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Michael,</p>\n<p>I am aware of your approach with combinators and have been using it in Isabelle for a <br>\nwhile. Unfortunately, the simplifier does not preserve variable names as required, but I <br>\nwas able to solve that by writing a simproc that takes care of that. Unfortunately, the <br>\nreasoning infrastructure sometimes spontaneously eta-expands (e.g., due to congruence <br>\nrules) or eta-contracts (in particular method subst) terms. Then, new variable names are <br>\nintroduced or some of the combinators remain in the goal. So this does not work as <br>\nsmoothly as in HOL.</p>\n<p>Maybe I could make your system work to preserve the variable names in my approach no. 2, <br>\nbut I don't see how I could avoid devising combinator rules for all combinations of splitting.</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294327769,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929152
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nI have never tried to tackle that issue, but a rough idea comes to my<br>\nmind: an optional simproc which collapses (%x. … fst x … snd x) to (%(a,<br>\nb). … a … b …).  No idea how this would work in practice.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/m-Kh_Iya45c7VkP_xVK7zL8G/signature.asc\">signature.asc</a></p>",
        "id": 294328106,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929256
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Florian,</p>\n<p>I am not sure that this would work in general, because \"fst x\" and \"snd x\" need not both <br>\nbe in the remaining term. In my example, we would get \"λ(a, d). h (fst a) d y\" in the <br>\nfirst step. For a, there is only \"fst a\", but no \"snd a\", so should the simproc trigger <br>\nonce more?</p>\n<p>What is more severe is that I do not see how one can possibly get back the original <br>\nvariable names. Once split_def has been unfolded, they seem to be gone forever.</p>\n<p>Andreas</p>",
        "id": 294328137,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929280
    }
]