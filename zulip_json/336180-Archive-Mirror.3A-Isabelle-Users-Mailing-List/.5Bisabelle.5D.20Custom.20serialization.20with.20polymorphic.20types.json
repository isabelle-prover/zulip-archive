[
    {
        "content": "<p>From: Sarah Winkler &lt;<a href=\"mailto:sarah.winkler@uibk.ac.at\">sarah.winkler@uibk.ac.at</a>&gt;<br>\nDear experts on code generation,</p>\n<p>I would like to export code to OCaml, using custom serialization to <br>\nadapt to an already present type.<br>\nHowever, my function have parameters of some polymorphic types, and I <br>\nwant to map instances of these types to non-polymorphic target types.<br>\nIn an example:<br>\nI have in OCaml<br>\ntype otree = ONode of otree * otree | OLeaf of int<br>\nand in Isabelle:</p>\n<p>datatype 'a \"tree\" = Node \"'a tree\" \"'a tree\" | Leaf 'a</p>\n<p>fun tsize :: \"'a tree \\&lt;Rightarrow&gt; nat\" where<br>\n\"tsize (Leaf a) = Suc 0\"<br>\n| \"tsize (Node l r) = Suc (tsize l) + (tsize r)\"</p>\n<p>Currently I use an extra data type and a transformation to export my <br>\nfunction to OCaml:<br>\ndatatype int_tree = INode int_tree int_tree | ILeaf int</p>\n<p>fun to_tree :: \"int_tree \\&lt;Rightarrow&gt; int tree\" where<br>\n\"to_tree (ILeaf i) = Leaf i\"<br>\n| \"to_tree (INode l r) = Node (to_tree l) (to_tree r)\"</p>\n<p>definition int_size :: \"int_tree \\&lt;Rightarrow&gt; nat\" where \"int_size t <br>\n\\&lt;equiv&gt; tsize (to_tree t)\"</p>\n<p>code_printing<br>\ncode_module \"Trees\" ⇀ (OCaml) {* type otree = ONode of otree * otree | <br>\nOLeaf of int *}<br>\n| type_constructor \"int_tree\" ⇀ (OCaml) \"otree\"<br>\n| constant ILeaf ⇀ (OCaml) \"OLeaf\"<br>\n| constant INode ⇀ (OCaml) \"ONode\"</p>\n<p>export_code tsize in OCaml</p>\n<p>Is there any more elegant way to achieve such a custom serialization, <br>\ncausing less \"overhead code\" in OCaml?</p>\n<p>Many thanks in advance,<br>\nSarah</p>",
        "id": 294248053,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909698
    },
    {
        "content": "<p>From: Sarah Winkler &lt;<a href=\"mailto:sarah.winkler@uibk.ac.at\">sarah.winkler@uibk.ac.at</a>&gt;<br>\nDear experts on code generation,</p>\n<p>I would like to export code to OCaml, using custom serialization to <br>\nadapt to an already present type.<br>\nHowever, my function have parameters of some polymorphic types, and I <br>\nwant to map instances of these types to non-polymorphic target types.<br>\nIn an example:<br>\nI have in OCaml<br>\ntype otree = ONode of otree * otree | OLeaf of int<br>\nand in Isabelle:</p>\n<p>datatype 'a \"tree\" = Node \"'a tree\" \"'a tree\" | Leaf 'a</p>\n<p>fun tsize :: \"'a tree \\&lt;Rightarrow&gt; nat\" where<br>\n\"tsize (Leaf a) = Suc 0\"<br>\n| \"tsize (Node l r) = Suc (tsize l) + (tsize r)\"</p>\n<p>Currently I use an extra data type and a transformation to export my <br>\nfunction to OCaml:<br>\ndatatype int_tree = INode int_tree int_tree | ILeaf int</p>\n<p>fun to_tree :: \"int_tree \\&lt;Rightarrow&gt; int tree\" where<br>\n\"to_tree (ILeaf i) = Leaf i\"<br>\n| \"to_tree (INode l r) = Node (to_tree l) (to_tree r)\"</p>\n<p>definition int_size :: \"int_tree \\&lt;Rightarrow&gt; nat\" where \"int_size t <br>\n\\&lt;equiv&gt; tsize (to_tree t)\"</p>\n<p>code_printing<br>\ncode_module \"Trees\" ⇀ (OCaml) {* type otree = ONode of otree * otree | <br>\nOLeaf of int *}<br>\n| type_constructor \"int_tree\" ⇀ (OCaml) \"otree\"<br>\n| constant ILeaf ⇀ (OCaml) \"OLeaf\"<br>\n| constant INode ⇀ (OCaml) \"ONode\"</p>\n<p>export_code tsize in OCaml</p>\n<p>Is there any more elegant way to achieve such a custom serialization, <br>\ncausing less \"overhead code\" in OCaml?</p>\n<p>Many thanks in advance,<br>\nSarah</p>",
        "id": 294248071,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909704
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Sarah,</p>\n<p>I am not completele sure that I fully understand your setting. In any case, you have <br>\nalready gone the canoncial way of doing this:</p>\n<ol>\n<li>Introduce a type copy that specialises the parameters as needed.</li>\n<li>Transfer all functions and theorems to the new type.</li>\n<li>Adapt the code generator for the new type.</li>\n</ol>\n<p>The packages lifting and transfer greatly help in the second step , they are described in <br>\n[1]. There are also many more tricks how to simplify the transfer.</p>\n<p>I do not know what you mean by \"overhead code\" in OCaml. Normally, you should not get code <br>\nfor the operations on \"'a leaf\" at all, unless you use then for other types than int. In <br>\nyour example, you should export int_size rather than tsize and provide code equations for <br>\nint_size:</p>\n<p>lemma [code]:<br>\n   \"int_size ILeaf = 0\"<br>\n   \"int_size (INode l r) = Suc (int_size l + int_size r)\"</p>\n<p>There are further possibilities for special cases, but it is hard to tell from your <br>\nexample whether they are promising directions. So, if the above does not work for you, <br>\nplease provide more detail on what you are trying to achieve.</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>[1] Florian Haftmann, Alexander Krauss, Ondrej Kuncar, Tobias Nipkow. Data Refinement in <br>\nIsabelle/HOL. In ITP 2013, LNCS, 2013.</p>",
        "id": 294248080,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909710
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Sarah,</p>\n<p>Indeed.  At might seem ridiculous at first sight to introduce type<br>\ncopies, but this maintains the one-to-one correspondence between types<br>\nin HOL and types in generated code, which is particularly important when<br>\ntype classes are involved.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/DG2Yo0sBU2UU7Ke-5iiOPvGg/signature.asc\">signature.asc</a></p>",
        "id": 294248211,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909760
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Sarah,</p>\n<blockquote>\n<p>It would be preferrable to get no code for operations on the abstract type ('a leaf).<br>\nThen just delete the code equations for the constants on the abstract type. The following <br>\nis the most reliable method to delete all code equations of a constant, say tsize:</p>\n</blockquote>\n<p>lemma [code, code del]: \"tsize = tsize\" ..</p>\n<blockquote>\n<p>However, I am a bit reluctant to copy all the theory for the abstract level (a lot of<br>\nstuff) to the concrete types - but I guess the lifting/transfer packages ease that task.<br>\n From a first glance I am afraid to not fully understand how they work, but I'll check in<br>\nmore detail (and possibly annoy the mailing list with further questions at a later point).<br>\nMy latest AFP entry Native Words [2] does something very similar, it maps bit operations <br>\non integers and words of different sizes to target language integers and machine words. <br>\nThere, I also have to instantiate type parameters in the type copies. Maybe you want to <br>\nhave a look at it, as it shows how to do all this with lifting/transfer. There's also a <br>\nuserguide that explains how to best use lifting/transfer once everything has been set up.</p>\n</blockquote>\n<p>Best,<br>\nAndreas</p>\n<p>[2] That entry is currently only available in the repository of the development AFP at <br>\n<a href=\"http://sourceforge.net/p/afp/code/ci/9f81b36d43b30aa09f79b17dfb9cb24d2f4802c9/\">http://sourceforge.net/p/afp/code/ci/9f81b36d43b30aa09f79b17dfb9cb24d2f4802c9/</a><br>\nIt has not yet made it onto the AFP devel website.</p>\n<blockquote>\n<p>Thanks for your help!<br>\nSarah</p>\n<blockquote>\n<p>lemma [code]:<br>\n  \"int_size ILeaf = 0\"<br>\n  \"int_size (INode l r) = Suc (int_size l + int_size r)\"</p>\n<p>There are further possibilities for special cases, but it is hard to tell from your<br>\nexample whether they are promising directions. So, if the above does not work for you,<br>\nplease provide more detail on what you are trying to achieve.</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>[1] Florian Haftmann, Alexander Krauss, Ondrej Kuncar, Tobias Nipkow. Data Refinement in<br>\nIsabelle/HOL. In ITP 2013, LNCS, 2013.<br>\n</p>\n</blockquote>\n<p>On 17/09/13 12:27, Sarah Winkler wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear experts on code generation,</p>\n<p>I would like to export code to OCaml, using custom serialization to adapt to an already<br>\npresent type.<br>\nHowever, my function have parameters of some polymorphic types, and I want to map<br>\ninstances of these types to non-polymorphic target types.<br>\nIn an example:<br>\nI have in OCaml<br>\ntype otree = ONode of otree * otree | OLeaf of int<br>\nand in Isabelle:</p>\n<p>datatype 'a \"tree\" = Node \"'a tree\" \"'a tree\" | Leaf 'a</p>\n<p>fun tsize :: \"'a tree \\&lt;Rightarrow&gt; nat\" where<br>\n\"tsize (Leaf a) = Suc 0\"<br>\n| \"tsize (Node l r) = Suc (tsize l) + (tsize r)\"</p>\n<p>Currently I use an extra data type and a transformation to export my function to OCaml:<br>\ndatatype int_tree = INode int_tree int_tree | ILeaf int</p>\n<p>fun to_tree :: \"int_tree \\&lt;Rightarrow&gt; int tree\" where<br>\n\"to_tree (ILeaf i) = Leaf i\"<br>\n| \"to_tree (INode l r) = Node (to_tree l) (to_tree r)\"</p>\n<p>definition int_size :: \"int_tree \\&lt;Rightarrow&gt; nat\" where \"int_size t \\&lt;equiv&gt; tsize<br>\n(to_tree t)\"</p>\n<p>code_printing<br>\ncode_module \"Trees\" ⇀ (OCaml) {* type otree = ONode of otree * otree | OLeaf of int *}<br>\n| type_constructor \"int_tree\" ⇀ (OCaml) \"otree\"<br>\n| constant ILeaf ⇀ (OCaml) \"OLeaf\"<br>\n| constant INode ⇀ (OCaml) \"ONode\"</p>\n<p>export_code tsize in OCaml</p>\n<p>Is there any more elegant way to achieve such a custom serialization, causing less<br>\n\"overhead code\" in OCaml?</p>\n<p>Many thanks in advance,<br>\nSarah<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294248247,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909775
    },
    {
        "content": "<p>From: Sarah Winkler &lt;<a href=\"mailto:sarah.winkler@uibk.ac.at\">sarah.winkler@uibk.ac.at</a>&gt;<br>\nDear Andreas and Florian,</p>\n<p>thanks for confirming the general approach, and the hints to the paper <br>\nand the Native Words theory! I think that gave me a good enough idea on <br>\nthe direction to pursue, and interesting references to points for <br>\nimprovement.</p>\n<p>Best regards,<br>\nSarah</p>",
        "id": 294248253,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909777
    }
]