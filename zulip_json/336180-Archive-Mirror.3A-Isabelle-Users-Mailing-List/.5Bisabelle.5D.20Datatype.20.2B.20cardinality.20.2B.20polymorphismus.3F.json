[
    {
        "content": "<p>From: \"Roger H.\" &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt;<br>\nHello,</p>\n<ol>\n<li>\n<p>If i have datatype color = red | blue<br>\nhow do i write smth like <br>\n-\"is c in color\"...meaning \"is c an instance of color?\"<br>\n-\"for all c in color: bla bla\" ... whats the \"in\"? cause the \"element of\" symbol is wrong<br>\n-length function..number of elements in the datatype .. so that it returns here length (color) = 2</p>\n</li>\n<li>\n<p>How do i write a function which maps different instances of the datatype to subsets of different types(like nat and bool):<br>\nf :: color -&gt; ??red |-&gt; {1,2}blue |-&gt; {True}<br>\ncause range f = UNIV isnt right.<br>\nMany thanks!</p>\n</li>\n</ol>",
        "id": 294645302,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163819
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMany of your questions are answered by the documentation. You will find it all in the documentation panel of an Isabelle session, or at the website <a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a>.</p>\n<p>Larry Paulson</p>",
        "id": 294645310,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163825
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nOn Sa, 2015-06-27 at 13:06 +0200, Roger H. wrote:</p>\n<p>Hi.</p>\n<blockquote>\n<p>Hello,<br>\n1. If i have datatype color = red | blue<br>\nhow do i write smth like <br>\n-\"is c in color\"...meaning \"is c an instance of color?\"<br>\n  Exactly the c's of type color are in color. <br>\n  The set of all colors is \"UNIV :: color set\".</p>\n</blockquote>\n<blockquote>\n<p>-\"for all c in color: bla bla\" ... whats the \"in\"? cause the \"element of\" symbol is wrong<br>\n  Just \"ALL c::color. P c\". Here, the ::color is a type constraint,<br>\nwhich forces the bound variable \"c\" to have type color, but is not<br>\nexplicitly visible in the parsed term.</p>\n</blockquote>\n<blockquote>\n<p>-length function..number of elements in the datatype .. so that it returns here length (color) = 2<br>\n  It's \"card( UNIV :: color set)\", provided color is a finite type.</p>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>How do i write a function which maps different instances of the datatype to subsets of different types(like nat and bool):<br>\nf :: color -&gt; ??red |-&gt; {1,2}blue |-&gt; {True}</li>\n</ol>\n</blockquote>\n<p>This is not possible in HOL's type system. An approximation would be<br>\n    f :: color =&gt; nat+bool</p>\n<p>Here, nat+bool is the sum type, that has the <br>\n  elements Inl (n::nat) and Inr (b::bool)</p>",
        "id": 294645322,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163831
    },
    {
        "content": "<p>From: \"Roger H.\" &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt;</p>\n<blockquote>\n<p>-\"is c in color\"...meaning \"is c an instance of color?\" <br>\nExactly the c's of type color are in color.  &gt; The set of all colors is \"UNIV :: color set\". </p>\n</blockquote>\n<ol>\n<li>\n<p>My question is how can i write this kind of predicate:<br>\n(red \\in color)   .................which is of type bool<br>\nI dont know it yet, since<br>\n\"red ∈ (UNIV :: color set)\" doesnt seem the right way to write it, since for<br>\n--datatype color = red | blue<br>\nlemma \"red ∈ (UNIV :: color set)\" is proven true,--<br>\nbut also<br>\nlemma \"green ∈ (UNIV :: color set)\" is also true..which should be false.  ??</p>\n</li>\n<li>\n<p>Concerning the cardinality... how do i prove the following<br>\nlemma \"card( UNIV :: color set) = 2\"<br>\nCause by simp, this just simplifies in :    \"card UNIV = 2\"<br>\nThank you!</p>\n</li>\n</ol>\n<p>On Sa, 2015-06-27 at 13:06 +0200, Roger H. wrote: Hi. </p>\n<blockquote>\n<p>Hello, <br>\n1. If i have datatype color = red | blue <br>\nhow do i write smth like <br>\n-\"is c in color\"...meaning \"is c an instance of color?\" <br>\n  Exactly the c's of type color are in color.   The set of all colors is \"UNIV :: color set\". </p>\n</blockquote>\n<blockquote>\n<p>-\"for all c in color: bla bla\" ... whats the \"in\"? cause the \"element of\" symbol is wrong <br>\n  Just \"ALL c::color. P c\". Here, the ::color is a type constraint, which forces the bound variable \"c\" to have type color, but is not explicitly visible in the parsed term. </p>\n</blockquote>\n<blockquote>\n<p>-length function..number of elements in the datatype .. so that it returns here length (color) = 2 <br>\n  It's \"card( UNIV :: color set)\", provided color is a finite type. </p>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>How do i write a function which maps different instances of the datatype to subsets of different types(like nat and bool): <br>\nf :: color -&gt; ??red |-&gt; {1,2}blue |-&gt; {True} </li>\n</ol>\n</blockquote>\n<p>This is not possible in HOL's type system. An approximation would be     f :: color =&gt; nat+bool   Here, nat+bool is the sum type, that has the   elements Inl (n::nat) and Inr (b::bool) &gt;</p>",
        "id": 294645464,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163871
    },
    {
        "content": "<p>From: \"C. Diekmann\" &lt;<a href=\"mailto:diekmann@in.tum.de\">diekmann@in.tum.de</a>&gt;<br>\nProbably you first want to define the type</p>\n<p>datatype colors = Red | Blue | Green</p>\n<p>The you want to reason about sets of this type</p>\n<p>lemma \"Red : {Blue, Red, Red}\"</p>\n<p>Otherwise, the manual provides good examples.<br>\n  Cornelius</p>",
        "id": 294645471,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163874
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI assume that you are talking about Isabelle/HOL (rather than, say, Isabelle/ZF). This is a typed formalism. The property of having a certain type is not a boolean formula, but is part of what it means for a term to be well-formed.</p>\n<p>Larry Paulson</p>",
        "id": 294645489,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163881
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nYou should check out (eg in the manual) how the type system in<br>\nIsabelle/HOL works. </p>\n<p>Propositions like \"x \\&lt;in&gt; UNIV\" are trivial, because x gets inferred<br>\nsome type, and UNIV is the set of all elements of this type. </p>\n<p>If you write \"green\", then green is just a variable (of type color).</p>",
        "id": 294645499,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163887
    },
    {
        "content": "<p>From: \"Roger H.\" &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt;</p>\n<blockquote>\n<p>I assume that you are talking about Isabelle/HOL (rather than, say, Isabelle/ZF). This is a typed formalism. The property of having a certain type is not a boolean formula, but is part of what it means for a term to be well-formed.</p>\n</blockquote>\n<p>Thank you Larry, this is a clear answer for one of my questions.<br>\nMy other questions were:</p>\n<ol>\n<li>\n<p>Assume I have <br>\ndatatype color = red |blue<br>\nfun f:: color =&gt; nat setf red = {1}f blue = {2}<br>\ndefinition M :: \"nat set\" whereM = the union...over all x in color...of  f(x)     //the result should be M = {1} union {2} = {1,2}<br>\nI dont know how to write the implementation of M in isabelle syntax.</p>\n</li>\n<li>\n<p>card (color) = 2 ? or size (color) = 2  ?  I am looking for the name of the function that gets a type and returns its number of constructors  (for such simple finite non-recursive types)</p>\n</li>\n</ol>\n<p>Thank you!</p>\n<blockquote>\n<p>Subject: Re: [isabelle] Datatype + cardinality + polymorphismus?<br>\nFrom: <a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a><br>\nDate: Sat, 27 Jun 2015 18:02:46 +0100<br>\nCC: <a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a><br>\nTo: <a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a></p>\n<p>I assume that you are talking about Isabelle/HOL (rather than, say, Isabelle/ZF). This is a typed formalism. The property of having a certain type is not a boolean formula, but is part of what it means for a term to be well-formed.</p>\n<p>Larry Paulson</p>\n<p>On 27 Jun 2015, at 12:22, Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Many of your questions are answered by the documentation. You will find it all in the documentation panel of an Isabelle session, or at the website <a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a>.</p>\n<p>Larry Paulson</p>\n<p>On 27 Jun 2015, at 12:06, Roger H. &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello,<br>\n1. If i have datatype color = red | blue<br>\nhow do i write smth like <br>\n-\"is c in color\"...meaning \"is c an instance of color?\"<br>\n-\"for all c in color: bla bla\" ... whats the \"in\"? cause the \"element of\" symbol is wrong<br>\n-length function..number of elements in the datatype .. so that it returns here length (color) = 2<br>\n2. How do i write a function which maps different instances of the datatype to subsets of different types(like nat and bool):<br>\nf :: color -&gt; ??red |-&gt; {1,2}blue |-&gt; {True}<br>\ncause range f = UNIV isnt right.<br>\nMany thanks!                     </p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294645513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163893
    },
    {
        "content": "<p>From: \"Roger H.\" &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt;<br>\nOr rather<br>\n1.datatype color = red |blue<br>\nfun f:: color =&gt; nat setf red = {1}f blue = {2}<br>\nhow do i prove <br>\nlemma \"(⋃x. f x) = {1,2}\"  ?<br>\nThank you.<br>\nFrom: <a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a><br>\nTo: <a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a><br>\nSubject: RE: [isabelle] Datatype + cardinality + polymorphismus?<br>\nDate: Sat, 27 Jun 2015 19:19:29 +0200</p>\n<blockquote>\n<p>I assume that you are talking about Isabelle/HOL (rather than, say, Isabelle/ZF). This is a typed formalism. The property of having a certain type is not a boolean formula, but is part of what it means for a term to be well-formed.</p>\n</blockquote>\n<p>Thank you Larry, this is a clear answer for one of my questions.<br>\nMy other questions were:</p>\n<ol>\n<li>\n<p>Assume I have <br>\ndatatype color = red |blue<br>\nfun f:: color =&gt; nat setf red = {1}f blue = {2}<br>\ndefinition M :: \"nat set\" whereM = the union...over all x in color...of  f(x)     //the result should be M = {1} union {2} = {1,2}<br>\nI dont know how to write the implementation of M in isabelle syntax.</p>\n</li>\n<li>\n<p>card (color) = 2 ? or size (color) = 2  ?  I am looking for the name of the function that gets a type and returns its number of constructors  (for such simple finite non-recursive types)</p>\n</li>\n</ol>\n<p>Thank you!</p>\n<blockquote>\n<p>Subject: Re: [isabelle] Datatype + cardinality + polymorphismus?<br>\nFrom: <a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a><br>\nDate: Sat, 27 Jun 2015 18:02:46 +0100<br>\nCC: <a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a><br>\nTo: <a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a></p>\n<p>I assume that you are talking about Isabelle/HOL (rather than, say, Isabelle/ZF). This is a typed formalism. The property of having a certain type is not a boolean formula, but is part of what it means for a term to be well-formed.</p>\n<p>Larry Paulson</p>\n<p>On 27 Jun 2015, at 12:22, Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Many of your questions are answered by the documentation. You will find it all in the documentation panel of an Isabelle session, or at the website <a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a>.</p>\n<p>Larry Paulson</p>\n<p>On 27 Jun 2015, at 12:06, Roger H. &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello,<br>\n1. If i have datatype color = red | blue<br>\nhow do i write smth like <br>\n-\"is c in color\"...meaning \"is c an instance of color?\"<br>\n-\"for all c in color: bla bla\" ... whats the \"in\"? cause the \"element of\" symbol is wrong<br>\n-length function..number of elements in the datatype .. so that it returns here length (color) = 2<br>\n2. How do i write a function which maps different instances of the datatype to subsets of different types(like nat and bool):<br>\nf :: color -&gt; ??red |-&gt; {1,2}blue |-&gt; {True}<br>\ncause range f = UNIV isnt right.<br>\nMany thanks!                     </p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294645556,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163909
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nSorry to repeat myself, but you really do need to read the documentation. Then you will be able to define f within Isabelle itself, and then you might find that Isabelle’s automation will make this example quite easy.</p>\n<p>Larry Paulson</p>",
        "id": 294645563,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163911
    }
]