[
    {
        "content": "<p>From: Diego Marmsoler &lt;<a href=\"mailto:marmsoler_diego@yahoo.it\">marmsoler_diego@yahoo.it</a>&gt;<br>\nHi,<br>\nI’ve a question regarding Datatypes in Isabelle/HOL. I want to define a new Datatype which is modeled as a set of tupels of traces where a trace is a list of some basic actions:<br>\n  typedecl actions<br>\n  type_synonym trace = \"(actions list) × (actions list)\"<br>\n  type_synonym program = \"trace set\"</p>\n<p>However I need to restrict the structure of the list: The list of action elements have to obey some constraints in order to be of type trace.<br>\nAt the moment I define a normal set to state the constraints of a trace and all my theorems are stated with “P” of type “program”  and include a separate assumption “P &lt;= CP” in order<br>\nto make use of some properties elicited by the set CP. The set CP is defined as follows:<br>\n  inductive_set<br>\n    CP :: compensable_program<br>\n  where<br>\n    cp_skip: \"([], []) ∈ CP\" |<br>\n    cp_error: \"([!], []) ∈ CP\" |<br>\n    cp_a_base: \"([Some a], [Some (inverse a)]) ∈ CP\" |<br>\n    cp_a_ind: \"(p, pi) ∈ CP ⟹ (Some a # p, pi @ [Some (inverse a)]) ∈ CP\"</p>\n<p>This works fine, however it would be much nicer if I could define a Datatype CP instead of using the set CP. Hence I could state all the theorems simply as “P” of type “CP” without the assumption that “P” is a subset of CP.</p>\n<p>Best,</p>\n<p>Diego</p>",
        "id": 294227487,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900704
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Diego,</p>\n<p>at the moment, program is just a type abbreviation, not a type constructor. <br>\nHence, you can use all functions on sets for programs, e.g., membership, <br>\nsubsets, bounded quantification. When you want to restrict the type of programs <br>\nto those sets of traces from CP, you have to model program as a type of its own, <br>\ni.e., you must define all the set operations you need on the new type. It is up <br>\nto you to decide whether this is worth the effort. Here's how you would do it in <br>\nIsabelle2012:</p>\n<p>inductive_set CP ...</p>\n<p>typedef (open) program = \"Pow CP\" by auto</p>\n<p>This defines the new type program. It is inhabited by all sets of traces all of <br>\nwhich are in CP. The function Abs_program constructs from an arbitrary set of <br>\ntraces the program that inhabits type program, Rep_program unpacks a program <br>\ninto the set of traces. For sets of traces not all of which are in CP, <br>\nAbs_program is unspecified. Since you make assumptions about the sets of traces <br>\nthat are programs, you cannot define program via datatype.</p>\n<p>The new lifting facility might help you in transferring and working with the <br>\ntype program.</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>PS: The rule cp_a_base in CP's definition is redundant, because it is a special <br>\ncase of cp_a_ind with cp_skip for the premise and simplification for @.</p>",
        "id": 294227496,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900707
    }
]