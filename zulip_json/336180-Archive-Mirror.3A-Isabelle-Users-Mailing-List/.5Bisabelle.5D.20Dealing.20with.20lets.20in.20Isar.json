[
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:christian.urban@kcl.ac.uk\">christian.urban@kcl.ac.uk</a>&gt;<br>\nDear All,</p>\n<p>We have a question about how to deal conveniently with <br>\nLets in Isar proofs. Some of our definitions contain many <br>\nnested lets, as in</p>\n<p>definition <br>\n   \"foo f e1 e2 e3 == let (x, y) = e1; (u, v) = e2; (w, k) = e3 in f x y u v w k\"</p>\n<p>The problem is that we have foo unfolded in our premises, say</p>\n<p>lemma<br>\n    assumes \"P (let (x, y) = e1; (u, v) = e2; (w, k) = e3 in f x y u v w k)\"<br>\n    shows \"thesis\"</p>\n<p>We could prove such lemmas with </p>\n<p>lemma<br>\n    assumes \"P (let (x, y) = e1; (u, v) = e2; (w, k) = e3 in f x y u v w k)\"<br>\n    shows \"thesis\"<br>\n  proof -<br>\n    from assms<br>\n    obtain x y u v w k<br>\n    where \"P (f x y u v w k)\" and <br>\n          \"(x, y) = e1\" and \"(u, v) = e2\" and \"(w, k) = e3\" by ...</p>\n<p>but we are wondering whether there is a simpler way. Essentially,<br>\nwe want to avoid having to fix the variables and to avoid to write <br>\nthe equations explicitly. We rather prefer the way how the cases-construction<br>\nworks, which automatically fixes variables and puts such equations<br>\ninto the context, for example</p>\n<p>lemma <br>\n    assumes \"P (n:: nat)\"<br>\n    shows \"thesis\"<br>\n  proof (cases n)</p>\n<p>In this example you have \"n = 0\" in the \"first\" case and fix nat/n = Suc nat <br>\nin the \"second\" case. Is there something similar for many nested lets?</p>\n<p>If not, how would we have to go about implementing (presumably in ML)<br>\nsuch a construction?</p>\n<p>Best wishes,<br>\nChristian</p>",
        "id": 294257692,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913174
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Christian,</p>\n<p>I don't completely understand why this is related to let. A let just introduces an <br>\nabbreviation. However, in your example, you are more concerned with patterns such as <br>\ntuples, but</p>\n<p>let (x, y) = e in f x y</p>\n<p>is syntactic sugar for</p>\n<p>Let e (prod_case (%x y. f x y))</p>\n<p>So, do you also want to introduce variables if there's no pattern-matching involved, such <br>\nthat \"P (let x = e in f x)\" gets transformed into \"!!x. x = e ==&gt; P (f x)\"?</p>\n<p>In principle, you can use Isabelle's splitter:</p>\n<p>lemma Let_prod_split_asm:<br>\n   \"P (Let e (prod_case f)) = (~ (EX x y. (x, y) = e &amp; ~ P (f x y)))\"<br>\nby(auto simp add: Let_def prod.split_asm)</p>\n<p>lemma Let_split_asm: \"P (Let e f) = (~ (EX x. x = e &amp; ~ P (f x)))\"<br>\nby(auto simp add: Let_def)</p>\n<p>lemma<br>\n   assumes \"P (let (x, y) = e1; (u, v) = e2; (w, k) = e3 in f x y u v w k)\"<br>\n   shows \"thesis\"<br>\nusing assms<br>\napply -<br>\nproof(split Let_prod_split_asm Let_split_asm)+<br>\n   case (goal1 x y u v w k)</p>\n<p>With some ML programming, it should be easy to make this more readable.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294257706,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913180
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nYou can implement a nice expansion of lets into equations with the simplifier as per Konrad Slimd's and my proof pearl paper in TPHOLs 2005</p>\n<p>Michael</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294257721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913188
    }
]