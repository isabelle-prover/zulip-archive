[
    {
        "content": "<p>From: \"Aaron W. Hsu\" &lt;<a href=\"mailto:arcfide@sacrideo.us\">arcfide@sacrideo.us</a>&gt;<br>\nDear Isabelle Users:</p>\n<p>I have been trying unsuccessfully for the past couple of days to get  <br>\nIsabelle to do my bidding when it comes to the following lemma and  <br>\ndefinition. I wonder if someone might be able to give me some hints on how  <br>\nto approach this. It seems like it ought to be a simple thing to prove,  <br>\nbut I think my Isabelle skills are still too weak.</p>\n<p>definition sv2vl :: \"nat ⇒ 'a list ⇒ 'a list\" where<br>\n   \"sv2vl n ls ≡<br>\n      if ls = []<br>\n      then (replicate n fill)<br>\n      else take n (concat (replicate (1 + n div length ls) ls))\"</p>\n<p>lemma sv2vl_mod [simp]:<br>\n   \"i &lt; n ∧ ls ≠ [] ⟹ sv2vl n ls ! i = ls ! (i mod length ls)\"<br>\nby ???</p>\n<p>I have been able to prove the following:</p>\n<p>lemma sv2vl_len [simp]:<br>\n   \"length (sv2vl n ls) = n\"</p>\n<p>but that required significantly more work than I would have thought it  <br>\nought to. If someone could provide some assistance on these, I would  <br>\nappreciate it.</p>",
        "id": 294225205,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899615
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Aaron,</p>\n<p>it would have helped a lot to describe what you want to achieve with sv2vl. I <br>\nguess that sv2vl denotes the prefix of length n of the list that always repeats <br>\nthe list ls, i.e., sv2vl 5 [1, 2] = [1, 2, 1, 2, 1].<br>\nIf this is the case, you can simplify your definition a bit, which makes proofs <br>\neasier:</p>\n<p>\"sv2vl n ls ==<br>\n      if ls = []<br>\n      then (replicate n fill)<br>\n      else take n (concat (replicate n ls))\"</p>\n<p>Both definitions are equivalent because \"take n\" cuts off any extra stuff that <br>\n\"replicate n\" produces. Note that HOL has no notion of computation, so <br>\nefficiency is not an issue here -- if you want to generate efficient code for <br>\nit, you can still prove your definition as a code equation later on.</p>\n<p>Your sv2vl_mod lemma requires the following lemma that is not yet present in <br>\nIsabelle's List library:</p>\n<p>lemma nth_concat_replicate:<br>\n   \"i &lt; n * length xs<br>\n   ==&gt; concat (replicate n xs) ! i = xs ! (i mod length xs)\"<br>\nby(induct n arbitrary: i)(auto simp add: nth_append mod_geq)</p>\n<p>Then, your lemma can be proven automatically:</p>\n<p>lemma sv2vl_mod [simp]:<br>\n   \"i &lt; n &amp; ls ~= [] ==&gt; sv2vl n ls ! i = ls ! (i mod length ls)\"<br>\nby(auto simp add: sv2vl_def neq_Nil_conv nth_concat_replicate)</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294225326,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899682
    }
]