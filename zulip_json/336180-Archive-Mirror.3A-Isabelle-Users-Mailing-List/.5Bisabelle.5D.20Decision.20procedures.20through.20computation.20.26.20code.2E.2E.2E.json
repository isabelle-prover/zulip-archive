[
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear code generation experts,</p>\n<p>When building a decision procedure though computation in Isabelle, one <br>\nway is to rely on the command Code_Runtime.dynamic_holds_conv, which <br>\ncompiles the goal into SML using code generation mechanism, and then <br>\nprove by evaluation. However, one drawback of this method is that the <br>\nsame computable functions are compiled each time the decision procedure <br>\nis called, as mentioned in the performance enhancement section in</p>\n<p><a href=\"http://home.in.tum.de/~hoelzl/documents/hoelzl09diplomathesis.pdf\">http://home.in.tum.de/~hoelzl/documents/hoelzl09diplomathesis.pdf</a></p>\n<p>which describes the decision procedure <br>\n\"HOL/Decision_Procs/Approximation.thy\". One way to counter the drawback <br>\nis to pre-compile these executable functions and call them directly when <br>\nthe decision procedure is invoked. \"approximate\" implements this idea by <br>\nbuilding an oracle inside the procedure.</p>\n<p>When checking the code generation documentation, I happened to find that <br>\nthe code_reflect command does the pre-compiling thing, so my question is <br>\nwhether it is possible to boost Code_Runtime.dynamic_holds_conv though <br>\ncode_reflect, or the oracle implementation in \"Approximation.thy\" is the <br>\nonly viable way to do the job.</p>\n<p>PS: there is an code_reflect declaration before the oracle in the <br>\ndecision procedure in \"HOL/Decision_Procs/Cooper.thy\", but it has been <br>\ncommented out.</p>\n<p>Moreover, when playing with examples from the code generation tutorial, <br>\nI found that the following code:</p>\n<p>code_reflect Rat<br>\n   datatypes rat = Frct<br>\n   functions Fract<br>\n     \"(plus :: rat ⇒ rat ⇒ rat)\" \"(minus :: rat ⇒ rat ⇒ rat)\"<br>\n     \"(times :: rat ⇒ rat ⇒ rat)\" \"(divide :: rat ⇒ rat ⇒ rat)\"<br>\n   file \"rat.ML\"</p>\n<p>did not produce an \"rat.ML\" file. I am not sure why.</p>\n<p>Any help is greatly appreciated.</p>\n<p>Thanks,<br>\nWenda</p>",
        "id": 294324558,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928103
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHi Wenda,</p>\n<p>I think Florian mentioned that \"Code_Runtime.static_holds_conv\" and<br>\n\"Code_Evaluation.static_value\" could be used as a replacement for the<br>\noracle in Approximation.</p>\n<p>A better support for reflection + code generation (without writing an<br>\noracle consisting of boilerplate code) is surely welcome!</p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294324607,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928121
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Florian and others,</p>\n<p>Many thanks for your previous replies. I have tried to build a minimum <br>\nexample with Code_Runtime.static_holds_conv and code_reflect:</p>\n<p>theory Scratch3<br>\n   imports<br>\n     Complex_Main<br>\n     \"~~/src/HOL/Library/Code_Target_Numeral\"<br>\nbegin</p>\n<p>definition square:: \"real ⇒ real\" where<br>\n   \"square x = x*x\"</p>\n<p>ML {*<br>\n   fun holds ctxt = Code_Runtime.static_holds_conv {ctxt= @{context},<br>\n         consts = [@{const_name HOL.Trueprop} ,@{const_name square},<br>\n                   @{const_name <br>\nReal.equal_real_inst.equal_real},@{const_name Rat.of_int}]} ctxt;</p>\n<p>*}</p>\n<p>method_setup solve_square_static = {*<br>\n       Scan.succeed ( fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION (holds <br>\nctxt)))<br>\n*}</p>\n<p>method_setup solve_square_dynamic = {*<br>\n      Scan.succeed<br>\n       (fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION <br>\n(Code_Runtime.dynamic_holds_conv ctxt)))<br>\n*}</p>\n<p>code_reflect Foo<br>\ndatatypes real=Ratreal and rat = Frct and int=int_of_integer<br>\nfunctions square<br>\n   (<em>file \"Foo.ML\"</em>)</p>\n<p>lemma \"square 3 = 9\"<br>\n(<em>instant</em>)<br>\napply (simp add:square_def)<br>\noops</p>\n<p>lemma \"square 3 = 9\"<br>\n(<em>around 0.5 elapsed time/cpu time</em>)<br>\napply solve_square_dynamic<br>\noops</p>\n<p>lemma \"square 3 = 9\"<br>\n(<em>around 1.1 elapsed time/cpu time</em>)<br>\napply solve_square_static<br>\noops</p>\n<p>end</p>\n<p>I don't know why solve_square_static is still slower than <br>\nsolve_square_dynamic.</p>\n<p>Moreover, when building decision procedures based on code generation, is <br>\nthere any other tricks like importing Code_Target_Numeral to improve <br>\nefficiency?</p>\n<p>Many thanks,<br>\nWenda</p>",
        "id": 294325012,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928280
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Florian,</p>\n<p>Many thanks for your previous reply. Your solution works perfectly. I <br>\ncan now observe the big difference between dynamic holds and static <br>\nholds as well as the effect of code_reflect on dynamic holds. However, I <br>\nfail to see the effect of code_reflect on static holds. Here is a <br>\nminimal example:</p>\n<p>theory Scratch3<br>\n   imports<br>\n     Complex_Main<br>\n     \"~~/src/HOL/Library/Code_Target_Numeral\"<br>\n     \"~~/src/HOL/Library/Poly_Deriv\"<br>\nbegin</p>\n<p>consts smods:: \"real poly ⇒ real poly ⇒ (real poly) list\"<br>\nlemma [code]: \"smods p q= (if p=0 then [] else Cons p (smods q (-(p mod <br>\nq))))\" sorry</p>\n<p>fun changes:: \"real list ⇒ int\" where<br>\n   \"changes [] = 0\"|<br>\n   \"changes [_] = 0\" |<br>\n   \"changes (x1#x2#xs) = (if x1*x2&lt;0 then 1+changes (x2#xs)<br>\n                           else if x2=0 then changes (x1#xs)<br>\n                           else changes (x2#xs))\"</p>\n<p>definition changes_poly_at::\"real poly list ⇒ real ⇒ int\" where<br>\n   \"changes_poly_at ps a= changes (map (λp. poly p a) ps)\"</p>\n<p>definition changes_itv_smods:: \"real ⇒ real ⇒real poly ⇒ real poly ⇒  <br>\nint\" where<br>\n   \"changes_itv_smods a b p q= (let ps= smods p q in changes_poly_at ps a </p>\n<ul>\n<li>changes_poly_at ps b)\"</li>\n</ul>\n<p>lift_definition real_poly:: \"rat poly ⇒ real poly\" is<br>\n  \"λp. real_of_rat o p \" sorry</p>\n<p>lemma [code abstract]: \"coeffs (real_poly p)=  (map of_rat (coeffs p))\" <br>\nsorry</p>\n<p>definition isolate::\"real poly ⇒ real ⇒ real ⇒ bool\" where<br>\n   \"isolate p lb ub= (if poly p lb=0 ∨ poly p ub =0 ∨ lb≥ub<br>\n     then False else changes_itv_smods lb ub p (pderiv p) =1)\"</p>\n<p>definition valid_alg::\"rat poly ⇒ rat ⇒ rat ⇒ bool\" where<br>\n   \"valid_alg p lb ub = (lb&lt;ub ∧ poly p lb * poly p ub &lt;0 ∧ isolate <br>\n(real_poly p) (of_rat lb) (of_rat ub))\"</p>\n<p>consts Alg::\"rat poly ⇒ rat ⇒ rat ⇒ real\"</p>\n<p>code_datatype Alg Ratreal</p>\n<p>consts sgn_at :: \"real poly ⇒ real ⇒ real\"</p>\n<p>lemma sgn_at_code_alg[code]: \"sgn_at q (Alg p lb ub) = (<br>\n     if valid_alg p lb ub then<br>\n       of_int (changes_itv_smods (of_rat lb) (of_rat ub) (real_poly p) <br>\n(pderiv (real_poly p) * q))<br>\n     else sgn (poly q undefined))\"<br>\nsorry</p>\n<p>definition pCons::\"rat ⇒ rat poly ⇒ rat poly\" where<br>\n   \"pCons=Polynomial.pCons\"</p>\n<p>ML {*<br>\n   val holds = Code_Runtime.static_holds_conv {ctxt= @{context},<br>\n         consts = [@{const_name HOL.Trueprop},@{const_name <br>\nReal.equal_real_inst.equal_real}<br>\n          ,@{const_name Rat.of_int},<br>\n          @{const_name sgn_at},<br>\n          @{const_name pCons},@{const_name Rat.one_rat_inst.one_rat}<br>\n                   ,@{const_name Polynomial.zero_poly_inst.zero_poly}<br>\n]} ;<br>\n*}</p>\n<p>method_setup eval_sgn_at_static = {*<br>\n       Scan.succeed ( fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION (holds <br>\nctxt)))<br>\n*}</p>\n<p>method_setup eval_sgn_at_dynamic = {*<br>\n      Scan.succeed<br>\n       (fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION <br>\n(Code_Runtime.dynamic_holds_conv ctxt)))<br>\n*}</p>\n<p>code_reflect Foo<br>\ndatatypes real=\"_\" and rat = \"_\"  and int=\"_\" and poly=\"_\"<br>\nfunctions sgn_at</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>1-1.6s with code_reflect; 2-2.5s without code_reflect</em>)<br>\n   apply eval_sgn_at_dynamic<br>\noops</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>approx. 0.5s with or without code_reflect</em>)<br>\n   apply eval_sgn_at_static<br>\noops</p>\n<p>end</p>\n<p>Apologies for the lengthy example and thanks again for any help,<br>\nWenda</p>",
        "id": 294326127,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928587
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Florian,</p>\n<p>Thanks again for your patience and wonderful suggestions.</p>\n<p>By dropping the code equation for sgn_at after \"code_reflect\" it, <br>\ndynamic hold runs much faster than before as what has happened in René's <br>\ncase. However, static hold runs at the same speed as before, which is <br>\nmuch slower than dynamic hold. I can roughly understand the explanation <br>\nrelated to reprocessing, but this (i.e. static hold runs slower than <br>\ndynamic hold) is quite unexpected.</p>\n<p>The current code is as follows:</p>\n<p>theory Scratch3<br>\n   imports<br>\n     Complex_Main<br>\n     \"~~/src/HOL/Library/Code_Target_Numeral\"<br>\n     \"~~/src/HOL/Library/Poly_Deriv\"<br>\nbegin</p>\n<p>consts smods:: \"real poly ⇒ real poly ⇒ (real poly) list\"<br>\nlemma [code]: \"smods p q= (if p=0 then [] else Cons p (smods q (-(p mod <br>\nq))))\" sorry</p>\n<p>fun changes:: \"real list ⇒ int\" where<br>\n   \"changes [] = 0\"|<br>\n   \"changes [_] = 0\" |<br>\n   \"changes (x1#x2#xs) = (if x1*x2&lt;0 then 1+changes (x2#xs)<br>\n                           else if x2=0 then changes (x1#xs)<br>\n                           else changes (x2#xs))\"</p>\n<p>definition changes_poly_at::\"real poly list ⇒ real ⇒ int\" where<br>\n   \"changes_poly_at ps a= changes (map (λp. poly p a) ps)\"</p>\n<p>definition changes_itv_smods:: \"real ⇒ real ⇒real poly ⇒ real poly ⇒  <br>\nint\" where<br>\n   \"changes_itv_smods a b p q= (let ps= smods p q in changes_poly_at ps a </p>\n<ul>\n<li>changes_poly_at ps b)\"</li>\n</ul>\n<p>lift_definition real_poly:: \"rat poly ⇒ real poly\" is<br>\n  \"λp. real_of_rat o p \" sorry</p>\n<p>lemma [code abstract]: \"coeffs (real_poly p)=  (map of_rat (coeffs p))\" <br>\nsorry</p>\n<p>definition isolate::\"real poly ⇒ real ⇒ real ⇒ bool\" where<br>\n   \"isolate p lb ub= (if poly p lb=0 ∨ poly p ub =0 ∨ lb≥ub<br>\n     then False else changes_itv_smods lb ub p (pderiv p) =1)\"</p>\n<p>definition valid_alg::\"rat poly ⇒ rat ⇒ rat ⇒ bool\" where<br>\n   \"valid_alg p lb ub = (lb&lt;ub ∧ poly p lb * poly p ub &lt;0 ∧ isolate <br>\n(real_poly p) (of_rat lb) (of_rat ub))\"</p>\n<p>consts Alg::\"rat poly ⇒ rat ⇒ rat ⇒ real\"</p>\n<p>code_datatype Alg Ratreal</p>\n<p>consts sgn_at :: \"real poly ⇒ real ⇒ real\"</p>\n<p>lemma sgn_at_code_alg[code]: \"sgn_at q (Alg p lb ub) = (<br>\n     if valid_alg p lb ub then<br>\n       of_int (changes_itv_smods (of_rat lb) (of_rat ub) (real_poly p) <br>\n(pderiv (real_poly p) * q))<br>\n     else sgn (poly q undefined))\"<br>\nsorry</p>\n<p>definition pCons::\"rat ⇒ rat poly ⇒ rat poly\" where<br>\n   \"pCons=Polynomial.pCons\"</p>\n<p>ML {*<br>\n   val holds = Code_Runtime.static_holds_conv {ctxt= @{context},<br>\n         consts = [@{const_name HOL.Trueprop},@{const_name <br>\nReal.equal_real_inst.equal_real}<br>\n          ,@{const_name Rat.of_int},<br>\n          @{const_name sgn_at},<br>\n          @{const_name pCons},@{const_name Rat.one_rat_inst.one_rat}<br>\n                   ,@{const_name Polynomial.zero_poly_inst.zero_poly}<br>\n]} ;<br>\n*}</p>\n<p>method_setup eval_sgn_at_static = {*<br>\n       Scan.succeed ( fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION (holds <br>\nctxt)))<br>\n*}</p>\n<p>method_setup eval_sgn_at_dynamic = {*<br>\n      Scan.succeed<br>\n       (fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION <br>\n(Code_Runtime.dynamic_holds_conv ctxt)))<br>\n*}</p>\n<p>code_reflect Foo<br>\ndatatypes real=\"_\" and rat = \"_\"  and int=\"_\" and poly=\"_\"<br>\nfunctions sgn_at</p>\n<p>declare [[code drop: sgn_at]]</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>almost instant</em>)<br>\n   apply eval_sgn_at_dynamic<br>\noops</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>0.5s-1s</em>)<br>\n   apply eval_sgn_at_static<br>\noops</p>\n<p>end</p>\n<p>Thanks,<br>\nWenda</p>",
        "id": 294327193,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928968
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Florian,</p>\n<blockquote>\n<p>the order must be:</p>\n<blockquote>\n<p>code_reflect Foo<br>\ndatatypes real=\"_\" and rat = \"_\"  and int=\"_\" and poly=\"_\"<br>\nfunctions sgn_at</p>\n</blockquote>\n<blockquote>\n<p>declare [[code drop: sgn_at]]</p>\n</blockquote>\n<blockquote>\n<p>method_setup eval_sgn_at_static = {*<br>\n      Scan.succeed ( fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION (holds <br>\nctxt)))<br>\n*}</p>\n</blockquote>\n</blockquote>\n<p>Unfortunately, this does not improve the performance of static hold.</p>\n<p>Moreover, if I put</p>\n<blockquote>\n<p>ML {*<br>\n val holds = Code_Runtime.static_holds_conv {ctxt= @{context},<br>\n       consts = [@{const_name HOL.Trueprop},@{const_name <br>\nReal.equal_real_inst.equal_real}<br>\n        ,@{const_name Rat.of_int},<br>\n        @{const_name sgn_at},<br>\n        @{const_name pCons},@{const_name Rat.one_rat_inst.one_rat}<br>\n                 ,@{const_name Polynomial.zero_poly_inst.zero_poly}<br>\n]} ;<br>\n*}</p>\n</blockquote>\n<p>After</p>\n<blockquote>\n<p>code_reflect Foo<br>\ndatatypes real=\"_\" and rat = \"_\"  and int=\"_\" and poly=\"_\"<br>\nfunctions sgn_at</p>\n</blockquote>\n<p>Errors like</p>\n<p>Wellsortedness error:<br>\nType real not of sort {zero,equal}<br>\nNo type arity real :: zero</p>\n<p>are quite annoying. I notice this kind of Wellsortedness is quite common <br>\nwhen using static hold, is this because we cannot use const with <br>\npolymorphic type in static hold?</p>\n<p>Wenda</p>\n<p>PS: current code is as</p>\n<p>theory Scratch3<br>\n   imports<br>\n     Complex_Main<br>\n     \"~~/src/HOL/Library/Code_Target_Numeral\"<br>\n     \"~~/src/HOL/Library/Poly_Deriv\"<br>\nbegin</p>\n<p>consts smods:: \"real poly ⇒ real poly ⇒ (real poly) list\"<br>\nlemma [code]: \"smods p q= (if p=0 then [] else Cons p (smods q (-(p mod <br>\nq))))\" sorry</p>\n<p>fun changes:: \"real list ⇒ int\" where<br>\n   \"changes [] = 0\"|<br>\n   \"changes [_] = 0\" |<br>\n   \"changes (x1#x2#xs) = (if x1*x2&lt;0 then 1+changes (x2#xs)<br>\n                           else if x2=0 then changes (x1#xs)<br>\n                           else changes (x2#xs))\"</p>\n<p>definition changes_poly_at::\"real poly list ⇒ real ⇒ int\" where<br>\n   \"changes_poly_at ps a= changes (map (λp. poly p a) ps)\"</p>\n<p>definition changes_itv_smods:: \"real ⇒ real ⇒real poly ⇒ real poly ⇒  <br>\nint\" where<br>\n   \"changes_itv_smods a b p q= (let ps= smods p q in changes_poly_at ps a </p>\n<ul>\n<li>changes_poly_at ps b)\"</li>\n</ul>\n<p>lift_definition real_poly:: \"rat poly ⇒ real poly\" is<br>\n  \"λp. real_of_rat o p \" sorry</p>\n<p>lemma [code abstract]: \"coeffs (real_poly p)=  (map of_rat (coeffs p))\" <br>\nsorry</p>\n<p>definition isolate::\"real poly ⇒ real ⇒ real ⇒ bool\" where<br>\n   \"isolate p lb ub= (if poly p lb=0 ∨ poly p ub =0 ∨ lb≥ub<br>\n     then False else changes_itv_smods lb ub p (pderiv p) =1)\"</p>\n<p>definition valid_alg::\"rat poly ⇒ rat ⇒ rat ⇒ bool\" where<br>\n   \"valid_alg p lb ub = (lb&lt;ub ∧ poly p lb * poly p ub &lt;0 ∧ isolate <br>\n(real_poly p) (of_rat lb) (of_rat ub))\"</p>\n<p>consts Alg::\"rat poly ⇒ rat ⇒ rat ⇒ real\"</p>\n<p>code_datatype Alg Ratreal</p>\n<p>consts sgn_at :: \"real poly ⇒ real ⇒ real\"</p>\n<p>lemma sgn_at_code_alg[code]: \"sgn_at q (Alg p lb ub) = (<br>\n     if valid_alg p lb ub then<br>\n       of_int (changes_itv_smods (of_rat lb) (of_rat ub) (real_poly p) <br>\n(pderiv (real_poly p) * q))<br>\n     else sgn (poly q undefined))\"<br>\nsorry</p>\n<p>method_setup eval_sgn_at_dynamic = {*<br>\n      Scan.succeed<br>\n       (fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION <br>\n(Code_Runtime.dynamic_holds_conv ctxt)))<br>\n*}</p>\n<p>definition pCons::\"rat ⇒ rat poly ⇒ rat poly\" where<br>\n   \"pCons=Polynomial.pCons\"</p>\n<p>ML {*<br>\n   val holds = Code_Runtime.static_holds_conv {ctxt= @{context},<br>\n         consts = [@{const_name HOL.Trueprop},@{const_name <br>\nReal.equal_real_inst.equal_real}<br>\n          ,@{const_name Rat.of_int},<br>\n          @{const_name sgn_at},<br>\n          @{const_name pCons},@{const_name Rat.one_rat_inst.one_rat}<br>\n]} ;<br>\n*}</p>\n<p>code_reflect Foo<br>\ndatatypes real=\"_\" and rat = \"_\"  and int=\"_\" and poly=\"_\"<br>\nfunctions sgn_at</p>\n<p>declare [[code drop: sgn_at]]</p>\n<p>method_setup eval_sgn_at_static = {*<br>\n       Scan.succeed ( fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION (holds <br>\nctxt)))<br>\n*}</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>almost instant</em>)<br>\n   apply eval_sgn_at_dynamic<br>\noops</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>0.5s-1s</em>)<br>\n   apply eval_sgn_at_static<br>\noops</p>\n<p>end</p>",
        "id": 294327224,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928980
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Florian,</p>\n<p>The following code leads to the wellsortedness error, and I really don't <br>\nknow which const causes it.</p>\n<p>theory Scratch3<br>\n   imports<br>\n     Complex_Main<br>\n     \"~~/src/HOL/Library/Code_Target_Numeral\"<br>\n     \"~~/src/HOL/Library/Poly_Deriv\"<br>\nbegin</p>\n<p>consts smods:: \"real poly ⇒ real poly ⇒ (real poly) list\"<br>\nlemma [code]: \"smods p q= (if p=0 then [] else Cons p (smods q (-(p mod <br>\nq))))\" sorry</p>\n<p>fun changes:: \"real list ⇒ int\" where<br>\n   \"changes [] = 0\"|<br>\n   \"changes [_] = 0\" |<br>\n   \"changes (x1#x2#xs) = (if x1*x2&lt;0 then 1+changes (x2#xs)<br>\n                           else if x2=0 then changes (x1#xs)<br>\n                           else changes (x2#xs))\"</p>\n<p>definition changes_poly_at::\"real poly list ⇒ real ⇒ int\" where<br>\n   \"changes_poly_at ps a= changes (map (λp. poly p a) ps)\"</p>\n<p>definition changes_itv_smods:: \"real ⇒ real ⇒real poly ⇒ real poly ⇒  <br>\nint\" where<br>\n   \"changes_itv_smods a b p q= (let ps= smods p q in changes_poly_at ps a </p>\n<ul>\n<li>changes_poly_at ps b)\"</li>\n</ul>\n<p>lift_definition real_poly:: \"rat poly ⇒ real poly\" is<br>\n  \"λp. real_of_rat o p \" sorry</p>\n<p>lemma [code abstract]: \"coeffs (real_poly p)=  (map of_rat (coeffs p))\" <br>\nsorry</p>\n<p>definition isolate::\"real poly ⇒ real ⇒ real ⇒ bool\" where<br>\n   \"isolate p lb ub= (if poly p lb=0 ∨ poly p ub =0 ∨ lb≥ub<br>\n     then False else changes_itv_smods lb ub p (pderiv p) =1)\"</p>\n<p>definition valid_alg::\"rat poly ⇒ rat ⇒ rat ⇒ bool\" where<br>\n   \"valid_alg p lb ub = (lb&lt;ub ∧ poly p lb * poly p ub &lt;0 ∧ isolate <br>\n(real_poly p) (of_rat lb) (of_rat ub))\"</p>\n<p>consts Alg::\"rat poly ⇒ rat ⇒ rat ⇒ real\"</p>\n<p>code_datatype Alg Ratreal</p>\n<p>consts sgn_at :: \"real poly ⇒ real ⇒ real\"</p>\n<p>lemma sgn_at_code_alg[code]: \"sgn_at q (Alg p lb ub) = (<br>\n     if valid_alg p lb ub then<br>\n       of_int (changes_itv_smods (of_rat lb) (of_rat ub) (real_poly p) <br>\n(pderiv (real_poly p) * q))<br>\n     else sgn (poly q undefined))\"<br>\nsorry</p>\n<p>method_setup eval_sgn_at_dynamic = {*<br>\n      Scan.succeed<br>\n       (fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION <br>\n(Code_Runtime.dynamic_holds_conv ctxt)))<br>\n*}</p>\n<p>code_reflect Foo<br>\ndatatypes real=\"_\" and rat = \"_\"  and int=\"_\" and poly=\"_\"<br>\nfunctions sgn_at</p>\n<p>declare [[code drop: sgn_at]]</p>\n<p>definition pCons::\"rat ⇒ rat poly ⇒ rat poly\" where<br>\n   \"pCons=Polynomial.pCons\"</p>\n<p>ML {*<br>\n   val holds = Code_Runtime.static_holds_conv {ctxt= @{context},<br>\n         consts = [@{const_name HOL.Trueprop},@{const_name <br>\nReal.equal_real_inst.equal_real}<br>\n          , @{const_name sgn_at}, @{const_name pCons}<br>\n]} ;<br>\n*}</p>\n<p>method_setup eval_sgn_at_static = {*<br>\n       Scan.succeed ( fn ctxt =&gt; SIMPLE_METHOD' (CONVERSION (holds <br>\nctxt)))<br>\n*}</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>almost instant</em>)<br>\n   apply eval_sgn_at_dynamic<br>\noops</p>\n<p>lemma \"sgn_at [:- 2, 0, 1:] (Alg [:- 2, 0, 1:] 0 2) = 0\"<br>\n   (<em>Wellsortedness error</em>)<br>\n   apply eval_sgn_at_static<br>\noops</p>\n<p>end</p>\n<p>Many thanks,<br>\nWenda</p>",
        "id": 294327263,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928998
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nHi Florian,</p>\n<p>Many thanks for your help. With code_reflect and static hold, my tactics <br>\nwork like magic. I think it would be ideal to include such things in the <br>\ncode generation tutorial.</p>\n<p>Best,<br>\nWenda</p>",
        "id": 294327374,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929035
    }
]