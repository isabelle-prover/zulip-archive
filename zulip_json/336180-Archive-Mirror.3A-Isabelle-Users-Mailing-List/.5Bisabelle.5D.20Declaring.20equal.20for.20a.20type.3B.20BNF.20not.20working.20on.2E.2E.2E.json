[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I think I understand that BNF is a work in progress, but I report some <br>\nerrors I get when trying to use it. I'll do that second, since the first <br>\npart sets the context. The good news is that it works well enough to use it.</p>\n<p>For the first part, I have a datatype, \"'a mT\", and an equality function <br>\nfor that type, mTeq. I want to declare mTeq as equality for \"'a mT\", but <br>\nI don't understand all the complexities of overloading in Isabelle.</p>\n<p>I want to make the simple statement, \"foo x y ==&gt; (x::'a mT) = y\", but I <br>\ncan't. I would have to introduce new notation for \"=\", and then use that.</p>\n<p>For anyone who has time, I give a brief summary of my application, I <br>\ninclude the source at the bottom, and I attach the file.</p>\n<p>I have a main datatype:</p>\n<p>datatype 'a mT =<br>\n   mTp \"'a * int\"<br>\n  |mTL \"'a mT list\"</p>\n<p>And then a secondary datatype:</p>\n<p>datatype_new 'a mS =<br>\n   mSp \"'a * int\"<br>\n  |mSS \"'a mS fset\"</p>\n<p>The type \"'a mT\" is list of ordered pairs, and nested lists of ordered <br>\npairs. For a pair \"mTp (x,y)\", y is the multiplicity, where the <br>\nmultiplicities of pairs with the same first component name, at the save <br>\nlevel of nesting, can be added together. The type int allows for <br>\nnegative quantities, where int could be replaced with a type class, such <br>\nas linordered_ab_group_add.</p>\n<p>For an equality function, I first define a function mTcomb, which <br>\ncombines any pairs with the same name, at the same level of nesting, <br>\ninto one pair, by adding their multiplicities.</p>\n<p>I then define a function mTset. This converts lists to fsets, the lists <br>\nand fsets used in the constructors <code>mTL \"'a mT list\"</code> and <code>mSS \"'a mS \nfset\"</code>.</p>\n<p>My equality function is then mTeq, with 3 simple cases, and the fourth <br>\ncase using mTcomb and mTset:</p>\n<p>\"mTeq (mTL x) (mTL y) = (mTset (mTL(mTcomb [] (mTL x))) = mTset <br>\n(mTL(mTcomb [] (mTL y))))\"</p>\n<p>That takes you to the bottom of my file, where I try to instantiate type <br>\nmT as type class equal. It doesn't work, which makes me wonder why I <br>\nthink I need to do that.</p>\n<p>---CONCERNING BNF ERRORS</p>\n<p>As to BNF, again I have this datatype:</p>\n<p>datatype_new 'a mS =<br>\n   mSp \"'a * int\"<br>\n  |mSS \"'a mS fset\"</p>\n<p>What I think I've found is that I can use it on the right side of <br>\nrecursive functions, but I can't use it on the left side.</p>\n<p>I try using datatype_new_compat, and also primrec instead of fun. I <br>\ntried to define a function to use \"'a mS fset option\", but it doesn't <br>\nwork, where a function like that for mT does work.</p>\n<p>Thanks,<br>\nGB</p>\n<p>theory i131031a__v5a__generalized_datatype_to_model_a_nested_set<br>\nimports Complex_Main BNF (<em>\"../../../iHelp/i\"</em>)<br>\nbegin</p>\n<p>(<em>__1__) MULTILIST: datatype and utility functions.</em>)</p>\n<p>datatype 'a mT =<br>\n   mTp \"'a * int\"<br>\n  |mTL \"'a mT list\"</p>\n<p>fun mTp_1st :: \"'a mT =&gt; 'a option\" where<br>\n   \"mTp_1st (mTp(x,y)) = Some x\"<br>\n  |\"mTp_1st (mTL x) = None\"</p>\n<p>fun mTp_2nd :: \"'a mT =&gt; int option\" where<br>\n   \"mTp_2nd (mTp(x,y)) = Some y\"<br>\n  |\"mTp_2nd (mTL x) = None\"</p>\n<p>fun mTLsome :: \"'a mT =&gt; 'a mT list option\" where<br>\n   \"mTLsome (mTp x) = None\"<br>\n  |\"mTLsome (mTL x) = Some x\"</p>\n<p>(<em>__2__) MSET: datatype and utility functions.</em>)</p>\n<p>datatype_new 'a mS =<br>\n   mSp \"'a * int\"<br>\n  |mSS \"'a mS fset\"</p>\n<p>datatype_new_compat \"mS\"</p>\n<p>primrec mSSsome :: \"'a mS =&gt; 'a mS fset option\" where<br>\n   \"mSSsome (mSp x) = None\"<br>\n  |\"mSSsome (mSS x) = Some x\"</p>\n<p>fun mSSsome2 :: \"'a mS =&gt; 'a mS fset option\" where<br>\n   \"mSSsome2 (mSp x) = None\"<br>\n  |\"mSSsome2 (mSS x) = Some x\"</p>\n<p>(*__3__) COMBINE BY ADDING MULTIPLICITIES: Start with L = [].<br>\n   CASE mTp(x,y): If there exists mTp(x,z) in List.set L, then remove <br>\nmTp(x,z)<br>\n     from L and return mTp(x,y+z)#L. If there exists no mTp(x,z), then <br>\nreturn<br>\n     mTp(x,y)#L.<br>\n   CASE mTL(x#xs): If x is just a pair, then \"mTcomb (mTcomb L (mTL xs)) <br>\nx\". The<br>\n     \"mTcomb L (mTL xs)\" will recursively work on the list which x will <br>\nbe given.<br>\n   CASE mTL(x#xs): If x is a mTL, then mTL(mTcomb [] x)) # (mTcomb L <br>\n(mTL xs)).<br>\n     The \"mTL(mTcomb [] x))\" will work on adding, to a new empty list, the<br>\n     multiplicities in the list of \"mTL x\"*)</p>\n<p>fun mTcomb :: \"'a mT list =&gt; 'a mT =&gt; 'a mT list\" where<br>\n   \"mTcomb L (mTp(x,y)) = (<br>\n      if List.find (%z. mTp_1st z = Some x) L<br>\n        = Some(mTp(x,the(mTp_2nd(the(List.find(%z. mTp_1st z = Some x) <br>\nL)))))<br>\n      then mTp(x,y + the(mTp_2nd(the(List.find(%z. mTp_1st z = Some x) L))))<br>\n        # (remove1(the(List.find(%z. mTp_1st z = Some x) L)) L)<br>\n      else (mTp(x,y))#L)\"<br>\n  |\"mTcomb L (mTL [])    = L\"<br>\n  |\"mTcomb L (mTL(x#xs)) = (if mTLsome x = None<br>\n                          then (mTcomb (mTcomb L (mTL xs)) x)<br>\n                          else (mTL(mTcomb [] x)) # (mTcomb L (mTL xs)))\"</p>\n<p>value \"mTcomb [] (mTL[mTp(x,1),mTL[mTp(x,y)],mTp(x,2)])\"<br>\nvalue \"mTcomb [] <br>\n(mTL[mTp(x,9),mTL[mTp(x,1),mTL[mTp(x,2),mTp(y,2)]],mTp(x,3),mTp(x,4),mTL[mTp(x,5)]])\"<br>\nvalue \"mTcomb [] <br>\n(mTL[mTp(1::int,9),mTL[mTp(1,1),mTL[mTp(1,2),mTp(y,2)]],mTp(1,3),mTp(1,4),mTL[mTp(1,5)]])\"</p>\n<p>(*__4__) FSET: Equality of a set is easy to state because it doesn't <br>\nhave to be<br>\n   ordered.*)</p>\n<p>fun mTset :: \"'a mT =&gt; 'a mS fset\" where<br>\n   \"mTset (mTp x)     = {|mSp x|}\"<br>\n  |\"mTset (mTL [])    = fempty\"<br>\n  |\"mTset (mTL(x#xs)) = (if mTLsome x = None<br>\n                        then funion (mTset x) (mTset (mTL xs))<br>\n                        else finsert (mSS(mTset x)) (mTset (mTL xs)))\"</p>\n<p>theorem \"mTset (mTL[mTp(x,1),mTL[mTp(x,y)],mTp(x,2)]) = z\"<br>\n   apply simp oops<br>\ntheorem \"mTset <br>\n(mTL[mTp(x,9),mTL[mTp(x,1),mTL[mTp(x,2),mTp(y,2)]],mTp(x,3),mTp(x,4),mTL[mTp(x,5)]]) <br>\n= z\"<br>\n   apply simp oops<br>\ntheorem \"mTset <br>\n(mTL[mTp(1::int,9),mTL[mTp(1,1),mTL[mTp(1,2),mTp(y,2)]],mTp(1,3),mTp(1,4),mTL[mTp(1,5)]]) <br>\n= z\"<br>\n   apply simp oops</p>\n<p>(<em>__5__) EQUALITY: The 4th case is what takes all the work.</em>)</p>\n<p>fun mTeq :: \"'a mT =&gt; 'a mT =&gt; bool\" where<br>\n   \"mTeq (mTp x) (mTp y) = (x = y)\"<br>\n  |\"mTeq (mTp x) (mTL y) = ([mTp x] = y)\"<br>\n  |\"mTeq (mTL x) (mTp y) = (x = [mTp y])\"<br>\n  |\"mTeq (mTL x) (mTL y) = (mTset (mTL(mTcomb [] (mTL x))) =<br>\n                            mTset (mTL(mTcomb [] (mTL y))))\"</p>\n<p>theorem \"mTset <br>\n(mTL[mTp(x,9),mTL[mTp(x,1),mTL[mTp(x,2),mTp(y,2)]],mTp(x,3),mTp(x,4),mTL[mTp(x,5)]]) <br>\n= z\"<br>\n   apply simp</p>\n<p>(*{|mSS{|mSS{|mSp(y,2),mSp(x,2)|},mSp(x,1)|},mSS{|mSp(x,5)|},mSp(x,4),mSp(x,3),mSp(x,9)|} <br>\n= z*)<br>\n   oops<br>\ntheorem \"mTset <br>\n(mTL[mTp(x,3),mTp(x,9),mTp(x,4),mTL[mTp(x,5)],mTL[mTp(x,1),mTL[mTp(x,2),mTp(y,2)]]]) <br>\n= z\"<br>\n   apply simp</p>\n<p>(*{|mSS{|mSp(x,5)|},mSS{|mSS{|mSp(y,2),mSp(x,2)|},mSp(x,1)|},mSp(x,4),mSp(x,9),mSp(x,3)|} <br>\n= z*)<br>\n   oops</p>\n<p>theorem \"mTeq</p>\n<p>(mTL[mTp(x,9),mTL[mTp(x,1),mTL[mTp(x,2),mTp(y,2)]],mTp(x,3),mTp(x,4),mTL[mTp(x,5)]])</p>\n<p>(mTL[mTp(x,3),mTp(x,9),mTp(x,4),mTL[mTp(x,5)],mTL[mTp(x,1),mTL[mTp(x,2),mTp(y,2)]]])\"<br>\nby(auto)</p>\n<p>(*Trying to define equal for type \"'a mT\". I don't know if I even need to to<br>\n   this.*)</p>\n<p>instantiation mT ::  equal<br>\nbegin<br>\ndefinition<br>\n   \"HOL.equal x y = (mTeq x y)\"<br>\ninstance<br>\nproof<br>\nqed<br>\nend</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\nend<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n<a href=\"/user_uploads/14278/b5YYy9_UoJOICsM-qJDOVYNc/i131031a__v5a__generalized_datatype_to_model_a_nested_set.thy\">i131031a__v5a__generalized_datatype_to_model_a_nested_set.thy</a></p>",
        "id": 294257172,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912981
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gottfried,</p>\n<p>You cannot define equality in Isabelle/HOL for any type as you wish, as the HOL axioms <br>\nalready define it for all types. The datatype package (and the BNF package) introduce an <br>\nalgebraic type whose constructors are free, i.e., injective and their ranges pairwise <br>\ndistinct. If you want to have a coarser notion of equality, you can define your own <br>\nfunction such as mTeq with fancy notation such as (infix \"===\"), but you cannot use HOL <br>\nequality = for it, and the proof tools (esp. the simplifier) will not treat it as equality <br>\neither.</p>\n<p>If you really want a type with your custom equality relation, you have to quotient your <br>\ndatatype through your custom equality relation [1] or directly construct a type with <br>\nnon-free type constructors [2]. You find more information on that in the references, but I <br>\nhave not examined your use case to see which route seems easier or feasible.</p>\n<p>Andreas</p>\n<p>[1] <a href=\"http://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf\">http://www21.in.tum.de/~kuncar/documents/huffman-kuncar-cpp2013.pdf</a></p>\n<p>[2] <br>\n<a href=\"https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2013-August/004413.html\">https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2013-August/004413.html</a></p>",
        "id": 294257521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913115
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nThe BNF crew can officially consider that this error report has been <br>\nresolved to my satisfaction, primarily because I should have been using <br>\nprimrec_new instead of primrec, though up to this point, I've stayed <br>\naway from using primrec, because the magic of fun can kick in where the <br>\nmagic of primrec ends. Consequently, there being no fun_new caused me to <br>\nforget about primrec_new, until things led me back to datatype.pdf</p>\n<p>Here, Andrea's answer to my question about equality led me to a <br>\nreference he gave me, which led me back to datatype.pdf.</p>\n<p>I don't care that I can't make fun work with datatype_new, as long as <br>\nprimrec_new is working for me.</p>\n<p>However, if one of the BNF crew cares, below is what I get, which could <br>\nbe due to me doing things wrong, or not knowing how to register <br>\nsomething to make it work. I give an example of \"value\" returning an <br>\nerror, where I know that \"value\" and the code generator can be a whole <br>\ndifferent matter.</p>\n<p>Regards,<br>\nGB</p>\n<p>datatype_new 'a mS =<br>\nmSp \"'a * int\"<br>\n|mSS \"'a mS fset\"</p>\n<p>primrec_new mSSsome :: \"'a mS =&gt; 'a mS fset option\" where<br>\n\"mSSsome (mSp x) = None\"<br>\n|\"mSSsome (mSS x) = Some x\"</p>\n<p>theorem \"mSSsome (mSS{|mSp x|}) = Some {|mSp x|}\"<br>\nby(simp)</p>\n<p>theorem \"mSSsome (mSp x) = None\"<br>\nby(simp)</p>\n<p>value \"mSSsome (mSp x)\"<br>\n(*ERROR:<br>\n\"c.mS.mSp\" is not a constructor, on left hand side of equation, in theorem:<br>\nmSSsome (mSp ?x) ≡ None*)</p>\n<p>datatype_new_compat \"mS\"<br>\n(*ERROR:<br>\nUnsupported recursion via type constructor \"FSet.fset\" not associated with<br>\nnew-style datatype (cf. \"datatype_new\")*)</p>\n<p>fun mSSsome2 :: \"'a mS =&gt; 'a mS fset option\" where<br>\n\"mSSsome2 (mSp x) = None\"<br>\n|\"mSSsome2 (mSS x) = Some x\"<br>\n(*Malformed definition:<br>\nNon-constructor pattern not allowed in sequential mode.<br>\n⋀x. mSSsome2 (mSp x) = None*)</p>",
        "id": 294257907,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913274
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nAm 07.11.2013 16:29, schrieb Gottfried Barrow:</p>\n<blockquote>\n<p>However, if one of the BNF crew cares, below is what I get, which <br>\ncould be due to me doing things wrong, or not knowing how to register <br>\nsomething to make it work. I give an example of \"value\" returning an <br>\nerror, where I know that \"value\" and the code generator can be a whole <br>\ndifferent matter.<br>\nIn this case it is simply the case that the new datatypes are not yet <br>\nregistered in the code generator. A simple</p>\n</blockquote>\n<p>code_datatype mSp mSS</p>\n<p>will make the \"value\" command work for now. There is some more useful <br>\ndefault code generator setup (see e.g. <br>\n$AFP/thys/Coinductive/Coinductive_List) that is as well on our agenda <br>\n(to make it happen automatically) as the interaction with fun (as Jasmin <br>\nmentioned).</p>\n<p>Dmitriy</p>\n<blockquote>\n<p>datatype_new 'a mS =<br>\nmSp \"'a * int\"<br>\n|mSS \"'a mS fset\"</p>\n<p>primrec_new mSSsome :: \"'a mS =&gt; 'a mS fset option\" where<br>\n\"mSSsome (mSp x) = None\"<br>\n|\"mSSsome (mSS x) = Some x\"</p>\n<p>theorem \"mSSsome (mSS{|mSp x|}) = Some {|mSp x|}\"<br>\nby(simp)</p>\n<p>theorem \"mSSsome (mSp x) = None\"<br>\nby(simp)</p>\n<p>value \"mSSsome (mSp x)\"<br>\n(*ERROR:<br>\n\"c.mS.mSp\" is not a constructor, on left hand side of equation, in <br>\ntheorem:<br>\nmSSsome (mSp ?x) ≡ None*)</p>\n</blockquote>",
        "id": 294258109,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913342
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nAndreas,</p>\n<p>Thanks for the help again. I looked at [2] a little, but without knowing <br>\nthe advantages of either, I'd pick [2] over [1]. That's because I <br>\nconstantly see emails about lifting and transfer, where quotients are a <br>\npart of that, so I need to learn all that anyway. The doc [2] also gives <br>\nsome instruction about specific Isar commands related to that, and <br>\nexplains things like Reb and Abs.</p>\n<p>From [1], they write, \"Building a theory library that implements a new <br>\nabstract type can take a lot of work.\" If I knew my datatype was going <br>\nto be a winner, then I'd want to research it all and set things up <br>\nright, because you only want to do things once. However, the datatype <br>\ncould be a loser, so I first need to prove enough theorems about it to <br>\nthink it's worth setting up in a more sophisticated way.</p>\n<p>Also, I need the experience working with more basic things anyway, <br>\nbecause I'm still working on learning how to use datatype, fun, primrec, <br>\nand function.</p>\n<p>Thinking about equality can be a brainbuster, because it's so basic, and <br>\nyou generally just use \"=\".</p>\n<p>Other than the methods you mentioned, there's an easy way to associate a <br>\nfunction with HOL.eq, and that's with an axiom.</p>\n<p>That's what I did with another type, where the type has to have axioms. <br>\nI can easily say `theorem bar [intro?]: \"foo a b ==&gt; a = b\", because the <br>\naxiom says \"(foo a b) &lt;-&gt; (a = b)\". So \"=\" is still the function HOL.eq, <br>\nbut the intro rule makes it easy to set up proving equality, which came <br>\nfrom a tip by Lars.</p>\n<p>I thought using my new type in a local might be the thing to do, but I <br>\ndon't understand locales that well. From what you told me, I sort of <br>\nleft off here:</p>\n<p>1) Variable 'a is special.</p>\n<p>2) Instantiation sometimes works in the background to help you out, but <br>\nsometimes it doesn't, at which times you must know what you're doing.</p>\n<p>I put me an assumes axiom in a local like this:</p>\n<p>locale mTloc =<br>\nassumes mTeq_ax: \"mTeq == HOL.eq\"<br>\nbegin<br>\ntheorem mTeq_imp_HOL_eq [simp]:<br>\n\"(mTeq x y) ==&gt; (x = y)\"<br>\nby (metis (full_types) mT.distinct(1) mTeq.simps(3) mTeq_ax)<br>\nend</p>\n<p>Doing that confused the issue for me even more about how type variables <br>\nare used in locales. First, the locale complains with this warning:</p>\n<p>\"Additional type variable(s) in locale specification \"mTloc\": 'a∷type \"</p>\n<p>It then uses 'b variables in the theorem. My goal was to determine <br>\nwhether what's proved in the locale is only true in the locale, where I <br>\nalready know that some things proved in a local are not completely <br>\nlocalized:</p>\n<p>locale P_by_sorry<br>\nbegin<br>\ntheorem P_is_true: \"P\" sorry<br>\nend</p>\n<p>theorem \"True &amp; False\"<br>\nby(rule, simp, rule P_by_sorry.P_is_true)</p>\n<p>So I tried to prove this outside the locale:</p>\n<p>theorem \"(mTeq x y) ==&gt; (x = y)\"<br>\n(*variables:<br>\nx, y :: 'a mT<br>\ntype variables:<br>\n'a :: type *)<br>\noops</p>\n<p>It can't use the locale theorem to prove the global theorem because the <br>\nlocale theorem is using 'b variables, and the global theorem is using 'a <br>\nvariables. I am left pondering the subject of type variables, though I <br>\nmust move on.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294258122,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913348
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 11/7/2013 11:01 AM, Jasmin Blanchette wrote:</p>\n<blockquote>\n<p>Once the next release is out, one of our first priorities will be to make sure \"fun\", the code generator, Quickcheck, Nitpick, etc., work with \"datatype_new\" just like they do with \"datatype\". We're currently waiting to avoid too much divergence between the release branch (from which the release candidates are generated) and the development branch (which will lead to the next-to-next Isabelle release).</p>\n</blockquote>\n<p>Jasmin,</p>\n<p>Alright, sounds good. Sledgehammer is my friend.</p>\n<p>On 11/7/2013 3:14 PM, Dmitriy Traytel wrote:</p>\n<blockquote>\n<p>In this case it is simply the case that the new datatypes are not yet <br>\nregistered in the code generator. A simple</p>\n<p>code_datatype mSp mSS</p>\n<p>will make the \"value\" command work for now. There is some more useful <br>\ndefault code generator setup (see e.g. <br>\n$AFP/thys/Coinductive/Coinductive_List) that is as well on our agenda <br>\n(to make it happen automatically) as the interaction with fun (as <br>\nJasmin mentioned).</p>\n</blockquote>\n<p>Dmitriy,</p>\n<p>Thanks. One error leads to another. That got me to the usual type of errors:</p>\n<p>Wellsortedness error:<br>\nType 'a∷type mS not of sort equal<br>\nNo type arity mS :: equal</p>\n<p>I might figure out how to fix that someday. On the other hand, my type <br>\nmT, which is based on lists rather than fsets, doesn't give me that <br>\nerror, so it's just easier to go with the magic.</p>\n<p>On 11/7/2013 3:32 PM, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>...I looked at [2] a little, but without knowing the advantages of <br>\neither, I'd pick [2] over [1].</p>\n</blockquote>\n<p>That should have been [1] over [2].</p>\n<blockquote>\n<p>I put me an assumes axiom in a local like this:<br>\nassumes mTeq_ax: \"mTeq == HOL.eq\"</p>\n</blockquote>\n<p>I guess it should be obvious that I wouldn't want the axiom \"mTeq x y <br>\n&lt;-&gt; x = y\" anywhere, since I'll commonly have \"mTeq x y = True\" when I <br>\nhave \"HOL.eq x y = False\". I suppose that's the difference between <br>\nstarting with a new type where you make all the rules, and a type you <br>\nuse which already has lots of rules with it.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294258147,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913360
    }
]