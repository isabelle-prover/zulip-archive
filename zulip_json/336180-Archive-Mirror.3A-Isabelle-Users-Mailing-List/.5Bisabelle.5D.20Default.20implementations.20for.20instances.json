[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nAssume the following classes:</p>\n<p>class a =<br>\n   fixes f :: \"'a =&gt; nat\"<br>\n   assumes ...</p>\n<p>class b =<br>\n   fixes g :: \"'a =&gt; 'a =&gt; nat\"<br>\n   assumes ...</p>\n<p>(the precise types of the class parameters don't matter)</p>\n<p>Furthermore assume that 'f' can be implemented in terms of 'g', but not <br>\n all types can be made instances of class 'b'. In such a case, I would <br>\n like to define a subclass relationship between 'b' and 'a', but this <br>\n doesn't work (because 'f' is not a class parameter of 'g').</p>\n<p>Johannes showed me the following \"pattern\" which is used e.g. in <br>\n Real_Vector_Space:</p>\n<p>class a0 =<br>\n   fixes f :: \"'a =&gt; nat\"</p>\n<p>class a =<br>\n   assumes ...</p>\n<p>class b = a0 +<br>\n   assumes \"f = foo g\" (* the implementation of 'f' in terms of 'g' *)<br>\n   and ...<br>\n begin</p>\n<p>subclass a<br>\n   proof ...</p>\n<p>end</p>\n<p>This works well, but comes at the cost of having to duplicate the 'f = <br>\n foo g' line in every instantiation of some type for 'b'. Additionally, <br>\n when using 'f', type inference will give me a class constraint 'a0' <br>\n which does not carry the necessary assumptions.</p>\n<p>My question now is whether this is common enough that it warrants a <br>\n \"default implementation\" mechanism, in the sense that one could specify <br>\n the implementation of 'f' in terms of 'g' \"once and for all\", and not <br>\n having to define and prove it everywhere. This could potentially also <br>\n make sense if just one class is involved:</p>\n<p>class eq =<br>\n   fixes eq  :: \"'a =&gt; 'a =&gt; bool\"<br>\n     and neq :: \"'a =&gt; 'a =&gt; bool\"<br>\n   assumes \"neq x y &lt;--&gt; ~(eq x y)\"</p>\n<p>Lars</p>",
        "id": 294275332,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918585
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>I have longed for a similar mechanism for default implementations in two situations:</p>\n<ol>\n<li>In the context of code generation, one often introduces a type class with a parameter <br>\nwhose assumptions completely determine the parameter. As parameters of type classes may <br>\nhave type-specific code equations, this is the only way to implement a polymorphic <br>\nconstant for each individual type.</li>\n</ol>\n<p>The most prominent example of this probably is \"op &lt;\" in the preorder type class, which is <br>\ncompletely determined by the assumption strict_iff_order. All instantiations have to <br>\nspecify both \"op &lt;=\" and \"op &lt;\" and prove that they are compatible. The theory <br>\nPartial_Function even defines a general mk_less operator to that end.</p>\n<ol start=\"2\">\n<li>In my AFP entry Containers, I introduce a new typeclass clinorder which has a default <br>\nimplementation if the type is in linorder, and the same for ceq and HOL.equal. René <br>\nThiemann extended his Datatype_Order_Generator such that it can automatically produce <br>\nthese instantiations and discharge the proof obligations.</li>\n</ol>\n<p>However, in this setting, I would not want to the instance to be automatic. Rather do I <br>\nwant to decide when I pick the default implementation and when I choose some other <br>\nimplementation. This would mean that I still issue a command that triggers the default <br>\nimplementation, but I no longer have to specify the instantiation nor prove the assumptions.</p>\n<p>Note that in this case, the assumptions are not of the form \"f = foo g\".</p>\n<p>Andreas</p>",
        "id": 294275350,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918593
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nThe story is more complicated since a »definition« in general is not<br>\nnecessarily equational.  As example have a look at class<br>\ncomplete_lattice where Inf determines Sup and vice versa, but none is<br>\ncharacterized equationally in the class' assumes.</p>\n<p>I hope someday that »permanent_interpretation« inside instantiation<br>\ntargets yields a pattern for default instantiations, but this is music<br>\nof the future.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/meh_0F81LGLxA2gaZ7sHxw83/signature.asc\">signature.asc</a></p>",
        "id": 294275617,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918680
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<p>The most prominent example of this probably is \"op &lt;\" in the preorder<br>\ntype class, which is completely determined by the assumption<br>\nstrict_iff_order. All instantiations have to specify both \"op &lt;=\" and<br>\n\"op &lt;\" and prove that they are compatible. The theory Partial_Function<br>\neven defines a general mk_less operator to that end.</p>\n</blockquote>\n<p>This strict coupling of Orderings.less_eq and Orderings.less is mainly<br>\nhistoric and could be split into two class hierarchies (e.g. strict_*<br>\nand reflexive_*, where the existing class »foo« joins the classes<br>\nstrict_foo and reflexive_foo).</p>\n<p>If the situation is pressing enough, this should be seriously considered.</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<ol start=\"2\">\n<li>In my AFP entry Containers, I introduce a new typeclass clinorder<br>\nwhich has a default implementation if the type is in linorder, and the<br>\nsame for ceq and HOL.equal. René Thiemann extended his<br>\nDatatype_Order_Generator such that it can automatically produce these<br>\ninstantiations and discharge the proof obligations.</li>\n</ol>\n<p>However, in this setting, I would not want to the instance to be<br>\nautomatic. Rather do I want to decide when I pick the default<br>\nimplementation and when I choose some other implementation. This would<br>\nmean that I still issue a command that triggers the default<br>\nimplementation, but I no longer have to specify the instantiation nor<br>\nprove the assumptions.</p>\n<p>Note that in this case, the assumptions are not of the form \"f = foo g\".</p>\n<p>Andreas</p>\n<p>On 10/04/14 16:16, Lars Hupel wrote:</p>\n<blockquote>\n<p>Assume the following classes:</p>\n<p>class a =<br>\n   fixes f :: \"'a =&gt; nat\"<br>\n   assumes ...</p>\n<p>class b =<br>\n   fixes g :: \"'a =&gt; 'a =&gt; nat\"<br>\n   assumes ...</p>\n<p>(the precise types of the class parameters don't matter)</p>\n<p>Furthermore assume that 'f' can be implemented in terms of 'g', but<br>\nnot all types can be<br>\nmade instances of class 'b'. In such a case, I would like to define a<br>\nsubclass<br>\nrelationship between 'b' and 'a', but this doesn't work (because 'f'<br>\nis not a class<br>\nparameter of 'g').</p>\n<p>Johannes showed me the following \"pattern\" which is used e.g. in<br>\nReal_Vector_Space:</p>\n<p>class a0 =<br>\n   fixes f :: \"'a =&gt; nat\"</p>\n<p>class a =<br>\n   assumes ...</p>\n<p>class b = a0 +<br>\n   assumes \"f = foo g\" (* the implementation of 'f' in terms of 'g' *)<br>\n   and ...<br>\nbegin</p>\n<p>subclass a<br>\n   proof ...</p>\n<p>end</p>\n<p>This works well, but comes at the cost of having to duplicate the 'f =<br>\nfoo g' line in<br>\nevery instantiation of some type for 'b'. Additionally, when using<br>\n'f', type inference<br>\nwill give me a class constraint 'a0' which does not carry the<br>\nnecessary assumptions.</p>\n<p>My question now is whether this is common enough that it warrants a<br>\n\"default<br>\nimplementation\" mechanism, in the sense that one could specify the<br>\nimplementation of 'f'<br>\nin terms of 'g' \"once and for all\", and not having to define and prove<br>\nit everywhere. This<br>\ncould potentially also make sense if just one class is involved:</p>\n<p>class eq =<br>\n   fixes eq  :: \"'a =&gt; 'a =&gt; bool\"<br>\n     and neq :: \"'a =&gt; 'a =&gt; bool\"<br>\n   assumes \"neq x y &lt;--&gt; ~(eq x y)\"</p>\n<p>Lars</p>\n<p><a href=\"/user_uploads/14278/1UZKyEADOXcApLN2XFA1waQU/signature.asc\">signature.asc</a></p>\n</blockquote>\n</blockquote>",
        "id": 294275679,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918686
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>No, please do not triple the number of type classes. It is already now somewhat cumbersome <br>\nto instantiate the order type classes for some type 'a foo to get the right sort <br>\nconstraints on the type parameter (things are already worse for the algebraic type classes).</p>\n<p>instantiation foo :: (ord) ord ...<br>\ninstance foo :: (preorder) preorder ...<br>\ninstance foo :: (order) order ...<br>\ninstance foo :: (linorder) linorder ...</p>\n<p>If you split each of these type classes into three, one would have to write twelve <br>\ninstance declarations and proofs.</p>\n<p>My point was that such default implementations might be convenient for the order <br>\nhierarchy. By the way, another example of making constants to type class parameters for <br>\nthe sake of code generation can be found in the card_UNIV hierarchy in <br>\nHOL/Library/Cardinality.</p>\n<p>Andreas</p>",
        "id": 294275890,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918753
    }
]