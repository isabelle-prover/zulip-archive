[
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>Do we have in Isabelle something like a union (sum) type constructor with<br>\nthe corresponding injections?<br>\nI went through the tutorial and did not  find use or reference to it. If<br>\nthere is, can anyone point to an application<br>\nor a written example of  this?</p>\n<p>I assume there must be a simple way to do it.</p>\n<p>Many thanks!</p>",
        "id": 294139507,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845368
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHello Alfio,</p>\n<p>Yes, there is a sum type 'a + 'b, which has constructors Inl :: 'a =&gt;<br>\n'a + 'b and Inr :: 'b =&gt; 'a + 'b.</p>\n<p>I am a bit surprised that this type is mentioned nowhere in the<br>\ntutorial. However it is documented in \"What's in Main\", which is found<br>\non the Isabelle documentation page:</p>\n<p><a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a></p>\n<p>Inl and Inr are used in lots of places in the example theories that<br>\ncome with the distribution; just use grep.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294139513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845371
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIt is written \"+\" and defined in theory Sum_Type, which is part of Main.<br>\nIt is hardly advertised because in most cases it is nicer to define your<br>\nown special datatype.</p>\n<p>Tobias</p>",
        "id": 294139525,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845377
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nTalking of the sum type... I think it would be good to have it more <br>\neasily accessible. Currently, e.g., I have to write \"Sum_Type.Projr\" to <br>\nget the right projection. As far as I can see it is mainly for internal <br>\nuse of some packages. But something like Haskell's Either would be <br>\nuseful for the library (together with a bunch of useful functions and <br>\nlemmas).</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294139537,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845384
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nThank you all for the quick replies!</p>\n<p>Cheers</p>",
        "id": 294139645,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845414
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nBefore we define a new type we should rather make the existing one more<br>\nusable. But what is really needed? Haskell does not offer Projl/r at all<br>\nbut lefts, rights and paritionEithers.</p>\n<p>Tobias</p>",
        "id": 294139655,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845421
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nOn 07/26/2011 10:13 PM, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Before we define a new type we should rather make the existing one more<br>\nusable.<br>\nYes indeed. That's what I meant.</p>\n</blockquote>\n<blockquote>\n<p>But what is really needed? Haskell does not offer Projl/r at all<br>\nbut lefts, rights and paritionEithers.<br>\nIn IsaFoR we use Sum_Type.Projr and Sum_Type.Projl. It would just feel <br>\n\"more official\" if you didn't have to use the cumbersome prefix.</p>\n</blockquote>\n<p>A not entirely related idea is the setup of an (executable) error monad <br>\nusing \"+\" (which is used heavily in IsaFoR for example).</p>\n<p>To this end I once tried to setup such a monad to use for partial <br>\nfunctions (I was heading towards a parsec-like parser combinator <br>\nlibrary; side remark: there are not many deep properties I wanted to <br>\nproof about this combinators, but it is just nice to be able to write <br>\nalso your parser in Isabelle when you use code generation) but  failed <br>\nto complete since different error cases (i.e., Inl's containing <br>\ndifferent error messages) are not equal. Maybe this could be generalized <br>\nusing some equivalence relation?</p>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<p>Tobias</p>\n<p>Am 26/07/2011 09:03, schrieb Christian Sternagel:</p>\n<blockquote>\n<p>Talking of the sum type... I think it would be good to have it more<br>\neasily accessible. Currently, e.g., I have to write \"Sum_Type.Projr\" to<br>\nget the right projection. As far as I can see it is mainly for internal<br>\nuse of some packages. But something like Haskell's Either would be<br>\nuseful for the library (together with a bunch of useful functions and<br>\nlemmas).</p>\n<p>cheers</p>\n<p>chris</p>\n</blockquote>\n<p>On 07/26/2011 07:42 AM, Tobias Nipkow wrote:</p>\n<blockquote>\n<blockquote>\n<p>It is written \"+\" and defined in theory Sum_Type, which is part of Main.<br>\nIt is hardly advertised because in most cases it is nicer to define your<br>\nown special datatype.</p>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>Am 26/07/2011 03:57, schrieb Alfio Martini:</p>\n<blockquote>\n<blockquote>\n<p>Dear Isabelle Users,</p>\n<p>Do we have in Isabelle something like a union (sum) type constructor<br>\nwith<br>\nthe corresponding injections?<br>\nI went through the tutorial and did not  find use or reference to it. If<br>\nthere is, can anyone point to an application<br>\nor a written example of  this?</p>\n<p>I assume there must be a simple way to do it.</p>\n<p>Many thanks!</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294139680,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845426
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>But what is really needed? Haskell does not offer Projl/r at all<br>\nbut lefts, rights and paritionEithers.<br>\nIn IsaFoR we use Sum_Type.Projr and Sum_Type.Projl. It would just feel \"more<br>\nofficial\" if you didn't have to use the cumbersome prefix.<br>\nSum_Type.Projr and Sum_Type.Projl are the destructor view on datatypes, which <br>\nare necessarily partial. But most formalisations in Isabelle follow the <br>\nconstructor view and use case expressions for destruction, for which there is a <br>\nreasonable setup (simp rules, split rules, etc.). For example,<br>\n(Sum_Type.Projl x) is (almost) equivalent to (case x of Inl y =&gt; y) and<br>\n(Sum_Type.Projr x) to (case x of Inr y =&gt; y).</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>A not entirely related idea is the setup of an (executable) error monad using<br>\n\"+\" (which is used heavily in IsaFoR for example).<br>\nI would recommend not to use sum types for such things, but introduce a new type <br>\nwith an error element. This has the advantage that split rules and the like can <br>\nbe applied more precisely. If sum types are used for other notions in a <br>\nformalisation, too, the general simplification and split rules might slow break <br>\ndown proof automation because they also apply to the other parts.</p>\n</blockquote>\n<blockquote>\n<p>To this end I once tried to setup such a monad to use for partial functions (I<br>\nwas heading towards a parsec-like parser combinator library; side remark: there<br>\nare not many deep properties I wanted to proof about this combinators, but it is<br>\njust nice to be able to write also your parser in Isabelle when you use code<br>\ngeneration) but failed to complete since different error cases (i.e., Inl's<br>\ncontaining different error messages) are not equal. Maybe this could be<br>\ngeneralized using some equivalence relation?<br>\nI suppose that the error messages are irrelevant to the proofs, so they need not <br>\nbe part of the logic. If the error monad is a type constructor of its own <br>\n(rather than a sum type), you can identify all error cases in the logic and <br>\nhandle the error messages in the code generator only. Here's the idea:</p>\n</blockquote>\n<p>datatype 'a err = Error | OK 'a</p>\n<p>definition Raise_error :: \"String.literal =&gt; 'a err\"<br>\nwhere \"Raise_error msg = Error\"</p>\n<p>code_datatype Raise_error OK</p>\n<p>In the logic, all errors are the same \"Error\" value, but the generated code uses <br>\nRaise_error as constructor which also stores the error message. Hence, the <br>\nlogical problem with different error messages no longer occurs.</p>\n<p>Andreas</p>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>Am 26/07/2011 09:03, schrieb Christian Sternagel:</p>\n<blockquote>\n<blockquote>\n<p>Talking of the sum type... I think it would be good to have it more<br>\neasily accessible. Currently, e.g., I have to write \"Sum_Type.Projr\" to<br>\nget the right projection. As far as I can see it is mainly for internal<br>\nuse of some packages. But something like Haskell's Either would be<br>\nuseful for the library (together with a bunch of useful functions and<br>\nlemmas).</p>\n<p>cheers</p>\n<p>chris</p>\n</blockquote>\n<p>On 07/26/2011 07:42 AM, Tobias Nipkow wrote:</p>\n<blockquote>\n<blockquote>\n<p>It is written \"+\" and defined in theory Sum_Type, which is part of Main.<br>\nIt is hardly advertised because in most cases it is nicer to define your<br>\nown special datatype.</p>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>Am 26/07/2011 03:57, schrieb Alfio Martini:</p>\n<blockquote>\n<blockquote>\n<p>Dear Isabelle Users,</p>\n<p>Do we have in Isabelle something like a union (sum) type constructor<br>\nwith<br>\nthe corresponding injections?<br>\nI went through the tutorial and did not find use or reference to it. If<br>\nthere is, can anyone point to an application<br>\nor a written example of this?</p>\n<p>I assume there must be a simple way to do it.</p>\n<p>Many thanks!</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294139706,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845433
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nOn 07/27/2011 02:31 PM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>But what is really needed? Haskell does not offer Projl/r at all<br>\nbut lefts, rights and paritionEithers.<br>\nIn IsaFoR we use Sum_Type.Projr and Sum_Type.Projl. It would just feel<br>\n\"more<br>\nofficial\" if you didn't have to use the cumbersome prefix.<br>\nSum_Type.Projr and Sum_Type.Projl are the destructor view on datatypes,<br>\nwhich are necessarily partial. But most formalisations in Isabelle<br>\nfollow the constructor view and use case expressions for destruction,<br>\nfor which there is a reasonable setup (simp rules, split rules, etc.).<br>\nFor example,<br>\n(Sum_Type.Projl x) is (almost) equivalent to (case x of Inl y =&gt; y) and<br>\n(Sum_Type.Projr x) to (case x of Inr y =&gt; y).</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>A not entirely related idea is the setup of an (executable) error<br>\nmonad using<br>\n\"+\" (which is used heavily in IsaFoR for example).<br>\nI would recommend not to use sum types for such things, but introduce a<br>\nnew type with an error element. This has the advantage that split rules<br>\nand the like can be applied more precisely. If sum types are used for<br>\nother notions in a formalisation, too, the general simplification and<br>\nsplit rules might slow break down proof automation because they also<br>\napply to the other parts.</p>\n</blockquote>\n<blockquote>\n<p>To this end I once tried to setup such a monad to use for partial<br>\nfunctions (I<br>\nwas heading towards a parsec-like parser combinator library; side<br>\nremark: there<br>\nare not many deep properties I wanted to proof about this combinators,<br>\nbut it is<br>\njust nice to be able to write also your parser in Isabelle when you<br>\nuse code<br>\ngeneration) but failed to complete since different error cases (i.e.,<br>\nInl's<br>\ncontaining different error messages) are not equal. Maybe this could be<br>\ngeneralized using some equivalence relation?<br>\nI suppose that the error messages are irrelevant to the proofs, so they<br>\nneed not be part of the logic. If the error monad is a type constructor<br>\nof its own (rather than a sum type), you can identify all error cases in<br>\nthe logic and handle the error messages in the code generator only.<br>\nHere's the idea:</p>\n</blockquote>\n<p>datatype 'a err = Error | OK 'a</p>\n<p>definition Raise_error :: \"String.literal =&gt; 'a err\"<br>\nwhere \"Raise_error msg = Error\"</p>\n<p>code_datatype Raise_error OK</p>\n<p>In the logic, all errors are the same \"Error\" value, but the generated<br>\ncode uses Raise_error as constructor which also stores the error<br>\nmessage. Hence, the logical problem with different error messages no<br>\nlonger occurs.<br>\nThis looks nice. However, we do compose error messages incrementally <br>\n(i.e., add more precise information to errors at different places). I do <br>\nnot immediately see how this could be achieved with a single error <br>\nconstructor. Any hints?</p>\n</blockquote>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<p>Andreas</p>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>Am 26/07/2011 09:03, schrieb Christian Sternagel:</p>\n<blockquote>\n<blockquote>\n<p>Talking of the sum type... I think it would be good to have it more<br>\neasily accessible. Currently, e.g., I have to write \"Sum_Type.Projr\" to<br>\nget the right projection. As far as I can see it is mainly for internal<br>\nuse of some packages. But something like Haskell's Either would be<br>\nuseful for the library (together with a bunch of useful functions and<br>\nlemmas).</p>\n<p>cheers</p>\n<p>chris</p>\n</blockquote>\n<p>On 07/26/2011 07:42 AM, Tobias Nipkow wrote:</p>\n<blockquote>\n<blockquote>\n<p>It is written \"+\" and defined in theory Sum_Type, which is part of<br>\nMain.<br>\nIt is hardly advertised because in most cases it is nicer to define<br>\nyour<br>\nown special datatype.</p>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>Am 26/07/2011 03:57, schrieb Alfio Martini:</p>\n<blockquote>\n<blockquote>\n<p>Dear Isabelle Users,</p>\n<p>Do we have in Isabelle something like a union (sum) type constructor<br>\nwith<br>\nthe corresponding injections?<br>\nI went through the tutorial and did not find use or reference to<br>\nit. If<br>\nthere is, can anyone point to an application<br>\nor a written example of this?</p>\n<p>I assume there must be a simple way to do it.</p>\n<p>Many thanks!</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294139729,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845439
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Christian,</p>\n<p>In code equations, you can \"pattern-match\" on the pseudo-constructor <br>\nRaise_error. If you need more structured types than String.literal, the <br>\nfollowing with phantom type variables should work for you:</p>\n<p>datatype ('a, 'b) err = Error | OK 'b</p>\n<p>definition Raise_error :: \"'a =&gt; ('a, 'b) err\"<br>\nwhere [simp]: \"Raise_error msg = Error\"</p>\n<p>code_datatype Raise_error OK</p>\n<p>primrec more_info :: \"('a, 'b) err =&gt; ('a * String.literal, 'b) err\"<br>\nwhere<br>\n   \"more_info Error = Error\"<br>\n| [code]: \"more_info (OK b) = (OK b)\"</p>\n<p>lemma more_info_Raise_error [code]:<br>\n   \"more_info (Raise_error a) = Raise_error (a, STR ''info'')\"<br>\nby simp</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294139741,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845445
    }
]