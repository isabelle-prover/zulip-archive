[
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nI'm having problems proving termination of the well-founded recursive  <br>\nfunction xs_strm defined below, and other functions like it.</p>\n<p>The termination measure is just less_than, and I've installed  <br>\nappropriate congruence rules. However, the function package generates  <br>\nan unprovable termination condition.</p>\n<p>On the other hand, I have been able to manually prove the identical  <br>\nfunction xs_strm2 below is well-founded by defining it in terms of<br>\nthe wfrec combinator and manually applying the congruence rules. Below  <br>\nare the definitions and lemmas needed to show the problem.</p>\n<p>Thanks in advance,<br>\n-john</p>\n<p>section \"Auxiliary function and lemma\"</p>\n<p>text {*Coerces a finite prefix of an infinite stream (represented as a  <br>\n@{typ \"nat \\&lt;Rightarrow&gt; 'a\"} function) into a finite list. *}<br>\ndefinition<br>\n   strm_to_list :: \"nat \\&lt;Rightarrow&gt; (nat \\&lt;Rightarrow&gt; 'a)  <br>\n\\&lt;Rightarrow&gt; 'a list\" where<br>\n  \"strm_to_list n f = map f [0..&lt;n]\"</p>\n<p>lemma length_strm_to_list[simp]:<br>\n   \"length (strm_to_list n f) = n\"<br>\nby (simp add: strm_to_list_def)</p>\n<p>section {* Congruence rules for proving termination of @{term  <br>\n\"xs_strm\"} below. *}</p>\n<p>lemma nth_cons_cong[fundef_cong]:<br>\n   \"\\&lt;lbrakk&gt;i = i';<br>\n     i' = 0 \\&lt;Longrightarrow&gt; x = x';<br>\n     \\&lt;And&gt;j. i = Suc j \\&lt;Longrightarrow&gt; xs ! j = xs' ! j\\&lt;rbrakk&gt;  <br>\n\\&lt;Longrightarrow&gt;<br>\n    (x # xs) ! i = (x' # xs') ! i'\"<br>\nby (cases i, auto)</p>\n<p>lemma nth_out_of_bounds:<br>\n   \"length xs \\&lt;le&gt; n \\&lt;Longrightarrow&gt; xs ! n = [] ! (n - length xs)\"<br>\napply (induct xs arbitrary: n, auto simp add: nth_list_def)<br>\nby (case_tac n, auto)</p>\n<p>lemma nth_take_cong[fundef_cong]:<br>\n   assumes \"i = i'\"<br>\n       and \"n = n'\"<br>\n       and \"i' &lt; n' \\&lt;Longrightarrow&gt; xs ! i' = xs' ! i'\"<br>\n       and \"length xs = length xs'\"<br>\n   shows \"(take n xs) ! i = (take n' xs') ! i'\"<br>\n   (is \"?lhs = ?rhs\")<br>\nusing prems apply (cases \"i' &lt; n'\", auto)<br>\napply (subst nth_out_of_bounds, auto)<br>\nby (subst (2) nth_out_of_bounds, auto)</p>\n<p>lemma nth_strm_to_list_cong[fundef_cong]:<br>\n   \"\\&lt;lbrakk&gt;n = n';<br>\n     i = i';<br>\n     i &lt; n \\&lt;Longrightarrow&gt; f i' = f' i'\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt;<br>\n    strm_to_list n f ! i = strm_to_list n' f' ! i'\"<br>\napply (simp add: strm_to_list_def)<br>\napply (cases \"i' &lt; n'\", auto)<br>\napply (subst nth_out_of_bounds, auto)<br>\nby (subst (2) nth_out_of_bounds, auto)</p>\n<p>section \"An unsuccessful attempt to prove termination of the<br>\nwell-founded function @{term xs_strm} below\"</p>\n<p>function<br>\n    xs_strm :: \"nat \\&lt;Rightarrow&gt; nat\" where<br>\n   \"xs_strm i<br>\n    = (0 # take 2 (strm_to_list 3 xs_strm)) ! i\"<br>\nby pat_completeness auto<br>\ntermination<br>\n   apply (relation less_than)<br>\n   apply auto<br>\n   -- \"I am left with an unprovable termination condition\"<br>\n   oops</p>\n<p>section \"Manually applying congruence rules to prove termination of the<br>\nidentical function @{term xs_strm2}\"</p>\n<p>definition<br>\n    xs_strm2 :: \"nat \\&lt;Rightarrow&gt; nat\" where<br>\n   \"xs_strm2 = wfrec less_than (\\&lt;lambda&gt;R i. (0 # take 2  <br>\n(strm_to_list 3 R)) ! i)\"</p>\n<p>lemma def_xs_strm2:<br>\n   \"xs_strm2 i = (0 # take 2 (strm_to_list 3 xs_strm2)) ! i\"<br>\n   (is \"?lhs = ?rhs\")<br>\nproof -<br>\n   let \"?H R i\" = \"((0::nat) # take 2 (strm_to_list 3 R)) ! i\"<br>\n   from wfrec[OF wf_less_than, where H=\"?H\" and a=i] xs_strm2_def<br>\n   have \"?lhs = ?H (cut xs_strm2 less_than i) i\" by simp<br>\n   also have \"\\&lt;dots&gt; = ?rhs\"<br>\n     -- \"Manually applying congruence rules here\"<br>\n     apply (subst nth_cons_cong, simp_all)<br>\n     apply (subst nth_take_cong, simp_all)<br>\n     apply (subst nth_strm_to_list_cong, simp_all)<br>\n     by (simp add: cut_apply)<br>\n   finally show ?thesis .<br>\nqed</p>",
        "id": 294062096,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824093
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi John,</p>\n<blockquote>\n<p>I'm having problems proving termination of the well-founded recursive <br>\nfunction xs_strm defined below, and other functions like it.</p>\n</blockquote>\n<p>Good to see that you are driving all available tools to their limits and <br>\nbeyond, as usual :-) But it might actually work...</p>\n<p>The problem is that nth_take_cong has the premise about the lengths <br>\nbeing equal. In the function definition, a \"recursive call\" will be <br>\ngenerated by this premise because the instance occuring contains the <br>\nfunction being defined. But this simplifies away in your manual proof <br>\nbecause \"length (strm_to_list n f)\" does not depend on f.</p>\n<p>So you need just one more cong rule to tell function about this:</p>\n<p>lemma length_strm_to_list_cong[fundef_cong]:<br>\n   \"n = n' ==&gt; length (strm_to_list n f) = length (strm_to_list n' f')\"<br>\n   by simp</p>\n<p>Then it works.</p>\n<p>Alex</p>",
        "id": 294062107,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824095
    },
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nThanks Alex, that did the trick nicely. It seems to be holding up for  <br>\ndefining mutually-recursive lists as well.</p>\n<p>-john</p>",
        "id": 294062155,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824120
    }
]