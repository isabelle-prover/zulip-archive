[
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nI'm trying to use Isabelle to play with synthetic projective geometry.<br>\nI've managed to prove things in the first couple of pages of the<br>\ntextbook I'm using, which is great. But in doing so, I've stumbled on<br>\nseveral items. I hope it's OK to ask multiple questions at once here.</p>\n<ol>\n<li>As a starting point, I'm working with affine planes. Those consist<br>\nof a set of points (an abstract type) and lines, a line being a subset<br>\nof the set of points. Two lines are parallel if their intersection is<br>\nempty, or if they're identical. So I've got this:</li>\n</ol>\n<p>theory Geometry2_jfh<br>\nimports Main<br>\nbegin<br>\n  locale affine_plane_syntax =<br>\n  fixes<br>\n    Points :: \"'a  set\" and<br>\n    Lines :: \"'a set set\"<br>\n  begin<br>\n    definition parallel (infix \"||\" 50)<br>\n    where \"⟦ l ∈ Lines; m ∈ Lines ⟧ ⟹  l || m ⟷ l = m ∨ ¬ (∃ P∈<br>\nPoints. P∈ l ∧ P ∈ m)\"<br>\nend</p>\n<p>There are a few axioms for an affine plane, and then I try to prove<br>\nthat parallelism is an equivalence relation...but nitpick shows that<br>\nit's not...by giving me an example in which s is parallel to t, and t<br>\nis parallel to u, but s is not parallel to u.  This is not because of<br>\na failure in the foundations of affine geometry, but a failure in my<br>\nIsabelle formulation: the sets s, t, u that \"nitpick\" discovers are<br>\nnot actually lines in my geometry. They're subsets of the set of<br>\npoints, but are not among those particular subsets that are declared<br>\nto be \"lines\". The definition above says that IF l and m are lines,<br>\nthen parallelism means this particular thing. But if they're NOT<br>\nlines, it also has a meaning. Is there a way for me to say \"parallel\"<br>\nis a predicate that operates on pairs of elements of the set \"Lines\",<br>\nand not on pairs of arbitrary subsets of the set of Points?</p>\n<p>[For now I've added two \"axioms\" that say that if m is not in \"Lines\",<br>\nthen a || m is false, and that m || a is false, but that seems bogus.]</p>\n<ol start=\"2\">\n<li>My current work has all been about a single affine plane, but at<br>\nsome point I need to say things where A and A' are both affine planes,<br>\nand f is an isomorphism between them, etc. For that, I probably want<br>\nto use the \"class\" construction as was done for groups (in the<br>\nabstract algebra sense) here:<br>\n<a href=\"http://isabelle.in.tum.de/library/HOL/HOL-Isar_Examples/Group.html\">http://isabelle.in.tum.de/library/HOL/HOL-Isar_Examples/Group.html</a></li>\n</ol>\n<p>I have a question about this, however: suppose that, in that \"groups\"<br>\ndocument, I'd wanted to prove that $Z/3Z$, i.e., a three element set<br>\nwith an operation defined in analogy with modular addition, is a<br>\ngroup. I don't see how to do this. I basically want to build a<br>\nconstant (my three-element set together with its addition operation)<br>\nand assert that this is an element of the class \"group\". Any thoughts?</p>\n<ol start=\"3\">\n<li>Even within my current work, I'd like to say \"The 4-point affine<br>\nplane is an affine plane,\" or at least \"the 4-point affine plane<br>\nsatisfies my first axiom, namely that for any two distinct points,<br>\nthere's a line containing them\". I tried writing this:</li>\n</ol>\n<p>theorem (in affine_plane) four_point_plane : \" (Points = {P,Q,R,S}) ∧<br>\n(Lines = {{P,Q},{P,R},{P,S},{Q,R},{Q,S},{R,S}}) →<br>\n(((E ∈ Points) ∧ (F ∈ Points) ∧ (E ≠ F)) → (∃! l∈ Lines. E ∈ l ∧ F ∈ l))</p>\n<p>but got a \"failed to parse prop\" error.</p>\n<p>I tried reducing this to a minimal non-working example, and arrived at this:</p>\n<p>theory test_jfh<br>\nimports Main<br>\nbegin<br>\ntheorem silly : \"(Points = {P}) → (P ∈ Points)\"<br>\nend</p>\n<p>for which I got the same \"failed to parse prop\" error.</p>\n<p>I'd sure appreciate any suggestions.</p>",
        "id": 294747977,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194300
    },
    {
        "content": "<p>From: Mark Wassell &lt;<a href=\"mailto:mpwassell@gmail.com\">mpwassell@gmail.com</a>&gt;<br>\nHi,</p>\n<p>Regarding your last question: The problem here is that your implication<br>\narrow is too short. Trying entering --&gt; (two dashes and then greater than).<br>\nAlternatively \\longrightarrow.</p>\n<p>Cheers</p>\n<p>Mark</p>",
        "id": 294747999,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194311
    },
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nThanks! I've begun resolving some of the other bits as well, but definitely<br>\nfeel as if there are a lot of arrows, and they all mean \"this leads to<br>\nthat\" , some being in Isabelle, some being in HOL, and the distinction<br>\nbeing baffling. And then there's the choice to use  int =&gt; int to mean an<br>\nint-to-int function, rather than int -&gt; int, which seems just weird. Does<br>\nthe \"-&gt;\" arrow mean ANYthing at all? Or is it just a vestigial thing left<br>\naround to tease newcomers? :)</p>\n<p>Just when I think I might be beginning to sort something out, I come to<br>\nthis in \"Programming and Proving\":<br>\n===<br>\nThe implication ⇒ is part of the Isabelle framework. It structures theorems<br>\nand proof states, separating assumptions from conclusions. The implication<br>\n→ is part of the logic HOL and can occur inside the formulas that make up<br>\nthe assumptions and conclusion. Theorems should be of the form [[ A1; . .<br>\n.; An ]] ⇒ A, not A1 ∧ . . . ∧ An → A. Both are logically equivalent but<br>\nthe first one works better when using the theorem in further proofs.<br>\n===<br>\nIt'd be nice if this oh-so-cryptic paragraph gave a hint about WHY one of<br>\ntwo logically equivalent things \"works better.\" Otherwise I'm just being<br>\ntold \"do this because it's what the master does,\" and doesn't help me<br>\nachieve my own mastery. Sigh.</p>\n<p>--John</p>",
        "id": 294748013,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194317
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIsabelle is a logical framework. Inference rules are expressed in this framework using the symbols (in ASCII) !! and ==&gt;. It’s a higher-order framework, so it has function types, written using =&gt;. All built-in inference mechanisms work on the level of this framework. Variables of the form ?x also express universal quantification.</p>\n<p>Note that a logic defined in Isabelle doesn’t need to have its own implication symbol, quantifiers or any concept of function space. But if it does, symbols such as !, --&gt; and -&gt; are available to denote them. </p>\n<p>In Isabelle/ZF, A -&gt; B denotes the <em>set</em> of functions between the sets A and B. And it has the same meaning in Isabelle/HOL.</p>\n<p>If you write a theorem as A ==&gt; B, then it can immediately be used for forward or backward chaining. If instead you write it as A --&gt; B, then you’ll need to involve implication rules in order to do anything with it. No surprise then that proofs in certain other systems are dominated by the use of implication rules.</p>\n<p>Larry</p>",
        "id": 294748065,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194323
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:sewell@chalmers.se\">sewell@chalmers.se</a>&gt;<br>\nI'll add some observations, which might or might not be helpful.</p>\n<p>There are indeed a lot of arrows. In addition, like every functional language I've used, Isabelle seems to make some non-orthodox decisions about about the symbol/arrow for various basic operators.</p>\n<p>I think that you are right, and the short-single arrow is always parsed as a symbol but is not (by default) part of any particular syntax.</p>\n<p>Here's the more substantial question. Given that they're logically equivalent, why would \"P ==&gt; Q ==&gt; R\" be described as more useful than \"P &amp; Q --&gt; R\"?</p>\n<p>To a beginner, they may in fact be equivalent. Most of the complex/smart tools, like metis or the simplifier, will use rules of either form in essentially the same way.</p>\n<p>However the basic Isabelle rule calculus can also be quite useful. The basic calculus takes its cues on how to use a rule from its shape, and only looks at the pure Isabelle operators \"_ ==&gt; _\" and \"!!_. _\". Used as an introduction rule, \"P &amp; Q --&gt; R\" can solve goals of exactly the same form, but \"P ==&gt; Q ==&gt; R\" will replace goals of the form \"R\" with a pair of goals \"P\" and \"Q\". \"P ==&gt; Q ==&gt; R\" can also be used as a destruction rule or elimination rule, which \"P &amp; Q --&gt; R\" can't.</p>\n<p>Or, in short, if you know how to use the resolution calculus, \"P ==&gt; Q ==&gt; R\" allows you to specify three different kinds of single step, whereas \"P &amp; Q --&gt; R\" is only useful in a situation you're unlikely to be in.</p>\n<p>Cheers,<br>\n    Thomas.</p>",
        "id": 294748414,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194454
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIt is better to have clearly designated threads for each topic, to<br>\nincrease chances that all problems are eventually sorted out.</p>\n<p>Makarius</p>",
        "id": 294748568,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194513
    }
]