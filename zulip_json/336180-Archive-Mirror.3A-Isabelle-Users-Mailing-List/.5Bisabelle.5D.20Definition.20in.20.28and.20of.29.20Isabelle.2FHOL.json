[
    {
        "content": "<p>From: Rob Arthan &lt;<a href=\"mailto:rda@lemma-one.com\">rda@lemma-one.com</a>&gt;<br>\nI am trying to address a comment to this short paper proposing an improved method of constant specification in the non-Isabelle implementations of HOL: <a href=\"http://www.lemma-one.com/papers/hcddr.pdf\">http://www.lemma-one.com/papers/hcddr.pdf</a>. The comment is asking me to say more about Isabelle/HOL. My reason for excluding Isabelle/HOL when I first wrote the paper, was that I believed, based on hearsay and guesswork, that all the mechanisms for defining constants in Isabelle/HOL are founded on a primitive that is part of the logical framework and that supports definition via (non-recursive) equations. So anything like the HOL4 new_specification would be implemented under the covers using the Hilbert choice function. Is that correct?</p>\n<p>Alternatively, so I can found out the answer for myself, can anyone point me at the definitive definition of the Isabelle/HOL logic, including the definitional mechanisms, please. (Sorry about all that definiteness :-)) The nearest I can find on the documentation page is the logics manual and that doesn’t seem to answer my question and is marked as out-of-date.</p>\n<p>Regards,</p>\n<p>Rob.</p>",
        "id": 294271531,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917382
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sat, 29 Mar 2014, Rob Arthan wrote:</p>\n<blockquote>\n<p>I am trying to address a comment to this short paper proposing an <br>\nimproved method of constant specification in the non-Isabelle <br>\nimplementations of HOL: <a href=\"http://www.lemma-one.com/papers/hcddr.pdf\">http://www.lemma-one.com/papers/hcddr.pdf</a>. The <br>\ncomment is asking me to say more about Isabelle/HOL. My reason for <br>\nexcluding Isabelle/HOL when I first wrote the paper, was that I <br>\nbelieved, based on hearsay and guesswork, that all the mechanisms for <br>\ndefining constants in Isabelle/HOL are founded on a primitive that is <br>\npart of the logical framework and that supports definition via <br>\n(non-recursive) equations.</p>\n</blockquote>\n<p>There is a long story behind that, started by Larry some decades ago, but <br>\nit continously changed according to new requirements.</p>\n<p>The original Pure logical framework by Larry merely had axiomatic <br>\nspecifications, which were introduced as 'types', 'consts', 'rules' <br>\n(similar to LF).</p>\n<p>In the mid-1990-ies we added a slightly restricted version of 'rules' that <br>\nwas called 'defs', with a few local checks, but no global guarantees of <br>\nthe well-formedness of the theory.</p>\n<p>When I introduced the Isar theory syntax in 1998/1999, I renamed 'rules' <br>\nto 'axioms'.  Later the 'defs' became a bit more serious, with some <br>\nnon-local checks, to track dependencies of overloaded and non-overloaded <br>\nconstants more explicitly.  This was substantially refined in 2005, and <br>\n2007/2008.</p>\n<p>Later the 'axioms' became 'axiomatization', with some explicit dependency <br>\ntracking of which constants are supposed to be axiomatized.  The 'defs' <br>\nwere also de-emphasized in favour of the Local_Theory.define abstraction, <br>\nwhich merely uses a restricted 'defs' form at the bottom: just c == t for <br>\nclosed terms, and no longer any pre-conditions that were still allowed in <br>\n'defs'.</p>\n<p>Isabelle/HOL relies on constant definitions of Isabelle/Pure in the above <br>\nform, but invents its own axiom schemes, notably 'typedef' (which is not <br>\nquite definitional as we all know).</p>\n<p>Our current version of typedef is notable, since it does not depend on a <br>\nproven non-emptiness theorem in advance, it merely needs that to turn a <br>\nconditional axiomatization into an actual one.  That formal trick makes <br>\nthe constant definitions independent on the typedefs, because the <br>\n\"meaning\" of consts is not needed to introduce new typedefs.</p>\n<blockquote>\n<p>So anything like the HOL4 new_specification would be implemented under <br>\nthe covers using the Hilbert choice function. Is that correct?</p>\n</blockquote>\n<p>There is indeed an Isabelle/HOL emulation of HOL4 new_specification called <br>\n'specification', which uses Hilbert choice + definition.  It has an <br>\nalternative axiomatic personality without the Hilbert Choice, but that was <br>\nactually never used and is already deleted for the coming Isabelle <br>\nrelease.</p>\n<p>In Isabelle2013-2 documentation <br>\n<a href=\"http://isabelle.in.tum.de/dist/Isabelle2013-2/doc/isar-ref.pdf\">http://isabelle.in.tum.de/dist/Isabelle2013-2/doc/isar-ref.pdf</a> there is <br>\nstill a description of ax_specification, but its worries about exposing <br>\nthe definition to the user are actually obsolete: with Local_Theory.define <br>\nthe kernel produces a precise definition c == @x. ... at the very bottom, <br>\nbut that is only for foundational purposes.  After the next renovation of <br>\nthe 'specification' element, it will just refrain from exposing that <br>\ndefinition to the normal fact name space, and the user will have a hard <br>\ntime to come across it accidentally.</p>\n<p>This is analogous to something that is \"private\" in Java.  Normally <br>\ninaccesible and not to be worried about, but with some tricks you can get <br>\nit from the low-level JVM environment, because it is there for <br>\nfoundational purposes</p>\n<p>This separation of Local_Theory primitives vs. theory foundations at the <br>\nbottom circumvents some old problems, although it introduces new <br>\ncomplexity to be dealt with.</p>\n<p>Makarius</p>",
        "id": 294271603,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917403
    },
    {
        "content": "<p>From: Rob Arthan &lt;<a href=\"mailto:rda@lemma-one.com\">rda@lemma-one.com</a>&gt;<br>\nMakarius,</p>\n<p>Thanks again for that. My current plan for the paper is to not to exclude Isabelle/HOL, but to discuss it alongside the other implementations. Perhaps you could let me know if you there is anything wrong with the following outline of my understanding, based on your reply below.</p>\n<p>Isabelle/HOl was first implemented in the early ‘90s after the unsoundness problem with type variables appearing on the right-hand side of a definition, c = t, but not on the left-hand side was known, so it never suffered from that problem. Its internal mechanisms for doing definitions have involved over the years, but the current position for type definitions is quite like HOL Light when you look right under the covers, i.e., new_specification is emulated using an equational definition and Hilbert choice. However, Isabelle has information-hiding mechanisms that are more powerful than HOL Light’s, so this is not so problematic in practice. I think it is also fair to say that locales in Isabelle/HOL provide an alternative abstraction mechanism that can be used as a replacement for the kind of abstraction offered by new_specification, in that it lets you identify the abstract properties needed to carry out a given set of proofs without requiring you to be explicit about the actual types and constants that satisfy those properties. Locales (or a slight variant of them) would perhaps give you a nice way of implementing the generalised new_specification proposed in my paper.</p>\n<p>Do you do anything to avoid the potential problem whereby two calls of new_specification with the same predicate will result in provably equal constants if you implement new_specification naively with Hilbert choice. E.g., ?x.1 &lt; x &lt; 10 used to define c and d?  This is addressed in HOL Light along the following lines: it defines a function on the natural numbers such that 1 &lt; x(n) &lt; 10 for all n, and then defines c = x(42) and d = x(43), assuming that c is the 42nd constant that HOL Light has been asked to define.</p>\n<p>What you say about type definitions in Isabelle/HOL sounds interesting and is reminiscent of what we do in ProofPower to allow users to defer consistency proofs.</p>\n<p>Regards,</p>\n<p>Rob.</p>",
        "id": 294275444,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918626
    },
    {
        "content": "<p>From: Rob Arthan &lt;<a href=\"mailto:rda@lemma-one.com\">rda@lemma-one.com</a>&gt;<br>\nMakarius,</p>\n<p>Thanks again for that. My current plan for the paper is to not to exclude Isabelle/HOL, but to discuss it alongside the other implementations. Perhaps you could let me know if you there is anything wrong with the following outline of my understanding, based on your reply below.</p>\n<p>Isabelle/HOl was first implemented in the early ‘90s after the unsoundness problem with type variables appearing on the right-hand side of a definition, c = t, but not on the left-hand side was known, so it never suffered from that problem. Its internal mechanisms for doing definitions have involved over the years, but the current position for type definitions is quite like HOL Light when you look right under the covers, i.e., new_specification is emulated using an equational definition and Hilbert choice. However, Isabelle has information-hiding mechanisms that are more powerful than HOL Light’s, so this is not so problematic in practice. I think it is also fair to say that locales in Isabelle/HOL provide an alternative abstraction mechanism that can be used as a replacement for the kind of abstraction offered by new_specification, in that it lets you identify the abstract properties needed to carry out a given set of proofs without requiring you to be explicit about the actual types and constants that satisfy those properties. Locales (or a slight variant of them) would perhaps give you a nice way of implementing the generalised new_specification proposed in my paper.</p>\n<p>Do you do anything to avoid the potential problem whereby two calls of new_specification with the same predicate will result in provably equal constants if you implement new_specification naively with Hilbert choice. E.g., ?x.1 &lt; x &lt; 10 used to define c and d?  This is addressed in HOL Light along the following lines: it defines a function on the natural numbers such that 1 &lt; x(n) &lt; 10 for all n, and then defines c = x(42) and d = x(43), assuming that c is the 42nd constant that HOL Light has been asked to define.</p>\n<p>What you say about type definitions in Isabelle/HOL sounds interesting and is reminiscent of what we do in ProofPower to allow users to defer consistency proofs.</p>\n<p>Regards,</p>\n<p>Rob.</p>",
        "id": 294275463,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918630
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThere is nothing like this in the 'specification' command of Isabelle/HOL, <br>\nbut that add-on feature from 2004 got hardly ever used in practice. It <br>\nalso fell behind a lot concerning general system infrastructure for <br>\nIsabelle specifications.</p>\n<p>I have recently asked around the canonical question if 'specification' <br>\nshould be be removed or renovated, and it came out a slight tendency <br>\ntowards renovation (after removal of some of its obsolete sub-features).</p>\n<p>Locales are indeed better in most situations to work in a context of <br>\nabstract term parameters with some logical premises in the local context. <br>\nAlmost all specification mechanisms in Isabelle/HOL are now \"localized\", <br>\ni.e. work in such hypothetical situations of \"fixes\" and \"assumes\", so <br>\nthat is a real practical benefit.  The cost for it is increasingly complex <br>\nsystem infrastructure (outside the core logical framework).</p>\n<p>Makarius</p>",
        "id": 294275479,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918636
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAnother observation about this detail: this approach of HOL Light assumes <br>\na single linear theort context.  In Isabelle we've had a DAG of theories <br>\n(with merge), ever since Larry introduced that in 1989.  One could still <br>\ndo a similar trick there, but with more structure for these intro-logical <br>\nindentifiers.</p>\n<p>Makarius</p>",
        "id": 294275503,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918642
    },
    {
        "content": "<p>From: Rob Arthan &lt;<a href=\"mailto:rda@lemma-one.com\">rda@lemma-one.com</a>&gt;<br>\nMakarius,</p>\n<p>Good point! This trick wouldn’t work properly in HOL4 or ProofPower for exactly the same reason.</p>\n<p>Regards,</p>\n<p>Rob.</p>",
        "id": 294275597,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918673
    }
]