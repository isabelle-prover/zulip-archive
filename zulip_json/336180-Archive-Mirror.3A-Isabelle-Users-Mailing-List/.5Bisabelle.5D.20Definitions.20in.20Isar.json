[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 9/3/2013 12:04 PM, Makarius wrote:</p>\n<blockquote>\n<p>On Tue, 3 Sep 2013, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>I care about the operator \"==\", and over the months, Makarius has <br>\nmade a number of comments deemphasizing it, and the comments below <br>\nindicate something similar. I don't see how \"==\" could be gotten rid <br>\nof from Isar, but what do I know?</p>\n<p>The operator \"==\" will forever be an Isar operator, won't it?</p>\n</blockquote>\n<p>...What exactly do you mean by \"==\" as Isar operator?  It belongs to <br>\nPure, not Isar.  So it is not an Isar operator now, and will never be.</p>\n</blockquote>\n<p>But it is Isar. Anything between \"theory\" and \"end\" in a THY is Isar. I <br>\nquote from an authority on Isar, you, in<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2012-August/msg00037.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2012-August/msg00037.html</a> <br>\n:</p>\n<p>* The content of a theory file between 'theory' and the final 'end'<br>\n    is by<br>\n       definition the Isar source language.</p>\n<blockquote>\n<p>If you mean this Isar command:</p>\n<p>def x == \"t\"</p>\n</blockquote>\n<p>No. What's being talked about on [isabelle-dev] and what I'm thinking <br>\nabout are apparently two different things. I'd say I'm wasting your <br>\ntime, but you've belittled \"==\" almost every time it's listed as one of <br>\nthe meta-operators in a discussion. Belittling a feature can precede a <br>\nfeature being eliminated.</p>\n<blockquote>\n<p>To finish this perspective of more flexibile local definitions within <br>\nproofs, in conformance to 'definition' for local theories, the general <br>\nform would be like this:</p>\n<p>define f where \"f x y z = t\" for x y z</p>\n</blockquote>\n<p>I'm wasn't talking about proofs, but having to use any HOL operator, <br>\nsuch as \"=\", is what I don't want to be forced to use. I'm talking about <br>\nusing \"==\" in \"definition\" and the statement of a theorem with \"lemma\" <br>\nor \"theorem\".</p>\n<p>This next definition is what I'm talking about, which is the one single <br>\ndefinition I need to mess around with meta-logic in Isabelle/HOL, and <br>\nkeep it separate from the object-logic:</p>\n<p>definition MFalse :: \"prop\" where<br>\n   \"MFalse == (!!P. PROP P)\"</p>\n<blockquote>\n<p>Nothing of that old cleanup plan is imminent, not for the coming release.</p>\n</blockquote>\n<p>My paranoia is a result of you telling me several times that I should be <br>\nworking at the object-logic level, rather than the meta-logic level. I <br>\ndon't care if you tell me that, but I'd hate to be forced to always work <br>\nat the object-logic level soley because that's what you think I should do.</p>\n<p>I'm imagining some 2-year plan by the devs to push the meta-logic <br>\noperators down and out of Isar. I don't want to put 6 months and more of <br>\nwork into developing a bunch of meta-logic, if I know it's going away.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294247678,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909554
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI'll generalize this comment thread I started, and here I'll play the <br>\npart of Joe User Advocate. The details I was talking about are covered <br>\nby this generalization, and after this I'll just take what comes. I <br>\ndon't expect any changes to be withheld because of me, and I'm basically <br>\ngoing to start making all my plans based on what the next release is.</p>\n<p>Maybe two weeks ago, my perception was that Isabelle2012 is a prime-time <br>\nproduct, not a throw-away research product, as it's been described in <br>\nthe past by one of the primary developers.</p>\n<p>Today, I'm thinking about two points, based on how I've seen changes <br>\nimplemented:</p>\n<p>1) For Isabelle/HOL, there is zero commitment to backwards compatibility <br>\nby the developers.</p>\n<p>2) For Isabelle/HOL, there is no long term, future forecasts published <br>\nby the developers so that users can plan for the future, to help users <br>\nnot get tied into things which are going to disappear.</p>\n<p>Here, I'm reminded of an email by a user about three months ago who had <br>\nput a lot of work into a version such as Isabelle2009, but who is now <br>\nout of luck with the new versions. Change is necessary, but I take that <br>\nas a lesson for what's coming down the road for me.</p>\n<p>Formalizing math is a multi-year project, like a 10, 20, or 30 year <br>\nproject. From today, I estimate that in five years, I might have <br>\nsomething that's worthwhile. I don't want to put a year or more of work <br>\ninto something, and then not be able to use it.</p>\n<p>The short story is that I've decided that I could get locked into <br>\nIsabelle2012 today, and it would get me through another 20 years, <br>\nrunning either on Windows, Linux, or on VirtualBox. Being prepared to <br>\nget locked into any version is my solution to 1) and 2) above.</p>\n<p>I would lose the ability to coordinate what I do with others, but I'm my <br>\nown highest priority. I don't have to wonder whether the ZFC axioms are <br>\ngoing to be the same in 6 months, so I'm not going to stay in some <br>\nconstant state of flux as far as the software.</p>\n<p>My suggestion is that a running, multi-year forecast of changes be <br>\npublished, to help other Joe Users get a feel for the future.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294248011,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909685
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 3 Sep 2013, Gottfried Barrow wrote:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>The operator \"==\" will forever be an Isar operator, won't it?</p>\n</blockquote>\n<p>...What exactly do you mean by \"==\" as Isar operator?  It belongs to Pure, <br>\nnot Isar.  So it is not an Isar operator now, and will never be.</p>\n</blockquote>\n<p>But it is Isar. Anything between \"theory\" and \"end\" in a THY is Isar. I quote <br>\nfrom an authority on Isar, you, in<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2012-August/msg00037.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2012-August/msg00037.html</a> <br>\n:</p>\n<p>* The content of a theory file between 'theory' and the final 'end'<br>\n  is by<br>\n     definition the Isar source language.</p>\n</blockquote>\n<p>That is indeed true for the outermost language of Isabelle/Isar, but there <br>\nthere are several languages embedded into that (potentially recursively), <br>\ne.g. the languages of types, terms, theorems of the logical environment <br>\n(Isabelle/Pure or Isabelle/HOL or whatever), or Isabelle/ML, or Isabelle <br>\ndocument source.</p>\n<blockquote>\n<p>I'm wasn't talking about proofs, but having to use any HOL operator, <br>\nsuch as \"=\", is what I don't want to be forced to use. I'm talking about <br>\nusing \"==\" in \"definition\" and the statement of a theorem with \"lemma\" <br>\nor \"theorem\".</p>\n</blockquote>\n<p>That was not really on the thread that you have seen on isabelle-dev. <br>\nBasic == of Isabelle/Pure is perfectly adequate for situations where you <br>\nmake Pure definitions, e.g. like this:</p>\n<blockquote>\n<p>definition MFalse :: \"prop\" where<br>\n \"MFalse == (!!P. PROP P)\"</p>\n</blockquote>\n<p>When you work in Isabelle/HOL, what most users do most of the time, it is <br>\nbetter to use its plain =, though.  This helps to make specifications and <br>\nproofs uniform and with reduced surprise of proof tools that cannot cope <br>\nwith pure == (e.g. certain calculation reasoning rules in HOL).</p>\n<blockquote>\n<p>My paranoia is a result of you telling me several times that I should be <br>\nworking at the object-logic level, rather than the meta-logic level. I <br>\ndon't care if you tell me that, but I'd hate to be forced to always work <br>\nat the object-logic level soley because that's what you think I should <br>\ndo.</p>\n</blockquote>\n<p>The general principle is: the right tool for the right job.  When you work <br>\nin Isabelle/Pure directly, without Isabelle/HOL, then == is fine, and in <br>\nfact the only option for actual \"meta\" definitions.</p>\n<p>Other object-logics like Isabelle/ZF cannot internalize all definition <br>\nforms into their own = and sometimes have to evade into Pure for that, but <br>\nthis extra complication is not needed in Isabelle/HOL.</p>\n<p>Makarius</p>",
        "id": 294248825,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909980
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 3 Sep 2013, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>Maybe two weeks ago, my perception was that Isabelle2012 is a prime-time <br>\nproduct, not a throw-away research product, as it's been described in <br>\nthe past by one of the primary developers.</p>\n</blockquote>\n<p>Does it mean you are not converted to Isabelle2013 yet?  Isabelle release <br>\ncycles are done such that the least painful way to upgrade is to do that <br>\ncontinuously.  The amount of incompatibilities in each release is usually <br>\nlimited to something that works out for most applications.</p>\n<blockquote>\n<p>Today, I'm thinking about two points, based on how I've seen changes <br>\nimplemented:</p>\n<p>1) For Isabelle/HOL, there is zero commitment to backwards compatibility by <br>\nthe developers.</p>\n<p>2) For Isabelle/HOL, there is no long term, future forecasts published by the <br>\ndevelopers so that users can plan for the future, to help users not get tied <br>\ninto things which are going to disappear.</p>\n</blockquote>\n<p>You should say \"Isabelle\" in general, not Isabelle/HOL (before you have <br>\npointed out an interest to work directly with Isabelle/Pure, ignoring the <br>\nhuge Isabelle/HOL library).</p>\n<p>I am myself involved in Isabelle only since 1993, but I've never seen a <br>\ncommitment to \"backwards compatibility\".  Instead there has always been a <br>\nnatural flow of updating the system technically, conceptually, introducing <br>\nnew things, discontinuing old things (the latter requires a lot of work).</p>\n<p>Without that principle, Isabelle2012 would not have been as nice as it was <br>\nlast year (now Isabelle2013 is nicer).  You may also browse through the <br>\nrecorded history to see yourself if you want to stack back in 1993:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/file/831a9a7ab9f3\">http://isabelle.in.tum.de/repos/isabelle/file/831a9a7ab9f3</a></p>\n<p>or lets say 1998:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/file/be6b5edbca9f\">http://isabelle.in.tum.de/repos/isabelle/file/be6b5edbca9f</a></p>\n<p>The 1998 vintage was actually an exceptionally good one.</p>\n<blockquote>\n<p>Here, I'm reminded of an email by a user about three months ago who had put a <br>\nlot of work into a version such as Isabelle2009, but who is now out of luck <br>\nwith the new versions. Change is necessary, but I take that as a lesson for <br>\nwhat's coming down the road for me.</p>\n</blockquote>\n<p>Isabelle2009 was a long time ago.  People who don't mange to keep <br>\nup-to-date all the time can put their material into shape for AFP, where <br>\nit usually gets updated \"automagically\".</p>\n<blockquote>\n<p>My suggestion is that a running, multi-year forecast of changes be <br>\npublished, to help other Joe Users get a feel for the future.</p>\n</blockquote>\n<p>You can look at Isabelle/NEWS to get a feeling for the continuity of <br>\nchanges in Isabelle, and project them into the future.</p>\n<p>If I compare this to the Java distribution that is even a bit younger than <br>\nIsabelle, I wonder which project turns out as more professional and <br>\nreliable in the end.</p>\n<p>E.g. see <a href=\"http://openjdk.java.net/projects/jdk8/\">http://openjdk.java.net/projects/jdk8/</a> for the precise forecast <br>\nthat has been changed so many times.  Tomorrow should be the \"Developer <br>\nPreview\" of Java 8, and <em>if</em> it happens I expect it to have most of the <br>\nold problems of Java 7 again, in perfect backwards compatibility.</p>\n<p>Makarius</p>",
        "id": 294248886,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909998
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFor the full fun of browsing ancient Isabelle/HOL sources, one needs to <br>\ninclude this annex to the history (which was cut out from the CVS tree at <br>\nsome point): <a href=\"http://isabelle.in.tum.de/repos/Old_HOL/\">http://isabelle.in.tum.de/repos/Old_HOL/</a></p>\n<p>For example <br>\n<a href=\"http://isabelle.in.tum.de/repos/Old_HOL/annotate/14b9286ed036/llist.ML\">http://isabelle.in.tum.de/repos/Old_HOL/annotate/14b9286ed036/llist.ML</a> <br>\nshows that what is now src/HOL/List.thy has always been \"TOO LONG!  needs <br>\nsplitting up\" (according to Larry Paulson 1993-09-22).</p>\n<p>Makarius</p>",
        "id": 294248908,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910004
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nTo me, llist.ML looks more like the construction of coinductive lists. This later became <br>\nLList.thy in HOL/Induct and has been dropped after Isabelle 2009 in favour of the AFP <br>\nentry Coinductive.</p>\n<p>Andreas</p>",
        "id": 294248931,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910011
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 4 Sep 2013, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>On 04/09/13 14:49, Makarius wrote:</p>\n<p>On Wed, 4 Sep 2013, Makarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>or lets say 1998:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/file/be6b5edbca9f\">http://isabelle.in.tum.de/repos/isabelle/file/be6b5edbca9f</a></p>\n<p>The 1998 vintage was actually an exceptionally good one.</p>\n</blockquote>\n<p>For the full fun of browsing ancient Isabelle/HOL sources, one needs to <br>\ninclude this annex<br>\nto the history (which was cut out from the CVS tree at some point):<br>\n<a href=\"http://isabelle.in.tum.de/repos/Old_HOL/\">http://isabelle.in.tum.de/repos/Old_HOL/</a></p>\n<p>For example <br>\n<a href=\"http://isabelle.in.tum.de/repos/Old_HOL/annotate/14b9286ed036/llist.ML\">http://isabelle.in.tum.de/repos/Old_HOL/annotate/14b9286ed036/llist.ML</a> <br>\nshows<br>\nthat what is now src/HOL/List.thy has always been \"TOO LONG!  needs <br>\nsplitting up\"<br>\n(according to Larry Paulson 1993-09-22).<br>\nTo me, llist.ML looks more like the construction of coinductive lists.</p>\n</blockquote>\n</blockquote>\n<p>You are right.  Strangely I can't see a List.thy in that view of the <br>\nhistory.  Here is a more complete one: <br>\n<a href=\"http://isabelle.in.tum.de/repos/Old_HOL/file/c3913a79b6ae\">http://isabelle.in.tum.de/repos/Old_HOL/file/c3913a79b6ae</a></p>\n<blockquote>\n<p>This later became LList.thy in HOL/Induct and has been dropped after <br>\nIsabelle 2009 in favour of the AFP entry Coinductive.</p>\n</blockquote>\n<p>Which is an excellent library, and it will be yet better in the next <br>\nrelease when the new codatatype package based on \"BNFs\" is used.</p>\n<p>Makarius</p>",
        "id": 294248977,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910029
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 9/4/2013 7:20 AM, Makarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>* The content of a theory file between 'theory' and the final 'end'<br>\n  is by<br>\n     definition the Isar source language.</p>\n</blockquote>\n<p>That is indeed true for the outermost language of Isabelle/Isar, but <br>\nthere there are several languages embedded into that (potentially <br>\nrecursively), e.g. the languages of types, terms, theorems of the <br>\nlogical environment (Isabelle/Pure or Isabelle/HOL or whatever), or <br>\nIsabelle/ML, or Isabelle document source.</p>\n</blockquote>\n<p>I will, many times, grudgingly conform, but if you make the Latin too <br>\ncomplex, the vulgar masses will corrupt the official Latin either out of <br>\nignorance, or to make it practical to use in everyday conversation.</p>\n<p>I can call '==' an Isabelle/Pure operator, but then the emphasis is all <br>\nwrong. There are three Isabelle/Pure operators, \\&lt;And&gt;, !!, and ==, that <br>\nare a seamless part of the Isar language. Because the high-level part of <br>\nIsar is the high-level language I want to use, I want vocabulary that <br>\nemphasizes that's the level I'm concerned about.</p>\n<p>Inside a command ML{...}, I would never call the '=' operator an Isar <br>\noperator, even though I've been told that everything between \"theory\" <br>\nand \"end\" is Isar.</p>\n<p>However, given the inner syntax part of the two lines <code>theorem \"A == B\"</code> <br>\nand <code>theorem \"A = B\"</code>, there is nothing special that marks '==' and '=' <br>\nto differentiate one as a Pure operator, and one as a HOL operator. So, <br>\nif '==' is an operator that is seamlessly integrated into Isar, and <br>\nhigh-level Isar is what I care about, rather than the low-level ML that <br>\nmakes up the bulk of Pure, then I definitely am inclined to call '==' an <br>\nIsar operator.</p>\n<p>It's Isar. It's an operator that can be used in inner syntax. It's an <br>\nIsar operator. That it's also a Pure operator, and a meta-logic <br>\noperator, that just reflects complexity and sophistication. It's \"Pure <br>\noperator\" that's going to be neglected, because I only look at the files <br>\nthat define Pure when I click on something in jEdit that opens up an ML <br>\nfile.</p>\n<p>It's not that important. It's just convenient. Severe torture could be <br>\nused to change my mindset.</p>\n<blockquote>\n<p>When you work in Isabelle/HOL, what most users do most of the time, it <br>\nis better to use its plain =, though.  This helps to make <br>\nspecifications and proofs uniform and with reduced surprise of proof <br>\ntools that cannot cope with pure == (e.g. certain calculation <br>\nreasoning rules in HOL).</p>\n</blockquote>\n<p>Trying to do what I'm told not to do can sometimes be an excellent way <br>\nto appreciate why I don't want to do what I'm told not to do, and <br>\noccasionally it leads to discovery of something good. With software, one <br>\ncan touch the hot stove and not get burned, if, say, the software is not <br>\nrunning on a server for a large corporation.</p>\n<p>Thanks for your time,<br>\nGB</p>",
        "id": 294249440,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910180
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 9/4/2013 7:38 AM, Makarius wrote:</p>\n<blockquote>\n<p>Does it mean you are not converted to Isabelle2013 yet?  Isabelle <br>\nrelease cycles are done such that the least painful way to upgrade is <br>\nto do that continuously.  The amount of incompatibilities in each <br>\nrelease is usually limited to something that works out for most <br>\napplications.</p>\n</blockquote>\n<p>I'm using Isabelle2013, and looking forward to the locale addition in <br>\n2013-1. The years 2012 and 2103 get blurred together for me. <br>\nIsabelle2012 was prime-time, and Isabelle2013, with the Poly/ML fix, was <br>\nprime-time+.</p>\n<blockquote>\n<blockquote>\n<p>Today, I'm thinking about two points, based on how I've seen changes <br>\nimplemented:</p>\n<p>1) For Isabelle/HOL, there is zero commitment to backwards <br>\ncompatibility by the developers.</p>\n<p>2) For Isabelle/HOL, there is no long term, future forecasts <br>\npublished by the developers so that users can plan for the future, to <br>\nhelp users not get tied into things which are going to disappear.</p>\n</blockquote>\n<p>You should say \"Isabelle\" in general, not Isabelle/HOL (before you <br>\nhave pointed out an interest to work directly with Isabelle/Pure, <br>\nignoring the huge Isabelle/HOL library).</p>\n</blockquote>\n<p>It becomes a matter of emphasis again. The signs indicate that it is <br>\nspecifically Isabelle/HOL of Isabelle that is going to rule the world. I <br>\ndon't ignore the Isabelle/HOL library at all, it's just taking me a <br>\nwhile to get through HOL.thy. The library as part of the distribution is <br>\na big part of what makes Isabelle/HOL convenient to use.</p>\n<p>Other practical matters also rule. It's preliminary, but I'm interested <br>\nin working up some meta-logic, such as intro and elim rules, along with <br>\npseudo-sequents, but only within Isabelle/HOL. With a little planning, I <br>\ncan maybe keep things independent, but because it's Isabelle/HOL I'm <br>\nworking in, everything can potentially be used in Isabelle/HOL, along <br>\nwith the potential of extracting what's been set up to be independent. <br>\nKeeping some logic independent within a locale, that's only dependent on <br>\nthe independent meta-logic, would again allow it to then be used with <br>\nHOL, but yet be extracted. I guess. I'm talking about things I haven't <br>\nworked out.</p>\n<p>It's not practical to spend years learning formal logic, and then not be <br>\nable to use the concepts you've learned.</p>\n<blockquote>\n<p>I am myself involved in Isabelle only since 1993, but I've never seen <br>\na commitment to \"backwards compatibility\".  Instead there has always <br>\nbeen a natural flow of updating the system technically, conceptually, <br>\nintroducing new things, discontinuing old things (the latter requires <br>\na lot of work).</p>\n</blockquote>\n<p>Consequently, because of your lack of promising to be all things to all <br>\npeople, to take care of Americans in all ways, and not promising <br>\neveryone a small rose garden, the tally of those who vote for you when <br>\nyou run for political office will be equal to a small integer n.</p>\n<blockquote>\n<p>Without that principle, Isabelle2012 would not have been as nice as it <br>\nwas last year (now Isabelle2013 is nicer).  You may also browse <br>\nthrough the recorded history to see yourself if you want to stack back <br>\nin 1993:</p>\n</blockquote>\n<p>I had downloaded 1999-2 to see what users would have had available to <br>\nthem in that year. The number systems are pretty much non-existent. The <br>\ndifferences are big enough that it makes it too much work to want to <br>\nspend any time figuring out what the differences are.</p>\n<p>For me, starting with Isabelle2013-1, there is the current version, and <br>\nthat's all there is. If I don't have a solution to be able to say that, <br>\nthen it's not worth the risk of continuing. But I do have a solution, to <br>\nat least address one scenario.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294249448,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910182
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 5 Sep 2013, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>On 9/4/2013 7:20 AM, Makarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>* The content of a theory file between 'theory' and the final 'end'<br>\n  is by<br>\n     definition the Isar source language.</p>\n</blockquote>\n<p>That is indeed true for the outermost language of Isabelle/Isar, but there <br>\nthere are several languages embedded into that (potentially recursively), <br>\ne.g. the languages of types, terms, theorems of the logical environment <br>\n(Isabelle/Pure or Isabelle/HOL or whatever), or Isabelle/ML, or Isabelle <br>\ndocument source.</p>\n</blockquote>\n<p>I will, many times, grudgingly conform, but if you make the Latin too <br>\ncomplex, the vulgar masses will corrupt the official Latin either out of <br>\nignorance, or to make it practical to use in everyday conversation.</p>\n</blockquote>\n<p>Vulgarisation is indeed a problem.  Note that in the best of times of the <br>\nRoman Empire, educated people were fluent in Latin, Greek, and probably <br>\nPersian (a bit later also Arabic).</p>\n<p>In Isabelle we have a similar multilingial environment that poses some <br>\nchallenges.  One needs to try to get at least at a few stable islands of <br>\nunderstanding of \"what is what\" in Isabelle.  To simplify that scheme, I <br>\nam using Isabelle/XYZ as uniform terminology to refer to the XYZ aspect of <br>\nIsabelle, e.g. Isabelle/Pure, Isabelle/HOL, Isabelle/Isar, Isabelle/ML, <br>\nIsabelle/Scala.  No \"X level\" nor \"Y layer\" as was done occasioanlly in <br>\nthe past.</p>\n<p>Sometimes there are more general expressions like \"the logical language\" <br>\n(which could mean Isabelle/Pure or Isabelle/HOL or both), or \"the Prover <br>\nIDE\" (which could mean Isabelle/Scala or Isabelle/jEdit, or some other <br>\nfront-end).</p>\n<blockquote>\n<p>I can call '==' an Isabelle/Pure operator, but then the emphasis is all <br>\nwrong. There are three Isabelle/Pure operators, \\&lt;And&gt;, !!, and ==, that <br>\nare a seamless part of the Isar language. Because the high-level part of <br>\nIsar is the high-level language I want to use, I want vocabulary that <br>\nemphasizes that's the level I'm concerned about.</p>\n</blockquote>\n<p>I don't quite understand that.  Maybe the use of \"level\" causes again <br>\nconfusion.  The Isar language is mostly about so-called \"outer syntax\": <br>\ncommands like 'theorem' or 'proof' / 'qed' with a certain token language, <br>\nlike \"...\" or {* ... <em>} or (</em> ... *).</p>\n<p>How does '==' from the logical environment get in here?  What is your <br>\nmeaning of \"Isar\"?  If you call it \"logical operator\" it is all fine: it <br>\nis clearly identified as part of the \"logical environment\".</p>\n<blockquote>\n<p>Inside a command ML{...}, I would never call the '=' operator an Isar <br>\noperator, even though I've been told that everything between \"theory\" <br>\nand \"end\" is Isar.</p>\n</blockquote>\n<p>That should be ML {* ... <em>}.  The verbatim token {</em> ... *} is used here <br>\nmost of the time for convenience, since it allows to use \"...\" inside <br>\nwithout extra escapes.  (Further nesting of languages then requires <br>\nslightly awkward backslashed quotes.)</p>\n<p>Conceptually, from the Isar language embedding approach, there is no <br>\ndifference of</p>\n<p>ML \"fun f x = x + 1\"   -- \"Isabelle/ML as embedded language\"</p>\n<p>vs.</p>\n<p>lemma \"xyz\"  -- \"logical proposition as embedded language\"</p>\n<p>In fact, just a few weeks ago I had some discussion with someone who wants <br>\nto do another Isabelle sub-language about that quoting business.  I had <br>\nsome problems explaining {* ... *} vs. \"...\" apart from history.  So if <br>\nthis would be done afresh, it could be all unified with some nestable <br>\nquotes (just one kind of them) and no escapes inside quotes.  Then, within <br>\nan advanced Prover IDE, the user might not even notice much about quoting <br>\nany more.</p>\n<blockquote>\n<p>It's Isar. It's an operator that can be used in inner syntax. It's an <br>\nIsar operator.</p>\n</blockquote>\n<p>This is contradictory.  A classic simplified view is:</p>\n<p>Isar --- \"outer syntax\"<br>\n   logical language --- \"inner syntax\"</p>\n<p>Makarius</p>",
        "id": 294249693,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910262
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 9/6/2013 6:58 AM, Makarius wrote:</p>\n<blockquote>\n<p>Vulgarisation is indeed a problem.  Note that in the best of times of <br>\nthe Roman Empire, educated people were fluent in Latin, Greek, and <br>\nprobably Persian (a bit later also Arabic).</p>\n</blockquote>\n<p>I'll put my most important comment first. I take the view that the <br>\nnon-structural parts of language, such as spelling, pronunciation, and <br>\nword choice, are largely arbitrary in nature. For example, which is it, <br>\nwelcome, willkommen, or bienvenida? Consequently, I try to be willing to <br>\nadopt official, technical vocabulary, but to do that I have to have <br>\nsomething that officially tells me what the official vocabulary is, with <br>\nsome explanations and examples explaining subtleties.</p>\n<p>I have heard that the French work very hard to preserve and protect <br>\ntheir language. There is the reputation of the French, that when an <br>\nAmerican goes to Paris and tries to ask questions in English, the French <br>\nwill act as if they don't know English, when they do (and we know they <br>\nall speak English).</p>\n<p>There is also the Academie francaise, the spelling of which I, of <br>\ncourse, slaughter, as every mono-lingual English speaker should:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Acad%C3%A9mie_fran%C3%A7aise\">https://en.wikipedia.org/wiki/Acad%C3%A9mie_fran%C3%A7aise</a></p>\n<p>I have no problem with people aggressively trying to protect their language.</p>\n<p>As to Isabelle, there should be a section in the Isar reference manual <br>\nwhich gives users something to authoritatively quote to explain to <br>\nothers how to talk about the different parts of Isabelle.</p>\n<p>When there are 10,000 users, I guarantee, you will be overwhelmed if no <br>\nsuch section exists.</p>\n<p>If there's something official to quote, then 2,000 experienced users of <br>\nthe 10,000 can act as the Academy of Isabelle, even if the vocabulary <br>\ndoesn't always make sense.</p>\n<blockquote>\n<p>In Isabelle we have a similar multilingial environment that poses some <br>\nchallenges.  One needs to try to get at least at a few stable islands <br>\nof understanding of \"what is what\" in Isabelle.  To simplify that <br>\nscheme, I am using Isabelle/XYZ as uniform terminology to refer to the <br>\nXYZ aspect of Isabelle, e.g. Isabelle/Pure, Isabelle/HOL, <br>\nIsabelle/Isar, Isabelle/ML, Isabelle/Scala.  No \"X level\" nor \"Y <br>\nlayer\" as was done occasioanlly in the past.</p>\n<p>Sometimes there are more general expressions like \"the logical <br>\nlanguage\" (which could mean Isabelle/Pure or Isabelle/HOL or both), or <br>\n\"the Prover IDE\" (which could mean Isabelle/Scala or Isabelle/jEdit, <br>\nor some other front-end).</p>\n</blockquote>\n<p>Context is everything, and you're fighting the traditional and general <br>\nuse of the word \"level\". More about \"level\" below.</p>\n<blockquote>\n<blockquote>\n<p>...Because the high-level part of Isar is the high-level language I <br>\nwant to use, I want vocabulary that emphasizes that's the level I'm <br>\nconcerned about.</p>\n</blockquote>\n<p>I don't quite understand that.  Maybe the use of \"level\" causes again <br>\nconfusion.  The Isar language is mostly about so-called \"outer <br>\nsyntax\": commands like 'theorem' or 'proof' / 'qed' with a certain <br>\ntoken language, like \"...\" or {* ... <em>} or (</em> ... *).</p>\n</blockquote>\n<p>You've now changed what I should or shouldn't say. I was taking as <br>\nauthoritative the statement \"everything between 'theory' and 'end' is by <br>\ndefinition the Isar source language\".</p>\n<p>Now, you say Isar is \"outer syntax\", where your use of \"mostly\" doesn't <br>\nhelp me figure out whether inner syntax can or can't be labeled as Isar.</p>\n<p>And there is the general meaning of \"level\" which is interfering here. <br>\n\"Level\" can commonly mean \"level of abstraction\".</p>\n<p>Hexadecimal machine code is low-level. Assembly language is low-level, <br>\nbut higher-level than machine code. C language is finally high-level, <br>\nbut with pointers, not as high-level as Java.</p>\n<p>If everything in a THY is Isar, I need to talk about what's in ML{<em>...</em>} <br>\nas low-level Isar. Generally speaking, ML is a lower-level language than <br>\nmuch of Isar. The context is merely the level of abstraction of ML <br>\nversus the level of abstraction of Isar.</p>\n<p>Here, I say this, \"Give me an example of a popular programming language <br>\nthat can't be referred to with just one word or phrase, where, or <br>\ncourse, Isabelle/HOL and Isar are not programming languages, though <br>\nthere's no official documentation that I can quote from to say that, and <br>\neven now, I'm not sure I'm right in saying that about Isabelle/HOL, <br>\nbecause, again, there's no authoritative documentation or book to sort <br>\nit all out for me.\"</p>\n<p>Coq has a language, Gallina, but everyone just calls Coq one thing, <br>\n\"Coq\". It's easy to talk about Coq when you want to talk about Coq. You <br>\njust talk about Coq.</p>\n<p>Calling Isabelle \"Isabelle\" is way too general. There's the popular <br>\nlogic Isabelle/HOL, the secondary logic Isabelle/ZF, and then many minor <br>\nlogics, all composed of languages that elude being given one label. <br>\nWanting to work at a high level of abstraction, I try to use \"Isar\", but <br>\nyou contest my use of \"Isar\".</p>\n<blockquote>\n<p>How does '==' from the logical environment get in here?  What is your <br>\nmeaning of \"Isar\"?  If you call it \"logical operator\" it is all fine: <br>\nit is clearly identified as part of the \"logical environment\".</p>\n</blockquote>\n<p>My meaning of Isar was your description of Isar, that everything between <br>\n\"theory\" and \"end\" is Isar. If only outer syntax is Isar, I must <br>\nreconsider this matter of correct vocabulary usage, more than I prefer to.</p>\n<blockquote>\n<blockquote>\n<p>It's Isar. It's an operator that can be used in inner syntax. It's an <br>\nIsar operator.</p>\n</blockquote>\n<p>This is contradictory.  A classic simplified view is:</p>\n<p>Isar --- \"outer syntax\"<br>\n  logical language --- \"inner syntax\"</p>\n</blockquote>\n<p>If the phrase <code>Isar --- \"outer syntax\"</code> is being enforced ex post facto, <br>\nit's clear that I'm breaking the law.</p>\n<p>I immediately ask, \"If inner syntax is not Isar, what one word can I use <br>\nto label the language that's being used in inner syntax? 'Syntax' <br>\nimplies the use of a language.\"</p>\n<p>Suppose I'm told, \"It's not a language, but a logic.\" (Here, others' <br>\npast emphasis on the difference between a logic and a programming <br>\nlanguage interfered with me focusing on there being \"languages of logic\".)</p>\n<p>I say, \"Fine, I can go with logic. The creator gets the liberty to make <br>\nthe rules axiomatically.\"</p>\n<p>I now immediately ask, \"What is the one word I can use to describe the <br>\nlogic being used in inner syntax?\"</p>\n<p>If I'm told, \"It's not that simple. There are multiple logics being used <br>\nin the inner syntax.\"</p>\n<p>I say, \"Okay. It is what you say it is. In <code>A = B ==&gt; A = B</code>, it is <br>\nclear that '==&gt;' is meta-logic or Pure, and that 'A = B' is HOL logic. <br>\nThere is a complication, though, because I know that 'A = B' is being <br>\ncoercied to type prop, so what is the one word to use to emphasize that <br>\n<code>A = B</code> is both a meta-logic term and an object-logic term?\"</p>\n<p>If I'm told. \"There is no one word, you must use a lengthy phrase, or a <br>\nword that is too general to capture the meaning of what you want to say.\"</p>\n<p>I then say, \"It's time to rebel against the creator, at least in my mind.\"</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294249797,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910287
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n(In order to avoid the usual chaos of cross-posting between the lists, <br>\nI've changed the subject.)</p>\n<p>What exactly do you mean by \"==\" as Isar operator?  It belongs to Pure, <br>\nnot Isar.  So it is not an Isar operator now, and will never be.</p>\n<p>If you mean this Isar command:</p>\n<p>def x == \"t\"</p>\n<p>it does belong to Isar, but it can be better done like 'obtain' as follows <br>\n(with the same preprocessing like 'definition'):</p>\n<p>define x where \"x = t\"</p>\n<p>Nothing of that old cleanup plan is imminent, not for the coming release.</p>\n<p>Makarius</p>",
        "id": 294249879,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910323
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI like to try bring to an end my part of these kind of threads as fast <br>\nas possible. First, I tell you my plan for the future, and then I try <br>\nand explain it.</p>\n<p>Unless I brainstorm for a better solution to fit my needs, in my mind, <br>\nit's \"Isar operator\". It's possible that what is in my mind will make <br>\nits way into something I put out on the Web, and what I put on the Web, <br>\nI will never ask anyone here for any kind of editorial review. That's <br>\nthe great thing about proof assistants, auto-review is built in. That <br>\nthe logic is correct, that's the main thing.</p>\n<p>I need a language, and I need a name for the language. Here, let me <br>\nstart by calling it the NN language, for the no-name language.</p>\n<p>You have provided many languages, so I pick the four that are most <br>\nrelated to what I'm doing: Isabelle/ML, Isabelle/HOL, Isabelle/Pure, and <br>\nIsabelle/Isar.</p>\n<p>It's hard not to go on tangents. As to Isabelle/HOL being a language, I <br>\nsee many places where HOL is called a logic, but there's only the <br>\noccasional, half-hearted comment where it's called a language. It <br>\ndoesn't even sound right to call it a language, but I'll call it a language.</p>\n<p>Here I describe the parts of the languages of Isabelle that I'm using:</p>\n<p>1) Outer syntax commands to state theorems and to make proof statements.<br>\n2) Inner syntax that is mainly formulas made up of meta-logic operators, <br>\nHOL operators, and HOL functions.</p>\n<p>I don't use any ML. I don't use any Latex. I don't use any  annotations. <br>\nThe inner syntax I'm using consists of item 2 that I've listed. So far, <br>\nwhat I'm doing looks more like the contents of a Mathematica document <br>\nthan an ML or Coq document. We could call much of it \"cryptic <br>\nnatural-language-like mathematics.\"</p>\n<p>That you've clarified to me that the logic of ML can be used in inner <br>\nsyntax makes \"inner syntax\" even less suitable to describe the language <br>\nthat I'm using. The name of a language doesn't give us exact details, <br>\nbut it can precisely rule out some things. With Java, we know that <br>\npointers aren't being used.</p>\n<p>If inner syntax can be ML as the logical language, and I don't use ML, <br>\nthen \"inner syntax\" ends up being too general to describe what I'm doing <br>\nin Isar.</p>\n<p>Here the imaginary conversation starts:</p>\n<p>/Someone/: \"You're using the language Pure.\"</p>\n<p>/Me/: \"But I'm exclusively working in the logic Isabelle/HOL. I don't <br>\nforesee working in any other logic, and I'm using HOL to do the bulk of <br>\nwhat I'm doing.\"</p>\n<p>/Someone/: \"Then obviously you're using the language Isabelle/HOL.\"</p>\n<p>/Me/: \"Not necessarily. I could be creating some meta-logic in HOL <br>\nthat's independent of HOL. There's also the issue that the three Pure <br>\noperators and the HOL operators have so much in common that they deserve <br>\nto be considered as part of the same language.\"</p>\n<p>/Someone/: \"Whatever you do, it's clear that 'Isar' can't be the word <br>\nyou use.\"</p>\n<p>/Me/: \"No, of course not, not without at least explaining my specific <br>\nuse of 'Isar' in the preface of a document.\"</p>\n<p>So, with a name for a language, I can then start modifying it with <br>\nthings like \"NN operator\". That's pretty normal, as I see it.</p>\n<p>It won't really matter if no one is interested in what I'm doing. If <br>\nthey are interested, that's good for me, and good for Isabelle.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294249910,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910336
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 6 Sep 2013, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>I have heard that the French work very hard to preserve and protect <br>\ntheir language. There is the reputation of the French, that when an <br>\nAmerican goes to Paris and tries to ask questions in English, the French <br>\nwill act as if they don't know English, when they do (and we know they <br>\nall speak English).</p>\n</blockquote>\n<p>The French are generally a bit reluctant to use English, because they <br>\ndon't know it very well.</p>\n<blockquote>\n<p>There is also the Academie francaise, the spelling of which I, of course, <br>\nslaughter, as every mono-lingual English speaker should:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Acad%C3%A9mie_fran%C3%A7aise\">https://en.wikipedia.org/wiki/Acad%C3%A9mie_fran%C3%A7aise</a></p>\n<p>I have no problem with people aggressively trying to protect their language.</p>\n</blockquote>\n<p>There are many jokes about that centralized language committee of France, <br>\nboth inside and outside the country.  Sometimes they do some interesting <br>\njob.  E.g. email is officially called \"courriel\", while spam is <br>\n\"pourriel\".  Unfortunately that ingenious linguistic construction is <br>\nhardly ever used in practice: the man on the street just says \"email\" and <br>\n\"spam\" with a strange French pronounciation.  Thus the pop culture from <br>\nNorth America has overcome Central European sophistication.</p>\n<p>Anyway, this is getting a bit off-topic.</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>...Because the high-level part of Isar is the high-level language I want <br>\nto use, I want vocabulary that emphasizes that's the level I'm concerned <br>\nabout.</p>\n</blockquote>\n<p>I don't quite understand that.  Maybe the use of \"level\" causes again <br>\nconfusion.  The Isar language is mostly about so-called \"outer syntax\": <br>\ncommands like 'theorem' or 'proof' / 'qed' with a certain token language, <br>\nlike \"...\" or {* ... <em>} or (</em> ... *).</p>\n</blockquote>\n<p>You've now changed what I should or shouldn't say. I was taking as <br>\nauthoritative the statement \"everything between 'theory' and 'end' is by <br>\ndefinition the Isar source language\".</p>\n</blockquote>\n<p>It is definitely Isar (as outer syntax).  Then you can embed any other <br>\nlanguage inside it (as inner syntax), and repeat or alternate that <br>\nprinciple ad infinitum.  After some nesting, it becomes difficult to hold <br>\nup the simplifying termninolgy of \"outer\" vs. \"inner\", although the <br>\noutermost Isar token language always remains as a starting point.</p>\n<blockquote>\n<p>\"Level\" can commonly mean \"level of abstraction\".</p>\n<p>Hexadecimal machine code is low-level. Assembly language is low-level, but <br>\nhigher-level than machine code. C language is finally high-level, but with <br>\npointers, not as high-level as Java.</p>\n<p>If everything in a THY is Isar, I need to talk about what's in ML{<em>...</em>} <br>\nas low-level Isar. Generally speaking, ML is a lower-level language than <br>\nmuch of Isar. The context is merely the level of abstraction of ML <br>\nversus the level of abstraction of Isar.</p>\n</blockquote>\n<p>This is leading in the wrong direction; the level of abstraction does not <br>\nmatter here.  Isabelle/ML and Isabelle/Isar are both high-level languages, <br>\nbut of quite different kind and purpose.</p>\n<blockquote>\n<p>Coq has a language, Gallina, but everyone just calls Coq one thing, <br>\n\"Coq\". It's easy to talk about Coq when you want to talk about Coq. You <br>\njust talk about Coq.</p>\n<p>Calling Isabelle \"Isabelle\" is way too general. There's the popular <br>\nlogic Isabelle/HOL, the secondary logic Isabelle/ZF, and then many minor <br>\nlogics, all composed of languages that elude being given one label.</p>\n</blockquote>\n<p>I would say as first approximation it is fine to say \"Isabelle source <br>\ntext\" for any of the Isabelle languages.  You then become specific <br>\naccording to the context: Isabelle/ML, Isabelle/HOL etc.</p>\n<p>The situation is not fundamentally different in Coq, although they never <br>\nworked out the integration of different languages as systematically as was <br>\ndone in Isabelle in the last 10 years.  Moreover there is a cultural <br>\ndifference: French Type Theorists like to eat everything from one plate, <br>\nso there is a tendency to internalize everything into the core logic <br>\n(which then becomes huge and hard to manage conceptually).</p>\n<blockquote>\n<blockquote>\n<p>This is contradictory.  A classic simplified view is:</p>\n<p>Isar --- \"outer syntax\"<br>\n  logical language --- \"inner syntax\"</p>\n</blockquote>\n<p>If the phrase <code>Isar --- \"outer syntax\"</code> is being enforced ex post facto, it's <br>\nclear that I'm breaking the law.</p>\n<p>I immediately ask, \"If inner syntax is not Isar, what one word can I use to <br>\nlabel the language that's being used in inner syntax? 'Syntax' implies the <br>\nuse of a language.\"</p>\n<p>Suppose I'm told, \"It's not a language, but a logic.\" (Here, others' past <br>\nemphasis on the difference between a logic and a programming language <br>\ninterfered with me focusing on there being \"languages of logic\".)</p>\n</blockquote>\n<p>A logic is also a language.  So if you just say \"the logic\" or \"the <br>\nlogical language\", either for Isabelle/Pure or Isabelle/HOL, it will be <br>\nright.</p>\n<blockquote>\n<p>I say, \"Okay. It is what you say it is. In <code>A = B ==&gt; A = B</code>, it is clear <br>\nthat '==&gt;' is meta-logic or Pure, and that 'A = B' is HOL logic. There is a <br>\ncomplication, though, because I know that 'A = B' is being coercied to type <br>\nprop, so what is the one word to use to emphasize that <code>A = B</code> is both a <br>\nmeta-logic term and an object-logic term?\"</p>\n<p>If I'm told. \"There is no one word, you must use a lengthy phrase, or a word <br>\nthat is too general to capture the meaning of what you want to say.\"</p>\n</blockquote>\n<p>I am a big fan of the distinction of Isabelle/Pure vs. Isabelle/HOL, but <br>\nyou should not overemphasize Pure as \"the meta-logic\".  There is not much <br>\n\"meta\" going on here: you can't reason about other logics with Pure.</p>\n<p>Instead, what really happens is that you use Isabelle/Pure connectives !! <br>\nand ==&gt; to outline the structure of natural deduction rules that you want <br>\ndo use in everyday work in Isabelle/HOL.  So Pure is mainly a framework <br>\nwork higher-order natural deduction, with declarative composition of rules <br>\naccording to a few principles (notably higher-order unification).</p>\n<p>Makarius</p>",
        "id": 294249970,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910360
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nMakarius,</p>\n<p>I assume you read that other email. All that email was is a statement of <br>\nmy decision to finalize what I'm going to do, with some forewarning, in <br>\ncase it matters in the grand scheme of things.</p>\n<p>Any complaining and arguing I do is indirectly a note of thanks, where <br>\nI'm trying to limit how much I thank you. There's like 3 main features <br>\nof Isabelle as I see it, jEdit user interface, Isar language syntax, and <br>\na powerful logic engine which allows the control of proof steps from <br>\nprecise statements all the way to full automation. I don't know what the <br>\nlimitations of the software are, but there's nothing else on the market <br>\nlike Isabelle.</p>\n<p>You control the distribution, but as far as language, you're not in <br>\ncomplete control of the language.</p>\n<p>Most of what I'm saying can be represented by this statement: For me, <br>\nthere has to be one word for a language, call it \"NN\", in which I can <br>\nsay \"NN operator\", where \"NN operator\" refers to the three Pure <br>\noperators, ==&gt;, !!, and ==, along with any object logic operator in a <br>\nTHY file.</p>\n<p>When you give me one word for your choice of \"NN\", I'm thinking that's <br>\nwhen I'm ready to start conforming on this matter.</p>\n<p>Just consider me a representative of the users to come. I can't lose on <br>\nthis. The nature of things like art, philosophy, religion, politics, and <br>\ngeneral acts of creation is that there's continual evolution and <br>\nmorphing of one thing to another. People pick and choose what they want.</p>\n<p>Right now, I'm refusing to do any work with Isabelle, to force myself to <br>\nget up to speed on some audio/video software. If I'm more successful <br>\nthan you at getting a popular following, then it's possible I'll have <br>\nmore influence than you on how the word \"Isar\" is eventually used.</p>\n<p>No one can authoritatively correct me if there's nothing authoritative <br>\nto quote from. I've tried authoritatively quoting from mailing list <br>\nemails. It doesn't work for sorting out the complexities of the <br>\nvocabulary of Isabelle. It's regrettable that writing would take up <br>\nvaluable resources on your part, but I can't help that. However, mere <br>\nwriting wouldn't solve me not having a \"NN operator\", as I described.</p>\n<p>On 9/10/2013 8:13 AM, Makarius wrote:</p>\n<blockquote>\n<p>This is leading in the wrong direction; the level of abstraction does <br>\nnot matter here.  Isabelle/ML and Isabelle/Isar are both high-level <br>\nlanguages, but of quite different kind and purpose.</p>\n</blockquote>\n<p>So maybe for you, \"level\" means \"level of logic\", which you consider <br>\nwrong, rather than some common meaning like \"level of abstraction\". My <br>\nmain point was that you're fighting other common usages of the word <br>\n\"level\", and I don't see you winning. That {a_i} is notation for a <br>\nsequence is messed up, but nothing any time soon is going to change that <br>\nit's the dominant notation.</p>\n<blockquote>\n<p>I would say as first approximation it is fine to say \"Isabelle source <br>\ntext\" for any of the Isabelle languages.  You then become specific <br>\naccording to the context: Isabelle/ML, Isabelle/HOL etc.</p>\n</blockquote>\n<p>There are many places I could say this, but the vocabulary is too <br>\ncomplex. I don't actually care that the vocabulary is complex. I think I <br>\nunderstand enough for why you require it to be complex. It's too complex <br>\nwithout some document existing to enforce the vocabulary, along with the <br>\nvocabulary meeting more than just your needs.</p>\n<blockquote>\n<p>I am a big fan of the distinction of Isabelle/Pure vs. Isabelle/HOL, <br>\nbut you should not overemphasize Pure as \"the meta-logic\".  There is <br>\nnot much \"meta\" going on here: you can't reason about other logics <br>\nwith Pure.</p>\n</blockquote>\n<p>Many places in all this, we're crossing into Ph.D. logic territory, <br>\nwhere most mathematicians of the world (me not being one) don't <br>\nunderstand Ph.D. level logic anymore than I do, where I'm already above <br>\naverage as to understanding logic.</p>\n<p>As to the \"meta\" in \"meta-logic\", I quickly admit that I don't <br>\nunderstand in-depth the connection between meta-languages and <br>\nobject-languages.</p>\n<p>However, with Isabelle, I can take a purely definitional view of <br>\n\"meta-logic\" to mean the three operators ==&gt;, !!, and ==, along with <br>\nwhat I can do with them in a THY file.</p>\n<p>I myself, rather than one of the many Ph.Ds here, discovered that I can <br>\ndefine and use meta-false as (!!P. PROP P), along with what I call <br>\nhybrid-false, (!!P. P::bool), which end up giving me the standard <br>\nconnectives, without using ML.</p>\n<p>It could be I'm wasting my time pursuing this line of logic. Finding <br>\nthat out must wait until I work my way through the audio/video software.</p>\n<blockquote>\n<p>Instead, what really happens is that you use Isabelle/Pure connectives <br>\n!! and ==&gt; to outline the structure of natural deduction rules that <br>\nyou want do use in everyday work in Isabelle/HOL.  So Pure is mainly a <br>\nframework work higher-order natural deduction, with declarative <br>\ncomposition of rules according to a few principles (notably <br>\nhigher-order unification).</p>\n</blockquote>\n<p>I'm willing to recognize my lack of knowledge, and recognize others' <br>\nsuperior knowledge, but when the student learns enough, the student <br>\nbegins to challenge the master.</p>\n<p>I don't accept at all the limitation of Pure as a framework, with only 3 <br>\noperators, meant to be used only to defined object-logics. If my view of <br>\nPure is ridiculously narrow and trivializes the bulk of Pure's purpose, <br>\nwhat is that to me? I work in a THY file, see the three operators and <br>\nprop as the face of Pure, and have quit wanting to ignore them.</p>\n<p>I had asked myself this question, \"What are the limitations of using the <br>\nstandard logic connectives of Pure, without being able to add any axioms?\"</p>\n<p>I'm past that question.</p>\n<p>If I add global axioms to HOL, it's not HOL anymore. There is the <br>\npossibility, though, of adding axioms in locales in HOL, and using, as <br>\nmuch as possible, operators which are abbreviations of ==&gt;, !!, ==, and <br>\nmeta-false. That sounds like more than only using Pure as a framework. <br>\nIt's actually the concept that's important, not whether there's a fatal <br>\nflaw to prevent me from following through.</p>\n<p>If I spend a lot of time trying to do these things, and decide you've <br>\nbeen right all along, you're the man, along with many others. If it <br>\nleads to something great, you're still the man, along with many others. <br>\nI'm doing the easy part.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294250034,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910388
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nTo finish this perspective of more flexibile local definitions within <br>\nproofs, in conformance to 'definition' for local theories, the general <br>\nform would be like this:</p>\n<p>define f where \"f x y z = t\" for x y z</p>\n<p>All composed from standard parts that we have elsewhere for many years <br>\nalready.  (When it actually happens, further fine points will come <br>\nnaturally from \"deriving the implementation\" properly and carefully from <br>\nthe existing framework.)</p>\n<p>Makarius</p>",
        "id": 294250035,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910391
    }
]