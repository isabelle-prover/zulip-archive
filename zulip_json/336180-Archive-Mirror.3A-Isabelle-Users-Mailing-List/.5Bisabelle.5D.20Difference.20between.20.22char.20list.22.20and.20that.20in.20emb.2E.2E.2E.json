[
    {
        "content": "<p>From: ducis &lt;<a href=\"mailto:ducis_cn@126.com\">ducis_cn@126.com</a>&gt;<br>\nDear friends,<br>\n       I'm a new user to Isabelle/HOL, trying to loading some external data following <br>\nthe instruction in \"A.4 Calling ML Functions from within HOL.\" in \"The Isabelle Cookbook (draft)\".<br>\nWhile I was able to get the example to work, I am unable to modify it to produce string output.<br>\nNeither have I found such cases on Stackoverflow or in the PDFs accompanying the distribution.</p>\n<p>For example, I have the following code:<br>\n===================================================================<br>\nML ‹ <br>\n(*fun ls x = Isabelle_System.bash_output (\"ls \" ^ (String.implode x)) |&gt; fst |&gt; String.explode;*)<br>\nfun lsA n = if n=4 then [] else ([]:char list);<br>\nfun lsB n = if n=4 then \"\" else \"abc\";<br>\nfun lsC n = if n=4 then 5 else 10;<br>\n›<br>\nconsts lsAA :: \"nat ⇒ char list\"<br>\ndefinition ls1 :: \"integer ⇒ char list\"<br>\nwhere [code del]: \"ls1 = lsAA ∘ nat_of_integer\"<br>\nlemma [code]: \"lsAA = ls1 ∘ integer_of_nat\" by (simp add: ls1_def fun_eq_iff)<br>\ncode_printing constant ls1 ⇀ (SML) \"lsA\"</p>\n<p>consts lsBB :: \"nat ⇒ string\"<br>\ndefinition ls2 :: \"integer ⇒ string\"<br>\nwhere [code del]: \"ls2 = lsBB ∘ nat_of_integer\"<br>\nlemma [code]: \"lsBB = ls2 ∘ integer_of_nat\" by (simp add: ls2_def fun_eq_iff)<br>\ncode_printing constant ls2 ⇀ (SML) \"lsB\"</p>\n<p>consts lsCC :: \"nat ⇒ nat\"<br>\ndefinition ls3 :: \"integer ⇒ integer\"<br>\nwhere [code del]: \"ls3 = integer_of_nat ∘ lsCC ∘ nat_of_integer\"<br>\nlemma [code]: \"lsCC = nat_of_integer ∘ ls3 ∘ integer_of_nat\" by (simp add: ls3_def fun_eq_iff)<br>\ncode_printing constant ls3 ⇀ (SML) \"lsC\"</p>\n<p>value \"lsAA 1\"  (* outputs \"ls1 1\"  :: \"char list\" *)<br>\nvalue \"lsBB 1\"  (* outputs \"ls2 1\" :: \"char list\" *)<br>\nvalue \"lsCC 1\"  (* outputs \"10\" :: \"nat\" *)<br>\n=====================================================================</p>\n<p>It seems that the result of calling ML functions lsA and lsB fail to be converted into the \"char list\" in the Isabelle context.<br>\nHow could I have ' value \"lsAA 1\" ' or ' value \"lsBB 1\" ' to produce ' [] :: \"char list\" '  or ' \"abc\" :: \"char list\" ?<br>\nAnd how can the ML function take a \"char list\" as its input?</p>\n<p>Best,<br>\nDu</p>",
        "id": 294713152,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182871
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Du,</p>\n<p>The character types in Isabelle/HOL and in SML (or Isabelle/ML) are by default not <br>\nconnected to each other. The only HOL types for exchanging data between Isabelle/HOL <br>\nfunctions and ML code are unit, bool, list, integer, and String.literal. The Isabelle/HOL <br>\nlibrary defines a few further types, e.g., char in ~~/src/HOL/Library/Code_Char\". If you <br>\nimport this theory, then the generated code will use the default SML char type for HOL <br>\ncharacters, and your code_printing adaptations work.</p>\n<p>However, note that you should make sure that your SML implementation correspond to their <br>\nHOL specification. As is, lsAA, lsBB and lsCC are unspecified. This is fine as long as <br>\nyour implementations lsA, lsB, and lsC do not depend on side effects.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294713338,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182934
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 04/07/17 18:49, ducis wrote:</p>\n<blockquote>\n<p>I'm a new user to Isabelle/HOL, trying to loading some external data following <br>\nthe instruction in \"A.4 Calling ML Functions from within HOL.\" in \"The Isabelle Cookbook (draft)\".</p>\n</blockquote>\n<p>I did not follow the further development of this Cookbook project in<br>\nrecent years, and can't say how relevant it is today for using Isabelle/ML.</p>\n<p>The main manual for Isabelle/ML programming within the official<br>\ndistribution is called \"implementation\" (e.g. see the Documentation<br>\npanel in the Prover IDE).</p>\n<blockquote>\n<p>For example, I have the following code:<br>\n===================================================================<br>\nML ‹ <br>\n(*fun ls x = Isabelle_System.bash_output (\"ls \" ^ (String.implode x)) |&gt; fst |&gt; String.explode;*)<br>\nfun lsA n = if n=4 then [] else ([]:char list);<br>\nfun lsB n = if n=4 then \"\" else \"abc\";<br>\nfun lsC n = if n=4 then 5 else 10;<br>\n›<br>\nconsts lsAA :: \"nat ⇒ char list\"<br>\ndefinition ls1 :: \"integer ⇒ char list\"<br>\nwhere [code del]: \"ls1 = lsAA ∘ nat_of_integer\"<br>\nlemma [code]: \"lsAA = ls1 ∘ integer_of_nat\" by (simp add: ls1_def fun_eq_iff)<br>\ncode_printing constant ls1 ⇀ (SML) \"lsA\"</p>\n</blockquote>\n<p>What is the motivation for using HOL -&gt; ML code generation in the first<br>\nplace? You can write Isabelle/ML sources directly, e.g. to produce<br>\nlogical term syntax and feed it into the formal context, lets say in a<br>\ngoal state or as definitions in the target theory.</p>\n<p>Here is a minimal example.</p>\n<p>The result of \"ls\" as a term of the HOL logic:</p>\n<p>ML ‹<br>\nfun ls_term dir =<br>\n  Isabelle_System.bash_output (\"ls \" ^ File.bash_path dir)<br>\n  |&gt; #1 |&gt; HOLogic.mk_string;<br>\n›</p>\n<p>Note that giving arguments to external processes (done via GNU bash<br>\nhere) always requires proper quoting. The File.bash_path function of<br>\nIsabelle/ML does that in a robust way.</p>\n<p>A concrete example, printed in regular notation:</p>\n<p>ML ‹<br>\n  val t = ls_term (Path.explode \"$ISABELLE_HOME/src\");<br>\n  val ctxt = @{context};<br>\n  writeln (Syntax.string_of_term ctxt t);<br>\n›</p>\n<p>This demonstrates how to define a constant in the target theory:</p>\n<p>ML ‹<br>\nfun ls_definition binding dir =<br>\n  Local_Theory.define ((binding, NoSyn), ((Thm.def_binding binding, []),<br>\nls_term dir));<br>\n›</p>\n<p>local_setup ‹#2 o ls_definition @{binding test} (Path.explode<br>\n\"$ISABELLE_HOME/src\")›<br>\nterm test<br>\nthm test_def</p>\n<p>I recommend to use the Prover IDE to explore these ML snippets, e.g. to<br>\nsee inferred types of sub-expressions and to follow formal links to the<br>\ndefinitions.</p>\n<p>If you want to browse formally through the main Isabelle/ML corpus, you<br>\nneed to open \"$ISABELLE_HOME/src/Pure/ROOT.ML\" to get to active source<br>\nfiles eventually, such as<br>\n\"$ISABELLE_HOME/src/Pure/System/isabelle_system.ML\"</p>\n<p>It is also important to look at examples -- always in the formal Prover IDE.</p>\n<p>Makarius</p>",
        "id": 294713552,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183002
    }
]