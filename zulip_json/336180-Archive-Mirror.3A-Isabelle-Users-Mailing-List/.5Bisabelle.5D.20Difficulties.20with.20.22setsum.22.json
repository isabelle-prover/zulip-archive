[
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>While trying to prove the correctness of a simple function that returns<br>\nthe sum of the values between integers  l and u, I stumbled upon<br>\nan unexpected problem: I was ano able to prove that</p>\n<p>(Sum k=l..(u+1). k) = (u+1) + (Sum k=l...u) if l&lt;u+1, which should<br>\nhold by the  definition of an indexed sum.</p>\n<p>My thy file is attached and, in the proof, is the only line with \"sorry\".<br>\nI would very grateful if anyone could take a quick look at that.</p>\n<p>To get a better feeling of what are the underlying simplification rules,<br>\nI performed some tests with setsum, but the results were disappointing.<br>\n(see below).</p>\n<p>Besides, acoording to \"What is is Main\", setsum is defined in \"Finite_Set\",<br>\nbut in Isabelle 2014 it is defined  in \"Groups_Big\".</p>\n<p>(* Testing the setsum function                            *)<br>\nfun i2n::\"int ⇒ nat\" where<br>\n\"i2n x = (if x ≤ 0 then 0 else Suc (i2n (x - 1)))\"</p>\n<p>value  \"int (setsum id {1::nat..5})\" (* this works *)<br>\nlemma  \"setsum id {1::nat..2} = (Suc (Suc (Suc 0)))\"<br>\n   apply (auto) oops<br>\nlemma \"setsum id {1::nat..5}= i2n 15\"<br>\n    apply (auto) oops<br>\nlemma  \"(setsum id {1::nat..2})= Suc (Suc (Suc 0))\"<br>\n    apply (auto) oops<br>\nlemma  \"(∑ k::nat ∈ {j. 1≤j ∧ j≤3}. k) = 6\"<br>\n     apply  oops<br>\nlemma  \"(∑ k::nat | k≥1 ∧ k≤2 . k) = Suc (Suc (Suc 0))\"<br>\n   apply (auto) oops<br>\nlemma \"(∑ k::nat=1..3. k)= (∑ k=1..2. k) + 3\" oops<br>\nterm \"∑ k=1..n. k\"<br>\nvalue \"∑ k::nat = 2 ..1. k\" (* this works *)<br>\n(*  end of test                                            *)</p>\n<p>All the Best!<br>\n<a href=\"/user_uploads/14278/DTLInqI4w4N5BrOKl4RXmcF-/SumInt.thy\">SumInt.thy</a></p>",
        "id": 294635787,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160075
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nSorry, there was a typo in the previous theory file. It is attached again.</p>\n<p>Best!<br>\n---------- Forwarded message ----------<br>\nFrom: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDate: Wed, Apr 22, 2015 at 11:46 AM<br>\nSubject: Difficulties with \"setsum\"<br>\nTo: \"<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>\" &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;</p>\n<p>Dear Isabelle Users,</p>\n<p>While trying to prove the correctness of a simple function that returns<br>\nthe sum of the values between integers  l and u, I stumbled upon<br>\nan unexpected problem: I was ano able to prove that</p>\n<p>(Sum k=l..(u+1). k) = (u+1) + (Sum k=l...u) if l&lt;u+1, which should<br>\nhold by the  definition of an indexed sum.</p>\n<p>My thy file is attached and, in the proof, is the only line with \"sorry\".<br>\nI would very grateful if anyone could take a quick look at that.</p>\n<p>To get a better feeling of what are the underlying simplification rules,<br>\nI performed some tests with setsum, but the results were disappointing.<br>\n(see below).</p>\n<p>Besides, acoording to \"What is is Main\", setsum is defined in \"Finite_Set\",<br>\nbut in Isabelle 2014 it is defined  in \"Groups_Big\".</p>\n<p>(* Testing the setsum function                            *)<br>\nfun i2n::\"int ⇒ nat\" where<br>\n\"i2n x = (if x ≤ 0 then 0 else Suc (i2n (x - 1)))\"</p>\n<p>value  \"int (setsum id {1::nat..5})\" (* this works *)<br>\nlemma  \"setsum id {1::nat..2} = (Suc (Suc (Suc 0)))\"<br>\n   apply (auto) oops<br>\nlemma \"setsum id {1::nat..5}= i2n 15\"<br>\n    apply (auto) oops<br>\nlemma  \"(setsum id {1::nat..2})= Suc (Suc (Suc 0))\"<br>\n    apply (auto) oops<br>\nlemma  \"(∑ k::nat ∈ {j. 1≤j ∧ j≤3}. k) = 6\"<br>\n     apply  oops<br>\nlemma  \"(∑ k::nat | k≥1 ∧ k≤2 . k) = Suc (Suc (Suc 0))\"<br>\n   apply (auto) oops<br>\nlemma \"(∑ k::nat=1..3. k)= (∑ k=1..2. k) + 3\" oops<br>\nterm \"∑ k=1..n. k\"<br>\nvalue \"∑ k::nat = 2 ..1. k\" (* this works *)<br>\n(*  end of test                                            *)</p>\n<p>All the Best!</p>\n<p>-- <br>\nAlfio Ricardo Martini<br>\nPhD in Computer Science (TU Berlin)<br>\nAssociate Professor at Faculty of Informatics (PUCRS)<br>\n<a href=\"http://www.inf.pucrs.br/alfio\">www.inf.pucrs.br/alfio</a><br>\nAv. Ipiranga, 6681 - Prédio 32 - Faculdade de Informática<br>\n90619-900 -Porto Alegre - RS - Brasil</p>\n<p>-- <br>\nAlfio Ricardo Martini<br>\nPhD in Computer Science (TU Berlin)<br>\nAssociate Professor at Faculty of Informatics (PUCRS)<br>\n<a href=\"http://www.inf.pucrs.br/alfio\">www.inf.pucrs.br/alfio</a><br>\nAv. Ipiranga, 6681 - Prédio 32 - Faculdade de Informática<br>\n90619-900 -Porto Alegre - RS - Brasil<br>\n<a href=\"/user_uploads/14278/LxP50cmN2Q5MIA4JpFduum4p/SumInt.thy\">SumInt.thy</a></p>",
        "id": 294635804,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160082
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThe problem is that in order to \"unroll\" the setsum, you first have to <br>\nbring the numerals (e.g. 2, 3, 4) into successor notation. One way to do <br>\nthis is to add eval_nat_numeral to your simpset, e.g.</p>\n<p>apply (auto simp: eval_nat_numeral)</p>\n<p>Most of your example work automatically with these, but you will have to <br>\nmassage expressions like \"(∑ k::nat ∈ {j. 1≤j ∧ j≤3}. k)\" by hand a bit <br>\nfirst, e.g. by proving that \"{j. 1≤j ∧ j≤3} = {1..3}\".</p>\n<p>One could easily write simplification rules that unroll setsums over <br>\nconstant intervals like these automatically or even write a simproc that <br>\ndoes that, but I don't think that would be very helpful in practice.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294635826,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160090
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nHi Manuel,</p>\n<p>Thanks for the feedback. But in my proof, I am working with integers and<br>\nthat line<br>\nwith \"sorry\" does not get proved with this lemma. The line with \"sorry\"<br>\naddresses the very definition<br>\nof indexed sums, I think.</p>\n<p>Best!</p>",
        "id": 294635845,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160099
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nHi,</p>\n<p>I think that the main problem is that the automatic methods cannot cope<br>\nwith following trivial<br>\nlemmas, although both sides evaluate correctly with the command 'value',</p>\n<p>value \"(setsum id {1::int..2}) + (3::int)\"<br>\nvalue \"(setsum id {1::int..3})\"<br>\nlemma \"(setsum id {1::int..3}) = (setsum id {1..2}) + 3\" oops<br>\nvalue \"(setsum id {-3::int..3})\"<br>\nvalue \"(setsum id {-3::int..2}) + 3\"<br>\nlemma \"(setsum id {-3::int..3}) = (setsum id {-3..2}) + 3\" oops</p>\n<p>I tried sledgehammer  but it does not find anything. Anyway, the last time<br>\nsledgehammer worked<br>\nfine for me was with Isabelle 2012.</p>\n<p>Best!</p>",
        "id": 294635895,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160119
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nHi Alfio,</p>\n<p>Your sorry can be proved by:</p>\n<p>also have \"... = (∑ k=l..i+1. k)\"<br>\n     proof -<br>\n       have \"{l..i + 1} = insert (i+1) {l..i}\" using hip02 by auto<br>\n       thus ?thesis by simp<br>\n     qed</p>\n<p>Also note, goals like this:</p>\n<p>lemma \"(setsum id {1::int..3}) = (setsum id {1..2}) + 3\"</p>\n<p>if both sides can be evaluated to the same value, you can discharge the <br>\ngoal by \"eval\".</p>\n<p>Cheers,<br>\nWenda</p>",
        "id": 294635903,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160121
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\n---------- Forwarded message ----------<br>\nFrom: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDate: Wed, Apr 22, 2015 at 2:17 PM<br>\nSubject: Re: [isabelle] Difficulties with \"setsum\"<br>\nTo: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;</p>\n<p>Hi Wenda,</p>\n<blockquote>\n<p>if both sides can be evaluated to the same value, you can discharge the<br>\ngoal by \"eval\"</p>\n</blockquote>\n<p>Great. Did not know this.</p>\n<p>also have \"... = (∑ k=l..i+1. k)\"</p>\n<blockquote>\n<p>proof -<br>\n      have \"{l..i + 1} = insert (i+1) {l..i}\" using hip02 by auto<br>\n      thus ?thesis by simp<br>\n    qed</p>\n</blockquote>\n<p>Very clever. Thanks a lot!!</p>\n<p>Best!</p>\n<p>On Wed, Apr 22, 2015 at 2:07 PM, Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Alfio,</p>\n<p>Your sorry can be proved by:</p>\n<p>also have \"... = (∑ k=l..i+1. k)\"<br>\n    proof -<br>\n      have \"{l..i + 1} = insert (i+1) {l..i}\" using hip02 by auto<br>\n      thus ?thesis by simp<br>\n    qed</p>\n<p>Also note, goals like this:</p>\n<p>lemma \"(setsum id {1::int..3}) = (setsum id {1..2}) + 3\"</p>\n<p>if both sides can be evaluated to the same value, you can discharge the<br>\ngoal by \"eval\".</p>\n<p>Cheers,<br>\nWenda</p>\n<p>On 2015-04-22 17:24, Alfio Martini wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I think that the main problem is that the automatic methods cannot cope<br>\nwith following trivial<br>\nlemmas, although both sides evaluate correctly with the command 'value',</p>\n<p>value \"(setsum id {1::int..2}) + (3::int)\"<br>\nvalue \"(setsum id {1::int..3})\"<br>\nlemma \"(setsum id {1::int..3}) = (setsum id {1..2}) + 3\" oops<br>\nvalue \"(setsum id {-3::int..3})\"<br>\nvalue \"(setsum id {-3::int..2}) + 3\"<br>\nlemma \"(setsum id {-3::int..3}) = (setsum id {-3..2}) + 3\" oops</p>\n<p>I tried sledgehammer  but it does not find anything. Anyway, the last time<br>\nsledgehammer worked<br>\nfine for me was with Isabelle 2012.</p>\n<p>Best!<br>\n</p>\n</blockquote>\n<p>On Wed, Apr 22, 2015 at 12:00 PM, Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>The problem is that in order to \"unroll\" the setsum, you first have to</p>\n<blockquote>\n<p>bring the numerals (e.g. 2, 3, 4) into successor notation. One way to do<br>\nthis is to add eval_nat_numeral to your simpset, e.g.</p>\n<p>apply (auto simp: eval_nat_numeral)</p>\n<p>Most of your example work automatically with these, but you will have to<br>\nmassage expressions like \"(∑ k::nat ∈ {j. 1≤j ∧ j≤3}. k)\" by hand a bit<br>\nfirst, e.g. by proving that \"{j. 1≤j ∧ j≤3} = {1..3}\".</p>\n<p>One could easily write simplification rules that unroll setsums over<br>\nconstant intervals like these automatically or even write a simproc that<br>\ndoes that, but I don't think that would be very helpful in practice.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n</blockquote>\n<p>On 22/04/15 16:46, Alfio Martini wrote:</p>\n<blockquote>\n<p>Dear Isabelle Users,</p>\n<blockquote>\n<p>While trying to prove the correctness of a simple function that returns<br>\nthe sum of the values between integers  l and u, I stumbled upon<br>\nan unexpected problem: I was ano able to prove that</p>\n<p>(Sum k=l..(u+1). k) = (u+1) + (Sum k=l...u) if l&lt;u+1, which should<br>\nhold by the  definition of an indexed sum.</p>\n<p>My thy file is attached and, in the proof, is the only line with<br>\n\"sorry\".<br>\nI would very grateful if anyone could take a quick look at that.</p>\n<p>To get a better feeling of what are the underlying simplification rules,<br>\nI performed some tests with setsum, but the results were disappointing.<br>\n(see below).</p>\n<p>Besides, acoording to \"What is is Main\", setsum is defined in<br>\n\"Finite_Set\",<br>\nbut in Isabelle 2014 it is defined  in \"Groups_Big\".</p>\n<p>(* Testing the setsum function                            *)<br>\nfun i2n::\"int ⇒ nat\" where<br>\n\"i2n x = (if x ≤ 0 then 0 else Suc (i2n (x - 1)))\"</p>\n<p>value  \"int (setsum id {1::nat..5})\" (* this works *)<br>\nlemma  \"setsum id {1::nat..2} = (Suc (Suc (Suc 0)))\"<br>\n    apply (auto) oops<br>\nlemma \"setsum id {1::nat..5}= i2n 15\"<br>\n     apply (auto) oops<br>\nlemma  \"(setsum id {1::nat..2})= Suc (Suc (Suc 0))\"<br>\n     apply (auto) oops<br>\nlemma  \"(∑ k::nat ∈ {j. 1≤j ∧ j≤3}. k) = 6\"<br>\n      apply  oops<br>\nlemma  \"(∑ k::nat | k≥1 ∧ k≤2 . k) = Suc (Suc (Suc 0))\"<br>\n    apply (auto) oops<br>\nlemma \"(∑ k::nat=1..3. k)= (∑ k=1..2. k) + 3\" oops<br>\nterm \"∑ k=1..n. k\"<br>\nvalue \"∑ k::nat = 2 ..1. k\" (* this works *)<br>\n(*  end of test                                            *)</p>\n<p>All the Best!</p>\n</blockquote>\n<p>--<br>\nWenda Li<br>\nPhD Candidate<br>\nComputer Laboratory<br>\nUniversity of Cambridge<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>-- <br>\nAlfio Ricardo Martini<br>\nPhD in Computer Science (TU Berlin)<br>\nAssociate Professor at Faculty of Informatics (PUCRS)<br>\n<a href=\"http://www.inf.pucrs.br/alfio\">www.inf.pucrs.br/alfio</a><br>\nAv. Ipiranga, 6681 - Prédio 32 - Faculdade de Informática<br>\n90619-900 -Porto Alegre - RS - Brasil</p>\n<p>-- <br>\nAlfio Ricardo Martini<br>\nPhD in Computer Science (TU Berlin)<br>\nAssociate Professor at Faculty of Informatics (PUCRS)<br>\n<a href=\"http://www.inf.pucrs.br/alfio\">www.inf.pucrs.br/alfio</a><br>\nAv. Ipiranga, 6681 - Prédio 32 - Faculdade de Informática<br>\n90619-900 -Porto Alegre - RS - Brasil</p>",
        "id": 294635944,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160129
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nNote that 'eval' does not go through the kernel and is generally<br>\nconsidered bad style (except for maybe exploratory purposes).</p>\n<p>Fortunately, there's an alternative:</p>\n<p>lemma \"(setsum id {1::int..3}) = (setsum id {1..2}) + 3\"<br>\n  by code_simp</p>\n<p>This sets uses the same code equations as 'eval' (as far as I know), but<br>\ngoes through the kernel (by invoking the simplifier).</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294635956,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160133
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 22/04/2015 21:17, Lars Hupel wrote:</p>\n<blockquote>\n<blockquote>\n<p>lemma \"(setsum id {1::int..3}) = (setsum id {1..2}) + 3\"</p>\n<p>if both sides can be evaluated to the same value, you can discharge the<br>\ngoal by \"eval\".</p>\n</blockquote>\n<p>Note that 'eval' does not go through the kernel and is generally<br>\nconsidered bad style (except for maybe exploratory purposes).</p>\n</blockquote>\n<p>I disagree. I have seen too many people wasting their time trying to achieve <br>\nsomething by \"pure inference\" that eval will do without blinking an eye. There <br>\nis no evidence that the evaluator is less reliable than the inference kernel. Of <br>\ncourse in this example you may as well use code_simp, but the latter can be <br>\nprohibitively slow.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Fortunately, there's an alternative:</p>\n<p>lemma \"(setsum id {1::int..3}) = (setsum id {1..2}) + 3\"<br>\n   by code_simp</p>\n<p>This sets uses the same code equations as 'eval' (as far as I know), but<br>\ngoes through the kernel (by invoking the simplifier).</p>\n<p>Cheers<br>\nLars</p>\n<p><a href=\"/user_uploads/14278/rrqHtkc7ksTCOxNC4klQq2bz/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294635990,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160147
    }
]