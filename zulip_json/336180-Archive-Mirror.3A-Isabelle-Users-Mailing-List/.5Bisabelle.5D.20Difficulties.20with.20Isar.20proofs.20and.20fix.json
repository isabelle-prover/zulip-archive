[
    {
        "content": "<p>From: Denis Bueno &lt;<a href=\"mailto:dbueno@gmail.com\">dbueno@gmail.com</a>&gt;<br>\nHi all,</p>\n<p>I'm having trouble with a proof skeleton that seems like it should<br>\nwork (judging from what I've seen from the Isar tutorial and manual),<br>\nbut I can't get it to, and I'm not sure why.</p>\n<p>Basically I have a theorem whose conclusion is of the form: ALL x. ...<br>\n(EX y. ... (ALL z. ...)).  I would like to show this by fix'ing an<br>\narbitrary x, exhibiting a y, and fix'ing an arbitrary z, then<br>\nsatisfying the respective bodies of each quantification.  Something<br>\nsimilar is done as the last example in section 2.4 of the Isar<br>\ntutorial, and it is this example which I'm trying to emulate.</p>\n<p>For what it's worth, I've already proved this theorem in a low-level<br>\nstyle with a bunch of apply's and tactics.  I'm trying to convert this<br>\nto a real Isar proof (not just one that embeds the apply-style proof).</p>\n<p>theorem proposition_1_oif:<br>\n  assumes S_Prop: \"S : Prop\"<br>\n  and     S_SP:   \"S : SP\"<br>\n  shows   lift_S_SHP: \"[[S]] : SHP\"<br>\napply (unfold SHP_def, unfold shp_def)<br>\napply (simp)<br>\n(* at this point the goal is:<br>\nALL T. T : Prop &amp; T ~: [[ S ]] --&gt;<br>\n           (EX M. M : Obs &amp; M &lt;| T &amp; (ALL T'. T' : Prop &amp; M &lt;| T' --&gt;<br>\nT' ~: [[ S ]]))<br>\n*)<br>\nproof<br>\n  fix T :: property<br>\n  assume T_st: \"T : Prop\" \"T ~: [[S]]\"</p>\n<p>obtain M where M_st: \"M : Obs\" \"M &lt;| T\" sorry</p>\n<p>fix T' :: property<br>\n  assume T'_st: \"T' : Prop\" \"M &lt;| T'\"</p>\n<p>hence \"T' ~: [[ S ]]\" sorry<br>\n  with T'_st have \"T' : Prop &amp; M &lt;| T' --&gt; T' ~: [[ S ]]\" by blast<br>\n  hence \"ALL T'. T' : Prop &amp; M &lt;| T' --&gt; T' ~: [[ S ]]\" ..</p>\n<p>The last step in the proof fails.  I'm not sure why, since it seems to<br>\nme that using the T' fix'd at the beginning, along with its relevant<br>\nconstraints, one should be able to show the last goal.  The informal<br>\nargument goes, \"Since T' was arbitrary, we know that for *all such<br>\nT'*, such-and-such holds.\"</p>\n<p>What have I done wrong?</p>",
        "id": 294057007,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821980
    },
    {
        "content": "<p>From: Amine Chaieb &lt;<a href=\"mailto:chaieb@in.tum.de\">chaieb@in.tum.de</a>&gt;<br>\nHi Denis,</p>\n<p>I was not able to reproduce your example due to lack of notation (what <br>\nis the &lt;| ?).</p>\n<p>Any way, to this kind of reasoning in Isar, you should use the \"{\" and <br>\n\"}\" brackets. This is like a new sheet of paper you take and prove <br>\nsomething new on it.</p>\n<p>So something like<br>\n  proof<br>\n    fix T :: property<br>\n    assume T_st: \"T : Prop\" \"T ~: [[S]]\"</p>\n<p>obtain M where M_st: \"M : Obs\" \"M &lt;| T\" sorry</p>\n<p>{<br>\n    fix T' :: property<br>\n    assume T'_st: \"T' : Prop\" \"M &lt;| T'\"</p>\n<p>hence \"T' ~: [[ S ]]\" sorry<br>\n    with T'_st have \"T' : Prop &amp; M &lt;| T' --&gt; T' ~: [[ S ]]\" by blast<br>\n}<br>\n    hence \"ALL T'. T' : Prop &amp; M &lt;| T' --&gt; T' ~: [[ S ]]\" ..</p>\n<p>When you leave the context of the brackets, you will see that Isar <br>\nalready generalizes your result, i.e. the have \"T' : Prop &amp; M &lt;| T' --&gt; <br>\nT' ~: [[ S ]]\" <em>inside</em> the brackets, becomes</p>\n<p>\"?T' : Prop &amp; M &lt;| ?T' --&gt; ?T' ~: [[ S ]]\"</p>\n<p>i.e. generalized for arbitrary T' of type property.</p>\n<p>Hope this helps.</p>\n<p>Amine.</p>\n<p>Denis Bueno wrote:</p>",
        "id": 294057020,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821985
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 25 Feb 2008, Denis Bueno wrote:</p>\n<blockquote>\n<p>Basically I have a theorem whose conclusion is of the form: ALL x. ...<br>\n(EX y. ... (ALL z. ...)).  I would like to show this by fix'ing an<br>\narbitrary x, exhibiting a y, and fix'ing an arbitrary z, then<br>\nsatisfying the respective bodies of each quantification.</p>\n</blockquote>\n<p>Here is your proof in Isar:</p>\n<p>lemma \"ALL x :: 'a. EX y :: 'b. ALL z :: 'c. P x y z\"<br>\nproof<br>\n  fix a :: 'a<br>\n  def b == \"t :: 'b\"<br>\n  have \"ALL z. P a b z\" <br>\n  proof<br>\n    fix c<br>\n    show \"P a b c\" sorry<br>\n  qed<br>\n  then show \"EX y. ALL z. P a y z\" ..<br>\nqed</p>\n<p>(Note that type constraints are needed here, because of the fully abstract <br>\nformulation of the problem and sub-problems.)</p>\n<p>Isar is very ``puristic'' in the sense in being ignorant of predicate <br>\nlogic.  The native way of expressing statements and proofs is via the <br>\nIsabelle/Pure logical framework, which provides very powerful means to <br>\nwork with higher-order Natural Deduction rules.  Maybe the paper <br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/isar-framework.pdf\">http://www4.in.tum.de/~wenzelm/papers/isar-framework.pdf</a> helps to <br>\nunderstand the basic approach.</p>\n<p>In the above text there are certain situations where single introduction <br>\nor elimination rules get involved; these are made explicit here:</p>\n<p>lemma \"ALL x :: 'a. EX y :: 'b. ALL z :: 'c. P x y z\"<br>\nproof (rule allI)<br>\n  fix a :: 'a<br>\n  def b == \"t :: 'b\"<br>\n  have \"ALL z. P a b z\" <br>\n  proof (rule allI)<br>\n    fix c<br>\n    show \"P a b c\" sorry<br>\n  qed<br>\n  then show \"EX y. ALL z. P a y z\" by (rule exI)<br>\nqed</p>\n<p>This is indeed a bit awkward, so one could blame Isar for not supporting <br>\n``standard'' logical connectives more directly.  On the other hand, by <br>\nmaking proper use of Pure principles, things work out smoothly not just <br>\nfor ALL/EX, but any concept you have introduced in your application.  The <br>\nidea is to derive intro/elim rules from your definitions, or even better <br>\nlet the system do it for you (using the 'inductive' package) as hinted in <br>\nsection 4.6 of the above article.</p>\n<blockquote>\n<p>theorem proposition_1_oif:<br>\n  assumes S_Prop: \"S : Prop\"<br>\n  and     S_SP:   \"S : SP\"<br>\n  shows   lift_S_SHP: \"[[S]] : SHP\"<br>\napply (unfold SHP_def, unfold shp_def)<br>\napply (simp)<br>\n(* at this point the goal is:<br>\nALL T. T : Prop &amp; T ~: [[ S ]] --&gt;<br>\n           (EX M. M : Obs &amp; M &lt;| T &amp; (ALL T'. T' : Prop &amp; M &lt;| T' --&gt;<br>\nT' ~: [[ S ]]))<br>\n*)<br>\nproof<br>\n  fix T :: property<br>\n  assume T_st: \"T : Prop\" \"T ~: [[S]]\"</p>\n<p>obtain M where M_st: \"M : Obs\" \"M &lt;| T\" sorry</p>\n<p>fix T' :: property<br>\n  assume T'_st: \"T' : Prop\" \"M &lt;| T'\"</p>\n<p>hence \"T' ~: [[ S ]]\" sorry<br>\n  with T'_st have \"T' : Prop &amp; M &lt;| T' --&gt; T' ~: [[ S ]]\" by blast<br>\n  hence \"ALL T'. T' : Prop &amp; M &lt;| T' --&gt; T' ~: [[ S ]]\" ..</p>\n</blockquote>\n<p>If you provide a working theory, we can play with it a little.  For the <br>\nmoment here are some general hints:</p>\n<p>* The abbreviations 'hence' for 'then have' and 'thus' for 'then show' <br>\n    are better avoided, because they demand much more typing.  This <br>\n    paradox is explained by the experience that the goal prefixing often <br>\n    changes in proof development and massaging, e.g. 'then have' vs. 'from <br>\n    blah have' vs. 'with blubb have' etc.</p>\n<p>* Local facts can be referenced literally, e.g. <code>S : Prop</code> (with ASCII <br>\n    backquotes); no need to emulate the structure of statements in names <br>\n    like S_Prop.</p>\n<p>Makarius</p>",
        "id": 294057033,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821995
    },
    {
        "content": "<p>From: Denis Bueno &lt;<a href=\"mailto:dbueno@gmail.com\">dbueno@gmail.com</a>&gt;<br>\nThank you all for your replies.  While I digest them, attached is the<br>\ntheory, so that you can play with it.  It requires the LList2 library<br>\n(lazy, infinite lists) available at<br>\n<a href=\"http://afp.sourceforge.net/entries/Lazy-Lists-II.shtml\">http://afp.sourceforge.net/entries/Lazy-Lists-II.shtml</a>.  I'd<br>\nappreciate any comments on my theory.<br>\n<a href=\"/user_uploads/14278/mafk2ohmUfhGYw-kEnnb2Jzk/Hyper.thy\">Hyper.thy</a></p>",
        "id": 294057051,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822010
    },
    {
        "content": "<p>From: Denis Bueno &lt;<a href=\"mailto:dbueno@gmail.com\">dbueno@gmail.com</a>&gt;<br>\nWell, I've completed the theorem I was having trouble with.  It is<br>\nquite a bit longer than the apply-style proof, though much clearer.<br>\nAny comments that would help me improve its readability and<br>\nconciseness are welcome.  Thank you, Makarius and Amine, for your<br>\nadvice.</p>",
        "id": 294057076,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822022
    },
    {
        "content": "<p>From: Denis Bueno &lt;<a href=\"mailto:dbueno@gmail.com\">dbueno@gmail.com</a>&gt;<br>\nI forgot to attach the proof to the email.  Sorry about that.</p>\n<p>It's attached.<br>\n<a href=\"/user_uploads/14278/WpzyUpCPnoz2YTBDCbD4A1hK/Hyper.thy\">Hyper.thy</a></p>",
        "id": 294057088,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822029
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI've started to look at your proofs, which are quite impressive as your <br>\nsecond attempt in Isar reasoning only.</p>\n<p>One reason why things turn out a bit long is the general strategy of <br>\nreducing things to predicate logic first, exposing it in the text, and <br>\nthen blasting your way through the thicked of quantifiers.  Even in your <br>\napply scripts, there have been these unfoldings of Pow_def, subset_def <br>\netc. followed by blast.</p>\n<p>By proving derived natural deduction rules (and declaring them to the <br>\nsystem as intro/elim, simp/iff etc.) you can work more smoothly without <br>\nthe detour through the object-logic.  This simplifies both apply scripts <br>\nand Isar texts.</p>\n<p>Moreover, in proper Isar you can usually avoid extra <code>boiler plate \nstatements'' like </code>have EX x. P x'' before continuing to ``obtain x <br>\nwhere P x'' --- the latter alone is usually sufficient.  Here is a <br>\nconcrete example from your proof of theorem proposition_1_oif:</p>\n<p>fix T :: property<br>\n    assume T_st: \"T : Prop\" \"T ~: [[S]]\"</p>\n<p>have t_is: \"EX t:T. t ~: S\"<br>\n    proof -<br>\n      from T_st have T_not_under_S: \"~(T &lt;= S)\"<br>\n        unfolding property_lift_def by blast<br>\n      thus ?thesis unfolding subset_def by blast<br>\n    qed<br>\n    then obtain t where t_st: \"t : T\" \"t ~: S\" ..</p>\n<p>Here t_is is only ever used to obtain the subsequent t.  The above <br>\nhava/obtain part can be simplified as follows:</p>\n<p>from <code>T ~: [[S]]</code> have \"~ T &lt;= S\"  by (simp add: property_lift_def)<br>\n    then obtain t where t_st: \"t : T\" \"t ~: S\" by blast</p>\n<p>In fact you can also finish the obtain directly in one blow:</p>\n<p>from <code>T ~: [[S]]</code> obtain t where t_st: \"t : T\" \"t ~: S\"<br>\n      by (auto simp add: property_lift_def)</p>\n<p>(Here I've merely applied the heuristic that auto somehow combines simp <br>\nand blast.)</p>\n<p>Isar is better at exploiting the power of automated reasoning than apply <br>\nscripts, because the effect can be limited to clearly delimited <br>\nsub-problems.</p>\n<p>Readability should also be kept in mind, of course.  The challenge (and <br>\nhigh art) in composing good Isar proofs is to expose just the relevant <br>\nbits in the text, and manage to get it accepted by the proof tools.</p>\n<p>Makarius</p>",
        "id": 294057113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822040
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust note that LList is based on the old HOL/ex/LList; there is also a <br>\nrenovated and Isar-ized version in HOL/Library/Coinductive_List. In <br>\nparticular, the proof method \"coinduct\" is used here for well-structured <br>\ncoinduction proofs.  Ideally AFP's LList2 would be converted to make use <br>\nof the newer Coinductive_List at some point.</p>\n<p>Makarius</p>",
        "id": 294057123,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822047
    }
]