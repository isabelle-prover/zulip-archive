[
    {
        "content": "<p>From: Scott Constable &lt;<a href=\"mailto:sdconsta@syr.edu\">sdconsta@syr.edu</a>&gt;<br>\nI’m currently working with AutoCorres v0.999, and I am trying to find a good disproof method to check my Hoare triples. For trivial proofs on words such as</p>\n<p>lemma “(x :: 8 word) = y”</p>\n<p>quickcheck easily finds a counterexample, but nitpick struggles with the potentially massive cardinalities of the underlying types. For example,</p>\n<p>lemma \"(x :: 8 word) = y\"<br>\nnitpick[sat_solver = MiniSat_JNI]</p>\n<p>outputs:</p>\n<p>Nitpicking formula... <br>\nTimestamp: 12:28:39. <br>\nToo many scopes. Skipping 95000 scopes. (Consider using \"mono\" or<br>\n\"merge_type_vars\" to prevent this.) <br>\nBatch 1 of 100: Trying 50 scopes:<br>\n  card int = 1, card nat = 1, card \"4 list\" = 1, card \"2 list\" = 1,<br>\n    card \"1 list\" = 1, card \"1\" = 1, card unit = 1, card \"8 word\" = 1,<br>\n    card \"8\" = 1, card \"4\" = 1, and card \"2\" = 1;<br>\n  card int = 2, card nat = 2, card \"4 list\" = 2, card \"2 list\" = 2,<br>\n    card \"1 list\" = 2, card \"1\" = 1, card unit = 1, card \"8 word\" = 2,<br>\n    card \"8\" = 2, card \"4\" = 2, and card \"2\" = 2;<br>\n…</p>\n<p>In my experience nitpick’s recommendations do not seem to alleviate the problem. By manually constraining the cardinalities, I was however able to found a counterexample for 4 bit words, but nothing greater. Quickcheck on the other hand does not seem to cooperate with anything that AutoCorres outputs. I typically receive something like the following:</p>\n<p>Quickchecking... <br>\nType unification failed: No type arity lifted_globals_ext :: full_exhaustive</p>\n<p>Type error in application: incompatible operand type</p>\n<p>Operator:  full_exhaustive_class.full_exhaustive ::<br>\n  (??'a × (unit ⇒ term) ⇒ (bool × term list) option)<br>\n  ⇒ natural ⇒ (bool × term list) option<br>\nOperand:<br>\n  λ(s, t_s__).<br>\n     Quickcheck_Random.catch_match<br>\n...<br>\n ::<br>\n  ??'b lifted_globals_scheme × (unit ⇒ term) ⇒ (bool × term list) option</p>\n<p>though to me it looks like this should work.</p>\n<p>Any help would be much appreciated.</p>",
        "id": 294320896,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926847
    },
    {
        "content": "<p>From: David Greenaway &lt;<a href=\"mailto:david.greenaway@nicta.com.au\">david.greenaway@nicta.com.au</a>&gt;<br>\nHi Scott,</p>\n<p>On 05/11/14 04:38, Scott Constable wrote:</p>\n<blockquote>\n<p>I’m currently working with AutoCorres v0.999 a good disproof method to<br>\ncheck my Hoare triples.</p>\n</blockquote>\n<p>I have no idea what I am doing with either nitpick nor quickcheck, but<br>\nthought I would have a bit of a poke around to see if I could understand<br>\nwhat was going on.</p>\n<blockquote>\n<p>[...] For trivial proofs on words such as</p>\n<p>lemma “(x :: 8 word) = y”</p>\n<p>quickcheck easily finds a counterexample, but nitpick struggles with<br>\nthe potentially massive cardinalities of the underlying types. For<br>\nexample,</p>\n<p>lemma \"(x :: 8 word) = y\"<br>\nnitpick[sat_solver = MiniSat_JNI]</p>\n<p>outputs:</p>\n<p>Nitpicking formula...<br>\nTimestamp: 12:28:39.<br>\nToo many scopes. Skipping 95000 scopes. (Consider using \"mono\" or<br>\n[...]</p>\n</blockquote>\n<p>It seems like nitpick is generating rather inefficient representations<br>\nof words. For example, for the lemma \"x = (y :: 2 word)\", nitpick<br>\ngenerates:</p>\n<p>Free variables:<br>\n    x = «0»<br>\n    y = «0»<br>\n  Types:<br>\n    nat = {0, 1, 2, 3, 4, 5, 6, 7, …}<br>\n    int = {- 3, - 2, - 1, 0, 1, 2, 3, 4, …}<br>\n    1 list =<br>\n      {[], [n⇩,⇩1], [n⇩,⇩1, n⇩,⇩1], [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1],<br>\n        [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1], [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1],<br>\n        [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1],<br>\n        [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1], …}<br>\n    unit = {()}<br>\n    2 word = {«0», …}<br>\n    2 = {«0», …}<br>\n  Constants:<br>\n    SOME xs. set xs = ⦃True⦄ ∧ distinct xs = [n⇩,⇩1]<br>\n    distinct =<br>\n      (λx. ?)<br>\n      ([] := True, [n⇩,⇩1] := True, [n⇩,⇩1, n⇩,⇩1] := False,<br>\n      ...<br>\n    set = (λx. ?)<br>\n          ([] := {}, [n⇩,⇩1] := {n⇩,⇩1}, [n⇩,⇩1, n⇩,⇩1] := {n⇩,⇩1},<br>\n           [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1] := {n⇩,⇩1}, [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1] := {n⇩,⇩1},<br>\n           ...<br>\n    tl = (λx. ?)<br>\n         ([] := [], [n⇩,⇩1] := [], [n⇩,⇩1, n⇩,⇩1] := [n⇩,⇩1],<br>\n          [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1] := [n⇩,⇩1, n⇩,⇩1],<br>\n          ...<br>\n    length =<br>\n      (λx. ?)<br>\n      ([] := 0, [n⇩,⇩1] := 1, [n⇩,⇩1, n⇩,⇩1] := 2, [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1] := 3,<br>\n       [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1] := 4, [n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1, n⇩,⇩1] := 5,<br>\n       ...<br>\n    op ^ 2 = (λx. ?)(0 := 1, 1 := 2, 2 := 4)</p>\n<p>The problem is compounded by nitpick wasting time trying different combinations<br>\nof cardinalities for the different intermediate types (nats, ints, lists,<br>\nwords).</p>\n<p>I am sure there would be a way to make nitpick generate more efficient<br>\nrepresentations of words, but I don't have the expertise, sorry. I wonder if<br>\nJasmin has any suggestions?</p>\n<blockquote>\n<p>[...] Quickcheck on the other hand does not seem to cooperate with<br>\nanything that AutoCorres outputs. I typically receive something like<br>\nthe following:</p>\n<p>Quickchecking...<br>\nType unification failed: No type arity lifted_globals_ext :: full_exhaustive</p>\n</blockquote>\n<p>AutoCorres defines the \"lifted_globals\" type using the Record package,<br>\nwhich itself will instantiate \"full_exhaustive\" if it is able to do so.</p>\n<p>In particular, if your C program doesn't use any global state (and hence your<br>\nlifted_globals datatype is particularly boring) the \"lifted_globals\" type is<br>\nindeed instantiated into the \"full_exhaustive\" class by the Record<br>\npackage. For example, in a C program that doesn't use the heap, we can<br>\nwrite:</p>\n<p>lemma \"(a :: lifted_globals) = b\"<br>\n      quickcheck</p>\n<p>and quickcheck produces:</p>\n<p>Quickcheck found a counterexample:</p>\n<p>a = ⦇phantom_machine_state_' = Suc 0, ghost'state_' = ()⦈<br>\n    b = ⦇phantom_machine_state_' = 0, ghost'state_' = ()⦈</p>\n<p>Things appear to fall apart, however, when either the \"lifted_globals\"<br>\nstate or the property being proven become more complex.</p>\n<p>On the \"lifted_globals\" side of things, the moment a program starts to<br>\nuse the heap, the \"ptr\" type comes into play. By default, quickcheck<br>\ndoesn't know how to work with this, so just gives up. We can write the<br>\nline:</p>\n<p>quickcheck_generator ptr constructors: Ptr</p>\n<p>which teaches quickcheck how to work with the \"ptr\" type, but quickcheck<br>\nstill falls over for reasons I don't fully understand. I _suspect_ it<br>\nmay be related to the dummy type variable in the \"ptr\" type, which<br>\ncauses quickcheck to fail with the error message:</p>\n<p>Error: Type 'a ptr list includes a free type variable</p>\n<p>This issue might have come up in the past on the list [1, 2].</p>\n<p>[1] : <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2009-July/msg00012.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2009-July/msg00012.html</a><br>\n  [2] : <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2009-September/msg00075.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2009-September/msg00075.html</a></p>\n<p>On the property-is-too-complex side of things, quickcheck quickly wants<br>\nthe \"lifted_globals\" type to be instantiated into the \"enum\" class;<br>\npresumably so it can evaluate quantifiers. As the lifted_globals type is<br>\nfrequently of infinite size (it has \"nat\"'s in its representation), this<br>\nisn't feasible.</p>\n<p>You also seem to have hit some different errors to me, and its not clear<br>\nto me if they are related or not.</p>\n<p>So, in short, I think the problems are (at least?):</p>\n<p>1. Many properties you might want to quickcheck appear to require<br>\n     \"lifted_globals\" to be in the \"enum\" class, which it usually<br>\n     can't be.</p>\n<p>2. The \"ptr\" type causes problems for \"quickcheck\" for reasons I don't<br>\n     fully understand, which means that any property involving<br>\n     a non-trivial \"lifted_globals\" will cause errors.</p>\n<p>Is there anyone with quickcheck expertise that might be able to help<br>\nresolve these issues?</p>\n<p>Cheers,<br>\nDavid</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294321064,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926895
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi David and Scott,</p>\n<p>I do have some experience with quickcheck, but I do not know AutoCorres at all.</p>\n<p>I nevertheless had a brief look at problem 1. At least for validity Hoare triples, the <br>\nenum requirement arises as follows:</p>\n<p>AutoCorres defines validity of Hoare triples as follows:<br>\n   \"⦃P⦄ f ⦃Q⦄ ≡ ∀s. P s ⟶ (∀(r,s') ∈ fst (f s). Q r s')\"</p>\n<p>The unbounded universal quantifier over s causes the problem with the enum type class, <br>\nbecause the code equation for ∀ implements it by testing all values of the universe (which <br>\nit obtains from the enum type class). There are two ways to avoid the enum type class:</p>\n<ol>\n<li>\n<p>Make the quantifier bounded by P and generate the states from P. Then, P cannot be a <br>\npredicate of type \"'s =&gt; bool\" any more, so this is probably not viable. One could, <br>\nhowever, implement a pass in the preprocessor of the code generator that tries to rewrite <br>\nprecondition instances into generators for states. Then, quickcheck would only test states <br>\nthat actually satisfy the precondition, so quickcheck has a reasonable chance of finding <br>\ncounterexamples. However, this only works if P can really be rewritten into a generator. I <br>\nexpect that one would need generative versions of all the common functions that occur in <br>\npreconditions.</p>\n</li>\n<li>\n<p>For quickcheck, it suffices to replace the quantifier by some generator for states <br>\n(rather than covering all states). To that end, you have to define a copy of the <br>\nquantifier and implement is with a code equation that tests the predicate in the points <br>\ngenerated by the generator and raises an exception (with Code.abort) after the generator <br>\nof states has been exhausted. This is probably less work in terms of setup than 1 and <br>\nworks reliably, but it is unclear how good the generated states are. If hardly any of them <br>\nsatisfy the precondition P, then test coverage is low.</p>\n</li>\n</ol>\n<p>If one wants to invest more work, one can also combine both approaches. If 1 fails, try 2.</p>\n<p>I was not able to look at problem 2, because I have not found a small example where the <br>\nptr causes an exception. If you provide one, I can have a look at this, too.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294321076,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926901
    },
    {
        "content": "<p>From: David Greenaway &lt;<a href=\"mailto:david.greenaway@nicta.com.au\">david.greenaway@nicta.com.au</a>&gt;<br>\nHi Andreas,</p>\n<p>Thanks for your suggestions about writing some custom state generators.<br>\nI have some ideas about what might be useful testcases in practice.</p>\n<p>Generating custom states by inspecting the precondition sounds fun, but<br>\nmight be a longer-term project. :)<br>\n<a href=\"/user_uploads/14278/HG_veGosmqEjAGO5_fpIia0h/PtrTypeQuickcheck.thy\">PtrTypeQuickcheck.thy</a></p>",
        "id": 294321192,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926944
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi David,</p>\n<p>Now I see that ML's value restriction causes the error. One of the parameters of the enum <br>\ntype class (namely enum) is not of function type. Since its definition 'a ptr does not <br>\ndepend on other type classes' parameters for 'a, the code generator produces a declaration <br>\nof the form</p>\n<p>val enum_ptr = ...</p>\n<p>which of course should be polymorphic in the element type, but this is not allowed for val <br>\ndeclarations in ML. If you restrict the element type to a type class with type parameters, <br>\nthen the code generator will produce a fun declaration, which may be polymorphic. You can <br>\ndefine your own type class such as</p>\n<p>class dummy = fixes DUMMY :: \"'a itself\"</p>\n<p>and declare a corresponding code equation:</p>\n<p>lemma enum_ptr_code [code]:<br>\n   \"Enum.enum = (map (Ptr o of_nat) [0 ..&lt; 2 ^ 32] :: 'a :: dummy ptr list)\"<br>\nby(simp add: enum_ptr_def)</p>\n<p>Of course, you have to instantiate this class for all your type constructors that you want <br>\nto store in a ptr.</p>\n<p>instantiation \"fun\" :: (type, type) dummy begin<br>\ndefinition \"DUMMY = TYPE('a ⇒ 'b)\"<br>\ninstance ..<br>\nend</p>\n<p>instantiation nat :: dummy begin<br>\ndefinition \"DUMMY = TYPE(nat)\"<br>\ninstance ..<br>\nend</p>\n<p>Alternatively, you can reuse one of Isabelle/HOL's type classes, e.g. typerep (of which <br>\nalmost every type is an instance of):</p>\n<p>lemma enum_ptr_code [code]:<br>\n   \"Enum.enum = (map (Ptr o of_nat) [0 ..&lt; 2 ^ 32] :: 'a :: typerep ptr list)\"<br>\nby(simp add: enum_ptr_def)</p>\n<p>With this setup, the code generator outputs valid ML code.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294321236,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926956
    },
    {
        "content": "<p>From: Scott Constable &lt;<a href=\"mailto:sdconsta@syr.edu\">sdconsta@syr.edu</a>&gt;<br>\nDavid and Andreas,</p>\n<p>Thanks for the investigation on quickcheck. Meanwhile I have been looking into tweaking nitpick, though the results thus far have been troubling. See below.</p>\n<p>lemma word_lem: \"(x :: 4 word) = y\"<br>\nnitpick[verbose, mono, card int = 32, card nat = 16, card \"2 list\" = 4, <br>\n    card \"1 list\" = 4, card \"4 word\" = 8, card \"4\" = 4, card \"2\" = 2, <br>\n    card \"1\" = 1, card unit = 1]</p>\n<p>Nitpicking formula... <br>\nTimestamp: 08:56:02. <br>\nThe types \"4 word\", \"4\", and \"2\" are considered monotonic. Nitpick might<br>\nbe able to skip some scopes. <br>\nUsing SAT solver \"Lingeling_JNI\". The following solvers are configured:<br>\n\"Lingeling_JNI\", \"CryptoMiniSat_JNI\", \"MiniSat_JNI\", \"SAT4J\",<br>\n\"SAT4J_Light\". <br>\nTrying 1 scope:<br>\n  card int = 32, card nat = 16, card \"2 list\" = 4, card \"1 list\" = 4,<br>\n    card \"4 word\" = 8, card \"4\" = 4, card \"2\" = 2, card \"1\" = 1, and<br>\n    card unit = 1. <br>\nNitpick found a potentially spurious counterexample for card int = 32,<br>\ncard nat = 16, card \"2 list\" = 4, card \"1 list\" = 4, card \"4 word\" = 8,<br>\ncard \"4\" = 4, card \"2\" = 2, card \"1\" = 1, and card unit = 1:</p>\n<p>Free variables:<br>\n    x = «1»<br>\n    y = «0» <br>\nNitpick could not find a better counterexample. It checked 1 of 1 scope. <br>\nTotal time: 3.8 s.</p>\n<p>For this contrived example, I was able to get nitpick to focus on one scope, and find the most trivial counterexample, albeit in almost four seconds. Slight perturbations to the cardinalities (i.e. reducing “card int” to 16) may either cause nitpick to find stranger counterexamples, like &lt;&lt;8&gt;&gt; and &lt;&lt;9&gt;&gt;, or not find any counterexamples at all. My experiments have exhausted my understanding of nitpick, and I’m not sure if there is any way of further improving performance.</p>\n<p>Though I have a general idea of what you both are suggesting on the quickcheck side, I am not convinced that this solution will scale up to the application which my research group desires: checking Hoare triples over heap abstracted code generated by AutoCorres. </p>\n<p>~Scott</p>",
        "id": 294321428,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927009
    },
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nDear Scott,</p>\n<p>Sorry for the delay in answering. I am just coming back from vacation.</p>\n<p>The problem here is that Nitpick has no built in support for words. It then needs to work in terms of the definition</p>\n<p>typedef 'a word = \"{(0::int) ..&lt; 2 ^ len_of TYPE('a::len0)}\"<br>\n      morphisms uint Abs_word by auto</p>\n<p>which is not fun for SAT solving.</p>\n<p>Nitpick's underlying engine, Kodkod, has a notion of words, and it would be possible to handle them really efficiently. However, this would require quite a bit of work in Nitpick, which is not one of my main research interests right now. Sorry about that.</p>\n<p>Regards,</p>\n<p>Jasmin</p>",
        "id": 294321533,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927049
    }
]