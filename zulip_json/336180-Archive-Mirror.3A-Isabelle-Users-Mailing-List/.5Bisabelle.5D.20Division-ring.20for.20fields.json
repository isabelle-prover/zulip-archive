[
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I have some algorithm which work on division rings (e.g., for computing the determinant of a matrix).</p>\n<p>However I sometimes also want to apply the same algorithm for fields, which is in principle easy since I just<br>\nhave to define „div“ as „/“ and „mod“ as „% x y. if y = 0 then x else 0“. Now my question is, whether there is a better way, <br>\nthan manually putting all common classes manually into div_ring as follows.</p>\n<p>class ring_div_field = field + div +<br>\n  assumes div: \"(op div :: 'a ⇒ 'a ⇒ 'a) = op /\"<br>\n  and mod: \"(x :: 'a) mod y = (if y = 0 then x else 0)\"<br>\nbegin</p>\n<p>subclass ring_div<br>\n  by (unfold_locales, auto simp: div mod field_simps)</p>\n<p>end</p>\n<p>instantiation rat :: ring_div_field<br>\nbegin<br>\ndefinition \"div_rat = (op / :: rat ⇒ rat ⇒ rat)\"<br>\ndefinition \"mod_rat (x :: rat) (y :: rat) = (if y = 0 then x else 0)\"<br>\ninstance<br>\n  by (intro_classes, auto simp: div_rat_def mod_rat_def)<br>\nend</p>\n<p>instantiation real :: ring_div_field<br>\nbegin<br>\ndefinition \"div_real = (op / :: real ⇒ real ⇒ real)\"<br>\ndefinition \"mod_real (x :: real) (y :: real) = (if y = 0 then x else 0)\"<br>\ninstance<br>\n  by (intro_classes, auto simp: div_real_def mod_real_def)<br>\nend</p>\n<p>instantiation complex :: ring_div_field<br>\nbegin<br>\ndefinition \"div_complex = (op / :: complex ⇒ complex ⇒ complex)\"<br>\ndefinition \"mod_complex (x :: complex) (y :: complex) = (if y = 0 then x else 0)\"<br>\ninstance<br>\n  by (intro_classes, auto simp: div_complex_def mod_complex_def)<br>\nend</p>\n<p>Best regards,<br>\nRené</p>",
        "id": 294636301,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160274
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi René,</p>\n<blockquote>\n<p>I have some algorithm which work on division rings (e.g., for<br>\ncomputing the determinant of a matrix).</p>\n<p>However I sometimes also want to apply the same algorithm for fields, which is in principle easy since I just<br>\nhave to define „div“ as „/“ and „mod“ as „% x y. if y = 0 then x else 0“. Now my question is, whether there is a better way, <br>\nthan manually putting all common classes manually into div_ring as follows.</p>\n<p>class ring_div_field = field + div +<br>\n  assumes div: \"(op div :: 'a ⇒ 'a ⇒ 'a) = op /\"<br>\n  and mod: \"(x :: 'a) mod y = (if y = 0 then x else 0)\"<br>\nbegin</p>\n<p>subclass ring_div<br>\n  by (unfold_locales, auto simp: div mod field_simps)</p>\n<p>end</p>\n</blockquote>\n<p>currently, there is no better way.</p>\n<p>I plan to establish a common class for a division partially specified as<br>\ninverse operation of multiplication, which is later on specialised both<br>\ntowards division with remainder as well as division in fields.</p>\n<p>This will happen somewhere after the next release.  I got entangled into<br>\nlong-overseen problems with abbreviations in type classes before<br>\ntackling the central element, the universal division operation.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/bOu_n2wHC3osfOFdoLISbST0/signature.asc\">signature.asc</a></p>",
        "id": 294636661,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160428
    }
]