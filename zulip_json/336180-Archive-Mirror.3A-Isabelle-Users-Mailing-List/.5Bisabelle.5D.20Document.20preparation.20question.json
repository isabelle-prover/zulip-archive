[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear Isabelle users,</p>\n<p>I am adding finishing touches to an upcoming AFP entry and I am playing<br>\naround a bit with Isabelle’s document generation features. It works<br>\nnicely, but I have some questions:</p>\n<p>I’d like to use @{term_type foo} on expressions whose type contains a<br>\ntype synonym, but the result contains the unfolded type. Is there a<br>\nbetter work-around than using<br>\n        @{term \"heapToEnv:: heap ⇒ (exp ⇒ Value) ⇒ Env\"}@{text \"::\"}@{typ \"heap ⇒ (exp ⇒ Value) ⇒ Env\"}<br>\ninstead of just<br>\n        @{term_type \"heapToEnv:: heap ⇒ (exp ⇒ Value) ⇒ Env\"}</p>\n<p>Also, I have trouble with no_document. My ROOT.ML reads<br>\n        $ cat isa-launchbury/ROOT.ML <br>\n        no_document use_thys [\"<del>/src/HOL/Library/FuncSet\", \"</del>/src/HOL/Library/LaTeXsugar\"];<br>\n        use_thys [\"Everything\"];<br>\nAnd indeed, the generated  files FuncSet.tex and LaTeXsugar.tex are<br>\nempty. But they are included in the session_graph.pdf file. Is there a<br>\nway to avoid that?</p>\n<p>The next items are more feature suggestions than question, but still:</p>\n<p>@{abbrev ..} is nice. Can we have an @{type_abbrev ..} that<br>\npretty-prints the type equations?</p>\n<p>Sometimes the lemmas would be clearer if free variables were explicitly<br>\nall-quantified. Is there an easy way to achieve this (besides defining a<br>\nvariant of the lemma with an HOL-∀ in front)?</p>\n<p>Breaking a lemma apart with (prem 1), (prem 2) and (concl) to insert it<br>\ninto the text appropriately is also nice, but feels a bit dangerous –<br>\nwhat if I later change the theory and add a premise. How about a command<br>\nthat asserts that a certain lemma has exactly n premises that would fail<br>\nif that is no longer true? Then the careful author could use the command<br>\nnear places where he uses (prem 1), (prem 2) and (concl) and be sure<br>\nthat he presents the lemma fully.</p>\n<p>I also miss good ways to automatically print data type definitions. My<br>\nwork around is to show<br>\n        lemma Terms:<br>\n          \"∃ x assn e'. (e = (Lam [x]. e') ∨ (e = Var x) ∨ (e = App e' x) ∨ (e = Let assn e'))\"<br>\n          by (metis Terms.exp_assn.exhaust(1))<br>\nand pretty-print this lemma in the text, but a tool that formats an<br>\nexhaust-lemma in the style of a grammar specification would be slick.</p>\n<p>Thanks,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/e8NEfeRb8a-BoQqbwJigcVtX/signature.asc\">signature.asc</a></p>",
        "id": 294232044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902978
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nNot that I know. The original type is lost, so you have to write at least one<br>\ntype, but to avoid writing two types you would need some ML (to check that the<br>\ntype you give is the right one).</p>\n<p>Tobias</p>",
        "id": 294232064,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902989
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Joachim,</p>\n<blockquote>\n<p>I’d like to use @{term_type foo} on expressions whose type contains a<br>\ntype synonym, but the result contains the unfolded type. Is there a<br>\nbetter work-around than using<br>\n        @{term \"heapToEnv:: heap ⇒ (exp ⇒ Value) ⇒ Env\"}@{text \"::\"}@{typ \"heap ⇒ (exp ⇒ Value) ⇒ Env\"}<br>\ninstead of just<br>\n        @{term_type \"heapToEnv:: heap ⇒ (exp ⇒ Value) ⇒ Env\"}</p>\n</blockquote>\n<p>I would suggest @{term_type [source] \"heapToEnv:: heap ⇒ (exp ⇒ Value) ⇒<br>\nEnv\"}</p>\n<blockquote>\n<p>@{abbrev ..} is nice. Can we have an @{type_abbrev ..} that<br>\npretty-prints the type equations?</p>\n</blockquote>\n<p>Something to think about.</p>\n<blockquote>\n<p>Sometimes the lemmas would be clearer if free variables were explicitly<br>\nall-quantified. Is there an easy way to achieve this (besides defining a<br>\nvariant of the lemma with an HOL-∀ in front)?</p>\n</blockquote>\n<p>You could write a style in ML for the term antiquotation to add the<br>\nquantifiers to propositions. See the LaTeX sugar document for<br>\nfundamental hints, or just get back here.</p>\n<blockquote>\n<p>I also miss good ways to automatically print data type definitions. My<br>\nwork around is to show<br>\n        lemma Terms:<br>\n          \"∃ x assn e'. (e = (Lam [x]. e') ∨ (e = Var x) ∨ (e = App e' x) ∨ (e = Let assn e'))\"<br>\n          by (metis Terms.exp_assn.exhaust(1))<br>\nand pretty-print this lemma in the text, but a tool that formats an<br>\nexhaust-lemma in the style of a grammar specification would be slick.</p>\n</blockquote>\n<p>Maybe also something which can be implemented as term style, e.g.<br>\nexpecting an exhaustivness lemma as produced by datatype and rearranging<br>\nit as desired.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/7S_2bmadW59WWStlbQxJf5N-/signature.asc\">signature.asc</a></p>",
        "id": 294232074,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902996
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Joachim,</p>\n<blockquote>\n<p>I’d like to use @{term_type foo} on expressions whose type contains a<br>\ntype synonym, but the result contains the unfolded type. Is there a<br>\nbetter work-around than using<br>\n         @{term \"heapToEnv:: heap ⇒ (exp ⇒ Value) ⇒ Env\"}@{text <br>\n\"::\"}@{typ \"heap ⇒ (exp ⇒ Value) ⇒ Env\"}<br>\ninstead of just<br>\n         @{term_type \"heapToEnv:: heap ⇒ (exp ⇒ Value) ⇒ Env\"}</p>\n</blockquote>\n<p>type_synonym declarations only introduce the parse translations for type <br>\nabbreviations. The print direction like for term abbreviations is not <br>\nproduced automatically, but you can add it manually:</p>\n<p>translations (latex)<br>\n   (type) heap &lt;= (type) \"(var * expr) list\"</p>\n<p>However, this translation will be applied to all printed type in the <br>\ngiven print mode (latex in the example), so any occurrence of (var * <br>\nexpr) list\" will be printed as \"heap\". This is similar to printing <br>\nabbreviations on the term level. With this translation in place, <br>\n@{term_type \"heapToEnv :: heap =&gt; (exp =&gt; Value) =&gt; Env\"} should print <br>\nwhat you expect.</p>\n<blockquote>\n<p>Also, I have trouble with no_document. My ROOT.ML reads<br>\n         $ cat isa-launchbury/ROOT.ML<br>\n         no_document use_thys [\"<del>/src/HOL/Library/FuncSet\", \"</del>/src/HOL/Library/LaTeXsugar\"];<br>\n         use_thys [\"Everything\"];<br>\nAnd indeed, the generated  files FuncSet.tex and LaTeXsugar.tex are<br>\nempty. But they are included in the session_graph.pdf file. Is there a<br>\nway to avoid that?<br>\nI know one way to avoid that: Build a heap image with all auxiliary <br>\ntheories that you do not want to show up in session_graph.pdf, i.e., HOL <br>\nwith FuncSet and LaTeXsugar, and then base your session on this image.</p>\n</blockquote>\n<blockquote>\n<p>I also miss good ways to automatically print data type definitions. My<br>\nwork around is to show<br>\n         lemma Terms:<br>\n           \"∃ x assn e'. (e = (Lam [x]. e') ∨ (e = Var x) ∨ (e = App e' x) ∨ (e = Let assn e'))\"<br>\n           by (metis Terms.exp_assn.exhaust(1))<br>\nand pretty-print this lemma in the text, but a tool that formats an<br>\nexhaust-lemma in the style of a grammar specification would be slick.<br>\nYou don't have to state and prove this lemma yourself, the datatype <br>\npackage generates a similar one called expr.nchotomy for type expr.</p>\n</blockquote>\n<p>Andreas</p>",
        "id": 294232089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903009
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>Am Donnerstag, den 17.01.2013, 11:21 +0100 schrieb Andreas Lochbihler:</p>\n<blockquote>\n<blockquote>\n<p>Also, I have trouble with no_document. My ROOT.ML reads<br>\n         $ cat isa-launchbury/ROOT.ML<br>\n         no_document use_thys [\"<del>/src/HOL/Library/FuncSet\", \"</del>/src/HOL/Library/LaTeXsugar\"];<br>\n         use_thys [\"Everything\"];<br>\nAnd indeed, the generated  files FuncSet.tex and LaTeXsugar.tex are<br>\nempty. But they are included in the session_graph.pdf file. Is there a<br>\nway to avoid that?<br>\nI know one way to avoid that: Build a heap image with all auxiliary <br>\ntheories that you do not want to show up in session_graph.pdf, i.e., HOL <br>\nwith FuncSet and LaTeXsugar, and then base your session on this image.</p>\n</blockquote>\n</blockquote>\n<p>Or, in my case, HOL+HOLCF+Nominal2+FuncSet+LaTeXsugar. This leads to<br>\nanother question:</p>\n<p>What should a IsaMakefile look like that uses a custom heap (in my case,<br>\nHOL+HOLCF+Nominal2 where Nominal2 comes with my submission in a<br>\nsubdirectory) so that it works on the AFP?</p>\n<p>Also, one of the theories that I want to exclude from the session graph<br>\nis Everything, which is actually the part of the introduction that uses<br>\nall this pretty-printing, but not really part of the theory. I guess the<br>\nheap building does not work here, because the theory is at the very<br>\nbottom of the graph?</p>\n<blockquote>\n<blockquote>\n<p>I also miss good ways to automatically print data type definitions. My<br>\nwork around is to show<br>\n         lemma Terms:<br>\n           \"∃ x assn e'. (e = (Lam [x]. e') ∨ (e = Var x) ∨ (e = App e' x) ∨ (e = Let assn e'))\"<br>\n           by (metis Terms.exp_assn.exhaust(1))<br>\nand pretty-print this lemma in the text, but a tool that formats an<br>\nexhaust-lemma in the style of a grammar specification would be slick.<br>\nYou don't have to state and prove this lemma yourself, the datatype <br>\npackage generates a similar one called expr.nchotomy for type expr.</p>\n</blockquote>\n</blockquote>\n<p>Thanks for the pointer. It seems that nominal_datatye does not build<br>\nsuch a lemma. Also, I had to collect all existentially quantified<br>\nvariables in the front so that the lemma would fit on one line :-)</p>\n<p>Greetings,<br>\nJoachin<br>\n<a href=\"/user_uploads/14278/EZGWzUzKI5-iPdud_aa7n2Qx/signature.asc\">signature.asc</a></p>",
        "id": 294232101,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903015
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>I tried to do it using the translation and syntax features, and here is<br>\nwhat I cam up with, based on my very partial understanding of these<br>\nfeatures:</p>\n<p>abbreviation (Grammar output)<br>\n  \"grammar_imp\"<br>\nwhere<br>\n  \"grammar_imp ≡ op ⟶\"</p>\n<p>syntax (Grammar output)<br>\n  \"_grapats\" :: \"term \\&lt;Rightarrow&gt; term \\&lt;Rightarrow&gt; term\" (\"_ | _\")<br>\n  \"_grafirst\" :: \"term \\&lt;Rightarrow&gt; term \\&lt;Rightarrow&gt; term\" (\"_ ::= _\")<br>\n  \"_grarest\" :: \"term \\&lt;Rightarrow&gt; term \\&lt;Rightarrow&gt; term\"<br>\n  \"_firsteq\" :: \"term \\&lt;Rightarrow&gt; term \\&lt;Rightarrow&gt; term\"<br>\n  \"_resteq\" :: \"term \\&lt;Rightarrow&gt; term \\&lt;Rightarrow&gt; term\"</p>\n<p>translations<br>\n  \"_grapats (_firsteq all) (_grarest (CONST grammar_imp rest1 rest2))\" &lt;= \"CONST grammar_imp all (CONST grammar_imp rest1 rest2)\"<br>\n  \"_grapats (_resteq all) (_grarest (CONST grammar_imp rest1 rest2))\" &lt;= \"_grarest (CONST grammar_imp all (CONST grammar_imp rest1 rest2))\"<br>\n  \"_resteq all\" &lt;= \"_grarest (CONST grammar_imp all rest)\"<br>\n  \"_resteq all\" &lt;= \"_resteq (CONST grammar_imp all rest)\"<br>\n  \"_firsteq all\" &lt;= \"_firsteq (CONST grammar_imp all rest)\"<br>\n  \"_firsteq imp\" &lt;= \"_firsteq (ALL x. imp)\"<br>\n  \"_resteq imp\" &lt;= \"_resteq (ALL x. imp)\"<br>\n  \"_grafirst x t\" &lt;= \"_firsteq (x = t)\"<br>\n  \"t\" &lt;= \"_resteq (x = t)\"</p>\n<p>This does require the lemma to be internalized, e.g.:<br>\n        lemma tmp:<br>\n        \"(∀ var. y = Var var ⟶ P) ⟶<br>\n         (∀ exp var. y = App exp var ⟶ P) ⟶<br>\n         (∀ assn exp. y = Terms.Let assn exp ⟶ P) ⟶<br>\n         (∀ var exp. y = Lam [var].exp ⟶ P) ⟶ P\"<br>\n          by (metis exp_assn.exhaust(1)) <br>\nbut then<br>\n        thm (Grammar) tmp[no_vars]<br>\nprints<br>\n        y ::= Var var | App exp var | Terms.Let assn exp | Lam [var].<br>\n        exp <br>\nwhich is nice.</p>\n<p>It seems that translations work independent of the current mode. That is<br>\nwhy I introduced a mode-dependent abbreviation for the outermost symbol<br>\nof the theorem (op ⟶), to make sure my translations only affect the<br>\noutput in this particular mode. The abbreviation command did however not<br>\nwork with Trueprop or ==&gt; – how can I adjust this setup to work with the<br>\nmeta logic directives directly?</p>\n<p>There might be more eleganter and saner ways to achieve this. If so,<br>\nplease let me know.</p>\n<p>Thanks,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/n-6eeXEzkGSZFw3ke109qpl5/signature.asc\">signature.asc</a></p>",
        "id": 294232136,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903033
    }
]