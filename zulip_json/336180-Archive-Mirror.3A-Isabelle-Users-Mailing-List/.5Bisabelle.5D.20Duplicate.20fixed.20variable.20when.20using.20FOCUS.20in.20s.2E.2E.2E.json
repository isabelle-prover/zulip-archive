[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nA student of mine has a problem with the following setup:</p>\n<p>ML‹<br>\nval focus_tac = Subgoal.FOCUS (K no_tac)<br>\n›<br>\nsetup ‹<br>\n   map_theory_simpset (fn ctxt =&gt; ctxt<br>\n     addSolver (mk_solver \"focus_solver\" focus_tac))<br>\n›</p>\n<p>In some cases this raises the error \"Duplicate fixed variable(s)\". Here is an <br>\nexample from the Multiset theory:</p>\n<p>This works:</p>\n<p>size_multiset_overloaded_def[THEN fun_cong, unfolded size_multiset_eq]</p>\n<p>but creates a thm with both ?x and a bound x. Applying the simplified attribute <br>\nwith the above setup raises \"Duplicate fixed variable(s): x\":</p>\n<p>size_multiset_overloaded_def[THEN fun_cong, unfolded size_multiset_eq, simplified]</p>\n<p>Any help is appreciated.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/sm8rRVN_1SgmrCGDZKf-eKt1/smime.p7s\">smime.p7s</a></p>",
        "id": 294767407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202591
    },
    {
        "content": "<p>From: \"Jackson, Vincent (Data61, Kensington NSW)\" &lt;<a href=\"mailto:Vincent.Jackson@data61.csiro.au\">Vincent.Jackson@data61.csiro.au</a>&gt;<br>\nAh, this reminds me of a problem I ran into a while ago.<br>\nThe following produces the wonderfully helpful error <code>Duplicate fixed variable(s): \"\"</code>.</p>\n<p>ML ‹<br>\n  @{cterm \"⋀a. x + (f x) ≤ y ∧ a = x + (if x = 0 then 1 else Suc y) div 2\"}<br>\n  |&gt; Goal.init<br>\n  |&gt; Subgoal.FOCUS_PARAMS (fn {context = ctxt, ...} =&gt; simp_tac ctxt 1)<br>\n    (Simplifier.add_cong @{thm HOL.conj_cong} @{context}) 1<br>\n  |&gt; Seq.hd<br>\n›</p>\n<p>There seems to be some interaction between simp and cong rules which causes this sort of problem. Replacing <code>Simplifier.add_cong @{thm HOL.conj_cong} @{context}</code> with <code>@{context}</code> prevents the error from occuring.</p>\n<p>Unfortunately, I can't offer a solution, but if anyone has a resolution to this problem, it would also be helpful to me.</p>\n<p>Thanks,<br>\n  Vincent</p>\n<hr>\n<p>Vincent Jackson<br>\nProof Engineer | Trustworthy Systems<br>\nCSIRO's Data61<br>\nE  Vincent.Jackson@data61.csiro.au&lt;mailto:<a href=\"mailto:Vincent.Jackson@data61.csiro.au\">Vincent.Jackson@data61.csiro.au</a>&gt;<br>\n1466  UNSW Sydney, NSW, Australia<br>\n<a href=\"http://www.data61.csiro.au\">www.data61.csiro.au</a></p>",
        "id": 294767491,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202618
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nProof tools often implicitly assume a proper goal context, but here<br>\n\"simplified\" operates in a global theory. The example can be made work like this:</p>\n<p>theory Scratch<br>\n  imports Main \"HOL-Library.Multiset\"<br>\nbegin</p>\n<p>ML ‹<br>\n  fun focus_tac ctxt =<br>\n    Subgoal.FOCUS (K no_tac) ctxt;<br>\n›<br>\nsetup ‹<br>\n  map_theory_simpset (fn ctxt =&gt; ctxt<br>\n    addSolver (mk_solver \"focus_solver\" focus_tac))<br>\n›</p>\n<p>notepad<br>\nbegin<br>\n  thm size_multiset_overloaded_def[THEN fun_cong, unfolded size_multiset_eq,<br>\nsimplified]<br>\nend</p>\n<p>Here the notepad provides a proper proof body. In ML the same effect can be<br>\nachieved like this:</p>\n<p>ML ‹<br>\n  val ctxt = \\&lt;^context&gt;;<br>\n  val thm = @{thm size_multiset_overloaded_def[THEN fun_cong, unfolded<br>\nsize_multiset_eq]};<br>\n  Simplifier.asm_full_simplify (Variable.set_body true ctxt) thm;<br>\n›</p>\n<p>Alternatively, focus_tac can be made more robust like this:</p>\n<p>ML ‹<br>\n  fun focus_tac ctxt =<br>\n    Subgoal.FOCUS (K no_tac) (Variable.set_body true ctxt);<br>\n›</p>\n<p>(Normally proof tools should not have to change context flags like that.)</p>\n<p>The deeper reason why the Simplifier is a bit unfriendly here: it pretends to<br>\nbe a plain inference rule, but uses tactical reasoning internally (e.g. the<br>\nsolver). I will see if its builtin policies can be changed to avoid such<br>\nsurprises.</p>\n<p>Makarius</p>",
        "id": 294767512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202628
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis example contains directly visible programming mistakes concerning the<br>\ncontext discipline:</p>\n<p>* Tactical reasoning always requires a proper goal context (not a global<br>\ntheory context like @{context} of the above ML command).</p>\n<p>* Goal statements need to be properly declared to the context.</p>\n<p>Here is a more standard approach:</p>\n<p>theory Scratch<br>\n  imports Main<br>\nbegin</p>\n<p>ML ‹<br>\n  val ctxt = @{context};<br>\n  val ct = @{cterm ‹⋀a. x + (f x) ≤ y ∧ a = x + (if x = 0 then 1 else Suc y)<br>\ndiv 2›};</p>\n<p>val goal_ctxt = ctxt<br>\n    |&gt; Variable.set_body true<br>\n    |&gt; Variable.declare_term (Thm.term_of ct);</p>\n<p>Goal.init ct<br>\n  |&gt; Subgoal.FOCUS_PARAMS (fn {context = focus_ctxt, ...} =&gt; simp_tac<br>\nfocus_ctxt 1)<br>\n    (Simplifier.add_cong @{thm HOL.conj_cong} goal_ctxt) 1<br>\n  |&gt; Seq.hd;<br>\n›</p>\n<p>end</p>\n<p>Of course, Goal.init / Seq.hd is a fairly low-level way to work with tactics:<br>\nGoal.prove provides the template for the full setup, including Goal.init,<br>\nVariable.set_body trueVariable.declare_term.</p>\n<p>Further stylistic notes on the modified example snippet:</p>\n<p>* The static antiquotations @{context} and @{cterm} are only used in the<br>\n\"prelude\", not the ML body text. Thus it is possible to turn a successful<br>\nexperiment into a function on ctxt and ct, without referring to inlined<br>\ncompile-time values by accident.</p>\n<p>* ML bindings like \"ctxt\" should never be re-used in local scopes: abive I<br>\nhave taken the care to be clear about ctxt, goal_ctxt, focus_ctxt. Unlike<br>\nIntelliJ IDEA, our Isabelle/ML does not warn about \"suspicious\" rebindings<br>\nlike \"val ctxt = f ctxt\", but Isabelle/jEdit can help to clean up odd sources<br>\nthat use that style reliably.</p>\n<p>Makarius</p>",
        "id": 294767530,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202637
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThere is now the following minimal change to make the internal tactical<br>\nreasoning more robust in this respect:<br>\n<a href=\"https://isabelle.in.tum.de/repos/isabelle/rev/1be996d8bb98\">https://isabelle.in.tum.de/repos/isabelle/rev/1be996d8bb98</a></p>\n<p>That is for the next release, presumably Isabelle2020 (June 2020). There are<br>\nfurther related changes already present and potentially still coming. Any<br>\ndiscussions about such ongoing development may happen on isabelle-dev as usual.</p>\n<p>Generally, projects with Isabelle should use the official release, and live<br>\nwith such small workarounds as above. There is nothing strictly wrong here,<br>\njust a small inconvenience.</p>\n<p>Makarius</p>",
        "id": 294767565,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202653
    }
]