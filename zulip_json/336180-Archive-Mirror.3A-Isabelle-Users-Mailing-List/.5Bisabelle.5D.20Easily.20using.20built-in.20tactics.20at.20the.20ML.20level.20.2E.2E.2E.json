[
    {
        "content": "<p>From: David Greenaway &lt;<a href=\"mailto:david.greenaway@nicta.com.au\">david.greenaway@nicta.com.au</a>&gt;<br>\nHi all,</p>\n<p>In an Isabelle theory file, I can write simple one-line tactics such as<br>\nthe following:</p>\n<p>apply (clarsimp simp: split_def split: prod.splits)</p>\n<p>I find, however, when I start writing ML code to automate proofs,<br>\nproducing a ML tactic object is far more verbose:</p>\n<p>clarsimp_tac (Context.proof_map (<br>\n      Simplifier.map_ss (fold Splitter.add_split @{thms prod.splits})<br>\n      #&gt; Simplifier.map_ss (fn ss =&gt; ss addsimps [@{thm split_def}]))<br>\n    @{context}) 1</p>\n<p>The background is that I am writing tools[1] to automatically convert<br>\nC code into an abstract(ish) monadic form with the goal of easing<br>\nreasoning. As part of this, I frequently need to write ML code that<br>\ndynamically generates theorems and then proceeds to prove them. A simple<br>\nway of writing tactics such as the one above would be helpful both in<br>\nquick-and-dirty prototyping of ML proof procedures, but ideally would<br>\nalso be clean enough for \"production quality code\".</p>\n<p>Does anyone have any hints or tips?</p>\n<p>(This discussion was originally started at StackOverflow[2], but it was<br>\nsuggested that I move it over here when the discussion became a little<br>\nmore involved. It is also part of long-running bigger question as to<br>\n\"what is the best way to interact with Isabelle at the ML level?\", but<br>\nperhaps it is better to address this concrete issue for now.)</p>\n<p>[1]: <a href=\"http://ssrg.nicta.com.au/projects/TS/autocorres/\">http://ssrg.nicta.com.au/projects/TS/autocorres/</a><br>\n  [2]: <a href=\"http://stackoverflow.com/questions/15217009/how-can-i-easily-write-simple-tactics-at-the-ml-level-of-isabelle\">http://stackoverflow.com/questions/15217009/how-can-i-easily-write-simple-tactics-at-the-ml-level-of-isabelle</a></p>\n<p>Thanks so much,<br>\nDavid</p>",
        "id": 294237990,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905629
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe first hint is off-topic: ML has values and functions over values, not <br>\n\"objects\".  Someone else had also used the oo-term \"method\" for ML <br>\nfunctions, but this is only adding confusion, and working against the <br>\nintentions of the oo-guys some decades ago: the idea back then was to have <br>\nunusual terminology (\"objects\", \"methods\", \"classes\") for unusual and <br>\ngroundbreaking concepts.</p>\n<p>Back to today's reality and the question how to work effectively and <br>\nsmoothly with Isabelle/ML, and how to write proof procedures in it. Here <br>\nis part of my answer from the Stackoverflow thread again:</p>\n<p>ML {*<br>\n   (*foo_tac -- the payload of what you want to do,<br>\n     note the dependency on ctxt: Proof.context*)<br>\n   fun foo_tac ctxt =<br>\n     let<br>\n       val my_ctxt =<br>\n         ctxt |&gt; Simplifier.map_simpset<br>\n          (fold Splitter.add_split @{thms prod.splits} #&gt;<br>\n           Simplifier.add_simp @{thm split_def})<br>\n     in ALLGOALS (clarsimp_tac my_ctxt) end<br>\n*}</p>\n<p>method_setup foo = {*<br>\n   (<em>concrete syntax like \"clarsimp\", \"auto\" etc.</em>)<br>\n   Method.sections Clasimp.clasimp_modifiers &gt;&gt;<br>\n     (<em>Isar method boilerplate</em>)<br>\n     (fn _ =&gt; fn ctxt =&gt; SIMPLE_METHOD (CHANGED (foo_tac ctxt)))<br>\n*}</p>\n<p>Here I had already applied some peep-hole optimization to make your <br>\ninitial version less awkward.  Instead of pasting together big ML <br>\nexpressions (also with antiquotations) in \"apply tactic {* ... *}\" you <br>\nbuild up small ML tools like foo_tac and eventually wrap them up in <br>\nconcrete Isar syntax via method_setup, for example.</p>\n<p>We still need to work out, why this direction did not look appealing to <br>\nyour application.  I have browsed through the AutoCorres 0.1 sources, but <br>\ndid not see the totally unusual problem that requires completely different <br>\napproaches to what people are already used to.  It might be there <br>\nnonetheless, and this is why be have switched to the more interactive <br>\nmailing list.</p>\n<p>In your second question (actually answer) on Stackoverflow, you've had a <br>\nfunction to parse strings into tactic values like this:</p>\n<p>mk_tac \"metis Suc_eq_plus1 mult_Suc_right nat_add_commute\"</p>\n<p>But that is better done at compile-time via ML antiquotations, <br>\nspeculatively like this:</p>\n<p>@{metis Suc_eq_plus1 mult_Suc_right nat_add_commute}</p>\n<p>It is reasonably easy to implement such antiquotations -- they are part of <br>\nthe Isar user space just like methods, attributes etc. -- I can also give <br>\nsome examples.</p>\n<p>Although we first need to sort out what is conceptually the right way to <br>\ngo.  Antiquotations are some kind of ML preprocessor macros, and that is <br>\nnot something you do without thinking several times about it.</p>\n<p>Makarius</p>",
        "id": 294238122,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905703
    },
    {
        "content": "<p>From: David Greenaway &lt;<a href=\"mailto:david.greenaway@nicta.com.au\">david.greenaway@nicta.com.au</a>&gt;<br>\nHi Makarius,</p>\n<p>On 10/03/13 06:47, Makarius wrote:</p>\n<blockquote>\n<p>On Fri, 8 Mar 2013, David Greenaway wrote:</p>\n<blockquote>\n<p>In an Isabelle theory file, I can write simple one-line tactics such<br>\nas the following:</p>\n<p>apply (clarsimp simp: split_def split: prod.splits)</p>\n<p>I find, however, when I start writing ML code to automate proofs,<br>\nproducing a ML tactic object is far more verbose:</p>\n<p>clarsimp_tac (Context.proof_map (<br>\n     Simplifier.map_ss (fold Splitter.add_split @{thms prod.splits})<br>\n     #&gt; Simplifier.map_ss (fn ss =&gt; ss addsimps [@{thm split_def}]))<br>\n   @{context}) 1</p>\n<p>[...]<br>\nThe first hint is off-topic: ML has values and functions over values,<br>\nnot \"objects\".  Someone else had also used the oo-term \"method\" for ML<br>\nfunctions, but this is only adding confusion, and working against the<br>\nintentions of the oo-guys some decades ago: the idea back then was to<br>\nhave unusual terminology (\"objects\", \"methods\", \"classes\") for unusual<br>\nand groundbreaking concepts.</p>\n</blockquote>\n</blockquote>\n<p>Thank you for the correction. I did understand a tactic is simply a \"thm<br>\n-&gt; thm Seq.seq\", but have the bad habit of being imprecise in my<br>\nlanguage.</p>\n<blockquote>\n<p>Back to today's reality and the question how to work effectively and<br>\nsmoothly with Isabelle/ML, and how to write proof procedures in it.<br>\nHere is part of my answer from the Stackoverflow thread again:</p>\n<p>ML {*<br>\n   (*foo_tac -- the payload of what you want to do,<br>\n     note the dependency on ctxt: Proof.context*)<br>\n   fun foo_tac ctxt =<br>\n     let<br>\n       val my_ctxt =<br>\n         ctxt |&gt; Simplifier.map_simpset<br>\n          (fold Splitter.add_split @{thms prod.splits} #&gt;<br>\n           Simplifier.add_simp @{thm split_def})<br>\n     in ALLGOALS (clarsimp_tac my_ctxt) end<br>\n*}</p>\n<p>method_setup foo = {*<br>\n   (<em>concrete syntax like \"clarsimp\", \"auto\" etc.</em>)<br>\n   Method.sections Clasimp.clasimp_modifiers &gt;&gt;<br>\n     (<em>Isar method boilerplate</em>)<br>\n     (fn _ =&gt; fn ctxt =&gt; SIMPLE_METHOD (CHANGED (foo_tac ctxt)))<br>\n*}</p>\n<p>Here I had already applied some peep-hole optimization to make your<br>\ninitial version less awkward.  Instead of pasting together big ML<br>\nexpressions (also with antiquotations) in \"apply tactic {* ... *}\" you<br>\nbuild up small ML tools like foo_tac and eventually wrap them up in<br>\nconcrete Isar syntax via method_setup, for example.</p>\n</blockquote>\n<p>Your version is indeed cleaner than mine, but still not quite what I am<br>\nlooking for.</p>\n<p>I think the confusion comes from me not explaining fully what my goal<br>\nis. Your solution works well when 1 particular tactic needs to be used<br>\nin \"n\" locations. What I am trying to simplify is having \"n\" different<br>\ntactics each used in 1 single location (with that one location always<br>\nbeing inside an ML function).</p>\n<p>In short, I am looking for syntactic sugar to make writing proof scripts<br>\nin ML less verbose. While a lot of the heavy lifting of such proof<br>\nscripts can be done in Isar and the result used as a \"thm\", I still find<br>\nthat I need to carry out proofs inside ML (such as when the proof goal<br>\nis not known in advance).</p>\n<blockquote>\n<p>In your second question (actually answer) on Stackoverflow, you've had<br>\na function to parse strings into tactic values like this:</p>\n<p>mk_tac \"metis Suc_eq_plus1 mult_Suc_right nat_add_commute\"</p>\n<p>But that is better done at compile-time via ML antiquotations,<br>\nspeculatively like this:</p>\n<p>@{metis Suc_eq_plus1 mult_Suc_right nat_add_commute}</p>\n<p>It is reasonably easy to implement such antiquotations -- they are<br>\npart of the Isar user space just like methods, attributes etc. --<br>\nI can also give some examples.</p>\n</blockquote>\n<p>An anti-quotation that generates code similar to what I original wrote<br>\n(or perhaps what you corrected it to :) would be ideal.</p>\n<p>Two problems that I have, though are:</p>\n<p>* I can't extract a list of valid methods names (or their associated<br>\n      tactic) from the \"Method\" structure;</p>\n<p>* Even if I could get a list of method names, I can't see a way of<br>\n      parsing method arguments into an AST without re-implementing the<br>\n      parsing logic of every single tactic. (Most tactics are not so<br>\n      bad, because they use one of three possible argument parsers.<br>\n      Nevertheless, as far as I can tell these would need to be<br>\n      reimplemented to produce an AST instead of directly modifying the<br>\n      proof context directly).</p>\n<p>If you have any suggestions for solving these problems, I would be keen<br>\nto hear.</p>\n<p>Thanks so much,<br>\nDavid</p>",
        "id": 294238221,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905745
    },
    {
        "content": "<p>From: David Greenaway &lt;<a href=\"mailto:david.greenaway@nicta.com.au\">david.greenaway@nicta.com.au</a>&gt;<br>\nOn 08/03/13 12:36, David Greenaway wrote:</p>\n<blockquote>\n<p>In an Isabelle theory file, I can write simple one-line tactics such<br>\nas the following:</p>\n<p>apply (clarsimp simp: split_def split: prod.splits)</p>\n<p>I find, however, when I start writing ML code to automate proofs,<br>\nproducing a ML tactic object is far more verbose:<br>\n[...]<br>\nDoes anyone have any hints or tips?</p>\n</blockquote>\n<p>With the help of Thomas Sewell, I came up with the following solution:</p>\n<p>The \"Method\" class provides an interface to both generate a \"method\"<br>\nfrom a list of tokens, and to generate a \"cases_tactic\" from a method.<br>\nThese can be combined as follows:</p>\n<p>(*</p>\n<p>* Generate an ML tactic object of the given Isar string.<br>\n     *</p>\n<p>* For example,<br>\n     *</p>\n<p>*   mk_tac \"auto simp: field_simps intro!: ext\" @{context}<br>\n     *</p>\n<p>* will generate the corresponding \"tactic\" object.<br>\n     *)<br>\n    fun mk_tac str ctxt =<br>\n    let<br>\n      val parsed_str = Outer_Syntax.scan Position.start str<br>\n          |&gt; filter Token.is_proper<br>\n          |&gt; <a href=\"http://Args.name\">Args.name</a><br>\n      val meth = Method.method (Proof_Context.theory_of ctxt)<br>\n          (Args.src (parsed_str, Position.start)) ctxt<br>\n    in<br>\n      Method.apply (K meth) ctxt [] #&gt; <a href=\"http://Seq.map\">Seq.map</a> snd<br>\n    end</p>\n<p>or alternatively as an anti-quotation:</p>\n<p>(*</p>\n<p>* Setup an antiquotation of the form:<br>\n     *</p>\n<p>*    @{tactic \"auto simp: foo intro!: bar\"}<br>\n     *</p>\n<p>* which returns an object of type \"context -&gt; tactic\".<br>\n     *</p>\n<p>* While this doesn't provide any benefits over a direct call to \"mk_tac\" just<br>\n     * yet, in the future it may generate code to avoid parsing the tactic at<br>\n     * run-time.<br>\n     *)<br>\n    val tactic_antiquotation_setup =<br>\n    let<br>\n      val parse_string =<br>\n        ((Args.context -- Scan.lift <a href=\"http://Args.name\">Args.name</a>) &gt;&gt; snd)<br>\n          #&gt;&gt; ML_Syntax.print_string<br>\n          #&gt;&gt; (fn s =&gt; \"mk_tac \" ^ s)<br>\n          #&gt;&gt; ML_Syntax.atomic<br>\n    in<br>\n      ML_Antiquote.inline @{binding \"tactic\"} parse_string<br>\n    end</p>\n<p>and setup in a theory file as follows:</p>\n<p>setup {*<br>\n      tactic_antiquotation_setup<br>\n    *}</p>\n<p>This can then be used in ML code to generate a tactic:</p>\n<p>lemma \"(a :: nat) * (b + 1) = (a * b) + a\"<br>\n      by (tactic {* @{tactic \"metis Suc_eq_plus1 mult_Suc_right nat_add_commute\"} @{context} *})</p>\n<p>Hopefully this helps somebody other than just me.</p>\n<p>Cheers,<br>\nDavid</p>",
        "id": 294238234,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905758
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 11 Mar 2013, David Greenaway wrote:</p>\n<blockquote>\n<p>On 08/03/13 12:36, David Greenaway wrote:</p>\n<blockquote>\n<p>In an Isabelle theory file, I can write simple one-line tactics such<br>\nas the following:</p>\n<p>apply (clarsimp simp: split_def split: prod.splits)</p>\n<p>I find, however, when I start writing ML code to automate proofs,<br>\nproducing a ML tactic object is far more verbose:<br>\n[...]<br>\nDoes anyone have any hints or tips?</p>\n</blockquote>\n<p>With the help of Thomas Sewell, I came up with the following solution:</p>\n<p>The \"Method\" class provides an interface</p>\n</blockquote>\n<p>That is the <em>structure</em> Method in Isabelle/ML.  SML is free from any <br>\nobject-oriented concepts.  You should do justice to what the oo-guys tried <br>\nto do several decades ago by using their terminology properly.</p>\n<blockquote>\n<p>* While this doesn't provide any benefits over a direct call to \"mk_tac\" just<br>\n    * yet, in the future it may generate code to avoid parsing the tactic at<br>\n    * run-time.<br>\n    *)<br>\n   val tactic_antiquotation_setup =<br>\n   let<br>\n     val parse_string =<br>\n       ((Args.context -- Scan.lift <a href=\"http://Args.name\">Args.name</a>) &gt;&gt; snd)<br>\n         #&gt;&gt; ML_Syntax.print_string<br>\n         #&gt;&gt; (fn s =&gt; \"mk_tac \" ^ s)<br>\n         #&gt;&gt; ML_Syntax.atomic<br>\n   in<br>\n     ML_Antiquote.inline @{binding \"tactic\"} parse_string<br>\n   end</p>\n</blockquote>\n<p>Parsing at runtime gets you back to LISP-style dynamic macro programming. <br>\nML_Antiquote.value should do the job statically at compile time. <br>\nSometimes this requires auxiliary data in the context, to transport <br>\nabstract values between the runtime/compile time of Isabelle/ML.  E.g. see <br>\nhow the @{thm} antiquotation is done.  (To get to its implementation you <br>\nwrite something like ML {* @{thm refl} *} and use hover-click in <br>\nIsabelle/jEdit on \"thm\".)</p>\n<blockquote>\n<p>This can then be used in ML code to generate a tactic:</p>\n<p>lemma \"(a :: nat) * (b + 1) = (a * b) + a\"<br>\n     by (tactic {* @{tactic \"metis Suc_eq_plus1 mult_Suc_right nat_add_commute\"} @{context} *})</p>\n<p>Hopefully this helps somebody other than just me.</p>\n</blockquote>\n<p>The next one will ask for arguments that are not just constants like <br>\nSuc_eq_plus1, but ML expressions at run-time.</p>\n<p>Makarius</p>",
        "id": 294238240,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905764
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>Nice!</p>\n<p>I can use this to somewhat emulate the [1!] feature¹ suggested on<br>\nisabelle-dev, without patching Isabelle:</p>\n<p>notepad <br>\nbegin<br>\n  assume x: \"B\"<br>\n  assume y: \"A ⟹ B\"<br>\n  assume z: A<br>\n  have B<br>\n  apply ((tactic {* SOLVE (@{tactic \"rule x\"} @{context}) *})[1]) -- \"solves the goal, so it works\"<br>\n  done<br>\n  have B<br>\n  apply ((tactic {* SOLVE (@{tactic \"rule y\"} @{context}) *})[1]) -- \"does not solve it, hence fails\"<br>\n  sorry</p>\n<p>Unfortunately, it does not parse complete method text with , | + ...:<br>\n  have B<br>\n  apply ((tactic {* SOLVE (@{tactic \"rule y, rule z\"} @{context}) *})[1]) -- \"should solve, but doesn't parse\"<br>\n  done</p>\n<p>Do you think that would be possible as well?</p>\n<p>I tried to find a way, but a parsed sequence of proof methods is a<br>\nMethod.text, which is interpreted by Proof.apply_text, and I did not<br>\nfind a way to turn a aggregate Method.text to a Method.method to use<br>\nwith Method.apply.</p>\n<p>Thanks,<br>\nJoachim</p>\n<p>¹ <a href=\"https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2013-March/003911.html\">https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2013-March/003911.html</a><br>\n<a href=\"/user_uploads/14278/0Ab0RHEt2a3xJq-6rLtDK3cR/signature.asc\">signature.asc</a></p>",
        "id": 294238257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905777
    }
]