[
    {
        "content": "<p>From: Jan Olaf Blech &lt;<a href=\"mailto:blech@informatik.uni-kl.de\">blech@informatik.uni-kl.de</a>&gt;<br>\nHi,</p>\n<p>We use Isabelle/HOL in a compiler runtime verification <br>\nenvironment. The verification process comprises \"lookup <br>\noperations\" in lists, function updates and sets, i.e. <br>\nproving lemmata of the following form:</p>\n<p>lemma \"a mem [...,a,...]\"<br>\nlemma \"f (...,a:= b,...) a = b\"<br>\nlemma \"a : {...,a,...}\"</p>\n<p>If the lists, function updates, and sets grow large, these <br>\nlookups take up almost all of the time of a verification <br>\nrun. In our current version we instantiate Isabelle's <br>\nsimplifier with some simple rules like</p>\n<p>\"x  = a | x : A ==&gt; x : insert a A\"</p>\n<p>to achieve time linear to the size of the underlying <br>\nstructure the lookup is conducted on.<br>\nHowever a lookup still takes quite long: several minutes <br>\nfor a list of a few thousand elements. For the <br>\nverification of some relatively small programs thousands <br>\nof lookups are needed in structures containing thousands <br>\nof elements.</p>\n<p>Is anyone aware of a technique to do this faster?</p>\n<p>What do you think of \"bypassing\" Isabelle's simplifier to <br>\nmake such lookups faster? One problem is probably that we <br>\nwould \"spoil\" the Isabelle implementation and the \"trusted <br>\ncomputing base\" would grow larger.</p>\n<p>Regards</p>\n<p>Jan Olaf Blech</p>",
        "id": 294042797,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816048
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThere are several possible solutions.</p>\n<ol start=\"0\">\n<li>\n<p>If your application is executable you may be able to generate ML code <br>\nfrom it and run it completely independently of Isabelle. The speedup <br>\nwill be about 100. If it is almost executable, it may be worth making it <br>\nfully executable (eg an implementation of finite sets as lists is <br>\nalready in the Library).</p>\n</li>\n<li>\n<p>You, as you say, bypass the the simplifier by writing an oracle, i.e. <br>\ntrusted piece of ML code that checks if an element is in a list/set. <br>\nThis is probably the quick an dirty solution (although you need to <br>\nfamiliarize yourself with oracles).</p>\n</li>\n<li>\n<p>You explicitly use some efficient data structure rather than a list <br>\nor set, eg a binary tree. This is completely safe, requires no low-level <br>\ncoding, but you will need to develop the efficient data structure (the <br>\ntheory BinarySearchTree in the AFP may provide much of what you need) <br>\nand will need to use it rather than the abstract type of <br>\nlist/function/set (which should not complicate proofs much).</p>\n</li>\n<li>\n<p>Alternative 0 can also be used \"locally\" by compiling executable <br>\ngoals like \"a mem [...]\" into ML and executing them there. The <br>\ndevelopment version of Isabelle contains a proof method \"evaluation\" <br>\nwhich does just this. However, currently it can only be used to solve a <br>\ngoal outright and it is not integrated with other proof tools. More <br>\nflexible versions are in preparation.</p>\n</li>\n<li>\n<p>You can use \"reflection\" to translate you list/function/set problem <br>\ninto some efficient data structure and execute it there. In contrast to <br>\nalternative 2 you only do this reflection at specific points (when you <br>\nneed to solve expensive goals) but otherwise work with the usual <br>\nmathematical types of lists/sets/etc. Efficiency is guaranteed as in 3.</p>\n</li>\n</ol>\n<p>Thanks for bringing this up. Efficient executability is an important <br>\nissue we are working on at the moment. Challenge problems are welcome.</p>\n<p>Tobias</p>\n<p>Jan Olaf Blech schrieb:</p>",
        "id": 294042806,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816054
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@csee.ogi.edu\">brianh@csee.ogi.edu</a>&gt;<br>\nA good solution might be to write a simplification procedure (or simproc) to <br>\nsolve these kinds of subgoals. A simproc is an ML function that takes a term <br>\nt as an argument, and optionally returns a theorem of the form t == t'. You <br>\ncan learn more about them in the Isabelle reference manual.</p>\n<p>For example, you could write some ML code that examines terms of the form x : <br>\nA, checking to see whether term x occurs explicitly in the term A. If so, it <br>\ncould then build theorem of the form \"x : A == True\" using Eq_TrueI, insertI1 <br>\nand insertI2 together with some simple theorem combinators. If term x is not <br>\nfound in the term A, the simproc would just fail and do nothing (hopefully <br>\nthis is not the common case).</p>\n<p>Note that since a simproc builds an actual theorem that proves the equality, <br>\nyou aren't adding anything to the trusted code base. You should still get a <br>\nsignificant speedup, because the ML code would be much faster than making <br>\nhundreds of recursive calls to the simplifier.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294042824,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816061
    },
    {
        "content": "<p>From: Steven Obua &lt;<a href=\"mailto:obua@in.tum.de\">obua@in.tum.de</a>&gt;<br>\nThere is one more solution possibility, you could use the compute oracle <br>\nin Pure/Tools/compute.ML.<br>\nIt is already included in your Isabelle build (so it is somewhere <br>\nbetween the \"trusted base\" and the rest :-)),<br>\nyou can invoke it by calling once</p>\n<p>Compute.basic_make ....</p>\n<p>and then each time you simplify a term by</p>\n<p>Compute.rewrite ...</p>\n<p>There are two major drawbacks to this method:</p>\n<ol>\n<li>You can only simplify terms which contain no type variables.</li>\n<li>You have to configure the rewrite by calling Compute.basic_make and <br>\ngive it ALL the theorems used for rewriting;<br>\n    these theorems must not contain type variables, either;</li>\n</ol>\n<p>The no-type-variables limitation in 2) is not so bad if you know what <br>\ntypes you can possibly have in your terms; you can just instantiate the <br>\npolymorphic rewrite theorems with all types you need and give these to <br>\nCompute.basic_make.</p>\n<p>I have used above technique successfully for fast matrix multiplication, <br>\ngaining a speed-up-factor comparable to compilation.<br>\nIt is more trustworthy than compilation, though, because it builds <br>\ndirectly on Pure and makes no additional assumptions.</p>\n<p>Steven</p>",
        "id": 294042858,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816073
    }
]