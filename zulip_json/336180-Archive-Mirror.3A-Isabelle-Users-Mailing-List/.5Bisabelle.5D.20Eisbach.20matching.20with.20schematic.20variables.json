[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Eisbach experts and users,</p>\n<p>I have trouble to write a proof method that does the following:</p>\n<ol>\n<li>\n<p>Apply a rule called foo.<br>\nIt has two premises that both contain variables that are not bound by the conclusion of <br>\nfoo. Hence, the goal state consists of two goals with a schematic variable ?x in them.</p>\n</li>\n<li>\n<p>Work on the first subgoal by applying rules from a named_theorems collection my_rules. <br>\nThis is supposed to instantiate the variable ?x. All these rules in my_rules have one <br>\nconstant C as the head term, and they have premises with the same head constant, but there <br>\nmay also be premises with other terms (let's call them side conditions). As long as the <br>\ncurrent subgoal has C as head symbol, I want to apply the rules in my_rules, and I want to <br>\napply some proof automation (like clarsimp or auto) to the side conditions. In particular, <br>\nI want to make sure that clarsimp and auto are _never_ applied to a goal with C as head <br>\nsymbol.</p>\n</li>\n</ol>\n<p>This should be done iteratively until either<br>\n(a) the goal arising from step 1 is solved or<br>\n(b) the current subgoal has C as head symbol, but there's no matching rule in my_rules, or<br>\n(c) one of the side conditions is not solved by clarsimp and auto.</p>\n<p>I tried to write the proof method with Eisbach, but I failed to make the distinction based <br>\non the head symbol. Here's my attempt:</p>\n<p>method step =<br>\n   (match conclusion in \"foo p1 p2 p3\" for p1 p2 p3 =&gt; rule my_rules<br>\n   \\&lt;bar&gt; H for H =&gt; \\&lt;open&gt;solves \\&lt;open&gt;clarsimp\\&lt;close&gt;\\&lt;close&gt;)<br>\nmethod my_method = (rule foo, (step+)?)</p>\n<p>The problem is that the match method seems to turn the schematic variable ?x into a fixed <br>\nvariable x, which the rules in my_rules can no longer instantiate.</p>\n<p>Can I somehow achieve with Eisbach what I want?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294694527,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177984
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Dan,</p>\n<p>Thanks for the suggestion with fail in the interesting case. That indeed gets me out of <br>\nthe subgoal focus of match. Indeed, a light-weight match without subgoal focus and without <br>\nbinding in the first place would be nice.</p>\n<p>Andreas</p>",
        "id": 294696293,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178198
    },
    {
        "content": "<p>From: <a href=\"mailto:Daniel.Matichuk@data61.csiro.au\">Daniel.Matichuk@data61.csiro.au</a><br>\nHi Andreas,</p>\n<p>The incompatibility with match and schematic variables is a known limitation, and unfortunately it's actually a hard problem to solve in general. Currently the \"match\" method performs a subgoal focus when matching on the conclusion or premises in order to turn them into proper terms/facts. This allows you to, for example, refer to \"p1\" (in your example) inside your method body and have it still make sense if p1 contained a goal parameter. This focus, however, needs to turns schematics into fixed terms for a number of reasons, most of which is so that they can't suddenly depend on goal parameters that they didn't before (i.e. in the case of \"!!x y. (?P x) /\\ (?Q y)\").</p>\n<p>Makarius and I had some discussions about how to handle this particular situation, we were leaning towards making methods \"smarter\" and realising that certain fixed parameters were actually schematics in the context and knowing how to instantiate them. </p>\n<p>The other more lightweight solution we thought of was to introduce a non-focusing match, i.e. a match that does not manipulate the goal state or try to bind goal elements. This seems more like what you would want in your current situation. It's not immediately clear how this would interact with nested matches, however.</p>\n<p>That all being said, I believe your particular situation can be resolved simply by putting \"rule my_rules\" outside of the match body itself. This is not the most elegant solution, but it should get the job done.</p>\n<p>method step =<br>\n((match conclusion in <br>\n  \"foo p1 p2 p3\" for p1 p2 p3 ⇒ ‹fail›<br>\n  ¦ H for H ⇒ ‹solves ‹clarsimp››) | (rule my_rules))</p>\n<p>The match will not backtrack past the fact that it matched \"foo p1 p2 p3\" and will immediately fail through to \"rule my_rules\".</p>\n<p>Hopefully this resolves your issue.</p>\n<p>-Dan</p>\n<p>P.S.</p>\n<p>The \"_\" pattern is valid in the match method, so we can make your method a bit more succinct.</p>\n<p>method step =<br>\n((match conclusion in <br>\n  \"foo _ _ _\" ⇒ ‹fail›<br>\n  ¦ _ ⇒ ‹solves ‹clarsimp››) | (rule my_rules))[1]</p>",
        "id": 294696348,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178217
    }
]