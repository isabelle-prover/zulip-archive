[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere are further examples for embedded languages in Isabelle:</p>\n<p>Isabelle2019/src/Pure/Tools/rail.ML<br>\n  Isabelle2019/src/Pure/Syntax/simple_syntax.ML</p>\n<p>Both is based on Isabelle parser combinators. There is also proper<br>\nsupport for formal positions and Prover IDE markup in the rail<br>\napplication -- without that an Isabelle language is not complete.</p>\n<p>(Note on browsing sources in Isabelle/Pure: Documentation panel, entry<br>\nsrc/Pure/ROOT.ML + its explanation at the top of the file.)</p>\n<p>I don't think that your first idea to change the Isabelle term language<br>\nwill work out in general: certain assumptions about lexical syntax and<br>\nidentifiers are deeply rooted in the system. There are some explanations<br>\non formal names in section 1.2 of the \"implementation\" manual (see the<br>\nDocumentation panel in Isabelle/jEdit). In particular, the system may<br>\ntransform names within a term in certain situation, e.g. \"x\" could<br>\nbecome \"x_\" or \"xa\" or \"?xa\" later on.</p>\n<p>You did not say anything about the application context nor the overall<br>\nmotivation. There might be more plain and basic approaches, e.g. an<br>\napplication notation \\&lt;app&gt; where this newly allocated Isabelle symbol<br>\nis rendered as a thin space.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/igOzhh5AvXVM0kB57FLI-psQ/signature.asc\">signature.asc</a></p>",
        "id": 294763761,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200904
    },
    {
        "content": "<p>From: Daniel Kirchner &lt;<a href=\"mailto:daniel@ekpyron.org\">daniel@ekpyron.org</a>&gt;<br>\nThank you very much for your pointers!<br>\nI already looked at Pure/Syntax/simple_syntax.ML, but Pure/Tools/rail.ML <br>\nindeed looks quite helpful, especially with respect to the Prover IDE markup <br>\n(I already tried to implement that in my preliminary approaches, but the <br>\nexample will prove very helpful, even though I might move to a different <br>\napproach altogether for my current application at least for now, see below).</p>\n<p>To say a bit more about my application: I'm constructing a shallow semantic <br>\nembedding of a philosophical logic (Edward Zalta's \"Theory of Abstract <br>\nObjects\"). That logic is quite different from HOL in multiple ways, which makes <br>\nthis an interesting research project. For example the language contains two <br>\nkinds of atomic formulas, i.e. Fxy \"x and y 'exemplify' F\" and xyF \"x and y <br>\n'encode' F\", neither of which can be implemented as mere function application <br>\nin an embedding in HOL. The variable names have type implications, e.g. x and <br>\ny have a different type than F and G, which again have a different type from <br>\ne.g. \\kappa, etc. - some of these types map directly to types in HOL, others I <br>\nneed to implement with guarding behind additional constants, etc.<br>\nMy basic implementation maps all these concepts to constructs in the Isabelle <br>\nterm language in a working, but not in a user-friendly way - e.g. I need <br>\nspecial syntax for both exemplification and encoding and at times explicit type <br>\nannotations (resp. \"type guard constants\"), etc.<br>\nIn other words I have a working implementation of the logic, but not of its <br>\nsyntax (i.e. I can map formulas of the logic to corresponding \"not-so-nice-<br>\nlooking\" formulas in Isabelle's term language, but this mapping is \"manual <br>\neffort\").</p>\n<p>So what I'm currently trying to research is how close I can get to the actual <br>\nsyntax of the target language directly in Isabelle, so that a person who is <br>\nused to the target logic has an easier time working with the embedding.</p>\n<p>The target logic itself also defines new symbols in terms of its basic symbols, <br>\nso the implementation should be extensible very much like with mixfix <br>\nannotations to constants or \"syntax\" commands. That's why I'm trying to avoid <br>\nduplicating an implementation of a priority grammar. (The definitions in the <br>\ntarget logic themselves are not quite the same as Isar definitions, so I will <br>\nprobably introduce new outer syntax commands for them, but in the end they <br>\nwill translate to \"plain\", but more complex definitions satisfying the narrowly <br>\ndefined inferential role of definitions in the hyper-intensional free logic of <br>\nthe target system).</p>\n<p>At the moment I'm trying to only <em>parse</em> the actual syntax of the language, <br>\nnot to print it, i.e. a formula given in the syntax of the target logic, will <br>\nbe translated to its representation in Isabelle's term logic and further <br>\nreasoning will be done in Isabelle's term logic directly (I think this should <br>\nalleviate the problem of transformed names like x_ and xa, but at a later <br>\nstage it might also be interesting to go further and print in the target <br>\nlogic's syntax and continue reasoning in it as well, for which this indeed <br>\nwill be an issue).</p>\n<p>Given that I basically need to support something like mixfix notation for <br>\nextending the syntax and reproducing a suitable variant of the Isabelle term <br>\nlanguage manually from strings or cartouches in the end seems like an <br>\nunnecessary duplication of work (especially since Pure/Syntax/syntax.ML, Pure/<br>\nSyntax/syntax_phases.ML, etc., are not exactly meant to be used like this), <br>\nI'm now trying to mainly stay within the Isabelle term language itself. <br>\nInterestingly, only now after looking through the syntax parsing ML code I <br>\nrealize that I can do much more than I thought within its boundaries.</p>\n<p>Simplified that approach will look like</p>\n<p>consts valid :: \"p =&gt; bool\"<br>\nconsts emb_implies :: \"p =&gt; p =&gt; p\"<br>\nnonterminal q<br>\nsyntax valid :: \"q =&gt; bool\" (\"[\\Turnstile _]\")<br>\n             emb_implies \"q =&gt; q =&gt; q\" (infixl \"-&gt;\" 8)<br>\n             emb_not \"q =&gt; q\" (\"\\&lt;not&gt;_\" [40] 70)<br>\n             \"_atomic_formula\" :: \"id_position =&gt; q\" (\"_\")<br>\netc.</p>\n<p>and then installing a parse_ast_translation for \"_atomic_formula\" which splits <br>\nup e.g. \"Fxy\" to \"(_exe F x y)\" and \"xyF\" to \"(_enc x y F)\", which is then <br>\ntranslated to the corresponding term in a parse_translation.</p>\n<p>So far this is working out quite well and is alleviating the need to deal with <br>\nmarkup myself for now, so I will see how far I will get with this approach.</p>\n<p>Regarding your suggestion to introduce something like \"\\&lt;app&gt;\", printed as a <br>\nthin space: I actually tried this at one point and attempted to introduce <br>\n\"\\&lt;delim&gt;\" to be printed as zero-width-space, but (1) this still makes it <br>\nharder to type formulas in the target logic and might actually be quite <br>\nconfusing and (2) I had some issues with jedit at least with zero-width spaces <br>\n(I'm not sure about thin spaces anymore) - unfortunately I don't quite <br>\nremember what these issues were right now.</p>\n<p>In any case: I think I can work with this for now and thank you very much for <br>\nyour help so far and for clarifying the fact that the ML parsing <br>\ninfrastructure for Isabelle's term language is probably best not to be re-/<br>\nabused for purposes like this.</p>\n<p>In general in the long run it would, of course, be nice to have a self-<br>\ncontained \"reentrant\" and \"public\" version of the parser for Isabelle's term <br>\nlanguage in ML, in which every aspect could be customized, including the <br>\nlexicon and tokenizing and maybe even the generation of \"fresh\" variable <br>\nnames, etc. - but I realize that this is way too much to ask especially for my <br>\nvery specific and probably rather exotic use case :-).</p>\n<p>Best wishes,<br>\nDaniel Kirchner<br>\n<a href=\"/user_uploads/14278/4W1hYTbBnnlUKB1daiFkvmGx/signature.asc\">signature.asc</a></p>",
        "id": 294763769,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200911
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/10/2019 17:29, Daniel Kirchner wrote:</p>\n<blockquote>\n<p>To say a bit more about my application: I'm constructing a shallow semantic <br>\nembedding of a philosophical logic (Edward Zalta's \"Theory of Abstract <br>\nObjects\"). That logic is quite different from HOL in multiple ways, which makes <br>\nthis an interesting research project. For example the language contains two <br>\nkinds of atomic formulas, i.e. Fxy \"x and y 'exemplify' F\" and xyF \"x and y <br>\n'encode' F\", neither of which can be implemented as mere function application <br>\nin an embedding in HOL. The variable names have type implications, e.g. x and <br>\ny have a different type than F and G, which again have a different type from <br>\ne.g. \\kappa, etc. - some of these types map directly to types in HOL, others I <br>\nneed to implement with guarding behind additional constants, etc.</p>\n</blockquote>\n<p>Thanks for the general application outline -- it is always important to<br>\nkeep the big picture in mind. A language that is very different from the<br>\nIsabelle/Pure lambda calculus (which is reused in the Isabelle/HOL<br>\nlibrary) definitely poses a challenge. It will require very careful<br>\nexploration to do just the right thing, otherwise it will lead to an<br>\nunmaintainable blob of \"code\" that nobody can understand nor maintain.</p>\n<blockquote>\n<p>The target logic itself also defines new symbols in terms of its basic symbols, <br>\nso the implementation should be extensible very much like with mixfix <br>\nannotations to constants or \"syntax\" commands. That's why I'm trying to avoid <br>\nduplicating an implementation of a priority grammar. (The definitions in the <br>\ntarget logic themselves are not quite the same as Isar definitions, so I will <br>\nprobably introduce new outer syntax commands for them, but in the end they <br>\nwill translate to \"plain\", but more complex definitions satisfying the narrowly <br>\ndefined inferential role of definitions in the hyper-intensional free logic of <br>\nthe target system).</p>\n</blockquote>\n<p>Note that there are different levels of complexity rolled into Isabelle<br>\nterm notation. A command like 'notation' with plain mixfix is relatively<br>\nclose to the priority grammer: if you subtract special things like<br>\n'binder' from the mixfix syntax, it is even simpler. In contrast,<br>\n'syntax' + 'translations' (or 'parse_translation' etc.) opens a not so<br>\nclearly defined space of adhoc syntax additions. If your own language<br>\ndoes not require that, it would greatly simplify a standalone<br>\nimplementation of it (one that is independent of the Isabelle \"syntax<br>\nphases\").</p>\n<blockquote>\n<p>At the moment I'm trying to only <em>parse</em> the actual syntax of the language, <br>\nnot to print it, i.e. a formula given in the syntax of the target logic, will <br>\nbe translated to its representation in Isabelle's term logic and further <br>\nreasoning will be done in Isabelle's term logic directly (I think this should <br>\nalleviate the problem of transformed names like x_ and xa, but at a later <br>\nstage it might also be interesting to go further and print in the target <br>\nlogic's syntax and continue reasoning in it as well, for which this indeed <br>\nwill be an issue).</p>\n</blockquote>\n<p>BTW, printing also means document output of the sources in HTML or<br>\nLaTeX. There is an implicit assumption that adjacent letters for one<br>\nword, not individual identifiers. Compare this with LaTeX typesetting of<br>\n$abc$ vs. \\emph{abc}. Presently, there is no proper way in the document<br>\npreparation system to change the typesetting of names, but it is<br>\nconceivable that a future notion of antiquotations within terms could<br>\nalso go through document presentation.</p>\n<blockquote>\n<p>I'm now trying to mainly stay within the Isabelle term language itself. <br>\nInterestingly, only now after looking through the syntax parsing ML code I <br>\nrealize that I can do much more than I thought within its boundaries.</p>\n<p>Simplified that approach will look like</p>\n<p>consts valid :: \"p =&gt; bool\"<br>\nconsts emb_implies :: \"p =&gt; p =&gt; p\"<br>\nnonterminal q<br>\nsyntax valid :: \"q =&gt; bool\" (\"[\\Turnstile _]\")<br>\n             emb_implies \"q =&gt; q =&gt; q\" (infixl \"-&gt;\" 8)<br>\n             emb_not \"q =&gt; q\" (\"\\&lt;not&gt;_\" [40] 70)<br>\n             \"_atomic_formula\" :: \"id_position =&gt; q\" (\"_\")<br>\netc.</p>\n<p>and then installing a parse_ast_translation for \"_atomic_formula\" which splits <br>\nup e.g. \"Fxy\" to \"(_exe F x y)\" and \"xyF\" to \"(_enc x y F)\", which is then <br>\ntranslated to the corresponding term in a parse_translation.</p>\n</blockquote>\n<p>This looks much better to me. It deescalates the overall complexity of<br>\nthe implementation by some orders of magnitude.</p>\n<p>Apart from id_position you can also experiment with cartouches for<br>\ncertain well-defined sub-languages.</p>\n<blockquote>\n<p>In general in the long run it would, of course, be nice to have a self-<br>\ncontained \"reentrant\" and \"public\" version of the parser for Isabelle's term <br>\nlanguage in ML, in which every aspect could be customized, including the <br>\nlexicon and tokenizing and maybe even the generation of \"fresh\" variable <br>\nnames, etc. - but I realize that this is way too much to ask especially for my <br>\nvery specific and probably rather exotic use case :-).</p>\n</blockquote>\n<p>This sounds a bit like marketing talk for \"software frameworks\". Such<br>\nsoftware components don't exist, and where people have tried it its has<br>\nlead to maintenance nightmares.</p>\n<p>The inner syntax implementation of Isabelle/Pure is the opposite of<br>\nthat. It has many special tricks based on the particular situation to<br>\nmake it just work by accident. I have reworked the architecture and<br>\nimplementation many times in the past 25 years. A few more reforms of it<br>\nare still in the pipeline, e.g. subterm PIDE markup as seen in the tiny<br>\nrail example.</p>\n<p>Such reforms naturally break bad applications of it -- or the other way<br>\nround: bad applications prevent further reforms.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/27gkr0_QVVmZWSU2472TAFgM/signature.asc\">signature.asc</a></p>",
        "id": 294763884,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200968
    }
]