[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Mikhail,</p>\n<blockquote>\n<p>Nonetheless, I am not certain whether/how it resolves the most fundamental<br>\nissue. Many constants require some form of the totality of the relation as<br>\na prerequisite for the possibility of a transfer rule to be established,<br>\ne.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc methods<br>\nto avoid having to deal with the transfer of such constants (e.g. by<br>\nconverting the statements of the theorems to the form that uses Ball/Bex,<br>\nwhile partially relying on tailor-made automation to achieve this).<br>\nHowever, I wonder whether there exists a more native solution (after all,<br>\nthe premises should always carry sufficient information for the transfer to<br>\nsucceed).</p>\n<p>All/Ex and friends are a thorny issue when it comes to transfer. Essentially, transfer <br>\nlooks at the syntactic structure of the term, decomposes it into atoms and tries to prove <br>\nthe transferring rule by composing the transfer rules for each following the rules for the <br>\nconnectives of the terms (application and abstractions). In particular, properties <br>\nemerging from the interplay of different constants in the term are not taken into account.</p>\n</blockquote>\n<p>The following example illustrates this issue. The following three statements are logically <br>\nequivalent:</p>\n<p>(1) Ball A P<br>\n(2) !x. x : A --&gt; P x<br>\n(3) !!x. x : A ==&gt; P x</p>\n<p>For transfer, (1) is the most suitable one because the interplay of quantification, <br>\nmembership and implication is captured in one constant Ball. This interplay is captured in <br>\nBall's transfer rule, which does not make any assumptions on the relation on the elements.</p>\n<p>However, we often write statements of form (3) because they play well with Pure's natural <br>\ndeduction, and terms of form (2) are generated by various packages and methods (e.g., <br>\natomize -- and transfer also rewrites (3) into (2) as a preparatory step).</p>\n<p>So, if you state your example lemma as follows, everything should work without the need <br>\nfor bi-totality.</p>\n<p>lemma [rule_format]:<br>\n   includes lifting_syntax<br>\n   assumes [transfer_rule]: \"monoid_eq' C F G\"<br>\n   shows \"!a ∈ carrier G. !b ∈ carrier G. a ⊗⇘F⇙ b = a ⊗⇘G⇙ b\"</p>\n<p>Some preprocessing can get you a long way in this direction. Unfortunately, I haven't <br>\nfound a one-size-fits-all solution for these problems (and I don't believe that such a <br>\nthing exists in general). Given Isabelle's interactive nature, a promising approach is to <br>\nidentify recurring patterns and then automate these patterns accordingly.</p>\n<blockquote>\n<p>As a side remark, I tried to explain the issue that is described in the<br>\nprevious paragraph of this email in the last two paragraphs of my previous<br>\nemail. However, having re-read them, I realized that I missed the point<br>\nalmost completely: please ignore the last two paragraphs of my previous<br>\nemail. Nonetheless, the example before the last paragraph is still relevant:</p>\n<p>lemma carrier_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq' C ===&gt; rel_set (eq_onp C)) carrier carrier\"<br>\n   unfolding monoid_eq'_def monoid_eq_def  eq_onp_def rel_set_def<br>\n   using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>\n   by blast</p>\n<p>lemma [transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(eq_onp C ===&gt; eq_onp C ===&gt; (=)) (=) (=)\"<br>\n   unfolding eq_onp_def by auto<br>\nInstead of this rule, you want to tell transfer that eq_onp relations are bi-unique. The <br>\nrule is missing from the library, but it's in one of my AFP entries:</p>\n</blockquote>\n<p><a href=\"https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D\">https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D</a></p>\n<blockquote>\n<p>lemma [transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(eq_onp C ===&gt; rel_set (eq_onp C) ===&gt; (=)) (∈) (∈)\"<br>\n   unfolding eq_onp_def rel_set_def by auto</p>\n</blockquote>\n<p>This should also be solved by declaring bi_unique_eq_onp as [transfer_rule].</p>\n<blockquote>\n<p>lemma<br>\n   includes lifting_syntax<br>\n   assumes [transfer_rule]: \"monoid_eq' C F G\"<br>\n   shows \"a ∈ carrier G ⟹ b ∈ carrier G ⟹ a ⊗⇘G⇙ b = a ⊗⇘G⇙ b\"<br>\n   apply transfer<br>\n   (<em>Transfer.Rel ((eq_onp C ===&gt; (=)) ===&gt; (=)) ?aa25 transfer_forall</em>)<br>\n   oops</p>\n<p>Lastly, please accept my apologies for asking so many questions on this<br>\ntopic lately. The reason for this is that I am trying to be careful to<br>\nensure that the framework for transfer is designed in a more-or-less<br>\ncanonical manner, as I believe that it has a potential for being<br>\ngeneralized to arbitrary partial equivalence relations on set-based<br>\nstructures defined using records (or similar). Naturally, I will share it<br>\nunder the terms of a BSD license when/if it will reach a certain state of<br>\ngenerality and maturity.</p>\n</blockquote>\n<p>No need to apologize. I'm happy to chat about these things.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294826007,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661244473
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Andreas Lochbihler/All,</p>\n<p>Thank you for your reply. I will allow myself to provide several concluding<br>\nremarks in an attempt to close this issue.</p>\n<p>Nonetheless, I am not certain whether/how it resolves the most fundamental</p>\n<p>issue. Many constants require some form of the totality of the relation as</p>\n<p>a prerequisite for the possibility of a transfer rule to be established,</p>\n<p>e.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc methods</p>\n<p>to avoid having to deal with the transfer of such constants (e.g. by</p>\n<p>converting the statements of the theorems to the form that uses Ball/Bex,</p>\n<p>while partially relying on tailor-made automation to achieve this).</p>\n<p>However, I wonder whether there exists a more native solution (after all,</p>\n<p>the premises should always carry sufficient information for the transfer to</p>\n<p>succeed).</p>\n<p>All/Ex and friends are a thorny issue when it comes to transfer.</p>\n<blockquote>\n<p>Essentially, transfer<br>\nlooks at the syntactic structure of the term, decomposes it into atoms and<br>\ntries to prove<br>\nthe transferring rule by composing the transfer rules for each following<br>\nthe rules for the<br>\nconnectives of the terms (application and abstractions). In particular,<br>\nproperties<br>\nemerging from the interplay of different constants in the term are not<br>\ntaken into account.</p>\n</blockquote>\n<blockquote>\n<p>...<br>\n</p>\n</blockquote>\n<p>So, if you state your example lemma as follows, everything should work</p>\n<blockquote>\n<p>without the need<br>\nfor bi-totality.<br>\nlemma [rule_format]:<br>\n   includes lifting_syntax<br>\n   assumes [transfer_rule]: \"monoid_eq' C F G\"<br>\n   shows \"!a ∈ carrier G. !b ∈ carrier G. a ⊗⇘F⇙ b = a ⊗⇘G⇙ b\"</p>\n</blockquote>\n<p>Thank you for the detailed explanation. Nevertheless, I have to mention<br>\nthat I am, to a certain degree, familiar with the algorithm that is used by<br>\nthe Isabelle's transfer tool. Therefore, of course, instead of \"for the<br>\ntransfer to succeed\" I should have written \"for a transfer-like algorithm<br>\nto succeed\". In any case, I believe that this was the intended meaning of<br>\nthe last sentence of the first quoted paragraph above. Also, in the same<br>\nparagraph, I mentioned that I was already able to partially automate the<br>\nprocess of the conversion of the goals of the form \"!!a b. a ∈ carrier G ⟹<br>\nb ∈ carrier G ⟹ a ⊗⇘G⇙ b = a ⊗⇘G⇙ b\" to the form \"!a ∈ carrier G. !b ∈<br>\ncarrier G. a ⊗⇘F⇙ b = a ⊗⇘G⇙ b\" at the time of writing. However, such<br>\nautomation only works in very simple cases (by now, I have already<br>\nencountered a use case where my methodology fails). Nonetheless, based on<br>\nwhat I have experimented with, it felt like it should be possible to devise<br>\na transfer-like algorithm that would work almost always even if the<br>\ntotality cannot be guaranteed (i.e. the transfer needs to be established<br>\nbetween two subsets).</p>\n<blockquote>\n<p>Some preprocessing can get you a long way in this direction.<br>\nUnfortunately, I haven't<br>\nfound a one-size-fits-all solution for these problems (and I don't believe<br>\nthat such a<br>\nthing exists in general). Given Isabelle's interactive nature, a promising<br>\napproach is to<br>\nidentify recurring patterns and then automate these patterns accordingly.<br>\n</p>\n</blockquote>\n<p>I am slightly disappointed. However, at least, that what you have stated<br>\ngives me confidence that the problem that I have encountered is far from<br>\nbeing trivial and, currently, there is no canonical solution that would<br>\nmake it possible to fully automate the transfer of results between two<br>\narbitrary subsets. Nonetheless, it feels like this limitation is a dramatic<br>\ngap in the capabilities of the transfer tool (of course, I am aware that<br>\nthis use case has never been advertised as one of the target applications<br>\nof the tool).</p>\n<blockquote>\n<p>Instead of this rule, you want to tell transfer that eq_onp relations are<br>\nbi-unique. The<br>\nrule is missing from the library, but it's in one of my AFP entries:</p>\n<p>Undeniably, I can be slightly reckless when writing code for forums/mailing<br>\nlists: most certainly, this was not a copy of my working version of the<br>\ncode :). Thank you for pointing out this flaw.</p>\n</blockquote>\n<hr>\n<p>Having tried every solution that was mentioned in this thread, I decided to<br>\nuse an explicit relation in favor of the solutions based on undefined.<br>\nNonetheless, I decided not to rely on transfer. Without an algorithm that<br>\nis capable of handling the \"interplay of quantification, membership and<br>\nimplication\" in a completely automated manner, unfortunately, in my view<br>\n(and taking into account my reasonably contrived use cases), it seems to be<br>\nmore natural to continue without transfer than having to rely on \"patchy\"<br>\nsolutions. Quite frankly, I found that a combination of locale<br>\ninterpretation + additional rules for the classical reasoners + specialized<br>\nsimpset in the form of a collection of named_theorems works reasonably well<br>\nin practice. While, from time to time, I have to use additional Isar code<br>\nto handle the equality, most proofs of the related steps look like this:<br>\n\"(auto simp: eq_simps)\", where eq_simps contains theorems of the form \"x ∈<br>\ncarrier F ⟹ y ∈ carrier F ⟹ x ⊗⇘G⇙ y = x ⊗⇘F⇙ y\". Naturally, I also<br>\nmaintain an additional set of introduction rules for the classical<br>\nreasoner.</p>\n<p>Having said this, it would be very interesting to understand whether it<br>\ncould be possible to develop a general transfer-like algorithm that could<br>\nwork without the requirement of the totality of the involved relations,<br>\ninferring the information about the membership directly from the<br>\npremises/assumptions (perhaps, augmented with some additional<br>\ninfrastructure). I believe that this could be useful in practice not only<br>\nfor my particular use case (i.e. equality) but also in many other similar<br>\ncases (e.g. consider the problem of the transfer of the results across an<br>\narbitrary isomorphism between two set-based structures).</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>On Wed, Apr 22, 2020 at 8:24 AM Andreas Lochbihler &lt;<br>\n<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Mikhail,</p>\n<blockquote>\n<p>Nonetheless, I am not certain whether/how it resolves the most<br>\nfundamental<br>\nissue. Many constants require some form of the totality of the relation<br>\nas<br>\na prerequisite for the possibility of a transfer rule to be established,<br>\ne.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc<br>\nmethods<br>\nto avoid having to deal with the transfer of such constants (e.g. by<br>\nconverting the statements of the theorems to the form that uses Ball/Bex,<br>\nwhile partially relying on tailor-made automation to achieve this).<br>\nHowever, I wonder whether there exists a more native solution (after all,<br>\nthe premises should always carry sufficient information for the transfer<br>\nto<br>\nsucceed).</p>\n<p>All/Ex and friends are a thorny issue when it comes to transfer.<br>\nEssentially, transfer<br>\nlooks at the syntactic structure of the term, decomposes it into atoms and<br>\ntries to prove<br>\nthe transferring rule by composing the transfer rules for each following<br>\nthe rules for the<br>\nconnectives of the terms (application and abstractions). In particular,<br>\nproperties<br>\nemerging from the interplay of different constants in the term are not<br>\ntaken into account.</p>\n</blockquote>\n<p>The following example illustrates this issue. The following three<br>\nstatements are logically<br>\nequivalent:</p>\n<p>(1) Ball A P<br>\n(2) !x. x : A --&gt; P x<br>\n(3) !!x. x : A ==&gt; P x</p>\n<p>For transfer, (1) is the most suitable one because the interplay of<br>\nquantification,<br>\nmembership and implication is captured in one constant Ball. This<br>\ninterplay is captured in<br>\nBall's transfer rule, which does not make any assumptions on the relation<br>\non the elements.</p>\n<p>However, we often write statements of form (3) because they play well with<br>\nPure's natural<br>\ndeduction, and terms of form (2) are generated by various packages and<br>\nmethods (e.g.,<br>\natomize -- and transfer also rewrites (3) into (2) as a preparatory step).</p>\n<p>So, if you state your example lemma as follows, everything should work<br>\nwithout the need<br>\nfor bi-totality.</p>\n<p>lemma [rule_format]:<br>\n   includes lifting_syntax<br>\n   assumes [transfer_rule]: \"monoid_eq' C F G\"<br>\n   shows \"!a ∈ carrier G. !b ∈ carrier G. a ⊗⇘F⇙ b = a ⊗⇘G⇙ b\"</p>\n<p>Some preprocessing can get you a long way in this direction.<br>\nUnfortunately, I haven't<br>\nfound a one-size-fits-all solution for these problems (and I don't believe<br>\nthat such a<br>\nthing exists in general). Given Isabelle's interactive nature, a promising<br>\napproach is to<br>\nidentify recurring patterns and then automate these patterns accordingly.</p>\n<blockquote>\n<p>As a side remark, I tried to explain the issue that is described in the<br>\nprevious paragraph of this email in the last two paragraphs of my<br>\nprevious<br>\nemail. However, having re-read them, I realized that I missed the point<br>\nalmost completely: please ignore the last two paragraphs of my previous<br>\nemail. Nonetheless, the example before the last paragraph is still<br>\nrelevant:</p>\n<p>lemma carrier_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq' C ===&gt; rel_set (eq_onp C)) carrier carrier\"<br>\n   unfolding monoid_eq'_def monoid_eq_def  eq_onp_def rel_set_def<br>\n   using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>\n   by blast</p>\n<p>lemma [transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(eq_onp C ===&gt; eq_onp C ===&gt; (=)) (=) (=)\"<br>\n   unfolding eq_onp_def by auto<br>\nInstead of this rule, you want to tell transfer that eq_onp relations are<br>\nbi-unique. The<br>\nrule is missing from the library, but it's in one of my AFP entries:</p>\n</blockquote>\n<p><a href=\"https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D\">https://search.isabelle.in.tum.de/#search/default_Isabelle2020-RC4_afp-2020-234a91c26d02?q=%7B%22term%22%3A%22bi_unique_eq_onp%22%2C%22facets%22%3A%7B%22SourceTheoryFacet%22%3A%5B%22CryptHOL.Misc_CryptHOL%22%5D%7D%7D</a></p>\n<blockquote>\n<p>lemma [transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(eq_onp C ===&gt; rel_set (eq_onp C) ===&gt; (=)) (∈) (∈)\"<br>\n   unfolding eq_onp_def rel_set_def by auto</p>\n</blockquote>\n<p>This should also be solved by declaring bi_unique_eq_onp as<br>\n[transfer_rule].</p>\n<blockquote>\n<p>lemma<br>\n   includes lifting_syntax<br>\n   assumes [transfer_rule]: \"monoid_eq' C F G\"</p>\n<p>[message truncated]</p>\n</blockquote>\n</blockquote>",
        "id": 294826086,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661244492
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Mikhail,</p>\n<p>I'm not surprised that option 2 creates a lot of effort because you change the locale <br>\nspecification. With option 1, you essentially get congruence rules of the form</p>\n<p>monoid_eq F G ==&gt; x : carrier G ==&gt; <a href=\"http://monoid.foo\">monoid.foo</a> F x = <a href=\"http://monoid.foo\">monoid.foo</a> G x</p>\n<p>for all derived concepts that are defined in monoid. Reasoning with such congruence rules <br>\ncan become cumbersome because the simplifier is not really able to reason with them <br>\nnatively. Moreover, you need a separate interpretation of monoid_eq for every pair of <br>\nmonoids you consider. If there are many, the number of interpretations grow quadratically <br>\nin the worst case.</p>\n<p>Defining the partial quotient as a type is not really feasible because type definitions <br>\nmust not depend on values in Isabelle/HOL, so you'd have to do the construction for every <br>\nfixed monoid separately.</p>\n<p>There are two further options that I want to mention. First, you can define a <br>\nnormalization function normalize :: 'a monoid =&gt; 'a =&gt; 'a via</p>\n<p>normalize F x = (if x : carrier F then x else undefined)</p>\n<p>and then lift it to a normalization function on monoid:</p>\n<p>normalize_monoid :: 'a monoid =&gt; 'a monoid</p>\n<p>that restricts the monoid operation to the carrier and sets it to undefined everywhere <br>\nelse. You can then prove</p>\n<p>monoid F ==&gt; normalize_monoid F</p>\n<p>and for all operations <a href=\"http://monoid.foo\">monoid.foo</a> defined on monoids equations such as the following:</p>\n<p>\"x : carrier F ==&gt; <a href=\"http://monoid.foo\">monoid.foo</a> F x = <a href=\"http://monoid.foo\">monoid.foo</a> (normalize_monoid F) x\"</p>\n<p>If you equip these equations with an assumption<br>\n   \"NO_MATCH (normalize_monoid G) F\"<br>\nthen you can even use them as simp rules without looping.</p>\n<p>So whenever you need to exploit the equality of monoids, you can add those equations to <br>\nthe simpset and switch all involved monoids F to \"normalize_monoid F\". And for these <br>\nnormalized monoids, you actually get the equality \"normalize_monoid F = normalize_monoid G\".</p>\n<p>A few caveats of this approach:</p>\n<ol>\n<li>\n<p>This only pays of if you have equalities between many monoids. If there are just two or <br>\nthree, it's probably not worth the effort.</p>\n</li>\n<li>\n<p>Going from F to normalize_monoid F works well for declarative proofs where you <br>\nexplicitly state the equality and then have simp transfer both sides. It does not work <br>\nwell with exploratory proof styles where you interactively develop the proof like with an <br>\napply script.</p>\n</li>\n<li>\n<p>The rewriting to normalize_monoid is limited to what simp can do. For example, <br>\nreplacements under higher-order operators like fold will not work in general because simp <br>\ncannot solve the side conditions _ : carrier _, even if you supply congruence rules.</p>\n</li>\n</ol>\n<p>The second approach is to use transfer. You can use your monoid_eq as a the relator for <br>\nmonoids and then prove appropriate transfer rules for all the operations on monoids. You <br>\nshould then be able to move from one monoid to the other by declaring the suitable <br>\nmonoid_eq fact as [transfer_rule] and let transfer do the rest. That's probably what I <br>\nwould go for.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294827288,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245075
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Andreas Lochbihler/All,</p>\n<p>Thank you for your reply. It contains very useful advice. However, I will<br>\nallow myself to provide several comments and make an attempt to clarify one<br>\npart of your answer that I may not have understood.</p>\n<p>Defining the partial quotient as a type is not really feasible because type</p>\n<blockquote>\n<p>definitions<br>\nmust not depend on values in Isabelle/HOL, so you'd have to do the<br>\nconstruction for every<br>\nfixed monoid separately.</p>\n</blockquote>\n<p>Of course, you are right, but I omitted an important detail from my<br>\nquestion: I specialize all structures to one particular type. Therefore, I<br>\nwas able to define a partial quotient type. Nonetheless, such an approach<br>\nresults in a substantial amount of duplication (moreover, there are other,<br>\nmore fundamental, complications) and I do not consider it to be the most<br>\npractical solution.</p>\n<p>...</p>\n<blockquote>\n<p>Reasoning with such congruence rules<br>\ncan become cumbersome because the simplifier is not really able to reason<br>\nwith them<br>\nnatively. Moreover, you need a separate interpretation of monoid_eq for<br>\nevery pair of<br>\nmonoids you consider. If there are many, the number of interpretations<br>\ngrow quadratically<br>\nin the worst case.<br>\n...<br>\nThe second approach is to use transfer. You can use your monoid_eq as a<br>\nthe relator for<br>\nmonoids and then prove appropriate transfer rules for all the operations<br>\non monoids. You<br>\nshould then be able to move from one monoid to the other by declaring the<br>\nsuitable<br>\nmonoid_eq fact as [transfer_rule] and let transfer do the rest. That's<br>\nprobably what I<br>\nwould go for.</p>\n</blockquote>\n<p>If I understood what is stated in your answer correctly, the second<br>\nsolution that you suggested is not entirely different from the first<br>\napproach that I proposed in my question. Naturally, I never suggested that<br>\none should rely on the simplifier/congruence rules exclusively. Indeed, I<br>\nrely predominantly on the capabilities of the transfer package to transfer<br>\nthe results across the members of a given equivalence class (however, I<br>\nonly mentioned it in passing in the last paragraph of the question and your<br>\nanswer gave me additional ideas for improvement of my own framework for<br>\ntransfer). Nonetheless, given what you have stated, I am still not certain<br>\nif I am using transfer in the best possible manner. For example, consider<br>\nthe following framework,</p>\n<p>locale monoid_eq = monoid G + monoid F for G F +<br>\n   assumes monoid_eq_carrier: \"carrier G = carrier F\"<br>\n     and monoid_eq_mult:<br>\n      \"x ∈ carrier G ⟹ y ∈ carrier G ⟹ x ⊗⇘G⇙ y = x ⊗⇘F⇙ y\"<br>\n     and monoid_eq_one: \"𝟭⇘G⇙ = 𝟭⇘F⇙\"</p>\n<p>definition monoid_eq_rel ::<br>\n  \"('a, 'b) monoid_scheme ⇒ ('a, 'c) monoid_scheme ⇒ 'a ⇒ 'a ⇒ bool\"<br>\n  where (*redundancy for symmetry :) *) \"monoid_eq_rel F G a b =<br>\n    (a = b ∧ a ∈ carrier F ∧ b ∈ carrier G ∧ monoid_eq F G)\"</p>\n<p>lemma eq_transfer[transfer_rule]:<br>\n  includes lifting_syntax<br>\n  shows \"(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (=) (=)\"<br>\n  unfolding monoid_eq_rel_def<br>\n  by (intro rel_funI) auto</p>\n<p>lemma carrier_transfer[transfer_rule]:<br>\n  includes lifting_syntax<br>\n  shows \"(monoid_eq ===&gt; (=)) carrier carrier\"<br>\n  unfolding monoid_eq_def<br>\n  using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>\n  by blast</p>\n<p>lemma mult_transfer[transfer_rule]:<br>\n  includes lifting_syntax<br>\n  shows \"(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (mult F) (mult<br>\nG)\"<br>\nproof(intro rel_funI)<br>\n  fix x y x' y'<br>\n  assume prems: \"monoid_eq_rel F G x y\" \"monoid_eq_rel F G x' y'\"<br>\n  then have myrel:<br>\n    \"x = y\" \"x' = y'\"<br>\n    \"x ∈ carrier F\" \"y ∈ carrier G\"<br>\n    \"x' ∈ carrier F\" \"y' ∈ carrier G\"<br>\n    \"monoid_eq F G\"<br>\n    unfolding monoid_eq_rel_def by auto<br>\n  interpret monoid_eq F G by (rule ‹monoid_eq F G›)<br>\n  show \"x ⊗⇘F⇙ x' = y ⊗⇘G⇙ y'\" using myrel by (simp add: monoid_eq_mult)<br>\nqed</p>\n<p>lemma Ball_transfer[transfer_rule]:<br>\n  includes lifting_syntax<br>\n  assumes \"monoid_eq F G\"<br>\n  shows \"((monoid_eq_rel F G ===&gt; (=)) ===&gt; (=))<br>\n    (Ball (carrier F)) (Ball (carrier G))\"<br>\n  unfolding Ball_def<br>\n  apply(intro rel_funI, unfold rel_fun_def)<br>\n  using assms by (metis monoid_eq.monoid_eq_carrier monoid_eq_rel_def)</p>\n<p>Now, as you suggested, many results can be conveniently transferred, e.g.</p>\n<p>lemma<br>\n  includes lifting_syntax<br>\n  assumes [transfer_rule]: \"monoid_eq F G\"<br>\n  shows \"∀a∈carrier G. ∀b∈carrier G. a ⊗⇘G⇙ b = a ⊗⇘G⇙ b\"<br>\n  apply transfer<br>\n  (<em>∀a∈carrier F. ∀b∈carrier F. a ⊗⇘F⇙ b = a ⊗⇘F⇙ b</em>)<br>\n  by simp</p>\n<p>However, I am not certain if this exactly what you had in mind when you<br>\nwrote your answer. Perhaps, the framework described above be improved<br>\nfurther in some way? I guess, it would make sense to generalize it to<br>\narbitrary partial equivalences. Also, how would one deal with the transfer<br>\nof Pure connectives? For example,</p>\n<p>lemma<br>\n  includes lifting_syntax<br>\n  assumes [transfer_rule]: \"monoid_eq F G\"<br>\n  shows \"a ∈ carrier G ⟹ b ∈ carrier G ⟹ a ⊗⇘G⇙ b = a ⊗⇘G⇙ b\"<br>\n  apply transfer<br>\n  (<em>((monoid_eq_rel ?F24 G ===&gt; (=)) ===&gt; (=)) ?aa23 transfer_forall</em>)<br>\n  by simp</p>\n<p>I guess, this problem is also not specific to equality, but any partial<br>\nequivalence relation (or, even more generally, any relation between two<br>\narbitrary subsets). I can see that one could automate atomization and<br>\nintroduction of Pure connectives before and after performing<br>\ntransfer, respectively. Nonetheless, I am curious whether there exists a<br>\nmore native solution.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>On Sat, Apr 18, 2020 at 12:18 PM Andreas Lochbihler &lt;<br>\n<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Mikhail,</p>\n<p>I'm not surprised that option 2 creates a lot of effort because you change<br>\nthe locale<br>\nspecification. With option 1, you essentially get congruence rules of the<br>\nform</p>\n<p>monoid_eq F G ==&gt; x : carrier G ==&gt; <a href=\"http://monoid.foo\">monoid.foo</a> F x = <a href=\"http://monoid.foo\">monoid.foo</a> G x</p>\n<p>for all derived concepts that are defined in monoid. Reasoning with such<br>\ncongruence rules<br>\ncan become cumbersome because the simplifier is not really able to reason<br>\nwith them<br>\nnatively. Moreover, you need a separate interpretation of monoid_eq for<br>\nevery pair of<br>\nmonoids you consider. If there are many, the number of interpretations<br>\ngrow quadratically<br>\nin the worst case.</p>\n<p>Defining the partial quotient as a type is not really feasible because<br>\ntype definitions<br>\nmust not depend on values in Isabelle/HOL, so you'd have to do the<br>\nconstruction for every<br>\nfixed monoid separately.</p>\n<p>There are two further options that I want to mention. First, you can<br>\ndefine a<br>\nnormalization function normalize :: 'a monoid =&gt; 'a =&gt; 'a via</p>\n<p>normalize F x = (if x : carrier F then x else undefined)</p>\n<p>and then lift it to a normalization function on monoid:</p>\n<p>normalize_monoid :: 'a monoid =&gt; 'a monoid</p>\n<p>that restricts the monoid operation to the carrier and sets it to<br>\nundefined everywhere<br>\nelse. You can then prove</p>\n<p>monoid F ==&gt; normalize_monoid F</p>\n<p>and for all operations <a href=\"http://monoid.foo\">monoid.foo</a> defined on monoids equations such as the<br>\nfollowing:</p>\n<p>\"x : carrier F ==&gt; <a href=\"http://monoid.foo\">monoid.foo</a> F x = <a href=\"http://monoid.foo\">monoid.foo</a> (normalize_monoid F) x\"</p>\n<p>If you equip these equations with an assumption<br>\n   \"NO_MATCH (normalize_monoid G) F\"<br>\nthen you can even use them as simp rules without looping.</p>\n<p>So whenever you need to exploit the equality of monoids, you can add those<br>\nequations to<br>\nthe simpset and switch all involved monoids F to \"normalize_monoid F\". And<br>\nfor these<br>\nnormalized monoids, you actually get the equality \"normalize_monoid F =<br>\nnormalize_monoid G\".</p>\n<p>A few caveats of this approach:</p>\n<ol>\n<li>\n<p>This only pays of if you have equalities between many monoids. If there<br>\nare just two or<br>\nthree, it's probably not worth the effort.</p>\n</li>\n<li>\n<p>Going from F to normalize_monoid F works well for declarative proofs<br>\nwhere you<br>\nexplicitly state the equality and then have simp transfer both sides. It<br>\ndoes not work<br>\nwell with exploratory proof styles where you interactively develop the<br>\nproof like with an<br>\napply script.</p>\n</li>\n<li>\n<p>The rewriting to normalize_monoid is limited to what simp can do. For<br>\nexample,<br>\nreplacements under higher-order operators like fold will not work in<br>\ngeneral because simp<br>\ncannot solve the side conditions _ : carrier _, even if you supply<br>\ncongruence rules.</p>\n</li>\n</ol>\n<p>The second approach is to use transfer. You can use your monoid_eq as a<br>\nthe relator for<br>\nmonoids and then prove appropriate transfer rules for all the operations<br>\non monoids. You<br>\nshould then be able to move from one monoid to the other by declaring the<br>\nsuitable<br>\nmonoid_eq fact as [transfer_rule] and let transfer do the rest. That's<br>\nprobably what I<br>\nwould go for.</p>\n<p>Best,<br>\nAndreas</p>\n<p>On 17/04/2020 15:09, Mikhail Chekhov wrote:</p>\n<blockquote>\n<p>Dear All,</p>\n<p>I have a technical question for those who are well versed in<br>\nthe formalizaton of applied mathematics in Isabelle/HOL using set-based<br>\nreasoning in HOL-Algebra (or similar).</p>\n<p>I am curious as to what is the canonical approach for dealing with the<br>\nequality of algebraic structures (e.g. monoids). Suppose, a given monoid<br>\nundergoes a sequence of transformations, the result of these<br>\ntransformations being an identical monoid (isomorphisms are not good<br>\nenough).</p>\n<p>I am aware of two different solutions, but I am not certain whether there<br>\nexist (better) alternatives and which solution would be preferred/more<br>\ncanonical?</p>\n<ol>\n<li>(Partial) equivalence relation. For example,</li>\n</ol>\n<p>locale monoid_eq = monoid G + monoid F for G F +<br>\n   assumes \"carrier G = carrier F\"<br>\n     and \"x ∈ carrier G ⟹ y ∈ carrier G ⟹ x ⊗⇘G⇙ y = x ⊗⇘F⇙ y\"<br>\n     and \"𝟭⇘G⇙ = 𝟭⇘F⇙\"</p>\n<p>It should also be possible to define a partial quotient type based on<br>\nmonoid_eq. However, I can imagine that this could result in a substantial<br>\namount of boilerplate code (one would wish to transfer the entire<br>\nHOL-Algebra to the new type(s)).</p>\n<ol start=\"2\">\n<li>Augmentation of the monoid locale with an additional condition that<br>\nmimics the restriction of the domain of the operation ⊗ to the carrier<br>\nset<br>\nvia undefined. Once this is done, one can use the standard HOL's<br>\neq<br>\n[message truncated]</li>\n</ol>\n</blockquote>\n</blockquote>",
        "id": 294827294,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245080
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nIf you go for the \"undefined\" approach, you indeed need to do it <br>\nsystematically.</p>\n<p>In my recent case study [1], for the required quotient constructions, I <br>\nonly needed to explicitly talk about undefinedness in definitions, not <br>\nspecifications.  With suitable lemmas on undefinedness I found that the <br>\nsimplifier's splitter was able to deal with the arising proof <br>\nobligations mostly automatically.  I only needed a few of these lemmas, <br>\nand you can find them by searching for \"undefined\" in the associated <br>\ntheory files [2].  The study contains a brief discussion on the topic in <br>\nsection 5.2.</p>\n<p>Clemens</p>\n<p>[1] <a href=\"http://dx.doi.org/10.1007/s10817-019-09537-9\">http://dx.doi.org/10.1007/s10817-019-09537-9</a> (unofficial version at <br>\n<a href=\"http://www21.in.tum.de/~ballarin/publications/jar2019.pdf\">http://www21.in.tum.de/~ballarin/publications/jar2019.pdf</a>)<br>\n[2] <br>\n<a href=\"https://www.isa-afp.org/browser_info/current/AFP/Jacobson_Basic_Algebra/index.html\">https://www.isa-afp.org/browser_info/current/AFP/Jacobson_Basic_Algebra/index.html</a></p>",
        "id": 294827344,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245087
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Mikhail,</p>\n<blockquote>\n<p>If I understood what is stated in your answer correctly, the second solution that you <br>\nsuggested is not entirely different from the first approach that I proposed in my <br>\nquestion. Naturally, I never suggested that one should rely on the simplifier/congruence <br>\nrules exclusively. Indeed, I rely predominantly on the capabilities of the transfer <br>\npackage to transfer the results across the members of a given equivalence class (however, <br>\nI only mentioned it in passing in the last paragraph of the question and your answer gave <br>\nme additional ideas for improvement of my own framework for transfer).<br>\nOh sorry, I missed that your mentioning of transfer referred to the transfer method.</p>\n</blockquote>\n<blockquote>\n<p>Nonetheless, given <br>\nwhat you have stated, I am still not certain if I am using transfer in the best possible <br>\nmanner. For example, consider the following framework,</p>\n<p>locale monoid_eq = monoid G + monoid F for G F +<br>\n    assumes monoid_eq_carrier: \"carrier G = carrier F\"<br>\n      and monoid_eq_mult:<br>\n       \"x ∈ carrier G ⟹ y ∈ carrier G ⟹ x ⊗⇘G⇙ y = x ⊗⇘F⇙ y\"<br>\n      and monoid_eq_one: \"𝟭⇘G⇙ = 𝟭⇘F⇙\"</p>\n<p>definition monoid_eq_rel ::<br>\n   \"('a, 'b) monoid_scheme ⇒ ('a, 'c) monoid_scheme ⇒ 'a ⇒ 'a ⇒ bool\"<br>\n   where (*redundancy for symmetry :) *) \"monoid_eq_rel F G a b =<br>\n     (a = b ∧ a ∈ carrier F ∧ b ∈ carrier G ∧ monoid_eq F G)\"</p>\n<p>lemma eq_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (=) (=)\"<br>\n   unfolding monoid_eq_rel_def<br>\n   by (intro rel_funI) auto</p>\n<p>lemma carrier_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq ===&gt; (=)) carrier carrier\"<br>\n   unfolding monoid_eq_def<br>\n   using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>\n   by blast</p>\n<p>lemma mult_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (mult F) (mult G)\"</p>\n</blockquote>\n<p>Here you run into the problem that we don't have a dependent function relator (or more <br>\nprecisely, transfer does not support such a relator). So we cannot state this as a <br>\ntransfer rule of the form</p>\n<p>\"(monoid_eq ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult\"</p>\n<p>Fortunately, we only care here about whether elements are contained in a carrier. So how <br>\nabout defining a relator monoid_eq' by</p>\n<p>monoid_eq' C F G = monoid_eq F G &amp; (C = %x. x : carrier G)</p>\n<p>Now the carrier predicate C is explicit and we can refer to it in the rules:</p>\n<p>\"(monoid_eq' C ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult\"</p>\n<p>This has the advantage that we relate only atomic terms, which work better with transfer <br>\nthan composite terms like \"mult F\" and \"mult G\" as in your rule. You should not need <br>\nmonoid_rel_eq then either and it should work well with the standard transfer rules for <br>\nlibrary constants.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294827348,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245092
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Andreas Lochbihler/All,</p>\n<p>Once again, thank you for your reply.</p>\n<blockquote>\n<p>Oh sorry, I missed that your mentioning of transfer referred to the<br>\ntransfer method.</p>\n<p>Most certainly, there is no need to apologize: I was the one who failed to<br>\npose the question in a comprehensive manner :).</p>\n</blockquote>\n<blockquote>\n<p>Fortunately, we only care here about whether elements are contained in a<br>\ncarrier. So how<br>\nabout defining a relator monoid_eq' by<br>\n   monoid_eq' C F G = monoid_eq F G &amp; (C = %x. x : carrier G)<br>\nNow the carrier predicate C is explicit and we can refer to it in the<br>\nrules:<br>\n   \"(monoid_eq' C ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult\"</p>\n<p>Thank you for your advice. Indeed, this is exactly what I was looking for.<br>\nUnfortunately, I was unaware of this method and somehow I did not think of<br>\nit when I started working on the framework for transfer.</p>\n</blockquote>\n<p>Nonetheless, I am not certain whether/how it resolves the most fundamental<br>\nissue. Many constants require some form of the totality of the relation as<br>\na prerequisite for the possibility of a transfer rule to be established,<br>\ne.g. 'All/Ex'. At the moment, I use a combination of custom/ad-hoc methods<br>\nto avoid having to deal with the transfer of such constants (e.g. by<br>\nconverting the statements of the theorems to the form that uses Ball/Bex,<br>\nwhile partially relying on tailor-made automation to achieve this).<br>\nHowever, I wonder whether there exists a more native solution (after all,<br>\nthe premises should always carry sufficient information for the transfer to<br>\nsucceed).</p>\n<p>As a side remark, I tried to explain the issue that is described in the<br>\nprevious paragraph of this email in the last two paragraphs of my previous<br>\nemail. However, having re-read them, I realized that I missed the point<br>\nalmost completely: please ignore the last two paragraphs of my previous<br>\nemail. Nonetheless, the example before the last paragraph is still relevant:</p>\n<p>lemma carrier_transfer[transfer_rule]:<br>\n  includes lifting_syntax<br>\n  shows \"(monoid_eq' C ===&gt; rel_set (eq_onp C)) carrier carrier\"<br>\n  unfolding monoid_eq'_def monoid_eq_def  eq_onp_def rel_set_def<br>\n  using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>\n  by blast</p>\n<p>lemma [transfer_rule]:<br>\n  includes lifting_syntax<br>\n  shows \"(eq_onp C ===&gt; eq_onp C ===&gt; (=)) (=) (=)\"<br>\n  unfolding eq_onp_def by auto</p>\n<p>lemma [transfer_rule]:<br>\n  includes lifting_syntax<br>\n  shows \"(eq_onp C ===&gt; rel_set (eq_onp C) ===&gt; (=)) (∈) (∈)\"<br>\n  unfolding eq_onp_def rel_set_def by auto</p>\n<p>lemma<br>\n  includes lifting_syntax<br>\n  assumes [transfer_rule]: \"monoid_eq' C F G\"<br>\n  shows \"a ∈ carrier G ⟹ b ∈ carrier G ⟹ a ⊗⇘G⇙ b = a ⊗⇘G⇙ b\"<br>\n  apply transfer<br>\n  (<em>Transfer.Rel ((eq_onp C ===&gt; (=)) ===&gt; (=)) ?aa25 transfer_forall</em>)<br>\n  oops</p>\n<p>Lastly, please accept my apologies for asking so many questions on this<br>\ntopic lately. The reason for this is that I am trying to be careful to<br>\nensure that the framework for transfer is designed in a more-or-less<br>\ncanonical manner, as I believe that it has a potential for being<br>\ngeneralized to arbitrary partial equivalence relations on set-based<br>\nstructures defined using records (or similar). Naturally, I will share it<br>\nunder the terms of a BSD license when/if it will reach a certain state of<br>\ngenerality and maturity.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>\n<p>On Sun, Apr 19, 2020 at 7:10 PM Andreas Lochbihler &lt;<br>\n<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Mikhail,</p>\n<blockquote>\n<p>If I understood what is stated in your answer correctly, the second<br>\nsolution that you<br>\nsuggested is not entirely different from the first approach that I<br>\nproposed in my<br>\nquestion. Naturally, I never suggested that one should rely on the<br>\nsimplifier/congruence<br>\nrules exclusively. Indeed, I rely predominantly on the capabilities of<br>\nthe transfer<br>\npackage to transfer the results across the members of a given<br>\nequivalence class (however,<br>\nI only mentioned it in passing in the last paragraph of the question and<br>\nyour answer gave<br>\nme additional ideas for improvement of my own framework for transfer).<br>\nOh sorry, I missed that your mentioning of transfer referred to the<br>\ntransfer method.</p>\n</blockquote>\n<blockquote>\n<p>Nonetheless, given<br>\nwhat you have stated, I am still not certain if I am using transfer in<br>\nthe best possible<br>\nmanner. For example, consider the following framework,</p>\n<p>locale monoid_eq = monoid G + monoid F for G F +<br>\n    assumes monoid_eq_carrier: \"carrier G = carrier F\"<br>\n      and monoid_eq_mult:<br>\n       \"x ∈ carrier G ⟹ y ∈ carrier G ⟹ x ⊗⇘G⇙ y = x ⊗⇘F⇙ y\"<br>\n      and monoid_eq_one: \"𝟭⇘G⇙ = 𝟭⇘F⇙\"</p>\n<p>definition monoid_eq_rel ::<br>\n   \"('a, 'b) monoid_scheme ⇒ ('a, 'c) monoid_scheme ⇒ 'a ⇒ 'a ⇒ bool\"<br>\n   where (*redundancy for symmetry :) *) \"monoid_eq_rel F G a b =<br>\n     (a = b ∧ a ∈ carrier F ∧ b ∈ carrier G ∧ monoid_eq F G)\"</p>\n<p>lemma eq_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (=) (=)\"<br>\n   unfolding monoid_eq_rel_def<br>\n   by (intro rel_funI) auto</p>\n<p>lemma carrier_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq ===&gt; (=)) carrier carrier\"<br>\n   unfolding monoid_eq_def<br>\n   using monoid_eq.intro monoid_eq.monoid_eq_carrier<br>\n   by blast</p>\n<p>lemma mult_transfer[transfer_rule]:<br>\n   includes lifting_syntax<br>\n   shows \"(monoid_eq_rel F G ===&gt; monoid_eq_rel F G ===&gt; (=)) (mult F)<br>\n(mult G)\"</p>\n</blockquote>\n<p>Here you run into the problem that we don't have a dependent function<br>\nrelator (or more<br>\nprecisely, transfer does not support such a relator). So we cannot state<br>\nthis as a<br>\ntransfer rule of the form</p>\n<p>\"(monoid_eq ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult\"</p>\n<p>Fortunately, we only care here about whether elements are contained in a<br>\ncarrier. So how<br>\nabout defining a relator monoid_eq' by</p>\n<p>monoid_eq' C F G = monoid_eq F G &amp; (C = %x. x : carrier G)</p>\n<p>Now the carrier predicate C is explicit and we can refer to it in the<br>\nrules:</p>\n<p>\"(monoid_eq' C ===&gt; eq_onp C ===&gt; eq_onp C ===&gt; eq_onp C) mult mult\"</p>\n<p>This has the advantage that we relate only atomic terms, which work better<br>\nwith transfer<br>\nthan composite terms like \"mult F\" and \"mult G\" as in your rule. You<br>\nshould not need<br>\nmonoid_rel_eq then either and it should work well with the standard<br>\ntransfer rules for<br>\nlibrary constants.</p>\n<p>Best,<br>\nAndreas<br>\n</p>\n</blockquote>",
        "id": 294827354,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245099
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Clemens Ballarin/All,</p>\n<p>Thank you for providing the references. Indeed, your work does provide an<br>\nanswer to one of my own old questions on the mailing list, i.e.<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00006.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00006.html</a><br>\n.</p>\n<p>I can hardly claim that my own use of proof automation in conjunction with<br>\n'undefined' could not be improved. Nonetheless, there are other reasons why<br>\nI am still inclined to prefer the use of an explicit equivalence relation<br>\nin conjunction with transfer for my application.</p>\n<p>Kind Regards,<br>\nMikhail Chekhov</p>",
        "id": 294827374,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245108
    }
]