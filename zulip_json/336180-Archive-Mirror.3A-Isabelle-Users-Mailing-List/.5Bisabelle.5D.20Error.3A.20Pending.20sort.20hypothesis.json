[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>I wanted to prove the following lemma:</p>\n<p>lemma<br>\n  fixes A :: \"'a set\"<br>\n  assumes \"finite A\"<br>\n  obtains f::\"'a =&gt; nat\" and n::\"nat\" where<br>\n    \"f`A = {i. i&lt;n}\"<br>\n    \"inj_on f A\"</p>\n<p>(* Sledgehammer found a proof: *)<br>\n  apply (metis finite finite_imageD id_apply inj_on_inverseI<br>\ninfinite_UNIV_char_0)<br>\n  (* Here, Isabelle sais: No subgoals<br>\n  However, when finnishing the proof: *)<br>\n  done<br>\n  (* I get the error:<br>\n*** Pending sort hypotheses: {finite,semiring_char_0}<br>\n*** At command \"done\".<br>\n*)</p>\n<p>Ok, I wondered how to prove the theorem from the lemmas given to metis.<br>\nBut what is happening here behind the scenes, how do these<br>\ntypeclasses(?) enter the game?</p>\n<p>Regards,<br>\n  Peter</p>",
        "id": 294090902,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831792
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI am surprised you got any answer from sledgehammer, I failed.<br>\nUnfortunately the proof you got is not a real proof: the ATPs are give a<br>\nproblem with some type information omitted for efficiency reasons. This<br>\nallows them sometimes to find proofs that do not replay in Isabelle<br>\nbecause of typing problems. Yours is most likely of that kind.</p>\n<p>The development version has a Settings item ATP: Full Types that gives<br>\nthe ATPs the full type information which you can try in such situations.<br>\nIt will avoid these unsound proofs but also reduces the success rate of<br>\nthe ATPs. In you example I am sceptical that the ATPs will find a real<br>\nproof because of the non-trivial witnesses required.</p>\n<p>Tobias</p>\n<p>Peter Lammich schrieb:</p>",
        "id": 294091021,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831823
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Peter,</p>\n<p>Peter Lammich schrieb:</p>\n<p>Pending sort hypothesis are sort constraints which a theorem's proof<br>\nrelies one, but whose type variables do not occur in the theorem<br>\nproposition; the have to be given explicitly in the assumptions, e.g.</p>\n<p>assumes \"SORT_CONSTRAINT('a::{finite,semiring_char_0})\"</p>\n<p>or whatever type variable 'x they refer too.</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/bMINcXekaB2E0P7VSzJ3bMbK/signature.asc\">signature.asc</a></p>",
        "id": 294091044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831836
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nHi Peter.</p>\n<p>I agree with Tobias, it's highly unlikely that the automated theorem <br>\nprovers will find an instantiation that solves your problem. I was <br>\nfiddling with your problem out of interest, and did find a proof, but <br>\nit's not especially elegant. The rule finite_distinct_list tells you <br>\nthat a list exists which puts A in order, giving you (roughly) the <br>\ninverse of the function f you want. The problem is inverting back to f <br>\nsince we don't have an injective function. To do this I had to extend <br>\ninto the sum type to force injectivity - maybe someone can see an easier <br>\nway?</p>\n<p>Yours,<br>\n    Thomas.</p>\n<p>lemma<br>\n  fixes A :: \"'a set\"<br>\n  assumes finA: \"finite A\"<br>\n  obtains f::\"'a =&gt; nat\" and n::\"nat\" where<br>\n    \"f`A = {i. i&lt;n}\"<br>\n    \"inj_on f A\"<br>\nproof -</p>\n<p>obtain xs where dist: \"distinct xs\" and A: \"A = set xs\"<br>\n    using finite_distinct_list[OF finA] by auto</p>\n<p>obtain g where g_def: \"g == (%n. if n &lt; length xs then Inl (xs ! n) <br>\nelse Inr n)\" ..</p>\n<p>obtain f where f_def: \"f == inv g o Inl\" ..</p>\n<p>have inj_g: \"inj g\"<br>\n    unfolding g_def<br>\n    apply (rule inj_onI)<br>\n    apply (auto simp: nth_eq_iff_index_eq[OF dist] split: split_if_asm)<br>\n    done</p>\n<p>have f_i: \"!!i. i &lt; length xs ==&gt; f (xs ! i) = i\"<br>\n    unfolding f_def<br>\n    apply (cut_tac x=i in inv_f_f[OF inj_g])<br>\n    apply (clarsimp simp: g_def)<br>\n    done</p>\n<p>have f_im: \"f ` A = {i. i &lt; length xs}\"<br>\n    apply safe<br>\n     apply (clarsimp simp: A in_set_conv_nth f_i)<br>\n    apply (simp add: A)<br>\n    apply (rule image_eqI[OF sym], erule f_i)<br>\n    apply simp<br>\n    done</p>\n<p>have f_inj: \"inj_on f A\"<br>\n    apply (rule inj_onI)<br>\n    apply (auto simp: A in_set_conv_nth f_i)<br>\n    done</p>\n<p>show ?thesis<br>\n    using prems f_im f_inj by auto</p>\n<p>qed</p>\n<p>Tobias Nipkow wrote:</p>",
        "id": 294091073,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831851
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIt would be nice to get a compact proof. Here is a condensed version of<br>\nThomas's proof, getting rid of Inl/Inr:</p>\n<p>lemma<br>\n fixes A :: \"'a set\"<br>\n assumes finA: \"finite A\"<br>\n obtains f::\"'a =&gt; nat\" and n::\"nat\" where<br>\n   \"f<code>A = {i. i&lt;n}\"\n   \"inj_on f A\"\nproof -\n  obtain xs where dist: \"distinct xs\" and A: \"A = set xs\"\n    using finite_distinct_list[OF finA] by auto\n  let ?I = \"{i. i&lt;size xs}\"\n  def g == \"%n. xs ! n\"\n  def f == \"Inv ?I g\"\n  have inj_g: \"inj_on g ?I\"\n    unfolding g_def\n    apply (rule inj_onI)\n    apply (auto simp: nth_eq_iff_index_eq[OF dist] split: split_if_asm)\n    done\n  have f_i: \"!!i. i : ?I ==&gt; f (xs ! i) = i\"\n    unfolding f_def by (metis Inv_f_f g_def inj_g)\n  have f_im: \"f </code> A = ?I\"<br>\n    apply(auto simp add:A in_set_conv_nth f_i)<br>\n    apply (metis Collect_def f_i in_set_conv_nth rev_image_eqI mem_def)<br>\n    done<br>\n  have f_inj: \"inj_on f A\"<br>\n    apply (rule inj_onI)<br>\n    apply (auto simp: A in_set_conv_nth f_i)<br>\n    done<br>\n  show ?thesis using prems f_im f_inj by auto<br>\nqed</p>\n<p>I am sure this can be improved further.</p>\n<p>Tobias</p>\n<p>Thomas Sewell wrote:</p>",
        "id": 294091084,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831860
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi Thomas,</p>\n<p>My hope was that ATP would find a proof based on the lemma<br>\n\"finite_imp_nat_seg_image_inj_on\" that is, in some sense, the inverse of<br>\nmy lemma.</p>\n<p>In the meantime, I proved the lemma directly with induction over the<br>\nfinite set (no idea whether this is more elegant ;) ):</p>\n<p>-- \"Finite sets have an injective mapping to an initial segments of the<br>\n      natural numbers\"<br>\nlemma finite_imp_inj_to_nat_seg:<br>\n  fixes A :: \"'a set\"<br>\n  assumes A: \"finite A\"<br>\n  obtains f::\"'a \\&lt;Rightarrow&gt; nat\" and n::\"nat\" where<br>\n    \"f`A = {i. i&lt;n}\"<br>\n    \"inj_on f A\"</p>\n<p>proof -<br>\n  from A have \"\\&lt;exists&gt;f (n::nat). f<code>A = {i. i&lt;n} \\&lt;and&gt; inj_on f A\"\n  proof (induct)\n    case empty thus ?case by auto\n  next\n    case (insert x A)\n    then obtain f and n::nat where\n      IH: \"f</code>A = {i. i&lt;n}\" \"inj_on f A\" by auto<br>\n    let ?fs = \"f(x:=n)\"<br>\n    from IH insert(2) have<br>\n      \"?fs`(insert x A) = {i. i&lt;Suc n}\"<br>\n      \"inj_on ?fs (insert x A)\"<br>\n      apply -<br>\n      apply force<br>\n      apply simp<br>\n      apply (rule inj_onI)<br>\n      apply (auto dest: inj_onD split: split_if_asm)<br>\n      done<br>\n    thus ?case by blast<br>\n  qed<br>\n  with that show ?thesis by blast<br>\nqed</p>\n<p>regards,<br>\n  Peter</p>\n<p>Thomas Sewell wrote:</p>",
        "id": 294091105,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831866
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIt turns out that your intuition was right: sledgehammer can prove the<br>\ntheorem, with a little help. This is the resulting proof (to go into the<br>\nlibrary):</p>\n<p>lemma finite_imp_inj_to_nat_seg:<br>\n  \"finite A ==&gt; EX f n::nat. f`A = {i. i&lt;n} &amp; inj_on f A\"<br>\nby (metis bij_betw_Inv bij_betw_def finite_imp_nat_seg_image_inj_on)</p>\n<p>For a start, notice the formulation in terms of EX rather than<br>\n\"obtains\", which s/h seems to prefer. But still, s/h does not find a<br>\nproof. You need to tell it to use finite_imp_nat_seg_image_inj_on:</p>\n<p>using finite_imp_nat_seg_image_inj_on</p>\n<p>Now s/h finds the above proof.</p>\n<p>Tobias</p>\n<p>Lammich schrieb:</p>",
        "id": 294091180,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831903
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nTobias Nipkow wrote:</p>\n<blockquote>\n<p>It turns out that your intuition was right: sledgehammer can prove the<br>\ntheorem, with a little help. This is the resulting proof (to go into the<br>\nlibrary):</p>\n<p>lemma finite_imp_inj_to_nat_seg:<br>\n  \"finite A ==&gt; EX f n::nat. f`A = {i. i&lt;n} &amp; inj_on f A\"<br>\nby (metis bij_betw_Inv bij_betw_def finite_imp_nat_seg_image_inj_on)</p>\n<p>Is there any rule of thumb when to use EX and when to use obtains for<br>\ntheorems (from a good-style viewpoint, not from the ATP viewpoint)?<br>\nNote that metis can also prove the theorem in obtains-style.</p>\n</blockquote>\n<p>regards,<br>\n  Peter</p>\n<blockquote>\n<p>For a start, notice the formulation in terms of EX rather than<br>\n\"obtains\", which s/h seems to prefer. But still, s/h does not find a<br>\nproof. You need to tell it to use finite_imp_nat_seg_image_inj_on:</p>\n</blockquote>",
        "id": 294091190,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831909
    }
]