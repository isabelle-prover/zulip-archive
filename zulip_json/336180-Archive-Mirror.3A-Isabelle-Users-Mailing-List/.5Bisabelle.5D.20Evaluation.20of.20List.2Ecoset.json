[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Jesus,</p>\n<p>By default, Isabelle represents sets as the list of its elements <br>\n(constructor set) or of the complement (List.coset). The latter is <br>\nmainly needed for representing UNIV as \"List.coset []\". Of course, you <br>\ncan implement List.coset in terms of set and enum, but then, you can <br>\nonly evaluate sets whose element type is an instance of enum - at least <br>\nwith the present setup for the code generator.</p>\n<p>If you want this, you must do the following:</p>\n<ol>\n<li>\n<p>Declare List.set as the only implementation constructor for sets:<br>\ncode_datatype set</p>\n</li>\n<li>\n<p>Remove all code equations that pattern-match on List.coset, e.g.,<br>\ndeclare union_coset_filter[code del]</p>\n</li>\n</ol>\n<p>You can look in List.thy for which code equation pattern-match on <br>\nList.coset, or print the whole code generator setup.</p>\n<ol start=\"3\">\n<li>Implement List.coset as you have already tried. This will pull in the <br>\nenum type class in many of the code equations for sets, so you will be <br>\nrestricted to elements of type enum, which excludes, e.g., nat.</li>\n</ol>\n<p>Best,<br>\nAndreas</p>",
        "id": 294230691,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902340
    },
    {
        "content": "<p>From: Jesus Aransay &lt;<a href=\"mailto:jesus-maria.aransay@unirioja.es\">jesus-maria.aransay@unirioja.es</a>&gt;<br>\nHi Andreas,</p>\n<p>thanks for your explanation.</p>\n<p>In the Isabelle development version I observed that the file<br>\n\"Cardinality.thy\" has suffered some changes related to the behaviour<br>\nof \"List.coset\"; more concretely, the line 467 in<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/744934b818c7/src/HOL/Library/Cardinality.thy\">http://isabelle.in.tum.de/repos/isabelle/file/744934b818c7/src/HOL/Library/Cardinality.thy</a><br>\nproves some results about \"List.coset\" of enumerated types \"by eval\";</p>\n<p>does this means that in the incoming release of Isabelle 2013<br>\n\"List.coset\" will be really evaluated for \"enum\" types?</p>\n<p>Looking forward for Isabelle 2013 ;-),</p>\n<p>Jesus</p>",
        "id": 294230698,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902345
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jesus,</p>\n<p>No, I have adapted Cardinality such that equality and subset between <br>\nsets and complements can be evaluated (cf. changeset 9014e78ccde2), <br>\nprovided that the element type instatiates the new type class card_UNIV.<br>\nThere's no enumeration involved.</p>\n<p>Andreas</p>",
        "id": 294230706,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902352
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou can start using Isabelle2013-RC2 right now, see again <br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2013-January/msg00157.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2013-January/msg00157.html</a></p>\n<p>It also points to <a href=\"https://bitbucket.org/isabelle_project/isabelle-release\">https://bitbucket.org/isabelle_project/isabelle-release</a> <br>\nwhich collects relevant information about this final stage before<br>\nlift-off of the final Isabelle2013 release.</p>\n<p>Anything you see on the main Isabelle repository happening now is for the <br>\nrelease after it (but 744934b818c7 mentioned above is from long ago).</p>\n<p>Makarius</p>",
        "id": 294230712,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902358
    },
    {
        "content": "<p>From: Jesus Aransay &lt;<a href=\"mailto:jesus-maria.aransay@unirioja.es\">jesus-maria.aransay@unirioja.es</a>&gt;<br>\nThanks Andreas and Makarius for your hints.</p>\n<p>Andreas, just to make it clear, a type which has been proven to be an<br>\ninstance of \"enum\" (and also with a finite cardinal, of course) could<br>\nbe proved to be an instance of the new class \"card_UNIV\"?</p>\n<p>Then, \"List.coset\" should be evaluated for instances of the<br>\n\"card_UNIV\" type class?</p>\n<p>My intuition is that the following question is related to the previous one;</p>\n<p>The following command:</p>\n<p>value \"remdups [finite_5.a_1,finite_5.a_2,finite_5.a_3]\"</p>\n<p>successfully removes duplicates from the input list (none in this<br>\ncase), whereas the following one (I had to prove the bit0 and bit1<br>\ntype constructors to be instances of \"equal\", and also some code<br>\nabstype and code abstract lemmas for Abs_bit1, Abs_bit0, Rep_bit0 and<br>\nRep_bit1 type morphisms):</p>\n<p>value \"remdups [1::5,2::5,1::5]\"</p>\n<p>does not produce any output.</p>\n<p>What information is missed in the code generator to evaluate<br>\nsuccessfully the previous command? Is it related to the cardinal of<br>\nthe underlying type, which is needed to compute the representation of<br>\nthe \"1::5\", \"2::5\" or \"7::5\" elements?</p>\n<p>As a more general question, in the HOL library, in file \"Enum.thy\"<br>\nthere are defined \"datatypes\" finite_1 up to finite_5, which are<br>\ndefined by enumerating its constants (a1, a1 and a2, and so on). Then,<br>\nin \"Numeral_Type.thy\", there are generic ordinal types (for any<br>\nn::nat) defined (\"typedef\"), in terms of a bit0 and bit1<br>\nrepresentation, as subsets of the integers.</p>\n<p>Could not be the types \"finite_n\" be seen as particular cases of the<br>\nordinal types? Are there good reasons to stick with the \"finite_n\"<br>\ntypes, being the ordinals far more general?</p>\n<p>Sorry for the long mail, I have been a few days working with both<br>\nkinds of types and still am a bit confused,</p>\n<p>thanks for any help,</p>\n<p>Jesus</p>",
        "id": 294231137,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902561
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Jesus,<br>\nOn 01/30/2013 07:49 PM, Jesus Aransay wrote:</p>\n<blockquote>\n<p>Andreas, just to make it clear, a type which has been proven to be an<br>\ninstance of \"enum\" (and also with a finite cardinal, of course) could<br>\nbe proved to be an instance of the new class \"card_UNIV\"?<br>\nThe card_UNIV type class is only definitional, i.e., every type can be <br>\nshown an instance of it. The type class card_UNIV merely defines an <br>\noverloaded constant card_UNIV with the meaning of card (UNIV :: 'a set) <br>\nwhich the different instantiations can implement as needed, e.g. <br>\ncard_UNIV = 2 for bool, card_UNIV = 256 for char and card_UNIV = <br>\ncard_UNIV * card_UNIV for pairs. The idea behind card_UNIV is described <br>\nin [1].</p>\n</blockquote>\n<blockquote>\n<p>Then, \"List.coset\" should be evaluated for instances of the<br>\n\"card_UNIV\" type class?<br>\nIf you understand \"evaluated\" as value \"List.coset [True]\" returns \"set <br>\n[False]\", then no. card_UNIV only evaluates comparisons between sets, <br>\ni.e., \"List.coset [True] = set [False]\" returns true, but without ever <br>\ncomputing explicitly that the left-hand side is in fact \"set [False]\".</p>\n</blockquote>\n<blockquote>\n<p>What information is missed in the code generator to evaluate<br>\nsuccessfully the previous command? Is it related to the cardinal of<br>\nthe underlying type, which is needed to compute the representation of<br>\nthe \"1::5\", \"2::5\" or \"7::5\" elements?<br>\nI cannot guess from the information you gave what could be the reason. <br>\nIf you can send your theory, I can have a look at it. The cardinality <br>\nshould not matter.</p>\n</blockquote>\n<blockquote>\n<p>Could not be the types \"finite_n\" be seen as particular cases of the<br>\nordinal types? Are there good reasons to stick with the \"finite_n\"<br>\ntypes, being the ordinals far more general?<br>\nYes, they could, but the finite_n types are not meant for <br>\ngeneral-purpose applications. Lukas introduced them such that quickcheck <br>\ncan instantiate type variables in theorems with finite types before <br>\nchecking.</p>\n</blockquote>\n<p>Andreas</p>\n<p>[1] Andreas Lochbihler.  Formalising FinFuns - Generating Code for <br>\nFunctions as Data from Isabelle/HOL. TPHOLs 2009, LNCS 5674, pp. <br>\n310--326, Springer, August 2009.<br>\n<a href=\"http://www.infsec.ethz.ch/people/andreloc/publications/lochbihler09tphols.pdf\">http://www.infsec.ethz.ch/people/andreloc/publications/lochbihler09tphols.pdf</a></p>",
        "id": 294231361,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902646
    },
    {
        "content": "<p>From: Jesus Aransay &lt;<a href=\"mailto:jesus-maria.aransay@unirioja.es\">jesus-maria.aransay@unirioja.es</a>&gt;<br>\nDear Andreas,</p>\n<p>thanks for your comments, they were really useful;</p>\n<p>I send attached a file where some examples of evaluations over<br>\n\"finite_n\" types succeed, whereas the same evaluations over<br>\nNumeral_Types (bit0 and bit1) do not terminate; in the file can be<br>\nalso found some instantiations that I missed in the Library (some of<br>\nthem were required for the bit0 and bit1 types to be evaluated):</p>\n<ul>\n<li>bit0 and bit1 are intances of \"equal\"</li>\n<li>bit0 and bit1 are instances of \"linorder\"</li>\n<li>bit0 and bit1 are instances of \"enum\"</li>\n</ul>\n<p>Any suggestions are really welcome,</p>\n<p>Jesus<br>\n<a href=\"/user_uploads/14278/eLo2zL9rFlIIS2WN5xRAZoCf/Num_Types_Enum_Types.thy\">Num_Types_Enum_Types.thy</a></p>",
        "id": 294231420,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902677
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Jesus,</p>\n<p>I had a look at your theories, and there several problems. I have tested <br>\nmy suggestion with Isabelle2013-RC2.</p>\n<ol>\n<li>You instantiate the type class equal by<br>\ndefinition \"equal_bit0 x y = (x = y)\"<br>\nThis is perfectly ok, but then, equality tests will never terminate, <br>\nbecause Isabelle's code generator rewrites the right-hand side to <br>\nequal_bit0 x y.</li>\n</ol>\n<p>You should really implement here (or in a code equation) the equality <br>\noperation, e.g.,</p>\n<p>lemma equal_bit0_code [code]:<br>\n   \"equal_class.equal x y = (Rep_bit0 x = Rep_bit0 y)\"<br>\nby(simp add: equal_eq Rep_bit0_inject)</p>\n<p>lemma equal_bit1_code [code]:<br>\n   \"equal_class.equal x y = (Rep_bit1 x = Rep_bit1 y)\"<br>\nby(simp add: equal_eq Rep_bit1_inject)</p>\n<ol start=\"2\">\n<li>Numeral_Type lifts all operations in terms of Abs_bit0' and <br>\nAbs_bit1'. Your code equations implement these via of_int, which uses <br>\nplus and times, which build on Abs_bit0' and Abs_bit1', so there's <br>\nanother source of non-termination. You should really implement them, <br>\ne.g., like this:</li>\n</ol>\n<p>lemma [code abstract]:<br>\n   \"Rep_bit0 (Abs_bit0' x :: 'a :: {finite, card_UNIV} bit0) =<br>\n    x mod int (CARD('a bit0))\"<br>\napply(simp add: Abs_bit0'_def)<br>\napply(rule Abs_bit0_inverse)<br>\napply simp<br>\nby (metis bit0.Rep_Abs_mod bit0.Rep_less_n card_bit0 of_nat_numeral <br>\nzmult_int)</p>\n<p>lemma [code abstract]:<br>\n   \"Rep_bit1 (Abs_bit1' x :: 'a :: {finite, card_UNIV} bit1) = x mod int <br>\n(CARD('a bit1))\"<br>\napply(simp add: Abs_bit1'_def)<br>\napply(rule Abs_bit1_inverse)<br>\napply simp<br>\nby (metis of_nat_0_less_iff of_nat_Suc of_nat_mult of_nat_numeral <br>\npos_mod_conj zero_less_Suc)</p>\n<ol start=\"3\">\n<li>The implementation of Abs_bit0' and Abs_bit1' needs to compute the <br>\nsize of the type, i.e., CARD('a bit). CARD('a bit) is only executable in <br>\nequations where 'a has sort card_UNIV (this is why 'a has the sort <br>\nconstraint card_UNIV in the above lemmas). In Isabelle2012, it is not <br>\nexecutable at all, but will always raise an exception. Hence, you need <br>\nto make num0, num1, bit0, and bit1 instances of card_UNIV (I leave the <br>\ninstantiation proofs to you).</li>\n</ol>\n<p>instantiation bit1 :: (type) finite_UNIV begin<br>\ndefinition \"finite_UNIV = Phantom('a bit1) True\"<br>\ninstance sorry<br>\nend</p>\n<p>instantiation bit1 :: (card_UNIV) card_UNIV begin<br>\ndefinition \"card_UNIV = Phantom('a bit1) (1 + 2 * of_phantom ((card_UNIV <br>\n:: 'a card_UNIV)))\"<br>\ninstance sorry<br>\nend</p>\n<p>instantiation bit0 :: (type) finite_UNIV begin<br>\ndefinition \"finite_UNIV = Phantom('a bit0) True\"<br>\ninstance sorry<br>\nend</p>\n<p>instantiation bit0 :: (card_UNIV) card_UNIV begin<br>\ndefinition \"card_UNIV = Phantom('a bit0) (2 * of_phantom ((card_UNIV :: <br>\n'a card_UNIV)))\"<br>\ninstance sorry<br>\nend</p>\n<p>instantiation num0 :: card_UNIV begin<br>\ndefinition \"finite_UNIV = Phantom(num0) False\"<br>\ndefinition \"card_UNIV = Phantom(num0) 0\"<br>\ninstance sorry<br>\nend</p>\n<p>instantiation num1 :: card_UNIV begin<br>\ndefinition \"finite_UNIV = Phantom(num1) True\"<br>\ndefinition \"card_UNIV = Phantom(num1) 1\"<br>\ninstance sorry<br>\nend</p>\n<p>I do agree that the setup for bit0 and bit1 could be improved, but for <br>\nIsabelle2013, it is too late already. If you produce a working <br>\ninstantiation that addresses these issues, I'm happy to add that to the <br>\nIsabelle repository such that it becomes part of the release after <br>\nIsabelle2013.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294231443,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660902689
    }
]