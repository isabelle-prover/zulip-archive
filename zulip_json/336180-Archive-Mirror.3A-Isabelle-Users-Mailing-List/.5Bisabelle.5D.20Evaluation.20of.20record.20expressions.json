[
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nHi Andrew, </p>\n<p>Thank you for your kind answer, that's what I searched for. <br>\nRegarding the first (and more important question) : the relation symbol can be treated as a \"&lt;\" relation. </p>\n<p>Andrew Boyton &lt;<a href=\"mailto:Andrew.Boyton@nicta.com.au\">Andrew.Boyton@nicta.com.au</a>&gt; schrieb:</p>",
        "id": 294250575,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910557
    },
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nIs there nobody with a clue?</p>",
        "id": 294250887,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910686
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nDear Michael,</p>\n<p>No, we are all clueless. ;)</p>\n<p>I presume you refer to the first question you posted some time ago. First of all, the theory snippet you pasted into your email cannot be parsed back by Isabelle (importing \"Complex_Complex\"). The parser chokes on \"⊩\". That makes it harder for us to help you.</p>\n<p>Second, there is no silver bullet in Isabelle that will prove finite goals. (I'm taking your claim at face value; being unable to parse the formula you sent, I cannot infer the types and check finiteness.) The closest thing to it is Nitpick, but you would have to trust it as an oracle. See e.g. my paper [1] for an instance where we used Nitpick for exhaustive verification.</p>\n<p>I presume that a properly set up \"blast\" or \"auto\" might be able to finish the job. Sometimes it's just a matter of adding a few intro, elim, or split rules; perhaps one of the experts could help you, once they are given a self-contained example.</p>\n<p>Regards,</p>\n<p>Jasmin</p>\n<p>[1] <a href=\"http://www21.in.tum.de/~blanchet/ppdp2011-cpp-mem.pdf\">http://www21.in.tum.de/~blanchet/ppdp2011-cpp-mem.pdf</a></p>",
        "id": 294250914,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910698
    },
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nDear Jasmin, </p>\n<p>Indeed, that was my fault. I work with custom theories where this symbol is treated as \"&lt;\" (less relation) and I forgot to replace it. Hope you could somehow help me now. My goal is just to make isabelle split all possible cases as they are finite and then solve every case for itself. Thanks! </p>\n<p>Regards <br>\nMichael </p>\n<p>Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt; schrieb:</p>",
        "id": 294250949,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910710
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Michael,</p>\n<p>I fail to see why your problem is finite. The pair of assumptions \"forall s. ...\" quantify over all states, of which there are infinitely many. I see some \"if\"s that could perhaps be split into separate cases, but they are under the scope of lambdas that bind again an infinite variable.</p>\n<p>Also, some of your variables seem to have overly general types, e.g. \"a\" has type 'a. Indeed, Nitpick reports a \"potentially spurious\" counterexample that appears to be genuine.</p>\n<p>Regards,</p>\n<p>Jasmin</p>",
        "id": 294250985,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910722
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Dienstag, den 08.10.2013, 18:14 +0200 schrieb Michael Vu:</p>\n<blockquote>\n<p>Dear isabelle experts,</p>\n<p>I am currently working with records and I'm trying to write a small automation tool for generating calculations. But I'm stuck at proving some simple expressions like this one:</p>\n<p>record state =<br>\n  t  :: real<br>\n  c :: real</p>\n<p>lemma weakly_bounded:<br>\n\"0 &lt; a ⟹<br>\n    a &lt; 1 ⟹<br>\n    0 &lt; b ⟹<br>\n    b &lt; 1 ⟹<br>\n    0 &lt; a + b - a * b ⟹<br>\n    ∀s. t s = 0 ∨ t s = 1 ⟹<br>\n    ∀s. c s = 0 ∨ c s = 1 ⟹<br>\n    λs. (if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n        (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a /<br>\n        (a + b -<br>\n         a * b) ⊩ λs. (if c s ≠ 1 then 1 else 0) *\n                      ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n                       (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b))\"</p>\n<p>I thought simp would be enough to evaluate this, but it seems not to be the case. So I am looking for a way to make isabelle automatically verify<br>\nall possible states (the space is finite due to the conditions). I would appreciate every help.</p>\n</blockquote>\n<p>Is ⊩ point wise  less or equal? If yes, you first should<br>\nunfold fun_le_def, then the splitter can operate on it. Also I don't<br>\nthink that the simplifier can deduce that the set of states is finite.</p>\n<blockquote>\n<p>And secondly I've another cosmetic question. Given following subgoals:</p>\n<ol>\n<li>0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 ≤ a</li>\n<li>0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 ≤ 1 - b</li>\n<li>0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 ≤ a</li>\n<li>some complicated subgoal<br>\napply(simp) <br>\napply(simp)<br>\napply(simp) </li>\n</ol>\n<p>Is there any more elegant way other than to invoke simp 3 times? I also tried \"auto\" but it gets stuck on subgoal 4. </p>\n</blockquote>\n<p>You can use Isar to proof subgoal 4 first and subgoal 1, 2, 3 by the<br>\nqed-command:</p>\n<p>proof -<br>\n  assumes \"\" then show \"\" ...<br>\nqed simp_all</p>\n<p>- Johannes</p>",
        "id": 294251007,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910732
    },
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nHello Johannes,</p>\n<p>Yes, \"⊩\" basically means \"≤\".<br>\nI tried to define a similar lemma:</p>\n<p>lemma test_bounded:<br>\n  \"0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 &lt; a + b - a * b ⟹<br>\n    ∀s. ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n        (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a /<br>\n        (a + b -<br>\n         a * b)) ≤ ((if c s ≠ 1 then 1 else 0) *\n                      ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n                       (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b)))\"<br>\n  apply(rule allI)<br>\n  apply(auto)</p>\n<p>In this case the simplifier is able to split all possible cases, it's just the matter that it won't evaluate all expressions afterwards.<br>\nSo my question is if there's a way how i can deduce this test_bounded lemma from the first one I posted and then make Isabelle evaluate all<br>\ncases. Thanks!</p>\n<p>Michael</p>",
        "id": 294251067,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910752
    },
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nI tried to define a similar lemma:</p>\n<p>lemma test_bounded:<br>\n  \"0 &lt; a ⟹ a &lt; 1 ⟹ 0 &lt; b ⟹ b &lt; 1 ⟹ 0 &lt; a + b - a * b ⟹<br>\n    ∀s. ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n        (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a /<br>\n        (a + b -<br>\n         a * b)) ≤ ((if c s ≠ 1 then 1 else 0) *\n                      ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n                       (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b)))\"<br>\n  apply(rule allI)<br>\n  apply(auto)</p>\n<p>In this case the simplifier is able to split all possible cases, it's just the matter that it won't evaluate all expressions afterwards.<br>\nSo my question is if there's a way how i can deduce this test_bounded lemma from the first one I posted and then make Isabelle evaluate all<br>\ncases.<br>\nRegarding the variables a and b: That's my fault again, happens when I try to cut a snippet from my code..You can assume that they are defined as ::real.</p>\n<p>Michael</p>",
        "id": 294251086,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910759
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHey all.</p>\n<p>I had a look at this on the assumption that this was somehow related to <br>\nthe record package.</p>\n<p>Looking at this test lemma, it would seem that</p>\n<p>a) it is false in the case where \"t s = 1 &amp; c s = 1 &amp; a * 2 = 1 &amp; b * 2 = 1\"<br>\nb) it seems to have nothing to do with the record package<br>\nc) nothing needs to be evaluated, instead, hypotheses need to be proven, <br>\nwhich is hard when they're false.</p>\n<p>You can see that the lemma is false via:<br>\n   apply (rule allI)<br>\n   apply (case_tac \"t s = 1 &amp; c s = 1 &amp; a = 0.5 &amp; b = 0.5\")<br>\n    apply (elim conjE, simp only: )<br>\n    apply (simp add: field_simps)</p>\n<p>(the fact that all these tools are conservative means the original goal <br>\nwas false also)</p>\n<p>I'm not exactly sure what you're looking for.</p>\n<p>Good luck,<br>\n     Thomas.</p>",
        "id": 294251179,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910783
    },
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nHello Thomas, hello all,</p>\n<p>you're right, I really failed...Thanks for your counter example. Well the reason behind this is that i work with a custom package of theorems and used the wrong lemma which resulted in an unsolveable goal. So I'm really sorry.<br>\nAnyway, I managed to correct this and now Isabelle outputs this subgoal:</p>\n<p>0 &lt; (a::real) ⟹<br>\na &lt; 1 ⟹<br>\n0 &lt; b ⟹<br>\nb &lt; 1 ⟹<br>\n0 &lt; a + b - a * b ⟹<br>\n∀s. t s = 0 ∨ t s = 1 ⟹<br>\n∀s. c s = 0 ∨ c s = 1 ⟹<br>\n    (THE ba. isLub UNIV<br>\n              (range (λs. (if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n                          (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b)))<br>\n              ba)<br>\n    ≤ (THE ba. isLub UNIV<br>\n                (range (λs. (if c s ≠ 1 then 1 else 0) *\n                            ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if t s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n                             (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - b) * a / (a + b - a * b))))<br>\n                ba)</p>\n<p>The remaining functions are all defined in Set.thy/Lubs.thy and now I am stuck on how to prove this. This subgoal just shows that the upper bound of <br>\nthe first lambda function is less or equal than the upper bound of the second function. Any help would be appreciated. I hope I didn't forget anything this time. Thanks!</p>\n<p>Michael</p>",
        "id": 294251458,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910901
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHey Michael.</p>\n<p>Sorry about being short with you before. I wasn't actually annoyed by <br>\nthe previous question, just pointing out that it didn't quite make sense <br>\nand there was probably a misunderstanding inherent in it somewhere.</p>\n<p>It looks like you're closer to the right track. I note two things you <br>\nmight want to work on.</p>\n<p>My first observation was that you probably want to hide the THE operator <br>\nsomehow. Using Hilbert choice semantically is fine (as long as you're OK <br>\nwith it), but the operator also happens to be syntactically difficult to <br>\ngrapple with.</p>\n<p>In short, \"THE x. isLub UNIV (range f) x\" seems like a verbose <br>\ndescription of the least upper bound of<br>\n\"range f\". I wonder if there's an instantiation/proof anywhere that lets <br>\nyou show \"(THE x. isLub UNIV (range f) x) = Sup (range f)\".</p>\n<p>I don't have an answer to that myself, I don't really know anything <br>\nabout reals in Isabelle. Maybe one of the calculus experts can comment?</p>\n<p>The other problem is that you're assuming that \"t s\" is 0 or 1 for every <br>\ns. That's never true. So your proof can be finished by:<br>\n   apply (drule_tac x=\"some_value (| t := 0.5 |)\" in spec)<br>\n   apply simp<br>\n   done</p>\n<p>That's almost certainly not what you want. I guess you probably just <br>\nwant to constrain the s's considered in computing the ranges of the <br>\nlambda functions, but you would do that by replace range f<br>\nwith f ` S instead.</p>\n<p>Good luck,<br>\n     Thomas.</p>",
        "id": 294251473,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910907
    },
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nHi Thomas, hi all,</p>\n<p>Thank you for your answer. I am using some kind of \"framework\" so that expression is defined as followed:</p>\n<p>definition bound_of :: \"('a ⇒ 'b::complete) ⇒ 'b\"<br>\nwhere     \"bound_of P ≡ THE b. isLub UNIV (P ` UNIV) b\"</p>\n<p>There are also some Lemmas regarding to \"bound_of\" but none which exactly fits my goal. But that makes it impossible for me to change it nor to fix the second problem because this is just a subgoal of another lemma and I just unfolded the definition. Or could you find any way to improve it?<br>\nAny answers would be appreciated :)</p>\n<p>Michael</p>",
        "id": 294252502,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911293
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHey Michael.</p>\n<p>I've had a think about your bound_of definition and the interesting case <br>\nyou're using it in.</p>\n<p>The only obvious thing I can prove about it is that it has the \"obvious\" <br>\nvalue if you happen to know what the maximum is:</p>\n<p>lemma bound_of_eq_max:<br>\n   \"[| ALL y. f y &lt;= f x |] ==&gt; bound_of f = f x\"<br>\n   apply (simp add: bound_of_def)<br>\n   apply (rule the_equality)<br>\n    apply (simp add: isLub_def leastP_def isUb_def setge_def setle_def)<br>\n   apply (simp add: isLub_def leastP_def isUb_def setge_def setle_def)<br>\n   apply (auto intro: antisym)<br>\n   done</p>\n<p>(I'm using the ASCII versions of syntax in case of transmission issues, <br>\nhowever maybe Unicode has gotten better than this.)</p>\n<p>It's not clear in your case that you'll know what the maximum value is, <br>\nhowever. It might depend on a or b. What simplifies your case is that it <br>\nlooks like your lambda function is only interested in \"t s = 0\", \"t s = <br>\n1\" etc. This made me think you could prove it was equal to a composition <br>\nof functions:</p>\n<p>record state =<br>\n    t  :: real<br>\n    c :: real</p>\n<p>record state =<br>\n    t  :: real<br>\n    c :: real</p>\n<p>lemma ts_01_etc_lemma:<br>\n   \"(%(x :: state). f (t x = 0) (t x = 1) (c x = 0) (c x = 1))<br>\n     = (%(a, b). f (a = Some False) (a = Some True) (b = Some False) (b <br>\n= Some True))<br>\n         o (%x. ([0 |-&gt; False, 1 |-&gt; True] (t x), [0 |-&gt; False, 1 |-&gt; <br>\nTrue] (c x)))\"<br>\n   by (simp add: o_def fun_eq_iff)</p>\n<p>lemma fun_01_eq_surj:<br>\n   \"surj (%(x :: state). ([0 |-&gt; False, (1 :: real) |-&gt; True] (t x), [0 <br>\n|-&gt; False, 1 |-&gt; True] (c x)))\"<br>\n   apply (rule_tac f=\"%x. (| t = (case x of (Some False, _) =&gt; 0 | (Some <br>\nTrue, _) =&gt; 1 | (None, _) =&gt; 2),<br>\n                             c = (case x of (_, Some False) =&gt; 0 | (_, <br>\nSome True) =&gt; 1 | (_, None) =&gt; 2) |)\" in surjI)<br>\n   apply (simp split: sum.split prod.split option.split bool.split)<br>\n   done</p>\n<p>This is useful, because the bound of \"g o f\" ought to be the bound of g, <br>\nassuming f is surjective.</p>\n<p>lemma range_compose:<br>\n   \"surj g ==&gt; range (f o g) = range f\"<br>\n   by (metis image_compose)</p>\n<p>lemma bound_of_compose:<br>\n   \"surj g ==&gt; bound_of (f o g) = bound_of f\"<br>\n   by (simp add: bound_of_def range_compose)</p>\n<p>lemma bound_of_eq_by_compose:<br>\n   \"g = f o h ==&gt; surj h ==&gt; bound_of g = bound_of f\"<br>\n   by (simp add: bound_of_compose)</p>\n<p>thm bound_of_eq_by_compose</p>\n<p>Finally, computing the bound of the minimal function extracted in this <br>\nway ought to be easier since it has a finite domain. I can use <br>\nenumeration to expand it:</p>\n<p>lemma fold_max_ge:<br>\n   \"(fold max xs y &gt;= (z :: 'a :: linorder)) = (y &gt;= z | (EX x : set xs. <br>\nx &gt;= z))\"<br>\n   apply (induct xs arbitrary: y)<br>\n    apply (auto simp: le_max_iff_disj)<br>\n   done</p>\n<p>lemma fold_max_le:<br>\n   \"(fold max xs y &lt;= (z :: 'a :: linorder)) = (y &lt;= z &amp; (ALL x : set <br>\nxs. x &lt;= z))\"<br>\n   by (induct xs arbitrary: y, auto)</p>\n<p>lemma bound_of_by_enum_vs:<br>\n   \"UNIV = set vs ==&gt;<br>\n     bound_of f = fold max (map f vs) (f (hd vs))\"<br>\n   apply (simp add: bound_of_def)<br>\n   apply (subgoal_tac \"hd vs : set vs\")<br>\n    apply (erule ssubst)<br>\n    apply (rule the_equality[OF _ antisym, rotated])<br>\n      apply (simp_all add: isLub_def leastP_def isUb_def setge_def <br>\nsetle_def)<br>\n     apply clarsimp<br>\n     apply (drule spec, erule mp)<br>\n     apply (auto simp: fold_max_le fold_max_ge)<br>\n   done</p>\n<p>lemmas bound_of_by_enum = bound_of_by_enum_vs[OF UNIV_enum]</p>\n<p>thm trans[OF bound_of_eq_by_compose[OF ts_01_etc_lemma fun_01_eq_surj] <br>\nbound_of_by_enum,<br>\n     unfolded enum_prod_def enum_sum_def enum_option_def enum_bool_def, <br>\nsimplified]</p>\n<p>It's a bit of a mess, but it looks like we can apply this to your kind <br>\nof problem:</p>\n<p>lemma \"0 &lt; (a::real) ⟹<br>\na &lt; 1 ⟹<br>\n0 &lt; b ⟹<br>\nb &lt; 1 ⟹<br>\n0 &lt; a + b - a * b ⟹<br>\n     bound_of (λs :: state. (if t s = 0 ∧ c s = 0 then 1 else 0) + (if t <br>\ns = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n                           (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 - <br>\nb) * a / (a + b - a * b))<br>\n     ≤ bound_of (λs :: state. (if c s ≠ 1 then 1 else 0) *\n                             ((if t s = 0 ∧ c s = 0 then 1 else 0) + (if <br>\nt s = 0 ∧ c s = 1 then 1 else 0) * a / (a + b - a * b) +<br>\n                              (if t s = 1 ∧ c s = 1 then 1 else 0) * (1 </p>\n<ul>\n<li>b) * a / (a + b - a * b)))\"<br>\n   apply (subst bound_of_eq_by_compose[OF ts_01_etc_lemma fun_01_eq_surj])+<br>\n   apply (simp add: bound_of_by_enum enum_prod_def enum_sum_def <br>\nenum_option_def enum_bool_def)<br>\n   apply (simp add: max_def)<br>\n   sorry</li>\n</ul>\n<p>This approach might be overspecialised, and you might have to use a <br>\nbigger intermediate type, but <em>hopefully</em> you can throw away your <br>\nrecords via this kind of reasoning, and maybe get a concrete result via <br>\nenumeration.</p>\n<p>Hope that helps. Happy hunting,<br>\n     Thomas.</p>",
        "id": 294252561,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911318
    },
    {
        "content": "<p>From: Andrew Boyton &lt;<a href=\"mailto:Andrew.Boyton@nicta.com.au\">Andrew.Boyton@nicta.com.au</a>&gt;<br>\nTo answer the simple question. Instead of</p>\n<p>apply(simp)<br>\napply(simp)<br>\napply(simp)</p>\n<p>you can go</p>\n<p>apply(simp)+</p>\n<p>or</p>\n<p>apply(simp_all)</p>\n<p>Strictly speaking, simp+ and simp_all have different semantics. simp_all works on all subgoals, where as simp+ works on the first subgoal, and if that discharges, it works on the second. Neither does exactly what the calling simp 3 times does, as they both try applying simp to the fourth goal. If you don't want that to happen, you can do the following</p>\n<p>apply (simp+)[3]</p>\n<p>which will limit simp+ to working on just three subgoals, but I suspect you don't need to.</p>\n<p>Hope this helps.</p>\n<p>Andrew</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294253933,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911870
    },
    {
        "content": "<p>From: Michael Vu &lt;<a href=\"mailto:michael.vu@rwth-aachen.de\">michael.vu@rwth-aachen.de</a>&gt;<br>\nHey Thomas,</p>\n<p>at first: many many thanks! That was quite a lot of information and very helpful. Sorry for my late answer, I had to take some time to understand the code and to discuss it with my supervisor. The idea is very interesting, I've never worked with enumerations before but it seems to be a good approach here. Anyway, it didn't completely work for me, I had some problems with the lemma \"bound_of_by_enum_vs\". It does not get proven by reaching the \"done\" statement:</p>\n<p>goal (4 subgoals):</p>\n<ol>\n<li>⋀b y. hd vs ∈ set vs ⟹ ∀y∈set vs. f y ≤ b ⟹ y ∈ set vs ⟹ f y ≤ fold max (map f vs) (f (hd vs))</li>\n<li>⋀b. hd vs ∈ set vs ⟹ ∀y∈set vs. f y ≤ b ⟹ ∀x. (∀y∈set vs. f y ≤ x) ⟶ b ≤ x ⟹ fold max (map f vs) (f (hd vs)) ≤ b</li>\n<li>⋀y. hd vs ∈ set vs ⟹ y ∈ set vs ⟹ f y ≤ fold max (map f vs) (f (hd vs))</li>\n<li>⋀x. hd vs ∈ set vs ⟹ ∀y∈set vs. f y ≤ x ⟹ fold max (map f vs) (f (hd vs)) ≤ x</li>\n</ol>\n<p>The approach is quite special but can be generalized for finite states, right? At first I thought that all problem classes I'm working with only have a finite number of states, but my supervisor showed me cases with infinite states. This should not work with enumerations should it? </p>\n<p>Michael</p>",
        "id": 294258300,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913407
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHey Michael.</p>\n<p>OK, two points. Firstly, this enumeration approach will only work for <br>\nhandling finitely many cases. I brought it up because your function <br>\nhappened to only care about finitely many valuations of \"t x\" and \"c x\". <br>\nIf it's more general than that, well, you'll need a different approach. <br>\nAnd finding bounds of functions in general requires calculus or similar, <br>\nwhich, of course, may be substantially more challenging. If you end up <br>\nhaving to use Lagrange multipliers then, well, good luck to you.</p>\n<p>Secondly, if one of the lemmas I typed didn't prove, it's probably <br>\nbecause I typed it into a different version of Isabelle, but also <br>\npossibly because I typed it in a context that contains a different set <br>\nof simplification rules to yours.</p>\n<p>What I typed seems to work in Isabelle-2013, in a context I built via<br>\n\"theory Scratch imports Lubs Real begin\"</p>\n<p>You might have to prove this theorem in the same context, or identify <br>\nwhat's changed and fix it, or come up with a new proof of the same rule, <br>\nor give us some more guidance as to how your context is built.</p>\n<p>Good luck,<br>\n     Thomas.</p>",
        "id": 294258411,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913446
    }
]