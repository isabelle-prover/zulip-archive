[
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nSuppose I want to prove something like \"in a group where the order of every<br>\nelement divides 3, there's an involution with only the identity element as<br>\na fixed point\". As a mathematician, I just say \"Consider the involution x<br>\n-&gt; x^2; that'll all you need!\"</p>\n<p>Similarly, if I want to prove that there are three distinct natural numbers<br>\nwhose product is 12, I say \"Well, 1 *  2 *  6 = 12\" (or perhaps I use 1 * 3</p>\n<ul>\n<li>4...both work!).</li>\n</ul>\n<p>Is there an idiomatic way to do such a proof in isabelle, i.e., to fill in</p>\n<p>lemma tiny: \"∃ (k::nat) (m::nat) (p::nat) . k<em>m</em>p = 12 ∧ k ≠ m ∧ k ≠ p ∧ m<br>\n≠ p\"<br>\nproof -<br>\n  ???</p>\n<p>[I should probably mention that Sledgehammer claims to have a proof, but<br>\nI'm not -- as you might have guessed! -- interested in this particular<br>\nfact, but rather in how to say to Isabelle, \"Look! It's right here!\" ]</p>\n<p>The proof suggested is \"(metis (no_types, lifting) add_right_imp_eq<br>\nnumeral_Bit0 numeral_Bit1 one_eq_numeral_iff semiring_norm(83)<br>\nsemiring_norm(86) semiring_normalization_rules(25)<br>\nsemiring_normalization_rules(4)) (671 ms)\" which hardly gives me an idiom<br>\nfor such proofs.</p>\n<p>--John</p>",
        "id": 294822985,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243055
    },
    {
        "content": "<p>From: Mark Wassell &lt;<a href=\"mailto:mpwassell@gmail.com\">mpwassell@gmail.com</a>&gt;<br>\nHi,</p>\n<p>I can provide a few ways of doing this. The key to all of them is to<br>\nreplace the dash following 'proof' with a proof method.</p>\n<p>First, if you give the proof method rule+ then Isabelle will pick<br>\nappropriate rule automatically [1] and do this multiple times. Here the<br>\nrule it applies is exI which will unpack the existentials. This will then<br>\nleave you with 2 things to prove.</p>\n<ol>\n<li>?k * ?m2 * ?p4 = 12</li>\n<li>?k ≠ ?m2 ∧ ?k ≠ ?p4 ∧ ?m2 ≠ ?p4</li>\n</ol>\n<p>You can plug anything you like into the ? variables and so the proof is:</p>\n<p>lemma tiny: \"∃ (k::nat) (m::nat) (p::nat) . k<em>m</em>p = 12 ∧ k ≠ m ∧ k ≠ p ∧ m<br>\n≠ p\"<br>\nproof(rule+)<br>\n  show \"1 * (2::nat) * 6 = 12\"  by simp<br>\n  show \"1 ≠ (2::nat) ∧ 1 ≠ (6::nat) ∧ 2 ≠  (6::nat)\" by simp<br>\nqed</p>\n<p>The fly in the ointment is that you have to add the type annotations to the<br>\nnumeric constants as these are overloaded constants. I don't know if there<br>\nis a nice way to tell Isabelle that you want fix all numeric constants to<br>\nbe nats within your proof or a part of your theory.</p>\n<p>The second is a variant of the above but here you specify the actual<br>\nconstant for each application of exI. This will give you the one line proof<br>\nof:<br>\nby(rule exI[where x=1],rule exI[where x=2], rule exI[where x=6], simp+)</p>\n<p>It's interesting here that I didn't need to include the type annotation.<br>\nAlso it would be nice if Isabelle was able to let you specify that you want<br>\nexI to be mapped over a list of literals [1,2,6]. One way to get around<br>\nthis for your case is to include:</p>\n<p>lemma exI3: \"P x y z ⟹ ∃x y z. P x y z\" by auto</p>\n<p>and then you can do<br>\nby(rule exI3[of _ 1 2 6],auto)</p>\n<p>Cheers</p>\n<p>Mark</p>\n<p>[1] Isar Reference Manual - page 6.4.2</p>",
        "id": 294823007,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243066
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI prefer this style when there are existential quantifiers to instantiate:</p>\n<p>lemma tiny: \"∃ (k::nat) (m::nat) (p::nat) . k<em>m</em>p = 12 ∧ k ≠ m ∧ k ≠ p ∧ m ≠ p\"<br>\nproof -<br>\n  have \"1 * 3 * 4 = (12::nat)\"<br>\n    by auto<br>\n  then show ?thesis<br>\n    using numeral_eq_iff one_eq_numeral_iff by blast<br>\nqed</p>\n<p>Larry Paulson</p>",
        "id": 294823020,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243072
    },
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nThanks to one and all for these useful approaches. I've used Larry's and it<br>\ngot me where I needed to go, and pretty readably. :)</p>",
        "id": 294823041,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243082
    },
    {
        "content": "<p>From: Pedro Sánchez Terraf &lt;<a href=\"mailto:sterraf@famaf.unc.edu.ar\">sterraf@famaf.unc.edu.ar</a>&gt;<br>\nEl 9/2/20 a las 05:15, Mark Wassell escribió:<br>\nHello,</p>\n<p>I have some related question, especially concerning the \"plug anything\" <br>\npart.</p>\n<p>Sometimes I have to prove a result like</p>\n<p>\"∃x. P x ∧ Q x\",</p>\n<p>and I intend to use a lemma that states</p>\n<p>lemma A: \"∃x. R x\".</p>\n<p>Moreover, I know that any such x (satisfying R) will work for me. Also, <br>\nit turns out that in my example it is better to prove \"P x\" first and <br>\nthen use this to prove \"Q x\".</p>\n<p>I would like to be able to write a proof that looks like this:</p>\n<p>lemma \"∃x. P x ∧ Q x\"proof (rule) (* goals here: P ?x &amp;&amp;&amp; Q ?x *) obtain <br>\nx where \"R x\" using A by blast then show \"P x\" &lt;proof&gt; then show \"Q x\" <br>\n&lt;proof&gt; qed</p>\n<p>This won't work (neither of the show commands) because I have an <br>\nobtained parameter in the conclusion. Nevertheless it looks like a sound <br>\nproof method, because I'm proving an existential.</p>\n<p>I know this kind of a \"feature request\"; I wanted to know if there is <br>\nsome way to write proofs like this, or if someone actually considered <br>\nthis might be useful.</p>\n<p>PST.-<br>\n<a href=\"http://cs.famaf.unc.edu.ar/~pedro/home_en\">cs.famaf.unc.edu.ar/~pedro/home_en</a> <br>\n&lt;<a href=\"https://cs.famaf.unc.edu.ar/~pedro/home_en.html\">https://cs.famaf.unc.edu.ar/~pedro/home_en.html</a>&gt;</p>",
        "id": 294823108,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243111
    },
    {
        "content": "<p>From: Frédéric Boulanger &lt;<a href=\"mailto:frederic.boulanger@lri.fr\">frederic.boulanger@lri.fr</a>&gt;<br>\nWhat about this:</p>\n<p>lemma ‹∃k m p. k<em>m</em>p = (12::nat) ∧ k≠m ∧ k≠p ∧ m≠p›<br>\nproof -<br>\n  have ‹1<em>3</em>4 = (12::nat)› by simp<br>\n  moreover have ‹1≠(3::nat)› by simp<br>\n  moreover have ‹1≠(4::nat)› by simp<br>\n  moreover have ‹3≠(4::nat)› by simp<br>\n  ultimately show ?thesis by blast<br>\nqed</p>\n<p>or even shorter:</p>\n<p>lemma ‹∃k m p. k<em>m</em>p = (12::nat) ∧ k≠m ∧ k≠p ∧ m≠p›<br>\nproof -<br>\n  have ‹1<em>3</em>4 = (12::nat)› by simp<br>\n  moreover have ‹1≠(3::nat) ∧ 1≠(4::nat) ∧ 3≠(4::nat)› by simp<br>\n  ultimately show ?thesis by blast<br>\nqed</p>\n<p>Some similar proof patterns are given in section 4.2.1 (page 45) of Programming and proving in Isabelle/HOL.</p>\n<p>Frédéric</p>\n<p>Frédéric Boulanger<br>\nCentraleSupélec - Département Informatique  Laboratoire de Recherche en Informatique<br>\n3 rue Joliot-Curie, 91192 Gif-sur-Yvette cedex  Bât 650 Ada Lovelace, Université Paris Sud, 91405 Orsay Cedex France<br>\n+33 [0]1 69 85 14 84</p>",
        "id": 294823128,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243120
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou seem to be saying that you know that R(x) implies P(x) and that P(x) implies Q(x), in both cases for all x. Prove those two implications, and if you have also proved \"∃x. R x\", then \"∃x. P x ∧ Q x\" should be provable automatically provided P, Q and R aren't too complicated. And if they are, you could introduce abbreviations for them.</p>\n<p>Larry Paulson</p>",
        "id": 294823166,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243136
    },
    {
        "content": "<p>From: Pedro Sánchez Terraf &lt;<a href=\"mailto:sterraf@famaf.unc.edu.ar\">sterraf@famaf.unc.edu.ar</a>&gt;<br>\nEl 10/2/20 a las 08:18, Lawrence Paulson escribió:<br>\nThank you very much; I understand this technique. The way I thought <br>\nabout this was to introduce the existential at the very end:</p>\n<p>lemma<br>\n   assumes \"∃x. R x\"<br>\n   shows \"∃x. P x ∧ Q x\"<br>\nproof -<br>\n   obtain x where \"R x\" using A by blast<br>\n   then<br>\n   have \"P x\" &lt;proof&gt;<br>\n   moreover from this<br>\n   have \"Q x\" &lt;proof&gt;<br>\n   ultimately<br>\n   show ?thesis by auto (* or something *)<br>\nqed</p>\n<p>The reason I asked is that the implication P(x)==&gt;Q(x) usually depends <br>\non too much information local to the lemma, and putting that in a <br>\nseparate result would sometimes obfuscate the proof document. Also, when <br>\nthe overall argument has some length, the cumulative approach <br>\n\"moreover... ultimately\" also seems impractical. Alternatively, I could <br>\nlabel the relevant facts and use them afterwards, but I want to avoid <br>\ncross-referencing and repetition as much as possible.</p>\n<p>Thanks again.</p>\n<p>PST.-<br>\n<a href=\"http://cs.famaf.unc.edu.ar/~pedro/home_en\">cs.famaf.unc.edu.ar/~pedro/home_en</a> <br>\n&lt;<a href=\"https://cs.famaf.unc.edu.ar/~pedro/home_en.html\">https://cs.famaf.unc.edu.ar/~pedro/home_en.html</a>&gt;</p>",
        "id": 294823215,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243155
    },
    {
        "content": "<p>From: Akihisa Yamada &lt;<a href=\"mailto:akihisayamada@nii.ac.jp\">akihisayamada@nii.ac.jp</a>&gt;<br>\nHello,</p>\n<blockquote>\n<p>Thank you very much; I understand this technique. The way I thought <br>\nabout this was to introduce the existential at the very end:</p>\n</blockquote>\n<p>it doesn't have to be very end, but after the relevant \"obtain\". This <br>\nmight look better:</p>\n<p>lemma<br>\n   shows \"∃x::'a. P x ∧ Q x\"<br>\nproof -<br>\n   obtain x ::'a where x: \"R x\" sorry<br>\n   show ?thesis<br>\n   proof (intro exI conjI)<br>\n    show \"P x\" using x sorry<br>\n    show \"Q x\" using x sorry<br>\n   qed<br>\nqed</p>\n<p>Best,<br>\nAkihisa</p>\n<blockquote>\n<p>lemma<br>\n   assumes \"∃x. R x\"<br>\n   shows \"∃x. P x ∧ Q x\"<br>\nproof -<br>\n   obtain x where \"R x\" using A by blast<br>\n   then<br>\n   have \"P x\" &lt;proof&gt;<br>\n   moreover from this<br>\n   have \"Q x\" &lt;proof&gt;<br>\n   ultimately<br>\n   show ?thesis by auto (* or something *)<br>\nqed</p>\n<p>The reason I asked is that the implication P(x)==&gt;Q(x) usually depends <br>\non too much information local to the lemma, and putting that in a <br>\nseparate result would sometimes obfuscate the proof document. Also, when <br>\nthe overall argument has some length, the cumulative approach <br>\n\"moreover... ultimately\" also seems impractical. Alternatively, I could <br>\nlabel the relevant facts and use them afterwards, but I want to avoid <br>\ncross-referencing and repetition as much as possible.</p>\n<p>Thanks again.</p>\n<p>PST.-<br>\n<a href=\"http://cs.famaf.unc.edu.ar/~pedro/home_en\">cs.famaf.unc.edu.ar/~pedro/home_en</a> <br>\n&lt;<a href=\"https://cs.famaf.unc.edu.ar/~pedro/home_en.html\">https://cs.famaf.unc.edu.ar/~pedro/home_en.html</a>&gt;</p>\n</blockquote>",
        "id": 294823229,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243160
    }
]