[
    {
        "content": "<p>From: James Cooper &lt;<a href=\"mailto:not.fenimore@gmail.com\">not.fenimore@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I'm new to the Isabelle system, so this might be a bit simplistic, but I've<br>\nlooked through the tutorials and references and can't really find an<br>\nexplanation. It's possible I'm just missing something, so if anyone can<br>\nexplain what that is I'd be very grateful.</p>\n<p>Basically, I'm trying to build a little interpreter, but the interpreter<br>\nand typechecker need to use \"inductive\" rather than e.g. \"primrec\" or<br>\n\"function\" because they do not provably terminate. That's fine, but the<br>\nproof rules for \"inductive_rule.induct\" don't seem to work straight for me.<br>\n(I'm on the Isabelle jEdit IDE for Mac, if it makes a difference.)</p>\n<p>For instance, my typechecking predicate looks like</p>\n<p>inductive typecheck :: \"type env =&gt; expr =&gt; type =&gt; bool\"<br>\nwhere chkNum: \"typecheck env (NumExpr n) NumType\"<br>\n    | chkStr: \"typecheck env (StrExpr s) StringType\"<br>\n    | chkVar: \"lookup env v = Some t ==&gt; typecheck<br>\n    | chkLength: \"typecheck env a StringType ==&gt; typecheck env (LengthExpr<br>\na) NumType\"<br>\netc.</p>\n<p>where there's exactly one case for each expression type in the second<br>\nargument. So I want to prove a little set of inversion lemmas,</p>\n<p>lemma num_const_invert: \"typecheck env (NumExpr n) t ==&gt; t = NumType\"<br>\netc.</p>\n<p>Since the typechecking rules are syntax-directed, this seems like it should<br>\nbe simple: induct on the typechecking rules, have the chkNum case trivially<br>\nand watch every other case produce e.g. \"StringExpr s = NumExpr n\" as an<br>\nassumption and proof by contradiction. Instead, the expression argument<br>\ngets wiped out and \"apply (induction rule: type check.induct)\" produces</p>\n<ol>\n<li>/\\ env n. NumType = NumType</li>\n<li>/\\ env s. StringType = NumType</li>\n<li>/\\ env v t1. lookup env v = Some t1 ==&gt; t1 = NumType</li>\n<li>/\\ env a. typecheck env a StrType  ==&gt; StringType = NumType ==&gt; NumType<br>\n= NumType<br>\n...</li>\n</ol>\n<p>which is obviously insoluble. As best I can tell it's inducting over a<br>\n<em>generic</em> term \"typecheck env expr t\", and the knowledge that expr is<br>\nreally NumExpr n has been lost; as a result it's trying to prove that<br>\ntypecheck <em>always</em> produces a NumType, with predictably strange results.</p>\n<p>Any idea what's going on here? Am I doing something wrong? What's the<br>\n<em>right</em> way to define a nonterminating function of this kind and prove<br>\nthings over it?</p>\n<p>James Cooper</p>",
        "id": 294229857,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901897
    }
]