[
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nHi,</p>\n<p>I have a question about how to extend locales such as pre_digraph (from<br>\nthe Graph_Theory AFP entry,<br>\n<a href=\"https://www.isa-afp.org/browser_info/current/AFP/Graph_Theory/Digraph.html\">https://www.isa-afp.org/browser_info/current/AFP/Graph_Theory/Digraph.html</a><br>\n).</p>\n<p>The definition in Graph_Theory/Digraph.thy goes like this:</p>\n<p>record ('a,'b) pre_digraph =<br>\n  verts :: \"'a set\"<br>\n  arcs :: \"'b set\"<br>\n  tail :: \"'b ⇒ 'a\"<br>\n  head :: \"'b ⇒ 'a\"</p>\n<p>locale pre_digraph =<br>\n  fixes G :: \"('a, 'b) pre_digraph\" (structure)</p>\n<p>Now I would like to use Graph_Theory as the basis for a theory about<br>\ngames where each vertex has a priority.  All definitions and lemmas<br>\nabout vertex degrees, connectivity etc. are unaffected by this, so I<br>\nwould like to import these in some way into my theory.</p>\n<p>I tried to do it like this:</p>\n<p>record ('a,'b) Game = \"('a, 'b) pre_digraph\" +<br>\n  priority :: \"'a ⇒ nat\" (\"ωı\")</p>\n<p>locale Game = pre_digraph G<br>\n  for G :: \"('a,'b,'c) Game_scheme\" (structure) +<br>\n  assumes priorities_finite: \"finite (ω ` verts G)\"</p>\n<p>But this does not work because the locale pre_digraph does not accept<br>\nrecords of type \"('a,'b,'c) Game_scheme\" or of type \"('a,'b) Game\".</p>\n<p>I would like to avoid giving the Game locale two parameters, because<br>\nthis will end up very verbose in the the rest of the theory.</p>\n<p>Another thing I tried was to change the definition in<br>\nGraph_Theory/Digraph.thy to:</p>\n<p>locale pre_digraph =<br>\n  fixes G :: \"('a, 'b, 'c) pre_digraph_scheme\" (structure)</p>\n<p>and then define Game in my theory as:</p>\n<p>locale Game = pre_digraph G<br>\n  for G :: \"('a, 'b, 'c) Game_scheme\" (structure) +<br>\n  assumes priorities_finite: \"finite (ω ` verts G)\"</p>\n<p>This seems to work, but changing the locale pre_digraph like this breaks<br>\na lot of lemmas in Graph_Theory and I do not know how much work it would<br>\nbe to fix this or even if this is best practice at all.</p>\n<p>What would be a good way to accomplish my use case?</p>\n<p>Thanks,<br>\nChristoph</p>",
        "id": 294704334,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180194
    },
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nHi,</p>\n<p>I just had the idea to define a record</p>\n<p>record GameVertex = priority :: nat</p>\n<p>and then use</p>\n<p>locale Game = pre_digraph G<br>\n  for G :: \"('a GameVertex_scheme, 'b) pre_digraph\" (structure) +<br>\n  assumes priorities_finite: \"finite (priority ` verts G)\"</p>\n<p>I will try this in the next days and report back if this works for me.</p>\n<p>Suggestions are still welcome. :)</p>\n<p>Best,<br>\nChristoph</p>",
        "id": 294704345,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180198
    },
    {
        "content": "<p>From: \"Elsa L. Gunter\" &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nDear Christoph,</p>\n<p>The path you are on for the interleaving of records and locales is <br>\nsimilar to an approach I have been taking. The fact the predigraph was <br>\nbuild from a record and not a record scheme makes it a bit awkward to <br>\nextend in a natural way, keeping up the interleaving of the record view <br>\nand the locale view.  For predigraph in particular, I ended up creating <br>\na structure that was mostly the same, but with more components, and <br>\nshowed it interpreted predigraphs, thereby getting the predigraph <br>\ntheory.  Below I give a skeleton of an example development I have <br>\ninterleaving records and locales, in case you find the methodology of use.</p>\n<p>So I have been using records as the \"signature\" of the locale, by using <br>\nrecord schemes.  As a bit of an example, I have</p>\n<p>record ('instr,'dir) generalized_control_flow_graph_context =<br>\n   Instructions :: \"'instr set\"<br>\n   Directions :: \"'dir set\"<br>\n   edgeTyping :: \"'instr ⇒ ('dir ⇒ nat)set\"</p>\n<p>and then</p>\n<p>locale GeneralizedControlFlowGraphContext =<br>\n   fixes GCFG :: \"('instr,'dir,'ext) <br>\ngeneralized_control_flow_graph_context_scheme\"<br>\n   assumes ...</p>\n<p>then</p>\n<p>record ('instr,'dir,'node) generalized_control_flow_graph =<br>\n   \"('instr,'dir) generalized_control_flow_graph_context\" +<br>\n   Nodes :: \"'node set\"<br>\n   Edges :: \"'node ⇒ ('dir × 'node)set\"<br>\n   labeling :: \"'node ⇒ 'instr\"</p>\n<p>then</p>\n<p>locale UnboundedGeneralizedControlFlowGraph =<br>\n   GeneralizedControlFlowGraphContext<br>\n   where GCFG  = \"GCFG :: ('instr,'dir,'node,'ext) <br>\ngeneralized_control_flow_graph_scheme\"<br>\n   for GCFG +<br>\n   assumes ...</p>\n<p>Note that just by making the type of GCFG be the more specific type of <br>\n('instr,'dir,'node,'ext) generalized_control_flow_graph_scheme, I can <br>\nget the extra fields \"for free\".  Because I keep using a scheme at each <br>\nlayer, I allow for the possibility of extension.</p>\n<p>Then I can do</p>\n<p>record<br>\n  ('instr,'dir,'node,'participant,'state) <br>\ngeneralized_control_flow_graph_interpretation =<br>\n\"('instr,'dir,'node) generalized_control_flow_graph\"<br>\n+<br>\nParticipants :: \" 'participant set\"<br>\nInterpretation ::<br>\n    \"(('participant ⇒ 'node) × 'state) ⇒ 'dir ⇒ (('participant ⇒ 'node) <br>\n× 'state) ⇒ bool\"</p>\n<p>locale UnboundedGeneralizedControlFlowGraphInterpretation =<br>\n   UnboundedGeneralizedControlFlowGraph<br>\n   where GCFG =<br>\n   \"GCFG :: ('instr, 'dir, 'node, 'participant,'state,'ext)<br>\n            generalized_control_flow_graph_interpretation_scheme\"<br>\n   for GCFG +<br>\n   assumes ...</p>\n<p>and</p>\n<p>locale  GeneralizedControlFlowGraph =<br>\n   UnboundedGeneralizedControlFlowGraph<br>\n   where GCFG =<br>\n   \"GCFG :: ('instr, 'dir, 'node,'ext) <br>\ngeneralized_control_flow_graph_scheme\"<br>\n   for GCFG +<br>\n  assumes finite_nodes: \"finite (Nodes GCFG)\"<br>\n      and finite_edges: \"n ∈ Nodes GCFG ⟹ finite (Edges GCFG n)\"</p>\n<p>sublocale GeneralizedControlFlowGraph ⊆ fin_digraph<br>\n   where G = \"⦇ verts = Nodes GCFG,<br>\n               arcs = {e. case e of (n,d,m) ⇒ n ∈ Nodes GCFG ∧ <br>\n(d,m)∈Edges GCFG n},<br>\n               tail = (λ e. case e of (n,d,m) ⇒ m),<br>\n               head = (λ e. case e of (n,d,m) ⇒ n) ⦈\"<br>\nby (unfold_locales, simp_all add: finite_nodes finite_edge_set)</p>\n<p>Elsewhere I have</p>\n<p>record ('block, 'region, 'val, 'thread)block_structure =<br>\n   good_block ::\"'block ⇒ bool\"<br>\n   good_region :: \"'region ⇒ bool\"<br>\n   region_overlap::\"'region ⇒ 'region ⇒ bool\"<br>\n   subblock::\"'block ⇒ 'block ⇒ bool\"<br>\n   subregion :: \"'region ⇒ 'region ⇒ bool\"<br>\n   region_get_block ::\"'region ⇒ 'block\"<br>\n   block_as_region ::\"'block ⇒ 'region\"<br>\n   value_fits_region :: \"'val ⇒ 'region ⇒ bool\"<br>\n   region_fits_block ::\"'region ⇒ 'block ⇒ bool\"<br>\n   does_not_modify_value :: \"('thread, 'block, 'region,'val) block_access<br>\n         ⇒ 'region ⇒  bool\"<br>\n   does_not_modify_permissions :: \"('thread, 'block, 'region,'val) <br>\nblock_access<br>\n         ⇒ 'region ⇒  bool\"</p>\n<p>locale block_structure =<br>\n   fixes BlkSt :: \"('block, 'region, 'val, 'thread, <br>\n'ext)block_structure_scheme\"*</p>\n<ul>\n<li>assumes ...</li>\n</ul>\n<p>Some definitions ...  and then a model for block_structure</p>\n<p>definition memory_machine_block_structure where<br>\n\"memory_machine_block_structure GMMA rest ≡<br>\n  ⦇good_block = good_block_mm GMMA ,<br>\n   good_region = good_region_mm GMMA ,<br>\n   region_overlap = region_overlap_mm GMMA ,<br>\n   subblock = subblock_mm GMMA ,<br>\n   subregion = subregion_mm GMMA ,<br>\n   region_get_block = region_get_block_mm GMMA ,<br>\n   block_as_region = block_as_region_mm GMMA ,<br>\n   value_fits_region = value_fits_region_mm GMMA ,<br>\n   region_fits_block = region_fits_block_mm GMMA ,<br>\n   does_not_modify_value =  does_not_modify_value_mm GMMA ,<br>\n   does_not_modify_permissions = does_not_modify_permissions_mm GMMA ,<br>\n   … = rest⦈\"<br>\ninterpretation block_structure<br>\n\"memory_machine_block_structure GMMA rest\"<br>\nproof ...  qed</p>\n<p>record ('block, 'region, 'val, 'thread, 'addr, 'byte) <br>\nblock_structure_addresses =<br>\n   \"('block, 'region, 'val, 'thread)block_structure\" +<br>\n   allowed_addresses:: \"'addr set\"<br>\n   region_to_addresses:: \"'region ⇒ 'addr set\"<br>\n   value_byte_check::<br>\n    \"'region ⇒ 'val ⇒ ('addr ⇒ 'byte option) ⇒ bool\"</p>\n<p>locale block_structure_addresses =<br>\n   fixes BlkStAddr ::<br>\n     \"('block, 'region, 'val, 'thread, 'addr, 'byte, <br>\n'ext)block_structure_addresses_scheme\"<br>\n   assumes ...</p>\n<p>And then we can extend our memory machine model for block_structure to <br>\none for block_structure_addresses with</p>\n<p>definition memory_machine_block_structure_addresses where<br>\n\"memory_machine_block_structure_addresses<br>\n  (GMMA:: ('byte list,'byte,'extmem)gen_memory_with_address_scheme) rest ≡<br>\n  (memory_machine_block_structure GMMA<br>\n  ⦇allowed_addresses = {i. (MinAddress GMMA ≤ i) ∧ (i ≤ MaxAddress GMMA)},<br>\n   region_to_addresses = (λ r. (case r of ((j,k),B) ⇒ {i. j ≤ i ∧ i ≤ k})),<br>\n   value_byte_check = (λ r v m. case r of ((j,k),B) ⇒ v = intmap m j k),<br>\n   … = rest ⦈<br>\n  ::((int * int), (int × int) × int × int, 'byte list, 'thread, int, <br>\n'byte, 'extblk)<br>\n    block_structure_addresses_scheme)\"</p>\n<p>and then we can prove the extended model is indeed a model of the <br>\nextended local</p>\n<p>interpretation block_structure_addresses<br>\n\"memory_machine_block_structure_addresses<br>\n  (GMMA:: ('byte list,'byte,'ext)gen_memory_with_address_scheme) rest \"<br>\napply (simp add: memory_machine_block_structure_addresses_def<br>\n                  memory_machine_block_structure_def)<br>\napply (unfold_locales, simp_all)<br>\n...</p>\n<p>This method has some kinks to it.  It gets a bit twisted up if you try <br>\nto extend the union of two locales with a common ancestor.  It is <br>\ngenerally best not to make definitions inside contexts, but pass the <br>\nextra argument(s) explicitly.  There may be some more limitations, but <br>\non the whole I have found it a useful way to use locals and records <br>\ntogether so that I can work inside the locale to prove facts about the <br>\ngeneral theory, and then use records and predicates when I am using <br>\ninstances of the theory.  Anyway, I hope it gives you some useful ideas.<br>\n---Elsa</p>",
        "id": 294704393,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180217
    },
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nHello Elsa,</p>\n<p>thank you for this suggestion.  I hadn't thought about using<br>\ninterpretations.</p>\n<p>For now, I am satisfied with showing that my Digraph locale and the<br>\nnomulti_digraph locale from Graph_Theory interpret each other:</p>\n<p><a href=\"https://devel.isa-afp.org/browser_info/current/AFP/Parity_Game/Graph_TheoryCompatibility.html\">https://devel.isa-afp.org/browser_info/current/AFP/Parity_Game/Graph_TheoryCompatibility.html</a></p>\n<p>This does not allow me to use the theorems of nomulti_digraph as easily<br>\nas I would like, but it shows at least that the locales are somehow<br>\ncompatible.</p>\n<p>Best,<br>\nChristoph</p>",
        "id": 294704412,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180223
    }
]