[
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nHi *,</p>\n<p>I stumbled upon some funny behaviour which prevents the simplifier in <br>\nproving \"True\" in Isabelle2012 (also in 8a1ef12f7e6d). The reduced <br>\nexample is attached.</p>\n<p>Dmitriy<br>\n<a href=\"/user_uploads/14278/PhJ53VaBDL0kBGQyzGA3uxyA/Simproc_Fail.thy\">Simproc_Fail.thy</a></p>",
        "id": 294166035,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854742
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThis exception is thrown by the simproc natless_cancel_sums (in <br>\nNat_Arith.nat_cancel_sums), as the following succeeds:</p>\n<p>notepad<br>\nbegin<br>\n   ML_prf {* Delsimprocs [nth Nat_Arith.nat_cancel_sums 1] *}<br>\n   have \"(\\&lt;And&gt;ys zs. length ys &lt; Suc (length zs + length ys))\" by simp<br>\n   hence True<br>\n     by simp</p>\n<p>The other simprocs in Nat_Arith also seem to be affected.</p>\n<p>-- Lars</p>",
        "id": 294166057,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854750
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nFor the record: This problem was caused by an interaction between<br>\nsimprocs and schematic type variables. More specifically, some<br>\ninternal proofs done by Nat_Arith simprocs would fail on terms that<br>\ncontain schematics. The problem is now fixed in revision 868dc809c8a2.</p>\n<p>Authors of simprocs should take note: The simplifier may run simprocs<br>\non terms containing schematics (type and/or term variables) and it is<br>\nthe responsibility of the simproc to handle this situation properly.</p>\n<p>A simproc must never instantiate any schematic variable. Some<br>\nguidelines for simproc writers: Internal proofs should use the<br>\nsimplifier only in \"safe\" mode, i.e. only using the \"safe\" solvers,<br>\nwhich avoid instantiating schematics. Also, avoid instantiating rules<br>\nwith terms from the input and then using those rules with rtac,<br>\nbecause schematic variables in a rule are not preserved when the rule<br>\nis applied. (The Nat_Arith simprocs failed to follow either of these<br>\nguidelines.)</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294166346,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854885
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 20.07.2012 15:06, Brian Huffman wrote:</p>\n<blockquote>\n<blockquote>\n<p>This exception is thrown by the simproc natless_cancel_sums (in<br>\nNat_Arith.nat_cancel_sums), as the following succeeds:</p>\n<p>notepad<br>\nbegin<br>\n   ML_prf {* Delsimprocs [nth Nat_Arith.nat_cancel_sums 1] *}<br>\n   have \"(\\&lt;And&gt;ys zs. length ys&lt;  Suc (length zs + length ys))\" by simp<br>\n   hence True<br>\n     by simp</p>\n<p>The other simprocs in Nat_Arith also seem to be affected.</p>\n</blockquote>\n<p>For the record: This problem was caused by an interaction between<br>\nsimprocs and schematic type variables. More specifically, some<br>\ninternal proofs done by Nat_Arith simprocs would fail on terms that<br>\ncontain schematics. The problem is now fixed in revision 868dc809c8a2.</p>\n<p>Authors of simprocs should take note: The simplifier may run simprocs<br>\non terms containing schematics (type and/or term variables) and it is<br>\nthe responsibility of the simproc to handle this situation properly.</p>\n</blockquote>\n<p>There are also other simprocs, which produce equations, which are <br>\nignored by the simplifier. I haven't checked closely yet, but these are <br>\nmost likely due to instantiations of schematic variables:</p>\n<p>$ zgrep 'IGNORED result of simproc' * | cut -d\\\" -f2 | sort | uniq -c<br>\n      45 Cfun.beta_cfun_proc<br>\n      86 equal<br>\n       2 Numeral_Simprocs.inteq_cancel_numerals<br>\n     941 perm_simproc_fun<br>\n   24814 record_eq_simp</p>\n<p>(src/HOL make all)</p>\n<blockquote>\n<p>A simproc must never instantiate any schematic variable. Some<br>\nguidelines for simproc writers: Internal proofs should use the<br>\nsimplifier only in \"safe\" mode, i.e. only using the \"safe\" solvers,<br>\nwhich avoid instantiating schematics. Also, avoid instantiating rules<br>\nwith terms from the input and then using those rules with rtac,<br>\nbecause schematic variables in a rule are not preserved when the rule<br>\nis applied. (The Nat_Arith simprocs failed to follow either of these<br>\nguidelines.)</p>\n</blockquote>\n<p>So you decided against the generic approach of importing the schematic <br>\nvariables? Was it because of efficiency?</p>\n<p>-- Lars</p>",
        "id": 294216641,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895214
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<p>$ zgrep 'IGNORED result of simproc' * | cut -d\\\" -f2 | sort | uniq -c<br>\n     86 equal</p>\n</blockquote>\n<p>I'm wondering a little bit about this.  The simproc »equal« is part of<br>\nthe code generatorm, preprocessor, as follows:</p>\n<p>setup {*<br>\n  Code_Preproc.map_pre (fn simpset =&gt;<br>\n    simpset addsimprocs [Simplifier.simproc_global_i @{theory} \"equal\"<br>\n[@{term HOL.eq}]<br>\n      (fn thy =&gt; fn _ =&gt;<br>\n        fn Const (_, Type (\"fun\", [Type _, _])) =&gt; SOME @{thm eq_equal}<br>\n| _ =&gt; NONE)])<br>\n*}</p>\n<p>I don't see any instantiation of schematic variables here, but I'm more<br>\nor less ignorant about the simproc business, so the code above may be<br>\nutterly wrong or conceptionally outdated.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/9fbhFxAHAslBDwg4aBtghDiL/signature.asc\">signature.asc</a></p>",
        "id": 294216663,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895227
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 20.07.2012 17:51, Florian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>$ zgrep 'IGNORED result of simproc' * | cut -d\\\" -f2 | sort | uniq -c<br>\n      86 equal</p>\n</blockquote>\n</blockquote>\n<p>Ok, these numbers are flawed. Despite the wording of the warning message</p>\n<p>\"IGNORED result of simproc \" ^ quote name ^ \" -- does not match\"</p>\n<p>the warning message is printed not only for non-matching equalities but <br>\nalso for anything which can not successfully be used for rewriting. This <br>\nexplains the big number for record_eq_simp (which generates conditional <br>\nrules).</p>\n<blockquote>\n<p>I'm wondering a little bit about this.  The simproc »equal« is part of<br>\nthe code generatorm, preprocessor, as follows:</p>\n<p>setup {*<br>\n   Code_Preproc.map_pre (fn simpset =&gt;<br>\n     simpset addsimprocs [Simplifier.simproc_global_i @{theory} \"equal\"<br>\n[@{term HOL.eq}]<br>\n       (fn thy =&gt;  fn _ =&gt;<br>\n         fn Const (_, Type (\"fun\", [Type _, _])) =&gt;  SOME @{thm eq_equal}<br>\n| _ =&gt;  NONE)])<br>\n*}</p>\n</blockquote>\n<p>Are there situations where this rewrite step is expected to fail (maybe <br>\ndue to sort constraints)? Then this warning would be expected, too.</p>\n<p>-- Lars</p>",
        "id": 294216688,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895247
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nFailure is expected due to types themselves: only instantiated equality<br>\n(eq [tyco …]) is rewritten, not fully polymorphic equality (eq ['a]).</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/E2xmzmOCYECaNltJaWiLS-ld/signature.asc\">signature.asc</a></p>",
        "id": 294216693,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895254
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Fri, Jul 20, 2012 at 5:36 PM, Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>On 20.07.2012 15:06, Brian Huffman wrote:</p>\n<blockquote>\n<p>A simproc must never instantiate any schematic variable. Some<br>\nguidelines for simproc writers: Internal proofs should use the<br>\nsimplifier only in \"safe\" mode, i.e. only using the \"safe\" solvers,<br>\nwhich avoid instantiating schematics. Also, avoid instantiating rules<br>\nwith terms from the input and then using those rules with rtac,<br>\nbecause schematic variables in a rule are not preserved when the rule<br>\nis applied. (The Nat_Arith simprocs failed to follow either of these<br>\nguidelines.)</p>\n</blockquote>\n</blockquote>\n<p>Perhaps I can explain this better. Here's how the Nat_Arith<br>\ncancellation simprocs worked before yesterday's rev. 868dc809c8a2 --<br>\nnote that this technique is <em>wrong</em> and simproc writers must avoid it!</p>\n<p>The idea is to prove e.g. \"(a + x + b &lt; c + x + d) = (a + b &lt; c + d)\"<br>\nby inserting \"x\" on the right, and then doing ac rewriting. The<br>\nsimproc does the same steps as this proof script:</p>\n<p>schematic_lemma<br>\n  \"(a + size (x::?'b1::size) + b &lt; c + size (x::?'b1::size) + d) = (a</p>\n<ul>\n<li>b &lt; c + d)\"<br>\napply (rule_tac ?k.1 = \"size x\" in nat_add_left_cancel_less [THEN subst_equals])<br>\napply (simp only: add_ac)</li>\n</ul>\n<p>Stepping through this proof with \"show_sorts\" enabled reveals the<br>\nproblem: The inserted \"x\" has type \"?'b3\" instead of \"?'b1\", because<br>\nrule_tac automatically renames schematics in the rule to avoid clashes<br>\nwith schematics in the proof goal.</p>\n<blockquote>\n<p>So you decided against the generic approach of importing the schematic<br>\nvariables? Was it because of efficiency?</p>\n</blockquote>\n<p>I haven't looked at efficiency yet. The more serious problem is that<br>\nsimprocs that use this approach now are broken! The simprocs in<br>\nProvers/Arith/cancel_numerals.ML already try to use<br>\nVariable.import_terms and Variable.export to temporarily fix<br>\nschematics. But on Dmitriy's original example, natless_cancel_numerals<br>\nreturns an equation that cannot be used by the simplifier because its<br>\nschematic type variables are instantiated.</p>\n<p>I'm not sure, but there might be a bug in Variable.export and related<br>\nfunctions. For example:</p>\n<p>ML_val {*<br>\nlet<br>\n  val ctxt = @{context}<br>\n  val ts1 = [Thm.term_of @{cpat \"size (x::?'a::size)\"}]<br>\n  val (ts2, ctxt') = Variable.import_terms true ts1 ctxt<br>\n  val ts3 = Variable.export_terms ctxt' ctxt ts2<br>\nin<br>\n  (ts1, ts2, ts3)<br>\nend<br>\n*}</p>\n<p>val it =<br>\n   ([Const (\"Nat.size_class.size\", \"?'a \\&lt;Rightarrow&gt; nat\") $ Free<br>\n(\"x\", \"?'a\")],<br>\n    [Const (\"Nat.size_class.size\", \"'a \\&lt;Rightarrow&gt; nat\") $ Free (\"x\", \"'a\")],<br>\n    [Const (\"Nat.size_class.size\", \"'a \\&lt;Rightarrow&gt; nat\") $ Free (\"x\", \"'a\")]):<br>\n   term list * term list * term list</p>\n<p>The export_terms step does nothing at all! (This example actually<br>\nworks correctly if we replace \"x\" with \"?x\" in the input term.)</p>\n<p>I'm afraid we can't recommend simproc writers to use the<br>\nVariable.import/export technique, at least not until we figure this<br>\nout.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294216756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895284
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\ntheory Simproc_Fail<br>\nimports Main<br>\nbegin</p>\n<p>notepad<br>\nbegin<br>\n   have \"(\\&lt;And&gt;ys zs. length ys &lt; Suc (length zs + length ys))\" by simp<br>\n   hence True apply simp sorry<br>\nend</p>\n<p>end</p>\n<p>This is a hard crash, not a tactic failure.  Generally, goal states with <br>\npolymorphic content (schematic type variables) are pathologic; many proof <br>\ntools will choke on them.  It is of the \"don't do it then category\": <br>\nposing goals with schematic type variables is asking for trouble.</p>\n<p>Above this happens above after piping the \"this\" fact into the True goal <br>\nvia the \"insert\" phase of simp. Instead of 'using' polymoprhic facts, <br>\ntypically those from the background library, one should \"add\" them somehow <br>\nto the automated tools, e.g. (simp add: ...), (auto simp add: ...), (auto <br>\niff: ...) ...</p>\n<p>Anyway, did you have a concrete application where unresolved types in <br>\ngoals were required, or was it just one of the common accidents to get <br>\nthem via bad luck?</p>\n<p>This incident remindes me again that I wanted to work out some refined <br>\ncolor scheme for term variables with unexpected poloypmorphism, <br>\npotentially with some extra tool tips apart from the coloring.</p>\n<p>Makarius</p>",
        "id": 294216774,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895308
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sat, 21 Jul 2012, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Fri, Jul 20, 2012 at 5:36 PM, Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt; wrote:</p>\n<p>On 20.07.2012 15:06, Brian Huffman wrote:</p>\n<blockquote>\n<blockquote>\n<p>A simproc must never instantiate any schematic variable. Some<br>\nguidelines for simproc writers: Internal proofs should use the<br>\nsimplifier only in \"safe\" mode, i.e. only using the \"safe\" solvers,<br>\nwhich avoid instantiating schematics. Also, avoid instantiating rules<br>\nwith terms from the input and then using those rules with rtac,<br>\nbecause schematic variables in a rule are not preserved when the rule<br>\nis applied. (The Nat_Arith simprocs failed to follow either of these<br>\nguidelines.)</p>\n</blockquote>\n</blockquote>\n<p>Perhaps I can explain this better. Here's how the Nat_Arith<br>\ncancellation simprocs worked before yesterday's rev. 868dc809c8a2 --<br>\nnote that this technique is <em>wrong</em> and simproc writers must avoid it!</p>\n</blockquote>\n<p>What is wrong, fixed, broken now?  I am confused.</p>\n<p>The simproc under consideration stems from 1997, when I was supervising <br>\nStefan Berghofer in a very small student project.  According to the <br>\nMercurial history, it has not really been improved since then.  I first <br>\nthought that it was covered by Brian's general simproc renovation project <br>\nfor Isabelle2012, but it does not seem the case.</p>\n<p>IIRC, the system was more aggressive back then to reject goals with <br>\nschematic types outright.</p>\n<blockquote>\n<p>The idea is to prove e.g. \"(a + x + b &lt; c + x + d) = (a + b &lt; c + d)\"<br>\nby inserting \"x\" on the right, and then doing ac rewriting. The<br>\nsimproc does the same steps as this proof script:</p>\n<p>schematic_lemma<br>\n \"(a + size (x::?'b1::size) + b &lt; c + size (x::?'b1::size) + d) = (a<br>\n+ b &lt; c + d)\"<br>\napply (rule_tac ?k.1 = \"size x\" in nat_add_left_cancel_less [THEN subst_equals])<br>\napply (simp only: add_ac)</p>\n</blockquote>\n<p>Goals with schematic type variables routinely lead to undefined behaviour. <br>\nSchematic types for fixed term variables are especially pathologic. Does <br>\nthis example have any practical relevance?</p>\n<p>Anyway, a more profound deficiency of this modest simproc is this: It is <br>\nsupposed to normalize certain outer algebraic structure, but it retains <br>\nthe concrete subterms.  Thus the normalization might do non-sense with the <br>\naccidental substructure, not just with its hidden polymorphism as above.</p>\n<p>This was already known in 1997, but we did not have the technology so do <br>\nbetter on the spot.  Today in 2012, it should be trivial to use the local <br>\ncontext of the simproc (from the \"ss\") to introduce fresh fixes for the <br>\nterms (ts, us, vs), then prove the result in its generalized form with <br>\nfully opaque subterms, finally export the resulting equation to hand it <br>\nback to the simplifier.  Thus the local goal is fully fixed with fixed <br>\ntypes, and the result as schematic and poylmorphic as required. The <br>\nsimplifier will apply higher-order matching to recover the concrete <br>\ninstance.</p>\n<blockquote>\n<p>I'm not sure, but there might be a bug in Variable.export and related<br>\nfunctions. For example:</p>\n<p>ML_val {*<br>\nlet<br>\n val ctxt = @{context}<br>\n val ts1 = [Thm.term_of @{cpat \"size (x::?'a::size)\"}]<br>\n val (ts2, ctxt') = Variable.import_terms true ts1 ctxt<br>\n val ts3 = Variable.export_terms ctxt' ctxt ts2<br>\nin<br>\n (ts1, ts2, ts3)<br>\nend<br>\n*}</p>\n<p>val it =<br>\n  ([Const (\"Nat.size_class.size\", \"?'a \\&lt;Rightarrow&gt; nat\") $ Free<br>\n(\"x\", \"?'a\")],<br>\n   [Const (\"Nat.size_class.size\", \"'a \\&lt;Rightarrow&gt; nat\") $ Free (\"x\", \"'a\")],<br>\n   [Const (\"Nat.size_class.size\", \"'a \\&lt;Rightarrow&gt; nat\") $ Free (\"x\", \"'a\")]):<br>\n  term list * term list * term list</p>\n<p>The export_terms step does nothing at all! (This example actually<br>\nworks correctly if we replace \"x\" with \"?x\" in the input term.)</p>\n<p>I'm afraid we can't recommend simproc writers to use the <br>\nVariable.import/export technique, at least not until we figure this out.</p>\n</blockquote>\n<p>A fixed term variable x::?'a with schematic type should normally not occur <br>\nduring logical inference.  It conceptually means that the type-inference <br>\nphase did not finish its job before entering the logic.  It might also <br>\nmean that old and new tools were combined in a odd way, without the <br>\n\"proper context\" or things not declared properly in the context.</p>\n<p>Fixed type variables within fixed term variables are still fixed, <br>\naccording to Hindley-Milner polymorphism.  So the above export looks <br>\nright. If subterms with their potential hidden polymorphism are made <br>\nabstract as sketched above, such problems will not occur.</p>\n<p>Makarius</p>",
        "id": 294216781,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895315
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Sat, Jul 21, 2012 at 8:19 PM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>On Sat, 21 Jul 2012, Brian Huffman wrote:</p>\n<p>On Fri, Jul 20, 2012 at 5:36 PM, Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>wrote:<br>\n&gt;</p>\n<p>On 20.07.2012 15:06, Brian Huffman wrote:</p>\n<blockquote>\n<blockquote>\n<p>A simproc must never instantiate any schematic variable. Some<br>\nguidelines for simproc writers: Internal proofs should use the<br>\nsimplifier only in \"safe\" mode, i.e. only using the \"safe\" solvers,<br>\nwhich avoid instantiating schematics. Also, avoid instantiating rules<br>\nwith terms from the input and then using those rules with rtac,<br>\nbecause schematic variables in a rule are not preserved when the rule<br>\nis applied. (The Nat_Arith simprocs failed to follow either of these<br>\nguidelines.)</p>\n</blockquote>\n</blockquote>\n<p>Perhaps I can explain this better. Here's how the Nat_Arith<br>\ncancellation simprocs worked before yesterday's rev. 868dc809c8a2 --<br>\nnote that this technique is <em>wrong</em> and simproc writers must avoid it!</p>\n</blockquote>\n<p>What is wrong, fixed, broken now?  I am confused.</p>\n</blockquote>\n<p>What's wrong: The implementation of the simprocs in<br>\nHOL/Tools/nat_arith.ML of Isabelle2012. (In particular, the function<br>\ngen_uncancel_tac is not robust in the presence of schematics.) Writers<br>\nof new simprocs should not emulate this code.</p>\n<p>What's fixed: Since rev. 868dc809c8a2, the simprocs in<br>\nHOL/Tools/nat_arith.ML work correctly on goals with schematics.</p>\n<blockquote>\n<blockquote>\n<p>The idea is to prove e.g. \"(a + x + b &lt; c + x + d) = (a + b &lt; c + d)\"<br>\nby inserting \"x\" on the right, and then doing ac rewriting. The<br>\nsimproc does the same steps as this proof script:</p>\n<p>schematic_lemma<br>\n \"(a + size (x::?'b1::size) + b &lt; c + size (x::?'b1::size) + d) = (a<br>\n+ b &lt; c + d)\"<br>\napply (rule_tac ?k.1 = \"size x\" in nat_add_left_cancel_less [THEN<br>\nsubst_equals])<br>\napply (simp only: add_ac)</p>\n</blockquote>\n<p>Goals with schematic type variables routinely lead to undefined behaviour.<br>\nSchematic types for fixed term variables are especially pathologic. Does<br>\nthis example have any practical relevance?</p>\n</blockquote>\n<p>Yes, it does.</p>\n<p>Sometimes users have proof goals containing schematics. Sometimes they<br>\nrun the simplifier on such goals. This can result in simprocs being<br>\nasked to rewrite terms containing schematics. For example, a simproc<br>\nmay need to internally prove the equality \"(a + size (x::?'b1::size) +<br>\nb &lt; c + size (x::?'b1::size) + d) = (a + b &lt; c + d)\".</p>\n<p>Keep in mind that the proof script above is not a <em>user</em> proof; it<br>\nrepresents the internal proof done by a simproc.</p>\n<blockquote>\n<p>Anyway, a more profound deficiency of this modest simproc is this: It is<br>\nsupposed to normalize certain outer algebraic structure, but it retains the<br>\nconcrete subterms.  Thus the normalization might do non-sense with the<br>\naccidental substructure, not just with its hidden polymorphism as above.</p>\n<p>This was already known in 1997, but we did not have the technology so do<br>\nbetter on the spot.  Today in 2012, it should be trivial to use the local<br>\ncontext of the simproc (from the \"ss\") to introduce fresh fixes for the<br>\nterms (ts, us, vs), then prove the result in its generalized form with fully<br>\nopaque subterms, finally export the resulting equation to hand it back to<br>\nthe simplifier.  Thus the local goal is fully fixed with fixed types, and<br>\nthe result as schematic and poylmorphic as required. The simplifier will<br>\napply higher-order matching to recover the concrete instance.</p>\n</blockquote>\n<p>I think your idea would work. However it seems like it would be<br>\nnon-trivial to implement: You would have to determine the high-level<br>\nstructure of the original term, identify which of the complex subterms<br>\nare equal, and then build new, abstract terms with fresh variables in<br>\nthe right places. Do you think we should recommend this technique as a<br>\nstandard best-practice for simproc writers?</p>\n<p>The technique used by the simprocs in<br>\nHOL/Tools/nat_numeral_simprocs.ML (based on an ML functor from<br>\nProvers/Arith/cancel_numerals.ML) is much easier to use: Just do a<br>\nVariable.import_terms at the beginning to locally fix the schematics,<br>\nand then run Variable.export on the resulting equation.</p>\n<p>I think the Variable.import/export technique would make a good<br>\nofficial recommendation for simproc writers (something for the<br>\nCookbook, maybe) if it only worked right! This is why I complained of<br>\na possible bug in Variable.export.</p>\n<p>In Dmitriy's original example, the simp trace reveals that the<br>\nnatless_cancel_numerals simproc (which uses the import/export<br>\ntechnique) returns an unusable rule where some of the locally-fixed<br>\ntype variables have not been properly generalized again.</p>\n<p>declare [[show_types]]<br>\ndeclare [[simp_trace]]<br>\ndeclare [[simp_debug]]</p>\n<p>notepad<br>\nbegin<br>\n  have \"(\\&lt;And&gt;ys zs. length ys &lt; Suc (length zs + length ys))\" by simp<br>\n  hence True apply simp sorry<br>\nend</p>\n<p>[1]Trying procedure \"Numeral_Simprocs.natless_cancel_numerals\" on:<br>\nlength (:000\\&lt;Colon&gt;?'a1 list) &lt; Suc (length (:001\\&lt;Colon&gt;?'b1 list) +<br>\nlength :000)<br>\n...<br>\n[1]Procedure \"Numeral_Simprocs.natless_cancel_numerals\" produced rewrite rule:<br>\nlength (:000\\&lt;Colon&gt;'a list) &lt; Suc (length (:001\\&lt;Colon&gt;'b list) +<br>\nlength :000) \\&lt;equiv&gt;<br>\n(0\\&lt;Colon&gt;nat) &lt; Suc (length :001)</p>\n<blockquote>\n<p>A fixed term variable x::?'a with schematic type should normally not occur<br>\nduring logical inference.  It conceptually means that the type-inference<br>\nphase did not finish its job before entering the logic.  It might also mean<br>\nthat old and new tools were combined in a odd way, without the \"proper<br>\ncontext\" or things not declared properly in the context.</p>\n</blockquote>\n<p>Oh, but it can, and it does! This situation is clearly shown in the<br>\nsimp trace above, which was produced by Dmitriy's completely<br>\nreasonable proof script.</p>\n<blockquote>\n<p>Fixed type variables within fixed term variables are still fixed, according<br>\nto Hindley-Milner polymorphism.  So the above export looks right. If<br>\nsubterms with their potential hidden polymorphism are made abstract as<br>\nsketched above, such problems will not occur.</p>\n</blockquote>\n<p>Of course, if we completely redesigned all of our simprocs, we could<br>\navoid all these problems.</p>\n<p>What we need, though, is a simple, practical technique that any<br>\nsimproc writer can use. The Variable.import/export technique would be<br>\njust the thing, but we need to address the bugs in Variable.export<br>\nfirst.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294216875,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895383
    }
]