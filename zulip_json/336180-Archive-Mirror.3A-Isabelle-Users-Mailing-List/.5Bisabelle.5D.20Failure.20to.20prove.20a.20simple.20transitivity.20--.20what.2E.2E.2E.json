[
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nI am stumped.  I have a proof block of the following form:</p>\n<p>proof -<br>\n   ...a bunch of stuff that proves A \"2\" and \"6\"...</p>\n<p>let ?X = \"...a modestly sized expression...\"<br>\n   let ?Y = \"...another expression of similar size...\"<br>\n   let ?Z = \"...yet another expression similar to the first...\"</p>\n<p>have \"?X = ?Y\" using A by auto<br>\n   also have \"?Y = ?Z\" using 2 6 by auto<br>\n   finally show \"?X = ?Z\" by auto<br>\n qed</p>\n<p>The proofs of \"?X = ?Y\" and \"?Y = ?Z\" succeed.</p>\n<p>The proof of \"?X = ?Z\" does not (the final \"auto\" is underlined<br>\nwith a red squiggle and the output window says \"Failed to apply<br>\ninitial proof method\", though the \"using this\" and \"goal\"<br>\nexpressions are identical).</p>\n<p>I introduced the \"lets\" after encountering the original problem,<br>\nto make sure that there wasn't some subtle difference in the<br>\nexpressions or that they were being interpreted in different ways<br>\nif they occurred multiple times.</p>\n<p>The \"show\" is in blue, indicating that it matches the statement<br>\nto be proved in the current block.  It doesn't matter if I change<br>\n\"show\" to \"have\", the proof still fails.  It also doesn't matter<br>\nif I change \"have ... also have ... finally\" to<br>\n\"have ... moreover have ... ultimately show\".<br>\nI also tried rewriting it as:</p>\n<p>have XY: \"?X = ?Y\" using A by auto<br>\n    have YZ: \"?Y = ?Z\" using 2 6 by auto<br>\n    thus \"?X = ?Z\" by (metis XY YZ)</p>\n<p>and metis does not terminate.</p>\n<p>Does anyone have any idea what could cause this?  I can't really<br>\ndistill the example better because it's embedded in thousands of<br>\nlines of context.  As I indicated, I tried ways of rewriting it<br>\nthat seemed to me like they might work around the problem, to no<br>\navail.</p>\n<p>- Gene Stark</p>",
        "id": 294664981,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171408
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nSomething to do with mismatching types or type classes I'd expect.</p>",
        "id": 294665034,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171426
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Eugene,</p>\n<p>Another cause might be eta-expansion which happens occasionally during resolution and is <br>\nnot shown in the proof state by default (attribute eta_contract). When this happens, the <br>\nsimplifier can go into very different directions. Have you tried the following?</p>\n<p>have \"?X = ?Y\" using A by auto<br>\n     also have \"?Y = ?Z\" using 2 6 by auto<br>\n     finally show \"?X = ?Z\" .</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294665045,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171432
    },
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear Eugene,</p>\n<p>another potential failure reason: is ?Y a subexpression of ?X ? Then it might be the case<br>\nthat the „?Y = ?Z“ also modifies the ?X. To prevent this you can try</p>\n<p>def X = ?X<br>\ndef Z = ?Z<br>\nhave „X = ?Y“ unfolding X_def using A by auto<br>\nalso have „?Y = Z“ unfolding Z_def using 2 6 by auto<br>\nfinally have „?X = ?Z“ unfolding X_def Z_def .</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294665063,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171439
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nThanks for the suggestions.  I've tried those, but they don't help.<br>\nHere is an abstracted version of the situation, which tries to get<br>\nrid of some of the simplifier issues by introducing definitions.<br>\nThis one happens to succeed, but not in the way I would expect<br>\n(the proof shown was generated by sledgehammer).  I don't really<br>\nunderstand why a trivial proof (not referencing X_def and Y_def)<br>\nis not possible. The types and the fact that the expressions don't<br>\nall have the same sets of free variables might be a clue.  Perhaps it<br>\nis something to do with the way sum types are implemented in the system.</p>\n<p>theory Barf<br>\nimports Main<br>\nbegin</p>\n<p>definition XXX :: \"'a ⇒ 'b ⇒ 'a ⇒ 'b ⇒ 'a + 'b ⇒ 'c + 'b\"<br>\n    where \"XXX f g x y = (λz :: 'a + 'b. Inr y)\"</p>\n<p>definition YYY :: \"'a =&gt; 'b =&gt; 'a =&gt; 'a =&gt; 'b =&gt; 'b =&gt; 'a + 'b =&gt; 'a + 'b\"<br>\n    where \"YYY f g x x' y y' = id\"</p>\n<p>definition ZZZ :: \"'a ⇒ 'b ⇒ 'a ⇒ 'b ⇒ 'b ⇒ 'a + 'b ⇒ 'd + 'b\"<br>\n    where \"ZZZ f g x y y' = (λz :: 'a + 'b. Inr y)\"</p>\n<p>lemma<br>\n    assumes \"XXX f g x y = YYY f g x x' y y'\"<br>\n    and \"YYY f g x x' y y' = ZZZ f g x y y'\"<br>\n    shows \"XXX f g x y = ZZZ f g x y y'\"<br>\n    proof -<br>\n      have \"XXX f g x y = id\"<br>\n        by (simp add: YYY_def assms(1))<br>\n      then show ?thesis<br>\n        using XXX_def id_apply sum.simps(4) by (metis (full_types))<br>\n    qed</p>\n<p>end</p>\n<p>The same approach with definitions has not yet allowed me to prove<br>\nthe original example, though, because as you can see, the proof that<br>\ndoes succeed is not a straight application of transitivity, but rather<br>\nuses special properties of the expressions involved.  Amusingly, when<br>\nI do try that approach on the original example, rendered as shown:</p>\n<p>have XY: \"XXX f g x y = YYY f g x x' y y'\"<br>\n            using A by (auto simp add: XXX_def YYY_def)<br>\n          moreover have YZ: \"YYY f g x x' y y' = ZZZ f g x y y'\"<br>\n            using 2 6 by (auto simp add: YYY_def ZZZ_def)<br>\n          ultimately have \"XXX f g x y = ZZZ f g x y y'\"<br>\n            using HOL.trans [of \"XXX f g x y\" \"YYY f g x x' y y'\" \"ZZZ f g x y y'\"]</p>\n<p>the proof state display shows:</p>\n<p>proof (prove)<br>\nusing this:<br>\n    XXX f g x y = YYY f g x x' y y'<br>\n    YYY f g x x' y y' = ZZZ f g x y y'<br>\n    XXX f g x y = YYY f g x x' y y' ⟹<br>\n    YYY f g x x' y y' = ZZZ f g x y y' ⟹ XXX f g x y = ZZZ f g x y y'</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>XXX f g x y = ZZZ f g x y y'</li>\n</ol>\n<p>Have I maybe missed some subtle point about HOL?</p>\n<p>- Gene Stark</p>",
        "id": 294665090,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171451
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gene,</p>\n<p>In this example, polymorphism gets in the way. Type inference assigns different types to <br>\nthe ZZZ instances. You can see this by hovering over the ZZZs in the theory file <br>\n(unfortunately, this does not work in the Output buffer) or with</p>\n<p>using [[show_consts]]<br>\n   apply -</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294665105,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171458
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nAh, yes.  Thank you, Andreas.</p>\n<p>I completed the original proof by introducing type constraints to avoid the<br>\nunwanted polymorphism.</p>\n<p>- Gene Stark</p>",
        "id": 294665118,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171463
    }
]