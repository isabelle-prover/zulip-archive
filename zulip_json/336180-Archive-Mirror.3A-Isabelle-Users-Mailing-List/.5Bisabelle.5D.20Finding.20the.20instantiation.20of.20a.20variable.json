[
    {
        "content": "<p>From: Steve W &lt;<a href=\"mailto:s.wong.731@gmail.com\">s.wong.731@gmail.com</a>&gt;<br>\nHi,</p>\n<p>Does anyone know how one would go about finding the instantiation of a<br>\nvariable in ML? Say, if I can obtain the proof term for the theorem 'EX f x.<br>\nf x &gt; 0', how do I work with the proof term in order to find the<br>\ninstantiations of 'f' and 'x'?</p>\n<p>Thanks<br>\nSteve</p>",
        "id": 294111799,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837077
    },
    {
        "content": "<p>From: Steve W &lt;<a href=\"mailto:s.wong.731@gmail.com\">s.wong.731@gmail.com</a>&gt;<br>\nOn Thu, Jul 8, 2010 at 3:38 PM, Steve W &lt;<a href=\"mailto:s.wong.731@gmail.com\">s.wong.731@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>Does anyone know how one would go about finding the instantiation of a<br>\nvariable in ML? Say, if I can obtain the proof term for the theorem 'EX f x.<br>\nf x &gt; 0', how do I work with the proof term in order to find the<br>\ninstantiations of 'f' and 'x'?</p>\n<p>Would the first step be to reconstruct the proof using<br>\nReconstruct.reconstruct_proof? If so, what would subsequent steps involve?</p>\n</blockquote>\n<p>Any help will be appreciated.</p>\n<p>Thanks<br>\nSteve</p>\n<p>Thanks</p>\n<blockquote>\n<p>Steve<br>\n</p>\n</blockquote>",
        "id": 294111875,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837091
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Steve,</p>\n<blockquote>\n<blockquote>\n<p>Does anyone know how one would go about finding the instantiation of a<br>\nvariable in ML?  Say, if I can obtain the proof term for the theorem 'EX f x.<br>\nf x &gt; 0', how do I work with the proof term in order to find the<br>\ninstantiations of 'f' and 'x'?</p>\n</blockquote>\n</blockquote>\n<p>There are at least two ways in which your question can be understood:</p>\n<p>a) Given a proof of \"EX x. P x\", you want to extract the term \"t\" that <br>\nwas used to prove the existential statement</p>\n<p>b) Given a proof of \"EX x. P x\", you want to find any term t such that <br>\n\"P t\" holds.</p>\n<p>to a) This is not possible in general. Note that Isabelle/HOL implements <br>\nclassical logic, which allows existential statements without providing <br>\nthe values that are proved to exists. So there is no \"instantiation\" <br>\nthat can be extracted, at least in general. You can find a simple <br>\nexample of such a proof (of the well-known Drinker's Principle) in the <br>\nfile \"HOL/Isar_Examples/Drinker.thy\".</p>\n<p>If the proof you have does not involve classical reasoning, then your <br>\nproblem can be solved in principle. But even then, the proof may be more <br>\nthan just an application of the rule \"exI\". Then the following paper is <br>\nprobably relevant:</p>\n<p>Stefan Berghofer. Program Extraction in simply-typed Higher Order Logic.<br>\nTYPES 2002<br>\n<a href=\"http://www4.informatik.tu-muenchen.de/~berghofe/papers/TYPES2002.pdf\">http://www4.informatik.tu-muenchen.de/~berghofe/papers/TYPES2002.pdf</a></p>\n<p>to b) If you just need some value that satisfies the property, then you <br>\ncan of course always use the choice operator and write \"SOME x. P x\". Of <br>\ncourse this does not contain any information, but sometimes it is <br>\nsufficient.</p>\n<blockquote>\n<p>Would the first step be to reconstruct the proof using<br>\nReconstruct.reconstruct_proof? If so, what would subsequent steps involve?</p>\n</blockquote>\n<p>Reconstructing is usually the first thing to do if you want to do <br>\nanything useful with a proof term. Further, I don't know. Maybe the <br>\nextraction described in the paper above does what you want (but I am not <br>\nsure what exactly you want).</p>\n<blockquote>\n<p>Any help will be appreciated.</p>\n</blockquote>\n<p>Actually, what is your application for this? It seems to be a rather <br>\nunusual way of using Isabelle. If you give us some more concrete <br>\ninformation about the big picture, i.e., what functionality do you want <br>\nto realise in the end, then you might get more helpful answers.</p>\n<p>Alex</p>",
        "id": 294111887,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837098
    },
    {
        "content": "<p>From: Steve W &lt;<a href=\"mailto:s.wong.731@gmail.com\">s.wong.731@gmail.com</a>&gt;<br>\nHi Alexander,</p>\n<p>I think my situation is similar to a). How about in the following:</p>\n<p>axiomatization<br>\nf :: \"real =&gt; real\" and<br>\nc :: real where<br>\nax1: \"f c = 0\"</p>\n<p>lemma lem1: \"EX x. f x = 0\"<br>\nusing ax1<br>\napply auto<br>\ndone</p>\n<p>Can one extract the term that was used to prove the existential statement by<br>\nauto? I.e., that term should be 'c' due to ax1. I've tried running<br>\n'full_prf' after 'apply auto', but I get an error about 'minimal proof<br>\nobject' even I have Full Proof switched on in PG. Does auto instantiate the<br>\nexistential variable to 'c'?</p>\n<p>Now, if I have the following instead:</p>\n<p>lemma lem1: \"EX x. f x = 0\"<br>\nusing ax1<br>\napply (rule exI [where x = c])<br>\ndone</p>\n<p>full_prf gives:</p>\n<p>protectI % EX x::real. f x = (0::real) %%<br>\n (exI % TYPE(real) % (%a::real. f a = (0::real)) % c %% (OfClass type_class<br>\n% TYPE(real)) %% thm.Test.ax1)</p>\n<p>It's clearer now that 'x' is instantiated to 'c' (because the instantiation<br>\nis explicit in the proof), which is a lambda term. However, how should 'c'<br>\nbe extracted from the proof?</p>\n<p>Thanks again.<br>\nSteve</p>",
        "id": 294112024,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837147
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nSteve W wrote:</p>\n<blockquote>\n<p>Can one extract the term that was used to prove the existential statement by<br>\nauto? I.e., that term should be 'c' due to ax1.</p>\n</blockquote>\n<p>I think in general the answer is no, since auto may perform classical <br>\nreasoning. In special cases, this may be possible but is certainly not <br>\ntrivial. You would probably have to study some decent proof theory...</p>\n<blockquote>\n<p>I've tried running<br>\n'full_prf' after 'apply auto', but I get an error about 'minimal proof<br>\nobject' even I have Full Proof switched on in PG.</p>\n</blockquote>\n<p>I am surprised by this myself. I would also have expected a full proof <br>\nhere. Maybe someone else has an idea?</p>\n<blockquote>\n<p>Does auto instantiate the<br>\nexistential variable to 'c'?</p>\n<p>Now, if I have the following instead:</p>\n<p>lemma lem1: \"EX x. f x = 0\"<br>\nusing ax1<br>\napply (rule exI [where x = c])<br>\ndone</p>\n<p>full_prf gives:</p>\n<p>protectI % EX x::real. f x = (0::real) %%<br>\n (exI % TYPE(real) % (%a::real. f a = (0::real)) % c %% (OfClass type_class<br>\n% TYPE(real)) %% thm.Test.ax1)</p>\n<p>It's clearer now that 'x' is instantiated to 'c' (because the instantiation<br>\nis explicit in the proof), which is a lambda term. However, how should 'c'<br>\nbe extracted from the proof?</p>\n</blockquote>\n<p>You can read about the format of proof terms in the paper that I <br>\nmentioned. From this, I guess, you will have to work out the details <br>\nyourself (starting from a precise problem definition), since it hasn't <br>\nbeen done yet AFAIK.</p>\n<p>Alex</p>",
        "id": 294112308,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837226
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIf this is Isabelle2009-2, then you need to build HOL-Proofs explicitly, <br>\nvia \"Isabelle2009-2/build -m HOL-Proofs\" on the command lines.</p>\n<p>In the past proof terms used to be part of the default HOL image, but we <br>\nhad to discontinue that due to resource limitations.</p>\n<p>Makarius</p>",
        "id": 294113332,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837534
    }
]