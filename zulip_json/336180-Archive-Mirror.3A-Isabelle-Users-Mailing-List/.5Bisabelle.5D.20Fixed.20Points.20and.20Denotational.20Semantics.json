[
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>I (kind of) wanted to star playing a bit with fixpoint operators in<br>\nIsabelle, which is motivated by  experiments in denotational<br>\nsemantics of imperative languages.</p>\n<p>I have noticed that the theories available in the Isabelle<br>\ndistribution (concerning the IMP language) follow Winskel´s<br>\nrelational approach. That is to say, the denotation of a command<br>\nis a set of pair of states, and then one can easily define<br>\nthe semantics of while by the least fixpoint of the appropriate<br>\nfunctional using Isabelle´s lfp fixpoint operator.</p>\n<p>In general, the fix point operator  fix  has type<br>\n(D-&gt;D)-&gt;D where D must be a chain complete cpo with<br>\na least element (according to Winskel´s Lecture Notes on<br>\nDenotational Semantics). In Isabelle, the operator<br>\nlfp has type ('a -&gt;'a)-&gt;'a, and it is defined in the<br>\ntheory Complete Lattice. So, what is the minimal requirement<br>\nin Isabelle</p>\n<p>On the other hand, in section 6.5 of the Isabelle/HOL tutorial<br>\nthe type of 'a is also a set of pairs and in the discussion<br>\nit is implied that 'a must always be a set.<br>\nThe book \"Concrete Semantics\"<br>\nby Nipkow and Klein also uses a relational semantics</p>\n<p>So  my main questions are:</p>\n<p>1) How to use the fixpoint operator on functionals that<br>\nare not based on sets of pairs? ?</p>\n<p>2) Do I need complete lattices or cpo´s with least elements<br>\nsuffice?</p>\n<p>3) Can I use functionals where D is a function space<br>\n(for instance, using partial maps provided by Isabelle).</p>\n<p>4) Do I have to use type classes to make the appropriate<br>\ninstantiations? (If yes I have no idea how)</p>\n<p>Thanks for any help. This will be a long journey!</p>",
        "id": 294253419,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911659
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Alfio,</p>\n<p>Have you already looked at HOLCF? It formalises domain theory and denotational semantics. <br>\nIf not, that's where you should go first. Brian Huffman's PhD thesis describes what is in <br>\nthere and how to use it.</p>\n<p>lfp has type \"('a =&gt; 'a) =&gt; 'a\" where 'a must be of sort complete_lattice. _ set <br>\ninstantiates complete_lattice, so lfp can in particular be used for functionals on all <br>\nsets. But you can also use other types that instantiate complete_lattice. For example, if <br>\n'a is a complete lattice, then so is _ =&gt; 'a, i.e., you can also use functions.</p>\n<p>If you only have a chain-complete partial order with a least element, you cannot use lfp, <br>\nbut instead fixp from the theory Complete_Partial_Order, but you have to deal with <br>\nadmissibility yourself. This is where HOLCF greatly helps you.</p>\n<p>All of the above solutions are based on type classes, and this is what makes them <br>\nconvenient. The package partial_function provides some front-end to fixp that does not <br>\nrely on type classes, but I recommend that you use the type classes, because they make <br>\ndefinitions and proofs much simpler.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294253424,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911661
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nOn Tue, Oct 8, 2013 at 7:32 AM, Andreas Lochbihler<br>\n&lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Alfio,</p>\n<p>Have you already looked at HOLCF? It formalises domain theory and<br>\ndenotational semantics. If not, that's where you should go first. Brian<br>\nHuffman's PhD thesis describes what is in there and how to use it.<br>\n[...]<br>\nIf you only have a chain-complete partial order with a least element, you<br>\ncannot use lfp, but instead fixp from the theory Complete_Partial_Order, but<br>\nyou have to deal with admissibility yourself. This is where HOLCF greatly<br>\nhelps you.</p>\n</blockquote>\n<p>Hi Alfio,</p>\n<p>I should point out a few differences between the HOLCF and<br>\nComplete_Partial_Order formalizations of fixpoints:</p>\n<p>Class ccpo from Complete_Partial_Order uses a slightly stronger<br>\ncompleteness condition than HOLCF uses; ccpo requires lubs of<br>\narbitrary chains, while HOLCF requires lubs only for countable chains.<br>\nOn the other hand, class ccpo has fixpoints for all monotone<br>\nfunctions, whereas HOLCF additionally requires functions to be<br>\ncontinuous.</p>\n<p>The other major consideration is that HOLCF uses a continuous function<br>\nspace type \"'a -&gt; 'b\" almost everywhere, rather than using ordinary<br>\nfunctions \"'a =&gt; 'b\" with a continuity predicate. One consequence is<br>\nthat you are locked in to using type classes for cpos (type 'a -&gt; 'b<br>\nis only defined for cpo types); Complete_Partial_Order is a bit more<br>\nflexible in this regard.</p>\n<p>That said, if you are willing to commit to using type classes and the<br>\ncontinuous function space type, HOLCF provides highly tuned automation<br>\nfor proving continuity and admissibility.</p>\n<p>Whichever library you decide to use, I'd welcome any questions,<br>\ncomments, or suggestions for improvements to either library.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294253445,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911673
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nMany Thanks Brian and Andreas!</p>\n<p>I have already downloaded Brian´s PhD thesis and it seems<br>\nhighly readable!</p>\n<p>All The Best!</p>",
        "id": 294253474,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911682
    },
    {
        "content": "<p>From: Viorel Preoteasaa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHi Alfio,</p>\n<p>Another approach of using least fix points for semantics of programs<br>\nis when using a predicate transformer semantics. As compared to<br>\nprograms as relations which can be used for modelling partial correctness, <br>\npredicate transformers allows modelling total correctness.</p>\n<p>If S is the set of computation states, programs are modelled as monotonic <br>\nfunctions from power set of S (Pred.S = S-&gt;bool) to Pred.S. In this model a <br>\nprogram P applied to a set X of final states returns the initial states from <br>\nwhich P terminates, and it terminates in a state from X.</p>\n<p>Iteration can be defined in this model as a least fix point of a monotonic<br>\nfunction from (Pred.S)-&gt;(Pred.S) to (Pred.S)-&gt;(Pred.S). This least fix point<br>\nexists in the complete lattice of monotonic predicate transformers <br>\n((Pred.S)-&gt;(pred.S))</p>\n<p>You can find formalizations of these concepts in the AFP entries: </p>\n<p>[1] Semantics and Data Refinement of Invariant Based Programs <br>\n     (sections 3 and 4)<br>\n[2] Algebra of Monotonic Boolean Transformers (Section 3)</p>\n<p>and corresponding papers:</p>\n<p>[3] Preoteasa, Viorel and Back, Ralph-Johan. <br>\nInvariant Diagrams with Data Refinement. Formal Aspect of Computing. <br>\nVol: 24, Num: 1, Pages 67-95. Springer London. <br>\n<a href=\"http://dx.doi.org/10.1007/s00165-011-0195-2\">http://dx.doi.org/10.1007/s00165-011-0195-2</a>. 2012.</p>\n<p>[4]  Preoteasa, Viorel. Refinement algebra with dual operator. <br>\nScience of Computer Programming. <br>\n<a href=\"http://dx.doi.org/10.1016/j.scico.2013.07.002\">http://dx.doi.org/10.1016/j.scico.2013.07.002</a>. 2013.</p>\n<p>[2] and [4] introduces an algebra for modelling programs. The <br>\nbasic model for this algebra is set of monotonic predicate<br>\ntransformers with their operations, so everything that is<br>\ndone in the algebra is true in the model. Actually you will<br>\nfind the definition of the while statement and its properties <br>\nthe algebra part of the paper. The model contains just the <br>\nthe  results needed to show that it is indeed a model for the algebra.<br>\n    [2] and [4] uses an arbitrary Boolean algebra B instead of Pred.S</p>\n<p>The algebra is more abstract than the model. In the algebra<br>\nonly fixed points of certain functions are axiomatised. These<br>\nare the functions needed for defining the while statements.</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294253609,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911723
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nThank you Viorel for the very detailed reply and the great references.<br>\nI was not aware of them!</p>\n<p>All the Best!</p>",
        "id": 294253628,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911730
    }
]