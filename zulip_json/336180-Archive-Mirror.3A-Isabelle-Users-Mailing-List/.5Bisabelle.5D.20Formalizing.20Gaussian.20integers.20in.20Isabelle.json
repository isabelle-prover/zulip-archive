[
    {
        "content": "<p>From: Christian Weinz &lt;<a href=\"mailto:christian.weinz@stud.uni-goettingen.de\">christian.weinz@stud.uni-goettingen.de</a>&gt;<br>\nHello,</p>\n<p>For a project in my university I'm working on a formalization of the<br>\nGaussian integers in Isabelle. Eventually, I want to use that for<br>\nnumber theoretic proofs within Isabelle.</p>\n<p>My first approach was to look how the complex numbers were introduced<br>\nin Isabelle and to copy that for the Gaussian integers, basically just<br>\nreplacing real for int. That worked fine, and I went on to show class<br>\ninstantiations for my Gaussian integers.</p>\n<p>The Gaussian integers form a euclidean domain. For now, I'd be happy to<br>\nshow that the Gaussian integers allow unique factorizations into prime<br>\nfactors up to a unit factor, i.e. that they are a factorial ring, so I<br>\naimed for the class \"factorial_ring_gcd\" in<br>\n\"/HOL/Computational_Algebra/Factorial_Ring.thy\".</p>\n<p>However, that did not work out because the path \"factorial_ring_gcd -&gt;<br>\nfactorial_semiring_gcd -&gt; factorial_semiring -&gt; normalization_semidom<br>\n-&gt; semidom_divide_unit_factor\" in the class hierarchy forces me to<br>\ndefine the functions \"unit_factor\" and \"normalize\" for the Gaussian<br>\nintegers satisfying the class definition of<br>\n\"semidom_divide_unit_factor\" in \"/HOL/Rings.thy\". I see no way to<br>\nnormalize the Gaussian integers that way.</p>\n<p>My next approach would be to define the Gaussian integer as a<br>\nring_scheme and use \"/HOL/Algebra/Ring_Divisibility.thy\". From that I<br>\nwould get the \"factorization_property\" from the same file, but that<br>\nformalization looks less intuitive and less practical for my purposes.</p>\n<p>That is why I'm writing here. Is the class hierarchy not suitable for<br>\nformalizing what I need to achieve? Am I just overlooking something? It<br>\nmight be possible that I have a mistake in my understand of the<br>\nGaussian Integers. I'm thankful for any ideas.</p>\n<p>Thanks and happy new year,<br>\nChristian</p>",
        "id": 294767782,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202730
    },
    {
        "content": "<p>From: Christian Weinz &lt;<a href=\"mailto:christian.weinz@stud.uni-goettingen.de\">christian.weinz@stud.uni-goettingen.de</a>&gt;<br>\nThank you, and let me be so frank to directly take up that offer.</p>\n<p>I started working with HOL-Algebra to show the properties of the<br>\nGaussian Integers that I need. However, I very early ran into a problem<br>\nabout \"duplicate fact declarations\".</p>\n<p>Below is a relatively small theory that shows the problem. As well<br>\ngiven below is the error message that is shown in the output panel<br>\nafter the proof of the instantiation.</p>\n<p>It might very well be that I use \"HOL-Algebra\" incorrectly. In any<br>\ncase, a workaround would be very welcome.</p>\n<p>---- theory ----</p>\n<p>theory GaussianIntegers<br>\n  imports               <br>\n    \"HOL-Algebra.Multiplicative_Group\"<br>\nbegin</p>\n<p>codatatype gaussian_integer = Gaussian_Integer (Re: int) (Im: int)</p>\n<p>lemma gaussian_integer_eq_iff: \"x = y ⟷ Re x = Re y ∧ Im x = Im y\"<br>\n  by (auto intro: gaussian_integer.expand)</p>\n<p>abbreviation gaussian_integer_ring :: \"gaussian_integer ring\"<br>\n  where \"gaussian_integer_ring ≡<br>\n    ⦇carrier = UNIV,<br>\n    mult = (λx y. Gaussian_Integer (Re x * Re y - Im x * Im y)<br>\n                                   (Re x * Im y + Im x * Re y)),<br>\n    one = Gaussian_Integer 1 0,<br>\n    zero = Gaussian_Integer 0 0,<br>\n    add = (λx y. Gaussian_Integer (Re x + Re y) (Im x + Im y))⦈\"</p>\n<p>interpretation cring gaussian_integer_ring<br>\n  unfolding cring_def ring_def abelian_group_def abelian_monoid_def<br>\n    monoid_def comm_monoid_def comm_monoid_axioms_def ring_axioms_def<br>\n    abelian_group_axioms_def comm_group_def group_def group_axioms_def<br>\n    Units_def<br>\n  apply (simp add: add.commute distrib_right distrib_left<br>\n      gaussian_integer_eq_iff right_diff_distrib left_diff_distrib)<br>\nproof -<br>\n  have \"⋀g. Re (g) + Re (Gaussian_Integer (- Re g) (- Im g)) = 0<br>\n          ∧ Im (g) + Im (Gaussian_Integer (- Re g) (- Im g)) = 0\"<br>\n    by simp<br>\n  then show \"UNIV ⊆ {y. ∃x. gaussian_integer.Re y</p>\n<p>+ gaussian_integer.Re x = 0<br>\n                          ∧ gaussian_integer.Im y</p>\n<p>+ gaussian_integer.Im x = 0}\"<br>\n    by blast<br>\nqed</p>\n<p>end</p>\n<p>---- error message ----</p>\n<p>Duplicate fact declaration \"GaussianIntegers.add.is_monoid\" vs.<br>\n\"GaussianIntegers.add.is_monoid\"⌂<br>\nThe above error(s) occurred while activating locale instance<br>\nadd : <a href=\"http://Group.group\">Group.group</a> \"add_monoid gaussian_integer_ring\"</p>\n<p>Kind regards,<br>\nChristian</p>",
        "id": 294768130,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202910
    },
    {
        "content": "<p>From: Christian Weinz &lt;<a href=\"mailto:christian.weinz@stud.uni-goettingen.de\">christian.weinz@stud.uni-goettingen.de</a>&gt;<br>\nI feel I might be able to contribute to that. Is this effort organized<br>\nsomewhere?</p>\n<p>Best,<br>\nChristian</p>",
        "id": 294768143,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202916
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>I started working with HOL-Algebra to show the properties of the<br>\nGaussian Integers that I need. However, I very early ran into a problem<br>\nabout \"duplicate fact declarations\".</p>\n</blockquote>\n<p>The problem is the theorem \"comm_monoid.is_monoid\" in<br>\nHOL-Algebra.Multiplicative_Group. This theorem is completely unnecessary<br>\nand it leads to a name clash when interpreting the locale. No idea why<br>\nnobody noticed this before. We should really remove this before the next<br>\nrelease.</p>\n<p>Since you will want to use Euclidean domains, there really is no way<br>\npast this, since the theory in which they are defined in HOL-Algebra<br>\ndepends on Multiplicative_Group. The only workaround I can offer is to<br>\nlocally remove the theorem \"is_monoid\" on lines 649-650 of<br>\nMultiplicative_Group.thy in your local Isabelle installation /or/ to<br>\nwait until I removed it from the development version (will probably do<br>\nthat later today) and work with the development version<br>\n(<a href=\"http://isabelle.in.tum.de/repos/isabelle\">http://isabelle.in.tum.de/repos/isabelle</a>).</p>\n<p>Sorry about this – HOL-Algebra is not used very much and is /really/ messy.</p>\n<p>I think I'll have a shot at cleaning up the type classes enough to be<br>\nusable in your case during the next few weeks. I can't say yet if it<br>\nwill work out though, but hopefully this will be done by the next<br>\nrelease (which I guess will be some time around April or May).</p>\n<blockquote>\n<p>It might very well be that I use \"HOL-Algebra\" incorrectly. In any<br>\ncase, a workaround would be very welcome.</p>\n</blockquote>\n<p>There are quite a few things that I think should be done differently:</p>\n<ol>\n<li>\n<p>Locale interpretations are typically done with the \"unfold_locales\"<br>\ncommand. That makes things much easier.</p>\n</li>\n<li>\n<p>I would advise against calling your constructors \"Re\" and \"Im\",<br>\nbecause they will then clash with the \"Re\" and \"Im\" from the complex<br>\nnumbers.</p>\n</li>\n<li>\n<p>It is good to keep names short, especially ones you will use a lot.<br>\nPerhaps \"gauss_int\" instead of \"gaussian_integer\" etc.</p>\n</li>\n<li>\n<p>I think it will be much more pleasant for you to go as far as<br>\npossible using the typeclass, i.e. instantiate all the appropriate<br>\ntypeclasses (at least up \"idom\") for your Gaussian integers. Then you<br>\ncan still easily move into the HOL-Algebra setting by defining something<br>\nlike</p>\n<p>definition Gauss_Ints :: \"gauss_int ring\"<br>\n  where \"gaussian_integer_ring ≡ ⦇carrier = UNIV,<br>\n           mult = (*), one = 1, zero = 0, add = (+)⦈\"</p>\n</li>\n</ol>\n<p>Then you can get the properties you need (unique factorisation etc) from<br>\nHOL-Algebra and pull them out to the type-class-based setting again.<br>\nIdeally, you should also first define a Euclidean norm on the Gaussian<br>\nintegers with all its properties. This will allow you to easily switch<br>\nto the type class-based Euclidean rings later on.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294768163,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202928
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI removed the problematic lemma as of isabelle-dev/a3f7f00b4fd8 (cf.<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/a3f7f00b4fd8\">http://isabelle.in.tum.de/repos/isabelle/rev/a3f7f00b4fd8</a>).</p>\n<p>The interpretation of the ring locale should work now.</p>\n<p>Manuel</p>",
        "id": 294821326,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661242275
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>However, that did not work out because the path \"factorial_ring_gcd -&gt;<br>\nfactorial_semiring_gcd -&gt; factorial_semiring -&gt; normalization_semidom<br>\n-&gt; semidom_divide_unit_factor\" in the class hierarchy forces me to<br>\ndefine the functions \"unit_factor\" and \"normalize\" for the Gaussian<br>\nintegers satisfying the class definition of<br>\n\"semidom_divide_unit_factor\" in \"/HOL/Rings.thy\". I see no way to<br>\nnormalize the Gaussian integers that way.</p>\n</blockquote>\n<p>Yes, sorry, that's my fault.</p>\n<p>The purpose of normalize/unit_factor is to have a canonical<br>\nrepresentative for each association class in a ring. The obvious choice<br>\nfor Gaussian integers is to define \"normalize (a + i * b) = abs a + i *\nabs b\". Unfortunately, this doesn't work because the typeclass<br>\n(semidom_divide_unit_factor) requires \"unit_factor\" (and thereby<br>\n\"normalize\") to be multiplicative. This requirement simple developed<br>\nfrom the fact that \"normalize\" is multiplicative for all the examples we<br>\nhad back when we introduced these classes, and it makes many theorems<br>\n(e.g. about GCDs) much nicer to state.</p>\n<p>It is always possible to define a multiplicative \"normalize\" for a ring<br>\nwith unique factorisation (simply pick whatever canonical representative<br>\nyou want for any prime element and then lift it up to general ring<br>\nelements by multiplicativity), but of course that is not something one<br>\nreally wants to do. Especially because one often wants to show that<br>\nsomething is a Euclidean domain in order to get unique factorisation for<br>\nfree.</p>\n<p>The proper solution would be to remove the multiplicativity condition<br>\nfrom semidom_divide_unit_factor. I tried that once but it turned out to<br>\nbe quite a bit of work, so I gave up again. Perhaps it would be worth<br>\ngiving it another shot now.</p>\n<blockquote>\n<p>My next approach would be to define the Gaussian integer as a<br>\nring_scheme and use \"/HOL/Algebra/Ring_Divisibility.thy\". From that I<br>\nwould get the \"factorization_property\" from the same file, but that<br>\nformalization looks less intuitive and less practical for my purposes.</p>\n</blockquote>\n<p>Using HOL-Algebra is definititely also possible. You have to jump<br>\nthrough a few more hoops. You would have to interpret the<br>\neuclidean_domain locale for your Gaussian integer type and an<br>\nappropriate Euclidean measure function, and then you get the theorem<br>\n\"factorization_property\", which you can polish a bit to get it into a<br>\nmore readable form.</p>\n<blockquote>\n<p>That is why I'm writing here. Is the class hierarchy not suitable for<br>\nformalizing what I need to achieve?</p>\n</blockquote>\n<p>You want to use the typeclass-based stuff whenever you can. However, the<br>\ntypeclass-based approach to algebra in Isabelle<br>\n(\"HOL-Computational_Algebra\") is very much geared towards pragmaticism:<br>\nIt was designed to work well for the use concrete cases that we had<br>\n(naturals, integers, polynomials, formal power series), and it does that<br>\nfairly well. But for Gaussian integers, it does not work in the current<br>\nform, and for others (p-adic numbers) will probably never work without a<br>\nconsiderable amount of effort.</p>\n<p>My suggestion would be to prove unique factorisation using HOL-Algebra<br>\nfor now, and if I get around to removing multiplicativity from that type<br>\nclass at some point (hopefully before the next release), you should be<br>\nable to switch over to that without much effort.</p>\n<p>Feel free to ask if you need help with any more concrete questions about<br>\nhow to use HOL-Algebra.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294821383,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661242314
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nGood news, as of isabelle-dev/e0237f2eb49d, normalization_semidom does<br>\nnot require \"unit_factor\" (or alternatively \"normalize\") to be<br>\nmultiplicative anymore. The property was replaced with</p>\n<p>\"is_unit u ==&gt; unit_factor (u * a) = u * unit_factor a\"</p>\n<p>This is a much weaker property that is equivalent to the following: Two<br>\nelements that are associated will normalize to the same canonical<br>\nrepresentative, i.e.</p>\n<p>\"a dvd b ==&gt; b dvd a ==&gt; normalize a = normalize b\"</p>\n<p>With this, it is now possible to prove that the Gaussian integers are a<br>\nEuclidean ring.</p>\n<p>There are also a few other related classes that slap on the<br>\nmultiplicativity assumption to restore the previous behaviour (the most<br>\nimportant examples of normalization_semidoms all fulfil it!). Some<br>\nthings (most notably polynomial GCD and related concepts) still require<br>\nmultiplicative normalization. It would probably be possible to remove<br>\nthat in the future as well, but let's take this one step at a time.</p>\n<p>While I was at it, I also introduced a class \"field_gcd\" that subsumes a<br>\nnumber of previous classes that all essentially meant \"a field that also<br>\nhas the trivial GCD defined on it\".</p>\n<p>NEWS entry will follow.</p>\n<p><a href=\"https://isabelle.in.tum.de/repos/isabelle/rev/e0237f2eb49d\">https://isabelle.in.tum.de/repos/isabelle/rev/e0237f2eb49d</a></p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294821592,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661242400
    },
    {
        "content": "<p>From: Christian Weinz &lt;<a href=\"mailto:christian.weinz@stud.uni-goettingen.de\">christian.weinz@stud.uni-goettingen.de</a>&gt;<br>\nThanks for this work Manel. Meanwhile I'm pretty sure I figured out a<br>\nway how to define a multiplicative unit_factor on the Gaussian<br>\nintegers; You first recursively divide by 1+i whenever the number is<br>\ndivisible by that, and then take the rest mod 2+2*i. The result is a<br>\nunit and that process is multiplicative. I have formalized and proved<br>\nmost of it in Isabelle already, I intend to finish that.</p>\n<p>I am aiming for a clean formalization suitable for upstreaming, so I<br>\ntried to use the existing typeclasses as much as possible, and slightly<br>\nmodifying existing ones, where needed. I ran very early into a problem<br>\nduring that, which I presented in another email to this list.</p>\n<p>What would be a good approach to encapsulate the the relation between<br>\nthe complex numbers and the Gaussian integers in Isabelle?<br>\nSpecifically, that the Gaussian integers are a subset and should be<br>\neasily coercable to complex, and that the conjugation \"cn\", the<br>\nfunctions \"Re\" and \"Im\" and the imaginary unit \"i\" should be usable<br>\nwhen working with either.</p>",
        "id": 294821756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661242473
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Thanks for this work Manel. Meanwhile I'm pretty sure I figured out a<br>\nway how to define a multiplicative unit_factor on the Gaussian<br>\nintegers; You first recursively divide by 1+i whenever the number is<br>\ndivisible by that, and then take the rest mod 2+2*i. The result is a<br>\nunit and that process is multiplicative. I have formalized and proved<br>\nmost of it in Isabelle already, I intend to finish that.<br>\nHm, okay. I have no intuition for what this means. Not sure if this is the best way to go; it seems to me that it makes more sense to have an intuitively clear concept of what a normalised Gaussian integer is (e.g. either 0 or real part &gt; 0, imaginary part ≥ 0).</p>\n</blockquote>\n<blockquote>\n<p>I am aiming for a clean formalization suitable for upstreaming, so I<br>\ntried to use the existing typeclasses as much as possible, and slightly<br>\nmodifying existing ones, where needed. I ran very early into a problem<br>\nduring that, which I presented in another email to this list.<br>\nI would advise against modifying type classes. Even small changes lead to a huge amount of merge work. Much of the Isabelle distribution and the AFP is affected by such changes, so I would only make them if absolutely necessary.</p>\n</blockquote>\n<blockquote>\n<p>What would be a good approach to encapsulate the the relation between<br>\nthe complex numbers and the Gaussian integers in Isabelle?<br>\nSpecifically, that the Gaussian integers are a subset and should be<br>\neasily coercable to complex, and that the conjugation \"cn\", the<br>\nfunctions \"Re\" and \"Im\" and the imaginary unit \"i\" should be usable<br>\nwhen working with either.<br>\nSimilarly to nat and real, I would say: Just define an injective homomorphism \"complex_of_gauss_int :: gauss_int ⇒ complex\" (or something like that). Using \"Re\", \"Im\", and \"i\" with both complex numbers and Gaussian integers is not that easy. There are a few possible options:</p>\n</blockquote>\n<p>– Pick a different name (e.g. \"ReZ\", \"ImZ\" for Gaussian integers; the \"Z\" standing for the integers)<br>\n  – Simply declare \"Re\" as additional notation. This will lead to syntax ambiguity warnings due to multiple parse trees.<br>\n  – Use ad-hoc overloading. That might, however, require some changes to the existing syntax, and I don't think Gaussian integers are important enough to justify going to such lengths.</p>\n<p>Personally, I would recommend going for the first option, and then /perhaps/ switching on some optional extra syntax for these things to make them nicer to look at.</p>\n<p>As I said to you privately, I do have a proof-of-concept implementation of Gaussian integers from years ago that does pretty much exactly that.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294821855,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661242522
    }
]