[
    {
        "content": "<p>From: Wang Zirui &lt;<a href=\"mailto:zirui@nus.edu.sg\">zirui@nus.edu.sg</a>&gt;<br>\nHi,</p>\n<p>I'd like to formalize the definition of Turing machine. If possible,<br>\nI'd like to do it without relying on ZFC. That is, I don't use sets,<br>\nintegers and so on.</p>\n<p>Yes, in the definition of Turing machine we see sets, such as the set<br>\nof states, but I think the use of set is convenient but not necessary.<br>\n(Am I wrong?) So if you agree with me and think it's possible to go<br>\nwithout sets, could you please outline how to define Turing machine?<br>\nIf you think this is impossible, can you give a proof?</p>\n<p>Thanks.</p>\n<p>Regards,<br>\nZirui Wang</p>",
        "id": 294084060,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831597
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nDeac Zirui,</p>\n<blockquote>\n<p>I'd like to formalize the definition of Turing machine. If possible,<br>\nI'd like to do it without relying on ZFC. That is, I don't use sets,<br>\nintegers and so on.</p>\n</blockquote>\n<p>There should be no problems with doing it in HOL. Note that HOL also has <br>\na notion of a set, although it is not quite the same as in ZFC.</p>\n<blockquote>\n<p>[...] So if you agree with me and think it's possible to go<br>\nwithout sets, could you please outline how to define Turing machine?</p>\n</blockquote>\n<p>You may want to look at Tobias Nipkow's formalization of finite <br>\nautomata, which you can find in the AFP:</p>\n<p><a href=\"http://afp.sourceforge.net/entries/Functional-Automata.shtml\">http://afp.sourceforge.net/entries/Functional-Automata.shtml</a></p>\n<p>It's not Turing Machines, but it may give you an idea...</p>\n<p>Alex</p>",
        "id": 294084086,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831603
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nDear Zirui,</p>\n<blockquote>\n<p>The point of not relying on ZFC is because it's a strong theory. I<br>\ndon't want the definition of Turing machine to be based on a strong<br>\ntheory. I want it to be based on a theory that is as weak as possible.<br>\nSo it's best if it's based on nothing.</p>\n</blockquote>\n<p>Well, HOL is what people are typically using, and if you are new to <br>\nIsabelle and are trying to use anything else, you are going to have a <br>\nhard time, because other logics are much less developed in terms of tool <br>\nsupport.</p>\n<blockquote>\n<p>Unfortunately HOL is at least as strong as ZFC because it has the idea<br>\nof a set.</p>\n</blockquote>\n<p>HOL's notion of a set is much weaker, as sets are just identified with <br>\npredicates over the respective type.</p>\n<blockquote>\n<p>My teacher Jain suggests that it might be possible to define<br>\nTuring machine based on Peano Arithmetic, which is weaker than ZFC.<br>\nAnd I'm going to try that.</p>\n</blockquote>\n<p>You can certainly try, and I think there should not be fundamental <br>\nproblems, but you will certainly suffer from the lack of tool support in <br>\nyour custom-made logic, as opposed to using something well-established.</p>\n<p>If these foundational issues of taking the weakest logic possible are <br>\nreally the core of your interest, then you can try and go for Peano <br>\nArithmetic, but if your main interest is formalizing Turing Machines <br>\nafter all, then using anything but HOL is like cutting your left leg off <br>\nbefore climbing a mountain.</p>\n<blockquote>\n<p>I don't understand the AFP formalization of automata as I read it.<br>\nDoes the author use the idea of sets, functions or numbers? If yes, he<br>\nprobably base the definition of automata on HOL or ZFC. But I want to<br>\nbase it on a weaker theory. Does the author do that?</p>\n</blockquote>\n<p>The formalization is based on HOL. If you have big trouble reading the <br>\nformalization, this is probably an indication that you should learn some <br>\nIsabelle basics first, e.g. by working through the Tutorial <br>\n(<a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/tutorial.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/tutorial.pdf</a>)</p>\n<p>Alex</p>",
        "id": 294084107,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831609
    },
    {
        "content": "<p>From: Wang Zirui &lt;<a href=\"mailto:zirui@nus.edu.sg\">zirui@nus.edu.sg</a>&gt;<br>\nHi Alex,</p>\n<p>The point of not relying on ZFC is because it's a strong theory. I<br>\ndon't want the definition of Turing machine to be based on a strong<br>\ntheory. I want it to be based on a theory that is as weak as possible.<br>\nSo it's best if it's based on nothing.</p>\n<p>Unfortunately HOL is at least as strong as ZFC because it has the idea<br>\nof a set. My teacher Jain suggests that it might be possible to define<br>\nTuring machine based on Peano Arithmetic, which is weaker than ZFC.<br>\nAnd I'm going to try that.</p>\n<p>I don't understand the AFP formalization of automata as I read it.<br>\nDoes the author use the idea of sets, functions or numbers? If yes, he<br>\nprobably base the definition of automata on HOL or ZFC. But I want to<br>\nbase it on a weaker theory. Does the author do that?</p>\n<p>Your suggestion of automata is certainly good as it has the same<br>\nproblem as Turing machines, but it's simpler.</p>\n<p>Regards,<br>\nZirui</p>",
        "id": 294084222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831647
    },
    {
        "content": "<p>From: Richard Waldinger &lt;<a href=\"mailto:waldinger@AI.SRI.COM\">waldinger@AI.SRI.COM</a>&gt;<br>\ndidn't turing's original paper do a formalization? in some sort of  <br>\nnumber theory, i forget which logic.</p>",
        "id": 294084247,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831654
    },
    {
        "content": "<p>From: Konrad Slind &lt;<a href=\"mailto:slind@cs.utah.edu\">slind@cs.utah.edu</a>&gt;<br>\nHi,</p>\n<p>Yes, you can define Turing machines in a very<br>\nsimple base theory. For example, you can use lists<br>\ninstead of sets because everything in a TM description<br>\nhas to be finite. So at least the preliminary theory<br>\nof TMs can be done without higher order things like<br>\nsets and functions. But going even a little bit into the<br>\ntheory, you will need to define computable functions etc.<br>\nOn the face of it, even the undecidability of the Halting<br>\nProblem seems to need sets to state (i.e. the <em>set</em> of all<br>\nhalting TMs is undecidable).</p>\n<p>I did some work on formalizing TMs in HOL-4 and the<br>\nfollowing definitions of the machines should be<br>\ncompletely straightforward to turn into Isabelle/HOL syntax.<br>\nOf course there is more to define, like machine configurations,<br>\nexecutions, languages, etc. but I will omit those.</p>\n<p>Also, doesn't the AFP include some computability theory<br>\nalready?</p>\n<p>Cheers,<br>\nKonrad.</p>\n<p>(*---------------------------------------------------------------------- <br>\n-----*)<br>\n(* Turing machines, tape infinite in one  <br>\ndirection.                          *)<br>\n(*---------------------------------------------------------------------- <br>\n-----*)</p>\n<p>Hol_datatype <code>dir = L | R</code>;</p>\n<p>(*---------------------------------------------------------------------- <br>\n-----*)<br>\n(* Raw datatype of TMs. The only slightly odd thing may be that the  <br>\nblank is *)<br>\n(* explicitly included. Also, it turns out to facilitate the  <br>\ndefinition of   *)<br>\n(* executions if the initial value of the current cell is set to a  <br>\nvalue.    *)<br>\n(* Because having a \"left-edge\" marker simplifies many TM algorithms,  <br>\nwe set *)<br>\n(* aside a particular \"star\" value for this  <br>\npurpose.                         *)<br>\n(*---------------------------------------------------------------------- <br>\n-----*)</p>\n<p>Hol_datatype<br>\n<code>TM = &lt;| states     : 'state -&gt; bool ;\n            inputsymbs : 'alpha -&gt; bool ;\n            tapesymbs  : 'alpha -&gt; bool ;\n            init       : 'state ;\n            trans      : 'state -&gt; 'alpha -&gt; 'state # 'alpha # dir;\n            accept     : 'state ;\n            reject     : 'state ;\n            blank      : 'alpha ;\n            star       : 'alpha |&gt;</code>;<br>\n(*---------------------------------------------------------------------- <br>\n-----*)<br>\n(* Predicate singling out the real Turing machines. Is in principle  <br>\nan       *)<br>\n(* executable thing, but we don't currently handle (bounded)  <br>\nquantifiers.    *)<br>\n(*---------------------------------------------------------------------- <br>\n-----*)</p>\n<p>val isTM_def =<br>\n  Define<br>\n<code>isTM (M : ('alpha,'state)TM) =\n       FINITE M.states            /\\\n       FINITE M.inputsymbs        /\\\n       FINITE M.tapesymbs         /\\\n       M.blank IN M.tapesymbs     /\\\n       ~(M.blank IN M.inputsymbs) /\\\n       M.star IN M.inputsymbs     /\\\n       M.inputsymbs SUBSET M.tapesymbs /\\\n       M.accept IN M.states       /\\\n       M.reject IN M.states       /\\\n       ~(M.accept = M.reject)     /\\\n       M.init IN M.states         /\\\n       !a p q b d.\n           a IN M.tapesymbs /\\ p IN M.states /\\ (M.trans p a = (q,b,d))\n           ==&gt; q IN M.states /\\ b IN M.tapesymbs</code>;</p>\n<p>Cheers,<br>\nKonrad.</p>",
        "id": 294084287,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831667
    },
    {
        "content": "<p>From: Konrad Slind &lt;<a href=\"mailto:konrad.slind@gmail.com\">konrad.slind@gmail.com</a>&gt;<br>\nHi Zirui,</p>\n<p>TMs can be represented by bitstrings (or numbers).<br>\nNo sets. A TM evaluator can be written that takes<br>\nin a bitstring, decodes it into a TM and an input,<br>\nand simulates the execution of the TM on the input.<br>\nThat evaluator can itself be written out as a bitstring<br>\nrepresenting a TM. Any decent undergrad theory<br>\ntextbook will go into this in some amount of detail.<br>\nSo there is a certain portion of computability theory<br>\nthat is basic programming and can be formalized in<br>\na simple logic that doesn't formalize set theory.</p>\n<p>On the other hand, much of computability is about<br>\ninfinite sets (not lists), some of which can be<br>\nimplemented by TMs and some which can't. Again,<br>\nany undergrad theory text (or wikipedia) has<br>\nplenty of detail.</p>\n<p>Cheers,<br>\nKonrad.</p>",
        "id": 294084322,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831681
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou need to be much more specific about your research objectives and  <br>\nabout what you mean by set theory. Zermelo set theory is rather weak  <br>\n(more or less equivalent to higher-order logic). ZF set theory is  <br>\nconsiderably stronger, but there are set theories much stronger than  <br>\nZF. Then there is a question of the axiom of choice. Just to say \"I  <br>\nwant to have nothing to do with the axioms of set theory\" is not a  <br>\nbasis for a scientific discussion. People do choose to work in weak  <br>\nformal systems, typically in order to investigate the power of those  <br>\nsystems.</p>\n<p>Lawrence C Paulson<br>\nProfessor of Computational Logic<br>\nComputer Laboratory, University of Cambridge<br>\n15 JJ Thomson Avenue, Cambridge CB3 0FD, England<br>\nTel: +44(0)1223 334623    Fax: +44(0)1223 334678</p>",
        "id": 294090595,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831686
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nTuring machines are finite objects.  They can be encoded as numbers (via<br>\nsome Gödel numbering, cf.<br>\n<a href=\"http://en.wikipedia.org/wiki/G%C3%B6del_number\">http://en.wikipedia.org/wiki/G%C3%B6del_number</a>).</p>\n<p>So depending on what you want to prove exactly, and provided that you<br>\ndon't want to speak about (infinite) sets of Turing machines, you may<br>\nindeed be able to avoid set theory entirely, and merely work in (some<br>\nfragment of) a theory of arithmetic (cf.<br>\n<a href=\"http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/\">http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/</a>,<br>\n<a href=\"http://en.wikipedia.org/wiki/Robinson_arithmetic\">http://en.wikipedia.org/wiki/Robinson_arithmetic</a>,<br>\n<a href=\"http://en.wikipedia.org/wiki/Peano_arithmetic\">http://en.wikipedia.org/wiki/Peano_arithmetic</a>).  Since your teacher<br>\nsuggested this in the first place, why not ask him to explain the<br>\ndetails?</p>\n<p>Note that finite lists (of numbers) can be encoded as numbers (again,<br>\nvia some Gödel numbering), so they are not \"as high level as sets\".</p>\n<p>Also note that Alex was perfectly right when he wrote:<br>\n| If these foundational issues of taking the weakest logic possible are <br>\n| really the core of your interest, then you can try and go for Peano <br>\n| Arithmetic, but if your main interest is formalizing Turing Machines <br>\n| after all, then using anything but HOL is like cutting your left leg<br>\n| off before climbing a mountain.</p>\n<p>If you really want to restrict yourself to Peano arithmetic, I suspect<br>\nthat a formalization on paper (not using Isabelle) would already be<br>\nenough of a challenge for a small student project.</p>\n<p>Regards,<br>\nTjark</p>",
        "id": 294090609,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831693
    },
    {
        "content": "<p>From: Wang Zirui &lt;<a href=\"mailto:zirui@nus.edu.sg\">zirui@nus.edu.sg</a>&gt;<br>\nLawrence wrote:<br>\nYou need to be much more specific about your research objectives and<br>\nabout what you mean by set theory. Zermelo set theory is rather weak<br>\n(more or less equivalent to higher-order logic). ZF set theory is<br>\nconsiderably stronger, but there are set theories much stronger than<br>\nZF. Then there is a question of the axiom of choice. Just to say \"I<br>\nwant to have nothing to do with the axioms of set theory\" is not a<br>\nbasis for a scientific discussion. People do choose to work in weak<br>\nformal systems, typically in order to investigate the power of those<br>\nsystems.</p>\n<p>Based on ZFC you can define and derive much of mathematics, so I<br>\nimagine that it's easy to define Turing machine from ZFC. The problem<br>\nwith this is that it's harder to do proofs in a strong theory.<br>\nTherefore I want to define Turing machine in a weaker theory (with<br>\nfewer axioms). Basically it would good to have the theory as weak as<br>\npossible (because it facilitates proofs). But when the theory gets<br>\nweaker, it also becomes less expressive. So I want the theory to be<br>\njust strong enough to define Turing machines. I think that would be<br>\nthe ideal theory, because it can express the definition of Turing<br>\nmachine and it is weak enough to do certain proofs.</p>\n<p>Zirui Wang</p>",
        "id": 294090647,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831701
    },
    {
        "content": "<p>From: Wang Zirui &lt;<a href=\"mailto:zirui@nus.edu.sg\">zirui@nus.edu.sg</a>&gt;</p>\n<blockquote>\n<p><a href=\"http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/\">http://www.math.ucsd.edu/~sbuss/ResearchWeb/handbookII/</a>,</p>\n</blockquote>\n<p>I read a bit about proof theory. So if I want to prove from premises<br>\nP_1, ..., P_k one can derive conclusion C and I used the induction<br>\nprinciple (IND) in the proof, I'm actually showing that P_1, ..., P_k,<br>\nIND entail C instead of just P_1, ..., P_k entail C. And usually for a<br>\nproblem whether Q_1, ..., Q_j entail D, we are actually showing Q_1,<br>\n..., Q_j, ZFC entail D.</p>",
        "id": 294090663,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831706
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou are quite right to be concerned about difficulty of proofs, but  <br>\nthere are many factors involved in this difficulty, and some weak  <br>\ntheories are much more difficult to use than stronger theories. If you  <br>\nwant to accomplish your project with the minimum of effort, you should  <br>\nundoubtedly choose Isabelle/HOL. Not only is the logic easy-to-use;  <br>\nthe implementation provides lots of automation.</p>\n<p>Larry Paulson</p>",
        "id": 294090695,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831715
    },
    {
        "content": "<p>From: Wang Zirui &lt;<a href=\"mailto:zirui@nus.edu.sg\">zirui@nus.edu.sg</a>&gt;<br>\nOK, maybe it's a bad choice to start with formalizing Turing machine,<br>\nwhich is a definition not a theorem. How about formalizing Cook's<br>\ntheorem, the Probabilistically Checkable Proof (PCP) theorem and the<br>\nnatural proof theorem? Yes, I'm very interested in formalizing<br>\ntheorems in computational complexity theory. Has anyone done this?</p>\n<p>Zirui Wang</p>",
        "id": 294090719,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831725
    },
    {
        "content": "<p>From: Jens Doll &lt;<a href=\"mailto:jd@cococo.de\">jd@cococo.de</a>&gt;<br>\nChurchs' thesis says, that all computability can be expressed  by Turing <br>\nmachines. So you probably cannot bypass sets when defining a such a <br>\nformalism. Mathematically spoken do groups, rings, (closed)  fields rely <br>\non sets in their definition. Also alphabets are sets. What do you have <br>\non mind?<br>\nJens<br>\n<a href=\"/user_uploads/14278/EKMXaEPr4k9xDtmcP9dni5VY/jd.vcf\">jd.vcf</a></p>",
        "id": 294090760,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831737
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nThere is no need to talk about the \"set of all halting TMs\" to state<br>\nundecidability of the halting problem.  Simply put, undecidability of<br>\nthe halting problem asserts that there is no Turing machine that decides<br>\nwhether an arbitrary Turing machine halts.  Stating this requires<br>\nquantification over all Turing machines, but no set comprehension.  (Of<br>\ncourse, you chose a deliberately careful wording in the first place, so<br>\nI guess this was obvious to you.)</p>\n<p>Maybe someone else can point out the precise theory required to prove<br>\nundecidability of the halting problem?</p>\n<p>Regards,<br>\nTjark</p>",
        "id": 294091125,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831876
    },
    {
        "content": "<p>From: Wang Zirui &lt;<a href=\"mailto:zirui@nus.edu.sg\">zirui@nus.edu.sg</a>&gt;<br>\nBut think about lambda calculus. It is computationally as powerful as<br>\nTuring machine. Following your line of reasoning, it should also rely<br>\non set in its definition. But I think it's simple enough to avoid the<br>\nuse of set.</p>\n<p>Zirui</p>",
        "id": 294091885,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832142
    },
    {
        "content": "<p>From: Wang Zirui &lt;<a href=\"mailto:zirui@nus.edu.sg\">zirui@nus.edu.sg</a>&gt;<br>\nI'm sorry, but I'd like to repeat again that I'm not talking about<br>\nprogramming tricks. So lists are as high level as sets, because you<br>\ncan implement sets by lists. Actually I don't mean sets in particular<br>\nbut rather <em>set theory</em>. I want to avoid the use of sets because I<br>\nwant to have nothing to do with the axioms of set theory. So lists<br>\nprobably also rely on the axioms of set theory, unless you can define<br>\nit without the axioms of set theory. So let repeat my question: Can we<br>\ndefine Turing machine without relying on the axioms of set theory? I<br>\nthink part of the misconception is because I'm posting this topic<br>\nunder Isabelle. Actually my question has nothing to do with Isabelle<br>\nor HOL; I just imagined that people here might be good at formalizing<br>\nconcepts and proofs using rudimentary logic theory. Sorry for the<br>\nmisunderstanding.</p>\n<p>Zirui</p>",
        "id": 294091905,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832148
    }
]