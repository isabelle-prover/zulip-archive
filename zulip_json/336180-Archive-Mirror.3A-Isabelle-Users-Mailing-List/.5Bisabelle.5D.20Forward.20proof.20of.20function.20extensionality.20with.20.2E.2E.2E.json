[
    {
        "content": "<p>From: Martin Desharnais &lt;<a href=\"mailto:martin.desharnais@gmail.com\">martin.desharnais@gmail.com</a>&gt;<br>\nDear Isabelle users,</p>\n<p>I am in a situation where I want to use function extensionality for<br>\nmultiple simplification equalities in a forward proof. Following is a<br>\nsimplification of my current theory.</p>\n<p>I have a function \"foo\" that has multiple (long) pattern matching cases.<br>\nSome of the cases have unique definitions (such as the \"foo True\" case)<br>\nbut many cases simply forward some of the parameters to a generic<br>\nfunction \"f\" with some more fixed arguments.</p>\n<p>Thus many simplification lemmas have the form \"foo False xs = f 0 False<br>\nxs\". I want some simpler lemmas with no schematic variables like \"xs\"<br>\nfor those cases. I want to use these simpler lemmas in proofs but, more<br>\nimportantly, in a PDF presentation of the theory.</p>\n<p>I can write a backward proof for each of them (cf. foo_False_backward),<br>\nbut I then need to restate all those cases. I want to avoid such<br>\nrepetition. My question is thus: how can I state these lemmas using a<br>\nforward proof?</p>\n<p>context fixes f :: \"nat =&gt; bool =&gt; 'a list =&gt; 'a list\" begin</p>\n<p>fun foo :: \"bool =&gt; 'a list =&gt; 'a list\" where<br>\n  \"foo True (x # xs) = xs\" |<br>\n  \"foo False xs = f 0 False xs\" |<br>\n  \"foo _ _ = []\"</p>\n<p>lemma foo_False_backward: \"foo False = f 0 False\"<br>\n  by auto</p>\n<p>(* how to do this ? *)<br>\nlemmas foo_False_forward = foo.simps(2) (* something with @{thm ext}? *)</p>\n<p>end</p>\n<p>This question seems to be an instance of a more general question on<br>\nschematic variables. I found an e-mail from October 2015 from Lars<br>\nNoschinski [1] where he stated the following.</p>\n<blockquote>\n<p>Isabelle normalizes all rules by (a) moving universal<br>\nquantifiers as far outside as possible and (b) replacing outermost<br>\nuniversal quantifiers by schematic variables.</p>\n</blockquote>\n<p>If I could invert operation (b), I could use the theorem HOL.ext and<br>\nachieve my goal. Anecdotally, I have encounter other cases where I would<br>\nneed to replace schematic variables by universal quantifiers. My second<br>\nquestion is thus: how can one replace schematic variable by universal<br>\nquantifiers?</p>\n<p>Regards,<br>\nMartin Desharnais</p>\n<p>[1]:<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2015-October/msg00024.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2015-October/msg00024.html</a><br>\n<a href=\"/user_uploads/14278/Hw1K85B1pprvnhXLuK4fhFxM/signature.asc\">signature.asc</a></p>",
        "id": 294826023,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661244480
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi</p>\n<p>One (slightly imperfect, see below) solution is:</p>\n<blockquote>\n<p>(* how to do this ? *)<br>\nlemmas foo_False_forward = foo.simps(2)[abs_def] </p>\n</blockquote>\n<p>The abs_def attribute is originally made to reduce all schematic<br>\nextensions of a theorem of the form \"c ?x1 ... ?xN = ...\".<br>\nIt will convert them to lambdas. I.e., my above solution actually<br>\nproduces</p>\n<p><a href=\"http://local.foo\">local.foo</a> False ≡ λxs. f 0 False xs</p>\n<p>which Isabelle displays eta-contracted, unless you tell it to not do<br>\nso:</p>\n<p>declare [[eta_contract = false]]</p>\n<p>Moreover, abs_def does not work with conditional equations:</p>\n<p>definition \"x&gt;0 ⟹ bar x y ≡ x+y\"  <br>\nthm bar_def[abs_def] (<strong> fail </strong>)</p>\n<p>although the y could safely be removed.</p>",
        "id": 294826070,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661244485
    }
]