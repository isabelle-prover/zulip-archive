[
    {
        "content": "<p>From: Edward Pierzchalski &lt;<a href=\"mailto:e.a.pierzchalski@gmail.com\">e.a.pierzchalski@gmail.com</a>&gt;<br>\nHi, I'm running into issues delegating the \"boring\"/homomorphic parts of<br>\nrecursion over a datatype. Consider the following:</p>\n<p>datatype t = N nat | A t | B t t</p>\n<p>fun boring :: \"(t =&gt; t) =&gt; t =&gt; t\" where<br>\n  \"boring f (N n) = N n\"<br>\n| \"boring f (A t) = A (f (boring f t))\"<br>\n| \"boring f (B t1 t2) = B (f (boring f t1)) (f (boring f t2))\"</p>\n<p>function (sequential) interesting :: \"nat =&gt; t =&gt; t\" where<br>\n  \"interesting k (N n) = N (n + k)\"<br>\n| \"interesting k (A t) = A (interesting (k + 1) t)\"<br>\n| \"interesting k t = boring (interesting k) t\"<br>\nby pat_completeness auto</p>\n<p>I hope you can convince yourself that <code>interesting</code> should terminate by<br>\nsize of the second recursive call argument. Unfortunately, since the<br>\nrecursive call is hidden by <code>boring</code>, the standard <code>relation \"measure ...\"</code><br>\ntechnique doesn't work (you end up with a goal like <code>!!k x l r. ((k, x),\n(k, B l r)) \\in measure ...</code> for arbitrary x, which doesn't look provable).</p>\n<p>Does anyone know how to proceed?</p>\n<p>Regards,<br>\n--Ed</p>",
        "id": 294683229,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177417
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nUnfortunately, it's not that easy.</p>\n<p>You pass the \"interesting\" function to the \"boring\" function as a<br>\nparameter, and the \"boring\" function applies that function that it is<br>\ngiven to things. In order for this to work, you need to essentially show<br>\nthat the \"interesting\" function that you are defining is only called on<br>\nvalues for which it terminates (i.e. that are smaller than the original<br>\nargument that it got)</p>\n<p>Normally, this is done with a fundef_cong rule, but in this case, I<br>\ndon't see how that is possible, because the values that \"interesting\" is<br>\ncalled on by \"boring\" are \"boring f t1\" and \"boring f t2\" – that means<br>\nthat you are relying on the fact that the \"interesting\" function does<br>\nnot increase the size of its argument.</p>\n<p>Showing that \"interesting\" is size-preserving is actually straightforward:</p>\n<p>lemma same_size_boring:<br>\n  assumes \"⋀y. size (f y) = size y\"<br>\n  shows   \"size (boring f x) = size x\"<br>\n  using assms by (induction x) simp_all</p>\n<p>lemma size_interesting_aux:<br>\n  assumes \"interesting_dom (k, t)\"<br>\n  shows   \"size (interesting k t) = size t\"<br>\n  using assms<br>\n  by (induction rule: interesting.pinduct) (simp_all add:<br>\ninteresting.psimps same_size_boring)</p>\n<p>However, I have no idea how you would then go on and prove termination.<br>\nTermination proofs depend on the call graph that is computed for the<br>\nrecursive definition, and if you don't have a fundef_cong rule for<br>\nboring, that call graph – as you discovered yourself – will be too<br>\ncoarse (i.e. you will not have the information that you need in your<br>\ntermination proof). However, as I see it, any cong rule for \"boring\"<br>\nwould have to be conditional, which is, as far as I am aware, not<br>\npossible for fundef_cong rules.</p>\n<p>What you are trying to do may therefore very well be outside of what the<br>\nfunction package can do. (although I'm not 100% sure about that – still,<br>\neven if it is possible, I would bet it will be ugly)</p>\n<p>My advice would be: try to define your functions in a simpler way.<br>\nProofs involving nested recursion tend to get very ugly very quickly,<br>\nbecause the termination of your function depends on the semantics of<br>\nyour function, and semantic properties are difficult to use without a<br>\nfull termination proof.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294683237,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177420
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Ed,</p>\n<p>as Manuel indicated, you'll likely have to define your function in<br>\nanother way.</p>\n<p>One way would be to use mutual recursion:</p>\n<p>function (sequential)<br>\n  interesting :: \"nat ⇒ t ⇒ t\" and<br>\n  boring :: \"nat ⇒ t ⇒ t\"<br>\nwhere<br>\n  \"interesting k (N n) = N (n + k)\"<br>\n| \"interesting k (A t) = A (interesting (k + 1) t)\"<br>\n| \"interesting k t = boring k t\"<br>\n| \"boring k (N n) = N n\"<br>\n| \"boring k (A t) = A (interesting k (boring k t))\"<br>\n| \"boring k (B t1 t2) = B (interesting k (boring k t1)) (interesting k<br>\n(boring k t2))\"<br>\nby (pat_completeness) auto</p>\n<p>where your \"boring\" is replaced by a variant that only takes \"k\" as<br>\nparameter. Then we can prove that both functions are size-preserving, as<br>\nalready suggested by Manuel.</p>\n<p>lemma [termination_simp]:<br>\n  shows \"interesting_boring_dom (Inl (k, t)) ⟹ size (interesting k t) =<br>\nsize t\"<br>\n    and \"interesting_boring_dom (Inr (k, t)) ⟹ size (boring k t) = size t\"<br>\nby (induct k t and k t rule: interesting_boring.pinduct)<br>\n   (simp_all add: interesting.psimps boring.psimps)</p>\n<p>Which incidentally suffices for termination:</p>\n<p>termination by (lexicographic_order)</p>\n<p>It remains to show that this actually corresponds to your original<br>\nfunction specification. Here, I use \"boring'\" for your \"boring\".</p>\n<p>fun boring' :: \"(t ⇒ t) ⇒ t ⇒ t\" where<br>\n  \"boring' f (N n) = N n\"<br>\n| \"boring' f (A t) = A (f (boring' f t))\"<br>\n| \"boring' f (B t1 t2) = B (f (boring' f t1)) (f (boring' f t2))\"</p>\n<p>Your definition of \"interesting\" (modulo \"case\" on the right vs.<br>\npattern-matching on the left) can be obtained by mutual induction:</p>\n<p>lemma<br>\n  shows \"interesting k s =<br>\n    (case s of<br>\n      N n ⇒ N (n + k)<br>\n    | A t ⇒ A (interesting (k + 1) t)<br>\n    | t ⇒ boring' (interesting k) t)\"<br>\n    and \"boring k s = boring' (interesting k) s\"<br>\nby (induct k s and k s rule: interesting_boring.induct) auto</p>\n<p>cheers</p>\n<p>chris</p>\n<p>PS: For those who care and know what I'm talking about: termination of<br>\nthe TRS corresponding to \"interesting\" and \"boring\" is trivial for<br>\nmodern termination tools. Maybe a reason to revive IsaFoR/TermFun? ;)</p>",
        "id": 294683248,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177425
    },
    {
        "content": "<p>From: <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a><br>\nWith some extra thought, you can make these definitions work by<br>\nexplicitly forcing \"boring\" to be size-preserving.</p>\n<p>datatype t = N nat | A t | B t t</p>\n<p>definition<br>\n    \"size_constrain f v = (if size (f v) = size v then f v else v)\"</p>\n<p>lemma size_size_constrain[simp]:<br>\n    \"size (size_constrain f v) = size v\"<br>\n    by (simp add: size_constrain_def)</p>\n<p>fun boring :: \"(t =&gt; t) =&gt; t =&gt; t\" where<br>\n    \"boring f (N n) = N n\"<br>\n| \"boring f (A t) = A (size_constrain f (boring f t))\"<br>\n| \"boring f (B t1 t2) = B (size_constrain f (boring f t1))<br>\n(size_constrain f (boring f t2))\"</p>\n<p>lemma boring_size[simp]:<br>\n    \"size (boring f t) = size t\"<br>\n    by (induct t, simp_all)</p>\n<p>lemma boring_fundef_cong[fundef_cong]:<br>\n    \"⟦ ⋀t'. size t' &lt; size t ⟹ f t' = f' t' ⟧<br>\n      ⟹ boring f t = boring f' t\"<br>\n    by (induct t, simp_all add: size_constrain_def)</p>\n<p>fun interesting :: \"nat =&gt; t =&gt; t\" where<br>\n    \"interesting k (N n) = N (n + k)\"<br>\n| \"interesting k (A t) = A (interesting (k + 1) t)\"<br>\n| \"interesting k t = boring (interesting k) t\"</p>\n<p>lemma interesting_size[simp]:<br>\n    \"size (interesting k t) = size t\"<br>\n    by (induct t arbitrary: k , simp_all)</p>\n<p>lemma interesting_size_constrain[simp]:<br>\n    \"size_constrain (interesting k) = interesting k\"<br>\n    by (simp add: size_constrain_def fun_eq_iff)</p>\n<p>That's a bit of a pain but it works with standard tools and gets you<br>\nroughly what you want.</p>\n<p>It might also be possible to relax the size constraint slightly to allow<br>\nsize reduction, for instance.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 294683260,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177432
    }
]