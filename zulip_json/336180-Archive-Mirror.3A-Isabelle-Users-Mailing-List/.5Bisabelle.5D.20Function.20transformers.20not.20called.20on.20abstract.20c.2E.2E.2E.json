[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear code generator experts,</p>\n<p>Pascal, a student of mine, and I are experimenting with the function transformer interface <br>\nof the preprocessor for code equations in Isabelle2016-1. After having read the code <br>\ngenerator tutorial, we expected that a function transformer F registered with</p>\n<p>Code.add_functrans (\"name\", F)</p>\n<p>would be called with the set of code equations for every HOL function for which code must <br>\nbe generated. However, we noticed that for constants that have an abstract code equation, <br>\nthe function transformer is called with an empty list instead of the code equations.</p>\n<p>setup ‹<br>\n     Code_Preproc.add_functrans (\"print\", (fn _ =&gt; fn thms =&gt;<br>\n      (Output.writeln (@{make_string} thms); NONE)));<br>\n   ›<br>\n   typedef n = \"{x :: nat. x &gt; 0}\" by auto<br>\n   setup_lifting type_definition_n<br>\n   lift_definition suc :: \"n ⇒ n\" is Suc by simp<br>\n   code_thms suc</p>\n<p>Are we doing something wrong? Is there a way to have the function transformers called also <br>\nfor constants with abstract code equations? Or is there a good reason why this is not done?</p>\n<p>Thanks,<br>\nAndreas</p>",
        "id": 294711911,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182461
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<p>function transformers are indeed only applied to regular function<br>\nequations, and admittedly the documentation is not explicit about that.</p>\n<p>The rationale behind this is historic and pragmatic: the typical<br>\napplication of function transformers is to rewrite whole sets of<br>\nequations, particularly patterns on the LHS.  For abstract equations,<br>\nthere is only one equation and no pattern at all.</p>\n<p>What application do you have in mind?  Maybe there is a different<br>\napproach that would work for you.</p>\n<p>Personally I would prefer anyway that the whole matter of preprocessing<br>\nwould take place in situ when function equations are declared, but this<br>\nis not possible since function equations can only be treated grouped by<br>\nheading constants, and that is architecturally not compatible with Isar<br>\ndeclarations.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/qDSQN0fpeZ8j5xZHaFn1ltcS/signature.asc\">signature.asc</a></p>",
        "id": 294711936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182474
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Florian,</p>\n<p>Thanks again for the quick reply. Changing the pattern-matching structure is also our <br>\napplication. But we also have to transform the right-hand sides of code equations. We <br>\nmight be able to get things done with [code_unfold] declarations, but we are not yet <br>\nabsolutely sure. Ultimately, our goal is to implement a preprocessor for codatatypes such <br>\nthat they are implemented lazily in the generated ML code. This means that we have to <br>\nreplace case-expressions and constructors in the right-hand sides with their lazy <br>\nversions. Unfortunately, this may not always enough, e.g., in case the constructor or case <br>\nexpression is not applied to sufficiently many arguments. So it might be the case that we <br>\nwant to apply some selective eta expansion in some places.</p>\n<p>But we'll try with [code_unfold] first.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294712054,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182511
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>But we'll try with [code_unfold] first.</p>\n</blockquote>\n<p>the preprocessor allows to fully apply the expressive power of the<br>\nsimplifier; hence sophisticated rewrite procedures can be implemented as<br>\nsimprocs also.</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<p>Best,<br>\nAndreas</p>\n<p>On 02/06/17 20:28, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Hi Andreas,</p>\n<blockquote>\n<p>After having read the code generator tutorial, we<br>\nexpected that a function transformer F registered with</p>\n<p>Code.add_functrans (\"name\", F)</p>\n<p>would be called with the set of code equations for every HOL function<br>\nfor which code must be generated. However, we noticed that for constants<br>\nthat have an abstract code equation, the function transformer is called<br>\nwith an empty list instead of the code equations.</p>\n<p>setup ‹<br>\n     Code_Preproc.add_functrans (\"print\", (fn _ =&gt; fn thms =&gt;<br>\n      (Output.writeln (@{make_string} thms); NONE)));<br>\n   ›<br>\n   typedef n = \"{x :: nat. x &gt; 0}\" by auto<br>\n   setup_lifting type_definition_n<br>\n   lift_definition suc :: \"n ⇒ n\" is Suc by simp<br>\n   code_thms suc</p>\n<p>Are we doing something wrong? Is there a way to have the function<br>\ntransformers called also for constants with abstract code equations? Or<br>\nis there a good reason why this is not done?</p>\n</blockquote>\n<p>function transformers are indeed only applied to regular function<br>\nequations, and admittedly the documentation is not explicit about that.</p>\n<p>The rationale behind this is historic and pragmatic: the typical<br>\napplication of function transformers is to rewrite whole sets of<br>\nequations, particularly patterns on the LHS.  For abstract equations,<br>\nthere is only one equation and no pattern at all.</p>\n<p>What application do you have in mind?  Maybe there is a different<br>\napproach that would work for you.</p>\n<p>Personally I would prefer anyway that the whole matter of preprocessing<br>\nwould take place in situ when function equations are declared, but this<br>\nis not possible since function equations can only be treated grouped by<br>\nheading constants, and that is architecturally not compatible with Isar<br>\ndeclarations.</p>\n<p>Hope this helps,<br>\n    Florian</p>\n<p><a href=\"/user_uploads/14278/eHW9F-z28dazWnBJj9DMduxN/signature.asc\">signature.asc</a></p>\n</blockquote>\n</blockquote>",
        "id": 294712071,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182519
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>That's an excellent idea. That should work in case we need eta expansion.</p>\n<p>Thanks,<br>\nAndreas</p>",
        "id": 294712082,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182523
    }
]