[
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nHi,</p>\n<p>The function command supports non-constructor patterns. Is it possible<br>\nto use patterns that are ambiguous, i.e., that could match in several<br>\nways?</p>\n<p>Consider the following (simplified) example:</p>\n<p>function f :: \"nat ⇒ nat\" where<br>\n  \"f 0 = 0\"<br>\n| \"f 1 = 0\"<br>\n| \"a &gt; 0 ⟹ b &gt; 0 ⟹ f (a + b) = f a + f b\"<br>\n   apply (metis less_imp_add_positive less_one linorder_neqE_nat)<br>\n  apply simp+<br>\noops</p>\n<p>This should define a function f that is 0 everywhere. However, the last<br>\nproof obligation that is generated contains f_sumC, and I am not sure<br>\nhow to prove it.</p>\n<p>Best,<br>\nTjark</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 294824294,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243670
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I don't know if there is a better way, but when I stumbled upon the <br>\n_sumC problem, the best I found was the following approach:</p>\n<p>Make the function manually unambiguous:</p>\n<p>function f :: \"nat ⇒ nat\" where<br>\n   f0: \"f 0 = 0\"<br>\n| f1: \"f 1 = 0\"<br>\n| fplus_raw: \"<em>a+b \\neq 0</em>  ==&gt; a &gt; 0 ⟹ b &gt; 0 ⟹ f (a + b) = f a + f b\"</p>\n<p>This defines the same function as yours, but of course it is <br>\ninconvenient because it has the added premise in the fplus_raw rule <br>\n(which is used for simplification).</p>\n<p>Then I would prove</p>\n<p>lemma fplus[simp]: \"a &gt; 0 ⟹ b &gt; 0 ⟹ f (a + b) = f a + f b\"</p>\n<p>This should work because now you can do induction and everything you need.</p>\n<p>And finally I would remove fplus_raw from the simplifier via:</p>\n<p>declare fplus_raw[simp del]</p>\n<p>This should more or less approximate the situation as if you had defined <br>\nthe function without the extra premise in the first place, I think.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294824319,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243682
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Tjark and Dominique,</p>\n<p>I don't think the function package can handle such cases out-of-the-box. Dominique, your solution does not remove the inherent ambiguity from the sum case, which is reflected in the goal:</p>\n<p>/\\ a b aa ba. 0 &lt; a ==&gt; 0 &lt; b ==&gt; 0 &lt; aa ==&gt; 0 &lt; ba ==&gt; a + b = aa + ba ==&gt;<br>\nf_sumC a + f_sumC b = f_sumC aa + f_sumC ba</p>\n<p>The most \"automatic\" solution I can see for such situations is to identify a reusable iteration pattern:</p>\n<p>fun iter_nat_monoid_add :: \"'a::monoid_add ⇒ nat ⇒ 'a\" where<br>\n \"iter_nat_monoid_add a 0 = 0\"<br>\n|\"iter_nat_monoid_add a (Suc 0) = a\"<br>\n|\"iter_nat_monoid_add a (Suc (Suc n)) = iter_nat_monoid_add a (Suc n) + a\"</p>\n<p>lemma iter_nat_monoid_add_add:<br>\n\"iter_nat_monoid_add a (m+n) = iter_nat_monoid_add a m + iter_nat_monoid_add a n\"<br>\nproof (induct n arbitrary: m)<br>\n  case (Suc n m)<br>\n  then show ?case<br>\n    apply(cases m, simp_all)<br>\n    by (metis Suc_funpow add.assoc add_Suc funpow_0 iter_nat_monoid_add.simps(2)<br>\n         iter_nat_monoid_add.simps(3))<br>\nqed simp</p>\n<p>definition f :: \"nat ⇒ nat\" where<br>\n\"f = iter_nat_monoid_add 0\"</p>\n<p>lemma f_simps: \"f 0 = 0\" \"f 1 = 0\" \"f (a + b) = f a + f b\"<br>\nusing iter_nat_monoid_add_add unfolding f_def by auto</p>\n<p>Best wishes,<br>\nAndrei</p>",
        "id": 294824333,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243696
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>you were right, my solution didn't work as stated, I thought the <br>\nambiguity was between different cases (in which case my solution can be <br>\nused), and not within a single case. For the latter, my trick can be <br>\nmodified: We need to make sure that the premise of that case fires only <br>\nfor one single pair a,b for each sum a+b. This can be achieved by adding <br>\nthe premise \"(a,b) = (SOME (a',b'). a' &gt; 0 ∧ b' &gt; 0 ∧ a'+b' = a+b)\" <br>\n(this basically says: assume that a,b equals some arbitrarily chosen <br>\nfixed a,b from all possible a,b that have the same sum\".</p>\n<p>Then the case distinctness can be proven relatively easily. However, <br>\nproving \"f (a+b) = f a + f b\" takes a bit of work. I worked this out in <br>\nthe attached theory file.</p>\n<p>Andrei's solution is certainly simpler in this case. But in case <br>\nAndrei's solution does not work for some other cases, I am adding mine <br>\nas well. (In the present case, an even simpler approach works: <br>\ndefinition \"f x = 0\" lemma f_simps: \"f 0 = 0\" \"f 1 = 0\" \"f (a + b) = f a </p>\n<ul>\n<li>f b\" using f_def by auto)</li>\n</ul>\n<p>Best wishes,<br>\nDominique.<br>\n<a href=\"/user_uploads/14278/YoE41oLZY28YEoIg3yvfaDNu/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294824341,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661243701
    }
]