[
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nDear all,</p>\n<p>I would like to formalise some linear algebra structures, such as principal<br>\nideal rings, principal ideal domains, unique factorization domains and so<br>\non.</p>\n<p>As part of those structures, there exist some basic operations over rings<br>\nsuch as gcd and div, which are already implemented in the Isabelle library.<br>\nFor instance, there is a class gcd in the library which has been<br>\ninstantiated by int and nat:</p>\n<p>class gcd = zero + one + dvd +<br>\n  fixes gcd :: \"'a =&gt; 'a =&gt; 'a\"<br>\n    and lcm :: \"'a =&gt; 'a =&gt; 'a\"</p>\n<p>begin</p>\n<p>Nevertheless, this class seems to me somehow strange, because it doesn’t<br>\nfix any property about gcd and lcm, so it could be instantiated by almost<br>\nanything.</p>\n<p>Moreover, the notion of greatest common divisor can be properly defined in<br>\ncommutative rings, and also in principal ideal rings, although in general<br>\nthere need not exist just one for every pair of elements.</p>\n<p>My doubt is how to include that concept in the principal ideal ring class<br>\nthat I’m formalising.</p>\n<p>I think that there are (at least) three options:</p>\n<p>1.- “Forget” the gcd class that exists in the library and define gcd inside<br>\nmy class:</p>\n<p>class pir = comm_ring_1 + assumes all_ideal_is_principal: \"∀I. ideal I ⟶<br>\nprincipal_ideal I\"</p>\n<p>begin</p>\n<p>definition \"gcd_pir a b = .....\"</p>\n<p>end</p>\n<p>2.- Define a class called “pir_gcd”, extending gcd and assuming what gcd<br>\nmust satisfy.</p>\n<p>class pir_gcd = comm_ring_1 + gcd + assumes all_ideal_is_principal: \"∀I.<br>\nideal I ⟶ principal_ideal I\"  and \"∀a b. gcd a b = ...\" and \"∀a b. lcm a b<br>\n= ...\"</p>\n<p>3.- Option 1 + interpretations/sublocales.</p>\n<p>class pir = comm_ring_1 + assumes all_ideal_is_principal: \"∀I. ideal I ⟶<br>\nprincipal_ideal I\"</p>\n<p>begin</p>\n<p>definition \"gcd_pir a b = .....\"</p>\n<p>definition \"lcm_pir a b = .....\"</p>\n<p>interpretation gcd \"0::'a\" 1 \"times::'a=&gt;'a=&gt;'a\" \"gcd_pir\" \"lcm_pir\" .</p>\n<p>sublocale gcd \"0::'a\" 1 \"times::'a=&gt;'a=&gt;'a\" \"gcd_pir\" \"lcm_pir\" .</p>\n<p>end</p>\n<p>By the way, what is the difference between interpretation and sublocale in<br>\nthis context?</p>\n<p>Which is the recommended option? At first I though that it was the last<br>\none, but then I wondered why the second one has been used in the library<br>\n(there are two classes: semiring and semiring_div in the library instead of<br>\nonly one of them).</p>\n<p>Thanks,<br>\nJose</p>",
        "id": 294291681,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923664
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>syntactic type classes such as this are not unusual. They allow<br>\noverloading of constants (such as 0, +, *, gcd, …) without restricting<br>\nthe way in which these constants can be used. In case of gcd, I think<br>\none could make a good argument for assuming basic facts about GCDs in<br>\nthe type class.</p>\n<p>Anyway, if you want to generalise the GCD, I would recommend you<br>\ncompletely ignore the current GCD theory and the gcd type class, because<br>\nit already defines a gcd on e.g. the natural numbers and the integers,<br>\nand your more general formalisation will probably also yield some GCD<br>\nimplementation on the natural numbers and integers – resulting in a<br>\nclash of these two definitions.</p>\n<p>GCDs are only unique (modulo association) in integral domains, and only<br>\nguaranteed to exist in factorial rings (UIDs). Therefore, I would<br>\nrecommend that you introduce a predicate is_gcd a b :: 'a =&gt; 'a =&gt; 'a =&gt;<br>\nbool for commutative rings in order to handle the situation of multiple<br>\n(or no) GCDs. Then you can introduce a function gcd :: 'a =&gt; 'a =&gt; 'a<br>\nfor integral domains, yielding a normalised GCD if it exists and<br>\nundefined (or 0 or 1 or whatever) otherwise, and for factorial rings,<br>\nyou can then actually prove that this gcd function is “total”, i.e. it<br>\nalways returns a GCD.</p>\n<p>For normalisation, the approach that I took in my formalisation of<br>\nEuclidean rings was to define a function called normalisation_factor ::<br>\n'a =&gt; 'a, which returns a unit such that dividing any element of the<br>\nring by that unit yields the same result for all elements in the same<br>\nassociation class, effectively normalising the element. E.g. for<br>\nintegers, the normalisation factor is the sign of the number; for<br>\npolynomials, it is the leading coefficient.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294291711,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923674
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Jose,</p>\n<p>your are actually stumbling over the issue that HOL so far does not<br>\nreally provide a hierarchy of type classes for divisibility in rings<br>\n(say, factorial ring, euclidean ring etc.)</p>\n<p>Here my thoughts of what can be done with reasonable effort at the moment</p>\n<p>1) The syntactic gcd type class.</p>\n<p>Cf. also Manuel's mail.  Syntactic type classes can also be seen as an<br>\ninstance of the traditional »worse is better« philosophy of UNIX: if you<br>\ndo not know how to provide the right policy, restrict yourself to<br>\nprovide a mechanisms while leaving the user to provide its own policy on<br>\nhis own.</p>\n<p>2) A fundamental algebraic type class for GCD.</p>\n<p>IMHO this could look like:</p>\n<blockquote>\n<p>class semiring_gcd = semiring + gcd +<br>\n  assumes \"gcd a b dvd a\"<br>\n  assumes \"gcd a b dvd b\"<br>\n  assumes \"c dvd a ⟹ c dvd b ⟹ c dvd gcd a b\"</p>\n<p>class ring_gcd = ring + semiring_gcd</p>\n</blockquote>\n<p>Remarks:</p>\n<p>a) I strongly believe the assumptions capture the essence of gcd,<br>\nwhatever the underlying structure is.</p>\n<p>b) Whenever you develop type class hierarchies for ring structures, you<br>\nalways have a semiring (the additive structure is a monoid, not a group)<br>\nand a ring.  The semiring part of the hierarchy is to accommodate the<br>\nnatural numbers (which, in algebra, appear not be that natural after all).</p>\n<p>c) Here I have chosen »semiring«/»ring« as a base point.  Maybe gcd<br>\nitself suggests are more specific entry point to start with already, but<br>\nI have found no argument to do so (maybe you would do after some rounds<br>\nof experimenting and thinking).</p>\n<p>d) The specification implicitly states<br>\n  I. the a gcd exists<br>\n  II. that is is functional, i.e. normalising wrt. to units<br>\nBut it does not assume anything how this normalisation actually looks<br>\nlike, i.e. concrete instances are free to normalise in a specific way.</p>\n<p>3) Specific instances for GCD in more specific algebraic structures</p>\n<p>a) e.g. for euclidean rings</p>\n<p>class euclidean_(semi)ring = …<br>\nbegin</p>\n<p>…</p>\n<p>definition gcd_eucl where … -- ‹definition via euclidean algorithm›</p>\n<p>…</p>\n<p>end</p>\n<p>class euclidean_(semi)ring_gcd = euclidean_(semi)ring + gcd<br>\n  assumes \"gcd = gcd_eucl\"<br>\nbegin</p>\n<p>subclass (semi)ring_gcd<br>\n  …</p>\n<p>end</p>\n<p>Note that this work has already been done by Manuel, but is not yet part<br>\nof Isabelle2014.  If you want to build on that, we will find a suitable<br>\nway without need to participate in the ongoing Isabelle development.</p>\n<p>b) e.g. for factorial rings</p>\n<p>class factorial_(semi)ring = …<br>\nbegin</p>\n<p>…</p>\n<p>definition factorization :: \"'a =&gt; 'a mulitset\" where …</p>\n<p>…</p>\n<p>end</p>\n<p>class factorial_(semi)ring_gcd = factorial_(semi)ring + gcd<br>\n  assumes \"gcd a b = msetprod (factorization a + factorization b)\"<br>\nbegin</p>\n<p>subclass (semi)ring_gcd<br>\n  …</p>\n<p>end</p>\n<blockquote>\n<p>By the way, what is the difference between interpretation and sublocale in<br>\nthis context?</p>\n</blockquote>\n<p>»interpretation« pulls in facts into the current target context, which<br>\nis closed at the final »end« – »confined interpretation«.</p>\n<p>»sublocale« establishes a permanent connection.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/_iuDbl9Z_Bv4RPfe3TVrZIwl/signature.asc\">signature.asc</a></p>",
        "id": 294291775,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923695
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\n[…]</p>\n<p>Some further thoughts.</p>\n<blockquote>\n<p>2) A fundamental algebraic type class for GCD.</p>\n<p>IMHO this could look like:</p>\n<blockquote>\n<p>class semiring_gcd = semiring + gcd +<br>\n  assumes \"gcd a b dvd a\"<br>\n  assumes \"gcd a b dvd b\"<br>\n  assumes \"c dvd a ⟹ c dvd b ⟹ c dvd gcd a b\"</p>\n<p>class ring_gcd = ring + semiring_gcd</p>\n</blockquote>\n</blockquote>\n<p>Maybe any (semi)ring_gcd is also a factorial_(semi)ring?</p>\n<p>The direction &lt;-- is obvious.  For --&gt; I am uncertain.<br>\n<a href=\"http://en.wikipedia.org/wiki/Greatest_common_divisor\">http://en.wikipedia.org/wiki/Greatest_common_divisor</a> (section »The gcd<br>\nin commutative rings«) suggests that it does not hold in general.  It<br>\nalso suggests that the base structure should be (sem)idom (integral<br>\ndomain) rather than plain (semi)ring.</p>\n<blockquote>\n<p>GCDs are only unique (modulo association) in integral domains, and only<br>\nguaranteed to exist in factorial rings (UIDs). Therefore, I would<br>\nrecommend that you introduce a predicate is_gcd a b :: 'a =&gt; 'a =&gt; 'a =&gt;<br>\nbool for commutative rings in order to handle the situation of multiple<br>\n(or no) GCDs. Then you can introduce a function gcd :: 'a =&gt; 'a =&gt; 'a<br>\nfor integral domains, yielding a normalised GCD if it exists and<br>\nundefined (or 0 or 1 or whatever) otherwise, and for factorial rings,<br>\nyou can then actually prove that this gcd function is “total”, i.e. it<br>\nalways returns a GCD.</p>\n</blockquote>\n<p>I would not recommend to follow this approach from my current<br>\nperspective.  Generally, it is best practice that algebraic type classes<br>\nare not a device to speculate about (unique) existence of certain<br>\noperations etc, but simply have such operations as parameters and<br>\npostulate certain properties of them.  For everything more general, it<br>\nis usually more suitable to follow HOL-Algebra with its locale hierarchy<br>\nwith explicit carrier etc. which allows to develop real meta-theory.<br>\nThis fundamental best practice distinction is a regularly re-occurring<br>\nissue on this mailing list.</p>\n<blockquote>\n<p>For normalisation, the approach that I took in my formalisation of<br>\nEuclidean rings was to define a function called normalisation_factor ::<br>\n'a =&gt; 'a, which returns a unit such that dividing any element of the<br>\nring by that unit yields the same result for all elements in the same<br>\nassociation class, effectively normalising the element. E.g. for<br>\nintegers, the normalisation factor is the sign of the number; for<br>\npolynomials, it is the leading coefficient.</p>\n</blockquote>\n<p>The deeper reason why we have to burden ourselves with normalisation at<br>\nall is the matter of equality vs. equivalence.</p>\n<p>Ideally, gcd is only determined up to equivalence wrt. divisibility,<br>\ne.g. (n.b. for suggestiveness I am using infix syntax here):</p>\n<p>a gcd b ≈ b gcd a</p>\n<p>where (a ≈ b ⟷ a dvd b ∧ b dvd a)</p>\n<p>Automation support for equivalence reasoning in Isabelle however is<br>\npoor.  Hence we prefer proper equality</p>\n<p>a gcd b = b gcd a</p>\n<p>This requires a normalisation.  There are different ways to express this<br>\nidea, here I will use</p>\n<p>norm :: α ⇒ α<br>\n  norm_unit :: α ⇒ α</p>\n<p>such that a = norm a * norm_unit a<br>\nwith norm (norm_unit a) = 1<br>\nand norm_unit (norm a) = 1<br>\nand norm_unit a dvd 1<br>\n(maybe further properties are required also).</p>\n<p>So,</p>\n<p>a gcd b = (norm a * norm_unit a) gcd (norm b * norm_unit b) =<br>\n    u * (norm a gcd norm b)</p>\n<p>where (norm a gcd norm b) is the essential gcd on normalised values and<br>\nu is a unit factor.  How to choose u?  Manuel's suggestion is to choose<br>\nu = 1.  What I consider unsatisfying then is that</p>\n<p>a gcd a = norm a<br>\n  – but not necessarily a gcd a = a</p>\n<p>Hence we cannot establish that gcd forms a lattice.</p>\n<p>Can we choose a better u?  I am not sure.  But what I am thinking of is<br>\nto provide an explicit »micro lattice« (_ inf _) for the units in the<br>\nunderlying ring structure.  Hence,</p>\n<p>a gcd b = (norm a * norm_unit a) gcd (norm b * norm_unit b) =<br>\n    (norm_unit a inf norm_unit b) * (norm a gcd norm b)</p>\n<p>which would maintain the lattice property.</p>\n<p>How to choose (_ inf _) then?  Maybe there is no general principle, but<br>\nhere some examples:</p>\n<p>for nat:<br>\n    _ inf _ = 1 (trivially)<br>\n  for int:<br>\n    every unit is (-1) ^ n for n in {1, 2}<br>\n    (-1) ^ m inf (-1) ^ n = (-1) ^ (m max n) (prefer positive values)<br>\n  for ℤ + iℤ (gauss numbers):<br>\n    every unit is i ^ n for n in {1, 2, 3, 4}<br>\n    i ^ m inf i ^ n = i ^ (m max n) (prefer positive values)<br>\n  for K[x] (polynomials over a field):<br>\n    every unit is in K<br>\n    here we must assume a lattice on K<br>\n    uncertain how this would look like in the general case;<br>\n    for reals, we can use the canonical ordering;<br>\n    what about gauss numbers?  maybe polar coordinates?</p>\n<p>Looks a little bit artificial.  But maybe it is the »Isabelle overhead«<br>\nto get a practically usable system.</p>\n<p>Just a few thoughs,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/ScutlXfD4AdgRI-TVRf0uKfj/signature.asc\">signature.asc</a></p>",
        "id": 294291788,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923700
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\n[…]</p>\n<p>Even more thoughts.</p>\n<p>1) A characterisation of a factorial ring.</p>\n<p>May sth. like this:</p>\n<blockquote>\n<p>class factorial_(semi)ring = (sem)idom +<br>\n  fixes is_prime :: \"α ⇒ bool\"<br>\n  assumes \"(⋀a. a dvd p ⟹ a dvd 1 ∨ p dvd a) ⟹ is_prime p<br>\n  assumes \"is_prime p ⟹ a dvd p ⟹ a dvd 1 ∨ p dvd a\"<br>\n  assumes \"(⋀a b. p dvd a * b ⟹ p dvd a ∨ p dvd b) ⟹ is_prime p<br>\n  assumes \"is_prime p ⟹ p dvd a * b ⟹ p dvd a ∨ p dvd b\"</p>\n</blockquote>\n<p>2)</p>\n<blockquote>\n<p>Maybe any (semi)ring_gcd is also a factorial_(semi)ring?</p>\n<p>The direction &lt;-- is obvious.  For --&gt; I am uncertain.<br>\n<a href=\"http://en.wikipedia.org/wiki/Greatest_common_divisor\">http://en.wikipedia.org/wiki/Greatest_common_divisor</a> (section »The gcd<br>\nin commutative rings«) suggests that it does not hold in general.</p>\n</blockquote>\n<p>Maybe --&gt; holds since the given specification for (semi)ring_gcd demands<br>\nthat every two elements have a gcd.  From this it might follow that<br>\nunique factors can be carved out using iterative gcd computations (I<br>\nhave once seen such a proof for the natural numbers, but I don't know<br>\nwhether this generalizes).</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/oq3eUVX-A0co4VYbs7LH0LMV/signature.asc\">signature.asc</a></p>",
        "id": 294291803,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923705
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nOn 02/09/14 13:07, Jose Divasón wrote:</p>\n<blockquote>\n<p>By the way, in your formalization I have seen you fix the euclidean<br>\nsize in the euclidean_semiring class. However, a Euclidean domain will<br>\nadmit many different euclidean size functions (in<br>\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_domainit\">http://en.wikipedia.org/wiki/Euclidean_domainit</a> is suggested that a<br>\nparticular Euclidean function fis notpart of the structure of a<br>\nEuclidean domain).<br>\nI am aware of that, but I saw no reason why a single sufficiently nice<br>\n(i.e. fulfilling the “b ≠ 0 ⟹ f (a mod b) &lt; f a” and \"b ≠ 0 ⟹ f a ≤ f<br>\n(a*b)” conditions) should not suffice. I cannot think of a circumstance<br>\nin which you might require several different euclidean size functions.</p>\n</blockquote>\n<blockquote>\n<p>Would it be possible to define that class this way? Could there be any<br>\npotential drawbacks?</p>\n<p>class euclidean_semiring = … +</p>\n<p>assumes exists_euclidean_size: \"∃f::'a =&gt; nat. ∀a b. b≠0 ⟶ (∃q r. a =<br>\nb*q + r ∧ (r=0 ∨ f r &lt; f b))\"</p>\n<p>You can do that and then define euclidean_size with Hilbert choice and<br>\nget all the properties you need with exists_euclidean_size. I see no<br>\ndrawbacks, but, as stated before, I also don't see any real advantages<br>\nthat would justify it – apart from the fact that you can drop the<br>\nmonotonicity assumption, because if any euclidean size function exists,<br>\nthen a monotonic one exists. (which you'd have to prove, of course)</p>\n</blockquote>\n<blockquote>\n<p>But if one uses this way of defining the euclidean_semiring class,<br>\nthen it would not be possible to get direct executability (because the<br>\neuclidean_size would not be instantiated). Anyway, with your<br>\ndefinition it would be possible to work with different euclidean sizes<br>\nof the same structure if the instantiations are done in independent<br>\nfiles. I don’t know which option is more suitable.</p>\n<p>I do not think that this is an issue. If I recall correctly, I never use<br>\neuclidean_size in any code equations – it is only required for the<br>\ntermination proof of the Euclidean algorithm, and termination measures<br>\ndo not have to be executable.</p>\n</blockquote>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294294622,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924208
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi José,</p>\n<p>after studying your answers I would recommend that you should follow the<br>\napproach in HOL-Algebra, i.e. use locales with explicit carriers.</p>\n<p>Using type classes has a somehow inherent bias toward totality, e.g.<br>\nclass idom assumes that the whole type (except 0, of course) forms an<br>\nintegral domain.  What you want is the real algebraic notion where an<br>\nintegral domain is a subset of a bigger domain (aka type).  Here it is<br>\nwhere the explicit carriers come in.  Similar for gcd also.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/452L5lc6ttl8HQHp2ipqDMvH/signature.asc\">signature.asc</a></p>",
        "id": 294306946,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924614
    },
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nThanks for all answers,</p>\n<p>2014-09-04 9:11 GMT+02:00 Florian Haftmann &lt;<br>\n<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;:</p>\n<p>Unfortunately, we would prefer to avoid HOL-Algebra: our final goal is to<br>\nformalise some well-known algorithms to obtain canonical forms of matrices<br>\nover principal ideal rings (echelon forms, Hermite) and generate code of<br>\nthem*. To do that, we have already developed some infrastructure in the<br>\nHOL-Multivariate Analysis library (and its representation of matrices) that<br>\nwe would like to reuse.</p>\n<p>Defining a gcd in an arbitrary ring could be cumbersome working with<br>\nstructures represented by type classes. Nevertheless, we are mainly<br>\ninterested in working on principal ideal rings, where any two elements have<br>\na gcd. Hence, gcd would be a total function, and appropriate for a type<br>\nclass representation. We just wanted to take the chance to implement some<br>\nadditional Abstract Algebra (commutative rings, integral domains) in a<br>\nproper way (including operations such as gcd), but maybe we will have to<br>\nreshape this goal.</p>\n<p>Fortunately, as far as we know in GCD Domain, Principal Ideal Ring,<br>\nPrincipal Ideal Domain, Factorial Domain and Euclidean Domain, which are<br>\nthe structures where we plan to work, gcd is a total function.</p>\n<p>I will go on thinking about it,</p>\n<p>Best,</p>\n<p>Jose</p>\n<ul>\n<li>Most of these algorithms need to compute gcds or Bézout’s identity. As<br>\nfar as I know, these algorithms could be defined and formalized over a<br>\nprincipal ideal ring, but they wouldn’t be executable if we don’t provide<br>\nan executable gcd function. Nevertheless, they would be executable on<br>\nmatrices whose coefficients belong to an euclidean domain (by means of a<br>\ncomputable euclidean algorithm).</li>\n</ul>",
        "id": 294307779,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924876
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Jose,</p>\n<p>ok, this sounds indeed that you should go for type classes.  In case,<br>\nothers can then use work and generalize it.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/OFdCRxmdH0oigP2V6wZqRbKY/signature.asc\">signature.asc</a></p>",
        "id": 294308147,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924969
    },
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nThank you both,</p>\n<blockquote>\n<p>syntactic type classes such as this are not unusual. They allow</p>\n</blockquote>\n<blockquote>\n<p>overloading of constants (such as 0, +, *, gcd, …) without restricting</p>\n</blockquote>\n<blockquote>\n<p>the way in which these constants can be used. In case of gcd, I think</p>\n</blockquote>\n<blockquote>\n<p>one could make a good argument for assuming basic facts about GCDs in</p>\n</blockquote>\n<blockquote>\n<p>the type class.</p>\n</blockquote>\n<p>I knew this kind of classes are not unusual for elements and operations<br>\nwhich characterise the structure, such as 0, 1, + and *. But, from my point<br>\nof view, gcd is not part of the definition of the structure ring.</p>\n<blockquote>\n<p>GCDs are only unique (modulo association) in integral domains, and only</p>\n</blockquote>\n<blockquote>\n<p>guaranteed to exist in factorial rings (UIDs)</p>\n</blockquote>\n<p>You are completely right. As you say, GCDs can exist in a commutative ring<br>\n(but not for every two elements). They are unique (modulo association) when<br>\nthey exist in integral domains and any two elements of a UFD have a gcd.</p>\n<blockquote>\n<p>For normalisation, the approach that I took in my formalisation of</p>\n</blockquote>\n<blockquote>\n<p>Euclidean rings was to define a function called normalisation_factor ::</p>\n</blockquote>\n<blockquote>\n<p>'a =&gt; 'a, which returns a unit such that dividing any element of the</p>\n</blockquote>\n<blockquote>\n<p>ring by that unit yields the same result for all elements in the same</p>\n</blockquote>\n<blockquote>\n<p>association class, effectively normalising the element. E.g. for</p>\n</blockquote>\n<blockquote>\n<p>integers, the normalisation factor is the sign of the number; for</p>\n</blockquote>\n<blockquote>\n<p>polynomials, it is the leading coefficient.</p>\n</blockquote>\n<p>By the way, in your formalization I have seen you fix the euclidean size in<br>\nthe euclidean_semiring class. However, a Euclidean domain will admit many<br>\ndifferent euclidean size functions (in<br>\n<a href=\"http://en.wikipedia.org/wiki/Euclidean_domain\">http://en.wikipedia.org/wiki/Euclidean_domain</a> it is suggested that a<br>\nparticular Euclidean function f is not part of the structure of a Euclidean<br>\ndomain). Would it be possible to define that class this way? Could there be<br>\nany potential drawbacks?</p>\n<p>class euclidean_semiring = … +</p>\n<p>assumes exists_euclidean_size: \"∃f::'a =&gt; nat. ∀a b. b≠0 ⟶ (∃q r. a = b*q +<br>\nr ∧ (r=0 ∨ f r &lt; f b))\"</p>\n<p>But if one uses this way of defining the euclidean_semiring class, then it<br>\nwould not be possible to get direct executability (because the<br>\neuclidean_size would not be instantiated). Anyway, with your definition it<br>\nwould be possible to work with different euclidean sizes of the same<br>\nstructure if the instantiations are done in independent files. I don’t know<br>\nwhich option is more suitable.</p>\n<blockquote>\n<p>2) A fundamental algebraic type class for GCD.</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>IMHO this could look like:</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>class semiring_gcd = semiring + gcd +</p>\n</blockquote>\n<blockquote>\n<p>assumes \"gcd a b dvd a\"</p>\n</blockquote>\n<blockquote>\n<p>assumes \"gcd a b dvd b\"</p>\n</blockquote>\n<blockquote>\n<p>assumes \"c dvd a ⟹ c dvd b ⟹ c dvd gcd a b\"</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>class ring_gcd = ring + semiring_gcd</p>\n</blockquote>\n<p>I think this class defines semirings where every two elements have a gcd,<br>\nisn’t it? GCD Domain (<a href=\"http://en.wikipedia.org/wiki/GCD_domain\">http://en.wikipedia.org/wiki/GCD_domain</a>) is the most<br>\nsimilar structure that I have seen in the literature. I would like to deal<br>\nwith the case of gcd in commutative rings (where gcd exists, but not for<br>\nevery pair of elements).</p>\n<blockquote>\n<p>a) I strongly believe the assumptions capture the essence of gcd,</p>\n</blockquote>\n<blockquote>\n<p>whatever the underlying structure is.</p>\n</blockquote>\n<p>Your assumptions seem good to me.</p>\n<blockquote>\n<p>b) Whenever you develop type class hierarchies for ring structures, you</p>\n</blockquote>\n<blockquote>\n<p>always have a semiring (the additive structure is a monoid, not a group)</p>\n</blockquote>\n<blockquote>\n<p>and a ring.  The semiring part of the hierarchy is to accommodate the</p>\n</blockquote>\n<blockquote>\n<p>natural numbers (which, in algebra, appear not be that natural after all).</p>\n</blockquote>\n<p>This is a good point because I was going to work above all with principal<br>\nideal rings (and natural numbers aren’t), thank you for remarking it.</p>\n<blockquote>\n<p>c) Here I have chosen »semiring«/»ring« as a base point.  Maybe gcd</p>\n</blockquote>\n<blockquote>\n<p>itself suggests a more specific entry point to start with already, but</p>\n</blockquote>\n<blockquote>\n<p>I have found no argument to do so (maybe you would do after some rounds</p>\n</blockquote>\n<blockquote>\n<p>of experimenting and thinking).</p>\n</blockquote>\n<p>In my opinion it is a good base point, although as you say it can change<br>\nwhen developing. Anyway, GCD Domain is the structure that usually appears<br>\nin the literature to refer a ring where every two elements have a gcd.</p>\n<blockquote>\n<p>d) The specification implicitly states</p>\n</blockquote>\n<blockquote>\n<p>I. the a gcd exists</p>\n</blockquote>\n<p>But then such a class formalises a structure where any two elements have a<br>\ngcd, which is not true for arbitrary rings. So, if we want to work with<br>\nstructures (such as commutative rings) where two elements could not have<br>\nalways a gcd, should we define a gcd inside the class instead of fixing it<br>\nin the class? Maybe should gcd have type “ ‘a =&gt; ‘a =&gt; ‘a option ”?</p>\n<p>But in the case we are working with structures where every two elements<br>\nhave a gcd, then fixing a gcd in the class seems to be the best option.</p>\n<blockquote>\n<p>Note that this work has already been done by Manuel, but is not yet part</p>\n</blockquote>\n<blockquote>\n<p>of Isabelle2014.  If you want to build on that, we will find a suitable</p>\n</blockquote>\n<blockquote>\n<p>way without need to participate in the ongoing Isabelle development.</p>\n</blockquote>\n<p>I was talking with Manuel and I already have the file of his development<br>\n(Euclidean_Algorithm.thy in the repository version of Isabelle).</p>\n<blockquote>\n<p>Maybe any (semi)ring_gcd is also a factorial_(semi)ring?</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>The direction &lt;-- is obvious.  For --&gt; I am uncertain.</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://en.wikipedia.org/wiki/Greatest_common_divisor\">http://en.wikipedia.org/wiki/Greatest_common_divisor</a> (section »The gcd</p>\n</blockquote>\n<blockquote>\n<p>in commutative rings«) suggests that it does not hold in general.  It</p>\n</blockquote>\n<blockquote>\n<p>also suggests that the base structure should be (sem)idom (integral</p>\n</blockquote>\n<blockquote>\n<p>domain) rather than plain (semi)ring.</p>\n</blockquote>\n<p>But if the base structure is an integral domain, then we could not deal<br>\nwith gcd in the natural numbers.</p>\n<blockquote>\n<p>Even more thoughts.</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>1) A characterisation of a factorial ring.</p>\n</blockquote>\n<p>&gt;</p>\n<blockquote>\n<p>May sth. like this:<br>\n</p>\n</blockquote>\n<blockquote>\n<p>class factorial_(semi)ring = (sem)idom +</p>\n</blockquote>\n<blockquote>\n<p>fixes is_prime :: \"α ⇒ bool\"</p>\n</blockquote>\n<blockquote>\n<p>assumes \"(⋀a. a dvd p ⟹ a dvd 1 ∨ p dvd a) ⟹ is_prime p</p>\n</blockquote>\n<blockquote>\n<p>assumes \"is_prime p ⟹ a dvd p ⟹ a dvd 1 ∨ p dvd a\"</p>\n</blockquote>\n<blockquote>\n<p>assumes \"(⋀a b. p dvd a * b ⟹ p dvd a ∨ p dvd b) ⟹ is_prime p</p>\n</blockquote>\n<blockquote>\n<p>assumes \"is_prime p ⟹ p dvd a * b ⟹ p dvd a ∨ p dvd b\"</p>\n</blockquote>\n<p>Why should is_prime be fixed in the structure? Prime elements (and<br>\nirreducible elements) exist in a commutative ring. I have seen that in<br>\nIsabelle2013-2 there was a class called “prime” similar to the gcd one:</p>\n<p>class prime = one +</p>\n<p>fixes prime :: \"'a ⇒ bool\"</p>\n<p>But it has disappeared in Isabelle2014.</p>\n<p>That is why at first I thought that defining gcd inside the class semiring<br>\nwas the best option, instead of creating a new class semiring_gcd (even if<br>\nsemiring_gcd would implicitly assume that every two elements have a gcd).</p>\n<blockquote>\n<p>Maybe --&gt; holds since the given specification for (semi)ring_gcd demands</p>\n</blockquote>\n<blockquote>\n<p>that every two elements have a gcd.  From this it might follow that</p>\n</blockquote>\n<blockquote>\n<p>unique factors can be carved out using iterative gcd computations (I</p>\n</blockquote>\n<blockquote>\n<p>have once seen such a proof for the natural numbers, but I don't know</p>\n</blockquote>\n<blockquote>\n<p>whether this generalizes).</p>\n</blockquote>\n<p>Maybe --&gt; doesn’t hold because it would be necessary the “ascending chain<br>\ncondition on principal ideals”. At least, for domains it is that way (see<br>\n<a href=\"http://en.wikipedia.org/wiki/GCD_domain\">http://en.wikipedia.org/wiki/GCD_domain</a>, where it is said that “an integral<br>\ndomain is a UFD if and only if it is a GCD domain satisfying the<br>\n&lt;<a href=\"http://en.wikipedia.org/wiki/Ascending_chain_condition_on_principal_ideals&gt;ascending\">http://en.wikipedia.org/wiki/Ascending_chain_condition_on_principal_ideals&gt;ascending</a><br>\nchain condition on principal ideals”).</p>\n<p>Still the problem of how to define normalisation properly is not addressed,<br>\nbut it could be similar to the ones of gcd and prime.</p>\n<p>Best,</p>\n<p>Jose</p>",
        "id": 294309151,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925269
    }
]