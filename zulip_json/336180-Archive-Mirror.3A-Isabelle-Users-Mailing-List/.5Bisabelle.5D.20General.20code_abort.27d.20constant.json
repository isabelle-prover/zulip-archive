[
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi all,</p>\n<p>I have been playing a bit with \"code_unspec\". I rapidly found myself defining this reusable constant, which I can now use in all sorts of contexts:</p>\n<p>definition code_unspec :: \"(unit =&gt; 'a) =&gt; 'a\" where<br>\n   [code del]: \"code_unspec f = f ()\"</p>\n<p>code_abort code_unspec</p>\n<p>For example, I can write</p>\n<p>f x = (if p x then some_behavior x else code_unspec (%_. f x))</p>\n<p>and easily prove it from</p>\n<p>p x ==&gt; f x = some_behavior x</p>\n<p>and the definition of \"code_unspec\". I cannot do the same with \"undefined\", because things like</p>\n<p>~ p x ==&gt; f x = undefined<br>\n   ~ p x ==&gt; f x = undefined x</p>\n<p>are not theorems in my application.</p>\n<p>I can't help but notice that my constant could potentially replace many existing uses of \"code_abort\", notably \"enum_the\" in \"Enum.thy\". Are there any takers, or should I define it in my own ((co)datatype-related) theories?</p>\n<p>Jasmin</p>\n<p>P.S. To members of the Munich Isabelle group: Sorry for the duplicate email.</p>",
        "id": 294248099,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909717
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jasmin,</p>\n<p>I have been using such a constant for a long time. In 2009, my FinFun theories in the AFP <br>\ndefined a constant code_abort with exactly the setup, later they made it into HOL/Library <br>\nand I have used that in JinjaThreads. The problem with such a code_unspec is that the <br>\ngenerated code will always raise the exception Fail with message \"code_unspec\". This is a <br>\nnight-mare when you try to debug the generated code. Therefore, I now use a new constant <br>\nCode.abort that also allows to specify an error message (changeset 7bfe0df532a9) that will <br>\nbe part of the next release. I recommend that you use Code.abort for your purposes.</p>\n<p>I would appreciate if all these code_aborts that you mention were consolidated to use <br>\nCode.abort.</p>\n<p>Andreas</p>",
        "id": 294248113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909722
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>I have been using such a constant for a long time. In 2009, my FinFun theories in the AFP defined a constant code_abort with exactly the setup, later they made it into HOL/Library and I have used that in JinjaThreads. The problem with such a code_unspec is that the generated code will always raise the exception Fail with message \"code_unspec\". This is a night-mare when you try to debug the generated code. Therefore, I now use a new constant Code.abort that also allows to specify an error message (changeset 7bfe0df532a9) that will be part of the next release. I recommend that you use Code.abort for your purposes.</p>\n</blockquote>\n<p>That's great. It escaped my simple-minded grep \"code_abort\" but that's what I need.</p>\n<blockquote>\n<p>I would appreciate if all these code_aborts that you mention were consolidated to use Code.abort.</p>\n</blockquote>\n<p>I second this. Cf. <a href=\"http://goo.gl/4kR3vu\">http://goo.gl/4kR3vu</a> :)</p>\n<p>Jasmin</p>",
        "id": 294248121,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909728
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I currently stumbled about a problem that Code.abort does not work in<br>\ncombination with Eval, where it does not fail, but loop.<br>\n(in Isabelle-2013-1-RC-1)</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>definition \"foo x = (x :: bool)\"<br>\nlemma [code]: \"foo x = (if x then True else Code.abort (STR ''not impl.'') (% _. foo x))\"<br>\n  by (auto simp: foo_def)</p>\n<p>export_code foo in Eval<br>\n(* delivers: <br>\n   fun foo x = (if x then true else (raise Fail \"not impl.\") (fn _ =&gt; foo x)); <br>\n*)</p>\n<p>value \"foo True\" (* True *)<br>\nvalue \"foo False\" (* loops *)</p>\n<p>ML {*<br>\n  let fun foo x = (if x then true else (raise Fail \"not impl.\") (fn _ =&gt; foo x))<br>\n  in foo false <br>\n  end<br>\n*}<br>\n(* delivers intended result: exception Fail raised: not impl. *)<br>\nend</p>\n<p>Is this a known limitation, feature, or a bug?</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294253529,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911704
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi René,</p>\n<blockquote>\n<p>I currently stumbled about a problem that Code.abort does not work in<br>\ncombination with Eval, where it does not fail, but loop.<br>\n(in Isabelle-2013-1-RC-1)<br>\nWell, it is not Eval that loops but nbe and code_simp. You can see this by specifying the <br>\nevaluation mechanism:</p>\n</blockquote>\n<p>value [code] \"foo False\" (* raises Fail *)<br>\nvalue [simp] \"foo False\" (* loops *)<br>\nvalue [nbe]  \"foo False\" (* loops *)</p>\n<p>It is fairly easy to stop the simplifier from looping, a congruence rule for Code.abort <br>\nsuffices (see the attached patch).</p>\n<p>With [nbe], I haven't found a way to achieve termination. As there are no code equations <br>\nfor Code.abort available, nbe descends into the argument (%_. foo x) and here, the <br>\nequation for foo yields the next unfolding. Maybe Florian knows a way to stop nbe.</p>\n<p>Therefore, I would call the looping of the simplifier a bug, the looping of nbe a limitation.</p>\n<p>@Makarius:<br>\nCan you add the attached hg export to isabelle-release?</p>\n<p>Andreas</p>\n<blockquote>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>definition \"foo x = (x :: bool)\"<br>\nlemma [code]: \"foo x = (if x then True else Code.abort (STR ''not impl.'') (% _. foo x))\"<br>\n   by (auto simp: foo_def)</p>\n<p>export_code foo in Eval<br>\n(* delivers:<br>\n    fun foo x = (if x then true else (raise Fail \"not impl.\") (fn _ =&gt; foo x));<br>\n*)</p>\n<p>value \"foo True\" (* True *)<br>\nvalue \"foo False\" (* loops *)</p>\n<p>ML {*<br>\n   let fun foo x = (if x then true else (raise Fail \"not impl.\") (fn _ =&gt; foo x))<br>\n   in foo false<br>\n   end<br>\n*}<br>\n(* delivers intended result: exception Fail raised: not impl. *)<br>\nend</p>\n<p>Is this a known limitation, feature, or a bug?</p>\n<p>Cheers,<br>\nRené</p>\n<p>Am 18.09.2013 um 17:04 schrieb Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;:</p>\n<blockquote>\n<p>Hi Jasmin,</p>\n<p>I have been using such a constant for a long time. In 2009, my FinFun theories in the AFP defined a constant code_abort with exactly the setup, later they made it into HOL/Library and I have used that in JinjaThreads. The problem with such a code_unspec is that the generated code will always raise the exception Fail with message \"code_unspec\". This is a night-mare when you try to debug the generated code. Therefore, I now use a new constant Code.abort that also allows to specify an error message (changeset 7bfe0df532a9) that will be part of the next release. I recommend that you use Code.abort for your purposes.</p>\n<p>I would appreciate if all these code_aborts that you mention were consolidated to use Code.abort.</p>\n<p>Andreas<br>\n</p>\n</blockquote>\n<p>On 18/09/13 16:42, Jasmin Christian Blanchette wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi all,</p>\n<p>I have been playing a bit with \"code_unspec\". I rapidly found myself defining this reusable constant, which I can now use in all sorts of contexts:</p>\n<p>definition code_unspec :: \"(unit =&gt; 'a) =&gt; 'a\" where<br>\n    [code del]: \"code_unspec f = f ()\"</p>\n<p>code_abort code_unspec</p>\n<p>For example, I can write</p>\n<p>f x = (if p x then some_behavior x else code_unspec (%_. f x))</p>\n<p>and easily prove it from</p>\n<p>p x ==&gt; f x = some_behavior x</p>\n<p>and the definition of \"code_unspec\". I cannot do the same with \"undefined\", because things like</p>\n<p>~ p x ==&gt; f x = undefined<br>\n    ~ p x ==&gt; f x = undefined x</p>\n<p>are not theorems in my application.</p>\n<p>I can't help but notice that my constant could potentially replace many existing uses of \"code_abort\", notably \"enum_the\" in \"Enum.thy\". Are there any takers, or should I define it in my own ((co)datatype-related) theories?</p>\n<p>Jasmin</p>\n<p>P.S. To members of the Munich Isabelle group: Sorry for the duplicate email.</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/nIrkXWAfspmStGEVCAEdOzms/code_abort_code_simp.patch\">code_abort_code_simp.patch</a></p>\n</blockquote>",
        "id": 294253672,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911747
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nDone.</p>\n<p>See <br>\n<a href=\"https://bitbucket.org/isabelle_project/isabelle-release/commits/da932f511746\">https://bitbucket.org/isabelle_project/isabelle-release/commits/da932f511746</a></p>\n<p>Makarius</p>",
        "id": 294253756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911790
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Andreas,</p>\n<blockquote>\n<blockquote>\n<p>I currently stumbled about a problem that Code.abort does not work in<br>\ncombination with Eval, where it does not fail, but loop.<br>\n(in Isabelle-2013-1-RC-1)<br>\nWell, it is not Eval that loops but nbe and code_simp. You can see this by specifying the evaluation mechanism:</p>\n</blockquote>\n<p>value [code] \"foo False\" (* raises Fail *)<br>\nvalue [simp] \"foo False\" (* loops *)<br>\nvalue [nbe]  \"foo False\" (* loops *)</p>\n</blockquote>\n<p>thanks for the explanation. I already tried value[nbe], but not value[code] :-(.<br>\nNow even my real example works as expected.</p>\n<p>Cheers,<br>\nRené</p>\n<blockquote>\n<p>It is fairly easy to stop the simplifier from looping, a congruence rule for Code.abort suffices (see the attached patch).</p>\n<p>With [nbe], I haven't found a way to achieve termination. As there are no code equations for Code.abort available, nbe descends into the argument (%_. foo x) and here, the equation for foo yields the next unfolding. Maybe Florian knows a way to stop nbe.</p>\n<p>Therefore, I would call the looping of the simplifier a bug, the looping of nbe a limitation.</p>\n</blockquote>",
        "id": 294253945,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911876
    }
]