[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nFirst, I ask a straightforward question.</p>\n<p>If I declare a type, such as</p>\n<p>typedecl sT,</p>\n<p>am I effectively creating a non-empty set, which has a power set <br>\nassociated with it? I've read several times that a type can be <br>\ninterpreted as a non-empty set.</p>\n<p>Second, I try to bump up the value of this email with some setup <br>\ninformation for Nitpick and Sledgehammer. I'm in the \"learn how to setup <br>\nand use Nitpick and Sledgehammer\" mode. I'm almost out of it, but I try <br>\nto explore it in depth so that when I get back to the drudgery of <br>\nworking through tutorials and exercises, I know how to use these <br>\nautomated tools for my own tangents. And, certain logics can never be <br>\nused to prove their own consistency, so I might as well run Nitpick on <br>\neverything, and to check the more likely scenario that I've introduced <br>\ninconsistency.</p>\n<p>Third, if you want to read that far, I have a type, a constant, a <br>\npredicate, one axiom, and one theory, and I get a counterexample from <br>\nNitpick. The answers to my questions on that may be obvious, but I ask <br>\nthem anyway. Not understanding subtleties can cause me to have a too <br>\nsimple view of the universe, which might take me months to find out.</p>\n<p>NITPICK STUFF</p>\n<p>If you run \"nitpick [verbose]\" under a theorem, you'll get this message <br>\n(at least for Cygwin):</p>\n<p>The following solvers are configured: \"MiniSat_JNI\", <br>\n\"CryptoMiniSat_JNI\", \"Lingeling_JNI\", \"SAT4J\", \"SAT4J_Light\".</p>\n<p>Jasmine Blanchette rates these SAT solvers like this:</p>\n<p>\"SAT4J is very slow, but the others are roughly equivalent, with <br>\nLingeling slightly better than CryptoMiniSat, and CryptoMiniSat slightly <br>\nbetter than vanilla MiniSat.\"</p>\n<p>Though CryptoMiniSat_JNI and Lingeling_JNI show up, to use them you need <br>\nKodkodi 1.5.2, from Blanchette's site:</p>\n<p><a href=\"http://www4.in.tum.de/~blanchet/#software\">http://www4.in.tum.de/~blanchet/#software</a> <br>\n&lt;<a href=\"http://www4.in.tum.de/%7Eblanchet/#software\">http://www4.in.tum.de/%7Eblanchet/#software</a>&gt;</p>\n<p>The install instructions for a Kodkodi upgrade are on page 3 of <br>\nnitpick.pdf.</p>\n<p>If you want to be compulsive, after setting some options with something <br>\nlike \"nitpick_params [verbose,timeout=120,user_axioms=true]\", which will <br>\nalso lists how all the options are set in the output window, you can run <br>\nall the SATs under a theorem with something like:</p>\n<p>nitpick[verbose,user_axioms,sat_solver=MiniSat_JNI]<br>\n   nitpick[verbose,user_axioms,sat_solver=CryptoMiniSat_JNI]<br>\n   nitpick[verbose,user_axioms,sat_solver=Lingeling_JNI]<br>\n   nitpick[verbose,user_axioms,sat_solver=SAT4J]<br>\n   nitpick[verbose,user_axioms,sat_solver=SAT4J_Light]</p>\n<p>SLEDGEHAMMER STUFF</p>\n<p>On Jasmin's site are also the upgrades to the Sledgehammer solvers CVC3, <br>\nE, SPASS, and Z3. So far, I haven't been big on wanting to change the <br>\ndefault Isabelle2012 distribution, but I'll work on doing this, which <br>\nwill keep me in the \"learn the auto-tools mode\" for another day.</p>\n<p>In the folder Isabelle2012/contrib, you can see the versions of Kodkodi, <br>\nCVC3, E, SPASS, and Z3 to see what versions you have.</p>\n<p>SLEDGEHAMMER YICES</p>\n<p>Working hard to do more than ask questions, I am the official liaison of <br>\nimportant, breaking news on [isabelle-dev], which is a joke, of course.</p>\n<p>Put YICES_INSTALLED=\"yes\" in your \"~/Isabelle2012/etc/settings\" file, <br>\nand yices will be one of the available solvers when you use the command <br>\n\"sledgehammer supported_provers\" under a theorem. The pertinent thread <br>\nis \"sledgehammer / yices\":</p>\n<p><a href=\"http://www.mail-archive.com/search?q=sledgehammer+%2F+yices&amp;l=isabelle-dev%40mailbroy.informatik.tu-muenchen.de\">http://www.mail-archive.com/search?q=sledgehammer+%2F+yices&amp;l=isabelle-dev%40mailbroy.informatik.tu-muenchen.de</a> <br>\n&lt;<a href=\"http://www.mail-archive.com/search?q=sledgehammer+%2F+yices&amp;l=isabelle-dev%40mailbroy.informatik.tu-muenchen.de\">http://www.mail-archive.com/search?q=sledgehammer+%2F+yices&amp;l=isabelle-dev%40mailbroy.informatik.tu-muenchen.de</a>&gt;</p>\n<p>NITPICK'S COUNTERX: PENCIL &amp; PAPER LOGIC vs. ISABELLE'S LOGIC</p>\n<p>The foundation of the traditional \"pencil &amp; paper\" logic can never be <br>\nexactly the same as Isabelle's logic foundation. Our brain maps formulas <br>\nto a value of either true or false. Isabelle uses typed lambda calculus <br>\nto map formulas to true or false. I understand that the two lowest-level <br>\nfoundations for the two logics aren't exactly the same.</p>\n<p>Suppose I have an \"extreme minimalist ZF sets logic\". I've been given <br>\nthe same logical symbols, the same non-logical symbols, and the same <br>\nrules for using them as ZF sets.</p>\n<p>I write one formula as an axiom, \"(1) there exists a set which contains <br>\nno elements\", (? x. ! y. ~(y IN x)).</p>\n<p>I write one formula as a theorem, \"(2) the set described by (1) is <br>\nunique\", (! u. ((! x. ~(x IN u)) --&gt; u = emptyS)).</p>\n<p>Setting aside that I'm taking liberties with (2) by using a constant <br>\nname, though I can't prove (2) because I haven't defined \"=\" with an <br>\naxiom, I would be very surprised if someone told me that a <br>\ncounterexample could be found for (2) using the single formula of (1), <br>\nwhich is all that's available to be used. Well, not quite. The FOL <br>\nspecification requires that \"=\" is given as a logical symbol, but I do <br>\nneed some sets available for a counterexample.</p>\n<p>Alright, but with Isabelle, I can never be so minimalist. My minimalist <br>\nlogic on top of HOL needs a declared type, and the \"=\" is given as the <br>\nFOL logical symbol which is (partly or fully) axiomatized by four axioms <br>\nstarting at line 196 of src/HOL/HOL.thy. I understand the first 2 <br>\naxioms, but not the second 2.</p>\n<p>My logic needs a declared type, \"typedecl sT\", and I assume I <br>\neffectively introduce a non-empty set by doing that, which means there <br>\nare sets available for a counterexample.</p>\n<p>I show my minimalist world below and I attache it as a file. The theorem <br>\n\"emS_is_unique1\" fails Nitpick. After \"=\" is defined for sets, <br>\n\"emS_is_unique2\" doesn't fail Nitpick, and is proved by metis.</p>\n<p>Some responses, whether sent or thought, might be:</p>\n<p>\"There's not a problem, don't make a mountain out of a molehill. Define <br>\nequality like you have to do anyway.\"</p>\n<p>Or, \"If a consistency results because your setup is too simplistic, <br>\nyou'll probably find out. If it takes you 6 months to find it out, well, <br>\nthat's the cost of doing business in the world of proof assistants.\"</p>\n<p>Regards,<br>\nGB</p>\n<p>theory sTs_Empty_Exist_Nitpick<br>\nimports Main<br>\nbegin<br>\ndeclare[[show_brackets=true]]<br>\ntypedecl sT<br>\nconsts emS::sT<br>\nconsts inS::\"sT =&gt; sT =&gt; bool\" (infixl \"IN\" 55)</p>\n<p>axiomatization where<br>\n   eeA:\"!x. ¬(x IN emS)\"</p>\n<p>theorem emS_is_unique1:<br>\n   \"!u. (!x. ~(x IN u)) --&gt; u = emS\"<br>\n   nitpick[verbose,user_axioms] oops</p>\n<p>axiomatization where<br>\n   exA: \"!u. !v. ((!x. x IN u &lt;-&gt; x IN v) --&gt; u = v)\"</p>\n<p>theorem emS_is_unique2:<br>\n   \"!u. (!x. ~(x IN u)) --&gt; u = emS\"<br>\n   by (metis eeA exA)<br>\nend<br>\n<a href=\"/user_uploads/14278/vNoI0ppz79z6tmoycZ76e5CJ/sTs_Empty_Exist_Nitpick.thy\">sTs_Empty_Exist_Nitpick.thy</a></p>",
        "id": 294166134,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854788
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI know that \"=\" as axiomatized in HOL.thy is a HOL function as <br>\nintroduced on line 98: eq :: \"['a, 'a] =&gt; bool\".</p>\n<p>I naively adopt the logical symbols /\\, \\/, --&gt;, ~, =, \\&lt;forall&gt;, <br>\n\\&lt;exists&gt;, and &lt;-&gt; as my FOL logical symbols.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294166141,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854793
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHere is my conclusion/lesson, which is merely stating the obvious: If I <br>\ndon't axiomatize things right, I get inconsistencies.</p>\n<p>axiomatization where<br>\n   eeA:\"!x. ¬(x IN emS)\"</p>\n<p>theorem emS_is_unique1:<br>\n   \"!u. (!x. ~(x IN u)) --&gt; u = emS\"<br>\n   nitpick[verbose,user_axioms] oops</p>\n<p>theorem emS_is_unique1_negation:<br>\n   \"~(!u. (!x. ~(x IN u)) --&gt; u = emS)\"<br>\n   nitpick[verbose,user_axioms] oops</p>\n<p>So nitpick finds counterexamples for both.</p>\n<p>Unfortunately, I don't understand types, lambda calculus, and the \"=\" <br>\nfunction well enough to know why.</p>\n<p>So, I add the standard axioms, without completely understanding the <br>\nunderlying engine, and hope for the best. There's always the possibility <br>\nthat it's something embarrassingly simple.</p>\n<p>Still, metis is pretty impressive, even though it's being applied to a <br>\nsimple problem. I negated emS_is_unique1 so that it started with an <br>\n\\&lt;exists&gt;, and then negated the whole thing with \"~\", and after defining <br>\nset equality, metis proved it by the non-negated version of the theorem <br>\nright above it. These things don't happen by accident, and sledgehammer <br>\nis there to help make things happen.</p>\n<p>Well, I go ahead and try to think this out. If emS_is_unique1 is false, <br>\nthen:</p>\n<p>? u. (! x. ~(x IN u)) &amp; (u ~= emS).</p>\n<p>If types allow an infininite number of  \"u::sT\" to be lurking out there, <br>\nthen there's a \"u\" distinct from emS for which I've never said that \"u = <br>\nemS\", therefore \"u ~= emS\", and for which I've never used on the RHS of <br>\nan \"IN\", therefore (!x. ~(x IN u)) .</p>\n<p>What blows my analysis apart is that Nitpick finds a counterexample for <br>\nemS_is_unique1_negation. I want to say that Nitpick shows that the <br>\nnegation of the theorem is true, but that would require me to ask an <br>\nembarrassing question, like, \"Uh, can I ask a simple question? If <br>\nNitpick finds a counterexample to a theorem, does that mean that the <br>\nnegation of the theorem is true?\"</p>\n<p>Things being both true and false don't make a lot of sense.<br>\nRegards,<br>\nGB</p>",
        "id": 294166162,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854803
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nJust to clarify: YICES_INSTALLED=\"yes\" alone won't work if the yices <br>\nbinary is not installed and set up correctly (as described in <code>isabelle \ndoc sledgehammer</code>), since the standard Isabelle bundle does not include <br>\nthis binary due to licensing issues.</p>\n<p>cheers</p>\n<p>chris</p>\n<p>PS: Z3_NON_COMMERCIAL=\"yes\" (in your etc/settings) is also a way to add <br>\nan additional prover and works out of the box.</p>",
        "id": 294166174,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854809
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nThat's good info because I would have missed that. The auto-provers <br>\nreturn lots of errors, and it wasn't apparent to me that yices wasn't <br>\ninstalled. I searched the web based on provers that showed up for <br>\n\"sledgehammer supported_provers\", but I did my web search before doing <br>\nmy YICES_INSTALLED=\"yes\".</p>\n<p>Here's the downloads that I found on the web:</p>\n<p>Yices: <a href=\"http://yices.csl.sri.com/download.shtml\">http://yices.csl.sri.com/download.shtml</a></p>\n<p>Vampire: <a href=\"http://www.vprover.org/\">http://www.vprover.org/</a></p>\n<p>alt_ergo: <a href=\"http://alt-ergo.lri.fr/\">http://alt-ergo.lri.fr/</a>, <a href=\"http://why3.lri.fr/\">http://why3.lri.fr/</a></p>\n<p>leo2: <a href=\"http://www.ags.uni-sb.de/~leo/\">http://www.ags.uni-sb.de/~leo/</a></p>\n<p>satallax: <a href=\"http://www.ps.uni-saarland.de/~cebrown/satallax/\">http://www.ps.uni-saarland.de/~cebrown/satallax/</a></p>\n<p>Yices has a Cygwin binary, and it works if I correctly use Cygwin's path <br>\nnaming like /cygdrive/e/.../yices-1.0.35/bin/yices. I wouldn't be able <br>\nto use it without the binary, since there's no remote yices.</p>\n<p>I couldn't get Vampire working on Cygwin last year, and I don't expect <br>\nbetter results this year, plus I can't get the file off of their web <br>\nsite. But there's remote_vampire.</p>\n<p>The alt_ergo installer got deleted by Norton, plus Why3 has to be <br>\ninstalled to use it, so I forget about that one for now.</p>\n<p>Leo2 and Satallax don't come with a Cygwin binary, so I forget about <br>\nthem, since I don't try to make anything with Cygwin. But there are <br>\nremote versions for both of these.</p>\n<p>I have them all in now. I count twenty-one of them. I wonder about that <br>\ndummy_thf. It doesn't ever solve anything. That \"dummy\" sounds a little <br>\nsuspicious.</p>\n<p>I wonder if I really need all three of spass, spass_new, and spass_old, <br>\nbut I leave them all in.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294166191,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854820
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 19 Jul 2012, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>Here is my conclusion/lesson, which is merely stating the obvious: If I <br>\ndon't axiomatize things right, I get inconsistencies.</p>\n</blockquote>\n<p>Axiomatizations are very difficult to get right.  Experts usually avoid <br>\nthem altogether, and use definitions exclusively.  Definitions can be as <br>\ndiverse as 'definition', 'inductive', 'function', 'locale', ...</p>\n<blockquote>\n<p>Unfortunately, I don't understand types, lambda calculus, and the \"=\" <br>\nfunction well enough to know why.</p>\n</blockquote>\n<p>Lambda calculus is just notations for mathematical functions; '=' is plain <br>\nclassical equality on arbitrary mathematical entities, including <br>\nfunctions.</p>\n<p>HOL is more simple than FOL, because it does not impose any restrictions <br>\nabout quantification and equality.</p>\n<p>Types in HOL are just separate syntactic domains, which are always <br>\nnon-empty by construction of the logic.  This is like the implicit <br>\n(single) domain of discourse in FOL, but HOL allows many of them, also <br>\nconstructors to operate on such domains: nat, nat =&gt; bool, nat set,<br>\nnat list, ..., 'a * 'b, ...</p>\n<p>Makarius</p>",
        "id": 294166310,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854861
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/20/2012 6:23 AM, Makarius wrote:</p>\n<blockquote>\n<p>Axiomatizations are very difficult to get right. Experts usually avoid<br>\nthem altogether, and use definitions exclusively. Definitions can be as<br>\ndiverse as 'definition', 'inductive', 'function', 'locale', ...</p>\n</blockquote>\n<p>I briefly thought about how to use definitions, just to try and use good <br>\ndiscipline. Suppose I have 7 standard axioms that I have to use. Then I <br>\nguess I could define an object, function, or property with a big <br>\nconjunction using the 7 axioms.</p>\n<p>If I see the right example, it'll become clear. Using axioms lets me <br>\nstart working on a real application right now as a diversion, instead of <br>\nwaiting until I've become thoroughly educated, which could be a long <br>\nprocess. Trying to apply what I know at any point in time helps drive it <br>\ninto long term memory, and usually requires me to learn something in <br>\naddition to the knowledge I'm trying to apply.</p>\n<blockquote>\n<p>Lambda calculus is just notations for mathematical functions; '=' is<br>\nplain classical equality on arbitrary mathematical entities, including<br>\nfunctions.</p>\n<p>HOL is more simple than FOL, because it does not impose any restrictions<br>\nabout quantification and equality.</p>\n<p>Types in HOL are just separate syntactic domains, which are always<br>\nnon-empty by construction of the logic. This is like the implicit<br>\n(single) domain of discourse in FOL, but HOL allows many of them, also<br>\nconstructors to operate on such domains: nat, nat =&gt; bool, nat set,<br>\nnat list, ..., 'a * 'b, ...</p>\n</blockquote>\n<p>Thanks for the summary. Not understanding subtleties can kill me, but I <br>\nalso need to understand the big picture.</p>\n<p>Quantifying over functions has me a little worried. I see the need to <br>\nquantify over types of something like \"sT =&gt; bool\", rather than over <br>\njust a primitive type variable. If I'm doing that in what would normally <br>\nbe a FOL system of logic, then I've entered the realm of higher order <br>\nlogic. I don't care about that. I only care that I get busted for doing it.</p>\n<p>I head down the road semi-blind, and find out where it leads.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294166352,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854891
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nWhy?  Semantically a function is just a set, and in mathematics you <br>\nqantify over collections of sets all the time.</p>\n<p>You can take HOL is a simplified version of FOL + set theory, but with an <br>\nexplicit type system.  Paradoxically HOL is weaker that FOL + ZF set <br>\ntheory, despite arbitrary abstraction and quantification in HOL.</p>\n<p>Anyway, in practice you don't need to worry about the foundations and <br>\ntheir relative logical strenth.  You just do your applications with <br>\nhigh-level specification mechanims in Isabelle (datatype, function, <br>\ninductive, locale etc.), better not axiomatization.</p>\n<p>Makarius</p>",
        "id": 294166395,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854910
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/20/2012 9:34 AM, Makarius wrote:</p>\n<blockquote>\n<p>On Fri, 20 Jul 2012, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>Quantifying over functions has me a little worried.</p>\n</blockquote>\n<p>Why? Semantically a function is just a set, and in mathematics you<br>\nqantify over collections of sets all the time.</p>\n</blockquote>\n<p>Because I read things that I don't completely understand that make me <br>\nworry, such as that certain things can be proved about FOL that can't be <br>\nproved about HOL. Was that \"completeness\" that I read about? I don't <br>\neven look it up.</p>\n<p>Until recently, I made my money as a technician working in telecom. I've <br>\nseen it over and over again. The best educated and hardest working <br>\nengineers don't typically make fundamental mistakes, because they <br>\nunderstand the fundamentals. Those with an inferior education, even if <br>\nthey work hard, make fundamental mistakes that doom their designs.</p>\n<p>You understand foundations all the way to the bottom. I try to <br>\nunderstand what I don't understand to not be the guy who makes the most <br>\nfundamental of mistakes. A healthy amount of worry keeps me on my toes.</p>\n<blockquote>\n<p>You can take HOL is a simplified version of FOL + set theory, but with<br>\nan explicit type system. Paradoxically HOL is weaker that FOL + ZF set<br>\ntheory, despite arbitrary abstraction and quantification in HOL.</p>\n</blockquote>\n<p>Here, I don't even know what \"weaker\" means because I've found no <br>\nstandard definition anywhere for \"logically weaker\".</p>\n<p>However, I've found enough information to assume that it means that <br>\neverything you can prove with HOL can be proved with FOL+ZF, but not <br>\nvice versa.</p>\n<p>Immediately, I ask the question, \"How can what each logic proves be <br>\ncompared? They're two different logics, with two different sets of <br>\nprimitive symbols, with two different rules for combining the symbols\".</p>\n<p>I answer my question and say, \"Ah, those logicians, they must have <br>\nformalized the study of translating statements from one logic into another.\"</p>\n<blockquote>\n<p>Anyway, in practice you don't need to worry about the foundations and<br>\ntheir relative logical strenth.</p>\n</blockquote>\n<p>Well, I think you're projecting your understanding of foundations onto <br>\nme. You see clearly to the bottom. I see through a glass darkly.</p>\n<blockquote>\n<p>You just do your applications with<br>\nhigh-level specification mechanims in Isabelle (datatype, function,<br>\ninductive, locale etc.), better not axiomatization.</p>\n</blockquote>\n<p>And so I'll make the switch as soon as possible, and either redo <br>\neverything based on some sort of definition, or I'll maintain two <br>\ndifferent versions. I'm jumping to conclusions here about me being able <br>\nto achieve overall success with my current idea.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294216674,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895237
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 20 Jul 2012, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>On 7/20/2012 9:34 AM, Makarius wrote:</p>\n<p>On Fri, 20 Jul 2012, Gottfried Barrow wrote:</p>\n<blockquote>\n<blockquote>\n<p>Quantifying over functions has me a little worried.</p>\n</blockquote>\n<p>Why? Semantically a function is just a set, and in mathematics you<br>\nqantify over collections of sets all the time.</p>\n</blockquote>\n<p>Because I read things that I don't completely understand that make me <br>\nworry, such as that certain things can be proved about FOL that can't be <br>\nproved about HOL. Was that \"completeness\" that I read about? I don't <br>\neven look it up.</p>\n</blockquote>\n<p>Depends you how completeness is formalized.  The book by Peter B. Andrews <br>\n\"An Introduction to Mathematical Logic and Type Theory: To Truth Through <br>\nProof\" contains the standard canon of correctness and completeness 3 <br>\ntimes: (1) propositional logic, (2) first-order logic, (3) higher-order <br>\nlogic.  The latter goes back to Henkin 1950, who was discussing the Church <br>\n1940 version of HOL, which was not called HOL back then.</p>\n<p>For using Isabelle/HOL, all of this is of little practical relevance. <br>\nYou just do mathematical modelling with the definitional mechanisms that <br>\nthe system gives you, and trust that the internal foundations <br>\n(implementation wrt. the core logic) work out.  It is like getting on a <br>\nhigh-speed train: you merely need to buy a ticket to participate, not <br>\nstudy all the technical manuals first.</p>\n<blockquote>\n<blockquote>\n<p>You can take HOL is a simplified version of FOL + set theory, but with<br>\nan explicit type system. Paradoxically HOL is weaker that FOL + ZF set<br>\ntheory, despite arbitrary abstraction and quantification in HOL.</p>\n</blockquote>\n<p>Here, I don't even know what \"weaker\" means because I've found no standard <br>\ndefinition anywhere for \"logically weaker\".</p>\n<p>However, I've found enough information to assume that it means that <br>\neverything you can prove with HOL can be proved with FOL+ZF, but not <br>\nvice versa.</p>\n</blockquote>\n<p>Yes.  HOL can live semantically in a small subspace of FOL+ZF.  So you can <br>\ndo most of classic mathematics with some restrictions.  It will take a <br>\nlong time until you get to the foundational limits, though.</p>\n<p>Makarius</p>",
        "id": 294216796,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895327
    }
]