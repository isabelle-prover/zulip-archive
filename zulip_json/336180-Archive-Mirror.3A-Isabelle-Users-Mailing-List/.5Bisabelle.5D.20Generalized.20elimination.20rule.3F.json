[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>I'm curious whether it is (easily) possible to apply elimination rules <br>\nin Isabelle that<br>\neliminate more than one premise.</p>\n<p>There is a consumes-flag for cases rules, however, simply doing:</p>\n<p>lemma AB_elim[consumes 2]: \"[| A; B; Foo =&gt; thesis |] ==&gt; thesis\"</p>\n<p>lemma  \"[| A; B; C |] ==&gt; Foo\"<br>\n  apply (cases rule: AB_elim)</p>\n<p>does not work, and leaves me with three subgoals, the last one being:<br>\n  [|A; B; C; Foo |] ==&gt;  Foo</p>\n<p>apply (erule (1) AB_elim) leaves me with one subgoal being:<br>\n     [| B; C; Foo |] ==&gt;  Foo</p>\n<p>However, I want something that yields the subgoal:<br>\n     [| C; Foo |] ==&gt;  Foo</p>\n<p>and that also works if the A and B are not in order, i.e. for<br>\n  [| ...; B; ...; A; ... |] ==&gt; Foo<br>\napply (?? AB_elim) shall yield:<br>\n  [| ...; ...; ...; Foo |] ==&gt; Foo<br>\ni.e. removing the matching A and B from the premises.</p>\n<p>(I need this for termination and proper behavior of a set of elimination <br>\nrules that I apply exhaustively with apply (...)+ ):</p>\n<p>Regards and thanks for any hints,<br>\n  Peter</p>",
        "id": 294100238,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833528
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Thu, Feb 25, 2010 at 10:04 AM, Peter Lammich<br>\n&lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I'm curious whether it is (easily) possible to apply elimination rules in<br>\nIsabelle that<br>\neliminate more than one premise.</p>\n<p>There is a consumes-flag for cases rules, however, simply doing:</p>\n<p>lemma AB_elim[consumes 2]: \"[| A; B; Foo =&gt; thesis |] ==&gt; thesis\"</p>\n<p>lemma  \"[| A; B; C |] ==&gt; Foo\"<br>\n apply (cases rule: AB_elim)</p>\n<p>does not work, and leaves me with three subgoals, the last one being:<br>\n [|A; B; C; Foo |] ==&gt;  Foo</p>\n<p>apply (erule (1) AB_elim) leaves me with one subgoal being:<br>\n   [| B; C; Foo |] ==&gt;  Foo</p>\n<p>However, I want something that yields the subgoal:<br>\n   [| C; Foo |] ==&gt;  Foo</p>\n</blockquote>\n<p>Hi Peter,</p>\n<p>The \"consumes\" attribute only has an effect when you are in an<br>\nIsar-style proof with chained facts. Here's a situation where it works<br>\nas you expect:</p>\n<p>lemma \"[|A; B; C|] ==&gt; Foo\"<br>\nproof -<br>\n  assume \"A\" and \"B\" and \"C\"<br>\n  then show \"Foo\"<br>\n   (* there are now 3 chained facts: \"A\", \"B\", \"C\" *)<br>\n  apply (cases rule: AB_elim)</p>\n<p>Now the first 2 chained facts are matched with rule AB_elim and<br>\ndisappear. The remaining fact \"C\" stays in the remaining subgoal,<br>\nleaving \"[| C; Foo |] ==&gt;  Foo\".</p>\n<blockquote>\n<p>and that also works if the A and B are not in order, i.e. for<br>\n [| ...; B; ...; A; ... |] ==&gt; Foo<br>\napply (?? AB_elim) shall yield:<br>\n [| ...; ...; ...; Foo |] ==&gt; Foo<br>\ni.e. removing the matching A and B from the premises.</p>\n</blockquote>\n<p>Unfortunately, chained facts can only be matched in the given order<br>\n(for efficiency reasons, I believe), so this doesn't really do what<br>\nyou want.</p>\n<blockquote>\n<p>(I need this for termination and proper behavior of a set of elimination<br>\nrules that I apply exhaustively with apply (...)+ ):</p>\n<p>Regards and thanks for any hints,<br>\n Peter</p>\n</blockquote>\n<p>I don't think there is any easy way to accomplish what you want to<br>\ndo---at least, I don't know of any already-implemented tactic in<br>\nIsabelle that does this. I do think such a tactic would be useful,<br>\nthough; I've wished for it a few times myself.</p>\n<p>It might be possible to implement such a tactic in ML. The obvious<br>\napproach of trying to generalize eresolve_tac probably won't work,<br>\nbecause eresolve_tac is implemented in terms of Thm.biresolution,<br>\nwhich is part of Isabelle's trusted kernel.</p>\n<p>You could probably define this tactic on top of eresolve_tac:<br>\nBasically you would do \"erule (n)\" (which is basically \"erule\" then<br>\n\"assumption\" n times) followed by n calls to \"thin_tac\" to eliminate<br>\nthe extra assumptions from the final proof state. The tricky bit would<br>\nbe to figure out how to record which assumptions were matched by<br>\n\"assumption\", so you can tell \"thin_tac\" which ones to get rid of<br>\nlater.</p>\n<p>Unfortunately, most of the development effort now is focused on<br>\nIsar-style proofs with chained facts, and not so much on tactics for<br>\napply-style proofs. So I'd say it is unlikely that this feature will<br>\nbe implemented by the main Isabelle development team. But be sure to<br>\nreport back if you try to implement this yourself; I'm sure plenty of<br>\npeople would find it useful.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294100257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833534
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nBrian Huffman wrote:</p>\n<blockquote>\n<p>On Thu, Feb 25, 2010 at 10:04 AM, Peter Lammich<br>\n&lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I'm curious whether it is (easily) possible to apply elimination rules in<br>\nIsabelle that<br>\neliminate more than one premise.</p>\n<p>[...]<br>\n</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>I don't think there is any easy way to accomplish what you want to<br>\ndo---at least, I don't know of any already-implemented tactic in<br>\nIsabelle that does this. I do think such a tactic would be useful,<br>\nthough; I've wished for it a few times myself.</p>\n<p>It might be possible to implement such a tactic in ML. The obvious<br>\napproach of trying to generalize eresolve_tac probably won't work,<br>\nbecause eresolve_tac is implemented in terms of Thm.biresolution,<br>\nwhich is part of Isabelle's trusted kernel.</p>\n<p>You could probably define this tactic on top of eresolve_tac:<br>\nBasically you would do \"erule (n)\" (which is basically \"erule\" then<br>\n\"assumption\" n times) followed by n calls to \"thin_tac\" to eliminate<br>\nthe extra assumptions from the final proof state. The tricky bit would<br>\nbe to figure out how to record which assumptions were matched by<br>\n\"assumption\", so you can tell \"thin_tac\" which ones to get rid of<br>\nlater.</p>\n<p>Brian, Peter, et al,</p>\n</blockquote>\n<p>My solution of this \"tricky bit\" depends on an idea presented by Konrad <br>\nSlind<br>\nfor HOL at TPHOLs 2002, which was to annotate selected goals (or, more <br>\ngenerally, subterms) _within_ the logic.</p>\n<p>Thus for a long time I have used<br>\n  forget        :: \"'a =&gt; 'a\"<br>\n  forget_def : \"forget f == f\"<br>\nto stop a particular hypothesis being used in asm_simp_tac and <br>\nasm_full_simp_tac</p>\n<p>For this problem I defined</p>\n<p>keep_def : \"keep b f == f\"<br>\n  keep          :: \"bool =&gt; 'a =&gt; 'a\"</p>\n<p>val _ = <a href=\"http://ListPair.app\">ListPair.app</a> bind_thm ([\"keepD\", \"keepI\"], [keep_def] RL defDs) ;<br>\nval _ = bind_thm (\"keepTD\", read_instantiate [(\"b\", \"True\")] keepD) ;<br>\nval _ = bind_thm (\"keepFD\", read_instantiate [(\"b\", \"False\")] keepD) ;<br>\nval _ = bind_thm (\"keepF_thin\", keepFD RS thin_rl) ;</p>\n<blockquote>\n<p>keepTD ;<br>\nval it = \"keep True ?P ==&gt; ?P\" : Thm.thm</p>\n</blockquote>\n<blockquote>\n<p>keepFD ;<br>\nval it = \"keep False ?P ==&gt; ?P\" : Thm.thm</p>\n</blockquote>\n<blockquote>\n<p>keepF_thin ;<br>\nval it = \"[| keep False ?P; PROP ?W |] ==&gt; PROP ?W\" : Thm.thm</p>\n</blockquote>\n<p>(You should change the uses of bind_thm if you're using Isar).</p>\n<p>Then the tactic is as follows - it is no doubt rather inefficient, but <br>\nseems to work OK.<br>\nI've done the analogue of fatac which deletes all matched premises from <br>\nremaining subgoals because it's simpler to follow (datac already deleted <br>\nthe first matched premise, and eatac also matches the conclusion, which <br>\nI think is here an additional irrelevant complication).</p>\n<p>(* fetac : thm -&gt; int -&gt; int -&gt; tactic<br>\n  like fatac n but also deletes hypotheses matched *)<br>\nfun fetac th n sg st =<br>\n  let val fth = thin_rl RS (replicate n keepFD MRS th) : thm ;<br>\n    val subgoal = List.nth (prems_of st, sg - 1) : term ;<br>\n    (* turn all subgoal hypotheses H into keep ?b H *)<br>\n    val nhyps = length (Logic.strip_assums_hyp subgoal) ;<br>\n    val ktac = EVERY' (replicate nhyps (dtac keepI)) : int -&gt; tactic ;<br>\n    (* then apply ftac fth - see later *)<br>\n    (* then apply atac n times,<br>\n      which marks the hypotheses to be deleted with keep False *)<br>\n    val atacs = EVERY' (replicate n atac) ;<br>\n    (* treat other instances of keep ?b as keep True, and erase them *)<br>\n    val ekttac = REPEAT o dtac keepTD : int -&gt; tactic ;<br>\n    (* delete hypotheses which are (keep False ...) *)<br>\n    val ekftac = REPEAT o etac keepF_thin : int -&gt; tactic ;<br>\n    (* combine all the above *)<br>\n    val ctac = EVERY' [ktac, ftac fth, atacs] THEN_ALL_NEW    <br>\n      (ekttac THEN' ekftac) : int -&gt; tactic ;<br>\n  in ctac sg st end ;</p>\n<blockquote>\n<p>Unfortunately, most of the development effort now is focused on<br>\nIsar-style proofs with chained facts, and not so much on tactics for<br>\napply-style proofs. So I'd say it is unlikely that this feature will<br>\nbe implemented by the main Isabelle development team. But be sure to<br>\nreport back if you try to implement this yourself; I'm sure plenty of<br>\npeople would find it useful.</p>\n<p>I hope so.  Incidentally, on a related topic  - sometimes using etac I <br>\n_don't_ want the matched premise deleted from the resulting subgoals <br>\n(which is why all_dupE is given as an alternative to allE). </p>\n</blockquote>\n<p>To achieve this for any elimination rule, I have</p>\n<p>fun mk_dupE thE = zero_var_indexes (rotate_prems ~1<br>\n  (tacsthm [PRIMITIVE (fn th =&gt; th RS cut_rl), atac 1] thE)) ;</p>\n<p>thus mk_dupE allE is approximately all_dupE</p>\n<p>Regards,</p>\n<p>Jeremy</p>\n<blockquote>\n<ul>\n<li>Brian</li>\n</ul>\n</blockquote>",
        "id": 294100302,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833546
    },
    {
        "content": "<p>From: Stephan Merz &lt;<a href=\"mailto:Stephan.Merz@loria.fr\">Stephan.Merz@loria.fr</a>&gt;<br>\nI second this request. More precisely, I'd like to be able to annotate a rule such that it is applied by the automatic proof methods only if the first n hypotheses are present in the current proof state. As a simple example, consider bspec, which would make a perfect elimination rule when its two assumptions can be proved by assumption. As others have pointed out, it is not hard to write a tactic that applies a rule only if the first n hypotheses can be proved by assumption, however, I don't know how to make such a tactic work inside auto and friends.</p>\n<p>Thanks,<br>\nStephan</p>",
        "id": 294100379,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833577
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nStephan Merz wrote:<br>\nStephan,</p>\n<p>This is described in Section 10.4 of the Reference Manual.  (NOT the <br>\nIsar reference manual, the Isabelle Reference Manual). </p>\n<p>For bspec, addSD2 is exactly what you want.  (or maybe addD2). </p>\n<p>Modifying the current claset (or creating a new one) is used by all the <br>\ntactics involving the classical reasoning set, eg safe_tac, clarify_tac, <br>\nauto_tac, force_tac</p>\n<p>Jeremy</p>",
        "id": 294100435,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833595
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi Brian,</p>\n<p>Many thanks you for your answer.</p>\n<p>I adopted your proposal for my needs. However, I ran into a problem that <br>\nshould also be imminent in your proposal (?).<br>\nIf there are premises of the form !!x. _==&gt;_, they are counted in nhyps, <br>\nhowever dtac keepI will not unify against them, thus<br>\n   val ktac = EVERY' (replicate nhyps (dtac keepI)) : int -&gt; tactic ;<br>\nproduces premises that are doubly-wrapped into keep.</p>\n<p>What's the best way around?<br>\n  Only counting \"plain\" premises? (How?)<br>\n  Can keepI be defined to also wrap higher-order premises?</p>\n<p>Best,<br>\n  Peter</p>\n<p>Jeremy Dawson schrieb:</p>",
        "id": 294103006,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834344
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nPeter Lammich wrote:<br>\nDear Peter,</p>\n<p>I'm not quite sure if I understand you correctly.</p>\n<p>Are you talking about the situation where there is a premise (among the <br>\nlist of premises of a subgoal) of the form !!x. _==&gt;_ ? </p>\n<p>(Isn't this rather unusual - could I see an example of how this arises ?)</p>\n<p>Certainly, keep, as I defined it, won't wrap around a premise of the form<br>\n!!x. _==&gt;_ because such a premise is of type prop, not bool. </p>\n<p>Isabelle generally - I think - wasn't intended to work very much with <br>\nmeta-level stuff, and previously I have found that playing around with <br>\nmeta-level props instead of object level bools doesn't seem to work as <br>\nexpected.  However to my surprise the attached does seem to work - try <br>\nit out and see if it works on your problem example.</p>\n<p>Regards,</p>\n<p>Jeremy<br>\n<a href=\"/user_uploads/14278/FJ_kQ1ggFs21GSH3ZfvI2t_S/x\">x</a></p>",
        "id": 294103088,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834368
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;</p>\n<blockquote>\n<p>Dear Peter,</p>\n<p>I'm not quite sure if I understand you correctly.</p>\n<p>Are you talking about the situation where there is a premise (among <br>\nthe list of premises of a subgoal) of the form !!x. _==&gt;_ ?<br>\n(Isn't this rather unusual - could I see an example of how this arises ?)<br>\nExactly. I ran into this situation, when proving elimination rules <br>\n(e.g., on Isar, containing \"obtains\").</p>\n</blockquote>\n<p>lemma foo:<br>\n  assumes bla<br>\n  obtains x where \"bar x\"<br>\n  apply -<br>\n  ** You end up with a subgoal something like [| bla; !!x. bar x ==&gt; <br>\nthesis |] ==&gt; thesis</p>\n<blockquote>\n<p>Certainly, keep, as I defined it, won't wrap around a premise of the form<br>\n!!x. _==&gt;_ because such a premise is of type prop, not bool.<br>\nIsabelle generally - I think - wasn't intended to work very much with <br>\nmeta-level stuff, and previously I have found that playing around with <br>\nmeta-level props instead of object level bools doesn't seem to work as <br>\nexpected.  However to my surprise the attached does seem to work - try <br>\nit out and see if it works on your problem example.<br>\nThank you very much.<br>\nI certainly will try it. (For now, I modified the val nhyps=... to only <br>\ncount plain premises).</p>\n</blockquote>\n<p>Best,<br>\n  Peter</p>\n<blockquote>\n<p>Regards,</p>\n<p>Jeremy</p>\n</blockquote>",
        "id": 294103178,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834393
    }
]