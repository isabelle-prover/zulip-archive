[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nGoing back to this very abstract level of the original question on this <br>\nthread: Yes, two times false is fine as a default.</p>\n<p>These options correspond to the following variants of declaration commands <br>\nthat are described in the isar-ref manual:</p>\n<p>\\item @{command \"declaration\"}~@{text d} adds the declaration<br>\n   function @{text d} of ML type @{ML_type declaration}, to the current<br>\n   local theory under construction.  In later application contexts, the<br>\n   function is transformed according to the morphisms being involved in<br>\n   the interpretation hierarchy.</p>\n<p>If the @{text \"(pervasive)\"} option is given, the corresponding<br>\n   declaration is applied to all possible contexts involved, including<br>\n   the global background theory.</p>\n<p>\\item @{command \"syntax_declaration\"} is similar to @{command<br>\n   \"declaration\"}, but is meant to affect only ``syntactic'' tools by<br>\n   convention (such as notation and type-checking information).</p>\n<p>Makarius</p>\n<hr>\n<p><a href=\"http://stop-ttip.org\">http://stop-ttip.org</a>  925,664 people so far</p>\n<hr>",
        "id": 294319285,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926391
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear experts,</p>\n<p>what is the canonical way of turning a function</p>\n<p>add ::  key =&gt; value =&gt; Context.generic =&gt; Context.generic</p>\n<p>into a function of type \"key =&gt; value =&gt; local_theory =&gt; local_theory\"?</p>\n<p>Btw: The reason for the type of \"add\" is that it is the add-function for <br>\nsome generic data (i.e., something of the form \"structure Data = <br>\nGeneric_Data (...)\"). More specifically I have</p>\n<p>add key value = <a href=\"http://Data.map\">Data.map</a> (Symtab.update_new (key, value))</p>\n<p>Until now I used \"Local_Theory.declaration\" (and applied the obtained <br>\nmorphism to all elements of my \"value\", which happen to be terms or <br>\ntheorems). Although I have to admit that I'm clueless about the meaning <br>\nof the \"syntax\" and \"pervasive\" flags of \"Local_Theory.declaration\" (so <br>\nI just used \"false\" for both).</p>\n<p>Doing the above I obtain the function:</p>\n<p>add' key value =<br>\n     Local_Theory.declaration {syntax=false,pervasive=false} (fn phi =&gt;<br>\n       add x (apply phi value)</p>\n<p>which is itself of type \"key =&gt; value =&gt; local_theory =&gt; local_theory\".</p>\n<p>The reason why I'm asking is that I recently found out that my \"add\" <br>\nfunction is actually called 3 times every time \"add'\" is called and the <br>\nmorphism applied to \"value\" seems to be different the last time (i.e., <br>\nconstants, generated via \"BNF_LFP_Rec_Sugar.add_primrec\" that are <br>\n\"Const\"s as expected the first 2 times, are \"Free\"s the 3rd time).</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294321547,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927060
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nMaybe the real question is: How do I turn the free variables in \"consts\" <br>\nbelow, into proper constants?</p>\n<p>val ((cs, c_simps), lthy') =<br>\n     BNF_LFP_Rec_Sugar.add_primrec bindings equations lthy</p>\n<p>As a more concrete example take:</p>\n<p>local_setup {* fn lthy =&gt;<br>\nlet<br>\n   val cs = [Free (\"c\", @{typ \"'a list =&gt; 'a list =&gt; 'a list\"})]<br>\n   val equations = [<br>\n     @{prop \"c ([]::'a list) (ys::'a list) = ([]::'a list)\"}]<br>\n   val bindings = map ((fn (name,ty) =&gt; (<a href=\"http://Binding.name\">Binding.name</a> name, SOME ty, <br>\nNoSyn)) o dest_Free) cs;<br>\n   val equations' = map (pair Attrib.empty_binding) equations;<br>\n   val ((cs, c_simps), lthy') =<br>\n     BNF_LFP_Rec_Sugar.add_primrec bindings equations' lthy;<br>\n   val _ = @{print} (cs, c_simps)<br>\nin<br>\n   lthy'<br>\nend<br>\n*}</p>\n<p>Where the @{print} shows \"c\" as \"Free\". What is the proper way of <br>\nturning this into a \"Const\"?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294321574,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927070
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nHi Christian,</p>\n<p>usually there is no need to \"turn free variables into proper constants\". <br>\nThings should mostly happen automagically at the package's boundaries.</p>\n<p>One exception is when you need polymorphism. This is actually quite <br>\noften the case in the new (co)datatype package. To get the polymorphic <br>\nconstants we use lthy' = Local_Theory.restore lthy after the <br>\ndeclaration, and apply the difference morphism between lthy' and lthy to <br>\nthe free variable (c.f. src/HOL/Tools/BNF/bnf_lfp.ML for some examples, <br>\ngrep for Local_Theory.define).</p>\n<p>Ondřej Kunčar uses a slightly different idiom involving <br>\nLocal_Theory.target_morphism in his code (c.f. <br>\nsrc/HOL/Tools/Lifting/lifting_def.ML), which is supposed to be slightly <br>\nless invasive than Local_Theory.restore [1]. But I'm also not sure if <br>\ntarget_morphism is what one wants in any situation.</p>\n<p>In your case, I assume that your need to turn Frees into Consts is <br>\ncaused by the mismatch in the output of the primrec package (mentioned <br>\nin [2]). If this is the case, I recommend to work with a forthcoming <br>\n(tomorrow) development version of Isabelle, where this mismatch will vanish.</p>\n<p>Dmitriy</p>\n<p>[1] The invasiveness of restore shows up, e.g. here: <br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2014-August/msg00200.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2014-August/msg00200.html</a><br>\n[2] <br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2014-October/msg00145.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2014-October/msg00145.html</a></p>",
        "id": 294321600,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927076
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Dmitriy,</p>\n<p>actually I also need polymorphism (hence Const instead of Free) since I <br>\nget type errors (for different instances) otherwise. So, thanks for the <br>\nhints! I'll look into the two different possibilities you indicated.</p>\n<p>Rene's thread ([2] in your email) seems to indicate that in the same <br>\nsituation the function package uses Free variables for the defined <br>\n\"constant\" as well as in its simplification rule. Is that canonical <br>\nbehaviour? If yes, any hints on its advantages compared to declaring a <br>\nConst?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294321613,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927080
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<p>this is quire regular: usually a declaration in a local theory has<br>\neffect on three levels:</p>\n<ol>\n<li>the background theory</li>\n<li>the target context itself</li>\n<li>the hypothetical surface context (hence the »Free«s)</li>\n</ol>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/qkOSlg5ORaaxDlZCptItqxw_/signature.asc\">signature.asc</a></p>",
        "id": 294321807,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927143
    }
]