[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I have a string s such as \"refl[of x]\" and would like to write an ML <br>\nfunction that parses this string and returns the corresponding theorem <br>\n(the same theorem that, e.g., the thm command would show, in this case <br>\n\"x=x\").</p>\n<p>Note: the string is not known at compile time, so the antiquotation <br>\n@{thm refl[of x]} is not what I need. Also, Thm.infer_instantiate is not <br>\nwhat I need because use of \"of\" is just an example. I want to be able to <br>\nuse any attribute, e.g., OF, simplified, abs_def, ...</p>\n<p>(Proof_Context.get_fact ctxt (Facts.named s) would work if there were no <br>\nattributes, but not with attributes.)</p>\n<p>I tried the following:</p>\n<p>ML ‹<br>\n    val toks = Token.explode0 (Thy_Header.get_keywords' \\&lt;^context&gt;)<br>\n    \"refl[of x]\"<br>\n    val (parsed,leftover) = Scan.catch Parse.thm toks (* [of x] is not<br>\n    parsed (stays in leftover) *)<br>\n    val fact = Attrib.eval_thms \\&lt;^context&gt; [parsed] (* Gives me<br>\n    \"?t=?t\", not \"x=x\" *)<br>\n    ›</p>\n<p>But this does not give me the correct result (see the comments in the ML <br>\nsource).</p>\n<p>What would be the correct approach be?</p>\n<p>(Background: I need this for my qrhl-tool <br>\n&lt;<a href=\"https://github.com/dominique-unruh/qrhl-tool\">https://github.com/dominique-unruh/qrhl-tool</a>&gt;. The user can specify the <br>\nnames of facts on the qrhl-tool side, and the fact is retrieved via <br>\nlibisabelle from Isabelle.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294756412,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661197688
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I have a string s such as \"refl[of x]\" and would like to write an ML <br>\nfunction that parses this string and returns the corresponding theorem <br>\n(the same theorem that, e.g., the thm command would show, in this case <br>\n\"x=x\").</p>\n<p>Note: the string is not known at compile time, so the antiquotation <br>\n@{thm refl[of x]} is not what I need. Also, Thm.infer_instantiate is not <br>\nwhat I need because use of \"of\" is just an example. I want to be able to <br>\nuse any attribute, e.g., OF, simplified, abs_def, ...</p>\n<p>(Proof_Context.get_fact ctxt (Facts.named s) would work if there were no <br>\nattributes, but not with attributes.)</p>\n<p>I tried the following:</p>\n<p>ML ‹<br>\n    val toks = Token.explode0 (Thy_Header.get_keywords' \\&lt;^context&gt;)<br>\n    \"refl[of x]\"<br>\n    val (parsed,leftover) = Scan.catch Parse.thm toks (* [of x] is not<br>\n    parsed (stays in leftover) *)<br>\n    val fact = Attrib.eval_thms \\&lt;^context&gt; [parsed] (* Gives me<br>\n    \"?t=?t\", not \"x=x\" *)<br>\n    ›</p>\n<p>But this does not give me the correct result (see the comments in the ML <br>\nsource).</p>\n<p>What would be the correct approach be?</p>\n<p>(Background: I need this for my qrhl-tool <br>\n&lt;<a href=\"https://github.com/dominique-unruh/qrhl-tool\">https://github.com/dominique-unruh/qrhl-tool</a>&gt;. The user can specify the <br>\nnames of facts on the qrhl-tool side, and the fact is retrieved via <br>\nlibisabelle from Isabelle.)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294756423,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661197694
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I found a solution by try and error but I would be curious to hear from <br>\nan expert whether it is the correct way (it seems somewhat ad-hoc).</p>\n<p>ML ‹<br>\n    val toks = Token.explode0 (Thy_Header.get_keywords' \\&lt;^context&gt;)<br>\n    \"refl[of x]\" |&gt; filter (not o Token.is_blank) |&gt; (fn t =&gt; t @<br>\n    [Token.eof])<br>\n    val (parsed,leftover) = Scan.catch Parse.thm toks (* leftover is<br>\n    [Token.eof] *)<br>\n    val fact = Attrib.eval_thms \\&lt;^context&gt; [parsed] (* Gives \"x=x\" *)<br>\n    ›</p>\n<p>The difference to my failed approach from my previous mail (below) is <br>\nthat I now filter out all tokens that are spaces after tokenizing <br>\n(filter (not o Token.is_blank)).</p>\n<p>Additionally, we need to append an EOF (fn t =&gt; t @ [Token.eof]) so that <br>\nparsing does not fail for strings without attributes (e.g., \"refl\").</p>\n<p>Best wishes,<br>\nDominique.</p>\n<p>PS: For completeness, here is the whole thing packaged as an ML <br>\nfunction, with error handling:</p>\n<p>fun get_thms ctxt spec = let<br>\n   val toks = Token.explode0 (Thy_Header.get_keywords' ctxt) spec<br>\n              |&gt; filter (not o Token.is_blank)<br>\n              |&gt; (fn t =&gt; t @ [Token.eof])<br>\n   val (parsed,leftover) = Scan.catch Parse.thm toks<br>\n   val _ = case leftover of [eof] =&gt; ()<br>\n           | _ =&gt; error (\"Error parsing theorem name \\\"\" ^ spec ^<br>\n                 \"\\\". Leftover tokens: \" ^ Pretty.string_of <br>\n(Token.pretty_src ctxt leftover))<br>\n   val fact = Attrib.eval_thms ctxt [parsed]<br>\nin fact end</p>",
        "id": 294756445,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661197706
    }
]