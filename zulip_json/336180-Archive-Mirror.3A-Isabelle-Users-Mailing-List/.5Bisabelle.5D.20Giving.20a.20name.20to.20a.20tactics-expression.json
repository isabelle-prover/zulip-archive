[
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nMakarius wrote:</p>\n<blockquote>\n<p>On Fri, 19 Feb 2010, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>Basically, it seems that methods can be combined in these sorts of <br>\nways, but it is hidden in the source code, which is essentially <br>\nundocumented. erule is<br>\nMethod.erule ;<br>\nval it = fn : int -&gt; Thm.thm list -&gt; Method.method</p>\n<p>combining methods uses</p>\n<blockquote>\n<p>Method.Then ;<br>\nval it = fn : Method.text list -&gt; Method.text<br>\nMethod.Try ;<br>\nval it = fn : Method.text -&gt; Method.text<br>\nMethod.Repeat1 ;<br>\nval it = fn : Method.text -&gt; Method.text</p>\n</blockquote>\n<p>You then have to work out how to get between a method and a Method.text</p>\n<p>One way would use</p>\n<blockquote>\n<p>Method.Basic ;<br>\nval it = fn : (ProofContext.context -&gt; Method.method) -&gt; Method.text</p>\n</blockquote>\n</blockquote>\n<p>Method.text merely models the Isar source representation of method <br>\nexpressions.  This is hardly useful in user-space.</p>\n<p>Well, that is useful information of a negative nature.  It tells me how <br>\nyou _don't_  do the following:</p>\n</blockquote>\n<p>val meth4 = EVERY [(TRY (REPEAT1 meth1)), meth2, meth3 ] ;</p>\n<p>But the question is how _do_ you do it.</p>\n<blockquote>\n<p>BTW, when reading the ML sources -- which are always written to be <br>\nread by humans -- you need to look both bottom-up and top-down.  In <br>\nparticular, checking for common uses of certain operations helps to <br>\ninfer their semantics (the sources themselve cannot say \"this is used <br>\nfor blah blah\" without violating modularity).<br>\nIt's true that saying \"this is used for blah blah\" is one of the three <br>\naspects to documenting a function, and it is certainly true that it is a <br>\nmoot point as to where it should go.  I've not come across the <br>\nsuggestion that as a consequence it should be omitted completely.  In <br>\nany case, the other two aspects of documenting a function are equally <br>\nabsent from most of the Isabelle source code. <br>\nIf you grep for Method.Then for example, you will immediately see that <br>\nonly the Isar infrastructure itself ever uses it, so we can ignore it <br>\nhere.</p>\n<blockquote>\n<p>Incidentally all the above code is Isabelle2007, some of it also <br>\nchanged to make some functions visible.<br>\nIn Isabelle2009 I've cleaned up the main method_setup (and <br>\nMethod.setup) interfaces.  If you just grep for either of these in the <br>\nexisting sources, you will get an idea how it is usually done.  (These <br>\nhigh-level entries are also covered in the manuals, with some minimal <br>\nexamples.)<br>\nAs far as I can see, method_setup and Method.setup are relevant only <br>\nwhen you already have the method you want to use.  If I'm wrong it may <br>\nbe because I haven't spent any longer examining the sources.  But <br>\nexamining (undocumented) sources is not the normal way to find out what <br>\na piece of software does.</p>\n</blockquote>\n</blockquote>\n<p>Jeremy</p>\n<blockquote>\n<p>Makarius<br>\n</p>\n</blockquote>",
        "id": 294099149,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833234
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou don't, but go down to the basic tactics behind meth1, meth2, meth3. <br>\n(All tools are supposed to export this ML view, apart from defining <br>\nend-user method syntax.)</p>\n<p>Isar methods are a more stylized way of refining structured goals than <br>\ntactics, and things like fine-grained goal addressing is missing.  This <br>\nmakes user space method expressions more digestible than old tactical ones <br>\n-- you certainly know how proof scripts looked 10 years ago -- but on the <br>\nother hand it is harder to define meaningful method combinations.</p>\n<p>So just compose things as a tactic and then link it up with Isar via <br>\nmethod_setup.  There are plenty of examples in the sources -- most of them <br>\nquite clean, because I've reworked these interfaces for Isabelle2009.</p>\n<p>Makarius</p>",
        "id": 294099465,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833325
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all.<br>\n[Apologies if this question already was on this list some time ago]</p>\n<p>Is there a way to give a short name to a complex tactic-expression. I <br>\nhave, e.g., the following pattern that I frequently use.<br>\n  apply (((erule (1) lemma1)+)?,erule lemma2,simp)+</p>\n<p>Lemma1 and lemma2 are two (fixed) lemmas proven in my theory.</p>\n<p>Instead, I would like to write something like:<br>\n    define_method my_method = (((erule (1) lemma1)+)?,erule lemma2,simp)+<br>\n  and later:<br>\n    apply (my_method)</p>\n<p>However, the only way I know is something like:<br>\nmethod_setup my_method = {* &lt;Some scary ML-code, much more boilerplate <br>\nthan the above tactics-expression, and much more complicated to read and <br>\nwrite if one does not know the ML-interface by heart&gt; *} \"...\"</p>\n<p>Is there a way without manually translating the above Tactics-expression <br>\nto ML code?</p>\n<p>Regards and thanks,<br>\n  Peter</p>",
        "id": 294101871,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834020
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nPeter Lammich schrieb:</p>\n<blockquote>\n<p>Is there a way to give a short name to a complex tactic-expression. I <br>\nhave, e.g., the following pattern that I frequently use.<br>\n apply (((erule (1) lemma1)+)?,erule lemma2,simp)+</p>\n<p>Trying to translate it to ML, I cannot find any ML-tactics equivalent <br>\nfor \"erule (1)\". There is only etac, but this seems to have no number of <br>\nadditional premises.</p>\n</blockquote>\n<p>Regards &amp; Thanks,<br>\n  Peter</p>\n<blockquote>\n<p>Lemma1 and lemma2 are two (fixed) lemmas proven in my theory.</p>\n<p>Instead, I would like to write something like:<br>\n   define_method my_method = (((erule (1) lemma1)+)?,erule lemma2,simp)+<br>\n and later:<br>\n   apply (my_method)</p>\n<p>However, the only way I know is something like:<br>\nmethod_setup my_method = {* &lt;Some scary ML-code, much more boilerplate <br>\nthan the above tactics-expression, and much more complicated to read <br>\nand write if one does not know the ML-interface by heart&gt; *} \"...\"</p>\n<p>Is there a way without manually translating the above <br>\nTactics-expression to ML code?</p>\n<p>Regards and thanks,<br>\n Peter</p>\n</blockquote>",
        "id": 294101885,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834025
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 18 Feb 2010, Peter Lammich wrote:</p>\n<blockquote>\n<p>Is there a way without manually translating the above Tactics-expression <br>\nto ML code?</p>\n</blockquote>\n<p>Not really.  Isar was introduced to overcome adhoc \"scripting\" of proofs, <br>\nand there is a carefully chosen terminology to emphasize this (\"proof <br>\ntext\" and \"proof method\", instead of the more primitive \"proof script\" and <br>\n\"tactic\"). This was just one further step to less operational detail <br>\ncompared to old-style ML tactics of classic Isabelle/HOL, which was <br>\nalready much more stylized in 1998 than original HOL with its huge numbers <br>\nof small tactics and tacticals.</p>\n<p>Comparing formalizations from these different eras, my general impression <br>\nis that people now achieve more with the more abstract means of Isar, and <br>\nthe results are checked faster and easier to maintain. Nonetheless, there <br>\nis still a lack of serious interactive proof development support, say some <br>\nkind of \"prover IDE\" that deserves this name.</p>\n<blockquote>\n<p>Is there a way to give a short name to a complex tactic-expression. I have, <br>\ne.g., the following pattern that I frequently use.<br>\napply (((erule (1) lemma1)+)?,erule lemma2,simp)+</p>\n<p>Lemma1 and lemma2 are two (fixed) lemmas proven in my theory.</p>\n<p>Instead, I would like to write something like:<br>\n  define_method my_method = (((erule (1) lemma1)+)?,erule lemma2,simp)+<br>\nand later:<br>\n  apply (my_method)</p>\n<p>However, the only way I know is something like: method_setup my_method = <br>\n{* &lt;Some scary ML-code, much more boilerplate than the above <br>\ntactics-expression, and much more complicated to read and write if one <br>\ndoes not know the ML-interface by heart&gt; *} \"...\"</p>\n</blockquote>\n<p>Designing (and implementing) Isar proof methods needs some care, this is <br>\nnot for quick scripting.</p>\n<p>First of all, in many situations, the intended goal refinement can be <br>\nachieve more declaratively, e.g. by deriving suitable compound rules, or <br>\nfeeding certain rules to simp/fast/blast/auto etc. with intro/elim/iff <br>\ndeclarations.</p>\n<p>If you really need to define a goal refinement macro, you can actually<br>\ngive a name to a tactic (not a complex method expression as in the example <br>\nabove).  E.g. like this:</p>\n<p>ML {* val my_tac = REPEAT o (rtac @{thm foo} THEN' (TRY o atac)) *}</p>\n<p>and use it later via the \"tactic\" method, e.g. like this:</p>\n<p>lemma True<br>\n   apply (tactic {* my_tac 1 *})</p>\n<p>This still looks a bit scary, but the overhead for argument parsing is <br>\navoided.</p>\n<p>If you explain your application more specifically, it is easier to say <br>\nwhat is really needed.</p>\n<p>Makarius</p>",
        "id": 294101923,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834037
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe numbers merely specify additional assumption steps -- which used to be <br>\na very common idiom in old-style tactic scripts.  (In Isar, reasoning by <br>\nassumption is usually implicit in the proof structure, e.g. after closing <br>\na 'by'.)</p>\n<p>The low-level tactic is called assume_tac.</p>\n<p>Makarius</p>",
        "id": 294101955,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834047
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nPeter Lammich wrote:</p>\n<blockquote>\n<p>Hi all.<br>\n[Apologies if this question already was on this list some time ago]</p>\n<p>Is there a way to give a short name to a complex tactic-expression. I <br>\nhave, e.g., the following pattern that I frequently use.<br>\n apply (((erule (1) lemma1)+)?,erule lemma2,simp)+</p>\n<p>Lemma1 and lemma2 are two (fixed) lemmas proven in my theory.</p>\n<p>Instead, I would like to write something like:<br>\n   define_method my_method = (((erule (1) lemma1)+)?,erule lemma2,simp)+<br>\n and later:<br>\n   apply (my_method)</p>\n<p>However, the only way I know is something like:<br>\nmethod_setup my_method = {* &lt;Some scary ML-code, much more boilerplate <br>\nthan the above tactics-expression, and much more complicated to read <br>\nand write if one does not know the ML-interface by heart&gt; *} \"...\"</p>\n<p>Is there a way without manually translating the above <br>\nTactics-expression to ML code?</p>\n<p>Basically, it seems that methods can be combined in these sorts of ways, <br>\nbut it is hidden in the source code, which is essentially undocumented. </p>\n</blockquote>\n<p>erule is<br>\n Method.erule ;<br>\nval it = fn : int -&gt; Thm.thm list -&gt; Method.method</p>\n<p>combining methods uses</p>\n<blockquote>\n<p>Method.Then ;<br>\nval it = fn : Method.text list -&gt; Method.text<br>\nMethod.Try ;<br>\nval it = fn : Method.text -&gt; Method.text<br>\nMethod.Repeat1 ;<br>\nval it = fn : Method.text -&gt; Method.text</p>\n</blockquote>\n<p>You then have to work out how to get between a method and a Method.text</p>\n<p>One way would use</p>\n<blockquote>\n<p>Method.Basic ;<br>\nval it = fn : (ProofContext.context -&gt; Method.method) -&gt; Method.text</p>\n</blockquote>\n<p>The other way, it seems I never finished figuring it out (I looked at <br>\nthis sort of stuff some years ago, and pretty much gave up on it, so I <br>\ndecided to stick to using tactics directly - which are all described in <br>\nthe Reference Manual).</p>\n<p>The problem may be that a Method.text seems to be applied directly, not <br>\nby turning it into a method, see</p>\n<blockquote>\n<p>Proof.apply ;<br>\nval it = fn : Method.text -&gt; Proof.state -&gt; Proof.state Seq.seq</p>\n</blockquote>\n<p>(which uses<br>\n Method.apply ;<br>\n val it = fn : Method.method -&gt; Thm.thm list -&gt; RuleCases.tactic<br>\nbut unfortunately not by creating a single compound method en route)</p>\n<p>(Incidentally all the above code is Isabelle2007, some of it also <br>\nchanged to make some functions visible).</p>\n<p>If you can use a compound tactic, it would be much easier.<br>\nMethod.erule is based on Tactic.eresolve_tac, plus some other stuff, <br>\nincluding doing something with facts.  If you can do without the other <br>\nstuff, just use tactics and the tactic combinators - so then it would <br>\nlook like</p>\n<p>EVERY' [(TRY o REPEAT1 o eatac lemma1 1), etac lemma2, Simp_tac ] 1 ;</p>\n<p>Jeremy</p>\n<blockquote>\n<p>Regards and thanks,<br>\n Peter</p>\n</blockquote>",
        "id": 294101959,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834049
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 19 Feb 2010, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>Basically, it seems that methods can be combined in these sorts of ways, but <br>\nit is hidden in the source code, which is essentially undocumented. <br>\nerule is<br>\nMethod.erule ;<br>\nval it = fn : int -&gt; Thm.thm list -&gt; Method.method</p>\n<p>combining methods uses</p>\n<blockquote>\n<p>Method.Then ;<br>\nval it = fn : Method.text list -&gt; Method.text<br>\nMethod.Try ;<br>\nval it = fn : Method.text -&gt; Method.text<br>\nMethod.Repeat1 ;<br>\nval it = fn : Method.text -&gt; Method.text</p>\n</blockquote>\n<p>You then have to work out how to get between a method and a Method.text</p>\n<p>One way would use</p>\n<blockquote>\n<p>Method.Basic ;<br>\nval it = fn : (ProofContext.context -&gt; Method.method) -&gt; Method.text</p>\n</blockquote>\n</blockquote>\n<p>Method.text merely models the Isar source representation of method <br>\nexpressions.  This is hardly useful in user-space.</p>\n<p>BTW, when reading the ML sources -- which are always written to be read by <br>\nhumans -- you need to look both bottom-up and top-down.  In particular, <br>\nchecking for common uses of certain operations helps to infer their <br>\nsemantics (the sources themselve cannot say \"this is used for blah blah\" <br>\nwithout violating modularity).  If you grep for Method.Then for example, <br>\nyou will immediately see that only the Isar infrastructure itself ever <br>\nuses it, so we can ignore it here.</p>\n<blockquote>\n<p>Incidentally all the above code is Isabelle2007, some of it also changed <br>\nto make some functions visible.</p>\n</blockquote>\n<p>In Isabelle2009 I've cleaned up the main method_setup (and Method.setup) <br>\ninterfaces.  If you just grep for either of these in the existing sources, <br>\nyou will get an idea how it is usually done.  (These high-level entries <br>\nare also covered in the manuals, with some minimal examples.)</p>\n<p>Makarius</p>",
        "id": 294101973,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834055
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nPeter Lammich wrote:<br>\nI was under the impression that erule (1) was just (erule,assumption) <br>\nwhich then would translate to \"etac some_rule THEN' atac\" in ML.</p>\n<p>In any case, check out Christian's example from the Isabelle Developer <br>\nWorkshop, where he shows an example translation from apply-style proof <br>\nscript to ML method: <a href=\"http://tphols.in.tum.de/IDW/CU-Ex1.thy\">http://tphols.in.tum.de/IDW/CU-Ex1.thy</a></p>\n<p>And also look at Makarius's slides/examples on proof methods. Available <br>\nhere:<br>\n<a href=\"http://tphols.in.tum.de/idw.html\">http://tphols.in.tum.de/idw.html</a></p>\n<p>I've found these practical examples have helped me much more than the <br>\nreference manual. Once I understood what the point of the exercise was, <br>\nthe reference manual started to help instead of confuse.</p>\n<p>Good luck!</p>\n<p>Rafal Kolanski.</p>",
        "id": 294102036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834080
    }
]