[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>In my proof, at several positions, there occurs a step like this:<br>\n      apply (<br>\n        (intro exI conjI),<br>\n        (subst (0) m_intro, simp only: m_moves, simp only: m_simps, <br>\n(rule compress_u_a[THEN tranclp_into_rtranclp] | rule <br>\nelim_use_chain_a[THEN tranclp_into_rtranclp] | erule apply_next_a[THEN <br>\ntranclp_into_rtranclp] ))+,<br>\n        (rule rtranclp.intros),<br>\n        (subst (0) m_intro, simp only: m_moves, simp only: m_simps, <br>\n(rule compress_u_a[THEN tranclp_into_rtranclp] | rule <br>\nelim_use_chain_a[THEN tranclp_into_rtranclp] | erule apply_next_a[THEN <br>\ntranclp_into_rtranclp] ))+,<br>\n        (simp add: Un_ac)<br>\n      )</p>\n<p>And I fear this step will even get longer in the future, but it's always <br>\nthe same step.<br>\nIs there a way to give this a symbolic name once, and then refer to the <br>\nstep via this symbolic name ?</p>\n<p>If the only way of doing so should be by converting this to an <br>\nML-tactical [As indicated in Christian Urban's mail of 2007-09-03], then <br>\nregard this mail as a feature request:<br>\n  A nice feature would be:</p>\n<p>define my_tactical = tactical_expression</p>\n<p>and then use:</p>\n<p>apply my_tactical </p>\n<p>instead of</p>\n<p>apply tactical_expression</p>\n<p>Best regards<br>\n  Peter</p>",
        "id": 294065839,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825426
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust to get the terminology right:</p>\n<p>* A tactic is a function that maps a goal state to a lazy sequence of <br>\n    potential successor state, with ML type tactic = thm -&gt; thm Seq.seq;<br>\n    tactics with explicit sub-goal addressing are also quite common, and <br>\n    have type int -&gt; tactic unsurprisingly.</p>\n<p>* A tactical is a combinator for tactics, e.g. THEN, ORELSE, REPEAT.</p>\n<p>* A proof method (in Isar) is a tactic that refers to an explicit proof <br>\n    context and a list of immediate facts to be \"used\" in the goal <br>\n    refinement.</p>\n<p>The ML type is essentially Proof.context -&gt; thm list -&gt; tactic.<br>\n    Methods handle goal addressing internally.  \"Methodicals\" are limited <br>\n    to regular expression combinators: \",\", \"|\", \"+\".    </p>\n<p>What you descrive above is a way to define your own methods.  In <br>\nIsabelle/Isar almost everything is \"defined\" in that sense anyway, and you <br>\ncan introduce methods on your own.  See the 'method_setup' command in the <br>\nisar-ref manual or the existing theory sources.</p>\n<p>When implementing a method, the implementation body works with ML tactics <br>\nand tacticals, wrapped into method syntax.</p>\n<p>Makarius</p>",
        "id": 294065842,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825432
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nPeter Lammich wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>In my proof, at several positions, there occurs a step like this:<br>\n     apply (<br>\n       (intro exI conjI),<br>\n       (subst (0) m_intro, simp only: m_moves, simp only: m_simps, <br>\n(rule compress_u_a[THEN tranclp_into_rtranclp] | rule <br>\nelim_use_chain_a[THEN tranclp_into_rtranclp] | erule apply_next_a[THEN <br>\ntranclp_into_rtranclp] ))+,<br>\n       (rule rtranclp.intros),<br>\n       (subst (0) m_intro, simp only: m_moves, simp only: m_simps, <br>\n(rule compress_u_a[THEN tranclp_into_rtranclp] | rule <br>\nelim_use_chain_a[THEN tranclp_into_rtranclp] | erule apply_next_a[THEN <br>\ntranclp_into_rtranclp] ))+,<br>\n       (simp add: Un_ac)<br>\n     )</p>\n<p>And I fear this step will even get longer in the future, but it's <br>\nalways the same step.<br>\nIs there a way to give this a symbolic name once, and then refer to <br>\nthe step via this symbolic name ?</p>\n<p>If the only way of doing so should be by converting this to an <br>\nML-tactical [As indicated in Christian Urban's mail of 2007-09-03], <br>\nthen regard this mail as a feature request:<br>\n A nice feature would be:</p>\n<p>define my_tactical = tactical_expression</p>\n<p>and then use:</p>\n<p>apply my_tactical<br>\n   instead of</p>\n<p>apply tactical_expression</p>\n<p>Best regards<br>\n Peter</p>\n<p>Peter,</p>\n</blockquote>\n<p>This is exactly the sort of thing that is readily available in Standard <br>\nML, without requesting any new feature.  In fact, ML was originally <br>\nconceived to develop proof tactics in the  LCF theorem prover (from <br>\nwhich, I gather, HOL and Isabelle originated).  In fact, HOL was first <br>\nrecommended to me, many years ago, on the grounds that it used a \"real <br>\nlanguage\" as its user interface language.</p>\n<p>The features designed into ML made it become also a general purpose <br>\nfunctional programming language as well as a user interaction language <br>\nfor theorem provers.<br>\nIt remains a highly effective language for combining tactics in various <br>\nways.</p>\n<p>Regards,</p>\n<p>Jeremy</p>\n<p>&lt;<a href=\"http://en.wikipedia.org/wiki/LCF_theorem_prover\">http://en.wikipedia.org/wiki/LCF_theorem_prover</a>&gt;<br>\n&gt;<br>\n&gt;<br>\n&gt;<br>\n&gt;</p>",
        "id": 294065934,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825462
    }
]