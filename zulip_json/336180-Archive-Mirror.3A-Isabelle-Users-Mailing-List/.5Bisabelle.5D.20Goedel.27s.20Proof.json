[
    {
        "content": "<p>From: Jens Doll &lt;<a href=\"mailto:jd@cococo.de\">jd@cococo.de</a>&gt;<br>\nHello all,</p>\n<p>now I've got 50 JAVA/C functions similar to</p>\n<p>----------- function 1 out of 46 -------------------<br>\n   //--------------------------------------<br>\n   //  1. Proposition<br>\n   // x is divisible by y<br>\n   //--------------------------------------<br>\n   BOOL divisible(NAT x, NAT y) {<br>\n     NAT i;<br>\n     for (i=1;(i&lt;=y);i++)<br>\n       if (x==y*z)<br>\n         return TRUE;<br>\n     return FALSE;}<br>\n--------------------- end of function------------------------------</p>\n<p>and I don't know how to transpose them into Isabelle proofs/theorems <br>\neffectively.</p>\n<p>Is anyone interested and willing to help me investigate the stuff?</p>\n<p>Jens<br>\n<a href=\"http://cococo.de\">http://cococo.de</a></p>",
        "id": 294162511,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853662
    },
    {
        "content": "<p>From: Jens Doll &lt;<a href=\"mailto:jd@cococo.de\">jd@cococo.de</a>&gt;<br>\nThanks, John, it was an error in transcription. Here are the first three.I<br>\nhope the html marking will also be transmitted ..  </p>\n<p>//--------------------------------------  <br>\n// 1\\. Proposition  <br>\n// x is divisible by y  <br>\n//--------------------------------------  <br>\nBOOL divisible(NAT x, NAT y) {  <br>\nNAT z;  <br>\nfor (z=1;(z&lt;=y);z++)  <br>\nif (x==y*z)  <br>\nreturn TRUE;  <br>\nreturn FALSE;}</p>\n<p>//--------------------------------------  <br>\n// 2\\. Proposition  <br>\n// x is a prime number  <br>\n//--------------------------------------  <br>\nBOOL Prim(NAT x) {  <br>\nNAT z;  <br>\nfor (z=1;(z&lt;=x);z++)  <br>\nif (z!=1)  <br>\nif (z!=x)  <br>\nreturn TRUE;  <br>\nreturn FALSE;}</p>\n<p>//--------------------------------------  <br>\n// 3\\. Function  <br>\n// the n-th prime number contained in x  <br>\n//--------------------------------------  <br>\nNAT Pr2(NAT n, NAT x) {  <br>\nNAT y;  <br>\nif (n==0) return 0;  <br>\nelse {  <br>\nn=0;  <br>\nfor (y=1;(y&lt;=x);y++) {  <br>\nn=n+1;  <br>\nif (Prim(y))  <br>\nif (divisible(x,y))  <br>\nif (y&gt;Pr2(n-1,x))  <br>\nreturn y;  <br>\n}  <br>\n}  </p>\n<p>return 0;}</p>\n<p>Best Regards<br>\n    Jens Doll</p>\n<p><code>Am 26.06.2012 09:08, schrieb John Wickerson:  \n</code><br>\n<a href=\"/user_uploads/14278/7Xnh9mVR2r-tYY6ZCL0FBC0f/Goedel.jpg\">Goedel.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/7Xnh9mVR2r-tYY6ZCL0FBC0f/Goedel.jpg\" title=\"Goedel.jpg\"><img src=\"/user_uploads/14278/7Xnh9mVR2r-tYY6ZCL0FBC0f/Goedel.jpg\"></a></div>",
        "id": 294162654,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853706
    },
    {
        "content": "<p>From: Jens Doll &lt;<a href=\"mailto:jd@cococo.de\">jd@cococo.de</a>&gt;<br>\nDear Isabelle users,  </p>\n<p>in order to have an imagination of what Kurt Goedel achieved in 1930 when he<br>\nproved that formally undecidable propositions (of Principia Mathematica)<br>\nexist, I did some implementation work based on his 46+ functions used in the<br>\nproof. I constructed macros EXISTS and FORALL and implemented them practically<br>\nas C functions (with some natural number arithmetic), where an EXISTS consists<br>\nof simple counting and testing all possibilities. Soon after having<br>\nimplemented and run some of these functions I came to a very practical border:<br>\nfunctions like Gl n x or Typ x, where x is a supposed to be a sequence of<br>\nnumbers, are practically not computable. Despite of that I have an<br>\nintermediate result consisting of  </p>\n<p>* the <strong>[46+ functions](cid:part1.06090203.07080202@cococo.de)</strong> as EXISTS/FORALL macros, <strong>a formal language</strong> (aiming at Isabelle)<br>\n  * a little <strong><a href=\"http://cococo.de/Context_IT_GmbH/index.jsp?content=goedel\">windows program</a>* </strong>which <strong>implements</strong> these functions (caveat, only the simple ones come to completion!)<br>\n  * a command line interface for <strong>natural number processing</strong> , e.g. &gt;goedel pow 12 1500 gives the digit sequence of attachment 1  </p>\n<p>If anyone should be interested in these software artefacts or is willing to<br>\nmake an Isabelle proof out of them (!!), he/she is invited to comment them or<br>\ngive a different feedback to me - thanks.  </p>\n<p>Happy reasoning,  <br>\nJens  </p>\n<ul>\n<li>an additional Linux implementation should be easy ...  </li>\n</ul>\n<p>\\-----------------------------------------------------------------------------------<br>\nattachment 1<br>\n\\--------------------------------------------------------------------------------------------------------------  </p>\n<blockquote>\n<p>goedel pow 12 1500  <br>\n59138332051041477857792134235669290840410130588006373166053589671727698902916332833359397148803993897326677281721126293  <br>\n773322423135275557345849997217508590192922491779070006392158472368759550821361036830323955751973780218814376420216153519  <br>\n444121554642854107036061566289075722709397810120974839954179767258632289195024519205509694080262900521148298534500308836  <br>\n228876765787453701167920379162857176687286340763959746406235760412522950737073600247960698254336951727417275609613120056  <br>\n199956484282376092960847737164871933048651915361763622502861856670844477897863919036299845630307083886241812099204540122  <br>\n356123742770559899747662595199231054488075097120984387716230576312978851398903482548204192854217775231839022397844642249  <br>\n321323335873821528321457923265174332452579814652247072248949939717987506210928283520107615692805468018645403583104833774  <br>\n321208226469210661260950278195394513731620511861842755325021854326749106268701235527111099367254720975509915629874031819  <br>\n337717818251600578695148127904560239367372840989928402126283340592389716241820479292549567005942358636245308522397253833  <br>\n009002641353055574299068860700295780015482612532490963318106560702127029406761735969721424132866689818076189313325449397  <br>\n570119979359463935796193912131761781764130424353007487147238491878151521444129055997301653419265677104023531656402985486  <br>\n902183104538959054135560788052294316761263825475659487083934449007284230375395247340049658371249407956911218599149612295  <br>\n816324812669282540591466965258714382472865123435168091921785414589354644004421298502167791054479852892289356228264738978  <br>\n948231124905010634616596869417552426431301715552391844069376  </p>\n</blockquote>\n<p>--------------</p>",
        "id": 294218972,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896413
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIt isn't that surprising that you can't compute these functions if they represent logical formulas by integers. However, Gödel-numbering can equivalently be done using Lisp S-expressions. (Strictly speaking, these should be the hereditarily finite sets, where order is ignored.) If you allow yourself a number of distinct atoms as a starting point, your data structures and proofs might actually become intelligible. </p>\n<p>The danger perhaps is that it would start to look too much like an ordinary proof checker coded in Lisp. Shankar's 1986 formalisation of Gödel's incompleteness theorem using nqthm comes to mind. As I recall, he wrote an entire proof-checker for first-order logic within nqthm's Lisp-like formalism.</p>\n<p>Larry Paulson</p>",
        "id": 294218996,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896431
    },
    {
        "content": "<p>From: Jens Doll &lt;<a href=\"mailto:jd@cococo.de\">jd@cococo.de</a>&gt;<br>\nHello all,  </p>\n<p>having published Version 0.87 of my program <a href=\"http://cococo.de/Context_IT_GmbH/index.jsp?content=goedel\">Goedel\n</a>I would like to<br>\nask the community for help:  </p>\n<p>*** Who is willing and able to produce Isabelle sources out of the 46+<br>\n<a href=\"http://cococo.de/Context_IT_GmbH/index.jsp?content=source&amp;file=products/Sources/C/Goedel/propositions.c\">functions</a>,<br>\nwhich I implemented in the C language?  </p>\n<p>It might be interesting for proof technology and looks quite simple: take the<br>\n<a href=\"http://cococo.de/Context_IT_GmbH/index.jsp?content=source&amp;file=products/Sources/C/Goedel/defs.nat.h\">macros</a>,<br>\nuse the C preprocessor and generate Isabelle functions from them.  </p>\n<p>Go ahead, it's thrilling ...  </p>\n<p>Jens</p>",
        "id": 294225176,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899603
    }
]