[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n(I have now changed the Subject to what we are talking about.)</p>\n<p>On 27/06/18 06:51, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>theory Scratch<br>\n  imports Pure<br>\nbegin</p>\n<p>ML \\&lt;open&gt;<br>\n  val Main_thy = Thy_Info.get_theory \"Main\";</p>\n<p>val ZF_thy = Thy_Info.get_theory \"ZF\";<br>\n\\&lt;close&gt;</p>\n<p>end</p>\n<p>and it still works when I substitute imports ZF for imports Pure.</p>\n</blockquote>\n<p>There is some freedom of choice here. In principle you can do everything<br>\nin a Pure-derived theory as above, and produce terms and facts from<br>\nother contexts as illustrated in the included Scratch.thy</p>\n<p>In practice it might be better to chose a default standing point, e.g.<br>\nMain HOL, and cherry-pick things from the ZF-derived context. This also<br>\nallows to use regular Isar statements and proofs from HOL.</p>\n<blockquote>\n<p>But how do I then start doing a proof in HOL involving that term?  The<br>\ntheory window won't let me put in another theory following the end of<br>\nthe first one, and it won't let me do<br>\ntheory Scratch<br>\n  imports ZF Main<br>\nand if I back up to the beginning and replace imports ZF by imports Main<br>\nthen it has forgotten the ML values which were declared.<br>\nSo how does one transfer ML values from a ZF proof to a proof in Main?</p>\n</blockquote>\n<p>ML values are not forgotten, but stored in the enclosing theory context.<br>\nIt is possible to move values between such theory contexts, e.g. via a<br>\nglobal Synchronized.var but then you need to take the physics of<br>\nIsabelle theory versions and PIDE processing into account.</p>\n<p>It is probably easier to pick plain values from a clearly defined theory<br>\ncontext (e.g. ZF) as illustrated in the included Scratch.thy</p>\n<blockquote>\n<p>So, given that the problem is to take a goal from a ZF proof, compute a<br>\ngoal to be proved in HOL, and start a HOL proof with that new goal, how<br>\ncan I do that?</p>\n</blockquote>\n<ul>\n<li>\n<p>You work always in an implicit HOL context.</p>\n</li>\n<li>\n<p>You occasionally use operations like Syntax.read_prop to produce ZF<br>\nterms within an explicit ZF context, and transform them to be usable in<br>\nthe HOL context.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/1Crlx6csGcRFukBTERk2D3Hq/Scratch.thy\">Scratch.thy</a></p>\n</li>\n</ul>",
        "id": 294734695,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189384
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:Jeremy.Dawson@anu.edu.au\">Jeremy.Dawson@anu.edu.au</a>&gt;<br>\nHi Makarius,</p>\n<p>but what is \"the\" enclosing theory context?</p>\n<p>Your example theory file shows how to parse, in ZF, a term that has been <br>\ntyped in, and use an ML function to prove a goal (which could, in <br>\ngeneral, be a HOL term computed from the ZF term).</p>\n<p>But I want to grab a subgoal which arises in the course of proving a <br>\nlemma in ZF, calculate a HOL term, and postulate that term as a goal in <br>\nHOL, for proving in HOL (in Isar, not in ML)</p>\n<p>That is,</p>\n<p>theory Z imports ZF begin<br>\nlemma ..... (ie set out to prove something in ZF)<br>\n   assorted proof steps<br>\n   grab subgoal n as a ML value of type term<br>\n   do things with it to create a term suitable for proving in HOL<br>\n   call this term hol_term<br>\noops or sorry or whatever</p>\n<p>switch context to HOL<br>\nnow set out to prove the goal, which is the term calculated previously,<br>\neg, as someone suggested,<br>\nschematic goal \"?P\"<br>\nresolve_tac (Thm.trivial hol_term)<br>\nnow continue the HOL proof</p>\n<p>Now as far as I can tell,<br>\nlemma ... (following theory Z imports ZF begin)<br>\nworks in the ZF context,<br>\nand I want the<br>\nschematic goal \"?P\" to work in the HOL context.</p>\n<p>Now you have shown me how to get a HOL context and a ZF context present <br>\ntogether, but I still don't see how to get<br>\nlemma (in the ZF context) and<br>\nschematic goal (in the HOL context) together<br>\n(ie, without ML values created during the first proof being lost before <br>\nyou start the second proof).</p>\n<p>Re the suggestion to use Synchronized.var - if I do that wouldn't I just <br>\nhave to somehow stop the Synchronized.var value getting lost, just as I <br>\nnow have to stop the term value getting lost.</p>\n<p>To sum up, the issue is to do<br>\n(1) grab a subgoal out of a proof in ZF<br>\n(2) massage it to create a term<br>\n(3) start up a proof in HOL with that term as the goal (and that proof <br>\nwill be using Isar, not using Goal.prove and ML code)</p>\n<p>Cheers,</p>\n<p>Jeremy Dawson</p>",
        "id": 294734725,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189397
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 28/06/18 06:56, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>On 28/06/18 01:36, Makarius wrote:</p>\n<blockquote>\n<p>ML values are not forgotten, but stored in the enclosing theory context.<br>\nIt is possible to move values between such theory contexts, e.g. via a<br>\nglobal Synchronized.var but then you need to take the physics of<br>\nIsabelle theory versions and PIDE processing into account.</p>\n<p>but what is \"the\" enclosing theory context?</p>\n</blockquote>\n</blockquote>\n<p>It is the context of the 'ML' or 'ML_file' command (or any other command<br>\nthan invokes the ML compiler). Everything in Isabelle has a formal<br>\ncontext; the ML environment is a part of that, and ML compilation is a<br>\nfunction to update that formal context.</p>\n<p>In addition, Isabelle2018 will also provide 'ML_export' to write through<br>\nto the bootstrap ML environment, what you might remember as \"the ML<br>\ntoplevel\" from 1998. That new feature needs to be used with great care,<br>\nthough, and with an understanding how normal Isabelle/ML works within a<br>\nformal context.</p>\n<blockquote>\n<p>Your example theory file shows how to parse, in ZF, a term that has been<br>\ntyped in, and use an ML function to prove a goal (which could, in<br>\ngeneral, be a HOL term computed from the ZF term).</p>\n<p>But I want to grab a subgoal which arises in the course of proving a<br>\nlemma in ZF, calculate a HOL term, and postulate that term as a goal in<br>\nHOL, for proving in HOL (in Isar, not in ML)</p>\n<p>That is,</p>\n<p>theory Z imports ZF begin<br>\nlemma ..... (ie set out to prove something in ZF)<br>\n  assorted proof steps<br>\n  grab subgoal n as a ML value of type term<br>\n  do things with it to create a term suitable for proving in HOL<br>\n  call this term hol_term<br>\noops or sorry or whatever</p>\n<p>switch context to HOL<br>\nnow set out to prove the goal, which is the term calculated previously,<br>\neg, as someone suggested,<br>\nschematic goal \"?P\"<br>\nresolve_tac (Thm.trivial hol_term)<br>\nnow continue the HOL proof</p>\n<p>Now as far as I can tell,<br>\nlemma ... (following theory Z imports ZF begin)<br>\nworks in the ZF context,<br>\nand I want the<br>\nschematic goal \"?P\" to work in the HOL context.</p>\n<p>Now you have shown me how to get a HOL context and a ZF context present<br>\ntogether, but I still don't see how to get<br>\nlemma (in the ZF context) and<br>\nschematic goal (in the HOL context) together<br>\n(ie, without ML values created during the first proof being lost before<br>\nyou start the second proof).</p>\n</blockquote>\n<p>I also don't see that on the spot, which is why I did not answer this so<br>\nfar. I guess it could work as a special Isar command like 'subgoal', but<br>\nit needs to switch the background theory context, which is normally not<br>\nsupported in Isar proofs.</p>\n<blockquote>\n<p>Re the suggestion to use Synchronized.var - if I do that wouldn't I just<br>\nhave to somehow stop the Synchronized.var value getting lost, just as I<br>\nnow have to stop the term value getting lost.</p>\n<p>To sum up, the issue is to do<br>\n(1) grab a subgoal out of a proof in ZF<br>\n(2) massage it to create a term<br>\n(3) start up a proof in HOL with that term as the goal (and that proof<br>\nwill be using Isar, not using Goal.prove and ML code)</p>\n</blockquote>\n<blockquote>\n<p>From what we've had so far on this thread, you should manage (1), (2),<br>\nand a variant of (3) that uses Goal.prove with a context derived from an<br>\nalien theory (HOL).</p>\n</blockquote>\n<p>We can later look again to figure out how to turn this approximation of<br>\n(3) into an Isar goal command.</p>\n<p>Note that in the coming days I will be on travel: FLoC at Oxford (UK)<br>\nuntil 15-Jul-2018.</p>\n<p>Makarius</p>",
        "id": 294737603,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661190360
    }
]