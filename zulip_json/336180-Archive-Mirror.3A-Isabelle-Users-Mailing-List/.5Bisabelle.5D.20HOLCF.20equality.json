[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear all,</p>\n<p>is there already something like Haskell's \"Eq\" typeclass for HOLCF <br>\n(which seems to be neccessariy/convenient to formalize typical Haskell <br>\nfunctions). If not, are there any other reasons than lack of time?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294218898,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896370
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nWhen trying to define my own type class (I dropped all axioms for the <br>\nsake of a minimal example)</p>\n<p>class eq =<br>\n   fixes eq :: \"'a → 'a → tr\"</p>\n<p>and instantiating the lift type</p>\n<p>declare [[names_long]]</p>\n<p>instantiation lift :: (type) eq<br>\nbegin</p>\n<p>I obtain</p>\n<p>Conflict of type arities for classes Representable.predomain &lt;<br>\n                    Bifinite.profinite:<br>\n   Lift.lift :: (HOL.type)<br>\n     Representable.predomain and<br>\n   Lift.lift :: (Countable.countable)<br>\n     Bifinite.profinite</p>\n<p>which I don't understand. What is happening here?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294218908,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896376
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nChristian,</p>\n<p>HOLCF is built out on a series of type classes. The most basic class that supports the continuous function space constructor (-&gt;) is \"cpo\".</p>\n<p>So the most general definition for your eq class is:</p>\n<p>class eq = fixes eq :: \"'a::cpo -&gt; 'a -&gt; tr\"</p>\n<p>I think you can find some discussion in the archives about what the default class is in HOLCF and why it is hard to get it right for all uses.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294218993,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896426
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Sat, Jul 7, 2012 at 6:51 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>When trying to define my own type class (I dropped all axioms for the sake<br>\nof a minimal example)</p>\n<p>class eq =<br>\n  fixes eq :: \"'a → 'a → tr\"</p>\n</blockquote>\n<p>Hi Chris,</p>\n<p>Try \"print_classes\" after this definition, and you will see that class<br>\n\"eq\" has \"domain\" as a superclass. The reason is that HOLCF declares<br>\nclass \"domain\" (consisting of types embeddable into the universal<br>\ndomain type \"udom\") as the default sort, so each occurrence of 'a in<br>\nthe type signature is treated as \"'a::domain\".</p>\n<p>You can override this by re-declaring a different default sort, or<br>\nwith a sort annotation:</p>\n<p>class eq = fixes eq :: \"'a::cpo → 'a → tr\"</p>\n<blockquote>\n<p>and instantiating the lift type</p>\n<p>declare [[names_long]]</p>\n<p>instantiation lift :: (type) eq<br>\nbegin</p>\n<p>I obtain</p>\n<p>Conflict of type arities for classes Representable.predomain &lt;<br>\n                   Bifinite.profinite:<br>\n  Lift.lift :: (HOL.type)<br>\n    Representable.predomain and<br>\n  Lift.lift :: (Countable.countable)<br>\n    Bifinite.profinite</p>\n<p>which I don't understand. What is happening here?</p>\n</blockquote>\n<p>For type \"'a lift\" to be in class \"domain\", type 'a must be in class<br>\n\"countable\".</p>\n<p>Now you are attempting to show that type \"'a lift\" is in class \"eq\" (a<br>\nsubclass of \"domain\") if 'a is in class \"type\" (a superclass of<br>\n\"countable\").</p>\n<p>Such combinations of instances are illegal in Isabelle, because they<br>\nwould cause problems with principal types for type inference. (I think<br>\nthe technical term for the requirement is \"regularity\",<br>\n\"co-regularity\", or something like that.)</p>\n<p>If you keep \"domain\" as a superclass of \"eq\", then the following<br>\ninstance for \"lift\" will work:</p>\n<p>instantiation lift :: (countable) eq</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294219039,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896456
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nA library with class \"Eq\" and other classes from Haskell would<br>\ncertainly be useful, and I don't think it would take much time to<br>\nimplement.</p>\n<p>I think the main reason I never implemented it is I could never decide<br>\non the details: what to name the functions, what syntax to provide,<br>\nwhat axioms to use, which classes to provide, etc.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294219049,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896464
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nI am currently using</p>\n<p>class eq =<br>\n   fixes eq :: \"'a::pcpo → 'a → tr\"<br>\n   assumes equals_strict [simp]:<br>\n     \"eq⋅x⋅⊥ = ⊥\" \"eq⋅⊥⋅y = ⊥\"<br>\n     and eq_iff [iff]:<br>\n     \"eq⋅x⋅y = TT ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x = y\"<br>\n     \"eq⋅x⋅y = FF ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x ≠ y\"<br>\n     \"eq⋅x⋅y = ⊥ ⟷ x = ⊥ ∨ y = ⊥\"</p>\n<p>but did not think much about the details ;).</p>\n<p>Maybe something like a theory for standard Haskell functions could be <br>\nplaced where everybody can browse and contribute? (I am currently mainly <br>\ndefining very basic list functions and proving basic properties about them.)</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294219062,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896474
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Mon, Jul 9, 2012 at 11:14 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>I am currently using</p>\n<p>class eq =<br>\n  fixes eq :: \"'a::pcpo → 'a → tr\"<br>\n  assumes equals_strict [simp]:<br>\n    \"eq⋅x⋅⊥ = ⊥\" \"eq⋅⊥⋅y = ⊥\"<br>\n    and eq_iff [iff]:<br>\n    \"eq⋅x⋅y = TT ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x = y\"<br>\n    \"eq⋅x⋅y = FF ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x ≠ y\"<br>\n    \"eq⋅x⋅y = ⊥ ⟷ x = ⊥ ∨ y = ⊥\"</p>\n<p>but did not think much about the details ;).</p>\n</blockquote>\n<p>I think your eq_iff rules need to be weakened like this:</p>\n<p>\"eq⋅x⋅y = TT ==&gt; x = y\"<br>\n    \"eq⋅x⋅y = FF ==&gt; x ≠ y\"</p>\n<p>Otherwise instances for lazy lists or other lazy datatypes are not<br>\npossible. (Your class \"eq\" is provably a subclass of \"flat\".)</p>\n<p>Alternatively, a subclass \"eq_flat\" with the strong eq_iff rules might<br>\nbe useful alongside a weakened \"eq\" class.</p>\n<blockquote>\n<p>Maybe something like a theory for standard Haskell functions could be placed<br>\nwhere everybody can browse and contribute? (I am currently mainly defining<br>\nvery basic list functions and proving basic properties about them.)</p>\n</blockquote>\n<p>This sounds like a good idea. The question is where to put it. We<br>\ncould add a theory file under HOLCF in the distribution, or we could<br>\nadd an AFP entry for this purpose. (Maybe using the distribution is<br>\nbetter; as an \"archive\", the AFP seems not to be intended so much for<br>\ndynamic, growing works with open authorship.)</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294219070,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896480
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThe distribution is more lightweight than the AFP. But in either case the set of<br>\npeople that can add contributions will be restricted.</p>\n<p>Tobias</p>",
        "id": 294219112,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896486
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAfter several successful years of AFP, this question is still coming up <br>\nroutinely, and I wonder myself often.</p>\n<p>Can the official AFP editors make some more explicit statements on the AFP <br>\nwebsite what it really is?  What are the official policies to grow it? <br>\nWill new versions of articles replace old ones, keeping the name or <br>\nchanging the name? Etc. etc.</p>\n<p>For example, JinjaThreads seems to have been a perfectly dynamic entry in <br>\nall these years, without any archival character beyond the Mercurial <br>\nhistory.</p>\n<p>Makarius</p>",
        "id": 294219160,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896511
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nOn 07/09/2012 10:04 PM, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Mon, Jul 9, 2012 at 11:14 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>I am currently using</p>\n<p>class eq =<br>\n   fixes eq :: \"'a::pcpo → 'a → tr\"<br>\n   assumes equals_strict [simp]:<br>\n     \"eq⋅x⋅⊥ = ⊥\" \"eq⋅⊥⋅y = ⊥\"<br>\n     and eq_iff [iff]:<br>\n     \"eq⋅x⋅y = TT ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x = y\"<br>\n     \"eq⋅x⋅y = FF ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x ≠ y\"<br>\n     \"eq⋅x⋅y = ⊥ ⟷ x = ⊥ ∨ y = ⊥\"</p>\n<p>but did not think much about the details ;).</p>\n</blockquote>\n<p>I think your eq_iff rules need to be weakened like this:</p>\n<p>\"eq⋅x⋅y = TT ==&gt; x = y\"<br>\n     \"eq⋅x⋅y = FF ==&gt; x ≠ y\"</p>\n<p>Otherwise instances for lazy lists or other lazy datatypes are not<br>\npossible. (Your class \"eq\" is provably a subclass of \"flat\".)<br>\nThanks for pointing this out. As I said, I did not think much about the <br>\ndetails yet (and my only instance of \"eq\" was \"lift\").</p>\n<p>Alternatively, a subclass \"eq_flat\" with the strong eq_iff rules might<br>\nbe useful alongside a weakened \"eq\" class.<br>\nThat sounds reasonable.</p>\n<blockquote>\n<p>Maybe something like a theory for standard Haskell functions could be placed<br>\nwhere everybody can browse and contribute? (I am currently mainly defining<br>\nvery basic list functions and proving basic properties about them.)</p>\n</blockquote>\n<p>This sounds like a good idea. The question is where to put it. We<br>\ncould add a theory file under HOLCF in the distribution, or we could<br>\nadd an AFP entry for this purpose. (Maybe using the distribution is<br>\nbetter; as an \"archive\", the AFP seems not to be intended so much for<br>\ndynamic, growing works with open authorship.)<br>\nI would suggest to start with a sourceforge project (or anything <br>\nequivalent) until there actually is something constituting a \"standard <br>\nlibrary\" which can then be submitted to the AFP (or the distribution).</p>\n</blockquote>\n<ul>\n<li>chris</li>\n</ul>",
        "id": 294219202,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896541
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 09/07/2012 23:00, schrieb Makarius:</p>\n<blockquote>\n<p>On Mon, 9 Jul 2012, Tobias Nipkow wrote:</p>\n<p>Am 09/07/2012 15:04, schrieb Brian Huffman:</p>\n<blockquote>\n<blockquote>\n<p>Maybe using the distribution is better; as an \"archive\", the AFP seems not to<br>\nbe intended so much for dynamic, growing works with open authorship.</p>\n</blockquote>\n<p>The distribution is more lightweight than the AFP. But in either case the set<br>\nof people that can add contributions will be restricted.</p>\n</blockquote>\n<p>After several successful years of AFP, this question is still coming up<br>\nroutinely, and I wonder myself often.</p>\n<p>Can the official AFP editors make some more explicit statements on the AFP<br>\nwebsite what it really is?  What are the official policies to grow it? Will new<br>\nversions of articles replace old ones, keeping the name or changing the name?<br>\nEtc. etc.</p>\n</blockquote>\n<p><a href=\"http://afp.sourceforge.net/updating.shtml\">http://afp.sourceforge.net/updating.shtml</a></p>\n<blockquote>\n<p>For example, JinjaThreads seems to have been a perfectly dynamic entry in all<br>\nthese years, without any archival character beyond the Mercurial history.</p>\n</blockquote>\n<p>In addition it has a change history which needs to be updated and resides not in<br>\nthe individual entry but in the central database.</p>\n<p>Tobias</p>",
        "id": 294219216,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896548
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nOn 07/09/2012 10:04 PM, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Mon, Jul 9, 2012 at 11:14 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>I am currently using</p>\n<p>class eq =<br>\n   fixes eq :: \"'a::pcpo → 'a → tr\"<br>\n   assumes equals_strict [simp]:<br>\n     \"eq⋅x⋅⊥ = ⊥\" \"eq⋅⊥⋅y = ⊥\"<br>\n     and eq_iff [iff]:<br>\n     \"eq⋅x⋅y = TT ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x = y\"<br>\n     \"eq⋅x⋅y = FF ⟷ x ≠ ⊥ ∧ y ≠ ⊥ ∧ x ≠ y\"<br>\n     \"eq⋅x⋅y = ⊥ ⟷ x = ⊥ ∨ y = ⊥\"</p>\n<p>but did not think much about the details ;).<br>\nBtw, the above strictness rules came from observing how ghci handled <br>\nequalities involving \"undefined\". For the case of (==) this is <br>\nrelatively simple.</p>\n</blockquote>\n</blockquote>\n<p>On a related note, in the the ghc sources there are often several <br>\nversions of a function (usually one due to the Haskell report and an <br>\noptimized one). Furthermore there are rewrite rules that can be used by <br>\nthe compiler. In both cases the strictness-behaviour (I don't know the <br>\ncorrect technical term) is sometimes different, i.e., optimized <br>\nfunctions behave different (I think I experienced this with the two <br>\nversions of \"any\", but am not a 100% sure) from report versions and <br>\nsometimes rewrite rules have not been correct when considering <br>\nstrictness, e.g., consider the following excerpt from the sources:</p>\n<p>{-# RULES<br>\n\"filter\"     [~1] forall p xs.  filter p xs = build (\\c n -&gt; foldr <br>\n(filterFB c p) n xs)<br>\n\"filterList\" [1]  forall p.     foldr (filterFB (:) p) [] = filter p<br>\n\"filterFB\"        forall c p q. filterFB (filterFB c p) q = filterFB c <br>\n(\\x -&gt; q x &amp;&amp; p x)<br>\n  #-}</p>\n<p>-- Note the filterFB rule, which has p and q the \"wrong way round\" in <br>\nthe RHS.<br>\n--     filterFB (filterFB c p) q a b<br>\n--   = if q a then filterFB c p a b else b<br>\n--   = if q a then (if p a then c a b else b) else b<br>\n--   = if q a &amp;&amp; p a then c a b else b<br>\n--   = filterFB c (\\x -&gt; q x &amp;&amp; p x) a b<br>\n-- I originally wrote (\\x -&gt; p x &amp;&amp; q x), which is wrong, and actually<br>\n-- gave rise to a live bug report.  SLPJ.</p>\n<p>For verification this is of course important. It seems that HOLCF <br>\nprovides a nice way to verify such compiler rewrite rules in a reliable way.</p>\n<p>chris</p>\n<blockquote>\n<p>I think your eq_iff rules need to be weakened like this:</p>\n<p>\"eq⋅x⋅y = TT ==&gt; x = y\"<br>\n     \"eq⋅x⋅y = FF ==&gt; x ≠ y\"</p>\n<p>Otherwise instances for lazy lists or other lazy datatypes are not<br>\npossible. (Your class \"eq\" is provably a subclass of \"flat\".)</p>\n<p>Alternatively, a subclass \"eq_flat\" with the strong eq_iff rules might<br>\nbe useful alongside a weakened \"eq\" class.</p>\n<blockquote>\n<p>Maybe something like a theory for standard Haskell functions could be placed<br>\nwhere everybody can browse and contribute? (I am currently mainly defining<br>\nvery basic list functions and proving basic properties about them.)</p>\n</blockquote>\n<p>This sounds like a good idea. The question is where to put it. We<br>\ncould add a theory file under HOLCF in the distribution, or we could<br>\nadd an AFP entry for this purpose. (Maybe using the distribution is<br>\nbetter; as an \"archive\", the AFP seems not to be intended so much for<br>\ndynamic, growing works with open authorship.)</p>\n<ul>\n<li>Brian<br>\n</li>\n</ul>\n</blockquote>",
        "id": 294219220,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896554
    }
]