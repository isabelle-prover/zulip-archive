[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHello,</p>\n<p>I’m in the progress of formalizing Launchbury’s natural semantics for<br>\nlazy evaluation. For the denotational part, I use HOLCF machinery (which<br>\nwas interesting to combine with Nominal, but it seems that I sailed<br>\naround that cliff).</p>\n<p>The type of the semantic environments are a chain-complete partial order<br>\n(typeclass cpo). My current problem is that Launcbury uses the meet on<br>\nthese, leaving it to the reader to believe that it is only used with<br>\narguments where the least upper bound exists.</p>\n<p>If I try to follow this path and define</p>\n<p>definition meet :: \"'a =&gt; 'a =&gt; 'a\" (infixl \"⊔\" 70)<br>\n          where \"x ⊔ y = lub {x, y}\"<br>\n        definition have_meet :: \"'a =&gt; 'a =&gt; bool\"<br>\n          where \"have_meet x y = (∃ z. {x, y} &lt;&lt;| z)\"</p>\n<p>then maybe I will be able to show the have_meet property everywhere<br>\nwhere I use the meet.</p>\n<p>But to be able to use HOLCF’s machinery, e.g. the lemmas from CFun.thy<br>\nand Fix.thy, I’d also have to show that the meet is continuous in both<br>\nits arguments, and that is currently not the case; it is not even<br>\ncontinuous, as x ⊔ y might exist, but x' ⊔ y for x' ⊒ x not.</p>\n<p>What would be a sensible way to tackle this problem? Using the type<br>\n        \"'a =&gt; 'a =&gt; 'a option\",<br>\nintroducing a notion of continuous_if_defined and re-creating most of<br>\nHOLCF’s lemmas using this notation¹? Or maybe there is a way to extend<br>\nthe meet continuously?</p>\n<p>Thanks,<br>\nJoachim</p>\n<p>¹ I already had to do that for the lemmas and definitions in Fix.thy, as<br>\ndue to restrictions from Nominal, the environments need to have finite<br>\nsupport. But the type of maps with finite domain (which I introduced) is<br>\nnot a pcpo, just a cpo, so I now have the notion of a least fixed point<br>\n“above a certain value”. If someone has use for that type, help yourself<br>\nat <a href=\"http://darcs.nomeata.de/isa-launchbury/\">http://darcs.nomeata.de/isa-launchbury/</a>, theories FMap, FMap-Nominal,<br>\nFMap-HOLCF and FMap-Nominal-HOLCF.<br>\n<a href=\"/user_uploads/14278/xn2-KkVgDgkoAMza0GVNSPe5/signature.asc\">signature.asc</a></p>",
        "id": 294217036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895458
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Mon, Jul 23, 2012 at 10:44 AM, Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I’m in the progress of formalizing Launchbury’s natural semantics for<br>\nlazy evaluation. For the denotational part, I use HOLCF machinery (which<br>\nwas interesting to combine with Nominal, but it seems that I sailed<br>\naround that cliff).</p>\n<p>The type of the semantic environments are a chain-complete partial order<br>\n(typeclass cpo). My current problem is that Launcbury uses the meet on<br>\nthese, leaving it to the reader to believe that it is only used with<br>\narguments where the least upper bound exists.</p>\n<p>If I try to follow this path and define</p>\n<p>definition meet :: \"'a =&gt; 'a =&gt; 'a\" (infixl \"⊔\" 70)<br>\n          where \"x ⊔ y = lub {x, y}\"<br>\n        definition have_meet :: \"'a =&gt; 'a =&gt; bool\"<br>\n          where \"have_meet x y = (∃ z. {x, y} &lt;&lt;| z)\"</p>\n<p>then maybe I will be able to show the have_meet property everywhere<br>\nwhere I use the meet.</p>\n<p>But to be able to use HOLCF’s machinery, e.g. the lemmas from CFun.thy<br>\nand Fix.thy, I’d also have to show that the meet is continuous in both<br>\nits arguments, and that is currently not the case; it is not even<br>\ncontinuous, as x ⊔ y might exist, but x' ⊔ y for x' ⊒ x not.</p>\n</blockquote>\n<p>Hi Joachim,</p>\n<p>First of all, I should point out that what you have defined is the<br>\n<em>join</em>, not the <em>meet</em>. The meet is the infimum, i.e. greatest lower<br>\nbound.</p>\n<blockquote>\n<p>What would be a sensible way to tackle this problem? Using the type<br>\n        \"'a =&gt; 'a =&gt; 'a option\",<br>\nintroducing a notion of continuous_if_defined and re-creating most of<br>\nHOLCF’s lemmas using this notation¹? Or maybe there is a way to extend<br>\nthe meet continuously?</p>\n</blockquote>\n<p>I would probably define a subclass of cpo for types for which a<br>\ncontinuous meet operation exists:</p>\n<p>class meet_cpo = cpo +<br>\n  fixes meet :: \"'a -&gt; 'a -&gt; 'a\"<br>\n  assumes \"meet\\&lt;cdot&gt;x\\&lt;cdot&gt;y \\&lt;sqsubseteq&gt; x\"<br>\n  assumes \"meet\\&lt;cdot&gt;x\\&lt;cdot&gt;y \\&lt;sqsubseteq&gt; y\"<br>\n  assumes \"z \\&lt;sqsubseteq&gt; x ==&gt; z \\&lt;sqsubseteq&gt;y ==&gt; z \\&lt;sqsubseteq&gt;<br>\nmeet\\&lt;cdot&gt;x\\&lt;cdot&gt;y\"</p>\n<p>Most instances of this class would need to have a bottom element. If<br>\nyou really need a meet operation for unpointed cpo types, then you<br>\nmight try defining the meet on the lifted cpo instead:</p>\n<p>class meet_cpo' = cpo +<br>\n  fixes meet :: \"'a u -&gt; 'a u -&gt; 'a u\"<br>\n  assumes \"meet\\&lt;cdot&gt;x\\&lt;cdot&gt;y \\&lt;sqsubseteq&gt; x\"<br>\n  assumes \"meet\\&lt;cdot&gt;x\\&lt;cdot&gt;y \\&lt;sqsubseteq&gt; y\"<br>\n  assumes \"z \\&lt;sqsubseteq&gt; x ==&gt; z \\&lt;sqsubseteq&gt;y ==&gt; z \\&lt;sqsubseteq&gt;<br>\nmeet\\&lt;cdot&gt;x\\&lt;cdot&gt;y\"</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294217055,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895467
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear Brian,</p>\n<p>thanks for your reply.</p>\n<p>Am Montag, den 23.07.2012, 11:33 +0200 schrieb Brian Huffman:</p>\n<blockquote>\n<p>First of all, I should point out that what you have defined is the<br>\n<em>join</em>, not the <em>meet</em>. The meet is the infimum, i.e. greatest lower<br>\nbound.</p>\n</blockquote>\n<p>ah, right, I keep confusing the two names. I did mean the join (and I<br>\nshould just say supremum, which is a name less likely confused).</p>\n<blockquote>\n<blockquote>\n<p>What would be a sensible way to tackle this problem? Using the type<br>\n        \"'a =&gt; 'a =&gt; 'a option\",<br>\nintroducing a notion of continuous_if_defined and re-creating most of<br>\nHOLCF’s lemmas using this notation¹? Or maybe there is a way to extend<br>\nthe meet continuously?</p>\n</blockquote>\n<p>I would probably define a subclass of cpo for types for which a<br>\ncontinuous meet operation exists:</p>\n<p>class meet_cpo = cpo +<br>\n  fixes meet :: \"'a -&gt; 'a -&gt; 'a\"<br>\n  assumes \"meet\\&lt;cdot&gt;x\\&lt;cdot&gt;y \\&lt;sqsubseteq&gt; x\"<br>\n  assumes \"meet\\&lt;cdot&gt;x\\&lt;cdot&gt;y \\&lt;sqsubseteq&gt; y\"<br>\n  assumes \"z \\&lt;sqsubseteq&gt; x ==&gt; z \\&lt;sqsubseteq&gt;y ==&gt; z \\&lt;sqsubseteq&gt;<br>\nmeet\\&lt;cdot&gt;x\\&lt;cdot&gt;y\"</p>\n</blockquote>\n<p>The problem is that for my types, defined as:</p>\n<p>domain Value = Fn (lazy \"Value → Value\")<br>\n        type_synonym Env = \"(var, Value) fmap\"</p>\n<p>the join does not always exist, so I could not instantiate the join_cpo<br>\nclass for Env.</p>\n<p>I thought about adding an artificial Top to my cpo, defining x ⊔ y to be<br>\nthat instead of undefined when there is no supremum of x and y. But it<br>\nseems that this is not enough to make the join monotonous: If x ⊑ x' and<br>\nx' ⊔ y exists it is possible that x and y, although having upper bounds,<br>\ndo not have a least upper bound.</p>\n<p>To make this work, I’d need arbitrary meets (this time I really mean<br>\nmeets) to exist in Value; not sure if that holds. What do you think of<br>\nthat approach?</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/3UPkroIgELaX0AQyA5pL6Zev/signature.asc\">signature.asc</a></p>",
        "id": 294217058,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895469
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nAdding a top element (at least to the return type of the join<br>\nfunction) seems like a reasonable thing to do.</p>\n<p>Arbitrary meets exist in every Scott domain, so I would expect that<br>\nthey exist in your Value type.</p>\n<p>I don't think omega-bifinite domains (aka SFP domains, formalized as<br>\nthe default class \"domain\" in HOLCF) have arbitrary meets, though, so<br>\nyou couldn't define a generic binary join function directly on class<br>\n\"domain\". You'll need to define a new subclass of cpo to use with your<br>\nbinary join function, but I expect that it shouldn't be too hard to<br>\ninstantiate it.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294217071,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895474
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear Brian,</p>\n<p>I am trying this path, now that my class-related issues are resolved<br>\n(thanks for that).</p>\n<p>I introduced a type class Top_cpo for cpo’s with top¹. Then I created a<br>\ndual of HOLCF/Up.thy, e.g. a type \"'a d\" that adjoins a top element²,<br>\nwith an instance for Top_cpo and the necessary setup to use it in domain<br>\nequations (is this generally useful? Feel free to include it in<br>\nHOLCF/Library).</p>\n<p>Finally I introduced type classes for cpo where meets of non-empty sets,<br>\narbitrary Meets and arbitrary Joins, respectively, exists, and showed<br>\nthat a type with top and arbitrary meets has arbitrary joins. I also<br>\nshows that if 'a has non-empty meets, then \"'a d\" has.</p>\n<p>Then I defined<br>\n        domain Value_ = Fn (lazy \"Value_ d → Value_ d\")<br>\n        type_synonym Value = \"Value_ d\"<br>\nand it seems that instantiating Nonempty_Meet_cpo for Value_ is what is<br>\nleft to do.</p>\n<p>Morally, things look clear to me: Either the set has a bottom, the the<br>\nmeet is bottom, or all elements are of the form \"Fn _\", then I take the<br>\nmeet pointwise. But this recurses, so I’m not sure how to define it.</p>\n<p>Because of the indirect recursion in the definition of Value_, no<br>\n“normal” induction rules are available. My first approach would be to<br>\nshow that for every nonempty S, I find a meet of \"Value__take i `<br>\nS\" (and I am hoping that I can show this by induction on i, but I’m not<br>\nsure yet). Then the lub of these seems to be the meet of M. I am a bit<br>\nworried about the use of cfun_map in Value__take and whether it behaves<br>\nwell in the inductive step of the proof.</p>\n<p>Thanks,<br>\nJoachim</p>\n<p>¹ <a href=\"http://darcs.nomeata.de/isa-launchbury/HOLCF-Top.thy\">http://darcs.nomeata.de/isa-launchbury/HOLCF-Top.thy</a><br>\n² <a href=\"http://darcs.nomeata.de/isa-launchbury/Down.thy\">http://darcs.nomeata.de/isa-launchbury/Down.thy</a><br>\n<a href=\"/user_uploads/14278/tZOZy-_xipOgW_OizSVhW0G3/signature.asc\">signature.asc</a></p>",
        "id": 294217373,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895634
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear Brian,</p>\n<p>I’m having a hard time showing that there are meets for my data type.<br>\nFor the inductive proof of<br>\n    ∃ u. {Value__take i ⋅ x | x . x ∈ S } &gt;&gt;| u<br>\nin the case where I know that all elements of S have the form \"Fn⋅_\", I<br>\nneed to show the existence of a meet of the image of set of continuous<br>\nfunctions (\"S :: (Value_ d → Value_ d) set\"), under cfun_map⋅f⋅g (where<br>\nf and g involve \"Value__take i\").</p>\n<p>By induction, I know that \"⨅ (g ` S')\" exists for any S' of type <br>\n\"Value_ d set\", so pointwise, the meet exists. My hope was to show the<br>\nfollowing lemma, which would then give me the existence of the meet of<br>\nthe set of function:</p>\n<p>lemma has_glb_cfunI:<br>\n    assumes \"(!! x. ∃ l. (λ f. f⋅x) ` S &gt;&gt;| l)\"<br>\n    shows \"(∃ l. S &gt;&gt;| l)\"</p>\n<p>I did not manage to proof that, though, and I am worried that it might<br>\nnot hold. By analogy from analysis, the set of functions on [0,2] given<br>\nby {x^n | n ∈ [1..∞]} has pointwise infimums, but itself none.</p>\n<p>You know the domains better than me: Do you still expect that is<br>\npossible to show the existence of arbitrary meets for such a data type,<br>\nand if so, how?</p>\n<p>Thanks a lot in advance,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/PCC1v6GMXlQR2jLrvz5vEobP/signature.asc\">signature.asc</a></p>",
        "id": 294217443,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895659
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Wed, Jul 25, 2012 at 4:44 PM, Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Brian,</p>\n<p>Am Mittwoch, den 25.07.2012, 13:54 +0200 schrieb Joachim Breitner:</p>\n<blockquote>\n<p>Then I defined<br>\n        domain Value_ = Fn (lazy \"Value_ d → Value_ d\")<br>\n        type_synonym Value = \"Value_ d\"<br>\nand it seems that instantiating Nonempty_Meet_cpo for Value_ is what is<br>\nleft to do.</p>\n<p>Morally, things look clear to me: Either the set has a bottom, the the<br>\nmeet is bottom, or all elements are of the form \"Fn _\", then I take the<br>\nmeet pointwise. But this recurses, so I’m not sure how to define it.</p>\n<p>Because of the indirect recursion in the definition of Value_, no<br>\n“normal” induction rules are available. My first approach would be to<br>\nshow that for every nonempty S, I find a meet of \"Value__take i `<br>\nS\" (and I am hoping that I can show this by induction on i, but I’m not<br>\nsure yet). Then the lub of these seems to be the meet of M. I am a bit<br>\nworried about the use of cfun_map in Value__take and whether it behaves<br>\nwell in the inductive step of the proof.<br>\n[...]<br>\nYou know the domains better than me: Do you still expect that is<br>\npossible to show the existence of arbitrary meets for such a data type,<br>\nand if so, how?</p>\n</blockquote>\n<p>Thanks a lot in advance,<br>\nJoachim</p>\n</blockquote>\n<p>Hi Joachim,</p>\n<p>Your idea of finding the meet of set M by taking the lub of a sequence<br>\nof meets of (take i ` M) is on the right track.</p>\n<p>I think you should be able to show that any bifinite domain with<br>\nbinary meets has arbitrary nonempty meets. First, note that if you<br>\nhave binary meets then you have all nonempty finite meets. Then from<br>\nbifiniteness, there exists a chain of approx functions: Like take<br>\nfunctions, these have their lub = ID, but more importantly each one<br>\nalso has a finite range, so (approx i <code> M) is always a finite set.\nFinally, LUB i. Meet (approx i </code> M) should give you the meet for M.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294217535,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895714
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear Brian,</p>\n<p>thanks for the hint, here is my progress so far: I was able to define<br>\nand proof the following class relations:</p>\n<p>class Finite_Meet_cpo = cpo +<br>\n          assumes binary_meet_exists: \"∃ l. l ⊑ x ∧ l ⊑ y ∧ (∀ z. (z ⊑ x ∧ z ⊑ y) ⟶ z ⊑ l)\"</p>\n<p>class Finite_Meet_bifinite_cpo = Finite_Meet_cpo + bifinite</p>\n<p>instance Finite_Meet_bifinite_cpo ⊆ Nonempty_Meet_cpo</p>\n<p>So indeed all I need to do is to give an</p>\n<p>instance Value_ :: Finite_Meet_cpo</p>\n<p>but it seems I am stuck at the same problem as before. To show the<br>\nexistence the meet of two values of the form \"Fn f\" and \"Fn g\" (while,<br>\nby induction, knowing that their images have pairwise meets), I can<br>\ndefine that as \"Fn (Λ x . f x ⨅ g x)\" but I have trouble showing that it<br>\nis continuous.</p>\n<p>To add to my worries, here is an example which tries to transfer the<br>\nanalysis example from my last mail. It may just implies that there is<br>\nlittle hope in relating the meet of a set of functions with the meet at<br>\nits points.</p>\n<p>Consider a domain D such that D = Fn (lazy (D → D)), and these<br>\n(hopefully continuous) functions:</p>\n<p>f :: D → D<br>\n        f x = Fn (λ _ . x)<br>\n        f' x = Fn (λ y . if y = ⊥ ⋀ x ⊑ µ f then x else µ f)<br>\n        g ⊥ = ⊥<br>\n        g (Fn h) = h (Fn id)</p>\n<p>Now g (f x) = x and (⨆i. f^i ⊥) = (⨆i. f'^i ⊥) = µ f. Looking at<br>\n(⨅i. g^i) I find pointwise</p>\n<p>(⨅i. g^i (f^j ⊥))  = ⨅{⊥}   = ⊥<br>\n        (⨅i. g^i (f'^j ⊥)) = ⨅{µ f} = µ f<br>\n        (⨅i. g^i (µ f)     = ⨅{µ f} = µ f</p>\n<p>so if (⨅i. g^i) exists, it cannot be (λ x (⨅i. g^i x)). Of course ⊥ is<br>\nstill a candidate, and I don’t have an example handy where I find many<br>\nlower bounds, but not a greatest.</p>\n<p>It seems that I don’t take the right approach to define the meet of two<br>\nfunction values. Is there some more magic required to define the meet?</p>\n<p>Thanks a lot,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/5PIgGQyv1dV3S9K4CClt0_w9/signature.asc\">signature.asc</a></p>",
        "id": 294217592,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895757
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Thu, Jul 26, 2012 at 11:25 AM, Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Brian,</p>\n<p>Am Donnerstag, den 26.07.2012, 07:39 +0200 schrieb Brian Huffman:</p>\n<blockquote>\n<blockquote>\n<p>You know the domains better than me: Do you still expect that is<br>\npossible to show the existence of arbitrary meets for such a data type,<br>\nand if so, how?</p>\n<p>Thanks a lot in advance,<br>\nJoachim</p>\n</blockquote>\n<p>Hi Joachim,</p>\n<p>Your idea of finding the meet of set M by taking the lub of a sequence<br>\nof meets of (take i ` M) is on the right track.</p>\n<p>I think you should be able to show that any bifinite domain with<br>\nbinary meets has arbitrary nonempty meets. First, note that if you<br>\nhave binary meets then you have all nonempty finite meets. Then from<br>\nbifiniteness, there exists a chain of approx functions: Like take<br>\nfunctions, these have their lub = ID, but more importantly each one<br>\nalso has a finite range, so (approx i <code> M) is always a finite set.\nFinally, LUB i. Meet (approx i </code> M) should give you the meet for M.</p>\n</blockquote>\n<p>thanks for the hint, here is my progress so far: I was able to define<br>\nand proof the following class relations:</p>\n<p>class Finite_Meet_cpo = cpo +<br>\n          assumes binary_meet_exists: \"∃ l. l ⊑ x ∧ l ⊑ y ∧ (∀ z. (z ⊑ x ∧ z ⊑ y) ⟶ z ⊑ l)\"</p>\n<p>class Finite_Meet_bifinite_cpo = Finite_Meet_cpo + bifinite</p>\n<p>instance Finite_Meet_bifinite_cpo ⊆ Nonempty_Meet_cpo</p>\n<p>So indeed all I need to do is to give an</p>\n<p>instance Value_ :: Finite_Meet_cpo</p>\n<p>but it seems I am stuck at the same problem as before. To show the<br>\nexistence the meet of two values of the form \"Fn f\" and \"Fn g\" (while,<br>\nby induction, knowing that their images have pairwise meets), I can<br>\ndefine that as \"Fn (Λ x . f x ⨅ g x)\" but I have trouble showing that it<br>\nis continuous.</p>\n</blockquote>\n<p>You should try constructing the witness for the binary meet directly<br>\nas a continuous function, e.g.</p>\n<p>fixrec meet :: \"Value_ → Value_ → Value_\"<br>\n  where \"meet⋅(Fn⋅f)⋅(Fn⋅g) =<br>\n    Fn⋅(Λ x. (Λ (up⋅a) (up⋅b). up⋅(meet⋅a⋅b))⋅(f⋅x)⋅(g⋅x))\"</p>\n<p>Using this definition, I was able to prove \"(t ⊑ meet⋅u⋅v) = (t ⊑ u ∧<br>\nt ⊑ v)\" by take induction on t.</p>\n<p>[...]</p>\n<blockquote>\n<p>It seems that I don’t take the right approach to define the meet of two<br>\nfunction values. Is there some more magic required to define the meet?</p>\n</blockquote>\n<p>No magic should be necessary; binary meets of (continuous) functions<br>\nare defined pointwise.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294217652,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895781
    }
]