[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 12 Sep 2013, Peter Lammich wrote:</p>\n<blockquote>\n<p>I encountered the following strange behaviour</p>\n<p>term \"(\\&lt;exists&gt;a::_::order. a\\&lt;le&gt;a) \\&lt;and&gt; (\\&lt;exists&gt;b::_::type. b=b)\"<br>\n*** Inconsistent sort constraints for type variable \"'_dummy_\"<br>\n*** At command \"term\"</p>\n<p>However,<br>\nterm \"(\\&lt;exists&gt;a::_. a\\&lt;le&gt;a) \\&lt;and&gt; (\\&lt;exists&gt;b::_::type. b=b)\"</p>\n<p>works as expected, and yields:<br>\n\"(\\&lt;exists&gt;a\\&lt;Colon&gt;'a\\&lt;Colon&gt;ord. a \\&lt;le&gt; a) \\&lt;and&gt; (\\&lt;exists&gt;b<br>\n\\&lt;Colon&gt;'b\\&lt;Colon&gt;type. b = b)\"<br>\n :: \"bool\"</p>\n<p>What has happened here.</p>\n</blockquote>\n<p>That is indeed a bit strange.  After some hours of studying the sources <br>\nand the history the explanation is as follows:</p>\n<p>Dummy type variables with sort constraints were introduced in 2000 for <br>\nIsabelle99-1 -- back then a quick and easy \"feature\" addition.</p>\n<p>12 years later, Isabelle2012 clarified the handling of sort constraints as <br>\nfollows (see NEWS):</p>\n<p>* Sort constraints are now propagated in simultaneous statements, just<br>\n   like type constraints.  INCOMPATIBILITY in rare situations, where<br>\n   distinct sorts used to be assigned accidentally.  For example:</p>\n<p>lemma \"P (x::'a::foo)\" and \"Q (y::'a::bar)\"  -- \"now illegal\"</p>\n<p>lemma \"P (x::'a)\" and \"Q (y::'a::bar)\"<br>\n       -- \"now uniform 'a::bar instead of default sort for first occurrence (!)\"</p>\n<p>This improvement on one side disrupted the simplistic implementation of <br>\ndummy type variables on the other side.  You can toss a coin which is the <br>\n\"bug\" and which the \"feature\", but these words are meaningless anyway.</p>\n<p>Old things often need the environment to act in an old way.</p>\n<blockquote>\n<p>And why does the second example work at all?</p>\n</blockquote>\n<p>Dummy types \"_\" are quite different from dummy type variables \"_::sort\". <br>\nThe former are used all the time, the latter hardly at all.</p>\n<blockquote>\n<p>Why are type constraints checked <em>before</em> dummy-patterns are <br>\ninstantiated?</p>\n</blockquote>\n<p>Because the system is so complex that its complexity is hard to grasp, and <br>\nit is very hard to change without breaking anything else, even for myself.</p>\n<p>Nonetheless, I count this as minor incident, and don't see a reason to <br>\nremove that old feature.  In the next release the dummy type variables <br>\nshould work better again.</p>\n<p>Anyway, just by accident I've come across the very existence of that half <br>\nforgotten thing just recently, but removed the dummies by plain named type <br>\nvariables for clarity.  (These were regular toplevel theorem statements, <br>\nwithout any special requirements.)</p>\n<p>So just for curiosity, what are your applications where the dummies with <br>\nsorts make a difference?</p>\n<p>Makarius</p>",
        "id": 294247751,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909575
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi all,</p>\n<p>I encountered the following strange behaviour (also in isabelle-dev<br>\n2b68f4109075):</p>\n<p>term \"(\\&lt;exists&gt;a::_::order. a\\&lt;le&gt;a) \\&lt;and&gt; (\\&lt;exists&gt;b::_::type. b=b)\"<br>\n*** Inconsistent sort constraints for type variable \"'_dummy_\"<br>\n*** At command \"term\"</p>\n<p>However, <br>\nterm \"(\\&lt;exists&gt;a::_. a\\&lt;le&gt;a) \\&lt;and&gt; (\\&lt;exists&gt;b::_::type. b=b)\"</p>\n<p>works as expected, and yields: <br>\n\"(\\&lt;exists&gt;a\\&lt;Colon&gt;'a\\&lt;Colon&gt;ord. a \\&lt;le&gt; a) \\&lt;and&gt; (\\&lt;exists&gt;b<br>\n\\&lt;Colon&gt;'b\\&lt;Colon&gt;type. b = b)\"<br>\n  :: \"bool\"</p>\n<p>What has happened here. Why are type constraints checked <em>before</em><br>\ndummy-patterns are instantiated? And why does the second example work at<br>\nall?</p>",
        "id": 294250242,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910446
    }
]