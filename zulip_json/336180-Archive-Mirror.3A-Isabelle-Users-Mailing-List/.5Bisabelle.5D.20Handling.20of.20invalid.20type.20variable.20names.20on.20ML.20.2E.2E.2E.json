[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nDear Makarius,</p>\n<p>thank you for the explanation. I was not aware the Variable.variant_fixes<br>\nand friends are also for type variables, this is useful to know. (Perhaps<br>\nthe implementation manual should mention this more explicitly.)</p>\n<p>Concerning my original confusion: I was wondering how it can be that fixing<br>\nthe variable \"a\" influences the behavior of the (invalid) type variable<br>\n\"a\". I think the answer is that, while type and regular variables are<br>\nseparate, the table that remembers what variables are fixed is shared by<br>\ntype and regular variables. Thus fixing the regular variable <em>a</em> also fixes<br>\nthe (invalid) type variable <em>a</em>. Is that correct?</p>\n<p>I will try to follow your programming guidelines. But one thing is unclear<br>\nto me in that context: Goal.prove has an argument xs (instantiated with<br>\n[\"l\"] in my example). I thought I can use xs with a hardcoded name because<br>\nGoal.prove will locally fix that variable. Is that incorrect? If it's<br>\nincorrect, I don't understand how the argument xs can be used, because if I<br>\nget a fresh name via Variable.variant_fixes and supply this name in the<br>\nargument xs, then I get an error that the variable is already fixed. So, I<br>\nsee no way how to use the xs argument. (Of course, I can always avoid using<br>\nthat argument by using Variable.export after creating a theorem using<br>\nGoal.prove, but then what is xs for?)</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294731730,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188317
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 25/05/18 21:03, Dominique Unruh wrote:</p>\n<blockquote>\n<p>Concerning my original confusion: I was wondering how it can be that<br>\nfixing the variable \"a\" influences the behavior of the (invalid) type<br>\nvariable \"a\". I think the answer is that, while type and regular<br>\nvariables are separate, the table that remembers what variables are<br>\nfixed is shared by type and regular variables. Thus fixing the regular<br>\nvariable /a/ also fixes the (invalid) type variable /a/. Is that correct?</p>\n</blockquote>\n<p>The aspect of the context that is relevant here is Name.context /<br>\nVariable.names_of. That sub-context throws type and term variables into<br>\none pot, and implicitly relies on other policies that ensure that they<br>\nare normally not in conflict.</p>\n<p>As you can see in the Variable module, there are further intermediate<br>\nstates of variables, corresponding to declare_names,<br>\ndeclare_constraints, declare_term etc. -- the \"implementation\" manual<br>\nexplains some of this.</p>\n<p>It is particularly important to develop an intuition how implicitly<br>\ndeclared type variables vs. explicitly fixed term variables give you<br>\nHindley-Milner polymorphism in the end. That is the main purpose of the<br>\nwhole affair of managing names formally.</p>\n<blockquote>\n<p>I will try to follow your programming guidelines. But one thing is<br>\nunclear to me in that context: Goal.prove has an argument xs<br>\n(instantiated with [\"l\"] in my example). I thought I can use xs with a<br>\nhardcoded name because Goal.prove will locally fix that variable. Is<br>\nthat incorrect? If it's incorrect, I don't understand how the argument<br>\nxs can be used, because if I get a fresh name via Variable.variant_fixes<br>\nand supply this name in the argument xs, then I get an error that the<br>\nvariable is already fixed. So, I see no way how to use the xs argument.</p>\n</blockquote>\n<p>Goal.prove provides a programming interface that corresponds to Isar<br>\n\"have props if asms for xs\", but Goal.prove uses<br>\nVariable.add_fixes_direct without any implicit name invention. The names<br>\nthat you provide need to be \"free\" in the sense that they can be fixed<br>\nin the current context, e.g. because they were invented properly beforehand.</p>\n<p>Apart from these explicit term variables, you need to take care about<br>\ntype variables occurring in the propositions: Variable.declare_term does<br>\nthat, it ensures that the term is syntactically known to the context.</p>\n<p>Makarius</p>",
        "id": 294731811,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188331
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I am not sure the following situation should be considered a bug or not,<br>\nsince it occurs only when using Isabelle incorrectly. But I feel that it<br>\nprobably indicates that invalid input is not detected in time, and it may<br>\nlead to very hard to understand problems (starting from a typo). So I just<br>\nexplain the problem and leave it to the Isabelle-experts to decide whether<br>\nit indicates a real problem or not.</p>\n<p>The problem is exhibited by the theory below. But in a nutshell, we have<br>\nthe following situation:</p>\n<p>- It is possible to prove a theorem with a type variable called <em>a</em> (not<br>\n<em>'a</em>). I understand that I should not do that, of course. But there is<br>\n   no error when proving the theorem.</p>\n<p>- Then, if we try to use OF with that theorem, we get unexpected<br>\n   failures. But only if <em>a</em> is the name of a fixed variable (not type<br>\n   variable).</p>\n<p>I guess that type variable <em>a</em> should probably just be rejected when trying<br>\nto prove the theorem. But even if not, it is surprising that the existence<br>\nof a fixed variable <em>a</em> makes a difference since I would have assumed that<br>\nfree variables and free type variables have completely independent name<br>\nspaces.</p>\n<p>theory Test<br>\n  imports Main<br>\nbegin</p>\n<p>lemma x: fixes c :: int assumes \"c = d\" shows \"True\" ..</p>\n<p>context fixes a :: int begin</p>\n<p>ML {*<br>\nval ctx = @{context}<br>\nval T = TFree((\"a\"),@{sort type}) (* Note the incorrect \"a\" instead of \"'a\"<br>\n*)<br>\nval l = Free((\"l\"),T)<br>\nval prop = HOLogic.mk_Trueprop (HOLogic.mk_eq (l,l)) (* prop = \"l=l\" *)<br>\nfun tac {context=ctx, ...} = ALLGOALS (simp_tac ctx)<br>\nval thm = Goal.prove ctx [\"l\"] [] prop tac (* proving prop *)<br>\nval _ = @{thm x} OF [thm] (* Fails with \"no unifiers\". But succeeds if<br>\n\"fixes a\" above is \"fixes b\" *)<br>\n*}</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294733474,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188924
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 25/05/18 16:51, Dominique Unruh wrote:</p>\n<blockquote>\n<p>I am not sure the following situation should be considered a bug or not,<br>\nsince it occurs only when using Isabelle incorrectly. But I feel that it<br>\nprobably indicates that invalid input is not detected in time, and it may<br>\nlead to very hard to understand problems (starting from a typo). So I just<br>\nexplain the problem and leave it to the Isabelle-experts to decide whether<br>\nit indicates a real problem or not.</p>\n</blockquote>\n<p>This preface already points in the direction of a \"general user error\",<br>\nor rather a mismatch of expectations vs. the reality of how the system<br>\nworks.</p>\n<blockquote>\n<p>The problem is exhibited by the theory below. But in a nutshell, we have<br>\nthe following situation:</p>\n<p>- It is possible to prove a theorem with a type variable called <em>a</em> (not<br>\n<em>'a</em>). I understand that I should not do that, of course. But there is<br>\n   no error when proving the theorem.<br>\n   - Then, if we try to use OF with that theorem, we get unexpected<br>\n   failures. But only if <em>a</em> is the name of a fixed variable (not type<br>\n   variable).</p>\n<p>I guess that type variable <em>a</em> should probably just be rejected when trying<br>\nto prove the theorem. But even if not, it is surprising that the existence<br>\nof a fixed variable <em>a</em> makes a difference since I would have assumed that<br>\nfree variables and free type variables have completely independent name<br>\nspaces.</p>\n</blockquote>\n<p>There are many different notions of names, variables, contexts etc. and<br>\na lot of system infrastructure to help getting Isabelle/ML tool<br>\nimplementations right. The \"implementation\" manual explains some of this<br>\n-- beyond that it is important to find good examples and study them<br>\ncarefully.</p>\n<p>In general, the programming interfaces are much less typed than one<br>\nmight expect. As a start you should think of Isabelle/ML is a variant of<br>\nLISP with a few static types to avoid utter nonsense. It is important to<br>\nobserve certain disciplines and high-level ideas -- the system often<br>\ndoes not check or cannot check for that.</p>\n<p>For type and term variables, it is usually already an error if literal<br>\nnames appear in the ML text. There are operations to invent fresh<br>\nvariables relative to a certain context -- and using them is mandatory<br>\nto make things work in arbitrary contexts. So it is unlikely to make a<br>\ntypo of \"a\" vs. \"'a\" in ML, because both are already wrong as literal<br>\nvariable names in the source.</p>\n<blockquote>\n<p>val ctx = @{context}</p>\n</blockquote>\n<p>First note that there are hard and fast naming conventions for certain<br>\nbasic Isabelle/ML types (see chapter 0 in the \"implementation\" manual),<br>\nin particular the value above needs to be called \"ctxt\". Otherwise there<br>\nis no chance to understand the source in more complex situations, when<br>\nthere is a serious problem with contexts (the present example is not<br>\nserious yet). The Highlighter of Isabelle/jEdit can be helpful here,<br>\nwhen sources are written in a standard form.</p>\n<blockquote>\n<p>fun tac {context=ctx, ...} = ALLGOALS (simp_tac ctx)</p>\n</blockquote>\n<p>At this spot you are binding the same name \"ctx\" again: this shadowing<br>\nmakes it difficult to understand and change the sources later. Anyway,<br>\nthe forward definition of \"tac\" is better inlined into the Goal.prove<br>\ninvocation, it makes the source more readable and robust.</p>\n<p>Here is that snippet in standard form, optimized for readability:</p>\n<p>ML ‹<br>\nval ctxt = @{context}<br>\nval T = TFree (\"a\", @{sort type})<br>\nval l = Free (\"l\", T)<br>\nval thm =<br>\n  Goal.prove ctxt [\"l\"] [] (HOLogic.mk_Trueprop (HOLogic.mk_eq (l, l)))<br>\n    (fn {context = ctxt', ...} =&gt; ALLGOALS (simp_tac ctxt'))<br>\n›</p>\n<p>Now the development of the local ctxt into ctxt' becomes clear: the<br>\nlatter is the \"eigen-context\" of the goal statement.</p>\n<p>After inspecting contexts, I routinely look at variables and terms vs.<br>\nthese contexts. Above Goal.prove is applied to some proposition that is<br>\nnot declared in the context (e.g. with Variable.declare_term). Omitting<br>\nthat in real applications can lead to really confusing situations with<br>\nthe implicit Hindley-Milner polymorphism and other corner cases.</p>\n<p>See also section \"6.1 Variables\" in the \"implementation\" manual,<br>\nincluding its minimal examples. With that you might produce fresh<br>\ntype/term variables robustly, such that the whole question from the<br>\nstart disappears.</p>\n<p>Makarius</p>",
        "id": 294733520,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188943
    }
]