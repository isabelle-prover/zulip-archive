[
    {
        "content": "<p>From: Omar Montano Rivas &lt;<a href=\"mailto:O.Montano-Rivas-2@sms.ed.ac.uk\">O.Montano-Rivas-2@sms.ed.ac.uk</a>&gt;<br>\nHi all!</p>\n<p>When modifying a theory, for instance using  <br>\n\"FundefPackage.add_fundef_i\", how sould errors be handled? In  <br>\nparticular, catching them and using the original theory results in  <br>\nstale theory errors?</p>\n<p>This is the problematic theory:</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>****)<br>\ntheory Test<br>\nimports Main<br>\nbegin</p>\n<p>datatype numero = Cero | Siguiente numero</p>\n<p>ML {*<br>\nlocal<br>\n  val by_pat_completeness_simp =<br>\n    Proof.global_terminal_proof<br>\n      (Method.Basic (K FundefDatatype.pat_completeness, Position.none),<br>\n       SOME (Method.Source_i (Args.src ((\"<a href=\"http://HOL.auto\">HOL.auto</a>\", []),  <br>\nPosition.none))));</p>\n<p>val termination_by_lexicographic_order =<br>\n    FundefPackage.setup_termination_proof NONE<br>\n    #&gt; Proof.global_terminal_proof<br>\n      (Method.Basic (LexicographicOrder.lexicographic_order [],  <br>\nPosition.none), NONE);<br>\nin<br>\n  fun simple_function name eqs thy =<br>\n    let<br>\n      val group = serial_string ();<br>\n      val config = FundefCommon.FundefConfig<br>\n        {sequential = false, default = \"%x. arbitrary\", domintros =  <br>\nfalse, tailrec = false};<br>\n    in<br>\n      tracing group;<br>\n      TheoryTarget.init NONE thy<br>\n      |&gt; LocalTheory.set_group group<br>\n      |&gt; FundefPackage.add_fundef_i<br>\n        [(name, NONE, NoSyn)] (map (fn t =&gt; ((\"\", []), t)) eqs) config  <br>\n[]<br>\n      |&gt; by_pat_completeness_simp<br>\n      |&gt; LocalTheory.restore<br>\n      |&gt; LocalTheory.set_group group<br>\n      |&gt; termination_by_lexicographic_order<br>\n      |&gt; ProofContext.theory_of<br>\n    end;<br>\nend;</p>\n<p>fun activate_defs eqs thry =<br>\n   case eqs of<br>\n      (name,eqns) :: teq =&gt; activate_defs teq (simple_function name  <br>\neqns thry handle ERROR e =&gt; thry)<br>\n    |     _     =&gt; thry;</p>\n<p>val eqs1 = [@{prop \"DEF1 x Cero = Siguiente x\"},<br>\n@{prop \"DEF1 (x::numero) (Siguiente y) = Siguiente (DEF1 x y)\"}];</p>\n<p>val eqs2 = [@{prop \"DEF2 x Cero = Siguiente x\"},<br>\n@{prop \"DEF2 x y = (DEF2::numero=&gt;numero=&gt;numero) x y\"}];</p>\n<p>val eqs3 = [@{prop \"DEF3 x Cero = (x::numero)\"},<br>\n@{prop \"DEF3 x (Siguiente y) = Siguiente (DEF3 (x::numero) y)\"}];<br>\n*}</p>\n<p>(* This generates the Stale theory error *)<br>\nsetup{*<br>\nactivate_defs [(\"DEF1\",eqs1),(\"DEF2\",eqs2),(\"DEF3\",eqs3)]<br>\n*}</p>\n<p>(* However swapping DEF1 and DEF2 generates no error *)<br>\nsetup{*<br>\nactivate_defs [(\"DEF2\",eqs2),(\"DEF1\",eqs1),(\"DEF3\",eqs3)]<br>\n*}</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>****)</p>\n<p>Thanks in advance!</p>\n<p>Regards,<br>\nOmar Montano</p>",
        "id": 294073222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827918
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAs explained in section 1.1.1 of the Isabelle/Isar Implementation manual, <br>\ntheories are essentially a linear type, with run-time checking of <br>\nnon-linear updates.  In activate_defs above, the application of <br>\nsimple_function can well update thry before raising the ERROR, so thry <br>\npassed in the handler comes out as stale. The Theory.checkpoint operation <br>\ndescribed in the manual is able to amend this. E.g. like this:</p>\n<p>fun activate_defs eqs thy0 =<br>\n  let val thy = Theory.checkpoint thy0 in<br>\n    case eqs of<br>\n       (name,eqns) :: teq =&gt; activate_defs teq (simple_function name <br>\n         eqns thy handle ERROR e =&gt; thy)<br>\n     |     _     =&gt; thy<br>\n  end</p>\n<p>Note that the canonical naming convention for theories is \"thy...\", this <br>\nmakes it easier to do static analysis in such error cases, by <br>\n\"eye-balling\" the sources.</p>\n<p>Anyway, handling general ERROR exceptions like above can easily lead into <br>\nobscure situations -- the error could stem from a quite different spot <br>\nthan you expect.  Which source of ERROR did you have in mind anyway?</p>\n<p>BTW, in the coming release, there will be less situations where stale <br>\ntheories can emerge in regular user code.  I will also try harder to get <br>\nregular ML interfaces for the 'function' package in -- then you do not <br>\nhave to copy half of the command wrapper implementation.</p>\n<p>Makarius</p>",
        "id": 294073325,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827959
    }
]