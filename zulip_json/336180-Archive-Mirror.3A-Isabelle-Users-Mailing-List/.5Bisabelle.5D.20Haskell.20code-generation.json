[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHi all,</p>\n<p>recently I tried to embed some generated code more deeply into the <br>\nHaskell standard library (by using Prelude functions whenever possible). <br>\nThe initial problem (which many of you may know) is that whenever in <br>\nIsabelle you are using \"nat\" the corresponding Haskell function would <br>\nuse either Int or Integer... since many Prelude functions are using Int, <br>\nlets just assume that Int should replace \"nat\" (ignoring the fact that <br>\nnat's may get arbitrarily large but Int's don't).</p>\n<p>First HOL/Library/Efficient_Nat.thy seemed exactly to be what I needed, <br>\nbut unfortunately it doesn't seem to hold what is claimed in the header: <br>\n\"The efficiency of the generated code can be improved<br>\ndrastically by implementing natural numbers by target-language<br>\nintegers.  To do this, just include this theory.\"</p>\n<p>I did just import Efficient_Nat.thy, is there anything else to do <br>\nafterwards (maybe for Haskell Integers are used instead of Int's?).</p>\n<p>Does anybody have experience with using Efficient_Nat for Haskell <br>\ncode-generation?</p>\n<p>cheers</p>\n<p>chris</p>\n<p>A minor comment: the code-generator setup for Haskell (in HOL.thy) <br>\ndeclares \"&amp;&amp;\" and \"||\" as infixl, whereas in Haskell's Prelude they are <br>\ndeclared infixr.</p>",
        "id": 294133823,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843722
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Christian,</p>\n<p>Efficient_Nat does implement nat in terms of Haskell Integer, so the comment is <br>\nnot wrong - provided you import Efficient_Nat as the <em>last</em> theory in your <br>\nimport list in the theory where you invoke the Haskell code generator. Even if <br>\nyou have imported Efficient_Nat in some ancestor theory, reimport it.</p>\n<p>However, nat is not literally translated to Integer, but wraps Integer in a type <br>\nNat (cf. the generated Nat.hs). This seems necessary to do because otherwise <br>\ntype class instantiations could not be Isabelle-specific, e.g., division by 0 is <br>\ndefined in Isabelle whereas not on Haskell integers. See also the comment in <br>\nEfficient_Nat on this.</p>\n<p>The easiest way to use the Haskell standard library is probably to unpack Nat to <br>\nInteger via toInteger and to wrap it back via fromInteger whenever this is <br>\nneeded in your custom translations.</p>\n<p>If you wish to replace Integer by Int, you will have to rewrite Efficent_Nat.thy <br>\nto use Int in all Haskell translations.</p>\n<p>Possibly, Florian can tell you more on that topic.</p>\n<p>Andreas</p>",
        "id": 294133862,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843733
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<blockquote>\n<p>A minor comment: the code-generator setup for Haskell (in HOL.thy)<br>\ndeclares \"&amp;&amp;\" and \"||\" as infixl, whereas in Haskell's Prelude they are<br>\ndeclared infixr.</p>\n</blockquote>\n<p>thanks for pointing that out, this seems to have been wrong from the<br>\nvery beginning.  Fixed in the hg repository (rev b992c8e6394b).</p>\n<blockquote>\n<p>First HOL/Library/Efficient_Nat.thy seemed exactly to be what I needed,<br>\nbut unfortunately it doesn't seem to hold what is claimed in the header:<br>\n\"The efficiency of the generated code can be improved<br>\ndrastically by implementing natural numbers by target-language<br>\nintegers.  To do this, just include this theory.\"</p>\n<p>I did just import Efficient_Nat.thy, is there anything else to do<br>\nafterwards (maybe for Haskell Integers are used instead of Int's?).</p>\n</blockquote>\n<p>Well, for Haskell indeed Integers are used for consistency.  But if your<br>\ncode involves massive computation on considerably large nats,<br>\nEfficient_Nat should bring a considerable speedup.  Maybe the bottleneck<br>\nis somewhere else?  A clear statement requires an inspection of the<br>\ncorresponding code.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/W8Fj751ZVhTDa5deVig9n3-u/signature.asc\">signature.asc</a></p>",
        "id": 294133894,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843740
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nHello Christian,</p>\n<p>we also provide the type code_numeral for Integers (Haskell Integer) for <br>\ncode generation, cf. src/HOL/Code_Numeral.thy</p>\n<p>Currently, in development, I added a type code_int that I map to bounded <br>\nIntegers (Haskell int), cf. src/HOL/Library/Quickcheck_Narrowing.thy<br>\nBut I developed the necessary theory about code_int only as far as I <br>\nneeded it for my purpose.<br>\nI am aware that the code generation setup for code_int could be <br>\npotentially unsound, if you exploit overflows in some tricky way.</p>\n<p>By this replacement, I have measured an overall 50% speed-up by <br>\nreplacing Integer by Int in my setting, the speed-up in the replaced <br>\nparts must be even larger.</p>\n<p>But from my experience, foreseeing or estimating possible performance <br>\nincreases in Isabelle's generated code is a difficult task.<br>\nE.g., it is still unclear to me, if the resulting non-overlapping code <br>\nequations from overlapping sequential function definitions make a <br>\nmeasurable performance difference in the runtime of the generated code.</p>\n<p>Of course, these dedicated types code_numeral and code_int are for some <br>\nvery special purposes,  evaluation by code generation, with ML, nbe and <br>\nquickcheck, in the system.<br>\nThey do not provide much theorems to reason about them, and should be <br>\nchosen with care.</p>\n<p>Hope this helps.</p>\n<p>Lukas</p>",
        "id": 294133917,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843746
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nThanks for all your fast answers,</p>\n<p>just for clarification, I want to use Haskell's Int in order to be able <br>\nto map many functions to Prelude functions (like mapping List.length :: <br>\n'a list =&gt; nat to length :: [a] -&gt; Int). I'm aware that this might lead <br>\nto inconsistencies (as Lukas already pointed out) -- not only because of <br>\npotential overflows but also since you cannot be sure that the Prelude <br>\nimplementation is correct -- but for the time being I just wanted to be <br>\nable to do it anyway :)</p>\n<p>In the end I'm thinking of a \"safe\" version of the generated code and a <br>\n\"fast\" version (using Int's and Prelude functions wherever possible).</p>\n<p>It seems as if what Lukas has developed is exactly what I was searching <br>\nfor. But first I will thoroughly read through the code-generation manual <br>\n(again) ;)</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294133934,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843752
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nOn 03/31/2011 10:56 AM, Christian Sternagel wrote:</p>\n<blockquote>\n<p>Thanks for all your fast answers,</p>\n<p>just for clarification, I want to use Haskell's Int in order to be <br>\nable to map many functions to Prelude functions (like mapping <br>\nList.length :: 'a list =&gt; nat to length :: [a] -&gt; Int). I'm aware that <br>\nthis might lead to inconsistencies (as Lukas already pointed out) -- <br>\nnot only because of potential overflows but also since you cannot be <br>\nsure that the Prelude implementation is correct -- but for the time <br>\nbeing I just wanted to be able to do it anyway :)</p>\n<p>In the end I'm thinking of a \"safe\" version of the generated code and <br>\na \"fast\" version (using Int's and Prelude functions wherever possible).</p>\n<p>It seems as if what Lukas has developed is exactly what I was <br>\nsearching for. But first I will thoroughly read through the <br>\ncode-generation manual (again) ;)<br>\n</p>\n</blockquote>\n<p>If this is of general interest, I am happy to move this development into <br>\na separate theory and incorporate your contributions. But I think we <br>\nshould discuss all the gory details offline.</p>\n<p>Lukas</p>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<p>On 03/31/2011 10:36 AM, Lukas Bulwahn wrote:</p>\n<blockquote>\n<p>Hello Christian,</p>\n<p>we also provide the type code_numeral for Integers (Haskell Integer) for<br>\ncode generation, cf. src/HOL/Code_Numeral.thy</p>\n<p>Currently, in development, I added a type code_int that I map to bounded<br>\nIntegers (Haskell int), cf. src/HOL/Library/Quickcheck_Narrowing.thy<br>\nBut I developed the necessary theory about code_int only as far as I<br>\nneeded it for my purpose.<br>\nI am aware that the code generation setup for code_int could be<br>\npotentially unsound, if you exploit overflows in some tricky way.</p>\n<p>By this replacement, I have measured an overall 50% speed-up by<br>\nreplacing Integer by Int in my setting, the speed-up in the replaced<br>\nparts must be even larger.</p>\n<p>But from my experience, foreseeing or estimating possible performance<br>\nincreases in Isabelle's generated code is a difficult task.<br>\nE.g., it is still unclear to me, if the resulting non-overlapping code<br>\nequations from overlapping sequential function definitions make a<br>\nmeasurable performance difference in the runtime of the generated code.</p>\n<p>Of course, these dedicated types code_numeral and code_int are for some<br>\nvery special purposes, evaluation by code generation, with ML, nbe and<br>\nquickcheck, in the system.<br>\nThey do not provide much theorems to reason about them, and should be<br>\nchosen with care.</p>\n<p>Hope this helps.</p>\n<p>Lukas</p>\n</blockquote>\n<p>On 03/31/2011 09:48 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear Christian,</p>\n<p>Efficient_Nat does implement nat in terms of Haskell Integer, so the<br>\ncomment is not wrong - provided you import Efficient_Nat as the <em>last</em><br>\ntheory in your import list in the theory where you invoke the Haskell<br>\ncode generator. Even if you have imported Efficient_Nat in some<br>\nancestor theory, reimport it.</p>\n<p>However, nat is not literally translated to Integer, but wraps Integer<br>\nin a type Nat (cf. the generated Nat.hs). This seems necessary to do<br>\nbecause otherwise type class instantiations could not be<br>\nIsabelle-specific, e.g., division by 0 is defined in Isabelle whereas<br>\nnot on Haskell integers. See also the comment in Efficient_Nat on this.</p>\n<p>The easiest way to use the Haskell standard library is probably to<br>\nunpack Nat to Integer via toInteger and to wrap it back via<br>\nfromInteger whenever this is needed in your custom translations.</p>\n<p>If you wish to replace Integer by Int, you will have to rewrite<br>\nEfficent_Nat.thy to use Int in all Haskell translations.</p>\n<p>Possibly, Florian can tell you more on that topic.</p>\n<p>Andreas<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294133961,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843758
    }
]