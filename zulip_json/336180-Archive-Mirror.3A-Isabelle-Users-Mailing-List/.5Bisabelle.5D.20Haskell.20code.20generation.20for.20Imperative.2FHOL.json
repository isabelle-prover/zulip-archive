[
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I just played a bit around with Imperative/HOL and got into the following problem:</p>\n<p>I want to use imperative HOL to run some imperative code within a functional program to increase the efficiency of some intermediate computation. So, in particular I need a function similar to Isabelle's “execute”<br>\nor Haskell’s “runST”. </p>\n<p>The following theory describes the problems I ran into, and I would be grateful for any hints.</p>\n<p>Cheers,<br>\nRené</p>\n<p>theory Head_Imperative<br>\n  imports \"~~/src/HOL/Imperative_HOL/Imperative_HOL\"  <br>\n  \"$AFP/Show/Show_Instances\"<br>\n  \"~~/src/HOL/Library/Code_Target_Numeral\"<br>\n  \"~~/src/HOL/Library/Code_Char\"<br>\nbegin</p>\n<p>(* example monadic function: compute the head of a list via arrays *)<br>\ndefinition \"head (xs :: nat list) = do {<br>\n   a &lt;- Array.of_list xs;<br>\n   Array.nth a 0}\" </p>\n<p>lemma head_sound_as_effect: \"xs ≠ [] ⟹ effect (head xs) h (snd (Array.alloc xs h)) (hd xs)\" <br>\n  unfolding head_def <br>\n  (* there clearly is a better proof by using the framework lemmas,<br>\n     but this is not the problem *)<br>\n  by (cases h, cases xs, auto simp: execute_simps effect_def<br>\n    Heap_Monad.heap_def Array.set_def Array.get_def<br>\n   Array.alloc_def o_def Let_def Array.nth_def Array.length_def guard_def)</p>\n<p>definition run_ST :: \"'a Heap ⇒ 'a\" where<br>\n  [code del]: \"run_ST h = fst (the (execute h (undefined ''heap'')))\" (* or Heap.empty *)</p>\n<p>(* run_ST admits to go outside the ST monad again and reason via the<br>\n   functional result of the computation  *)<br>\nlemma run_ST_effect: assumes \"⋀ h. ∃ h'. effect c h h' r\"<br>\n  shows \"run_ST c = r\" <br>\nproof -<br>\n  from assms obtain h' where \"effect c (undefined ''heap'') h' r\" by auto<br>\n  thus ?thesis unfolding run_ST_def effect_def by simp<br>\nqed</p>\n<p>definition \"head_functional xs = run_ST (head xs)\" </p>\n<p>lemma head_sound_as_functional_program: \"xs ≠ [] ⟹ head_functional xs = hd xs\" <br>\n  unfolding head_functional_def<br>\n  using run_ST_effect head_sound_as_effect by metis</p>\n<p>(* this code belongs into the code-setup for Heap, cf. the code-printing in Heap_Monad *)<br>\ncode_printing constant run_ST ⇀ (Haskell) \"RunST.runST\"</p>\n<p>code_printing code_module \"RunST\" ⇀ (Haskell)<br>\n‹import qualified Control.Monad.ST; <br>\nrunST = Control.Monad.ST.runST;›</p>\n<p>definition \"test = show (head_functional [17,90,2])\"<br>\nexport_code test in Haskell module_name Head</p>\n<p>(* the problem now is the type-signature in the generated code of</p>\n<p>nth ::<br>\n  forall a.<br>\n    (Heapa a) =&gt; Heap.STArray Heap.RealWorld a -&gt;<br>\n                   Nat -&gt; Heap.ST Heap.RealWorld a;<br>\nnth a n = Heap.readArray a (integer_of_nat n);</p>\n<p>and</p>\n<p>head :: [Nat] -&gt; Heap.ST Heap.RealWorld Nat;<br>\nhead xs = do { <br>\n            a &lt;- Heap.newListArray xs;<br>\n            nth a zero_nat<br>\n           };</p>\n<p>because of the code_printing setup in Heap_Monad</p>\n<p>type RealWorld = Control.Monad.ST.RealWorld; </p>\n<p>type_constructor Heap ⇀ (Haskell) \"Heap.ST/ Heap.RealWorld/ _\"</p>\n<p>The problem is that the type of the Haskell function runST is of<br>\ntype forall a. ((forall s. ST s a) -&gt; a), so that in particular the<br>\n  state in the ST monad must be arbitrary, but not a fixed type like RealWorld.</p>\n<p>So, the proper code-printing would be </p>\n<p>type_constructor Heap ⇀ (Haskell) \"Heap.ST/ s/ _\" </p>\n<p>where \"s\" is some additional type variable. (ST in Haskell requires<br>\ntwo type parameters, one for state, the other for the return type). </p>\n<p>Now there is the problem, that I don't know how to tell the code-generator<br>\nto observe the heap/ST type as binary, although it is unary in Isabelle.</p>\n<p>In particular, the type of nth and head have to become</p>\n<p>nth ::<br>\n  forall a s.<br>\n    (Heapa a) =&gt; Heap.STArray s a -&gt; Nat -&gt; Heap.ST s a;</p>\n<p>head :: forall s. [Nat] -&gt; Heap.ST s Nat;</p>\n<p>where the s is quantified. Once one performs this change, compilation and<br>\nexecution works as expected.</p>\n<p>*)<br>\nend</p>",
        "id": 294691450,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177935
    },
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nA small update:</p>\n<p>one can use</p>\n<p>code_printing code_module \"RunST\" ⇀ (Haskell)<br>\n‹import qualified Control.Monad.ST; <br>\nimport qualified System.IO.Unsafe;<br>\nrunST = System.IO.Unsafe.unsafePerformIO . Control.Monad.ST.stToIO;›</p>\n<p>to make the generated code compile. However, this seems a bit odd to use<br>\nthe unsafePerformIO-operation where there is the safe runST in Haskell.</p>\n<p>Cheers,<br>\nRené</p>\n<p>PS: The problem appears both in Isabelle2016 and Isabelle2016-1-RC0</p>",
        "id": 294691467,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177941
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Rene,</p>\n<p>Am 21.10.2016 um 08:16 schrieb Thiemann, Rene:</p>\n<blockquote>\n<p>A small update:</p>\n<p>one can use</p>\n<p>code_printing code_module \"RunST\" ⇀ (Haskell)<br>\n‹import qualified Control.Monad.ST; <br>\nimport qualified System.IO.Unsafe;<br>\nrunST = System.IO.Unsafe.unsafePerformIO . Control.Monad.ST.stToIO;›</p>\n<p>to make the generated code compile. However, this seems a bit odd to use<br>\nthe unsafePerformIO-operation where there is the safe runST in Haskell.</p>\n</blockquote>\n<p>this indeed is the core of the problem: there is a safe runST in<br>\nHaskell, but I have found no way to express this adequately in the HOL<br>\ntype system.  Early code generation setups for Imperative HOL attempted<br>\nthis but that never worked out.</p>\n<p>Hope this helps,<br>\n    Florian</p>\n<blockquote>\n<p>Cheers,<br>\nRené</p>\n<p>PS: The problem appears both in Isabelle2016 and Isabelle2016-1-RC0</p>\n<blockquote>\n<p>Am 20.10.2016 um 23:50 schrieb Thiemann, Rene &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;:</p>\n<p>Dear all,</p>\n<p>I just played a bit around with Imperative/HOL and got into the following problem:</p>\n<p>I want to use imperative HOL to run some imperative code within a functional program to increase the efficiency of some intermediate computation. So, in particular I need a function similar to Isabelle's “execute”<br>\nor Haskell’s “runST”. </p>\n<p>The following theory describes the problems I ran into, and I would be grateful for any hints.</p>\n<p>Cheers,<br>\nRené</p>\n<p>theory Head_Imperative<br>\n imports \"~~/src/HOL/Imperative_HOL/Imperative_HOL\"  <br>\n \"$AFP/Show/Show_Instances\"<br>\n \"~~/src/HOL/Library/Code_Target_Numeral\"<br>\n \"~~/src/HOL/Library/Code_Char\"<br>\nbegin</p>\n<p>(* example monadic function: compute the head of a list via arrays *)<br>\ndefinition \"head (xs :: nat list) = do {<br>\n  a &lt;- Array.of_list xs;<br>\n  Array.nth a 0}\" </p>\n<p>lemma head_sound_as_effect: \"xs ≠ [] ⟹ effect (head xs) h (snd (Array.alloc xs h)) (hd xs)\" <br>\n unfolding head_def <br>\n (* there clearly is a better proof by using the framework lemmas,<br>\n    but this is not the problem *)<br>\n by (cases h, cases xs, auto simp: execute_simps effect_def<br>\n   Heap_Monad.heap_def Array.set_def Array.get_def<br>\n  Array.alloc_def o_def Let_def Array.nth_def Array.length_def guard_def)</p>\n<p>definition run_ST :: \"'a Heap ⇒ 'a\" where<br>\n [code del]: \"run_ST h = fst (the (execute h (undefined ''heap'')))\" (* or Heap.empty *)</p>\n<p>(* run_ST admits to go outside the ST monad again and reason via the<br>\n  functional result of the computation  *)<br>\nlemma run_ST_effect: assumes \"⋀ h. ∃ h'. effect c h h' r\"<br>\n shows \"run_ST c = r\" <br>\nproof -<br>\n from assms obtain h' where \"effect c (undefined ''heap'') h' r\" by auto<br>\n thus ?thesis unfolding run_ST_def effect_def by simp<br>\nqed</p>\n<p>definition \"head_functional xs = run_ST (head xs)\" </p>\n<p>lemma head_sound_as_functional_program: \"xs ≠ [] ⟹ head_functional xs = hd xs\" <br>\n unfolding head_functional_def<br>\n using run_ST_effect head_sound_as_effect by metis</p>\n<p>(* this code belongs into the code-setup for Heap, cf. the code-printing in Heap_Monad *)<br>\ncode_printing constant run_ST ⇀ (Haskell) \"RunST.runST\"</p>\n<p>code_printing code_module \"RunST\" ⇀ (Haskell)<br>\n‹import qualified Control.Monad.ST; <br>\nrunST = Control.Monad.ST.runST;›</p>\n<p>definition \"test = show (head_functional [17,90,2])\"<br>\nexport_code test in Haskell module_name Head</p>\n<p>(* the problem now is the type-signature in the generated code of</p>\n<p>nth ::<br>\n forall a.<br>\n   (Heapa a) =&gt; Heap.STArray Heap.RealWorld a -&gt;<br>\n                  Nat -&gt; Heap.ST Heap.RealWorld a;<br>\nnth a n = Heap.readArray a (integer_of_nat n);</p>\n<p>and</p>\n<p>head :: [Nat] -&gt; Heap.ST Heap.RealWorld Nat;<br>\nhead xs = do { <br>\n           a &lt;- Heap.newListArray xs;<br>\n           nth a zero_nat<br>\n          };</p>\n<p>because of the code_printing setup in Heap_Monad</p>\n<p>type RealWorld = Control.Monad.ST.RealWorld; </p>\n<p>type_constructor Heap ⇀ (Haskell) \"Heap.ST/ Heap.RealWorld/ _\"</p>\n<p>The problem is that the type of the Haskell function runST is of<br>\ntype forall a. ((forall s. ST s a) -&gt; a), so that in particular the<br>\n state in the ST monad must be arbitrary, but not a fixed type like RealWorld.</p>\n<p>So, the proper code-printing would be </p>\n<p>type_constructor Heap ⇀ (Haskell) \"Heap.ST/ s/ _\" </p>\n<p>where \"s\" is some additional type variable. (ST in Haskell requires<br>\ntwo type parameters, one for state, the other for the return type). </p>\n<p>Now there is the problem, that I don't know how to tell the code-generator<br>\nto observe the heap/ST type as binary, although it is unary in Isabelle.</p>\n<p>In particular, the type of nth and head have to become</p>\n<p>nth ::<br>\n forall a s.<br>\n   (Heapa a) =&gt; Heap.STArray s a -&gt; Nat -&gt; Heap.ST s a;</p>\n<p>head :: forall s. [Nat] -&gt; Heap.ST s Nat;</p>\n<p>where the s is quantified. Once one performs this change, compilation and<br>\nexecution works as expected.</p>\n<p>*)<br>\nend</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/gD84zk0z8xCW9N-ToZZ5yaq8/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294701112,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179205
    }
]