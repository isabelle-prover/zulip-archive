[
    {
        "content": "<p>From: <a href=\"mailto:Primrose.Mbanefo@Infineon.com\">Primrose.Mbanefo@Infineon.com</a><br>\nHello,</p>\n<p>I have a list (a \"nat list\") with N elements.</p>\n<p>I assume that the elements which come before the i-th element are all<br>\nless than or equal to i.</p>\n<p>I would like to say that if the i+1th element is also less than or equal<br>\nto the i-th element, <br>\nthen if I exchange the elements in the ith and i+1th positions <br>\nthen all elements upto i+1 are less than or equal to the i+1-th element.</p>\n<p>I thought this should look like this:<br>\n\\&lt;forall&gt; j. (j + 1) &lt; length xs \\&lt;and&gt; xs!j &lt; ((xs!(j+1))::nat)<br>\n\\&lt;longrightarrow&gt; (\\&lt;forall&gt;i &lt; j. xs!j &lt; xs!i \\&lt;longrightarrow&gt;<br>\n(\\&lt;forall&gt;k \\&lt;le&gt; j+1. xs[j:=xs!(j+1),(j+1) := xs!j]!(j+1) \\&lt;le&gt;<br>\nxs[j:=xs!(j+1),(j+1):=xs!j]!k))</p>\n<p>I thought the best thing to do would be to prove a slightly simpler<br>\nversion first which states that if all the elements in positions less<br>\nthan i are less than/equal to the ith element and also that the i+1st<br>\nelement is less than/equal to the ith element then all the elements upto<br>\ni+1 should be less than/equal to the ith element.</p>\n<p>I have tried to formulate this in different ways but the formulation I<br>\nbelieve comes close to what I am looking for is:<br>\n\\&lt;forall&gt; j. (j + 1) &lt; length xs \\&lt;and&gt; xs!j &lt; ((xs!(j+1))::nat)<br>\n\\&lt;longrightarrow&gt; (\\&lt;forall&gt;i &lt; j. xs!j &lt; xs!i \\&lt;longrightarrow&gt;<br>\n(\\&lt;forall&gt;k \\&lt;le&gt; j+1. xs!j \\&lt;le&gt; xs!k) ) )</p>\n<p>But I am not capable of proving anything about this statement. I tried<br>\ndoing the induction on xs or on j (after removing its quantification)<br>\nbut I didn't go very far.</p>\n<p>Trying to reason about the sets involved didn't bring much. Notably, I<br>\nam wondering why I couldn't prove the below using an induction on the<br>\nlist xs.:<br>\n \\&lt;forall&gt;n j . n &lt; j \\&lt;longrightarrow&gt; (\\&lt;forall&gt;(i::nat) \\&lt;in&gt; set xs.<br>\nn &lt; i \\&lt;longrightarrow&gt; ( \\&lt;forall&gt;k \\&lt;in&gt; set xs \\&lt;union&gt; {j}. n &lt; k) )</p>\n<p>I do not believe I understand what quantification actually is...</p>\n<p>Could anyone tell me what is wrong with these formulations and how I can<br>\nstart reasoning about these?</p>\n<p>Thanks in advance!</p>\n<p>Regards,<br>\nPrimrose</p>",
        "id": 293899834,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660744008
    },
    {
        "content": "<p>From: Martin Ellis &lt;<a href=\"mailto:m.a.ellis@ncl.ac.uk\">m.a.ellis@ncl.ac.uk</a>&gt;<br>\nOn Friday 24 February 2006 15:51, <a href=\"mailto:Primrose.Mbanefo@infineon.com\">Primrose.Mbanefo@infineon.com</a> wrote:</p>\n<blockquote>\n<p>I assume that the elements which come before the i-th element are all<br>\nless than or equal to i.</p>\n</blockquote>\n<p>That's a mouthful.  Call it 'P':<br>\nconstdefs<br>\n\"P (xs::nat list) == ALL i. i &lt; length xs --&gt; xs!i &lt;= i\"</p>\n<p>(I'm using the ASCII notation here, see the tutorial appendix for the prettier <br>\nrepresentation)</p>\n<blockquote>\n<p>I would like to say that if the i+1th element is also less than or equal<br>\nto the i-th element,<br>\nthen if I exchange the elements in the ith and i+1th positions<br>\nthen all elements upto i+1 are less than or equal to the i+1-th element.</p>\n</blockquote>\n<p>You can start by defining 'exchange the elements'.  Might as well make it for <br>\nany two elements, no need to limit ourselves to consecutive elements:</p>\n<p>constdefs<br>\n\"listswap xs i j == xs[i := xs ! j, j := xs ! i]\"</p>\n<p>The function \"preserves the length of xs\", in the sense that it's result is <br>\nthe same length.  You don't need this property, but it can tidy up the proof <br>\nstates you see later if you have these lemmas:</p>\n<p>lemma listswap_length:<br>\n  \"!! i j xs. i &lt; length xs &amp; j &lt; length xs --&gt;<br>\n              length (listswap xs i j) = length xs\"<br>\n  apply(induct_tac i)<br>\n  by(auto simp add:listswap_def)</p>\n<p>lemma listswap_length2:<br>\n  \"[| i&lt; length xs; j &lt; length xs |] ==&gt; length (listswap xs i j) = length xs\"<br>\n  by(simp add: listswap_length)</p>\n<p>(Is there an easier way to get the latter?)</p>\n<blockquote>\n<p>I thought this should look like this:<br>\n\\&lt;forall&gt; j. (j + 1) &lt; length xs \\&lt;and&gt; xs!j &lt; ((xs!(j+1))::nat)<br>\n\\&lt;longrightarrow&gt; (\\&lt;forall&gt;i &lt; j. xs!j &lt; xs!i \\&lt;longrightarrow&gt;<br>\n(\\&lt;forall&gt;k \\&lt;le&gt; j+1. xs[j:=xs!(j+1),(j+1) := xs!j]!(j+1) \\&lt;le&gt;<br>\nxs[j:=xs!(j+1),(j+1):=xs!j]!k))</p>\n</blockquote>\n<p>Firstly, the \"\\&lt;forall&gt;i &lt; j. xs!j &lt; xs!i\" doesn't seem to correspond with <br>\nanything in your English description.</p>\n<p>You seem to be missing either the assumption that P already holds of the list <br>\nin the first place, or it holds for some initial number of elements, <br>\ndepending on what you're trying to prove.  If it doesn't already hold, then <br>\nyour exchange wont fix that property.  </p>\n<p>Not sure whether you want to assume P true of the whole list, or just up to a <br>\ngiven element.  Assuming the former, you could write:</p>\n<p>lemma \"P xs --&gt; <br>\n              (ALL j. j &lt; (length xs - 1) --&gt;<br>\n                 xs!(j+1) &lt;= xs!j --&gt;<br>\n                    P (listswap xs j (j+1)) )\"</p>\n<p>You should see that that much more closely matches your English description <br>\nabove. (\"P xs\" is the first paragraph of yours I quoted, etc.)</p>\n<p>Using the listswap_length lemma, the last line will expand to:<br>\n   ALL i &lt; length xs. listswap xs j (j+1) ! i &lt;= i</p>\n<p>So there are three cases to consider:</p>\n<ul>\n<li>where xs!i is the element at j (i.e. i = j)</li>\n<li>where xs!i is the element at j+1 (i = j+1)</li>\n<li>where i is an element unaffected by the exchange.<br>\nThe proof of that falls out fairly straight-forwardly.</li>\n</ul>\n<p>Is that the goal you're trying to prove?  If not, and you want P to be a <br>\nproperty only of the first n elements, then redefine it to be a predicate<br>\nP (xs::nat list) (n::nat), rather than P (xs::nat list).</p>\n<p>Hope that gives you a start.</p>\n<p>Martin</p>",
        "id": 293899838,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660744009
    },
    {
        "content": "<p>From: <a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a><br>\nThanks for answering that one, Martin.</p>\n<blockquote>\n<p>(Is there an easier way to get the latter?)</p>\n</blockquote>\n<p>Yes, induction is not needed because the relevant lemma about length and<br>\nlist-updaate is already known:</p>\n<p>lemma listswap_length2:<br>\n  \"[| i&lt; length xs; j &lt; length xs |] ==&gt; length (listswap xs i j) = length xs\"<br>\n  by(simp add: listswap_def)</p>\n<p>Tobias</p>",
        "id": 293899847,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660744011
    },
    {
        "content": "<p>From: <a href=\"mailto:Primrose.Mbanefo@Infineon.com\">Primrose.Mbanefo@Infineon.com</a><br>\nThanks a whole lot for the replies!</p>\n<blockquote>\n<p>Firstly, the \"\\&lt;forall&gt;i &lt; j. xs!j &lt; xs!i\" doesn't seem to correspond<br>\nwith anything in your English description.</p>\n</blockquote>\n<p>I definetly did make a mistake in the english formulation of the<br>\nproblem.</p>\n<p>I am studying your approach now and I believe I can start something<br>\n(actually a whole lot) with this. <br>\nI am now beginning to think my problem is that I am not used to this<br>\nverification snowballing effect where verifying one thing leads to<br>\ndescribing or verifying something smaller or more general.</p>\n<p>I will get back once I have been able to do something (or when I am<br>\nstuck again :))</p>\n<p>Thanks once more.<br>\nPrimrose</p>",
        "id": 293899859,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660744013
    },
    {
        "content": "<p>From: <a href=\"mailto:Primrose.Mbanefo@Infineon.com\">Primrose.Mbanefo@Infineon.com</a><br>\nHello,<br>\nI corrected the specification and simplified it so that P is valid on the entire list (to make the proof simpler for me).</p>\n<p>P now looks like:<br>\nconstdefs <br>\n\"P (xs::nat list) Y == \\&lt;forall&gt;i &lt; length xs. xs!i \\&lt;le&gt; Y\"</p>\n<p>And the lemma I am trying to prove is:<br>\nlemma \"P xs Y \\&lt;longrightarrow&gt; (\\&lt;forall&gt; j. j &lt; (length xs - 1) \\&lt;longrightarrow&gt; P (listswap xs j (j+1)) Y)\"</p>\n<p>And I am still using the listswap and listswap_length.</p>\n<p>I have tried to prove that lemma in different ways and failed.<br>\nThe formulation of the proof which reflects my current try looks like:</p>\n<p>lemma \"P xs Y \\&lt;longrightarrow&gt; (\\&lt;forall&gt; j. j &lt; (length xs - 1) \\&lt;longrightarrow&gt; P (listswap xs j (j+1)) Y)\"<br>\nproof (simp add: listswap_length P_def)<br>\n  have \"P xs Y \\&lt;longrightarrow&gt; (\\&lt;forall&gt; j. Suc j &lt; length xs \\&lt;longrightarrow&gt; <br>\n    (\\&lt;forall&gt;i. i &lt; length xs \\&lt;longrightarrow&gt; <br>\n    (i \\&lt;noteq&gt; j \\&lt;and&gt; i \\&lt;noteq&gt; (Suc j) <br>\n        \\&lt;longrightarrow&gt; (listswap xs j (Suc j))!i \\&lt;le&gt; Y))) \"<br>\n    by (simp add: listswap_def P_def)<br>\n  also have \"P xs Y \\&lt;longrightarrow&gt; (\\&lt;forall&gt; j. Suc j &lt; length xs \\&lt;longrightarrow&gt; <br>\n    (\\&lt;forall&gt;i. i = j \\&lt;longrightarrow&gt; (listswap xs j (Suc j))!j \\&lt;le&gt; Y))\"<br>\n    by (simp add: listswap_def P_def) <br>\n  oops<br>\n  also have \"P xs Y \\&lt;longrightarrow&gt; (\\&lt;forall&gt; j. Suc j &lt; length xs \\&lt;longrightarrow&gt; <br>\n    (\\&lt;forall&gt;i. (i = (Suc j)) \\&lt;longrightarrow&gt; (listswap xs j (Suc j))!(Suc j) \\&lt;le&gt; Y))\"<br>\n    by (simp add: listswap_def P_def)    <br>\n  finally show ?thesis apply ()<br>\n  qed</p>\n<p>With the oops showing where it breaks.<br>\nIsn't this a valid way of breaking down this proof?</p>\n<p>Thanks for your help!</p>\n<p>Regards,</p>\n<p>Primrose</p>\n<p>P.S: Also how do you convert the X-Symbols to ascii?</p>",
        "id": 293899865,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660744014
    }
]