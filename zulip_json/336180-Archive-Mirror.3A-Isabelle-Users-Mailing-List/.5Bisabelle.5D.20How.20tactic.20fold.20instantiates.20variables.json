[
    {
        "content": "<p>From: Daniel Raggi &lt;<a href=\"mailto:danielraggi@gmail.com\">danielraggi@gmail.com</a>&gt;<br>\nI'm having trouble understanding something. Let me explain:</p>\n<p>When folding a definition, why would someone (in some cases), need to<br>\nspecify instantiations of variables using [where \"X = ...\"]?</p>\n<p>I can see how it's useful to do it in some cases to avoid having to<br>\nbacktrack.</p>\n<p>I've defined function <em>fadd</em> as follows:<br>\n<em>definition \"fadd M N = (λa. M a + N a)\"</em></p>\n<p>purely as a test, I have the following goal to prove:<br>\n<em>lemma \"(λx. 0 + 0) = (λx. 0)\"</em></p>\n<p>However, when I try this:<br>\n<em>lemma \"(λx. 0 + 0) = (λx. 0)\"</em></p>\n<ul>\n<li>apply (fold fadd_def)*</li>\n</ul>\n<p>I get *(λx. fadd (λa. 0) (λa. a) 0) = (λx. 0) *as a result. However, if I<br>\ntry:<br>\nlemma \"(λx. 0 + 0) = (λx. 0)\"</p>\n<ul>\n<li>apply (fold fadd_def[where M = \"λx. 0\" and N = \"λx. 0\"]) *</li>\n</ul>\n<p>I get what I want, which is <em>fadd (λx. 0) (λx. 0) = (λx. 0)</em>.</p>\n<p>I'm a bit confused, because in the case of *apply (fold fadd_def) *I'm not<br>\neven getting what I want, even when using <em>back</em>. Can anyone point me at<br>\nwhy my desired instantiation of variables is not tried?</p>\n<p>Thanks a lot to anyone who minds taking a look at this.</p>\n<p>Best,<br>\nDaniel</p>",
        "id": 294642010,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162501
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n(This old thread still looks unsettled.)</p>\n<p>On Fri, 29 May 2015, Daniel Raggi wrote:</p>\n<blockquote>\n<p>When folding a definition, why would someone (in some cases), need to<br>\nspecify instantiations of variables using [where \"X = ...\"]?</p>\n<p>I can see how it's useful to do it in some cases to avoid having to<br>\nbacktrack.</p>\n</blockquote>\n<p>First note that (fold eq) is the same as (unfold eq [symmetric]).</p>\n<p>For more than one equation, there is a slight difference in the initial <br>\norder, although the details are unclear to me; see <br>\nsrc/Pure/raw_simplifer.ML:</p>\n<p>val rev_defs = sort_lhs_depths o map Thm.symmetric;</p>\n<p>Larry might be able to explain that code \"from the depths of time\", as he <br>\nusually says; see<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/e7588b53d6b0\">http://isabelle.in.tum.de/repos/isabelle/rev/e7588b53d6b0</a></p>\n<p>Back to \"unfold\".  That is just the Simplifier with its usual policies, <br>\nsee also the isar-ref manual section 9.3 \"The Simplifier\".  The main <br>\nstrategy is bottom-up rewriting with higher-order patterns.</p>\n<p>There is no support for back-tracking in the rewrite engine, so the <br>\ncommand 'back' normally does not make any sense with applications of <br>\n\"unfold\", \"simp\" etc.  (In principle some wrapper tactics of the <br>\nsimplifier can produce more than one result for back-tracking.)</p>\n<blockquote>\n<p>I've defined function <em>fadd</em> as follows:<br>\n<em>definition \"fadd M N = (λa. M a + N a)\"</em></p>\n<p>purely as a test, I have the following goal to prove:<br>\n<em>lemma \"(λx. 0 + 0) = (λx. 0)\"</em></p>\n<p>However, when I try this:<br>\n<em>lemma \"(λx. 0 + 0) = (λx. 0)\"</em>\n*  apply (fold fadd_def)*</p>\n<p>I get *(λx. fadd (λa. 0) (λa. a) 0) = (λx. 0) *as a result. However, if I<br>\ntry:<br>\nlemma \"(λx. 0 + 0) = (λx. 0)\"\n*  apply (fold fadd_def[where M = \"λx. 0\" and N = \"λx. 0\"]) *</p>\n<p>I get what I want, which is <em>fadd (λx. 0) (λx. 0) = (λx. 0)</em>.</p>\n<p>I'm a bit confused, because in the case of *apply (fold fadd_def) *I'm not<br>\neven getting what I want, even when using <em>back</em>. Can anyone point me at<br>\nwhy my desired instantiation of variables is not tried?</p>\n</blockquote>\n<p>Looking quickly over the example, it looks as an expected result of <br>\nbottom-up rewriting.</p>\n<p>What you want, might be something else.  Depending on the application, you <br>\ncan try a simproc to determine instantiations in ML, or you can try to <br>\nimplement your very own replacement strategy as a conversion in ML.</p>\n<p>The latter is actually easier than writing common tactics, although less <br>\nknown.  The starting point is src/Pure/conv.ML and examples may be found <br>\nin existing Isabelle sources, although that structure Conv is exceptional <br>\nin being used as \"open\" in Isabelle/ML, i.e. it requires a hypersearch <br>\nwith unqualified names.</p>\n<p>Makarius</p>",
        "id": 294644674,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163556
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI don’t have anything to explain about the code, other than to note that the comments refer to critical pairs. This is a reminder that a set of rewrite rules can be ambiguous. Instantiating variables is one way to cope with ambiguity, and it also helps if folding the right hand side would involve higher-order matching.</p>\n<p>Larry Paulson</p>",
        "id": 294644861,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163629
    }
]