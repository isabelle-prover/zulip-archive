[
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nHi!</p>\n<p>Consider the following attempt of a locale definition:</p>\n<p>locale example =<br>\n      fixes R :: \"['a, 'a] ⇒ bool\"<br>\n      assumes is_equivalence: \"equivp R\"<br>\n    begin</p>\n<p>quotient_type Q = 'a / R</p>\n<p>end</p>\n<p>Isabelle doesn’t accept the use of the type variable <code>'a</code> in the<br>\nquotient type definition, although it does accept referring to <code>'a</code> in<br>\ntypes. How can I define a quotient type for the type <code>'a</code>?</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294760244,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199204
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Wolfgang Jeltsch,</p>\n<p>I am not an expert in this subject and, hopefully, someone more<br>\nknowledgeable will correct me if I am wrong. However, as far as I know,<br>\neven the plain typedecl does not accept fixed type variables.  Of course,<br>\ninternally the command quotient_type relies on the same mechanism for the<br>\ndeclaration of new types. Therefore, it is not possible to use the command<br>\nquotient_type to obtain the result that you need.</p>\n<p>Anecdotally, the Local Typedef Rule (LT) axiom associated with<br>\nTypes-To-Sets can be used to solve the problem that you are dealing with,<br>\nbut, as far as I know, with some restrictions. Effectively, the Local<br>\nTypedef Rule (LT) states the following:</p>\n<p>(*<br>\nLocal Typedef Rule (LT)</p>\n<p>Γ ⊢ (∃(Rep::β ⇒ τ) Abs. type_definition Rep Abs A) ⟹ φ</p>\n<hr>\n<p>[β not in φ, Γ, A;<br>\n                       Γ ⊢ A ≠ ∅ ⟹ φ<br>\n sort(β)=HOL.type]<br>\n*)</p>\n<p>Given that Rep, Abs and A are arbitrary (of course, A should not be empty),<br>\nit is not too difficult to define the ones suitable for a quotient type for<br>\nsome relation R. Nevertheless, there is a restriction \"β not in φ\", which,<br>\nfor your problem, might be too much to bear. In essence, you will be able<br>\nto use β as the quotient type, prove theorems about it, but these theorems<br>\ncan only be used within the context with the assumption \"∃(Rep::β ⇒ τ set)<br>\nAbs. type_definition Rep Abs A\". To use them outside of this context, you<br>\nwill need to transfer them back to the original type τ. This process can be<br>\nautomated completely using the capabilities of the transfer package.<br>\nNevertheless, I appreciate that this may be a substantial restriction for<br>\nyour use case.</p>\n<p>The example below demonstrates, vaguely, how the 'Local Quotient Rule'<br>\nmight work (of course, you need to import Types-To-Sets from the main<br>\nlibrary to run the example). If you are interested, I can add something<br>\nakin to a 'Local Quotient Rule' (which would, effectively, hide all the<br>\nugly details in the example below and complete it with the instantiation of<br>\nall quotient theorems and transfer rules) to my extension of Types-To-Sets (<br>\n<a href=\"https://github.com/xanonec/HOL-TTS-Ext\">https://github.com/xanonec/HOL-TTS-Ext</a>).</p>\n<p>Thank you</p>\n<p>locale local_typedef =<br>\n  fixes R :: \"['a, 'a] ⇒ bool\"<br>\n  assumes is_equivalence: \"equivp R\"<br>\nbegin</p>\n<p>(*The exposition subsumes some of the content of<br>\n HOL/Types_To_Sets/Examples/Prerequisites.thy*)<br>\ncontext<br>\n  fixes S and s :: \"'s itself\"<br>\n  defines S: \"S ≡ {x. ∃u. x = {v. R u v}}\"<br>\n  assumes Ex_type_definition_S:<br>\n    \"∃(Rep::'s ⇒ 'a set) (Abs::'a set ⇒ 's). type_definition Rep Abs S\"<br>\nbegin</p>\n<p>definition \"rep = fst (SOME (Rep::'s ⇒ 'a set, Abs). type_definition Rep<br>\nAbs S)\"<br>\ndefinition \"Abs = snd (SOME (Rep::'s ⇒ 'a set, Abs). type_definition Rep<br>\nAbs S)\"</p>\n<p>definition \"rep' a = (SOME x. a ∈ S ⟶ x ∈ a)\"<br>\ndefinition \"Abs' x = (SOME a. a ∈ S ∧ a = {v. R x v})\"</p>\n<p>definition \"rep'' = rep' o rep\"<br>\ndefinition \"Abs'' = Abs o Abs'\"</p>\n<p>lemma type_definition_S: \"type_definition rep Abs S\"<br>\n  unfolding Abs_def rep_def split_beta'<br>\n  by (rule someI_ex) (use Ex_type_definition_S in auto)</p>\n<p>lemma rep_in_S[simp]: \"rep x ∈ S\"<br>\n  and rep_inverse[simp]: \"Abs (rep x) = x\"<br>\n  and Abs_inverse[simp]: \"y ∈ S ⟹ rep (Abs y) = y\"<br>\n  using type_definition_S<br>\n  unfolding type_definition_def by auto</p>\n<p>definition cr_S where \"cr_S ≡ λs b. s = rep b\"<br>\nlemmas Domainp_cr_S = type_definition_Domainp[OF type_definition_S<br>\ncr_S_def, transfer_domain_rule]<br>\nlemmas right_total_cr_S = typedef_right_total[OF type_definition_S<br>\ncr_S_def, transfer_rule]<br>\n  and bi_unique_cr_S = typedef_bi_unique[OF type_definition_S cr_S_def,<br>\ntransfer_rule]<br>\n  and left_unique_cr_S = typedef_left_unique[OF type_definition_S cr_S_def,<br>\ntransfer_rule]<br>\n  and right_unique_cr_S = typedef_right_unique[OF type_definition_S<br>\ncr_S_def, transfer_rule]</p>\n<p>lemma cr_S_rep[intro, simp]: \"cr_S (rep a) a\" by (simp add: cr_S_def)<br>\nlemma cr_S_Abs[intro, simp]: \"a∈S ⟹ cr_S a (Abs a)\" by (simp add: cr_S_def)</p>\n<p>(* this part was sledgehammered - please do not pay attention to the<br>\n(absence of) proof style *)<br>\nlemma r1: \"∀a. Abs'' (rep'' a) = a\"<br>\n  unfolding Abs''_def rep''_def comp_def<br>\nproof-<br>\n  {<br>\n    fix s'<br>\n    note repS = rep_in_S[of s']<br>\n    then have \"∃x. x ∈ rep s'\" using S equivp_reflp is_equivalence by force<br>\n    then have \"rep' (rep s') ∈ rep s'\"<br>\n      using repS unfolding rep'_def by (metis verit_sko_ex')<br>\n    moreover with is_equivalence repS have \"rep s' = {v. R (rep' (rep s'))<br>\nv}\"<br>\n      by (smt CollectD S equivp_def)<br>\n    ultimately have arr: \"Abs' (rep' (rep s')) = rep s'\"<br>\n      unfolding Abs'_def by (smt repS some_sym_eq_trivial verit_sko_ex')<br>\n    have \"Abs (Abs' (rep' (rep s'))) = s'\" unfolding arr by (rule<br>\nrep_inverse)<br>\n  }<br>\n  then show \"∀a. Abs (Abs' (rep' (rep a))) = a\" by auto<br>\nqed</p>\n<p>lemma r2: \"∀a. R (rep'' a) (rep'' a)\"<br>\n  unfolding rep''_def rep'_def<br>\n  using is_equivalence unfolding equivp_def by blast</p>\n<p>lemma r3: \"∀r s. R r s = (R r r ∧ R s s ∧ Abs'' r = Abs'' s)\"<br>\n  apply(intro allI)<br>\n  apply standard<br>\n  subgoal unfolding Abs''_def Abs'_def<br>\n    using is_equivalence unfolding equivp_def by auto<br>\n  subgoal unfolding Abs''_def Abs'_def<br>\n    using is_equivalence unfolding equivp_def<br>\n    by (smt Abs''_def Abs'_def CollectD S comp_apply local.Abs_inverse<br>\nmem_Collect_eq someI_ex)<br>\n  done</p>\n<p>definition cr_Q where \"cr_Q = (λx y. R x x ∧ Abs'' x = y)\"</p>\n<p>lemma quotient_Q: \"Quotient R Abs'' rep'' cr_Q\"<br>\n  unfolding Quotient_def<br>\n  apply(intro conjI)<br>\n  subgoal by (rule r1)<br>\n  subgoal by (rule r2)<br>\n  subgoal by (rule r3)<br>\n  subgoal by (rule cr_Q_def)<br>\n  done</p>\n<p>(* instantiate the quotient lemmas from the theory Lifting *)<br>\nlemmas Q_Quotient_abs_rep = Quotient_abs_rep[OF quotient_Q]<br>\n(<em>...</em>)</p>\n<p>(* prove the statements about the quotient type 's *)<br>\n(<em>...</em>)</p>\n<p>(* transfer the results back to 'a using the capabilities of transfer -<br>\nnot demonstrated in the example *)<br>\nlemma aa: \"(a::'a) = (a::'a)\"<br>\n  by auto</p>\n<p>end</p>\n<p>thm aa[cancel_type_definition]<br>\n(* this shows {x. ∃u. x = {v. R u v}} ≠ {} ⟹ ?a = ?a *)</p>\n<p>end</p>",
        "id": 294760267,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199217
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I forgot to mention the references that I used in the answer:</p>\n<ol>\n<li>\n<p>The document \"Structured Formal Development with Quotient Types in<br>\nIsabelle/HOL\" by Maksym Bortin and Christoph Lüth was used a general<br>\nreference</p>\n</li>\n<li>\n<p>The formula for the Local Typedef Rule was copied directly from the file<br>\n\"HOL/Types_To_Sets/local_typedef.ML\"</p>\n</li>\n<li>\n<p>The example subsumes the content of<br>\nHOL/Types_To_Sets/Examples/Prerequisites.thy</p>\n</li>\n</ol>\n<p>Thank you</p>",
        "id": 294760279,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199223
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nHi!<br>\nThanks for your elaborate answer.<br>\nUnfortunately I know nothing about “types to sets” and the mathematics<br>\nbehind it. Therefore the message I’m taking from your e-mail is that<br>\nwhat I want isn’t supported and making it somehow supported is<br>\ncomplicated and gives only a partial solution.<br>\nI think for my use case it’s easiest to just define the quotient types<br>\nmanually for each individual interpretation of the locale. That said,<br>\nbeing able to define quotient types within locales might be very useful<br>\nin other situations; thus adding some sort of support for it might be a<br>\ngood idea.<br>\nAll the best,Wolfgang</p>",
        "id": 294760293,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199229
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Wolfgang Jeltsch</p>\n<p>Therefore the message I’m taking from your e-mail is that<br>\nI believe that the opening remark in my original email was not very clear -<br>\nI was in a rush to finish the email and was slightly careless - please<br>\naccept my apologies. However, indeed, I meant to say exactly what you<br>\ninferred from it. I would also like to provide a more clear explanation of<br>\nthe opening remark using the PhD thesis Ondřej Kunčar as the general<br>\nreference. Isabelle/HOL provides two definitional primitives: one for<br>\noverloaded constants and one for types (i.e. typedef). All other<br>\ndefinitional mechanisms (including, e.g., quotient_type) have to be defined<br>\nin terms of these primitives, provided that one does not neglect the LCF<br>\napproach. The typedef primitive allows for the definition of new types in<br>\nterms of an isomorphism with respect to an arbitrary non-empty subset of an<br>\nexisting type. typedef α k = S requires S to be a closed term, k to be a<br>\nfresh type constructor and all type variables in S need to be among the<br>\nvariables in α. If one is to try to define a nullary type constructor based<br>\non an existing fixed type variable, then the last condition will be<br>\ninevitably violated. Unfortunately, provided that there is no<br>\nmisunderstanding on my part, this is exactly what you were trying to do by<br>\ncalling the command quotient_type with the fixed type variable occurring in<br>\nthe input term and not occurring on the lhs in the specification of the<br>\ntype constructor.</p>\n<p>Also, perhaps, I can provide an explanation for another remark from your<br>\noriginal email \"although it does accept referring to <code>'a</code> in types\". When<br>\nyou invoke the command quotient_type, your intention is to declare a new<br>\ntype constructor. Of course, the mechanism of the declaration of new type<br>\nconstructors is very different from merely using a fixed type variable as<br>\nan input to the existing type constructor. Hopefully, this clarifies why<br>\none can refer to fixed variables when constructing new types, but not new<br>\ntype constructors.</p>\n<p>Thank you</p>",
        "id": 294760304,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199235
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nPossibly now is a good time to plug my own paper \"Defining functions on equivalence classes”, which is available* from my webpage (<a href=\"https://www.cl.cam.ac.uk/~lp15/papers/refereed.html\">https://www.cl.cam.ac.uk/~lp15/papers/refereed.html</a>). In this I outline how one can create quotient constructions quite easily using the set-theoretic primitives of Isabelle/HOL. Obviously quotient_type is easier to use, but as discussed, it wants to introduce a type and there is no reason on earth to conflate quotient constructions with types.</p>\n<p>Larry Paulson</p>\n<ul>\n<li>It is available via an ACM system that supposedly provides open access from the author’s own webpage. If it doesn’t work for you, please email me for a copy.</li>\n</ul>",
        "id": 294760316,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199241
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nThanks for the pointer!</p>\n<p>Unfortunately, I cannot download the paper via that link.</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294760383,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199253
    }
]