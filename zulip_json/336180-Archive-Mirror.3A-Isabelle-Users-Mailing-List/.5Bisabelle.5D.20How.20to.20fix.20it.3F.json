[
    {
        "content": "<p>From: Lucas Cavalcante &lt;<a href=\"mailto:lu_cavalcante_@hotmail.com\">lu_cavalcante_@hotmail.com</a>&gt;<br>\nI'd like to provetheorem negeq: \"EX xs. ((neg_eq Formula) = ~xs (<em>here</em>) | (neq_eq Formula) = xs)\"<br>\nApplying induction over Formula, but Isar says \"Inner lexical error at: = ~xs\". Just as happen at neg_eq's recursive funcion definition:<br>\nconsts neg_eq :: \"sbf =&gt; sbf\"<br>\nprimrec <br>\n\"neg_eq P = P\" (<em>here</em>)<br>\n\"neg_eq ~P = ~P\"<br>\n\"neg_eq ~~P = neg_eq P\"<br>\n Isar says \"Inner lexical error at: = P\".How to fix it?Regards,LucasPS.: THIS MENSAGE: (<a href=\"http://paste.ubuntubrasil.org/4300\">http://paste.ubuntubrasil.org/4300</a>), THE THEORY: (<a href=\"http://paste.ubuntubrasil.org/4299\">http://paste.ubuntubrasil.org/4299</a>).</p>\n<hr>\n<p>Veja só alguns dos novos serviços online no Windows Live Ideas — são tão novos que ainda não foram disponibilizados oficialmente.<br>\n<a href=\"http://ideas.live.com\">http://ideas.live.com</a></p>",
        "id": 294049604,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818845
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nLucas Cavalcante wrote:</p>\n<blockquote>\n<p>I'd like to provetheorem negeq: \"EX xs. ((neg_eq Formula) = ~xs<br>\n(<em>here</em>) | (neq_eq Formula) = xs)\" Applying induction over Formula,<br>\nbut Isar says \"Inner lexical error at: = ~xs\".</p>\n</blockquote>\n<p>The theory you are pointing to builds on Pure, not HOL. In Pure,<br>\napplication is written \"f(x)\", not \"f x\". That's why you get the parsing<br>\nerrors. If you want curried application, you can use CPure.</p>\n<p>Then, you are trying to use an existential quantifier, but your theory<br>\ndoes not define any quantifiers, just propositional and modal<br>\nconnectives. So it won't be there. You just get what you define, plus<br>\nthe meta logic (\"!!\" and \"==&gt;\").</p>\n<blockquote>\n<p>Just as happen at neg_eq's recursive funcion definition:<br>\nconsts neg_eq :: \"sbf =&gt; sbf\"<br>\nprimrec <br>\n\"neg_eq P = P\" (<em>here</em>)<br>\n\"neg_eq ~P = ~P\"<br>\n\"neg_eq ~~P = neg_eq P\"</p>\n</blockquote>\n<p>primrec definitions (and many other things described in the tutorial)<br>\nare only possible in HOL. If you use Pure, then you really only have the<br>\nbare logic.</p>\n<p>I'm not sure what you are trying to do. If you want to implement your<br>\nown logic in Isabelle, then you are on the right track, but you can't<br>\nuse any of the Isabelle/HOL facilities, and most of the Isabelle/HOL<br>\ndocumentation does not apply.</p>\n<p>If you want to use Isabelle/HOL, you can also describe modal formulae as<br>\na HOL datatype, and the define the semantics recursively. But this is<br>\nsomething else, since you are doing an embedding.</p>\n<p>Hope that helps a little...<br>\nAlex</p>",
        "id": 294049751,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818912
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIn your two examples you need to relace ~X by (~X).</p>\n<p>Tobias</p>\n<p>Lucas Cavalcante schrieb:</p>",
        "id": 294049901,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818980
    },
    {
        "content": "<p>From: Lucas Cavalcante &lt;<a href=\"mailto:lu_cavalcante_@hotmail.com\">lu_cavalcante_@hotmail.com</a>&gt;<br>\nDear Alex,&gt; The theory you are pointing to builds on Pure, not HOL. In Pure,&gt; application is written \"f(x)\", not \"f x\". That's why you get the parsing&gt; errors. If you want curried application, you can use CPure.Ok, it seem's working, thanks very very much. I've added CPure and HOL at imports's field.consts neg_eq :: \"sbf =&gt; sbf\"primrec\"neg_eq(P) = P\"\"neg_eq((Neg(P))) = Neg(P)\"\"neg_eq((Neg(Neg(P)))) = neg_eq(P)\"but it steel remains not okay, it returns <strong>* Uninitialized theory data \"HOL/datatypes\"</strong>* At command \"primrec\".&gt; I'm not sure what you are trying to do. If you want to implement your&gt; own logic in Isabelle, then you are on the right track, but you can't&gt; use any of the Isabelle/HOL facilities, and most of the Isabelle/HOL&gt; documentation does not apply.I'm trying to prove that every possible proposicional formula can be wrriten usingone or any negations in front of. It's a very simple theorem. I'm just starting, but i did not found anything looking exactaly like this in'Isabelle Tutorial'.Something liketheorem ALL formula. \"neg_eq(formula) = P | neg_eq(formula) = Neg( P )\"But I think it is not possible, becouse he doesn't know who is \"P\" (:-\\), it's why i've used\"EX\", but you're right, seems there's no definition of EX in my theory. And also i wouldapply induction over P, but it won't work, so i must apply over \"formula\", but it's quantified.&gt; If you want to use Isabelle/HOL, you can also describe modal formulae as&gt; a HOL datatype, and the define the semantics recursively. But this is&gt; something else, since you are doing an embedding.Basicaly, it's what I'm trying to do, but I don't know how. I just want to learnhow to do in case of this very simple case at proposicional logic, mounting my own theory, then apply to modal logic, and then define it structuraly recusirve.Any hint? (:-P)Thank you,LucasTHIS MENSSAGE: ( <a href=\"http://paste.ubuntubrasil.org/4305\">http://paste.ubuntubrasil.org/4305</a> )THE THEORY: ( <a href=\"http://paste.ubuntubrasil.org/4304\">http://paste.ubuntubrasil.org/4304</a> )</p>\n<hr>\n<p>Obtenha o novo Windows Live Messenger!<br>\n<a href=\"http://get.live.com/messenger/overview\">http://get.live.com/messenger/overview</a></p>",
        "id": 294049975,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819023
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nLucas,</p>\n<blockquote>\n<p>Ok, it seem's working, thanks very very much. I've added CPure and HOL<br>\nat imports's field.</p>\n</blockquote>\n<p>For normal applications, you should always import \"Main\" (which CPure<br>\nand HOL). Then the primrec command is available.</p>\n<blockquote>\n<p>consts neg_eq :: \"sbf =&gt; sbf\"<br>\nprimrec<br>\n\"neg_eq(P) = P\"<br>\n\"neg_eq((Neg(P))) = Neg(P)\"<br>\n\"neg_eq((Neg(Neg(P)))) = neg_eq(P)\"</p>\n</blockquote>\n<p>Primrec can only do primitive recursion over inductive datatypes (i.e.<br>\nyou define them via the \"datatype\" command). So even if you import Main,<br>\nthis will fail.</p>\n<blockquote>\n<p>I'm trying to prove that every possible proposicional formula can be<br>\nwrriten using<br>\none or any negations in front of.</p>\n</blockquote>\n<p>For that, you need to define your formulae as an inductive datatype,<br>\njust as a type of lists or trees (see Tutorial).</p>\n<p>Alex</p>",
        "id": 294049991,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819029
    }
]