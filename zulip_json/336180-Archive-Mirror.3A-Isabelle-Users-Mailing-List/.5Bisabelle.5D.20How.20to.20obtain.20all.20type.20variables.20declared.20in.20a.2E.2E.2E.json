[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>Today, I found myself struggling to resolve a, seemingly, very trivial<br>\nissue. I am trying to obtain a list of all type variables that are declared<br>\nin a proof context. It does not seem that the relevant data is exposed to<br>\nthe public interface. However, most likely, I am missing something.</p>\n<p>Here is a minimal example:</p>\n<p>val ctxt = @{context};<br>\nval T = TVar ((\"'a\", 0), [\"Groups.plus\"]);<br>\nval ctxt = Variable.declare_typ T ctxt;<br>\n(* val declTs = obtain_declared_types ctxt ? *)</p>\n<p>Please note that I am aware of the function Variable.is_declared. However,<br>\nseemingly, this function merely performs a check based on the name context<br>\nand, therefore, does not include the schematic (type) variables.</p>\n<p>The use case is the generation of fresh schematic type variables.<br>\nTherefore, if a solution to this problem can already be found somewhere in<br>\nthe source code, it may be a suitable alternative to the answer to the<br>\noriginal question. Nevertheless, I would still highly prefer to understand<br>\nhow to obtain all declared type variables.</p>\n<p>Thank you</p>",
        "id": 294760564,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199343
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nAm 14.07.2019 um 18:03 schrieb mailing-list anonymous:</p>\n<blockquote>\n<p>I am trying to obtain a list of all type variables that are declared<br>\nin a proof context. It does not seem that the relevant data is exposed to<br>\nthe public interface.</p>\n</blockquote>\n<p>Yes, I think this is not exposed. As I understand it, it is more of an<br>\nimplementation detail, and the \"invent fresh names\" operations are what<br>\nyou are supposed to use.</p>\n<p>[...]</p>\n<blockquote>\n<p>The use case is the generation of fresh schematic type variables.</p>\n</blockquote>\n<p>In this case, I would probably generate fixed type variables first (cf.<br>\nVariable.invent_types) and then generalize the final results (terms,<br>\ntheorems) (cf. Variable.export_*)</p>\n<p>Hope this helps</p>\n<p>Alex</p>",
        "id": 294760570,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199345
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Alexander Krauss/All,</p>\n<p>Thank you for your reply. It is very useful to know that the functionality<br>\nthat I was looking for is not available.</p>\n<p>Indeed, my problem is slightly superficial and, generally, can be resolved<br>\nby following one of the more traditional approaches, like the one that you<br>\nsuggested at the end of your email. Nevertheless, it seems that using such<br>\ntraditional approaches would result in redundant computations, given the<br>\nproblem at hand. Perhaps, there is another way to proceed. I would like to<br>\nknow if there is a way to reduce all indexnames in a theorem to zero in a<br>\ncontext-aware fashion (please note that I am aware of the function<br>\nDrule.zero_var_indexes, but it ignores the local context). Such a function<br>\ncould provide an efficient alternative to the solution of the problem that<br>\nI am dealing with.</p>\n<p>As a side note, it seems that making a functionality that shows all<br>\nentities declared in a context or, better yet, a context difference<br>\nfunction would be very useful for the purposes of<br>\ninspection/testing/verification/debugging. For example, I would like to<br>\nensure that my modules do not leave any redundant entities in the context.<br>\nGiven the information in your previous email, it seems that this is<br>\nsomething that one cannot do at the moment.</p>\n<p>I would also like to make another remark that has some connection to the<br>\nproblem that I was trying to solve. I encountered a behaviour which I find<br>\ndifficult to understand. Somehow, given a locale context with declared<br>\n(type) variables, it is still possible to register theorems in the locale<br>\ncontext that, seemingly, ignore the sorts/types associated with the<br>\npreviously declared variables (see the code listing after my signature).<br>\nSomehow, I was under the (seemingly, erroneous) impression that, unlike<br>\nconstants, variables are only allowed to have one type/sort in the same<br>\ncontext... does there exist any documentation that explains this behaviour?<br>\nThe only references that I could find on this matter were in the<br>\nimplementation manual (p. 65 and p. 69):</p>\n<ol>\n<li>\n<p>\"The core logic handles the type variables with the same name but<br>\ndifferent sorts as different, although the type-inference layer (which is<br>\noutside the core) rejects anything like that.\"</p>\n</li>\n<li>\n<p>\"Type-inference rejects variables of the same name, but different types.<br>\nIn contrast, mixed instances of polymorphic constants occur routinely.\"<br>\nHowever, these references do not explicitly state that it is, indeed, legal<br>\nand appropriate to use the same variable with different type/sort in the<br>\nsame context. Why are the users allowed to forego a type inference before<br>\nregistering a theorem in a context or creating a proveable goal? Are there<br>\nany practical use cases for this allowance? Most certainly, it enables the<br>\nconstruction of slightly peculiar theorems. For example, I was able to<br>\nproduce the following theorem (see the code listing below):<br>\n\"(B::'b::plus) = B ⟹ B::'b::type ≡ B\"</p>\n</li>\n</ol>\n<p>Thank you</p>\n<p>declare [[show_sorts]]</p>\n<p>locale myloc =<br>\n  fixes B :: \"'b::plus\"<br>\n  assumes \"B ≡ B\"<br>\nbegin</p>\n<p>lemma tt: \"True ≡ True\" by auto</p>\n<p>ML ‹</p>\n<p>val T = TVar ((\"'a\", 0), [\"Groups.plus\"]);</p>\n<p>fun mk_eq_thm lthy =<br>\nlet<br>\n  val T = TVar ((\"'a\", 1), [\"HOL.type\"]);<br>\n  val ct = Var ((\"A\", 0), T) |&gt; Thm.cterm_of lthy;<br>\n  val thm = ct |&gt; Thm.reflexive;<br>\n  val lthy = Local_Theory.note ((@{binding mythm}, []), single thm) lthy |&gt;<br>\nsnd<br>\nin lthy end<br>\nval q = Thm.implies_intr<br>\nfun mk_eq_thm' lthy =<br>\nlet<br>\n  val T = TFree (\"'b\", [\"HOL.type\"])<br>\n  val ct = Free (\"B\", T) |&gt; Thm.cterm_of lthy<br>\n  val thm = ct |&gt; Thm.reflexive<br>\n  val thm = Thm.implies_intr<br>\n    (@{term True} |&gt; HOLogic.mk_Trueprop |&gt; Thm.cterm_of lthy)<br>\n    thm<br>\n  val lthy = Local_Theory.note ((@{binding mythm'}, []), single thm) lthy<br>\n|&gt; snd<br>\nin lthy end</p>\n<p>›</p>\n<p>local_setup ‹Local_Theory.target (Variable.declare_typ T)›</p>\n<p>(*<br>\nBoth produce an error similar to<br>\n\"Sort constraint type inconsistent with default plus for type variable<br>\n\"?'a\"⌂\":</p>\n<p>schematic_goal \"(?A::?'a::type) = ?A\"<br>\nlemma \"(Q::'b::type) = (Q::'b::type)\"</p>\n<p>*)</p>\n<p>local_setup ‹mk_eq_thm›<br>\nlocal_setup ‹mk_eq_thm'›</p>\n<p>thm mythm (* ?A::?'a::type ≡ ?A *)<br>\nthm mythm' (* B::'b::type ≡ B *)</p>\n<p>(* peculiar theorem *)<br>\nlemma QQ: \"True\"<br>\nproof-<br>\n  (* the occurrences of B have different types in the goal *)<br>\n  define C where \"C = (B = B)\"<br>\n  have True_C: \"C = True\" unfolding C_def by auto<br>\n  have aaa: \"True\" by auto<br>\n  note mythm'' = mythm'[folded True_C, unfolded C_def]<br>\n  thm mythm'' (* (B::'b::plus) = B ⟹ B::'b::type ≡ B *)<br>\n  show ?thesis by auto<br>\nqed</p>\n<p>(*<br>\nIt seems that it is possible to produce theorems in the locale<br>\ncontext that use the default sort 'type' both for the schematic type<br>\nvariable<br>\nwith the indexname (\"'a\", 0) and the fixed type variable with the name 'b,<br>\nas well as the type \"'b::type\" for the fixed variable B.<br>\nNevertheless, the sorts of the declared types are still '<a href=\"http://Groups.plus\">Groups.plus</a>'. This<br>\ncan be observed by trying to state the lemmas from the previous example:</p>\n<p>schematic_goal \"(?A::?'a::type) = ?A\"<br>\nlemma \"(Q::'b::type) = (Q::'b::type)\"</p>\n<p>which results in the same error as before.</p>\n<p>*)</p>\n<p>end</p>",
        "id": 294760689,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199398
    }
]