[
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:lukas.bulwahn@gmail.com\">lukas.bulwahn@gmail.com</a>&gt;<br>\nDear all,</p>\n<p>In my latest Isabelle theory development, I have been using the<br>\nrecently added Eisbach technology. Thanks to Daniel, Makarius and Toby<br>\nfor the work on this valuable addition to Isabelle.</p>\n<p>After very quickly writing the essential functionality of my method, I<br>\nthen unfortunately stumbled with the following issue:</p>\n<p>I have defined a method <code>injectivity_solver</code> with Eisbach; what the<br>\nmethod does is not further relevant for my question.</p>\n<p>I currently employ the method on certain goals (where disjoint_under<br>\nis a defined predicate, and ?comp and ?S are some fixed terms).</p>\n<p>To make the chained facts F1 ... F3  part of the proof state the<br>\nEisbach method acts on, I use <code>by - (injectivity_solver ...)</code> or<br>\n<code>apply - apply (injectivity_solver ...)</code> as follows:</p>\n<p>have \"disjoint_under ?comp ?S\" using F1 F2 F3 by - (injectivity_solver ...)<br>\n  have \"disjoint_under ?comp ?S\" using F1 F2 F3 apply - apply<br>\n(injectivity_solver ...)</p>\n<p>However, the following fails:</p>\n<p>have \"G\" using F1 F2 F3 by m</p>\n<p>I did not find a way to make the Eisbach method itself insert the<br>\nchained facts into the proof goal before applying the further methods<br>\n(by some simple experiments and by looking through the Eisbach<br>\nmanual).</p>\n<p>Available local Isabelle experts in the very close Munich area did not<br>\nhave a quick answer at hand.</p>\n<p>Hence, my questions here:</p>\n<ul>\n<li>\n<p>Is there a simple way to process chained facts with the current<br>\nEisbach technology?</p>\n</li>\n<li>\n<p>Is this feature request considered valuable for Eisbach?</p>\n</li>\n</ul>\n<p>For further details and experimentation, the described setup is in the<br>\nAFP entry Bell_Numbers_Spivey. The method is defined in lines 111f.<br>\nand invoked in lines 522, 543 and 554 of the Bell_Numbers theory file.</p>\n<p>Best regards,</p>\n<p>Lukas</p>",
        "id": 294675199,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174716
    },
    {
        "content": "<p>From: Daniel Matichuk &lt;<a href=\"mailto:Daniel.Matichuk@nicta.com.au\">Daniel.Matichuk@nicta.com.au</a>&gt;<br>\nHi Lukas,</p>",
        "id": 294675213,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174720
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHow about a general Isar method combinator that manipulates the \"using\"<br>\nslot? E.g. called \"use\":</p>\n<p>by (use facts in simp)<br>\n  by (use facts in auto simp: ...)<br>\n  by (use [[simproc foo]] in simp)</p>\n<p>That would cover many similar situations that have accumulated in the<br>\npast few years.</p>\n<p>At this stage it is independently of Eisbach.</p>\n<p>Makarius</p>",
        "id": 294675490,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174806
    },
    {
        "content": "<p>From: Daniel Matichuk &lt;<a href=\"mailto:Daniel.Matichuk@nicta.com.au\">Daniel.Matichuk@nicta.com.au</a>&gt;</p>\n<blockquote>\n<p>On 27 May 2016, at 1:48 AM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>On 23/05/16 02:50, Daniel Matichuk wrote:<br>\n&gt;</p>\n<p>On 21 May 2016, at 7:08 PM, Lukas Bulwahn &lt;lukas.bulwahn@gmail.com&lt;mailto:<a href=\"mailto:lukas.bulwahn@gmail.com\">lukas.bulwahn@gmail.com</a>&gt;&gt; wrote:</p>\n<blockquote>\n<p>In my latest Isabelle theory development, I have been using the<br>\nrecently added Eisbach technology.</p>\n<p>I have defined a method <code>injectivity_solver</code> with Eisbach; what the<br>\nmethod does is not further relevant for my question.</p>\n</blockquote>\n<blockquote>\n<p>Hence, my questions here:</p>\n<ul>\n<li>Is there a simple way to process chained facts with the current<br>\nEisbach technology?</li>\n</ul>\n<p>This is a known limitation of Eisbach. The current design choice was to have the inner methods<br>\nin an Eisbach method simply inherit the chained facts, but I think we're getting some evidence that this is not the expected or desired behaviour.</p>\n<ul>\n<li>Is this feature request considered valuable for Eisbach?</li>\n</ul>\n<p>Yes, I think this is a good discussion to have. My current thinking is to instead bind all of the chained facts in the Eisbach method as a special named_theorem, that you can choose to insert, discard, or pass on to further methods.</p>\n</blockquote>\n<p>How about a general Isar method combinator that manipulates the \"using\"<br>\nslot? E.g. called \"use\":</p>\n<p>by (use facts in simp)<br>\n by (use facts in auto simp: ...)<br>\n by (use [[simproc foo]] in simp)</p>\n<p>That would cover many similar situations that have accumulated in the<br>\npast few years.</p>\n</blockquote>\n<p>I agree that this makes sense, this is similar to the solution I proposed to Christian Sternagel's issue a few weeks ago. It's unclear whether it should override the \"using\" slot or augment it, though.</p>\n<blockquote>\n<p>At this stage it is independently of Eisbach.</p>\n</blockquote>\n<p>I'm not sure if this is what you were suggesting, but I think that the named_theorems idea would work in conjunction with the proposed \"use\" combinator.</p>\n<p>i.e.</p>\n<p>method foo uses other_rules = (rule baz, use using_rules other_rules in simp)</p>\n<p>Where the initial invocation of the \"rule\" method always has an empty \"using\" slot (and so will predictably only apply the \"baz\" rule), but it gets chained into \"simp\" via the special \"using_rules\" fact, and is augmented with any given \"other_rules\".</p>\n<p>Does that make sense?</p>\n<blockquote>\n<p>Makarius<br>\n</p>\n</blockquote>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294675559,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174834
    }
]