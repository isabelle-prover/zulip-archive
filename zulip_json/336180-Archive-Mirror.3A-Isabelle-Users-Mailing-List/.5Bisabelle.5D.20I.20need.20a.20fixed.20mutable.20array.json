[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHOL itself does not support mutable arrays. </p>\n<p>However, there is Imperative_HOL, which has a heap monad supporting<br>\nmutable arrays.</p>\n<p>Then there is afp/Collections/Lib/Diff_Array, which provides an<br>\nimplementation of arrays that behaves purely functional, but is<br>\nefficient if only the last version is accessed.</p>\n<p>However, if you are not after <em>efficient</em> executability, but only<br>\nlooking for an abstract model of a memory, it makes no sense using the<br>\nabove types, as the efficiency comes at teh price of additional<br>\nformalization overhead.</p>",
        "id": 294278977,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919712
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nRamana,</p>\n<p>Thanks for the suggestion. There's always more to say than anyone wants <br>\nto read.</p>\n<p>I'll say the same thing here that I'll say to Peter Lammich about the <br>\ninfo he gave me. It's probably better that I didn't get this information <br>\nfrom you before now. In particular, my finding this link from your tip:</p>\n<p><a href=\"http://www.cl.cam.ac.uk/~acjf3/arm\">www.cl.cam.ac.uk/~acjf3/arm</a></p>\n<p>That would be about ARMv7. The ARM Cortex-A15 was the CPU I thought I <br>\nwas going to go with. Please see [1] and [2] below.</p>\n<p>There's like three main factors in looking at CPUs: they need to be sold <br>\non a board that's affordable, they need to have a large following, and <br>\nthey need to have some lasting power.</p>\n<p>The Sony Playstation 3 CPU looks great, and it's fairly cheap, but then <br>\nthe Sony PS4 is changing to an AMD CPU. That's a bad sign.</p>\n<p>Basically, there's GPUs, ARM, and Intel i7. Part of my pursuit began <br>\nwith looking for processors that have 256-bit data registers, because I <br>\nused to work in graphics image generators, which had 256-bit wide data <br>\nbusses.</p>\n<p>It was there all the time with the i7, and even before for 128-bit, with <br>\nSSE, SSE2, SSS3, SS3, SS4, and now it's there for 256-bit, with AVX <br>\nextensions.</p>\n<p>RISC and ARM sounds like it should be fast, but then I looked at [3], <br>\nand it's not like they blow everyone away.</p>\n<p>I think an i7 is hard to beat, with 4 cores and 8 threads, with a clock <br>\nat 3 to 4 GHz.. Lots of people have them, and people don't have to do <br>\nanything special to run them, unlike embedded processors, or external, <br>\nsingle board Linux computers.</p>\n<p>All these practical considerations have a big part in influencing what <br>\nroute I think I should go. ARM is good, but then there's all sorts of <br>\nspecial things I have to do for, among other things, develop tools.</p>\n<p>Regards,<br>\nGB</p>\n<p>[1] Samsung Exynos 5 Octa: <br>\n<a href=\"http://www.samsung.com/global/business/semiconductor/minisite/Exynos/products5octa_5410.html\">http://www.samsung.com/global/business/semiconductor/minisite/Exynos/products5octa_5410.html</a></p>\n<p>[2] ODROID-X3: ARM Cortex-A15 / Cortex A7 / Samsung Exynos 5 Octa based <br>\ncomputer for $169.<br>\n<a href=\"http://hardkernel.com/main/products/prdt_info.php?g_code=G137510300620\">http://hardkernel.com/main/products/prdt_info.php?g_code=G137510300620</a></p>\n<p>[3] CoreMark integers tests: <a href=\"http://www.eembc.org/coremark/index.php\">http://www.eembc.org/coremark/index.php</a> <br>\n(sort by CoreMark/MHz)</p>\n<p>[4] Brix with i7-4770R: <br>\n<a href=\"http://www.amazon.com/BRIX-Pro-GB-BXI7-4770R-Desktop-Computer/dp/B00HX3OJSG/ref=sr_1_5?ie=UTF8&amp;qid=1402845781&amp;sr=8-5&amp;keywords=gigabyte+brix\">http://www.amazon.com/BRIX-Pro-GB-BXI7-4770R-Desktop-Computer/dp/B00HX3OJSG/ref=sr_1_5?ie=UTF8&amp;qid=1402845781&amp;sr=8-5&amp;keywords=gigabyte+brix</a></p>",
        "id": 294279004,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919720
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nOn 14-06-18 16:19, Peter Lammich wrote:</p>\n<blockquote>\n<p>On Di, 2014-06-17 at 10:56 -0500, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>I did a few searches to find whether there are mutable arrays in<br>\nIsabelle. It appears there's not, though I found a little info:<br>\nHowever, there is Imperative_HOL, which has a heap monad supporting<br>\nmutable arrays.</p>\n</blockquote>\n</blockquote>\n<p>Peter,</p>\n<p>Thanks for the info. I never consider using anything but Isabelle/HOL, <br>\nsince it has the biggest user base. Limitations can sometimes be a good <br>\nthing, by forcing me to figure out how to do things different.</p>\n<blockquote>\n<p>Then there is afp/Collections/Lib/Diff_Array, which provides an<br>\nimplementation of arrays that behaves purely functional, but is<br>\nefficient if only the last version is accessed.</p>\n</blockquote>\n<p>I searched on \"array\" at the AFP site before, but I didn't find that, <br>\nsince it's buried in the tar file. It's good that I didn't, but it's <br>\ngood to see it now, and see how they're implementing things with lists.</p>\n<p>It might come in handy later, and the collections in general.</p>\n<blockquote>\n<p>However, if you are not after <em>efficient</em> executability, but only<br>\nlooking for an abstract model of a memory, it makes no sense using the<br>\nabove types, as the efficiency comes at teh price of additional<br>\nformalization overhead.</p>\n</blockquote>\n<p>I just need something to give me a decent model for the use a subset of <br>\nassembly language instructions, which involves reading and writing to <br>\nmemory.</p>\n<p>List and nat, they're part of the foundation of HOL. They're used a lot, <br>\nso there's a lot of development around them. Proof can be a scary <br>\nthought, so I try to play it safe, and keep things simple with lists, <br>\nwhen I can.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294279017,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919723
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nIt would also be \"they\", but then \"you\" as the primary.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294279032,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919728
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nHi Gottfried,</p>\n<p>are you aware of the HOL/Word library? It gives you arbitrary fixed-size words. With that, memory would be something like</p>\n<p>type_synonym mem = “64 word =&gt; 8 word”</p>\n<p>If the purpose is to model and reason only, basic functions are as mutable as records. If you want to generate efficient code from it, then it might be better to go with implementations like Peter’s.</p>\n<p>A formalisation of (very) basic machine language is explained in Section 8.1 of Concrete Semantics:<br>\n<a href=\"http://www21.in.tum.de/~nipkow/Concrete-Semantics/\">http://www21.in.tum.de/~nipkow/Concrete-Semantics/</a></p>\n<p>Cheers,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294279063,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919736
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nOn 14-06-18 19:43, Gerwin Klein wrote:</p>\n<blockquote>\n<p>A formalisation of (very) basic machine language is explained in Section 8.1 of Concrete Semantics:<br>\n<a href=\"http://www21.in.tum.de/~nipkow/Concrete-Semantics/\">http://www21.in.tum.de/~nipkow/Concrete-Semantics/</a></p>\n</blockquote>\n<p>Gerwin,</p>\n<p>Thanks again. That's short, but very useful. I kind of knew that my <br>\ninstruction set is one, big datatype, but it hadn't yet entered my mind <br>\nwhat my execution function was going to be for the datatype, so seeing <br>\n\"iexec\" is helpful.</p>\n<p>Also, I'll be looking at the info about the program counter again, and <br>\nother tips there.</p>\n<blockquote>\n<p>are you aware of the HOL/Word library? It gives you arbitrary fixed-size words. With that, memory would be something like</p>\n<p>type_synonym mem = “64 word =&gt;  8 word”</p>\n</blockquote>\n<p>I've looked at that briefly now, and I start at section 3.1, where <br>\nthey're starting with num0 and num1. It would take me  a lot of work to <br>\nwork through the details, and I'm assuming, it's safe to assume, it's <br>\nnot what I need, where my assumption is based on my work with Num.num, <br>\nwhich I really like.</p>\n<p>For what I'm trying to do, everything is about trying to precisely model <br>\nthe specific registers of a particular CPU. With a CPU, the register set <br>\nand size of registers is fixed, and there's nothing that complex about <br>\nthem, though how they're used may be complex. For 64-bit registers, you <br>\nusually only have 8-bit, 16-bit, 32-bit, and 64-bit words. Also, my <br>\nchoice of bool for the bits is based on the fact that True and False are <br>\nfundamental to HOL, which might become very useful to me.</p>\n<p>Arbitrary will be important, if I can get to it, but arbitrary has to be <br>\nimplemented as it's implemented by the good math libraries, and the <br>\nprecise way that they use fixed sized registers. For arbitrary, the <br>\nfirst place I'll look to see how arithmetic is done will the GnuMP <br>\nlibrary. I'll be asking, \"What's special about the way they deal with <br>\nregisters, and assembly language instructions?\"</p>\n<p>There's another issue here. For pattern matching with \"fun\", it's <br>\nimportant that a datatype use only 0-ary type constructors, like True <br>\nand False. My awareness of this is a result of having been working with <br>\nNum.num. What I've done is use Num.num as a template, and I've implement <br>\nthe functionality of Num.num  as a \"bool list\". For example, \"[]\" is 1, <br>\nand [True,True] is 7. That allows me to pattern match in ways I <br>\notherwise couldn't pattern match.</p>\n<p>Having spent a lot of time learning how Num.num works, I'm not very <br>\nmotivated to do it all again with Word, and I assume that doing things <br>\nmore straightforward will help me in some ways.</p>\n<p>There always more. I'm talking prematurely, but suppose I need a sign <br>\nbit for signed integers. I could do something like this for a 16-bit <br>\nsigned integer:</p>\n<p>datatype d7T = d7C bool bool bool bool bool bool bool<br>\ndatatype d8uT = d8uC bool bool bool bool bool bool bool bool<br>\ndatatype d16sT = d16C bool d7T d8uT</p>\n<blockquote>\n<p>If the purpose is to model and reason only, basic functions are as mutable as records. If you want to generate efficient code from it, then it might be better to go with implementations like Peter’s.</p>\n</blockquote>\n<p>In times like these, a person like me would actually like to understand <br>\na phrase like \"basic functions are as mutable as records\", but I don't <br>\nworry about understanding everything.</p>\n<p>I'm actually liking what I stumbled onto, which is to generate a list of <br>\nthe CPU register and memory state for each instruction. That would get <br>\nme a debugger by default. Compiled languages are bigger hassle to use, <br>\nand with assembly language, it becomes more important to use GNU gdb, or <br>\nsome other IDE.</p>\n<p>If I could get a state machine thing accurately modeling assembly <br>\nlanguage, then I could run it with a combination of Isabelle/HOL and ML, <br>\nin Isabelle/jEdit. That would be nice.</p>\n<p>Well, this is all premature.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294279075,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919741
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I did a few searches to find whether there are mutable arrays in <br>\nIsabelle. It appears there's not, though I found a little info:</p>\n<p><a href=\"https://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrayshttps://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrays\">https://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrayshttps://groups.google.com/forum/?fromgroups#!searchin/fa.isabelle/mutable$20arrays</a></p>\n<p>I need to simulate the RAM of a cpu, and this is what I've done with a <br>\nrecord and list:</p>\n<p>record 'a marray = MList :: \"'a list\"</p>\n<p>definition \"array_size_512 = ( (| MList = replicate 0x100 (0::nat) |), <br>\n0x100::nat )\"</p>\n<p>fun array_write :: \"('a marray * nat) =&gt; nat =&gt; 'a =&gt; ('a marray * nat) <br>\noption\" where<br>\n   \"array_write (an_array, a_size) index data = (<br>\n      if (index &gt;= a_size) then None<br>\n      else Some (an_array(| MList := (MList an_array)[index := data] |), <br>\na_size)<br>\n   )\"</p>\n<p>value \"array_write array_size_512 3 1234\"<br>\nvalue \"array_write array_size_512 0x100 1234\"</p>\n<p>I'm wondering if there's a better way to do that. Better efficiency <br>\nwould be good, but efficiency in Isabelle is not of utmost concern, <br>\nsince it will hopefully represent what will be done in assembly language.</p>\n<p>I'm just getting started, but a partial record for a Intel 64-bit cpu <br>\nmight be something like this, where \"Mem\" is the fixed mutable array to <br>\nrepresent RAM:</p>\n<p>record cpu64 =<br>\n   Ax :: nat<br>\n   Bx :: nat<br>\n   Mem :: \"nat list\"</p>\n<p>definition cpu_mem256 :: \"cpu64 * nat\" where<br>\n   \"cpu_mem256 =<br>\n   ( (| Ax = 0, Bx = 0, Mem = (replicate 0x100 (0::nat)) |), 0x100::nat )\"</p>\n<p>fun mem_write :: \"(cpu64 * nat) =&gt; nat =&gt; nat =&gt; (cpu64 * nat) option\" where<br>\n   \"mem_write (cpu, memsize) addr data = (<br>\n      if (addr &gt;= memsize) then None<br>\n      else Some (cpu(| Mem := (Mem cpu)[addr := data] |), memsize)<br>\n   )\"</p>\n<p>This is the beginning of an attempt to tie into the SIMD instruction <br>\nsets of the AMD and Intel microprocessors. The SIMD instructions use <br>\n128-bit and 256-bit registers to do multiple operations at the same <br>\ntime. I include a lot of links below.</p>\n<p>Thanks,<br>\nGB</p>\n<p>Wiki Pages</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions\">http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions</a><br>\n<a href=\"http://en.wikipedia.org/wiki/SSE2\">http://en.wikipedia.org/wiki/SSE2</a><br>\n<a href=\"http://en.wikipedia.org/wiki/SSE3\">http://en.wikipedia.org/wiki/SSE3</a><br>\n<a href=\"http://en.wikipedia.org/wiki/SSSE3\">http://en.wikipedia.org/wiki/SSSE3</a><br>\n<a href=\"http://en.wikipedia.org/wiki/SSE4\">http://en.wikipedia.org/wiki/SSE4</a><br>\n<a href=\"http://en.wikipedia.org/wiki/Advanced_Vector_Extensions\">http://en.wikipedia.org/wiki/Advanced_Vector_Extensions</a></p>\n<p>INTEL</p>\n<p><a href=\"http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a><br>\n<a href=\"https://software.intel.com/en-us/intel-isa-extensions\">https://software.intel.com/en-us/intel-isa-extensions</a></p>\n<p>AMD (See AMD64 Arch Programmer's Manuals under the manual heading)</p>\n<p><a href=\"http://developer.amd.com/resources/documentation-articles/developer-guides-manuals/\">http://developer.amd.com/resources/documentation-articles/developer-guides-manuals/</a></p>\n<p>PRO ASSEMBLY LANGUAGE (chapter 17)</p>\n<p><a href=\"http://www.wrox.com/WileyCDA/WroxTitle/Professional-Assembly-Language.productCd-0764579010,descCd-tableOfContents.html\">http://www.wrox.com/WileyCDA/WroxTitle/Professional-Assembly-Language.productCd-0764579010,descCd-tableOfContents.html</a></p>\n<p><a href=\"http://media.wiley.com/product_data/excerpt/10/07645790/0764579010-2.pdf\">http://media.wiley.com/product_data/excerpt/10/07645790/0764579010-2.pdf</a></p>",
        "id": 294281596,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920545
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nHi Gottfried,</p>\n<p>most assembly formalisation don’t represent memory as an array, but as a function from address to value (usually byte or word). With that, read is just function application, store is function update. These are easier to reason about than arrays.</p>\n<p>There are existing large formalisations of x86 out there that you might want to look at. E.g. the Cambridge model in HOL4, which is close to what you’d do in Isabelle, or the model of Ben Pierce’s group in Coq.</p>\n<p>Cheers,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294281621,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920551
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nA little feedback can go a long way towards getting me to the next step.</p>\n<p>This all falls under a more general question: \"How do I execute a list <br>\nof instructions in Isabelle/HOL, like in a normal programming language?\"</p>\n<p>Even further: \"How do I use GOTO in a functional programming language?\"</p>\n<p>That led, with some past information, to this thought (possibly wrong):</p>\n<p>1) There is nothing mutable in Isabelle/HOL. Records only have the <br>\nappearance of mutability. Consequently, for my case, a record adds <br>\nneedless complexity.</p>\n<p>So, no mutability can lead to good things.</p>\n<p>I include some source and attach some source. The idea behind it is to <br>\nhave a cpu datatype that holds the register and memory state. I execute <br>\na list of instructions, and it produces a list of states, not that I <br>\nknow anything about state machines, only that Ramon Zuniga used to <br>\nimplement them in programmable logic. I wonder what that guy's up to <br>\nthese days.</p>\n<p>I did a trivial proof, to make sure I had a token proof to show, but the <br>\nvalue wasn't trivial. There was a simple condition I needed, and it <br>\nhadn't occurred to me that I needed it. Another example that shows that <br>\nproofs are a good thing.</p>\n<p>With no mutability, based on the basic idea, it seems I should be able <br>\nto prove some complex things about executing a list of instructions.</p>\n<p>Regards,<br>\nGB</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>*)<br>\ntheory i140618a__mem_write_execute_state_list<br>\nimports Complex_Main \"~~/src/HOL/Library/Code_Target_Nat\"<br>\nbegin</p>\n<p>(<em>16-bit dataword and a little notation.</em>)</p>\n<p>type_synonym b8T  = \"bool * bool * bool * bool * bool * bool * bool * <br>\nbool\"<br>\n   type_synonym b16T = \"b8T * b8T\"</p>\n<p>notation (input)<br>\n     False (\"0\\&lt;^sub&gt;B\")<br>\n   notation (input)<br>\n     True (\"1\\&lt;^sub&gt;B\")<br>\n   abbreviation hex00 :: b8T (\"00\\&lt;cdot&gt;\") where<br>\n     \"hex00 == <br>\n(0\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B)\"<br>\n   abbreviation hex55 :: b8T (\"55\\&lt;cdot&gt;\") where<br>\n     \"hex55 == <br>\n(0\\&lt;^sub&gt;B,1\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,1\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,1\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,1\\&lt;^sub&gt;B)\"<br>\n   abbreviation hexAA :: b8T (\"AA\\&lt;cdot&gt;\") where<br>\n     \"hexAA == <br>\n(1\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,1\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,1\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B,1\\&lt;^sub&gt;B,0\\&lt;^sub&gt;B)\"<br>\n   abbreviation hex16 :: \"b8T =&gt; b8T =&gt; b16T\" where<br>\n     \"hex16 b1 b0 == (b1, b0)\"<br>\n     notation hex16 (\"x\\&lt;bar&gt;__\" [1000, 1000] 1000)</p>\n<p>(*Indexed, fixed size b16T list. The list idx won't always match the <br>\npair idx.*)</p>\n<p>type_synonym idxed_flist = \"(nat * b16T) list * nat\"</p>\n<p>primrec idx0s_app_flist :: \"(nat * b16T) list \\&lt;Rightarrow&gt; nat <br>\n\\&lt;Rightarrow&gt; (nat * b16T) list\" where<br>\n     \"idx0s_app_flist nlist 0       = nlist\"<br>\n    |\"idx0s_app_flist nlist (Suc n) = idx0s_app_flist <br>\n((n,x\\&lt;bar&gt;00\\&lt;cdot&gt;00\\&lt;cdot&gt;) # nlist) n\"</p>\n<p>definition create_idxed_flist :: \"nat \\&lt;Rightarrow&gt; idxed_flist\" where<br>\n     \"create_idxed_flist lsize = (idx0s_app_flist [] lsize, lsize)\"</p>\n<p>value \"create_idxed_flist 0x10\"<br>\n   value \"length (fst (create_idxed_flist 0x10)) = 0x10\"</p>\n<p>(<em>The write function.</em>)</p>\n<p>primrec write_idxed_flist :: \"idxed_flist \\&lt;Rightarrow&gt; nat <br>\n\\&lt;Rightarrow&gt; b16T \\&lt;Rightarrow&gt; idxed_flist option\"<br>\n     where<br>\n     \"write_idxed_flist (flist, lsize) idx data = (<br>\n        if (idx &gt;= lsize \\&lt;or&gt; length flist \\&lt;noteq&gt; lsize) then None<br>\n        else Some (flist[idx := (idx, data)], lsize)<br>\n     )\"</p>\n<p>(<em>Two sequential writes done manually.</em>)</p>\n<p>value \"write_idxed_flist<br>\n     (the(write_idxed_flist (create_idxed_flist 0x10) 5 <br>\nx\\&lt;bar&gt;55\\&lt;cdot&gt;55\\&lt;cdot&gt;))<br>\n     3 x\\&lt;bar&gt;AA\\&lt;cdot&gt;AA\\&lt;cdot&gt;\"</p>\n<p>(<em>Automate execution of a list of writes, to generate a list of states.</em>)</p>\n<p>fun execute_list :: \"(idxed_flist option) list \\&lt;Rightarrow&gt; (nat * <br>\nb16T) list<br>\n         \\&lt;Rightarrow&gt; (idxed_flist option) list\" where<br>\n     \"execute_list [] _ = []\"<br>\n    |\"execute_list state_list [] = state_list\"<br>\n    |\"execute_list [s] ((idx,data) # xs)<br>\n        = execute_list ((write_idxed_flist (the s) idx data) # [s]) xs\"<br>\n    |\"execute_list (s # ss) ((idx,data) # xs)<br>\n        = execute_list ((write_idxed_flist (the s) idx data) # (s # ss)) xs\"<br>\n    (*Adding the third condition sped up the termination proof a lot. It <br>\nprobably<br>\n      needs more conditions to speed it up more.*)</p>\n<p>(*Execute a list of three instructions. The states are shown last to <br>\nfirst.*)</p>\n<p>abbreviation \"three_write_list ==<br>\n     [(5, x\\&lt;bar&gt;55\\&lt;cdot&gt;55\\&lt;cdot&gt;), (3, x\\&lt;bar&gt;AA\\&lt;cdot&gt;AA\\&lt;cdot&gt;), <br>\n(0x10, x\\&lt;bar&gt;55\\&lt;cdot&gt;55\\&lt;cdot&gt;)]\"</p>\n<p>value \"execute_list [Some (create_idxed_flist 0xF)] three_write_list\"</p>\n<p>(*Prove something trivial. The value of proving this wasn't trivial. It <br>\nshowed<br>\n   me I needed the condition \"length flist \\&lt;noteq&gt; lsize\" in my <br>\nfunction above.*)</p>\n<p>lemma \"idx &lt; lsize \\&lt;and&gt; length flist = lsize<br>\n     \\&lt;Longrightarrow&gt; write_idxed_flist (flist, lsize) idx dw \\&lt;noteq&gt; <br>\nNone\"<br>\n   by(simp)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\nend<br>\n<a href=\"/user_uploads/14278/PD5PiLNc3Rt02z4q_79YUZVO/i140618a__mem_write_execute_state_list.thy\">i140618a__mem_write_execute_state_list.thy</a></p>",
        "id": 294281721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920582
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Tue, Jun 17, 2014 at 11:54 PM, Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt; wrote:</p>\n<blockquote>\n<p>On 14-06-17 16:58, Gerwin Klein wrote:</p>\n<blockquote>\n<p>most assembly formalisation don’t represent memory as an array, but as a<br>\nfunction from address to value (usually byte or word). With that, read is<br>\njust function application, store is function update. These are easier to<br>\nreason about than arrays.</p>\n<p>Gerwin,</p>\n</blockquote>\n<p>I do actually have a set of word datatypes in mind. At the moment, this is<br>\nwhat I'm thinking:</p>\n<p>type_synonym b8T   = \"bool * bool * bool * bool * bool * bool * bool *\nbool\"<br>\n  type_synonym b16T  = \"b8T * b8T\"<br>\n  type_synonym b32T  = \"b16T * b16T\"<br>\n  type_synonym b64T  = \"b32T * b32T\"<br>\n  type_synonym b128T = \"b64T * b64T\"<br>\n  type_synonym b256T = \"b128T * b128T\"</p>\n<p>If someone showed me specifically the memory representation you're talking<br>\nabout, along with some supplementary documentation and explanations, I<br>\ncould probably figure out in about 15 minutes to an hour whether trying to<br>\ngo that route would be within my ability.</p>\n<p>There are existing large formalisations of x86 out there that you might</p>\n<blockquote>\n<p>want to look at. E.g. the Cambridge model in HOL4, which is close to what<br>\nyou’d do in Isabelle...<br>\n</p>\n</blockquote>\n<p>Initially, I did have the idea to try and model things at the bit and<br>\nopcode level, but I decided that's not doable. Lifetimes have an upper<br>\nlimit, and it's hard to produce something as it is.</p>\n<p>I've started to compartmentalize more between programming and proving. I<br>\ndon't have to do proofs for all the functions, datatypes, and lines of<br>\nlogic I define in Isabelle/HOL, though proofs are desirable. Isabelle is<br>\nuseful just as a way to work with functions and datatypes at a higher<br>\nlevel, to experiment with ideas.</p>\n<p>My idea now is to take a very minimal model of an Intel cpu and implement<br>\npseudo-assembly language around that model, for the smallest number of<br>\ninstructions possible.</p>\n<p>It seems it should be very simple. I move data in and out of registers,<br>\nback and forth to memory, doing bit operations and arithmetic, and look at<br>\nflags to make decisions. As far as proving, that wouldn't be simple at all.</p>\n<p>I have to go with what I know, and I always learn something in the process<br>\nanyway. The only mutable datatype I know about in Isabelle/HOL is a record,<br>\nso it seems a mutable array would have to be something like I defined.</p>\n<p>I did a few searches on the HOL4 model you mentioned, but my motivation is<br>\nlow to pursue that. It's got to be very complex and huge.<br>\n</p>\n</blockquote>\n<p>I recommend looking at the other (non-x86) processor models in HOL4 too.<br>\nNot all are complex and huge (though I guess that depends on your<br>\nperspective).</p>\n<blockquote>\n<p>Thanks,<br>\nGB</p>\n</blockquote>",
        "id": 294281751,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920591
    }
]