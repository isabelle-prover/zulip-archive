[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>There's the meta-and, &amp;&amp;&amp;, but I need a meta-or, so I don't have to <br>\ndefine two meta-or operators to keep from using PROP. After giving a <br>\nsummary, I show what I found in pure_thy.ML, but I don't know how to <br>\nmake it work.</p>\n<p>As it is, I have to define two meta-or operators to not have to use PROP:</p>\n<p>definition orbb :: \"bool ⇒ bool ⇒ prop\" (infixr \"||\" 15) where<br>\n\"orbb P Q == (!!R. (P ==&gt; R) ==&gt; (Q ==&gt; R) ==&gt; R)\"</p>\n<p>definition orbp :: \"bool ⇒ prop ⇒ prop\" (infixr \"|||\" 15) where<br>\n\"orbp P Q == (!!R. (P ==&gt; R) ==&gt; (PROP Q ==&gt; R) ==&gt; R)\"</p>\n<p>(<em>Life is messy with two operators.</em>)<br>\ntheorem<br>\n\"(A ||| (B || C)) ==&gt; (A | (B | C))\"<br>\napply(simp add: orbb_def orbp_def)<br>\nby(smt)</p>\n<p>(<em>Life is clean with &amp;&amp;&amp;.</em>)<br>\ntheorem<br>\n\"(A &amp;&amp;&amp; (B &amp;&amp;&amp; C)) ==&gt; (A &amp; (B &amp; C))\"<br>\nby(linarith)</p>\n<p>If there's a &amp;&amp;&amp;, then it seems there should be the complete suite of <br>\nbasic meta operators, along the lines of lines 175 to 183 in HOL.thy.</p>\n<p>In pure_thy.ML, I found these lines for &amp;&amp;&amp;:</p>\n<p>val typ = Simple_Syntax.read_typ;<br>\nval prop = Simple_Syntax.read_prop;<br>\nval const = Lexicon.mark_const;</p>\n<p>Sign.add_syntax_i [(const \"Pure.conjunction\", typ \"prop =&gt; prop =&gt; <br>\nprop\", Infixr (\"&amp;&amp;&amp;\", 2))];<br>\nSign.add_consts_i [(<a href=\"http://Binding.name\">Binding.name</a> \"conjunction\", typ \"prop =&gt; prop =&gt; <br>\nprop\", NoSyn)];<br>\n(Global_Theory.add_defs false o map Thm.no_attributes)<br>\n[(<a href=\"http://Binding.name\">Binding.name</a> \"conjunction_def\", prop \"(A &amp;&amp;&amp; B) == (!!C::prop. (A ==&gt; <br>\nB ==&gt; C) ==&gt; C)\")];<br>\nSign.hide_const false \"Pure.conjunction\";</p>\n<p>I tried to modify them like this to get my meta-or, but I can't make it <br>\nwork:</p>\n<p>ML{*<br>\nval typ = Simple_Syntax.read_typ;<br>\nval prop = Simple_Syntax.read_prop;<br>\nval const = Lexicon.mark_const;</p>\n<p>Sign.add_syntax_i [(const \"MFZ.meta_or\", typ \"prop =&gt; prop =&gt; prop\", <br>\nInfixr (\"|||\", 2))];<br>\nSign.add_consts_i [(<a href=\"http://Binding.name\">Binding.name</a> \"meta_or\", typ \"prop =&gt; prop =&gt; prop\", <br>\nNoSyn)];<br>\n(Global_Theory.add_defs false o map Thm.no_attributes)<br>\n[(<a href=\"http://Binding.name\">Binding.name</a> \"meta_or_def\", prop \"(A ||| B) == (!!R::prop. (P ==&gt; R) <br>\n==&gt; (Q ==&gt; R) ==&gt; R)\")];<br>\nSign.hide_const false \"MFZ.meta_or\";<br>\n*}</p>\n<p>If anyone can do a quick edit to make that work, I would appreciate it.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294243914,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908142
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI found a faster solution, so I don't know if I need what I asked for. <br>\nHowever, it shows that a person might want to define a function using <br>\ntype prop, and not have to annotate everything with PROP, and need not <br>\nto have to fight the automatic Trueprop coercion.</p>\n<p>But I'm trying to duplicate the functionality of the right-hand side of <br>\na sequent without resorting to the object-logic operators.</p>\n<p>According to pg.203 of isar-ref.pdf, if you have a sequent \"A |- E, B, <br>\nC, D\", then you can negate all the right-hand side members except for <br>\none of them, and make a big implication out of it, with the non-negated <br>\nmember put to the far right, like \"A ==&gt; ~E ==&gt; ~C ==&gt; ~D ==&gt; B\".</p>\n<p>So rather than implement the right-hand side as a meta-disjunction, I <br>\nstay closer to what's in isar-ref.pdf. It's faster and acceptably meta. <br>\nI have to use variables of type bool, along with False, which equals <br>\n(!P. P), but the rest is ==&gt;.</p>\n<p>The simplifier seems to like working directly with True and False, <br>\nrather than lower-level definitions.</p>\n<p>I still have to use two operators:</p>\n<p>notation ==&gt; (infixr \"|-\" 4)</p>\n<p>definition seqr :: \"bool =&gt; bool =&gt; prop\" (infixr \"||\" 15) where<br>\n   \"seqr P Q == ((P ==&gt; False) ==&gt; Q)\"<br>\nthm seqr_def</p>\n<p>definition seql :: \"bool =&gt; prop =&gt; prop\" (infixr \"|||\" 15) where<br>\n   \"seql P Q == ((P ==&gt; False) ==&gt; PROP Q)\"<br>\nthm seql_def</p>\n<p>theorem<br>\n   \"   (A |- (~E ==&gt; ~C ==&gt; ~D ==&gt; B))<br>\n   ==&gt; (A |- (E ||| B ||| C || D))\"<br>\napply(auto simp only: seqr_def seql_def)<br>\ndone</p>\n<p>theorem<br>\n   \"   (A |- (E ||| B ||| C || D))<br>\n   ==&gt; (A |- (~E ==&gt; ~C ==&gt; ~D ==&gt; B))\"<br>\napply(auto simp only: seqr_def seql_def)<br>\ndone</p>\n<p>It seems right.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294243939,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908158
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIn principle you could define all the standard connectives of Isabelle/HOL <br>\nin Isabelle/Pure as well, but what is the point?</p>\n<p>The purpose of Isabelle/Pure is to provide a framework for higher-order <br>\nnatural deduction, with declarative rule structure indicated by the <br>\nconnectives !! and ==&gt; (i.e. Minimal Higher-order Logic).  Anything beyond <br>\nthat is not really pure.</p>\n<p>Note that &amp;&amp;&amp; is merely used internally as auxilary device -- it should <br>\nhardly ever occur in applications of Isabelle/Pure (or HOL).  You just use <br>\nmultiple propositions directly in Isar like this:</p>\n<p>lemma A and B and C<br>\n   proof -<br>\n     show A sorry<br>\n     show B sorry<br>\n     show C sorry<br>\n   qed</p>\n<p>You better chose to ignore that the internal system state somewhere <br>\ninvolves \"A &amp;&amp;&amp; B &amp;&amp;&amp; C\" -- it is never encountered in a regular proof.</p>\n<p>Makarius</p>",
        "id": 294244105,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908237
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/29/2013 3:23 PM, Makarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>If there's a &amp;&amp;&amp;, then it seems there should be the complete suite of <br>\nbasic meta operators</p>\n</blockquote>\n<p>In principle you could define all the standard connectives of <br>\nIsabelle/HOL in Isabelle/Pure as well, but what is the point?</p>\n</blockquote>\n<p>Makarius,</p>\n<p>For myself, the point has become more general. Having meta-connectives <br>\nwould now be a result of being able to define functions using \"prop\", <br>\nsuch as \"prop =&gt; prop\", \"prop =&gt; prop =&gt; prop\", etc., and have the <br>\nfunctions coexist nicely with Trueprop coercion just like <br>\nmeta-implication does, that is, not having to annotate the variables <br>\nwith PROP, and Trueprop not trying to coerce when it's not supposed to.</p>\n<p>For me, the general point is to do formalizations about other logics <br>\nwithin HOL, and be able to keep those formalizations respectably <br>\nseparate from the object-logic functions, definitions, axioms, etc., <br>\nuntil I intentionally want to mix the (mostly) meta-logic with the <br>\nobject-logic.</p>\n<p>I don't know that it has to be about formalizing other logics. If you <br>\nhad an Isar definition and Isar abbreviation command that allowed a <br>\nperson to define functions using prop, and the functions behaved nicely <br>\nlike ==&gt;, then people would find a use for those commands.</p>\n<p>I now have the perfect function to make my point, which is not the <br>\nmeta-or I asked for at first. The meta-or I initially wanted sort of <br>\nfell under the \"what is the point\" category. Meta-or is \"(!!R. (P ==&gt; R) <br>\n==&gt; (Q ==&gt; R) ==&gt; R)\", so to make it practical to use, you would have to <br>\nstart defining a bunch of simp rules, and then you'd end up asking, \"And <br>\nwhy exactly am I duplicating all the simp rules that have been created <br>\nfor \\&lt;or&gt;?\"</p>\n<p>My function now is, \"((P ==&gt; False) ==&gt; Q)\", which requires absolutely <br>\nnothing additional to use. If I want to go total meta (other than bool <br>\nvariables), then I can replace False with \"(!!P Q. P == Q::bool)\", which <br>\nwould only require a simp rule to convert the meta-False back to False, <br>\nsince meta-False by itself can make simplification slower.</p>\n<blockquote>\n<p>The purpose of Isabelle/Pure is to provide a framework for <br>\nhigher-order natural deduction, with declarative rule structure <br>\nindicated by the connectives !! and ==&gt; (i.e. Minimal Higher-order <br>\nLogic).  Anything beyond that is not really pure.</p>\n</blockquote>\n<p>You're the authority, but my inclination is to say that a logic is <br>\ndefined by its axioms, so I'm inclined to say that any logic that is <br>\nderived using only Pure is Pure. Even with a little bit of corruption, <br>\nlike having to use bool variables, I'd say it can be considered Pure, <br>\npractically speaking. I'm just a novice here speaking.</p>\n<p>You talk about Isabelle/Pure as a framework, but I don't see the problem <br>\nwith taking the framework to its limits, though there would have to be <br>\nIsar commands to facilitate that, or ML templates that can be used to <br>\ndefine \"prop\" based functions that behave like ==&gt;.</p>\n<p>My interest in this evolved due to sequents. The LHS of a sequent is a <br>\nconjunction, which matches the use of ==&gt; perfectly. The RHS of a <br>\nsequent is a disjunction, so for the RHS, ==&gt; by itself ceases to work.</p>\n<p>I created some notation to sync up the turnstile with ==&gt;, and I used <br>\n\\&lt;or&gt; to duplicate the RHS properties of the sequent.</p>\n<p>I then plugged in a sequent derivation proof from Wikipedia with my <br>\nnotation. It happened to be that the second line of the proof and the <br>\nconclusion of the proof were the same, because of the \\&lt;or&gt;. Very <br>\nuninspiring. A \"what's the point\" moment.</p>\n<p>If there's a mistake, it's that you make it too easy to use ==&gt;. If I <br>\nknow that ==&gt; is of type (prop =&gt; prop =&gt; prop), and I can do:</p>\n<p>theorem \"A ==&gt; (B ==&gt; C)\"</p>\n<p>It's only natural that I think I should be able to do:</p>\n<p>abbreviation imp2 :: \"prop =&gt; prop =&gt; prop\" (infixr \"=+&gt;\" 15) where<br>\n       \"imp2 P Q == (P ==&gt; Q)\"</p>\n<p>theorem \"A =+&gt; (B =+&gt; C)\"</p>\n<p>But it doesn't work. I can finagle things to make it work, but it'll <br>\nnever work like that.</p>\n<p>The good news is that my finagling led to something that's acceptable <br>\n(with Lars' prior help).</p>\n<p>I think there are lots of tangents to go off on for why a person might <br>\nwant to intentionally stay within the meta-logic. Part of it is catching <br>\nthe \"meta-logic spirit\". What other proof assistant has a meta-logic <br>\nthat a person can use?</p>\n<p>Part of it is trying to figure out what in Isabelle/HOL is optimized for <br>\nthe meta-logic, and what's optimized for the object-logic. Overusing the <br>\nmeta-logic should at least teach me how to use the meta-logic, and <br>\nformalizing something differently can sometimes help a person do old <br>\nthings better.</p>\n<p>I do this:</p>\n<p>theorem \"(A ==&gt; False) ==&gt; (~A)\"<br>\n    using[[simp_trace]]<br>\n    apply(auto simp only:)<br>\n    done</p>\n<p>The simp trace shows this:</p>\n<p>[1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\n    (A ==&gt; False) ==&gt; ~A<br>\n    [1]Adding rewrite rule \"??.unknown\":<br>\n    A == True</p>\n<p>I didn't give it any simp rules about True and False, but it knows how <br>\nto use them. That tells me the simplifier is optimized for the <br>\nobject-logic, that and 15ms more for a proof if I use meta-False.</p>\n<p>Consequently, I decide I should use \"((P ==&gt; False) ==&gt; Q)\" instead of <br>\n\"((P ==&gt; (!!P Q. P == Q::bool)) ==&gt; Q)\", because in this case, the <br>\nperformance price for staying pure is probably too high, and False is <br>\nnot too much to accept. It's some lambda calculus and the HOL refl axiom.</p>\n<p>I know that the logic engine really likes statements like \"P ==&gt; Q\", so <br>\nI'm trying to go through the exercise of seeing to what extent I can <br>\nstay in the \"==&gt;\" world. I don't think the logic engine is fond of <br>\nthings like \"(!!R. (P ==&gt; R) ==&gt; (Q ==&gt; R) ==&gt; R)\", but I'm pretty sure <br>\nthat it doesn't consider \"((P ==&gt; False) ==&gt; Q)\" to be much more of a <br>\nburden than \"P ==&gt; Q\". In fact, I think the logic engine loves \"((P ==&gt; <br>\nFalse) ==&gt; Q)\", because it's easy, and different.</p>\n<p>In a more perfect world, my function \"((P ==&gt; False) ==&gt; Q)\" would be of <br>\ntype \"prop =&gt; prop =&gt; prop\". It's okay that it's not. I'm happy to have <br>\nfound something that's simple, and that fits in the \"==&gt;\" paradigm.</p>\n<p>After your email I put a little more effort into creating the <br>\nmeta-versions of the standard connectives. I was trying to cut and paste <br>\nfrom the HOL versions, but the HOL versions use lambda calculus, which <br>\nwasn't working for me. Then I came up with the version for meta-False, <br>\nwhich gave me meta-not, and then I cut and pasted for the meta-exists.</p>\n<p>If the performance cost is too high to stay pure, then I don't want to <br>\nuse the meta-connectives. But my perfect example, \"((P ==&gt; False) ==&gt; <br>\nQ)\", which I've used to make my point, is not a standard connective. <br>\nIt's also fast, and I need it, and I want it. I have it, too. Just not <br>\nin a one-operator form.</p>\n<p>Regards,<br>\nGB</p>\n<p>notation ==&gt; (infixr \"|-\" 4)</p>\n<p>abbreviation mFalse :: \"prop\" (\"mFalse\") where<br>\n   \"mFalse == (!!P Q. P == Q::bool)\"</p>\n<p>abbreviation (input) seqr :: \"bool =&gt; bool =&gt; prop\" (infixr \"||\" 9) where<br>\n   \"seqr P Q == ((P ==&gt; mFalse) ==&gt; Q)\"</p>\n<p>abbreviation (input) seql :: \"bool =&gt; prop =&gt; prop\" (infixr \"|||\" 9) where<br>\n   \"seql P Q == ((P ==&gt; mFalse) ==&gt; PROP Q)\"</p>\n<p>theorem mF_EQ_False:<br>\n   \"mFalse == (Trueprop False)\"<br>\nby(rule equal_intr_rule, metis, presburger)</p>\n<p>(*3ms with False in abbreviation.<br>\n   18ms with meta-False used in abbreviation and no mF_EQ_False simp rule.<br>\n   3ms with meta-False used in abbreviation and simp rule mF_EQ_False.*)<br>\ntheorem<br>\n   \"   (A |- (~E ==&gt; ~C ==&gt; ~D ==&gt; B))<br>\n   ==&gt; (A |- (E ||| B ||| C || D))\"<br>\napply(auto simp only: mF_EQ_False)<br>\ndone</p>\n<p>theorem meta_not_EQ_not:<br>\n   \"(P ==&gt; (!!P Q. P == Q::bool)) == (Trueprop (~P))\"<br>\napply(simp only: mF_EQ_False not_def)<br>\napply(rule equal_intr_rule)<br>\nby(auto)</p>\n<p>theorem meta_exists_EQ_exists:<br>\n   \"(!!Q. (!!x. P x ==&gt; Q) ==&gt; Q) == (Trueprop (? x. P x))\"<br>\napply(rule equal_intr_rule)<br>\nby(auto simp only:)</p>",
        "id": 294244180,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908262
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nIt's a syntax priority problem.</p>\n<p>Trueprop priority is 5, so dealing with the syntax of functions of type <br>\n\"prop =&gt; prop\" and \"prop =&gt; prop =&gt; prop\" is tricky:</p>\n<p>Trueprop :: \"bool =&gt; prop\"   (\"(_)\" 5)</p>\n<p>I haven't figured out the rules completely, but it seems I have what I need.</p>\n<p>However, the rules don't make complete sense. For this meta_not_abbr, <br>\nthe function form \"meta_not_abbr P\" gets a coercion error, but notation <br>\nwith a priority of 40 works, or even 4:</p>\n<p>abbreviation (input) meta_not_abbr :: \"prop =&gt; prop\"  where<br>\n       \"meta_not_abbr P == (PROP P ==&gt; False)\"</p>\n<p>notation meta_not_abbr (\"~~~ _\" 40)</p>\n<p>theorem<br>\n       \"meta_not_abbr P\" (* coercion error *)</p>\n<p>theorem<br>\n       \"(~~~ (~~~ P)) == Trueprop (P)\"<br>\n    by(rule equal_intr_rule, auto simp only:)</p>\n<p>I then have my meta_or_abbr. The function form \"meta_or_abbr P Q\" also <br>\ngets a coercion error, but infixr notation with priority less than 5 <br>\nworks, and notation (\"mOr _ _\") also works:</p>\n<p>abbreviation (input) meta_or_abbr :: \"prop =&gt; prop =&gt; prop\"  where<br>\n       \"meta_or_abbr P Q == ((PROP P ==&gt; False) ==&gt; PROP Q)\"</p>\n<p>notation<br>\n       meta_or_abbr (infixr \"+++\" 4) and<br>\n       meta_or_abbr (\"mOr _ _\")</p>\n<p>theorem<br>\n       \"(P +++ Q +++ R) == Trueprop (P | Q | R)\"<br>\n    by(rule equal_intr_rule, auto simp only:)</p>\n<p>theorem<br>\n       \"(mOr P Q) == Trueprop (P | Q)\"<br>\n    by(rule equal_intr_rule, auto simp only:)</p>\n<p>theorem<br>\n       \"meta_or_abbr P Q\" (* coercion error *)</p>\n<p>Here are the four connective hybrids. I know why I need one of them:</p>\n<p>theorem meta_not:<br>\n   \"(P ==&gt; False) == Trueprop (~P)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>theorem meta_or:<br>\n   \"((P ==&gt; False) ==&gt; Q) == Trueprop (P | Q)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>theorem meta_and:<br>\n   \"((P ==&gt; (Q ==&gt; False)) ==&gt; False) == Trueprop (P &amp; Q)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>theorem meta_exists:<br>\n   \"((!!x. P x ==&gt; False) ==&gt; False) == Trueprop (? x. P x)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>",
        "id": 294244334,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908323
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIf you want to play with syntax, you can always use 'notation' and <br>\n'no_notation' to specify things in any way you like, but don't ask me <br>\nabout suitable priorities -- this is a black art and better not changed <br>\nfundamentally.</p>\n<p>Generally, Isabelle/Pure is not really a meta-logic, i.e. a logic to <br>\nreason about other logics.  It is just a logical framework, for <br>\nhigher-order natural deduction based on !! and ==&gt;.</p>\n<p>If you really want to reason about some other logic, better do it in <br>\nIsabelle/HOL, and define you syntax as datatype, semantics as function, <br>\ninference system as inductive predicate in the usual way.  AFP has <br>\nexamples for that.</p>\n<p>Makarius</p>",
        "id": 294244390,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908342
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/31/2013 3:29 PM, Makarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>Trueprop priority is 5, so dealing with the syntax of functions of <br>\ntype \"prop =&gt; prop\" and \"prop =&gt; prop =&gt; prop\" is tricky:</p>\n<p>Trueprop :: \"bool =&gt; prop\"   (\"(_)\" 5)</p>\n</blockquote>\n<p>If you want to play with syntax, you can always use 'notation' and <br>\n'no_notation' to specify things in any way you like, but don't ask me <br>\nabout suitable priorities -- this is a black art and better not <br>\nchanged fundamentally.</p>\n</blockquote>\n<p>Reminder to self. Add the following to the official GB list of HOL <br>\ncardinal rules: \"Never change the default settings of Trueprop priority. <br>\nLive within the limits of Trueprop priority being at 5, lest you cause <br>\nyourself or others great logical harm in the future.\"</p>\n<blockquote>\n<p>Generally, Isabelle/Pure is not really a meta-logic, i.e. a logic to <br>\nreason about other logics.  It is just a logical framework, for <br>\nhigher-order natural deduction based on !! and ==&gt;.</p>\n<p>If you really want to reason about some other logic, better do it in <br>\nIsabelle/HOL, and define you syntax as datatype, semantics as <br>\nfunction, inference system as inductive predicate in the usual way.  <br>\nAFP has examples for that.</p>\n</blockquote>\n<p>In these technical matters, I'm a practical purist. I'm only interested <br>\nin logics other than HOL to the extent they help me understand <br>\nisar-ref.pdf, and other Isabelle documentation. I also want there to be <br>\nthe possibility that I can use anything I do as part of HOL. I'm just a <br>\nuser who delves into foundations because I never found the book \"Set <br>\nTheory, Real Analysis, Algebra, Combinatorics, and Number Theory for <br>\nMaple, Mathematica, and Even Isabelle2013\".</p>\n<p>I decided to take a step back and finally study natural deduction. <br>\nHowever, natural deduction inevitably leads to sequents, so I have <br>\nwanted to create a psuedo-sequent to use with exercises and, in some <br>\nmanner, really be using a metalanguage.</p>\n<p>With the pseudo-sequent I have now, there is the possibility that it <br>\nwill all end up being academic, where I end up only using the standard <br>\nnatural deduction rules. There is also the possibility that I will <br>\neventually find a use for the pseudo-sequent, or at least for the notation.</p>\n<p>I have no idea at this point why the RHS of a sequent needs to behave as <br>\na disjunction, or why a person needs more than what the natural <br>\ndeduction rules provide. But, it could be that I find a practical use <br>\nfor stating a theorem using a meta-or along with !! and ==&gt;. Sometimes, <br>\nwe do that kind of thing as a preliminary step, because it helps us sort <br>\nout foggy concepts.</p>\n<p>Thanks for the help, and thanks to Lars for the info about PROP.</p>\n<p>I got my meta-False down to \"(!!P. P::bool)\". If I could roam the halls <br>\nof CMU, I'd stop by Avigad's office, make sure I called him professor, <br>\nand ask him if I can get a meta-False without using !!.</p>\n<p>Regards,<br>\nGB</p>\n<p>notation ==&gt; (infixr \"|-\" 4) (* ==&gt; and |-, they're close relatives. *)<br>\nnotation ==&gt; (infixr \",,\" 4) (* Fake sequent comma. It's all ==&gt; on the <br>\nLHS. *)</p>\n<p>(<em>Warning!! What's below could all be bogus.</em>)</p>\n<p>(*Meta False. Trying to use \"PROP P\" instead of \"P::bool\" causes some <br>\nlooping<br>\n   below. It's no loss. If automatic Trueprop coercion is used, there's <br>\nno extra<br>\n   purity obtained from using \"PROP P\".</p>\n<p>It looks like I'm only tied into the object-logic because of these <br>\nstatements:<br>\n     typedecl bool<br>\n     judgment Trueprop :: \"bool =&gt; prop\",<br>\n   though probably also to the arities statements right above them.*)</p>\n<p>abbreviation MFalse :: \"prop\" (\"MFalse\") where<br>\n   \"MFalse == (!!P. P::bool)\"</p>\n<p>theorem meta_False:<br>\n   \"MFalse == (Trueprop False)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>(<em>Meta not.</em>)<br>\nabbreviation (input) meta_not_abbr :: \"prop =&gt; prop\" (\"([~]_)\" 40) where<br>\n   \"meta_not_abbr P == (PROP P ==&gt; MFalse)\"</p>\n<p>theorem meta_not:<br>\n   \"([~]P) == Trueprop (~P)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>(<em>Meta or.</em>)<br>\nabbreviation (input) meta_or_abbr :: \"prop =&gt; prop =&gt; prop\" (infixr <br>\n\"([|])\" 4) where<br>\n   \"meta_or_abbr P Q == ((PROP P ==&gt; MFalse) ==&gt; PROP Q)\"</p>\n<p>theorem meta_or:<br>\n   \"(P [|] Q) == Trueprop (P | Q)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>(<em>Meta and.</em>)<br>\nabbreviation (input) meta_and_abbr :: \"prop =&gt; prop =&gt; prop\" (infixr <br>\n\"([&amp;])\" 4) where<br>\n   \"meta_and_abbr P Q == ((PROP P ==&gt; (PROP Q ==&gt; MFalse)) ==&gt; MFalse)\"</p>\n<p>theorem meta_and:<br>\n   \"(P [&amp;] Q) == Trueprop (P &amp; Q)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>(*Meta exists. I don't feel like looking up how to do the binder <br>\nnotation right<br>\n   now. The presence of implicit meta-quantification always leaves one <br>\nparanoid.<br>\n   You do the pencil and paper scratch work 15 times, but because you cannot<br>\n   stop by Avigad's office to get confirmation of the obvious, and <br>\nbecause you<br>\n   have used up your bi-monthly mailing list quota for asking questions, <br>\nyou never<br>\n   rest easy.*)<br>\ntheorem meta_exists:<br>\n   \"((!!x. P x ==&gt; MFalse) ==&gt; MFalse) == Trueprop (? x. P x)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>(*Finally, the pseudo-sequent. The order of the arguments on both the <br>\nLHS and<br>\n   RHS don't matter, and there's actually a meta-language operator being <br>\nused<br>\n   that's not HOL disjunction.</p>\n<p>The priorities of the commas, |-, and [|] are all at 4, so they nest <br>\nto the<br>\n   right, which means I don't have to use parentheses for the turnstile <br>\nstatement.<br>\n   The ==&gt; is at priority 1 so the parentheses have to be used as shown.*)</p>\n<p>theorem<br>\n   \"  (P,, Q |- (~E ==&gt; ~C ==&gt; ~D ==&gt; B))<br>\n   == (Q,, P |- E [|] B [|] C [|] D)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>\n<p>theorem<br>\n   \"  (P,, Q |- (~E ==&gt; ~C ==&gt; ~D ==&gt; B))<br>\n   == (Q,, P |- D [|] E [|] B [|] C)\"<br>\nby(rule equal_intr_rule, auto simp only:)</p>",
        "id": 294246020,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908952
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nWanting to be a helpful, altruistic individual, I give you now a way to <br>\ncreate some priority space, for that day when selfish indiviuals <br>\ncomplain, moan, and groan about there not being enough space between the <br>\npriorities of =&gt;, !!, ==&gt;, ==, and Trueprop, which are at 0, 0, 1, 2, <br>\nand 5, you being well aware of such things.</p>\n<p>For priorities 5 and above, you add 95 to them. This puts Trueprop at a <br>\nnice 100. For priorities 0 to 4, you put them at 10, 20, 30, 40, and 50. <br>\nThat would be one way to do it, unless there's something I'm not <br>\nconsidering.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294246213,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909017
    }
]