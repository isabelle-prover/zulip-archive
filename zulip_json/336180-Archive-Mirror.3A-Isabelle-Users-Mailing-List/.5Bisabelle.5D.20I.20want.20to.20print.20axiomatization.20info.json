[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I have a function:</p>\n<p>axiomatization--\"Set membership predicate.\"<br>\n   in\\&lt;^isub&gt;\\&lt;sigma&gt;::\"\\&lt;sigma&gt;\\&lt;^isub&gt;t \\&lt;Rightarrow&gt; <br>\n\\&lt;sigma&gt;\\&lt;^isub&gt;t \\&lt;Rightarrow&gt; \\&lt;sigma&gt;\\&lt;^isub&gt;t\\&lt;^isub&gt;b\" (\"_ <br>\n\\&lt;in&gt;\\&lt;^isub&gt;\\&lt;sigma&gt; _\" 55)</p>\n<p>I then state multiple axioms about it, one of them being:</p>\n<p>axiomatization--\"Axiom schema of comprehension: schema set.\" where<br>\n   \\&lt;Sigma&gt;\\&lt;^isub&gt;s\\&lt;^isub&gt;c\\&lt;^isub&gt;A: \"\\&lt;forall&gt;u. \\&lt;forall&gt;P. <br>\n\\&lt;exists&gt;a. \\&lt;forall&gt;x.(x \\&lt;in&gt;\\&lt;^isub&gt;\\&lt;sigma&gt; a \\&lt;longleftrightarrow&gt; <br>\n(x \\&lt;in&gt;\\&lt;^isub&gt;\\&lt;sigma&gt; u \\&lt;and&gt; P x))\"</p>\n<p>I want to look at how Isabelle decided to type variables in my <br>\naxiomatization, but I can't find any print or find commands that will do <br>\nthat for me. I also want to see if explicit parentheses will be added as <br>\nI expect, and see if there are any operator priority surprises.</p>\n<p>Is there such a command that will do this for me?</p>\n<p>The above is the basic question. Here's what led me to want to know this:</p>\n<p>1) I used \"\\&lt;in&gt;\" as notation for my set membership.<br>\n2) I got lots of warnings like: \"Ambiguous input produces 4 parse <br>\ntrees... Fortunately, only one parse tree is type correct...\"<br>\n3) I change my notation to \" \\&lt;in&gt;\\&lt;^isub&gt;\\&lt;sigma&gt;\", and it gets rid of <br>\nsome of the warnings.<br>\n4) For the axiom above, I still get \"ambiguous\" warnings, with some of <br>\nthe variables explicitly typed.<br>\n5) So, I explicitly type every variable in the formula, and I still get <br>\n\"ambiguous\" warnings.<br>\n6) So, I remove all the typing, and it seems to work. Explicit or <br>\nnon-explicit typing doesn't affect the warnings.<br>\n7) I then conclude that Isabelle gets all of the typing information in <br>\nthe formula from my one uniquely named function, \"in\\&lt;^isub&gt;\\&lt;sigma&gt;\". <br>\nConsequently, I ask myself, \"Is that too good to be true?\"</p>\n<p>Okay, if I knew how to prove anything, maybe I would know how to get the <br>\ninformation I want. However, even if I was an expert, I would want to be <br>\nable to get immediate feedback to check my typing, see if I'm correctly <br>\nusing parentheses, and see if I understand correctly the priority of the <br>\noperators.</p>\n<p>I attach a screen shot of my code. I don't think attaching images and <br>\nPDFs is the best way to give people code information. On the other hand, <br>\nthe above low-level Isar shows that nice looking things in jEdit cease <br>\nto be good for reading in a text file. Also, \"\\&lt;^isub&gt;\" doesn't result <br>\nin subscripted, unicode characters when copying and pasting.</p>\n<p>jEdit Stuff: I edited the etc/symbols file and jEdit gave me an <br>\nexception error when loading. Afterwards, jEdit wouldn't translate <br>\ncommands like \"\\&lt;in&gt;\" in the one file. About an hour later, or two, I <br>\ndeleted \"jEdit/recent.xml\" and it started working again.</p>\n<p>Regards,<br>\nGB<br>\n<a href=\"/user_uploads/14278/57GyiJYt2WNLYiDafnvTr1JV/wantToPrintAxiomInfo.png\">wantToPrintAxiomInfo.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/57GyiJYt2WNLYiDafnvTr1JV/wantToPrintAxiomInfo.png\" title=\"wantToPrintAxiomInfo.png\"><img src=\"/user_uploads/14278/57GyiJYt2WNLYiDafnvTr1JV/wantToPrintAxiomInfo.png\"></a></div>",
        "id": 294218981,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896420
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThis message indicates that your syntax is ambiguous. The way to eliminate such a message is by disambiguating your syntax, which in most cases means tightening up the precedences of operators. And indeed, your operator â€œin\" gives no precedence information for its operands. I wonder why you don't use something akin to (ignoring fancy symbols)</p>\n<p>(infixl \"IN\" 55)</p>\n<p>where you have</p>\n<p>(\"_ IN_ \" 55) .</p>\n<p>Larry Paulson</p>",
        "id": 294219010,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896437
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nLarry,</p>\n<p>Thanks for fix. It makes sense now that a binary operator needs an <br>\nassociativity rule. I was trying to finish making my table of HOL <br>\noperator priorities, so I would have lots of examples, and then try to <br>\ndig through section \"7.2 Mixfix annotations\" of isar-ref.pdf. But now, I <br>\ncan put off looking at the mixfix documentation.</p>\n<p>(For anyone interested, I've attached iS.thy. Load it into jEdit, have <br>\nsidekick open to see the section tree, and in section 1 there's all the <br>\nsymbols from etc/symbols. In section 2 there's a table showing the <br>\nmixfix operator priorites from HOL.thy, and in section 3 there's the <br>\nsource from src/Pure/pure_thy.ML, which contains the mixfix operator <br>\npriorities for the Pure logic.)</p>\n<p>If I had print commands, like thm, find_theorems, find_consts, etc., but <br>\nfor axiomatizations and defs, I might could figure out some of your <br>\nlogic in HOL.thy. Makarius showed me how to print explicit use of <br>\nTrueprop and prop, so with explicit types, explicit parentheses, <br>\nexplicit names, explicit Trueprop, and explicit prop, I might could <br>\neventually figure out the reasoning behind your defs in HOL.thy, like <br>\nfor these:</p>\n<p>LINE: 178 of src/HOL/HOL.thy<br>\ndefs<br>\n   True_def:     \"True      == ((%x::bool. x) = (%x. x))\"<br>\n   All_def:      \"All(P)    == (P = (%x. True))\"<br>\n   Ex_def:       \"Ex(P)     == !Q. (!x. P x --&gt; Q) --&gt; Q\"<br>\n   False_def:    \"False     == (!P. P)\"<br>\n   not_def:      \"~ P       == P--&gt;False\"<br>\n   and_def:      \"P &amp; Q     == !R. (P--&gt;Q--&gt;R) --&gt; R\"<br>\n   or_def:       \"P | Q     == !R. (P--&gt;R) --&gt; (Q--&gt;R) --&gt; R\"<br>\n   Ex1_def:      \"Ex1(P)    == ? x. P(x) &amp; (! y. P(y) --&gt; y=x)\"</p>\n<p>I'm thinking that parts of your \"Interactive Proof with Cambridge LCF\" <br>\nand your \"The Foundation of a Generic Theorem Prover\" will eventually <br>\nhelp me out, that you directly implement into HOL.thy some of the logic <br>\ndefinitions in your LCF book. It'll take time for me to find that out.</p>\n<p>But, with the right print info for definitions and axiomatizations, it <br>\nwould help me when I occasionally look at definitions such as the above.</p>\n<p>Thanks,<br>\nGB<br>\n<a href=\"/user_uploads/14278/PD1D590kZBFE7iTsNY8vGsp6/iS.thy\">iS.thy</a></p>",
        "id": 294219021,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896444
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI imagine that the following paper (Church, 1940) has all the information you need:</p>\n<p><a href=\"http://www.classes.cs.uchicago.edu/archive/2007/spring/32001-1/papers/church-1940.pdf\">http://www.classes.cs.uchicago.edu/archive/2007/spring/32001-1/papers/church-1940.pdf</a></p>\n<p>However, Isabelle's formalism includes a much richer variety of types, including type variables and type constructors. As I recall, essentially the same system of axioms is used in HOL.</p>\n<p>Larry Paulson</p>",
        "id": 294219025,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896450
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nLarry,</p>\n<p>Thanks for link to the document. I added Church's journal article to my <br>\nlibrary of HOL documents.</p>\n<p>I kind of figured out that in the definitions below, I should start <br>\ndoing some substitutions, like</p>\n<p>P &amp; Q == !R. ((P--&gt; Q--&gt;R) --&gt;  R)<br>\n       == (R = (%x.True)). ((P--&gt; Q--&gt;R) --&gt;  R)<br>\n       == (R = (%x.((%y::bool. y) = (%y. y))). ((P--&gt; Q--&gt;R) --&gt;  R)</p>\n<p>Using trial and error, I finally decided I don't know what the notation <br>\nmeans enough to continue to make substitutions.</p>\n<p>If I was formally enrolled in a course, I would go and impose myself on <br>\nmy professor, and take up his or her time. But I'm not, so it'll have to <br>\nbe delayed gratification.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294219140,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896498
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI honestly don't think doing such substitutions is of any benefit at all. See if you can make some sense of each definition individually.<br>\nLarry Paulson</p>",
        "id": 294219152,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896504
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/9/2012 2:35 PM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I honestly don't think doing such substitutions is of any benefit at all.<br>\nSee if you can make some sense of each definition individually.</p>\n</blockquote>\n<p>I can make sense of the logic with these equivalencies:</p>\n<p>(A --&gt; B --&gt; C) == ((A /\\ B) --&gt; C), and<br>\n     (A --&gt; B) == (~A \\/ B).</p>\n<p>So I reduce (!R. ((P --&gt; Q --&gt; R) --&gt; R)) down to</p>\n<p>!R. ((P /\\ Q) \\/ R)</p>\n<p>THE_SCRATCH_THIS_FUNCTION<br>\n(This is where my truth-table-indoctrinated mentality starts to cause me <br>\na lot of insecurity, because when R=F, P=T, and Q=T, the result is false).</p>\n<p>THE_ALMOST_DID_SAY_SOMETHING_DUMB_FUNCTION__MAYBE_STILL_AM<br>\n(I almost sent this email off based on the above sentence. A faulty bias <br>\nwas causing me to misinterpret my truth table, plus my final result <br>\ncolumn was under an \"/\\\" due to my writing.</p>\n<p>So when R=false, the reduction above functions like conjunction. This <br>\nbrings to my attention to the definition</p>\n<p>False == (!P. P).</p>\n<p>I've gone on too long here, but I've already written what's below, so I <br>\nleave it. For me, truth table logic vs. constructive and natural <br>\ndeduction logic causes me some confusion, on how to interpret a simple <br>\nstatement like \"!P. P\", or maybe, as I say below, it's because I'm not <br>\nused to quantifying over propositions, but only over elements of a set, <br>\nsuch as in \"!x P(x)\". I'll get straightened out with the right books.</p>\n<p>If you don't read what's below, it'll be no loss, but it represents <br>\ncertain aspects of life, as experienced by me.<br>\n)</p>\n<p>But, though I haven't went through my natural deduction textbook much, I <br>\nassume that it's saying \"for every R that is asserted to be true...\".</p>\n<p>If that's the case, then the engine is somehow implementing and_def as <br>\nconjunction, which, of course, I know to begin with.</p>\n<p>It could be that I've said something dumb, so I write it with a little <br>\ntyping,</p>\n<p>!R::('a =&gt; bool). ((P /\\ Q) \\/ (R::('a =&gt; bool))),</p>\n<p>to try and figure out if I have said something dumb. I know that R can <br>\nbe viewed as a proposition, but I'm not used to quantifying over <br>\npropositions; I'm used to quantifying over elements of a set, like</p>\n<p>!x P(x).</p>\n<p>I've gone on like this to demonstrate (even more) that I have some <br>\nweaknesses in logic. I assume that your B.S. in Math at CalTech (not to <br>\nmention your PhD) gave you a lot better education than my B.S. in Math <br>\nat Podunk University, but I also know from experience and observation <br>\nthat most undergrad and graduate degrees in math don't give people much <br>\nmore than a basic education in logic.</p>\n<p>Anyway, you're paying the price for giving people access to the details <br>\nof the engine, unlike Mizar.</p>\n<p>Can I work without understanding all the logic details? I suppose I have <br>\nto. But if I get access to information, many times I think I'm supposed <br>\nto understand it. Actually, I do need to set aside some of this <br>\nlow-level stuff. I'm progressing at a snail's pace.</p>\n<p>Thanks for your time,<br>\nGB</p>\n<p>&gt;<br>\n &gt;</p>\n<blockquote>\n<p>On 9 Jul 2012, at 20:28, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>I kind of figured out that in the definitions below, I should start <br>\ndoing some substitutions, like</p>\n<p>P&amp;  Q == !R. ((P--&gt;  Q--&gt;R) --&gt;   R)<br>\n      == (R = (%x.True)). ((P--&gt;  Q--&gt;R) --&gt;   R)<br>\n      == (R = (%x.((%y::bool. y) = (%y. y))). ((P--&gt;  Q--&gt;R) --&gt;   R)<br>\n</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>On 9 Jul 2012, at 20:28, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>I kind of figured out that in the definitions below, I should start doing some substitutions, like</p>\n<p>P&amp;  Q == !R. ((P--&gt;  Q--&gt;R) --&gt;   R)<br>\n      == (R = (%x.True)). ((P--&gt;  Q--&gt;R) --&gt;   R)<br>\n      == (R = (%x.((%y::bool. y) = (%y. y))). ((P--&gt;  Q--&gt;R) --&gt;   R)<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294219182,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896523
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 10.07.2012 02:42, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>On 7/9/2012 2:35 PM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I honestly don't think doing such substitutions is of any benefit at all.<br>\nSee if you can make some sense of each definition individually.</p>\n</blockquote>\n<p>I can make sense of the logic with these equivalencies:</p>\n<p>(A --&gt; B --&gt; C) == ((A /\\ B) --&gt; C), and<br>\n(A --&gt; B) == (~A \\/ B).</p>\n<p>So I reduce (!R. ((P --&gt; Q --&gt; R) --&gt; R)) down to</p>\n<p>!R. ((P /\\ Q) \\/ R)</p>\n</blockquote>\n<p>This would be \"!R. (~(P /\\ Q) \\/ R)\"</p>\n<blockquote>\n<p>So when R=false, the reduction above functions like conjunction. This<br>\nbrings to my attention to the definition</p>\n<p>False == (!P. P).</p>\n</blockquote>\n<p>\"!P. P\" just says \"all propositions hold\". As long as our logic is <br>\nconsistent, this is not going to be the case, so we choose this as our <br>\nvalue for False.</p>\n<p>-- Lars</p>",
        "id": 294219224,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896560
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nNo need even to do that. The reasoning is very simple. let P and Q be two given formulas, and suppose that you have !R. ((P --&gt; Q --&gt; R) --&gt; R). And suppose that you want to prove some formula, R say (just to keep things very simple). Then it is enough to prove P --&gt; Q --&gt; R. Which means, you may as well assume that P and Q are actually true while you are proving R. And that is what it means to know P&amp;Q.</p>\n<p>Disjunction can be defined similarly. If I'm not mistaken, this discovery is due to Frege.</p>\n<p>Larry Paulson</p>",
        "id": 294219236,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896572
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/10/2012 2:14 AM, Lars Noschinski wrote:</p>\n<blockquote>\n<blockquote>\n<p>So I reduce (!R. ((P --&gt; Q --&gt; R) --&gt; R)) down to</p>\n<p>!R. ((P /\\ Q) \\/ R)</p>\n</blockquote>\n<p>This would be \"!R. (~(P /\\ Q) \\/ R)\"</p>\n</blockquote>\n<p>I don't know. This is what I get:</p>\n<p>(P --&gt; Q --&gt; R) --&gt; R<br>\n   == ((P /\\ Q) --&gt; R) --&gt; R)<br>\n   == (~(P /\\ Q) \\/ R) --&gt; R)<br>\n   == ~(~(P /\\ Q) \\/ R) \\/ R<br>\n   == ((P /\\ Q) /\\ ~R) \\/ R<br>\n   == ((P /\\ Q) \\/ R) /\\ (~R \\/ R)<br>\n   == (P /\\ Q) \\/ R</p>\n<blockquote>\n<blockquote>\n<p>So when R=false, the reduction above functions like conjunction. This<br>\nbrings to my attention to the definition</p>\n<p>False == (!P. P).</p>\n</blockquote>\n<p>\"!P. P\" just says \"all propositions hold\". As long as our logic is<br>\nconsistent, this is not going to be the case, so we choose this as our<br>\nvalue for False.</p>\n</blockquote>\n<p>Okay, that's good to know. I'm still transitioning from truth tables, <br>\nwhere writing a formula doesn't assert anything, at least that's how <br>\nI've always viewed it for the connectives /\\, \\/, --&gt;, and ~.</p>\n<p>I did decide previously that I should interpret \"!P. P\" as asserting <br>\nthat P is always true, which helps me with it being the definition of <br>\nFalse, but it doesn't help me understand</p>\n<p>!R. ((P /\\ Q) \\/ R), or even<br>\n   !R. (~(P /\\ Q) \\/ R).</p>\n<p>The \"P\" and \"Q\" part of the \"conj\" (infixed as \"&amp;\", and \"/\\\") definition <br>\nmakes sense to me because when I use the function</p>\n<p>conj P Q,</p>\n<p>in my mind, I go through the truth table and make assignments to \"P\" and <br>\n\"Q\" and decide what result I should get based on how the function was <br>\nbeing used in a statement.</p>\n<p>With</p>\n<p>!R. ((P /\\ Q) \\/ R),</p>\n<p>I try to use the same trick and say, \"it's asserting that for every R, R <br>\nis always true\", but that doesn't work. If R is always true, then the <br>\nstatement is always true. But if it's always false, then the statement <br>\noperates as a conjunction.</p>\n<p>Well, okay, the above sentence shows I still have trouble interpreting <br>\nthings.</p>\n<p>What I know is that saying \"every proposition R is true\" is a false <br>\nstatement, so if that's what makes R always false in the statement \"((P <br>\n/\\ Q) \\/ R)\", then the statement as a whole works.</p>\n<p>Ah, maybe I have it. The statement \"!R. ((P /\\ Q) \\/ R)\" could be <br>\nasserting this:</p>\n<p>\"For every proposition R, (P /\\ Q) is true or R is true.\"</p>\n<p>A more friendlier statement would be this, using your statement above:</p>\n<p>\"Every proposition is true or (P /\\ Q) is true\".</p>\n<p>I guess that's it. Simple stuff, unless it's not.</p>\n<p>Thanks for the help.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294219413,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896646
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 11.07.2012 14:54, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>On 7/10/2012 2:14 AM, Lars Noschinski wrote:</p>\n<blockquote>\n<blockquote>\n<p>So I reduce (!R. ((P --&gt; Q --&gt; R) --&gt; R)) down to</p>\n<p>!R. ((P /\\ Q) \\/ R)</p>\n</blockquote>\n<p>This would be \"!R. (~(P /\\ Q) \\/ R)\"</p>\n</blockquote>\n<p>I don't know. This is what I get:</p>\n</blockquote>\n<p>Yes, sorry.</p>\n<blockquote>\n<p>Ah, maybe I have it. The statement \"!R. ((P /\\ Q) \\/ R)\" could be<br>\nasserting this:</p>\n<p>\"For every proposition R, (P /\\ Q) is true or R is true.\"</p>\n</blockquote>\n<p>Exactly.</p>\n<p>-- Lars</p>",
        "id": 294219425,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896652
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/10/2012 2:57 AM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>On 10 Jul 2012, at 01:42, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>So I reduce (!R. ((P --&gt;  Q --&gt;  R) --&gt;  R)) down to</p>\n<p>!R. ((P /\\ Q) \\/ R)</p>\n</blockquote>\n<p>No need even to do that. The reasoning is very simple. let P and Q<br>\nbe two given formulas, and suppose that you have !R. ((P --&gt;  Q --&gt; <br>\nR) --&gt;  R).<br>\nAnd suppose that you want to prove some formula, R say (just to keep <br>\nthings<br>\nvery simple). Then it is enough to prove P --&gt;  Q --&gt;  R. Which <br>\nmeans, you<br>\nmay as well assume that P and Q are actually true while you are <br>\nproving R.<br>\nAnd that is what it means to know P&amp;Q.</p>\n<p>Disjunction can be defined similarly. If I'm not mistaken, this discovery is due to Frege.</p>\n</blockquote>\n<p>I'll do the easy part and show HOL's definition of disjunction to <br>\ncomplete the discussion.</p>\n<p>P | Q  == !R.(P--&gt;R) --&gt; (Q--&gt;R) --&gt; R</p>\n<p>Larry, thanks for the explanation of the not-so-straightforward logic.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294219447,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896664
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 7/10/2012 2:31 AM, Ramana Kumar wrote:</p>\n<blockquote>\n<blockquote>\n<p>I can make sense of the logic with these equivalencies:</p>\n<p>(A --&gt; B --&gt; C) == ((A /\\ B) --&gt; C), and<br>\n  (A --&gt; B) == (~A \\/ B).</p>\n</blockquote>\n<p>Sure, but you should remember that from the perspective of defining the<br>\nconnectives, the definitions are primary and we would derive these<br>\nequivalences as consequences. So it would be good to get a little<br>\nintuitive appreciation for the definitions directly.</p>\n</blockquote>\n<p>I kind of understood that I'm getting circular, which is why I wasn't so <br>\nready to be satisfied with those kind of substitutions, but Larry told <br>\nme to forget about low-level substitutions, so that relieved me of a <br>\nfeeling of responsibility to not get circular.</p>\n<p>Larry's explanation was able to explain the logic and still only use \"--&gt;\".</p>\n<blockquote>\n<blockquote>\n<p>So I reduce (!R. ((P --&gt; Q --&gt; R) --&gt; R)) down to</p>\n<p>!R. ((P /\\ Q) \\/ R)</p>\n</blockquote>\n<p>Can you see why this is a good definition for 'and'?</p>\n</blockquote>\n<p>It's a good definition if you only have \"!\" and \"--&gt;\" at your disposal. <br>\nIt's doesn't sync up well with simplistic lessons in logic as given in <br>\n\"Discrete Mathematics\" by Rosen, or many other mathematical logic <br>\ntextbooks. But yea, it looks good.</p>\n<blockquote>\n<blockquote>\n<p>This is where my truth-table-indoctrinated mentality starts to cause<br>\nme a lot of insecurity, because when R=F, P=T, and Q=T, the result is<br>\nfalse).</p>\n</blockquote>\n<p>Surely when R is false but P and Q are true the result is true...?<br>\nTruth tables still work for propositional logic embedded in HOL.</p>\n</blockquote>\n<p>You're asking about what I said there? That was messed up. I left it in <br>\nto show how I was messed up, but it leaving it in and not working to <br>\nredo the email right was probably messed up too.</p>\n<p>The result with truth tables is the same, but there are subtle or <br>\nnot-so-subtle differences in the logic notation and the use of logic <br>\nformulas as specifically used in a proof assistant. Or maybe there's <br>\nnot. It could just be information overload that throws me off, which <br>\nresults in me not being able to process simple statements.</p>\n<blockquote>\n<blockquote>\n<p>...causes me some confusion, on how to interpret a simple<br>\nstatement like \"!P. P\", or maybe, as I say below, it's because I'm not<br>\nused to quantifying over propositions, but only over elements of a set,<br>\nsuch as in \"!x P(x)\". I'll get straightened out with the right books.</p>\n</blockquote>\n<p>Don't get confused by its being a capital letter. Look at the type. P is<br>\na plain old boolean proposition. It doesn't take any arguments. The<br>\ndefinition of false basically says both boolean values are true, that<br>\nis, there is an inconsistency.</p>\n</blockquote>\n<p>Sometimes a formula can be so simple that a newbie doesn't know how to <br>\nget information out of it. It helps for people to tell me exactly how to <br>\nphrase the meaning of a formula in informal English, until I get good at <br>\ncreating my own interpretive phrases.</p>\n<blockquote>\n<blockquote>\n<p>!R::('a =&gt; bool). ((P /\\ Q) \\/ (R::('a =&gt; bool))),<br>\n</p>\n</blockquote>\n<p>Surely that did not typecheck.</p>\n</blockquote>\n<p>Here are some pertinent lines from ~/HOL/HOL.thy:</p>\n<p>074: consts<br>\n082:   All::\"('a =&gt; bool) =&gt; bool\" (binder \"ALL \" 10)</p>\n<p>153: notation (HOL)<br>\n154:   All  (binder \"! \" 10)</p>\n<p>178: defs<br>\n180:   All_def:      \"All(P)    == (P = (%x. True))\"</p>\n<p>I put this in jEdit, and it shows R::bool:</p>\n<p>lemma \"!R. (P--&gt;Q--&gt;R) --&gt; R\"</p>\n<p>So, you're right, though I thought you had to be wrong, until the goal <br>\nfor the proof step told me you're right. This is where things like <br>\ndeclare[[show_types=true]] save us a bunch of time.</p>\n<p>It appeared to me, by line 82, that \"All\" takes a \"('a =&gt; bool)\" and <br>\nreturns a bool. It could be that \"All(P)\" is not the same thing as \"All P\".</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294219468,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896676
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nIf you resolve the binder syntax,</p>\n<p>!R. (P --&gt; Q --&gt; R) --&gt; R</p>\n<p>is the same as</p>\n<p>All (%R. (P --&gt; Q --&gt;R) --&gt; R)</p>\n<p>where the lambda abstraction has type bool =&gt; bool.</p>",
        "id": 294219479,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896683
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nLars, thanks for the tip. Knowing that has saved me some time, and will <br>\nsave me some time.</p>\n<p>Thanks again,<br>\nGB</p>",
        "id": 294219486,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896689
    }
]