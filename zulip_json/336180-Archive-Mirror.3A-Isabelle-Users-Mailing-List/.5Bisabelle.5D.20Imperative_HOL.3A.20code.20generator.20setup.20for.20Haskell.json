[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Imperative HOLers,</p>\n<p>maybe you could enlighten me on the following points:</p>\n<p>1) In Heap_Monad.thy there is a Haskell preamble including</p>\n<p>lengthArray :: STArray s a -&gt; ST s Integer;<br>\nlengthArray a = Control.Monad.liftM snd (Data.Array.ST.getBounds a);</p>\n<p>Shouldn't that be the above +1? I thought in Haskell the bounds state <br>\nthe lowest and highest <em>index</em> of an array. So an array created with <br>\nbound (0, k) should have length k+1. Maybe I'm wrong?</p>\n<p>2) How would we actually use an \"imperative\" function from inside some <br>\npure function? Can there be a mapping to runST for Haskell (I guess that <br>\nwould not be safe, since there's no rank-2 types in Isabelle/HOL)? Any <br>\nthoughts or further explanations?</p>\n<p>thanks in advance</p>\n<p>chris</p>",
        "id": 294316903,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925727
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Christian,</p>\n<p>With the current setup, you cannot. If you look at the code_printing declarations in <br>\nHeap_Monad, you will see that the heap type is mapped to ST RealWorld. That means that <br>\nheap values are meant to be used with stToIO rather than runST.</p>\n<p>However, one could think of a different serialisation for Haskell. I see three problems:</p>\n<ol>\n<li>\n<p>The type of runST requires that the ST parameter is polymorphic, but Heap in <br>\nImperative_HOL does not have such a type parameter. You could replace Heap.RealWorld in <br>\nthe Heap's serialisation with some literal type variable. To avoid clashes, this type <br>\nvariable must not be used by the code generator. For example, you could use some fancy <br>\nunicode characters that the code generator does not use. I have not tried this, but I <br>\nwould expect that the types of the generated functions are general enough to be passed to <br>\nrunST.</p>\n</li>\n<li>\n<p>execute takes an initial state, runST does not. Hence, you would have to implement some <br>\nglue code that converts the initial state accordingly. The easiest way is probably to <br>\ndefine a function runST as \"runST f = map_option fst (execute f s)\" and serialise that.</p>\n</li>\n<li>\n<p>References into the heap must not be passed between different invocations of runST. <br>\nAFAIK, reference types are tagged with the state type in Haskell. That is, if you <br>\nnevertheless serialise a function that returns a reference, Haskell's type system should <br>\nprevent you from applying runST to it. Hence, you can generate code that does not compile <br>\nafterwards. From the point of view on partial correctness, this is sound.</p>\n</li>\n</ol>\n<p>Best,<br>\nAndreas</p>",
        "id": 294316908,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925729
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<p>well, experimentally the second position of getBounds seems indeed to be<br>\nthe <em>length</em>, not the highest index.  You may want to make two, three<br>\nexamples to convince yourself.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/T0D_o6b9r1lcoDkSM9c8U-uz/signature.asc\">signature.asc</a></p>",
        "id": 294316932,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925737
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>2) How would we actually use an \"imperative\" function from inside some<br>\npure function? Can<br>\nthere be a mapping to runST for Haskell (I guess that would not be<br>\nsafe, since there's no<br>\nrank-2 types in Isabelle/HOL)? Any thoughts or further explanations?<br>\nWith the current setup, you cannot. If you look at the code_printing<br>\ndeclarations in Heap_Monad, you will see that the heap type is mapped to<br>\nST RealWorld. That means that heap values are meant to be used with<br>\nstToIO rather than runST.</p>\n</blockquote>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p>That is, if you nevertheless serialise a function that<br>\nreturns a reference, Haskell's type system should prevent you from<br>\napplying runST to it. Hence, you can generate code that does not compile<br>\nafterwards. From the point of view on partial correctness, this is sound.</p>\n</blockquote>\n<p>Initially I have been so optimistic to follow that »let Haskell moan if<br>\nit is not linear« approach, but there have been technical problems which<br>\ncould not been solved within the existing infrastructure.  The details I<br>\ndo not remember, but maybe the hg history knows more.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/m3vCXzuMkOagQVWpy7ngxvM_/signature.asc\">signature.asc</a></p>",
        "id": 294316949,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925744
    }
]