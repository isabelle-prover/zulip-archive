[
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHi Alfio,</p>\n<p>I'm still not sure why you insist on the length of the computation<br>\nsequence. Do you want to reason about the _runtime complexity_ of your<br>\nalgorithm? Then you need to model \"time\" explicitly, and you need<br>\nsemantics handling time.</p>\n<p>If you just want to have induction which follows the rewrite steps of<br>\nyour function, then use the induction rule by the fun-package.</p>\n<p>with this you can even show equality with Q:</p>\n<p>lemma \"tail_multn m n a = r = Q(m,n,a,r)\"<br>\n  by (induction m n a rule: tail_multn.induct) auto</p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294656543,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168260
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nHi Johannes,</p>\n<p>If you just want to have induction which follows the rewrite steps of</p>",
        "id": 294656635,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168291
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Users,</p>\n<p>Whenever I want to (manually) prove that an invariant of a tail recursive<br>\nfunction is true,<br>\nI perform induction on  the length of computation sequences. For instance,<br>\nconsider the following<br>\nexample:</p>\n<p>fun tail_multn::\"nat =&gt; nat =&gt; nat =&gt; nat\" where<br>\n  \"tail_multn 0 n a = a\" |<br>\n  \"tail_multn (Suc m) n a = tail_multn m n (a+n)\"</p>\n<p>Thus, a state s_ k (0&lt;=k&lt;=n) for a computation of this function is a triple<br>\ns_k=(m_k,n_k,a_k) in nat x nat x nat.<br>\nNow, using induction on k, I can prove that</p>\n<p>P(k)=def all m,n,a:nat. tail_multn m n a = m_k*n_k+ a_k</p>\n<p>The only way I was able to encode this proof in Isabelle was using<br>\ncomputation induction,<br>\nafter reading carefully the presentation of this material in \"Programming<br>\nand Proving\".</p>\n<p>So, my proof in Isabelle is given by:</p>\n<p>lemma \"tail_inv\": \"tail_multn x y a = x*y +a\"<br>\n  apply (induction x y a  rule: tail_multn.induct)<br>\n  apply (simp_all)<br>\ndone</p>\n<p>Two questions:</p>\n<p>1) Is this a correct way to encode a proof of an invariant of a tail<br>\nrecursive function?<br>\n2) Is there a more elegant way to approach this problem?</p>\n<p>Best!</p>",
        "id": 294657342,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168597
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHi Alfio,</p>\n<p>To answer your two questions:</p>\n<blockquote>\n<p>1) Is this a correct way to encode a proof of an invariant of a tail<br>\nrecursive function?</p>\n</blockquote>\n<p>Yes, to use the induction-scheme by the function method is the usual way<br>\nin Isabelle/HOL. of course, the induction-scheme is independent of the<br>\nfunction itself: you can use other induction-schemes (like nat_induct),<br>\nand you can also use the induction scheme tail_multn.induct to prove<br>\ntheorems no involving tail_multn.</p>\n<blockquote>\n<p>2) Is there a more elegant way to approach this problem?</p>\n</blockquote>\n<p>I find it quite elegant. Do you have anything more elegant in mind?<br>\nObviously, if you have more specific theorems to prove you might use a<br>\ndifferent approach.</p>\n<p>Btw, sometimes when defining tail-recursive functions the<br>\nfunction-package is not enough and you might want to use<br>\npartial_function.</p>\n<p>Greetings,</p>\n<ul>\n<li>Johannes</li>\n</ul>\n<p>Am Freitag, den 09.10.2015, 14:46 -0300 schrieb Alfio Martini:</p>\n<blockquote>\n<p>Dear Users,</p>\n<p>Whenever I want to (manually) prove that an invariant of a tail recursive<br>\nfunction is true,<br>\nI perform induction on  the length of computation sequences. For instance,<br>\nconsider the following<br>\nexample:</p>\n<p>fun tail_multn::\"nat =&gt; nat =&gt; nat =&gt; nat\" where<br>\n  \"tail_multn 0 n a = a\" |<br>\n  \"tail_multn (Suc m) n a = tail_multn m n (a+n)\"</p>\n<p>Thus, a state s_ k (0&lt;=k&lt;=n) for a computation of this function is a triple<br>\ns_k=(m_k,n_k,a_k) in nat x nat x nat.<br>\nNow, using induction on k, I can prove that</p>\n<p>P(k)=def all m,n,a:nat. tail_multn m n a = m_k*n_k+ a_k</p>\n<p>The only way I was able to encode this proof in Isabelle was using<br>\ncomputation induction,<br>\nafter reading carefully the presentation of this material in \"Programming<br>\nand Proving\".</p>\n<p>So, my proof in Isabelle is given by:</p>\n<p>lemma \"tail_inv\": \"tail_multn x y a = x*y +a\"<br>\n  apply (induction x y a  rule: tail_multn.induct)<br>\n  apply (simp_all)<br>\ndone</p>\n<p>Two questions:</p>\n<p>1) Is this a correct way to encode a proof of an invariant of a tail<br>\nrecursive function?<br>\n2) Is there a more elegant way to approach this problem?</p>\n<p>Best!<br>\n</p>\n</blockquote>",
        "id": 294657413,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168628
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nHi Johannes,</p>\n<p>Thank you for your feedback.</p>\n<p>I wanted actually to perform induction on the length  of computation<br>\nsequences of the tail recursive<br>\nfunction, so I chose to use the rule f.induct. But I was not really sure if<br>\nusing that that rule I<br>\nwas really doing this kind of induction. So I decided to make an explicit<br>\ndefinition of<br>\nthe tail function as an inductive set of quadruples. This time I was more<br>\nconvinced that I was<br>\nperforming induction on the the length of the computation sequences. But<br>\nmaybe this<br>\nwas the ugly way. I am not sure.</p>\n<p>I will be glad to receive more comments about this. This is the alternative<br>\ncode, defining<br>\nthe multiplication as an inductive predicate.</p>\n<p>inductive<br>\n  imultn :: \"nat x nat x nat x nat  =&gt; bool\"<br>\nwhere<br>\nbase : \"imultn(0,n,a,a)\" |<br>\nind : \"imultn(m, n, a+n, value) ==&gt; imultn(Suc m,n,a,value)\"</p>\n<p>fun Q::\"nat x nat x nat x nat =&gt;bool\" where<br>\n  \"Q(x,y,z,w) = (x*y+z = w)\"</p>\n<p>lemma \"imultn(m,n,a,r) ==&gt;Q(m,n,a,r)\" (* consistency *)<br>\n    proof (induct rule:imultn.induct)<br>\n    fix n a<br>\n       show \"Q(0,n,a,a)\" by simp<br>\n    next<br>\n      fix m n a v<br>\n      assume h1: \"imultn(m,n,a+n,v)\"<br>\n      assume h2: \"Q(m,n,a+n,v)\"<br>\n      show \"Q(Suc m, n,a,v)\"<br>\n        proof -<br>\n          from h2 have \"m*n+(a+n)=v\" by simp<br>\n          then have \"m*n+n +a=v\" by simp<br>\n          then have \"(m+1)*n+a=v\" by simp<br>\n          then show ?thesis by simp<br>\n        qed<br>\n    qed</p>\n<p>lemma \"Q(m,n,a,r) ==&gt; imultn(m,n,a,r)\" (* completeness *)<br>\n   proof (induction m arbitrary:n a r)<br>\n     fix n a r<br>\n     assume h:\"Q(0,n,a,r)\"<br>\n     show \"imultn(0,n,a,r)\"<br>\n       proof -<br>\n         from h have \"a=r\" by simp<br>\n         have \"imultn(0,n,a,a)\" by (rule base)<br>\n         then show ?thesis using h by simp<br>\n       qed<br>\n     next<br>\n      fix m n a r<br>\n      assume IH:\" /\\ i n a r. Q (m, n, a, r) ==&gt;imultn (m, n, a, r)\"<br>\n      assume h2: \"Q (Suc m, n, a, r)\"<br>\n      show \"imultn (Suc m, n, a, r)\"<br>\n         proof (rule ind)<br>\n          from h2 have \"m*n + (n+a) = r\" by simp<br>\n          then have \"Q(m,n,a+n,r)\" by simp<br>\n          then show \"imultn(m,n,a+n,r)\" using IH by simp<br>\n         qed<br>\n   qed</p>\n<p>fun tail_multn::\"nat =&gt; nat =&gt; nat =&gt; nat\" where<br>\n  \"tail_multn 0 n a = a\" |<br>\n  \"tail_multn (Suc m) n a = tail_multn m n (a+n)\"</p>\n<p>lemma \"tail_multn m n a = r ==&gt; Q(m,n,a,r)\"<br>\n   apply(induction m n a rule:tail_multn.induct)<br>\n   apply (simp)<br>\n   apply(simp)<br>\ndone</p>",
        "id": 294657487,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168646
    }
]