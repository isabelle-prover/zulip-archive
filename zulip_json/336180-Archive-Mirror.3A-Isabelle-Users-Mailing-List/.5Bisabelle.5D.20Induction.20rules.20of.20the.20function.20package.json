[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@ipd.info.uni-karlsruhe.de\">lochbihl@ipd.info.uni-karlsruhe.de</a>&gt;<br>\nHi all,</p>\n<p>the induction rules that the function package generates for a function <br>\ndefinitions are usually great. However, is always quantifies over all <br>\nparameters of the function, even if they are just passed through all <br>\nrecursive calls. For some proofs, I would like not to have them <br>\nquantified. Is there an option to the function package to declare such <br>\nparameters to treat differently (like the for clause for inductive)?</p>\n<p>A concrete example:</p>\n<p>fun map where<br>\n   \"map f [] = []\"<br>\n| \"map f (x # xs) = f x # map f xs\"</p>\n<p>produces the induction rule map.induct:<br>\n[| !!f. P f []; !!f x xs. P f xs ==&gt; P f (x # xs) |] ==&gt; P a0 a1</p>\n<p>but I would much more like the following rule (which I currently derive <br>\nby hand from the generated one):<br>\n[| P []; !!x xs. P xs ==&gt; P (x # xs) |] ==&gt; P a</p>\n<p>Thanks,<br>\nAndreas</p>",
        "id": 294083559,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831449
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<p>Currently, there is no such option. In fact, a for-clause would not  <br>\nsolve the problem completely, since even if an argument arguments does  <br>\nchange in recursive calls, one would sometime like to see it  <br>\neliminated from the induction rule.</p>\n<p>In suce a case, I usually project away the extra arguments manually  <br>\n(using something like [where P=\"%x y. Q y\", standard]), which is not  <br>\nnice but works.</p>\n<p>Cheers,<br>\nAlex</p>",
        "id": 294083755,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831493
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@ipd.info.uni-karlsruhe.de\">lochbihl@ipd.info.uni-karlsruhe.de</a>&gt;<br>\nHi Alex,</p>\n<blockquote>\n<blockquote>\n<p>the induction rules that the function package generates for a function<br>\ndefinitions are usually great. However, is always quantifies over all<br>\nparameters of the function, even if they are just passed through all<br>\nrecursive calls. For some proofs, I would like not to have them<br>\nquantified. Is there an option to the function package to declare such<br>\nparameters to treat differently (like the for clause for inductive)?</p>\n</blockquote>\n<p>Currently, there is no such option. In fact, a for-clause would not <br>\nsolve the problem completely, since even if an argument arguments does <br>\nchange in recursive calls, one would sometime like to see it eliminated <br>\nfrom the induction rule.<br>\nThat is right, but a for clause would also help in proving compatibility <br>\nfor overlapping patterns, because already the function graph definition <br>\ncould use the for clause. Then, reasoning on the graph becomes easier <br>\nand the termination proof as well, because one would not need to code <br>\nthe functional dependency on the fixed parameters into the relation.</p>\n</blockquote>\n<blockquote>\n<p>In suce a case, I usually project away the extra arguments manually <br>\n(using something like [where P=\"%x y. Q y\", standard]), which is not <br>\nnice but works.<br>\nI also use that trick to derive my own induction rules. However, this <br>\ndoes not work, if one of the fixed parameters is used in some guard to <br>\nthe recursive call. Here is a concrete example:</p>\n</blockquote>\n<p>datatype 'a array = Array \"'a list\"<br>\nprimrec array_length :: \"'a array =&gt; nat\"<br>\nwhere \"array_length (Array a) = length a\"</p>\n<p>function assoc_list_of_array_code :: \"'a array =&gt; nat =&gt; (nat * 'a) list\"<br>\nwhere<br>\n   \"assoc_list_of_array_code a n =<br>\n   (if array_length a &lt; n then []<br>\n    else ... # assoc_list_of_array_code a (n + 1))\"<br>\nby pat_completeness auto<br>\ntermination assoc_list_of_array_code<br>\nby(relation \"measure (%p. array_length (fst p) - snd p)\") auto</p>\n<p>My desired induction rule is:</p>\n<p>(!!n. (n &lt; array_length a ==&gt; P (n + 1)) ==&gt; P n) ==&gt; P n</p>\n<p>I obtain it by instantiating P in assoc_list_of_array_code.induct to <br>\n\"%a' n. a = a' --&gt; P n\" and doing some more manipulations.</p>\n<p>If you have some time somewhen you might consider such a for clause as a <br>\nfeature request. Here is what I think would be a nice definition:</p>\n<p>function assoc_list_of_array_code :: \"'a array =&gt; nat =&gt; (nat * 'a) list\"<br>\nfor a :: \"'a array<br>\nwhere<br>\n   \"assoc_list_of_array_code a n =<br>\n   (if array_length a &lt; n then []<br>\n    else ... # assoc_list_of_array_code a (n + 1))\"<br>\nby pat_completeness auto<br>\ntermination assoc_list_of_array_code<br>\nby(relation \"%a. measure (%n. array_length a - n)\") auto</p>\n<p>Anyway, I will have a look at your induct_scheme method.</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294083821,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831510
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nAndreas Lochbihler wrote:<br>\nLooks reasonable. I'll think about it.</p>\n<p>Cheers,<br>\nAlex</p>",
        "id": 294083906,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831547
    }
]