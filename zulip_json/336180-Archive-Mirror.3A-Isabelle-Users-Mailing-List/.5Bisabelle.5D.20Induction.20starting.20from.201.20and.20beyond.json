[
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;<br>\nI sent this once before and the first line didn't come through, so it <br>\ngot bounced. I'm sending it again now, as follows. -WDMaurer</p>\n<p>I have to teach a unit on mathematical induction to students in my <br>\nhigh-level algorithms class. Many of them were undergraduate <br>\nmechanical engineering or electrical engineering majors who switched <br>\nin graduate school to being computer science majors, so their <br>\nexposure to mathematical induction, during their undergraduate years, <br>\nwas sketchy at best. One of the books we use presents the basic <br>\nprinciple of mathematical induction to be induction starting from 1 <br>\ninstead of from zero. The first example in that book is <br>\nfactorial(n) &gt;= 2^(n-1), which, if I try to do it on type nat, makes <br>\nno sense for n = 0. All of the examples I have been able to find in <br>\nIsar manuals and tutorials are for induction starting from 0. How do <br>\nI do induction starting from 1 in Isar?<br>\nP. S. While I was still in graduate school I co-wrote a paper <br>\ncontaining an inductive proof in which the inductive step, P(k-1) <br>\nimplies P(k), depended on the fact that k &gt;= 3. Therefore I needed <br>\ntwo basis steps, one for k = 1, which was trivial, and one for k = 2, <br>\nwhich my co-author supplied. How would you do something like that in <br>\nIsar?</p>",
        "id": 294330799,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930180
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHello,</p>\n<p>On Tuesday 24 March 2015 15:37:40 W. Douglas Maurer wrote:</p>\n<blockquote>\n<p>I sent this once before and the first line didn't come through, so it<br>\ngot bounced. I'm sending it again now, as follows. -WDMaurer</p>\n<p>I have to teach a unit on mathematical induction to students in my<br>\nhigh-level algorithms class. Many of them were undergraduate<br>\nmechanical engineering or electrical engineering majors who switched<br>\nin graduate school to being computer science majors, so their<br>\nexposure to mathematical induction, during their undergraduate years,<br>\nwas sketchy at best. One of the books we use presents the basic<br>\nprinciple of mathematical induction to be induction starting from 1<br>\ninstead of from zero. The first example in that book is<br>\nfactorial(n) &gt;= 2^(n-1), which, if I try to do it on type nat, makes<br>\nno sense for n = 0. </p>\n</blockquote>\n<p>Actually it makes sense for n = 0, since 0 - 1 = 0 (over natural numbers, <br>\nnot integers).</p>\n<blockquote>\n<p>All of the examples I have been able to find in<br>\nIsar manuals and tutorials are for induction starting from 0. How do<br>\nI do induction starting from 1 in Isar?</p>\n</blockquote>\n<p>The easiest way is probably to use a case distinction :</p>\n<p>lemma \"(fact n :: nat) ≥ 2^(n-1)\"<br>\nproof (induct n)<br>\n  case 0<br>\n  thus ?case by auto<br>\nnext<br>\n  case (Suc n) note IH = this<br>\n  { assume \"Suc n = 1\"<br>\n     hence ?case by auto    <br>\n  }<br>\n  also {<br>\n    assume \"Suc n &gt; 1\"<br>\n    have ?case sorry<br>\n  }<br>\n  ultimately show ?case by arith<br>\nqed</p>\n<p>If you prefer, the 0 case can be the result of the assumption \"n &gt; 0\". </p>\n<blockquote>\n<p>P. S. While I was still in graduate school I co-wrote a paper<br>\ncontaining an inductive proof in which the inductive step, P(k-1)<br>\nimplies P(k), depended on the fact that k &gt;= 3. Therefore I needed<br>\ntwo basis steps, one for k = 1, which was trivial, and one for k = 2,<br>\nwhich my co-author supplied. How would you do something like that in<br>\nIsar?<br>\nThere might be a better solution, but using nat_less_induction rule <br>\n(instead of the default nat_induct) associated with case distinctions (k=0, <br>\nk=1, k=2, k&gt;=3) like the above should work. If you need often such kind of <br>\ninduction, proving another induction principle that does the case <br>\ndistinction might be useful.</p>\n</blockquote>\n<p>Regards,</p>\n<p>Mathias Fleury</p>",
        "id": 294330812,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930183
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear Douglas,</p>\n<p>remember that inductions schemes are just regular lemmas, so you can<br>\nalways define precisely the induction rule that you need, and use that:</p>\n<p>lemma ind_from_2[case_names 0 1 2 many]:<br>\n  assumes \"P 0\"<br>\n  assumes \"P 1\"<br>\n  assumes \"P 2\"<br>\n  assumes \"⋀ k. k ≥ 2 ⟹ P k ⟹ P (Suc k)\"<br>\n  shows \"P n\"<br>\nproof(induction n)<br>\n  case 0 thus ?case by fact<br>\nnext<br>\n  case (Suc k)<br>\n  have \"k = 0 ∨ k = 1 ∨ k ≥ 2\" by auto<br>\n  with Suc.IH assms<br>\n  show ?case by (auto simp add: numeral_eq_Suc)<br>\nqed  </p>\n<p>And later</p>\n<p>lemma \"foo n\"<br>\nproof(induction n rule: ind_from_2)<br>\ncase 0 show ?case...<br>\nnext<br>\ncase 1 show ?case...<br>\nnext<br>\ncase 2 show ?case...<br>\nnext<br>\ncase many show ?case... <br>\nqed</p>\n<p>I find this separation of concerns makes your proofs much easier to read<br>\nand understand.</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/xqmqcd9eCkYp9m-oiAqq7RrF/signature.asc\">signature.asc</a></p>",
        "id": 294330833,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930195
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:michael.norrish@nicta.com.au\">michael.norrish@nicta.com.au</a>&gt;<br>\nSimilarly, you might prove induction lemmas like</p>\n<p>⊢ P 2 ∧ (∀n. 2 ≤ n ∧ P n ⇒ P (Suc n)) ⇒ (∀n. 2 ≤ n ⇒ P n)</p>\n<p>where the 2 ≤ n part has been factored out of the P.  I don’t know how to best<br>\napply this theorem in Isabelle; perhaps it would not be as easy as a regular<br>\ninduction because of the more complicated pattern under the ∀ in the conclusion.<br>\n (Clearly it could be cast as an introduction rule.)</p>\n<p>Michael<br>\n<a href=\"/user_uploads/14278/Ep7RaQ8iXJwf3DjaFZNopP6P/signature.asc\">signature.asc</a></p>",
        "id": 294330853,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930202
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nIn Isabelle one would write:</p>\n<p>lemma nat_induct2[consumes 1]:<br>\n  \"2 &lt;= n ==&gt; P 2 ==&gt; (!!n. 2 &lt;= n ==&gt; P n ==&gt; P (Suc n)) ==&gt; P n\"</p>\n<p>with the consumes attribute it's stated that 2 &lt;= n is not a induction<br>\nstep but an assumption for the induction itself.</p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294330906,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930207
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nMaybe this is a good point to remind us all of the very nice <br>\n\"induction_schema\" method that comes with the function package by Alex <br>\nKrauss (and the automatic \"termination\" methods that also come with it, <br>\nlike \"lexicographic_order\").</p>\n<p>lemma ind_from_2 [case_names 0 1 2 many]:<br>\n   fixes P :: \"nat ⇒ bool\"<br>\n   assumes \"P 0\"<br>\n     and \"P 1\"<br>\n     and \"P 2\"<br>\n     and \"⋀k. k ≥ 2 ⟹ P k ⟹ P (Suc k)\"<br>\n   shows \"P n\"<br>\n   using assms<br>\n   apply (induction_schema)<br>\n   apply (case_tac n, force, force)<br>\n   apply (lexicographic_order)<br>\ndone</p>\n<p>the 2nd line of the proof script is a bit awkward in this case, but can <br>\noften be replaced by \"apply (pat_completeness)\" (which raises an <br>\nexception on this specific example).</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294330965,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930225
    }
]