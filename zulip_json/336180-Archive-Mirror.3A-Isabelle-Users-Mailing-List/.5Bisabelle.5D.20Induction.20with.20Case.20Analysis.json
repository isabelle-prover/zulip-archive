[
    {
        "content": "<p>From: Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt;<br>\nDear all,</p>\n<p>Is there a good way to induct and case-analyze (like the cases method)<br>\nsimultaneously?  Here's a stripped down example using a fragment of<br>\npropositional logic:</p>\n<p>{* begin example *}<br>\ntheory PropLogic<br>\nimports Main<br>\nbegin</p>\n<p>datatype formula =<br>\n  Atomic string (\"^_\" [150])<br>\n| Not formula<br>\n| And formula formula (infix \"&amp;&amp;\" 80)<br>\n| Or formula formula (infix \"||\" 70)</p>\n<p>abbreviation flip_insert (infixl \".\" 60) where<br>\n  \"Γ . A ≡ insert A Γ\"</p>\n<p>(* ⊢ Γ means at least one formula in Γ is true *)<br>\ninductive derivation :: \"formula set ⇒ bool\" (\"⊢ _\" [30] 30) where<br>\n  Assm: \"⊢ Γ . Not A . A\"<br>\n| AndI: \"⟦ ⊢ Γ . A; ⊢ Γ . B ⟧ ⟹ ⊢ Γ . A &amp;&amp; B\"<br>\n| OrI: \"⟦ ⊢ Γ . A . B ⟧ ⟹ ⊢ Γ . A || B\"</p>\n<p>lemma strong_inversion_And:<br>\n  assumes \"⊢ Γ . A &amp;&amp; B\"<br>\n    shows \"⊢ Γ . A\"<br>\nusing assms<br>\napply (induct rule: derivation.induct)<br>\n{* end example *}</p>\n<p>Here, my goal is to prove something like inversion for conjunction,<br>\nbut the A &amp;&amp; B may not have been introduced by the last rule used in<br>\nthe derivation, so it requires induction.</p>\n<p>Unfortunately, because the premise I'm inducting on (⊢ Γ . A &amp;&amp; B) has<br>\na parameter of a very specific shape, the higher-order unifier can't<br>\ninfer an appropriate instantiation of the derivation.induct, giving a<br>\nuseless goal state:</p>\n<ol>\n<li>⋀Γ' Aa. ⊢ Γ . A</li>\n<li>⋀Γ' Aa B. ⊢ Γ' . Aa ⟹ ⊢ Γ . A ⟹ ⊢ Γ' . B ⟹ ⊢ Γ . A ⟹ ⊢ Γ . A</li>\n<li>⋀Γ' Aa B. ⊢ Γ' . Aa . B ⟹ ⊢ Γ . A ⟹ ⊢ Γ . A</li>\n</ol>\n<p>The first subgoal is the very lemma I'm trying to prove.  I rather<br>\nneed something like</p>\n<p>⋀Γ' Aa. ⟦ Γ . A = Γ' . Not Aa . Aa⟧ ⟹ ⊢ Γ . A</p>\n<p>Using apply(induct rule: derivation.cases) instead of induct does give<br>\nsomething like this, but then in the other subgoals I won't have an<br>\ninductive hypothesis.</p>\n<p>How can I get around this problem?  Is there a method or attribute<br>\nthat can combine cases and induct?</p>",
        "id": 294730917,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188008
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHello Jun,</p>\n<p>you can specify the instantiation to perform to the induction method, for example:</p>\n<p>apply (induction \"Γ . A &amp;&amp; B\" rule: derivation.induct)</p>\n<p>However, I am not sure whether this helps you to perform the proof, since it gives you another non-trivial goal:</p>\n<p>⋀Γ' Aa. Γ' . formula.Not Aa . Aa = Γ . A &amp;&amp; B ⟹ ⊢ Γ . A</p>\n<blockquote>\n<p>Using apply(induct rule: derivation.cases) instead of induct does give<br>\nsomething like this, but then in the other subgoals I won't have an<br>\ninductive hypothesis.</p>\n<p>How can I get around this problem?  Is there a method or attribute<br>\nthat can combine cases and induct?</p>\n</blockquote>\n<p>You can also write your own induction rule.</p>\n<p>Unless there are more rules that you have not shown, I am not sure that your theorem holds, because you have no semantic of Not in your predicate derivation: I expect ‹⊢ {} . formula.Not (A || B) . A› to be true in propositional logic, but you can't derive this from your predicate \"derivation\".</p>\n<p>Best,<br>\nMathias</p>\n<blockquote>\n<p>On 21. Apr 2018, at 19:54, Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt; wrote:</p>\n<p>Dear all,</p>\n<p>Is there a good way to induct and case-analyze (like the cases method)<br>\nsimultaneously?  Here's a stripped down example using a fragment of<br>\npropositional logic:</p>\n<p>{* begin example *}<br>\ntheory PropLogic<br>\nimports Main<br>\nbegin</p>\n<p>datatype formula =<br>\n Atomic string (\"^_\" [150])<br>\n| Not formula<br>\n| And formula formula (infix \"&amp;&amp;\" 80)<br>\n| Or formula formula (infix \"||\" 70)</p>\n<p>abbreviation flip_insert (infixl \".\" 60) where<br>\n \"Γ . A ≡ insert A Γ\"</p>\n<p>(* ⊢ Γ means at least one formula in Γ is true *)<br>\ninductive derivation :: \"formula set ⇒ bool\" (\"⊢ _\" [30] 30) where<br>\n Assm: \"⊢ Γ . Not A . A\"<br>\n| AndI: \"⟦ ⊢ Γ . A; ⊢ Γ . B ⟧ ⟹ ⊢ Γ . A &amp;&amp; B\"<br>\n| OrI: \"⟦ ⊢ Γ . A . B ⟧ ⟹ ⊢ Γ . A || B\"</p>\n<p>lemma strong_inversion_And:<br>\n assumes \"⊢ Γ . A &amp;&amp; B\"<br>\n   shows \"⊢ Γ . A\"<br>\nusing assms<br>\napply (induct rule: derivation.induct)<br>\n{* end example *}</p>\n<p>Here, my goal is to prove something like inversion for conjunction,<br>\nbut the A &amp;&amp; B may not have been introduced by the last rule used in<br>\nthe derivation, so it requires induction.</p>\n<p>Unfortunately, because the premise I'm inducting on (⊢ Γ . A &amp;&amp; B) has<br>\na parameter of a very specific shape, the higher-order unifier can't<br>\ninfer an appropriate instantiation of the derivation.induct, giving a<br>\nuseless goal state:</p>\n<ol>\n<li>⋀Γ' Aa. ⊢ Γ . A</li>\n<li>⋀Γ' Aa B. ⊢ Γ' . Aa ⟹ ⊢ Γ . A ⟹ ⊢ Γ' . B ⟹ ⊢ Γ . A ⟹ ⊢ Γ . A</li>\n<li>⋀Γ' Aa B. ⊢ Γ' . Aa . B ⟹ ⊢ Γ . A ⟹ ⊢ Γ . A</li>\n</ol>\n<p>The first subgoal is the very lemma I'm trying to prove.  I rather<br>\nneed something like</p>\n<p>⋀Γ' Aa. ⟦ Γ . A = Γ' . Not Aa . Aa⟧ ⟹ ⊢ Γ . A</p>\n<p>Using apply(induct rule: derivation.cases) instead of induct does give<br>\nsomething like this, but then in the other subgoals I won't have an<br>\ninductive hypothesis.</p>\n<p>How can I get around this problem?  Is there a method or attribute<br>\nthat can combine cases and induct?</p>\n<p>-- <br>\nJun Inoue<br>\n</p>\n</blockquote>",
        "id": 294730932,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188014
    },
    {
        "content": "<p>From: Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt;<br>\nHello Mathias,</p>\n<p>Yes, that's exactly what I was looking for!  Thank you!</p>\n<p>On Sun, Apr 22, 2018 at 5:50 PM, Mathias Fleury<br>\n&lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello Jun,</p>\n<p>you can specify the instantiation to perform to the induction method, for<br>\nexample:</p>\n<p>apply (induction \"Γ . A &amp;&amp; B\" rule: derivation.induct)</p>\n<p>However, I am not sure whether this helps you to perform the proof, since it<br>\ngives you another non-trivial goal:</p>\n<p>⋀Γ' Aa. Γ' . formula.Not Aa . Aa = Γ . A &amp;&amp; B ⟹ ⊢ Γ . A</p>\n<p>Using apply(induct rule: derivation.cases) instead of induct does give<br>\nsomething like this, but then in the other subgoals I won't have an<br>\ninductive hypothesis.</p>\n<p>How can I get around this problem?  Is there a method or attribute<br>\nthat can combine cases and induct?</p>\n<p>You can also write your own induction rule.</p>\n<p>Unless there are more rules that you have not shown, I am not sure that your<br>\ntheorem holds, because you have no semantic of Not in your predicate<br>\nderivation: I expect ‹⊢ {} . formula.Not (A || B) . A› to be true in<br>\npropositional logic, but you can't derive this from your predicate<br>\n\"derivation\".</p>\n</blockquote>\n<p>That's right, what I showed was meant as a stripped down, (nearly)<br>\nminimal example, including just enough rules to make it desirable to<br>\ncombine case analysis and induction.  The actual development I'm<br>\nworking on has lots more stuff that I didn't want to force people to<br>\nwade through.  My apologies for the awkwardness.</p>\n<blockquote>\n<p>Best,<br>\nMathias</p>\n<p>On 21. Apr 2018, at 19:54, Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt; wrote:</p>\n<p>Dear all,</p>\n<p>Is there a good way to induct and case-analyze (like the cases method)<br>\nsimultaneously?  Here's a stripped down example using a fragment of<br>\npropositional logic:</p>\n<p>{* begin example *}<br>\ntheory PropLogic<br>\nimports Main<br>\nbegin</p>\n<p>datatype formula =<br>\n Atomic string (\"^_\" [150])<br>\n| Not formula<br>\n| And formula formula (infix \"&amp;&amp;\" 80)<br>\n| Or formula formula (infix \"||\" 70)</p>\n<p>abbreviation flip_insert (infixl \".\" 60) where<br>\n \"Γ . A ≡ insert A Γ\"</p>\n<p>(* ⊢ Γ means at least one formula in Γ is true *)<br>\ninductive derivation :: \"formula set ⇒ bool\" (\"⊢ _\" [30] 30) where<br>\n Assm: \"⊢ Γ . Not A . A\"<br>\n| AndI: \"⟦ ⊢ Γ . A; ⊢ Γ . B ⟧ ⟹ ⊢ Γ . A &amp;&amp; B\"<br>\n| OrI: \"⟦ ⊢ Γ . A . B ⟧ ⟹ ⊢ Γ . A || B\"</p>\n<p>lemma strong_inversion_And:<br>\n assumes \"⊢ Γ . A &amp;&amp; B\"<br>\n   shows \"⊢ Γ . A\"<br>\nusing assms<br>\napply (induct rule: derivation.induct)<br>\n{* end example *}</p>\n<p>Here, my goal is to prove something like inversion for conjunction,<br>\nbut the A &amp;&amp; B may not have been introduced by the last rule used in<br>\nthe derivation, so it requires induction.</p>\n<p>Unfortunately, because the premise I'm inducting on (⊢ Γ . A &amp;&amp; B) has<br>\na parameter of a very specific shape, the higher-order unifier can't<br>\ninfer an appropriate instantiation of the derivation.induct, giving a<br>\nuseless goal state:</p>\n<ol>\n<li>⋀Γ' Aa. ⊢ Γ . A</li>\n<li>⋀Γ' Aa B. ⊢ Γ' . Aa ⟹ ⊢ Γ . A ⟹ ⊢ Γ' . B ⟹ ⊢ Γ . A ⟹ ⊢ Γ . A</li>\n<li>⋀Γ' Aa B. ⊢ Γ' . Aa . B ⟹ ⊢ Γ . A ⟹ ⊢ Γ . A</li>\n</ol>\n<p>The first subgoal is the very lemma I'm trying to prove.  I rather<br>\nneed something like</p>\n<p>⋀Γ' Aa. ⟦ Γ . A = Γ' . Not Aa . Aa⟧ ⟹ ⊢ Γ . A</p>\n<p>Using apply(induct rule: derivation.cases) instead of induct does give<br>\nsomething like this, but then in the other subgoals I won't have an<br>\ninductive hypothesis.</p>\n<p>How can I get around this problem?  Is there a method or attribute<br>\nthat can combine cases and induct?</p>\n<p>--<br>\nJun Inoue</p>\n</blockquote>",
        "id": 294730943,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188020
    }
]