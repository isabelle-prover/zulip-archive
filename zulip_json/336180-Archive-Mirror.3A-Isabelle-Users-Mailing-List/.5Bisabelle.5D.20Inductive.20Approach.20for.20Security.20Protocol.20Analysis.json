[
    {
        "content": "<p>From: <a href=\"mailto:kristof.teichel@ptb.de\">kristof.teichel@ptb.de</a><br>\nHello Isabellers,</p>\n<p>I am part of a team seeking to develop a protocol with a lot of security <br>\naspects. I have taken on the responsibility of performing a formal <br>\nverification of the security aspects. One of the methods I would really <br>\nlike to employ is Larry Paulson's 'Inductive Approach' via Isabelle.<br>\nIn parallel with the development, I have begun with modelling parts of the <br>\nprotocol and proving some basic properties, mostly to get a feel for it.<br>\nSince I am new to most aspects of all this, it would be great if someone <br>\nwas able and willing to help me out every now and again with some <br>\nbeginner's aid.</p>\n<p>My first concrete questions are these:</p>\n<p>1) We are using keyed Hash signatures for authenticity. Is there already a <br>\nTheory treating authenticity goals via Hash signatures? If so, could <br>\nsomeone please point me to it? <br>\nI believe I have succeeded with proving the authenticity goal I had in <br>\nmind, but I had to start with the very basic facts like that no Hash value <br>\nis in the \"initState\" knowledge of any participant; I was feeling like <br>\nthis had probably been treated somewhere before and I just couldn't find <br>\nit.</p>\n<p>2) What would be a good way to model a (secret) random seed for each <br>\nagent? This seed shall be used to deterministically generate secrets in <br>\nthe course of the protocol.</p>\n<p>2a) Until I figure out a good answer to 2): If I do not wish to use the <br>\n\"shrK\" shared key that every agent possesses for its original purpose, <br>\nwould it make sense to just divert this from its intended use and model <br>\nthe seed(s) with it? The property that the \"Server\" entity (which will be <br>\nused by me to represent a Certificate Authority) then knows all the seeds <br>\ndoes not benefit me, nor does it mirror the true behaviour of the <br>\nparticipants. I <em>suppose</em> it won't hurt, but does anyone here think it is <br>\na really bad idea anyway?</p>\n<p>That's it for now. I would be thankful for any help, even just little <br>\nhints.</p>\n<p>Regards<br>\nKristof</p>",
        "id": 294273909,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918090
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThanks for your enquiry. The first thing to say is that I’m not sure that this old work is still the best way to prove protocols. I have seen more modern methods that seem to lead to simpler proofs, described for example in the following paper:</p>\n<p><a href=\"http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5552641&amp;tag=1\">http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5552641&amp;tag=1</a></p>\n<p>On the other hand, I haven’t studied that work in detail and am not certain what it can and cannot do. The main advantage of the inductive method today is that, being based on little more than pure logic, you can adapt it to almost anything. The highly refined and effective verification methods that many people are using now may turn out to be too specialised to cope with a sort of protocol that hasn’t been seen before.</p>\n<p>As regards the inductive method, proving authenticity properties isn’t that difficult compared with the effort of getting to grips with a typical protocol specification consisting of hundreds of pages of text. Secrecy properties tend to be much trickier, requiring very subtle invariants.</p>\n<p>Turning to your questions:</p>\n<p>1: I assume that by a keyed hash signature you mean hashing the plaintext, then encrypting it with a private key. Quite a few examples exist in the Isabelle distribution, above all in HOL/SET_Protocol. Papers about this work can be downloaded from <a href=\"http://www.cl.cam.ac.uk/~lp15/papers/Auth/\">http://www.cl.cam.ac.uk/~lp15/papers/Auth/</a></p>\n<p>2: if the random seed in question is assumed to be an unguessable long-term secret, then you could represent it in exactly the same way as shrK. Probably you could use shrK itself, for example, if other secrets are generated by a hash chain starting from this. It isn’t strictly correct to say that the Server “knows” anything, in the sense that it cannot do anything with its “knowledge” other than to execute the protocol lawfully. Only the knowledge of the Spy is critical.</p>\n<p>I hope you find all this useful.</p>\n<p>Larry Paulson</p>",
        "id": 294274036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918158
    }
]