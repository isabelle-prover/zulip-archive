[
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nMy ashamed apologizes if this looks as weird as I'm afraid it may looks,  <br>\nhowever, this question really tickles me.</p>\n<p>I came to something like this after some simplifications, so I wanted to  <br>\ntest it with a lemma:</p>\n<p>lemma \"f = (λa. a ∨ f a) ⟹ (f a = a)\"</p>\n<p>Isabelle tells me it found a counter example with “a = False” and “f a =  <br>\nTrue” . It does not seems to see there is an infinite recursion, or else I  <br>\ndon't understand how it can believe “f a” may differs from “a” (how so?).</p>\n<p>To me, it can only be “a”, an infinite never ending sequence of  <br>\ndisjunctions of the same term may be nothing else if it's ever something,  <br>\nthan this term.</p>\n<p>I guess this case looks weird, but I would like to know, first if Isabelle  <br>\nsees it as an infinitely recursive lambda expression or not, then if if it  <br>\ndo, if there exists some trusted axioms which are able to deal with this?</p>",
        "id": 294260038,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914028
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nHi Yannick,</p>\n<p>The counterexample involves having f as the constant \"True\" function, and then picking \"a\" to be False. The assumption in your lemma can be rewritten as</p>\n<p>∀x. (f(x) = x ∨ f(x))</p>\n<p>and this certainly holds when f is the constant \"True\" function, since both sides of the =-operator are True. But the conclusion of your lemma doesn't hold since f(False) is not False.</p>\n<p>Does that help?</p>\n<p>john</p>",
        "id": 294260059,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914036
    },
    {
        "content": "<p>From: Yannick &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nOn Sat, 14 Dec 2013 11:29:47 +0100, John Wickerson  <br>\n&lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Yannick,</p>\n</blockquote>\n<p>Hello John, and thanks for your interest in the question.</p>\n<blockquote>\n<p>The counterexample involves having f as the constant \"True\" function,  <br>\nand then picking \"a\" to be False. The assumption in your lemma can be  <br>\nrewritten as</p>\n<p>∀x. (f(x) = x ∨ f(x))</p>\n<p>and this certainly holds when f is the constant \"True\" function, since  <br>\nboth sides of the =-operator are True. But the conclusion of your lemma  <br>\ndoesn't hold since f(False) is not False.</p>\n<p>Does that help?</p>\n</blockquote>\n<p>I don't know so far, will see if I understand. At least you seem to  <br>\nconfirm Isabelle really understand it as a recursive function application  <br>\n(I had a doubt on this for a moment).</p>\n<p>Why is f(False) not False ? If it's built with False only and only  <br>\ndisjunctions, where could True comes from?</p>\n<p>Or else may be my interpretation is wrong: I see it as an infinite  <br>\nsequence like “x ∨ x ∨ x ∨ x ∨ x ∨ …”.</p>\n<p>For the longer story, what I was attempting with this lemma, is to get a  <br>\nrule for elimination of this particular kind of infinite recursion. A more  <br>\ngeneral case could be (in my interpretation which may be erroneous, I  <br>\ndon't know so far): let “+” be an operator, let the proposition “a + b =  <br>\na” be previously proved to holds, then an infinite sequence like “a + b +  <br>\nb + b + b + …” may be substituted to “a”; that was the meaning I expected.</p>\n<p>May be there is a way to prove it with something like a list induction and  <br>\nproving the function recursion is like the list recursion on an infinite  <br>\nlist. May be with a list I could say “what ever the length of a + b + b +  <br>\nb + b + … it will always be a when a + b = a” so the infinite length list  <br>\nproduce the same if it's interpreted as producing anything (already hardly  <br>\nprovable I believe). Just that it's not a list, it's a recursive function  <br>\ninstead. Then I wondered if there exist an axiom for this in any kind of  <br>\ntheory (either that of Isabelle or from foreign theories) or else if it  <br>\nwould be safe to create one, and I'm afraid of creating an axiom which I'm  <br>\nnot able to prove (so a pure axiom, not a theorem).</p>",
        "id": 294260092,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914050
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nYannick,</p>\n<p>I just make more explicit what John says with regards to the constant <br>\nfunction, and also, explicitly, for any free variables in a lemma, there <br>\nis implicit universal quantification of those free variables, something <br>\nwhich Christian Sternagel made explicit enough with explicit examples to <br>\nconclusively show, for me, the connection between free variables and <br>\nuniversal quantification.</p>\n<p>There can be lots of implicit action working underneath.</p>\n<p>You're stating this:</p>\n<p>lemma \"!!f. !!a. f = (%a. a | f a) ==&gt; (f a = a)\"<br>\noops</p>\n<p>So, let \"f = (%a. True)\", and for the quantified variable \"a\", let \"a = <br>\nFalse\".</p>\n<p>Then</p>\n<p>lemma \"(%x. True) = (%x. x | (%x. True) x) ==&gt; ((%x. True) False ~= False)\"<br>\nby(simp)</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294260098,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914053
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI’m afraid that’s your mistake. Such expressions simply don’t make sense.</p>\n<p>Larry Paulson</p>",
        "id": 294260114,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914059
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nI wanted to check if had an issue with binding (indeed, I did had issues  <br>\nwith implicit operations in some cases), so tried this:</p>\n<p>lemma \"f = (λa. False ∨ f False) ⟹ (f False = False)\"</p>\n<p>It still says it find a counter example, with “f False = True”. Precisely,  <br>\nwhat I don't understand, is why it suppose this may be True. “a” is not  <br>\nused, and the only constant used in f is False.</p>\n<p>I must be missing something important, or else it's just Auto Quickcheck  <br>\nwhich is not made for this kind of infinite expression.</p>\n<p>I won't go with an axiom, looks unsafe if I am missing something.</p>",
        "id": 294260188,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914083
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nI agree opinion may vary about the sense, I mainly had the hope this won't  <br>\nbe unsound.</p>\n<p>I will go another way, reformulating some expressions, using a garde, to  <br>\navoid this case. The question was still interesting to me.</p>\n<p>Thanks again for the comments.</p>",
        "id": 294260224,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914096
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIt is simply that if f is the constant-True function, then f = (λa. False ∨ f False).</p>\n<p>I think that you are imagining some sort of execution model for HOL. But HOL doesn’t have an operational semantics. </p>\n<p>Larry Paulson</p>",
        "id": 294260243,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914108
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nYou might have worked this out already, but I attach and include a THY <br>\nwhich has comments. You're treating \"=\" as programming language <br>\nassignment, but it's not. You're also speaking of non-terminating, <br>\nrecursive functions, but they don't exist in HOL, so I've read, I think.</p>\n<p>In the second half the theory, I define a recursive function, sumXP, and <br>\nI demonstrate that \"sumXp 4\" doesn't automatically get recursively applied.</p>\n<p>I could ask, \"How do I easily prove <code>theorem \"sumXp 4 = 10\"</code>, without <br>\nusing the successor form of nat?\" But that would put me over my yearly <br>\nquota for asking questions.</p>\n<p>Regards,<br>\nGB</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\ntheory i131216a__isaU_eq_is_not_assignment<br>\nimports Complex_Main (<em>\"../../../iHelp/i\"</em>)<br>\nbegin<br>\n(<em>SHOWING THAT \"=\" IS HOL.eq, RATHER THAN PROGRAMMING LANGUAGE ASSIGNMENT</em>)</p>\n<p>(*<br>\nYou're treating \"=\" as if it's assignment or definition, such as \"val x <br>\n= 1\", but<br>\nit's not, it's the application of the function HOL.eq::('a =&gt; 'a =&gt; <br>\nbool), which<br>\nhas been axiomatized to have certain properties, such as substitution.</p>\n<p>The expression \"f = (%a. a | f a)\" is a statement of function equality, <br>\nand the<br>\npertinent theorem is this:<br>\n*)</p>\n<p>theorem \"(f = g) &lt;-&gt; (!x. f x = g x)\"<br>\nby(rule fun_eq_iff)</p>\n<p>(*<br>\nTo prove your theorem wrong, I only need one function of type (bool =&gt; <br>\nbool),<br>\nand I choose (%x. True), with the result that \"(%x. True) = (%a. a | <br>\n(%x. True) a)\"<br>\nis True by fun_eq_iff. There are only two values, True and False, that <br>\nneed to<br>\nbe tested to determine whether (%x. True) is equal to (%a. a | (%x. <br>\nTrue) a).</p>\n<p>Also, this shows that there's no recursion, unless for a particular f, f has<br>\nbeen defined to be recursive. Here, it appears I've defined a recursive <br>\nfunction<br>\nnamed fix_f:<br>\n*)</p>\n<p>function fix_f :: \"bool =&gt; bool\" where<br>\n   \"fix_f a = (%x. x | fix_f x) a\"<br>\nby(auto)</p>\n<p>(*<br>\nOf note is that the \"=\" used is still HOL.eq, which can be seen by <br>\ncntl-clicking<br>\non it.</p>\n<p>You might think that \"(fix_f True)\" should return \"(True | fix_f True)\", <br>\nwhere<br>\nif HOL implements a short-circuited or, it would simplify to \"True\".</p>\n<p>You might think that \"(fix_f False)\" should be an infinite loop, because<br>\nthe first iteration will return \"(False | fix_f False)\", and so on, to <br>\ninfinity.</p>\n<p>You can try to use fix_f in theorems, but it's not usable because <br>\ntermination<br>\nhasn't been proved.</p>\n<p>Your options for defining recursive functions are function, fun, and <br>\nprimrec,<br>\nnone of which will work for fix_f. The applicable documents are <br>\nfunctions.pdf<br>\nand isar-ref.pdf.<br>\n*)</p>\n<p>function fix_g :: \"bool =&gt; bool\" where<br>\n   \"fix_g a = (%x. x | fix_g x) a\"<br>\nby pat_completeness auto<br>\ntermination by lexicographic_order<br>\n(*ERROR: Unfinished goal \"1. False\". Could not find lexicographic <br>\ntermination<br>\n   order.*)</p>\n<p>fun fix_h :: \"bool =&gt; bool\" where<br>\n   \"fix_h a = (%x. x | fix_h x) a\"<br>\n(<em>ERROR: Same error as for \"function\".</em>)</p>\n<p>primrec fix_i :: \"bool =&gt; bool\" where<br>\n   \"fix_i a = (%x. x | fix_i x) a\"<br>\n(<em>ERROR: primrec only defines functions that use datatype.</em>)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>****)<br>\n(<em>SHOWING THAT RECURSIVE FUNCTIONS DON'T GET \"COMPUTED\" AUTOMATICALLY</em>)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>****)</p>\n<p>fun sumXp :: \"nat =&gt; nat\" where<br>\n   \"sumXp 0 = 0\"<br>\n  |\"sumXp n = n + sumXp(n - 1)\"</p>\n<p>find_theorems \"sumXp\"<br>\nthm sumXp.simps<br>\n(*<br>\nPrints the simp rules created for sumXp: sumXp.simps(1), sumXp.simps(2)<br>\n*)</p>\n<p>value \"sumXp 4\"<br>\n(*<br>\nThe code generator prints the successor form of 10. Doing an import of<br>\n\"~~/src/HOL/Library/Code_Target_Nat\" will print 10, but the fact that the<br>\nsuccessor form is being used is needed information here.<br>\n*)</p>\n<p>theorem \"sumXp 4 = 10\"<br>\napply(simp) oops<br>\n(*<br>\nBut simp here doesn't do any magic computation, even though sumXp.simps(1)<br>\nand sumXp.simps(2) are automatically declared as simp rules.<br>\n*)</p>\n<p>theorem \"(!!f::(nat =&gt; nat). !!a. f = (%x. f x) ==&gt; f a = a) ==&gt; False\"<br>\nby(auto)<br>\n(*<br>\nEXAMPLE: This example, similar to yours, will be made concrete with sumXp.<br>\n*)</p>\n<p>theorem \"sumXp = (%x. sumXp x)\"<br>\nby(rule eta_contract_eq)<br>\n(*<br>\nChecking that the left-hand side will be true.<br>\n*)</p>\n<p>theorem \"sumXp = (%x. sumXp x) ==&gt; sumXp 4 = 10\"<br>\nusing[[simp_trace]]<br>\napply(simp) oops<br>\n(*<br>\nAfter simp is applied, the goal is \"sumXp 4 = 10\". The RHS hasn't been<br>\nsimplified any at all. Computations like this are a result of simp rule<br>\nsubstitutions (rewriting), and simp rules are picky.<br>\n*)</p>\n<p>theorem \"sumXp = (%x. sumXp x) ==&gt;<br>\n   sumXp (Suc (Suc (Suc (Suc 0))))<br>\n     = (Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc (Suc 0))))))))))\"<br>\n(*<br>\nHappy simp rules make for happy computations...<br>\n*)<br>\nusing[[simp_trace]]<br>\nby(simp)<br>\n(*<br>\n...by means of rewriting. With the right form of natural numbers, the simp<br>\nrules can compute what is needed to obtain the necessary \"HOL.eq a b == <br>\nTrue\",<br>\nthe rewriting of which can be seen at the end of the simp trace.<br>\n*)</p>\n<p>(<em>declare[[simp_trace]]</em>)<br>\nvalue \"sumXp 4\"<br>\n(*<br>\nGoing back, I'd like to see if simp_trace can tell me what simp rule <br>\n\"value\" is<br>\nusing to compute <code>value \"sumXp 4\"</code>.</p>\n<p>It's using the function Num.nat_of_num, which cntl-clicking will take <br>\nyou to.<br>\nIt's also using a lot of other rewrite rules.<br>\n*)</p>\n<p>term \"nat_of_num\"</p>\n<p>theorem \"sumXp 4 = 10\"<br>\napply(simp add: nat_of_num.simps)<br>\noops<br>\n(*<br>\nThe message is that nat_of_num.simps are duplicate rewrite rules. It will be<br>\neasier just to ask what needs to be done to be able to prove a theorem which<br>\nuses an expression like \"sumXp 4 = 10\".<br>\n*)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\nend<br>\n<a href=\"/user_uploads/14278/fNtL9Gx2z-H61eMFz7v2-OC9/i131216a__isaU_eq_is_not_assignment.thy\">i131216a__isaU_eq_is_not_assignment.thy</a></p>",
        "id": 294260678,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914256
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nSo 4 is not equal to 10, but the primary purpose was to show that <br>\nnothing automatically happens with function application, such as \"sumXp <br>\n4\", and at most, a sequence of substitutions are made, if things are <br>\ndone the way I did them. Most important, maybe, is knowing that infinite <br>\nrecursion can't happen.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294260712,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914272
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nI did not really interpreted this as an assignment, rather as an equality  <br>\nwhich in turn allows a substitution, and so, recursively. Ex:</p>\n<p>theory Test<br>\n     imports Main<br>\n     begin</p>\n<p>(* Based on the original proposition which was: \"f = (λa. a ∨ f a) ⟹  <br>\n(f a = a)\" *)</p>\n<p>lemma \"f = (λa. a ∨ f a) ⟹ f = (λa. a ∨ (λa. a ∨ f a) a)\" by simp</p>\n<p>lemma \"f = (λa. a ∨ f a) ⟹ f = (λa. a ∨ (λa. a ∨ (λa. a ∨ f a) a)  <br>\na)\" by simp</p>\n<p>(* And so on… *)</p>\n<p>end</p>\n<p>That's why I saw an infinite recursion.</p>\n<p>I will have a look later in your extensive sample.</p>",
        "id": 294261082,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914409
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nTo tell it another way, my erroneous interpretation was to believe it was  <br>\nthe same as a definition of “f”, while both an explicit “definition” and a  <br>\n“fun/function” definition fails with such an expression:</p>\n<p>definition f where \"f = (λa. a ∨ f a)\" (* Isabelle complains “Extra  <br>\nvariables on rhs: \"f\"”. *)</p>\n<p>fun f where \"f a = (a ∨ f a)\" (* Isabelle complains “Could not find  <br>\nlexicographic termination order”. *)</p>\n<p>For the second case, no way to try with “function”, as that's absolutely  <br>\nnon‑terminating.</p>\n<p>So this was like an attempt to define something impossible to Isabelle,  <br>\nand also after some comments here, something HOL can't deal with. Finally,  <br>\nin the absence of any real definition, Quickcheck was free to substitute  <br>\n“f” to whatever it wanted. This should summarize the case.</p>",
        "id": 294261137,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914429
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nFrom a computational point of view, \"f a = (a ∨ f a)” must be regarded as undefined, because the recursion is not well-founded. There are logics where you could then prove that f(True)=True and f(False)=undefined.</p>\n<p>Larry Paulson</p>",
        "id": 294261146,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914434
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nInteresting. Just out of curiosity and learn more (really not to use it),  <br>\nwhat are the names of these logics?</p>",
        "id": 294261161,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914440
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou could try Isabelle/HOLCF, but I’m not sure how well documented and supported it is.</p>\n<p>Larry Paulson</p>",
        "id": 294261179,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914445
    },
    {
        "content": "<p>From: Yannick &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nThis document seems a good introduction on LCF vs HOL and the idea of  <br>\ngetting one with the other:<br>\n<a href=\"http://csep.hpcc.nectec.or.th/Journals/oup/smj/journals/ed/titles/computer_journal/Volume_38/Issue_02/38.2.pdf/agerholm.pdf\">http://csep.hpcc.nectec.or.th/Journals/oup/smj/journals/ed/titles/computer_journal/Volume_38/Issue_02/38.2.pdf/agerholm.pdf</a><br>\n(the one I will read)</p>\n<p>For HOL and LCF as an Isabelle theory, this one:<br>\n<a href=\"http://www4.in.tum.de/publ/papers/Regensburger_HOLT1995.pdf\">http://www4.in.tum.de/publ/papers/Regensburger_HOLT1995.pdf</a><br>\n(outdated?)</p>\n<p>Quote of the abstract of the former:</p>",
        "id": 294261199,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914454
    }
]