[
    {
        "content": "<p>From: Thomas Genet &lt;<a href=\"mailto:Thomas.Genet@irisa.fr\">Thomas.Genet@irisa.fr</a>&gt;<br>\nDear Isabelle users,</p>\n<p>I am trying to use some Scala code generated from an Isabelle theory and <br>\nhaving a problem.<br>\nThis is a newbie problems (I guess) but, unfortunately, I am a newbie in <br>\nIsabelle and Scala!</p>\n<p>Since I use the \"=\" on polymorphic type 'a, the scala generated classes <br>\nhave to have the <code>HOL.equal</code> trait. I did this using implicit conversion <br>\nfunction. However, I get the same error message with explicit conversions.</p>\n<p>Any help is welcome...</p>\n<p>Thanks in advance,</p>\n<p>Thomas</p>\n<p>-------- Here is the Isabelle Theory---------<br>\ntheory testScala<br>\nimports Main<br>\nbegin</p>\n<p>fun member:: \"'a \\&lt;Rightarrow&gt; 'a list \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n\"member x []=False\" |<br>\n\"member x (y#yr) = (if x=y then True else (member x yr))\"</p>\n<p>export_code member<br>\n   in Scala<br>\nend</p>\n<p>-------- Here is the scala generated code----------<br>\nobject HOL {</p>\n<p>trait equal[A] {<br>\n   val <code>HOL.equal</code>: (A, A) =&gt; Boolean<br>\n}<br>\ndef equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = <br>\nA.<code>HOL.equal</code>(a, b)</p>\n<p>def eq[A: equal](a: A, b: A): Boolean = equal<a href=\"http://a,%20b\">A</a></p>\n<p>} /* object HOL */</p>\n<p>object testScala {</p>\n<p>def member[A: HOL.equal](x: A, xa1: List[A]): Boolean = (x, xa1) match {<br>\n   case (x, Nil) =&gt; false<br>\n   case (x, y :: yr) =&gt; (if (HOL.eq<a href=\"http://x,%20y\">A</a>) true else member<a href=\"http://x,%20yr\">A</a>)<br>\n}</p>\n<p>} /* object testScala */</p>\n<p>-------- Here is the code trying to call the \"member\" function-----</p>\n<p>object Main {<br>\n   implicit def wrapString(s:String):StringWrapper = new StringWrapper(s)<br>\n   implicit def wrapList(l: List[(String,String)]): <br>\nList[(StringWrapper,String)]={<br>\n     l match {<br>\n       case Nil =&gt; Nil<br>\n       case (x,y) :: xs =&gt; ((new StringWrapper(x)),y)::(wrapList(xs))<br>\n     }<br>\n   }</p>\n<p>class StringWrapper(val s : String) extends HOL.equal[StringWrapper]{<br>\n     def <code>HOL.equal</code>(s1:StringWrapper, s2:StringWrapper):Boolean = s1==s2<br>\n   }</p>\n<p>val l: List[String]= \"John\"::\"Paul\"::\"George\"::\"Ringo\"::Nil<br>\n   val b= testScala.member(\"John\",l)<br>\n}</p>\n<p>-------- Here is the error message ---------</p>\n<p>error: could not find implicit value for evidence parameter of type <br>\nmember.HOL.equal[String]<br>\n   val b= testScala.member(\"John\",l)</p>",
        "id": 294137586,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844862
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Thomas,</p>\n<p>those implicit values must be values (val, def), not classes.</p>\n<p>To get an idea how they should look, I recommend to have a look at<br>\ngenerated Scala code which contains implicit value definitions for class<br>\ninstances, e.g.</p>\n<p>definition \"foo = distinct [0, Suc 0]\"</p>\n<p>export_code foo in Scala</p>\n<p>As I rule of thumb, I further recommend to avoid plumbing generated and<br>\nnon-generated code as far as possible and doing as much as possible<br>\nwithin HOL.  Note that it is possible to generate Scala strings using<br>\ntype String.literal with constructor STR:</p>\n<p>definition \"foo = STR ''foo''\"</p>\n<p>export_code foo in Scala</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Lltym0NDCkq0WfSJ_GqbDq4V/signature.asc\">signature.asc</a></p>",
        "id": 294137602,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844869
    },
    {
        "content": "<p>From: Thomas Genet &lt;<a href=\"mailto:Thomas.Genet@irisa.fr\">Thomas.Genet@irisa.fr</a>&gt;<br>\nDear all Isabelle users,</p>\n<p>If I understand well the generated code, to match my problem, I should <br>\nsimply write:</p>\n<hr>\n<p>object Main {<br>\n   implicit def equal_nat: HOL.equal[String] = new HOL.equal[String] {<br>\n     val <code>HOL.equal</code> = (a: String, b: String) =&gt; a==b<br>\n   }</p>\n<p>def main(args: Array[String]): Unit = {<br>\n     val l: List[String]= \"John\"::\"Paul\"::\"George\"::\"Ringo\"::Nil<br>\n     val b= testScala.member(\"John\",l)<br>\n   }</p>\n<hr>\n<p>Instead of all the horrible implicit conversion of classes I wrote first :-)<br>\nThis solution seems to be OK.<br>\nThanks a lot Florian,</p>\n<p>Thomas</p>",
        "id": 294137681,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844889
    }
]