[
    {
        "content": "<p>From: Scott West &lt;<a href=\"mailto:scott.west@inf.ethz.ch\">scott.west@inf.ethz.ch</a>&gt;<br>\nHello list!</p>\n<p>Is there a standard, accepted, advised, or otherwise endorsed method of <br>\ninterfacing with the Isabelle system? Currently I have a small program <br>\nwhich spawns a Isabelle TTY through the isatool, and communicates <br>\nthrough the standard handles.</p>\n<p>I feel this may not be the best way for automated-interaction (I'm <br>\ntrying to see if I can make a new interface). Is there some other way <br>\nthat is recommended? I also tried just invoking isabelle, at which point <br>\nI became stymied by the documentation of the underlying ML (is there <br>\nsome disjointedness between the documentation and the current release?).</p>\n<p>Thanks in advance!</p>\n<p>Regards,<br>\nScott West</p>\n<p>(PS, sorry if this is the third message that is received of this sort, <br>\nthe list wasn't responding to my mails...)</p>",
        "id": 294073066,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827861
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 25 Feb 2009, Scott West wrote:</p>\n<blockquote>\n<p>Is there a standard, accepted, advised, or otherwise endorsed method of <br>\ninterfacing with the Isabelle system? Currently I have a small program <br>\nwhich spawns a Isabelle TTY through the isatool, and communicates <br>\nthrough the standard handles.</p>\n</blockquote>\n<p>Traditionally, the \"standard\" way to work with Isabelle under external <br>\nprogram control is rather primitive, see the \"isabelle-process\" command in <br>\nthe system manual.  Here you get access to the raw ML toplevel, and you <br>\ncan pass ML expressions via the -e option.  In principle this allows you <br>\nto do whatever you want, by invoking suitable ML things of your own <br>\nmaking.  (Which is quite admittedly quite hard.)</p>\n<p>A few such interaction wrappers have emerged in the past (notably for <br>\nProof General), and made it into the official distribution, adding funny <br>\noptions like -P -I -X to isabelle-process.</p>\n<p>Starting with Isabelle2008 we have introduced one final wrapper <br>\n(isabelle-process option -W), which is meant to interface to a proper API <br>\nthat lives in the JVM world.  That JVM library is part of the official <br>\nIsabelle distribution, so user code does not need to fiddle with low-level <br>\ninteraction protocols anymore (that is the basic plan).</p>\n<p>In Isabelle2008 this extra layer is still Java/JVM, but we have already <br>\nleft behind Java altogether in favour of Scala/JVM (which is the Next Big <br>\nThing in programming language design, see <a href=\"http://www.scala-lang.org/\">http://www.scala-lang.org/</a>).</p>\n<p>There are still many things missing here; we have only started to make <br>\nactual use of Isabelle within the Scala/JVM world, using jEdit as editor <br>\nframework.  Others have tried Netbeans with some success.</p>\n<blockquote>\n<p>I feel this may not be the best way for automated-interaction (I'm <br>\ntrying to see if I can make a new interface).</p>\n</blockquote>\n<p>Can you be more specific what you are working on?  Interacting with <br>\ninteractive provers under program control is very hard to get right.  I <br>\nhave been involved in a couple of attempts so far, some succesful, many <br>\nfailed.</p>\n<blockquote>\n<p>I became stymied by the documentation of the underlying ML (is there <br>\nsome disjointedness between the documentation and the current release?).</p>\n</blockquote>\n<p>The manuals usually lag behind the real system a couple of years.  The <br>\nnewer manuals are at least formally checked against the system, meaning <br>\nthat any references to ML entities, Isar commands, methods etc. correct.</p>\n<p>For the forthcoming release the main reference manuals (isar-ref, <br>\nimplementation, system) come in significantly updated and extended <br>\nversions.  If your are interested, you may already peek at this version <br>\nvia the repository <br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/351fc2f8493d\">http://isabelle.in.tum.de/repos/isabelle/rev/351fc2f8493d</a> (or later).</p>\n<p>It is usually easier to peek at (fully tested) snapshots via <br>\n<a href=\"http://isabelle.in.tum.de/devel/\">http://isabelle.in.tum.de/devel/</a> but that appears to be unmaintained right <br>\nnow.</p>\n<p>Makarius</p>",
        "id": 294073084,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827868
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 26 Feb 2009, Scott West wrote:</p>\n<blockquote>\n<blockquote>\n<p>Traditionally, the \"standard\" way to work with Isabelle under external<br>\nprogram control is rather primitive, see the \"isabelle-process\" command in<br>\nthe system manual.  Here you get access to the raw ML toplevel, and you<br>\ncan pass ML expressions via the -e option.  In principle this allows you<br>\nto do whatever you want, by invoking suitable ML things of your own<br>\nmaking.  (Which is quite admittedly quite hard.)</p>\n</blockquote>\n<p>It sounds like this repeated invocation would make you constantly lose <br>\nthe current proof state. Or can can this be avoided by <br>\ndumping/re-loading the heap every time? At the very least it sounds as <br>\nif it may have a high cost due to the repeated initializations of the <br>\nsystem?</p>\n</blockquote>\n<p>Well, your ML function does not have to terminate immediately.  The setup <br>\nfor Proof General for example takes over the tty and then reacts to <br>\nfurther input.  All of this is very delicate to get right, though.  <br>\nBetter try something based on the new process wrapper.</p>\n<blockquote>\n<blockquote>\n<p>If your are interested, you may already peek at this version via the <br>\nrepository <a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/351fc2f8493d\">http://isabelle.in.tum.de/repos/isabelle/rev/351fc2f8493d</a> <br>\n(or later).</p>\n</blockquote>\n<p>I now have a development version compiled (I think... untested)</p>\n</blockquote>\n<p>OK, maybe you want to subscribe to <br>\n<a href=\"https://mailmanbroy.informatik.tu-muenchen.de/mailman/listinfo/isabelle-dev\">https://mailmanbroy.informatik.tu-muenchen.de/mailman/listinfo/isabelle-dev</a> <br>\nwhich is the proper place to discuss things that are not in the official <br>\nrelease yet.</p>\n<p>Also make sure to use polyml-5.2.1, say from <br>\n<a href=\"http://isabelle.in.tum.de/polyml-5.2.1/\">http://isabelle.in.tum.de/polyml-5.2.1/</a> -- otherwise threads will not <br>\nwork, and these are required for any of the newer interaction models. <br>\n(Threads will also give you better multicore performance.)</p>\n<p>Makarius</p>",
        "id": 294073115,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827881
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nMaybe you are interested in the following presentations, which I have <br>\ngiven in Edinburgh 2007 and 2008, respectively:</p>\n<p>Asynchronous processing of proof documents -- rethinking interactive <br>\n  theorem proving<br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/edinburgh2007.pdf\">http://www4.in.tum.de/~wenzelm/papers/edinburgh2007.pdf</a></p>\n<p>Interactive Proof Documents -- Theorem Provers for User Interfaces<br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/edinburgh2008.pdf\">http://www4.in.tum.de/~wenzelm/papers/edinburgh2008.pdf</a></p>\n<p>Makarius</p>",
        "id": 294073129,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827885
    },
    {
        "content": "<p>From: Scott West &lt;<a href=\"mailto:scott.west@inf.ethz.ch\">scott.west@inf.ethz.ch</a>&gt;</p>\n<blockquote>\n<p>Traditionally, the \"standard\" way to work with Isabelle under external<br>\nprogram control is rather primitive, see the \"isabelle-process\" command in<br>\nthe system manual.  Here you get access to the raw ML toplevel, and you<br>\ncan pass ML expressions via the -e option.  In principle this allows you<br>\nto do whatever you want, by invoking suitable ML things of your own<br>\nmaking.  (Which is quite admittedly quite hard.)</p>\n</blockquote>\n<p>It sounds like this repeated invocation would make you constantly lose the <br>\ncurrent proof state. Or can can this be avoided by dumping/re-loading the heap <br>\nevery time? At the very least it sounds as if it may have a high cost due to <br>\nthe repeated initializations of the system?</p>\n<blockquote>\n<p>Starting with Isabelle2008 we have introduced one final wrapper<br>\n(isabelle-process option -W), which is meant to interface to a proper API<br>\nthat lives in the JVM world.  That JVM library is part of the official<br>\nIsabelle distribution, so user code does not need to fiddle with low-level<br>\ninteraction protocols anymore (that is the basic plan).</p>\n<p>In Isabelle2008 this extra layer is still Java/JVM, but we have already<br>\nleft behind Java altogether in favour of Scala/JVM (which is the Next Big<br>\nThing in programming language design, see <a href=\"http://www.scala-lang.org/\">http://www.scala-lang.org/</a>).</p>\n</blockquote>\n<p>I've actually used Scala a little before (and use Haskell quite a bit, so am <br>\nfamiliar with the functional style). I will give this a look.<br>\nsuccess.</p>\n<blockquote>\n<blockquote>\n<p>I feel this may not be the best way for automated-interaction (I'm<br>\ntrying to see if I can make a new interface).</p>\n</blockquote>\n<p>Can you be more specific what you are working on?  Interacting with<br>\ninteractive provers under program control is very hard to get right.  I<br>\nhave been involved in a couple of attempts so far, some succesful, many<br>\nfailed.</p>\n</blockquote>\n<p>I can't be more specific, because I really don't know :). I am still in the <br>\nexploring stage right now, seeing what can be done and what the best way to do <br>\nit is. I will likely do another round of research on general theorem prover <br>\ninterfaces and things like this if it proves needed (too busy right now).</p>\n<blockquote>\n<blockquote>\n<p>I became stymied by the documentation of the underlying ML (is there<br>\nsome disjointedness between the documentation and the current release?).</p>\n</blockquote>\n<p>The manuals usually lag behind the real system a couple of years.  The<br>\nnewer manuals are at least formally checked against the system, meaning<br>\nthat any references to ML entities, Isar commands, methods etc. correct.</p>\n<p>For the forthcoming release the main reference manuals (isar-ref,<br>\nimplementation, system) come in significantly updated and extended<br>\nversions.  If your are interested, you may already peek at this version<br>\nvia the repository<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/351fc2f8493d\">http://isabelle.in.tum.de/repos/isabelle/rev/351fc2f8493d</a> (or later).</p>\n</blockquote>\n<p>Ahhh, thanks for the tip! I now have a development version compiled (I <br>\nthink... untested)</p>\n<p>Regards,<br>\nScott</p>",
        "id": 294073154,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827895
    },
    {
        "content": "<p>From: Scott West &lt;<a href=\"mailto:scott.west@inf.ethz.ch\">scott.west@inf.ethz.ch</a>&gt;<br>\nI've found the grammar for the Isabelle input syntax, but I have yet to <br>\nfind one for the Isabelle output. Does one exist that you know of? It <br>\nseems this would be crucial for the creation of higher levels of control <br>\non top of what Isabelle offers.</p>\n<p>Regards,<br>\nScott</p>",
        "id": 294073182,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827903
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n(1) Command syntax.</p>\n<p>The grammars for Isabelle/Isar commands, methods, attributes etc. in the <br>\nmanual are only for end-users.  When building a system that operates on <br>\ninput source systematically, you cannot count on that.  First of all, <br>\nmaintaining consistency with such a huge specification is practically <br>\nimpossible (the manual itself is probably not 100% correct).  Secondly <br>\nsuch a specification can never be complete, because user applications may <br>\nintroduce new language elements at any time (Isabelle/HOL is just an <br>\n\"application\" in that sense, albeit a large one).</p>\n<p>What interfaces can rely on is the outer token syntax and the <br>\ncategorisation of \"command keywords\" as produced by a particular logic <br>\nsession.  The editor side can then chop up the source into \"command spans\" <br>\nand rely on the system reacting in a certain way, e.g. do a theory update <br>\nas in 'definition' or start a proof as in 'theorem'.  A very basic ML <br>\nexample of this rough syntactic analysis is parse_spans in <br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/83c50c62cf23/src/Pure/Thy/thy_syntax.ML\">http://isabelle.in.tum.de/repos/isabelle/file/83c50c62cf23/src/Pure/Thy/thy_syntax.ML</a></p>\n<p>At some later stage we will provide this kind of functionality on the <br>\nScala level as well, but it will be more flexible, operating on some kind <br>\nof editor buffer model instead of doing batch-mode parsing.</p>\n<p>(2) Message syntax.</p>\n<p>Messages are merely packets of text sent to certain \"output channels\", <br>\ne.g. writeln, warning, error. There are hooks for each channel, so the <br>\ninterface ML wrapper can do whatever it needs to do.  E.g. see <br>\nOutput.warning_fn and its redifinition in the various wrappers (use \"grep <br>\n-r\" or hypersearch in jEdit to find the places).</p>\n<p>Thus you get messages plus some message type information.  Apart from that <br>\nthere is usually extra markup within the body, e.g. when printing a term <br>\nyou get information about bound, free, schematic variables etc.  Proof <br>\nGeneral turns this into the well-known colour scheme for variables.  You <br>\ncan also inspect the markup in semi-human-readable form like this in Proof <br>\nGeneral:</p>\n<p>thm (test_markup) exE</p>\n<p>The representation of markup in existing interfaces is quite adhoc -- no <br>\nneed to look into that.  The new Isabelle process wrapper (remember <br>\nisabelle-process option -W) always uses (untyped) XML trees encoded in <br>\nYXML transfer syntax (this format is explained in the Isabelle System <br>\nmanual).  When using the Scala wrapper around that, you do not have to <br>\ncare about the encoding, but get back the tree structure directly.</p>\n<p>These trees are still uninterpreted.  We will probably add some kind of <br>\ndefault rendering via CSS at some stage.</p>\n<p>(3) Scala wrapper.</p>\n<p>I have mentioned the Isabelle scala wrapper several times already.  Here <br>\nis a simple example session (using the development snapshot of Isabelle, <br>\nor a repository version after invoking \"Admin/build jars\"):</p>\n<p>$ isabelle scala<br>\n  scala&gt; val p = new isabelle.IsabelleProcess(\"HOL\")<br>\n  scala&gt; p.command(\"\"\" theory A imports Main begin \"\"\")</p>\n<p>WRITELN [[theory A]]</p>\n<p>scala&gt; p.command(\"\"\" theorem \"A --&gt; A\" \"\"\")</p>\n<p>WRITELN [[proof (prove): step 0</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>\n<p>A --&gt; A]]</p>\n<p>scala&gt; p.command(\"\"\" .. \"\"\")</p>\n<p>WRITELN [[theorem ?A --&gt; ?A]]</p>\n<p>scala&gt; p.command(\"\"\" end \"\"\")<br>\nscala&gt; p.close</p>\n<p>...</p>\n</li>\n</ol>\n<p>In the transscript I have suppressed some of the more chatty messages.  <br>\nHere you have direct access to the most basic prover protocol: <br>\ncommands-in, messages-out.  But the protocol is not as simple as it seems, <br>\nbecause commands can produces any number of messages in any order, <br>\npotentially intermingled with messages from other commands that are <br>\nrunning concurrently.  (Note that the prover \"prompt\" still used in Proof <br>\nGeneral no longer exists.)</p>\n<p>Our next step is to wrap up the command/message protocol into a proper <br>\ndocument model that maintains sources + command structure + message <br>\nfeedback as extra markup to the sources.</p>\n<p>Makarius</p>",
        "id": 294073258,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827929
    }
]