[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Isabelle developers,</p>\n<p>Interpretations treat abbreviations in a type class context strangely. Here's an example <br>\nfor Isabelle2015. In List.thy, the function sort is defined as an abbreviation of sort_key <br>\n(%x. x) in the type class context linorder.</p>\n<p>When I now interpret the linorder locale with the dual operations with prefix \"dual\", both <br>\nnames \"dual.sort\" and \"dual.sort_key\" come into scope. The latter \"dual.sort_key\" indeed <br>\nrefers to \"linorder.sort_key (op &gt;=)\". However, \"dual.sort\" does NOT denote<br>\n\"linorder.sort_key (op &gt;=) (%x. x)\", but \"linorder.sort_key (op &lt;=) (%x. x)\", i.e., the <br>\nparameter instantiation of the interpretation is lost.</p>\n<p>I find this extremely counter-intuitive, because dual.sort sorts ascendingly and <br>\ndual.sort_key sorts descendingly! Can this be changed such that dual.sort also refers to <br>\nthe sorting with the dual operation?</p>\n<p>theory Scratch imports \"~~/src/HOL/Main\" begin<br>\ninterpretation dual!: linorder \"op ≥\" \"op &gt; :: _ :: linorder ⇒ _\" by(rule dual_linorder)<br>\nlemma \"dual.sort [1,2] = [1,2 :: int]\" by simp (* ascendingly! *)<br>\nlemma \"dual.sort_key (λx. x) [1,2] = [2,1 :: int]\" by simp (* descendingly *)<br>\nend</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294656930,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168419
    }
]