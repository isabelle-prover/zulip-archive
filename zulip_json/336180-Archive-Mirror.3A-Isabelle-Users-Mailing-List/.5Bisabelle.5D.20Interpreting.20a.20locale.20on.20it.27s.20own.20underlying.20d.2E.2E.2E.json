[
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nI'm trying to ensure that any theorem attributes given in a locale are  <br>\npropagated to the locale's underlying global definitions. Here's an  <br>\nexample:</p>\n<p>locale L =<br>\n   fixes a :: int<br>\nbegin</p>\n<p>definition<br>\n    x :: int where<br>\n   \"x = a\"</p>\n<p>lemma r[simp]: \"x + a = 2 * a\"<br>\nby (simp add: x_def)</p>\n<p>end</p>\n<p>interpretation L [a] .</p>\n<p>I then use the interpretation command above to ensure that the simp  <br>\nrule \"r\" in L is installed for the locale's underlying global  <br>\ndefinition L.x. This works, but with an unintended side-effect: The  <br>\ndefinition of f below causes a type error, because the interpretation  <br>\ncommand has also installed the unqualified name \"x\" into the namespace.</p>\n<p>definition<br>\n   f :: \"('a \\&lt;Rightarrow&gt; 'a)\" where<br>\n  \"f x = foo\"</p>\n<p>How can I perform a locale interpretation that targets the current  <br>\nbackground theory, but that doesn't add the unqualified names of the  <br>\nlocale definitions to the background theory? Note that some of these  <br>\ndefinitions may occur after the original interpretation command.</p>\n<p>Thanks,<br>\n-john</p>",
        "id": 294062897,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824392
    }
]