[
    {
        "content": "<p>From: Norbert Schirmer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>While using the simplifier to rewrite a cterm I encountered a subtle issue (described below).<br>\nI wonder if I have either encountered a bug in the simplifier or otherwise I was <br>\nbreaking some assumptions / invariants on the relation of free variables in a term<br>\nvs. fixed variables in the context.</p>\n<p>I did not find the answer in the implementation manual, hence my question here:</p>\n<p>Are there any assumptions / invariants / (strong) guidelines on the usage of <br>\nfree vs. fixed variables in the simplifier (or other proof tools in general) ?</p>\n<p>I have rules in mind like:</p>\n<ul>\n<li>Fix every free variable in the context before calling a proof tool.</li>\n<li>Always set the 'body' flag in the context before calling a proof tool.</li>\n<li>Declare a term to the context before calling a proof tool.</li>\n</ul>\n<p>Or is it the other way around and the responsibility of the proof tool to do a proper setup?</p>\n<p>Here the issue I stumbled upon.</p>\n<p>Simplifies to True as expected.</p>\n<p>lemma \"b (0::nat) + (a::int) ≤ n ⟹ b 0 + a ≤ n + 1\"<br>\n apply simp<br>\n done</p>\n<p>Does not simplify to True</p>\n<p>declare [[linarith_trace=true]]<br>\nML_val ‹<br>\nval ct = @{cterm \"b (0::nat) + (a::int) ≤ n ⟹ b 0 + a ≤ n + 1\"}<br>\nval test = Simplifier.asm_full_rewrite @{context} ct<br>\n›</p>\n<p>Diagnoses with ‹linarith_trace› reveals that linarith accidently (re)uses variable name \"a\" <br>\nas \"fresh\" name for @{term \"b 0\"} which in turn makes the proof fail as it collides with the <br>\nalready present free variable \"a\".</p>\n<p>My guess (without inspecting the actual code) is, that linarith creates new variable names merely <br>\nrefering to the context, e.g. with @{ML Variable.variant_fixes} without additionally considering the <br>\nfree (and not fixed) variables in the present term, e.g. with @{ML Term.variant_frees}.</p>\n<p>When fixing and declaring the variables it simplifies to True as expected.</p>\n<p>ML_val ‹<br>\nval ctxt0 = @{context};<br>\nval ([b, a, n], ctxt1) = ctxt0 |&gt; Variable.add_fixes [\"b\", \"a\", \"n\"];<br>\nval t = Syntax.read_term ctxt1 \"b (0::nat) + (a::int) ≤ n ⟹ b 0 + a ≤ n + 1\";<br>\nval ctxt2 = ctxt1 |&gt; Variable.declare_term t;<br>\nval ct = Thm.cterm_of ctxt2 t;<br>\nval test = Simplifier.asm_full_rewrite ctxt2 ct;<br>\n›</p>\n<p>Actually, just declaring the term already has the desired effect.</p>\n<p>ML_val ‹<br>\nval ctxt0 = @{context};<br>\nval t = Syntax.read_term ctxt0 \"b (0::nat) + (a::int) ≤ n ⟹ b 0 + a ≤ n + 1\";<br>\nval ctxt1 = ctxt0 |&gt; Variable.declare_term t;<br>\nval ct = Thm.cterm_of ctxt1 t;<br>\nval test = Simplifier.asm_full_rewrite ctxt1 ct;<br>\n›</p>\n<p>Alternatively, setting the ‹body› flag in the context also has the desired effect.</p>\n<p>ML_val ‹<br>\nval ct = @{cterm \"b (0::nat) + (a::int) ≤ n ⟹ b 0 + a ≤ n + 1\"}<br>\nval test = Simplifier.asm_full_rewrite (Variable.set_body true @{context}) ct<br>\n›</p>\n<p>Regards,<br>\nNorbert</p>",
        "id": 294763971,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661201017
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI will look at your examples in detail later, but here are some abstract<br>\nnotes.</p>\n<p>Generally, you should make your formal items as official in the context<br>\nas possible: the minimum is a variant of Variable.declare_term, but it<br>\nis better to use Variable.add_fixes or similar to make it really right.<br>\nSometimes the latter is not possible for historical reasons.</p>\n<p>There are many intermediate situations for variables in the context, for<br>\nthe sake of old tools that don't register properly in the context. It<br>\nwould be better to be really strict about demanding everything to be<br>\nproperly \"fixed\" in the context, but this will break some old tools.</p>\n<p>Ah, and the word \"bug\" has not meaning in the Isabelle context:<br>\neverything is so complex that we can only talk about behaviour that is<br>\nexpected / unexpected, simple / complex, desirable / undesirable,<br>\nchangeable / unchangeable (for now).</p>\n<p>The usual strategy of survival is to do things in a \"canonical\" way,<br>\nincluding certain context disciplines. (Example: normally you should<br>\n<em>not</em> change context flags like \"is_body\": that belongs to the system<br>\ninfrastructure, not the user-space tools).</p>\n<p>Makarius</p>",
        "id": 294763980,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661201020
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 09/10/2019 22:26, Norbert Schirmer via Cl-isabelle-users wrote:</p>\n<blockquote>\n<p>Are there any assumptions / invariants / (strong) guidelines on the usage of <br>\nfree vs. fixed variables in the simplifier (or other proof tools in general) ?</p>\n</blockquote>\n<blockquote>\n<p>I have rules in mind like:\n* Fix every free variable in the context before calling a proof tool.</p>\n</blockquote>\n<p>This should work, but it is not necessary in the strict sense.</p>\n<blockquote>\n<ul>\n<li>Always set the 'body' flag in the context before calling a proof tool.</li>\n</ul>\n</blockquote>\n<p>Don't do this -- the flag is managed by the system infrastructure, not<br>\nuser tools.</p>\n<blockquote>\n<ul>\n<li>Declare a term to the context before calling a proof tool.</li>\n</ul>\n</blockquote>\n<p>Always do that, explicitly or implicitly via other operations that<br>\nensure that terms become \"part of the context\" in the proper way. This<br>\nis avtually the main conclusion of this thread.</p>\n<blockquote>\n<p>Does not simplify to True</p>\n<p>declare [[linarith_trace=true]]<br>\nML_val ‹<br>\nval ct = @{cterm \"b (0::nat) + (a::int) ≤ n ⟹ b 0 + a ≤ n + 1\"}<br>\nval test = Simplifier.asm_full_rewrite @{context} ct<br>\n›</p>\n<p>Diagnoses with ‹linarith_trace› reveals that linarith accidently (re)uses variable name \"a\" <br>\nas \"fresh\" name for @{term \"b 0\"} which in turn makes the proof fail as it collides with the <br>\nalready present free variable \"a\".</p>\n<p>My guess (without inspecting the actual code) is, that linarith creates new variable names merely <br>\nrefering to the context, e.g. with @{ML Variable.variant_fixes} without additionally considering the <br>\nfree (and not fixed) variables in the present term, e.g. with @{ML Term.variant_frees}.</p>\n</blockquote>\n<p>The \"refering to the context\" to create new variables is correct. The<br>\n\"merely\" wording reveals a wrong (outdated) understanding how things<br>\nwork. All terms participating in manipulations by proof tools need to be<br>\nformally part of the context. It is neither efficient nor sufficient to<br>\nre-inspect e.g. a goal state -- like was done routinely many years.</p>\n<blockquote>\n<p>Actually, just declaring the term already has the desired effect.</p>\n<p>ML_val ‹<br>\nval ctxt0 = @{context};<br>\nval t = Syntax.read_term ctxt0 \"b (0::nat) + (a::int) ≤ n ⟹ b 0 + a ≤ n + 1\";<br>\nval ctxt1 = ctxt0 |&gt; Variable.declare_term t;<br>\nval ct = Thm.cterm_of ctxt1 t;<br>\nval test = Simplifier.asm_full_rewrite ctxt1 ct;<br>\n›</p>\n</blockquote>\n<p>That is the standard approach, but note that the Syntax.read_term<br>\ninvocation is only correct by accident in this example. In general the<br>\nlocal variables a, b would have to be somehow reserved in the context<br>\nbeforehand, e.g. via Variable.add_fixes. Some newer tools also have a<br>\nconvenient 'for' notation for that (e.g. proof method \"ind_cases\" in<br>\nIsabelle/HOL). You probably won't need that technique right now, but<br>\nknowing it in advance can avoid many old problems from 20 years ago.</p>\n<p>Makarius</p>",
        "id": 294764529,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661201296
    }
]