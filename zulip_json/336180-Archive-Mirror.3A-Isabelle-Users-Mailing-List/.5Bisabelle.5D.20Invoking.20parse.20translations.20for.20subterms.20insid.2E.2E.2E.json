[
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nDear Isabelle Gurus,</p>\n<p>I am doing a tricky parse_translation where the term I substitute in <br>\ndepends on the type of the left-hand-side term that gets passed into the <br>\ntranslation.</p>\n<p>E.g. (p :: struct_s1 pptr) &amp;-&gt; ''z''<br>\n      becomes struct_s1_field_z :: \"struct_s1 pptr =&gt; 32 word pptr\"<br>\n      but<br>\n      (p :: struct_s2 pptr) &amp;-&gt; ''x''<br>\n      becomes struct_s2_field_x :: \"struct_s2 pptr =&gt; struct_s1 pptr\"</p>\n<p>This means that in my parse_translation I need to type-check the LHS <br>\nterm, and I'd also like to get at the string on the right-hand side.</p>\n<p>I've got all the underlying infrastructure and examples working, but I <br>\nreally, really need to invoke the parse translation mechanism for my LHS <br>\nsubterm (to figure out the pointer type) and to be able to call <br>\nHOLogic.dest_string on my RHS.</p>\n<p>Otherwise I get something like (for example):<br>\n    Const (\"\\\\&lt;^const&gt;Pointers.addr_add\", \"_\") $ Free (\"p\", \"_\") $<br>\n      Const (\"\\\\&lt;^const&gt;HOL.one_class.one\", \"_\")<br>\n    : term<br>\nor<br>\n    Const (\"_constrain\", \"_\") $ Free (\"p\", \"_\") $<br>\n      (Free (\"pptr\", \"_\") $ Free (\"struct_s1\", \"_\"))<br>\n    : term</p>\n<p>Needless to say, passing these to read_term won't work as they're not <br>\nstrings, passing them to check_term will fail because those constants <br>\naren't real constants (e.g. \"_constrain\" is not a constant).</p>\n<p>So what do I pass them to such that it figures out the syntax and gives <br>\nme back a term I can either use or pass into check_term with dummy types?</p>\n<p>My actual syntax is:<br>\nsyntax<br>\n   \"_struct_get_field\" :: \"('v, 'p, 't) ptr_t ⇒ string ⇒ ('v, 'p, 't2) <br>\nptr_t\"<br>\n   (infixl \"&amp;→\" 51)</p>\n<p>I've been looking through the code for a few hours. I've also looked at <br>\nthe \"alternative\" mechanism of Syntax.add_term_check, but I can't figure <br>\nout how to use it to do what I want. I don't think any documentation for <br>\nit exists. Perhaps someone's scribbled some notes on it?</p>\n<p>As this relates to my PhD, which is on a tighter schedule than my other <br>\nwork, I'd really appreciate hints towards a practical solution rather <br>\nthan an elegant/generic one. I hope I'm just missing something obvious <br>\nrather than doing it all wrong.</p>\n<p>Does anyone have any advice?</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294124116,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840754
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nDear All,</p>\n<p>It turns out I was missing something simple. I finally tracked down a <br>\nfunction called ProofContext.decode_term. It turns out that this <br>\nfunction converts the \"syntactic-style\" term I've been having trouble <br>\nwith into one that can be passed to Syntax.check_term to get a properly <br>\ntyped term.</p>\n<p>So, here's a \"before\" term:<br>\n  Const (\"_constrain\", \"_\") $ Free (\"p\", \"_\") $<br>\n    (Free (\"pptr\", \"_\") $ Free (\"struct_s1\", \"_\"))</p>\n<p>(note that _constrain is not a constant)</p>\n<p>and here it is after passing it through ProofContext.decode:<br>\n    Const (\"_type_constraint_\",<br>\n           \"StructExample.struct_s1 TypedHeap.pptr<br>\n            ⇒ StructExample.struct_s1 TypedHeap.pptr\") $<br>\n      Free (\"p\", \"_\")</p>\n<p>Note that all constants are now identified by their proper names, so <br>\nSyntax.check_term can deal with them.</p>\n<p>Perhaps my discovery will be of service to someone else in the future.</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294124124,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840759
    }
]