[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I work with limited knowledge, so if I stumble onto something useful <br>\nthen I resort to it a lot.</p>\n<p>I've resorted a lot to wrapping a type in a datatype to be able to <br>\ninstantiate the type with type classes.</p>\n<p>This question is about \"bool list\" in particular, but it's also of <br>\ninterest to me in general.</p>\n<p>What I have is \"bool list\" in a 1-1 relation with non-zero nat, but I <br>\ndon't use it directly. I put it in a datatype like this:</p>\n<p>datatype_new boD = bo_C \"bool list\"</p>\n<p>I did that in the past because:</p>\n<p>1) I didn't know how to do what has now come to my mind,</p>\n<p>2) but also, I thought that doing such a thing would be hijacking \"list\".</p>\n<p>I have a type class, which I eventually will want to prove some things <br>\nabout:</p>\n<p>class binc =<br>\n     fixes binc :: \"'a =&gt; 'a\"</p>\n<p>This is a binary increment function, which for \"bool list\" is in this <br>\ninstantiation, for the moment:</p>\n<p>instantiation list :: (\"{complete_boolean_algebra, linorder}\") binc<br>\n   begin<br>\n   primrec binc_list :: \"bool list =&gt; bool list\" where<br>\n     \"binc_list []       = False # []\"<br>\n    |\"binc_list (b # bl) = (if b = False then True # bl else False # <br>\n(binc_list bl))\"<br>\n   instance ..<br>\n   end</p>\n<p>I got that idea from the increment function in Num.thy.</p>\n<p>The part of instantiating \"bool list\" that was foggy for me was the idea <br>\nthat I needed to find a bunch of type classes which \"bool\" satisfies. <br>\nThe light bulb finally turned on.</p>\n<p>For the above, I executed \"print_classes\" and found that \"bool\" had been <br>\ninstantiated for 42 type classes. I picked the two above with the idea <br>\nthat I need type classes that will give \"bool list\" enough properites of <br>\n\"nat\" to prove what I need. Those looked like a good start.</p>\n<p>Is instantiating \"list\" like this a bad thing in general?</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294307648,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924840
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gottfried,</p>\n<p>On 08/09/14 08:00, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I work with limited knowledge, so if I stumble onto something useful then I resort to it a<br>\nlot.</p>\n<p>I've resorted a lot to wrapping a type in a datatype to be able to instantiate the type<br>\nwith type classes.</p>\n<p>This question is about \"bool list\" in particular, but it's also of interest to me in general.</p>\n<p>What I have is \"bool list\" in a 1-1 relation with non-zero nat, but I don't use it<br>\ndirectly. I put it in a datatype like this:</p>\n<p>datatype_new boD = bo_C \"bool list\"</p>\n<p>I did that in the past because:</p>\n<p>1) I didn't know how to do what has now come to my mind,</p>\n<p>2) but also, I thought that doing such a thing would be hijacking \"list\".</p>\n<p>I have a type class, which I eventually will want to prove some things about:</p>\n<p>class binc =<br>\n     fixes binc :: \"'a =&gt; 'a\"</p>\n<p>This is a binary increment function, which for \"bool list\" is in this instantiation, for<br>\nthe moment:</p>\n<p>instantiation list :: (\"{complete_boolean_algebra, linorder}\") binc<br>\n   begin<br>\n   primrec binc_list :: \"bool list =&gt; bool list\" where<br>\n     \"binc_list []       = False # []\"<br>\n    |\"binc_list (b # bl) = (if b = False then True # bl else False # (binc_list bl))\"<br>\n   instance ..<br>\n   end<br>\nThis will not work the way you expect. To make the list type an instance of binc, you have <br>\nto do this for lists of arbitrary elements of the assumed sort <br>\n(\"{complete_boolean_algebra, linorder}\" in this example), not for a specific type bool. As <br>\nit is now, you define a function binc_list which is completely unrelated to binc. You will <br>\nrealise this at the latest when you introcude some assumptions about binc and are unable <br>\nto prove them for your attempted instantiation.</p>\n</blockquote>\n<p>Note that if you replace False by bot and True by top, then your definition should <br>\ngeneralise to 'a :: {complete_boolean_algebra, linorder}.</p>\n<blockquote>\n<p>Is instantiating \"list\" like this a bad thing in general?<br>\nIf you define your own type classes and instantiate them for list, that is all right. <br>\nHowever, you should be very careful when you instantiate list for type classes of HOL/Main <br>\nor other people, because this may restrict the interoperability with the formalisations of <br>\nothers, as type classes may only be instantiated once for each type in one session.</p>\n</blockquote>\n<p>Andreas</p>",
        "id": 294307670,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924846
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nOn 14-09-08 01:33, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>This will not work the way you expect. To make the list type an <br>\ninstance of binc, you have to do this for lists of arbitrary elements <br>\nof the assumed sort (\"{complete_boolean_algebra, linorder}\" in this <br>\nexample), not for a specific type bool. As it is now, you define a <br>\nfunction binc_list which is completely unrelated to binc. You will <br>\nrealise this at the latest when you introcude some assumptions about <br>\nbinc and are unable to prove them for your attempted instantiation.</p>\n<p>Note that if you replace False by bot and True by top, then your <br>\ndefinition should generalise to 'a :: {complete_boolean_algebra, <br>\nlinorder}.</p>\n</blockquote>\n<p>Andreas,</p>\n<p>Thanks. Abstract thinking, it can incapacitate a majority of neurons. In <br>\nthis case, among other reasons, because my goal wasn't to generalize <br>\nanything for \"list\".</p>\n<p>The syntax 'instantiation list :: (\"{......}\") binc ' required one or <br>\nmore type classes between the braces, so I was trying to make it <br>\nconcrete as possible for \"bool\", instead of abstract as possible for \"'a <br>\nlist\".</p>\n<p>So now, using your tip, I've generalized it for \"list\" with the minimum <br>\nrequirements:</p>\n<p>instantiation list :: (\"{bot,top}\") binc<br>\nbegin<br>\nprimrec binc_list :: \"'a list â‡’ 'a list\" where<br>\n\"binc_list [] = bot # []\"<br>\n|\"binc_list (b # bl) = (if b = bot then top # bl else bot # (binc_list bl))\"<br>\ninstance ..<br>\nend</p>\n<p>I make \"binc\" a syntactic type class, and I guess in future, if I build <br>\non that with \"assumes\" in type classes designed for my other concrete <br>\ndatatypes, I then should try to figure if my assumptions are applicable <br>\nto \"'a list\".</p>\n<blockquote>\n<blockquote>\n<p>Is instantiating \"list\" like this a bad thing in general?<br>\nIf you define your own type classes and instantiate them for list, <br>\nthat is all right. However, you should be very careful when you <br>\ninstantiate list for type classes of HOL/Main or other people, because <br>\nthis may restrict the interoperability with the formalisations of <br>\nothers, as type classes may only be instantiated once for each type in <br>\none session.</p>\n</blockquote>\n</blockquote>\n<p>Specifically, I wanted to decide if I could instantiate \"list\" for <br>\n\"numeral\", to get the convenience of using standard number syntax with <br>\n\"bool list\", since it's 1-to-1 with non-zero nat, but I had the right, <br>\nfoggy idea to begin with, that I shouldn't be hijacking \"list\" like that.</p>\n<p>So, I think the answer is that I can instantiate \"list\" for my own <br>\nsyntactic type classes, but I should rarely, if ever, instantiate a <br>\ngeneral HOL type for any general HOL type class.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294307753,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924871
    }
]