[
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Isabelle/ML experts,</p>\n<p>Suppose I have a function/constant in Isabelle/ML:</p>\n<p>ML {*<br>\nval f:term -&gt; term = (fn x =&gt; x);<br>\n*}</p>\n<p>I was wondering if I can somehow access it in the top level. That is, I <br>\nwish I could define a function based on f:</p>\n<p>definition \"foo x=f x\" (<em>not working yet</em>)</p>\n<p>I know we can do similar things with theorem:</p>\n<p>ML {*<br>\n   ML_Thms.bind_thm(\"foo\",@{thm exI});<br>\n*}<br>\nthm foo</p>\n<p>In fact, this question is a follow-up question to my previous query:</p>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-April/msg00102.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-April/msg00102.html</a></p>\n<p>where I want to use a piece of untrusted code (in Isabelle/ML probably) <br>\nto compute some untrusted but verifiable results. In order to verify and <br>\nuse such results, I may need to extract them from the Isabelle/ML level <br>\nto the top level.</p>\n<p>Any help is greatly appreciated,<br>\nWenda</p>",
        "id": 294652120,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166518
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda,</p>\n<p>There is no official support for this, but two months ago, Lars Hupel implemented a sketch <br>\nof what might be useful for you. Have a look:</p>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-June/msg00076.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-June/msg00076.html</a></p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294652144,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166530
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Andreas,</p>\n<p>Many thanks for referring me to Lars Hupel' wonderful SPLICE technique! <br>\nIt did seem quite relevant in my situation. However, it seems that the <br>\nSPLICE can only embed \"static\" code (I am not sure if my description is <br>\naccurate or not) in Isabelle/ML to the top level. For example,</p>\n<p>theory Scratch4 imports<br>\n   Main<br>\n   \"Splice/Splice\"<br>\nbegin</p>\n<p>ML {*<br>\nval g:int -&gt; int = (fn x =&gt; x+2);</p>\n<p>fun g1 (x:term): term = (if is_Bound x then x else g <br>\n(HOLogic.dest_number x |&gt; snd) |&gt; HOLogic.mk_number @{typ int}) ;</p>\n<p>fun g2 (x:term):term  =  Const (\"<a href=\"http://Groups.plus_class.plus\">Groups.plus_class.plus</a>\", @{typ \"int ⇒ <br>\nint ⇒ int\"}) $ x $ @{term \"2::int\"};</p>\n<p>*}</p>\n<p>definition \"foo= (λx. SPLICE  ‹g2 (Bound 0)›)\"</p>\n<p>print_theorems (<em>foo_def: foo = (λx. x + 2)</em>)</p>\n<p>definition \"foo'= (λx. SPLICE  ‹g1 (Bound 0)›)\"</p>\n<p>print_theorems (<em>foo'_def: foo' = (λx. x)</em>)</p>\n<p>end</p>\n<p>what I want is to access the computation by g in the top level. <br>\nCurrently, I can only do it by explicitly constructing computations in g <br>\nusing constants (i.e. g2 and foo), while what I really wish is to access <br>\nresults computed by g without knowing how they are computed (i.e. g1 and <br>\nfoo'). Unfortunately, foo and foo' are not equivalent yet.</p>\n<p>My whole idea is to compute something externally (in Isabelle/ML or even <br>\na program written in C), and then verify and port the result back to the <br>\ntop level. Of course, I can hard-code the whole computation in the top <br>\nlevel (with definition/fun/function) without proving anything, but I <br>\nfeel it may not be necessary.</p>\n<p>Again any suggestion is highly appreciated,<br>\nWenda</p>",
        "id": 294652196,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166561
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe use of the word \"top level\" is very strange.  Maybe you just mean the <br>\nmaterial you can put into an Isabelle theory document, between the \"theory <br>\n... begin\" and \"end\".  That language is called \"Isabelle/Isar outer <br>\nsyntax\", but it merely means you can put arbitrary commands there that are <br>\nultimately defined somewhere in Isabelle/ML. Command like 'definition' or <br>\n'theorem' are also defined as such -- this can be proven in Isabelle/jEdit <br>\nvia C-hover-click on the keywords.</p>\n<p>Since the 'ML' command is of the same kind, the easyiest answer to your <br>\nquestion is to use that to evaluate ML expressions in Isabelle/Isar <br>\nsource.  That gives you values in the ML environment.</p>\n<p>I guess that your actual question is: \"How do I get values produced in <br>\nIsabelle/ML into the Isabelle/HOL logic?\"  Since ML can control the logic, <br>\nbut not the other way round, the standard approach is the use ML to set up <br>\na logical statement (and prove it) on demand.</p>\n<p>Here it is usually possible to split the problem into two parts: the <br>\nharder one to find a solution (outside the logic) and the easier one to <br>\nestablish a desired property of it (within the logic).</p>\n<p>You can also produce the ML code in creative ways, e.g. from HOL <br>\nspecifications via the code generator.</p>\n<p>Makarius</p>",
        "id": 294652214,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166568
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Makarius and code generation experts,</p>\n<p>Thanks for pointing out my inaccuracies, it is always good to know ways <br>\nto polish my questions.</p>\n<p>In terms of my question -- \"How do I get values produced in Isabelle/ML <br>\ninto the Isabelle/HOL logic?\", my current try is through some code <br>\ngeneration setups. That is, to declare a function constant, and manually <br>\nlink some ML code to it. Since this function constant is not associated <br>\nwith any theorem, whatever code we are linking to it should not <br>\nintroduce inconsistencies to the logic.</p>\n<p>Here is what I have got so far,</p>\n<p>theory Scratch4 imports<br>\n   Main<br>\nbegin</p>\n<p>consts double ::\"int ⇒ int\"</p>\n<p>code_printing code_module \"Untrusted\" ⇀ (SML)<br>\n{*structure Bar : sig<br>\n   val double' : int -&gt; int;<br>\nend = struct<br>\n   fun double' n = n+n;<br>\nend<br>\n*}</p>\n<p>code_printing constant double ⇀ (SML) \"Bar.double'\"</p>\n<p>export_code double in SML module_name Foo</p>\n<p>(*does not work because the native int type is different from the <br>\ngenerated int type *)<br>\nvalue [code] \"double 3\"</p>\n<p>end</p>\n<p>This is not work yet, as code_printing may not work the way I am using <br>\nit. I was wondering if it is possible to make my idea (i.e. declaring a <br>\nconstant and manually linking some ML code to it) work?</p>\n<p>Again any help is greatly appreciated,<br>\nWenda</p>",
        "id": 294652269,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166597
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda,</p>\n<p>Unfortunately, there is no good theory so far to back up code_printing. So whatever you do <br>\nwith code_printing, you yourself have to convince yourself that what you are doing is sound.</p>\n<p>I still have not found out what you want to achieve in the end. I will nevertheless try to <br>\nprovide a few hints:</p>\n<ol>\n<li>\n<p>Suppose you (1) declare an unspecified constant foo with consts, (2) never define the <br>\nconstant foo, and (3) set up code_printing for foo to some function foo' in SML. If (a) <br>\nfoo' is referentially transparent (i.e., no side effects, no access to mutable state) and <br>\n(b) the return type of foo is not a code_abstype and (c) the argument types of foo have <br>\nnot been refined during code generation, then you are pretty safe that Isabelle's logic is <br>\nstill consistent. The reasoning goes as follows: If you do not define the constant, all <br>\nyou know about the constant is its type. Thus, by refinement, you can replace it with any <br>\nreferentially-transparent function during code generation. Referential transparency <br>\nensures that two calls with the same arguments always return the same value. Thus, <br>\nevaluation cannot falsify equations like \"foo 17 = foo 17\". Due to the transformations in <br>\nthe code generator, code_abstype return types are not safe by default. They are OK <br>\nprovided that the function foo' returns only those values that satisfy the invariant I of <br>\nthe abstract type. Otherwise, you could falsify the theorem \"I (Rep_type (foo 17))\". If <br>\nthe argument types have been refined, your function has to ensure that it respects the <br>\nabstraction. For example, you could declare</p>\n<p>to_list :: \"'a set =&gt; 'a list\"</p>\n</li>\n</ol>\n<p>and implement it in SML as</p>\n<p>\"fun to_list (Set.set xs) = xs\"</p>\n<p>Then, you could prove  \"to_list {1, 2} ~= to_list {2, 1}\", which is obviously false as <br>\n{1,2} = {2,1} in HOL.</p>\n<ol start=\"2\">\n<li>\n<p>If any of these conditions are not satisfied, you yourself have to see whether <br>\neverything stays sound. In particular, as soon as you specify the constant foo somehow, <br>\nyou have to be very careful. My AFP entry Native_Words is full of code_printing statements <br>\nfor such cases, and I spent a lot of thought on making sure that I do not introduce <br>\ninconsistencies. As we do not have a formal model of code generation, only a certain level <br>\nof confidence can be provided (by inspection and testing), but never a rigorous proof.</p>\n</li>\n<li>\n<p>From your previous mails, I had the impression that you wanted to compute results in <br>\nuntrusted code and then use them back in HOL after checking their correctness. This is <br>\npossible with the above approach of declaring an unspecified constant, binding it to some <br>\nSML code (subject to the above restrictions), and checking the result. The code equation <br>\ncould look as follows:</p>\n</li>\n</ol>\n<p>lemma [code]:<br>\n   \"bar x =<br>\n   (let r = foo x<br>\n    in if check x r then r else Code.abort (STR ''Error in result of foo'') (%_. bar x))\"</p>\n<p>If the check function imposes sufficiently many checks, you can prove this lemma without <br>\nknowing anything about foo.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294652357,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166622
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Wenda,</p>\n<blockquote>\n<p>Many thanks for referring me to Lars Hupel' wonderful SPLICE technique!<br>\nIt did seem quite relevant in my situation. However, it seems that the<br>\nSPLICE can only embed \"static\" code (I am not sure if my description is<br>\naccurate or not) in Isabelle/ML to the top level.</p>\n</blockquote>\n<p>Your observation is accurate. I was meaning to reply to Andreas' mail, but<br>\nforgot.</p>\n<blockquote>\n<p>what I want is to access the computation by g in the top level.<br>\nCurrently, I can only do it by explicitly constructing computations in g<br>\nusing constants (i.e. g2 and foo), while what I really wish is to access<br>\nresults computed by g without knowing how they are computed (i.e. g1 and<br>\nfoo'). Unfortunately, foo and foo' are not equivalent yet.</p>\n</blockquote>\n<p>The short answer here is that what you want to do is impossible with<br>\n'SPLICE' or similar techniques. It is impossible to refer to dynamic ML<br>\ncomputations in the Isabelle term language. Imagine if it were possible:<br>\nFor the example you've shown, that would also mean that the proof kernel<br>\nwould need to be able to execute arbitrary ML functions in order to<br>\nperform reductions.</p>\n<blockquote>\n<p>My whole idea is to compute something externally (in Isabelle/ML or even<br>\na program written in C), and then verify and port the result back to the<br>\ntop level. Of course, I can hard-code the whole computation in the top<br>\nlevel (with definition/fun/function) without proving anything, but I<br>\nfeel it may not be necessary.</p>\n</blockquote>\n<p>I'm not sure what you mean with \"hard coding\". There is no necessity to<br>\nwrite the Isar specification by hand. As Makarius pointed out, the general<br>\ntechnique is to not just write ML code which computes the values you are<br>\ninterested in, but also ML code which \"lifts\" those values into the \"logic<br>\nlanguage\". For example, you can write a piece of ML code which proves a<br>\nlemma or which specifies a function. (One could say that \"ML is the<br>\nscripting language of Isabelle\" -- although this is not entirely<br>\naccurate.)</p>\n<p>However, this will still not allow you to prove results about dynamic ML<br>\nfunction executions. Defining your function in HOL and then using the code<br>\ngenerator is in my opinion the preferable way.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294652371,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166628
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Andreas and Lars,</p>\n<p>I am so grateful to have your feedback, from which I have learnt a lot. <br>\nAnd also I do apologize for any of my previous inaccuracies that caused <br>\nconfusions.</p>\n<blockquote>\n<ol start=\"3\">\n<li>From your previous mails, I had the impression that you wanted to<br>\ncompute results in untrusted code and then use them back in HOL after<br>\nchecking their correctness. This is possible with the above approach<br>\nof declaring an unspecified constant, binding it to some SML code<br>\n(subject to the above restrictions), and checking the result. The code<br>\nequation could look as follows:</li>\n</ol>\n<p>lemma [code]:<br>\n  \"bar x =<br>\n  (let r = foo x<br>\n   in if check x r then r else Code.abort (STR ''Error in result of<br>\nfoo'') (%_. bar x))\"</p>\n<p>If the check function imposes sufficiently many checks, you can prove<br>\nthis lemma without knowing anything about foo.</p>\n</blockquote>\n<p>This is exactly what I want to achieve in the end! Suppose the check <br>\nfunction is strong enough, I can define foo in an arbitrary way and <br>\nstill prove this lemma (i.e. \"without knowing anything about foo\"). One <br>\nway to implement foo is of course, as suggested by Lars, to define it <br>\nwithin the Isabelle/HOL logic: we can have something like:</p>\n<p>fun foo x = ...</p>\n<p>in the Isabelle/Isar source, and the code generator will do the job. <br>\nHowever, suppose the computation performed by foo is complicated and <br>\nthere exists highly efficient external tools (e.g. Z3) that implement <br>\nfoo, it might be more appealing to use (after checking) results returned <br>\nby external tools rather than re-implementing an almost-certainly-slower <br>\nfoo in Isabelle/Isar (though we don't need to worry about the proofs).</p>\n<blockquote>\n<p>This is possible with the above approach<br>\nof declaring an unspecified constant, binding it to some SML code<br>\n(subject to the above restrictions), and checking the result.</p>\n</blockquote>\n<p>This is what I want to do in the first step. What I don't know is how to <br>\ndo the \"binding\" step, and code_printing in my previous email is just <br>\none attempt to achieve this.</p>\n<blockquote>\n<p>For example, you could declare</p>\n<p>to_list :: \"'a set =&gt; 'a list\"</p>\n<p>and implement it in SML as</p>\n<p>\"fun to_list (Set.set xs) = xs\"</p>\n<p>Then, you could prove  \"to_list {1, 2} ~= to_list {2, 1}\", which is<br>\nobviously false as {1,2} = {2,1} in HOL.</p>\n</blockquote>\n<p>This example makes perfect sense to me now and it really didn't occur to <br>\nme before. Thanks for such a wonderful example!</p>\n<p>Overall, the whole idea is just an exploration. If it really does not <br>\nwork, I can go back to my original plan (i.e. the way Lars suggested).</p>\n<p>Again any idea from the list is greatly appreciated,<br>\nWenda</p>",
        "id": 294652396,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166640
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda,</p>\n<p>On 17/08/15 15:46, Wenda Li wrote:</p>\n<blockquote>\n<p>Dear Andreas and Lars,</p>\n<p>I am so grateful to have your feedback, from which I have learnt a lot. And also I do<br>\napologize for any of my previous inaccuracies that caused confusions.</p>\n<blockquote>\n<ol start=\"3\">\n<li>From your previous mails, I had the impression that you wanted to<br>\ncompute results in untrusted code and then use them back in HOL after<br>\nchecking their correctness. This is possible with the above approach<br>\nof declaring an unspecified constant, binding it to some SML code<br>\n(subject to the above restrictions), and checking the result. The code<br>\nequation could look as follows:</li>\n</ol>\n<p>lemma [code]:<br>\n  \"bar x =<br>\n  (let r = foo x<br>\n   in if check x r then r else Code.abort (STR ''Error in result of<br>\nfoo'') (%_. bar x))\"</p>\n<p>If the check function imposes sufficiently many checks, you can prove<br>\nthis lemma without knowing anything about foo.</p>\n</blockquote>\n<p>This is exactly what I want to achieve in the end! Suppose the check function is strong<br>\nenough, I can define foo in an arbitrary way and still prove this lemma (i.e. \"without<br>\nknowing anything about foo\"). One way to implement foo is of course, as suggested by Lars,<br>\nto define it within the Isabelle/HOL logic: we can have something like:</p>\n<p>fun foo x = ...</p>\n<p>in the Isabelle/Isar source, and the code generator will do the job. However, suppose the<br>\ncomputation performed by foo is complicated and there exists highly efficient external<br>\ntools (e.g. Z3) that implement foo, it might be more appealing to use (after checking)<br>\nresults returned by external tools rather than re-implementing an almost-certainly-slower<br>\nfoo in Isabelle/Isar (though we don't need to worry about the proofs).<br>\nIf you define foo in HOL and generate the code for foo, there is not much point in using a <br>\nchecker function. If you define foo in HOL and serialise it to some other hand-written ML <br>\nfunction, getting this right is actually more difficult than if there was no definition of <br>\nfoo in HOL (because you additionally have to make sure that the HOL definition agrees with <br>\nthe SML implementation). Having an undefined constant is fine.</p>\n</blockquote>\n<blockquote>\n<p>This is what I want to do in the first step. What I don't know is how to do the \"binding\"<br>\nstep, and code_printing in my previous email is just one attempt to achieve this.<br>\nI suggest that you have a look at the AFP entry Native_Word. It contains a lot of <br>\nnon-trivial code printing examples, also in combination with integers. You might also want <br>\nto have a look at my TLS paper from last year's Isabelle workshop [1]. Section 4 discusses <br>\nthe issues a bit. If you want to use types for exchanging data between generated code and <br>\nhand-written or library code, you have to use the types for data exchange. In <br>\nIsabelle/HOL, they are unit, bool, a * b, a + b, a option, integer and natural. I.e., you <br>\nshould convert your \"int\"s to \"integer\" first. Again, lots of examples are in the <br>\nNative_Word entry.</p>\n</blockquote>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>[1] <br>\n<a href=\"http://www.infsec.ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/information-security-group-dam/people/andreloc/lochbihler14iw.pdf\">http://www.infsec.ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/information-security-group-dam/people/andreloc/lochbihler14iw.pdf</a></p>\n<blockquote>\n<blockquote>\n<p>For example, you could declare</p>\n<p>to_list :: \"'a set =&gt; 'a list\"</p>\n<p>and implement it in SML as</p>\n<p>\"fun to_list (Set.set xs) = xs\"</p>\n<p>Then, you could prove  \"to_list {1, 2} ~= to_list {2, 1}\", which is<br>\nobviously false as {1,2} = {2,1} in HOL.</p>\n</blockquote>\n<p>This example makes perfect sense to me now and it really didn't occur to me before. Thanks<br>\nfor such a wonderful example!</p>\n<p>Overall, the whole idea is just an exploration. If it really does not work, I can go back<br>\nto my original plan (i.e. the way Lars suggested).</p>\n<p>Again any idea from the list is greatly appreciated,<br>\nWenda<br>\n</p>\n</blockquote>",
        "id": 294652414,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166647
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Andreas,</p>\n<p>Many thanks for such a wonderful paper! The discussion about foreign <br>\nfunction interface in the paper is super useful to me. I finally got my <br>\nproblem solved.</p>\n<p>Wenda</p>",
        "id": 294652431,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166653
    }
]