[
    {
        "content": "<p>From: Denis Nikiforov &lt;<a href=\"mailto:denis.nikif@gmail.com\">denis.nikif@gmail.com</a>&gt;<br>\nHi</p>\n<p>Could someone provide an example of denotational semantics of a simple<br>\nprograming language defined via HOLCF? For example, \"Denotational Sematics\"<br>\nby David A. Schmidt contains very good examples. I'm trying to implement<br>\nthem in HOLCF and I stuck at the begining. I've read HOLCF tutorial but<br>\nit's too brief. Brian Huffman's dissertation is too complex for me. I think<br>\nthat an example of application of HOLCF to simple programming languages<br>\nfrom D. Schmidt's book or something like this would be very helpful for<br>\nnewbies like me.</p>",
        "id": 294708692,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181452
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nDenis,</p>\n<p>There is my PCF entry in the AFP:</p>\n<p><a href=\"https://www.isa-afp.org/entries/PCF.shtml\">https://www.isa-afp.org/entries/PCF.shtml</a> &lt;<a href=\"https://www.isa-afp.org/entries/PCF.shtml\">https://www.isa-afp.org/entries/PCF.shtml</a>&gt;</p>\n<p>The language is simple, but I’m not sure anything else is. :-)</p>\n<p>Also if you dig through the HOLCF directory in the Isabelle distribution, there are some classical examples like streams and while loops.</p>\n<p>cheers,<br>\npeter</p>\n<p>— <br>\n<a href=\"http://peteg.org/\">http://peteg.org/</a></p>",
        "id": 294708706,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181456
    },
    {
        "content": "<p>From: Denis Nikiforov &lt;<a href=\"mailto:denis.nikif@gmail.com\">denis.nikif@gmail.com</a>&gt;<br>\nPeter,</p>\n<p>Thanks for advice! I'm trying to understand your example. You can see my<br>\nsimple language below.<br>\nThe problem is that when I try to evaluate expressions via dval function<br>\n(see 2 last lines in the theory) I get the following error:</p>\n<p>Wellsortedness error<br>\n(in code equation u_map ≡ Λ f. fup⋅(up oo f),<br>\nwith dependency \"Pure.dummy_pattern\" -&gt; \"dval\" -&gt; \"ValD\" :: \"domain\" -&gt;<br>\n\"ValD\" :: \"predomain\" -&gt; \"ValD\" :: \"predomain_syn\" -&gt; \"liftemb [ValD]\" -&gt;<br>\n\"u_map\"):<br>\nType 'b⇩⊥ not of sort {enum,pcpo}<br>\nNo type arity u :: enum</p>\n<p>Could someone explain what's the problem?</p>\n<p>theory Arithm4<br>\n  imports<br>\n    HOLCF<br>\n    \"~~/src/HOL/HOLCF/Library/Nat_Discrete\"<br>\nbegin</p>\n<p>type_synonym var = nat<br>\ntype_synonym Var = var<br>\ntype_synonym 'a Env = \"Var → 'a\"</p>\n<p>definition env_empty :: \"'a Env\" where<br>\n\"env_empty ≡ ⊥\"</p>\n<p>definition env_ext :: \"Var → 'a → 'a Env → 'a Env\" where<br>\n\"env_ext ≡ Λ v x ρ v'. if v = v' then x else ρ ⋅ v'\"</p>\n<p>domain ValD = ValFF | ValTT</p>\n<p>datatype exp = Let var ValD exp | Var var | And exp exp</p>\n<p>type_synonym EnvD = \"ValD Env\"</p>\n<p>fixrec dand :: \"ValD → ValD → ValD\" where<br>\n  \"dand ⋅ ValTT ⋅ ValTT = ValTT\"<br>\n| (unchecked) \"b ≠ ⊥ ⟹ dand ⋅ ValFF ⋅ b = ValFF\"<br>\n| (unchecked) \"a ≠ ⊥ ⟹ dand ⋅ a ⋅ ValFF = ValFF\"</p>\n<p>primrec dval :: \"exp ⇒ EnvD → ValD\" where<br>\n  \"dval (Let var val exp) = (Λ e. dval exp ⋅ (env_ext ⋅ var ⋅ val ⋅ e))\"<br>\n| \"dval (Var var) = (Λ e. e ⋅ var)\"<br>\n| \"dval (And a b) = (Λ e. dand ⋅ (dval a ⋅ e) ⋅ (dval b ⋅ e))\"</p>\n<p>value \"dval (Let 1 ValFF (Let 2 ValTT (And (Var 1) (Var 2)))) ⋅ env_empty\"<br>\nvalue \"dval (Var 1)\"</p>\n<p>end</p>",
        "id": 294708958,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181523
    },
    {
        "content": "<p>From: Denis Nikiforov &lt;<a href=\"mailto:denis.nikif@gmail.com\">denis.nikif@gmail.com</a>&gt;<br>\nPeter</p>\n<p>Oops, it seems that the mailing list doesn't support unicode. Here is<br>\nan ASCII version:</p>\n<p>Thanks for advice! I'm trying to understand your example. You can see<br>\nmy simple language below.<br>\nThe problem is that when I try to evaluate expressions via dval<br>\nfunction (see 2 last lines in the theory) I get the following error:</p>\n<p>Wellsortedness error<br>\n(in code equation u_map ≡ Λ f. fup⋅(up oo f),<br>\nwith dependency \"Pure.dummy_pattern\" -&gt; \"dval\" -&gt; \"ValD\" :: \"domain\"<br>\n-&gt; \"ValD\" :: \"predomain\" -&gt; \"ValD\" :: \"predomain_syn\" -&gt; \"liftemb<br>\n[ValD]\" -&gt; \"u_map\"):<br>\nType 'b⇩⊥ not of sort {enum,pcpo}<br>\nNo type arity u :: enum</p>\n<p>Could someone explain what's the problem?</p>\n<p>theory Arithm4<br>\n  imports<br>\n    HOLCF<br>\n    \"~~/src/HOL/HOLCF/Library/Nat_Discrete\"<br>\nbegin</p>\n<p>type_synonym var = nat<br>\ntype_synonym Var = var<br>\ntype_synonym 'a Env = \"Var \\&lt;rightarrow&gt; 'a\"</p>\n<p>definition env_empty :: \"'a Env\" where<br>\n\"env_empty \\&lt;equiv&gt; \\&lt;bottom&gt;\"</p>\n<p>definition env_ext :: \"Var \\&lt;rightarrow&gt; 'a \\&lt;rightarrow&gt; 'a Env<br>\n\\&lt;rightarrow&gt; 'a Env\" where<br>\n\"env_ext \\&lt;equiv&gt; \\&lt;Lambda&gt; v x \\&lt;rho&gt; v'. if v = v' then x else<br>\n\\&lt;rho&gt; \\&lt;cdot&gt; v'\"</p>\n<p>domain ValD = ValFF | ValTT</p>\n<p>datatype exp = Let var ValD exp | Var var | And exp exp</p>\n<p>type_synonym EnvD = \"ValD Env\"</p>\n<p>fixrec dand :: \"ValD \\&lt;rightarrow&gt; ValD \\&lt;rightarrow&gt; ValD\" where<br>\n  \"dand \\&lt;cdot&gt; ValTT \\&lt;cdot&gt; ValTT = ValTT\"<br>\n| (unchecked) \"b \\&lt;noteq&gt; \\&lt;bottom&gt; \\&lt;Longrightarrow&gt; dand \\&lt;cdot&gt;<br>\nValFF \\&lt;cdot&gt; b = ValFF\"<br>\n| (unchecked) \"a \\&lt;noteq&gt; \\&lt;bottom&gt; \\&lt;Longrightarrow&gt; dand \\&lt;cdot&gt; a<br>\n\\&lt;cdot&gt; ValFF = ValFF\"</p>\n<p>primrec dval :: \"exp \\&lt;Rightarrow&gt; EnvD \\&lt;rightarrow&gt; ValD\" where<br>\n  \"dval (Let var val exp) = (\\&lt;Lambda&gt; e. dval exp \\&lt;cdot&gt; (env_ext<br>\n\\&lt;cdot&gt; var \\&lt;cdot&gt; val \\&lt;cdot&gt; e))\"<br>\n| \"dval (Var var) = (\\&lt;Lambda&gt; e. e \\&lt;cdot&gt; var)\"<br>\n| \"dval (And a b) = (\\&lt;Lambda&gt; e. dand \\&lt;cdot&gt; (dval a \\&lt;cdot&gt; e)<br>\n\\&lt;cdot&gt; (dval b \\&lt;cdot&gt; e))\"</p>\n<p>value \"dval (Let 1 ValFF (Let 2 ValTT (And (Var 1) (Var 2)))) \\&lt;cdot&gt; env_empty\"<br>\nvalue \"dval (Var 1)\"</p>\n<p>end</p>",
        "id": 294708974,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181529
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nDenis,</p>\n<p>The ‘value’ command relies on the code generator, which isn’t set up for HOLCF.</p>\n<p>You could instead try to use the simplifier, e.g.:</p>\n<p>lemma \"dval (Let 1 ValFF (Let 2 ValTT (And (Var 1) (Var 2)))) \\&lt;cdot&gt; env_empty = XXX\"<br>\napply simp</p>\n<p>HTH,<br>\npeter</p>\n<p>— <br>\n<a href=\"http://peteg.org/\">http://peteg.org/</a> &lt;<a href=\"http://peteg.org/\">http://peteg.org/</a>&gt;</p>",
        "id": 294709048,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181554
    }
]