[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:joachim@cis.upenn.edu\">joachim@cis.upenn.edu</a>&gt;<br>\nHi,</p>\n<p>based on repeated discussions and confusion when interacting with<br>\nfunctional programmers and type-theory based theorem prover users, I<br>\nwrote a blog post explaining how functions in Isabelle are different<br>\nthan functions in Haskell/Coq/etc, and what the deal is about<br>\nundefined:</p>\n<p><a href=\"http://www.joachim-breitner.de/blog/732\">http://www.joachim-breitner.de/blog/732</a></p>\n<p>Please let me know if I say something wrong that should not be said<br>\nlike that on the Internet. Otherwise, feel free to share when you have<br>\ntrouble explaining these things to someone.</p>\n<p>Regards,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/4buKNY7XI1rJ7nzSqGJUchWc/signature.asc\">signature.asc</a></p>",
        "id": 294721339,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184928
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Joachim,</p>\n<p>Many people will probably agree with you when you declare</p>\n<blockquote>\n<blockquote>\n<p>Isabelle functions do not compute (unlike, say, Coq functions)</p>\n</blockquote>\n</blockquote>\n<p>However, I think stopping at this declaration means giving up too easily on what Isabelle/HOL (and HOL in general) have to offer w.r.t. certified programming.</p>\n<p>True, you can get non-computable behavior for the specifications of functions. But rather than saying that you cannot program in HOL, I would rather say that</p>\n<p>the traditional machinery developed in HOL-based provers includes a functional programming language, but currently does not (bother to) clearly single it out, as a subset</p>\n<p>of what can be specified. (Of course, singling that out would mean committing to intensional, extra-logical aspects -- which is always necessary when connecting logic with programming -- likewise, the termination property of a function written in Coq  does not dwell in the Coq logic.)</p>\n<p>To see my point, consider the same OCaml program in the following two scenarios:</p>\n<p>1) generated from an Isabelle/HOL function</p>\n<p>2) extracted from a Coq function</p>\n<p>Say you prove something about the source functions in each of these provers. Is the fact proved in Coq more relevant for the OCaml program than that proved in Isabelle?</p>\n<p>The answer is: No, provided some minimal precautions are taken about the specification and the code extraction setup. One can of course go into a discussion about the partial correctness restriction stemming from the additional flexibility of Isabelle/HOL's code generator (discussed by Haftmann and Nipkow), but this can be alleviated by removing that flexibility. Btw, for adequacy, both Coq and Isabelle would need to carefully consider that one reasons in a total logic about a program written in a \"partial\" environment, and rely on a form of \"moral correctness\" result (<a href=\"http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html\">http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html</a>).</p>\n<p>Andrei</p>",
        "id": 294721359,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184940
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:joachim@cis.upenn.edu\">joachim@cis.upenn.edu</a>&gt;<br>\nHi,</p>\n<p>Am Donnerstag, den 12.10.2017, 19:40 +0000 schrieb Andrei Popescu:</p>\n<blockquote>\n<p>Many people will probably agree with you when you declare</p>\n<blockquote>\n<blockquote>\n<p>Isabelle functions do not compute (unlike, say, Coq functions)</p>\n</blockquote>\n</blockquote>\n<p>However, I think stopping at this declaration means giving up too<br>\neasily on what Isabelle/HOL (and HOL in general) have to offer w.r.t.<br>\ncertified programming.</p>\n</blockquote>\n<p>Good point. I should add  section</p>\n<h3>You can still compute with Isabelle functions</h3>\n<blockquote>\n<p>Say you prove something about the source functions in each of these<br>\nprovers. Is the fact proved in Coq more relevant for the OCaml<br>\nprogram than that proved in Isabelle?</p>\n<p>The answer is: No, provided some minimal precautions are taken about<br>\nthe specification and the code extraction setup. One can of course go<br>\ninto a discussion about the partial correctness restriction stemming<br>\nfrom the additional flexibility of Isabelle/HOL's code generator<br>\n(discussed by Haftmann and Nipkow), but this can be alleviated by<br>\nremoving that flexibility.</p>\n</blockquote>\n<p>How can you achieve that?</p>\n<p>Coq users stress the point that when you extract from Coq to Haskell,<br>\nyou know it terminates. And similarly, when you translate Haskell to<br>\nCoq, and Coq accepts it, then this is in a way a termination proof of<br>\nthe Haskell code.</p>\n<p>Can we say the same for Isabelle code extraction?</p>\n<p>(I guess we can say the same for Haskabelle translation from Haskell to<br>\nCoq, because <code>fun</code> requires well-founded recursion.)</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/WhsXzZi4r0dmYcIzNJHleCPc/signature.asc\">signature.asc</a></p>",
        "id": 294721377,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184946
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI generally like it. Yes, HOL is first and foremost classical<br>\nmathematics; the functional specifications give an appearance of<br>\nfunctional programming, without restricting it to a computational<br>\nworld-view. The \"programming\" in HOL is good enough for most applications.</p>\n<p>BTW, if you take the literal meaning of the word \"undefined\", it means<br>\n\"not defined\". So it fits well into your story. People who think of<br>\n\"undefined\" as \"halt and catch fire\" instruction are wrong :-)</p>\n<p>Minor note: some ASCII =&gt; have sneaked in, but you appear to use Unicode<br>\nrendering of Isabelle symbols uniformly.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/JhJc5qkD6mNRwc4FU55zuLYi/signature.asc\">signature.asc</a></p>",
        "id": 294721392,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184953
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Joachim,</p>\n<p>See £££ below..</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; on behalf of Joachim Breitner &lt;<a href=\"mailto:joachim@cis.upenn.edu\">joachim@cis.upenn.edu</a>&gt;<br>\nSent: 12 October 2017 20:57<br>\nTo: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nSubject: Re: [isabelle] Isabelle functions: Always total, sometimes undefined</p>\n<p>Hi,</p>\n<p>Am Donnerstag, den 12.10.2017, 19:40 +0000 schrieb Andrei Popescu:</p>\n<blockquote>\n<p>Many people will probably agree with you when you declare</p>\n<blockquote>\n<blockquote>\n<p>Isabelle functions do not compute (unlike, say, Coq functions)</p>\n</blockquote>\n</blockquote>\n<p>However, I think stopping at this declaration means giving up too<br>\neasily on what Isabelle/HOL (and HOL in general) have to offer w.r.t.<br>\ncertified programming.</p>\n</blockquote>\n<p>Good point. I should add  section</p>\n<h3>You can still compute with Isabelle functions</h3>\n<blockquote>\n<p>Say you prove something about the source functions in each of these<br>\nprovers. Is the fact proved in Coq more relevant for the OCaml<br>\nprogram than that proved in Isabelle?</p>\n<p>The answer is: No, provided some minimal precautions are taken about<br>\nthe specification and the code extraction setup. One can of course go<br>\ninto a discussion about the partial correctness restriction stemming<br>\nfrom the additional flexibility of Isabelle/HOL's code generator<br>\n(discussed by Haftmann and Nipkow), but this can be alleviated by<br>\nremoving that flexibility.</p>\n</blockquote>\n<p>How can you achieve that?</p>\n<p>£££ E.g., refraining from using that flexibility.  :- )</p>\n<p>Coq users stress the point that when you extract from Coq to Haskell,<br>\nyou know it terminates. And similarly, when you translate Haskell to<br>\nCoq, and Coq accepts it, then this is in a way a termination proof of<br>\nthe Haskell code.</p>\n<p>Can we say the same for Isabelle code extraction?</p>\n<p>(I guess we can say the same for Haskabelle translation from Haskell to<br>\nCoq, because <code>fun</code> requires well-founded recursion.)</p>\n<p>£££ We could achieve that, in principle, if we went through the trouble of automatically tracking executable specifications. In practice, I believe this is not such a big issue,: we can make sure this is the case by inspecting the definitions. Staying executable is easy -- the hard part is proving properties of the functions....</p>\n<p>Andrei</p>\n<p>-</p>",
        "id": 294721426,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184962
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Joachim,</p>\n<p>Just two pointers on this.</p>\n<ol>\n<li>\n<p>CakeML has a linkup from HOL4 function definitions to their deeply embedded CakeML <br>\nsemantics. This linkup is used for code generation and ensures that the generated code <br>\nterminates.</p>\n</li>\n<li>\n<p>Lars Hupel has been working on a link from Isabelle/HOL functions to CakeML's <br>\nsemantics, using similar ideas. He is also able to generate CakeML code out of <br>\nIsabelle/HOL function definitions. I'm not sure, though, whether he has also shown that <br>\nall generated programs terminate. But the theory would definitely allow you to track that <br>\nfairly easily. He has a draft paper on his homepage:</p>\n</li>\n</ol>\n<p><a href=\"https://www21.in.tum.de/~hupel/pub/isabelle-cakeml.pdf\">https://www21.in.tum.de/~hupel/pub/isabelle-cakeml.pdf</a></p>\n<p>Andreas</p>",
        "id": 294721459,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184965
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nI only show that all the functions that I compile terminate (a side<br>\neffect of the dictionary construction), but I haven't show total<br>\ncorrectness of the resulting CakeML program.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294721477,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184970
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:joachim@cis.upenn.edu\">joachim@cis.upenn.edu</a>&gt;<br>\nHi,</p>\n<p>you have a deep embedding of the extracted code equations, right? So<br>\nyou could state termination, and (at least in theory) prove it in<br>\nIsabelle, couldn’t you?</p>\n<p>Joachim<br>\n<a href=\"/user_uploads/14278/9d1Z7_aKgdv2vCZxp4l7s7yH/signature.asc\">signature.asc</a></p>",
        "id": 294721494,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184977
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nThe initial semantics (plain HO term rewriting) has no notion of<br>\nevaluation order or normal forms.</p>\n<p>Instead one would need to define an alternative semantics that<br>\nprescribes an evaluation order and prove its correctness wrt original<br>\nsemantics, or run my compiler to CakeML (which does precisely that).</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294721518,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184983
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Joachim,</p>\n<blockquote>\n<p>based on repeated discussions and confusion when interacting with&gt; functional programmers and type-theory based theorem prover users, I&gt;<br>\nwrote a blog post explaining how functions in Isabelle are different&gt;<br>\nthan functions in Haskell/Coq/etc, and what the deal is about&gt;<br>\nundefined:&gt; &gt; <a href=\"http://www.joachim-breitner.de/blog/732\">http://www.joachim-breitner.de/blog/732</a>&gt; &gt; Please let me<br>\nknow if I say something wrong that should not be said&gt; like that on the<br>\nInternet. Otherwise, feel free to share when you have&gt; trouble<br>\nexplaining these things to someone.<br>\nthanks for that blog post, which does indeed cover the essence of the<br>\nrelationship of Isabelle/HOL and functional programming.</p>\n</blockquote>\n<p>Let me add some remarks:</p>\n<p>a) Terminology</p>\n<p>You are mixing Isabelle and Isabelle/HOL quite freely.  IMHO it should<br>\nread Isabelle/HOL throughout.</p>\n<p>b) Section »Not all function specifications are ok«</p>\n<p>Notation »S« stands beside »Suc«.  You might want to consolidate that.</p>\n<p>c) Section »You can still compute with Isabelle functions«</p>\n<p>You might want to add the key idea of the “moral reasoning” foundation:<br>\ninterpret HOL equations as a <em>shallow embedding</em> of corresponding programs.</p>\n<p>The approach still has its advantages, e.g. you get datatype abstraction<br>\n(almost) for free.</p>\n<p>Lars' work goes beyond that by constructing a <em>deep embedding</em> of<br>\nequations into HOL itself.</p>\n<p>d) Section »Termination is a property of specifications, not functions«</p>\n<p>Speaking about »termination« for function specifications is illusive,<br>\nsince the logic itself does not know about a concept called<br>\n»termination«.  But you can utilize typical termination arguments (e.g.<br>\nwell-founded relations) to automate the derivation of equations from a<br>\nprimitive, abstract definition.</p>\n<p>e) Why there is nothing but a quite loose characterization of the<br>\n»executable« sublanguage of Isabelle/HOL.</p>\n<p>It is the sheer complexity of the system itself: The sublanguage is not<br>\nbuilt into the logic, but appears by a elaborate stack of tools:</p>\n<ul>\n<li>\n<p>Tools to introduce concepts known from FP in a suitable manner:<br>\ndatatype, function.</p>\n</li>\n<li>\n<p>Tool to generate programs for sets of equations: code generator.</p>\n</li>\n</ul>\n<p>Both layers are highly customizable. Of course you can do some kind of<br>\nFP while you use, but you are always free to make it crumble down doing<br>\nsome – apparent according to common sense but difficult to characterize<br>\nprecisely – »nonsense«, e.g. non-terminating simp rules for the<br>\ntermination prover.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/UBukJ2TYCtLyyIy-fTG3zplX/signature.asc\">signature.asc</a></p>",
        "id": 294721887,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185100
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nSurely the point is that Coq (or rather its underlying calculus, and similar type theories) have an operational semantics. The semantics of higher-order logic is set-theoretic. Therefore higher-order logic has no definitive operational semantics at all. Rather we identify an executable sublanguage.</p>\n<p>Larry Paulson</p>",
        "id": 294721912,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185105
    }
]