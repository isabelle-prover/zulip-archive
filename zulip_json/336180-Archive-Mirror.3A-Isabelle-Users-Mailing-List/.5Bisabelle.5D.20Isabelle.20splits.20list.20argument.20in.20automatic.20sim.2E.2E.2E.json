[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Josh,</p>\n<blockquote>\n<p>fun poly_mult :: \"int list =&gt; int list =&gt; int list\" where<br>\n  \"poly_mult xs [] = []\" |<br>\n  \"poly_mult [] xs = []\" |<br>\n  \"poly_mult (x#xs) ys = add_lists (scale_list ys x) (0#(poly_mult xs ys))\"</p>\n<p>add_lists ?y [] == ?y<br>\nadd_lists [] (?v1 # ?va1) == ?v1 # ?va1<br>\nadd_lists (?x1 # ?xs1) (?y1 # ?ys1) == (?x1 + ?y1) # add_lists ?xs1 ?ys1</p>\n<p>Why are the second list arguments split into their head and tail in the<br>\nsecond and third rules?</p>\n</blockquote>\n<p>this is a feature of the function package. Isabelle's internal logic<br>\ndoes not have a notion of \"top-to-bottom\" processing of patterns, as is<br>\nusual in e.g. Haskell or Scala. The function package merely pretends<br>\nthat Isabelle supports that, and internally disambiguates all equations<br>\nso that they're valid independently.</p>\n<p>In your example, the first and the third equation overlap: Let the first<br>\nargument be non-empty and the second empty. Then, both rules would<br>\nmatch. It is not immediately clear whether or not both rules would also<br>\nproduce the same result, which would be necessary for consistency.</p>\n<p>Hence, the function package will helpfully instantiate the last rule so<br>\nthat it doesn't overlap with the first one anymore, and matches the<br>\nexpected FP semantics of top-to-bottom processing.</p>\n<p>It is possible to prevent the function package from doing that, but I<br>\nwould highly recommend against that, unless you know what you're doing.</p>\n<blockquote>\n<p>This affects some proofs I am writing where I want to just match the entire second list and not have it split.<br>\nI try to get around this by writing additional lemmas stating what I need, but this is sometimes tricky. Is there a simpler way to get the rule I want? </p>\n</blockquote>\n<p>There is a way to transform a set of equations (e.g. the ones that come<br>\nout of the function package) into a single equation that performs the<br>\npattern matching on the right-hand side. It can be imported from<br>\n\"HOL-Library.Simps_Case_Conv\". Here's an example use:</p>\n<p>case_of_simps map_alt: <a href=\"http://list.map\">list.map</a><br>\n  thm map_alt</p>\n<p>You could then declare the \"unwanted\" simp rules as [simp del] and that<br>\none as [simp] (be careful, though, sometimes this might make internal<br>\ntools loop):</p>\n<p>declare list.map[simp del]<br>\n  declare map_alt[simp]</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294726476,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186579
    }
]