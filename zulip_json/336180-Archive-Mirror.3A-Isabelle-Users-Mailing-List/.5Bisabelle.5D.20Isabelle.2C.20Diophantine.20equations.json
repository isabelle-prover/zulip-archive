[
    {
        "content": "<p>From: Jan Pax &lt;<a href=\"mailto:pax0@seznam.cz\">pax0@seznam.cz</a>&gt;<br>\nHi,<br>\n  could someone please tell me how to handle Diophantine equations in Isabelle and<br>\n  give me some simple example?<br>\n  For example how to try to prove or disprove</p>\n<p>all x, exits y, x^4=y^2</p>\n<p>exists x, exists y, x^4 = 1 + x + y^2</p>\n<p>exists x, exists y, x^2 (1 + y) = 1 + x + y^2</p>\n<p>Thank you, Jan Pax</p>",
        "id": 294049804,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818943
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@gmx.de\">tjark.weber@gmx.de</a>&gt;<br>\nJan,</p>\n<p>it seems that you haven't received a public reply yet, so I'll try to make <br>\nsome potentially useful remarks.</p>\n<ul>\n<li>\n<p>I don't think there's a decision procedure available at the moment which<br>\n  specifically targets Diophantine equations.  \"arith\" should be able to deal<br>\n  with linear ones though: e.g.</p>\n<p>lemma \"EX (x::int) y. 5<em>x + 3</em>y = 1\"<br>\n    by arith</p>\n</li>\n<li>\n<p>Addition and power function are generic in Isabelle, available not only for<br>\n  integers, but also for other types.  Since you consider Diophantine<br>\n  equations, you'll probably want to use \"int\" type annotations: e.g.</p>\n<p>lemma \"ALL (x::int). EX y. x^4 = y^2\"</p>\n<p>Otherwise use \"Isabelle &gt; Settings &gt; Show Types\" (and possibly \"Isabelle &gt;<br>\nSettings &gt; Show Sorts\") to show the types inferred by the system.</p>\n<p>Here's a proof of the above lemma:</p>\n<p>apply (rule allI)<br>\n    apply (rule_tac x=\"x^2\" in exI)<br>\n    apply (simp add: power_mult [symmetric])<br>\n  done</p>\n</li>\n<li>\n<p>You can use the \"ProofGeneral &gt; Find Theorems\" feature to search for<br>\n  existing lemmas.  E.g. search for theorems containing</p>\n<p>\"(_ ^ _) ^ _\"</p>\n<p>to find the \"power_mult\" theorem (among others) that was used in the above<br>\nproof.</p>\n</li>\n<li>\n<p>\"quickcheck\" will try to disprove your current goal by instantiating free<br>\n  variables with random values.  This means you can also use it to find<br>\n  witnesses for existential statements, by negating the statement: e.g.</p>\n<p>lemma \"~ (x::int)^4 = 1 + x + y^2\"<br>\n    quickcheck</p>\n<p>might print</p>\n<p>Counterexample found:<br>\n  x = -1::int<br>\n  y = -1::int</p>\n<p>which would suggest the following proof of your second equation:</p>\n<p>lemma \"EX (x::int) y. x^4 = 1 + x + y^2\"<br>\n    apply (rule_tac x=\"-1\" in exI)<br>\n    apply (rule_tac x=\"-1\" in exI)<br>\n    apply simp<br>\n  done</p>\n<p>Likewise for your third equation,</p>\n<p>lemma \"~ x^2 * (1 + y) = 1 + x + y^2\"<br>\n    quickcheck</p>\n<p>might print</p>\n<p>Counterexample found:<br>\n  x = -2::int<br>\n  y = -1::int</p>\n</li>\n</ul>\n<p>Best,<br>\nTjark</p>",
        "id": 294049929,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818996
    }
]