[
    {
        "content": "<p>From: Francois Pottier &lt;<a href=\"mailto:Francois.Pottier@inria.fr\">Francois.Pottier@inria.fr</a>&gt;<br>\nHello,</p>\n<p>I am trying to gain an initial understanding of both Isabelle/HOL<br>\nand the Isar structured proof language. My main sources are the<br>\nIsabelle/HOL tutorial and Markus Wenzel's PhD thesis. I have some<br>\nquestions about proofs by induction.</p>\n<p>I have been trying to write a few simple proofs about simply-typed<br>\nlambda-calculus. Here is a typical statement, a substitution lemma:</p>\n<p>lemma substitution:<br>\n    assumes p: \"(env1, e1, t1) : judgments\"<br>\n    assumes q: \"(env2, e2, t2) : judgments\"<br>\n    assumes e: \"ALL y. y ~= x --&gt; env1 y = env2 y\"<br>\n    assumes f: \"env1 x = t2\"<br>\n    shows      \"(env2, subst x e2 e1, t1) : judgments\"</p>\n<p>(For reference, I include the definitions that lead up to this lemma<br>\nat the end of this message.) (For simplicity, my environments are<br>\ntotal functions from variable names to types.)</p>\n<p>If I try to attack a proof of this statement by saying</p>\n<p>using p proof (induct)</p>\n<p>then Isabelle presents me with new subgoals that are plain wrong.<br>\nThe first of these, for instance, is </p>\n<p>1. !!env xa. (env2, subst x e2 (EVar xa), env xa) : judgments</p>\n<p>I can understand how these subgoals appear. The induction principle for<br>\njudgments (judgments.induct) involves a schematic variable ?P that must<br>\nsatisfy the equation</p>\n<p>?P env1 e1 t1 = ((env2, subst x e2 e1, t1) : judgments)</p>\n<p>(This equation is obtained by considering the fact p and the statement's final<br>\n\"shows\" clause. The facts q, e, and f are apparently ignored in this process.)<br>\nThis leads to the candidate</p>\n<p>?P = %env1 e1 t1. ((env2, subst x e2 e1, t1) : judgments)</p>\n<p>which is inappropriate.</p>\n<p>My questions are,</p>\n<ul>\n<li>\n<p>how should I reformulate the statement (or the proof) so that appropriate<br>\n   sub-goals arise? should I explicitly provide a value for the variable ?P in<br>\n   the proof script? or should I modify the statement so that the hypotheses q,<br>\n   e, and f are moved into the shows clause, using explicit implications?</p>\n</li>\n<li>\n<p>the Isabelle tutorial suggests that this kind of induction<br>\n   requires a strengthened statement, typically making use of<br>\n   the object-level quantifiers ALL and --&gt;. However, Wenzel's<br>\n   thesis suggests that this is no longer necessary in Isabelle/Isar,<br>\n   and that it is possible to stick with the meta-level quantifiers<br>\n   !! and ==&gt;. What's the final word?</p>\n</li>\n</ul>\n<p>I will of course continue to explore on my own, but any help would be warmly<br>\nwelcome. Pointers to Isabelle/Isar developments that perform proofs by<br>\ninduction with multiple hypotheses or multiple parameters, like above, would<br>\nalso be very interesting to me.</p>\n<p>Best regards,</p>",
        "id": 293896439,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660742852
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 10 Oct 2005, Francois Pottier wrote:</p>\n<blockquote>\n<p>I have been trying to write a few simple proofs about simply-typed<br>\nlambda-calculus. Here is a typical statement, a substitution lemma:</p>\n<p>lemma substitution:<br>\n    assumes p: \"(env1, e1, t1) : judgments\"<br>\n    assumes q: \"(env2, e2, t2) : judgments\"<br>\n    assumes e: \"ALL y. y ~= x --&gt; env1 y = env2 y\"<br>\n    assumes f: \"env1 x = t2\"<br>\n    shows      \"(env2, subst x e2 e1, t1) : judgments\"</p>\n</blockquote>\n<blockquote>\n<p>If I try to attack a proof of this statement by saying</p>\n<p>using p proof (induct)</p>\n<p>then Isabelle presents me with new subgoals that are plain wrong.<br>\nThe first of these, for instance, is </p>\n<p>1. !!env xa. (env2, subst x e2 (EVar xa), env xa) : judgments</p>\n</blockquote>\n<p>The problem here is that your goal statement is not fully general wrt. to<br>\nthe induction principle, using an expression \"subst x e2 e1\" in place of<br>\nan inductive variable.</p>\n<p>In order to make this work, one may reformulate the goal in terms of a<br>\nlocal definition of that expression, then perform the induction, then<br>\nunfold the definition in each inductive case:</p>\n<p>lemma substitution:<br>\n  assumes p: \"(env1, e1, t1) : judgments\"<br>\n  assumes q: \"(env2, e2, t2) : judgments\"<br>\n  assumes e: \"ALL y. y ~= x --&gt; env1 y = env2 y\"<br>\n  shows      \"!!x e1 e2. e == subst x e2 e1 ==&gt; (env2, e, t1) : judgments\"<br>\nusing p<br>\nproof (induct)<br>\n  case JVar<br>\n  then show ?case apply (simp only:) sorry<br>\nnext<br>\n  case JAbs<br>\n  then show ?case apply (simp only:) sorry<br>\nnext<br>\n  case JApp<br>\n  then show ?case apply (simp only:) sorry<br>\nqed</p>\n<p>Note that the 'apply (simp only:)' above just demonstrate the machanics.  <br>\nA proper proof would spell this out differently.</p>\n<blockquote>\n<ul>\n<li>the Isabelle tutorial suggests that this kind of induction<br>\n   requires a strengthened statement, typically making use of<br>\n   the object-level quantifiers ALL and --&gt;. However, Wenzel's<br>\n   thesis suggests that this is no longer necessary in Isabelle/Isar,<br>\n   and that it is possible to stick with the meta-level quantifiers<br>\n   !! and ==&gt;.</li>\n</ul>\n</blockquote>\n<p>!! ==&gt; == instead of ALL --&gt; = spare you 2 more bookeeping steps to get<br>\nrid of the logical connectives in the goal and the final result.</p>\n<blockquote>\n<p>What's the final word?</p>\n</blockquote>\n<p>An even better version of the 'induct' method, that is able to do<br>\ngeneralizations and local definitions (induction over structured<br>\nexpressions) on the fly.  I don't know if this will be the final word, but<br>\nit would move even further from fiddling with connectives, emphasizing<br>\nactual reasoning instead.</p>\n<p>Makarius</p>",
        "id": 293896444,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660742853
    }
]