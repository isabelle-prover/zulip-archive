[
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nDear Isabelle experts,</p>\n<p>my impression (which may have been wrong) from Isabelle2013 was that<br>\n\"try\" tries \"try0\" before \"sledgehammer\".  In Isabelle2013-1-RC3 this no<br>\nlonger seems to be the case.</p>\n<p>I find this quite annoying because I have made it a habit to enter \"try\"<br>\nafter almost every statement.  In many cases I don't know whether try0<br>\nwould be sufficient to prove something, or whether a more complex proof<br>\n(such as those that sledgehammer finds) is required.  Then, when<br>\nsledgehammer finds a proof, looking at the lemmas used by this proof<br>\nsometimes gives me the intuition that try0 might also suffice, e.g. when<br>\nI know that all of these lemmas are simp rules.</p>\n<p>Here is a self-contained almost minimal example.  I didn't try this with<br>\nolder versions but I'd be happy to do so.  Please ignore the first step:<br>\nmaybe there is an easier proof for this, but for _this_ email only the<br>\nsecond step is relevant.</p>\n<p>notepad<br>\nbegin<br>\n  fix R::\"('a × 'b) set\"<br>\n    and N::\"'a set\"<br>\n    and n::'a<br>\n  have \"{ (x, y) . (x, y) ∈ R ∧ x ≠ n }¯ = { (y, x) . (y, x) ∈ R¯ ∧ x ≠ n }\"<br>\n    by (smt Collect_cong converse_unfold curryE curry_split<br>\nmem_Collect_eq splitD split_cong)<br>\n  then have \"Domain { (x, y) . (x, y) ∈ R ∧ x ≠ n } = Range { (y, x) .<br>\n(y, x) ∈ R¯ ∧ x ≠ n}\" try<br>\nend</p>\n<p>On my machine try0 finds that simp/auto/force each take 2 ms.</p>\n<p>However when I say \"try\", it resorts to running sledgehammer, which<br>\ntells me:</p>\n<p>--- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; ---<br>\nTrying \"solve_direct\", \"quickcheck\", \"try0\", \"sledgehammer\", and<br>\n\"nitpick\"...<br>\n\"z3\": Sledgehammer (\"z3\") found a proof: by (metis Range_converse) (128 ms).<br>\nTo minimize: sledgehammer min (Range_converse <code>{(x, y). (x, y) ∈ R ∧ x ≠\nn}¯ = {(y, x). (y, x) ∈ R¯ ∧ x ≠ n}</code>).<br>\n\"spass\": Sledgehammer (\"spass\") found a proof: by (metis Range_converse)<br>\n(108 ms).<br>\nTo minimize: sledgehammer min (Range_converse <code>{(x, y). (x, y) ∈ R ∧ x ≠\nn}¯ = {(y, x). (y, x) ∈ R¯ ∧ x ≠ n}</code>).<br>\n\"remote_vampire\": Sledgehammer (\"remote_vampire\") found a proof: by<br>\n(metis Range_converse converse_unfold) (109 ms).<br>\nTo minimize: sledgehammer min (Range_converse converse_unfold <code>{(x, y).\n(x, y) ∈ R ∧ x ≠ n}¯ = {(y, x). (y, x) ∈ R¯ ∧ x ≠ n}</code>).<br>\n\"e\": Sledgehammer (\"e\") found a proof: by (smt Collect_mem_eq<br>\nDomain_Collect_split Domain_converse Domain_unfold converse_converse<br>\nconverse_unfold internal_split_def) (28 ms).<br>\nTo minimize: sledgehammer min [smt] (Collect_mem_eq Domain_Collect_split<br>\nDomain_converse Domain_unfold converse_converse converse_unfold<br>\ninternal_split_def <code>{(x, y). (x, y) ∈ R ∧ x ≠ n}¯ = {(y, x). (y, x) ∈ R¯\n∧ x ≠ n}</code>).<br>\nStructured proof (3 ms):<br>\nproof -<br>\n  show \"Domain {(x, y). (x, y) ∈ R ∧ x ≠ n} = Range {(y, x). (y, x) ∈ R¯<br>\n∧ x ≠ n}\"<br>\n    using Domain_unfold by auto<br>\nqed<br>\n--- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; ---</p>\n<p>Here, it was clearly the last sledgehammer output that gave me the idea<br>\nthat try0 can do the job.  In other cases (I'll be happy to dig out some<br>\nmore) it's not that easy.</p>\n<p>Any ideas?</p>\n<p>Cheers, and thanks in advance,</p>\n<p>Christoph</p>",
        "id": 294252389,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911245
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nA minor correction:</p>\n<p>2013-10-27 16:06 Christoph LANGE:</p>\n<blockquote>\n<p>my impression (which may have been wrong) from Isabelle2013 was that<br>\n\"try\" tries \"try0\" before \"sledgehammer\".  In Isabelle2013-1-RC3 this no<br>\nlonger seems to be the case.</p>\n<p>I find this quite annoying because I have made it a habit to enter \"try\"<br>\nafter almost every statement.  In many cases I don't know whether try0<br>\nwould be sufficient to prove something, or whether a more complex proof<br>\n(such as those that sledgehammer finds) is required.  Then, when<br>\nsledgehammer finds a proof, looking at the lemmas used by this proof<br>\nsometimes gives me the intuition that try0 might also suffice, e.g. when<br>\nI know that all of these lemmas are simp rules.</p>\n<p>Here is a self-contained almost minimal example.  I didn't try this with<br>\nolder versions but I'd be happy to do so.  Please ignore the first step:<br>\nmaybe there is an easier proof for this, but for _this_ email only the<br>\nsecond step is relevant.</p>\n</blockquote>\n<p>OK, I see this is not the most elegant example, as …</p>\n<blockquote>\n<p>notepad<br>\nbegin<br>\n  fix R::\"('a × 'b) set\"<br>\n    and N::\"'a set\"<br>\n    and n::'a<br>\n  have \"{ (x, y) . (x, y) ∈ R ∧ x ≠ n }¯ = { (y, x) . (y, x) ∈ R¯ ∧ x ≠ n }\"<br>\n    by (smt Collect_cong converse_unfold curryE curry_split<br>\nmem_Collect_eq splitD split_cong)<br>\n  then have \"Domain { (x, y) . (x, y) ∈ R ∧ x ≠ n } = Range { (y, x) .<br>\n(y, x) ∈ R¯ ∧ x ≠ n}\" try<br>\nend</p>\n<p>On my machine try0 finds that simp/auto/force each take 2 ms.</p>\n<p>However when I say \"try\", it resorts to running sledgehammer, which<br>\ntells me:</p>\n<p>--- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; ---<br>\nTrying \"solve_direct\", \"quickcheck\", \"try0\", \"sledgehammer\", and<br>\n\"nitpick\"...<br>\n\"z3\": Sledgehammer (\"z3\") found a proof: by (metis Range_converse) (128 ms).<br>\nTo minimize: sledgehammer min (Range_converse <code>{(x, y). (x, y) ∈ R ∧ x ≠\nn}¯ = {(y, x). (y, x) ∈ R¯ ∧ x ≠ n}</code>).<br>\n\"spass\": Sledgehammer (\"spass\") found a proof: by (metis Range_converse)<br>\n(108 ms).<br>\nTo minimize: sledgehammer min (Range_converse <code>{(x, y). (x, y) ∈ R ∧ x ≠\nn}¯ = {(y, x). (y, x) ∈ R¯ ∧ x ≠ n}</code>).<br>\n\"remote_vampire\": Sledgehammer (\"remote_vampire\") found a proof: by<br>\n(metis Range_converse converse_unfold) (109 ms).<br>\nTo minimize: sledgehammer min (Range_converse converse_unfold <code>{(x, y).\n(x, y) ∈ R ∧ x ≠ n}¯ = {(y, x). (y, x) ∈ R¯ ∧ x ≠ n}</code>).<br>\n\"e\": Sledgehammer (\"e\") found a proof: by (smt Collect_mem_eq<br>\nDomain_Collect_split Domain_converse Domain_unfold converse_converse<br>\nconverse_unfold internal_split_def) (28 ms).<br>\nTo minimize: sledgehammer min [smt] (Collect_mem_eq Domain_Collect_split<br>\nDomain_converse Domain_unfold converse_converse converse_unfold<br>\ninternal_split_def <code>{(x, y). (x, y) ∈ R ∧ x ≠ n}¯ = {(y, x). (y, x) ∈ R¯\n∧ x ≠ n}</code>).<br>\nStructured proof (3 ms):<br>\nproof -<br>\n  show \"Domain {(x, y). (x, y) ∈ R ∧ x ≠ n} = Range {(y, x). (y, x) ∈ R¯<br>\n∧ x ≠ n}\"<br>\n    using Domain_unfold by auto<br>\nqed</p>\n</blockquote>\n<p>… this shows that the first proof step is not necessary at all, because<br>\n\"using Domain_unfold by auto\" suffices to establish the second step<br>\nwithout the first step.  Still this doesn't affect my point that \"try\"<br>\nseems to give preference to \"sledgehammer\" over \"try0\".</p>\n<blockquote>\n<p>--- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; --- %&lt; ---</p>\n<p>Here, it was clearly the last sledgehammer output that gave me the idea<br>\nthat try0 can do the job.  In other cases (I'll be happy to dig out some<br>\nmore) it's not that easy.</p>\n<p>Any ideas?</p>\n<p>Cheers, and thanks in advance,</p>\n<p>Christoph<br>\n</p>\n</blockquote>",
        "id": 294252399,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911251
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Christoph,</p>\n<p>Sorry for the delay in answering.</p>\n<p>\"try\" does a number of things in parallel, using the ML function \"Par_List.get_some\". Because it may use several threads in parallel, there are no guarantees about which result will be printed first. Usually, \"try0\" results tend to be shown first because the \"try0\" thread is launched first and it tends to return first as well; but Sledgehammer has become faster, and \"try0\" is only as fast as its slowest tool (with a timeout of 5 s).</p>\n<p>In short, this does not appear to be a deep difference between Isabelle2013-1-RC1 and Isabelle2013, but rather a matter of (bad) luck.</p>\n<p>Still, the behavior you described is somewhat undesirable, so I've now made it less likely to happen in the repository version of Isabelle (change c7af3d651658). When \"try0\" is invoked from \"try\", it now stops as soon as it has found one proof, instead of reporting detailed timings for different tools.</p>\n<p>Since this is not a true regression, and there is an easy workaround (i.e. invoke \"try0\" directly), I will not ask Makarius to add the change to the final version of Isabelle2013-1. If this is very important to you, I would suggest that you apply the patch locally. In any case, the patch should be part of (the expected) Isabelle2014.</p>\n<p>Thank you for your report.</p>\n<p>Regards,</p>\n<p>Jasmin</p>",
        "id": 294254561,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912097
    }
]