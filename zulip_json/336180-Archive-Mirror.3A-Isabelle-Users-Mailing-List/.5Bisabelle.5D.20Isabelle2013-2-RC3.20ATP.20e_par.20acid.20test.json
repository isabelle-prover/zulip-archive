[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nMakarius,</p>\n<p>The short story is that I can reliably get non-terminating processes (or <br>\nprocesses that can't be shut down, and that will run for a long time), <br>\nbut so far, I can only do that with the ATP e_par, and when it's started <br>\nwith a bunch of other ATPs.</p>\n<p>The theorem I use for the test has to be put it at the bottom of a <br>\ntheory, so that Sledgehammer can find some relevant facts.</p>\n<p>The test is to start Sledgehammer, and then terminate it prematurely by <br>\ndeleting the \"r\" in \"Sledgehammer\", sometimes soon, and sometimes later. <br>\nI actually have to let e_par run for a while to get the right conditions <br>\nfor it to not terminate.</p>\n<p>I didn't spend a lot of time experimenting with the command I show next, <br>\nwhich doesn't use e_par, but it uses most every ATP that's available to <br>\nme, and I haven't seen any problems from prematurely terminating the <br>\nSledgehammer command. This is the command:</p>\n<p>ML {* Multithreading.max_threads_value () *}<br>\n    ML {* Multithreading.max_threads := 300 *}<br>\n    ML {* Multithreading.max_threads_value () *}</p>\n<p>theorem \"False = True\"<br>\n    sledgehammer [minimize=smart,preplay_timeout=10,timeout=60,verbose=true,<br>\n                  isar_try0=true,isar_proofs=smart,provers=\"<br>\n       remote_vampire  metis  remote_satallax  z3_tptp  remote_e  smt<br>\n       remote_e_tofof  spass  remote_e_sine    e        z3        yices</p>\n<p>remote_snark  remote_iprover  remote_z3    remote_waldmeister  <br>\n    spass_poly<br>\n       remote_cvc3   remote_agsyhol  remote_leo2  remote_iprover_eq   <br>\n    leo2        cvc3<br>\n    \"]<br>\n    oops</p>\n<p>From here, two key points are that e_par starts up 12 eprover.exe <br>\nprocesses regardless of what max_threads is set to, that the number and <br>\norder of ATPs run with it affect things, and \"max_thread := 4\" is what <br>\nsets up the particular sequence I list below.</p>\n<p>I give the Isar command below, but I work it like this:</p>\n<p>1) I start the command.<br>\n2) Lots of eprover processes will be started and terminated, several times.<br>\n3) At about 40 seconds using my CPU, the ATP \"leo\" will be running with <br>\n12 eprover.exe processes, during a time when processes aren't being shut <br>\ndown and started (shown by green and red lines using <br>\n<a href=\"http://systemexplorer.net/\">http://systemexplorer.net/</a> )<br>\n4) I delete the \"r\" in \"Sledgehammer\".<br>\n5) The processes keep running much long than what I'm willing to wait. <br>\n(I have waited up to 15 minutes to see if they would terminate, and they <br>\ndidn't.)<br>\n6) I exit the PIDE. Processes are terminated except for the ATP related <br>\nprocesses. I attach a screen shot showing the many non-terminating <br>\nprocesses.</p>\n<p>The command is this:</p>\n<p>ML {* Multithreading.max_threads_value () *}<br>\n    ML {* Multithreading.max_threads := 4 *}<br>\n    ML {* Multithreading.max_threads_value () *}</p>\n<p>theorem \"False = True\"</p>\n<p>sledgehammer [minimize=smart,preplay_timeout=10,timeout=60,verbose=true,<br>\n                  isar_try0=true,isar_proofs=smart,provers=\"<br>\n       e_par e leo2 z3 metis z3_tptp spass yices cvc3 smt spass_poly<br>\n    \"]</p>\n<p>oops</p>\n<p>The steps listed above don't always work, but they probably work more <br>\nthan 50% of the time.</p>\n<p>In the PIDE options, the default for \"Threads\" is \"0\", which is what <br>\ncontrolled my \"max_thread\" until I started changing \"max_threads\" with <br>\nthe ML command, which affected me being able to get the sequence of <br>\nevents to happen as I described above. The value \"max_threads := 4\" gets <br>\nthe same results as the \"Threads\" set to \"0\". I have a 4 core CPU with <br>\nno hyperthreading.</p>\n<p>This is no problem for me. The ATP e_par actually terminates much of the <br>\ntime, and I haven't been using it because of the large number of <br>\nprocesses that it starts.</p>\n<p>Regards,<br>\nGB<br>\n<a href=\"/user_uploads/14278/upxVfMJI74aTvLxLV3DwHj8X/131204_non-term-processes.png\">131204_non-term-processes.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/upxVfMJI74aTvLxLV3DwHj8X/131204_non-term-processes.png\" title=\"131204_non-term-processes.png\"><img src=\"/user_uploads/14278/upxVfMJI74aTvLxLV3DwHj8X/131204_non-term-processes.png\"></a></div>",
        "id": 294262390,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914847
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI don't actually have to terminate the Sledgehammer command. This worked <br>\nthree times in a row:</p>\n<p>1) Log out and back into my Windows account.<br>\n2) Run the command I showed with max_threads set to 4.<br>\n3) It gets to where \"leo\" and 12 \"eprover.exe\" processes are running, <br>\nand they don't timeout like they should.</p>\n<p>I think it's related to the number of threads, but not completely. I can <br>\nchange max_threads to 3, and e_par times out like it should. I change it <br>\nback to 4, and it can time out like it should.</p>\n<p>I did the log out/log in sequence with max_threads set to 3, and it did <br>\nlike with 4, except \"leo\" wasn't running, but it didn't do it twice in a <br>\nrow. The number 4 seems worse, but 3 fails, and every computer might be <br>\ndifferent.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294262396,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914850
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 4 Dec 2013, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>The short story is that I can reliably get non-terminating processes (or <br>\nprocesses that can't be shut down, and that will run for a long time), <br>\nbut so far, I can only do that with the ATP e_par, and when it's started <br>\nwith a bunch of other ATPs.</p>\n</blockquote>\n<p>This is the first time I learn about the existence of e_par.  It seems to <br>\nbe an add-on script to E prover by Josef Urban.  Maybe Jasmin can say <br>\nsomething about the degree of supportedness within the Sledgehammer suite.</p>\n<p>My general impression is that there are many experimental add-ons that are <br>\nnot widely used nor tested on the usual platforms.</p>\n<blockquote>\n<p>I didn't spend a lot of time experimenting with the command I show next, <br>\nwhich doesn't use e_par, but it uses most every ATP that's available to <br>\nme, and I haven't seen any problems from prematurely terminating the <br>\nSledgehammer command. This is the command:</p>\n<p>ML {* Multithreading.max_threads_value () *}<br>\n  ML {* Multithreading.max_threads := 300 *}<br>\n  ML {* Multithreading.max_threads_value () *}</p>\n<p>theorem \"False = True\"<br>\n  sledgehammer [minimize=smart,preplay_timeout=10,timeout=60,verbose=true,<br>\n                isar_try0=true,isar_proofs=smart,provers=\"<br>\n     remote_vampire  metis  remote_satallax  z3_tptp  remote_e  smt<br>\n     remote_e_tofof  spass  remote_e_sine    e        z3        yices</p>\n<p>remote_snark  remote_iprover  remote_z3    remote_waldmeister <br>\nspass_poly<br>\n     remote_cvc3   remote_agsyhol  remote_leo2  remote_iprover_eq      leo2 <br>\ncvc3<br>\n  \"]<br>\n  oops</p>\n<p>From here, two key points are that e_par starts up 12 eprover.exe processes <br>\nregardless of what max_threads is set to, that the number and order of ATPs <br>\nrun with it affect things, and \"max_thread := 4\" is what sets up the <br>\nparticular sequence I list below.</p>\n</blockquote>\n<p>300 threads are quite a lot, but I suggested to go towards and beyond the <br>\nlimits of what is feasible :-)</p>\n<p>The e_par implementation ($E_HOME/runepar.pl) has its own process <br>\nmanagement and allocation of CPU resources.  It does not take the number <br>\nof ML threads into account.  Looking a bit through the script, I see <br>\nvarious potential weaknesses and non-portabilities.  E.g. there is ulimit, <br>\nwhich only works reliably on various brands of Unix, not the generic <br>\nquasi-POSIX of Isabelle that includes Cygwin.  It is also unclear if its <br>\ninternal signal handling is really robust (e.g. the Cleanup does not wait<br>\nfor the process farm.)</p>\n<p>A general note on Multithreading.max_threads: changing that in Isabelle/ML <br>\nmight lead to some surprises, because the PIDE protocol will update its <br>\nvalue after some change of properties, using the value that is given in <br>\nIsabelle/Scala, which is the same that you see in Isabelle/jEdit in the <br>\ndialog \"Plugin Options / Isabelle / General / Threads\".</p>\n<p>ML {* Multithreading.max_threads_value () *} is fine to check what <br>\nIsabelle/ML is presently using.</p>\n<blockquote>\n<p>I give the Isar command below, but I work it like this:</p>\n<p>1) I start the command.<br>\n2) Lots of eprover processes will be started and terminated, several times.<br>\n3) At about 40 seconds using my CPU, the ATP \"leo\" will be running with 12 <br>\neprover.exe processes, during a time when processes aren't being shut down <br>\nand started (shown by green and red lines using <a href=\"http://systemexplorer.net/\">http://systemexplorer.net/</a> )</p>\n</blockquote>\n<p>Does that mean you have a local installation of leo?  I've never looked <br>\nat it myself, and don't know where to get it.  It might have once again <br>\nits very own process management done in OCaml.</p>\n<blockquote>\n<p>4) I delete the \"r\" in \"Sledgehammer\".<br>\n5) The processes keep running much long than what I'm willing to wait. (I <br>\nhave waited up to 15 minutes to see if they would terminate, and they <br>\ndidn't.)<br>\n6) I exit the PIDE. Processes are terminated except for the ATP related <br>\nprocesses. I attach a screen shot showing the many non-terminating <br>\nprocesses.</p>\n</blockquote>\n<p>We've had that already: switching off the light with the hammer --- by <br>\nshutting down the outermost PIDE application --- does not really help. <br>\nIt can leave processes behind at the bottom of the implicit hierarchy.</p>\n<p>POSIX processes are relatively difficult to control systematically.  One <br>\nneeds to look at particular implementations, to see that they are within <br>\nreason of fork, wait, signal handling etc.</p>\n<blockquote>\n<p>This is no problem for me. The ATP e_par actually terminates much of the <br>\ntime, and I haven't been using it because of the large number of <br>\nprocesses that it starts.</p>\n</blockquote>\n<p>Indeed.  It seems to be an experiment to allocate as many CPU cores as <br>\nfeasible, with different strategies for E tried in parallel.</p>\n<p>Makarius</p>",
        "id": 294262484,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914888
    },
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nYes, \"e_par\" should be considered experimental. Beyond the technical issues, it didn't perform well on our benchmarks.</p>\n<p>Jasmin</p>",
        "id": 294262504,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914894
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 12/5/2013 7:59 AM, Makarius wrote:</p>\n<blockquote>\n<p>300 threads are quite a lot, but I suggested to go towards and beyond <br>\nthe limits of what is feasible :-)</p>\n</blockquote>\n<p>I have about 70 processes running normally, and with threads set to 300, <br>\nonly a maximum of about 140 processes are ever running for the \"False = <br>\nTrue\" test. An ATP running as a thread sometimes starts up lots of <br>\nprocesses of its own. With threads set to 4, a max of about 90 processes <br>\nwill be running on my computer.</p>\n<p>I think I'll try threads set to 12 for a while, even though you've said <br>\nit should be set to the number of physical cores. One of the new remote <br>\nATPs that came with Isablle2013-1 is \"remote_agsyhol\", which is finding <br>\nproofs.</p>\n<p>I've added that to my \"first pass ATPs\", so here are the 12 I use for a <br>\nfirst pass. Setting threads to 12 lets all of the them start (or maybe <br>\nit needs to be more than 12), and many of them will sometimes timeout fast:</p>\n<p>remote_vampire  metis  remote_satallax  z3_tptp  remote_e remote_agsyhol<br>\n   remote_e_tofof  spass  remote_e_sine    e        z3       yices</p>\n<blockquote>\n<p>A general note on Multithreading.max_threads: changing that in <br>\nIsabelle/ML might lead to some surprises, because the PIDE protocol <br>\nwill update its value after some change of properties, using the value <br>\nthat is given in Isabelle/Scala, which is the same that you see in <br>\nIsabelle/jEdit in the dialog \"Plugin Options / Isabelle / General / <br>\nThreads\".</p>\n<p>ML {* Multithreading.max_threads_value () *} is fine to check what <br>\nIsabelle/ML is presently using.</p>\n</blockquote>\n<p>Before, I didn't see max_threads_value change after changing \"Threads\", <br>\nbut now I see that if I save the file, max_threads_value will display <br>\nwhat I set \"Threads\" to in the options.</p>\n<blockquote>\n<p>Does that mean you have a local installation of leo?  I've never <br>\nlooked at it myself, and don't know where to get it.  It might have <br>\nonce again its very own process management done in OCaml.</p>\n</blockquote>\n<p>Yes. I have a local install. Your colleague must have forgot to mention <br>\nit to you:</p>\n<p><a href=\"http://www.cl.cam.ac.uk/~lp15/Grants/leo2.html\">http://www.cl.cam.ac.uk/~lp15/Grants/leo2.html</a></p>\n<p>You may be able to ask him about it in Houston. Texas is big, so they <br>\nsay. You wouldn't want to get lost. With your good English grammar, <br>\nTexans might not be able to understand you.</p>\n<p><a href=\"http://www.nasaformalmethods.org/?page_id=104\">http://www.nasaformalmethods.org/?page_id=104</a></p>\n<p>I haven't had to do anything special to keep leo2 running since <br>\nIsabelle2012, unlike satallax, which doesn't run anymore because I <br>\nhaven't downloaded what's needed for Cygwin.</p>\n<p>For anyone interested, there are a number of ATPs which can be run <br>\nlocally, that aren't part of the distribution.</p>\n<p>Vampire, <a href=\"http://www.vprover.org/\">http://www.vprover.org/</a> (The version is up to 3.0, but the <br>\ndownloads haven't been available for a long time, and local vampire <br>\nwon't run on Windows)</p>\n<p>Leo2, <a href=\"http://www.ags.uni-sb.de/~leo/\">http://www.ags.uni-sb.de/~leo/</a> (the link is not responding for me <br>\nright now)</p>\n<p>Satallax, <a href=\"http://www.ps.uni-saarland.de/~cebrown/satallax/\">http://www.ps.uni-saarland.de/~cebrown/satallax/</a></p>\n<p>Yices, <a href=\"http://yices.csl.sri.com/download.shtml\">http://yices.csl.sri.com/download.shtml</a></p>\n<p>Regards,<br>\nGB</p>",
        "id": 294262526,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914900
    }
]