[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Eisbach developers,</p>\n<p>First of all, thanks for designing and implementing Eisbach. Unfortunately, I am <br>\nstruggling with instantiating variables in rules when I write my own proof methods in Eisbach.</p>\n<p>Abstractly,</p>\n<ol>\n<li>I select a rule R by matching a list L of theorems against a term, and</li>\n<li>then instantiate a variable in R with a term obtained by matching the conclusion <br>\nagainst a pattern.</li>\n</ol>\n<p>Unfortunately, I always get the error \"More instantiations than variables in theorem\" <br>\nalthough all the theorems in the list L contain at least one variable. I do not know where <br>\nthis error comes from. Below is a small example:</p>\n<p>theory Scratch imports Main \"~~/src/HOL/Eisbach/Eisbach_Tools\" begin</p>\n<p>consts foo :: \"'a ⇒ 'a ⇒ 'a ⇒ bool\"<br>\nlemma my_thms: \"foo x y z ⟹ z ∧ y\" \"foo x y y ⟹ x ∧ z\" sorry</p>\n<p>lemma \"⋀z. A z ∧ B\"<br>\napply(<br>\n   match concl in \"f x y\" for f x y ⇒ ‹<br>\n     match my_thms in R:\"PROP P ⟹ f u v\" for P u v ⇒ ‹<br>\n       rule R[of x]<br>\n     ›<br>\n   ›<br>\n)<br>\noops</p>\n<p>end</p>\n<p>Thanks for any help,<br>\nAndreas</p>\n<p>PS: I am trying to build something similar to the apply_split method in the Eisbach paper <br>\npresented at ITP2014.</p>",
        "id": 294635341,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159900
    },
    {
        "content": "<p>From: Daniel Matichuk &lt;<a href=\"mailto:daniel.matichuk@nicta.com.au\">daniel.matichuk@nicta.com.au</a>&gt;<br>\nHi Andreas,</p>\n<p>Unfortunately the ITP paper is slightly out of date, specifically regarding rule instantiation. The \"match\" method is now meant to guard rule instantiation at run-time by ensuring that the matched theorem(s) has<br>\nthe correct slots available. This is done by using meta-quantifiers in your patterns. Specifically the semantics of a match are that a \"for-fixed\" variable may match anything, whereas a meta-quantified variable<br>\nmust match against a schematic. So in your example, assuming you wish to instantiate \"P\", your pattern should be \"!!P. PROP P ==&gt; f u v\" for u v\". This statically ensures that any matched rule can be instantiated appropriately (so the failure occurs in the match, rather than the rule instantiation).<br>\nThe motivation for this requirement is perhaps more clear when using match to define an Eisbach method, rather than when used in-place.</p>\n<p>It's also worth noting that a pattern like \"f x y\" for f x y will produce a large set of possible matches, due to \"match\" using the unifier internally. The usual best-practice approach is to add type annotations to your pattern to restrict the matches.<br>\nThere is some argument for extending the match pattern language to support more precise term deconstruction, but I'm waiting to see more use cases before adding more complexity.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294636080,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160194
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIt would be interesting to explore the question if/how the new \"rewrite\" <br>\nmethod facilities could be re-used here.</p>\n<p>Makarius</p>",
        "id": 294636102,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160201
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Daniel,</p>\n<p>Thanks for the reply. Unfortunately, I cannot get this to work at all. Your suggested <br>\npattern \"!!P. PROP P ==&gt; f u v\" raises a type error. After several failed attempts, I am <br>\nnow stuck at the following where something really strange happens.</p>\n<p>lemma \"⋀z. A z ∧ B\"<br>\napply(<br>\n  match concl in \"f x y\" for f x y ⇒ ‹<br>\n    match my_thms in R:\"⋀x :: _ :: type. P x ⟹ f u v\" for P u v ⇒ ‹<br>\n      print_fact R,<br>\n      print_fact R[of undefined],<br>\n      rule R[of undefined]<br>\n    ›<br>\n  ›<br>\n)</p>\n<p>If I name the bound variable to be matched by a schematic, print_fact R outputs something <br>\nlike foo ?x ?y ?x ⟹ ?x ∧ ?y whereas the matched rule is \"foo x y z ⟹ z ∧ y\", i.e., it <br>\nunifies x with z. If I rename the bound variable !!x to !!z, the rule stays in its general <br>\nform. Still, the method still fails, because the variable instantiations are done in a <br>\nstrange order (not in the order in which they occur in the theorem).</p>\n<p>I do not know the form of the assumption of my matched theorem in my real use case, I just <br>\nknow that there is a variable in the assumptions and that I want to instantiate the first <br>\none. How can I express this in Eisbach? I tried to play with \"!!x :: _ :: type. PROP P x <br>\n==&gt; PROP Q\" but this did not match anything I tried.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294636133,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160213
    },
    {
        "content": "<p>From: Daniel Matichuk &lt;<a href=\"mailto:daniel.matichuk@nicta.com.au\">daniel.matichuk@nicta.com.au</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>On 24 Apr 2015, at 2:03 am, Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<p>Hi Daniel,</p>\n<p>Thanks for the reply. Unfortunately, I cannot get this to work at all. Your suggested pattern \"!!P. PROP P ==&gt; f u v\" raises a type error. After several failed attempts, I am now stuck at the following where something really strange happens.</p>\n<p>lemma \"⋀z. A z ∧ B\"<br>\napply(<br>\nmatch concl in \"f x y\" for f x y ⇒ ‹<br>\n  match my_thms in R:\"⋀x :: _ :: type. P x ⟹ f u v\" for P u v ⇒ ‹<br>\n    print_fact R,<br>\n    print_fact R[of undefined],<br>\n    rule R[of undefined]<br>\n  ›<br>\n›<br>\n)</p>\n<p>If I name the bound variable to be matched by a schematic, print_fact R outputs something like foo ?x ?y ?x ⟹ ?x ∧ ?y whereas the matched rule is \"foo x y z ⟹ z ∧ y\", i.e., it unifies x with z. If I rename the bound variable !!x to !!z, the rule stays in its general form.</p>\n</blockquote>\n<p>It's likely you've uncovered an issue with variable clashes here, picking a fresh name for the bound variable seems to result in the expected behaviour. I imagine I've overlooked some schematic index management somewhere, I'll look into it ASAP.</p>\n<blockquote>\n<p>Still, the method still fails, because the variable instantiations are done in a strange order (not in the order in which they occur in the theorem).</p>\n</blockquote>\n<p>The method instantiations are done in the order that they are declared in the match. So in your example \"undefined\" will be bound to whatever x matches against, regardless of the form of the actual rule.<br>\nIt is precisely equivalent to writing \"R[where x=undefined]\".</p>\n<blockquote>\n<p>I do not know the form of the assumption of my matched theorem in my real use case, I just know that there is a variable in the assumptions and that I want to instantiate the first one. How can I express this in Eisbach? I tried to play with \"!!x :: _ :: type. PROP P x ==&gt; PROP Q\" but this did not match anything I tried.</p>\n</blockquote>\n<p>The notion of the \"first\" schematic is not something that can be described with a match pattern. Again, this is perhaps some indication that a more expressive pattern language is needed.<br>\nYour pattern should backtrack over all possible ways some \"P\" can be bound such that \"x\" is bound to a schematic from the theorem, within these backtracking options will be the one that happens to be first.</p>\n<p>However I believe this backtracking is not happening in your specific example, and I think it's actually a related issue to the other one. Bear with me while I investigate.</p>\n<blockquote>\n<p>Best,<br>\nAndreas</p>\n<p>On 23/04/15 03:48, Daniel Matichuk wrote:</p>\n<blockquote>\n<p>Hi Andreas,</p>\n<p>Unfortunately the ITP paper is slightly out of date, specifically regarding rule instantiation. The \"match\" method is now meant to guard rule instantiation at run-time by ensuring that the matched theorem(s) has<br>\nthe correct slots available. This is done by using meta-quantifiers in your patterns. Specifically the semantics of a match are that a \"for-fixed\" variable may match anything, whereas a meta-quantified variable<br>\nmust match against a schematic. So in your example, assuming you wish to instantiate \"P\", your pattern should be \"!!P. PROP P ==&gt; f u v\" for u v\". This statically ensures that any matched rule can be instantiated appropriately (so the failure occurs in the match, rather than the rule instantiation).<br>\nThe motivation for this requirement is perhaps more clear when using match to define an Eisbach method, rather than when used in-place.</p>\n<p>It's also worth noting that a pattern like \"f x y\" for f x y will produce a large set of possible matches, due to \"match\" using the unifier internally. The usual best-practice approach is to add type annotations to your pattern to restrict the matches.<br>\nThere is some argument for extending the match pattern language to support more precise term deconstruction, but I'm waiting to see more use cases before adding more complexity.</p>\n<p>On 20 Apr 2015, at 10:49 pm, Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Eisbach developers,</p>\n<p>First of all, thanks for designing and implementing Eisbach. Unfortunately, I am struggling with instantiating variables in rules when I write my own proof methods in Eisbach.</p>\n<p>Abstractly,<br>\n1. I select a rule R by matching a list L of theorems against a term, and<br>\n2. then instantiate a variable in R with a term obtained by matching the conclusion against a pattern.</p>\n<p>Unfortunately, I always get the error \"More instantiations than variables in theorem\" although all the theorems in the list L contain at least one variable. I do not know where this error comes from. Below is a small example:</p>\n<p>theory Scratch imports Main \"~~/src/HOL/Eisbach/Eisbach_Tools\" begin</p>\n<p>consts foo :: \"'a ⇒ 'a ⇒ 'a ⇒ bool\"<br>\nlemma my_thms: \"foo x y z ⟹ z ∧ y\" \"foo x y y ⟹ x ∧ z\" sorry</p>\n<p>lemma \"⋀z. A z ∧ B\"<br>\napply(<br>\n match concl in \"f x y\" for f x y ⇒ ‹<br>\n   match my_thms in R:\"PROP P ⟹ f u v\" for P u v ⇒ ‹<br>\n     rule R[of x]<br>\n   ›<br>\n ›<br>\n)<br>\noops</p>\n<p>end</p>\n<p>Thanks for any help,<br>\nAndreas</p>\n<p>PS: I am trying to build something similar to the apply_split method in the Eisbach paper presented at ITP2014.<br>\n</p>\n</blockquote>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294636294,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160268
    }
]