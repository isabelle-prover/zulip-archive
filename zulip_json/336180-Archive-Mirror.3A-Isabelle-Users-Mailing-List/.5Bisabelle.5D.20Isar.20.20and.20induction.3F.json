[
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi David,</p>\n<blockquote>\n<p>In the last line of the following proof I am tring  to use a  known<br>\nfact  (that is something that appears in the  prems list of facts) by<br>\nplacing it between \\&lt;langle&gt; and \\&lt;rangle&gt;.<br>\nAm I unable to  refer to facts like this?</p>\n</blockquote>\n<p>In recent Isabelle versions (post-2005 developer's version, I believe),<br>\nyou can refer to literal facts using backquotes. They are just converted<br>\nto the small angle brackets in printed theory sources.</p>\n<p>lemma \"A --&gt; A\"<br>\nproof<br>\n  assume \"A\"</p>\n<p>from <code>A</code> show \"A\" .<br>\nqed</p>\n<p>Note that there are also other ways to reference facts:</p>\n<ul>\n<li>\n<p>If you are inside a \"case\", the name of the case refers to a list of<br>\nassumptions</p>\n</li>\n<li>\n<p>You can use prems(i) (where i is a number). This actually works for<br>\nany list of facts.</p>\n</li>\n</ul>\n<blockquote>\n<p>using  p proof (induct    rule:   lts.fat_act.induct)  --\" fixing: P<br>\nfails to parse\"</p>\n</blockquote>\n<p>The \"fixing\" option is now called \"arbitrary\".</p>\n<blockquote>\n<p>Question 2.</p>\n<p>The next thing I tried was<br>\n       from  prems tinAB  [where t = s  and A = A and P = (Abs P) and Q<br>\n= (Abs Q)]     show ?case</p>\n<p>but this failed to parse.</p>\n<p>so I rewrote tinAA replacing P by  Abs P  and Q by Abs Q.  Thus I used.</p>\n<p>from  prems tinAB  [where t = s  and A = A and P = P and Q = Q]   show<br>\n?case</p>\n<p>Have I missed some thing or are  the right hand side of these equalities<br>\nvery restricted?</p>\n</blockquote>\n<p>You are missing quotes:</p>\n<p>from  prems tinAB  [where t = s  and A = A and P =\"(Abs P)\"<br>\n                    and Q = \"(Abs Q)\"]     show ?case</p>\n<p>Every term or type (\"inner syntax\") must be quoted. Just for single<br>\nsymbols, the quotes can be ommitted.</p>\n<blockquote>\n<p>Question 3.  I have defined parallel composition but the transitions in<br>\nthis definition are the union of three somewhat complexe sets. I will<br>\nfrequently need to split these transitions into the three cases and<br>\nproove my results for each case (set).</p>\n</blockquote>\n<p>I haven't looked very closely at your specific instance... but in<br>\ngeneral you want a rule which can be used as an elimination rule. This<br>\nshould have the following format (more or less):</p>\n<p>lemma mytrans_cases:<br>\n  \"t : trans (par P A Q)<br>\n   ==&gt; ((fst_tran t : trans P &amp; ...) ==&gt; C)<br>\n   ==&gt; ((snd_tran t : trans Q &amp; ...) ==&gt; C)<br>\n   ==&gt; (!!a. (act t : trans P &amp; a : liftobs A ...) ==&gt; C)<br>\n   ==&gt; C\"</p>\n<p>Here is a simple example that actually works:</p>\n<p>definition<br>\n  \"myRel P = {(x,y). P x y | P y x}\"</p>\n<p>lemma myRel_cases[consumes 1]:<br>\n  \"[| (x,y) : myRel P;<br>\n      P x y ==&gt; A;<br>\n      P y x ==&gt; A |]<br>\n  ==&gt; A\"<br>\n  unfolding myRel_def<br>\n  by blast</p>\n<p>lemma example: \"(x,y) : myRel P ==&gt; something\"<br>\nproof -<br>\n  assume \"(x,y) : myRel P\"<br>\n  thus something<br>\n  proof (cases rule:myRel_cases)<br>\n    assume \"P x y\" thus something sorry<br>\n  next<br>\n    assume \"P y x\" thus something sorry<br>\n  qed<br>\nqed</p>\n<p>Note that the existentials in your lemma become universals in the<br>\ncases-theorem, since you are working \"on the left hand side of the arrow\".</p>\n<p>The \"consumes 1\" attribute tells the \"cases\" method to resolve one<br>\npremise with the assumptions in your actual proof. To get a clearer<br>\nunderstanding of what happens here, just leave it out and see what changes.</p>\n<p>If you need the splitting very often, you can also give names to the<br>\ndifferent cases, which makes proofs look nicer. For the simple example:</p>\n<p>lemma myRel_cases[consumes 1, case_names foo bar]:<br>\n  \"[| (x,y) : myRel P;<br>\n      P x y ==&gt; A;<br>\n      P y x ==&gt; A |]<br>\n  ==&gt; A\"<br>\n  unfolding myRel_def<br>\n  by blast</p>\n<p>lemma \"(x,y) : myRel P ==&gt; something\"<br>\nproof -<br>\n  assume \"(x,y) : myRel P\"<br>\n  thus something<br>\n  proof (cases rule:myRel_cases)<br>\n    case foo thus something sorry<br>\n  next<br>\n    case bar thus something sorry<br>\n  qed<br>\nqed</p>\n<p>You will be excited about how pretty your proofs can become :-)</p>\n<p>Alex</p>",
        "id": 294049316,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818710
    }
]