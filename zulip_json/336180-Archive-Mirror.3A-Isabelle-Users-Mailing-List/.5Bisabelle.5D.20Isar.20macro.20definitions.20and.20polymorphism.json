[
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:uuomul@yahoo.com\">uuomul@yahoo.com</a>&gt;<br>\nHello, </p>\n<p>I have trouble understanding the following behavior of macros w.r.t. <br>\npolymorphism. Consider the following situation: </p>\n<p>consts f :: \"nat =&gt; 'a\"<br>\nconsts g :: \"'a =&gt; nat\" </p>\n<p>lemma L1: fixes n::nat   shows \"g(f n) = undefined\"<br>\nproof-<br>\n  term f    (* has type \"nat =&gt; 'b\" OK *)<br>\n  term g    (* has type \"'b =&gt; nat\" OK *)<br>\n  (* So my understanding was that, inside this proof, 'b acts like a <br>\n    fixed unspecified type.  *)<br>\n  term \"g(f(n))\"  (* has type \"nat\" OK *)<br>\n  let ?c = \"g(f n)\"<br>\n  term \"?c\"  <br>\n  (* ?c is now \"%TYPE. g (f n)\" and has type \"'b itself =&gt; nat\" WHY? *)<br>\n  let ?d = \"(g::'b =&gt; nat)((f::nat =&gt; 'b) n)\"<br>\n  term ?d  (* This did not work either  *)<br>\n  (* Neither does this: *)<br>\n  have \"?d _ = (g::'b =&gt; nat)((f::nat =&gt; 'b) n)\" sorry<br>\n  show ?thesis sorry<br>\nqed</p>\n<p>But the following works as expected: </p>\n<p>lemma L2 fixes n::nat <br>\nshows \"(g::'b =&gt; nat)((f::nat =&gt; 'b) n) = undefined\"<br>\nproof-<br>\n  term \"g(f(n))\"  (* has type \"nat\" OK *)<br>\n  let ?d = \"(g::'b =&gt; nat)((f::nat =&gt; 'b) n)\"<br>\n  term \"?d\"  (* has type \"nat\" OK *)<br>\n  show ?thesis sorry<br>\nqed</p>\n<blockquote>\n<p>From outside, the two lemmas L1 and L2 are identical.  </p>\n</blockquote>\n<p>1) Why is it that macros seemingly take into consideration some <br>\nextra generality? <br>\nAnd what does this generality mean -- is it a form of universal <br>\nquantification over types?  </p>\n<p>2) What is the status difference between the type variable <br>\n'b from L1 (that was provided automatically) and the one from L2 (that <br>\nwas declared explicitly)?  Before encountering the above, I was <br>\nassuming there is no difference. </p>\n<p>Thank you in advance for any explanations on this.  </p>\n<p>Andrei</p>",
        "id": 294092275,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832234
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Andrei,</p>\n<p>If you turn on \"Show Sorts\" and \"Show Consts\", then you should be able<br>\nto see what is going on with your example.</p>\n<p>On Thu, Nov 12, 2009 at 2:07 PM, Andrei Popescu &lt;<a href=\"mailto:uuomul@yahoo.com\">uuomul@yahoo.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have trouble understanding the following behavior of macros w.r.t.<br>\npolymorphism. Consider the following situation:</p>\n<p>consts f :: \"nat =&gt; 'a\"<br>\nconsts g :: \"'a =&gt; nat\"</p>\n<p>lemma L1: fixes n::nat   shows \"g(f n) = undefined\"</p>\n</blockquote>\n<p>At this point, 'a is a fixed, unspecified type. The \"f\" in the goal<br>\nhas type \"nat =&gt; 'a\" and the \"g\" in the goal has type \"'a =&gt; nat\". If<br>\nyou have \"Show Sorts\" turned on, then the goal display will include a<br>\nline like \"type variables: 'a :: type\" telling you that 'a is a fixed<br>\ntype.</p>\n<blockquote>\n<p>proof-<br>\n term f    (* has type \"nat =&gt; 'b\" OK *)<br>\n term g    (* has type \"'b =&gt; nat\" OK *)<br>\n (* So my understanding was that, inside this proof, 'b acts like a<br>\n   fixed unspecified type.  *)</p>\n</blockquote>\n<p>Here, Isabelle is telling you that terms f and g are polymorphic,<br>\nwhich it would usually denote with the types \"nat =&gt; 'a\" and \"'a =&gt;<br>\nnat\", respectively. But since type variable 'a is already used,<br>\nIsabelle uses the next available free type variable, which is 'b.</p>\n<blockquote>\n<p>term \"g(f(n))\"  (* has type \"nat\" OK *)<br>\n let ?c = \"g(f n)\"<br>\n term \"?c\"<br>\n (* ?c is now \"%TYPE. g (f n)\" and has type \"'b itself =&gt; nat\" WHY? *)</p>\n</blockquote>\n<p>The term \"g(f(n))\" has type \"nat\", but there is also a free variable<br>\ninside the term. The fully type-annotated term is<br>\n\"(g::'b=&gt;nat)((f::nat=&gt;'b)(n::nat)) :: nat\" (Remember that 'b here<br>\nindicates polymorphism; it is not a fixed type in this context.)</p>\n<p>The extra parameter of type 'b itself is Isabelle's way of dealing<br>\nwith this situation where term contains a free type variable that does<br>\nnot appear in the term's type.</p>\n<p>When defining a constant or abbreviation, all polymorphic type<br>\nvariables in the term are required to appear in the type of the term.<br>\nFor example, if you try the following definition command, Isabelle<br>\nwill give you a \"Specification depends on extra type variables\" error:</p>\n<p>definition c :: \"nat =&gt; nat\" where \"c n = g (f n)\"</p>\n<p>When defining abbreviations with \"let\" inside a proof script, Isabelle<br>\nhas a workaround for this restriction: It adds an extra parameter to<br>\nchange the type from \"nat\" (which is not allowed since it doesn't<br>\nmention 'b) to \"'b itself =&gt; nat\" (which is OK).</p>\n<blockquote>\n<p>let ?d = \"(g::'b =&gt; nat)((f::nat =&gt; 'b) n)\"<br>\n term ?d  (* This did not work either  *)</p>\n</blockquote>\n<p>This means exactly the same thing as the previous definition of ?c.</p>\n<p>If you had instead typed</p>\n<p>let ?d = \"(g::'a =&gt; nat)((f::nat =&gt; 'a) n)\"</p>\n<p>Then the extra TYPE parameter would disappear. Since 'a is a fixed<br>\ntype variable in the proof context, it is OK to define an abbreviation<br>\nfor a term mentioning 'a whose type doesn't mention 'a.</p>\n<blockquote>\n<p>(* Neither does this: *)<br>\n have \"?d _ = (g::'b =&gt; nat)((f::nat =&gt; 'b) n)\" sorry<br>\n show ?thesis sorry<br>\nqed</p>\n<p>But the following works as expected:</p>\n<p>lemma L2 fixes n::nat<br>\nshows \"(g::'b =&gt; nat)((f::nat =&gt; 'b) n) = undefined\"<br>\nproof-<br>\n term \"g(f(n))\"  (* has type \"nat\" OK *)<br>\n let ?d = \"(g::'b =&gt; nat)((f::nat =&gt; 'b) n)\"<br>\n term \"?d\"  (* has type \"nat\" OK *)<br>\n show ?thesis sorry<br>\nqed</p>\n</blockquote>\n<p>Yes, this one works because the type variable in term ?d and the type<br>\nvariable in the goal are the same.</p>\n<blockquote>\n<blockquote>\n<p>From outside, the two lemmas L1 and L2 are identical.</p>\n</blockquote>\n<p>1) Why is it that macros seemingly take into consideration some<br>\nextra generality?<br>\nAnd what does this generality mean -- is it a form of universal<br>\nquantification over types?</p>\n<p>2) What is the status difference between the type variable<br>\n'b from L1 (that was provided automatically) and the one from L2 (that<br>\nwas declared explicitly)?  Before encountering the above, I was<br>\nassuming there is no difference.</p>\n<p>Thank you in advance for any explanations on this.</p>\n<p>Andrei</p>\n</blockquote>\n<p>I think the original source of all your confusion was with the \"term<br>\nf\" and \"term g\" commands inside the proof script. In these cases,<br>\nIsabelle does <em>not</em> assume that by \"term f\" you mean, \"the type of f<br>\nas it appears in the goal\".</p>\n<p>Also, remember to use \"Show Sorts\" if you ever get confused about<br>\nwhich type variables are fixed in a proof.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294092359,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832265
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:uuomul@yahoo.com\">uuomul@yahoo.com</a>&gt;<br>\nHello Brian, </p>\n<p>Many thanks for the detailed answer -- this does clarify everything.</p>",
        "id": 294092509,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832309
    }
]