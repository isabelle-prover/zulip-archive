[
    {
        "content": "<p>From: Askar Safin via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHello. I want to share my personal experience with Isabelle. I will list<br>\nits issues and give some ideas, which can be implemented in Isabelle and<br>\nother proof assistants. This letter is attempt to help you, I don't want to<br>\nblame you.</p>\n<p>The following issues are very annoying, they are simply distract me from<br>\nusing Isabelle, but unfortunately I simply don't see better alternative at<br>\nthe moment. All they must be considered when developing new proof<br>\nassistants. Unfortunately it seems they cannot be fixed in Isabelle,<br>\nbecause this would require its full rewriting. It will be very nice if some<br>\nof this problems will be addressed in Larry Paulson's (CC'd) project<br>\nAlexandria.</p>\n<p>In 2015 I formalized in Isabelle part of our Moscow State University<br>\nlectures on mathematical logic (using latest Isabelle at that moment).<br>\n(Unfortunately resulting proof script doesn't fully work in Isabelle 2017.)<br>\nThis is lectures: <a href=\"http://lpcs.math.msu.su/vml2010/lectures1-8.pdf\">http://lpcs.math.msu.su/vml2010/lectures1-8.pdf</a> and this<br>\nis my formalization in Isabelle: <a href=\"http://paste.debian.net/hidden/eb960c2e\">http://paste.debian.net/hidden/eb960c2e</a> (I<br>\nwill call it vml2010_fol.thy). I formalized section 3 which proves some<br>\ntheorems about FOL. Even if you don't know Russian, I think you will easily<br>\nunderstand what is going in that Isabelle source. I will use this source as<br>\nan example of Isabelle problems.</p>\n<p>Issues:</p>\n<ol>\n<li>Lack of true partial functions.</li>\n</ol>\n<p>There is a lot of definitions at that section 3 which make sense only if<br>\nsome assumptions apply. For example, I have a datatype for FOL terms and a<br>\nfunction \"Tm\", which returns \"True\" if a term is indeed valid. And lots of<br>\nsubsequent definitions assume that \"Tm\" is true. Unfortunately I don't have<br>\na way to specify this assumption in code, so I have to simply put it to a<br>\ncomment. Here is example:</p>\n<p>(* assumes \"Tm \\&lt;Sigma&gt; t\" *)<br>\nprimrec<br>\n  Tm_vars      :: \"[Var set, raw_Tm] \\&lt;Rightarrow&gt; bool\" and<br>\n  Tm_list_vars :: \"[Var set, raw_Tm list] \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n  \"Tm_vars xs (Var x) \\&lt;longleftrightarrow&gt; x \\&lt;in&gt; xs\"<br>\n| \"Tm_vars xs (Fapp f args) \\&lt;longleftrightarrow&gt; Tm_list_vars xs args\"<br>\n| \"Tm_list_vars xs [] \\&lt;longleftrightarrow&gt; True\"<br>\n| \"Tm_list_vars xs (t # ts) \\&lt;longleftrightarrow&gt; Tm_vars xs t \\&lt;and&gt;<br>\nTm_list_vars xs ts\"</p>\n<p>This was definition of \"variables of this term\" which makes sense only if<br>\nthe term is actually valid (technically the definition will work even if<br>\nterm is \"wrong\", but this is not important).</p>\n<p>There are even more complex cases. For example:</p>\n<p>(*<br>\nassumes \"model \\&lt;Sigma&gt; M\"<br>\nassumes \"image_in g xs (domain M)\"<br>\nassumes \"Tm \\&lt;Sigma&gt; t\"<br>\nassumes \"Tm_vars xs t\"<br>\n*)<br>\nprimrec<br>\n  Tm_value  :: \"[raw_model, raw_Tm     ] \\&lt;Rightarrow&gt; ((Var<br>\n\\&lt;Rightarrow&gt; ZF) \\&lt;Rightarrow&gt; ZF     )\" and<br>\n  Tm_list_value :: \"[raw_model, raw_Tm list] \\&lt;Rightarrow&gt; ((Var<br>\n\\&lt;Rightarrow&gt; ZF) \\&lt;Rightarrow&gt; ZF list)\"<br>\nwhere<br>\n  \"Tm_value _ (Var x) g = g x\"<br>\n| \"Tm_value M (Fapp f args) g = Finterpret M f (Tm_list_value M args g)\"<br>\n| \"Tm_list_value _ [] _ = []\"<br>\n| \"Tm_list_value M (t # ts) g = Tm_value M t g # Tm_list_value M ts g\"</p>\n<p>This was definition of \"value of term in this model\". As you can see it<br>\nassumes that:</p>\n<ul>\n<li>The model is actually the model of a given signature</li>\n<li>Values of variables actually belong to model's domain</li>\n<li>The term is valid</li>\n<li>The term doesn't use variables not listed in \"xs\"</li>\n</ul>\n<p>When I write new definition I must be careful to write in comments all<br>\nassumptions for definitions I use. When I write a lemma I must write all<br>\nassumptions used by definitions. And it is possible that I will forget one<br>\nand Isabelle will not tell me about this. You may say: \"If Isabelle<br>\naccepted your lemma, then it is true in its form, even if you forgot some<br>\nassumption\". Yes, but I want a lemma to convey information I meant. And I<br>\nmeant that proposition only if all assumptions apply, i. e. only if whole<br>\nformula makes sense.</p>\n<p>You may say \"just use option\". Well, yes, it is possible that this will<br>\nmake all assumptions explicit, and I will not be able to forget some<br>\nassumption. But the code will become even larger and it will be even harder<br>\nto read and write it.</p>\n<p>And we still have 0 / 0 = 0. This proposition alone will distract any<br>\n\"working mathematician\". Even computer algebra system Mathematica deal with<br>\ndivision better. (Note that Alexandria announced computer algebra<br>\nintegration).</p>\n<p>What I want is functions which take proof object as an argument. I. e.<br>\ndivision should take as arguments \"a\", \"b\" and proof object of proposition<br>\n\"b ~= 0\". You will say that the syntax will be impossible to read and<br>\nwrite. No. Division will look the same, i. e. \"a / b\", A proof assistant<br>\nwill automatically search proof object for \"b ~= 0\" in the context and pass<br>\nit to division function. I. e. we will write this: \"a = 0 ==&gt; b ~= 0 ==&gt; a<br>\n/ b = 0\" and the proof assistant will transform this to: \"a = 0 ==&gt; !!! p<br>\n::: (b ~= 0). (divide a b p = 0)\". Here this \"!!!\" construct is usual type<br>\ntheory Pi-term. Also we will be able to write something like this:</p>\n<p>have \"b ~= 0\" by ...<br>\n...<br>\nhave \"a / b = c\" by ... (* here the proof assistant found proof object for<br>\nb ~= 0 in the context *)</p>\n<p>Moreover, \"a &amp;&amp;&amp; b\" in Isabelle is \"!! C. (A ==&gt; B ==&gt; C) ==&gt; C\". So, proof<br>\nobject for A is available in B. So we can write, say, \"b ~= 0 &amp;&amp;&amp; a / b =<br>\n1\". But not \"a / b = 1 &amp;&amp;&amp; b ~= 0\". You will say that we break commutation.<br>\nBut this matches actual mathematics practice. Suppose you have read in some<br>\nmathematical article: \"Let's assume that b is not 0 and a / b = 1\". Now<br>\nimagine \"Let's assume that a / b = 1 and b is not 0\". You see? The first<br>\nvariant is natural and the second is not. I think that proof-object-powered<br>\npartial functions really match actual mathematics. We actually assume them<br>\nwhen we talk about mathematics. Especially compared to 0 / 0 = 0.</p>\n<p>True partial function will be especially useful in ZF. Nearly all functions<br>\nwill take proof objects. Say, sum for natural numbers will take proof that<br>\nboth arguments are actually natural numbers. Working in ZF may become easy<br>\nlike HOL. This proof objects will be something like alternative to HOL<br>\ntype-checking.</p>\n<p>Of course, this is not complete solution. I don't know how to deal with<br>\nmeta-implication/object-implication distinction, with non-classical logics<br>\netc.</p>\n<ol start=\"2\">\n<li>There is no proof method which works for all simple cases.</li>\n</ol>\n<p>When I write proof scripts, it is nearly impossible to figure which proof<br>\nmethod (auto, blast etc) I should use and why. Usually I first try \"auto\",<br>\nthen \"blast\", then, say, \"fastforce\", then \"metis\" etc. This is very<br>\nannoying. For example, see this example:<br>\n<a href=\"https://en.wikipedia.org/wiki/Isabelle_(proof_assistant)\">https://en.wikipedia.org/wiki/Isabelle_(proof_assistant)</a> . You see auto,<br>\nfastforce, simp, rule, blast.</p>\n<p>Often \"auto\" and \"blast\" doesn't work, but \"rule\" or \"fact\" or \".\" or \"..\"<br>\nsurprisingly does.</p>\n<p>For example:</p>\n<p>lemma Fm_vars_minus:<br>\n  assumes \"Fm_vars xs A\"<br>\n  shows \"Fm_vars (xs - {x}) (any x A)\" (is ?a)<br>\n  and \"Fm_vars (xs - {x}) (exists x A)\" (is ?e)<br>\nproof -<br>\n  have \"Fm_vars (xs \\&lt;union&gt; {x}) A\" using assms and Fm_vars_subset by<br>\nblast<br>\n  thus ?a and ?e by auto<br>\nqed</p>\n<p>The first step can be proved by \"blast\", but not \"auto\", the second - by<br>\n\"auto\" and not by blast, and even not by \"blast+\".</p>\n<p>Yes, I know that auto uses simplification rules, and blast does not. And<br>\nthus I cannot put \"blast\" instead of \"auto\" in that example. But why we<br>\njust don't have one method which combines power of blast and auto's<br>\nsimplification rules?</p>\n<p>Also, consider this code:</p>\n<p>notepad begin<br>\n  have A and B sorry<br>\n  hence A and B by auto<br>\nend</p>\n<p>\"auto\" works, but blast and metis do not. Yes, I know that I must put \"+\"<br>\nafter blast and metis. But why auto doesn't require such \"+\"? This is<br>\ninconsistency.</p>\n<p>Consider this:</p>\n<p>notepad begin<br>\n  have \"A &amp;&amp;&amp; B\" sorry<br>\n  hence \"A &amp;&amp;&amp; B\" by auto<br>\nend</p>\n<p>Here I simply could not find working method. \"auto+\", \"blast+\", \"metis+\",<br>\n\"rule+\", \"fact+\" - all they fail.</p>\n<p>Consider this (from vml2010_fol.thy):</p>\n<p>have \"(THE x. x \\&lt;in&gt; X \\&lt;and&gt; f x = y) \\&lt;in&gt; X \\&lt;and&gt; f (THE x. x \\&lt;in&gt;<br>\nX \\&lt;and&gt; f x = y) = y\" using x_def and uqAdvInq by (rule theI)</p>\n<p>Why I should write (rule theI) here? Why just \"auto\" doesn't work? Why<br>\n\"auto\" doesn't know anything about theI? Why even \"using theI by auto\"<br>\ndoesn't work?</p>\n<p>Consider this:</p>\n<p>have \"partial_bij_betw f X Y \\&lt;Longrightarrow&gt; f x \\&lt;in&gt; Y<br>\n\\&lt;Longrightarrow&gt; the_inv_into X f (f x) \\&lt;in&gt; X\" by (rule ff1yy)</p>\n<p>Why I cannot write \"using ff1yy by auto\" here? \"auto\" is not powerful<br>\nenough to replace \"y\" with \"f x\"? Why \"using ff1yy by blast\" doesn't work?<br>\n\"using ff1yy by metis\" surprisingly works. But metis doesn't support<br>\nsimplification, and so will not work in similar situation where<br>\nsimplification will be also required.</p>\n<p>Consider this:</p>\n<p>also have \"... \\&lt;longleftrightarrow&gt; (\\&lt;forall&gt; obj \\&lt;in&gt; domain M'.<br>\ncalc M' A (\\&lt;lambda&gt; y. if y = x then obj else (\\&lt;phi&gt; \\&lt;circ&gt; g) y))\"<br>\nusing partial_bij_betw_any and bij .</p>\n<p>Why auto and blast don't work, but \".\" does?! As well as I know \".\" is<br>\nsimple method, so why it works when more powerful methods such as auto and<br>\nblast doesn't work?</p>\n<p>Isabelle is too similar to programming. Hypothetical \"working<br>\nmathematician\" will simply cry.</p>\n<hr>\n<p>Recently I found out Alexandria. I think you should take this project as<br>\nopportunity to develop better proof assistant and possible rewrite<br>\neverything. Instead of basing everything on top of Isabelle in its current<br>\nform (0 / 0 = 0). I don't mean I want to participate in the project, I just<br>\ngave some ideas. I hope you will use this opportunity to do something good.</p>\n<p>Feel free to publish this letter or any parts of it anywhere, say, in some<br>\nmathematical magazine.</p>\n<p>==<br>\nAskar Safin<br>\n<a href=\"http://vk.com/safinaskar\">http://vk.com/safinaskar</a></p>",
        "id": 294739706,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191081
    },
    {
        "content": "<p>From: José Manuel Rodriguez Caballero &lt;<a href=\"mailto:josephcmac@gmail.com\">josephcmac@gmail.com</a>&gt;<br>\nThe beautiful formula 0 / 0 = 0 makes sense to a mathematician, although<br>\nthis was not the original motivation. I interprete it as the identification<br>\nbetween 0 and infinity. Indeed, let G be the multiplicative group of<br>\nnon-zero real numbers. This is a Lie group with two connected components:<br>\nthe positive real numbers and the negative ones. Let H be the union of G<br>\nwith the zero. In H we take the topology from G and  we define the set of<br>\nfundamental neighbourhoods of zero to be the set of real numbers either<br>\nlarger than n or smaller than 1/n.</p>\n<p>Consider the function f(x) = 1/x if x is non-zero and f(0) = k. This<br>\nfunction transform H into itself. It is easy to prove that f(x) is<br>\ncontinuous in H if and only if k = 0. Notice that f(0) = 0 can be rewritten<br>\nas 0/0 = 0 using a slight abuse of notation.</p>\n<p>Jose M.</p>",
        "id": 294739769,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191090
    },
    {
        "content": "<p>From: José Manuel Rodriguez Caballero &lt;<a href=\"mailto:josephcmac@gmail.com\">josephcmac@gmail.com</a>&gt;<br>\ntypographical correction (I forgot to multiply by 0 at the right)</p>\n<p>0*f(0) = 0 can be rewritten as 0/0 = 0 using a slight abuse of notation.</p>\n<p>Jose M.</p>\n<p>2018-08-15 5:28 GMT-04:00 José Manuel Rodriguez Caballero &lt;<br>\n<a href=\"mailto:josephcmac@gmail.com\">josephcmac@gmail.com</a>&gt;:</p>",
        "id": 294739785,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191096
    },
    {
        "content": "<p>From: José Manuel Rodriguez Caballero &lt;<a href=\"mailto:josephcmac@gmail.com\">josephcmac@gmail.com</a>&gt;<br>\nanother typographical correction<br>\nin place of<br>\nthe set of real numbers either larger than n or smaller than 1/n.</p>\n<p>read</p>\n<p>set of real numbers which in absolute value are either larger than n or<br>\nsmaller than 1/n.</p>\n<p>2018-08-15 5:33 GMT-04:00 José Manuel Rodriguez Caballero &lt;<br>\n<a href=\"mailto:josephcmac@gmail.com\">josephcmac@gmail.com</a>&gt;:</p>",
        "id": 294739797,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191102
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nDear Askar, thanks for your thoughtful message. It's always valuable to have feedback from new users.</p>\n<ol>\n<li>The question of partial functions has been around for a long time, and the following 20 year old survey is still worth reading: Treating Partiality in a Logic of Total Functions &lt;<a href=\"http://wwwbroy.in.tum.de/publ/papers/MS97.pdf\">http://wwwbroy.in.tum.de/publ/papers/MS97.pdf</a>&gt; (Müller and Slind, 1996). I won't repeat the arguments here. I would merely mention that other approaches have been tried in other systems. PVS &lt;<a href=\"http://pvs.csl.sri.com/\">http://pvs.csl.sri.com/</a>&gt; can support partial functions (by generating validity conditions), as did IMPS &lt;<a href=\"https://link.springer.com/article/10.1007/BF00881906\">https://link.springer.com/article/10.1007/BF00881906</a>&gt; (using a calculus of definedness). As I understand it, type theory-based systems such as Coq &lt;<a href=\"https://coq.inria.fr/\">https://coq.inria.fr/</a>&gt; also handle partial functions (using the implicit argument approach you outline, along with irrelevance of proofs). The penalty for using more complicated approaches is that proofs become longer and more difficult.</li>\n</ol>\n<p>It's a good bet that anybody using Isabelle or HOL is willing to live with a calculus of total functions only. As that survey article describes, we can formalise what we want to express well enough, without being forced to repeatedly prove that subexpressions are defined. You mention your wish to make assumptions explicit (e.g., that an FOL term is well-defined), even when those assumptions aren't needed to prove the given property. But one could equally say that the formalism itself is telling us which assumptions are needed and which are not. Your theory only regards an FOL term as well-defined if each function application has the required number of arguments, and yet the set of variables in a raw term is perfectly meaningful regardless of that.</p>\n<p>Division is another excellent example. It's easy to imagine that postulating x/0 = 0 introduces inconsistency, but instead it reveals which identities are sensitive to division by zero and which are not. We discover that x/x=1 still requires the assumption that x is nonzero, while (u+v)/x = u/x + v/x does not. Most of us are happy to have as few assumptions as possible, as this makes proofs easier.</p>\n<ol start=\"2\">\n<li>We'd certainly like to have a proof method that works for all simple cases, but it isn't easy. In theory, auto should do it, but as you note, it doesn't (and auto is unlikely to change very much). Work on better automation has been ongoing for decades now. Sledgehammer is one attempt at a magic bullet, but it's also defeated in some surprisingly easy cases. But a lot of new work is promising, e.g. Zhan's auto2 &lt;<a href=\"https://arxiv.org/abs/1707.04757\">https://arxiv.org/abs/1707.04757</a>&gt; and some recent work by Nagashima, e.g. PSL &lt;<a href=\"https://arxiv.org/abs/1606.02941\">https://arxiv.org/abs/1606.02941</a>&gt;. </li>\n</ol>\n<p>Mathematicians who use Isabelle today are pioneers, which means that some things will be painful, but on the other hand, they will be the first to make new discoveries.</p>\n<p>Larry Paulson</p>",
        "id": 294739824,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191115
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear Askar,</p>\n<p>just a small practical tip (in case you don't use  this already)<br>\nit saves plenty of time to use the keyword : \"try0 \"<br>\nwhich tries several methods and tells you if one of them works,<br>\nso the users don't need to try them all one by one themselves.</p>\n<p>Also the keyword \"try\" does the above plus moreover runs sledgehammer <br>\nand looks for counterexamples with quickcheck and nitpick,<br>\nso you don't need to try all the proof methods separately one by one <br>\nyourself.</p>\n<p>Best wishes,<br>\nAngeliki</p>",
        "id": 294739925,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191157
    },
    {
        "content": "<p>From: Askar Safin via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nLawrence, current approach with partial functions lacks any mathematical<br>\naccuracy.</p>\n<p>You said that \"x / x = 1\" requires assumption \"x ~= 0\", but \"(u+v)/x = u/x</p>\n<ul>\n<li>v/x\" does not. And you present this as feature. This is not a feature,<br>\nthis is absolutely strange behavior. What will \"working mathematician\" say<br>\nabout this? Let both theorems require \"x ~= 0\". This makes slightly harder<br>\nto use this theorems, but this will make whole system more sound.</li>\n</ul>\n<p>Look at this:</p>\n<p>(* Current behavior *)<br>\nlemma l1: \"(u+v)/x = u/x + v/x\" sorry<br>\nnotepad begin<br>\nassume \"c ~= 0\" (* Usually we work with assumption that denominator is non-zero anyway *)<br>\n... (* Some steps *)<br>\nhave \"(a+b)/c = a/c + b/c\" using l1 by auto</p>\n<p>(* With implicit proof object arguments *)<br>\nlemma l1: assumes \"x ~= 0\" shows \"(u+v)/x = u/x + v/x\" sorry<br>\nnotepad begin<br>\nassume a1: \"c ~= 0\"<br>\n... (* Some steps *)<br>\nhave \"(a+b)/c = a/c + b/c\" using l1 and a1 by auto</p>\n<p>As you can see the only thing that my proposal adds is \"and a1\". So, proofs<br>\nbecome just slightly bigger, but a lot more sound. Moreover, if we mandate<br>\nall assumptions, some proofs will become even shorter! For example, actual<br>\nlemma inverse_inverse_eq \"inverse (inverse a) = a\" uses proof by cases \"a =<br>\n0\", it will be simpler if we know that \"a ~= 0\".</p>\n<p>Finally, I'm making another proposal. Let all proof methods (auto, blast<br>\netc) automatically extract from environment facts about well-definedness of<br>\nits premises and goals. So, under this new proposal you will not need even<br>\nwrite \"and a1\" like in example above. Moreover, you will not need to<br>\nexplicitly pass similar assumption even if you use lemma \"x/x = 1\", so<br>\nproof will always become not bigger than currently. But in all cases you<br>\nwill need to have all assumptions available in context, of course.</p>\n<p>Taking proof objects as arguments will allow us to make true \"THE\"<br>\nconstruct and true Hilbert's choice operator. It will be possible to write<br>\n\"THE x. P x\" only if we know that \"?! x. P x\" and similar condition for<br>\nHilbert's choice. Current THE and SOME are absolutely strange to \"working<br>\nmathematician\".</p>\n<p>I often see argument form some people that proof assistants should be as<br>\nclose to \"real mathematics\" as possible, because:</p>\n<ol>\n<li>This is why we create proof assistants</li>\n<li>This is only way to get mathematicians to work with proof assistants</li>\n</ol>\n<p>Thus these people argue that proof assistants should be based on ZFC,<br>\nbecause \"real math\" uses ZFC, that proof assistants should be classical,<br>\nbecause \"real math\" is classical. I partially agree with such position. And<br>\nin \"real math\" we have true partial functions (and 0/0=0 have nothing to do<br>\nwith \"real math\"). So, we need them [i. e. partial functions] here, in<br>\nproof assistants.</p>\n<p>But my arguments are not purely theoretical. See: first of all, with true<br>\npartial functions you will never handle strange cases like division by zero<br>\n(as opposed to current proof of inverse_inverse_eq). Second (and this is<br>\nvery important!), you will catch errors early. You will not be even state<br>\nlemma if you didn't list all assumptions. Thus you will catch error when<br>\nyou state your lemma and not when you will unable to prove it after several<br>\nhours.</p>\n<p>My proposals can dramatically change proofs in ZF. Consider this:</p>\n<p>(* Common part *)<br>\nlemma add_nat: \"a : nat ==&gt; b : nat ==&gt; a + b : nat\" sorry (* Here I use \"+\" for raw_add from standard library *)<br>\nlemma add_comm: \"a : nat ==&gt; b : nat ==&gt; a + b = b + a\" sorry<br>\nlemma add_assoc: \"a : nat ==&gt; b : nat ==&gt; c : nat ==&gt; (a + b) + c = a + (b + c)\" sorry</p>\n<p>(* Current behavior *)<br>\nnotepad begin<br>\nassume a: \"a : nat\" and b: \"b : nat\" and c: \"c : nat\"<br>\nhence \"b + a : nat\" using add_nat by auto<br>\nhave \"(a + b) + c = (b + a) + c\" using a and b and add_comm by auto<br>\nalso have \"... = c + (b + a)\" using ba and c and add_comm by auto<br>\nalso have \"... = (c + b) + a\" using a and b and c and add_assoc by auto<br>\nfinally have \"a + b + c = c + b + a\" .<br>\nend</p>\n<p>Now I'm making third proposal. Not only prover should extract<br>\nwell-definedness facts for terms from context, but also it should try to<br>\nprove them.</p>\n<p>(* If all 3 my proposals apply *)<br>\nnotepad begin<br>\nassume \"a : nat\" and \"b : nat\" and \"c : nat\"<br>\nhave \"(a + b) + c = (b + a) + c\" using add_comm by auto<br>\nalso have \"... = c + (b + a)\" using add_comm by auto<br>\nalso have \"... = (c + b) + a\" using add_assoc by auto<br>\nfinally have \"a + b + c = c + b + a\" .<br>\nend</p>\n<p>As you can see, proof became considerably smaller and simpler. And now we<br>\ndon't need tricks like \"natify\" from standard lib. That \"natify\" version<br>\nfrom standard library is nonsense (why add two non-numbers?) and doesn't<br>\nearly detect errors.</p>\n<p>So, working with sets like \"nat\" will become as easy as working with types.<br>\nAnd thus ZFC will became as easy to work with as HOL!!!</p>\n<blockquote>\n<p>Treating Partiality in a Logic of Total Functions (Müller and Slind, 1996)<br>\nAll methods proposed in this article are not satisfactory as opposed to<br>\ntrue partial function. Because all they allow one to write term \"0 / 0\",<br>\nand it will type-check.</p>\n</blockquote>\n<blockquote>\n<p>It's a good bet that anybody using Isabelle or HOL is willing to live with a calculus of total functions only<br>\nSo, you mean that everybody wanting partiality already moved to other<br>\nsystems? Unfortunately, I cannot move to systems supporting partiality,<br>\nbecause they lack some Isabelle features. I tried Coq, it allows<br>\nconstructing true partial functions. But its standard library has total<br>\ndivision instead of partial one. And Coq has very strange type system as<br>\nopposed to natural Isabelle's HOL. Coq's proofs are unreadable. I like<br>\nIsabelle's foundations, logic framework, nice declarative proofs, IDE. I<br>\nwant something like Isabelle, but with partiality, but as well as I know<br>\nthere is no currently such system. And it would be very good if you will<br>\nuse Alexandria project to create such system.</p>\n</blockquote>\n<p>Freek Wiedijk [CC'd] in his slides \"The next generation of proof<br>\nassistants: ten questions\" ( <a href=\"http://www.cs.ru.nl/~freek/talks/lsfa.pdf\">http://www.cs.ru.nl/~freek/talks/lsfa.pdf</a> )<br>\ngives the following Tobias Nipkow's (CC'd) quote: \"Occasionally I do [hate<br>\nthe totality of the HOL logic]. But mostly not. The next generation of<br>\nproof assistants will take it into account\".</p>\n<p>So, when this \"next generation of proof assistants\" will emerge?! How long<br>\nshould I wait for them?! Why not to create them right now?!!! Why not use<br>\nAlexandria's money to create the future now?!!!</p>\n<p>==<br>\nAskar Safin<br>\n<a href=\"http://vk.com/safinaskar\">http://vk.com/safinaskar</a></p>",
        "id": 294740798,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191446
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>You said that \"x / x = 1\" requires assumption \"x ~= 0\", but \"(u+v)/x = u/x<br>\n+ v/x\" does not. And you present this as feature. This is not a feature,<br>\nthis is absolutely strange behavior. What will \"working mathematician\" say<br>\nabout this? Let both theorems require \"x ~= 0\". This makes slightly harder<br>\nto use this theorems, but this will make whole system more sound.</p>\n</blockquote>\n<p>As Larry has already said, this has literally nothing to do with<br>\nsoundness. See also &lt;<a href=\"https://www.hillelwayne.com/post/divide-by-zero/\">https://www.hillelwayne.com/post/divide-by-zero/</a>&gt;<br>\nfor a survey on this.</p>\n<blockquote>\n<p>So, when this \"next generation of proof assistants\" will emerge?! How long<br>\nshould I wait for them?! Why not to create them right now?!!!</p>\n</blockquote>\n<p>Nobody prevents you from working on a next-generation proof assistant.<br>\nIn fact, I think many people would be very excited about a proof of concept.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294740808,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191452
    },
    {
        "content": "<p>From: Askar Safin via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nI will repeat: main drawback of Isabelle's totality is need to manually<br>\nkeep track of assumptions, i. e. see my first letter, where I had to write<br>\nall assumptions in comments without any help from Isabelle. This was main<br>\nreason I gave up on developing this proof script more.</p>\n<p>And the second drawback is that what I write doesn't correspond to what I<br>\nmean. When I write \"(x + y) / z = x / z + y / z\" I mean \"only if z ~= 0\",<br>\nbut Isabelle doesn't require such assumption. So, I have to manually make<br>\nsure that such assumption is always present in the context and thus what I<br>\nwrite is actually correspond to what I mean.</p>\n<p>So, current approach lacks some degree of automation.</p>\n<p>And finally, I will say again that division is partial in actual<br>\nmathematics. Actual proofs assume partial division, and proof assistants<br>\nmust do the same to be close to real math. I will repeat that phrase \"Let's<br>\nassume that b ~= 0 and a / b = 4\" is OK for mathematical text, but \"Let's<br>\nassume that a / b = 4 and b ~= 0\" is not, and thus the same should apply to<br>\nproof assistants. It should be possible to directly convert any mathematical<br>\ntext to proof script.</p>\n<p>==<br>\nAskar Safin<br>\n<a href=\"http://vk.com/safinaskar\">http://vk.com/safinaskar</a></p>",
        "id": 294740824,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191458
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nOn Do, 2018-08-23 at 18:35 +0300, Askar Safin via Cl-isabelle-users<br>\nwrote:</p>\n<blockquote>\n<blockquote>\n<p>As Larry has already said, this has literally nothing to do with<br>\nsoundness. See also &lt; <a href=\"https://www.hillelwayne.com/post/divide-by-ze\">https://www.hillelwayne.com/post/divide-by-ze</a><br>\nro/ &gt;<br>\nfor a survey on this.<br>\nI will repeat: main drawback of Isabelle's totality is need to<br>\nmanually<br>\nkeep track of assumptions, i. e. see my first letter, where I had to<br>\nwrite<br>\nall assumptions in comments without any help from Isabelle. This was<br>\nmain<br>\nreason I gave up on developing this proof script more.</p>\n</blockquote>\n<p>And the second drawback is that what I write doesn't correspond to<br>\nwhat I<br>\nmean. When I write \"(x + y) / z = x / z + y / z\" I mean \"only if z ~=<br>\n0\",<br>\nbut Isabelle doesn't require such assumption. So, I have to manually<br>\nmake<br>\nsure that such assumption is always present in the context and thus<br>\nwhat I<br>\nwrite is actually correspond to what I mean.</p>\n</blockquote>\n<p>Another option would be to encode partiality explicitly, on top of HOL,<br>\ne.g., by lifting everything into an option monad. Then, you could use<br>\nIsabelle's standard reasoning tools to reason about definedness. I<br>\ndoubt that definedness is trivial enough to do it fully automatic,<br>\ne.g., what is about \"1/f(x)\", with a very complicated f, that has a<br>\nvery complicated proof that !x. f(x) ~= 0.</p>\n<p>However, current Isabelle lacks automation or syntax support for such<br>\nan embedding, but maybe this might be a more feasible short-term<br>\nsolution than writing a new proof assistant from scratch.</p>\n<blockquote>\n<p>So, current approach lacks some degree of automation.</p>\n<p>And finally, I will say again that division is partial in actual<br>\nmathematics. Actual proofs assume partial division, and proof<br>\nassistants<br>\nmust do the same to be close to real math. I will repeat that phrase<br>\n\"Let's<br>\nassume that b ~= 0 and a / b = 4\" is OK for mathematical text, but<br>\n\"Let's<br>\nassume that a / b = 4 and b ~= 0\" is not, and thus the same should<br>\napply to<br>\nproof assistants. </p>\n</blockquote>\n<p>This imposes an execution order! But don't you also want to have <br>\n\"a&amp;b = b&amp;a\", and substitution? then both terms must have the same<br>\nmeaning.</p>\n<p>Of course, in the option monad, you could explicitly define a <br>\nshort-circuit version of \"&amp;\", which, however, would not be commutative.</p>",
        "id": 294740841,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191464
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 23/08/18 16:44, Askar Safin via Cl-isabelle-users wrote:</p>\n<blockquote>\n<p>lemma l1: assumes \"x ~= 0\" shows \"(u+v)/x = u/x + v/x\" sorry<br>\nnotepad begin<br>\nassume a1: \"c ~= 0\"<br>\n... (* Some steps *)<br>\nhave \"(a+b)/c = a/c + b/c\" using l1 and a1 by auto</p>\n</blockquote>\n<p>Just a side remark on proper naming of facts in Isabelle/Isar: if you<br>\nneed meaningless names, you can just use <em>, <strong>, </strong></em> or decimal numerals<br>\n1, 2, 3, ...</p>\n<p>There is no need to have a prefix like \"l\" for \"lemma\" or \"a\" for<br>\nassumption above. In fact, it is bad style to decorate fact names<br>\naccording to there provenience, especially in  Isar proofs, where facts<br>\noften change there origin between 'assume', 'obtain', 'case', 'have',<br>\n'show', 'note' etc.</p>\n<blockquote>\n<p>have \"(a+b)/c = a/c + b/c\" using l1 and a1 by auto</p>\n</blockquote>\n<p>More stylistic notes: Isar goals can have before and after it. Before<br>\nyou have important things from the local proof context, after it<br>\nrelevant global things from the library. According to this rule of of<br>\nthumb, the above becomes:</p>\n<p>from a1 have \"(a+b)/c = a/c + b/c\" using l1 by auto</p>\n<p>This discipline works more smoothly, if you always expand the old<br>\n(obsolete) command abbreviations \"hence\" == \"then have\" and \"thus\" ==<br>\n\"then show\" -- on average they make proof texts longer, and harder to write.</p>\n<p>Makarius</p>",
        "id": 294741036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191544
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nDear Askar,</p>\n<p>The problem is that different mathematicians have quite different ideas of what a proof assistant should do. Some people want mathematics to be typed while other people firmly reject type systems. Some would like to see actual texts formalised, including syntactic elements such as parentheses. Some would like to be notified when the statement of a theorem includes assumptions not needed for the proof. You have the opposite wish: you'd like some definitions to be conditional on certain well-formedness assumptions, even when they aren't strictly necessary. It's not a common wish, but note that once you leave the world of definitions, you can include additional assumptions in theorems and they will be checked when you use the theorems.</p>\n<p>An interesting observation about division is that when we put x/0 = 0, we do not change the meaning of definition where it is defined but merely extend its domain. Contrast this with the way division is implemented in computer hardware and in most computer languages: in OCaml I can type</p>\n<h1>-4 mod 3;;</h1>\n<p>val it : int = -1</p>\n<p>and this violates an elementary property of division: that the remainder lies between 0 and the divisor. In other words, division on a computer (any computer) regularly delivers the wrong answer. Somehow people cope with this. Similarly people are able to cope with the formalisms of today's proof assistants, none of which are a perfect match to mathematical reasoning.</p>\n<p>It may be that in the future, somebody will come up with a natural and practical formalisation of partial functions. Probably people are getting research funding for this sort of work. But I have funding for a different research programme.</p>\n<p>Larry</p>",
        "id": 294741275,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191624
    },
    {
        "content": "<p>From: \"Chun Tian (binghe)\" &lt;<a href=\"mailto:binghe.lisp@gmail.com\">binghe.lisp@gmail.com</a>&gt;<br>\nHi,</p>\n<p>I want to point out a similar problem in Isabelle’s Extended_Real theory, in which the sum operator as a total function permits that ∞ + (-∞) = (∞::ereal), the case in which textbooks said it should be avoided (i.e. no definition):</p>\n<p>function plus_ereal where<br>\n  \"ereal r + ereal p = ereal (r + p)\"<br>\n| \"∞ + a = (∞::ereal)\"<br>\n| \"a + ∞ = (∞::ereal)\"<br>\n| \"ereal r + -∞ = - ∞\"<br>\n| \"-∞ + ereal p = -(∞::ereal)\"<br>\n| \"-∞ + -∞ = -(∞::ereal)\"</p>\n<p>HOL4’s extrealTheory [1] currently has the same problem, but its original authors have fixed the definition, and soon it [2] will be submit to HOL4 official.</p>\n<p>What I observed is, having a total function here, many related theorems have simpler proofs and less assumptions, because otherwise lemmas like \"a + b = b + a” is not true any more, if we don’t put extra assumptions that a and b are not mixing of ∞ and (-∞).  I found that, theorem prover doesn’t forbid its user to write down a term which has no definition, just with that term it is not possible to manipulate it with any theorem.</p>\n<p>Is above definition of “plus_ereal” <em>wrong</em>?  I think so, but I don’t think everyone agrees with me.</p>\n<p>—Chun</p>\n<p>[1] <a href=\"https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml\">https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml</a> &lt;<a href=\"https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml\">https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/probability/extrealScript.sml</a>&gt;<br>\n[2] <a href=\"https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml\">https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml</a> &lt;<a href=\"https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml\">https://github.com/binghe/HOL/blob/HOL-Probability/src/probability/extrealScript.sml</a>&gt;<br>\n<a href=\"/user_uploads/14278/i3UauW-UbgQzMV3loWFdm0oF/signature.asc\">signature.asc</a></p>",
        "id": 294741435,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191683
    }
]