[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi list,</p>\n<p>I want to formalize a saturation algorithm.<br>\nThat is, I start with some initial set v_0:: 's set and have a function <br>\nf:: 's set =&gt; 's set that maps sets to additional elements that should <br>\nbe added.</p>\n<p>Imperatively, I have the following algorithm:<br>\ninput: v0<br>\nprecondition: v0 \\subseteq U &amp;  P v0<br>\n  v:=v_0<br>\n  while there is some x with x \\in f v and not x \\in v do v:=v \\cup {x}; od<br>\noutput: v</p>\n<p>Function f is monotonous.</p>\n<p>Termination is because I have a finite set U such that v_0 \\subseteq U <br>\nand v\\subseteq U ==&gt; f v \\subseteq U.</p>\n<p>To prove something about the result, I have an invariant P, such that P <br>\nv_0 and [|P v; x\\in f v - v |] ==&gt; P (v \\cup {x}).</p>\n<p>What approach should I use to formalize this algorithm in isabelle, i.e. <br>\ndefine some Isabelle function algo: 's set =&gt; 's set that describes the <br>\nalgorithm above, and<br>\nhow to prove<br>\n  v0 \\subseteq U &amp; P v0 ==&gt; P algo v0<br>\nand<br>\n  v0 \\subseteq U &amp; P v0 ==&gt; f(algo v0) \\subseteq algo v0</p>\n<p>My main problem with using inductive definition, i.e. somthing like<br>\n  inductive \"algo v0\"<br>\n  intros<br>\n    \"x\\in v0  ==&gt; x \\in algo v0\"<br>\n    \"x\\in f (algo v0) ==&gt; x \\in (algo v0)\"<br>\n  monos f_mono</p>\n<p>is, that I cannot use the invariant P to reason about the correctness of <br>\nthe result. Using algo.induct, I can only reason about single elements <br>\nof (algo v0), but not<br>\nabout the set as whole (as this reasoning would not be correct in <br>\ngeneral for infinite sets).</p>\n<p>Thanks in advance for any hints or pointers to examples of formalization <br>\nof such algorithms.</p>\n<p>-- Peter</p>",
        "id": 294045746,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817214
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nPeter,</p>\n<blockquote>\n<p>I want to formalize a saturation algorithm.<br>\nThat is, I start with some initial set v_0:: 's set and have a function<br>\nf:: 's set =&gt; 's set that maps sets to additional elements that should<br>\nbe added.</p>\n<p>Imperatively, I have the following algorithm:<br>\ninput: v0<br>\nprecondition: v0 \\subseteq U &amp;  P v0<br>\n v:=v_0<br>\n while there is some x with x \\in f v and not x \\in v do v:=v \\cup <br>\n{x}; od<br>\noutput: v</p>\n<p>Function f is monotonous.</p>\n<p>Termination is because I have a finite set U such that v_0 \\subseteq U<br>\nand v\\subseteq U ==&gt; f v \\subseteq U.</p>\n</blockquote>\n<p>It seems the best way to to this is using recdef (I assume you are using <br>\nIsabelle 2005, otherwise the new \"function\" package for partial <br>\nfunctions would be just what you need)</p>\n<p>The problem here is that the function might not terminate if called <br>\noutside the finite set U you mention...? In this case, you might need to <br>\nhave an extra check for this:</p>\n<p>recdef algo \"???\"<br>\n   \"algo v = (if v \\subseteq U then<br>\n               then if f v \\subseteq v then v else algo (v \\union f v)<br>\n               else arbitrary)\"</p>\n<p>for the termination relation, you should be able to construct something <br>\nusing the predefined wellfounded relation \"finite_psubset\".</p>\n<p>I replaced the \"pointwise\" addition by a union, which should be the same <br>\nif f is monotone...</p>\n<blockquote>\n<p>To prove something about the result, I have an invariant P, such that P<br>\nv_0 and [|P v; x\\in f v - v |] ==&gt; P (v \\cup {x}).</p>\n</blockquote>\n<p>From this you should also be able to prove<br>\n   \"[| v \\subseteq U; P v |] ==&gt; P (v \\union f v)\"<br>\n(using your finiteness assumptions and induction) which together with <br>\nalgo.induct gives you your result.</p>\n<p>Hope this helps...<br>\nAlex</p>",
        "id": 294045785,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817225
    }
]