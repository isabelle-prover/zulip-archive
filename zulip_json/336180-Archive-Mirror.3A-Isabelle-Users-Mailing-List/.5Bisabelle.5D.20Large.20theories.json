[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Stanislav,</p>\n<p>I had a similar problem when checking some objects that came out of the Kepler <br>\nconjecture proof where I had 5 definitions of lists of (in total) 20.000 graphs. <br>\nIsabelle choked on those when inputting them as an HOL definition. This is what <br>\nI did instead:</p>\n<ol>\n<li>\n<p>I first defined those lists in ML files so they could be read by by the <br>\nPolyML parser. Then I used some magic to import those ML definitions as HOL <br>\ndefinitions. Here is the magic code:<br>\n<a href=\"http://www.isa-afp.org/browser_info/current/AFP/Flyspeck-Tame/Arch.html\">http://www.isa-afp.org/browser_info/current/AFP/Flyspeck-Tame/Arch.html</a><br>\nCode_Runtime.polyml_as_definition performs that conversion. You would need to <br>\nadapt this to your own situation. It worked because the types used on the ML <br>\nexisted on the HOL level: integers and lists.</p>\n</li>\n<li>\n<p>To reduce the time to check the objects I wrote the checker in the executable <br>\nsubset of HOL. The final theorems<br>\n<a href=\"http://www.isa-afp.org/browser_info/current/AFP/Flyspeck-Tame/ArchComp.html\">http://www.isa-afp.org/browser_info/current/AFP/Flyspeck-Tame/ArchComp.html</a><br>\nwere proved with \"eval\", a proof method that compiles executable theorems to ML <br>\nand runs them there, i.e. reduces them to true or false. (The fact that the <br>\ndefinitions were initially made in ML is orthogonal to the final proof by ML.)</p>\n</li>\n</ol>\n<p>Best<br>\nTobias<br>\n<a href=\"/user_uploads/14278/TmVRPnQlEFiSrvV0KQDuEE3o/smime.p7s\">smime.p7s</a></p>",
        "id": 294676791,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175230
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThese numbers are not that big, but if you go through surface syntax of<br>\nIsabelle (the logical language, the theory and proof language, maybe<br>\neven just ML source language) it is likely to choke.</p>\n<p>Note that the canonical way to import big things into an LCF-style<br>\nprover like Isabelle is to write some ML functions that do that, and<br>\nconstruct terms and proofs by internal means. Never ever generate source<br>\nthat is then fed into the system.</p>\n<p>Examples for reading external material can be seen in src/HOL/SPARK.</p>\n<p>In such applications it is important to recall that surface syntax (for<br>\ninput and output of end-user material) is really just the surface and<br>\nnot the real system. E.g. the SPARK importer turned out incredible slow,<br>\nuntil someone pointed out that there is redundant output of intermediate<br>\nstatements.</p>\n<p>Makarius</p>",
        "id": 294676803,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175235
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 08/06/2016 15:01, Станислав Владимирович Моисеев wrote:</p>\n<blockquote>\n<p>Dear Tobias and Makarius!<br>\nThank you for your links and suggestions.</p>\n<p>Now I realize that it's better to import my objects to ML directly. I will<br>\nconcentrate on this approach.</p>\n<p>I have a question regarding \"eval\" proof method.<br>\nIf one uses \"eval\", what stack of code will one have to trust? Will the \"trusted<br>\nbase\" be larger than that for proofs without \"eval\"?</p>\n</blockquote>\n<p>Yes, you also need to trust the translation of HOL function definitions into ML <br>\nfunction definitions.</p>\n<p>Tobias</p>\n<blockquote>\n<p>If you can give any links discussing the topic of trusted code stack in theorem<br>\nprovers (whether in case of \"eval\" method or not) — I would appreciate it.</p>\n<p>Thank you!<br>\nStanislav.</p>\n<p><a href=\"/user_uploads/14278/l9IBbLlvNjlPZlfiDY7konA-/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294676912,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175261
    },
    {
        "content": "<p>From: Станислав Владимирович Моисе ев &lt;<a href=\"mailto:stanislav.moiseev@gmail.com\">stanislav.moiseev@gmail.com</a>&gt;<br>\nDear Tobias and Makarius!<br>\nThank you for your links and suggestions.</p>\n<p>Now I realize that it's better to import my objects to ML directly. I will<br>\nconcentrate on this approach.</p>\n<p>I have a question regarding \"eval\" proof method.<br>\nIf one uses \"eval\", what stack of code will one have to trust? Will the<br>\n\"trusted base\" be larger than that for proofs without \"eval\"?</p>\n<p>If you can give any links discussing the topic of trusted code stack in<br>\ntheorem provers (whether in case of \"eval\" method or not) — I would<br>\nappreciate it.</p>\n<p>Thank you!<br>\nStanislav.</p>",
        "id": 294677012,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175294
    }
]