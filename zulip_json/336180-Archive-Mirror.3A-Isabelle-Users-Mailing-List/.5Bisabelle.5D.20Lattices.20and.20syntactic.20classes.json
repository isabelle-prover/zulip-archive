[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Viorel,</p>\n<p>the answer to your issue has many facets.</p>\n<p>Historically, syntactic classes where necessary since the class +<br>\noperations &amp; instantiation infrastructure has not yet emerged.  With the<br>\nclass package my first thought was to avoid syntactic classes entirely,<br>\nsince they allow to write down things for which one might expect certain<br>\nproperties to hold, which, in fact, do not, only with more specific sort<br>\nconstraints:</p>\n<p>(a + b) + c = a + (b + c)<br>\n        2 + 2 = 4 -- an Isabelle classic!</p>\n<p>(an aside: there is a similar issue with min/max which are defined<br>\npurely syntactical, not only on linear orders)</p>\n<p>I kept the then existing syntactic classes a) for backward compatibility<br>\nand b) since they carry syntax by default.  The case for inf and sup<br>\nthen was different.</p>\n<p>Nowadays I have to admit that in situations like yours syntactic classes<br>\nfor inf and sup would allow a more liberal building of the class<br>\nhierarchy.  Indeed, I recently had some thoughts how you could achieve<br>\nsomething like »import class parameters, but with different<br>\nspecification from which the original specification follows«, in essence<br>\na class with simultaneous subclass.  But it looked rather complicated.</p>\n<p>I have no strong opinion whether to turn inf and sup into syntactic<br>\nclasses.  But note that to simplify your instantiation proofs you can<br>\nprove a specific introduction rule for P ==&gt; OFCLASS('a, left_inf) where<br>\nP is the body of your left_inf class.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Kgwr1OA7lfydY9umu0DsheXj/signature.asc\">signature.asc</a></p>",
        "id": 294143623,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846728
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Wed, Aug 31, 2011 at 11:53 AM, Florian Haftmann<br>\n&lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Viorel,</p>\n<blockquote>\n<p>Ultimately the structure is a (semi-) lattice, but the axioms are<br>\ndifferent.<br>\nImagine an algebraic structure with some operations *, left_imp which<br>\nsatisfies<br>\nsome properties and in which inf can be defined</p>\n<p>class left_inf = inf + times + left_imp + order +<br>\n  assumes some axioms for times and left_imp<br>\n  and inf_l_def: \"(inf a b) = (left_imp a b) * a\"<br>\n  and definition of order</p>\n<p>begin</p>\n<p>in this setting the fact that inf is a semi-lattice operation can be<br>\nproved from the axioms of times and left_imp.</p>\n</blockquote>\n</blockquote>\n<p>There are several similar situations that arise in Isabelle's real<br>\nanalysis class hierarchy. For example, RealVector.thy introduces type<br>\nclasses topological_space and metric_space. Every metric space is also<br>\na topological space, so we definitely want a subclass relationship<br>\ntopological_space &lt; metric_space. The naive way to formalize these<br>\nclasses is shown below.</p>\n<p>class topological_space =<br>\n  fixes \"open\" :: \"'a set =&gt; bool\"<br>\n  assumes open_UNIV: \"open UNIV\"<br>\n  assumes open_Int: \"open S ==&gt; open T ==&gt; open (S \\&lt;inter&gt; T)\"<br>\n  assumes open_Union:: \"ALL S:K. open S ==&gt; open (Union K)\"</p>\n<p>class metric_space = topological_space +<br>\n  fixes dist :: \"'a =&gt; 'a =&gt; real\"<br>\n  assumes dist_eq_0_iff: \"(dist x y = 0) = (x = y)\"<br>\n  assumes dist_triangle2: \"dist x y \\&lt;le&gt; dist x z + dist y z\"<br>\n  assumes open_dist: \"open S = (ALL x:S. EX e&gt;0. ALL y. dist y x &lt; e --&gt; y : S)\"</p>\n<p>Of course, the problem here is that whenever we want to prove an<br>\ninstance of the metric_space class, Isabelle expects us to re-prove<br>\nall the topological_space axioms as well, even though they are implied<br>\nby the metric_space axioms! To avoid this, I broke up the class<br>\ndefinitions using some syntactic classes:</p>\n<p>class \"open\" = fixes \"open\" :: \"'a set =&gt; bool\"</p>\n<p>class topological_space = \"open\" +<br>\n  assumes open_UNIV: \"open UNIV\"<br>\n  assumes open_Int: \"open S ==&gt; open T ==&gt; open (S \\&lt;inter&gt; T)\"<br>\n  assumes open_Union:: \"ALL S:K. open S ==&gt; open (Union K)\"</p>\n<p>class dist = fixes dist :: \"'a =&gt; 'a =&gt; real\"</p>\n<p>class open_dist = \"open\" + dist +<br>\n  assumes open_dist: \"open S = (ALL x:S. EX e&gt;0. ALL y. dist y x &lt; e --&gt; y : S)\"</p>\n<p>class metric_space = open_dist +<br>\n  assumes dist_eq_0_iff: \"(dist x y = 0) = (x = y)\"<br>\n  assumes dist_triangle2: \"dist x y \\&lt;le&gt; dist x z + dist y z\"</p>\n<p>Then we can prove a subclass relationship:</p>\n<p>instance topological_space &lt; metric_space<br>\nproof ...</p>\n<p>Now instance proofs for metric_space give us exactly the proof<br>\nobligations we want.</p>\n<p>Similar relationships exist among a whole sequence of classes, and<br>\nthey are set up in a similar manner:<br>\ntopological_space &lt; metric_space &lt; real_normed_vector &lt; real_inner</p>\n<blockquote>\n<p>Historically, syntactic classes where necessary since the class +<br>\noperations &amp; instantiation infrastructure has not yet emerged.  With the<br>\nclass package my first thought was to avoid syntactic classes entirely,<br>\nsince they allow to write down things for which one might expect certain<br>\nproperties to hold, which, in fact, do not, only with more specific sort<br>\nconstraints:</p>\n<p>(a + b) + c = a + (b + c)<br>\n       2 + 2 = 4 -- an Isabelle classic!</p>\n</blockquote>\n<p>The redefined class hierarchy as I presented it above still has this<br>\nsame kind of problem: If you write something like \"dist x y = dist y<br>\nx\", the inferred sort for x and y is \"dist\", and not \"metric_space\" as<br>\nyou would like. I solve this problem with the following ML command:</p>\n<p>setup {* Sign.add_const_constraint<br>\n  (@{const_name dist}, SOME @{typ \"'a::metric_space =&gt; 'a =&gt; real\"}) *}</p>\n<p>This tells Isabelle's parser/typechecker to automatically infer a<br>\nmetric_space class constraint whenever the \"dist\" constant is used.<br>\nThis works great most of the time, but there are rare occasions when I<br>\nneed to temporarily turn off the extra constraints (see<br>\nLibrary/Inner_Product.thy) which is a pain.</p>\n<blockquote>\n<p>Nowadays I have to admit that in situations like yours syntactic classes<br>\nfor inf and sup would allow a more liberal building of the class<br>\nhierarchy.  Indeed, I recently had some thoughts how you could achieve<br>\nsomething like »import class parameters, but with different<br>\nspecification from which the original specification follows«, in essence<br>\na class with simultaneous subclass.  But it looked rather complicated.</p>\n</blockquote>\n<p>Such a feature might be worthwhile; after all, my workaround for the<br>\nproblem is rather complicated too! This feature would let us radically<br>\nsimplify the class hierarchy in the real analysis theories. It would<br>\nalso let us simplify the group/ring class hierarchy a bit. But perhaps<br>\nmost importantly, it would let users define classes like Viorel's<br>\n\"left_inf\" class in the most natural way.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294143644,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846733
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Brian, Florian,</p>\n<p>Thank you for your answers.</p>\n<p>It seems that the only reason for not having<br>\nsyntactic classes for inf and sup is because<br>\nan expression \"inf a b\", by default will<br>\nhave a too week type. However you do accept<br>\nthis compromise for the arithmetic operators<br>\nwhich seems more difficult to justify.</p>\n<p>As Brian pointed out syntactic classes are needed<br>\nalso when dealing with topological and metric spaces<br>\nin order to avoid reproving things for every instantiation.</p>\n<p>I have another example which is also in the favor of<br>\nsyntactic classes. In Isabelle 2009 the operations<br>\nInf and Sup were defined as part of the complete<br>\nlattice structure, and now they are syntactic classes.<br>\nIt seems that there was  a similar problem for the complete<br>\nlattice operations.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294143667,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846743
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nA further aspect: Pure.intro declaration have precedence over the intro<br>\nclasses method, as shown in the folling silly example:</p>\n<p>lemma nonsense [Pure.intro]:<br>\n  \"False \\&lt;Longrightarrow&gt; OFCLASS('a, default_class)\"<br>\n  ..</p>\n<p>instance bool :: default<br>\napply default<br>\noops</p>\n<p>By declaring your customary class introduction rules Pure.intro, they<br>\nare preferred in instance proofs.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/ENupSyVINc3Y_h-7ESqhXeIe/signature.asc\">signature.asc</a></p>",
        "id": 294143935,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846819
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nDoes that solve the issues that were raised on this thread earlier?  I <br>\nhave followed the matter only with one eye, without really understanding <br>\nthe full situation.</p>\n<p>The \"default\" proof step is a little bit entangled, it tries to be smart <br>\nin including certain aspects of \"intro_classes\" to make such proof <br>\npatterns look somehow obvious.  The classical reasoner overrides \"default\" <br>\nlater once more, to add its classical viewpoint to the \"rule\" part.</p>\n<p>If there is a need for it, such things can certainly be reformed, but it <br>\nwould require a brief inspection of the status quo and the parts of the <br>\nhistory leading to it.</p>\n<p>If plain Pure.intro (which already works with the \"rule\" method, BTW) is <br>\nsufficient, it is even easier.</p>\n<p>Makarius</p>",
        "id": 294144060,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846862
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nTo me this looks rather like a workaround for some specific situations. <br>\nIf I understand correctly, it wouldn't work with a more complex class <br>\nhierarchy, where parts of the instance may already be established etc. <br>\nThe issue certainly deserves more thourough examination at some point.</p>\n<p>For now I have just added (5e51075cbd97) the syntactic classes for inf <br>\nand sup, which were originally asked for by Viorel. This is a rather <br>\nstraightforward thing, and the more general typings that may arise seem <br>\nto have little impact in practice.</p>\n<p>Alex</p>",
        "id": 294144090,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846872
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>By declaring your customary class introduction rules Pure.intro, they<br>\nare preferred in instance proofs.</p>\n</blockquote>\n<p>Does that solve the issues that were raised on this thread earlier?</p>\n</blockquote>\n<p>To me this looks rather like a workaround for some specific situations.<br>\nIf I understand correctly, it wouldn't work with a more complex class<br>\nhierarchy, where parts of the instance may already be established etc.<br>\nThe issue certainly deserves more thourough examination at some point.</p>\n</blockquote>\n<p>Indeed.</p>\n<blockquote>\n<p>For now I have just added (5e51075cbd97) the syntactic classes for inf<br>\nand sup, which were originally asked for by Viorel. This is a rather<br>\nstraightforward thing, and the more general typings that may arise seem<br>\nto have little impact in practice.</p>\n</blockquote>\n<p>OK.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/vzT9MlJCeWrif2p3r2yT3IRG/signature.asc\">signature.asc</a></p>",
        "id": 294144157,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846899
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nOn 08/31/2011 09:58 PM, Brian Huffman wrote:</p>\n<p>[...]</p>\n<blockquote>\n<p>To avoid this, I broke up the class<br>\ndefinitions using some syntactic classes:</p>\n<p>class \"open\" = fixes \"open\" :: \"'a set =&gt;  bool\"</p>\n<p>class topological_space = \"open\" +<br>\n   assumes open_UNIV: \"open UNIV\"<br>\n   assumes open_Int: \"open S ==&gt;  open T ==&gt;  open (S \\&lt;inter&gt;  T)\"<br>\n   assumes open_Union:: \"ALL S:K. open S ==&gt;  open (Union K)\"</p>\n<p>class dist = fixes dist :: \"'a =&gt;  'a =&gt;  real\"</p>\n<p>class open_dist = \"open\" + dist +<br>\n   assumes open_dist: \"open S = (ALL x:S. EX e&gt;0. ALL y. dist y x&lt;  e --&gt;  y : S)\"</p>\n<p>class metric_space = open_dist +<br>\n   assumes dist_eq_0_iff: \"(dist x y = 0) = (x = y)\"<br>\n   assumes dist_triangle2: \"dist x y \\&lt;le&gt;  dist x z + dist y z\"</p>\n<p>Then we can prove a subclass relationship:</p>\n<p>instance topological_space&lt;  metric_space<br>\nproof ...</p>\n<p>Now instance proofs for metric_space give us exactly the proof<br>\nobligations we want.</p>\n<p>Similar relationships exist among a whole sequence of classes, and<br>\nthey are set up in a similar manner:<br>\ntopological_space&lt;  metric_space&lt;  real_normed_vector&lt;  real_inner</p>\n</blockquote>\n<p>Another instance of that same pattern is in <br>\nHOL/Library/Kleene_Algebra.thy: In any idempotent additive structure (x </p>\n<ul>\n<li>x = x) we can define a partial order as \"x &lt;= y &lt;-&gt; x + y = y\". Again, <br>\none relies on the syntactic class \"ord\" here.</li>\n</ul>\n<blockquote>\n<blockquote>\n<p>Nowadays I have to admit that in situations like yours syntactic classes<br>\nfor inf and sup would allow a more liberal building of the class<br>\nhierarchy.  Indeed, I recently had some thoughts how you could achieve<br>\nsomething like »import class parameters, but with different<br>\nspecification from which the original specification follows«, in essence<br>\na class with simultaneous subclass.  But it looked rather complicated.</p>\n</blockquote>\n<p>Such a feature might be worthwhile; after all, my workaround for the<br>\nproblem is rather complicated too! This feature would let us radically<br>\nsimplify the class hierarchy in the real analysis theories. It would<br>\nalso let us simplify the group/ring class hierarchy a bit. But perhaps<br>\nmost importantly, it would let users define classes like Viorel's<br>\n\"left_inf\" class in the most natural way.</p>\n</blockquote>\n<p>Could one maybe achieve the same effect by declaring the subclass <br>\nrelationship (instead of proving it later), but then have the <br>\n\"intro_classes\" method (or whatever its name was exactly) apply some <br>\nuser-supplied rule to prove the original axioms from the new <br>\nspecification? In other words, formalize the workaround suggested by <br>\nFlorian a little bit more, with some minimalistic tool support... But <br>\nthis will need more thought...</p>\n<p>Alex</p>",
        "id": 294144169,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846905
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;</p>\n<blockquote>\n<p>To me this looks rather like a workaround for some specific <br>\nsituations. If I understand correctly, it wouldn't work with a more <br>\ncomplex class hierarchy, where parts of the instance may already be <br>\nestablished etc. The issue certainly deserves more thourough <br>\nexamination at some point.</p>\n<p>For now I have just added (5e51075cbd97) the syntactic classes for inf <br>\nand sup, which were originally asked for by Viorel. This is a rather <br>\nstraightforward thing, and the more general typings that may arise <br>\nseem to have little impact in practice.<br>\nThank you for this change. I did use a work around which worked well. So<br>\nthe alternatives suggested did not seem better to me.</p>\n</blockquote>\n<p>The work around that I used is the following:</p>\n<p>class inf =<br>\n   fixes inf :: \"'a =&gt; 'a =&gt; 'a\" (infixl \"\\&lt;sqinter&gt;\" 70)</p>\n<p>class sup =<br>\n   fixes sup :: \"'a =&gt; 'a =&gt; 'a\" (infixl \"\\&lt;squnion&gt;\" 65)</p>\n<p>class lattice_infix = order + inf + sup +<br>\n   assumes lattice: \"class.lattice (op \\&lt;le&gt;) (op &lt;) inf sup\"</p>\n<p>sublocale lattice_infix &lt; lattice  \"op \\&lt;le&gt;\" \"op &lt;\" inf sup<br>\n   by (rule lattice)</p>\n<p>After this I used lattice_infix instead of lattice. It seems that<br>\nthis way works better and it is more general that the ways<br>\nsuggested earlier.</p>\n<p>Viorel</p>\n<p>&gt;<br>\n&gt;</p>",
        "id": 294144338,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846960
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nI guess the intro_classes method must maintain a list of introduction<br>\nrules for OFCLASS predicates; maybe we could just introduce an<br>\nattribute for adding new theorems to this list (replacing any<br>\npre-existing rule for the same class). I wouldn't expect this to be<br>\ntoo hard to implement.</p>\n<p>But I think that the real challenge for making the process<br>\nuser-friendly is to find a way to avoid mucking around with<br>\n\"Sign.add_const_constraint\".</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294144814,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847107
    }
]