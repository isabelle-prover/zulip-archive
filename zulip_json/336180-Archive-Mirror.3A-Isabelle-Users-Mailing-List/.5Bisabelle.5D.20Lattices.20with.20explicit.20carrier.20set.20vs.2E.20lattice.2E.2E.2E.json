[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>there are two ways of defining lattices in Isabelle:<br>\nThe first approach makes the carrier set of the lattice explicit, as<br>\ne.g. in HOL/Algebra/Lattice.thy, the<br>\nsecond one (in HOL/Lattices.thy and HOL/Lattices/*) uses implicit<br>\ncarrier sets (the UNIV-set of a type) and type-classes.</p>\n<p>Is there a systematic/automatic way to go from theorems with the<br>\nimplicit carrier set to corresponding theorems for an explicit carrier set?</p>\n<p>My concrete problem is, that I have many theorems for the implicit<br>\ncarrier-set, but the algorithms I want to verify require parametric<br>\ncarrier sets, e.g.<br>\nI need the lattice of all subsets of control locations in the program,<br>\nthat has some nice properties (e.g. finite-height) only, if there are<br>\nonly finitely many<br>\ncontrol locations.</p>\n<p>However, because the set of control locations is a parameter of the<br>\nalgorithm I want to verify, I cannot fix it in advance, and thus cannot<br>\ndefine a datatype of control locations, that<br>\nwould be required to show that it's corresponding set-type is in the<br>\nlattice-typeclass.</p>\n<p>Any ideas? Is the only way to redo the proofs of all necessary theorems<br>\nfor explicit carrier sets?</p>\n<p>Regards and thanks for any hints,<br>\n  Peter</p>",
        "id": 294091460,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832001
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nUnfortunately, I suspect that that will be necessary.<br>\nLarry Paulson</p>",
        "id": 294091481,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832012
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<p>My concrete problem is, that I have many theorems for the implicit<br>\ncarrier-set, but the algorithms I want to verify require parametric<br>\ncarrier sets, e.g.<br>\n[...]<br>\nAny ideas? Is the only way to redo the proofs of all necessary theorems<br>\nfor explicit carrier sets?</p>\n</blockquote>\n<p>The developer version contains a transfer tool (written by Amine Chaieb) <br>\nwhich may be helpful in situations like yours. Currently it is used for <br>\nlifting theorems between int and nat etc. But there is not really much <br>\nexperience in using it, and it is not part of an official release, so <br>\nexpect the unexpected! (and maybe redoing the proofs is less painful in <br>\nthe end). Probably Amine or someone else can point you to an example of <br>\nhow it can be used...</p>\n<p>Alex</p>",
        "id": 294091521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832028
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nQuoting Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;:</p>\n<blockquote>\n<p>there are two ways of defining lattices in Isabelle:<br>\nThe first approach makes the carrier set of the lattice explicit, as<br>\ne.g. in HOL/Algebra/Lattice.thy, the<br>\nsecond one (in HOL/Lattices.thy and HOL/Lattices/*) uses implicit<br>\ncarrier sets (the UNIV-set of a type) and type-classes.</p>\n</blockquote>\n<p>In fact, there is a third, even more general way: don't use the HOL  <br>\nequality, but an arbitrary equivalence relation.   <br>\nHOL/Algebra/Lattice.thy explores this, based on work by Stephan Hohe.</p>\n<blockquote>\n<p>Is there a systematic/automatic way to go from theorems with the<br>\nimplicit carrier set to corresponding theorems for an explicit carrier set?</p>\n</blockquote>\n<p>I believe that this is theoretically not possible in general.  It  <br>\nmight be, if you restrict the kind of statements to a subset of  <br>\nformulae -- for example, universal sentences only.  I believe that  <br>\nPeter Homeier addressed such issues in his quotient type work for HOL.</p>\n<p>Clemens</p>",
        "id": 294091604,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832044
    },
    {
        "content": "<p>From: Jeremy Avigad &lt;<a href=\"mailto:avigad@cmu.edu\">avigad@cmu.edu</a>&gt;<br>\nFriends,</p>\n<p>Below Alex is referring to a transfer method that Amine and I  <br>\ndeveloped while I was revising Isabelle's number theory library,  <br>\ndesigned to help transfer theorems about the natural numbers to  <br>\nequivalent statements about the nonnegative integers and vice-versa.</p>\n<p>The idea is simple: whenever you have a bijection from a subset A of  <br>\none type (possibly the universal set) to a subset B of another, and  <br>\nsome functions and relations that respect the bijection, then any  <br>\ntheorem about A is equivalent to a theorem about B. (Similarly things  <br>\ncan be said about surjections rather than bijections, e.g. quotient  <br>\nmaps.) The transfer method simply applies carefully chosen rewrite  <br>\nrules to translate theorems back and forth between such domains.</p>\n<p>You can find the code for transfer in Transfer.ML, and the rules  <br>\ndesigned specifically for transfer between nats and ints in  <br>\nNat_Transfer.thy of the developer version. They are put to use in  <br>\nfiles like GCD.thy, Primes.thy, and UniqueFactorization.thy (the  <br>\nlatter two are in NumberTheory). It is pretty nifty: you give the  <br>\nmethod a nat theorem and it returns the corresponding int theorem, or  <br>\nvice-versa. It even works with higher-order constructs like summation,  <br>\netc.</p>\n<p>But the methods are still in a prototype stage. Amine and I still need  <br>\nto find time to polish them and put in rules for other higher-order  <br>\nconstructs, and improve the interface and document it. I'm not sure if/ <br>\nwhen that will happen...</p>\n<p>Unfortunately, this won't solve Peter's problem. The issue is that, in  <br>\ngeneral, one does not have bijections between parameterized structures  <br>\nand types. This is what makes simple type theory simple: types can't  <br>\ndepend on parameters. (There is a trick due to John Harrison for  <br>\nencoding natural numbers as types, and using polymorphism over type  <br>\nvariables, but it is limited.) Axiomatic type classes are simply stuck  <br>\nin type-land.</p>\n<p>If you really want to use structures that depend on parameters, here  <br>\nare some options:</p>\n<p>(1) (Re)do everything in locales, as Larry suggests.</p>\n<p>(2) Give up on simple type theory and use a dependent type theory like  <br>\nCoq (see e.g. Gonthier's finite group theory project).</p>\n<p>(3) Give up on simple type theory and go the other direction, to set  <br>\ntheory. See, for example, Mizar's type system for an example of how  <br>\ninfrastructure for keeping track of types can be added on top of set  <br>\ntheory.</p>\n<p>Tobias Nipkow, Brian Huffman, Amine Chaieb, and I once discussed ways  <br>\nthat one could embed Isabelle's type theory in a larger set-theoretic  <br>\nframework, e.g. adding a type of sets and axioms that guarantee that  <br>\n\"small\" types correspond to sets. If done right, that could yield a  <br>\nconsistent system (e.g. having the same logical strength as set  <br>\ntheory) where one could go back and forth between typed and set- <br>\ntheoretic versions of theorems, and so, indirectly, from axiomatic- <br>\ntype class versions to set-based locale versions. I still think that's  <br>\nan idea worth exploring, if anyone is willing and able.</p>\n<p>Best wishes,</p>\n<p>Jeremy</p>",
        "id": 294091651,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832057
    },
    {
        "content": "<p>From: \"Dr. Brendan Patrick Mahony\" &lt;<a href=\"mailto:brendan.mahony@dsto.defence.gov.au\">brendan.mahony@dsto.defence.gov.au</a>&gt;<br>\nThis is an issue that has been of interest for some time.</p>\n<p>If you want to do interesting mathematics (eg about lattices rather  <br>\nthan using lattices) you really should be using explicit carrier sets.</p>\n<p>My intuitions suggest that the existing axclass - locale binding could  <br>\nbe strengthened to support moving seamlessly from \"pure\" mathematics  <br>\n(on carrier set algebras) to \"applied\" mathematics (on type algebras).  <br>\nA \"carrier\" locale could be associated with the \"type\" axclass and new  <br>\naxclasses could be developed as specialised extensions of the  <br>\n\"carrier\" locale (restrict to single type parameter, what else?). An  <br>\ninstance of the axclass is induced from an interpretation of the  <br>\nlocale with a universal carrier set.</p>\n<p>We have a lattice development with this sort of structure, carrier  <br>\nbased development of sub-lattices, lattice morphisms, and other useful  <br>\napproaches to proving lattice instances. A couple of linking theorems  <br>\nthen connect axclass and locale to make it easy to prove type lattice  <br>\ninstances.</p>\n<p>It would be nice if the Isabelle axclass mechanism gave serious  <br>\nsupport for this sort of approach.</p>\n<p>IMPORTANT: This email remains the property of the Australian Defence Organisation and is subject to the jurisdiction of section 70 of the CRIMES ACT 1914.  If you have received this email in error, you are requested to contact the sender and delete the email.</p>",
        "id": 294091662,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832064
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYes, this would be an excellent research project for somebody who is  <br>\nfamiliar with a variety of type theories and also has an intuitive  <br>\nunderstanding of set theory. But finding such a person is probably  <br>\nmore difficult than finding somebody who is conversant in both Latin  <br>\nand Klingon.<br>\nLarry</p>",
        "id": 294091675,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832070
    },
    {
        "content": "<p>From: Gergely Buday &lt;<a href=\"mailto:gbuday@gmail.com\">gbuday@gmail.com</a>&gt;<br>\nSo it is a \"challange\". My question is whether having such a theory<br>\nmakes it easy to tailor Isabelle to do such lifting between the two<br>\nkinds of theory development? How much programming work would this be<br>\nto have a usable framework?</p>\n<ul>\n<li>Gergely</li>\n</ul>",
        "id": 294091723,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832087
    }
]