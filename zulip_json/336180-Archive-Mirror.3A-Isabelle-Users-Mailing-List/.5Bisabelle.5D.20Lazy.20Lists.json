[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear all,</p>\n<p>just for fun, I recently wanted to formalize the first \"pearl\" from the <br>\nbook \"Pearls of Functional Algorithm Design\" (by Richard Bird) inside <br>\nIsabelle/HOL. The solutions in the book are implemented in Haskell and <br>\nsometimes rely on lazy evaluation.</p>\n<p>I stumbled across the following points. In proofs the case of infinite <br>\nlists is (as far as I read) never considered (i.e., plain structural <br>\ninduction on finite lists is used). However, the implementations <br>\nsometimes contain infinite lists like [0..]. Since this \"omissions\" are <br>\nonly done in contexts where the lists that are used for induction are <br>\nreally finite, this seems to be fine.</p>\n<p>My question is now, how closely can such a kind of proof be imitated <br>\ninside Isabelle/HOL?</p>\n<p>Lets consider we use \"'a llist\" (from AFP/Coinductive) for lazy lists <br>\nand \"'a list\" for finite lists.</p>\n<p>If I'm correct, the new transfer package should be able (after <br>\nappropriate setup) to transfer facts from \"'a list\" to \"'a llist\" with <br>\nadditional \"lfinite ...\" assumptions (and also the other way round?). <br>\nBut how this setup is actually done, I did not find out. The current <br>\ndocumentation of the transfer package is rather inaccessible (in fact I <br>\nonly know of the example theories that are mentioned in the NEWS file).</p>\n<p>Another issue is that Haskell functions (on lazy lists) are defined <br>\nusing notation like \"fun\" of Isabelle/HOL despite not being based on <br>\nwell-founded recursion, whereas for function definitions on \"'a llist\" <br>\nin Isabelle/HOL this does not work (at least I don't know how). That is, <br>\nthere is a gap between what is used in Haskell programming and how this <br>\ncan be \"simulated\" in Isabelle/HOL.</p>\n<p>So, here is a wish-list:</p>\n<ul>\n<li>in contexts where we have \"lfinite\", reuse facts on \"'a list\" functions</li>\n<li>\n<p>provide a command that allows to define functions on \"'a llist\" using <br>\nthe same notation as \"fun\" (is this already possible?)</p>\n</li>\n<li>\n<p>for Haskell code generation Nil and LNil as well as Cons and LCons <br>\nshould be unified and mapped to [] and (:) of Haskell</p>\n</li>\n<li>\n<p>moreover, would it be possible to unify \"equivalent\" (modulo <br>\ninfiniteness) functions like \"map\" and \"lmap\", \"filter\" and \"lfilter\" <br>\n..., for code generation?</p>\n</li>\n</ul>\n<p>My main questions are:<br>\n1) how would the above mentioned transfer setup work?<br>\n2) how realistic is the above wish-list and what do you think about it?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294162157,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853542
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nOn 06/25/2012 01:21 PM, Peter Gammie wrote:</p>\n<blockquote>\n<p>Christian,</p>\n<p>(We could have this conversation on the list if you like - just post any followup there.)</p>\n<p>On 25/06/2012, at 2:10 PM, Christian Sternagel wrote:</p>\n<blockquote>\n<p>thanks for the pointer to HOLCF. Assuming code generation works (almost) as usual for HOLCF, this is indeed what I was looking for.</p>\n</blockquote>\n<p>AFAIK the code generator does not work at all for HOLCF.<br>\nIf that is the case, it would be interesting to know whether this is an <br>\ninherent restriction or would \"just\" require more work (I know by <br>\npainful experience that such \"just\"s can get quite huge ;)).</p>\n</blockquote>\n<p>I would love to be able to formalize functions as is done in lazy <br>\nfunctional programming papers and get generated code \"for free\".</p>\n<blockquote>\n<blockquote>\n<p>PS: I wanted to download your paper on the worker/wrapper transformation from your website, but the file seems to be damaged (at least that's what two of my pdf reader applications are claiming).</p>\n</blockquote>\n<p>Oops, thanks for that.</p>\n<p>I'd recommend you scrape the theory out of the AFP - it subsumes the JFP paper.<br>\nGood to know, thanks.</p>\n<p>BTW this transformation should apply to other inductively-defined things, e.g. inductive definitions in HOL.</p>\n<p>However I have not investigated how you'd connect an inductive thing (e.g. a function nat =&gt; 'a) to it's coinductive counterpart (e.g. an 'a llist) using it. (It works in a domain theoretic setting as recursive domain equations have unique fixed points.)<br>\nI guess this is the same problem as relating \"'a list\" to \"'a llist\"?</p>\n<p>There's some work on this by Thorsten Altenkirch et al that is heavy on the category theory (TLCA 2001?) - I think the keyword is \"containers\". See the original worker/wrapper paper by Hutton and Gill for the reference.</p>\n</blockquote>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294162175,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853548
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nChristian,</p>\n<p>Probably. Roughly I think Altenkirch et al show that if you have a function from an inductively-defined domain then there is an equivalent coinductive definition of that function.</p>\n<p>You can think of it as a generalisation of using lazy lists to memoise functions from the natural numbers, as Hutton and Gill did in their worker/wrapper paper. In their setting, for (partial) f :: nat -&gt; 'a, f x is memoised by the x'th element of the lazy list. (In a total setting you'd want to use streams, not lazy lists.)</p>\n<p>In general you need to index into a more complex coinductive type (whose structure depends on the type of the function's domain). There's probably a link to differentiating datatypes, zippers and so forth too.</p>\n<p>Their framework probably handles the issue in the paper I mentioned earlier.</p>\n<p>BTW I think it is great you are contemplating putting Bird et al's work through a proof assistant. Parts of Bird's theory of lists (from circa 1987) are still visible in List.thy. One might hope the newer work is similarly useful.</p>\n<p>I'll leave the questions about code generation to Brian and Florian.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294162203,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853556
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Christian,</p>\n<p>if you want to formalise functional programming, I recommend HOLCF over <br>\nCoinductive, because domain theory is the semantics behind Haskell, not <br>\ncoinductive datatypes. HOLCF lists, for example, can distinguish between <br>\n\"definitely terminating\", \"definitely infinite\", and \"evaluated up to a certain <br>\npoint with unknown rest\". Coinductive lists ('a llist) cannot express the last <br>\ncase. You can then also do induction over HOLCF lists, known as Scott induction.<br>\nHowever, using standard HOL types and functions within HOLCF may need some work.</p>\n<blockquote>\n<p>Lets consider we use \"'a llist\" (from AFP/Coinductive) for lazy lists and \"'a<br>\nlist\" for finite lists.<br>\nThe predicate \"lfinite\" is defined inductively, so you could do induction on <br>\nthat. But obviously, your induction then has to thread through this predicate.</p>\n</blockquote>\n<blockquote>\n<p>If I'm correct, the new transfer package should be able (after appropriate<br>\nsetup) to transfer facts from \"'a list\" to \"'a llist\" with additional \"lfinite<br>\n...\" assumptions (and also the other way round?). But how this setup is actually<br>\ndone, I did not find out.<br>\nI tried to set it up in the attached theory, but it only seems to works in the <br>\nwrong direction: You can prove theorems on 'a list by transferring them to 'a <br>\nllist with the lfinite predicate. Since neither 'a llist nor 'a list are defined <br>\nin terms of each other, you need to do the setup manually, i.e., prove all those <br>\ntransfer rules that relate functions on 'a llist with those on 'a list. Maybe <br>\nthe transfer package experts can improve my attempt.</p>\n</blockquote>\n<blockquote>\n<p>Another issue is that Haskell functions (on lazy lists) are defined using<br>\nnotation like \"fun\" of Isabelle/HOL despite not being based on well-founded<br>\nrecursion, whereas for function definitions on \"'a llist\" in Isabelle/HOL this<br>\ndoes not work (at least I don't know how). That is, there is a gap between what<br>\nis used in Haskell programming and how this can be \"simulated\" in Isabelle/HOL.<br>\nUnfortunately, there is currently no support for corecursive definitions.</p>\n</blockquote>\n<blockquote>\n<p>So, here is a wish-list:<br>\n- in contexts where we have \"lfinite\", reuse facts on \"'a list\" functions<br>\nThat would be great, but you have to ensure that the functions on 'a llist <br>\nbehave exactly like on 'a list. This is non-trivial for underspecified functions <br>\nlike hd and nth when applied with inappropriate parameters (such as []). I tried <br>\nhard to make these functions coindice (see, e.g., the \"undefined (Suc n)\" in the <br>\ndefinition of lnth), but I do not remember whether this was always possible.</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>provide a command that allows to define functions on \"'a llist\" using the same<br>\nnotation as \"fun\" (is this already possible?)<br>\nI hope that the new package for codatatypes provides at least \"coprimrec\". I <br>\ndoubt that there will be a powerful tool for arbitrary corecursive definitions, <br>\nbecause the internal constructions and proofs required differ considerably from <br>\nwell-founded recursions.</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>for Haskell code generation Nil and LNil as well as Cons and LCons should be<br>\nunified and mapped to [] and (:) of Haskell</li>\n<li>moreover, would it be possible to unify \"equivalent\" (modulo infiniteness)<br>\nfunctions like \"map\" and \"lmap\", \"filter\" and \"lfilter\" ..., for code generation?<br>\nThe last two should be easy to accomplish. Even you yourself could do that, one <br>\nonly has to adapt the section on code_type and code_const in List.thy for <br>\nCoinductive_List_Lib.</li>\n</ul>\n</blockquote>\n<p>Hope this helps,<br>\nAndreas<br>\n<a href=\"/user_uploads/14278/k_gfGjo-HHaCS8kjFWshG5Wx/Transfer_List.thy\">Transfer_List.thy</a></p>",
        "id": 294162229,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853567
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nAbsolutely and definitely true. HOLCF is explicitly a theory of computation; Coinductive is merely a theory of infinite objects. Such a pity if it doesn't yet support code generation.</p>\n<p>Larry</p>",
        "id": 294162261,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853578
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Mon, Jun 25, 2012 at 8:43 AM, Andreas Lochbihler<br>\n&lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt; wrote:</p>\n<blockquote>\n<blockquote>\n<p>If I'm correct, the new transfer package should be able (after appropriate<br>\nsetup) to transfer facts from \"'a list\" to \"'a llist\" with additional<br>\n\"lfinite<br>\n...\" assumptions (and also the other way round?). But how this setup is<br>\nactually<br>\ndone, I did not find out.</p>\n</blockquote>\n<p>I tried to set it up in the attached theory, but it only seems to works in<br>\nthe wrong direction: You can prove theorems on 'a list by transferring them<br>\nto 'a llist with the lfinite predicate. Since neither 'a llist nor 'a list<br>\nare defined in terms of each other, you need to do the setup manually, i.e.,<br>\nprove all those transfer rules that relate functions on 'a llist with those<br>\non 'a list. Maybe the transfer package experts can improve my attempt.</p>\n</blockquote>\n<p>That's right: The automation provided by the setup_lifting command is<br>\ndesigned for transferring theorems from supertype to subtype, not the<br>\nother way around. But you can always define your own transfer relation<br>\nmanually, in whichever direction you want. The attached theory file<br>\ndefines a relation for transferring from list to llist (it is the<br>\nconverse of the relation that would be generated by setup_lifting),<br>\nand shows how it can be used.</p>\n<p>Using the \"transfer\" proof method (which acts like the \"descending\"<br>\nmethod from the Quotient package) is rather cumbersome for these kinds<br>\nof examples; once we get around to implementing counterparts to the<br>\n\"lifting\" method and \"lifted\" attribute, transferring theorems from<br>\nlist to llist should be a lot easier.</p>\n<blockquote>\n<blockquote>\n<p>So, here is a wish-list:<br>\n- in contexts where we have \"lfinite\", reuse facts on \"'a list\" functions</p>\n</blockquote>\n</blockquote>\n<p>Using the planned but yet-to-be-implemented \"transferred\" attribute,<br>\nthis kind of transfer should be completely automatic. You should be<br>\nable to write</p>\n<p>map_append [transferred tr_llist]</p>\n<p>and get the theorem</p>\n<p>\"lfinite xs ==&gt; lfinite ys ==&gt; lmap f (lappend xs ys) = lappend (lmap<br>\nf xs) (lmap f ys)\"</p>\n<p>(assuming that the transfer rules are set up as in the attached theory file).</p>\n<p>This feature will definitely be available before the next Isabelle release.</p>\n<ul>\n<li>Brian<br>\n<a href=\"/user_uploads/14278/C71LGY1WhfvB96tKFZPW2G9s/List_LList.thy\">List_LList.thy</a></li>\n</ul>",
        "id": 294162283,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853585
    }
]