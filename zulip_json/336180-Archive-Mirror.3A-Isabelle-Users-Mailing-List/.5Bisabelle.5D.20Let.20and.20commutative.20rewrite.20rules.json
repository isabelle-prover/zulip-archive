[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Andreas,</p>\n<p>I am certainly open to changes. Here are two that I would welcome: simplifying <br>\nthe code or adding informal explanations. In the case of your proposed change I <br>\ndid notice that it would increase the running time and was also a bit concerned <br>\nabout that.</p>\n<p>I am afraid I cannot remember what situations prompted Norbert to write the more <br>\nelaborate simproc.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/YQ9Zr5uA8EL_c3Fi7wl9cP1N/smime.p7s\">smime.p7s</a></p>",
        "id": 294639108,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161342
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Tobias,</p>\n<p>An informal explanation of the code is in the NEWS file (for Isabelle2005). It explains <br>\npretty well what is going on.</p>\n<p>Simplifier: new simproc for \"let x = a in f x\".  If a is a free or<br>\n   bound variable or a constant then the let is unfolded.  Otherwise<br>\n   first a is simplified to b, and then f b is simplified to g. If<br>\n   possible we abstract b from g arriving at \"let x = b in h x\",<br>\n   otherwise we unfold the let and arrive at g.</p>\n<p>Unfortunately, this does not help much in understanding the motivation and indented use <br>\ncases for the simproc. From a proving perspective, Norbert's case looks quite pragmatic to <br>\nme: let's inline and see what happens - maybe one can regain the abstraction afterwards. <br>\nThus, the simproc breaks the abstraction of the binding - if more can be done, then it <br>\nwill be done.</p>\n<p>This is in line with my experience. Let bindings help to make definitions more readable, <br>\nbut for proving, I usually just get rid of them by unfolding Let_def, because the <br>\nclassical reasoner does not deal with them at all and the simplifier does these funny <br>\ntransformations.</p>\n<p>I am not really happy with this behaviour. I'd prefer something (maybe a different let) <br>\nthat respects the abstraction. What are your and others' experience with this?</p>\n<p>Below are my thoughts on respecting the abstraction:</p>\n<p>From a conceptual point of view, the let binding should respect the abstraction. That is, <br>\nthe new variable should be treated like a fresh constant - this is presently the case <br>\nwithout the simproc. Unfortunately, proving then becomes a nightmare because no properties <br>\nof the variable are known to the provers. It would be good to have some mechanism that <br>\nautomatically transfers the required properties from the bound term to the variable, but <br>\nit is not clear what these properties should be. In fact, being equal to the bound term is <br>\nalso a property. So the simproc let_simp just goes all the way of transferring the <br>\nproperties by inlining.</p>\n<p>Still, I wonder whether let_simp is doing to much. Essentially, it tries to guess when the <br>\nbinding should be unfolded (by trying out all possibilities). The other abstraction <br>\nfacilities in Isabelle such as definition and function have well-defined rules for when to <br>\nbreak the abstraction automatically: definition only explicitly when the user unfolds the <br>\ndefining equation, and function when the argument matches the pattern. This seems to work <br>\nrather well in practice. With let_simp, it does not work for bindings.</p>\n<p>Unfortunately, I do not a good understanding of how such on-the-fly abstractions (let <br>\nbindings) should be handled in general. I just have a few data points. Norrish and Slind <br>\n(TPHOLs 2005 proof pearl) argue that it is important in some cases to keep the abstraction <br>\nof let bindings (and the names of the bound variables). Their approach extracts let <br>\nbindings from proof goals and makes them available as assumptions. Thus, the user can <br>\nmanually derive the required properties for the bound variables and---equally <br>\nimportantly---the let bindings are out of the way in the proof term.</p>\n<p>Urban mentioned a similar problem in <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00277.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00277.html</a>.</p>\n<p>What I like about let_simp is that it eliminates duplicate let bindings, i.e., the term</p>\n<p>let x = f a b in let y = f a b in P x x y y</p>\n<p>becomes</p>\n<p>let x = f a b in P x x x x</p>\n<p>It also folds the abstraction if the bound term occurs in the body:</p>\n<p>let x = f a b in P x x (f a b)</p>\n<p>becomes</p>\n<p>let x = f a b in P x x x</p>\n<p>Unfortunately, the current simproc does not get the let out of the way. For example, to <br>\nprove the following, I have to unfold the binding.</p>\n<p>1 + (let x = f a in x + x) = (let x = f a in 1 + (x + x))</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294639121,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161347
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI like the elimination of atomic let bindings (and the elimination if there are <br>\n&lt;= 1 occurrences of the bound variable), but not the rest of the current <br>\nlet_simp. If possible, I would relegate that to a special simproc that can be <br>\nactivated on demand.</p>\n<p>A mechanism to make let-bindings in a goal available as assumptions (as in HOL4) <br>\nwould be nice, but that only seems to sense in combination with a structured <br>\nproof that can access these assumption by some name.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/Bh77owRtcrb_JOCEiFkTz8_C/smime.p7s\">smime.p7s</a></p>",
        "id": 294639287,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161410
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Tobias,</p>\n<p>On 08/05/15 13:41, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>I like the elimination of atomic let bindings (and the elimination if there are &lt;= 1<br>\noccurrences of the bound variable), but not the rest of the current let_simp. If possible,<br>\nI would relegate that to a special simproc that can be activated on demand.<br>\nThese cases I like, too, but they are not part of Norbert's special case.</p>\n</blockquote>\n<blockquote>\n<p>A mechanism to make let-bindings in a goal available as assumptions (as in HOL4) would be<br>\nnice, but that only seems to sense in combination with a structured proof that can access<br>\nthese assumption by some name.<br>\nI would already be very happy to float lets consistently outwards - if the classical <br>\nreasoner also knows what to do with them. At least, they would no longer intervene with <br>\nother rewrite rules as in \"map f (let g = h a in map g ys)\", where the let prevents the <br>\nsimp rule \"map f (map g xs) = map (f o g) xs\" from triggering.</p>\n</blockquote>\n<p>I find these intervening control operators (let, if, case, ...) pretty annoying - <br>\nespecially if the occur under lambdas where the splitter cannot extract them <br>\nautomatically. But that's a different story.</p>\n<p>Andreas</p>\n<blockquote>\n<p>On 08/05/2015 09:46, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Dear Tobias,</p>\n<p>An informal explanation of the code is in the NEWS file (for Isabelle2005). It<br>\nexplains pretty well what is going on.</p>\n<p>Simplifier: new simproc for \"let x = a in f x\".  If a is a free or<br>\n   bound variable or a constant then the let is unfolded.  Otherwise<br>\n   first a is simplified to b, and then f b is simplified to g. If<br>\n   possible we abstract b from g arriving at \"let x = b in h x\",<br>\n   otherwise we unfold the let and arrive at g.</p>\n<p>Unfortunately, this does not help much in understanding the motivation and<br>\nindented use cases for the simproc. From a proving perspective, Norbert's case<br>\nlooks quite pragmatic to me: let's inline and see what happens - maybe one can<br>\nregain the abstraction afterwards. Thus, the simproc breaks the abstraction of<br>\nthe binding - if more can be done, then it will be done.</p>\n<p>This is in line with my experience. Let bindings help to make definitions more<br>\nreadable, but for proving, I usually just get rid of them by unfolding Let_def,<br>\nbecause the classical reasoner does not deal with them at all and the simplifier<br>\ndoes these funny transformations.</p>\n<p>I am not really happy with this behaviour. I'd prefer something (maybe a<br>\ndifferent let) that respects the abstraction. What are your and others'<br>\nexperience with this?</p>\n<p>Below are my thoughts on respecting the abstraction:</p>\n<p>From a conceptual point of view, the let binding should respect the<br>\nabstraction. That is, the new variable should be treated like a fresh constant -<br>\nthis is presently the case without the simproc. Unfortunately, proving then<br>\nbecomes a nightmare because no properties of the variable are known to the<br>\nprovers. It would be good to have some mechanism that automatically transfers<br>\nthe required properties from the bound term to the variable, but it is not clear<br>\nwhat these properties should be. In fact, being equal to the bound term is also<br>\na property. So the simproc let_simp just goes all the way of transferring the<br>\nproperties by inlining.</p>\n<p>Still, I wonder whether let_simp is doing to much. Essentially, it tries to<br>\nguess when the binding should be unfolded (by trying out all possibilities). The<br>\nother abstraction facilities in Isabelle such as definition and function have<br>\nwell-defined rules for when to break the abstraction automatically: definition<br>\nonly explicitly when the user unfolds the defining equation, and function when<br>\nthe argument matches the pattern. This seems to work rather well in practice.<br>\nWith let_simp, it does not work for bindings.</p>\n<p>Unfortunately, I do not a good understanding of how such on-the-fly abstractions<br>\n(let bindings) should be handled in general. I just have a few data points.<br>\nNorrish and Slind (TPHOLs 2005 proof pearl) argue that it is important in some<br>\ncases to keep the abstraction of let bindings (and the names of the bound<br>\nvariables). Their approach extracts let bindings from proof goals and makes them<br>\navailable as assumptions. Thus, the user can manually derive the required<br>\nproperties for the bound variables and---equally importantly---the let bindings<br>\nare out of the way in the proof term.</p>\n<p>Urban mentioned a similar problem in<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00277.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00277.html</a>.</p>\n<p>What I like about let_simp is that it eliminates duplicate let bindings, i.e.,<br>\nthe term</p>\n<p>let x = f a b in let y = f a b in P x x y y</p>\n<p>becomes</p>\n<p>let x = f a b in P x x x x</p>\n<p>It also folds the abstraction if the bound term occurs in the body:</p>\n<p>let x = f a b in P x x (f a b)</p>\n<p>becomes</p>\n<p>let x = f a b in P x x x</p>\n<p>Unfortunately, the current simproc does not get the let out of the way. For<br>\nexample, to prove the following, I have to unfold the binding.</p>\n<p>1 + (let x = f a in x + x) = (let x = f a in 1 + (x + x))</p>\n<p>Best,<br>\nAndreas<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294639375,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161440
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 08/05/2015 15:29, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Hi Tobias,</p>\n<p>On 08/05/15 13:41, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>I like the elimination of atomic let bindings (and the elimination if there<br>\nare &lt;= 1<br>\noccurrences of the bound variable), but not the rest of the current let_simp.<br>\nIf possible,<br>\nI would relegate that to a special simproc that can be activated on demand.<br>\nThese cases I like, too, but they are not part of Norbert's special case.</p>\n</blockquote>\n</blockquote>\n<p>That is my point, I would like to separate out the rest of his code.</p>\n<p>Tobias</p>\n<blockquote>\n<blockquote>\n<p>A mechanism to make let-bindings in a goal available as assumptions (as in<br>\nHOL4) would be<br>\nnice, but that only seems to sense in combination with a structured proof that<br>\ncan access<br>\nthese assumption by some name.<br>\nI would already be very happy to float lets consistently outwards - if the<br>\nclassical reasoner also knows what to do with them. At least, they would no<br>\nlonger intervene with other rewrite rules as in \"map f (let g = h a in map g<br>\nys)\", where the let prevents the simp rule \"map f (map g xs) = map (f o g) xs\"<br>\nfrom triggering.</p>\n</blockquote>\n<p>I find these intervening control operators (let, if, case, ...) pretty annoying<br>\n- especially if the occur under lambdas where the splitter cannot extract them<br>\nautomatically. But that's a different story.</p>\n<p>Andreas</p>\n<p>On 08/05/2015 09:46, Andreas Lochbihler wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear Tobias,</p>\n<p>An informal explanation of the code is in the NEWS file (for Isabelle2005). It<br>\nexplains pretty well what is going on.</p>\n<p>Simplifier: new simproc for \"let x = a in f x\".  If a is a free or<br>\n   bound variable or a constant then the let is unfolded.  Otherwise<br>\n   first a is simplified to b, and then f b is simplified to g. If<br>\n   possible we abstract b from g arriving at \"let x = b in h x\",<br>\n   otherwise we unfold the let and arrive at g.</p>\n<p>Unfortunately, this does not help much in understanding the motivation and<br>\nindented use cases for the simproc. From a proving perspective, Norbert's case<br>\nlooks quite pragmatic to me: let's inline and see what happens - maybe one can<br>\nregain the abstraction afterwards. Thus, the simproc breaks the abstraction of<br>\nthe binding - if more can be done, then it will be done.</p>\n<p>This is in line with my experience. Let bindings help to make definitions more<br>\nreadable, but for proving, I usually just get rid of them by unfolding Let_def,<br>\nbecause the classical reasoner does not deal with them at all and the simplifier<br>\ndoes these funny transformations.</p>\n<p>I am not really happy with this behaviour. I'd prefer something (maybe a<br>\ndifferent let) that respects the abstraction. What are your and others'<br>\nexperience with this?</p>\n<p>Below are my thoughts on respecting the abstraction:</p>\n<p>From a conceptual point of view, the let binding should respect the<br>\nabstraction. That is, the new variable should be treated like a fresh constant -<br>\nthis is presently the case without the simproc. Unfortunately, proving then<br>\nbecomes a nightmare because no properties of the variable are known to the<br>\nprovers. It would be good to have some mechanism that automatically transfers<br>\nthe required properties from the bound term to the variable, but it is not clear<br>\nwhat these properties should be. In fact, being equal to the bound term is also<br>\na property. So the simproc let_simp just goes all the way of transferring the<br>\nproperties by inlining.</p>\n<p>Still, I wonder whether let_simp is doing to much. Essentially, it tries to<br>\nguess when the binding should be unfolded (by trying out all possibilities). The<br>\nother abstraction facilities in Isabelle such as definition and function have<br>\nwell-defined rules for when to break the abstraction automatically: definition<br>\nonly explicitly when the user unfolds the defining equation, and function when<br>\nthe argument matches the pattern. This seems to work rather well in practice.<br>\nWith let_simp, it does not work for bindings.</p>\n<p>Unfortunately, I do not a good understanding of how such on-the-fly abstractions<br>\n(let bindings) should be handled in general. I just have a few data points.<br>\nNorrish and Slind (TPHOLs 2005 proof pearl) argue that it is important in some<br>\ncases to keep the abstraction of let bindings (and the names of the bound<br>\nvariables). Their approach extracts let bindings from proof goals and makes them<br>\navailable as assumptions. Thus, the user can manually derive the required<br>\nproperties for the bound variables and---equally importantly---the let bindings<br>\nare out of the way in the proof term.</p>\n<p>Urban mentioned a similar problem in<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00277.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00277.html</a>.</p>\n<p>What I like about let_simp is that it eliminates duplicate let bindings, i.e.,<br>\nthe term</p>\n<p>let x = f a b in let y = f a b in P x x y y</p>\n<p>becomes</p>\n<p>let x = f a b in P x x x x</p>\n<p>It also folds the abstraction if the bound term occurs in the body:</p>\n<p>let x = f a b in P x x (f a b)</p>\n<p>becomes</p>\n<p>let x = f a b in P x x x</p>\n<p>Unfortunately, the current simproc does not get the let out of the way. For<br>\nexample, to prove the following, I have to unfold the binding.</p>\n<p>1 + (let x = f a in x + x) = (let x = f a in 1 + (x + x))</p>\n<p>Best,<br>\nAndreas</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/hi4-SsqowFIIAhMkHbc_ABTC/smime.p7s\">smime.p7s</a></p>\n</blockquote>\n</blockquote>",
        "id": 294639489,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161496
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nWhile the let-simp simproc is being discussed, I might mention the<br>\nproblem I ran into with it.</p>\n<p>Note that the body of the let is simplified twice, once by the normal<br>\nbottom-up algorithm of the simplifier, and again with the let-expression<br>\nunfolded as part of let-simp.</p>\n<p>Now suppose that you start with a largish program which uses the let<br>\nconstruct for structuring:</p>\n<p>\"let a = 1;<br>\n     (b, s) = f a s;<br>\n     (c, s) = g b s;<br>\n     d = a + b;<br>\n     ... etc\"</p>\n<p>Running the regular simplifier on this is exponential in the nesting<br>\nlevel of the lets. The innermost expression will be simplified with each<br>\npossible combination of folding and unfolding of all the let expressions<br>\nit is in.</p>\n<p>There's also a secondary problem in my case, which is that the let<br>\nexpression was folded in the first place to avoid an exponential blowup.<br>\nI tried working around this, but the long story is that I gave up on<br>\nusing Isabelle for handling this problem.</p>\n<p>Nonetheless, you might want to think about avoiding the exponential issue.</p>\n<p>Cheers,<br>\n     Thomas.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294639621,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161556
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThanks for the data point, it looks like we should really separate out that <br>\nexponential blowup because it happens in practice.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/djhlV1BbOBc1H--RSQjanrlV/smime.p7s\">smime.p7s</a></p>",
        "id": 294639668,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161563
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<p>I like the elimination of atomic let bindings (and the elimination if<br>\n                                                 ^^^^^^^^^^^^^^^^^^^^^^<br>\nthere are &lt;= 1 occurrences of the bound variable)<br>\n  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p>\n</blockquote>\n<p>This in fact has been introduced by me.</p>\n<p>(Just a remark.  I have little ideas what proof support we actually<br>\nwould need for let-bindings).</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/OwFAWg_zOIqoFOHYPZslmnz1/signature.asc\">signature.asc</a></p>",
        "id": 294640022,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161704
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear experts on rewriting,</p>\n<p>I have a problem with let bindings and commutative rewrite rules. Here is an example and <br>\nmy understanding of what is happening.</p>\n<p>lemma \"(let pb = foobar b in f pb (λpad. g (pb * pad :: int))) = bar\"<br>\napply(simp add: mult.commute)</p>\n<ol>\n<li>\n<p>mult.commute rewrites pb * pad into pad * pb, because pad seems to be smaller than pb <br>\nin the term order that the simplifier uses.</p>\n</li>\n<li>\n<p>The let simproc determines that pb occurs more than once in the body, so it does not <br>\ninline the let binding. Instead, it simplifies the body with knowledge pb = foobar b. <br>\nThus, the simplifier now sees pad * foobar b. Since \"foobar b\" is smaller than pad in the <br>\nterm order, commutativity kicks in again and we get foobar b * pad. Now, the simproc <br>\nabstracts the simplified body over foobar b again and replaces it with pb. So we are back <br>\nto pb * pad. Thus, the simplifier goes over the whole term again and we are back at step 1.</p>\n</li>\n</ol>\n<p>In my understanding so far, commutative rewrite rules are safe (in the sense of <br>\ntermination) to add to the simplifier, but the let simproc interferes with this. Is this a <br>\nknown problem? Can the let simproc be somehow changed to avoid this?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294642487,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162703
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Andreas,</p>\n<p>I was not aware of this interaction but it does not surprise me - the let <br>\nsimproc is magic - but you can switch it off. I have no idea if it can be <br>\nmodified to avoid this interaction in the first place. That sounds like a time sink.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/ktF60FLxaf07QjLaaoQI6cOI/smime.p7s\">smime.p7s</a></p>",
        "id": 294642509,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162710
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Tobias,</p>\n<p>I had another look at the implementation of let_simp. I guess that one might be able to <br>\nchange the let simproc fairly easily. The idea is as follows. For non-trivial lets (at <br>\nleast two occurrences of the bound variable and the bound term is not atomic), the let <br>\nsimproc inlines the bound term in the body, normalises the result with the simplifier and <br>\nthe current simpset, and then replaces all the remaining occurrences of the bound term in <br>\nthe normalised term with the bound variable.</p>\n<p>There is already a check whether the new body is alpha-beta-eta-equivalent to the old <br>\nbody. In that case, the simproc aborts with NONE. Now, the interaction can occur only if <br>\nthe abstracted body is no longer in normal form (although it is with the bound term <br>\ninlined)*. Thus, it would make sense to normalise the abstracted body again and check for <br>\nequivalence with the original body.</p>\n<p>When I add this additional check, the looping in my example disappears. What do you think?</p>\n<p>Best,<br>\nAndreas</p>\n<ul>\n<li>This may happen due to term order as in my case, but I imagine that simprocs like <br>\nNO_MATCH equally cause trouble here.</li>\n</ul>",
        "id": 294642596,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162758
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Andreas,</p>\n<p>Thank you for your thoughts, but I would rather not change the current setup. I <br>\ndon't really understand Norbert's code and I don't want to add further bits to <br>\nit. Moreover, the problem seems to crop up very rarely. If we were to modify the <br>\ncode, I would expect one of two results: it hardly has any effect or it breaks a <br>\nlot of proofs. In both cases I would want to leave well alone.</p>\n<p>Tobias</p>\n<p>PS I have recently made some similar change also in HOL and am thinking about <br>\nundoing it for some of the reasons above.<br>\n<a href=\"/user_uploads/14278/f0fb7yThQ5_NgZ6emw0aPKY1/smime.p7s\">smime.p7s</a></p>",
        "id": 294642859,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162857
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Tobias,</p>\n<p>I do not like the situation \"We do not fully understand what is going on, so better not <br>\nchange anything\", because this effectively freezes the code as it currently is with no way <br>\nto ever improve it. I am pretty sure that my change would have hardly any effect on the <br>\nexisting proofs (although I would have to test this hypothesis). Still, I agree with your <br>\ndecision for another reason. The let_simp simproc is already fairly inefficient when there <br>\nare nested let expressions such as</p>\n<p>let x = foo a b c in<br>\nlet y = bar a b c in<br>\nlet z = fbr a b c in<br>\nf x x y y z z</p>\n<p>because when the simproc triggers on the let for x (i.e., it has already looked at the <br>\nlets for y and z), it inlines the x in the body and invokes the simplifier on the body</p>\n<p>let y = bar a b c in<br>\nlet z = fbr a b c in<br>\nf (foo a b c) (foo a b c) y y z z</p>\n<p>Thus, the simplifier goes over the whole body again, which triggers the let_simp for the y <br>\nonce more (it has already triggered for this let binding before it triggered for the outer <br>\nlet). In summary, let_simp's runtime is exponential in the depth of let nestings.</p>\n<p>Now, if we were to add another normalisation check for the abstracted body, this would <br>\nincrease the base of the exponential by one. The non-termination problem occurs rarely <br>\n(the main reason is probably that commutativity rules are not in the simpset by default), <br>\nso it probably does not justify slowing the simplifier down (although it took me a while <br>\nto understand where the non-termination came from).</p>\n<p>I consider the exponential running time more of a problem. (Note that this term remains <br>\nlinear in size if everything is inlined, so there is no exponential blow-up in term size <br>\ndue to the inlining.) I digged a bit through the history of the simproc, but I was not <br>\nable to find any more information on what Norbert's case really is. Is there anyone who <br>\nremembers?</p>\n<p>Andreas</p>\n<p>PS: For completeness, here's the changed simproc with the additional normalisation test <br>\nfor Isabelle2015-RC3.</p>\n<p>lemma Let_folded2: \"⟦ f x ≡ g x; g ≡ g' ⟧ ⟹ Let x f ≡ Let x g'\"<br>\nby (simp add: Let_def)</p>\n<p>simproc_setup let_simp (\"Let x f\") = {*<br>\nlet<br>\n   val (f_Let_unfold, x_Let_unfold) =<br>\n     let val [(_ $ (f $ x) $ _)] = Thm.prems_of @{thm Let_unfold}<br>\n     in apply2 (Thm.cterm_of @{context}) (f, x) end<br>\n   val (f_Let_folded2, x_Let_folded2) =<br>\n     let val [(_ $ (f $ x) $ _), _] = Thm.prems_of @{thm Let_folded2}<br>\n     in apply2 (Thm.cterm_of @{context}) (f, x) end;<br>\n   val (g_Let_folded2, g'_Let_folded2) =<br>\n     let val [_, (_ $ g $ g')] = Thm.prems_of @{thm Let_folded2}<br>\n     in apply2 (Thm.cterm_of @{context}) (g, g') end;<br>\n   fun count_loose (Bound i) k = if i &gt;= k then 1 else 0<br>\n     | count_loose (s $ t) k = count_loose s k + count_loose t k<br>\n     | count_loose (Abs (_, _, t)) k = count_loose  t (k + 1)<br>\n     | count_loose _ _ = 0;<br>\n   fun is_trivial_let (Const (@{const_name Let}, _) $ x $ t) =<br>\n     (case t of<br>\n       Abs (_, _, t') =&gt; count_loose t' 0 &lt;= 1<br>\n     | _ =&gt; true);<br>\nin<br>\n   fn _ =&gt; fn ctxt =&gt; fn ct =&gt;<br>\n     if is_trivial_let (Thm.term_of ct)<br>\n     then SOME @{thm Let_def} (<em>no or one ocurrence of bound variable</em>)<br>\n     else<br>\n       let (<em>Norbert Schirmer's case</em>)<br>\n         val t = Thm.term_of ct;<br>\n         val ([t'], ctxt') = Variable.import_terms false [t] ctxt;<br>\n       in<br>\n<a href=\"http://Option.map\">Option.map</a> (hd o Variable.export ctxt' ctxt o single)<br>\n           (case t' of Const (@{const_name Let},_) $ x $ f =&gt; (* x and f are already in <br>\nnormal form *)<br>\n             if is_Free x orelse is_Bound x orelse is_Const x<br>\n             then SOME @{thm Let_def}<br>\n             else<br>\n               let<br>\n                 val n = case f of (Abs (x, _, _)) =&gt; x | _ =&gt; \"x\";<br>\n                 val cx = Thm.cterm_of ctxt x;<br>\n                 val xT = Thm.typ_of_cterm cx;<br>\n                 val cf = Thm.cterm_of ctxt f;<br>\n                 val fx_g = Simplifier.rewrite ctxt (Thm.apply cf cx);<br>\n                 val (_ $ _ $ g) = Thm.prop_of fx_g;<br>\n                 val g' = abstract_over (x, g);<br>\n                 val abs_g'= Abs (n, xT, g');<br>\n               in<br>\n                 if g aconv g' then<br>\n                   let<br>\n                     val rl =<br>\n                       cterm_instantiate [(f_Let_unfold, cf), (x_Let_unfold, cx)] @{thm <br>\nLet_unfold};<br>\n                   in SOME (rl OF [fx_g]) end<br>\n                 else if (Envir.beta_eta_contract f) aconv (Envir.beta_eta_contract <br>\nabs_g') then<br>\n                   NONE (<em>avoid identity conversion</em>)<br>\n                 else<br>\n                   (* normalise the abstracted body, as the abstraction might have<br>\n                      un-normalised the body, e.g., ordered rewriting,<br>\n                      simprocs with syntactic checks, ... *)<br>\n                   let<br>\n                     val g'_normal = Simplifier.rewrite ctxt (Thm.cterm_of ctxt abs_g');<br>\n                     val (_ $ _ $ g'_normalised) = Thm.prop_of g'_normal;<br>\n                   in<br>\n                     if (Envir.beta_eta_contract f) aconv (Envir.beta_eta_contract <br>\ng'_normalised) then<br>\n                       NONE<br>\n                     else<br>\n                       let<br>\n                         val g'x = abs_g' $ x;<br>\n                         val g_g'x = Thm.symmetric (Thm.beta_conversion false <br>\n(Thm.cterm_of ctxt g'x));<br>\n                         val rl =<br>\n                           @{thm Let_folded2} |&gt; cterm_instantiate<br>\n                             [(f_Let_folded2, Thm.cterm_of ctxt f),<br>\n                              (x_Let_folded2, cx),<br>\n                              (g_Let_folded2, Thm.cterm_of ctxt abs_g'),<br>\n                              (g'_Let_folded2, Thm.cterm_of ctxt g'_normalised)];<br>\n                       in SOME (rl OF [Thm.transitive fx_g g_g'x, g'_normal])<br>\n                       end<br>\n                   end<br>\n               end<br>\n           | _ =&gt; NONE)<br>\n       end<br>\nend<br>\n*}</p>",
        "id": 294643070,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162937
    }
]