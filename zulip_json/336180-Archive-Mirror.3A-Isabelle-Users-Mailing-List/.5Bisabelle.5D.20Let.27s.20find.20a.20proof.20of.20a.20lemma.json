[
    {
        "content": "<p>From: Victor Porton &lt;<a href=\"mailto:porton@narod.ru\">porton@narod.ru</a>&gt;<br>\nLet's find a proof of the following lemma, which is forgotten in ZF theory:</p>\n<p>lemma right_comp_id_any: \"r&lt;=Sigma(A,B) ==&gt; r O id(C) = restrict(r,C)\"</p>\n<p>I think I can, spending some time, find a proof myself, but I suspect my proof won't be optimal.</p>\n<p>Note that you have asked me to not send anymore missing lemmas in ZF. But this my message serves a different purpose, not to suggest its addition to ZF but to ask to help to find an elegant proof. (If you'll ask to not send messages like this, this will be the last.)</p>",
        "id": 294123228,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840471
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Mon, Dec 20, 2010 at 1:33 PM, Victor Porton &lt;<a href=\"mailto:porton@narod.ru\">porton@narod.ru</a>&gt; wrote:</p>\n<blockquote>\n<p>Let's find a proof of the following lemma, which is forgotten in ZF theory:</p>\n<p>lemma right_comp_id_any: \"r&lt;=Sigma(A,B) ==&gt; r O id(C) = restrict(r,C)\"</p>\n<p>I think I can, spending some time, find a proof myself, but I suspect my proof won't be optimal.</p>\n</blockquote>\n<p>This trivial lemma has a trivial proof. Just unfold the definitions<br>\nand apply auto:</p>\n<p>lemma right_comp_id_any: \"r O id(C) = restrict(r,C)\"<br>\nunfolding restrict_def comp_def by auto</p>\n<p>Notice that your assumption \"r&lt;=Sigma(A,B)\" is completely irrelevant<br>\nto the conclusion, which mentions neither A nor B.</p>\n<blockquote>\n<p>Note that you have asked me to not send anymore missing lemmas in ZF. But this my message serves a different purpose, not to suggest its addition to ZF but to ask to help to find an elegant proof. (If you'll ask to not send messages like this, this will be the last.)</p>\n</blockquote>\n<p>You have called this lemma \"forgotten\"; does this mean something<br>\ndifferent to you than \"missing\"?</p>\n<p>You might think this lemma would be a useful addition to the<br>\nIsabelle/ZF libraries, but I would suggest waiting to make such<br>\njudgments: Getting more experience writing nontrivial proofs in<br>\nIsabelle will give you a better idea of what kinds of library lemmas<br>\nare really useful. Working on a submission to the AFP would be a very<br>\ngood idea.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294123243,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840480
    },
    {
        "content": "<p>From: Victor Porton &lt;<a href=\"mailto:porton@narod.ru\">porton@narod.ru</a>&gt;<br>\n21.12.2010, 00:58, \"Brian Huffman\" &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;:</p>\n<blockquote>\n<p>On Mon, Dec 20, 2010 at 1:33 PM, Victor Porton &lt;<a href=\"mailto:porton@narod.ru\">porton@narod.ru</a>&gt;; wrote:</p>\n<blockquote>\n<p>Let's find a proof of the following lemma, which is forgotten in ZF theory:</p>\n<p>lemma right_comp_id_any: \"r&lt;=Sigma(A,B) ==&gt; r O id(C) = restrict(r,C)\"</p>\n<p>I think I can, spending some time, find a proof myself, but I suspect my proof won't be optimal.</p>\n</blockquote>\n<p>This trivial lemma has a trivial proof. Just unfold the definitions<br>\nand apply auto:</p>\n<p>lemma right_comp_id_any: \"r O id(C) = restrict(r,C)\"<br>\nunfolding restrict_def comp_def by auto</p>\n</blockquote>\n<p>Thanks for your proof. I would not find a short proof myself.<br>\nCan you teach me how to find such short proofs? Has it appeared as a simple experiment (let's try \"unfolding restrict_def comp_def by auto\") or there are some deep magic behind?</p>\n<blockquote>\n<blockquote>\n<p>Note that you have asked me to not send anymore missing lemmas in ZF. But this my message serves a different purpose, not to suggest its addition to ZF but to ask to help to find an elegant proof. (If you'll ask to not send messages like this, this will be the last.)</p>\n</blockquote>\n<p>You have called this lemma \"forgotten\"; does this mean something<br>\ndifferent to you than \"missing\"?</p>\n</blockquote>\n<p>It is the same.</p>\n<blockquote>\n<p>You might think this lemma would be a useful addition to the<br>\nIsabelle/ZF libraries, but I would suggest waiting to make such<br>\njudgments: Getting more experience writing nontrivial proofs in<br>\nIsabelle will give you a better idea of what kinds of library lemmas<br>\nare really useful. Working on a submission to the AFP would be a very<br>\ngood idea.</p>\n</blockquote>\n<p>I consider submission to AFP. But first I will try to submit to IsarMathLib, there my works are suitable. (Well, there are a problem: Larry Paulson's proofs with apply-style in my ZF_Addons.thy while IsarMathLib requires ISAR proofs. Maybe later I will ask for help transforming short apply-style proofs into not too long ISAR proofs.) I recall that I am accumulating my own theory with missing ZF theory lemmas, which I use in my logic research.)</p>",
        "id": 294123256,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840486
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nThere is no magic; this proof was practically the first thing I tried.</p>\n<p>In general it is often a good idea to start by trying an automatic<br>\ntactic like \"auto\"; sometimes you will get lucky. If \"auto\" can't<br>\nsucceed on its own, then unfolding some definitions first often helps.<br>\nHere auto doesn't know any rules about \"restrict\", so we need to<br>\nunfold its definition. It turns out that auto <em>does</em> have some rules<br>\nabout \"O\", so we don't really need to unfold that one (see compI and<br>\ncompE from ZF/Perm.thy).</p>\n<p>lemma right_comp_id_any: \"r O id(C) = restrict(r,C)\"<br>\nunfolding restrict_def by auto</p>\n<p>A useful addition to the ZF libraries might be to add rules about<br>\n\"restrict\" so that auto can do this proof all by itself. Here are some<br>\nnew lemmas restrictI and restrictE (compare these to compI and compE):</p>\n<p>lemma restrictI [intro!]:<br>\n  \"[| &lt;x, y&gt; : r; x : A |] ==&gt; &lt;x, y&gt; : restrict(r, A)\"<br>\nunfolding restrict_def by auto</p>\n<p>lemma restrictE [elim!]:<br>\n  \"[| xy : restrict(r, A);<br>\n      !!x y. [| xy = &lt;x, y&gt;; &lt;x, y&gt; : r; x : A |] ==&gt; P<br>\n   |] ==&gt; P\"<br>\nunfolding restrict_def by auto</p>\n<p>With these rules declared with the intro and elim attributes, auto can<br>\nnow prove your lemma in one step:</p>\n<p>lemma right_comp_id_any: \"r O id(C) = restrict(r,C)\"<br>\nby auto</p>\n<p>Rules restrictI and restrictE are the kinds of lemmas that make good<br>\nadditions to libraries: they make other proofs easier and more<br>\nautomatic. Learning to recognize and create useful lemmas like this<br>\nwill come with experience.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294123263,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840489
    }
]