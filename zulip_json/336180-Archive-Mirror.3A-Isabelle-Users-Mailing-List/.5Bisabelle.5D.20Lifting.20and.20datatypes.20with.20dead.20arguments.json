[
    {
        "content": "<p>From: Joshua Schneider &lt;<a href=\"mailto:dev@jshs.de\">dev@jshs.de</a>&gt;<br>\nDear list,</p>\n<p>I have this datatype, which is some kind of generalised tree:</p>\n<p>datatype 'a T = L | N \"'a ⇒ 'a T\"</p>\n<p>I would like to combine it with a quotient and then lift properties to<br>\nthe combined type. Because 'a is dead, the datatype package won't define<br>\na relator or do any of the setup for lifting/transfer.</p>\n<p>If I define the \"obvious\" relator</p>\n<p>inductive rel_T :: \"('a ⇒ 'b ⇒ bool) ⇒ 'a T ⇒ 'b T ⇒ bool\"<br>\n      for R<br>\n      where<br>\n        \"rel_T R L L\"<br>\n      | \"rel_fun R (rel_T R) f g ⟹ rel_T R (N f) (N g)\"</p>\n<p>and similarly a map function, it seems like quotients should be<br>\npreserved. However, proving some of the relator properties directly by<br>\ninduction over T and rel_T is rather difficult, and I have not fully<br>\nsucceeded with the quotient map rule.</p>\n<p>Could this even work? Is there a more general theory for lifting through<br>\ndatatypes than what is provided by BNFs? It would be particularly nice<br>\nif I could use somehow that the function type itself preserves<br>\nquotients.</p>\n<p>Best,<br>\nJoshua</p>",
        "id": 294708896,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181499
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Joshua,</p>\n<p>When we designed the BNF package, we mainly cared about preserving BNFs (which are covariant functors) across (co)datatype fixpoints.</p>\n<p>So, for now we decided to \"kill\" all contravariant arguments.</p>\n<p>For your case, one can prove</p>\n<p>lemma Quotient_T[quot_map]:<br>\nassumes \"Quotient R Abs Rep T\"<br>\nshows \"Quotient (rel_T R) (map_T Rep) (map_T Abs) (rel_T T)\"</p>\n<p>with the following definition of map_T:</p>\n<p>primrec map_T :: \"('a ⇒ 'b) ⇒ 'b T ⇒ 'a T\"<br>\n  where<br>\n   \"map_T u L = L\"<br>\n  |\"map_T u (N f) = N (map_T u o f o u)\"</p>\n<p>Below is the proof (very unpolished, due to lack of time). Hopefully, in the future we'll automate such proofs for BNFs.</p>\n<p>All the best,</p>\n<p>Andrei</p>\n<p>datatype 'a T = L | N \"'a ⇒ 'a T\"</p>\n<p>inductive rel_T :: \"('a ⇒ 'b ⇒ bool) ⇒ 'a T ⇒ 'b T ⇒ bool\"<br>\nfor R<br>\nwhere<br>\n \"rel_T R L L\"<br>\n| \"rel_fun R (rel_T R) f g ⟹ rel_T R (N f) (N g)\"</p>\n<p>primrec map_T :: \"('a ⇒ 'b) ⇒ 'b T ⇒ 'a T\"<br>\n  where<br>\n   \"map_T u L = L\"<br>\n  |\"map_T u (N f) = N (map_T u o f o u)\"</p>\n<p>lemma T_map_id[simp]: \"map_T id t = t\"<br>\n  by (induct t) auto</p>\n<p>lemma T_map_o: \"map_T (g o f) t = map_T f (map_T g t)\"<br>\n  by (induct t) auto</p>\n<p>lemma symp_rel_T:<br>\nassumes \"Quotient R Abs Rep T\"<br>\nshows \"symp (rel_T R)\"<br>\nunfolding symp_def proof safe<br>\n  fix t t' assume \"rel_T R t t'\" thus \"rel_T R t' t\"<br>\n    apply induct apply(auto intro!: rel_T.intros simp: rel_fun_def)<br>\n      using assms<br>\n      by (meson Quotient_part_equivp part_equivp_symp)<br>\n  qed</p>\n<p>lemma transp_rel_T:<br>\nassumes \"Quotient R Abs Rep T\"<br>\nshows \"transp (rel_T R)\"<br>\nunfolding transp_def proof safe<br>\n  fix t t' t'' assume \"rel_T R t t'\" \"rel_T R t' t''\"<br>\n  thus \"rel_T R t t''\"<br>\n    apply (induction arbitrary: t'')<br>\n     apply(auto intro!: rel_T.intros simp: rel_fun_def)<br>\n      apply(case_tac t'', auto elim!: rel_T.cases simp: rel_fun_def)<br>\n    by (metis Quotient_refl1 assms rel_T.intros(2) rel_funI)<br>\nqed</p>\n<p>lemma Quotient_rel_map_T:<br>\nassumes \"Quotient R Abs Rep T\"<br>\nshows \"rel_T R t t' ⟷ (rel_T R t t ∧ rel_T R t' t' ∧ map_T Rep t = map_T Rep t')\"<br>\nproof(induction t arbitrary: t')<br>\n  case (L t')<br>\n  thus ?case by (auto intro!: rel_T.intros elim!: rel_T.cases)<br>\nnext<br>\n  case (N f t') note i = N<br>\n  show ?case proof(cases t')<br>\n    case L thus ?thesis by (auto elim!: rel_T.cases)<br>\n  next<br>\n    case (N f') note t' = N<br>\n    show ?thesis unfolding t' proof safe<br>\n      assume ff': \"rel_T R (N f) (N f')\"<br>\n      show \"rel_T R (N f) (N f)\" proof(intro rel_T.intros rel_funI)<br>\n        fix a b assume R: \"R a b\"<br>\n        hence \"rel_T R (f a) (f a)\" \"rel_T R (f b) (f b)\" \"map_T Rep (f a) = map_T Rep (f b)\"<br>\n        apply (metis T.distinct(1) T.inject apply_rsp assms ff' i rangeI rel_T.simps)<br>\n        apply (metis Quotient_refl2 T.distinct(1) T.inject R apply_rsp assms ff' i rangeI rel_T.simps)<br>\n        by (metis Quotient_refl2 T.distinct(2) T.inject R assms ff' i rangeI rel_T.simps rel_fun_def)<br>\n        thus \"rel_T R (f a) (f b)\" using i unfolding image_def by auto<br>\n      qed<br>\n      show \"rel_T R (N f') (N f')\" proof(intro rel_T.intros rel_funI)<br>\n        fix a b assume R: \"R a b\"<br>\n        hence \"rel_T R (f a) (f a)\" \"rel_T R (f b) (f b)\" \"map_T Rep (f a) = map_T Rep (f b)\"<br>\n        apply (metis T.distinct(1) T.inject apply_rsp assms ff' i rangeI rel_T.simps)<br>\n        apply (metis Quotient_refl2 T.distinct(1) T.inject R apply_rsp assms ff' i rangeI rel_T.simps)<br>\n        by (metis Quotient_refl2 T.distinct(2) T.inject R assms ff' i rangeI rel_T.simps rel_fun_def)<br>\n        hence \"rel_T R (f a) (f b)\" using i unfolding image_def by auto<br>\n        moreover have \"rel_T R (f a) (f' b)\"<br>\n        by (metis R T.distinct(2) T.inject apply_rsp assms ff' rel_T.simps)<br>\n        moreover have \"rel_T R (f' a) (f b)\"<br>\n        by (metis R T.distinct(1) T.inject apply_rsp assms ff' rel_T.simps symp_def symp_rel_T)<br>\n        ultimately show \"rel_T R (f' a) (f' b)\"<br>\n        using symp_rel_T[OF assms] transp_rel_T[OF assms]<br>\n        by (meson sympE transpE)<br>\n      qed<br>\n      {fix a have \"map_T Rep (f (Rep a)) = map_T Rep (f' (Rep a))\"<br>\n       using i[of \"f (Rep a)\" \"f' (Rep a)\"] ff'<br>\n       by simp (metis Quotient_rel_rep T.inject assms rel_T.simps rel_funD)<br>\n      }<br>\n      thus \"map_T Rep (N f) = map_T Rep (N f')\" by (auto simp: fun_eq_iff)<br>\n    next<br>\n      assume 0: \"rel_T R (N f) (N f)\" and 1: \"rel_T R (N f') (N f')\" and 2: \"map_T Rep (N f) = map_T Rep (N f')\"<br>\n      show \"rel_T R (N f) (N f')\" proof(intro rel_T.intros rel_funI)<br>\n        fix a b assume R: \"R a b\"<br>\n        hence 3: \"R a a ∧ R b b ∧ Abs a = Abs b\" using assms unfolding Quotient_def by blast<br>\n        have \"R a (Rep (Abs a))\"<br>\n        by (smt \"3\" Quotient_abs_rep Quotient_rel Quotient_rel_rep assms)<br>\n        hence A: \"rel_T R (f a) (f (Rep (Abs a)))\"<br>\n        by (metis \"0\" T.distinct(2) T.inject apply_rsp assms rel_T.simps)<br>\n        have \"map_T Rep (f (Rep (Abs a))) = map_T Rep (f' (Rep (Abs b)))\"<br>\n        using 2 3 by (auto simp: fun_eq_iff)<br>\n        moreover have \"rel_T R (f (Rep (Abs a))) (f (Rep (Abs a)))\"<br>\n        using A i by blast<br>\n        moreover have \"rel_T R (f' (Rep (Abs b))) (f' (Rep (Abs b)))\"<br>\n        by (metis \"1\" T.distinct(1) T.inject apply_rsp'' assms rel_T.cases)<br>\n        ultimately have AB: \"rel_T R (f (Rep (Abs a))) (f' (Rep (Abs b)))\"<br>\n        using i[of \"f (Rep (Abs a))\" \"f' (Rep (Abs b))\"] by blast<br>\n        have \"R b (Rep (Abs b))\"<br>\n        by (smt \"3\" Quotient_abs_rep Quotient_rel Quotient_rel_rep assms)<br>\n        hence B: \"rel_T R (f' b) (f' (Rep (Abs b)))\"<br>\n        by (metis 1 T.distinct(2) T.inject apply_rsp assms rel_T.simps)<br>\n        from A B AB show \"rel_T R (f a) (f' b)\" using symp_rel_T[OF assms] transp_rel_T[OF assms]<br>\n        by (meson sympE transpE)<br>\n      qed<br>\n    qed<br>\n  qed<br>\nqed</p>\n<p>lemma Quotient_rel_map_T2:<br>\nassumes  \"Quotient R Abs Rep T\"<br>\nshows \"rel_T R (map_T Abs t) (map_T Abs t)\"<br>\n  apply(induct t)<br>\n  by (auto intro!: rel_T.intros simp: rel_fun_def T_map_o[symmetric] image_def Quotient_rel[OF assms])<br>\n     (metis Quotient_rel assms)</p>\n<p>lemma Quotient_T[quot_map]:<br>\nassumes \"Quotient R Abs Rep T\"<br>\nshows \"Quotient (rel_T R) (map_T Rep) (map_T Abs) (rel_T T)\"<br>\nunfolding Quotient_def proof (intro conjI)<br>\n  have [simp]: \"Abs o Rep = id\" using assms unfolding Quotient_def o_def id_def by auto<br>\n  show \"∀ t. map_T Rep (map_T Abs t) = t\"<br>\n  using assms unfolding Quotient_def T_map_o[symmetric] by simp<br>\nnext<br>\n  show \"∀ t. rel_T R (map_T Abs t) (map_T Abs t)\"<br>\n  using  Quotient_rel_map_T2[OF assms] by auto<br>\nnext<br>\n  show \"∀r s. rel_T R r s = (rel_T R r r ∧ rel_T R s s ∧ map_T Rep r = map_T Rep s)\"<br>\n  using  Quotient_rel_map_T[OF assms] by blast<br>\nnext<br>\n  show \"rel_T T = (λt t'. rel_T R t t ∧ map_T Rep t = t')\" proof(intro ext)<br>\n    fix t t' show \"rel_T T t t' ⟷ rel_T R t t ∧ map_T Rep t = t'\"<br>\n    proof(induct t arbitrary: t')<br>\n      case L<br>\n      thus ?case by (auto intro!: rel_T.intros elim!: rel_T.cases)<br>\n    next<br>\n      case (N f t')<br>\n      {fix t t' assume \"∀x y. R x y ⟶ rel_T R (f x) (f y)\" and \"T t t'\"<br>\n       hence \"rel_T T (f t) (map_T Rep (f (Rep t')))\"<br>\n       using N.hyps[of \"f t\" \"map_T Rep (f (Rep t'))\"] using Quotient_rel_map_T[OF assms]<br>\n       by (smt Quotient_abs_rep Quotient_cr_rel Quotient_rel Quotient_rel_rep assms rangeI)<br>\n      }<br>\n      thus ?case apply(cases t') apply (auto intro!: rel_T.intros ext elim!: rel_T.cases simp: rel_fun_def)<br>\n      apply (smt N.hyps Quotient_refl1 Quotient_refl2 Quotient_rel_abs Quotient_rel_map_T Quotient_to_transfer assms rangeI)<br>\n      by (metis N.hyps Quotient_alt_def4 assms rangeI)<br>\n    qed<br>\n  qed<br>\nqed</p>",
        "id": 294708915,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181507
    },
    {
        "content": "<p>From: Joshua Schneider &lt;<a href=\"mailto:dev@jshs.de\">dev@jshs.de</a>&gt;<br>\nHi Andrei,</p>\n<p>Thank you for working through the proof! It seems like the transfer of the<br>\nequivalence relation is the trickiest part, which was the missing piece in<br>\nmy own attempt at proving this.</p>\n<p>I would also like to generalise the quotient mapping to arbitrary nested<br>\nBNFs, but I don't see how that would work based on your solution.</p>\n<p>I recently talked to Andreas Lochbihler about the problem, and he suggested<br>\na fixed-point induction. I have now implemented that idea (see attached<br>\ntheory), using a version of the Quotient predicate which is restricted to<br>\nsome subset of the abstract type. I think that it is promising, because the<br>\ncore of the proof is compositional with respect to the functor structure.<br>\nI have not tried to scale it to larger examples, though.</p>\n<p>Do you think that this is a worthwhile path towards automation, or do you<br>\nhave something different in mind?</p>\n<p>Cheers,<br>\nJoshua<br>\n<a href=\"/user_uploads/14278/XAwxfm5M1Ijq5QB3JY-6eCZf/Inductive_Quotients.thy\">Inductive_Quotients.thy</a></p>",
        "id": 294708988,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181536
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Joshua,</p>\n<p>Thanks for the theory file. You are up to some very nice and useful results.  :-)</p>\n<p>However, to approach the case of arbitrary (nested) datatypes, I don't think fixpoint induction</p>\n<p>for constructors is very helpful. Over the last few years, we have built powerful abstractions</p>\n<p>that you can use here: Given a BNF ('a,'b) F, there is a generic way to construct its datatype BNF,</p>\n<p>'a D, and its codatatype BNF, 'a C, i.e., such that:</p>\n<p>(1) ('a, 'a D) F is isomorphic to 'a D,</p>\n<p>(2) ('a, 'a C) F is isomorphic to 'a C,</p>\n<p>(3) suitable (co)induction and (co)recursion principles hold for these.</p>\n<p>Our main motivation behind BNFs was to provide enough structure for being able to construct</p>\n<p>'a D and 'a C abstractly (without caring about how the underlying F looks like). Note that this</p>\n<p>situation covers the nested case, since F can be any BNF.</p>\n<p>The familiar high-level case distinction, induction, recursion etc. made available to the users is</p>\n<p>essentially implemented as \"syntactic sugar\" on top of these abstract constructions (performed</p>\n<p>for n mutually (co)recursive fixpoint equations like the above). This is all described in our paper:</p>\n<p><a href=\"http://andreipopescu.uk/pdf/LICS2012.pdf\">http://andreipopescu.uk/pdf/LICS2012.pdf</a></p>\n<p>So, IMO, the best^[*] way to go is:</p>\n<p>--(1) Prove the quotient theorem under abstract assumptions, using BNFs and their fixpoints.</p>\n<p>You will see that the abstract induction theorem encodes your fixpoint \"apply_T_ctors\" induction</p>\n<p>as structural induction, so you will not need a generalized quotient predicate.</p>\n<p>--(2) Then either manually instantiate to particular (co)datatypes of interest (it is very easy!),</p>\n<p>or, more ambitiously, automate the instantiation in Isabelle/ML.</p>\n<p>If you are interested in going on this path (perhaps after having consulted the above paper), I</p>\n<p>can set up for you a theory file with the relevant structure for pursuing point (1).</p>\n<p>Best regards,</p>\n<p>Andrei</p>\n<p>PS. By \"best,\" I mean \"most interesting scientifically and most useful for Isabelle.\"</p>",
        "id": 294709012,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181541
    }
]