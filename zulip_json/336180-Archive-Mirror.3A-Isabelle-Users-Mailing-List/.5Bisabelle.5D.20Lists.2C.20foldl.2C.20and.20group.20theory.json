[
    {
        "content": "<p>From: Matthew &lt;<a href=\"mailto:superuser@mattweidner.com\">superuser@mattweidner.com</a>&gt;<br>\nHello,</p>\n<p>To get myself used to Isabelle/Isar, I am attempting to formalize some<br>\nbasic results of group theory (I realize this has already been done in<br>\ntheory Group-Ring-Module).  I have already formalized the axioms and<br>\nbasic results (e.g., ab = 1 ==&gt; a = b^-1).<br>\nHowever, I have been having great difficulty with the theorem which can<br>\nbe represented informally as:<br>\na1 : G; a2 : G; ... an : G  ==&gt; a1 <strong> a2 </strong> ... ** an : G<br>\nwhere the a's with subscripts are members of G, G is the group's set, **<br>\nis the group operation, and : indicates set membership.<br>\nMy approach so far has been to use a list of elements, where membership<br>\nin the list implies membership in G, and then to show that foldl( ** 1<br>\nthelist ) is in G (1 is the identity element), i.e.,<br>\n\"\\&lt;lbrakk&gt;x \\&lt;in&gt; set( thelist::'a list ) \\&lt;longrightarrow&gt; x \\&lt;in&gt; G<br>\n\\&lt;rbrakk&gt; \\&lt;longrightarrow&gt; (foldl (prod) 1 thelist ) \\&lt;in&gt; G\"</p>\n<p>Is this the correct approach?</p>\n<p>Using induction, I have  reduced the problem to several subgoals which<br>\nlook provable:<br>\n\" 1. \\&lt;And&gt;a list.<br>\n       \\&lt;lbrakk&gt;x \\&lt;in&gt; set (a # list) \\&lt;longrightarrow&gt; x \\&lt;in&gt; G;<br>\nfoldl op ** 1 list \\&lt;in&gt; G; a \\&lt;in&gt; G\\&lt;rbrakk&gt;<br>\n       \\&lt;Longrightarrow&gt; foldl op <strong> (1 </strong> a) list = a <strong> foldl op </strong> 1<br>\nlist</p>\n<ol start=\"2\">\n<li>\\&lt;And&gt;a list. \\&lt;lbrakk&gt;x \\&lt;in&gt; set (a # list) \\&lt;longrightarrow&gt; x<br>\n\\&lt;in&gt; G; foldl op ** 1 list \\&lt;in&gt; G\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; a \\&lt;in&gt;<br>\nG\"<br>\nwhere \"a\" and \"list\" are variables generated by the application of<br>\n(induct_tac thelist).<br>\nHowever, these subgoals have been extremely difficult to prove.  The<br>\nmost frustrating thing is that sledgehammer will claim to find proofs,<br>\nbut metis is unable to reconstruct them.</li>\n</ol>\n<p>Is my whole approach wrong, or am I missing some essential theorems?</p>\n<p>Thanks,<br>\nMatthew</p>",
        "id": 294144519,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847019
    },
    {
        "content": "<p>From: Johannes Hoelzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nYou need to quantify over all x, the meta-quantifier is \"!!\":</p>\n<p>\"\\&lt;lbrakk&gt;<br>\n  (!!x. x \\&lt;in&gt; set( thelist::'a list ) \\&lt;longrightarrow&gt; x \\&lt;in&gt; G)<br>\n  \\&lt;rbrakk&gt; \\&lt;longrightarrow&gt; (foldl (prod) 1 thelist ) \\&lt;in&gt; G\"</p>\n<p>without quantifier you assume there is one x which if it is in thelist <br>\nthen also in G. With the quantifer you assume that all elements in the <br>\nlist are in G.</p>\n<p>With this the lemma should be solveable<br>\n   by (induct thelist) (auto simp add: ...)</p>\n<p>Btw: Don't use induct_tac, use the induct method. Generally try to avoid <br>\nthe _tac methods when working in Isabelle/Isar.</p>\n<p>Sledgehammer may in the current release of Isabelle find some false<br>\n\"proofs\", which are then not proveable by metis. In the next version <br>\nSledgehammer shouldn't return that it found a proof.</p>\n<p>- Johannes</p>",
        "id": 294144521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847021
    }
]