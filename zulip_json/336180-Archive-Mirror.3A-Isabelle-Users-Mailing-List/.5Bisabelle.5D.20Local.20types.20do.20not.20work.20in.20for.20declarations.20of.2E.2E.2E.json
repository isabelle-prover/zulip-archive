[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear localisation experts,</p>\n<p>I have a locale with polymorphic parameters and would like instantiate the type variables <br>\nin a sublocale. I know of two ways to achieve this:</p>\n<ol>\n<li>Declare the parameters in a for clause with the specialised types.</li>\n<li>Use the context element constrains with the specialised types.</li>\n</ol>\n<p>From past discussions on this mailing list, I have the impression that \"constrains\" is <br>\nconsidered outdated and should be replaced with for clauses (for example in <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-February/msg00138.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-February/msg00138.html</a>).</p>\n<p>I now ran into a problem with approach 1 when there are local type synonyms. Below is a <br>\nminimal example. Locale l declares a type with a type variable, its sublocale l1 fixes a <br>\nparameter whose type contains the local type, and l1's sublocale l2 tries to instantiate <br>\ntype type variable:</p>\n<p>locale l begin<br>\n   typedef 'a td = \"UNIV :: 'a set\" ..<br>\n   end</p>\n<p>locale l1 = l + fixes y :: \"'a td\"</p>\n<p>locale l2 = l1 y for y :: \"bool td\"</p>\n<p>Here, I get an error in the last line claiming that td was an undefined type name. The <br>\ndeclaration works if I use constrains instead of a for clause.</p>\n<p>locale l2 = l1 + constrains y :: \"bool td\"</p>\n<p>Alternatively, I can go via the foundational type, but this seems to be somewhat ugly.</p>\n<p>locale l2 = l1 y for y :: \"bool <a href=\"http://l.td\">l.td</a>\"</p>\n<p>Is this a known limitation of localised typedef/type_synonym and/or a valid reason for <br>\nusing the \"deprecated\" constrains element?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294646971,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164519
    }
]