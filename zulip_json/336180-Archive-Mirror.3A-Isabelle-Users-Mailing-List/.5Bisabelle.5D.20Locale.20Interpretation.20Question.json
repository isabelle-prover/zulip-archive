[
    {
        "content": "<p>From: Ashley Yakeley &lt;<a href=\"mailto:ashleyy@microsoft.com\">ashleyy@microsoft.com</a>&gt;<br>\nHi, how do I express \"if V is a vector space, then V is an affine space on <br>\nV\" given this locale for affine spaces? Note that vector_space is also a <br>\nlocale. I know how to show something is an interpretation of my affine_space <br>\nlocale if that something is a class instead of a locale.</p>\n<p>theory Affine<br>\nimports RealVector<br>\nbegin</p>\n<p>locale affine_space =<br>\n  vector_space scale for scale ::\"'a::field ⇒ 'b::ab_group_add ⇒ 'b\" +<br>\n  fixes affplus :: \"'b ⇒ 'f ⇒ 'f\"<br>\n  fixes affminus :: \"'f ⇒ 'f ⇒ 'b\"<br>\n  assumes affine_zero [simp]: \"affplus 0 p = p\"<br>\n  and  affine_assoc [simp]: \"affplus v (affplus w p) = affplus (v + w) p\"<br>\n  and  affine_invert_1 [simp]: \"affplus (affminus q p) p = q\"<br>\n  and  affine_invert_2 [simp]: \"affminus (affplus v p) p = v\"</p>\n<p>end</p>",
        "id": 294145705,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847410
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Ashley,</p>\n<p>there are in several ways to do that.</p>\n<ol>\n<li>\"sublocale\" for locales is the analogue of \"subclass\" for type classes, see <br>\nthe tutorial on locales, section 4. Thus, you could write</li>\n</ol>\n<p>sublocale vector_space &lt; affine_space<br>\n     \"space\"<br>\n     \"implementation for affplus\"<br>\n     \"implementation for affminus\"</p>\n<p>followed by a proof that your implementations for affplus and affminus satisfy <br>\nthe assumptions. Although this is the standard way, it does not work in your <br>\ncase because affine_space is already a sublocale of vector_space, as the former <br>\ninherits from the latter. Therefore, after this declaration, the context <br>\nvector_space may no longer be opened.</p>\n<ol start=\"2\">\n<li>Instead, section 7.1 of the locale tutorial applies. Declare a new locale <br>\nthat collects all facts about vector spaces viewed as affine spaces.</li>\n</ol>\n<p>locale vector_space_as_affine_space = vector_space<br>\nsublocale vector_space_as_affine_space &lt; affine_space<br>\n     \"space\"<br>\n     \"implementation_for_affplus\"<br>\n     \"implementation_for_affminus\"</p>\n<ol start=\"3\">\n<li>If you only seldomly need to refer to vector spaces as affine spaces, it <br>\nmight be a good idea (for performance reasons) not to declare the sublocale <br>\nrelation. In that case, you want to prove a lemma in vector_space that allows <br>\nyou to quickly interpret affine_space whenever needed:</li>\n</ol>\n<p>lemma (in vector_space) affine_space:<br>\n   \"affine_space space<br>\n      (implementation_for_affplus) (implementation_for_affminus)\"</p>\n<p>Then, whenever you need a fact F from affine_space in a proof of vector_space, <br>\neither locally interpret affine_space</p>\n<p>lemma ...<br>\nproof<br>\n   interpret affine_space<br>\n     \"space\"<br>\n     \"implementation for affplus\"<br>\n     \"implementation for affminus\"<br>\n     by(rule affine_space)<br>\n   note F<br>\nqed</p>\n<p>or bypass the locale mechanism and work on the foundational layer directly, i.e.</p>\n<p>note affine_space.F[OF affine_space]</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294145724,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847414
    }
]