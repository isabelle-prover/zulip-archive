[
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nAndreas,</p>\n<p>Thanks for your help on this. Your explanation of what the sublocale command actually does is the most lucid I have yet seen. Can the documentation maintainer(s) add something like this to the official docs please?</p>\n<p>Now, to flog my dead horse a bit more:</p>\n<p>On 18/02/2010, at 7:51 PM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>[..]<br>\n- The sublocale command introduces an abbreviation foo in C<br>\nwhere \"foo == %c. <a href=\"http://A.foo\">A.foo</a> (g c)\".</p>\n</blockquote>\n<p>Ah, indeed! This is the behaviour I want. However:</p>\n<blockquote>\n<p>Now back to your old post: If you just want the additional parameter \"a\" of locale A to be \"lambda-abstractable\", declare it explicitly in a for clause:</p>\n<p>sublocale L &lt; LsubA!: A x X a for a by unfold_locales.</p>\n<p>Do not forget to give a name (like LsubA) to this import and make it an obligatory prefix (!). Otherwise, you will not be able to open the context A again. Then, in locale L, you get an abbreviation LsubA.f for the f from A which takes an extra parameter \"a\". Similarly, there are the facts LsubA.f_def, LsubA.g_def and LsubA.Q. Is this, what you wanted?</p>\n</blockquote>\n<p>I think I gave up on this approach as the constants you mention take the locale-assumptions they use as parameters, separately. This means that if I change the definition of these constants, e.g. to use more or fewer of the locale-assumptions, then I may have to update all uses of them everywhere.</p>\n<p>The limitations/irritations of the position-based locale setup are well illustrated by this theory:</p>\n<p><a href=\"http://afp.sourceforge.net/entries/Presburger-Automata.shtml\">http://afp.sourceforge.net/entries/Presburger-Automata.shtml</a></p>\n<p>by Stefan Berghofer and Markus Reiter. IMHO the locale interpretation commands are meaningless to the casual reader, whereas the lemmas (in e.g. the DFS theory) are as lucid one can hope for.</p>\n<p>I adapted this theory to use records explicitly. Now the DFS lemmas are a bit obfuscated but using the theory has been a bit simpler and more robust to change. I originally did this because I did not understand sublocale.</p>\n<blockquote>\n<blockquote>\n<p>I overcame my parameterisation problem by rewriting the locale as a record (of variables that were 'fixes' in the locale) and a predicate (capturing the locale assumptions). I suggest the locale mechanism be extended to do this, in addition to whatever it now does.<br>\nThe locale package already produces global definitions, but not a record. There is a predicate with the same name as the locale which contains all the assumptions (including those from imported locales).<br>\nEvery definition and abbreviation of X in a locale L produces a global definition/abbreviation L.X.<br>\nSimilarly, every fact T that is shown inside L corresponds to a global fact L.T, which has the locale predicate L as additional premise.<br>\nSo, this is very much what you want except for currying: The locale parameters are not collapsed into a record, but kept separately.<br>\nYou might want to have a look at those.</p>\n</blockquote>\n</blockquote>\n<p>I have. My issue is that they are not as abstract as I'd like them to be.</p>\n<blockquote>\n<p>Collapsing all parameters into a single record would make it easier to work with the global constants because one would have to pass only a single parameter to them. However, if you have definitions in different locales (one of which is a sublocale of the other), you would have to do many record conversions from the sublocale record to the superlocale record. So, a record is not a better option.</p>\n</blockquote>\n<p>This is a good point. I suggested the record-based constants be additional to the existing ones, so the limitations of using records does not get in the way of large locale hierarchies.</p>\n<p>Locales strike me as very successful when the number of parameters are small, but are less so when used with lots of parameters, as in the DFS theory mentioned above. Perhaps the use-cases split into those with loads of parameters (e.g. parameterised algorithms like the DFS) and those with few (e.g. algebraic structures), and different naming mechanisms might be appropriate for each. Perhaps I have been too quick to propose records as the solution.</p>\n<p>Thanks again Andreas!</p>\n<p>cheers<br>\npeter</p>",
        "id": 294100354,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833565
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<p>I think I gave up on this approach as the constants you mention take<br>\nthe locale-assumptions they use as parameters, separately. This means<br>\nthat if I change the definition of these constants, e.g. to use more<br>\nor fewer of the locale-assumptions, then I may have to update all uses<br>\nof them everywhere.<br>\nIf you ever refer to the global constants somewhere, you are right. I <br>\nexperienced this myself often enough, but as long as you stay within the <br>\nlocale framework, this all is very convenient - provided that you make <br>\nsure that the order of parameters stays the same when extending locales.<br>\nThis is particularly tricky if they have a lot of parameters.</p>\n</blockquote>\n<p>Here are two hints on how I use locales:</p>\n<ol>\n<li>Split your locale into two: Let one only fix the parameters and let <br>\nthe other inherit from it and add the locale assumptions. Then, put all <br>\nyour constant definitions (definition/inductive/fun/primrec/...) into <br>\nthe first locale and all your lemmas into the second locale, if <br>\npossible. (I think, only function definitions whose termination proof <br>\nrelies on locale assumptions cannot go that way). This has the following <br>\nadvantages:</li>\n</ol>\n<ul>\n<li>\n<p>The definitional facts, simplification/introduction rules, etc. have <br>\nno additional locale predicate as premise, i.e. you can use them <br>\nwhenever you like without having to make sure that the locale <br>\nassumptions are currently satisfied. This also allows the code generator <br>\nto use them.</p>\n</li>\n<li>\n<p>You can have the locale parameters already implicit when you make your <br>\ndefinitions (unlike in the Presburger-Automaton AFP entry).</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>Try to avoid as hard as you can to refer to global constants anytime. <br>\n  Always use the sublocale command or conditional interpretation (see <br>\nthe locale tutorial, sec. 7). Then, the locale infrastructure keeps <br>\ntrack of all implicit parameters - even if you change your definitions <br>\nin a locale. If you finally decide to change the parameter order, you <br>\nonly have to adapt the sublocale/conditional interpretations, but not <br>\nthe uses.</li>\n</ol>\n<blockquote>\n<p>Locales strike me as very successful when the number of parameters are<br>\nsmall, but are less so when used with lots of parameters, as in the<br>\nDFS theory mentioned above.<br>\nI myself have found locales very helpful even if there are a lot of <br>\nparameters around (see e.g. my theory <br>\n<a href=\"http://afp.sourceforge.net/browser_info/current/HOL/JinjaThreads/FWBisimulation.html\">http://afp.sourceforge.net/browser_info/current/HOL/JinjaThreads/FWBisimulation.html</a><br>\nfrom \"Jinja with Threads\" in the AFP), but I must admit that getting <br>\neverything work smoothly with very complex locale structures is quite <br>\nchallenging.</p>\n</blockquote>\n<p>What I would like is to be able to automatically generate a locale <br>\ninheritance graph (similar to the theory graph produced by the graph <br>\nbrowser) with all locale morphisms shown.</p>\n<p>Chees,<br>\nAndreas</p>",
        "id": 294100400,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833583
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHello all,</p>\n<p>I want to import a locale A into a locale B such that one of A's <br>\nparameters is replaced by a fixed parameter of B applied to an arbitrary <br>\nvalue. Here's a short example what I would like to write:</p>\n<p>locale A =<br>\n   fixes f :: \"'a\"<br>\n   assume \"f\"</p>\n<p>locale B = A \"g b\"<br>\n   for g :: \"'b =&gt; 'a\"<br>\n   assumes ...</p>\n<p>However, Isabelle complains at B's declaration that b is an illegal free <br>\nvariable. Adding b to the for clause is no solution to my problem, <br>\nbecause this fixes b. I am currently doing the following:</p>\n<p>locale B = fixes g :: \"'b =&gt; 'a\"<br>\n   assumes A: \"A (g b)\"<br>\n   and ...</p>\n<p>sublocale B &lt; A \"g b\"<br>\n   for b<br>\nby(rule A)</p>\n<p>Although this works for the moment, I am not happy with this solution:<br>\nI can only use definitions from A in the other assumptions of B via <br>\ntheir full name with all parameters explicitly provided.</p>\n<p>So my question is:<br>\nWhat is the best way to import A in B?</p>\n<p>Regards,<br>\nAndreas</p>",
        "id": 294101292,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833859
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>I want to import a locale A into a locale B such that one of A's<br>\nparameters is replaced by a fixed parameter of B applied to an<br>\narbitrary value. Here's a short example what I would like to write:</p>\n<p>locale A =<br>\n  fixes f :: \"'a\"<br>\n  assume \"f\"</p>\n<p>locale B = A \"g b\"<br>\n  for g :: \"'b =&gt; 'a\"<br>\n  assumes ...</p>\n</blockquote>\n<p>I am not sure what your ultimate goal is, and I don't see what  <br>\nsemantics of b should be here.  Locale parameters are \"arbitrary but  <br>\nfixed\".  I don't know what \"arbitrary and not fixed\" should mean when  <br>\nit comes to applying the module in another context.</p>\n<blockquote>\n<p>However, Isabelle complains at B's declaration that b is an illegal<br>\nfree variable. Adding b to the for clause is no solution to my problem,<br>\nbecause this fixes b. I am currently doing the following:</p>\n<p>locale B = fixes g :: \"'b =&gt; 'a\"<br>\n  assumes A: \"A (g b)\"<br>\n  and ...</p>\n<p>sublocale B &lt; A \"g b\"<br>\n  for b<br>\nby(rule A)</p>\n<p>Although this works for the moment, I am not happy with this solution:<br>\nI can only use definitions from A in the other assumptions of B via<br>\ntheir full name with all parameters explicitly provided.</p>\n</blockquote>\n<p>The declaration of B is still strange and should probably be rejected.  <br>\n  Don't rely on this in future version of Isabelle.</p>\n<blockquote>\n<p>What is the best way to import A in B?</p>\n</blockquote>\n<p>Since both declarations of B are \"strange\" this question is not well-defined.</p>\n<p>Possibly you want to redeclare syntax for definitions that was  <br>\ndisabled since inherited through a non-identical morphism (cf. Section  <br>\n6 of the tutorial, immediately before Section 6.1 starts.)</p>\n<p>Best regards,</p>\n<p>Clemens</p>",
        "id": 294101399,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833894
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nContrary to my previous message, this is, of course, well-defined.  b  <br>\nis here universally quantified in the assumption.  I am still at loss  <br>\nwhat you are trying to achieve, though.</p>\n<p>Clemens</p>",
        "id": 294101425,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833902
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Clemens,</p>\n<p>probably my example was too reduced to convey my problem, so I try again <br>\nwith a (hopefully better) example.</p>\n<p>Suppose we have two locales A and B that are independent of each other:</p>\n<p>locale A =<br>\n   fixes f :: \"'a =&gt; 'b\"<br>\n   assumes ...<br>\nbegin<br>\ndefinition foo where \"foo = ... f ...\"<br>\nlemma bar: \"P foo\" sorry -- \"P is some property\"<br>\nend</p>\n<p>locale B =<br>\n   fixes g :: \"'c =&gt; 'a =&gt; 'b\"<br>\n   assumes ...</p>\n<p>Now, I want to combine both A and B in a new locale C such that A's <br>\nparameter f is instantiated with B's parameter g applied to any value.</p>\n<p>locale C = B +<br>\n   assumes A: \"A (g c)\"<br>\n   and Q: \"Q g c (<a href=\"http://A.foo\">A.foo</a> (g c))\" -- \"Q is some predicate\"<br>\nsublocale C &lt; A \"g c\" for c by(rule A)</p>\n<p>In context C, the sublocale introduces an abbreviation foo for<br>\n\"%c. <a href=\"http://A.foo\">A.foo</a> (g c)\"<br>\nand the inherited lemma bar from locale A is now<br>\n\"P (foo c)\" where c is a free variable.</p>\n<p>This is what I want to achieve. Two things are unsatisfactory here:</p>\n<ol>\n<li>\n<p>I mention a locale predicate as an assumption of a locale instead of <br>\nproperly importing it. The first step after the locale declaration is to<br>\nchange the locale graph to include this import.</p>\n</li>\n<li>\n<p>The assumption Q in locale C involves a constant defined in A. Since <br>\nI do not know how to add A to the import list, I must resort to the <br>\nglobal constant <a href=\"http://A.foo\">A.foo</a>. In my real case, A (and B) have a lot more fixed <br>\nparameters and writing all of them makes the assumptions hard to read.</p>\n</li>\n</ol>\n<p>I hope that this illustrates better what I am trying to achieve: In <br>\nlocale C, I want to use everything from locale A with f instantiated by <br>\n\"g c\", where I can use a different c each time.</p>\n<p>Is there a better way to achieve something like this?<br>\nI do not want to change locale A because I need to interpret it <br>\nelsewhere with parameters that only take one argument.</p>\n<p>No, this has nothing to do with syntax declarations for constants, but <br>\nwith the abbreviations introduced by the locales.</p>\n<p>Best regards,<br>\nAndreas</p>",
        "id": 294101524,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833927
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nAndreas,</p>\n<p>I think this is similar to what I wanted to do. (You can try reading my earlier email to this list but it is nowhere as clear as yours is.)</p>\n<p>I have a question for you and a suggestion for the locale implementors. Please excuse my top posting: your context is important.</p>\n<p>How do you expect to later instantiate 'c'?</p>\n<p>I overcame my parameterisation problem by rewriting the locale as a record (of variables that were 'fixes' in the locale) and a predicate (capturing the locale assumptions). I suggest the locale mechanism be extended to do this, in addition to whatever it now does. Concretely, imagine:</p>\n<p>locale A =<br>\n  fixes f :: \"''c =&gt; 'c\"<br>\n  fixes g :: \"'c =&gt; 'c\"<br>\n  assumes \"P f\"<br>\n  assumes \"Q g\"<br>\nbegin</p>\n<p>definition \"h = f o g\"</p>\n<p>lemma HX: \"h x = f (g x)\" ...</p>\n<p>end</p>\n<p>Could the locale mechanism produce extra definitions of the form:</p>\n<p>record 'c A_fixes =<br>\n f :: \"'c =&gt; 'c\"<br>\ng :: \"'c =&gt; 'c\"<br>\n(* captures \"fixes\" *)</p>\n<p>definition<br>\n  A_pred :: \"'c A_fixes =&gt; bool\"<br>\n(* captures the two \"assumes\" *)</p>\n<p>definition<br>\n \"A_h :: 'c A_fixes =&gt; 'c =&gt; 'c\"</p>\n<p>lemma A_HX: \"A_pred A ==&gt; h x = f (g x)\"</p>\n<p>The idea is to shift from the curried form where external definitions capture only the locale-fixed variables used in the expression to an uncurried form where the record aggregates all locale-fixed variables. I intend this to be a purely syntactic matter.</p>\n<p>This idea is essentially the same as using records to simulate type classes in Haskell, sometimes termed an evidence-passing translation. This implies it might have typing implications (viz require higher-ranked polymorphism) but I'm yet to run into any.</p>\n<p>In my case I would get the benefit of being able to state things in the locale conveniently and later uniformly abstract at the term level using the record-based external definitions.</p>\n<p>I admit I have no deep understanding of locales, so there is a good chance this proposal stumbles on some key matter.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294101812,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834001
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHello Peter,</p>\n<blockquote>\n<p>I think this is similar to what I wanted to do. (You can try reading my earlier email to this list but it is nowhere as clear as yours is.)<br>\nIt could be. Unfortunately, I don't understand fully what you are trying <br>\nto do.</p>\n</blockquote>\n<blockquote>\n<p>How do you expect to later instantiate 'c'?<br>\nThe sublocale command</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>sublocale C &lt; A \"g c\" for c by(rule A)</p>\n</blockquote>\n</blockquote>\n<p>transports all definitions and lemmas from A into C, where f is <br>\ninstantiated by \"g c\". Since c is declared in the for clause, this <br>\nbecomes a new parameter to all definitions in A.</p>\n<blockquote>\n<blockquote>\n<p>definition foo where \"foo = ... f ...\"<br>\nIm my example, the definition of foo in locale A depends on A's <br>\nparameter f. The above sublocale command now introduces a variant of foo <br>\nin locale C that takes an additional parameter c. To \"instantiate\" c <br>\nlater on, I simply pass it as a parameter to foo.</p>\n</blockquote>\n</blockquote>\n<p>Behind the scenes, the following actually happens:</p>\n<ul>\n<li>\n<p>The definition of foo in locale A defines a global constant <a href=\"http://A.foo\">A.foo</a>, <br>\nwhich takes all locale parameters that the definition depends on, <br>\nadditional to the parameters in the definition. It also produces an <br>\nabbreviation foo inside the locale A, which abbreviates \"<a href=\"http://A.foo\">A.foo</a> f\".</p>\n</li>\n<li>\n<p>The sublocale command introduces an abbreviation foo in C<br>\nwhere \"foo == %c. <a href=\"http://A.foo\">A.foo</a> (g c)\".</p>\n</li>\n</ul>\n<p>Now back to your old post: If you just want the additional parameter \"a\" <br>\nof locale A to be \"lambda-abstractable\", declare it explicitly in a for <br>\nclause:</p>\n<p>sublocale L &lt; LsubA!: A x X a for a by unfold_locales.</p>\n<p>Do not forget to give a name (like LsubA) to this import and make it an <br>\nobligatory prefix (!). Otherwise, you will not be able to open the <br>\ncontext A again. Then, in locale L, you get an abbreviation LsubA.f for <br>\nthe f from A which takes an extra parameter \"a\". Similarly, there are <br>\nthe facts LsubA.f_def, LsubA.g_def and LsubA.Q. Is this, what you wanted?</p>\n<blockquote>\n<p>I overcame my parameterisation problem by rewriting the locale as a record (of variables that were 'fixes' in the locale) and a predicate (capturing the locale assumptions). I suggest the locale mechanism be extended to do this, in addition to whatever it now does.<br>\nThe locale package already produces global definitions, but not a <br>\nrecord. There is a predicate with the same name as the locale which <br>\ncontains all the assumptions (including those from imported locales).<br>\nEvery definition and abbreviation of X in a locale L produces a global <br>\ndefinition/abbreviation L.X.<br>\nSimilarly, every fact T that is shown inside L corresponds to a global <br>\nfact L.T, which has the locale predicate L as additional premise.<br>\nSo, this is very much what you want except for currying: The locale <br>\nparameters are not collapsed into a record, but kept separately.<br>\nYou might want to have a look at those.</p>\n</blockquote>\n<p>Collapsing all parameters into a single record would make it easier to <br>\nwork with the global constants because one would have to pass only a <br>\nsingle parameter to them. However, if you have definitions in different <br>\nlocales (one of which is a sublocale of the other), you would have to do <br>\nmany record conversions from the sublocale record to the superlocale <br>\nrecord. So, a record is not a better option.</p>\n<p>Regards,<br>\nAndreas</p>",
        "id": 294101991,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834064
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nAfter some off-line discussion with Andreas Lochbihler, I would like  <br>\nto summarise the most important points.</p>\n<blockquote>\n<p>Suppose we have two locales A and B that are independent of each other:</p>\n<p>locale A =<br>\n  fixes f :: \"'a =&gt; 'b\"<br>\n  assumes ...<br>\nbegin<br>\ndefinition foo where \"foo = ... f ...\"<br>\nlemma bar: \"P foo\" sorry -- \"P is some property\"<br>\nend</p>\n<p>locale B =<br>\n  fixes g :: \"'c =&gt; 'a =&gt; 'b\"<br>\n  assumes ...</p>\n<p>Now, I want to combine both A and B in a new locale C such that A's<br>\nparameter f is instantiated with B's parameter g applied to any value.</p>\n<p>locale C = B +<br>\n  assumes A: \"A (g c)\"<br>\n  and Q: \"Q g c (<a href=\"http://A.foo\">A.foo</a> (g c))\" -- \"Q is some predicate\"<br>\nsublocale C &lt; A \"g c\" for c by(rule A)</p>\n<p>In context C, the sublocale introduces an abbreviation foo for<br>\n\"%c. <a href=\"http://A.foo\">A.foo</a> (g c)\"<br>\nand the inherited lemma bar from locale A is now<br>\n\"P (foo c)\" where c is a free variable.</p>\n<p>This is what I want to achieve. Two things are unsatisfactory here:<br>\n1. I mention a locale predicate as an assumption of a locale instead of<br>\nproperly importing it. The first step after the locale declaration is to<br>\nchange the locale graph to include this import.</p>\n</blockquote>\n<p>Locales enrich the context by syntax and theorems.  Therefore, direct  <br>\nimport of infinite families of locale instances is not possible.   <br>\nLocale predicates, on the other hand, are first-class citizens of the  <br>\nlogic and can be used to emulate this.  Those instances that are  <br>\nrequired in proofs, and for which syntax and theorems are needed, may  <br>\nbe added to either the proof context or a locale with either  <br>\n\"sublocale\" or \"interpret\" respectively.  This idea is explored in</p>\n<p>Clemens Ballarin. Interpretation of Locales in Isabelle: Theories and  <br>\nProof Contexts. In<br>\nJ.M. Borwein and W.M. Farmer, MKM 2006, LNAI 4108, pages 3143, 2006.<br>\n(<a href=\"http://www4.in.tum.de/~ballarin/publications/mkm2006.pdf\">http://www4.in.tum.de/~ballarin/publications/mkm2006.pdf</a>)</p>\n<p>in Section 5, proofs for the discussed examples are in HOL-Algebra.</p>\n<blockquote>\n<ol start=\"2\">\n<li>The assumption Q in locale C involves a constant defined in A. Since<br>\nI do not know how to add A to the import list, I must resort to the<br>\nglobal constant <a href=\"http://A.foo\">A.foo</a>. In my real case, A (and B) have a lot more fixed<br>\nparameters and writing all of them makes the assumptions hard to read.</li>\n</ol>\n</blockquote>\n<p>This is generally unavoidable since the parameters are bound in the  <br>\nassumption.  The best you can do here is introduce syntax for <a href=\"http://A.foo\">A.foo</a>  <br>\nwith the parameters that are fixed with a locale inserted into the  <br>\nhierarchy.</p>\n<p>Clemens</p>",
        "id": 294103774,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834580
    }
]