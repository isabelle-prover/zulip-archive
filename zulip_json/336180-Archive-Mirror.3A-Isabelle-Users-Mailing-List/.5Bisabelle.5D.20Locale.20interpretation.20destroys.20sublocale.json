[
    {
        "content": "<p>From: Daniel Wasserrab &lt;<a href=\"mailto:wasserra@infosun.fim.uni-passau.de\">wasserra@infosun.fim.uni-passau.de</a>&gt;<br>\nHello all,</p>\n<p>wondering about the strange behaviour of my locale theories, I came <br>\nacross the following problem:</p>\n<p>We define the following locale with an internal inductive definition:</p>\n<p>locale A =<br>\n   fixes P :: \"'a =&gt; 'b\"<br>\n   fixes Q :: \"'c =&gt; 'a =&gt; bool\"<br>\n   fixes R :: \"'c =&gt; 'b =&gt; bool\"<br>\n   assumes R_def:\"R c b = (?a. Q c a &amp; b = P a)\"</p>\n<p>begin</p>\n<p>inductive S :: \"'c =&gt; 'b =&gt; 'a list =&gt; 'b =&gt; bool\"<br>\n   for c :: \"'c\"<br>\n   where S_rule1:\"R c b ==&gt; S c b [] b\"<br>\n     | S_rule2:\"[|S c b1 as b2; Q c a; P a = b3|] ==&gt; S c b3 (a#as) b2\"</p>\n<p>end</p>\n<p>Furthermore we have a sublocale in which we want to use this internal <br>\ndefinition of S in an assumes. Thus we need the following (really <br>\nawkward) notation where we need to specify all the functions P Q R fixed <br>\nin locale A for function A.S:</p>\n<p>locale B = A +<br>\n   fixes wf :: \"'a list =&gt; bool\"<br>\n   assumes wf_def:\"A.S P Q R c b1 as b2 ==&gt; wf as\"</p>\n<p>We now define quite dumb functions:</p>\n<p>definition sn :: \"nat =&gt; nat\" where \"sn n = n\"</p>\n<p>definition ve :: \"nat =&gt; nat =&gt; bool\" where \"ve m n = True\"</p>\n<p>definition vn :: \"nat =&gt; nat =&gt; bool\" where \"vn m n = True\"</p>\n<p>locale B still looks good:</p>\n<p>print_locale B</p>\n<p>Now we interpret A with the new functions:</p>\n<p>interpretation A [\"sn\" \"ve\" \"vn\"] by(unfold_locales,simp add:sn_def <br>\nve_def vn_def)</p>\n<p>If we now try again to look at B, the following happens:</p>\n<p>print_locale B</p>\n<p>*** Duplicate definition of (co)inductive predicate \"local.P_Q_R.S\"<br>\n*** The error(s) above occurred in locale: A P Q R<br>\n*** At command \"print_locale\".</p>\n<p>Has anyone any suggestion what is happening here?</p>\n<p>Regards<br>\nDaniel</p>",
        "id": 294052661,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820214
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nHi Daniel,</p>\n<p>What happens here is that after the interpretation a global inductive  <br>\ndefinition is around.  This happens to have the same name  <br>\n(local.P_Q_R.S) as the inductive definition added to the local  <br>\ncontext when evaluating locale A during print_locale B.</p>\n<p>This is a bug, presumably due to inaccurate handling of names which  <br>\nleads to fauly set up of the theory/context data of the inductive  <br>\npackage.</p>\n<p>For now you can get around this by adding a name prefix in the  <br>\ninterpretation command:</p>\n<p>interpretation my_label: A [\"sn\" \"ve\" \"vn\"]</p>\n<p>Clemens</p>",
        "id": 294052726,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820249
    }
]