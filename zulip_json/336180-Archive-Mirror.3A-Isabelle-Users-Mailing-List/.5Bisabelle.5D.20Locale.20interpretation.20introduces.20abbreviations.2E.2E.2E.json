[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi all, </p>\n<p>I have the problem that locale interpretation introduces abbreviations<br>\nfor locally defined constants, rather than definitions. This does not<br>\nwork well with the code generator. Is there a way to make locale<br>\ninterpretation introduce real definitions, and, if not, how much effort<br>\nwould it be to implement such a feature?</p>\n<p>Example:</p>\n<p>locale l =<br>\n  fixes g::\"'a =&gt; 'b\"<br>\nbegin<br>\n  definition \"foo x == (g x,x)\"<br>\n  lemma lem: \"snd (foo x) = x\" unfolding foo_def by simp<br>\nend</p>\n<p>interpretation i: l id .<br>\nthm i.lem<br>\nexport_code <a href=\"http://i.foo\">i.foo</a><br>\n*** Not a constant: <a href=\"http://l.foo\">l.foo</a> id</p>\n<p>What I would like here is, that the interpretation command introduces a<br>\nnew constant <a href=\"http://i.foo\">i.foo</a>, with the definition (or at least code equation)<br>\n\"<a href=\"http://i.foo\">i.foo</a> x == (g x,x)\", and that this constant is also used in the<br>\ninstantiated facts.</p>\n<p>For this, the code generator could then generate code.</p>\n<p>Currently, I am defining those constants by hand, after the<br>\ninterpretation, which causes lots of boilerplate in my real applications<br>\nwith more than a dozen of definitions.</p>\n<p>-- Peter</p>",
        "id": 294165610,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854658
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nIt is better to define the constants before making the interpretation,  <br>\nbecause then interpretation can do the require replacements for you  <br>\n(as outlined in Florian's tutorial).  If your definitions don't depend  <br>\non the assumption, the approach suggested by Lukas is also appealing.   <br>\nIt exploits the interpretation on the foundational constants that is  <br>\ngenerated automatically for every locale.</p>\n<p>Interpretation can only add syntax and theorems to local theories, it  <br>\ncannot make definitions.  Which definitions should be made, even if  <br>\nyou want all, is only obvious in simple examples.  Sublocale  <br>\ndeclarations may remap constants of other involved locales, and then  <br>\nprobably for those no constants should be defined.  My design decision  <br>\nwas to leave this to the discretion of the user.</p>\n<p>This decision shouldn't prevent providing commands that solve  <br>\nimportant special cases, like exporting all constants and then  <br>\ninterpreting onto them.  This seems to be an important use case for  <br>\ncode generation.  In fact, in my terminology, this operation would  <br>\ncompute a locale instance, not an interpretation (in analogy to type  <br>\nclasses).</p>\n<p>Clemens</p>\n<p>Quoting Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;:</p>",
        "id": 294166113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854779
    }
]