[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Gene,</p>\n<p>bringing some light into these »stangenesses«…<br>\n<a href=\"/user_uploads/14278/X5asva9sudheCLe_PnVxBcnj/signature.asc\">signature.asc</a></p>",
        "id": 294650652,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165978
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nConsider the following two theories: Foo and Bar (below and attached).</p>\n<p>Theory Foo defines a locale L containing a definition \"foo\", then<br>\ninterprets that locale at the top level.</p>\n<p>Theory Bar imports Foo, extends locale L via a context block with an<br>\nadditional definition \"bar\", then attempts to construct an interpretation<br>\nnamed Foobar for locale L at the top level.  After that, it tries<br>\nto reference the constants \"<a href=\"http://Foo.foo\">Foo.foo</a>\", \"<a href=\"http://Foo.bar\">Foo.bar</a>\", \"<a href=\"http://Foobar.foo\">Foobar.foo</a>\", and \"<a href=\"http://Foobar.bar\">Foobar.bar</a>\".</p>\n<p>As expected, \"<a href=\"http://Foo.foo\">Foo.foo</a>\" is recognized, however \"<a href=\"http://Foo.bar\">Foo.bar</a>\" is not recognized.<br>\nI theorize that the interpretation declared in theory Foo is fixed at the<br>\npoint of its declaration, and does not receive any additional facts that<br>\nresult from later extensions to the locale.  That is understandable in<br>\nterms of the way locales generally seem to work, but is perhaps not so useful<br>\nfrom a modularity point of view, because it forces a theory that interprets<br>\na locale to import all possible extensions to that theory before declaring<br>\nthe interpretation, otherwise such extensions become impossible.</p>\n<p>It is also the case that neither \"<a href=\"http://Foobar.foo\">Foobar.foo</a>\" nor \"<a href=\"http://Foobar.bar\">Foobar.bar</a>\" are recognized.<br>\nThis seems to be because the system recognizes an existing interpretation<br>\nwith the same parameters (there aren't any parameters in this case, but<br>\nthe same effect occurs if there are parameters) and does not create a new<br>\ninterpretation, with the effect that the qualified names \"<a href=\"http://Foobar.foo\">Foobar.foo</a>\"<br>\nand \"<a href=\"http://Foobar.bar\">Foobar.bar</a>\" remain unbound.  This occurs even though the locale L<br>\nwas extended with an additional definition.  So the extension is pointless<br>\nbecause there is no way to get access to the additional constant.</p>\n<p>If the interpretation in theory Foo is commented out, then in theory Bar<br>\nreference to <a href=\"http://Foo.foo\">Foo.foo</a> and <a href=\"http://Foo.bar\">Foo.bar</a> fail -- this is expected.  The references<br>\nto <a href=\"http://Foobar.foo\">Foobar.foo</a> and <a href=\"http://Foobar.bar\">Foobar.bar</a> now succeed, presumably due to there being<br>\nno pre-existing interpretation.</p>\n<p>Besides the modularity issue, this example exhibits a complaint I have that<br>\nI am becoming more confident about, now that I have gotten some experience<br>\nusing locales. I can well understand why the system will not create redundant<br>\ninstantiations of a locale.  However, as the example illustrates, this<br>\nresults in the rather surprising effect that after declaring an interpretation,<br>\nqualified names that one might expect to have been introduced by that<br>\ndeclaration have in fact not been introduced.  This is not just a surprise,<br>\nit is also detrimental to readability, because one is forced to use the<br>\npreviously introduced names to refer to the existing entities, even though<br>\nit might make more sense in the current context to use different names.<br>\nMy opinion is that every locale declaration ought to introduce new bindings<br>\nfor qualified names, even if these names are aliases to existing names<br>\nentities for which other names already exist.  Note that I am not saying that<br>\nredundant entities be created, just that new aliases for these entities should<br>\nbecome bound.  This would obviously cause ambiguity in unparsing, as there<br>\nwould potentially be multiple choices of names to use, but this already occurs<br>\nin the case of abbreviations.</p>\n<p>- Gene Stark</p>\n<p>theory Foo<br>\nimports Main<br>\nbegin</p>\n<p>locale L<br>\n  begin<br>\n    definition foo where \"foo = True\"<br>\n  end</p>\n<p>(* Comment or uncomment the following to observe changes in theory Bar. *)<br>\n  interpretation L .</p>\n<p>end</p>\n<p>theory Bar<br>\nimports Main Foo<br>\nbegin</p>\n<p>context L<br>\n  begin<br>\n    definition bar where \"bar = False\"<br>\n  end</p>\n<p>interpretation Foobar: L .</p>\n<p>(* With interpretation in Foo.thy commented this fails -- expected. *)<br>\n  (* With interpretation in Foo.thy uncommented this succeeds -- expected. *)<br>\n  lemma \"<a href=\"http://Foo.foo\">Foo.foo</a> = True\" using Foo.foo_def by auto</p>\n<p>(* With interpretation in Foo.thy commented out these succeed -- expected. *)<br>\n  (* With interpretation in Foo.thy uncommented these fail -- strange. *)<br>\n  lemma \"<a href=\"http://Foobar.foo\">Foobar.foo</a> = True\" using Foobar.foo_def by auto<br>\n  lemma \"<a href=\"http://Foobar.bar\">Foobar.bar</a> = False\" using Foobar.bar_def by auto</p>\n<p>(* This fails regardless -- strange. *)<br>\n  lemma \"<a href=\"http://Foo.bar\">Foo.bar</a> = False\" using Foo.bar_def by auto</p>\n<p>end<br>\n<a href=\"/user_uploads/14278/hiF-uTk6K8v-dWvBzXFyJyC6/Foo.thy\">Foo.thy</a><br>\n<a href=\"/user_uploads/14278/S8mrbfx7zJ1nvuaNbI-f8P4c/Bar.thy\">Bar.thy</a></p>",
        "id": 294651919,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166426
    }
]