[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Joachim,</p>\n<p>The assumptions in your locales lack their names, so the example as such does not work. I <br>\nguess that locale A should have assumption \"a\" and \"B\" has \"b\".</p>\n<p>Interpretations of locales at the theory level have the disadvantage that they generate a <br>\nhuge number of theorems that both consume memory and pollute the name space. In <br>\nJinjaThreads, I had quite a number of such interpretations and they once caused memory <br>\nproblems (before David Matthews implemented a smarter GC). Nowadays, I try to avoid <br>\ninterpretations at the theory level. Instead, use two options. Either, I interpret a <br>\nlocale in an unnamed context whenever I need it. Or, I declare a wrapper locale without <br>\nparameters in which I import the locales via sublocale. In both cases, I get all the <br>\ntheorems from that locale that I want - independent of the imports.</p>\n<blockquote>\n<p>One thing that might help me to work around the limitation would be if</p>\n<p>context B begin sublocale A \"int B\" end</p>\n<p>made the theorem \"B x ==&gt; A (int x)\" (which I believe is generated<br>\nthere) available by some name (e.g. B_sublocale_of_A), and similarly for<br>\ninterpretations.<br>\nIt is unfortunate that this theorem is not generated automatically. Therefore, I normally <br>\nprove the theorem first as a lemma B_to_A (by copying the proof of the interpretation <br>\ncommand). Then, I replace the proof for the interpretation command with \"by(rule B_to_A)\".</p>\n</blockquote>\n<p>If you cannot change the interpretation itself, you can get B_to_A by stating it and <br>\nproving it with unfold_locales.</p>\n<p>Andreas</p>",
        "id": 294324658,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928146
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear List,</p>\n<p>That seems to be precisely the work-around Iâ€™m looking at.</p>\n<p>With <br>\n        theory C_Imp<br>\n        imports C<br>\n        begin</p>\n<p>locale C_True<br>\n        begin<br>\n        sublocale C True.<br>\n        end</p>\n<p>end</p>\n<p>I can change my integration theory to read</p>\n<p>theory Integration<br>\n        imports A B C C_Imp C_to_B B_to_A<br>\n        begin</p>\n<p>interpretation C_True.</p>\n<p>theorem \"0 &lt; int (if True then 2 else 1)\" by (rule a)</p>\n<p>end</p>\n<p>and everything works as I want it to.</p>\n<p>Thanks!<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/sUnNw7KacK-jVWMYtDQ5gm21/signature.asc\">signature.asc</a></p>",
        "id": 294324668,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928152
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Joachim,</p>\n<p>I recommend that you interpret of C_True in an unnamed context like this:</p>\n<p>theory Integration<br>\nimports A B C C_Imp C_to_B B_to_A<br>\nbegin</p>\n<p>context begin<br>\ninterpretation C_True.</p>\n<p>theorem \"0 &lt; int (if True then 2 else 1)\" by (rule a)<br>\nend</p>\n<p>The reason is the following:<br>\nSuppose that you or someone else adds another sublocale declaration to C later in some <br>\nunrelated theory and then imports your theory. With an interpretation at the global theory <br>\nlevel, there is no way to get the theorems from the newly imported locales, because the <br>\ninterpretation of C_True is still active. If it is done in an unnamed context, the <br>\ninterpretation vanished at the \"end\" and you can re-interpret it later again.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294324784,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928195
    }
]