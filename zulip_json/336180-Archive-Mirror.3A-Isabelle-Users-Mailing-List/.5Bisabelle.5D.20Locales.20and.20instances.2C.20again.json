[
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nMy previous question about locales arose because I was trying to address a<br>\nmore complicated question, and wanted a minimal case; apparently I<br>\novershot. Here's the more complicated one. I've defined a locale, \"affine<br>\nplane\", with three axioms. (It has to include \"affine_plane_data\", because<br>\nI need the notions of parallelism and collinearity, which are defined<br>\nthere; I confess that I don't understand the bit saying</p>\n<p>locale affine_plane =<br>\n    affine_plane_data meets<br>\n  for meets :: \"'point ⇒ 'line ⇒ bool\" +<br>\n  assumes ...</p>\n<p>and wrote it because someone helpful earlier suggested it would let me tell<br>\nISabelle that the \"meets\" functions in the two different locals were one<br>\nand the same, and would still be called \"meets.\" The three axioms are<br>\nfairly straightforward: there's a unique line through any two distinct<br>\npoints; if P does not lie on a line l, then there's a line through P that's<br>\nparallel to l; there are three noncollinear points.</p>\n<p>I then build up the real affine plane (Cartesian 2-dimensional coordinate<br>\nspace) by defining types for points and lines, and writing down the \"meets\"<br>\nfunction, which I've called \"a2meets\"; indeed, everything in this example<br>\nhas \"a2\" as a preface, indicating \"real affine 2-space\".</p>\n<p>I then state three theorems, whose proofs I've omitted by using \"sorry\" so<br>\nthat I can get to the point, which is that I want to say that the function<br>\n\"a2meets\" constitutes the data needs for an affine plane, the final<br>\ntheorem. The three little theorem match the axiom statements as closely as<br>\nI can make them. (I used cut-and-paste, and then added 'a2' in the relevant<br>\nplaces.) It seems completely obvious to me that theorem \"a2_is_plane\" is<br>\ntrue, but using \"try\" lead to no joy. Nor does</p>\n<p>using a2_ax1 a2_ax2 a2_ax3 try</p>\n<p>which I thought might guide \"try\" a little bit. Is there some way to guide<br>\nIsabelle to agree with this (obvious) conclusion? I'm going to have to show<br>\nvarious things are affine and projective planes over the next few weeks,<br>\nand I'd like to think that each proof need not require that I ask yet<br>\nanother question of this mailing list.<br>\n========</p>\n<p>theory Scratch3<br>\n  imports Complex_Main</p>\n<p>begin<br>\n  locale affine_plane_data =<br>\n    fixes meets :: \"'point ⇒ 'line ⇒ bool\"</p>\n<p>begin<br>\n    definition (in affine_plane_data) parallel:: \"'line  ⇒ 'line ⇒ bool\"<br>\n(infix \"||\" 50)<br>\n      where \"l || m ⟷ (l = m ∨ ¬ (∃ P. meets P l  ∧ meets P m))\"</p>\n<p>definition  (in affine_plane_data) collinear :: \"'point  ⇒ 'point ⇒<br>\n'point ⇒ bool\"<br>\n      where \"collinear A B C ⟷ (∃ l. meets A l ∧ meets B l ∧ meets C l)\"<br>\n  end</p>\n<p>locale affine_plane =<br>\n    affine_plane_data meets<br>\n  for meets :: \"'point ⇒ 'line ⇒ bool\" +<br>\n  assumes<br>\n    ax1: \"P ≠ Q ⟹ ∃!l. meets P l ∧ meets Q l\" and<br>\n    ax2: \"¬ meets P l ⟹ ∃!m. l || m ∧ meets P m\" and<br>\n    ax3: \"∃P Q R. P ≠ Q ∧ P ≠ R ∧ Q ≠ R ∧ ¬ collinear P Q R\"</p>\n<p>(* Now describe the real affine plane: Points are pairs (x,y); lines<br>\nare either ordinary (y = mx + b) or vertical (x = c). A point p meets<br>\na line l if p lies on l.  *)<br>\n  datatype a2pt = A2Point \"real\" \"real\"</p>\n<p>datatype a2ln = A2Ordinary \"real\" \"real\"<br>\n                | A2Vertical \"real\"</p>\n<p>fun a2meets :: \"a2pt ⇒ a2ln ⇒ bool\" where<br>\n    \"a2meets (A2Point x y) (A2Ordinary m b) = (y = m*x + b)\" |<br>\n    \"a2meets (A2Point x y) (A2Vertical xi) = (x = xi)\"</p>\n<p>definition a2parallel:: \"a2ln  ⇒ a2ln ⇒ bool\" (infix \"a2||\" 50)<br>\n      where \"l a2|| m ⟷ (l = m ∨ ¬ (∃ P. a2meets P l  ∧ a2meets P m))\"</p>\n<p>definition  a2collinear :: \"a2pt  ⇒ a2pt ⇒ a2pt ⇒ bool\"<br>\n      where \"a2collinear A B C ⟷ (∃ l. a2meets A l ∧ a2meets B l ∧ a2meets<br>\nC l)\"</p>\n<p>theorem a2_ax1 : \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"<br>\n  sorry</p>\n<p>theorem a2_ax2: \"¬ (a2meets P l) ⟹ ∃!m. l a2|| m ∧ a2meets P m\"<br>\n  sorry</p>\n<p>theorem a2_ax3:  \"∃P Q R . P ≠ Q ∧ P ≠ R ∧ Q ≠ R ∧  ¬ a2collinear P Q R\"<br>\n  sorry</p>\n<p>theorem a2_is_plane: \"affine_plane a2meets\"<br>\n  try</p>",
        "id": 294762077,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200090
    },
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nYou need to create an interpretation of affine_plane_data in order to satisfy the<br>\nproof obligations of an an interpretation of affine_plane (cf. the \"layered approach\"<br>\nreferred to somewhere that I remember reading in the tutorials on locales).</p>\n<p>Your affine_plane_data locale has no assumptions, so the interpretation can<br>\nbe made with a trivial proof (\".\", see below).  Nevertheless, you need it because<br>\n\"affine_plane_data a2meets\" is an explicit condition of all the facts in \"affine_plane\".</p>\n<p>=========================<br>\ntheory Scratch3<br>\n  imports Complex_Main</p>\n<p>begin<br>\n  locale affine_plane_data =<br>\n    fixes meets :: \"'point ⇒ 'line ⇒ bool\"</p>\n<p>begin<br>\n    definition parallel:: \"'line  ⇒ 'line ⇒ bool\"   (infix \"||\" 50)<br>\n      where \"l || m ⟷ (l = m ∨ ¬ (∃ P. meets P l  ∧ meets P m))\"</p>\n<p>definition collinear :: \"'point  ⇒ 'point ⇒ 'point ⇒ bool\"<br>\n      where \"collinear A B C ⟷ (∃ l. meets A l ∧ meets B l ∧ meets C l)\"<br>\n  end</p>\n<p>locale affine_plane =<br>\n    affine_plane_data meets<br>\n  for meets :: \"'point ⇒ 'line ⇒ bool\" +<br>\n  assumes<br>\n    ax1: \"P ≠ Q ⟹ ∃!l. meets P l ∧ meets Q l\" and<br>\n    ax2: \"¬ meets P l ⟹ ∃!m. l || m ∧ meets P m\" and<br>\n    ax3: \"∃P Q R. P ≠ Q ∧ P ≠ R ∧ Q ≠ R ∧ ¬ collinear P Q R\"</p>\n<p>(* Now describe the real affine plane: Points are pairs (x,y); lines<br>\nare either ordinary (y = mx + b) or vertical (x = c). A point p meets<br>\na line l if p lies on l.  *)<br>\n  datatype a2pt = A2Point \"real\" \"real\"</p>\n<p>datatype a2ln = A2Ordinary \"real\" \"real\"<br>\n                | A2Vertical \"real\"</p>\n<p>fun a2meets :: \"a2pt ⇒ a2ln ⇒ bool\" where<br>\n    \"a2meets (A2Point x y) (A2Ordinary m b) = (y = m*x + b)\" |<br>\n    \"a2meets (A2Point x y) (A2Vertical xi) = (x = xi)\"</p>\n<p>definition a2parallel:: \"a2ln  ⇒ a2ln ⇒ bool\" (infix \"a2||\" 50)<br>\n      where \"l a2|| m ⟷ (l = m ∨ ¬ (∃ P. a2meets P l  ∧ a2meets P m))\"</p>\n<p>definition  a2collinear :: \"a2pt  ⇒ a2pt ⇒ a2pt ⇒ bool\"<br>\n      where \"a2collinear A B C ⟷ (∃ l. a2meets A l ∧ a2meets B l ∧ a2meets<br>\nC l)\"</p>\n<p>theorem a2_ax1 : \"P ≠ Q ⟹ ∃! l . a2meets P l ∧ a2meets Q l\"<br>\n    sorry</p>\n<p>theorem a2_ax2: \"¬ (a2meets P l) ⟹ ∃!m. l a2|| m ∧ a2meets P m\"<br>\n    sorry</p>\n<p>theorem a2_ax3:  \"∃P Q R . P ≠ Q ∧ P ≠ R ∧ Q ≠ R ∧  ¬ a2collinear P Q R\"<br>\n    sorry</p>\n<p>theorem a2_is_plane: \"affine_plane a2meets\"<br>\n  proof<br>\n    interpret affine_plane_data a2meets .<br>\n    show \"⋀P Q. P ≠ Q ⟹ ∃!l. a2meets P l ∧ a2meets Q l\"<br>\n      using a2_ax1 by simp<br>\n    show \"⋀P l. ¬ a2meets P l ⟹ ∃!m. parallel l m ∧ a2meets P m\"<br>\n      using a2_ax2<br>\n      by (simp add: a2parallel_def parallel_def)<br>\n    show \"∃P Q R. P ≠ Q ∧ P ≠ R ∧ Q ≠ R ∧ ¬ collinear P Q R\"<br>\n      using a2_ax3<br>\n      by (simp add: a2collinear_def collinear_def)<br>\n  qed</p>\n<p>end</p>",
        "id": 294762085,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200094
    }
]