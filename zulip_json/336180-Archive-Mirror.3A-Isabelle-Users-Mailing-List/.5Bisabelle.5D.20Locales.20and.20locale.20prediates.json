[
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nI'm still trying to understand locales. Following<br>\n<a href=\"https://isabelle.in.tum.de/doc/locales.pdf\">https://isabelle.in.tum.de/doc/locales.pdf</a>, I defined the \"partial order\"<br>\nlocale describe there, and followed step by step through the example; the<br>\nresults I got had slightly different formatting in some cases, but were<br>\notherwise reasonable.</p>\n<p>I thought I could test it out on my own locales, which involve affine<br>\nplanes. (I'm eager to show that the Euclidean plane is an affine plane). To<br>\ndo a minimal test, I wrote this:</p>\n<p>theory Scratch2<br>\n  imports Main<br>\nbegin</p>\n<p>locale aff =<br>\n  fixes meets :: \"'p ⇒ 'p ⇒ bool\"<br>\n(*  assumes refl: \"meets a a = True\" *)</p>\n<p>print_locale! aff<br>\nthm aff_def</p>\n<p>fun meets2 :: \"nat ⇒ nat ⇒ bool\" where<br>\n    \"meets2 a b = (a = b)\"</p>\n<p>theorem \"aff meets2\"<br>\n  try</p>\n<p>The actual \"meets\" procedures I'll be using have the form 'a -&gt; 'b -&gt; bool,<br>\nbut I thought I'd simplify for early testing. Right after the commented-out<br>\nline, Isabelle reports that the locale \"aff\" has been defined, and I can<br>\nprint it just fine. But at \"thm aff_def\", it turns out that \"aff_def\" is<br>\nundefined. If I uncomment the \"assumes refl\" line, then it actually IS<br>\ndefined. And the theorem at the bottom -- that \"meets2\" has all the<br>\nproperties required to be an \"aff\", is easy to prove with \"simp\".</p>\n<p>But leaving that line commented out, there are two oddities, The first is<br>\nthat aff_def is undefined, as I mentioned. Then second is that when I let<br>\n\"try\" attempt to prove the theorem at the bottom, which I believe to be<br>\ntrue, Nitpick finds a counterexample. I'm assuming (since there's something<br>\nabout \"free variable: aff =\" in those results that the predicate \"aff\" has<br>\nsomehow not been recognized or defined, but frankly, I'm baffled. Can<br>\nanyone clear up my confusion?</p>",
        "id": 294761994,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200064
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear John,</p>\n<p>If a locale makes no assumptions, i.e., it only fixes parameters, there's nothing to be <br>\nshown. Accordingly, the locale command does not define a locale predicate for such <br>\nlocales. That's why aff_def does not exist. When you look at your theorem, you'll see that <br>\naff is a free variable of the theorem, not a constant.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294761998,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200069
    },
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nI admit that I may have overgeneralized, thinking that the example in<br>\nBallarin's tutorial was a model showing what happened during a generic<br>\nlocale-definition, rather than during <em>this specific</em> locale-definition.</p>\n<p>I find the choice not to include aff_def a baffling bit of software<br>\nengineering (why not <em>always</em> introduce the predicate, and sometimes have<br>\nit be a predicate that's always true? If you don't, then every proof you do<br>\nabout locales has to have two cases, etc. I probably just don't understand<br>\nsomething deeper that's going on.)</p>\n<p>Also, to match the definition of \"aff\", there needs to be an actual<br>\nfunction of the correct type -- the predicate <em>shouldn't</em> be completely<br>\nvacuous, and indeed, the type-def inherent in the argument to \"add_def\" (in<br>\nthe case where we do have assumptions) ensures this, so it's actually doing<br>\nsomething useful. It's a pity (to me) that it's not there unless there are<br>\nassumptions.</p>",
        "id": 294762010,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200078
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@it.uu.se\">tjark.weber@it.uu.se</a>&gt;<br>\nJohn,</p>\n<p>Note that there is a dedicated command \"interpretation\" to interpret a<br>\nlocale in a theory, described in Section 5 of Ballarin's tutorial.</p>\n<p>Thus, you probably don't want/need to refer to aff_def directly even<br>\nwhen it exists, and instead of</p>\n<p>theorem \"aff meets2\"<br>\n  &lt;proof&gt;</p>\n<p>you likely want to use</p>\n<p>interpretation foo: aff meets2<br>\n  &lt;proof&gt;</p>\n<p>This automatically generates the right proof obligations, and works<br>\nregardless of whether aff actually makes any assumptions.</p>\n<p>Best,<br>\nTjark</p>\n<p>När du har kontakt med oss på Uppsala universitet med e-post så innebär det att vi behandlar dina personuppgifter. För att läsa mer om hur vi gör det kan du läsa här: <a href=\"http://www.uu.se/om-uu/dataskydd-personuppgifter/\">http://www.uu.se/om-uu/dataskydd-personuppgifter/</a></p>\n<p>E-mailing Uppsala University means that we will process your personal data. For more information on how this is performed, please read here: <a href=\"http://www.uu.se/en/about-uu/data-protection-policy\">http://www.uu.se/en/about-uu/data-protection-policy</a></p>",
        "id": 294762026,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200082
    }
]