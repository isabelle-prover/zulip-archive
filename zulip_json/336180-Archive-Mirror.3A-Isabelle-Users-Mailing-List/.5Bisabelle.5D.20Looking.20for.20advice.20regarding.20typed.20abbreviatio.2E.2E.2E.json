[
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nDear Isabelle Gurus,</p>\n<p>I'm trying to put together a representation of C structures using <br>\nrecords, coupled with a memory model that involves pointers. There is an <br>\noperation I'm trying to express elegantly, however, that is giving me <br>\nquite a bit of trouble: dereference-and-get-address-of-field.</p>\n<p>For example take these two C structures:<br>\nstruct A {<br>\n   char z;<br>\n};<br>\nstruct B {<br>\n   int x;<br>\n   struct A y;<br>\n};<br>\nThese have correspondingly obvious isabelle record representations (with <br>\nnames prefixed to prevent collisions).</p>\n<p>If we have some variable \"sa\" holding a pointer to a struct A in memory, <br>\nthen the dereference-and-get-address-of-field operator (denoted &amp;-&gt;) <br>\nshould look something like this: sa&amp;-&gt;''x''<br>\nrepresenting the C code: &amp;(sa-&gt;x)<br>\nThis will add the structure offset of field \"x\" to the address contained <br>\nin the pointer \"sa\" and retype it as a pointer to an int.</p>\n<p>Doing the one-step case, as with \"x\" is possible using overloaded <br>\nfunctions with a manual constraint on the return type, but what I really <br>\nwant is chaining, for example:<br>\n   sa&amp;-&gt;y&amp;-&gt;z should give a char pointer of z within struct A within <br>\nstruct B.</p>\n<p>This is where I'm completely stuck. In my case, a \"pointer\" is just an <br>\naddress with a phantom type variable representing the type of value it <br>\npoints to. I have a function per record that given a string name of the <br>\nfield, gives its offset within the corresponding structure. I have a <br>\nfunction that given a variable pointing to a structure of some type, <br>\nreturns the relevant lookup function. The problem is the return value, <br>\nsince it's type varies based on which field name one requests.</p>\n<p>I am aware that this is probably not the neatest way to go about it. <br>\nHowever, I really want to have a nice-looking textual representation for <br>\nthe user, and ugly details under the carpet if necessary to make that <br>\npossible.</p>\n<p>The generic problem boils down to (simplified pseudo-Isabelle):</p>\n<p>consts (overloaded)<br>\n   get_lookup_table_for :: \"'a itself =&gt; string =&gt; 'b\"<br>\nconsts (overloaded)<br>\n   -- \"lookup table for structure A\"<br>\n   lookup_A :: \"'a ptr =&gt; string =&gt; 'b ptr\"<br>\n   -- \"lookup table for structure B\"<br>\n   lookup_B :: \"'a ptr =&gt; string =&gt; 'b ptr\"<br>\nthen define:<br>\n   \"get_lookup_table_for TYPE(A) = lookup_A\"<br>\n   \"get_lookup_table_for TYPE(B) = lookup_B\"<br>\n   \"lookup_A p ''y'' = (ptr_add p 4)::(B ptr)\"<br>\n   \"lookup_B p ''z'' = (ptr_add p 0)::(char ptr)\"</p>\n<p>to finally get a function:<br>\n   \"lookup p name = get_lookup_table_for (TYPE(p)) p name\"<br>\nwhich can be chained like so:<br>\n   lookup (lookup sa ''y'') ''z''<br>\nand that should give something, which will either have the type \"char <br>\nptr\" inferred, or, if constrained to type \"char ptr\" can still be <br>\nreasoned about.</p>\n<p>I wish to avoid having to constrain the type returned by almost every <br>\nsingle structure field lookup when annotating code.</p>\n<p>As such, I welcome <em>any</em> method which will work, no matter how clunky. <br>\nIf it involves ML hackery, no problem.</p>\n<p>Would any of you have some kind of recommendation for me? I saw some <br>\nposts a while back about doing syntax translations pre and post type <br>\nchecking, but I'm unsure how to apply them to this situation seeing as I <br>\nneed the type of \"sa\" to be able to infer the type of the lookup result.</p>\n<p>Sincerely hopeful,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294119353,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839306
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Rafael,</p>\n<blockquote>\n<p>struct A {<br>\n  char z;<br>\n};<br>\nstruct B {<br>\n  int x;<br>\n  struct A y;<br>\n};</p>\n<p>[...]</p>\n<p>The generic problem boils down to (simplified pseudo-Isabelle):</p>\n<p>consts (overloaded)<br>\n  get_lookup_table_for :: \"'a itself =&gt; string =&gt; 'b\"<br>\nconsts (overloaded)<br>\n  -- \"lookup table for structure A\"<br>\n  lookup_A :: \"'a ptr =&gt; string =&gt; 'b ptr\"<br>\n  -- \"lookup table for structure B\"<br>\n  lookup_B :: \"'a ptr =&gt; string =&gt; 'b ptr\"<br>\nthen define:<br>\n  \"get_lookup_table_for TYPE(A) = lookup_A\"<br>\n  \"get_lookup_table_for TYPE(B) = lookup_B\"<br>\n  \"lookup_A p ''y'' = (ptr_add p 4)::(B ptr)\"<br>\n  \"lookup_B p ''z'' = (ptr_add p 0)::(char ptr)\"</p>\n<p>to finally get a function:<br>\n  \"lookup p name = get_lookup_table_for (TYPE(p)) p name\"<br>\nwhich can be chained like so:<br>\n  lookup (lookup sa ''y'') ''z''<br>\nand that should give something, which will either have the type \"char <br>\nptr\" inferred, or, if constrained to type \"char ptr\" can still be <br>\nreasoned about.</p>\n<p>Would any of you have some kind of recommendation for me? I saw some <br>\nposts a while back about doing syntax translations pre and post type <br>\nchecking, but I'm unsure how to apply them to this situation seeing as I <br>\nneed the type of \"sa\" to be able to infer the type of the lookup result.<br>\nI think syntax translations during type checking might solve your problem. <br>\nHowever, I feel that you need a more general framework than the one by Christian <br>\nSternagel. In his approach, the overloaded constant is replaced during type <br>\nchecking with another constant whose type is more specific. AFAIK this approach <br>\nworks as follows when it encounters an overloaded constant c during parsing:</p>\n</blockquote>\n<p>1st) Determine the type constraints on c (from surrounding applications/type <br>\nannotations etc.)<br>\n2nd) Check whether these constraints unify with one of the registered <br>\ntranslations. If so, replace c appropriately.<br>\n3rd) After type checking, raise an error if c still occurs literally in the term.</p>\n<p>Your problem looks a bit more difficult because the return type of the <br>\noverloaded lookup constant not only depends on the arguments' types, but also on <br>\nthe value. For exmple, suppose that the type of sa is known as<br>\n\"B ptr\". What should be the type of \"lookup sa x\" in<br>\n\"x = ''y'' | x = ''z'' --&gt; lookup sa x = ...\"?</p>\n<p>However, if you only need to succeed in type checking lookup terms when the <br>\nsecond argument is given as a literal string, a similar approach might work.<br>\nInstead of looking at the type constraints, you would have to match for term <br>\npattern</p>\n<p>Const (\"lookup\", _) $<br>\n(_, &lt;ML representation of \"B ptr\"&gt;) $<br>\n(Const (\"Cons\", _) $<br>\n   (Const (\"String.char.Char\", _) $ ... ))</p>\n<p>and replace this with a specialized constant<br>\nlookup_B_y defined as</p>\n<p>lookup_B_y p = (ptr_add p 4)::(A ptr)\"</p>\n<p>If this solves your problem, there might be an even simpler solution: Make the <br>\nfield name parameter part of the lookup function name. Every struct declaration <br>\ngets translated to a list of dereference functions. In your example:</p>\n<p>definition lookup_A_z :: \"A ptr =&gt; char ptr\" (\"_&amp;-&gt;''''z''''\")<br>\nwhere \"lookup_A_z p == ptr_add p 0\"</p>\n<p>definition lookup_B_x :: \"B ptr =&gt; int ptr\" (\"_&amp;-&gt;''''x''''\")<br>\nwhere \"lookup_B_x p == ptr_add p 0\"</p>\n<p>definition lookup_B_y :: \"B ptr =&gt; A ptr\" (\"_&amp;-&gt;''''y''''\")<br>\nwhere \"lookup_B_y p == ptr_add p 4\"</p>\n<p>Then, \"(p&amp;-&gt;''y'')&amp;-&gt;''z''\" should type check and have type \"char ptr\", although <br>\nI have not tested this yet.<br>\nNote that if you have multiple structs with the same field name, say</p>\n<p>struct C { char x; }</p>\n<p>you will get another definition</p>\n<p>definition lookup_C_x :: \"C ptr =&gt; char ptr\" (\"_&amp;-&gt;''''x''''\")<br>\nwhere \"lookup_C_x == ptr_add p 0\"</p>\n<p>Now, \"p&amp;-&gt;''x''\" will produce two parse trees, but in most cases, only one will <br>\nbe type correct.  If this happens multiple times, parsing becomes increadibly <br>\nslow because the number of parse trees grows exponentially. In that case, you <br>\ncan have an overloaded constant for every field name and use Christian <br>\nSternagel's solution. You only need to register translations for \"_&amp;-&gt;''x''\" and <br>\n\"_&amp;-&gt;''y''\" etc.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294119374,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839312
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Rafal,</p>\n<p>The approach is the same as the adhoc overloading facility by Christian <br>\nSternagel (in the current development version in <br>\n~~/src/Tools/Adhoc_Overloading). This mechanism adds the translation via <br>\nSyntax.add_term_check to the type checking phase of terms (and similarly the <br>\ninverse translation to the printing phase). For more information on this, see <br>\nthe thread on the mailing list starting with this post:<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-May/msg00055.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-May/msg00055.html</a></p>\n<p>At this very point in the type checking phase, you'd have to replace the generic <br>\nconstant \"lookup\" with specialized versions like \"lookup_B_y\". To determine the <br>\nright specialized version, you will need the type of the first parameter and the <br>\nvalue of the second parameter of lookup. Determining the value of the second <br>\nparameter could be done with pattern matching. I don't know exactly what the <br>\nsyntax tree looks like at this stage, but you should be able to find that out.</p>\n<p>Sincerely,<br>\nAndreas</p>",
        "id": 294119384,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839318
    }
]