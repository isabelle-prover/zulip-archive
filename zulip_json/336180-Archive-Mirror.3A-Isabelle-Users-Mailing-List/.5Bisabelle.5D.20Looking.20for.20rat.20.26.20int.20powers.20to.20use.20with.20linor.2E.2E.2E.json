[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>What I did is create a function based on integers. I then decided to <br>\ngeneralize it using linordered_idom, which is the type class linear <br>\nordered integral domain.</p>\n<p>A general question is, if you want to look at my theory, is there <br>\nsomething I should be doing to do things better? I guess I got some of <br>\nthe basics right.</p>\n<p>My three basic questions are:</p>\n<p>1) Is there an integer powers operator?</p>\n<p>2) Is there a rat::('a =&gt; rat) function, like there's a real::('a =&gt; <br>\nreal) function. I didn't find one, so I had to add a few commands to get <br>\none.</p>\n<p>3) The \"value\" for my function is a complicated expression. Is there an <br>\neasy way to get \"value\" to simplify it, like when I use \"simp\" with <br>\n\"theorem\".</p>\n<p>I attach a simplified theory with comments, and I include the text in <br>\nthis email, where I repeat the questions I just asked.</p>\n<p>Thanks,<br>\nGB</p>\n<p>(*Questions:<br>\n1) Is there an integer powers operator I can use to get rid of my <br>\nif/then in the<br>\nfunction oZCq, which I use after comment __2__.<br>\n2) Is there a rat function of type ('a =&gt; rat), as I talk about in comments<br>\n4, 5, and 6. As I talk about, I used the function real::('a =&gt; real) as an<br>\nexample on how to define my rat below.<br>\n3) Is there something easy I can do to get the value method to return a <br>\nsimplified<br>\nanswer when I use my oICq function, as it is used after comment __8__.<br>\n4) Is there something I should be doing here that would make it better?<br>\n*)</p>\n<p>(*__1__) I start with a non-generalized datatype based on (int * int).*)</p>\n<p>datatype oZ =<br>\noZf \"int * int\"<br>\n|oZF \"oZ list\"</p>\n<p>(*__2__) I compute a recursive list or pairs of int. I found no HOL <br>\noperator<br>\nto do integer powers, so I use an if/then statement.*)</p>\n<p>fun oZCq :: \"oZ =&gt; rat\" where<br>\n\"oZCq (oZf p) = (if (snd p) &lt; 0<br>\nthen 1/of_int(fst p ^ nat(- snd p))<br>\nelse of_int(fst p ^ nat(snd p)))\"<br>\n|\"oZCq (oZF[]) = 1\"<br>\n|\"oZCq (oZF(x#xs)) = oZCq x * oZCq (oZF xs)\"</p>\n<p>value \"oZCq(oZF[oZf(2,-2),oZf(2,3)])\" (* 2 *)<br>\nvalue \"oZCq(oZF[oZf(2,-3),oZf(2,2)])\" (* 1/2 *)</p>\n<p>(*__3__) Instead of using integers, I want to use type class <br>\nlinordered_idom,<br>\nwhich is a linear ordered integral domain. The problem is that I found no<br>\nfunction ('a =&gt; rat). There is, however, the function real::('a =&gt; real). I<br>\nuse that as an example to make me an overloaded rat::('a =&gt; rat), and I <br>\ndefine<br>\nrat::(int =&gt; rat). The following shows what I found from Rat.thy and <br>\nReal.thy<br>\nto know how to create my rat function.*)</p>\n<p>(*__4__) From Real.thy: Here is source showing what's done for the ('a <br>\n=&gt; real)<br>\nconversion, and for the real::(int =&gt; real) definition. It is taken from<br>\nlines 1021-1042.<br>\nconsts<br>\n(<em>overloaded constant for injecting other types into \"real\"</em>)<br>\nreal :: \"'a =&gt; real\"<br>\nabbreviation<br>\nreal_of_int :: \"int ⇒ real\" where \"real_of_int == of_int\"<br>\ndefs (overloaded)<br>\nreal_of_int_def [code_unfold]: \"real == real_of_int\"<br>\ndeclare [[coercion_enabled]]<br>\ndeclare [[coercion \"real::int⇒real\"]] *)</p>\n<p>(*__5__) In Rat.thy, I found nothing implemented for ('a =&gt; rat) <br>\nconversion, but<br>\nit shows that rat_of_int::(int =&gt; rat) has already been defined.<br>\n0758:<br>\nabbreviation rat_of_int :: \"int =&gt; rat\" where<br>\n\"rat_of_int == of_int\"<br>\n0898:<br>\ndefinition of_int :: \"int =&gt; rat\" where<br>\n[code_abbrev]: \"of_int = Int.of_int\" *)</p>\n<p>(*__6__) I decide that maybe I only need to add the following two <br>\ncommands.*)</p>\n<p>consts rat :: \"'a =&gt; rat\"</p>\n<p>defs (overloaded)<br>\nrat_of_int_def [simp,code_unfold]: \"rat == rat_of_int\"</p>\n<p>(*__7__) I make a new datatype, \"'a oI\", and it seems I can now <br>\ngeneralize my<br>\ncomputation function to be of type ('a::linordered_idom oI =&gt; rat).*)</p>\n<p>datatype 'a oI =<br>\noIf \"'a * int\"<br>\n|oIF \"'a oI list\"</p>\n<p>fun oICq :: \"'a::linordered_idom oI =&gt; rat\" where<br>\n\"oICq (oIf p) = (if (snd p) &lt; 0<br>\nthen 1/rat(fst p ^ nat(- snd p))<br>\nelse rat(fst p ^ nat(snd p)))\"<br>\n|\"oICq (oIF[]) = 1\"<br>\n|\"oICq (oIF (x#xs)) = oICq x * oICq (oIF xs)\"</p>\n<p>(*__8__) I try out a few examples, some using int, to find out whether <br>\nwhat I've<br>\ndone is a total loser. It's hard to tell. The return values are partially<br>\nsimplified, but they are still complicated expressions.*)</p>\n<p>value \"rat(1::int)\"<br>\nvalue \"rat(1::'a::linordered_idom)\"</p>\n<p>value \"oICq(oIF[oIf(2,-2),oIf(2,3)])\" (* SB 2 *)<br>\nvalue \"oICq(oIF[oIf(2,-3),oIf(2,2)])\" (* SB 1/2 *)</p>\n<p>value \"oICq(oIF[oIf(2::int,-2),oIf(2,3)])\" (* SB 2 rat *)<br>\nvalue \"oICq(oIF[oIf(2::int,-3),oIf(2,2)])\" (* SB 1/2 rat *)</p>\n<p>(*__9__) As I said, the output of value when I use oICq is a big <br>\ncomplicated<br>\nexpression, so I resort to using simp to look at the computations.*)</p>\n<p>theorem \"oICq(oIF[oIf(2,-2),oIf(2,3)])=z\" (* (rat(8::'a))/(rat (4::'a)) <br>\n= z *)<br>\napply(simp) oops<br>\ntheorem \"oICq(oIF[oIf(2,2),oIf(2,-3)])=z\" (* (rat(8::'a))/(rat (4::'a)) <br>\n= z *)<br>\napply(simp) oops</p>\n<p>theorem \"oICq(oIF[oIf(2::int,-2),oIf(2,3)]) = z\" (* z = (2::rat) *)<br>\napply(simp) oops<br>\ntheorem \"oICq(oIF[oIf(2::int,-3),oIf(2,2)]) = z\" (* (z * (2::rat)) = <br>\n(1::rat) *)<br>\napply(simp) oops</p>\n<p>theorem \"oICq(oIF[oIf(2::int,-2),oIf(2,3)]) = 2\"<br>\nby(simp)<br>\n<a href=\"/user_uploads/14278/qXYR1ideON6B8QpZwC6OxmH0/i131031a__v3_simple_fun_linordered_idom_to_rat.thy\">i131031a__v3_simple_fun_linordered_idom_to_rat.thy</a></p>",
        "id": 294258468,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913465
    }
]