[
    {
        "content": "<p>From: Janik Benzin &lt;<a href=\"mailto:janik.benzin@rwth-aachen.de\">janik.benzin@rwth-aachen.de</a>&gt;<br>\nHi all,</p>\n<p>I would like to learn a bit more about the ML basis of Isabelle.<br>\nRecently, I have tried to catch and handle the user exception \"ERROR of<br>\nstring\" defined in exn.ML in the following example:</p>\n<p>ML {*<br>\n       type isar_record =  {context: Proof.context, facts: thm list, goal:<br>\nthm}</p>\n<p>fun goal_display ctxt (isar_goal:isar_record) =<br>\n            Pretty.writeln(Goal_Display.pretty_goal ctxt (#goal(isar_goal)))<br>\n       handle Exn.ERROR _    =&gt;   ();<br>\n*}</p>\n<p>Now I would like to insert the function using ML_val and antiquotations<br>\nanywhere in a theory file, i.e. inside and outside of proofs:</p>\n<p>ML_val {*<br>\n               goal_display @{context} @{Isar.goal}<br>\n             *}</p>\n<p>However, the exception ERROR \"No proof state\" is printed as an error<br>\nmessage in Isabelle, although I’ve installed the corresponding error<br>\nhandler. Am I doing something wrong here?</p>\n<p>Thank you for your time and help!</p>\n<p>Best regards,<br>\nJanik Benzin</p>",
        "id": 294746829,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661193826
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 08/11/2018 20:25, Janik Benzin wrote:</p>\n<blockquote>\n<p>I would like to learn a bit more about the ML basis of Isabelle.<br>\nRecently, I have tried to catch and handle the user exception \"ERROR of<br>\nstring\" defined in exn.ML in the following example:</p>\n</blockquote>\n<p>The \"implementation\" manual contains a lot of explanations about<br>\nIsabelle/ML in chapter 0. Section 0.5 is about exceptions in particular:<br>\nthese clear guidelines help to work with various kinds of errors robustly.</p>\n<blockquote>\n<p>ML {*<br>\n       type isar_record =  {context: Proof.context, facts: thm list, goal:<br>\nthm}</p>\n<p>fun goal_display ctxt (isar_goal:isar_record) =<br>\n            Pretty.writeln(Goal_Display.pretty_goal ctxt (#goal(isar_goal)))<br>\n       handle Exn.ERROR _    =&gt;   ();<br>\n*}</p>\n</blockquote>\n<p>BTW, when you find yourself defining record-type aliases such as<br>\nisar_record above there is something wrong with your function<br>\nsignatures. In the Isabelle/Pure implementation, types are defined in a<br>\nmanner to minimize redundant type constraints: ML is essentially<br>\nimplicitly typed LISP, and the Isabelle/ML IDE tells you what the<br>\ninferred types are -- you rarely write anything in the source.</p>\n<p>So here is the example written in a more standard way:</p>\n<p>ML ‹<br>\n  fun goal_display ctxt goal =<br>\n    Pretty.writeln (Goal_Display.pretty_goal ctxt goal)<br>\n    handle ERROR _ =&gt; ();<br>\n›</p>\n<p>ML_val ‹goal_display (#goal @{Isar.goal})›</p>\n<blockquote>\n<p>ML_val {*<br>\n               goal_display @{context} @{Isar.goal}<br>\n             *}</p>\n<p>However, the exception ERROR \"No proof state\" is printed as an error<br>\nmessage in Isabelle, although I’ve installed the corresponding error<br>\nhandler. Am I doing something wrong here?</p>\n</blockquote>\n<p>The error is produced statically by the @{Isar.goal} antiquotation,<br>\nbecause the context of the ML_val command lacks a goal state.</p>\n<p>Such confusions about the origin of exceptions belong to the nature of<br>\nexceptions: it requires care to write programs correctly in that respect<br>\n(section 0.5 of the \"implementation\" manual and the body of<br>\nIsabelle/Pure ML sources should provide some idea how to do it).</p>\n<p>Makarius</p>",
        "id": 294746909,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661193853
    }
]