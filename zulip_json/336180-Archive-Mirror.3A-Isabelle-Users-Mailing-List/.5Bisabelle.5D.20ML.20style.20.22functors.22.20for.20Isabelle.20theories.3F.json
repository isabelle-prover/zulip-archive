[
    {
        "content": "<p>From: \"Dr. Brendan Patrick Mahony\" &lt;<a href=\"mailto:mahonybp@tpg.com.au\">mahonybp@tpg.com.au</a>&gt;<br>\nIsabelle’s mathematical structuring facilities, classes and locales, have well known scopes that preclude some otherwise attractive modelling approaches.</p>\n<p>For example, the AFP has three approaches to category theory that model a category’s carrier classes of objects and arrows as types.</p>\n<p><a href=\"https://www.isa-afp.org/browser_info/current/AFP/Category/document.pdf\">https://www.isa-afp.org/browser_info/current/AFP/Category/document.pdf</a> &lt;<a href=\"https://www.isa-afp.org/browser_info/current/AFP/Category/document.pdf\">https://www.isa-afp.org/browser_info/current/AFP/Category/document.pdf</a>&gt;<br>\n<a href=\"https://www.isa-afp.org/entries/Category2.html\">https://www.isa-afp.org/entries/Category2.html</a> &lt;<a href=\"https://www.isa-afp.org/entries/Category2.html\">https://www.isa-afp.org/entries/Category2.html</a>&gt;<br>\n<a href=\"https://www.isa-afp.org/entries/Category3.html\">https://www.isa-afp.org/entries/Category3.html</a> </p>\n<p>Besides the pure mathematical constraints this places of the classes of category instances (much of which is I guess inherent to the use of HOL), this also brings a degree of applied mathematical pain in that it would frequently be convenient in a practical reasoning sense to model objects and arrows as classes of types, so as to make use of a type overloaded arrow composition operator and enjoy all the reasoning safety benefits of HOL strong typing. </p>\n<p>This can of course be done for any desired category, some examples </p>\n<p>Set:</p>\n<p>class cat_obj = small</p>\n<p>typedef<br>\n  ('a, 'b) cat_arrow = \"{ f :: ('a::cat_obj) ⇒ ('b::cat_obj). True}\"<br>\n  by (auto)</p>\n<p>definition<br>\n  cat_compose :: \"('a::cat_obj, 'b::cat_obj) cat_arrow ⇒ ('b, 'c::cat_obj) cat_arrow ⇒ ('a, 'c) cat_arrow\"<br>\n  where<br>\n    \"cat_compose f g = Abs_cat_arrow ((Rep_cat_arrow g) ∘ (Rep_cat_arrow f))\"</p>\n<p>definition<br>\n  cat_id :: \"('a::cat_obj, 'a) cat_arrow\"<br>\n  where<br>\n    \"cat_id = Abs_cat_arrow id\"</p>\n<p>lemma cat_left_id: <br>\n  \"cat_compose cat_id a = a\" <br>\n  by (auto simp add: cat_compose_def cat_id_def Abs_cat_arrow_inverse Rep_cat_arrow_inverse)</p>\n<p>lemma cat_right_id: <br>\n  \"cat_compose a cat_id = a\"  <br>\n  by (auto simp add: cat_compose_def cat_id_def Abs_cat_arrow_inverse Rep_cat_arrow_inverse)</p>\n<p>lemma cat_comp_assoc: <br>\n  \"cat_compose (cat_compose a b) c = cat_compose a (cat_compose b c)\"<br>\n  by (auto simp add: cat_compose_def cat_id_def Abs_cat_arrow_inverse Rep_cat_arrow_inverse comp_assoc)</p>\n<p>Grp:</p>\n<p>class cat_obj = group_add</p>\n<p>typedef (overloaded)<br>\n  ('a, 'b) cat_arrow = \"{ f :: ('a::cat_obj) ⇒ ('b::cat_obj). (∀ a b. f (a + b) = f a + f b) }\"<br>\n  apply (rule_tac x = \"(λ a. 0)\" in exI)<br>\n  apply (auto)<br>\n  done</p>\n<p>definition<br>\n  cat_compose :: \"('a::cat_obj, 'b::cat_obj) cat_arrow ⇒ ('b, 'c::cat_obj) cat_arrow ⇒ ('a, 'c) cat_arrow\"<br>\n  where<br>\n    \"cat_compose f g = Abs_cat_arrow ((Rep_cat_arrow g) ∘ (Rep_cat_arrow f))\"</p>\n<p>lemma cat_compose_wf:<br>\n  assumes<br>\n    a1: \"f ∈ { f :: ('b::cat_obj) ⇒ ('c::cat_obj). (∀ a b. f (a + b) = f a + f b) }\" and<br>\n    a2: \"g ∈ { f :: ('a::cat_obj) ⇒ ('b::cat_obj). (∀ a b. f (a + b) = f a + f b) }\"<br>\n  shows<br>\n    \"f ∘ g ∈ { f :: ('a::cat_obj) ⇒ ('c::cat_obj). (∀ a b. f (a + b) = f a + f b) }\"<br>\n  using assms<br>\n  by (auto)</p>\n<p>definition<br>\n  cat_id :: \"('a::cat_obj, 'a) cat_arrow\"<br>\n  where<br>\n    \"cat_id = Abs_cat_arrow id\"</p>\n<p>lemma cat_left_id: <br>\n  \"cat_compose cat_id a = a\" <br>\n  by (auto simp add: cat_compose_def cat_id_def Abs_cat_arrow_inverse Rep_cat_arrow_inverse)</p>\n<p>lemma cat_right_id: <br>\n  \"cat_compose a cat_id = a\"  <br>\n  by (auto simp add: cat_compose_def cat_id_def Abs_cat_arrow_inverse Rep_cat_arrow_inverse)</p>\n<p>lemma cat_comp_assoc: <br>\n  \"cat_compose (cat_compose a b) c = cat_compose a (cat_compose b c)\"<br>\n  by (auto simp add: cat_compose_def cat_id_def Rep_cat_arrow_inverse comp_assoc <br>\n                     Abs_cat_arrow_inverse [OF cat_compose_wf [OF Rep_cat_arrow Rep_cat_arrow]])</p>\n<p>This is nice for “using\" these categories in modelling efforts, but not so nice for doing category “theory” and in particular developing a class of category operators and associated properties that are shared by all by all instances. You know, the sort of instancing power offered by classes and locales. </p>\n<p>My naive solution is to define an axiomatised “signature” theory for category theory and do all the abstract (repeatable) reasoning there.</p>\n<p>theory Category_Sig</p>\n<p>imports<br>\n  Main</p>\n<p>begin</p>\n<p>class<br>\n  cat_obj</p>\n<p>typedecl<br>\n  ('a, 'b) cat_arrow</p>\n<p>consts<br>\n  cat_compose :: \"('a::cat_obj, 'b::cat_obj) cat_arrow ⇒ ('b, 'c::cat_obj) cat_arrow ⇒ ('a, 'c) cat_arrow\"</p>\n<p>consts<br>\n  cat_id :: \"('a::cat_obj, 'a) cat_arrow\"</p>\n<p>axiomatization where<br>\n    cat_left_id: \"cat_compose cat_id a = a\" and<br>\n    cat_right_id: \"cat_compose a cat_id = a\" and<br>\n    cat_comp_assoc: \"cat_compose (cat_compose a b) c = cat_compose a (cat_compose b c)\"</p>\n<p>context<br>\nbegin</p>\n<p>notation<br>\n  cat_compose (infixr \"∘⇩♭\" 55)</p>\n<p>notation<br>\n  cat_id (\"ι⇩♭\")</p>\n<p>qualified lemma inv_uniq:<br>\n  assumes<br>\n    a1: \"f ∘⇩♭ g = cat_id\" and<br>\n    a2: \"h ∘⇩♭ f = cat_id\"<br>\n  shows<br>\n    \"g = h\"<br>\nproof -<br>\n  have<br>\n    \"g = ι⇩♭ ∘⇩♭ g\"<br>\n    by (rule cat_left_id [symmetric])<br>\n  also have \"…<br>\n    = (h ∘⇩♭ f) ∘⇩♭ g\"<br>\n    by (simp add: a2)<br>\n  also have \"…<br>\n    = h ∘⇩♭ (f ∘⇩♭ g)\"<br>\n    by (simp add: cat_comp_assoc)<br>\n  also have \"…<br>\n    = h ∘⇩♭ ι⇩♭\"<br>\n    by (simp add: a1)<br>\n  also have \"…<br>\n    = h\"<br>\n    by (rule cat_right_id)<br>\n  finally show<br>\n   \"g = h\"<br>\n    by (this)<br>\nqed</p>\n<p>end</p>\n<p>end</p>\n<p>Then I can use textual replacement to make copies of the signature theory and \"drop in” the appropriate definitions to replace the axiomatisations, global replace the \\&lt;flat&gt; subscript, etc … to get the desired instance theories.</p>\n<p>Any pointers to more sophisticated approaches? (Should note that categories are not my actual algebraic target here, just a convenient and easily understood example)</p>\n<p>It seems to suggest to me that it would be nice to have a theory “functor” facility analogous to the structure “functor\" facility of standard ML.</p>\n<p>Does anyone have any pointers to (Isabelle) work in this direction?</p>\n<p>I noted with interest an MMT/LF paper in the recent LFMTP workshop that seemed to be suggesting something similar, but I think a bit more general </p>\n<p>@inproceedings{Roux:2020a,<br>\n    Author = {Navid Roux and Florian Rabe},<br>\n    Booktitle = {Logical Frameworks and Meta Languages: Theory and Practice},<br>\n    Title = {Diagram Operators in a Logical Framework},<br>\n    Year = {2020}}</p>",
        "id": 294830738,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246516
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear Brendan Patrick Mahony/All,</p>\n<p>I would like to make a side remark for your question.</p>\n<p>At one point, I did think about developing an infrastructure for the<br>\ndefinition of generic 'meta-theories' by using implicit quantification over<br>\ntypes modelled via the use of the schematic type variables (see<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-September/msg00095.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-September/msg00095.html</a><br>\nand,<br>\nmore importantly, the reply). For this to work, one would need to write<br>\nIsabelle/ML infrastructure that can generate an 'instance' of (for example)<br>\ncategory theory on demand for a given set of constants like group,<br>\ngroup_hom, etc. This is certainly possible (see the screenshot and please<br>\nignore all aspects not directly related to the software infrastructure that<br>\nthe screenshot is meant to demonstrate), but, for me, the amount of effort<br>\nrequired seemed to be unsurmountable. The advantage of this approach is<br>\nthat it does not require any new axioms to be added to Isabelle/HOL.</p>\n<p>Since then, I have converged on the idea that it is best to use an<br>\nextension of HOL (e.g. ZFC in HOL or HOTG) and allow the 'meta-theory' and<br>\nthe 'object-theory' to coexist using only the standard techniques. In the<br>\ncontext of such extensions, this means that the 'object-theory' will be<br>\nlimited to some reasonably small set (e.g. V(ω+ω)). Of course, once such<br>\ntheory is developed, one might be able to develop an infrastructure for the<br>\ntranslation of concepts across isomorphisms, under the limitation of size<br>\nonly (I am not certain how easy and well automated this could become). I<br>\nhave been doing some work in this direction for a certain time. The<br>\nfoundational part of my development is available here:<br>\n<a href=\"https://gitlab.com/user9716869/czh_foundations\">https://gitlab.com/user9716869/czh_foundations</a> (more applied concepts are<br>\nstill in a very transient state and not available publicly). However, most<br>\nlikely, this work will be superseded by HOTG that is being developed by<br>\nAlexander Krauss, Kevin Kappelmann and Joshua Chen (see<br>\n<a href=\"https://bitbucket.org/cezaryka/tyset/src\">https://bitbucket.org/cezaryka/tyset/src</a>).</p>\n<p>Kind Regards,<br>\nMikhail Chekhov<br>\n<a href=\"/user_uploads/14278/QkoPsay06zyDFwKh6sakfeyj/MCATS.png\">MCATS.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/QkoPsay06zyDFwKh6sakfeyj/MCATS.png\" title=\"MCATS.png\"><img src=\"/user_uploads/14278/QkoPsay06zyDFwKh6sakfeyj/MCATS.png\"></a></div>",
        "id": 294830819,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246535
    },
    {
        "content": "<p>From: Mikhail Chekhov &lt;<a href=\"mailto:mikhail.chekhov.w@gmail.com\">mikhail.chekhov.w@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I forgot to provide references for my previous post in this thread. It was<br>\nnot my intention to put an emphasis on the references, as they contain<br>\nwell-known foundational material, but I do feel awkward for omitting them<br>\nfrom my post and feel the need to correct this.</p>",
        "id": 294830834,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246546
    }
]