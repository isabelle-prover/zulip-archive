[
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Joachim,</p>\n<p>that indeed would be a nice feature, not only for product types but for all non-recursive arguments of a (co)datatype constructor. Similarly for records.</p>\n<p>I guess one non-invasive to implement this would be via a plugin to the free_constructors abstraction (c.f. Ctr_Sugar.ctr_sugar_interpretation). Jasmin and me are putting this on some low-priority feature request list. But if you really want the functionality (i.e. want to do it by yourself), we would be happy to give more guidance.</p>\n<p>Cheers,<br>\nDmitriy</p>",
        "id": 294665836,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171733
    },
    {
        "content": "<p>From: Richard Molitor via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Dmitriy,</p>\n<p>I talked to Joachim yesterday, he said he was not interested at the<br>\nmoment, but if you want to provide some pointers I would like to give it<br>\na shot!</p>\n<p>A bit of background maybe: I did spend some time implementing an<br>\nextension to inductive predicates for Isabelle for my masters thesis<br>\n(Joachim was my supervisor).[1] -- What I am trying to say is that I am<br>\nsomewhat proficient in digging around in Isabelle-style ML-code and<br>\nmaking some sense of what I read, so if you provide me with some<br>\nguidance your time wont be wasted :)</p>\n<p>Best regards<br>\nRichard</p>\n<p>[1] I originally intended to get it into the AFP, but then never pushed<br>\nit when I got busy with applying for jobs and other things. The code is<br>\non github though (<a href=\"https://github.com/gattschardo/open-inductive\">https://github.com/gattschardo/open-inductive</a>) and I<br>\nmade it work with Isabelle2015 (and this week Isabelle2016-RC4).</p>",
        "id": 294666076,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171809
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Richard,</p>\n<blockquote>\n<p>On 12 Feb 2016, at 06:58, Richard Molitor &lt;<a href=\"mailto:gattschardo@googlemail.com\">gattschardo@googlemail.com</a>&gt; wrote:</p>\n<p>Hi Dmitriy,</p>\n<p>On Thu, 11 Feb 2016, Dmitriy Traytel wrote:</p>\n<blockquote>\n<blockquote>\n<p>On 05 Feb 2016, at 14:59, Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt; wrote:<br>\nConcrete proposal for your consideration: For product data types</p>\n<p>datatype t = C t₁ ... tₙ</p>\n<p>automatically generate the equivalent of</p>\n<p>lemma measure_t[measure_function]:<br>\n    \"is_measure f ⟹ is_measure (λ t. case t of C t₁ ... tₙ ⇒ (t₁,...,tₙ)\"..</p>\n</blockquote>\n<p>I guess one non-invasive to implement this would be via a plugin to<br>\nthe free_constructors abstraction (c.f.<br>\nCtr_Sugar.ctr_sugar_interpretation). Jasmin and me are putting this on<br>\nsome low-priority feature request list. But if you really want the<br>\nfunctionality (i.e. want to do it by yourself), we would be happy to<br>\ngive more guidance.</p>\n</blockquote>\n<p>I talked to Joachim yesterday, he said he was not interested at the<br>\nmoment, but if you want to provide some pointers I would like to give it<br>\na shot!</p>\n</blockquote>\n<p>Great to hear. I’ll provide some pointers in a separate mail (sent a bit later today) off this list.</p>\n<blockquote>\n<p>A bit of background maybe: I did spend some time implementing an<br>\nextension to inductive predicates for Isabelle for my masters thesis<br>\n(Joachim was my supervisor).[1] -- What I am trying to say is that I am<br>\nsomewhat proficient in digging around in Isabelle-style ML-code and<br>\nmaking some sense of what I read, so if you provide me with some<br>\nguidance your time wont be wasted :)</p>\n<p>Best regards<br>\nRichard</p>\n<p>[1] I originally intended to get it into the AFP, but then never pushed<br>\nit when I got busy with applying for jobs and other things. The code is<br>\non github though (<a href=\"https://github.com/gattschardo/open-inductive\">https://github.com/gattschardo/open-inductive</a>) and I<br>\nmade it work with Isabelle2015 (and this week Isabelle2016-RC4).</p>\n</blockquote>\n<p>Yes, I’ve came across your nice work at some point (I don’t remember the occasion). It certainly belongs into the AFP.</p>\n<p>Actually, putting the thing into the AFP will reduce your work in the long term. Basically, you’ll almost never again will have to make it work with IsabelleXXX. This is particularly true for Isabelle/ML code which changes more rapidly than well-established concepts from HOL-Main.</p>\n<p>Dmitriy</p>",
        "id": 294666100,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171819
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI've already commented on an earlier version of this material, and you <br>\nseem to have improved it further. It generally looks good -- above the <br>\naverage of various ML experiments that are already in AFP.</p>\n<p>Some years ago, the AFP editors did not want to see actual ML tools there, <br>\nbut de-facto we have that already.</p>\n<p>Note that the \"auto-magic\" maintenance in AFP means that someone changing <br>\ncertain Isabelle/ML things in Pure or HOL also goes through applications <br>\nin AFP and tries to adapt them. This sometimes requires to go over it with <br>\nthe lawn-mower first, to put it into maintainable form. (Your sources look <br>\nquite maintainable already.)</p>\n<p>I cannot say anything about the application, i.e. the problem that is <br>\naddressed here from a user perspective.</p>\n<p>Makarius</p>",
        "id": 294666337,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171886
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nDear Isabelle list,</p>\n<p>I was surprised to find that one function definition involving a type<br>\n(t1 × t2) would work, but the equivalent function definition involving<br>\na custom data type isomorphic to (t1 × t2) (i.e. one constructor with<br>\ntwo fields) would not work. See<br>\n<a href=\"http://stackoverflow.com/questions/35225110/termination-checking-for-product-types\">http://stackoverflow.com/questions/35225110/termination-checking-for-product-types</a><br>\nfor the example.</p>\n<p>The reason is, of course, that the selectors of the pair type are set<br>\nup as measure functions:</p>\n<p>lemma measure_fst[measure_function]: \"is_measure f ⟹ is_measure (λp. f (fst p))\"<br>\n    by (rule is_measure_trivial)<br>\n    lemma measure_snd[measure_function]: \"is_measure f ⟹ is_measure (λp. f (snd p))\"<br>\n    by (rule is_measure_trivial)</p>\n<p>and doing something similar for my custom type solves the problem.</p>\n<p>But it was still surprising, so I wonder if there is a reason not to<br>\nregister a similar measure function for product data types by default.</p>\n<p>Concrete proposal for your consideration: For product data types</p>\n<p>datatype t = C t₁ ... tₙ</p>\n<p>automatically generate the equivalent of</p>\n<p>lemma measure_t[measure_function]:<br>\n     \"is_measure f ⟹ is_measure (λ t. case t of C t₁ ... tₙ ⇒ (t₁,...,tₙ)\"..</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/ecfd8SzFk5qFFWdC16DRlqvV/signature.asc\">signature.asc</a></p>",
        "id": 294668350,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661172580
    }
]