[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear probability experts,</p>\n<p>I have a possibly infinite nesting of discrete probability distributions, i.e., a <br>\ncodatatype of the form</p>\n<p>codatatype foo = Foo \"(nat * foo) pmf\"</p>\n<p>where pmf is the type of discrete probability distributions (probability mass functions, <br>\nPMF). Now, I would like to measure unrollings of some \"foo :: foo\", which are infinite <br>\nstreams of naturals. The streams are generated by picking a element (n, foo') from the <br>\nsupport of foo's PMF, use n as the head of the stream and continue corecursively with <br>\nfoo'. The probability of a single stream should intuitively be the product of all the <br>\nprobabilities of the random choices according to the PMFs. This is only the intuition, as <br>\nthe stream is infinite and the resulting distribution is continuous, so the density given <br>\nby the product does not exist.</p>\n<p>I now want to construct the measure space with the associated measure on the sigma algebra <br>\ngenerated by the usual cylinders on streams. I tried to define the measure on the <br>\ncylinders (which can be indexed all finite lists of naturals) and found the function <br>\nextend_measure for that. Unfortunately, I have not found many usable theorems about <br>\nextend_measure. In the theorem emeasure_extend_measure, e.g., I have to provide a positive <br>\nand countably-additive function mu' on the sigma algebra of the cylinders, which is just <br>\nwhat I want to construct. Am I overlooking the obvious? Are there better ways to construct <br>\nthe measure function I want? The sigma algebra is isomorphic to the infinite indexed <br>\nproduct. My problem is just assigning the right probability to the sets of streams.</p>\n<p>Thanks in advance for any pointers and suggestions,<br>\nAndreas</p>\n<p>PS: I am hooked in a recent snapshot of the development version, so I am happy to use all <br>\nthe new stuff that will be only available in Isabelle2015. I still post on isabelle-users <br>\nas this is a general question about measures in Isabelle which will still be relevant <br>\nafter the next release.</p>",
        "id": 294326459,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928698
    },
    {
        "content": "<p>From: Johannes HÃ¶lzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<p>I think you can use the formalization of Markov chains in the locale<br>\nMC_syntax in $AFP/Markov_Models/Discrete_Time_Markov_Chain. Here a<br>\nMarkov chain K is given as the Markov kernel (i.e. transition system)<br>\nK :: 's =&gt; 's pmf.</p>\n<p>In your case the state space is nat * foo, so MC_syntax can be<br>\ninstantiated with<br>\n  K == un_Foo o snd<br>\nthen you get a trace space \"T s :: (nat * foo) stream measure\". With<br>\n  T' s == distr (T s) (stream_space (count_space UNIV)) (smap fst)<br>\nyou construct a \"nat stream space\". But be aware: you lost some<br>\ninformation, so T' is not the trace space of a Markov chain anymore!</p>\n<p>Does this answer your question?</p>\n<ul>\n<li>Johannes</li>\n</ul>\n<p>PS: If you want to construct the trace space yourself you want to use<br>\nCaratheodories extension theorem in the form of<br>\nextend_measure_caratheodory.<br>\nBut generally I would suggest to avoid this and use the product measure<br>\nor the trace space of Markov chains.</p>",
        "id": 294326511,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928716
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Johannes,</p>\n<p>Thanks for the quick answer. Building on your work seems easier than redoing everything <br>\nfrom scratch. I still have some trouble to define the distribution T', because T' should <br>\nhave type \"foo =&gt; ...\" rather than \"nat * foo =&gt; ...\". I tried to define T' as</p>\n<p>T' s = distr (T (undefined, s)) (stream_space (count_space UNIV)) (smap fst)</p>\n<p>but then I have trouble to get a nice recursion equation in the style of <br>\nMC_Syntax.nn_integral_T, because I don't know how to show \"MC_syntax.walk K (n, foo) = <br>\nMC_syntax.walk K (undefined, foo)\" for K = \"un_Foo o snd\". Can you give me a hint?</p>\n<p>I also looked at your theory on Markov Decision Processes, which look very interesting. <br>\nUnfortunately, I have not been able to really understand them. Can you give me a reference <br>\nwhere I can read up on that? The paper linked from the AFP entry's abstract does not cover <br>\nMDPs.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294326554,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928734
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Johannes,</p>\n<p>Meanwhile, I found a way to prove this using MC_syntax.T_eq_T'.</p>\n<p>Sorry for the noise,<br>\nAndreas</p>",
        "id": 294326566,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928741
    }
]