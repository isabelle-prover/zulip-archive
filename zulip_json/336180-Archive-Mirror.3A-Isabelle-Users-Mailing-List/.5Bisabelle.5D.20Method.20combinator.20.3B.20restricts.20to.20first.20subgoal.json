[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nDan has already explained most aspects of this.  Just for completeness, <br>\nhere is the relevant snippet from the isar-ref manual:</p>\n<p>Structural composition ``@{text m1}@{verbatim \";\"}~@{text m2}'' means<br>\n   that method @{text m1} is applied with restriction to the first subgoal,<br>\n   then @{text m2} is applied consecutively with restriction to each<br>\n   subgoal that has newly emerged due to @{text m1}. This is analogous to<br>\n   the tactic combinator @{ML_op THEN_ALL_NEW} in Isabelle/ML, see also<br>\n   @{cite \"isabelle-implementation\"}. For example, @{text \"(rule r;<br>\n   blast)\"} applies rule @{text \"r\"} and then solves all new subgoals by<br>\n   @{text blast}.</p>\n<p>The citation of isabelle-implementation is pointless, though: the manual <br>\ndoes not mention it in Isabelle2015.  The THEN_ALL_NEW tactical was new in <br>\n1998, and I just thought that it is universally known and properly <br>\ndocumented.  See also <br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/0e034d76932e\">http://isabelle.in.tum.de/repos/isabelle/rev/0e034d76932e</a></p>\n<p>In that ML definition you also see that it is just a matter of working <br>\nwith subgoal indices, without ever looking at the actual goal state.  The <br>\nassumption is that tactics / proof methods work in the way that is <br>\nspecified in the Isabelle/Isar implementation manual, sections 4.2 <br>\n\"Tactics\" and 7.2 \"Proof methods\".</p>\n<p>The Isar method combinator does some more sandboxing of proof states, to <br>\nenforce certain policies, which was observed here in the examples.</p>\n<p>Makarius</p>",
        "id": 294643752,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163206
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I am wondering why the new method combinator restricts the first method to the first <br>\nsubgoal. Is there any deeper reason for this design decision?</p>\n<p>I regularly attempt myself to write things like the following</p>\n<p>apply(safe; simp_all)<br>\n   apply(simp_all; blast)<br>\n   apply(auto; force intro: ...)<br>\n   apply(case_tac [1-3] x; simp_all)</p>\n<p>and then wonder why they don't work as expected (throw the first method at all/the <br>\nspecified subgoals and then invoke the second method only on subgoals arising from the <br>\nfirst method). What are the use cases for the restriction to the first subgoal? Or am I <br>\njust using bad style?</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294646391,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164248
    },
    {
        "content": "<p>From: Daniel Matichuk &lt;<a href=\"mailto:daniel.matichuk@nicta.com.au\">daniel.matichuk@nicta.com.au</a>&gt;<br>\nHi Andreas,<br>\nIt's not really defined what it means for a subgoal to \"arise\" out of a method which applies to all subgoals.<br>\nIn the general case a method can perform arbitrary modifications to the collection of subgoals<br>\n(including changing the number), and so the \"new\" subgoals would need to be all of them.</p>\n<p>In the restricted case, it is clear which subgoals are new because it is exactly those which are on<br>\ntop of the subgoal stack.</p>\n<p>One possible solution to your problem is to expose \"ALLGOALS\" as a method combinator. This can be done relatively easily with some<br>\nsimple Eisbach-provided functionality (I didn't get around to including this in the release):</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">method_setup</span> <span class=\"n\">all</span> <span class=\"o\">=</span>\n  <span class=\"err\">‹</span><span class=\"n\">Method_Closure.parse_method</span> <span class=\"err\">&gt;&gt;</span> <span class=\"o\">(</span><span class=\"n\">fn</span> <span class=\"n\">m</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span> <span class=\"n\">fn</span> <span class=\"n\">ctxt</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span> <span class=\"n\">fn</span> <span class=\"n\">facts</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span>\n    <span class=\"k\">let</span>\n      <span class=\"k\">fun</span> <span class=\"n\">tac</span> <span class=\"n\">i</span> <span class=\"n\">st'</span> <span class=\"o\">=</span>\n        <span class=\"n\">Goal.restrict</span> <span class=\"n\">i</span> <span class=\"n\">1</span> <span class=\"n\">st'</span>\n        <span class=\"o\">|</span><span class=\"err\">&gt;</span> <span class=\"n\">Method_Closure.method_evaluate</span> <span class=\"n\">m</span> <span class=\"n\">ctxt</span> <span class=\"n\">facts</span>\n        <span class=\"o\">|</span><span class=\"err\">&gt;</span> <span class=\"n\">Seq.map</span> <span class=\"o\">(</span><span class=\"n\">Goal.unrestrict</span> <span class=\"n\">i</span> <span class=\"n\">o</span> <span class=\"n\">snd</span><span class=\"o\">)</span>\n\n    <span class=\"kp\">in</span> <span class=\"n\">EMPTY_CASES</span> <span class=\"o\">(</span><span class=\"n\">ALLGOALS</span> <span class=\"n\">tac</span><span class=\"o\">)</span> <span class=\"k\">end</span><span class=\"o\">)</span>\n<span class=\"err\">›</span>\n\n\n<span class=\"kn\">lemma</span>\n  <span class=\"kp\">assumes</span> <span class=\"n\">B</span><span class=\"o\">:</span> <span class=\"n\">B</span>\n  <span class=\"kp\">shows</span>\n  <span class=\"s\">\"A ⟶ (A ∧ B)\"</span> <span class=\"s\">\"A ⟶ (A ∧ B)\"</span> <span class=\"s\">\"A ⟶ (A ∧ B)\"</span>\n  <span class=\"kp\">apply</span> <span class=\"o\">-</span>\n  <span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">all</span> <span class=\"err\">‹</span><span class=\"n\">safe</span><span class=\"err\">;</span> <span class=\"n\">rule</span> <span class=\"n\">B</span><span class=\"err\">›</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In this example, \"safe\" is executed in isolation against each subgoal, and \"rule B\" applied to each emerging one.</p>\n<p>Although this implementation throws away rule cases, you probably get the idea. You could also use PARALLEL_ALLGOALS if desired.</p>\n<p>As a side note, something like \"(x; simp_all)\" never makes sense, the second argument is run against each resulting subgoal in isolation.<br>\nYou almost certainly mean \"(x; simp)\".</p>\n<p>-Dan</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294646454,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164279
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Daniel,</p>\n<p>On 05/06/15 07:23, Daniel Matichuk wrote:</p>\n<blockquote>\n<p>It's not really defined what it means for a subgoal to \"arise\" out of a method which applies to all subgoals.<br>\nIn the general case a method can perform arbitrary modifications to the collection of subgoals<br>\n(including changing the number), and so the \"new\" subgoals would need to be all of them.<br>\nI see. My naive intuition was that new subgoals are those that are there but were not <br>\nthere before (and their relative order must be the same), but that is probably a bit too <br>\nvague.</p>\n</blockquote>\n<blockquote>\n<p>One possible solution to your problem is to expose \"ALLGOALS\" as a method combinator. This can be done relatively easily with some<br>\nsimple Eisbach-provided functionality (I didn't get around to including this in the release):</p>\n<p>~~~<br>\nmethod_setup all =<br>\n   ‹Method_Closure.parse_method &gt;&gt; (fn m =&gt; fn ctxt =&gt; fn facts =&gt;<br>\n     let<br>\n       fun tac i st' =<br>\n         Goal.restrict i 1 st'<br>\n         |&gt; Method_Closure.method_evaluate m ctxt facts<br>\n         |&gt; <a href=\"http://Seq.map\">Seq.map</a> (Goal.unrestrict i o snd)</p>\n<p>in EMPTY_CASES (ALLGOALS tac) end)<br>\n›</p>\n<p>lemma<br>\n   assumes B: B<br>\n   shows<br>\n   \"A ⟶ (A ∧ B)\" \"A ⟶ (A ∧ B)\" \"A ⟶ (A ∧ B)\"<br>\n   apply -<br>\n   by (all ‹safe; rule B›)<br>\n~~~<br>\nIn this example, \"safe\" is executed in isolation against each subgoal, and \"rule B\" applied to each emerging one.<br>\nThe all combinator is nice, thanks. Still, I am not really comfortable with it. I am used <br>\nto auto and safe working on all goals. Now, if read something like</p>\n</blockquote>\n<p>apply(auto intro: ... simp add: ... simp del: ...; blast elim: ...)</p>\n<p>I am still tempted to think that it works on all subgoals, because the restriction <br>\noperator \";\" is well hidden between two method invocations (and visually not so much <br>\ndifferent from \",\", which does not restrict auto). The restriction operator [3] added <br>\nafter the closing parenthesis is much easier to spot.</p>\n<blockquote>\n<p>As a side note, something like \"(x; simp_all)\" never makes sense, the second argument is run against each resulting subgoal in isolation.<br>\nYou almost certainly mean \"(x; simp)\".<br>\nYou are right, although I in fact have a few instances of \"...; simp_all\" in my code. This <br>\nstems from transforming something like</p>\n</blockquote>\n<p>apply(rule ...)<br>\n   apply simp_all</p>\n<p>into</p>\n<p>apply(rule ...; simp_all)</p>\n<p>I still have to get my head around to then change simp_all into simp.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294646483,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164298
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nAn aside on this thread: the ';' combinator provides a nice way for<br>\ntransferring class instances to parametric types, e.g. in<br>\n~~/src/HOL/NSA/StarDef.thy</p>\n<blockquote>\n<p>instance star :: (order) order<br>\napply (intro_classes)<br>\napply (transfer, rule less_le_not_le)<br>\napply (transfer, rule order_refl)<br>\napply (transfer, erule (1) order_trans)<br>\napply (transfer, erule (1) order_antisym)<br>\ndone</p>\n</blockquote>\n<p>can now be simply written as</p>\n<blockquote>\n<p>instance star :: (order) order<br>\n  by (intro_classes; transfer) (fact less_le_not_le order_refl order_trans order_antisym)+</p>\n</blockquote>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/J3_33n78XCtAQh4VcjMTxEIb/signature.asc\">signature.asc</a></p>",
        "id": 294646513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164317
    },
    {
        "content": "<p>From: Daniel Matichuk &lt;<a href=\"mailto:daniel.matichuk@nicta.com.au\">daniel.matichuk@nicta.com.au</a>&gt;</p>\n<blockquote>\n<p>On 5 Jun 2015, at 4:47 pm, Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<p>Hi Daniel,</p>\n<p>On 05/06/15 07:23, Daniel Matichuk wrote:<br>\nI see. My naive intuition was that new subgoals are those that are there but were not there before (and their relative order must be the same), but that is probably a bit too vague.</p>\n</blockquote>\n<p>I had the same thought. The naive solution works in most cases but there are a fair number of edge cases where it breaks down or is unclear. For example, if m1 rotates all subgoals by 1,<br>\ndoes \"m1;m2\" apply m2 to all subgoals or none? I think without the ability to have a method officially declare what is a \"new\" subgoal, it will be difficult to address this generally.</p>\n<blockquote>\n<p>The all combinator is nice, thanks. Still, I am not really comfortable with it. I am used to auto and safe working on all goals. Now, if read something like</p>\n<p>apply(auto intro: ... simp add: ... simp del: ...; blast elim: ...)</p>\n<p>I am still tempted to think that it works on all subgoals, because the restriction operator \";\" is well hidden between two method invocations (and visually not so much different from \",\", which does not restrict auto). The restriction operator [3] added after the closing parenthesis is much easier to spot.</p>\n</blockquote>\n<p>I agree that it's a bit strange to suddenly have this implicit [1] restriction. I think, however, that such an application of \";\" is improper and should either result in an error or just be considered bad style (if auto is not explicitly restricted to the first subgoal).</p>\n<p>I would argue that the introduction of the \";\" combinator should result a shift away from using all-subgoal methods as anything but sole terminal methods. If, for example, you chained your long method expression<br>\nusing \";\" to the method which originally produced the subgoals then you would not need to rely on the fact that \"auto\" applies to all subgoals:<br>\ni.e<br>\n        apply (cases ..; auto intro: .. simp add: ... ; blast elim: ...)</p>\n<p>In this case the scope and intent of \"auto ...\" is much more clear, and avoids clobbering additional subgoals that sneak in during regular proof maintenance.</p>\n<p>Regards,<br>\nDan</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294646757,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164420
    },
    {
        "content": "<p>From: Daniel Matichuk &lt;<a href=\"mailto:daniel.matichuk@nicta.com.au\">daniel.matichuk@nicta.com.au</a>&gt;</p>\n<blockquote>\n<p>On 6 Jun 2015, at 3:52 am, Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt; wrote:</p>\n<p>An aside on this thread: the ';' combinator provides a nice way for<br>\ntransferring class instances to parametric types, e.g. in<br>\n~~/src/HOL/NSA/StarDef.thy</p>\n<blockquote>\n<p>instance star :: (order) order<br>\napply (intro_classes)<br>\napply (transfer, rule less_le_not_le)<br>\napply (transfer, rule order_refl)<br>\napply (transfer, erule (1) order_trans)<br>\napply (transfer, erule (1) order_antisym)<br>\ndone</p>\n</blockquote>\n<p>can now be simply written as</p>\n<blockquote>\n<p>instance star :: (order) order<br>\n by (intro_classes; transfer) (fact less_le_not_le order_refl order_trans order_antisym)+</p>\n</blockquote>\n</blockquote>\n<p>You could also write it as</p>\n<blockquote>\n<p>(intro_classes; transfer; fact less_le_not_le order_refl order_trans order_antisym)</p>\n</blockquote>\n<p>Which is not that useful here, but generally more appropriate in an apply-script (where \"+\" has a tendency to over-step).</p>\n<p>Regards,<br>\nDan</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294646768,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164426
    }
]