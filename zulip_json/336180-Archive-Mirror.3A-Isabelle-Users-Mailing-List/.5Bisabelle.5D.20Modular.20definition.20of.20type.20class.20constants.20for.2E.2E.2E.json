[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nAssume the following simple type class:</p>\n<p>class foo =<br>\n   fixes count :: \"'a ⇒ nat\"</p>\n<p>Instantiations for simple recursive data types are trivial:</p>\n<p>instantiation list :: (foo) foo<br>\n begin<br>\n   fun count_list where<br>\n   \"count [] = 0\" |<br>\n   \"count (x # xs) = count x + count xs\"</p>\n<p>instance ..<br>\n end</p>\n<p>Now, consider a more elaborate data type:</p>\n<p>datatype_new 'a rose = Fork 'a \"'a rose list\"</p>\n<p>The naive attempt to instantiate \"foo\" for \"rose\" fails, as I expected:</p>\n<p>instantiation rose :: (foo) foo<br>\n begin<br>\n   fun count_rose where<br>\n   \"count (Fork a as) = count a + count as\"</p>\n<p>instance ..<br>\n end</p>\n<p>My question is: How to define \"count_rose\" in such a way that I don't <br>\n have to repeat large parts of \"count_list\"?</p>\n<p>The ultimate goal is to derive these instances automatically. I know <br>\n about the relevant AFP entry <br>\n (&lt;<a href=\"http://afp.sourceforge.net/entries/Datatype_Order_Generator.shtml\">http://afp.sourceforge.net/entries/Datatype_Order_Generator.shtml</a>&gt;), <br>\n but as far as I can see, it builds on the old datatype package, and I'd <br>\n rather like to have something for the new BNF package.</p>\n<p>Cheers<br>\n Lars</p>",
        "id": 294280305,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920128
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Lars,</p>\n<blockquote>\n<p>instantiation list :: (foo) foo<br>\nbegin<br>\n  fun count_list where<br>\n  \"count [] = 0\" |<br>\n  \"count (x # xs) = count x + count xs\"</p>\n<p>instance ..<br>\nend</p>\n<p>datatype_new 'a rose = Fork 'a \"'a rose list\"</p>\n<p>The naive attempt to instantiate \"foo\" for \"rose\" fails, as I expected:</p>\n<p>instantiation rose :: (foo) foo<br>\nbegin<br>\n  fun count_rose where<br>\n  \"count (Fork a as) = count a + count as\"</p>\n<p>instance ..<br>\nend</p>\n</blockquote>\n<p>the best way to approach this is to replace count_rose mentally by a<br>\nsyntactically different operation f and write down a specification for f<br>\naccordingly.  This then should be transferable to an instantiation.</p>\n<blockquote>\n<p>The ultimate goal is to derive these instances automatically. I know about the relevant AFP entry (&lt;<a href=\"http://afp.sourceforge.net/entries/Datatype_Order_Generator.shtml\">http://afp.sourceforge.net/entries/Datatype_Order_Generator.shtml</a>&gt;), but as far as I can see, it builds on the old datatype package, and I'd rather like to have something for the new BNF package.</p>\n</blockquote>\n<p>Well, sounds there is some work to do there.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/gE9uTjwISceIYxkfV2nvdGOj/signature.asc\">signature.asc</a></p>",
        "id": 294280331,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920134
    },
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Lars,</p>\n<p>Am 10.06.2014 um 18:50 schrieb Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;:</p>\n<blockquote>\n<p>Now, consider a more elaborate data type:</p>\n<p>datatype_new 'a rose = Fork 'a \"'a rose list\"</p>\n<p>The naive attempt to instantiate \"foo\" for \"rose\" fails, as I expected:</p>\n<p>instantiation rose :: (foo) foo<br>\nbegin<br>\n fun count_rose where<br>\n \"count (Fork a as) = count a + count as\"</p>\n<p>instance ..<br>\nend</p>\n<p>My question is: How to define \"count_rose\" in such a way that I don't have to repeat large parts of \"count_list\"?</p>\n</blockquote>\n<p>Here's one way, perhaps:</p>\n<p>class foo =<br>\n     fixes count :: \"'a =&gt; nat\"</p>\n<p>instantiation nat :: foo<br>\n    begin<br>\n     definition count_nat where \"count n = n\"</p>\n<p>instance ..<br>\n    end</p>\n<p>instantiation list :: (foo) foo<br>\n    begin<br>\n     primrec count_list where<br>\n     \"count [] = 0\" |<br>\n     \"count (x # xs) = count x + count xs\"</p>\n<p>instance ..<br>\n    end</p>\n<p>datatype_new 'a rose = Fork 'a \"'a rose list\"</p>\n<p>instantiation rose :: (foo) foo<br>\n    begin<br>\n     primrec count_rose where<br>\n     \"count (Fork a as) = count a + count (map count as)\"</p>\n<p>instance ..<br>\n    end</p>\n<p>Notice that the above solution works with \"primrec\" -- no ad hoc termination arguments! But it does cheat a little bit in \"count (map count as)\", first counting the elements of the list, then counting the list of nats.</p>\n<p>You might want to take a look at the BNF-based size extension. Try</p>\n<p>thm list.size<br>\n    thm rose.size</p>\n<p>to see what it has to offer. I suspect that you could base \"count\" on \"size_xxx\" (e.g. \"size_list\"). If not, the idiom used to derive \"size\" systematically for all BNF-based datatypes might still serve as an inspiration.</p>\n<p>Another possible source of inspiration is our sketch for a \"countable\" extension to BNF datatypes. I'm attaching the theory file. This development is somewhat simpler than the \"size\" extension, because it doesn't need to maintain two series of symbols in parallel (e.g. \"size\" instances vs. \"size_xxx\"). Hence, it appears to be a better model for what you want to do (assuming the \"count (map count as)\" cheat works for you).</p>\n<blockquote>\n<p>The ultimate goal is to derive these instances automatically. I know about the relevant AFP entry (&lt;<a href=\"http://afp.sourceforge.net/entries/Datatype_Order_Generator.shtml\">http://afp.sourceforge.net/entries/Datatype_Order_Generator.shtml</a>&gt;), but as far as I can see, it builds on the old datatype package, and I'd rather like to have something for the new BNF package.</p>\n</blockquote>\n<p>The author of this entry is all in favor of porting it to the new package, and it is, from what I understand, only a matter of time until he gets to it. ;)</p>\n<p>Jasmin<br>\n<a href=\"/user_uploads/14278/w5-FrfwsfiYvw13EVnho9Pqx/BNF_LFP_Countable.thy\">BNF_LFP_Countable.thy</a></p>",
        "id": 294280347,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920140
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Jasmin,</p>\n<blockquote>\n<p>instantiation rose :: (foo) foo<br>\n    begin<br>\n     primrec count_rose where<br>\n     \"count (Fork a as) = count a + count (map count as)\"</p>\n<p>instance ..<br>\n    end</p>\n</blockquote>\n<p>thanks, but my real type class is a little bit more complicated. I <br>\n guess I should've posted the real thing from the beginning ;-)</p>\n<p>class evaluate =<br>\n   fixes eval :: \"rule set ⇒ term ⇒ 'a ⇒ bool\" (\"_/ ⊢/ (_ ↓/ _)\" <br>\n [50,0,50] 50)<br>\n   assumes ...</p>\n<p>Instantiations typically look like this:</p>\n<p>instantiation list :: (evaluate) evaluate<br>\n begin<br>\n   primrec eval_list where<br>\n   \"eval_list rs t [] ⟷ rs ⊢ t ⟶* Const ''List.list.Nil''\" |<br>\n   \"eval_list rs t (x # xs) ⟷ (∃t⇩1 t⇩2. rs ⊢ t⇩1 ↓ x ∧ rs ⊢ t⇩2 ↓ xs ∧ <br>\n rs ⊢ t ⟶* Const ''List.list.Cons'' $ t⇩1 $ t⇩2)\"</p>\n<p>...</p>\n<p>end</p>\n<p>Off the top of my head, I don't see any way I could make this cheat <br>\n work for this class, because every element of a data type needs to be <br>\n mapped with a different function.</p>\n<blockquote>\n<p>You might want to take a look at the BNF-based size extension. Try</p>\n<p>thm list.size<br>\n    thm rose.size</p>\n<p>to see what it has to offer. I suspect that you could base \"count\" on<br>\n\"size_xxx\" (e.g. \"size_list\"). If not, the idiom used to derive <br>\n\"size\"<br>\nsystematically for all BNF-based datatypes might still serve as an<br>\ninspiration.</p>\n</blockquote>\n<p>Thanks, I'll have a look. This doesn't seem to be in the Isabelle <br>\n 2013-2 release, but I have no problem with switching to a repository <br>\n version.</p>\n<blockquote>\n<p>The author of this entry is all in favor of porting it to the new<br>\npackage, and it is, from what I understand, only a matter of time<br>\nuntil he gets to it. ;)</p>\n</blockquote>\n<p>Well, in that case, here's one more person who'd like to see that <br>\n happening :-)</p>\n<p>Cheers<br>\n Lars</p>",
        "id": 294280364,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920146
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Florian,</p>\n<p>unfortunately, this approach isn't modular. If I pull out the <br>\n specification of \"count_rose\" into a different constant, e.g. <br>\n \"count_rose_pre\", ideally I'd still want to use the instance \"list :: <br>\n foo\", but this requires the element type (\"rose\") to have a \"foo\" <br>\n instance. This naive translation merely trades a \"circular constant <br>\n dependency\" error message for a circular dependency which is impossible <br>\n to express.</p>\n<p>Surely I can also pull out the definition of \"count_list\" and refer to <br>\n that, but my attempt failed:</p>\n<p>datatype_new 'a seq = Cons 'a \"'a seq\" | Nil<br>\n datatype_new 'a rose = Fork 'a \"'a rose seq\"</p>\n<p>primrec_new count_seq_pre where<br>\n \"count_seq_pre _ Nil = 0\" |<br>\n \"count_seq_pre f (Cons x xs) = f x + count_seq_pre f xs\"</p>\n<p>primrec_new count_rose_pre where<br>\n \"count_rose_pre f (Fork a as) = f a + count_seq_pre (count_rose_pre f) <br>\n as\"</p>\n<p>The error message is:</p>\n<p>primrec_new error:<br>\n   Invalid map function in \"count_seq_pre (count_rose_pre f)\"</p>\n<p>If I change everything to \"fun\" and use \"datatype_new_compat\", the <br>\n function package is unable to find a termination order.</p>\n<p>Cheers<br>\n Lars</p>",
        "id": 294280380,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920152
    },
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Lars,</p>\n<p>Yes, I ran into this issue when implementing the \"size\" extension. To sort this out, it should be possible to rephrase the \"primrec\" specification so that it's expressed in terms of \"map\". Then you can derive the desired specification without \"map\" as a theorem. Perhaps we can discuss this live if you're in the office tomorrow.</p>\n<p>Jasmin</p>",
        "id": 294280401,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920158
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nIf I understand it correctly, here really the same trick as for the size <br>\nfunction can be done: one uses two versions of the function:</p>\n<ul>\n<li>eval :: \"rule set =&gt; term =&gt; 'a :: evaluate list =&gt; bool\"</li>\n<li>eval_list :: \"rule set =&gt; (term =&gt; 'a =&gt; bool) =&gt; term =&gt; 'a list =&gt; bool\"</li>\n</ul>\n<p>s.t. \"eval rs = eval_list rs (eval rs :: term =&gt; 'a :: evaluate =&gt; bool)\"</p>\n<p>For lists eval_list would be defined by:</p>\n<p>primrec eval_list where<br>\n\"eval_list rs ev t [] ⟷ rs ⊢ t ⟶* Const ''List.list.Nil''\" |<br>\n\"eval_list rs ev t (x # xs) ⟷ (∃t1 t2. ev t1 x ∧ eval_list rs ev t2 xs ∧ <br>\nrs ⊢ t ⟶* Const ''List.list.Cons'' $ t1 $ t2)\"</p>\n<p>Then for rose trees:</p>\n<p>datatype_new 'a tree = Node 'a \"'a tree list\"</p>\n<p>primrec eval_tree where<br>\n   \"eval_tree rs ev u (Node a us) = (∃t ts. ev t a ∧<br>\n      eval_list rs (λt f. f t) ts (map (λu t. eval_tree rs ev t u) us) ∧<br>\n      rs ⊢ u ⟶* Const ''Scratch.tree.Node'' $ t $ ts)\"</p>\n<p>And the class instantiation again via</p>\n<p>\"eval rs = eval_tree rs (eval rs :: term =&gt; 'a :: evaluate =&gt; bool)\"</p>\n<p>Dmitriy</p>",
        "id": 294280423,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920164
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nBTW: hopefully something like \"eval_list rs (λt f. f t) ts (map (λu t. <br>\neval_tree rs ev t u) us) = eval_list rs (eval_tree rs ev) ts us\" will be <br>\nprovable, such that one can get nice equations (similarly to what you <br>\ntried after Florian's suggestion hitting the syntactic restriction of <br>\nprimrec).</p>\n<p>Dmitriy</p>",
        "id": 294280437,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920170
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nYet a few more thoughts.</p>\n<p>To get a deeper understanding of the specification, you could try the<br>\nfollowing:</p>\n<p>a) provide a f corresponding to count ['a list] but abstracted over<br>\ncount ['a] (»dictionary«)</p>\n<p>b) define count ['a list] in terms of f</p>\n<p>c) try to write down your specification for a g corresponding to count<br>\n['a rose].</p>\n<p>If your specification mechanisms chokes then, its beyond the borders of<br>\nthe specification mechanisms itself (at least in its particular setup).</p>\n<p>If no, try to replace g by count ['a rose] using plain overloading<br>\ntarget (remove the const constraint from count if necessary).  If this<br>\nis rejected, it is just not covered by overloaded definitions in Isabelle.</p>\n<p>If no, the instantiation target itself cannot cover your specification.</p>\n<p>Beyond that, I can emphasize what Jasmin has hinted at: particularly<br>\nconcerning automatically derived specifications, you should not rely on<br>\nfun.  For systematic instantiation, usually primrec specifications can<br>\nbe achieved, perhaps including funny combinators defined once and for<br>\nall by hand.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/_K1DSProXvHE3A4ESVcY6Vjq/signature.asc\">signature.asc</a></p>",
        "id": 294280460,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920177
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Lars and all,</p>\n<p>Indeed, currently everything in the AFP-entry Datatype_Order_Generator works via<br>\nthe interface of the old datatype-package, but most of it is currently <br>\naccessible via datatype_compat (but not \"derive countable\"). </p>\n<p>It is on my TODO list to adapt the AFP-entry to the new datatype package, but<br>\ncurrently this is not a high-priority item, so it might take some while.</p>\n<p>Cheers,<br>\nRené</p>\n<p>PS: I can only confirm Florian's comment on not using \"fun\" but primrec instead.<br>\nIn the first version I tried to develop the order-generators via the function package<br>\nwhich turned out quite to be quite complicated / tedious. Once I switched to the<br>\nrecursors from the old datatype package, the whole task became much simpler.<br>\n<a href=\"/user_uploads/14278/Mpq6IUCqGMwLtVWde5Se798b/signature.asc\">signature.asc</a></p>",
        "id": 294280646,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920238
    }
]