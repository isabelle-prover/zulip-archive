[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHi there,</p>\n<p>I wrote a theory (plus accompanying ML file) that allows to use <br>\ndo-notation (as in Haskell and where braces and semicolons are <br>\nmandatory) for arbitrary monads (in this case, arbitrary bind- and <br>\nthen-functions), after a setup via:</p>\n<p>setup {*<br>\n   add_monad \"List\" {<br>\n     monad_bind = @{term \"%xs f. concat (map f xs)\"},<br>\n     monad_then = NONE<br>\n   }<br>\n*}</p>\n<p>(Here \"monad_then = NONE\" means that \"bind m (%_. n)\" is used instead of <br>\n\"then m n\".)</p>\n<p>setup {* use_monad \"List\" *}</p>\n<p>Now, we can write, e.g.,</p>\n<p>do {<br>\n   let xs = [0..2];<br>\n   x &lt;- xs;<br>\n   y &lt;- xs;<br>\n   [(x, y)]<br>\n}</p>\n<p>to obtain the list [(0, 0), (0, 1), (0, 2), ..., (2, 2)].</p>\n<p>So far so good :). In this setup it is not possible to combine different <br>\nmonads. Consider for example the following option monad:</p>\n<p>setup {*<br>\n   add_monad \"Option\" {<br>\n     monad_bind = @{term \"%m f. <a href=\"http://Option.map\">Option.map</a> f m\"},<br>\n     monad_then = NONE<br>\n   }<br>\n*}</p>\n<p>I would like to be able to write, e.g.,</p>\n<p>do {<br>\n   let xs = [Some 0, Some 1, None];<br>\n   x &lt;- xs;<br>\n   y &lt;- xs;<br>\n   let r = do {<br>\n     m &lt;- x;<br>\n     n &lt;- y;<br>\n     Some (x + y)<br>\n   };<br>\n   return [r]<br>\n}</p>\n<p>which is an admittedly contrived example. My first thought, was to give <br>\n\"do\" an optional argument (the name of the monad that should be used), as in</p>\n<p>do List { ... do Option { ... } ... }</p>\n<p>This brings me to my actual question ;)</p>\n<p>If I would use Theory_Data to store the \"current monad\", my <br>\nparse_translations would have to modify the current theory. I assume, <br>\nthis is bad (furthermore, I have no clue how to do this :)). Would it be <br>\nokay to use a reference for this? What about potential problems?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294108227,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835920
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Christian,</p>\n<p>I can see that your parse_translation might need to read information<br>\nfrom the current theory, but I don't see why it would have to <em>modify</em><br>\nthe current theory. The parse_translation for case syntax (function<br>\ncase_tr in HOL/Tools/Datatype/datatype_case.ML) probably uses all the<br>\nrelevant techniques that you would need to implement your generic<br>\nmonadic syntax: it reads information about constructors from theory<br>\ndata, and translates the case branches (built with the \"_case1\" and<br>\n\"_case2\" syntactic constructors) into the appropriate case<br>\ncombinators. It does not modify any theory data during parsing.</p>\n<p>I'm not sure how your current parse_translation is implemented, but<br>\nhere's the approach I would take: First, define some syntactic<br>\nconstructors for the do-syntax, similar to how the case syntax is<br>\ndefined in HOL.thy:</p>\n<p>nonterminals dobinds</p>\n<p>syntax<br>\n  \"_do1\" :: \"'a =&gt; dobinds\" (\"_\")<br>\n  \"_do2\" :: \"[pttrn, 'a, dobinds] =&gt; dobinds\" (\"_ &lt;- _;/ _\")<br>\n  \"_do_syntax\" :: \"[string, dobinds] =&gt; 'a\" (\"do _ {_}\")</p>\n<p>Then define a parse_translation for \"_do_syntax\" that would parse the<br>\nlist of \"_do2\" and \"_do1\" constructors, then choose an appropriate<br>\nmonad instance based on the value of the string argument (obtaining<br>\nthe table of monad instances from the theory data).</p>\n<p>Alternatively you could omit the \"string\" argument to \"_do_syntax\" and<br>\nlook up the monad instance based on the type of the last statement of<br>\nthe do-block (except I'm not sure whether the type information would<br>\nbe available yet). Or you could do a lookup based on what the<br>\ntop-level constant of the last statement is, e.g. a term of the form<br>\n[_] indicates the list monad, and Some _ indicates the option monad.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294108274,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835936
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is going in the right direction.</p>\n<p>Also note that Scala \"for\" comprehensions are officially explained as a <br>\ncertain syntax translation on untyped expressions, which are later run <br>\nthrough the regular type-inference.</p>\n<p>If it turns out that you do need type information for your tanslation you <br>\ncan organize it like that:</p>\n<p>* The translation functions (advanced parse translations etc.) only take<br>\n     care of producing proper binders.</p>\n<p>* Further transformations within the type-checking phase are done by<br>\n     your own \"check\" operation, which is installed via Syntax.add_term_check</p>\n<p>The latter gives you an opportunity to participate in a simultaneous <br>\nprocess to infer full type information.  The regular Hindley-Milner type <br>\ninference is only one part of that.  This relatively new and advanced <br>\nabstract syntax technology is still not use very much, but could open a <br>\nchance to get things really right that did not work so well with plain old <br>\nmacros (aka translations).</p>\n<p>Makarius</p>",
        "id": 294108352,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835957
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Chris,</p>\n<p>I am not a syntax wizard, so I cannot help much with the actual task, <br>\nbut note that there are two monads in the library already, each with its <br>\nown syntax setup for do notation:</p>\n<p>HOL/Library/State_Monad.thy<br>\nHOL/Imperative_HOL/Heap_Monad.thy</p>\n<p>You might want to look at them if you haven't already. In the AFP there <br>\nis also MiniML/Maybe.thy, but with a rather basic syntax.</p>\n<p>If you manage to unify all this somehow, this would be a really cool thing.</p>\n<p>Alex</p>\n<p>Christian Sternagel wrote:</p>",
        "id": 294108387,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835969
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nOn 05/19/2010 10:22 AM, Makarius wrote:</p>\n<blockquote>\n<ul>\n<li>The translation functions (advanced parse translations etc.) only take<br>\ncare of producing proper binders.<br>\nI am not sure what you mean by that... currently I first introduce:</li>\n</ul>\n</blockquote>\n<p>nonterminals<br>\n   do_expr</p>\n<p>syntax<br>\n   ...<br>\n   \"_do_bind\" :: \"pttrn =&gt; 'a =&gt; do_expr =&gt; do_expr\"<br>\n     (\"_ &lt;- _;//_\") [1000, 13, 12] 12)<br>\n   ...</p>\n<p>consts<br>\n   ...<br>\n   bindM :: \"'a =&gt; ('b =&gt; 'c) =&gt; 'c\"<br>\n   ...</p>\n<p>translations<br>\n   ...<br>\n   \"_do_bind x m n\" =&gt; \"CONST bindM m (%x n)\"<br>\n   ...</p>\n<p>and then use Syntax.add_term_check to register a transformation from <br>\nthis general constants to specific ones (that have to be registered <br>\nfirst by e.g.,<br>\nsetup {* Monad.add_monad \"option\" \"option_bind\" \"Some\" *}), depending on <br>\nthe type.</p>\n<blockquote>\n<ul>\n<li>Further transformations within the type-checking phase are done by<br>\nyour own \"check\" operation, which is installed via Syntax.add_term_check</li>\n</ul>\n<p>1) Are those term_checks applied bottom-up to all subterms or do I have <br>\nto use a recursive function that will be applied at the root?</p>\n</blockquote>\n<p>2) Further, I saw the \"stage\" parameter. Do I assume correctly that the <br>\nstage gives the order of the checks and that type checking is done at <br>\nstage 0?</p>\n<p>3) Is add_term_uncheck the symmetric operation before printing?</p>\n<p>4) I find this framework very convenient :D. With few lines of code I <br>\nseem to have a working solution (for the parsing direction and modulo <br>\nthe fact that it is currently necessary to provide typing contraints at <br>\nthe \"right\" places, but that is due to my lack of knowledge about how to <br>\nuse types properly in Isabelle programming).</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294108439,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835987
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 19 May 2010, Christian Sternagel wrote:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>Further transformations within the type-checking phase are done by<br>\nyour own \"check\" operation, which is installed via Syntax.add_term_check</li>\n</ul>\n<p>1) Are those term_checks applied bottom-up to all subterms or do I have to <br>\nuse a recursive function that will be applied at the root?</p>\n</blockquote>\n<p>2) Further, I saw the \"stage\" parameter. Do I assume correctly that the stage <br>\ngives the order of the checks and that type checking is done at stage 0?</p>\n<p>3) Is add_term_uncheck the symmetric operation before printing?</p>\n</blockquote>\n<p>Each check or uncheck operation operates on the whole textual situation, <br>\ni.e. a context and a collection of terms to be treated simultaneously. <br>\nThus you do not only get the root of a single term, but the full chunk of <br>\ntext to be processed, i.e. the super-root.  You can also keep information <br>\nin the result context for later -- in the very end it is discarded, <br>\nthough.</p>\n<p>Stages progress from smaller to larger integer values for check, and <br>\nreverse for uncheck.  At stage 0 there are the \"standard\" check/uncheck <br>\nphases, there is also a final \"fixate\" check at stage 100 to finalize <br>\ntype-inference parameters that are left over. Anything else can be defined <br>\nin the user context, and arbitrary things can be done here, i.e. this <br>\npowerful mechanism needs to be used with some care.</p>\n<p>Since the whole process iterates repeatedly over all stages, your part <br>\nmight get invoked multiple times, until a global fixed-point is reached <br>\n(if it ever happens). This is a bit like a simplifier on abstract syntax, <br>\nbut without any builtin strategy to traverse the terms.</p>\n<blockquote>\n<p>4) I find this framework very convenient :D. With few lines of code I <br>\nseem to have a working solution (for the parsing direction and modulo <br>\nthe fact that it is currently necessary to provide typing contraints at <br>\nthe \"right\" places, but that is due to my lack of knowledge about how to <br>\nuse types properly in Isabelle programming).</p>\n</blockquote>\n<p>Somehow the standard type checking at phase 0 is special: it takes raw <br>\nparser output (where all names and binder scopes are already resolved, but <br>\nlacks type information apart from constraints that happen to be in the <br>\ninput), and produces fully types terms according to the usual <br>\nHindley-Milner scheme.  If you act before, you won't get proper type <br>\ninformation, but afterwards most of it is already finished.  Typically, <br>\nlater check phases merely \"improve\" inferred types by specializing them, <br>\nas is usually done in advanced Haskell-style systems.</p>\n<p>Case 1: You operate after stage 0.  This means that your concrete syntax <br>\nneeds to be mapped to auxiliary combinators etc. that will be accepted by <br>\nthe standard type check.  That result can then be expanded to suitable <br>\nlogical constants by your function. In other words you need to be able to <br>\nmodel your monad language using simply-typed higher-order abstract syntax.</p>\n<p>Case 2: You operate before stage 0.  This means you merely rearrange the <br>\nuser input schematically such that the later stages will synthesize just <br>\nthe right types accidentally.  This is a bit like \"for\" in Scala, where <br>\nthe compiler expands nested comprehensions to certain combinators in an <br>\nuntyped fashion.  (Maybe they now have some papers on the details, I did <br>\nnot find any 1-2 years ago.  There are some basic explanations in the <br>\nScala book by Odersky-et-al.)</p>\n<p>Makarius</p>",
        "id": 294108460,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835993
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 21 May 2010, Christian Sternagel wrote:</p>\n<blockquote>\n<p>Hence here is just my check function:</p>\n<p>fun check_monad ts ctxt =<br>\n   let</p>\n</blockquote>\n<blockquote>\n<p>| subst_monad_app ctxt (Const (@{const_name \"thenM\"}, T), [m, n]) =<br>\n           (case add_monad_type ctxt n (add_monad_type ctxt m []) of<br>\n             typ :: _ =&gt;<br>\n               let<br>\n                 val used = Term.add_free_names n [];<br>\n                 val v = Free (Name.variant used \"x\", dummyT);</p>\n</blockquote>\n<p>At this point it is important to use the proper context to invent fresh <br>\nnames, not just the terms you hold in your hand.  Term.add_free_names and <br>\nName.variant belong to a very old layer of the system.  Use <br>\nVariable.variant_frees or similar -- its implementation may even serve as <br>\nan example how it works with contexts:</p>\n<p>fun variant_frees ctxt ts frees =<br>\n   let<br>\n     val names = Variable.names_of (fold Variable.declare_names ts ctxt);<br>\n     val xs = fst (Name.variants (map #1 frees) names);<br>\n   in xs ~~ map snd frees end;</p>\n<blockquote>\n<p>I) Currently I'm going for Case 2 (of makarius suggestion) and <br>\nregistered the check function at stage 0.</p>\n</blockquote>\n<p>I recommend to use a stage number &lt;&gt; 0.  While there are standard policies <br>\nabout precedence of plugins at the same stage, it is better to make your <br>\nintention fully clear.</p>\n<p>I've heard that you have made some progress off-list.  If there is a nice <br>\nresult emerging here, it is worth posting it again.</p>\n<p>Makarius</p>",
        "id": 294108613,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836030
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHi again!</p>\n<p>I am still tinkering with the monad notation stuff, and since I have now <br>\nspent quite some time, I am not willing to give up anymore :D</p>\n<p>I thought that some code would be good this time, but I'm not sure <br>\nwhether I am allowed to send attachments to the mailing list? Hence here <br>\nis just my check function:</p>\n<p>fun check_monad ts ctxt =<br>\n     let<br>\n       fun map_default f xs =<br>\n         let val ys = map f xs in<br>\n           if exists is_some ys<br>\n             then SOME (map2 the_default xs ys)<br>\n             else NONE<br>\n          end;</p>\n<p>fun subst_monad_app ctxt (Const (@{const_name \"returnM\"}, T), [x]) =<br>\n             let val typ = range_type T<br>\n             in if is_monad_type ctxt typ<br>\n               then SOME (Const (get_return typ ctxt, dummyT) $ x)<br>\n               else more_err ()<br>\n             end<br>\n         | subst_monad_app ctxt (Const (@{const_name \"returnM\"}, T), []) =<br>\n             let val typ = range_type T<br>\n             in if is_monad_type ctxt typ<br>\n               then SOME (Const (get_return typ ctxt, dummyT))<br>\n               else more_err ()<br>\n             end<br>\n         | subst_monad_app ctxt (Const (@{const_name \"bindM\"}, _), [m, f]) =<br>\n             (case add_monad_fun_type ctxt f (add_monad_type ctxt m []) of<br>\n               typ :: _ =&gt;<br>\n                 SOME (Const (get_bind typ ctxt, dummyT) $ m $ f)<br>\n             | [] =&gt; more_err ())<br>\n         | subst_monad_app ctxt (Const (@{const_name \"thenM\"}, T), [m, n]) =<br>\n             (case add_monad_type ctxt n (add_monad_type ctxt m []) of<br>\n               typ :: _ =&gt;<br>\n                 let<br>\n                   val used = Term.add_free_names n [];<br>\n                   val v = Free (Name.variant used \"x\", dummyT);<br>\n                 in<br>\n                   SOME (Const (get_bind typ ctxt, dummyT) $ m $ lambda v n)<br>\n                 end<br>\n               | [] =&gt; more_err ())<br>\n         | subst_monad_app ctxt (t, ts) =<br>\n             (case map_default (subst_monad ctxt) ts of<br>\n               SOME ts' =&gt; SOME (list_comb (t, ts'))<br>\n             | NONE =&gt; NONE)<br>\n       and subst_monad ctxt (Abs (v, T, t)) =<br>\n             (case subst_monad ctxt t of<br>\n               SOME t' =&gt; SOME (Abs (v, T, t'))<br>\n             | NONE =&gt; NONE)<br>\n         | subst_monad ctxt t = subst_monad_app ctxt (strip_comb t);<br>\n     in<br>\n       map_default (subst_monad ctxt) ts<br>\n       |&gt; <a href=\"http://Option.map\">Option.map</a> (rpair ctxt)<br>\n     end;</p>\n<p>(Here, more_err () just tells the user that more type constraints are <br>\nneeded in order to infer the current monad type.)</p>\n<p>I) Currently I'm going for Case 2 (of makarius suggestion) and <br>\nregistered the check function at stage 0. When I add a type contraint <br>\naround a do block, this does always work, however I am not pleased with <br>\nthe few examples that work without any type constraints.</p>\n<p>The tricky part is \"bindM\" (and \"thenM\" is analogeous). Here I know that <br>\nthe arguments m and f (which are of type \"'a m\" and \"'a =&gt; 'b m\" for <br>\nsome monad type \"m\") are already checked. Now, I want to find out, which <br>\nactual bind method I should use instead of \"bindM\" (the function <br>\nget_bind returns the corresponding constant for a given type in a given <br>\ncontext).</p>\n<p>The choice is based on the functions \"add_monad_type\" (for m) and <br>\n\"add_monad_fun_type\" (for f).</p>\n<p>I have mainly tried 2 versions (which do both not work in all cases):</p>\n<p>1) My first try was to collect all types occurring somewhere in a given <br>\nterm (by folding a function that collects all Type's from a given typ, <br>\nover all typs of a term) that are registered as monadic. But then I get <br>\ntyping problems when more than one monad type occurs inside a term, e.g.,</p>\n<p>do {<br>\n   x &lt;- map Some [0..2];<br>\n   return x<br>\n}</p>\n<p>assuming that \"list\" and \"option\" are registered as monadic, my function<br>\nfinds \"'a option\" before \"'a list\" and hence substitutes \"option_bind\", <br>\nwhen \"list_bind\" was needed. It is not immediately clear to me which <br>\nstrategy I should use for finding monad types.</p>\n<p>2) In the other extreme I do just check for the fastype of m and the <br>\nrange type of the fastype of f to be monadic... but then I cannot handle <br>\ncases like, e.g.,</p>\n<p>do {<br>\n   x &lt;- xs;<br>\n   y &lt;- [0..2];<br>\n   return (x, y)<br>\n}</p>\n<p>although, the list monad is the only possibility.</p>\n<p>So I would need a better way to check for the current monad type, based <br>\non m and f.</p>\n<p>A further problem are cases like</p>\n<p>do {<br>\n   let xs = [0 .. 2];<br>\n   x &lt;- xs;<br>\n   y &lt;- ys;<br>\n   return (x, y)<br>\n}</p>\n<p>which is parsed to (using the infix &gt;&gt;= instead of \"bindM\"):</p>\n<p>(%xs. xs &gt;&gt;= (%x. ys &gt;&gt;= (%y. returnM (x, y)))) [0 .. 2]</p>\n<p>So at the actual occurrences of &gt;&gt;= I would have to know the type of the <br>\nbound variable xs. But I do not know how to handle this in Isabelle <br>\n(since bound variables do not contain types).</p>\n<p>I do appreciate any comments and/or suggestions.</p>\n<p>II) I also have some design questions concerning printing for you :)</p>\n<p>I would like to allow both, the combinator notation using &gt;&gt;=, &gt;&gt;, and <br>\nreturn; and the do-notation. As input this is easy: just provide <br>\nnotation for bindM, thenM, and returnM</p>\n<p>notation<br>\n   bindM (infixl \"&gt;&gt;=\" 54) and ...</p>\n<p>For printing it would be nice to let the user decide (or do you have <br>\nbetter suggestions?). Can this be handled with 'modes'? Also, return <br>\nshould only be used when \"monad printing\" is on, since, seeing \"return <br>\nx\" everywhere instead of \"Some x\" (for the option monad) or \"Inr x\" (for <br>\nthe error monad) does not seem to be nice.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294108632,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836036
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nOn 05/21/2010 09:11 PM, Makarius wrote:</p>\n<blockquote>\n<p>On Fri, 21 May 2010, Christian Sternagel wrote:</p>\n<blockquote>\n<p>Hence here is just my check function:</p>\n<p>fun check_monad ts ctxt =<br>\nlet</p>\n</blockquote>\n<blockquote>\n<p>| subst_monad_app ctxt (Const (@{const_name \"thenM\"}, T), [m, n]) =<br>\n(case add_monad_type ctxt n (add_monad_type ctxt m []) of<br>\ntyp :: _ =&gt;<br>\nlet<br>\nval used = Term.add_free_names n [];<br>\nval v = Free (Name.variant used \"x\", dummyT);</p>\n</blockquote>\n<p>At this point it is important to use the proper context to invent fresh<br>\nnames, not just the terms you hold in your hand. Term.add_free_names and<br>\nName.variant belong to a very old layer of the system. Use<br>\nVariable.variant_frees or similar -- its implementation may even serve<br>\nas an example how it works with contexts:</p>\n<p>fun variant_frees ctxt ts frees =<br>\nlet<br>\nval names = Variable.names_of (fold Variable.declare_names ts ctxt);<br>\nval xs = fst (Name.variants (map #1 frees) names);<br>\nin xs ~~ map snd frees end;</p>\n<blockquote>\n<p>I) Currently I'm going for Case 2 (of makarius suggestion) and<br>\nregistered the check function at stage 0.</p>\n</blockquote>\n<p>I recommend to use a stage number &lt;&gt; 0. While there are standard<br>\npolicies about precedence of plugins at the same stage, it is better to<br>\nmake your intention fully clear.<br>\nThe problem is that I have a solution that works when using stage 0. But <br>\nnot on any other stage :). On stage ~1 I get a MATCH exception for a <br>\ncall to range_type (to find out the specific \"return\" to use) and on <br>\nstage 1 I can not use dummyT without getting a TYPE exception.</p>\n</blockquote>\n<p>Here is my new check function (as I said, when registered at stage 0, <br>\nevery example I have tried, did also work). Thanks to alex krauss, I am <br>\nnow using Pattern.rewrite_term, which makes everthing much more <br>\nconvenient. If I understand correctly, since I registered \"check_monad\" <br>\nat stage 0, it is interleaved with type inference... and that is exactly <br>\nwhat I need here.</p>\n<p>fun check_monad ts ctxt =<br>\nlet<br>\n   val thy = ProofContext.theory_of ctxt;</p>\n<p>fun map_default f xs =<br>\n         let val ys = map f xs in<br>\n         if exists is_some ys<br>\n           then SOME (map2 the_default xs ys)<br>\n           else NONE<br>\n         end;</p>\n<p>fun subst_monad ctxt (Const (@{const_name \"returnM\"}, T)) =<br>\n       let val typ = range_type T<br>\n       in if is_monad_type ctxt typ<br>\n         then SOME (Const (get_return typ ctxt, dummyT))<br>\n         else NONE<br>\n       end<br>\n   | subst_monad ctxt (Const (@{const_name \"bindM\"}, T) $ m $ f) =<br>\n       let val mty :: fty :: rty = binder_types T in<br>\n         (case filter (is_monad_type ctxt) (mty :: range_type fty :: rty) of<br>\n           typ :: _ =&gt;<br>\n             SOME (Const (get_bind typ ctxt, dummyT) $ m $ f)<br>\n         | [] =&gt; NONE)<br>\n       end<br>\n   | subst_monad ctxt (Const (@{const_name \"thenM\"}, T) $ m $ n) =<br>\n       (case filter (is_monad_type ctxt) (binder_types T) of<br>\n         typ :: _ =&gt;<br>\n           let<br>\n             val used = Term.add_free_names n [];<br>\n             val v = Free (Name.variant used \"x\", dummyT);<br>\n           in<br>\n             SOME (Const (get_bind typ ctxt, dummyT) $ m $ lambda v n)<br>\n           end<br>\n        | [] =&gt; NONE)<br>\n   | subst_monad ctxt _ = NONE</p>\n<p>fun no_abstract_consts t =<br>\n       let<br>\n         val cs = Term.add_const_names t [];<br>\n         val taboos = [@{const_name \"returnM\"}, @{const_name \"bindM\"}, <br>\n@{const_name \"thenM\"}];<br>\n       in<br>\n         (case inter (op =) cs taboos of<br>\n           [] =&gt; true<br>\n         | _ =&gt; more_err ())<br>\n       end;</p>\n<p>fun check t =<br>\n       let val t' = Pattern.rewrite_term thy [] [subst_monad ctxt] t<br>\n         in if t = t' andalso no_abstract_consts t then NONE else SOME <br>\nt' end;<br>\nin<br>\n   map_default check ts<br>\n   |&gt; <a href=\"http://Option.map\">Option.map</a> (rpair ctxt)<br>\nend;</p>\n<blockquote>\n<p>I've heard that you have made some progress off-list. If there is a nice<br>\nresult emerging here, it is worth posting it again.<br>\nI will :)</p>\n<p>Makarius</p>\n<p>chris</p>\n</blockquote>\n<p>PS: I will change the variable stuff according to your comment... it is <br>\nsometimes difficult to see from the sources, which functions are <br>\nsupposed to be used and which not :D</p>",
        "id": 294108662,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836049
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 21 May 2010, Christian Sternagel wrote:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>I) Currently I'm going for Case 2 (of makarius suggestion) and<br>\nregistered the check function at stage 0.</p>\n</blockquote>\n<p>I recommend to use a stage number &lt;&gt; 0. While there are standard<br>\npolicies about precedence of plugins at the same stage, it is better to<br>\nmake your intention fully clear.<br>\nThe problem is that I have a solution that works when using stage 0. But <br>\nnot on any other stage :). On stage ~1 I get a MATCH exception for a <br>\ncall to range_type (to find out the specific \"return\" to use) and on <br>\nstage 1 I can not use dummyT without getting a TYPE exception.</p>\n</blockquote>\n</blockquote>\n<p>Stage 0 is perfectly OK, if you really mean to be a peer of the standard <br>\ntypecheck mechnism, which seems to be the case here.</p>\n<p>BTW, the exception raised by Term.range_type is the builtin Match of SML, <br>\nnot MATCH (which some other modules define internally). It is important to <br>\nbe hypercritical concerning the naming of any exception with unqualified <br>\nname and without argument, because mispelling will result in a dreaded <br>\ncatch-all pattern.  This would make the meaning of the programm depend on <br>\nthe weather, since various external events are injected as Interrupt <br>\nexception into the regular program executation.</p>\n<blockquote>\n<p>| subst_monad ctxt (Const (@{const_name \"thenM\"}, T) $ m $ n) =<br>\n     (case filter (is_monad_type ctxt) (binder_types T) of<br>\n       typ :: _ =&gt;<br>\n         let<br>\n           val used = Term.add_free_names n [];<br>\n           val v = Free (Name.variant used \"x\", dummyT);<br>\n         in<br>\n           SOME (Const (get_bind typ ctxt, dummyT) $ m $ lambda v n)<br>\n         end<br>\n      | [] =&gt; NONE)<br>\n | subst_monad ctxt _ = NONE</p>\n</blockquote>\n<p>Back again to this part of inventing locally fresh names, which is <br>\nsuprisingly hard to get right in many practical situations.</p>\n<p>In fact, the above is technically right, because you merely feed the name <br>\nto the Term.lambda function, which will then abstract over v that is not <br>\nin the body n.  It is also a bit confusing, because lambda terms work via <br>\nde-Bruijn indices, so you do not need to invent names in most situations <br>\n-- the pretty printer will take care of the renaming if required.</p>\n<p>Above you merely do a dummy abstraction, which usually works by <br>\nincrementing \"loose bounds\" in the body and adding an Abs constructor on <br>\ntop, with a \"comment\" for the bound variable as you like, e.g. \"x\". The <br>\nincrementing can be skipped if the term is \"closed\", which is actually a <br>\nprecondition for the lambda function.  Your subterms seem to be indeed <br>\nclosed like that, because you operate as a plugin to Pattern.rewrite_term <br>\nwhich strips off abstractions before entering the body.</p>\n<p>Interestingly, Pattern.rewrite_term invents auxiliary free variables only <br>\nby looking at the visible term material.  This means there is an implicit <br>\nassumption that the rewrite process will not introduce other fixed <br>\nvariables from the surrounding context.</p>\n<p>Anyway, to cut a long story short, you can just use Term.abs_dummy above <br>\nwithout your own inventing of variables.  Like lambda it assumes a closed <br>\nbody.</p>\n<p>Makarius</p>",
        "id": 294108739,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836073
    }
]