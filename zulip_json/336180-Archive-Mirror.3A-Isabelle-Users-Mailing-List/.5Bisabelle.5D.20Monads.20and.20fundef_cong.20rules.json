[
    {
        "content": "<p>From: Simon Wimmer &lt;<a href=\"mailto:wimmersimon@gmail.com\">wimmersimon@gmail.com</a>&gt;<br>\nDear list,</p>\n<p>a student of mine is trying to build a little utility to automatically<br>\nprovide memoized versions of a class of recursively defined functions (e.g.<br>\nfor dynamic programming).</p>\n<p>We are experimenting with a monadification style, which tries to lift a<br>\nfunction of type<br>\n  ('a =&gt; 'b) =&gt; 'c =&gt; 'd<br>\nto a function of type<br>\n  (('a =&gt; 'b m) =&gt; ('c =&gt; 'd m) m) m.</p>\n<p>This works quite nicely up to the point where we need to fundef_cong rules<br>\nfor termination proofs.<br>\nConsider the following example:</p>\n<p>fun f :: \"nat ⇒ int\" where<br>\n  \"f 0 = 0\"<br>\n| \"f (Suc i) = undefined (map f [0..&lt;Suc i])\"</p>\n<p>If we use a lifted version of map of type<br>\n  ('a =&gt; 'b m) =&gt; 'a list =&gt; 'b list m,<br>\nthen we can obtain a lifted version of f</p>\n<p>fun f' :: \"nat ⇒ int m\" where<br>\n  \"f' 0 = return 0\"<br>\n| \"f' (Suc i) = undefined (map' f' [0..&lt;Suc i])\"</p>\n<p>by using the following fundef_cong rule:</p>\n<p>assumes \"⋀x. x ∈ set xs ⟹ f x = g x\" \"xs = ys\"<br>\n  shows   \"map' f xs = map' g ys\"<br>\n.</p>\n<p>However, what we would really want is to use the combinator map'' of type<br>\n  (('a =&gt; 'b m) =&gt; ('a list =&gt; 'b list m) m) m<br>\nlike this</p>\n<p>function f'' :: \"nat ⇒ int m\" where<br>\n  \"f'' 0 = return 0\"<br>\n| \"f'' (Suc i) = undefined (map'' . (return f'') . (return ([0..&lt;Suc i])))\"<br>\n(. is lifted application)</p>\n<p>We tried to lift the fundef_cong rule to this setting by starting like this</p>\n<p>assumes<br>\n\"⋀x xs'. xs' ∈ set_state xs ⟹ x ∈ set xs' ⟹ f . (return x) = g . (return<br>\nx)\" \"xs = ys\"<br>\nshows  \"map'' . f . xs = map'' . g . ys\"</p>\n<p>If we leave out the assumption, then the function package seems to be able<br>\nto apply the rule and presents us a trivial goal for termination.<br>\nHowever, we do not know how to phrase a correct rule that would be helpful<br>\nfor the function package.<br>\nDoes anyone have an idea on how this could be done?</p>\n<p>Cheers,<br>\nSimon<br>\n<a href=\"/user_uploads/14278/YkvYgGrXbUmAxGCxeVb5VL53/DP_Lifting.thy\">DP_Lifting.thy</a><br>\n<a href=\"/user_uploads/14278/QqOISm4GfZqu9Fug80N2QkAo/Monad.thy\">Monad.thy</a><br>\n<a href=\"/user_uploads/14278/kl-uuOclvBV6rq2uuSsxQddR/Test_Map.thy\">Test_Map.thy</a></p>",
        "id": 294712824,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182751
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Simon,</p>\n<p>Here's a quick guess: In the conclusion of the premises of the fundef_cong rule, the <br>\nhigher-order recursion variable still occurs as an argument to a function. In your <br>\ntheories, I haven't seen any fundef_cong rule for the operator (.). So the function <br>\npackage will use the congruence rule \"cong\" for dealing with (.), which loses the <br>\nconnection between f and x. Have you tried adding a fundef congruence rule for (.), too?</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294712837,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182756
    },
    {
        "content": "<p>From: Simon Wimmer &lt;<a href=\"mailto:wimmersimon@gmail.com\">wimmersimon@gmail.com</a>&gt;<br>\nThank you Andreas, your suggestion at least solved part of the problem.<br>\nI can use a rule like this to get through the termination proof:</p>\n<p>assumes<br>\n    \"⋀x xs'. xs' ∈ set_state xs ⟹ x ∈ set xs' ⟹ f x = g x\" \"xs = ys\"<br>\n  shows \"map⇩T . (return f) . xs = map⇩T . (return g) . ys\"</p>\n<p>However, I was not able to define a fundef congruence rule for (.).<br>\nTrying something like this (not sure if this is correct), gives me an error<br>\nfor COMP in the function command:</p>\n<p>assumes<br>\n    \"⋀ f' g' x' y'. f' ∈ set_state f ⟹ g' ∈ set_state g ⟹ x' ∈ set_state x<br>\n⟹ y' ∈ set_state y<br>\n    ⟹ f' x' = g' y'\"<br>\n  shows \"f . x = g . y\"</p>\n<p>Cheers,<br>\nSimon</p>",
        "id": 294712852,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182762
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Simon,</p>\n<p>Your congruence rule for (.) has the problem that the variables in the conclusion of the <br>\ncongruence rule do not show up in the conclusion of the premise. The function package uses <br>\nthese rules to infer the context in which a function all occurs. When it applies your new <br>\nrule to a schematic goal like</p>\n<p>(map_T . (return f)) . xs = ?rhs</p>\n<p>then the next subgoal will look like</p>\n<p>!!f' g' x' y'. [| ... |] ==&gt; f' x' = g' y'</p>\n<p>where there are no more recursive calls in the conclusion. Thus, it thinks that it has now <br>\nfound all of them, which obviously is not true and later leads to the error, because the <br>\nrecursive call has moved to the assumptions of the goal state.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294712868,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182769
    }
]