[
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\n[Apologies for previous incomplete message]<br>\nAgain, I'm trying to work with affine geometries. It seemed that proving<br>\nthings about general affine geometries might be like proving things about<br>\ngeneral groups, or modules, or other things like that...but because I seem<br>\nto have two type-parameters, the \"class\" approach used in<br>\n<a href=\"http://isabelle.in.tum.de/library/HOL/HOL-Isar_Examples/Group.html\">http://isabelle.in.tum.de/library/HOL/HOL-Isar_Examples/Group.html</a><br>\nwon't work. So I went back to locales. I wanted to say that in a geometry,<br>\nthere are \"points\" and \"lines\", and that a point may or may not be on a<br>\nline. An initial version of this said that Points was an 'a set, and Lines<br>\nwas an 'a set set, but then when I wanted to define \"parallel\" as a<br>\npredicate on pairs of lines, I ended up with a predicate on pairs of 'a<br>\nsets (not all of which are lines). So I backed off and said that point and<br>\nline are types, and there's a predicate, \"meets P l\" that tells whether a<br>\npoint P is on the line l. That seemed to work OK (see the first part of the<br>\ncode below).</p>\n<p>But then I wanted to extend that to include some of the axioms of an affine<br>\ngeometry (see the second locale below).</p>\n<p>I initially wrote axiom a1b, for which I got a \"unification failed\" error.<br>\nThen I wrote a1a, which worked. My questions are, \"Why did Isabelle decide<br>\nthat the names 'a and 'b were better than the ones that I chose, and can I<br>\nprevent this, so that the rest of my work is more readable?\"</p>\n<p>--John</p>\n<p>My minimal example follows.</p>\n<p>section ‹Basic affine geometries›</p>\n<p>theory Affine1<br>\n  imports Main<br>\nbegin</p>\n<p>locale affine_plane_basics =<br>\n  fixes<br>\n    meets :: \"'point ⇒ 'line ⇒ bool\"</p>\n<p>locale affine_plane = affine_plane_basics +<br>\n  assumes<br>\n    a1a: \"⟦ (P::'a) ≠ Q ⟧ ⟹  (∃! (l::'b). meets P l ∧ meets Q  l)\"<br>\n    (* This version fails:<br>\n    a1b: \"⟦ (P::'point) ≠ Q ⟧ ⟹  (∃! (l::'line). meets P l ∧ meets Q  l)\"<br>\n    *)</p>\n<p>...</p>",
        "id": 294748101,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194336
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 31/12/2018 23:02, John F. Hughes wrote:</p>\n<blockquote>\n<p>So I backed off and said that point and<br>\nline are types, and there's a predicate, \"meets P l\" that tells whether a<br>\npoint P is on the line l. That seemed to work OK (see the first part of the<br>\ncode below).</p>\n</blockquote>\n<p>Note that Isabelle sources are formal proof documents, not \"code\". This<br>\nis formal mathematics, not programming. (Our would you call this mail<br>\ntext \"code\", because it was processed on a computer in fixed-width font?).</p>\n<blockquote>\n<p>But then I wanted to extend that to include some of the axioms of an affine<br>\ngeometry (see the second locale below).</p>\n<p>I initially wrote axiom a1b, for which I got a \"unification failed\" error.<br>\nThen I wrote a1a, which worked. My questions are, \"Why did Isabelle decide<br>\nthat the names 'a and 'b were better than the ones that I chose, and can I<br>\nprevent this, so that the rest of my work is more readable?\"</p>\n</blockquote>\n<p>This is due to standard policies of Hindley-Milner type inference. There<br>\nare certain rules for implicit scopes of type variables: sometimes they<br>\nare fixed, sometimes arbitrary. Referring to things with arbitrary types<br>\nin a different context produces most general canonical types,<br>\nenumeration of fresh variable names like 'a, 'b, 'c, ...</p>\n<p>If you want different type names, you can put explicit type constraints<br>\njust in the right spot, e.g. like this:</p>\n<p>locale affine_plane_basics =<br>\n  fixes meets :: \"'point ⇒ 'line ⇒ bool\"</p>\n<p>locale affine_plane =<br>\n  affine_plane_basics meets for meets :: \"'point ⇒ 'line ⇒ bool\" +<br>\n  assumes a1b: \"P ≠ Q ⟹ ∃!l. meets P l ∧ meets Q l\"</p>\n<p>Note that I have removed the pointless type-constraints from the a1b<br>\nproposition.</p>\n<p>Quite often it is better not to want different type variable names, but<br>\nlet the type inference do its business unhindered.</p>\n<p>There is a certain art to work with type-inference such that it does the<br>\nright thing most of the time, without further ado.</p>\n<p>Makarius</p>",
        "id": 294748780,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194581
    }
]