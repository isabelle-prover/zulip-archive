[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHi there,</p>\n<p>I ran into the following problem when generating Haskell code from an <br>\nIsabelle theory.</p>\n<p>I use a custom error monad that has an infix `bind' operator &gt;&gt;=, with <br>\ncorresponding &gt;&gt;.</p>\n<p>In Isabelle I have a function with the following structure:</p>\n<p>fun foo :: \"_\" where \"<br>\nfoo args = (<br>\n   (let x = somethig_of args in (<br>\n     monadic_function_on args<br>\n   )) &gt;&gt; (<br>\n     additional_monadic_stuff_on args<br>\n   )<br>\n)\"</p>\n<p>This is in turn translated to Haskell code that does not have <br>\nparentheses around the `let' construct, i.e., part of the code looks as <br>\nfollows</p>\n<p>bind let {<br>\n     x = something_of args;<br>\n   } in monadic_function_on args<br>\n   (\\xa -&gt; additional_monadic_stuff_on args)</p>\n<p>but it should be</p>\n<p>bind (let {<br>\n     x = something_of args;<br>\n   } in monadic_function_on args)<br>\n   (\\xa -&gt; additional_monadic_stuff_on args)</p>\n<p>How can I tell the code-generator to add the missing parentheses?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294078405,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829804
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<p>the printing of let-expressions for Haskell in Isabelle 2009 is indeed<br>\nbroken.</p>\n<p>There is a possibility to circumvent this.  One is to use the built-in<br>\nmonad pretty printing of the Haskell code generator:</p>\n<blockquote>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>typedecl 'a M</p>\n<p>axiomatization bind :: \"'a M =&gt; ('a =&gt; 'b M) =&gt; 'b M\" (infixl \"»=\" 54)</p>\n</blockquote>\n<p>Specification of the monad (here, just an axiomatic placeholder)</p>\n<blockquote>\n<p>abbreviation<br>\n  chainM :: \"'a M =&gt; 'b M =&gt; 'b M\" (infixl \"»\" 54) where<br>\n  \"f » g =&gt; f »= (%_. g)\"</p>\n</blockquote>\n<p>Means: &gt;&gt; is just syntax for &gt;&gt;=</p>\n<blockquote>\n<p>code_monad bind Haskell</p>\n</blockquote>\n<p>Here \"bind\" is declared as monad operator.</p>\n<blockquote>\n<p>definition \"foo x y = (x »= (%. let z = y a a in z))\"</p>\n<p>export_code foo in Haskell file -</p>\n</blockquote>\n<p>The example yield the following code:</p>\n<p>foo :: forall b a. M b -&gt; (b -&gt; b -&gt; M a) -&gt; M a;<br>\nfoo x y = do {a &lt;- x; let z = y a a; z};</p>\n<p>Do not hesitate to ask further question if you need further hints on this.</p>\n<p>Alternatively, we can use special syntax for bind (which I will explain<br>\non demand).</p>\n<p>If this does not solve your problem either, I will provide you with a<br>\npatch for the Haskell code generator.  The issue will be solved in next<br>\nIsabelle release (though there is no official schedule for this).</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/hwl9RMlA2hNZcbUNJHIJbewx/signature.asc\">signature.asc</a></p>",
        "id": 294078512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829861
    }
]