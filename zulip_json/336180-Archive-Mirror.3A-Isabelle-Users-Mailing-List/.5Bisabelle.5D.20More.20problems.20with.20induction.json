[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nAgain considering the same recdef, that defines some advanced shuffle<br>\noperator:</p>\n<p>consts cil :: \"('a \\&lt;Rightarrow&gt; ('m set \\&lt;times&gt; 'm set)) \\&lt;times&gt; ('a<br>\nlist) \\&lt;times&gt; ('a list) \\&lt;Rightarrow&gt; 'a list set\"</p>\n<p>syntax<br>\n  cons_interleave :: \"'a list \\&lt;Rightarrow&gt; ('a \\&lt;Rightarrow&gt; ('m set<br>\n\\&lt;times&gt; 'm set)) \\&lt;Rightarrow&gt; 'a list \\&lt;Rightarrow&gt; 'a list set\" (\"_<br>\n\\&lt;otimes&gt;\\&lt;^bsub&gt;_\\&lt;^esub&gt; _\" [64,64,64] 64)<br>\ntranslations<br>\n  \"a\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt;b\" == \"cil (\\&lt;alpha&gt;,a,b)\"</p>\n<p>recdef \"cil\" \"measure (\\&lt;lambda&gt;(\\&lt;alpha&gt;,x,y). length x + length y)\"<br>\n  \"[] \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt; \\&lt;^esub&gt; w = {w}\"<br>\n  \"w \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; [] = {w}\"<br>\n  \"e1#w1 \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; e2#w2 = (if fst (\\&lt;alpha&gt; e1)<br>\n\\&lt;inter&gt; foldl (op \\&lt;union&gt;) {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e)<br>\n\\&lt;union&gt; snd (\\&lt;alpha&gt; e)) (e2#w2)) = {} then e1\\&lt;cdot&gt;(w1<br>\n\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; e2#w2) else {}) \\&lt;union&gt;<br>\n                     (if fst (\\&lt;alpha&gt; e2) \\&lt;inter&gt; foldl (op \\&lt;union&gt;)<br>\n{} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e) \\&lt;union&gt; snd (\\&lt;alpha&gt; e))<br>\n(e1#w1)) = {} then e2\\&lt;cdot&gt;(e1#w1 \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; w2)<br>\nelse {})\"</p>\n<p>lemma [simp]: \"w\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt;[] = {w}\" by (cases w,<br>\nauto)</p>\n<p>Now I want to prove the following lemma:<br>\nlemma cil_contains_empty[simp]: \"[] \\&lt;in&gt;<br>\nwa\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt;wb \\&lt;longrightarrow&gt; wa=[] \\&lt;and&gt; wb=[]\"<br>\n  apply (induct rule: cil.induct)<br>\nthis leaves me with some odd subgoals of the form:</p>\n<ol start=\"2\">\n<li>\\&lt;And&gt;\\&lt;alpha&gt; ad ae. ad # ae \\&lt;in&gt; wa<br>\n\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; [] \\&lt;longrightarrow&gt; wa = ad # ae<br>\n\\&lt;and&gt; [] = ad # ae<br>\n  (Consider the last conjunct, []=ad#ae). It obviously does not the same<br>\ncase distinction as in the definition, but fixes wa.</li>\n</ol>\n<p>I have no idea how to get the right unification automatically, my<br>\ncurrent workaround is instantiating the induction rule by hand:<br>\n  apply (rule cil.induct[where P=\"\\&lt;lambda&gt;\\&lt;alpha&gt; wa wb. [] \\&lt;in&gt;<br>\nwa\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt;wb \\&lt;longrightarrow&gt; wa=[] \\&lt;and&gt;<br>\nwb=[]\"])<br>\n  apply auto</p>\n<p>this works, but is many writing overhead and makes the proof look confusing.</p>\n<p>Is there any documentation/tutorial information on how the induct method<br>\nworks and what all the parameters mean (e.g. arbitrary). The<br>\nIsabelle/HOL Tutorial only covers induct_tac.</p>\n<p>Many thanks for any hints again,<br>\n  yours Peter</p>",
        "id": 294052505,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820145
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nSee the isar-ref manual.  Some common patterns are given in <br>\nHOL/Induct/Common_Patterns.thy</p>\n<p>Makarius</p>",
        "id": 294052513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820150
    }
]