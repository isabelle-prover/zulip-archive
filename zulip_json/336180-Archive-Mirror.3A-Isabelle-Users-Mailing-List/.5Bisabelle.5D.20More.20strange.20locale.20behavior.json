[
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:stark@cs.stonybrook.edu\">stark@cs.stonybrook.edu</a>&gt;<br>\nIt seems like with almost anything I try to do with locales,<br>\nI run up against behavior that I have no way to comprehend from<br>\nthe documentation that comes with the Isabelle2014 system.</p>\n<p>Here is my latest example (below and also attached).<br>\nThe interpretation of partial_order inside the sup_semilattice<br>\nlocale context block succeeds, but an attempt to declare<br>\nsup_semilattice as a sublocale of partial_order fails.</p>\n<p>Even though the \"locale tutorial\" says that the final sublocale<br>\nproof will take place in the context of the sup_semilattice locale,<br>\napparently the connection between the parameter sup of that<br>\nlocale and the derived notion le is not retained.<br>\nWhat is also strange is that the identifier le is not completely free:<br>\nif I enter a dummy lemma like <code>have \"le = le\"</code> and CTRL-mouse<br>\nover the \"le\", it shows not a completely generic type but actually<br>\nthe type inherited from the sup_semilattice locale.</p>\n<p>Can anyone explain how I should understand this?  Thanks.</p>\n<p>- Gene Stark</p>\n<p>theory Strange<br>\nimports Main<br>\nbegin</p>\n<p>locale partial_order =<br>\n  fixes le :: \"'a ⇒ 'a ⇒ bool\"<br>\n  assumes le_refl: \"le x x\"<br>\n  and le_antisym: \"le x y ∧ le y x ⟶ x = y\"<br>\n  and le_trans: \"le x y ∧ le y z ⟶ le x z\"</p>\n<p>locale sup_semilattice =<br>\n  fixes I :: 'a and sup :: \"'a ⇒ 'a ⇒ 'a\"<br>\n  assumes sup_unit_left: \"sup I x = x\"<br>\n  and sup_unit_right: \"sup x I = x\"<br>\n  and sup_commute: \"sup x y = sup y x\"<br>\n  and sup_assoc: \"sup x (sup y z) = sup (sup x y) z\"<br>\n  and sup_idem: \"sup x x = x\"<br>\n  begin<br>\n    definition le where \"le x y = (sup x y = y)\"<br>\n    lemma le_refl: \"le x x\" using le_def sup_idem by blast<br>\n    lemma le_antisym: \"⟦ le x y; le y x ⟧ ⟹ x = y\" using le_def sup_commute by auto<br>\n    lemma le_trans: \"⟦ le x y; le y z ⟧ ⟹ le x z\" using le_def sup_assoc by metis</p>\n<p>lemma le_po: \"partial_order le\"<br>\n    proof<br>\n      fix x y z<br>\n      show \"le x x\" using le_refl by auto<br>\n      show \"le x y ∧ le y x ⟶ x = y\" using le_antisym by auto<br>\n      show \"le x y ∧ le y z ⟶ le x z\" using le_trans by blast<br>\n    qed</p>\n<p>interpretation partial_order le using le_po by auto<br>\n  end</p>\n<p>sublocale sup_semilattice ⊆ partial_order<br>\n  proof<br>\n    fix x y z<br>\n    show \"le x x\" using le_refl by auto  (* Fails!  Nitpick gives a counterexample. *)<br>\n    show \"le x y ∧ le y x ⟶ x = y\" using le_antisym by auto<br>\n    show \"le x y ∧ le y z ⟶ le x z\" using le_trans by blast<br>\n  qed</p>\n<p>end<br>\n<a href=\"/user_uploads/14278/X51F18B7H9pMDwMX-W2qpLk5/Strange.thy\">Strange.thy</a></p>",
        "id": 294330822,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930189
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Gene,</p>\n<blockquote>\n<p>Can anyone explain how I should understand this?  Thanks.</p>\n</blockquote>\n<p>there is actually nothing strange here:</p>\n<blockquote>\n<p>sublocale sup_semilattice ⊆ partial_order</p>\n</blockquote>\n<p>Note that on the right on side of »⊆« there is a locale expression, not<br>\na locale name.  To establish the desired correspondence, you have to<br>\ngive an explicit instantiation for the parameter(s) of partial_order:</p>\n<blockquote>\n<p>sublocale sup_semilattice ⊆ partial_order le</p>\n</blockquote>\n<p>Otherwise just default names for fresh variables are instantiated.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/hMV5KauxhWZ78pLlrJSlAh6X/signature.asc\">signature.asc</a></p>",
        "id": 294331146,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660930293
    }
]