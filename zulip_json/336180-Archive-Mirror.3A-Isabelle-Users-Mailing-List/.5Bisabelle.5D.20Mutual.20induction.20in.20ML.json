[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is indeed a bit difficult, because the induct method has accumulated <br>\nso many add-on features over time, and there are many versions of the <br>\nunderlying tactics. In your example, you are using <br>\nInductTacs.induct_rules_tac, which is actually dead code in Isabelle2011 / <br>\nIsabelle2011-1, so it will require some further digging in the history to <br>\nunderstand why it is (still) there.</p>\n<p>Below is my attempt to make use to the actual tactic behind the \"induct\" <br>\nmethod in 45 min ... (using Isabelle2011-1-RC2).  Note that the <br>\nIsabelle/jEdit Prover IDE allows to jump to the ML source of the proof <br>\nmethod definition in ML by hovering with CONTROL/COMMAND overit and <br>\nclicking on the hyperlink (blue underline).</p>\n<p>This wraps up Induct.induct_tac with some sane defaults:</p>\n<p>ML {*<br>\n   fun infer_term x ctxt =<br>\n     let val (T, ctxt') = Proof_Context.inferred_param x ctxt<br>\n     in (Free (x, T), ctxt') end;</p>\n<p>fun induct_tac ctxt xss rule i =<br>\n     let<br>\n       val (tss, ctxt') = (fold_map o fold_map) infer_term xss ctxt;<br>\n       val instss = map (map (fn inst =&gt; SOME (NONE, (inst, false)))) tss;<br>\n     in <a href=\"http://Seq.map\">Seq.map</a> snd o Induct.induct_tac ctxt' false instss [] [] (SOME rule) [] i end;<br>\n*}</p>\n<p>Here is the revised example:</p>\n<p>datatype 'a T1 = A1 \"'a T2\" | B1<br>\n   and 'a T2 = A2 \"'a T1\"</p>\n<p>fun foo1 and foo2 where<br>\n   \"foo1 (A1 a) = foo2 a\"<br>\n| \"foo1 a = a\"<br>\n| \"foo2 (A2 b) = foo1 b\"</p>\n<p>lemma<br>\n   \"foo1 (a::'a T1) = B1\"<br>\n   \"foo2 (b::'a T2) = B1\"<br>\n   apply (induct a and b rule: foo1_foo2.induct)<br>\n     apply simp_all<br>\n   done</p>\n<p>lemma<br>\n   \"foo1 (a::'a T1) = B1\"<br>\n   \"foo2 (b::'a T2) = B1\"<br>\n   apply (raw_tactic {* induct_tac @{context} [[\"a\"], [\"b\"]] @{thms foo1_foo2.induct} 1 *})<br>\n     apply simp_all<br>\n   done</p>\n<p>Makarius</p>",
        "id": 294145621,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847395
    },
    {
        "content": "<p>From: Mathieu Giorgino &lt;<a href=\"mailto:mathieu.giorgino@irit.fr\">mathieu.giorgino@irit.fr</a>&gt;<br>\nHello all,</p>\n<p>I'm wondering what is the right way to apply a mutual induction using a rule <br>\ngenerated by the function package in ML ?</p>\n<blockquote>\n<p>From the function package documentation, I have seen the mutual goals can be <br>\nproved by stating them in parallel (as a conjunction in Pure, if I understand <br>\nwell, unless Isar also comes into play) and then applying the proof method <br>\n\"induct\" on the induction variables with the function induction rule.</p>\n</blockquote>\n<p>However I can't simulate this behavior in ML:<br>\nI have tried \"Induct_Tacs.induct_rules_tac\" in \"Goal.prove\" but it seems it <br>\ncan't be applied to multiple goals.<br>\nI also tried to use \"Induct.induct_tac\" but I don't really understand how I <br>\ncould use a \"cases_tactic\".</p>\n<p>Do you have any hint ?</p>\n<p>I attach an example,</p>\n<p>Thanks in advance,</p>\n<p>Mathieu Giorgino<br>\n<a href=\"/user_uploads/14278/qhXSIL1FIO6XEt7YjASkP332/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294146417,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847650
    }
]