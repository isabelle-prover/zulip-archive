[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHello all,</p>\n<p>I am having trouble understanding the coinduction rule that the <br>\n(co)inductive package produces for mutually recursive definitions. <br>\nHere's an example:</p>\n<p>theory Test imports Nat_Infinity begin</p>\n<p>coinductive even :: \"inat set\"<br>\nand odd :: \"inat set\"<br>\nwhere<br>\n   \"even 0\"<br>\n| \"odd n ==&gt; even (iSuc n)\"<br>\n| \"even n ==&gt; odd (iSuc n)\"</p>\n<p>The only coinduction theorem I was able to find, was even_odd.coinduct, <br>\nbut it looks like this:</p>\n<p>[| ?X ?x ?xa;<br>\n    !!x xa.<br>\n       ?X x xa<br>\n       ==&gt; ~ x &amp; xa = 0 |<br>\n           (EX n. ~ x &amp; xa = iSuc n &amp; (?X True n | odd n)) |<br>\n           (EX n. x &amp; xa = iSuc n &amp; (?X False n | even n)) |]<br>\n==&gt; even_odd ?x ?xa</p>\n<p>Here are my troubles with this rule;</p>\n<ol>\n<li>\n<p>Why is there a boolean parameter x to even_odd and similarly to X?<br>\n    (In case I have three mutually recursive predicates, there are even<br>\n     more booleans floating around!)</p>\n</li>\n<li>\n<p>How can I use this rule to ever prove anything about even or odd<br>\n    (e.g. that Infty is both even and add)?<br>\n    The conclusion only mentions the combined predicate even_odd.<br>\n    Searching for \"even\" or \"odd\" with find_theorems does not produce any<br>\n    theorems that relate even or odd with even_odd other than<br>\n    even_odd.coinduct.</p>\n</li>\n</ol>\n<p>Thanks in advance for any help,</p>\n<p>Andreas</p>",
        "id": 294113347,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837540
    },
    {
        "content": "<p>From: Tambet &lt;<a href=\"mailto:qtvali@gmail.com\">qtvali@gmail.com</a>&gt;<br>\nI replace ?X with function name \"EO\" and add some parentheses:</p>\n<p>[| EO ?x ?xa;<br>\n  !!x xa.<br>\n     EO x xa<br>\n     ==&gt; ~ x &amp; xa = 0 |<br>\n         (EX n. ~ x &amp; xa = iSuc n &amp; (EO True n | odd n)) |<br>\n         (EX n. x &amp; xa = iSuc n &amp; (EO False n | even n)) |]<br>\n==&gt; even_odd ?x ?xa</p>\n<p>For me it seems that ?x is boolean and ?xa is number. Thus, I do the<br>\ncorresponding replacement (for readability, not compileability):</p>\n<p>[| EO isodd n;<br>\n  !!isodd n.<br>\n     EO isodd n<br>\n     ==&gt; (~ isodd) &amp; (n = 0) |<br>\n         (EX m. (~ isodd) &amp; (n = iSuc m) &amp; ((EO True m) | (odd m))) |<br>\n         (EX m. (isodd) &amp; (n = iSuc m) &amp; ((EO False m) | (even m))) |]<br>\n==&gt; even_odd isodd n</p>\n<p>This ((EO True m) | (odd m)) is odd rule then, but it basically says that<br>\n((odd m+1) | (odd m)). As m+1 is n, it's also a conclusion<br>\n(~(odd n - 1) ==&gt; (EO True n)) or, in other words, (~(odd n - 1) ==&gt; (odd<br>\nn)).</p>\n<p>Tambet</p>",
        "id": 294113387,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837552
    }
]