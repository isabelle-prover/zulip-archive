[
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>I see that Named_Target.reinit is gone in 2014-rc0. It seems that it is<br>\nequivalent to leaving to a theory and then entering the target again.<br>\nWhat was its purpose and what is the right way to replace it?</p>\n<p>It seems that it is sometimes necessary to perform these steps to get<br>\nthe simpset updated after changing it in the background theory with<br>\nLocal_Theory.background_theory_result.</p>",
        "id": 294284153,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921299
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 23 Jul 2014, Lars Noschinski wrote:</p>\n<blockquote>\n<p>I see that Named_Target.reinit is gone in 2014-rc0. It seems that it is <br>\nequivalent to leaving to a theory and then entering the target again. <br>\nWhat was its purpose and what is the right way to replace it?</p>\n</blockquote>\n<p>This belongs to the system infrastructure -- user-space tools in <br>\nIsabelle/ML should not be affected by the change.</p>\n<blockquote>\n<p>It seems that it is sometimes necessary to perform these steps to get <br>\nthe simpset updated after changing it in the background theory with <br>\nLocal_Theory.background_theory_result.</p>\n</blockquote>\n<p>This sounds a bit odd, maybe some formerly global-theory tool that was <br>\nupdated a bit too quickly, without really leaving the old ways behind.</p>\n<p>Declarations with the \"simp\" attribute may be done like in Isar source, <br>\nusing the ML antiquotation @{attributes [simp]} with Local_Theory.note, <br>\nfor example.  (Just hypersearch the sources for examples.)</p>\n<p>If the simpset update is some other ML function, not an attribute, you may <br>\nuse Simplifier.map_ss with Local_Theory.declaration, which also allows to <br>\ninsist in a pervasive scope, such that the declaration affects the global <br>\ntheory as well.</p>\n<p>Makarius</p>",
        "id": 294284370,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921354
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nThis is a good opportunity to describe the rationale behind the local<br>\ntheory / target / named target matter in more detail »as it is by now«.</p>\n<p>The fundamental ideas have been presented in »Local Theory<br>\nSpecifications in Isabelle/Isar« by Haftmann/Wenzel; as usual, the<br>\nimplementation is a little bit more involved, and also some extensions<br>\nhave appeared since then, notably nested target contexts and confined<br>\ninterpretation.</p>\n<p>What is a <em>local theory</em>? The extension of a proof context with an<br>\nabstract signature to allow definitional extensions (most prominently,<br>\n<em>define</em> and <em>note</em> – the actual interface can be found as *type<br>\noperations* in Pure/Isar/local_theory.ML).</p>\n<p>A <em>target</em> is a particular implementation of the local theory signature.</p>\n<p>The picture is a little complicated by the possibility to stack<br>\narbitrary many auxiliary contexts on top a target (»context fixes …<br>\nassumes … begin … end« in Isar). However, these merely add variables and<br>\nassumptions in a canonical way; the target at the bottom of this stack,<br>\nthe <em>bottom target,</em> is not really affected by this. So, if we speak<br>\nabout target, we most times refer to a particular bottom target with a<br>\n(possibly empty) stack auf axuiliary contexts on top of it.</p>\n<p>Conceptually, there are two main targets: the theory target and the<br>\nlocale target, which can be seen as the most generic targets possible.</p>\n<p>A slight variant of the locale target is the class target, which adds a<br>\ncanonical interpretation on the theory level. An important class of<br>\ntargets are <em>theory-like targets</em>, which behave almost like the theory<br>\ntarget, but feature slight modifications like additional syntax and a<br>\nconsistency check before leaving the local theory. The overloading and<br>\ninstantiation targets are prominent examples.</p>\n<p>Concerning the concept of *named target. *Each type class and locale in<br>\na theory can be referred to by a string s; if we identify the empty<br>\nstring with the theory itself, Named_Target.init s opens a local theory<br>\nfor the theory / locale / class with the appropriate theory / locale /<br>\nclass target. This »selection by name« manifests in the Isar toplevel<br>\nalso (»context s begin … end«), and hence the prominent status of these<br>\nnamed targets in the system infrastructure.</p>\n<p>An important consequence of the abstract nature of local theories is<br>\nthat only target implementations are allowed to break their abstraction;<br>\nclient code is expected to operate on any kind of local theory<br>\nregardless of the particular (bottom) target. In the Isabelle<br>\ndistribution, there are currently (Isabelle2014-RC0) four spots which<br>\nare candidates for a violation of this principle:</p>\n<p>./Pure/Isar/class_declaration.ML:349:    val proto_sub = case<br>\nNamed_Target.class_of lthy of<br>\n./Pure/Isar/expression.ML:925:  if Named_Target.is_theory lthy<br>\n./Pure/Isar/expression.ML:932:      if Named_Target.is_theory lthy<br>\n./Tools/quickcheck.ML:365:    val some_locale =<br>\nNamed_Target.bottom_locale_of lthy;</p>\n<p>The first one is sane since the class target is allowed to break its own<br>\nabstraction. Number two and three are similar. The last one is indeed a<br>\nlittle bit odd, but since its is some kind of diagnostic device, it is<br>\nmaybe ok.</p>\n<p>Generally, user space tools should refrain from using those<br>\nabstraction-breaking query operations in Named_Target. The same holds<br>\nfor the Named_Target.switch (or its earlier predecessor,<br>\nNamed_Target.reinit) which is a device to master the following situation<br>\nwith an ad-hoc local theory switch which is currently allowed in Isar:</p>\n<p>context s<br>\nbegin</p>\n<p>…</p>\n<p>definition (in t):<br>\n  …</p>\n<p>…</p>\n<p>end</p>\n<p>If client code implements its own target, in most cases it will be a<br>\ntheory-like target. There are two possibilites to approach it:</p>\n<p>a) Something like<br>\n    |&gt; Local_Theory.init naming<br>\n       {define = Generic_Target.define …,<br>\n        notes = Generic_Target.notes Generic_Target.theory_notes,<br>\n        abbrev = Generic_Target.abbrev Generic_Target.theory_abbrev,<br>\n        declaration = K Generic_Target.theory_declaration,<br>\n        subscription = Generic_Target.theory_registration,<br>\n        pretty = …,<br>\n        exit = … #&gt; Local_Theory.target_of #&gt; Sign.change_end_local}<br>\n(cf. Pure/Isar/class.ML) See how Generic_Target provides everything<br>\nneeded to plug together implementations of local theory operations on<br>\nthe spot.</p>\n<p>b) If the target only adds a check or something similar before leaving<br>\nthe local theory, it can also be setup using Named_Target.theory_like_init.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/RLcd3c-VAxKZK4j4t4-R6tr5/signature.asc\">signature.asc</a></p>",
        "id": 294284418,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921373
    }
]