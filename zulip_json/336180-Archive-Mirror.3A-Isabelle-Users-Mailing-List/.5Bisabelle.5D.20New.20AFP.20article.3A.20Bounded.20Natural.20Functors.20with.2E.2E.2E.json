[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nBounded Natural Functors with Covariance and Contravariance<br>\nAndreas Lochbihler and Joshua Schneider</p>\n<p>Bounded natural functors (BNFs) provide a modular framework for the construction <br>\nof (co)datatypes in higher-order logic. Their functorial operations, the mapper <br>\nand relator, are restricted to a subset of the parameters, namely those where <br>\nrecursion can take place. For certain applications, such as free theorems, data <br>\nrefinement, quotients, and generalised rewriting, it is desirable that these <br>\noperations do not ignore the other parameters. In this article, we formalise the <br>\ngeneralisation BNF_CC that extends the mapper and relator to covariant and <br>\ncontravariant parameters. We show that</p>\n<ol>\n<li>BNF_CCs are closed under functor composition and least and greatest fixpoints,</li>\n<li>\n<p>subtypes inherit the BNF_CC structure under conditions that generalise those <br>\nfor the BNF case, and</p>\n</li>\n<li>\n<p>BNF_CCs preserve quotients under mild conditions.</p>\n</li>\n</ol>\n<p>These proofs are carried out for abstract BNF_CCs similar to the AFP entry BNF <br>\nOperations. In addition, we apply the BNF_CC theory to several concrete functors.</p>\n<p><a href=\"https://www.isa-afp.org/entries/BNF_CC.html\">https://www.isa-afp.org/entries/BNF_CC.html</a></p>\n<p>Enjoy!<br>\n<a href=\"/user_uploads/14278/2M5-FjYYiTD0XDUi_N8tdLbg/smime.p7s\">smime.p7s</a></p>",
        "id": 294731029,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188058
    },
    {
        "content": "<p>From: Bertram Felgenhauer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nTobias Nipkow wrote:</p>\n<blockquote>\n<p>Bounded Natural Functors with Covariance and Contravariance<br>\nAndreas Lochbihler and Joshua Schneider<br>\n[...]</p>\n</blockquote>\n<p>I'm not sure if I understand this correctly. Could this bring us closer<br>\nto obtaining a map function for 'a set, and hence for datatypes<br>\ninvolving sets?</p>\n<p>datatype 'a foo = foo \"('a Ã— 'a) set\"</p>\n<p>(* no map_foo is provided since none of the arguments admit recursion *)</p>\n<p>(The argument of set is special in that it admits both a contravariant<br>\nview (by viewing sets as predicates) and a covariant view with the<br>\nf ` X being corresponding map function -- it's the latter that I would<br>\nlike to have as a map function...)</p>\n<p>Cheers,</p>\n<p>Bertram</p>",
        "id": 294731063,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188072
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Bertram,</p>\n<p>You are right. This entry provides exactly the theory for getting such a map function (and <br>\nalso a relator). For your example, you would precisely get the covariant map (but you <br>\nstill cannot do (co)datatype recursion through such non-live covariant arguments). You can <br>\nalso go crazy as in</p>\n<p>datatype ('a, 'b) bar = Bar \"(('a * 'a) set =&gt; 'b) =&gt; 'a list\"</p>\n<p>The construction gives you a map function that is covariant in 'a and contravariant in 'b.</p>\n<p>The entry formalises the constructions for an abstract functor and for a few examples. <br>\nThere's no automation yet, so you have to intelligently copy-n-paste. I have used these <br>\nconstructions and proofs for quite complicated (co)datatypes. Joshua and I have a paper on <br>\nthe theory at ITP this year. A preliminary draft is available on my homepage:</p>\n<p><a href=\"http://www.andreas-lochbihler.de/pub/lochbihlerschneider2018.pdf\">http://www.andreas-lochbihler.de/pub/lochbihlerschneider2018.pdf</a></p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294731072,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188075
    }
]