[
    {
        "content": "<p>From: David Trachtenherz &lt;<a href=\"mailto:trachten@in.tum.de\">trachten@in.tum.de</a>&gt;<br>\nAn additional remark on infinite lists in my entry: I designed them very <br>\npragmatically; the definitions and lemmas are named similar to those for <br>\nfinite lists and also work similar, also w. r. t. lemmas added to the <br>\nsimpset. Some lemmas work even simpler because infinite lists naturally <br>\ndon't need assumptions of the form \"i &lt; length xs\" or \"length xs = <br>\nlength ys\". So I do hope that everybody used to work with finite lists <br>\nwill also be comfortable with this formalization of infinite lists.</p>\n<p>Additionally, the relation and transition between infinite and finite <br>\nlists is very direct: truncating an infinite list returns a finite list, <br>\nappending an infinite list to a finite list returns an infinite list, <br>\nand finite lists can also be prefixes of infinite lists. (For example, I <br>\nused this direct relation in my other entry, AutoFocus-Stream, which <br>\nformalizes AutoFocus stream processing: the computation of an AutoFocus <br>\ncomponent/model/system is an infinite stream of results delivered for an <br>\ninfinite stream of input messages, represented by infinite lists; this <br>\nway we can reason about AutoFocus computations. When truncating the <br>\ninfinite input stream/list, we obtain a finite input stream, represented <br>\nby a finite list, and can not only reason about the resulting finite <br>\ncomputation, but also operationally simulate it using the Isabelle <br>\nevaluation function \"value\" with the finite input stream/list.)</p>\n<p>David</p>\n<p>Andreas Lochbihler wrote:</p>",
        "id": 294129938,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842460
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear David,</p>\n<p>my point was not to criticize your work. I merely wanted to point out that at <br>\npresent, any user has to buy into one of the three versions. Switching from one <br>\nto the other might be difficult because of the small differences, in particular <br>\ndifferent names for constants and lemmas and types of constants. Like you, I <br>\nhave tried to stay close to HOL/List for Coinductive, too. In fact, many <br>\ndefinitions of yours and mine are equivalent. So I wondered whether there is any <br>\ninterest in combining the formalisations into one - and how that would be done.</p>\n<p>Andreas</p>\n<p>David Trachtenherz schrieb:</p>\n<blockquote>\n<p>An additional remark on infinite lists in my entry: I designed them very<br>\npragmatically; the definitions and lemmas are named similar to those for<br>\nfinite lists and also work similar, also w. r. t. lemmas added to the<br>\nsimpset. Some lemmas work even simpler because infinite lists naturally<br>\ndon't need assumptions of the form \"i &lt; length xs\" or \"length xs =<br>\nlength ys\". So I do hope that everybody used to work with finite lists<br>\nwill also be comfortable with this formalization of infinite lists.</p>\n<p>[...]</p>\n<p>David<br>\n</p>\n</blockquote>",
        "id": 294129983,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842476
    },
    {
        "content": "<p>From: David Trachtenherz &lt;<a href=\"mailto:trachten@in.tum.de\">trachten@in.tum.de</a>&gt;<br>\nDear Andreas,</p>\n<blockquote>\n<p>I merely wanted to point out that at present, any user has to buy into <br>\none of the three versions.</p>\n</blockquote>\n<p>This is why I've written the previous mail. I just wanted to point out <br>\nthe options provided (and not provided) in my version of infinite lists <br>\nin the ListInf theory, and why I've made the infinite lists like this. <br>\nWhat I wanted to do was embedding infinite lists into the already <br>\navailable frame of the finite list theory, in fact I didn't even <br>\nintroduce new data types for infinite lists but just operator <br>\ndefinitions and/or abbreviations (especially: types 'a ilist = \"nat =&gt; <br>\n'a\"); the only new data type was the one for generalized lists capable <br>\nof taking both finite and infinite lists (datatype 'a glist = FL \"'a <br>\nlist\" | IL \"'a ilist\").</p>\n<p>As far as I've understood from a first glimpse at your theory (so, <br>\nplease correct me where necessary) you went the way of defining the new <br>\ndata type llist suitable for both finite and infinite lists, and using <br>\nconversion operators between \"standard\" finite lists and llist. <br>\nTherefore, I see some (limited) similarity between llist and glist in my <br>\nListInf, as glist is the only new data type in ListInf and takes both <br>\nfinite and infinite lists; notably I have defined it first of all for <br>\nthe sake of completeness; in fact I used only the pure finite and <br>\ninfinite lists in my other theories (also in the unpublished ones). So <br>\nif I get it right, you have established an elaborate framework for the <br>\nllist data type with special attention to coinduction, while I have <br>\n(intentionally) taken the way of making as few as possible new data type <br>\ndefinitions and rather adding operations and/or lemmas for interpreting <br>\nfunctions \"nat =&gt; 'a\" as infinite lists in a manner making there usage <br>\nas similar as possible to finite lists.</p>\n<blockquote>\n<p>Moreover, both Coinductive and Infinite Lists contain additions to <br>\nNat_Infinity in HOL/Library (theories Coinductive_Nat and Util_NatInf, <br>\nresp.). Interestingly, both of them instantiate the type class minus <br>\nfor inat in exactly same way. Alas, no Isabelle session can import <br>\nboth because that type classes can be instantiated only once. As <br>\nUtil_NatInf's setup for arithmetic is more elaborate than <br>\nCoinductive_Nat's, I suggest to move this to Nat_Infinity in <br>\nIsabelle's library. Is there anyone using Nat_Infinity with other type <br>\nclass instantiations, which would break then?</p>\n</blockquote>\n<p>It would be a pity if the instantiation of the type class minus would <br>\nprevent using both theories simultaneously, because I see absolutely no <br>\nreason why not employing both where useful. If the Isabelle developers <br>\nteam would opt for moving any of the theories from List-Infinite (be it <br>\nconcerning arithmetics, sets, or anything else) to the Isabelle Library, <br>\nno matter whether partially, fully and/or adjusted, I certainly wouldn't <br>\nmind.</p>\n<p>David</p>\n<blockquote>\n<p>Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Dear David,</p>\n<p>I merely wanted to point out that at present, any user has to buy <br>\ninto one of the three versions. Switching from one to the other might <br>\nbe difficult because of the small differences, in particular <br>\ndifferent names for constants and lemmas and types of constants. Like <br>\nyou, I have tried to stay close to HOL/List for Coinductive, too. In <br>\nfact, many definitions of yours and mine are equivalent. So I <br>\nwondered whether there is any interest in combining the <br>\nformalisations into one - and how that would be done.</p>\n<p>Andreas</p>\n<p>David Trachtenherz schrieb:</p>\n<blockquote>\n<p>An additional remark on infinite lists in my entry: I designed them <br>\nvery pragmatically; the definitions and lemmas are named similar to <br>\nthose for finite lists and also work similar, also w. r. t. lemmas <br>\nadded to the simpset. Some lemmas work even simpler because infinite <br>\nlists naturally don't need assumptions of the form \"i &lt; length xs\" <br>\nor \"length xs = length ys\". So I do hope that everybody used to work <br>\nwith finite lists will also be comfortable with this formalization <br>\nof infinite lists.</p>\n<p>Additionally, the relation and transition between infinite and <br>\nfinite lists is very direct: truncating an infinite list returns a <br>\nfinite list, appending an infinite list to a finite list returns an <br>\ninfinite list, and finite lists can also be prefixes of infinite <br>\nlists. (For example, I used this direct relation in my other entry, <br>\nAutoFocus-Stream, which formalizes AutoFocus stream processing: the <br>\ncomputation of an AutoFocus component/model/system is an infinite <br>\nstream of results delivered for an infinite stream of input <br>\nmessages, represented by infinite lists; this way we can reason <br>\nabout AutoFocus computations. When truncating the infinite input <br>\nstream/list, we obtain a finite input stream, represented by a <br>\nfinite list, and can not only reason about the resulting finite <br>\ncomputation, but also operationally simulate it using the Isabelle <br>\nevaluation function \"value\" with the finite input stream/list.)</p>\n<p>David</p>\n<p>Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>It's great to see that people are working with infinite data <br>\nstructures.<br>\nHowever, there are now three different formalisations of (possibly) <br>\ninfinite lists in the AFP: Lazy Lists II by Stefan Friedrich, <br>\nInfinite Lists by David Trachtenherz and Coinductive by myself. At <br>\npresent, they are pairwise incompatible, and each of them has a <br>\ndifferent focus: Lazy Lists II focuses on lists over alphabets, <br>\nInfinite Lists on infinite lists, and Coinductive on coinductive <br>\ndefinitions and proofs.<br>\nI think it would be great if there was just one theory similar to <br>\nHOL/List that unified these three as far as possible such that <br>\nfuture users do not have to pick one (or reinvent their own) and <br>\nrelinquish the other developments.</p>\n<p>Moreover, both Coinductive and Infinite Lists contain additions to <br>\nNat_Infinity in HOL/Library (theories Coinductive_Nat and <br>\nUtil_NatInf, resp.). Interestingly, both of them instantiate the <br>\ntype class minus for inat in exactly same way. Alas, no Isabelle <br>\nsession can import both because that type classes can be <br>\ninstantiated only once. As Util_NatInf's setup for arithmetic is <br>\nmore elaborate than Coinductive_Nat's, I suggest to move this to <br>\nNat_Infinity in Isabelle's library. Is there anyone using <br>\nNat_Infinity with other type class instantiations, which would <br>\nbreak then?</p>\n<p>Andreas </p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294130075,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842495
    }
]