[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nBelow you find 5 new entries, the components of an exceutable and reasonably<br>\nefficient LTL Model Checker. The last entry combines them all. An early version<br>\nwas described in a CAV 2013 paper: <a href=\"http://www.in.tum.de/~nipkow/pubs/cav13.html\">http://www.in.tum.de/~nipkow/pubs/cav13.html</a></p>\n<hr>\n<p>The CAVA Automata Library<br>\nPeter Lammich</p>\n<p>We report on the graph and automata library that is used in the fully verified<br>\nLTL model checker CAVA. As most components of CAVA use some type of graphs or<br>\nautomata, a common automata library simplifies assembly of the components and<br>\nreduces redundancy.</p>\n<p>The CAVA Automata Library provides a hierarchy of graph and automata classes,<br>\ntogether with some standard algorithms. Its object oriented design allows for<br>\nsharing of algorithms, theorems, and implementations between its classes, and<br>\nalso simplifies extensions of the library. Moreover, it is integrated into the<br>\nAutomatic Refinement Framework, supporting automatic refinement of the abstract<br>\nautomata types to efficient data structures.</p>\n<p>Note that the CAVA Automata Library is work in progress. Currently, it is very<br>\nspecifically tailored towards the requirements of the CAVA model checker.<br>\nNevertheless, the formalization techniques presented here allow an extension of<br>\nthe library to a wider scope. Moreover, they are not limited to graph libraries,<br>\nbut apply to class hierarchies in general.</p>\n<p>The CAVA Automata Library is described in the paper: Peter Lammich, The CAVA<br>\nAutomata Library, Isabelle Workshop 2014, to appear.</p>\n<p><a href=\"http://afp.sourceforge.net/entries/CAVA_Automata.shtml\">http://afp.sourceforge.net/entries/CAVA_Automata.shtml</a></p>\n<hr>\n<p>Converting Linear-Time Temporal Logic to Generalized Büchi Automata<br>\nAlexander Schimpf and Peter Lammich</p>\n<p>We formalize linear-time temporal logic (LTL) and the algorithm by Gerth et al.<br>\nto convert LTL formulas to generalized Büchi automata. We also formalize some<br>\nsyntactic rewrite rules that can be applied to optimize the LTL formula before<br>\nconversion. Moreover, we integrate the Stuttering Equivalence AFP-Entry by<br>\nStefan Merz, adapting the lemma that next-free LTL formula cannot distinguish<br>\nbetween stuttering equivalent runs to our setting.</p>\n<p>We use the Isabelle Refinement and Collection framework, as well as the Autoref<br>\ntool, to obtain a refined version of our algorithm, from which efficiently<br>\nexecutable code can be extracted.</p>\n<p><a href=\"http://afp.sourceforge.net/entries/LTL_to_GBA.shtml\">http://afp.sourceforge.net/entries/LTL_to_GBA.shtml</a></p>\n<hr>\n<p>Verified Efficient Implementation of Gabow's Strongly Connected Components Algorithm<br>\nPeter Lammich</p>\n<p>We present an Isabelle/HOL formalization of Gabow's algorithm for finding the<br>\nstrongly connected components of a directed graph. Using data refinement<br>\ntechniques, we extract efficient code that performs comparable to a reference<br>\nimplementation in Java. Our style of formalization allows for re-using large<br>\nparts of the proofs when defining variants of the algorithm. We demonstrate this<br>\nby verifying an algorithm for the emptiness check of generalized Büchi<br>\nautomata, re-using most of the existing proofs.</p>\n<p><a href=\"http://afp.sourceforge.net/entries/Gabow_SCC.shtml\">http://afp.sourceforge.net/entries/Gabow_SCC.shtml</a></p>\n<hr>\n<p>Promela Formalization<br>\nRené Neumann</p>\n<p>We present an executable formalization of the language Promela, the description<br>\nlanguage for models of the model checker SPIN. This formalization is part of the<br>\nwork for a completely verified model checker (CAVA), but also serves as a useful<br>\n(and executable!) description of the semantics of the language itself, something<br>\nthat is currently missing. The formalization uses three steps: It takes an<br>\nabstract syntax tree generated from an SML parser, removes syntactic sugar and<br>\nenriches it with type information. This further gets translated into a<br>\ntransition system, on which the semantic engine (read: successor function) operates.</p>\n<p><a href=\"http://afp.sourceforge.net/entries/Promela.shtml\">http://afp.sourceforge.net/entries/Promela.shtml</a></p>\n<hr>\n<p>A Fully Verified Executable LTL Model Checker<br>\nJavier Esparza, Peter Lammich, René Neumann, Tobias Nipkow, Alexander Schimpf,<br>\nJan-Georg Smaus</p>\n<p>We present an LTL model checker whose code has been completely verified using<br>\nthe Isabelle theorem prover. The checker consists of over 4000 lines of ML code.<br>\nThe code is produced using the Isabelle Refinement Framework, which allows us to<br>\nsplit its correctness proof into (1) the proof of an abstract version of the<br>\nchecker, consisting of a few hundred lines of ``formalized pseudocode'', and (2)<br>\na verified refinement step in which mathematical sets and other abstract<br>\nstructures are replaced by implementations of efficient structures like<br>\nred-black trees and functional arrays. This leads to a checker that, while still<br>\nslower than unverified checkers, can already be used as a trusted reference<br>\nimplementation against which advanced implementations can be tested.</p>\n<p><a href=\"http://afp.sourceforge.net/entries/CAVA_LTL_Modelchecker.shtml\">http://afp.sourceforge.net/entries/CAVA_LTL_Modelchecker.shtml</a></p>\n<hr>",
        "id": 294276927,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919091
    }
]