[
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nSeconded!</p>\n<p>I've been going on about this for years, but haven't been giving it high enough priority.</p>\n<p>Gerwin</p>",
        "id": 294099129,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833227
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<p>A feature that I often miss, especially considering namespace pollution<br>\nproblems. One of the top-candidates on my wish list<br>\nis something like import-qualified, giving the user control over what<br>\nsymbols (and syntax) will be loaded into the toplevel-namespace.</p>\n</blockquote>\n<p>This is a misunderstanding which exhibits the source of the problem:<br>\nsyntax is not bound to namespaces but always global, which makes<br>\npollution pervasive (c.f. the funny (no_)notation declarations for inf<br>\nand sup in the HOL theories -- an Isabelle joke...). We need finer<br>\ncontrol over syntax here.</p>\n<blockquote>\n<p>Currently, the hide-command allows one to hide<br>\nprivate symbols, but the other way round would be more comfortable.</p>\n</blockquote>\n<p>I do not seed this demand as urgent: given that theory developers have<br>\nthought carefully which symbols ought to be hidden / qualified, the user<br>\nis always free to hide additional symbols when needed.</p>\n<blockquote>\n<p>If users want hierarchical module names, why don't we (the Isabelle<br>\ndevelopers) just implement that feature?</p>\n</blockquote>\n<p>I agree that this is desirable.  But I suppose we first should find a<br>\nway to replace the rather archaic session concept by something which is<br>\nless driven by building descriptions in IsaMakefiles and ROOT.MLs, but<br>\nby the implicit structure of hierarchies.</p>\n<p>A somehow related question is how to treat relative imports.  I recall<br>\nthere has been (still is?) much debate on this in the Java and Python<br>\ncommunity, and this has to be considered carefully (maybe inspired by<br>\nScala!?).</p>\n<p>Tapping yet another barrel... ;-)<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Y23O8fWj7_oTopmQW822p8yW/signature.asc\">signature.asc</a></p>",
        "id": 294099330,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833277
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nA related issue: we have to encourage ourselves to factor out generic<br>\nformalisations from applications, as Tobias pointed out.  From my<br>\nperspective the four major obstacles are:</p>\n<ul>\n<li>little reputation in the strictly scientific sense;</li>\n<li>no real user interface support for refactoring activities;</li>\n<li>\n<p>difficult to tinker with the bootstrap theories above Main.thy, even<br>\nfor developers (a typical candidate would be List.thy);</p>\n</li>\n<li>\n<p>incoherence and duplication in existing theories themselves, which<br>\nmake it difficult to decide what \"the\" way for contributed things<br>\nactually is.</p>\n</li>\n</ul>\n<p>But this leaves still room for contributions to HOL/Library or separate<br>\nAFP articles.  It would be interesting to hear experiences and comments<br>\nfrom users who have tried to factor out library theories from their<br>\napplications -- successes and failures.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/TfCnLWAfc8Ni9rGggUoICEpP/signature.asc\">signature.asc</a></p>",
        "id": 294099356,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833283
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nWell, I did give it a high priority, but it is technically very difficult. <br>\nIn principle we already have sufficient infrastructure to control <br>\nvisibility, or limit all kinds of \"declarations\" (syntax, hints to proof <br>\ntools) to a certain scope.  It is all part of the \"local theory\" <br>\ninfrastructure.</p>\n<p>Unfortunately, we are still stuck halfway in localizing everything -- this <br>\nrefers to specification packages in the main library (datatype, <br>\nnominal_datatype etc.).  Then the toplevel theory context can be treated <br>\nas just another local theory target, and benefit from additional control <br>\nover when and where declarations actually hit the user context.</p>\n<p>I am in the middle of a major effort to work towards that again. <br>\nNonetheless, it will take several more rounds to get there eventually. <br>\nEven worse, I recently see tendencies in user tools to forget about proper <br>\nlocality and go back to global operations on the bare metal of the raw <br>\ntheory context.</p>\n<p>Makarius</p>",
        "id": 294099446,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833320
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nBetter use 'notation' / 'no_notation' which perform static checking of the <br>\nterm constants involved.  The more primitive 'syntax' / 'no_syntax' is <br>\nonly needed for very special syntax table manipulations.</p>\n<p>Makarius</p>",
        "id": 294099485,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833332
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThere are already well-established concepts of long names, name bindings, <br>\nnaming context, name spaces, which are used everywhere except for the <br>\ntheory database.  So one merely needs to make theories conform to the <br>\nestablished scheme, and somehow link up with the theory loader.</p>\n<p>All of this is completely non-trivial.</p>\n<p>Nonetheless, it should happen eventually, and without putting the system <br>\ninto an undefined state.</p>\n<p>Makarius</p>",
        "id": 294099517,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833338
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nOn 22/02/2010, at 8:10 PM, Florian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>A feature that I often miss, especially considering namespace pollution<br>\nproblems. One of the top-candidates on my wish list<br>\nis something like import-qualified, giving the user control over what<br>\nsymbols (and syntax) will be loaded into the toplevel-namespace.</p>\n</blockquote>\n<p>This is a misunderstanding which exhibits the source of the problem:<br>\nsyntax is not bound to namespaces but always global, which makes<br>\npollution pervasive (c.f. the funny (no_)notation declarations for inf<br>\nand sup in the HOL theories -- an Isabelle joke...). We need finer<br>\ncontrol over syntax here.</p>\n</blockquote>\n<p>Yes, we do. </p>\n<p>We don't need to do everything at once, though. We'd still be in a well-defined, better state if we could just treat normal names (thms, consts, types) in theory name spaces.</p>\n<blockquote>\n<blockquote>\n<p>Currently, the hide-command allows one to hide<br>\nprivate symbols, but the other way round would be more comfortable.</p>\n</blockquote>\n<p>I do not seed this demand as urgent: given that theory developers have<br>\nthought carefully which symbols ought to be hidden / qualified, the user<br>\nis always free to hide additional symbols when needed.</p>\n</blockquote>\n<p>This requires the user to know everything in the libraries (and track all syntax changes over library versions). Much better to be able to import only what you want. </p>\n<p>In our project we have really bad cases of name space pollution (three large specifications describing the same thing, names do get scarce quickly). The conceptual problem is long solved in other languages. We \"just\" need to implement one of the solutions.</p>\n<blockquote>\n<blockquote>\n<p>If users want hierarchical module names, why don't we (the Isabelle<br>\ndevelopers) just implement that feature?</p>\n</blockquote>\n<p>I agree that this is desirable.  But I suppose we first should find a<br>\nway to replace the rather archaic session concept by something which is<br>\nless driven by building descriptions in IsaMakefiles and ROOT.MLs, but<br>\nby the implicit structure of hierarchies.</p>\n</blockquote>\n<p>I see that as a fairly orthogonal problem (not that it shouldn't be addressed at some point). The sessions really only govern what theories get loaded when. All actual dependencies and data are tracked on the theory level by Isabelle already anyway. I'd rate proper name spaces a much higher priority.</p>\n<blockquote>\n<p>A somehow related question is how to treat relative imports.  I recall<br>\nthere has been (still is?) much debate on this in the Java and Python<br>\ncommunity, and this has to be considered carefully (maybe inspired by<br>\nScala!?).</p>\n</blockquote>\n<p>In terms of name space handling, I so far like the Haskell model best. This is something that can easily be discussed and tweaked, though (almost as hard as concrete syntax ;-))). The real problem will be down at the technical end as Makarius writes.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294099664,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833375
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThis theory provides functions for finding the index of an element in a<br>\nlist, by predicate and by value.</p>\n<p><a href=\"http://afp.sourceforge.net/entries/List-Index.shtml\">http://afp.sourceforge.net/entries/List-Index.shtml</a></p>\n<hr>\n<p>Above I have intentionally not used the word \"article\" but \"theory\" to<br>\nemphasize that this is a small contribution (a single theory of modest<br>\nsize) - but a reusable one! I would like to use this opportunity to<br>\nremind readers of this list of the purpose of the AFP:</p>\n<p>\"The Archive of Formal Proofs is a collection of proof libraries,<br>\nexamples, and larger scientific developments.\"</p>\n<p>At the moment the majority of contributions are large (sometimes<br>\nimpressively so), monolithic developments. Very rarely are parts of such<br>\ndevelopments reused elsewhere. That is, the library aspect is<br>\nunderdeveloped. The above theory \"List Index\" used to be hidden in the<br>\narticle \"Jinja is not Java\" and I have (after 5 years!) finally gotten<br>\naround to making it a separate contribution.</p>\n<p>This is a call for reusable AFP entries. I am sure many of you have such<br>\ntheories hidden away in their drawers (or their AFP entries): Do take<br>\nthe time to polish and submit them to the AFP (or refactor some existing<br>\nAFP article), for the benefit of the whole community (and your fame).</p>\n<p>Don't think publication, think reuse!</p>\n<p>Sorry about getting carried away ;-)</p>\n<p>Tobias</p>",
        "id": 294102205,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834127
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nMy immediate plea is for modular library components. Having those as<br>\ntop-level entries dramatically increases the likelyhood that they are<br>\nreused.</p>\n<p>But you are quite right: Hackage offers some things worth emulating:</p>\n<ul>\n<li>A listing of packages by category</li>\n<li>cabal<br>\nA complication is that Isabelle does not support hierarchical module<br>\nnames in the way Haskell (or Java or ...) does.</li>\n</ul>\n<p>Tobias</p>\n<p>Simon Winwood schrieb:</p>",
        "id": 294102229,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834133
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nTobias Nipkow wrote:<br>\nA feature that I often miss, especially considering namespace pollution<br>\nproblems. One of the top-candidates on my wish list<br>\nis something like import-qualified, giving the user control over what<br>\nsymbols (and syntax) will be loaded into the toplevel-namespace.<br>\nRelated to this would be the possibility to specify the public interface<br>\nof a theory. Currently, the hide-command allows one to hide<br>\nprivate symbols, but the other way round would be more comfortable.</p>\n<p>Peter</p>",
        "id": 294102244,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834139
    },
    {
        "content": "<p>From: Simon Winwood &lt;<a href=\"mailto:sjw@cse.unsw.edu.au\">sjw@cse.unsw.edu.au</a>&gt;<br>\nPerhaps a useful model to emulate is Hackage.  For those who don't know, <br>\nhackage is a website (similar to the AFP) for hosting haskell packages.  One thing that <br>\nmakes it so useful is the cabal utility --- somewhat like debian's apt tool --- which<br>\nallows you to download a package and all its dependencies automatically.  This seems <br>\nto encourage both reuse and participation.</p>\n<p>Whether or not this would work for the Isabelle community is debatable --- the <br>\nthe haskell community is much larger.  Having said that, we might be able to co-opt <br>\nsome of the tech used in cabal and hackage ...</p>\n<p>Simon</p>",
        "id": 294102250,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834141
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nIf users want hierarchical module names, why don't we (the Isabelle<br>\ndevelopers) just implement that feature?</p>\n<p>The implementation wouldn't involve much:</p>\n<ol>\n<li>\n<p>Make the dot \".\" a legal character in module names.</p>\n</li>\n<li>\n<p>Define a new mapping from module names to filepaths, so that<br>\n\"imports A.B.C\" makes Isabelle load the file \"~/A/B/C.thy\", where \"~\"<br>\nis filled in with some directory from the search path.</p>\n</li>\n</ol>\n<p>The hard part would be social, rather than technical: Deciding how to<br>\norganize and populate the hierarchy. But we wouldn't have to switch<br>\nover everything at once---we could flesh out the hierarchy gradually,<br>\nwith input from the user community, and move libraries to their new<br>\nplaces in the namespace one at a time. I think this would work, and<br>\nsolving the problem of module name clashes would remove one big<br>\nobstacle to sharing Isabelle libraries.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294102274,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834155
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nYes!</p>\n<p>Besides the flat module namespace, I think that syntax clashes are the<br>\nother big obstacle to sharing Isabelle libraries. I have experienced<br>\nthis problem from both sides.</p>\n<p>As a user importing other Isabelle libraries, I have often been<br>\nconstrained in the choice of syntax to use for my own theories,<br>\nbecause so many useful bits of syntax are already taken by something<br>\nin Isabelle/HOL. For example, if I use \"_ [_ / _]\" as a notation for<br>\nsubstitution in one of my own theories, this causes ambiguous parse<br>\nwarnings, due to clashes with the List library. This is especially<br>\nannoying when my theory does not use lists at all!</p>\n<p>As an implementer of Isabelle libraries, adding special syntax for<br>\nconstants is quite worrisome: What if the end-user of this library is<br>\nalready using the same syntax for something else? This is the reason<br>\nwhy RealVector.thy doesn't define the standard \"||x||\" syntax for<br>\n\"norm x\" (I tried adding it once, but it clashed with another<br>\nlibrary), and Library/Inner_Product.thy doesn't define an infix-dot<br>\nnotation for the inner product.</p>\n<p>Of course, I can always define nice syntax to use within the library<br>\nitself, and then use \"no_syntax\" at the end to avoid potential clashes<br>\nwith user theories. But some users might actually want to use my<br>\nsyntax! It seems silly to have the <em>library</em> decide for all users<br>\nwhether or not some bit of syntax will be visible to them. Obviously,<br>\nthis choice should left to each user of the library, as Peter<br>\nsuggests.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294102291,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834159
    }
]