[
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Dienstag, den 18.08.2015, 21:23 +0200 schrieb Esseger:</p>\n<blockquote>\n<p>If ?f is simple enough, it suffices to do</p>\n<p>have \"incseq ?f\" by ...<br>\nmoreover have \"⋀i. AE x in M. 0 ≤ ?f i x\" by ...<br>\nmoreover have \"⋀i. ?f i ∈ borel_measurable M\" by ...<br>\nultimately have \"(∫⇧+ x. (SUP i. ?f i x) ∂M) = (SUP i. integral⇧N M (?f <br>\ni))\" using nn_integral_monotone_convergence_SUP_AE_incseq by force</p>\n<p>which has no need for additional notations, and in which the flow of <br>\nideas is clear. Unfortunately, when ?f starts being complicated, force <br>\ndoes not succeed.</p>\n</blockquote>\n<p>Lars already mentioned the use of proof-blocks. But in this specific<br>\ncase it should also be possible to use</p>\n<p>by (rule nn_integral_monotone_convergence_SUP_AE_incseq)</p>\n<p>directly to prove the last have. \"force\" needs to find the instantiation<br>\nfor the theorem provided by using, which gets difficult for big<br>\nterms ?f.</p>\n<p>The proof block has one advantage: you can concentrate on the<br>\nnon-automatic part and hope that everything else works automatic.<br>\nnn_integral_monotone_convergence_SUP_AE_incseq is a good example:<br>\nusually 0 &lt;= f x and the measurability proof work automatic (the later<br>\nhopefully when the measurability assumptions are annotated with<br>\n[measurable]). Then you can write:</p>\n<p>have \"(∫⇧+ x. (SUP i. ?f i x) ∂M) = (SUP i. integral⇧N M (?f i))\"<br>\n  proof (rule nn_integral_monotone_convergence_SUP_AE_incseq)<br>\n    show \"incseq ?f\" by ...<br>\n  qed auto</p>\n<blockquote>\n<p>2) In the middle of proofs, once a lot of context was fixed, I needed to<br>\ndo inductive constructs. But I did not find how to define recursive<br>\nfunctions in the middle of a proof, so I had to define a helper function<br>\noutside of the body of the proof. This is not satisfactory since this<br>\nhelper function is completely useless (and impossible to understand)<br>\noutside of the context of the proof, and should really not be in the<br>\nglobal namespace.</p>\n</blockquote>\n<p>Yes, this is very unfortunate. In my experience for analysis simple<br>\ninductive definitions are not enough (i.e. the rec_nat or rec_list etc<br>\nmentioned by others). For more complicated constructions there are also<br>\nthe choice theorems: choice, dependent_nat_choice, or<br>\ndependendent_wf_choice (for a well-founded definition).</p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294649938,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165696
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 18/08/2015 22:40, Larry Paulson wrote:</p>\n<blockquote>\n<p>A lot is missing, for sure. Contributions definitely welcome!</p>\n</blockquote>\n<p>Very much so! If you (Esseger) happen to have a teaching position, consider <br>\nstudent projects in this area.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Larry Paulson</p>\n<p>On 18 Aug 2015, at 20:23, Esseger &lt;<a href=\"mailto:esseger@free.fr\">esseger@free.fr</a>&gt; wrote:</p>\n<blockquote>\n<p>I would say the main problem is precisely to formalize the results (say, a little bit of functional analysis and spectral theory...)</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/xCet61FQlFFli1scZemZgT6Q/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294649962,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165702
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nI agree with the suggestions of Johannes and Lars. You might also try<br>\nsomething along the lines of</p>\n<p>by (force intro: nn_integral_monotone_convergence_SUP_AE_incseq)</p>\n<p>or</p>\n<p>by (intro nn_integral_monotone_convergence_SUP_AE_incseq) (auto ...)</p>\n<p>This is often useful, if you don't want to spell out all of the<br>\nassumptions automatically.</p>\n<p>-- Lars</p>",
        "id": 294650000,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165714
    },
    {
        "content": "<p>From: Esseger &lt;<a href=\"mailto:esseger@free.fr\">esseger@free.fr</a>&gt;<br>\nDear Isabelle users,</p>\n<p>I played recently with Isabelle/HOL, to see if it was possible to <br>\nformally prove a nice mathematical theorem I have recently established. <br>\nMy conclusion is that the system is excellent, since mathematicians with <br>\nalmost no computer science background can use it, but there are still <br>\ntoo many missing mathematical bricks (which, hopefully, will be covered <br>\nwith time) for research mathematics. In any case, it was a lot of fun, <br>\nand very interesting. I will certainly come back later to it, to add <br>\nmore results to what I have already proved.</p>\n<p>Along the way, I stumbled across some difficulties. I solved them in a <br>\nnon-satisfactory way, so I wanted to ask if there are better practices:</p>\n<p>1) In the middle of proofs, I often needed to prove statements of the <br>\nform \"!!n. P n\", by induction, or by case analysis.<br>\nI proved them as follows:</p>\n<p>have \"!!n. P n\"<br>\nproof -<br>\n   fix n<br>\n   show \"P n\"<br>\n   proof (induction n)<br>\n     ...<br>\n   qed<br>\nqed</p>\n<p>This looks like too much boilerplate, and from the mathematical point of <br>\nview it is definitely not the right thing to fix n before doing an <br>\ninduction (in which n is varying). So, is there a better way? Something like</p>\n<p>have \"!!n. P n\"<br>\nproof (?????, induction n)<br>\n   ...<br>\nqed</p>\n<p>2) In the middle of proofs, once a lot of context was fixed, I needed to <br>\ndo inductive constructs. But I did not find how to define recursive <br>\nfunctions in the middle of a proof, so I had to define a helper function <br>\noutside of the body of the proof. This is not satisfactory since this <br>\nhelper function is completely useless (and impossible to understand) <br>\noutside of the context of the proof, and should really not be in the <br>\nglobal namespace.</p>\n<p>So, is there a way to define recursive functions inside a proof?</p>\n<p>3) In an Isar proof, is there a way to refer to previous statements in <br>\nan OF clause? More specifically, consider</p>\n<p>have *: \"P\" by auto<br>\nhave \"Q\" using foo[OF *] by auto</p>\n<p>where P is some complicated statement. I would like to write this as</p>\n<p>have \"P\" by auto<br>\nthen have \"Q\" using foo[OF this] by auto</p>\n<p>But this fails. Is there a way to make it work, replacing \"this\" by <br>\nsomething else?</p>\n<p>Same thing with \"moreover\" statements: is it possible to write something <br>\nlike:</p>\n<p>have \"P1\" by auto<br>\nmoreover have \"P2\" by auto<br>\nmoreover have \"P3\" by auto<br>\nultimately have \"Q\" using foo[OF this-1, OF this-2, OF this-3] by auto</p>\n<p>Two additional comments:</p>\n<p>4) \"theorem\", \"lemma\" and \"corollary\" are available, but it seems that <br>\nmost theories use \"lemma\" 99% of the time. Maybe adding \"proposition\" <br>\n(and maybe \"example\") would help a little bit to have a bigger scale of <br>\nstatements, for more expressiveness.</p>\n<p>5) When I knew that some statement foo would be helpful to prove a <br>\nproperty P, I would write<br>\nhave \"P\" using foo<br>\nand then call sledgehammer on it. Very often, I would get results of the <br>\nform:<br>\nproof reconstruction failed: \"by (metis bar)\"</p>\n<p>Most of the time, \"by (metis foo bar)\" would do the job, so I guess the <br>\nproblem is an excessive minimization, assuming wrongly that \"using foo <br>\nby (metis bar)\" is the same as \"by (metis foo bar)\"...</p>\n<p>Any comment welcome!<br>\nEsseger</p>",
        "id": 294652481,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166669
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nQuite a lot in your question! But to answer this bit, you can refer to the theorem P as <code>P</code>.</p>\n<p>Incidentally, I also vote for “proposition”. I gather that to a mathematician, a proposition is a routine but interesting result, while a lemma is a stepping-stone that is of no interest in its own right.</p>\n<p>Larry Paulson</p>",
        "id": 294652483,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166670
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Esseger,</p>\n<blockquote>\n<p>I played recently with Isabelle/HOL, to see if it was possible to<br>\nformally prove a nice mathematical theorem I have recently established.<br>\nMy conclusion is that the system is excellent, since mathematicians with<br>\nalmost no computer science background can use it, but there are still<br>\ntoo many missing mathematical bricks (which, hopefully, will be covered<br>\nwith time) for research mathematics. In any case, it was a lot of fun,<br>\nand very interesting. I will certainly come back later to it, to add<br>\nmore results to what I have already proved.</p>\n</blockquote>\n<p>that is nice to hear! The community is always interested in use cases and<br>\nfeedback from non-computer-scientists.</p>\n<blockquote>\n<p>1) In the middle of proofs, I often needed to prove statements of the<br>\nform \"!!n. P n\", by induction, or by case analysis.<br>\nI proved them as follows:</p>\n<p>have \"!!n. P n\"<br>\nproof -<br>\n   fix n<br>\n   show \"P n\"<br>\n   proof (induction n)<br>\n     ...<br>\n   qed<br>\nqed</p>\n</blockquote>\n<p>Try this instead:</p>\n<p>{<br>\n    fix n<br>\n    show \"P n\"<br>\n      proof (induction n)<br>\n        ...<br>\n      qed<br>\n  }</p>\n<p>The effect will be the roughly same: You will have proven the predicate<br>\n\"P\" for all arguments. As a general rule of thumb: Avoid the \"!!\"<br>\nquantifier on the right-hand side of an implication.</p>\n<p>(The formal description of these \"proof blocks\" is in Sec 6.1.2 of<br>\n&lt;<a href=\"https://isabelle.in.tum.de/dist/Isabelle2015/doc/isar-ref.pdf\">https://isabelle.in.tum.de/dist/Isabelle2015/doc/isar-ref.pdf</a>&gt;.)</p>\n<blockquote>\n<p>This looks like too much boilerplate, and from the mathematical point of<br>\nview it is definitely not the right thing to fix n before doing an<br>\ninduction (in which n is varying).</p>\n</blockquote>\n<p>I think your intuition about what the phrase \"fix a variable\" means in<br>\nIsabelle is not accurate. In this example, you merely introduce a variable<br>\ninto the scope, so that the system knows about it. You could also leave<br>\nthe \"fix n\" off, which will make Isabelle/jEdit render the variable<br>\ndistinctly to alert you that you're using something unknown.</p>\n<blockquote>\n<p>2) In the middle of proofs, once a lot of context was fixed, I needed to<br>\ndo inductive constructs. But I did not find how to define recursive<br>\nfunctions in the middle of a proof, so I had to define a helper function<br>\noutside of the body of the proof. This is not satisfactory since this<br>\nhelper function is completely useless (and impossible to understand)<br>\noutside of the context of the proof, and should really not be in the<br>\nglobal namespace.</p>\n<p>So, is there a way to define recursive functions inside a proof?</p>\n</blockquote>\n<p>No, but there's a different solution. You can write it like this:</p>\n<p>context begin</p>\n<p>private fun helper where ...</p>\n<p>lemma bla<br>\n    ... use helper ...</p>\n<p>end</p>\n<p>After the end of the context block, the \"helper\" function is inaccessible.<br>\nSee also Sec 5.2 of the aforementioned manual.</p>\n<p>Hope that helps.<br>\nLars</p>",
        "id": 294652501,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166677
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn occasion I have used the primitive recursion operator that comes with each <br>\ndata type. This way you can defined a recursive function nonrecursively. <br>\nHowever, the result tends to be obscure.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/LtFuB492THlVSG2WUyTDfgFF/smime.p7s\">smime.p7s</a></p>",
        "id": 294652517,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166684
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 18.08.2015 18:26, Esseger wrote:</p>\n<blockquote>\n<p>Dear Isabelle users,</p>\n<p>I played recently with Isabelle/HOL, to see if it was possible to<br>\nformally prove a nice mathematical theorem I have recently established.<br>\nMy conclusion is that the system is excellent, since mathematicians with<br>\nalmost no computer science background can use it, but there are still<br>\ntoo many missing mathematical bricks (which, hopefully, will be covered<br>\nwith time) for research mathematics. In any case, it was a lot of fun,<br>\nand very interesting. I will certainly come back later to it, to add<br>\nmore results to what I have already proved.</p>\n</blockquote>\n<p>Thanks a lot for the feedback! May I ask what you used as learning<br>\nresources?</p>\n<p>If you want to build on some missing result, which you do want to<br>\nformalize, it is sometimes an option to just assume the result (using a<br>\nlocale).</p>\n<blockquote>\n<p>Along the way, I stumbled across some difficulties. I solved them in a<br>\nnon-satisfactory way, so I wanted to ask if there are better practices:</p>\n<p>1) In the middle of proofs, I often needed to prove statements of the<br>\nform \"!!n. P n\", by induction, or by case analysis.<br>\nI proved them as follows:</p>\n<p>have \"!!n. P n\"<br>\nproof -<br>\n  fix n<br>\n  show \"P n\"<br>\n  proof (induction n)<br>\n    ...<br>\n  qed<br>\nqed</p>\n</blockquote>\n<p>I would state this as</p>\n<p>{ fix n have \"P n\"<br>\n  proof (induction n)<br>\n    ..<br>\n  qed<br>\n}</p>\n<p>which admittedly is still a bit boilerplatey.  In the next Isabelle<br>\nrelease, it might be possible to write 'have \"P n\" for n' instead.</p>\n<blockquote>\n<p>2) In the middle of proofs, once a lot of context was fixed, I needed to<br>\ndo inductive constructs. But I did not find how to define recursive<br>\nfunctions in the middle of a proof, so I had to define a helper function<br>\noutside of the body of the proof. This is not satisfactory since this<br>\nhelper function is completely useless (and impossible to understand)<br>\noutside of the context of the proof, and should really not be in the<br>\nglobal namespace.</p>\n<p>So, is there a way to define recursive functions inside a proof?</p>\n</blockquote>\n<p>Unfortunately, you cannot use primrec or fun inside a proof. If you want<br>\nprimitive recursion on datatypes, you can use the recursion function<br>\ndefined by the datatype package. E.g., for a list datatype defined as</p>\n<p>datatype 'a mylist = My_Nil | My_Cons 'a \"'a mylist\"</p>\n<p>you could use</p>\n<p>def mylen == \"rec_mylist 0 (λx' xs' rec. rec + 1)\"</p>\n<p>to define a recursive length function inside a proof. There is also the<br>\nwhileOption combinator (from ~~/src/HOL/Library/While_Combinator).</p>\n<blockquote>\n<p>3) In an Isar proof, is there a way to refer to previous statements in<br>\nan OF clause? More specifically, consider</p>\n<p>have *: \"P\" by auto<br>\nhave \"Q\" using foo[OF *] by auto</p>\n<p>where P is some complicated statement. I would like to write this as</p>\n<p>have \"P\" by auto<br>\nthen have \"Q\" using foo[OF this] by auto</p>\n<p>But this fails. Is there a way to make it work, replacing \"this\" by<br>\nsomething else?</p>\n</blockquote>\n<p>In most cases, I would use the \\&lt;open&gt;P\\&lt;close&gt; syntax suggested by<br>\nLarry. \"this\" is only bound before the have, you could write</p>\n<p>have \"P\" by auto<br>\nwith foo[OF this] have \"Q\" by auto</p>\n<p>(keep in mind that \"then\" abbreviates \"from this\" and \"with ...\"<br>\nabbreviates \"from ... this\".</p>\n<blockquote>\n<p>Same thing with \"moreover\" statements: is it possible to write something<br>\nlike:</p>\n<p>have \"P1\" by auto<br>\nmoreover have \"P2\" by auto<br>\nmoreover have \"P3\" by auto<br>\nultimately have \"Q\" using foo[OF this-1, OF this-2, OF this-3] by auto</p>\n</blockquote>\n<p>I don't know a nice syntax for this. For me this is not an<br>\noften-occurring situation, so I wonder if writing the proof differently<br>\nwould help. Do you have an example?</p>\n<p>Note that many proof tools work better if lemmas are used in a more<br>\ndirected fashion, e.g. as simp, intro, elim, ... rules.</p>\n<blockquote>\n<p>Most of the time, \"by (metis foo bar)\" would do the job, so I guess the<br>\nproblem is an excessive minimization, assuming wrongly that \"using foo<br>\nby (metis bar)\" is the same as \"by (metis foo bar)\"...</p>\n</blockquote>\n<p>Indeed, there are some subtle differences between these two statements,<br>\nthat sledgehammer does not fully deal with. Jasmin (the sledgehammer<br>\nauthor) is aware of this problem.</p>\n<p>-- Lars</p>",
        "id": 294652529,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166690
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nAs other people have already said here: no. You can, however, define a<br>\nrecursive function within a locale that has the same fixes as the place<br>\nin your proof where you want to define the function and the assumes the<br>\nrelevant facts. You can then just interpret that locale in your proof.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294652539,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166696
    },
    {
        "content": "<p>From: Esseger &lt;<a href=\"mailto:esseger@free.fr\">esseger@free.fr</a>&gt;<br>\nVery nice, thanks a lot!</p>",
        "id": 294652551,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166701
    },
    {
        "content": "<p>From: Esseger &lt;<a href=\"mailto:esseger@free.fr\">esseger@free.fr</a>&gt;<br>\nLe 18/08/2015 19:22, Lars Noschinski a écrit :</p>\n<blockquote>\n<p>On 18.08.2015 18:26, Esseger wrote:</p>\n</blockquote>\n<blockquote>\n<p>Thanks a lot for the feedback! May I ask what you used as learning<br>\nresources?</p>\n</blockquote>\n<p>\"Programming and Proving in Isabelle/HOL\" was invaluable to start. The <br>\ntutorial on locales was also very useful.<br>\n On the other hand, the <br>\nIsabelle/Isar Reference Manual was essentially of no use to me (too many <br>\ninformations, probably). But I mostly understood things by looking at <br>\ncode in the HOL library, and HOL-Multivariate_Analysis.</p>\n<blockquote>\n<p>If you want to build on some missing result, which you do want to<br>\nformalize, it is sometimes an option to just assume the result (using a<br>\nlocale).</p>\n</blockquote>\n<p>I would say the main problem is precisely to formalize the results (say, <br>\na little bit of functional analysis and spectral theory...)</p>\n<blockquote>\n<blockquote>\n<p>3) In an Isar proof, is there a way to refer to previous statements in<br>\nan OF clause? More specifically, consider</p>\n<p>have *: \"P\" by auto<br>\nhave \"Q\" using foo[OF *] by auto</p>\n<p>where P is some complicated statement. I would like to write this as</p>\n<p>have \"P\" by auto<br>\nthen have \"Q\" using foo[OF this] by auto</p>\n<p>But this fails. Is there a way to make it work, replacing \"this\" by<br>\nsomething else?</p>\n</blockquote>\n<p>In most cases, I would use the \\&lt;open&gt;P\\&lt;close&gt; syntax suggested by<br>\nLarry. \"this\" is only bound before the have, you could write</p>\n<p>have \"P\" by auto<br>\nwith foo[OF this] have \"Q\" by auto</p>\n</blockquote>\n<p>nice, thanks. The problem with <code>P</code> is when P is really complicated. Then <br>\nit is more efficient to give a name to \"P\", say:<br>\nhave i: \"P\"<br>\nhave \"Q\" using foo[OF i] by auto</p>\n<p>But I don't like giving names to equations if it is not necessary, as <br>\nmore notations are always a burden on the reader.</p>\n<blockquote>\n<blockquote>\n<p>Same thing with \"moreover\" statements: is it possible to write something<br>\nlike:</p>\n<p>have \"P1\" by auto<br>\nmoreover have \"P2\" by auto<br>\nmoreover have \"P3\" by auto<br>\nultimately have \"Q\" using foo[OF this-1, OF this-2, OF this-3] by auto</p>\n</blockquote>\n<p>I don't know a nice syntax for this. For me this is not an<br>\noften-occurring situation, so I wonder if writing the proof differently<br>\nwould help. Do you have an example?</p>\n</blockquote>\n<p>Take for instance the following lemma (from <br>\nProbability/Nonnegative_Lebesgue_Integration.thy):</p>\n<p>lemma nn_integral_monotone_convergence_SUP_AE_incseq:<br>\n   assumes f: \"incseq f\" \"⋀i. AE x in M. 0 ≤ f i x\" and borel: \"⋀i. f i <br>\n∈ borel_measurable M\"<br>\n   shows \"(∫⇧+ x. (SUP i. f i x) ∂M) = (SUP i. integral⇧N M (f i))\"</p>\n<p>To use this lemma, you typically need to check his three assumptions, <br>\nand all of them are nontrivial. If ?f is some complicated expression to <br>\nwhich I want to apply the above lemma, I will typically do:</p>\n<p>have i: \"incseq ?f\" by ...<br>\nhave ii: \"⋀i. AE x in M. 0 ≤ ?f i x\" by ...<br>\nhave iii: \"⋀i. ?f i ∈ borel_measurable M\" by ...<br>\nhave \"(∫⇧+ x. (SUP i. ?f i x) ∂M) = (SUP i. integral⇧N M (?f i))\" by <br>\n(rule nn_integral_monotone_convergence_SUP_AE_incseq[OF i, OF ii, OF iii])</p>\n<p>I don't really like this syntax because I have to give names to <br>\nequations (more notations are always more confusing), and because it <br>\ndoes not illustrate directly that the last statement is deduced from the <br>\nprevious ones.</p>\n<p>If ?f is simple enough, it suffices to do</p>\n<p>have \"incseq ?f\" by ...<br>\nmoreover have \"⋀i. AE x in M. 0 ≤ ?f i x\" by ...<br>\nmoreover have \"⋀i. ?f i ∈ borel_measurable M\" by ...<br>\nultimately have \"(∫⇧+ x. (SUP i. ?f i x) ∂M) = (SUP i. integral⇧N M (?f <br>\ni))\" using nn_integral_monotone_convergence_SUP_AE_incseq by force</p>\n<p>which has no need for additional notations, and in which the flow of <br>\nideas is clear. Unfortunately, when ?f starts being complicated, force <br>\ndoes not succeed.</p>\n<p>Best,<br>\nEsseger</p>",
        "id": 294652565,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166708
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nIn these cases I usually employ a subproof:</p>\n<p>have \"(∫⇧+ x. (SUP i. ?f i x) ∂M) = (SUP i. integral⇧N M (?f i))\"<br>\n  proof (rule nn_integral_monotone_convergence_SUP_AE_incseq)<br>\n    show \"incseq ?f\" by ...<br>\n  next<br>\n    ...<br>\n  qed</p>\n<p>However, this is largely a matter of taste.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294652588,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166718
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nA lot is missing, for sure. More complex analysis is on the way for the next release, along with the Stone-Weierstraß theorem, etc. Contributions definitely welcome!</p>\n<p>Larry Paulson</p>",
        "id": 294652590,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166720
    }
]