[
    {
        "content": "<p>From: Dave Thayer &lt;<a href=\"mailto:dathayer@microsoft.com\">dathayer@microsoft.com</a>&gt;<br>\nFor technical reasons I am restricted at the moment to using Isabelle2009<br>\nI am trying to use code generation to generate code for trigonometric functions and other functions that utilize the real datatype.</p>\n<p>I have the following code that is attempting to exercise this ability.</p>\n<p>definition test_pi :: \"real\" where \"test_pi = pi\"<br>\ndefinition test_sin :: \"real =&gt; real\" where \"test_sin x = sin x\"<br>\ndefinition test_cos :: \"real =&gt; real\" where \"test_cos x = cos x\"<br>\ndefinition test_tan :: \"real =&gt; real\" where \"test_tan x = tan x\"<br>\ndefinition test_arcsin :: \"real =&gt; real\" where \"test_arcsin x = arcsin x\"<br>\ndefinition test_arccos :: \"real =&gt; real\" where \"test_arccos x = arccos x\"<br>\ndefinition test_arctan :: \"real =&gt; real\" where \"test_arctan x = arctan x\"<br>\ndefinition test_trig :: \"real =&gt; real =&gt; real =&gt; real\" where \"test_trig x y a = cos (arctan (y / x) + sin a - pi/4)\"</p>\n<p>export_code<br>\n test_pi test_sin test_cos test_tan<br>\n test_arcsin test_arccos test_arctan<br>\n test_trig<br>\nin OCaml<br>\nmodule_name \"TestCodeGen\"<br>\nfile \"<a href=\"http://TestCodeGen3.ml\">TestCodeGen3.ml</a>\"</p>\n<p>I am getting the following error message</p>\n<h3>No code equation for LIMSEQ, The</h3>\n<p>Does anybody know where the code equations for LIMSEQ are defined?<br>\nI have looked through the HOL/Library but found nothing  so far.</p>\n<p>Thank you for your time,<br>\nDavid Thayer</p>",
        "id": 294147745,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848129
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYou are trying to generate code for real numbers and functions defined <br>\nby limits. Such definitions are not executable. You have two choices: <br>\nyou can generate code that utilizes machine floats, or you can generate <br>\ncode that realizes arbitrary precision interval arithmetic. The former <br>\nis a quick hack, the latter is sound but more work. Depending on what <br>\nyou want, we can tell you how to do it.</p>\n<p>Tobias</p>",
        "id": 294147748,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848131
    },
    {
        "content": "<p>From: Dave Thayer &lt;<a href=\"mailto:dathayer@microsoft.com\">dathayer@microsoft.com</a>&gt;<br>\nWe are trying to create hypothetical explanations  couched in HOL terms for a set of orbital observations and create an executable piece of code that determines how well the observations act as a model for our theory.  Therefore creating a function that accepts real values as floats is quite acceptable.</p>\n<p>David</p>",
        "id": 294147814,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848162
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHi David,</p>\n<p>as floats are acceptable for you, you can directly compile real to float<br>\nwith:</p>\n<p>theory Code_Float<br>\n  imports Complex_Main \"~~/src/HOL/Library/Code_Integer\"<br>\nbegin</p>\n<p>code_type real<br>\n    (OCaml \"float\")</p>\n<p>code_const \"0 :: real\"<br>\n    (OCaml \"0.0\")<br>\n  declare zero_real_code[code inline del]</p>\n<p>code_const \"1 :: real\"<br>\n    (OCaml \"1.0\")<br>\n  declare one_real_code[code inline del]</p>\n<p>code_const \"op + :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( +. )\")</p>\n<p>code_const \"op * :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( *. )\")</p>\n<p>code_const \"op - :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( -. )\")</p>\n<p>code_const \"op / :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( '/. )\")</p>\n<p>code_const cos<br>\n    (OCaml \"Pervasives.cos\")<br>\n  declare cos_def[code del]</p>\n<p>code_const sin<br>\n    (OCaml \"Pervasives.sin\")<br>\n  declare sin_def[code del]</p>\n<p>code_const pi<br>\n    (OCaml \"Pervasives.pi\")<br>\n  declare pi_def[code del]</p>\n<p>code_const arctan<br>\n    (OCaml \"Pervasives.atan\")<br>\n  declare arctan_def[code del]</p>\n<p>code_const arccos<br>\n    (OCaml \"Pervasives.acos\")<br>\n  declare arccos_def[code del]</p>\n<p>code_const arcsin<br>\n    (OCaml \"Pervasives.asin\")<br>\n  declare arcsin_def[code del]</p>\n<p>definition \"test_trig x y a = cos (arctan (y / x) + sin a - pi/(1 + 1 + 1 + 1))\"</p>\n<p>export_code test_trig<br>\n    in OCaml module_name CodegenTest file -</p>\n<p>end</p>\n<p>I tried it in Isabelle 2009 (not 2009-2), and it generates the expected<br>\ncode, but I don't know if OCaml accepts this code. I have a problem with<br>\nnumerals (i.e. numbers greater 2, just write them as 1 + 1 + ... + 1).</p>\n<p>A good example how to map number types to special types for the code<br>\ngenerator is \"~~/src/HOL/Library/Code_Integer.thy\".</p>\n<p>We do not provide these code generator setup, as obviously many<br>\nequalities don't hold any more. For example, in Haskell:</p>\n<p>cos (pi / 2 :: Double) == 0</p>\n<p>returns False.</p>\n<p>I hope this helps,<br>\n  Johannes</p>",
        "id": 294147896,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848197
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nOkay now with numerals support:</p>\n<p>theory Scratch<br>\n  imports Complex_Main \"~~/src/HOL/Library/Code_Integer\"<br>\nbegin</p>\n<p>code_type real<br>\n    (OCaml \"float\")</p>\n<p>code_const \"0 :: real\"<br>\n    (OCaml \"0.0\")<br>\n  declare zero_real_code[code inline del]</p>\n<p>code_const \"1 :: real\"<br>\n    (OCaml \"1.0\")<br>\n  declare one_real_code[code inline del]</p>\n<p>code_const \"op + :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( +. )\")</p>\n<p>code_const \"op * :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( *. )\")</p>\n<p>code_const \"op - :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( -. )\")</p>\n<p>code_const \"op / :: real \\&lt;Rightarrow&gt; real \\&lt;Rightarrow&gt; real\"<br>\n    (OCaml \"Pervasives.( '/. )\")</p>\n<p>code_const cos<br>\n    (OCaml \"Pervasives.cos\")<br>\n  declare cos_def[code del]</p>\n<p>code_const sin<br>\n    (OCaml \"Pervasives.sin\")<br>\n  declare sin_def[code del]</p>\n<p>code_const pi<br>\n    (OCaml \"Pervasives.pi\")<br>\n  declare pi_def[code del]</p>\n<p>code_const arctan<br>\n    (OCaml \"Pervasives.atan\")<br>\n  declare arctan_def[code del]</p>\n<p>code_const arccos<br>\n    (OCaml \"Pervasives.acos\")<br>\n  declare arccos_def[code del]</p>\n<p>code_const arcsin<br>\n    (OCaml \"Pervasives.asin\")<br>\n  declare arcsin_def[code del]</p>\n<p>definition \"embed = (of_int :: int \\&lt;Rightarrow&gt; real)\"<br>\n  code_const embed<br>\n    (OCaml \"float'_of'_int\")</p>\n<p>lemma of_int_eq_embed[code inline]:<br>\n    \"of_int = embed\"<br>\n    unfolding embed_def ..</p>\n<p>declare number_of_real_code [code inline del]</p>\n<p>definition \"test_trig x y a = cos (arctan (y / x) + sin a - pi/4.1)\"</p>\n<p>export_code test_trig<br>\n    in OCaml module_name CodegenTest file -</p>\n<p>end</p>",
        "id": 294147907,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848200
    }
]