[
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nDear Isabelle users,</p>\n<p>I made another interesting observation.  According to earlier experience<br>\nI will not call it \"strange\" or \"bug\", but merely \"interesting\" ;-)</p>\n<p>have \"(0::nat) ∈ ℕ\" by simp -- works</p>\n<p>have \"(1::nat) ∈ ℕ\" by simp -- doesn't work</p>\n<p>have \"(1::nat) ∈ ℕ\" by (rule Nat.semiring_1_class.Nats_1) -- works, but<br>\ninterestingly Nats_1 _is_ a simp rule</p>\n<p>have \"1 ∈ ℕ\" by simp -- works</p>\n<p>have \"(666::nat) ∈ ℕ\" by simp -- works</p>\n<p>So it seems that statements of this pattern work for all natural<br>\nnumbers, when given explicit type information, except for 1.</p>\n<p>Let me briefly explain the background of my work.  Any feedback on<br>\nwhether my approach is reasonable is most welcome.  As a part of our<br>\nsoundness verification of auctions<br>\n(<a href=\"http://www.cs.bham.ac.uk/research/projects/formare/code/auction-theory/#sound-verif\">http://www.cs.bham.ac.uk/research/projects/formare/code/auction-theory/#sound-verif</a>,<br>\n<a href=\"http://arxiv.org/abs/1308.1779\">http://arxiv.org/abs/1308.1779</a>,<br>\n<a href=\"https://github.com/formare/auctions/tree/master/isabelle/Auction\">https://github.com/formare/auctions/tree/master/isabelle/Auction</a>), I'd<br>\nlike to prove that the functions that describe certain auctions (e.g.<br>\nthat compute the price someone has to pay) are well-defined.  At the<br>\nvery least this means that the functions are total on the set of<br>\npossible inputs (i.e. bids that bidders place on goods).  Now, in<br>\nIsabelle/HOL, functions are always total in a trivial sense, and I think<br>\nI don't want to use explicit partial functions.</p>\n<p>So I thought the following approach should work: given a function<br>\nf::\"nat ⇒ nat\", I prove that for any concrete natural number (Is there a<br>\nbetter word than \"concrete\"?) the function returns a concrete value.<br>\nI.e. \"⋀ x . x ∈ ℕ ⟹ f x ∈ ℕ\", or, using the terminology of FuncSet, \"f ∈<br>\nℕ → ℕ\".</p>\n<p>Does this make sense?</p>\n<p>Cheers, and thanks in advance,</p>\n<p>Christoph</p>",
        "id": 294250156,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910416
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYou can prove \"(n::nat) : Nats\", which shows you that Nats is just the set of<br>\nall natural numbers. Nats is polymrphic and only becomes useful when it<br>\ndescribes the natural numbers as a subset of some other numeric type.</p>\n<p>Your proof attempt will just lead to trivial goals that don't tell you anything:<br>\nany term n::nat is equal to some concrete natural number built up from 0 and Suc<br>\nsimply because that is how nat is defined. What you probably have in mind is the<br>\nfollowing: you want to prove that for any concrete n::nat you can prove \"f n =<br>\nm\" for some concrete m - and the proof should only use the equations defining f<br>\nand the functions it is based on. That is not possible, because you cannot<br>\nrestrict deduction to some sublogic.</p>\n<p>Tobias</p>",
        "id": 294250194,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910425
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nChristoph,</p>\n<p>I'll add specific details of why `have \"(1::nat) ∈ ℕ\" by simp' doesn't work.</p>\n<p>First, 0 and 1 are special, so you frequently have to do special things <br>\nto prove statements about 0 and 1.</p>\n<p>I use this to look at all the typing in the output panel: <br>\ndeclare[[show_sorts=true]]</p>\n<p>Along with this to see what simp rules are getting used: <br>\ndeclare[[simp_trace=true]]</p>\n<p>For the formula \"1 \\&lt;in&gt; \\&lt;nat&gt;\", 1 is type 'a and \\&lt;nat&gt; is ('a set), <br>\nso \"1 \\&lt;in&gt; \\&lt;nat&gt;\" is not the same statement as \"(1::nat) \\&lt;in&gt; \\&lt;nat&gt;\".</p>\n<p>The simp trace for <code>\"(1::nat) \\&lt;in&gt; \\&lt;nat&gt;\" by simp</code> shows that the only <br>\nsimp rule used is One_nat_def, which rewrites 1 as (Suc 0).</p>\n<p>In Nat.thy, these two simp rules are on the following lines:</p>\n<p>(Line 0186) One_nat_def [simp]: \"1 = Suc 0\"<br>\n(Line 1467) lemma Nats_1 [simp]: \"1 ∈ ℕ\"</p>\n<p>The order that simp rules are declared is not always followed by the <br>\nsimplifier. For example, permutative rewrite rules take precedence. But <br>\nmuch of the time, I've found that simp rules are applied in the order in <br>\nwhich they are declared.</p>\n<p>So, One_nat_def converts 1 to \"Suc 0\" first. The simp rule Nats_1 is <br>\nthen not applicable.</p>\n<p>Try this:</p>\n<p>theorem \"(1::nat) \\&lt;in&gt; \\&lt;nat&gt;\"<br>\n   by(simp del: One_nat_def)</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294250203,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910429
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nThanks, Tobias and Gottfried!</p>\n<p>Thanks, Tobias, for preventing me from wasting a lot of time proving<br>\ntrivial results.</p>\n<p>2013-09-12 13:48 Tobias Nipkow:</p>\n<blockquote>\n<p>What you probably have in mind is the<br>\nfollowing: you want to prove that for any concrete n::nat you can prove \"f n =<br>\nm\" for some concrete m - and the proof should only use the equations defining f<br>\nand the functions it is based on. That is not possible, because you cannot<br>\nrestrict deduction to some sublogic.</p>\n</blockquote>\n<p>Indeed that's what I had in mind.  Luckily there are still other<br>\ninteresting properties of my functions f, which I can and will prove.</p>\n<p>2013-09-12 14:30 Gottfried Barrow:</p>\n<blockquote>\n<p>I use this to look at all the typing in the output panel:<br>\ndeclare[[show_sorts=true]]</p>\n<p>Along with this to see what simp rules are getting used:<br>\ndeclare[[simp_trace=true]]</p>\n</blockquote>\n<p>Thanks for pointing out, and for explaining the background!</p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294250213,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910434
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nThanks for the info. One can make the wrong correlation about simple <br>\nthings. If I look at the simp rules I've made, I'll probably see that I <br>\nusually create basic equivalencies first, and then more complex <br>\nequivalencies, which results in their order being followed.</p>\n<p>To others, I should point out that many prefer the CNTL-hover method of <br>\ngetting typing information for a term, and that <br>\n\"declare[[show_sorts=true]\" will interfere with the CNTL-hover method:</p>\n<p><a href=\"http://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-February/msg00002.html\">http://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-February/msg00002.html</a></p>\n<p>I like to see all the typing at once for a complete formula, so I use <br>\nthe \"declare\" method.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294250261,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910452
    }
]