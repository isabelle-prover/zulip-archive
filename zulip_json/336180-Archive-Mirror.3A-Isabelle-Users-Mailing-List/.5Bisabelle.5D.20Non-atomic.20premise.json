[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>when I use</p>\n<p>inductive fun_rel' for P where<br>\n          fun_relI'[intro]: \"(⋀ x. P (id m x) (id m' x)) ⟹ fun_rel' P m<br>\n        m'\"</p>\n<p>inductive works without problem. But when I do</p>\n<p>inductive fun_rel' for P where<br>\n          fun_relI'[intro]: \"(⋀ x. P (m x) (m' x)) ⟹ fun_rel' P m m'\"</p>\n<p>I get:</p>\n<p>Proofs for inductive predicate(s) \"fun_rel\" <br>\n        Ill-formed premise<br>\n        ⋀x. P (m x) (m' x)<br>\n        in introduction rule \"fun_relI\"<br>\n        ⋀m m'. (⋀x. P (m x) (m' x)) ⟹ fun_rel P m m'<br>\n        Non-atomic premise</p>\n<p>I don’t understand the error message, nor why it should not work. Can<br>\nanyone enlighten me?</p>\n<p>Thanks,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/UFYxsRIU1ANBHYkZIjKldj0k/signature.asc\">signature.asc</a></p>",
        "id": 294259574,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913876
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nHi Joachim,</p>\n<p>The problem with your second example, using \"(⋀ x. P (m x) (m' x)) ⟹<br>\nfun_rel' P m m'\", is that some of the inferred type variables have the<br>\nempty sort \"{}\" instead of the usual default sort \"type\". (The<br>\nobject-level forall quantifier requires sort \"type\", which is why the<br>\natomization fails.) Adding the \"id\" functions constrains these type<br>\nvariables to the appropriate sort.</p>\n<p>To fix the problem you can add some type annotations for P and x:</p>\n<p>inductive fun_rel' for P :: \"'a ⇒ 'b ⇒ bool\" where<br>\n  fun_relI'[intro]: \"(⋀ x::'c. P (m x) ( m' x)) ⟹ fun_rel' P m m'\"</p>\n<p>Or if you'd rather have Isabelle infer the types as much as possible,<br>\nyou can try something like this:</p>\n<p>inductive fun_rel' for P :: \"_::type\" where<br>\n  fun_relI'[intro]: \"(⋀ x::_::type. P (m x) ( m' x)) ⟹ fun_rel' P m m'\"</p>\n<p>The meta-universal quantifier is defined in Pure (outside of HOL) so<br>\nit makes sense for it to allow more general sorts than HOL's \"type\".<br>\nHowever, I don't see any possible use for HOL-specific commands like<br>\n\"inductive\" to allow free variables or parameters with non-\"type\"<br>\ntypes.</p>\n<p>Perhaps we should make a feature request: Free variables in<br>\nspecifications of HOL-specific commands (e.g. the P, m, and m' in the<br>\n\"inductive\" command above) should be constrained to have a sort no<br>\nmore general than \"type\".</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294259775,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913943
    }
]