[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<blockquote>\n<p>Case certificates must always be exhaustive!<br>\nExhaustive with respect to what?</p>\n</blockquote>\n</blockquote>\n<p>exhaustive in the sense that the number of discriminators must be<br>\n<em>equal</em> to the number of constructors (in the sense of the code generator).</p>\n<blockquote>\n<p>I do not see why<br>\ncode certificates need to be exhaustive with respect to the logic other<br>\nthan restrictions in the code generator implementation.</p>\n</blockquote>\n<p>True.  The implementation however is not so general since in my mind I<br>\ncould never imagine a user case which would make it necessary to provide<br>\nanything beyond the internal foundational case certificates as a kind of<br>\nprotocol between the datatype package and the code generator.  This is<br>\nthe reason why there is no full-blown user interface for case<br>\ncertificates (yet).  Indeed two years ago I was thinking about that but<br>\nput it aside since it did not seem worth the effort.</p>\n<p>The best documentation for case certificates available is indeed if you<br>\nfollow the implementation of Code.add_case.</p>\n<p>What is your application?  Does it go beyond pure esthetic concerns?  I<br>\nwould be relucant to touch the trusted code base of code.ML if there is<br>\nnot a striking reason (neglecting questions of effort estimation at the<br>\nmoment).</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/z-ar9bTrHuNl7AbPJAhCM4X4/signature.asc\">signature.asc</a></p>",
        "id": 294154508,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850647
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Florian,</p>\n<blockquote>\n<p>True.  The implementation however is not so general since in my mind I<br>\ncould never imagine a user case which would make it necessary to provide<br>\nanything beyond the internal foundational case certificates as a kind of<br>\nprotocol between the datatype package and the code generator.  This is<br>\nthe reason why there is no full-blown user interface for case<br>\ncertificates (yet).  Indeed two years ago I was thinking about that but<br>\nput it aside since it did not seem worth the effort.</p>\n</blockquote>\n<p>Note that I do not ask about a full-blown user interface for case certificates. <br>\nI just plan to generate and register them on the ML level. All I need is that <br>\nthe case operator is allowed to take extra variables that do not appear in any <br>\nconclusion.</p>\n<blockquote>\n<p>Does it go beyond pure esthetic concerns?<br>\nIn principle, case certificates are <em>always</em> esthetic because they do not <br>\nenhance the expressivity of the code generator. One could always replace any <br>\ncase expression by a definition of a specialised constant via pattern matching <br>\nand then hope that the ML or Haskell compiler inlines the artificial function as <br>\na case expression again. Nevertheless, they do exist in their present form, <br>\nbecause it is much nicer to use case expressions in code equations than to <br>\ndefine a separate constant for each occurrence.</p>\n</blockquote>\n<blockquote>\n<p>What is your application?<br>\nI am currently working on the problem that you cannot use different <br>\nimplementations for 'a set or ('a, 'b) mapping in a single application without <br>\ngetting into trouble with sort constraints. To get an extensible solution to <br>\nthat, I define extensible enumerations, i.e., something like</p>\n</blockquote>\n<p>datatype enum = A | B | C</p>\n<p>but with the possibility to add further constructors to enum later on. With <br>\nthis, one of course loses exhaustiveness theorems, but it seems to work for my <br>\napplication. Nevertheless, I would like to do case distinctions on enum in code <br>\nequations using a case expression like</p>\n<p>my_fun q = (case ... of A =&gt; ... | B =&gt; ... | C =&gt; ... | other =&gt; my_fun q)</p>\n<p>where the new case \"other\" represents all constructors that have not yet been <br>\nbeen added to enum. Due to reflexivity of =, this equation is provable if the <br>\ncases for the existing constructors A, B, and C are provable. Now, I would like <br>\nthe generated code to be something like</p>\n<p>fun my_fun q = (case ... of A =&gt; ... | B =&gt; ... | C =&gt; ...)</p>\n<p>and not</p>\n<p>fun enum_case a _ _ _ A = a<br>\n   | enum_case _ b _ _ B = b<br>\n   | enum_case _ _ c _ C = c</p>\n<p>fun my_fun q = enum_case ... ... ... (my_fun q) ...</p>\n<p>because that would loop and evaluate all cases before deciding.</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294154664,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850714
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>I am currently working on the problem that you cannot use different<br>\nimplementations for 'a set or ('a, 'b) mapping in a single application<br>\nwithout getting into trouble with sort constraints. To get an extensible<br>\nsolution to that, I define extensible enumerations, i.e., something like</p>\n<p>datatype enum = A | B | C</p>\n<p>but with the possibility to add further constructors to enum later on.<br>\nWith this, one of course loses exhaustiveness theorems, but it seems to<br>\nwork for my application. Nevertheless, I would like to do case<br>\ndistinctions on enum in code equations using a case expression like</p>\n<p>my_fun q = (case ... of A =&gt; ... | B =&gt; ... | C =&gt; ... | other =&gt; my_fun q)</p>\n</blockquote>\n<p>OK, convinced.</p>\n<p>Indeed, when looking at the code in code.ML (functions case_certificate<br>\nand add_cert), it does not seem so difficult to extend it in a manner<br>\nthat arguments to a case combinator can be ignored.  However it would<br>\nrequire some generalization which I personally do not have resources<br>\nnow.  Maybe you would like to give it a try?  The first step would be to<br>\nextend code.ML accordingly and then look what consequences this has for<br>\nthe derived modules in src/Tools/Code.</p>\n<blockquote>\n<blockquote>\n<p>Does it go beyond pure esthetic concerns?<br>\nIn principle, case certificates are <em>always</em> esthetic because they do not enhance the expressivity of the code generator. One could always replace any case expression by a definition of a specialised constant via pattern matching and then hope that the ML or Haskell compiler inlines the artificial function as a case expression again. Nevertheless, they do exist in their present form, because it is much nicer to use case expressions in code equations than to define a separate constant for each occurrence.</p>\n</blockquote>\n</blockquote>\n<p>Not wholly.  It is also a matter of evaluation order.  This is the<br>\nreason why e.g. NBE generated explicit cases.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/IgGrYhuaeAj0hIngdm2vYmv0/signature.asc\">signature.asc</a></p>",
        "id": 294155498,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851042
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear all,</p>\n<p>suppose I have a type with a number of constructors, but only some of them are <br>\nmeant to be used for code generation. For example:</p>\n<p>datatype foo = A | B | C | D<br>\ndefinition test<br>\n   where \"test x = 4 + (case x of A =&gt; 0 | B =&gt; 1 | C =&gt; 2 | D =&gt; 3)\"</p>\n<p>In the exported code for test, the case expression is translated into a case <br>\nexpression of the target language. In particular, it does not use foo_case.<br>\nHowever, when I restrict foo to some subset of constructors, say</p>\n<p>code_datatype A B C</p>\n<p>then export_code on test generates the error message</p>\n<p>*** \"Test.foo.D\" is not a constructor, on left hand side of equation:<br>\n*** case D of A =&gt; ?f1.0 | B =&gt; ?f2.0 | C =&gt; ?f3.0 | D =&gt; ?f4.0 == ?f4.0<br>\n*** At command \"export_code\"</p>\n<p>This error message seems to stem from the case certificate that the datatype <br>\ndeclaration registered in the code generator. I'd like to replace that after the <br>\ncode_datatype declaration with something like</p>\n<p>lemma new_foo_case_cert:<br>\n   assumes \"CASE == foo_case a b c d\"<br>\n   shows \"(CASE A == a) &amp;&amp;&amp; (CASE B == b) &amp;&amp;&amp; (CASE C == c)\"<br>\nusing assms by auto<br>\nsetup {*<br>\n   Code.add_case @{thm new_foo_case_cert}<br>\n*}</p>\n<p>This version raises the exception option, other variations yield \"bad case <br>\ncertificate\". How do I need to phrase the case certificate such that the code <br>\ngenerator accepts it?</p>\n<p>If this is impossible, I'd like to know why. If it is just a matter of adapting <br>\nthe code generator implementation, I'd be happy to assist in implementing this.</p>\n<p>Andreas</p>",
        "id": 294155818,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851156
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>However, when I restrict foo to some subset of constructors, say</p>\n<p>code_datatype A B C</p>\n<p>then export_code on test generates the error message</p>\n<p>*** \"Test.foo.D\" is not a constructor, on left hand side of equation:<br>\n*** case D of A =&gt; ?f1.0 | B =&gt; ?f2.0 | C =&gt; ?f3.0 | D =&gt; ?f4.0 == ?f4.0<br>\n*** At command \"export_code\"</p>\n</blockquote>\n<p>This has nothing to do with the case certificate, but stems from the <br>\ncode equations for »foo_case«.  The case certificate should be thrown <br>\naway on »code_datatype«, so code generation falls back on the <br>\ncorresponding code equations.</p>\n<p>So do something like:</p>\n<p>lemma [code, code del]:<br>\n   \"foo_case = foo_case\" ..</p>\n<p>lemma [code]:<br>\n   \"foo_case … = …\"<br>\n   \"foo_case … = …\"<br>\n   \"foo_case … = …\"<br>\n   …<br>\n   \"foo_case … = …\"</p>\n<p>If you still want proper case expressions, add a case certificate manually.</p>\n<blockquote>\n<p>lemma new_foo_case_cert:<br>\nassumes \"CASE == foo_case a b c d\"<br>\nshows \"(CASE A == a) &amp;&amp;&amp; (CASE B == b) &amp;&amp;&amp; (CASE C == c)\"<br>\nusing assms by auto<br>\nsetup {*<br>\nCode.add_case @{thm new_foo_case_cert}<br>\n*}</p>\n</blockquote>\n<p>What is suspicicious is that »d« never occurs in the conclusion.  I <br>\nguess they should read »a d« etc.</p>\n<p>Cheers,<br>\n    Florian</p>",
        "id": 294155984,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851224
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nI forgot:</p>\n<p>Case certificates must always be exhaustive!</p>\n<p>Florian</p>",
        "id": 294156340,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851361
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Florian,</p>\n<p>thanks for the clarifiction.</p>\n<blockquote>\n<p>If you still want proper case expressions, add a case certificate manually.<br>\nYes, I do want them, because otherwise ML evaluates all parameters too foo_case, <br>\nwhich might raise an exception. And I do not want to add closures everywhere.</p>\n</blockquote>\n<blockquote>\n<p>Case certificates must always be exhaustive!<br>\nExhaustive with respect to what? The lemma below is exhaustive with respect to <br>\nthe code generator setup -- there are three code_datatype constructors and there <br>\nis one conclusion for each). I do not see why code certificates need to be <br>\nexhaustive with respect to the logic other than restrictions in the code <br>\ngenerator implementation.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>lemma new_foo_case_cert:<br>\nassumes \"CASE == foo_case a b c d\"<br>\nshows \"(CASE A == a) &amp;&amp;&amp; (CASE B == b) &amp;&amp;&amp; (CASE C == c)\"<br>\nusing assms by auto<br>\nsetup {*<br>\nCode.add_case @{thm new_foo_case_cert}<br>\n*}</p>\n</blockquote>\n<p>What is suspicicious is that »d« never occurs in the conclusion. I guess they<br>\nshould read »a d« etc.<br>\nI do not fully understand your remark, but let me explain in a bit more detail:<br>\nfoo_case is not changed by the code_datatype command. Logically, type foo still <br>\nhas 4 constructors, so the case combinator needs to have 4 parameters for the <br>\ncases, which are a, b, c, and d in the above lemma. However, the code generator <br>\nonly knows about three constructors A, B, and C. As soon as I try to prove a <br>\ncase certificate with 4 conclusions, I get a \"bad case certificate\" error. For <br>\nexample:</p>\n</blockquote>\n<p>lemma new_foo_case_cert:<br>\n   assumes \"CASE == foo_case a b c d\"<br>\n   shows \"(CASE A == a) &amp;&amp;&amp; (CASE B == b) &amp;&amp;&amp; (CASE C == c) &amp;&amp;&amp; (CASE D = d)\"<br>\n   using assms by auto<br>\nsetup {* Code.add_case @{thm new_foo_case_cert} *}</p>\n<p>I also tried the following version without success:</p>\n<p>lemma new_foo_case_cert:<br>\n   assumes \"CASE == foo_case a b c\"<br>\n   shows \"(CASE d A == a) &amp;&amp;&amp; (CASE d B == b) &amp;&amp;&amp; (CASE d C == c)\"</p>\n<p>So what is the right form of the certificate?</p>\n<p>Note that I cannot define a specialised case combinator such as</p>\n<p>foo_case' a b c = foo_case a b c 3</p>\n<p>and use the symmetric equation as code_unfold, because other constants might <br>\nneed different specialised case combinators and the code generator supports only <br>\none.</p>\n<p>Andreas</p>",
        "id": 294156524,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851426
    }
]