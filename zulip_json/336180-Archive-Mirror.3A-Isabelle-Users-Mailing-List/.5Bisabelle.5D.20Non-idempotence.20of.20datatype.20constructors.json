[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThis is one for our datatype experts:</p>\n<p>I just noticed that theorems like</p>\n<p>Cons x xs ≠ xs</p>\n<p>are not automatically provided by the datatype package although they<br>\nshould clearly hold for any datatype. To be more precise, I am talking<br>\nabout theorems of the form</p>\n<p>C x1 … xn ≠ x1<br>\n…<br>\nC x1 … xn ≠ xn</p>\n<p>for any n-ary datatype constructor C (and of course also the flipped<br>\nvariant).</p>\n<p>I'm not sure how useful something like this is in practice and it's<br>\nfairly easy to prove these by hand when needed. I just ran into a<br>\nsituation where I had an assumption of the form \"C a b ≠ b\" and was<br>\nsurprised that the simplifier didn't take care of it automatically.</p>\n<p>I realise that the datatype package already provides an absurd number of<br>\ntheorems and one should be careful to blow it up even more, but seeing<br>\nas the number of theorems to be generated is linear in the number of<br>\nconstructors and they're probably very easy to prove, one could consider<br>\nit. Or perhaps at least as an optional plugin or standalone tool.</p>\n<p>Manuel</p>",
        "id": 294827738,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245252
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI do think such rules are useful, esp if they are there by default. I suggest  <br>\nthey are best handled by a simproc that is triggered by any \"(=)\" but that  <br>\nchecks immediately if the two argumenst are of the appropriate type and form.  <br>\nThat can be done very quickly (there are similar simprocs already). The simproc  <br>\nshould work for any datatype and any degree of nesting of the constructors.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/5UTOIMVPCELHo0wrXhuy_irD/smime.p7s\">smime.p7s</a></p>",
        "id": 294827999,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245326
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThat sounds like a good idea.</p>\n<p>However, if such a simproc is to work for any nesting of<br>\nconstructors,having pre-proven theorems for every constructor will not<br>\nbe enough.Instead, I suppose one would have to introduce a<br>\n\"proper-subexpression\"relation for datatypes (e.g. xs &lt; Cons x xs) along<br>\nwith a proof thatthis relation has the obvious properties (irreflexive,<br>\nasymmetric,transitive).</p>\n<p>I guess that is something that only a datatype package plugin similar<br>\ntothe one for the \"size\" function could provide. Having looked at the<br>\ncodebriefly, I think only the people who wrote the BNF package could (or<br>\natleast should) implement that.</p>\n<p>Alternatively, one could just use the size function (as someone<br>\nalreadysuggested in this thread) to get pretty much the same thing,<br>\nexcept thatit won't work for all datatypes (e.g. infinitely branching ones).</p>\n<p>Manuel</p>",
        "id": 294828159,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245393
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nA first version which only deals with depth 1 would already cover most of the <br>\npractical cases.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/gj9u4hmuIemTV5TXx-t_kK1I/smime.p7s\">smime.p7s</a></p>",
        "id": 294828189,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245406
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nTrue, but after your suggestion, I realised that the solution with the<br>\n\"proper subexpression\" relation (or, alternatively, the size function)<br>\ncombined with a simproc that produces these theorems on the spot is<br>\nactually the superior approach in every respect. It's simpler, more<br>\ngeneral, and probably more performant.</p>\n<p>I can try to come up with a proof-of-concept implementation using the<br>\nsize function approach, since that needs no additional new features from<br>\nthe BNF package.</p>\n<p>Manuel</p>",
        "id": 294828201,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245412
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI attached a proof of concept (works with Isabelle 2020) using the<br>\nsimple size-based approach, including some example applications.</p>\n<p>It works well, although I'm not sure what the proper way to get the<br>\ndatatype information is (e.g. the list of all the constructors of the<br>\ndatatype and the associated other datatypes in case of mutual recursion).</p>\n<p>Is the ML interface of the BNF package documented anywhere (in<br>\nparticular this aspect)?</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/lQEcihnnYLsHDbisIJPYZ2hR/Foo.thy\">Foo.thy</a></p>",
        "id": 294828233,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245424
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nUnfortunately, the simproc breaks a few things in the AFP.</p>\n<p>One of them is the proof of viewL_correct in Finger-Trees.FingerTree,<br>\nwhere a call to \"auto\" loops (it also loops when changing it to \"simp\").</p>\n<p>It's not an implementation problem of my simproc either. When I disable<br>\nthe simproc and add the theorems</p>\n<p>\"Node3 a b c d ≠ b\" \"Node3 a b c d ≠ c\" \"Node3 a b c d ≠ d\"</p>\n<p>to the simpset instead, it also loops.</p>\n<p>These rules look perfectly harmless to me, so my suspicion would be that<br>\nthe simpset in this theory was fragile all this time and these new rules<br>\nsimply exposed that. However, I couldn't find any problematic-looking<br>\nsimp rules either, so perhaps it's some premise that the simplifier adds<br>\nto the simpset itself.</p>\n<p>After inspecting the trace, it seems that the simplifier tries to apply<br>\nthe following rule over and over again:</p>\n<p>[1]Adding rewrite rule \"??.unknown\":<br>\nnodeToList nd2 = [] ∧ nodeToList nd3 = [] ⟹<br>\nFalse ⟹<br>\nundefined = n_unwrap nd1 ⟹<br>\nis_leveln_node 0 nd1 ⟹ is_measured_node nd1 ⟹ nodeToList nd1 ≡ [undefined]</p>\n<p>(plus a few other variants of this with other permutations of nd1, nd2,<br>\nnd3, so I guess it loops when trying to rewrite the first premise)</p>\n<p>I find this a bit odd. Why does the simplifier add something that has<br>\n\"False\" in its premises to the simpset in the first place? Shouldn't<br>\nthis entire thing get rewritten to \"True\" and discarded before that happens?</p>\n<p>Manuel</p>",
        "id": 294828261,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245437
    },
    {
        "content": "<p>From: Traytel  Dmitriy &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>while your code works for the examples you show, it does not seem to handle nested recursion. See code below, with your simproc enabled. Also I would register it only for types that belong to the size class, i.e.,</p>\n<p>simproc_setup datatype_no_proper_subterm (\"(x :: 'a :: size) = y\") = ‹K datatype_no_proper_subterm_simproc›</p>\n<p>Your retrieval of mutual types looks reasonable to me. As usual with Isabelle/ML, the most reliable documentation is the code.</p>\n<p>I am sympathetic to the proposal of having a 'proper subexpression' ordering defined for all datatypes (e.g., via a plugin similarly to size). Its usefulness goes beyond the acyclicity rules which this thread is about. In particular, the 'proper subexpression' ordering can be used for 'strong induction' or to prove termination of functions in cases when size does not exists. (Provided that we also have the fact that this ordering is wellfounded proved.) Something along the following lines:</p>\n<p>class subexp =<br>\n  fixes subexp :: \"'a ⇒ 'a ⇒ bool\" (infixl \"⊏\" 65)<br>\n  assumes wf: \"wfP subexp\"</p>\n<p>declare [[typedef_overloaded]]</p>\n<p>bnf_axiomatization 'a F [wits: \"'a F\"]</p>\n<p>datatype x = Ctor \"x F\"</p>\n<p>instantiation x :: subexp begin</p>\n<p>definition subexp_x :: \"x ⇒ x ⇒ bool\" where<br>\n  \"subexp_x = tranclp (λx y. case y of Ctor f ⇒ x ∈ set_F f)\"</p>\n<p>instance<br>\n  apply intro_classes<br>\n  apply (unfold subexp_x_def)<br>\n  apply (rule wfP_trancl)<br>\n  apply (rule wfPUNIVI)<br>\n  subgoal premises prems for P x<br>\n    apply (induct x)<br>\n    apply (rule prems[rule_format])<br>\n    apply (simp only: <a href=\"http://x.case\">x.case</a>)<br>\n    done<br>\n  done</p>\n<p>end</p>\n<p>But one would like to have some reasonable simp rules for subexp_x (which may be as hard as the original problem that you are trying to solve). In particular, if F is itself a datatype that belongs to the subexp type class, its notion of subexp should be linked to the one of x.</p>\n<p>Dmitriy</p>\n<p>datatype 'a rtree = Leaf | Node 'a \"'a rtree list\"</p>\n<p>lemma \"Node x (a # xs) ≠ a\"<br>\n  apply simp? ―‹no_change›<br>\n  apply (rule size_neq_size_imp_neq)<br>\n  apply simp<br>\n  done</p>\n<p>lemma \"Node x [c,a,b] ≠ a\"<br>\n  apply simp? ―‹no_change›<br>\n  apply (rule size_neq_size_imp_neq)<br>\n  apply simp<br>\n  done</p>",
        "id": 294828289,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245442
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHello,</p>\n<p>we're talking about Isabelle datatypes here, which are always finite<br>\n(final algebras is the categorial interpretation). The Haskell<br>\ninterpretation is actually a codatatype (the final coalgebra) and<br>\ncalling them \"datatypes\" is, in my opinion, actually a bit non-standard.<br>\nBut it makes sense given the lazy semantics of Haskell.</p>\n<p>Manuel</p>",
        "id": 294828321,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245449
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nOn 03/05/2020 11:46, Traytel Dmitriy wrote:</p>\n<blockquote>\n<p>while your code works for the examples you show, it does not seem to handle nested recursion.</p>\n</blockquote>\n<p>Yes, I am aware of that. Nested datatypes make things considerably more<br>\ncomplicated, so I'd rather not support that for now. I'd have to</p>\n<ol>\n<li>\n<p>somehow figure out /all/ the other datatypes involved in the<br>\ndefinition of my datatype and</p>\n</li>\n<li>\n<p>figure out a robust way to expand their size functions.</p>\n</li>\n</ol>\n<p>I have no idea how to do 1 with the information provided by the BNF<br>\npackage (other than inspecting the types of the constructors to figure<br>\nout the nesting).</p>\n<p>I also have no idea how to do 2 properly – the \"size\" plugin provides<br>\nsome information with BNF_LFP_Size.size_of, but oddly enough it only<br>\nprovides the equations for the \"regular\" size function \"size\", but not<br>\nfor the generalised one (e.g. \"size_list\"), which appear in the size<br>\nfunctions of nested datatypes.</p>\n<p>Note that I really do want to do 2, because relying on the simplifier<br>\nitself to solve the precondition \"size lhs ≠ size rhs\" is fragile and<br>\nbreaks at least in some cases in the AFP.</p>\n<blockquote>\n<p>I am sympathetic to the proposal of having a 'proper<br>\nsubexpression' ordering defined for<br>\nall datatypes (e.g., via a plugin similarly to size).<br>\nIts usefulness goes beyond the<br>\nacyclicity rules which this thread is about.</p>\n</blockquote>\n<p>Absolutely! It's probably no surprise to you when I say that I won't<br>\nimplement this. But if you (or one of our other datatype experts) ever<br>\ndoes it, do let me know!</p>\n<blockquote>\n<p>But one would like to have some reasonable simp rules for subexp_x<br>\n(which may be as hard as the original problem that you are trying to solve). <br>\nIn particular, if F is itself a datatype that belongs to the subexp type class, <br>\nits notion of subexp should be linked to the one of x.</p>\n</blockquote>\n<p>Already for mutual and nested datatypes, you would probably need an<br>\nentire family of relations for each combination of types (e.g. if you<br>\nhave mutually recursive datatypes A and B, you would probably need<br>\nsubexpr_A_A, subexpr_A_B, subexpr_B_A, subexpr_B_B).</p>\n<p>I guess everything gets complicated once you involve nested datatypes…</p>\n<p>Manuel</p>\n<p>See code below, with your simproc enabled. Also I would register it<br>\nonly for types that belong to the size class, i.e.,</p>\n<blockquote>\n<p>simproc_setup datatype_no_proper_subterm (\"(x :: 'a :: size) = y\") = ‹K datatype_no_proper_subterm_simproc›</p>\n<p>Your retrieval of mutual types looks reasonable to me. As usual with Isabelle/ML, the most reliable documentation is the code.</p>\n<p>I am sympathetic to the proposal of having a 'proper subexpression' ordering defined for all datatypes (e.g., via a plugin similarly to size). Its usefulness goes beyond the acyclicity rules which this thread is about. In particular, the 'proper subexpression' ordering can be used for 'strong induction' or to prove termination of functions in cases when size does not exists. (Provided that we also have the fact that this ordering is wellfounded proved.) Something along the following lines:</p>\n<p>class subexp =<br>\n  fixes subexp :: \"'a ⇒ 'a ⇒ bool\" (infixl \"⊏\" 65)<br>\n  assumes wf: \"wfP subexp\"</p>\n<p>declare [[typedef_overloaded]]</p>\n<p>bnf_axiomatization 'a F [wits: \"'a F\"]</p>\n<p>datatype x = Ctor \"x F\"</p>\n<p>instantiation x :: subexp begin</p>\n<p>definition subexp_x :: \"x ⇒ x ⇒ bool\" where<br>\n  \"subexp_x = tranclp (λx y. case y of Ctor f ⇒ x ∈ set_F f)\"</p>\n<p>instance<br>\n  apply intro_classes<br>\n  apply (unfold subexp_x_def)<br>\n  apply (rule wfP_trancl)<br>\n  apply (rule wfPUNIVI)<br>\n  subgoal premises prems for P x<br>\n    apply (induct x)<br>\n    apply (rule prems[rule_format])<br>\n    apply (simp only: <a href=\"http://x.case\">x.case</a>)<br>\n    done<br>\n  done</p>\n<p>end</p>\n<p>But one would like to have some reasonable simp rules for subexp_x (which may be as hard as the original problem that you are trying to solve). In particular, if F is itself a datatype that belongs to the subexp type class, its notion of subexp should be linked to the one of x.</p>\n<p>Dmitriy</p>\n<p>datatype 'a rtree = Leaf | Node 'a \"'a rtree list\"</p>\n<p>lemma \"Node x (a # xs) ≠ a\"<br>\n  apply simp? ―‹no_change›<br>\n  apply (rule size_neq_size_imp_neq)<br>\n  apply simp<br>\n  done</p>\n<p>lemma \"Node x [c,a,b] ≠ a\"<br>\n  apply simp? ―‹no_change›<br>\n  apply (rule size_neq_size_imp_neq)<br>\n  apply simp<br>\n  done</p>\n<p>On 2 May 2020, at 18:04, Manuel Eberl &lt;eberlm@in.tum.de&lt;mailto:<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;&gt; wrote:</p>\n<p>I attached a proof of concept (works with Isabelle 2020) using the<br>\nsimple size-based approach, including some example applications.</p>\n<p>It works well, although I'm not sure what the proper way to get the<br>\ndatatype information is (e.g. the list of all the constructors of the<br>\ndatatype and the associated other datatypes in case of mutual recursion).</p>\n<p>Is the ML interface of the BNF package documented anywhere (in<br>\nparticular this aspect)?</p>\n<p>Manuel</p>\n<p>On 02/05/2020 16:19, Manuel Eberl wrote:<br>\nTrue, but after your suggestion, I realised that the solution with the<br>\n\"proper subexpression\" relation (or, alternatively, the size function)<br>\ncombined with a simproc that produces these theorems on the spot is<br>\nactually the superior approach in every respect. It's simpler, more<br>\ngeneral, and probably more performant.</p>\n<p>I can try to come up with a proof-of-concept implementation using the<br>\nsize function approach, since that needs no additional new features from<br>\nthe BNF package.</p>\n<p>Manuel</p>\n<p>On 02/05/2020 16:16, Tobias Nipkow wrote:<br>\nA first version which only deals with depth 1 would already cover most<br>\nof the practical cases.</p>\n<p>Tobias</p>\n<p>On 02/05/2020 15:50, Manuel Eberl wrote:<br>\nThat sounds like a good idea.</p>\n<p>However, if such a simproc is to work for any nesting of<br>\nconstructors,having pre-proven theorems for every constructor will not<br>\nbe enough.Instead, I suppose one would have to introduce a<br>\n\"proper-subexpression\"relation for datatypes (e.g. xs &lt; Cons x xs) along<br>\nwith a proof thatthis relation has the obvious properties (irreflexive,<br>\nasymmetric,transitive).</p>\n<p>I guess that is something that only a datatype package plugin similar<br>\ntothe one for the \"size\" function could provide. Having looked at the<br>\ncodebriefly, I think only the people who wrote the BNF package could (or<br>\natleast should) implement that.</p>\n<p>Alternatively, one could just use the size function (as someone<br>\nalreadysuggested in this thread) to get pretty much the same thing,<br>\nexcept thatit won't work for all datatypes (e.g. infinitely branching<br>\nones).</p>\n<p>Manuel</p>\n<p>On 02/05/2020 15:36, Tobias Nipkow wrote:<br>\nI do think such rules are useful, esp if they are there by default. I<br>\nsuggest they are best handled by a simproc that is triggered by any<br>\n\"(=)\" but that checks immediately if the two argumenst are of the<br>\nappropriate type and form. That can be done very quickly (there are<br>\nsimilar simprocs already). The simproc should work for any datatype and<br>\nany degree of nesting of the constructors.</p>\n<p>Tobias</p>\n<p>On 01/05/2020 22:51, Manuel Eberl wrote:<br>\nFirstly, I don't think these theorem is especially useful. You might<br>\nhave planned to add this to the simplifier, but its term net<br>\ndoesn't do<br>\nany magic here. It will end up checking every term that matches<br>\n\"Cons x<br>\nxs = ys\" for whether \"xs\" can match \"ys\". I'm not sure if that<br>\nmatching<br>\nis equality, alpha-equivalent or unifiable.</p>\n<p>I honestly never think /that/ much about the performance<br>\nimplications of<br>\nsimp rules (as long as they're unconditional). At least for lists, by<br>\nthe way, this is already a simp rule by default though, and lists are<br>\nprobably by far the most prevalent data type in the Isabelle universe.</p>\n<p>But you're certainly right that it would make sense to keep a look at<br>\nthis performance impact if one wanted to add these to the simp set for<br>\nall datatypes by default, and I agree that the rules are probably not<br>\nhelpful /that/ often. Still, it might be nice to have them available<br>\nnonetheless.</p>\n<p>Secondly, you can prove these theorems by using this handy trivial<br>\ntheorem : \"size x ~= size y ==&gt; x ~= y\". Apparently that theorem<br>\nhas the<br>\nname  Sledgehammer.size_ne_size_imp_ne - presumably the sledgehammer<br>\nuses it to prove such inequalities.</p>\n<p>It's even easier to prove it by induction. Plus, in fact, the \"size\"<br>\nthing only works if the data type even has a sensible size function.<br>\nThat is not always the case, e.g. when you nest the datatype through a<br>\nfunction.</p>\n<p>My main point however is that when you have a datatype with a dozen<br>\nbinary constructors, there's quite a bit of copying &amp; pasting involved<br>\nbefore you've proven all those theorems. Since it can (probably) be<br>\nautomated very easily, why not do that? Whether or not these should be<br>\nsimp lemmas by default is another question.</p>\n<p>Manuel</p>\n<p>&lt;Foo.thy&gt;<br>\n</p>\n</blockquote>",
        "id": 294828342,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245455
    },
    {
        "content": "<p>From: Traytel  Dmitriy &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<blockquote>\n<p>On 4 May 2020, at 17:06, Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt; wrote:</p>\n<p>On 03/05/2020 11:46, Traytel Dmitriy wrote:</p>\n<blockquote>\n<p>while your code works for the examples you show, it does not seem to handle nested recursion.</p>\n</blockquote>\n<p>Yes, I am aware of that. Nested datatypes make things considerably more<br>\ncomplicated, so I'd rather not support that for now. I'd have to<br>\n1. somehow figure out /all/ the other datatypes involved in the<br>\ndefinition of my datatype and<br>\n2. figure out a robust way to expand their size functions.</p>\n<p>I have no idea how to do 1 with the information provided by the BNF<br>\npackage (other than inspecting the types of the constructors to figure<br>\nout the nesting).</p>\n</blockquote>\n<p>We store the BNFs that nest recursive occurrences in fp_nesting_bnfs (in fp_sugar). There is also the live_nesting_bnfs for BNFs that nest an occurrence of one of the datatype's (live) type variables. See the following examples:</p>\n<p>datatype 'a tree = Node 'a \"'a tree list\"<br>\ndatatype ('a, 'b) tree2 = Node \"'b ⇒ 'a option\" \"(('a, 'b) tree2 list × 'a) tree\"<br>\nML ‹BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name list} |&gt; the |&gt; #fp_nesting_bnfs›<br>\nML ‹BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name tree} |&gt; the |&gt; #fp_nesting_bnfs |&gt; map BNF_Def.name_of_bnf›<br>\nML ‹BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name tree} |&gt; the |&gt; #live_nesting_bnfs |&gt; map BNF_Def.name_of_bnf›<br>\nML ‹BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name tree2} |&gt; the |&gt; #fp_nesting_bnfs |&gt; map BNF_Def.name_of_bnf›<br>\nML ‹BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name tree2} |&gt; the |&gt; #live_nesting_bnfs |&gt; map BNF_Def.name_of_bnf›</p>\n<p>I'm not 100% sure whether you only need the fp_nesting_bnfs or the union of the two. And of course you will need the associated fp_sugars rather than just BNFs (for those types that are in fact datatypes), but these are easy to get once you have the names.</p>\n<blockquote>\n<p>I also have no idea how to do 2 properly – the \"size\" plugin provides<br>\nsome information with BNF_LFP_Size.size_of, but oddly enough it only<br>\nprovides the equations for the \"regular\" size function \"size\", but not<br>\nfor the generalised one (e.g. \"size_list\"), which appear in the size<br>\nfunctions of nested datatypes.</p>\n</blockquote>\n<p>Jasmin can say more but it is probably due to the fact that the old interface didn't provide the generalized equations either. You could access the equations by name (cf. \"List.list.size\"), but this is of course a bit fragile. The correct way would be to extend BNF_LFP_Size's interface. The equations should be available internally.</p>\n<blockquote>\n<p>Note that I really do want to do 2, because relying on the simplifier<br>\nitself to solve the precondition \"size lhs ≠ size rhs\" is fragile and<br>\nbreaks at least in some cases in the AFP.</p>\n</blockquote>\n<p>Makes sense.</p>\n<blockquote>\n<blockquote>\n<p>I am sympathetic to the proposal of having a 'proper<br>\nsubexpression' ordering defined for<br>\nall datatypes (e.g., via a plugin similarly to size).<br>\nIts usefulness goes beyond the<br>\nacyclicity rules which this thread is about.</p>\n</blockquote>\n<p>Absolutely! It's probably no surprise to you when I say that I won't<br>\nimplement this. But if you (or one of our other datatype experts) ever<br>\ndoes it, do let me know!</p>\n</blockquote>\n<p>I won't promise anything, but will keep this in mind for students looking for theses. :)</p>\n<blockquote>\n<blockquote>\n<p>But one would like to have some reasonable simp rules for subexp_x<br>\n(which may be as hard as the original problem that you are trying to solve). <br>\nIn particular, if F is itself a datatype that belongs to the subexp type class, <br>\nits notion of subexp should be linked to the one of x.</p>\n</blockquote>\n<p>Already for mutual and nested datatypes, you would probably need an<br>\nentire family of relations for each combination of types (e.g. if you<br>\nhave mutually recursive datatypes A and B, you would probably need<br>\nsubexpr_A_A, subexpr_A_B, subexpr_B_A, subexpr_B_B).</p>\n</blockquote>\n<p>Right, or just one subexpr_(A+B)_(A+B) which is reminiscent of what function does for mutual recursion.</p>\n<blockquote>\n<p>I guess everything gets complicated once you involve nested datatypes…</p>\n</blockquote>\n<p>Actually, no. Because nesting is handled by the virtue of BNFs (more precisely their set function) in this case. See my example, where the recursive occurrence of x was nested in F.</p>\n<p>Dmitriy</p>",
        "id": 294828351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245461
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:sewell@chalmers.se\">sewell@chalmers.se</a>&gt;<br>\nTwo quick comments on this.</p>\n<p>Firstly, I don't think these theorem is especially useful. You might have planned to add this to the simplifier, but its term net doesn't do any magic here. It will end up checking every term that matches \"Cons x xs = ys\" for whether \"xs\" can match \"ys\". I'm not sure if that matching is equality, alpha-equivalent or unifiable.</p>\n<p>Secondly, you can prove these theorems by using this handy trivial theorem : \"size x ~= size y ==&gt; x ~= y\". Apparently that theorem has the name  Sledgehammer.size_ne_size_imp_ne - presumably the sledgehammer uses it to prove such inequalities.</p>\n<p>Best regards,</p>\n<p>Thomas.</p>",
        "id": 294828495,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245517
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI cleaned up and optimised my simproc a little bit more [1] and ran some<br>\ntests [2]. In particular, I realised that it makes no sense for it to<br>\nwork on lists since other simprocs already handle the problem there.</p>\n<p>Both tests on my machine and on the Testboard seem to indicate that, on<br>\naverage, the simproc leads to about 0.7% to 1.0% slowdown (both elapsed<br>\ntime and CPU time).</p>\n<p>Tobias and I think the simproc is interesting enough to switch on by<br>\ndefault (it makes trivial and obvious proof obligations go away).</p>\n<p>Dmitriy and Jasmin were concerned that it might not be worth the<br>\nslowdown and that it should be discussed on the list. Jasmin thinks it<br>\nmight not be useful often enough to justify a 1% slowdown and should<br>\ntherefore not be enabled by default.</p>\n<p>I on the other hand think that any simproc that is not enabled by<br>\ndefault will simply never be used in practice so that if we don't enable<br>\nit by default, we might as well not have it in the first place.</p>\n<p>Feel free to weigh in on this, everyone!</p>\n<p>Manuel</p>\n<p>[1]: <a href=\"http://isabelle.in.tum.de/repos/testboard/rev/f13520ad9b93\">http://isabelle.in.tum.de/repos/testboard/rev/f13520ad9b93</a><br>\n[2]: <a href=\"https://ci.isabelle.systems/jenkins/job/testboard/320/\">https://ci.isabelle.systems/jenkins/job/testboard/320/</a></p>",
        "id": 294828510,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245523
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Firstly, I don't think these theorem is especially useful. You might<br>\nhave planned to add this to the simplifier, but its term net doesn't do<br>\nany magic here. It will end up checking every term that matches \"Cons x<br>\nxs = ys\" for whether \"xs\" can match \"ys\". I'm not sure if that matching<br>\nis equality, alpha-equivalent or unifiable.</p>\n</blockquote>\n<p>I honestly never think /that/ much about the performance implications of<br>\nsimp rules (as long as they're unconditional). At least for lists, by<br>\nthe way, this is already a simp rule by default though, and lists are<br>\nprobably by far the most prevalent data type in the Isabelle universe.</p>\n<p>But you're certainly right that it would make sense to keep a look at<br>\nthis performance impact if one wanted to add these to the simp set for<br>\nall datatypes by default, and I agree that the rules are probably not<br>\nhelpful /that/ often. Still, it might be nice to have them available<br>\nnonetheless.</p>\n<blockquote>\n<p>Secondly, you can prove these theorems by using this handy trivial<br>\ntheorem : \"size x ~= size y ==&gt; x ~= y\". Apparently that theorem has the<br>\nname  Sledgehammer.size_ne_size_imp_ne - presumably the sledgehammer<br>\nuses it to prove such inequalities.</p>\n</blockquote>\n<p>It's even easier to prove it by induction. Plus, in fact, the \"size\"<br>\nthing only works if the data type even has a sensible size function.<br>\nThat is not always the case, e.g. when you nest the datatype through a<br>\nfunction.</p>\n<p>My main point however is that when you have a datatype with a dozen<br>\nbinary constructors, there's quite a bit of copying &amp; pasting involved<br>\nbefore you've proven all those theorems. Since it can (probably) be<br>\nautomated very easily, why not do that? Whether or not these should be<br>\nsimp lemmas by default is another question.</p>\n<p>Manuel</p>",
        "id": 294828703,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245583
    }
]