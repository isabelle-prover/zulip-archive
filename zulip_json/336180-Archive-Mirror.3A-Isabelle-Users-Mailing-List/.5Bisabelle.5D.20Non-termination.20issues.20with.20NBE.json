[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I've read in the paper on Isabelle's normalisation-by-evaluation mechanism (Aehlig, <br>\nHaftmann, Nipkow, JFP 22(1), 2010) that it is supposed to delay the evaluation in the <br>\nbranches of case expressions (Section 5.2) until it is clear which case to evaluate. <br>\nUnfortunately, this seems to be broken in some cases. Here's a contrived example:</p>\n<p>definition silly :: \"nat =&gt; nat\" where \"silly _ = 0\"<br>\nlemma [code]: \"silly n = id (case n of 0 =&gt; silly (Suc 0) | Suc n =&gt; silly n)\" sorry<br>\nvalue [nbe] \"silly n\" (* does not terminate *)</p>\n<p>As the argument to silly is a variable, I would have expected that this returns \"silly n\" <br>\nor maybe \"case n of 0 =&gt; silly (Suc n) | Suc n =&gt; silly n\", but the call to value loops. <br>\nInterestingly, when I drop the \"id\" in the above code equation, then NBE does terminate <br>\nwith the expected result. Is this intended? Can I somehow enforce that the branches of a <br>\ncase are evaluated only after it is clear which branch to take?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294711863,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182449
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<p>you can inspect code generated by NBE using</p>\n<p>declare [[nbe_trace]]</p>\n<p>Note that this is extremely arcane to study, though.</p>\n<p>Concerning your particular observation: case matches are treated<br>\ndifferently a) on top level of rhs b) inside a nested term expression.</p>\n<p>a) is implemented the same way as pattern match failure on LHS: a failed<br>\npattern match advances to the next code equation.  Using the same<br>\noperational semantics in case b) would require a more sophisticated code<br>\ngeneration, either involving exceptions or some kind of option monad,<br>\nwhich we have been reluctant to undertake; instead, the case combinator<br>\nis left as it is, but the other terms of the case expression are normalized.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/E9xoTf0EWCeI2-iWR1bstCWN/signature.asc\">signature.asc</a></p>",
        "id": 294711959,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182481
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>Thanks for the quick answer. Looking at the code, I can see the difference in treatment.</p>\n<p>I had hoped that there was some clever trick to delay the normalisation of the branches in <br>\nthe code and that I might be able to use the same trick to stop NBE from expanding <br>\ncorecursive definitions for ever. But as is, it seems impossible to get lazy evaluation <br>\nwith NBE. :-(</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294712013,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182498
    }
]