[
    {
        "content": "<p>From: \"gallais @ <a href=\"http://ensl.org\">ensl.org</a>\" &lt;<a href=\"mailto:guillaume.allais@ens-lyon.org\">guillaume.allais@ens-lyon.org</a>&gt;<br>\nHi everyone,</p>\n<p>I did not find Isabelle's bug tracker so I hope that this is the place where<br>\nI'm supposed to report this.</p>\n<p>Pierre Boutillier's trick (which breaks Coq's SN) seems to work in Isabelle.<br>\nAs in Agda, we do not lose SN but we do accept a function that is not<br>\nwell-defined.</p>\n<p>================================<br>\ntheory test<br>\nimports Main</p>\n<p>begin</p>\n<p>fun f :: \"unit \\&lt;Rightarrow&gt; unit\" where<br>\n  \"f x = (\\&lt;lambda&gt; _ .  ()) (f ())\"</p>\n<p>lemma fail : \"f () \\&lt;equiv&gt; ()\"<br>\nby simp</p>\n<p>end<br>\n================================</p>\n<p>Cheers,</p>",
        "id": 294146424,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847653
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThere is no bug here. \"(% _ .  ()) (f ()) = ()\", and \"f x = ()\" is<br>\nexactly what Isabelle defines. You can see that when you look at the thm<br>\nf.simps. You may complain that Isabelle beta-reduced the rhs of your<br>\ninput string before it made the definition. You can hide the beta redex<br>\nby an explicit apply function, and then fun will no longer accept your<br>\ninput.</p>\n<p>The point is that your input string is transformed into a definition and<br>\non the way it may get modified, and this is unavoidable. Beta-reduction<br>\nis one of the possible modifications. Disambiguation on pattern matching<br>\nis another.</p>\n<p>Tobias</p>",
        "id": 294146453,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847663
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou quote this like something that is well-known in the constructive <br>\ncommunity.  Can you point to some mailing list threads discussing it, or <br>\nsimilar?</p>\n<p>On his web page, Pierre Boutillier has the following interesting <br>\nquotation:</p>\n<p>What I cannot create, I do not understand.<br>\n   Richard Feynman (Merci O. Danvy)</p>\n<p>This attitude might explain part of the confusion.  Isabelle/HOL is a very <br>\nplatonistic system, using classical mathematical principles that are not <br>\nas \"created\" as one would expect in Coq or Agda.</p>\n<p>As Tobias has already pointed out, our abstract syntax layer works modulo<br>\nvarious reductions (alpha, beta, eta) that are considered a purely <br>\nsyntactic device on the term language, without any computational idea <br>\nbehind it.  The heavy lifting is then done in classic set-theory of HOL <br>\nbehind the scenes, so that the original specification of the user is <br>\neventually derived as actual theorems (plus extra infrastructure such as <br>\nsimplification and induction rules).</p>\n<p>Back to the example:</p>\n<p>fun f :: \"unit =&gt; unit\" where ...</p>\n<p>My first reaction as a classically-mindend person: Isn't there just one <br>\nsuch function \"unit =&gt; unit\", namely \"\\&lt;lambda&gt;x. ()\", so it does not <br>\nreally matter what the user specifies or the system defines behind the <br>\nscenes, the \"fail\" result always holds universally:</p>\n<p>lemma<br>\n   fixes f :: \"unit \\&lt;Rightarrow&gt; unit\"<br>\n   shows \"f x = ()\" by (cases \"f x\")</p>\n<p>But the unit type is not really essential in the \"trick\".  Consider this <br>\nvariant:</p>\n<p>fun g :: \"'a \\&lt;Rightarrow&gt; 'a\" where<br>\n   \"g x = (\\&lt;lambda&gt;_. undefined) (g undefined)\"</p>\n<p>Here \"undefined\" is just a global unspecified constant that is used as a <br>\ndummy here.  Equally well you could have written this from the very start:</p>\n<p>fun g :: \"'a \\&lt;Rightarrow&gt; 'a\" where<br>\n   \"g x = undefined\"</p>\n<p>Here we know that \"g x\" is always that constant, without known what it is. <br>\n(It might also depend on the type 'a.)  The Isabelle/HOL library has a <br>\nslightly more constructive variant of this idea, where some overloaded <br>\nconstant \"default\" is the parameter of a type-class of the same name. <br>\nThus the value is usually known from the type structure by extra-logical <br>\nmeans, such that the code generator can use that information, for example.</p>\n<p>Makarius</p>",
        "id": 294146472,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847672
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>I did not find Isabelle's bug tracker so I hope that this is the place where<br>\nI'm supposed to report this.</p>\n</blockquote>\n<p>In principle, yes, although this concrete one is a misunderstanding. (We <br>\ncurrently have no formal tracking of bugs or misunderstandings)</p>\n<blockquote>\n<p>Pierre Boutillier's trick (which breaks Coq's SN) seems to work in Isabelle.<br>\nAs in Agda, we do not lose SN but we do accept a function that is not<br>\nwell-defined.</p>\n</blockquote>\n<p>Some further remarks:</p>\n<p>You seem to be using a specific notion of \"well-defined\", probably <br>\ncoming from constructive type theory.</p>\n<p>In HOL, there is no formal notion of well-definedness other than a very <br>\nprimitive one. Leaving pattern matching aside for now, we should rather <br>\nsay that a function (given by a recursive equation) is \"definable\", iff <br>\nthere is a HOL term that satisfies the equation (here that term is <br>\n\"\\&lt;lambda&gt; _. ()\"). Finding that term basically amounts to \"solving\" the <br>\nequation, and this is what the definition command does for you for a <br>\ncertain subclass of definable functions.</p>\n<p>Note also that Isabelle has no notion of SN other than the trivial <br>\nbeta/eta reduction of simply-typed lambda calculus. In particular, <br>\ndefinitions are not unfolded (aka reduced) automatically, unlike in Coq, <br>\nAgda etc. This means that \"f is terminating\" is merely an informal way <br>\nof saying \"f can be defined using well-founded induction\".</p>\n<p>Alex</p>",
        "id": 294146513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847687
    },
    {
        "content": "<p>From: \"gallais @ <a href=\"http://ensl.org\">ensl.org</a>\" &lt;<a href=\"mailto:guillaume.allais@ens-lyon.org\">guillaume.allais@ens-lyon.org</a>&gt;<br>\nThanks for all the comments: I now understand a bit more the philosophy<br>\nbehind Isabelle. Given that extraction remains safe (I guess that the simps<br>\nequations are the one used to generate the code?), I suppose that this is<br>\njust a matter of taste.</p>",
        "id": 294146608,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847733
    }
]