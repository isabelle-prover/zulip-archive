[
    {
        "content": "<p>From: Yann Le Du &lt;<a href=\"mailto:yledu@free.fr\">yledu@free.fr</a>&gt;<br>\nDear all,</p>\n<p>Benjamin Pierce, who suggested I should send the question that follows on<br>\nthis mailing list, writes, in the introduction to his new book on \"Software<br>\nFoundations\", that \"logic is to software engineering what calculus is to<br>\nmechanical/civil engineering\". Now that caught my attention since, as a<br>\nphysicist who recently discovered the world of formal methods thanks to<br>\nDijkstra's archives, I believe formal methods (program derivation, proof of<br>\ncorrectness, etc.) can help me in my work in physics for which I code<br>\ndifferent kinds of things including simulations and solvers. Now, following<br>\nPierce, how could I \"logicize\" my coding ?</p>\n<p>I'm very ignorant of Isabelle, I just read the back cover blurb, but let me<br>\ngo to the heart of the matter : is it possible, and advisable if we want to<br>\ndo things correctly, to code Press et al. \"Numerical Recipes\" in Isabelle<br>\n(if that has any meaning) ? How would a software engineer approach the task<br>\nof coding Numerical Recipes ? Since Isabelle, like Coq if I'm not mistaken,<br>\ncan extract Haskell/OCaml code, then am I right to envision a \"proved<br>\ncorrect\" Isabelle numerical recipe then extracted to Haskell/Ocaml and<br>\nefficiently compiled ?</p>\n<p>The answer to that central question determines the fate of many others I<br>\nhave in store !</p>\n<p>Sincerely,</p>\n<p>Yann</p>\n<p>P.S. I crosspost on the Coq and PVS mailing lists.</p>",
        "id": 294091264,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831925
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Yann,</p>\n<p>A logical account of Numerical Recipes can take on two distinct forms:</p>\n<ol>\n<li>\n<p>You give up on imperative programming, use the prover's built-in<br>\nfunctional language, and extract functional code at the end.</p>\n</li>\n<li>\n<p>You write C code and use some C verification tool that generates<br>\nproof obligations that you prove with your favourite prover.</p>\n</li>\n</ol>\n<p>Option 1 seems to be what you have in mind, which is why I will<br>\nconcentrate on it. It is the most direct approach and usually leads to<br>\nsimpler proofs.</p>\n<p>Note that I have not refered explicitly to any particular prover. Option<br>\n1 is viable with Coq, Isabelle and PVS. There are some variations on<br>\nthis approach, eg in Isabelle you could write your code in Haskell and<br>\nimport it to Isabelle for verification, which may appeal to the<br>\nprogrammer, but most of the work would still be at the Isabelle level.</p>\n<p>Is your task advisable? It should enable you to do some very interesting<br>\nresearch on the theorem proving front. Whether you will convince your<br>\ncommunity is another matter. Because, make no mistake, these proofs are<br>\nhard to push through any prover. You will not be able to just breeze<br>\nthrough Numerical Recipes and tick off one algorithm after another. For<br>\nexample, you will often have to establish quite a bit of background<br>\nmaths first that the prover does not know about. And unless you find<br>\nbugs, the response to a successful verification of a well-known<br>\nalgorithm is likely to be muted on the application front.</p>\n<p>How would a software engineer approach the task of coding Numerical<br>\nRecipes? He would draw a UML class diagram in his favourite case tool<br>\nand generate the code automatically ;-)</p>\n<p>Best<br>\nTobias</p>\n<p>PS You should also look at HOL Light<br>\n<a href=\"http://www.cl.cam.ac.uk/~jrh13/hol-light/\">http://www.cl.cam.ac.uk/~jrh13/hol-light/</a>. It does not directly support<br>\ngeneration of OCaml code (although it could) but has a first-rate<br>\nmathematics library (which we are in the process of importing to Isabelle).</p>\n<p>Yann Le Du schrieb:</p>",
        "id": 294091272,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831930
    },
    {
        "content": "<p>From: Steven Obua &lt;<a href=\"mailto:obua@wjpserver.cs.uni-sb.de\">obua@wjpserver.cs.uni-sb.de</a>&gt;<br>\nHi,</p>\n<p>this is possible in Isabelle, though it might be a little bit harder  <br>\nand cumbersome than you might imagine and the resulting code is not as  <br>\nefficient as you would like it to be :-) Recently there has been work  <br>\non computing with floating point numbers in Isabelle, and stuff like  <br>\nTaylor-approximation is available now, I think (though I do not know  <br>\nhow accessibly packaged this is).<br>\nThere is one efficiency problem: To my knowledge sabelle does not  <br>\ndirectly deal with the usual IEEE floats and doubles, but uses a pair  <br>\nof arbitrary size integers to encode a float. This and the fact that  <br>\nyour code will be functional code (as opposed to imperative code) will  <br>\nmake the compiled code way slower than if coded for example in C.</p>\n<p>Cheers,</p>\n<p>Steven Obua</p>",
        "id": 294091276,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831933
    },
    {
        "content": "<p>From: Richard Waldinger &lt;<a href=\"mailto:waldinger@AI.SRI.COM\">waldinger@AI.SRI.COM</a>&gt;<br>\nPierce is paraphrasing John McCarthy:</p>",
        "id": 294091313,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831949
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>this is possible in Isabelle, though it might be a little bit harder and<br>\ncumbersome than you might imagine and the resulting code is not as<br>\nefficient as you would like it to be :-) Recently there has been work on<br>\ncomputing with floating point numbers in Isabelle, and stuff like<br>\nTaylor-approximation is available now, I think (though I do not know how<br>\naccessibly packaged this is).</p>\n</blockquote>\n<p>Very nicely.</p>\n<blockquote>\n<p>There is one efficiency problem: To my knowledge sabelle does not<br>\ndirectly deal with the usual IEEE floats and doubles, but uses a pair of<br>\narbitrary size integers to encode a float. This and the fact that your<br>\ncode will be functional code (as opposed to imperative code) will make<br>\nthe compiled code way slower than if coded for example in C.</p>\n</blockquote>\n<p>Generating code with floats and doubles is not an issue. Of course you<br>\nneed a theory of IEEE 754 to base your verification on. There are some<br>\nin HOL (which would not be hard to port to Isabelle).</p>\n<p>You avoided machine floats because you wanted to rely on as few trusted<br>\ncomponents as possible (which is the Coq/HOL/Isabelle tradition). But<br>\nfor Numerical Recipes this would be unnatural and would appear esoteric<br>\nto that community.</p>\n<p>Tobias</p>",
        "id": 294091332,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831958
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThere is something else you have to beware of: purely functional<br>\nlanguages do not have mutable arrays! Of course you can simulate them by<br>\nlists, but the resulting code is very inefficient. Different languages<br>\nand provers have different answers to this. The Isabelle answer is the<br>\nHaskell answer: you need to write your code in a monadic style, then<br>\nIsabelle and later the Haskell compiler can generate code that updates<br>\narrays in place.</p>\n<p>Tobias</p>\n<p>Yann Le Du schrieb:</p>",
        "id": 294091349,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831964
    },
    {
        "content": "<p>From: Amine Chaieb &lt;<a href=\"mailto:ac638@cam.ac.uk\">ac638@cam.ac.uk</a>&gt;<br>\nYou might be interested in previous considerations such as described in<br>\nthis paper:</p>\n<p><a href=\"http://citeseer.ist.psu.edu/old/535034.html\">http://citeseer.ist.psu.edu/old/535034.html</a></p>\n<p>Theorem provers are not mentioned there though.</p>\n<p>Note also that functional programming does not necessarily mean less<br>\nefficiency. Purely functional programs are highly parallelizable and if<br>\nyour target programming language already provides parallel<br>\nimplementations of some key-functions like map, fold_map etc... then you<br>\ncan extract parallel code for free. This has been done for ML see for<br>\nthat e.g. Makarius's latest work<br>\n(<a href=\"http://www4.in.tum.de/~wenzelm/papers/parallel-isabelle.pdf\">http://www4.in.tum.de/~wenzelm/papers/parallel-isabelle.pdf</a>). Haskell<br>\nalso provides one of the best parallelization architectures, hopefully<br>\nOcaml will follow soon.</p>\n<p>One further point worth mentioning here is when it worth the effort to<br>\nverify/implement numerical algorithms in a theorem prover? In several<br>\ncases, it will just be sufficient to check the results. Take for example<br>\nthe simple problem of LU decomposition of a matrix. All you need is to<br>\ncompute <em>somehow</em> L and U, then check that L is upper triangular and U<br>\nis lower diagonal (very easy), and that the product is your original<br>\nmatrix. The algorithm itself need not be verified, just the results (but<br>\nhere again, each time!!). The same applies to several other problems<br>\nlike interpolation, root finding (depending on what you want to verify),<br>\nEigenvalues etc...</p>\n<p>In some cases you will need to implement and verify the full algorithm<br>\nof course. I don't see for instance a simple check for numerical<br>\nintegration.</p>\n<p>Amine.</p>\n<p>Tobias Nipkow wrote:</p>",
        "id": 294091383,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831977
    }
]