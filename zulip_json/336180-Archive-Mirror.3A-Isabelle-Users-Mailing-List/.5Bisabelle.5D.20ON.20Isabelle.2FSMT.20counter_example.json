[
    {
        "content": "<p>From: li yongjian &lt;<a href=\"mailto:lyj238@gmail.com\">lyj238@gmail.com</a>&gt;<br>\nHi:<br>\n   . I have two questions on Isabelle/SMT.</p>\n<p>1) is the intermedia formula which is tranformed from HOL formula, and<br>\nwill be fed<br>\n into z3.<br>\n2) is the counterexample format after z3 checked the formula has</p>\n<p>I use the following as a running example.</p>\n<p>lemma \"P --&gt; Q\" using [[smt_trace]] by smt;</p>\n<p>by my understanding,</p>\n<p>The intermediate formula should be a propostion logical formula in SMT<br>\nformat for<br>\n\"~(p--&gt;q)\"</p>\n<p>The counter-ex should say an assignment: P: true; and<br>\nQ:Flase.</p>\n<p>but I'm confued about the Isabelle's trace output. Can anyone explain,<br>\n(see Isabelle's output below):</p>\n<p>Does the terms f1 f2 make sense?</p>\n<p>The assignment only says P = ??.SMT.term_true, but this is not complete,<br>\nQ is False is also needed to specify?</p>\n<p>regards!</p>\n<p>f1 = ??.SMT.term_true<br>\n    f2 = ??.SMT.term_false</p>\n<p>The counterexample output is just as follows:<br>\nSMT: Assertions:<br>\n  \\&lt;not&gt; (P \\&lt;longrightarrow&gt; Q)</p>\n<p>SMT: Names:<br>\n  sorts:<br>\n    S1 = bool<br>\n  functions:<br>\n    f1 = ??.SMT.term_true<br>\n    f2 = ??.SMT.term_false<br>\n    f3 = P<br>\n    f4 = Q</p>\n<p>SMT: Problem:<br>\n  (benchmark Isabelle<br>\n  :status unknown<br>\n  :logic AUFLIA<br>\n  :extrasorts ( S1)<br>\n  :extrafuns (<br>\n    (f1 S1)<br>\n    (f2 S1)<br>\n    (f3 S1)<br>\n    (f4 S1)<br>\n  )<br>\n  :assumption (not (= f1 f2))<br>\n  :assumption (not (implies (= f3 f1) (= f4 f1)))<br>\n  :formula true)<br>\n  ; solver: z3<br>\n  ; timeout: 20.0<br>\n  ; random seed: 1<br>\n  ; arguments:<br>\n  ; DISPLAY_PROOF=true<br>\n  ; PROOF_MODE=2<br>\n  ; -rs:1<br>\n  ; MODEL=true<br>\n  ; -smt</p>\n<p>SMT: Invoking SMT solver \"z3\" ...</p>\n<p>SMT: Solver:</p>\n<p>SMT: Result:<br>\n  f2 -&gt; S1!val!1<br>\n  f1 -&gt; S1!val!0<br>\n  f3 -&gt; S1!val!0<br>\n  f4 -&gt; S1!val!2<br>\n  sat</p>\n<p>SMT: Solver z3: Counterexample found (possibly spurious):<br>\n  P = ??.SMT.term_true</p>",
        "id": 294165869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854677
    },
    {
        "content": "<p>From: Sascha Boehme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>The short answer: Counterexamples produced by SMT solvers might often  <br>\nby spurious, and the corresponding code in Isabelle/HOL is not well  <br>\ntested and currently experimental. You might instead consider Nitpick  <br>\nor Quickcheck for producing counterexamples.</p>\n<p>The long answer:</p>\n<p>The SMT interface in Isabelle/HOL applies transformations before  <br>\ngiving a formula to the SMT solver. These transformations are tuned  <br>\nfor proving a goal, but might unfortunately lead to strange  <br>\ncounterexamples.</p>\n<p>One particular transformation encodes any formula of type bool that is  <br>\nnot a Boolean constant nor a Boolean connective into an equation with  <br>\nthe constant term_true. The idea is to turn atomic formulas into terms  <br>\n(in the sense of first-order logic). These terms get a new type,  <br>\ncalled term_bool, to distinguish them from formulas. For the SMT  <br>\nsolver, the constant term_true belongs to the type term_bool.</p>\n<p>And this is what happens in your case. Your goal</p>\n<p>P --&gt; Q</p>\n<p>is transformed into</p>\n<p>(P = term_true) --&gt; (Q = term_true)</p>\n<p>where P and Q are now of type term_bool. In addition, the SMT solver  <br>\ngets the fact</p>\n<p>term_true ~= term_false</p>\n<p>Hence, it will know that there are at least two distinct values of  <br>\ntype term_bool. For the SMT solver, however, there might also be other  <br>\nvalues of type term_bool. This is because, for technical reasons, the  <br>\nSMT solver does not get an exhaustion rule such as</p>\n<p>ALL x::term_bool. x = term_true | x = term_false</p>\n<p>Therefore, an SMT counterexample produced for your goal might refer to  <br>\nfurther values of type term_bool. And indeed, this is what happens:</p>\n<blockquote>\n<p>SMT: Result:<br>\n  f2 -&gt; S1!val!1<br>\n  f1 -&gt; S1!val!0<br>\n  f3 -&gt; S1!val!0<br>\n  f4 -&gt; S1!val!2<br>\n  sat</p>\n</blockquote>\n<p>The names f1 and f2 abbreviate term_true and term_false, whereas f3  <br>\nand f4 abbreviate P and Q. The value \"S1!val!1\" is what Z3 assigns to  <br>\nterm_false. The above output can thus be read as follows: For P =  <br>\nterm_true and Q having some other value, your goal does not hold.</p>\n<p>Now, there is some piece of code in Isabelle's SMT integration that  <br>\nparses the above output and tries to turn it into a better readable  <br>\nform. It produces:</p>\n<blockquote>\n<p>SMT: Solver z3: Counterexample found (possibly spurious):<br>\n  P = ??.SMT.term_true</p>\n</blockquote>\n<p>As you already noted, a value for Q is missing. This is just one  <br>\nindication that currently the parsing code for counterexamples is just  <br>\nexperimental and not well tested. You can look at it in your Isabelle  <br>\ndistribution at src/HOL/Tools/SMT/z3_model.ML. In case, you  <br>\ndesperately need counterexamples from Z3 (or some other SMT solver)  <br>\ninstead of relying on Nitpick or Quickcheck, you are invited to extend  <br>\nand modify this code. I suggest to discuss the details privately (not  <br>\non this list).</p>\n<p>Cheers,<br>\nSascha</p>\n<p>Quoting li yongjian &lt;<a href=\"mailto:lyj238@gmail.com\">lyj238@gmail.com</a>&gt;:</p>\n<blockquote>\n<p>Hi:<br>\n   . I have two questions on Isabelle/SMT.</p>\n<p>1) is the intermedia formula which is tranformed from HOL formula, and<br>\nwill be fed<br>\n into z3.<br>\n2) is the counterexample format after z3 checked the formula has</p>\n<p>I use the following as a running example.</p>\n<p>lemma \"P --&gt; Q\" using [[smt_trace]] by smt;</p>\n<p>by my understanding,</p>\n<p>The intermediate formula should be a propostion logical formula in SMT<br>\nformat for<br>\n\"~(p--&gt;q)\"</p>\n<p>The counter-ex should say an assignment: P: true; and<br>\nQ:Flase.</p>\n<p>but I'm confued about the Isabelle's trace output. Can anyone explain,<br>\n(see Isabelle's output below):</p>\n<p>Does the terms f1 f2 make sense?</p>\n<p>The assignment only says P = ??.SMT.term_true, but this is not complete,<br>\nQ is False is also needed to specify?</p>\n<p>regards!</p>\n<p>f1 = ??.SMT.term_true<br>\n    f2 = ??.SMT.term_false</p>\n<p>The counterexample output is just as follows:<br>\nSMT: Assertions:<br>\n  \\&lt;not&gt; (P \\&lt;longrightarrow&gt; Q)</p>\n<p>SMT: Names:<br>\n  sorts:<br>\n    S1 = bool<br>\n  functions:<br>\n    f1 = ??.SMT.term_true<br>\n    f2 = ??.SMT.term_false<br>\n    f3 = P<br>\n    f4 = Q</p>\n<p>SMT: Problem:<br>\n  (benchmark Isabelle<br>\n  :status unknown<br>\n  :logic AUFLIA<br>\n  :extrasorts ( S1)<br>\n  :extrafuns (<br>\n    (f1 S1)<br>\n    (f2 S1)<br>\n    (f3 S1)<br>\n    (f4 S1)<br>\n  )<br>\n  :assumption (not (= f1 f2))<br>\n  :assumption (not (implies (= f3 f1) (= f4 f1)))<br>\n  :formula true)<br>\n  ; solver: z3<br>\n  ; timeout: 20.0<br>\n  ; random seed: 1<br>\n  ; arguments:<br>\n  ; DISPLAY_PROOF=true<br>\n  ; PROOF_MODE=2<br>\n  ; -rs:1<br>\n  ; MODEL=true<br>\n  ; -smt</p>\n<p>SMT: Invoking SMT solver \"z3\" ...</p>\n<p>SMT: Solver:</p>\n<p>SMT: Result:<br>\n  f2 -&gt; S1!val!1<br>\n  f1 -&gt; S1!val!0<br>\n  f3 -&gt; S1!val!0<br>\n  f4 -&gt; S1!val!2<br>\n  sat</p>\n<p>SMT: Solver z3: Counterexample found (possibly spurious):<br>\n  P = ??.SMT.term_true<br>\n</p>\n</blockquote>",
        "id": 294166344,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854883
    }
]