[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe following version tries to imitate what the system actually does -- <br>\nonly concerning contexts, facts and goals, without Isar proof machinery <br>\ngetting in between.</p>\n<p>ML {*<br>\n   val cert = Thm.cterm_of @{theory};<br>\n   val ctxt1 = @{context};</p>\n<p>val (_, ctxt2) = ctxt1 |&gt; Variable.add_fixes [\"P\", \"f\"];<br>\n   val [A, C] = Syntax.read_props ctxt2 [\"EX x. P (f x)\", \"EX y. P y\"];<br>\n   val ([a], ctxt3) = ctxt2<br>\n     |&gt; Variable.declare_term A<br>\n     |&gt; Variable.declare_term C<br>\n     |&gt; Assumption.add_assumes [cert A];</p>\n<p>val ((xs, [b]), ctxt4) = ctxt3<br>\n     |&gt; Obtain.result (fn _ =&gt; etac @{thm exE} 1) [a];</p>\n<p>val res = Goal.prove ctxt4 [] [] C (fn _ =&gt; rtac @{thm exI} 1 THEN rtac b 1);<br>\n   val final_res = singleton (ProofContext.export ctxt4 ctxt1) res;<br>\n*}</p>\n<p>This may also serve as an example of operations from Chapter 4 in the Isar <br>\nImplementation manual.</p>\n<p>When experimenting, you can often do it in a more light-weight fashion, <br>\ne.g. using @{cprop \"EX x. P (f x)\"} the produce a certified proposition <br>\nthat will become the assumption later.  Nonetheless, simultaneous reading <br>\nof propositions as above affects type-inference -- a priori the \"f\" and <br>\n\"P\" carry no type constraint. The fully official Variable.declare_term is <br>\nrequired in production code to get implicit polymorphism of results right, <br>\namong other things.</p>\n<p>Makarius</p>",
        "id": 294099546,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833350
    },
    {
        "content": "<p>From: Palle Raabjerg &lt;<a href=\"mailto:palle.raabjerg@it.uu.se\">palle.raabjerg@it.uu.se</a>&gt;<br>\nMakarius wrote:<br>\nThanks. It appears we are getting closer to a possible solution. But<br>\nObtain.result is still causing some headaches.<br>\nIn the specific case we are working on, we have this obtain line in Isar:<br>\nfrom <code>length xvec = length Tvec</code> <code>¬(a \\&lt;sharp&gt; xvec)</code> obtain T where<br>\n\"(Name a)[xvec:=Tvec] = T\" and \"T mem Tvec\"</p>\n<p>Which will give us the proof obligation:<br>\n(\\&lt;And&gt;T. [|Name a[xvec:=Tvec] = T; T mem Tvec|] ==&gt; thesis) ==&gt; thesis<br>\nWith the assumptions:<br>\nlength xvec = length Tvec<br>\n\\&lt;not&gt;(a \\&lt;sharp&gt; xvec)<br>\nWhich we have a tactic for solving.</p>\n<p>What confuses me is that Obtain.result takes a list of assumptions and a<br>\ntactic, and will give as output lists of bindings (witnesses) and a list<br>\nof propositions, whereas the Isar-obtain allows us to specify the<br>\nwitnesses and propositions explicitly.</p>\n<p>If we have an existentially quantified assumption and want it to become<br>\na proposition and a witness, then Obtain.result seems to work.</p>\n<p>But if I want to do something like the above, and I give the assumptions<br>\n<code>length xvec = length Tvec</code> and <code>\\&lt;not&gt;(a \\&lt;sharp&gt; xvec)</code> to<br>\nObtain.result, it simply expects us to prove ([|length xvec = length<br>\nTvec; \\&lt;not&gt;(a \\&lt;sharp&gt; xvec)|] ==&gt; thesis) ==&gt; (thesis)<br>\nwhich is not quite what we want.</p>\n<p>The Isar-obtain and Obtain.result are clearly related. But there is a<br>\ndisconnect somewhere that I don't quite understand.</p>\n<ul>\n<li>Palle Raabjerg</li>\n</ul>",
        "id": 294099901,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833450
    },
    {
        "content": "<p>From: Palle Raabjerg &lt;<a href=\"mailto:palle.raabjerg@it.uu.se\">palle.raabjerg@it.uu.se</a>&gt;<br>\nFirst, thank you for the replies to \"Structured induction with custom<br>\ntactics\". FOCUS and SUBPROOF does indeed seem to be more or less what we<br>\nwere looking for. We may have read over that particular part of the<br>\nprogramming tutorial a bit too lightly. At the time, we were also using<br>\na slightly older Isabelle version without FOCUS.</p>\n<p>Anyway. This time I have a somewhat more specific question. How do we<br>\nuse Obtain.result?</p>\n<p>For some proofs, we often need to fix variables using the Isar obtain<br>\ncommand. Obtain.result would seem to be the corresponding ML function,<br>\nbut we have so far been unable to figure out how to use it properly. And<br>\nwe may possibly be on the wrong track again.</p>\n<p>An example may be best at this stage, so let us take a simple one from<br>\nthe Isar tutorial:</p>\n<p>lemma<br>\n  assumes Pf: \"\\&lt;exists&gt;x. P(f x)\"<br>\n  shows \"\\&lt;exists&gt;y. P y\"<br>\nusing assms<br>\nproof -<br>\n  from Pf obtain x where \"P(f x)\" ..<br>\n  thus \"\\&lt;exists&gt;y. P y\" ..<br>\nqed</p>\n<p>What might that look like in ML?</p>\n<p>Regards,<br>\nPalle Raabjerg</p>",
        "id": 294102020,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834074
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 23 Feb 2010, Palle Raabjerg wrote:</p>\n<blockquote>\n<p>It appears we are getting closer to a possible solution. But <br>\nObtain.result is still causing some headaches. In the specific case we <br>\nare working on, we have this obtain line in Isar: from <code>length xvec = \nlength Tvec</code> <code>¬(a \\&lt;sharp&gt; xvec)</code> obtain T where \"(Name a)[xvec:=Tvec] = <br>\nT\" and \"T mem Tvec\"</p>\n</blockquote>\n<blockquote>\n<p>What confuses me is that Obtain.result takes a list of assumptions and a <br>\ntactic, and will give as output lists of bindings (witnesses) and a list <br>\nof propositions, whereas the Isar-obtain allows us to specify the <br>\nwitnesses and propositions explicitly.</p>\n<p>But if I want to do something like the above, and I give the assumptions<br>\n<code>length xvec = length Tvec</code> and <code>\\&lt;not&gt;(a \\&lt;sharp&gt; xvec)</code> to<br>\nObtain.result, it simply expects us to prove ([|length xvec = length<br>\nTvec; \\&lt;not&gt;(a \\&lt;sharp&gt; xvec)|] ==&gt; thesis) ==&gt; (thesis)<br>\nwhich is not quite what we want.</p>\n<p>The Isar-obtain and Obtain.result are clearly related. But there is a <br>\ndisconnect somewhere that I don't quite understand.</p>\n</blockquote>\n<p>Isar text is always based on explicit statements by the user, this is <br>\nusually easy to write and easy to read.  When working in ML, composing <br>\nstatements is often quite delicate, so Obtain.result refrains from asking <br>\nfor that.  In stead the obtained result is specified indirectly via the <br>\ngiven facts and the tactic to smash them, and extract the result context <br>\n(with local parameters and premises).</p>\n<blockquote>\n<p>If we have an existentially quantified assumption and want it to become<br>\na proposition and a witness, then Obtain.result seems to work.</p>\n</blockquote>\n<p>You can try it as follows (in ML):</p>\n<p>have \"EX x y. A x y &amp; B x y\" by your_specific_tactic<br>\n     -- \"explicit proposition composed in ML\"<br>\n   then obtain x y where \"A x y\" and \"B x y\" by (elim exE conjE)<br>\n     -- \"Obtain.result here\"</p>\n<p>Makarius</p>",
        "id": 294102311,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834166
    }
]