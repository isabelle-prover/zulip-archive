[
    {
        "content": "<p>From: Anja Gerbes &lt;<a href=\"mailto:agerb@gmx.de\">agerb@gmx.de</a>&gt;<br>\nGood evening, </p>\n<p>I am working with Isabelle, but in the following lemmas I cannot solve the problem. Can you tell me how I can complete the proof of the following lemma?</p>\n<p>lemma subst_no_occ:<br>\n shows \"\\&lt;not&gt; occ (Var v) t<br>\n     \\&lt;Longrightarrow&gt; Var v \\&lt;noteq&gt; t<br>\n     \\&lt;Longrightarrow&gt; t \\&lt;triangleleft&gt; [(v,s)] = t\"<br>\n   and \"\\&lt;not&gt; occ_list (Var v) ts<br>\n     \\&lt;Longrightarrow&gt; (\\&lt;And&gt;u. u \\&lt;in&gt; set ts<br>\n       \\&lt;Longrightarrow&gt; Var v \\&lt;noteq&gt; u)<br>\n     \\&lt;Longrightarrow&gt; apply_subst_list ts [(v,s)] = ts\"<br>\napply (induct rule: trm.inducts)<br>\napply (simp_all)<br>\n...<br>\ndone</p>\n<p>If I would find a solution, how could I prove this lemma in Isabelle, then I could continue working on this and expand the following Lemma:</p>\n<p>lemma MGU_Var[intro]: <br>\n  assumes no_occ: \"\\&lt;not&gt;occ (Var v) t\"<br>\n  shows \"MGU [(v,t)] (Var v) t\"<br>\nproof (intro MGUI exI)<br>\n  show \"Var v \\&lt;triangleleft&gt; [(v,t)] = t \\&lt;triangleleft&gt; [(v,t)]\" using no_occ<br>\n   apply (cases \"Var v = t\")<br>\n   apply (auto simp:subst_no_occ)<br>\nproof -<br>\n  fix \\&lt;theta&gt; assume th: \"Var v \\&lt;triangleleft&gt; \\&lt;theta&gt; = t \\&lt;triangleleft&gt; \\&lt;theta&gt;\" <br>\n  then have \"\\&lt;theta&gt; =\\&lt;^sub&gt;s [(v,t)] \\&lt;bullet&gt; \\&lt;theta&gt;\" <br>\n  proof -<br>\n    fix s  have \"s \\&lt;triangleleft&gt; \\&lt;theta&gt; = s \\&lt;triangleleft&gt; [(v,t)] \\&lt;bullet&gt; \\&lt;theta&gt;\" using th <br>\n      apply (induct s) <br>\n      apply (auto)<br>\n  qed<br>\nqed<br>\nqed</p>\n<p>Unfortunately I can not verify that my assumption is correct, because there must first be proved Lemma no_subst_occ for it. It would be very kind of you, if you could help me in this case.</p>\n<p>For a better understanding of the unification algorithm and further lemma is stated that I was able to prove already. I can send it to you if you want it.</p>\n<p>Greetings Anja</p>",
        "id": 294139247,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845277
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 20.07.2011 20:19, Anja Gerbes wrote:</p>\n<blockquote>\n<p>I am working with Isabelle, but in the following lemmas I cannot solve the problem. Can you tell me how I can complete the proof of the following lemma?</p>\n<p>lemma subst_no_occ:<br>\n  shows \"\\&lt;not&gt;  occ (Var v) t<br>\n      \\&lt;Longrightarrow&gt;  Var v \\&lt;noteq&gt;  t<br>\n      \\&lt;Longrightarrow&gt;  t \\&lt;triangleleft&gt;  [(v,s)] = t\"<br>\n    and \"\\&lt;not&gt;  occ_list (Var v) ts<br>\n      \\&lt;Longrightarrow&gt;  (\\&lt;And&gt;u. u \\&lt;in&gt;  set ts<br>\n        \\&lt;Longrightarrow&gt;  Var v \\&lt;noteq&gt;  u)<br>\n      \\&lt;Longrightarrow&gt;  apply_subst_list ts [(v,s)] = ts\"<br>\napply (induct rule: trm.inducts)<br>\napply (simp_all)<br>\n...<br>\ndone</p>\n</blockquote>\n<p>If proofs get more complex, it is often a good idea, to use structured <br>\nproofs instead of apply scripts (see the Isar Tutorial for an <br>\nintroduction, if you've have never worked with structured proofs).</p>\n<p>So start your proof with</p>\n<p>proof (induct rule: trm.inducts)</p>\n<p>You can use Isabelle / Show Me / Cases in Proof General, to see which <br>\ncases are there. It turns out, two of them are really easy:</p>\n<p>proof (induct rule: trm.inducts)<br>\n   case Var then show ?case by simp<br>\nnext<br>\n   case Nil_trm then show ?case by simp<br>\nnext</p>\n<p>Now, the two cases Fn and Cons_trm seem to be harder; neither simp nor <br>\nauto can solve these directly; at least, as long as you don't give <br>\nadditional lemmas. At this point, you have multiple options, amongst others:</p>\n<p>- Split the proof into smaller steps, which might be easier to solve<br>\n   - Use find_theorems to find a useful lemma, which might already<br>\n     exist, but is not known to the various automatic solvers</p>\n<p>- Often quite useful: Try sledgehammer to find proofs automatically.<br>\n     Often the proof found by sledgehammer can also help you to identify<br>\n     lemmas which enable the simplifier to find a proof.</p>\n<p>Let's have a look at Cons_trm.</p>\n<p>next<br>\n   case Cons_term then show ?case<br>\n     apply simp</p>\n<p>Still some goal left. How can we proceed? Hm, there is an \"if\" in the <br>\nhypotheses:</p>\n<p>~(if occ (Var v) trm then True else occ_list (Var v) list)</p>\n<p>By default, the simplifier only expands an \"if\", if it can simplify the <br>\ncondition to either true or false. So it might help, if we tell Isabelle <br>\nto do a case distinction on the condition:</p>\n<p>apply (cases \"occ (Var v) trm\")<br>\n     apply simp_all</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>No subgoals!</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>Nice, that helped. Instead of using cases, We can also tell the <br>\nsimplifier to split the if and just use</p>\n<p>by (simp add: split_if)</p>\n<p>instead. Now, how can we solve the last goal? Maybe \"split_if\" also <br>\nhelps us here?</p>\n<p>next<br>\n   case Fn then show ?case<br>\n     apply (simp add: split_if)</p>\n<p>No, does not seem to suffice. What's left?</p>\n<p>⟦(⋀u. u ∈ set list ⟹ Var v ≠ u) ⟹ apply_subst_list list [(v, s)] = list;<br>\n      ¬ list_ex (op = (Var v)) list ∧<br>\n      (¬ list_ex (op = (Var v)) list ⟶ ¬ occ_list (Var v) list)⟧<br>\n     ⟹ apply_subst_list list [(v, s)] = list</p>\n<p>Let's try brute force and invoke \"sledgehammer\". If I run sledgehammer <br>\non my version of Isabelle, it finds the following proof (might be <br>\ndifferent in the Isabelle 2011 release):</p>\n<p>by (metis (full_types) list_ex_iff)</p>\n<p>This is a perfectly valid proof, but often you can gain knowledge about <br>\nIsabelle's library, if you take this proof to find a new proof with the <br>\nsimplifier. So replace the proof we have till now with</p>\n<p>by (simp add: list_ex_iff split_if)<br>\nqed</p>\n<p>We're lucky, it works like a charm! Now, that we have found a proof, we <br>\ncan turn it into a really compact one: Each of our subgoals was solved <br>\nwith simp, so we replace the whole proof...qed block by</p>\n<p>by (induct rule: trm.inducts) (auto simp: list_ex_iff split_if)</p>\n<p>(auto is much like the simplifier, but uses some more techniques and <br>\napplies to all goals).</p>\n<p>So, we now have found a really compact proof. But such a short, nice <br>\nproof is often the result of some lengthy process. If you are proficient <br>\nin Isabelle's library, you are considerably faster, but such knowledge <br>\ncomes only with experience.</p>\n<p>And when you request help from others, it really helps, if you narrow <br>\nyour problem down. Instead of presenting the whole problem, just present <br>\nthe subgoal you are not able to solve; but provide enough context, that <br>\none can recreate what you have done. Exact questions have a much better <br>\nchance to be answered.</p>\n<blockquote>\n<p>If I would find a solution, how could I prove this lemma in Isabelle, then I could continue working on this and expand the following Lemma:</p>\n</blockquote>\n<p>If you are sure that a lemma holds but you don't want to prove it right <br>\nnow, you can use \"sorry\" to fake a proof (as long as you are in <br>\nquick'n'dirty mode). But of course, this always bears the risk that you <br>\nbuild your later work on sand, not on a solid fundament ...</p>\n<p>Greetings and HTH, Lars</p>",
        "id": 294139352,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845312
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 22.07.2011 10:53, Johannes Hölzl wrote:</p>\n<blockquote>\n<p>Hey, A nice description how proving in Isabelle actually works!</p>\n</blockquote>\n<p>Thanks!</p>\n<blockquote>\n<p>Just a small note about split_if:</p>\n<p>Am Donnerstag, den 21.07.2011, 19:04 +0200 schrieb Lars Noschinski:</p>\n<blockquote>\n<p>Nice, that helped. Instead of using cases, We can also tell the<br>\nsimplifier to split the if and just use</p>\n<p>by (simp add: split_if)</p>\n<p>instead. Now, how can we solve the last goal? Maybe \"split_if\" also<br>\nhelps us here?</p>\n<p>next<br>\n    case Fn then show ?case<br>\n      apply (simp add: split_if)</p>\n<p>No, does not seem to suffice. What's left?</p>\n</blockquote>\n<p>It should work with<br>\n   (simp split: split_if)<br>\ni.e. it is not a normal simp rule but added to the splitter.</p>\n</blockquote>\n<p>In this case it also works for the simplifier. Actually, I had to go to <br>\nthe old HOL manual, to find out, why one would usually use the splitter <br>\nfor this. In our case, the if is in the assumption, so one would need</p>\n<p>(simp split: split_if_asm)</p>\n<p>here instead. But I'm quite fuzzy on the semantics of the split <br>\nparameter -- why would split_if be applied to the conclusion and <br>\nsplit_if_asm to the hypotheses? Is there somewhere a high-level <br>\ndescription of the splitter?</p>\n<p>BTW: Is the isar-ref documentation about the split method correct? It <br>\ndoes not seem (and need) to accept the \"(asm)\" option?</p>\n<blockquote>\n<p>[...]</p>\n<blockquote>\n<p>Let's try brute force and invoke \"sledgehammer\". If I run sledgehammer<br>\non my version of Isabelle, it finds the following proof (might be<br>\ndifferent in the Isabelle 2011 release):</p>\n<p>by (metis (full_types) list_ex_iff)</p>\n<p>This is a perfectly valid proof, but often you can gain knowledge about<br>\nIsabelle's library, if you take this proof to find a new proof with the<br>\nsimplifier. So replace the proof we have till now with</p>\n<p>by (simp add: list_ex_iff split_if)</p>\n</blockquote>\n</blockquote>\n<p>This should be \"(auto simp add: list_ex_iff split_if)\"</p>\n<blockquote>\n<blockquote>\n<p>qed</p>\n</blockquote>\n<p>I don't have your theories but I assume (simp add: list_ex_iff) is<br>\nenough? Otherwise (simp add: list_ex_iff split: split_if) would be<br>\nrequired.</p>\n</blockquote>\n<p>[I attached theory I used] No, this does not suffice. And while</p>\n<p>(auto simp: list_ex_iff split: split_if_asm)</p>\n<p>is probably the more correct solution, mine suffices to prove this goal.</p>\n<p>-- Lars<br>\n<a href=\"/user_uploads/14278/ltqIWZCCCjgYy2gy2VIoimUp/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294139402,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845336
    }
]