[
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Anja,</p>\n<blockquote>\n<p>I can not prove the lemma, however. <br>\nCan you tell me how I should do in the proof of the <br>\nlemma continues to Isabelle runs through here?</p>\n</blockquote>\n<ol>\n<li>\n<p>For the benefit of the readers who did not follow the thread on isabelle-dev, it would help if you could provide some context and explan what you want to achieve. People here are unlikely to finish your proofs for you, but they will gladly help with conceptual roadblocks.</p>\n</li>\n<li>\n<p>The formatting of your code got lost at some point. It now looks like this:</p>\n</li>\n</ol>\n<blockquote>\n<p>datatype 'a trm =             Var 'a           | Fn 'a \"('a <br>\ntrm) list\"        <br>\n       types          'a subst = \"('a \\&lt;times&gt; 'a trm) list\"        <br>\n       text {* Applying a substitution to a variable: *}        fun assoc <br>\n:: \"'a \\&lt;Rightarrow&gt; 'b \\&lt;Rightarrow&gt; ('a \\&lt;times&gt; 'b) list \\&lt;Rightarrow&gt; <br>\n'b\"        where          \"assoc x d [] = d\"        | \"assoc x d ((p,q)#t) <br>\n= (if x = p then q else assoc x d t)\"        <br>\n       text {* Applying a substitution to a term: *}        primrec </p>\n</blockquote>\n<p>With code like this, you're unlikely to get a helpful answer.</p>\n<ol start=\"3\">\n<li>My general advice for learning Isabelle, which I've shared with your supervisor in an informal discussion earlier tonight (and he seemed not to disagree, but that could have been the wine), would be to tackle an easier problem than unification first and gain some experience and confidence doing that. Some people have observed that there's no learning curve when learning an interactive theorem prover, but rather a \"series of steep cliffs\". If the cliffs are steep, you can compensate by taking smaller strides.</li>\n</ol>\n<p>I hope this helps.</p>\n<p>Regards,</p>\n<p>Jasmin</p>",
        "id": 294139223,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845268
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nOn 07/20/2011 11:41 PM, Jasmin Blanchette wrote:</p>\n<blockquote>\n<ol>\n<li>For the benefit of the readers who did not follow the thread on<br>\nisabelle-dev, it would help if you could provide some context and<br>\nexplan what you want to achieve.<br>\n[...]</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>The formatting of your code got lost at some point.<br>\n[...]</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>My general advice for learning Isabelle, which I've shared with<br>\nyour supervisor in an informal discussion earlier tonight (and he<br>\nseemed not to disagree, but that could have been the wine), would be<br>\nto tackle an easier problem than unification first and gain some<br>\nexperience and confidence doing that.</li>\n</ol>\n</blockquote>\n<p>Let me add:</p>\n<ol start=\"4\">\n<li>Please do not attempt to send your questions/followups off-list to <br>\nindividuals who responded previously. Instead, keep the mailing list on <br>\nCc. Keeping the discussion public is important, since</li>\n</ol>\n<p>a) it ensures that others can learn from your problems/solutions,<br>\nb) it distributes the question answering workload over community members,<br>\nc) if questions are public (and permanently archived) they are often <br>\nbetter thought-out, and<br>\nd) it allows the assessment of how much of the work is actually your <br>\nown, which is important if the work is part of coursework or a thesis.</p>\n<p>Alex</p>",
        "id": 294139251,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845279
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Anja,</p>\n<p>you might also have a look at IsaFoR at <br>\n<a href=\"http://cl-informatik.uibk.ac.at/software/ceta/\">http://cl-informatik.uibk.ac.at/software/ceta/</a></p>\n<p>It contains several formalizations about terms and term rewriting, including a fully formalized unification algorithm for first order terms (theory Substitution.thy).</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294139436,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845353
    },
    {
        "content": "<p>From: Anja Gerbes &lt;<a href=\"mailto:agerb@gmx.de\">agerb@gmx.de</a>&gt;<br>\nGood evening,</p>\n<p>I can not prove the lemma, however. <br>\nCan you tell me how I should do in the proof of the <br>\nlemma continues to Isabelle runs through here?</p>\n<p>Thank you in advance</p>\n<p>Anja Gerbes        </p>\n<p>datatype 'a trm =             Var 'a           | Fn 'a \"('a <br>\ntrm) list\"        <br>\n        types          'a subst = \"('a \\&lt;times&gt; 'a trm) list\"        <br>\n        text {* Applying a substitution to a variable: *}        fun assoc <br>\n:: \"'a \\&lt;Rightarrow&gt; 'b \\&lt;Rightarrow&gt; ('a \\&lt;times&gt; 'b) list \\&lt;Rightarrow&gt; <br>\n'b\"        where          \"assoc x d [] = d\"        | \"assoc x d ((p,q)#t) <br>\n= (if x = p then q else assoc x d t)\"        <br>\n        text {* Applying a substitution to a term: *}        primrec <br>\napply_subst_list :: \"('a trm) list \\&lt;Rightarrow&gt; 'a subst \\&lt;Rightarrow&gt; ('a <br>\ntrm) list\"  and                apply_subst :: \"'a trm \\&lt;Rightarrow&gt; 'a <br>\nsubst  \\&lt;Rightarrow&gt; 'a trm\" (infixl \"\\&lt;triangleleft&gt;\" 60) where          <br>\n\"apply_subst_list [] s = []\"        | \"apply_subst_list (x#xs) s = <br>\n(apply_subst x s)#(apply_subst_list xs s)\"        | \"(Var v) <br>\n\\&lt;triangleleft&gt; s = assoc v (Var v) s\"        | \"(Fn f xs) \\&lt;triangleleft&gt; <br>\ns = (Fn f (apply_subst_list xs s))\"        <br>\n        text {* Composition of substitutions: *}        fun compose :: \"'a <br>\nsubst \\&lt;Rightarrow&gt; 'a subst \\&lt;Rightarrow&gt; 'a subst\" (infixl \"\\&lt;bullet&gt;\" <br>\n80)        where          \" [] \\&lt;bullet&gt; bl = bl\"        | \"((a,b) # al) <br>\n\\&lt;bullet&gt; bl = (a, b \\&lt;triangleleft&gt; bl) # (al \\&lt;bullet&gt; bl)\"        <br>\n        text {* Equivalence of substitutions: *}        definition eqv <br>\n(infix \"=\\&lt;^sub&gt;s\" 50)        where          \"s1 =\\&lt;^sub&gt;s s2 \\&lt;equiv&gt; <br>\n\\&lt;forall&gt;t. t \\&lt;triangleleft&gt; s1 = t \\&lt;triangleleft&gt; s2\"           <br>\n        text {* Occurs Check: *}        <br>\n        fun eq :: \"'a trm \\&lt;Rightarrow&gt; 'a trm \\&lt;Rightarrow&gt; bool\"        <br>\nwhere         \"eq x y = (if x = y then True else False)\"        <br>\n        primrec occ :: \"'a trm \\&lt;Rightarrow&gt; 'a trm \\&lt;Rightarrow&gt; bool\" and <br>\n               occ_list :: \"'a trm \\&lt;Rightarrow&gt; 'a trm list <br>\n\\&lt;Rightarrow&gt; bool\" where          \"occ u (Var v)     = False\"        | <br>\n\"occ u (Fn f xs)   = (if (list_ex (eq u) xs) then True else (occ_list u <br>\nxs))\"        | \"occ_list u []     = False\"        | \"occ_list u (x#xs) = <br>\n(if occ u x then True else occ_list u xs)\"        <br>\n        text {* Listenverarbeitung und Unifikationalgorithmus: *}        <br>\nfun  unify :: \"'a trm \\&lt;Rightarrow&gt; 'a trm \\&lt;Rightarrow&gt; 'a subst option\" <br>\nand             unify_list :: \"'a trm list \\&lt;Rightarrow&gt; 'a trm list <br>\n\\&lt;Rightarrow&gt; 'a subst option\" where          \"unify u (Var v) = (if (occ <br>\n(Var v) u)                                   then None        <br>\n                          else Some [(v, u)])\"        | \"unify <br>\n(Var v) u = (if (occ (Var v) u)                               <br>\n    then None                                  else Some <br>\n[(v, u)])\"        | \"unify (Fn f xs) (Fn g ys) = (if (f \\&lt;noteq&gt; g) then <br>\nNone else unify_list xs ys)\"          | \"unify_list [] [] = Some[]\"        <br>\n| \"unify_list (x#xs) (y#ys) = (case unify x y of                     <br>\n                       None \\&lt;Rightarrow&gt; None             <br>\n                             | Some subst \\&lt;Rightarrow&gt; case <br>\nunify_list xs ys of                                        <br>\n                     None \\&lt;Rightarrow&gt; None                <br>\n                                           | Some <br>\nsubst' \\&lt;Rightarrow&gt; Some (subst \\&lt;bullet&gt; subst'))\"        | \"unify_list _ \n_ = None\"                 subsection {* Specification: Most general <br>\nunifiers *}        <br>\n        definition          \"Unifier \\&lt;sigma&gt; t u \\&lt;equiv&gt; <br>\n(t\\&lt;triangleleft&gt;\\&lt;sigma&gt; = u\\&lt;triangleleft&gt;\\&lt;sigma&gt;)\"        <br>\n        definition          \"MGU \\&lt;sigma&gt; t u  \\&lt;equiv&gt; Unifier \\&lt;sigma&gt; t <br>\nu \\&lt;and&gt;  (\\&lt;forall&gt;\\&lt;theta&gt;. Unifier \\&lt;theta&gt; t u            <br>\n\\&lt;longrightarrow&gt; (\\&lt;exists&gt;\\&lt;gamma&gt;. \\&lt;theta&gt;  =\\&lt;^sub&gt;s \\&lt;sigma&gt; <br>\n\\&lt;bullet&gt; \\&lt;gamma&gt;))\"        <br>\n        lemma MGUI[intro]:          \"\\&lt;lbrakk&gt;t  \\&lt;triangleleft&gt; \\&lt;sigma&gt; <br>\n= u \\&lt;triangleleft&gt;  \\&lt;sigma&gt;; \\&lt;And&gt;\\&lt;theta&gt;. t \\&lt;triangleleft&gt;  \\&lt;theta&gt; <br>\n= u \\&lt;triangleleft&gt; \\&lt;theta&gt;  \\&lt;Longrightarrow&gt; \\&lt;exists&gt;\\&lt;gamma&gt;. \\&lt;theta&gt; <br>\n =\\&lt;^sub&gt;s \\&lt;sigma&gt; \\&lt;bullet&gt;  \\&lt;gamma&gt;\\&lt;rbrakk&gt;          <br>\n\\&lt;Longrightarrow&gt; MGU \\&lt;sigma&gt; t u\"          by (simp only:Unifier_def <br>\nMGU_def, auto)        <br>\n        lemma MGU_sym[sym]:          \"MGU \\&lt;sigma&gt; s t \\&lt;Longrightarrow&gt; <br>\nMGU \\&lt;sigma&gt; t s\"          by (auto simp:MGU_def Unifier_def)        <br>\n        subsection {* Basic lemmas *}        <br>\n        lemma apply_empty[simp]: \"t \\&lt;triangleleft&gt; [] = t\"        apply <br>\n(induct t)        apply (simp)        apply (simp)        apply (simp)      <br>\n  apply (simp)        done         <br>\n        lemma compose_empty[simp]: \"\\&lt;sigma&gt; \\&lt;bullet&gt; [] = \\&lt;sigma&gt;\"       <br>\n by (induct \\&lt;sigma&gt;) auto        <br>\n        lemma assoc_compose[simp]:\"assoc a (Var a) (s1 \\&lt;bullet&gt; s2) = <br>\nassoc a (Var a) s1 \\&lt;triangleleft&gt; s2\"        apply(induct_tac s1)        <br>\napply(simp)        apply(auto)        done        <br>\n        lemma  apply_compose[simp]: \"t \\&lt;triangleleft&gt; (s1 \\&lt;bullet&gt; s2) =  <br>\nt \\&lt;triangleleft&gt; s1 \\&lt;triangleleft&gt; s2\"        apply (induct t)        <br>\napply(simp)        apply(simp)        apply(simp)        apply(simp)        <br>\ndone        <br>\n        subsection {* Partial correctness *}        <br>\n        text {* Some lemmas about occ and MGU: *}        <br>\n        lemma subst_no_occ:         shows \"\\&lt;not&gt; occ (Var v) t          <br>\n   \\&lt;Longrightarrow&gt; Var v \\&lt;noteq&gt; t             \\&lt;Longrightarrow&gt; t <br>\n\\&lt;triangleleft&gt; [(v,s)] = t\"           and \"\\&lt;not&gt; occ_list (Var v) ts    <br>\n         \\&lt;Longrightarrow&gt; (\\&lt;And&gt;u. u \\&lt;in&gt; set ts              <br>\n \\&lt;Longrightarrow&gt; Var v \\&lt;noteq&gt; u)             \\&lt;Longrightarrow&gt; <br>\napply_subst_list ts [(v,s)] = ts\"        apply (induct rule: trm.inducts)   <br>\n     apply (simp_all)        ...        done</p>",
        "id": 294141964,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846145
    }
]