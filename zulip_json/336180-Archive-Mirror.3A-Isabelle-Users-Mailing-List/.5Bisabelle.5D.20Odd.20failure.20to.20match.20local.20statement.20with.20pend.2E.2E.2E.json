[
    {
        "content": "<p>From: Bertram Felgenhauer &lt;<a href=\"mailto:bertram.felgenhauer@googlemail.com\">bertram.felgenhauer@googlemail.com</a>&gt;<br>\nDear Isabelle users,</p>\n<p>I have a theory (the full theory is attached to this mail) with the<br>\nfollowing definitions,</p>\n<p>datatype tree = LeafA | LeafB | Node \"tree\" \"tree\"</p>\n<p>fun closure :: \"tree \\&lt;Rightarrow&gt; tree set\" where<br>\n    \"closure (Node r s) = { z. \\&lt;exists&gt; r' s'. r' \\&lt;in&gt; closure r<br>\n      \\&lt;and&gt; s' \\&lt;in&gt; closure s \\&lt;and&gt; z = Node r' s' }\"<br>\n  | \"closure LeafA = { LeafA }\"<br>\n  | \"closure LeafB = { LeafA, LeafB }\"</p>\n<p>The failure occurs when proving the following lemma.</p>\n<p>lemma \"closure (Node r (Node s t)) \\&lt;subseteq&gt; closure (Node (Node r s) t)\"<br>\n    unfolding closure.simps</p>\n<p>First I unfolded a couple of things,</p>\n<p>proof (rule subsetI, unfold mem_Collect_eq, elim exE conjE)</p>\n<p>and then I essentially copied the resulting goal (this explains the<br>\nhorrible variable names)</p>\n<p>fix x r' s' r'a s'a</p>\n<p>assume \"r' \\&lt;in&gt; closure r\" and \"x = Node r' s'\" and \"r'a \\&lt;in&gt; closure s\"<br>\n      and \"s'a \\&lt;in&gt; closure t\" and \"s' = Node r'a s'a\"<br>\n    thus \"\\&lt;exists&gt;r' s'.<br>\n      (\\&lt;exists&gt;r'a s'. r'a \\&lt;in&gt; closure r \\&lt;and&gt; s' \\&lt;in&gt; closure s<br>\n        \\&lt;and&gt; r' = Node r'a s') \\&lt;and&gt;<br>\n      s' \\&lt;in&gt; closure t \\&lt;and&gt; x = Node r' s'\"</p>\n<p>At this point I get a failure that I don't understand, that this<br>\nstatement fails to match the goal:</p>\n<p>*** Local statement will fail to refine any pending goal<br>\n  *** Failed attempt to solve goal by exported rule:<br>\n  ...</p>\n<p>The failure disappears if I rename the r'a to r'a' inside the existential<br>\nquantifier of the conclusion (included as a comment in the attachment),<br>\ni.e., simply by doing an alpha conversion. I find this very odd. Can<br>\nanybody explain this behaviour?</p>\n<p>Thanks in advance,</p>\n<p>Bertram</p>\n<p>P.S.</p>\n<blockquote>\n<p>isabelle version<br>\nIsabelle2011: January 2011<br>\nuname -a<br>\nLinux host 2.6.39-2-amd64 #1 SMP Wed Jun 8 11:01:04 UTC 2011 x86_64 GNU/Linux<br>\n<a href=\"/user_uploads/14278/HDKwRYq3De7z2FJxhlfMP30J/Test.thy\">Test.thy</a></p>\n</blockquote>",
        "id": 294139807,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845470
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI'm afraid I can't. In general, the name of a bound variable should be irrelevant. I considered the possibility of a hidden effect on type inference, but all variables have the same type, namely tree.</p>\n<p>Strange.</p>\n<p>Larry Paulson</p>",
        "id": 294139844,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845482
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nIndeed. When I tried to find a minimal example, I found that it goes <br>\naway, when I try to remove the initial proof steps:</p>\n<hr>\n<p>lemma \"⋀x. x ∈ {z. ∃r' s'. r' ∈ closure r ∧ s' ∈ {z. ∃r' s'. r' ∈<br>\n       closure s ∧ s' ∈ closure t ∧ z = Node r' s'} ∧ z = Node r' s'} ⟹<br>\n     x ∈ {z. ∃r' s'. r' ∈ {z. ∃r' s'. r' ∈ closure r ∧ s' ∈ closure<br>\n       s ∧ z = Node r' s'} ∧ s' ∈ closure t ∧ z = Node r' s'}\"<br>\n   apply (unfold mem_Collect_eq)<br>\n   apply (elim exE conjE)<br>\nproof -<br>\n   fix x r' s' r'a</p>\n<p>assume \"x = Node r' s'\" and \"r'a ∈ closure s\"<br>\n   then show \"∃r' s'.<br>\n     (∃r'a s'. r'a ∈ closure r ∧ s' ∈ closure s<br>\n       ∧ r' = Node r'a s') ∧<br>\n     s' ∈ closure t ∧ x = Node r' s'\"<br>\noops</p>\n<hr>\n<p>still exhibits this behabiour, but if I remove the unfold too, it goes <br>\naway. The show statement in the following snippet works just fine:</p>\n<hr>\n<p>lemma \"⋀x. ∃r' s'. r' ∈ closure r ∧ (∃r' s'a. r' ∈ closure s ∧ s'a ∈<br>\n       closure t ∧ s' = Node r' s'a) ∧ x = Node r' s' ⟹<br>\n     ∃r' s'. (∃r'a s'. r'a ∈ closure r ∧ s' ∈ closure s ∧ r' = Node r'a<br>\n       s') ∧ s' ∈ closure t ∧ x = Node r' s'\"<br>\n   apply (elim exE conjE)<br>\nproof -<br>\n   fix x r' s' r'a</p>\n<p>assume \"x = Node r' s'\" and \"r'a ∈ closure s\"<br>\n   then show \"∃r' s'.<br>\n     (∃r'a s'. r'a ∈ closure r ∧ s' ∈ closure s<br>\n       ∧ r' = Node r'a s') ∧<br>\n     s' ∈ closure t ∧ x = Node r' s'\"<br>\n     sorry<br>\noops</p>\n<hr>",
        "id": 294139896,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845488
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nHello all,</p>\n<p>As Larry stated, this is indeed a strange problem. I tried to find a <br>\nminimal example; here is what I came up with:</p>\n<hr>\n<p>lemma<br>\n   shows  \"⋀c d. d ∈ Z ⟹ x = c ⟹<br>\n         ∃e. e ∈ {_. ∃e. e ∈ Z ∧ y = e}\"<br>\n   apply (unfold mem_Collect_eq)<br>\nproof -<br>\n   fix s t<br>\n   assume \"x = s\" and \"t ∈ Z\"<br>\n   then show \"∃s t. t ∈ Z ∧ y = t\"<br>\n     sorry<br>\nqed</p>\n<hr>\n<p>The show statement fails with</p>\n<blockquote>\n<p>*** Local statement will fail to refine any pending goal<br>\n   *** Failed attempt to solve goal by exported rule:<br>\n   ...</p>\n</blockquote>\n<p>Any of the following actions will make this example succeed:</p>\n<p>- Rename any of the two existentially bound variables in the shows<br>\n    statement</p>\n<p>- Rename any of the two existentially bound variables in the show<br>\n    statement</p>\n<p>- Rename any of the variables mentioned by fix<br>\n  - Remove any one of the assume statements<br>\n  - Remove the \"apply (unfold ...)\" and state the unfolded goal directly</p>\n<p>This was tested on a relatively current repository version of Isabelle <br>\n(last week or so).</p>\n<p>-- Lars</p>",
        "id": 294139913,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845494
    },
    {
        "content": "<p>From: Bertram Felgenhauer &lt;<a href=\"mailto:bertram.felgenhauer@googlemail.com\">bertram.felgenhauer@googlemail.com</a>&gt;<br>\nHi,</p>\n<p>[...]</p>\n<p>So do we know whether this is an obscure feature or possibly a bug?<br>\n(If it's a feature I'd love to hear the underlying story.)</p>\n<p>Best regards,</p>\n<p>Bertram</p>",
        "id": 294142211,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846236
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nBertram Felgenhauer wrote:</p>\n<blockquote>\n<p>So do we know whether this is an obscure feature or possibly a bug?<br>\n(If it's a feature I'd love to hear the underlying story.)</p>\n</blockquote>\n<p>Hi,</p>\n<p>this problem has now been fixed in the repository version of Isabelle (476a239d3e0e).<br>\nIt was caused by some rather old code in Isabelle's theorem module that renamed<br>\n\"all bound variables and some unknowns\" in a rule during resolution, in order to preserve<br>\nas many of the variable names in the goal as possible. For example, when resolving the rule</p>\n<p>?P ?x ==&gt; \\&lt;exists&gt;x. P x</p>\n<p>with the proof state</p>\n<p>\\&lt;exists&gt;foo. P foo</p>\n<p>this will result in the new proof state</p>\n<p>?P ?foo</p>\n<p>because the schematic variable ?x in the rule has been renamed to match that of the<br>\nbound variable foo in the goal.<br>\nUnfortunately, such a renaming of schematic variables can cause two kinds of name clashes,<br>\nneither of which were detected by the old code:</p>\n<ol>\n<li>\n<p>If two bound variables in the goal happen to have the same name, this may cause<br>\n   two schematic variables in the rule to be mapped to the same variable:</p>\n<p>lemma R1: \"P x ==&gt; Q y ==&gt; (\\&lt;exists&gt;x. P x) \\&lt;and&gt; (\\&lt;exists&gt;y. Q y)\"<br>\n   by auto</p>\n<p>lemma \"(\\&lt;exists&gt;z. P z) \\&lt;and&gt; (\\&lt;exists&gt;z. Q z)\"<br>\n   apply (rule R1)<br>\n   oops</p>\n</li>\n<li>\n<p>If a bound variable in the goal happens to have the same name as a schematic variable<br>\n   in the rule, it may clash with another schematic variable in the rule after the<br>\n   renaming.</p>\n<p>lemma R2: \"P y ==&gt; x = y ==&gt; \\&lt;exists&gt;x. P x\"<br>\n   by auto</p>\n<p>lemma \"\\&lt;exists&gt;y. P y\"<br>\n   apply (rule R2)<br>\n   oops</p>\n</li>\n</ol>\n<p>I have now introduced a check that filters out such problematic renamings.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294142321,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846285
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nIt certainly looks like a bug to me. I don't have an idea yet of why<br>\nit happens, but I found an even smaller example. I constrained<br>\neverything to type \"nat\" just to rule out any weirdness with<br>\npolymorphism. Note the repeated bound variable name in the goal (the<br>\nargument to Q is the second \"c\", which pretty-prints as \"ca\"). This<br>\nseems to be necessary to make the error happen.</p>\n<p>lemma<br>\n  shows \"⋀(a::nat) (b::nat). P a b ⟹ ∀(c::nat) (c::nat). Q c\"<br>\nproof -<br>\n  fix s t :: nat assume \"P s t\"<br>\n  thus \"∀(s::nat) (t::nat). Q t\" (* Local statement will fail to refine... *)</p>\n<p>Swapping the order of the bound variable names in the conclusion also<br>\ngives the same error:</p>\n<p>thus \"∀(t::nat) (s::nat). Q s\"</p>\n<p>Just about any other modification to the lemma or proof that I could<br>\nthink of seems to make it work again.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294142368,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846304
    }
]