[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Alfio,</p>\n<p>it works like this</p>\n<p>lemma \"(⋀x. P x) ≡ Trueprop (∀x. P x)\"<br>\n   apply (rule)<br>\n   apply (rule allI)<br>\n   apply (assumption)<br>\n   apply (rule spec, assumption)<br>\ndone</p>\n<p>But I agree that there are some \"strange\" steps. Lets try to go through <br>\nthe proof step by step (please correct me if I claim anything wrong in <br>\nthe following ;)).</p>\n<p>In Line 1 we apply \"rule\", which on its own (without arguments) uses a <br>\ndefault rule that is determined by the syntactic structure of the goal. <br>\nSince I was not able to find any rule that directly reduces a <br>\nmeta-equality into two implications with</p>\n<p>find_theorems \"(?A ==&gt; ?B) ==&gt; (?B ==&gt; ?A) ==&gt; ?A == ?B\"</p>\n<p>but such a rule is obviously applied. This step is somewhat \"magic\" (I <br>\nguess it is part of the Isabelle/Isar/Pure framework).</p>\n<p>Lines 2 and 3 are nothing special.</p>\n<p>Line 4, applies spec directly followed by assumption (internally many <br>\nmethods do not just return a single result, but in fact an (possibly) <br>\ninfinite list of results (due to higher-order unification)). Thus, by <br>\ncomposing methods into a single apply step, we can \"pick\" the desired <br>\nresult of such a sequence, more specifically, the above states \"use the <br>\nfirst result of spec which is directly solvable by assumption\". If such <br>\na result does not exist, the composition returns an empty result <br>\nsequence (i.e., fails). If we do not compose these two steps, the first <br>\nelement of the result sequence is taken. To this end, let as have a look <br>\nat \"spec\", which is</p>\n<p>ALL x. ?P x ==&gt; ?P ?x</p>\n<p>with \"rule spec\" we try to unify the conclusion of the current goal with <br>\nthe conclusion of spec, i.e,</p>\n<p>P x with ?P ?x</p>\n<p>one possible unifier is ?x = P x and ?P = (%x. x) (the identity <br>\nfunction), instantiating spec to</p>\n<p>ALL x. (%x. x) x ==&gt; (%x. x) (P x)</p>\n<p>which is immediately beta-reduced to</p>\n<p>ALL x. x ==&gt; P x</p>\n<p>and thus explains the result of applying just \"rule spec\" without <br>\n\"assumption\".</p>\n<p>hope this helps</p>\n<p>chris</p>",
        "id": 294156750,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851509
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nThanks Christian,</p>\n<p>This was a very instructive explanation!  Besides, taking into account the<br>\nsequence<br>\nof apply steps I sent before, I have just read in the very good old<br>\ntutorial the following<br>\nstatement:</p>\n<p>\"The methods drule spec and erule allE do precisely the same inference.\"</p>\n<p>All the best!</p>",
        "id": 294156754,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851511
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nYou used a too-specific pattern with your theorem search. A term like<br>\n\"?A ==&gt; ?B\" is parsed as \"Trueprop ?A ==&gt; Trueprop ?B\", with ?A and ?B<br>\nof type \"bool\". Of course you want ?A and ?B to be parsed as type<br>\n\"prop\" here, so you need to add \"PROP\" tags to tell the parser what<br>\nyou want:</p>\n<p>find_theorems \"(PROP ?A ==&gt; PROP ?B) ==&gt; (PROP ?B ==&gt; PROP ?A) ==&gt;<br>\nPROP ?A == PROP ?B\"</p>\n<p>found 1 theorem(s):</p>\n<p>Pure.equal_intr_rule:<br>\n  [| PROP ?phi ==&gt; PROP ?psi; PROP ?psi ==&gt; PROP ?phi |] ==&gt; PROP ?phi<br>\n== PROP ?psi</p>\n<p>If there is any \"magic\" it is in the parser, which magically inserts<br>\n\"Trueprop\" everywhere unless you tell it not to. ;)</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294156768,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851518
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nOn 05/11/2012 02:27 PM, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Fri, May 11, 2012 at 6:59 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;  wrote:</p>\n<blockquote>\n<p>Since I was not able to find any rule that directly reduces a meta-equality<br>\ninto two implications with</p>\n<p>find_theorems \"(?A ==&gt;  ?B) ==&gt;  (?B ==&gt;  ?A) ==&gt;  ?A == ?B\"</p>\n<p>but such a rule is obviously applied. This step is somewhat \"magic\" (I guess<br>\nit is part of the Isabelle/Isar/Pure framework).</p>\n</blockquote>\n<p>You used a too-specific pattern with your theorem search. A term like<br>\n\"?A ==&gt;  ?B\" is parsed as \"Trueprop ?A ==&gt;  Trueprop ?B\", with ?A and ?B<br>\nof type \"bool\". Of course you want ?A and ?B to be parsed as type<br>\n\"prop\" here, so you need to add \"PROP\" tags to tell the parser what<br>\nyou want:</p>\n<p>find_theorems \"(PROP ?A ==&gt;  PROP ?B) ==&gt;  (PROP ?B ==&gt;  PROP ?A) ==&gt;<br>\nPROP ?A == PROP ?B\"</p>\n<p>found 1 theorem(s):</p>\n<p>Pure.equal_intr_rule:<br>\n   [| PROP ?phi ==&gt;  PROP ?psi; PROP ?psi ==&gt;  PROP ?phi |] ==&gt;  PROP ?phi<br>\n== PROP ?psi</p>\n<p>If there is any \"magic\" it is in the parser, which magically inserts<br>\n\"Trueprop\" everywhere unless you tell it not to. ;)<br>\nThanks, what a relief ;)</p>\n<ul>\n<li>Brian<br>\n</li>\n</ul>\n</blockquote>",
        "id": 294156778,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851524
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nBTW, src/HOL/HOL.thy subsubsection {* Atomizing meta-level connectives *} <br>\nhas proper Isar proofs for these Pure-vs-HOL theorems.  This reduces the <br>\nmagic to some extent.</p>\n<p>When showing such things in public I usually make the Trueprop explicit <br>\nlike this:</p>\n<p>notation Trueprop  (\"Tr\")</p>\n<p>or even:</p>\n<p>notation Trueprop  (\"\\&lt;^bold&gt;T\\&lt;^bold&gt;r\")</p>\n<p>Makarius</p>",
        "id": 294156794,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851536
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Users,</p>\n<p>Attached to this  e-mail is an image of small theory where I adapt an<br>\nexample of<br>\nPaulson, from the book \"ML for the Working Programmer\". I have two simple<br>\ndoubts:</p>\n<p>1) In the proof of the theorem, below in the file (and in the image), I use<br>\nrecursion induction together<br>\nwith \"induct_tac\" (as taught in the tutorial) and everything works as<br>\nexpected. However, If I try to use</p>\n<p>apply (induction b rule: NNF.induct) as suggested by the new tutorial from<br>\nTobias<br>\nNipkow (e.g., section 2.3, page 15) , I get the following error message:</p>\n<p>ill-typed instantiation: b :; 'a.</p>\n<p>Why this is so?</p>\n<p>2) This is perhaps for Makarius: In the image  one sees that I have a total<br>\nof 11 subgoals,<br>\nbut only 10 are printed. I would expect to reach the eleventh subgoal by<br>\nscrolling down in the output<br>\nwindow, but it does not work like that.</p>\n<p>Many thanks!</p>\n<p>PS: Using Isabelle-2012-RC1-Windows<br>\n<a href=\"/user_uploads/14278/9EUBbvmqeH5Y0n8XpksJXVNj/Working-Paulson-NNF-exercise.PNG\">Working-Paulson-NNF-exercise.PNG</a><br>\n<a href=\"/user_uploads/14278/okNCqhmhn59Vp64ymzM-9TTo/t1201201.thy\">t1201201.thy</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/9EUBbvmqeH5Y0n8XpksJXVNj/Working-Paulson-NNF-exercise.PNG\" title=\"Working-Paulson-NNF-exercise.PNG\"><img src=\"/user_uploads/14278/9EUBbvmqeH5Y0n8XpksJXVNj/Working-Paulson-NNF-exercise.PNG\"></a></div>",
        "id": 294161135,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853178
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Alfio,</p>\n<p>Actually this is independent from the interface you use. The number of <br>\nsubgoals that are printed is controlled by the configuration option <br>\n\"goals_limit\" (see isar-ref p. 143). You can set it like</p>\n<p>declare [[goals_limit=20]]</p>\n<p>when in theory mode (i.e., not inside a proof), or like</p>\n<p>note [[goals_limit=20]]</p>\n<p>when in proof mode. (I don't know if it is possible to set it in \"prove\" <br>\nmode however ;)).</p>\n<p>hope this helps</p>\n<p>chris</p>",
        "id": 294161143,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853180
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Alfio,</p>\n<p>\"induct\"/\"induction\" is not the same as \"induct_tac\" (all methods with a <br>\n\"_tac\" suffix are emulations for traditional tactics (as used in <br>\napply-style proofs) and are considered \"improper\" by isar-ref p. 173. <br>\nOne difference is that with traditional tactics case-analysis (case_tac) <br>\nand induction (induct_tac) is possible over meta-bound variables, for <br>\n\"induct\"/\"induction\" however, you need free variables (I guess in <br>\nreality the difference is more subtle, so please Isabelle-gurus, correct <br>\nme). Moreover your statement</p>\n<p>theorem \"∀b. ∀e. valbool b e = valbool (NNF b) e\"</p>\n<p>is a bit strange since by-default all variables are <br>\n(meta-)all-quantified after a successful proof. With proper methods you <br>\ncan proof the statement as follows:</p>\n<p>theorem \"valbool b e = valbool (NNF b) e\"<br>\n     by (induction b rule: NNF.induct) auto</p>\n<p>which is short for</p>\n<p>theorem \"valbool b e = valbool (NNF b) e\"<br>\n   apply (induction b rule: NNF.induct)<br>\n   apply (auto)<br>\n   done</p>\n<p>The resulting thm is \"valbool ?b ?e = valbool (NNF ?b) ?e\" (note the <br>\nquestion marks which mark schematic variables, i.e., variables that can <br>\nbe instantiated arbitrarily according to their type). Your original <br>\nversion results in \"ALL b e. valbool b e = valbool (NNF b) e\" (which is <br>\nequivalent, but not so nice to use, since you cannot directly <br>\ninstantiate it).</p>\n<p>hope this helps</p>\n<p>chris</p>",
        "id": 294161173,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853192
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nI was about to suggest the same thing.</p>\n<p>Another standard idiom is to use \"fix\" to introduce a new free<br>\nvariable, which can then be used with \"induct\":</p>\n<p>theorem \"\\&lt;forall&gt;b. \\&lt;forall&gt;e. valbool b e = valbool (NNF b) e\"<br>\nproof (rule allI)<br>\n  fix b<br>\n  show \"\\&lt;forall&gt;e. valbool b e = valbool (NNF b) e\"<br>\n    by (induction b rule:NNF.induct) auto<br>\nqed</p>\n<p>(Note that simply \"proof\", which applies a default intro rule, would<br>\nalso work in place of \"proof (rule allI)\".)</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294161185,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853198
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nThank you Christian!</p>\n<p>That was very helpful! Cheers</p>",
        "id": 294161287,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853233
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThis should be \"using [[goals_limit=20]]]\" then.</p>\n<p>-- Lars</p>",
        "id": 294161306,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853239
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Christian and Brian,</p>\n<p>Many thanks for your reply. Some remarks below:</p>\n<blockquote>\n<p>(all methods with a \"_tac\" suffix are emulations for traditional tactics<br>\n(as used in apply-style proofs) and are considered \"improper\" by &gt;isar-ref<br>\np. 173</p>\n</blockquote>\n<p>I looked at section 9.2.3 in the reference manual and did not find<br>\n\"induct_tac\" in the list of improper proof methods. But assuming it<br>\nis, I think that the tutorial, for instance, Chapter 2, should be updated,<br>\nshouldn´t it?</p>\n<blockquote>\n<p>Moreover your statement</p>\n</blockquote>\n<blockquote>\n<p>theorem \"∀b. ∀e. valbool b e = valbool (NNF b) e\"<br>\nis a bit strange since by-default all variables are (meta-)all-quantified<br>\nafter a successful proof. With proper methods you can proof the &gt;statement<br>\nas follows:<br>\ntheorem \"valbool b e = valbool (NNF b) e\"<br>\nby (induction b rule: NNF.induct) auto</p>\n</blockquote>\n<p>Good point. However, whenever I am playing (training) with Isabelle,<br>\nI use toy problems like this. This means that I want Isabelle to<br>\ncheck the proof I made by hand, so my level of abstraction is<br>\nthe set of rules of natural deduction. I usually play like this: first<br>\nan exploratory proof using procedural style and auto and then a<br>\ndetailed step-by-step proof using  the Isar language. I know<br>\nthat free variables become logical variables (in the sense of Prolog)<br>\nand thus, operationally behave as if the were universally quantified and<br>\ncan be used more directly by the simplifier.</p>\n<p>But at the \"playing level\" I prefer to proceed like in a hand-made proof,<br>\nfirst stripping off all the quantifiers and then applying induction. In this<br>\nkind of exercise I can use this theorem further by applying rule allE and<br>\nso on. So, I assume that this kind of approach can be only done<br>\nwith Isar and the fix command, as pointed out by Brian, which I usually<br>\ndo.</p>\n<blockquote>\n<p>Your original version results in \"ALL b e. valbool b e = valbool (NNF &gt;b)<br>\ne\" (which is equivalent, but not so nice to use, since you cannot &gt;directly<br>\ninstantiate it).</p>\n</blockquote>\n<p>I think I spoke about this above, but I would like to capture in a<br>\nprecise way (in a theorem) this equivalence. Informally we<br>\nall know that they are. I often think about it. Do you know how<br>\nto write (in Isabelle) this \"equivalence\"?</p>\n<p>All the Best!</p>\n<p>On Tue, May 8, 2012 at 2:13 AM, Christian Sternagel &lt;c-sterna@jaist.ac.jp&gt;wrote:</p>\n<blockquote>\n<p>Dear Alfio,</p>\n<p>On 05/08/2012 01:03 PM, Alfio Martini wrote:</p>\n<blockquote>\n<p>1) In the proof of the theorem, below in the file (and in the image), I<br>\nuse<br>\nrecursion induction together<br>\nwith \"induct_tac\" (as taught in the tutorial) and everything works as<br>\nexpected. However, If I try to use</p>\n<p>apply (induction b rule: NNF.induct) as suggested by the new tutorial from<br>\nTobias<br>\nNipkow (e.g., section 2.3, page 15) , I get the following error message:</p>\n<p>ill-typed instantiation: b :; 'a.</p>\n<p>Why this is so?</p>\n<p>\"induct\"/\"induction\" is not the same as \"induct_tac\" (all methods with a<br>\n\"_tac\" suffix are emulations for traditional tactics (as used in<br>\napply-style proofs) and are considered \"improper\" by isar-ref p. 173. One<br>\ndifference is that with traditional tactics case-analysis (case_tac) and<br>\ninduction (induct_tac) is possible over meta-bound variables, for<br>\n\"induct\"/\"induction\" however, you need free variables (I guess in reality<br>\nthe difference is more subtle, so please Isabelle-gurus, correct me).<br>\nMoreover your statement</p>\n</blockquote>\n<p>theorem \"∀b. ∀e. valbool b e = valbool (NNF b) e\"</p>\n<p>is a bit strange since by-default all variables are (meta-)all-quantified<br>\nafter a successful proof. With proper methods you can proof the statement<br>\nas follows:</p>\n<p>theorem \"valbool b e = valbool (NNF b) e\"<br>\n   by (induction b rule: NNF.induct) auto</p>\n<p>which is short for</p>\n<p>theorem \"valbool b e = valbool (NNF b) e\"</p>\n<p>apply (induction b rule: NNF.induct)<br>\n apply (auto)<br>\n done</p>\n<p>The resulting thm is \"valbool ?b ?e = valbool (NNF ?b) ?e\" (note the<br>\nquestion marks which mark schematic variables, i.e., variables that can be<br>\ninstantiated arbitrarily according to their type). Your original version<br>\nresults in \"ALL b e. valbool b e = valbool (NNF b) e\" (which is equivalent,<br>\nbut not so nice to use, since you cannot directly instantiate it).</p>\n<p>hope this helps</p>\n<p>chris</p>\n</blockquote>",
        "id": 294161314,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853241
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Brian,</p>\n<p>Thanks for your reply!</p>\n<blockquote>\n<p>Another standard idiom is to use \"fix\" to introduce a new free<br>\nvariable, which can then be used with \"induct\":</p>\n</blockquote>\n<blockquote>\n<p>theorem \"\\&lt;forall&gt;b. \\&lt;forall&gt;e. valbool b e = valbool (NNF b) e\"<br>\nproof (rule allI)<br>\nfix b<br>\nshow \"\\&lt;forall&gt;e. valbool b e = valbool (NNF b) e\"<br>\nby (induction b rule:NNF.induct) auto<br>\nqed</p>\n</blockquote>\n<p>That is the way I go about it when using Isar. So the question that<br>\nremains is: how to prove the theorem above (with all the (two)<br>\nquantifiers) using the procedural style (and without using induct_tac)?</p>\n<p>All the Best!</p>\n<p>On Tue, May 8, 2012 at 2:21 AM, Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>On Tue, May 8, 2012 at 7:13 AM, Christian Sternagel<br>\n&lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Alfio,<br>\n</p>\n</blockquote>\n<p>On 05/08/2012 01:03 PM, Alfio Martini wrote:</p>\n<blockquote>\n<blockquote>\n<p>1) In the proof of the theorem, below in the file (and in the image), I<br>\nuse<br>\nrecursion induction together<br>\nwith \"induct_tac\" (as taught in the tutorial) and everything works as<br>\nexpected. However, If I try to use</p>\n<p>apply (induction b rule: NNF.induct) as suggested by the new tutorial<br>\nfrom<br>\nTobias<br>\nNipkow (e.g., section 2.3, page 15) , I get the following error message:</p>\n<p>ill-typed instantiation: b :; 'a.</p>\n<p>Why this is so?</p>\n</blockquote>\n<p>\"induct\"/\"induction\" is not the same as \"induct_tac\" (all methods with a<br>\n\"_tac\" suffix are emulations for traditional tactics (as used in<br>\napply-style<br>\nproofs) and are considered \"improper\" by isar-ref p. 173. One difference<br>\nis<br>\nthat with traditional tactics case-analysis (case_tac) and induction<br>\n(induct_tac) is possible over meta-bound variables, for<br>\n\"induct\"/\"induction\"<br>\nhowever, you need free variables (I guess in reality the difference is<br>\nmore<br>\nsubtle, so please Isabelle-gurus, correct me). Moreover your statement</p>\n<p>theorem \"∀b. ∀e. valbool b e = valbool (NNF b) e\"</p>\n<p>is a bit strange since by-default all variables are (meta-)all-quantified<br>\nafter a successful proof. With proper methods you can proof the<br>\nstatement as<br>\nfollows:</p>\n<p>theorem \"valbool b e = valbool (NNF b) e\"<br>\n   by (induction b rule: NNF.induct) auto</p>\n</blockquote>\n<p>I was about to suggest the same thing.</p>\n<p>Another standard idiom is to use \"fix\" to introduce a new free<br>\nvariable, which can then be used with \"induct\":</p>\n<p>theorem \"\\&lt;forall&gt;b. \\&lt;forall&gt;e. valbool b e = valbool (NNF b) e\"<br>\nproof (rule allI)<br>\n fix b<br>\n show \"\\&lt;forall&gt;e. valbool b e = valbool (NNF b) e\"<br>\n    by (induction b rule:NNF.induct) auto<br>\nqed</p>\n<p>(Note that simply \"proof\", which applies a default intro rule, would<br>\nalso work in place of \"proof (rule allI)\".)</p>\n<ul>\n<li>Brian<br>\n</li>\n</ul>\n</blockquote>",
        "id": 294161336,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853247
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nRight! Thanks! cheers chris</p>",
        "id": 294161379,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853260
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Alfio,</p>\n<p>Maybe the closest you get to this equivalence is</p>\n<p>lemma \"(⋀x. P x) ≡ Trueprop (∀x. P x)\"<br>\n     by (rule) (rule allI, assumption, rule spec)</p>\n<p>which shows that meta-all-quantification is the same as <br>\nHOL-all-quantification. It is not possible to prove that schematic <br>\nvariables are equivalent to meta-all-quantified variables inside the <br>\nlogic. Also the need for the explicit Trueprop (which turns something of <br>\ntype \"bool\" [the type of HOL formulas] into type \"prop\" [the type of <br>\npropositions in the general Isabelle framework]) in the above proof <br>\nhints that we are doing something non-standard (for lack of a better <br>\nexpression).</p>\n<p>To convince yourself that the equivalence is not only informal, the <br>\ntheorems allI and spec should be enough.</p>\n<p>just my 2 cents</p>\n<p>chris</p>",
        "id": 294161391,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853265
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 08.05.2012 21:40, Alfio Martini wrote:</p>\n<blockquote>\n<p>I looked at section 9.2.3 in the reference manual and did not find<br>\n\"induct_tac\" in the list of improper proof methods. But assuming it<br>\nis, I think that the tutorial, for instance, Chapter 2, should be updated,<br>\nshouldn´t it?</p>\n</blockquote>\n<p>This tutorial is a bit dated (but still very useful). I think Tobias <br>\nNipkow is working on a newer version.</p>\n<blockquote>\n<p>But at the \"playing level\" I prefer to proceed like in a hand-made proof,<br>\nfirst stripping off all the quantifiers and then applying induction. In this<br>\nkind of exercise I can use this theorem further by applying rule allE and<br>\nso on. So, I assume that this kind of approach can be only done<br>\nwith Isar and the fix command, as pointed out by Brian, which I usually<br>\ndo.</p>\n</blockquote>\n<p>If you really want to do step-by-step application of natural deduction <br>\nrules, you might want to use the old-style rule_tac and erule_tac <br>\nmethods, because they allow you to instantiate meta-quantified variable <br>\n(syntax is \"rule_tac x=... in exI\").</p>\n<p>-- Lars</p>",
        "id": 294161406,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853272
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\n... both of which are definitely in the list of \"harmful\" proof methods of section 9.2.3.</p>\n<p>It would seem to me that the use of tactic emulation proof methods (i.e. methods whose name end with \"_tac\") in one place and the warnings against their use in another place reflects more the inclinations of the respective authors of these documents than the date at which these were written.</p>\n<p>Jasmin</p>",
        "id": 294161417,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853278
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIt is probably both the inclination and the date.</p>\n<p>Many years ago, Larry Paulson invented a very nice natural deduction rule <br>\nframework called Isabelle/Pure with one main composition principle called <br>\n\"RS\" (now visible in Isar as \"rule\" method or \"OF\" attribute).  For <br>\nvarious technical reasons he also added erule/drule/frule variants, and <br>\nsome means for explicit instantiations under a local quantifier <br>\nerule_tac/drule_tac/frule_tac.</p>\n<p>10 years later I came up with a natural deduction proof framework called <br>\nIsabelle/Isar.  It worked out just with the original Pure principles, the <br>\nadd-on zoo was not required.  The isar-ref manual explains this Pure style <br>\nof structured natural deduction in chapter 1 and 2.</p>\n<p>Later I also re-integrated all the old stuff into the Isabelle/Isar <br>\ninfrastructure, so that existing material could be converted to Isar <br>\nsyntax in a superficial sense, without rewriting things deeply.  Someone <br>\n(not me) invented the name \"apply style\" for this guest mode of <br>\nIsabelle/Isar.  This is the class of \"improper language elements\" within <br>\nproper Isar turned out quite succesful, so that its guest status is <br>\noccasionally forgotten.</p>\n<p>Concerning rule_tac in particular: it is already mostly obsolete in ML <br>\nbecause the FOCUS combinators address the the demand for working under <br>\nlocal quantifiers more directly.  It is a re-use of Isar proof contexts <br>\nfor ML tactic programming.</p>\n<p>Makarius</p>",
        "id": 294161489,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853290
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nNot a newer version but a completely new and much more compact document<br>\n\"Programming and Proving in Isabelle/HOL\" which you can find for example at<br>\n<a href=\"http://isabelle.in.tum.de/website-Isabelle2012-RC2/documentation.html\">http://isabelle.in.tum.de/website-Isabelle2012-RC2/documentation.html</a> and in the<br>\nrelease in a few weeks. It minimizes \"apply\" and does not introduce *rule_tac<br>\nbut structured proofs.</p>\n<p>But, as Lars wrote, that tutorial is still useful, but I do not recommend it for<br>\nbeginners anymore.</p>\n<p>Tobias</p>",
        "id": 294161527,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853303
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Christian,</p>\n<p>Thanks for your reply. The proposition below is simple and<br>\nprecise enough for me. The use of allI was clear, but I was<br>\nnot so sure about spec, to be honest.</p>\n<p>Many thanks!</p>",
        "id": 294161545,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853308
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Christian,</p>\n<p>I was a little puzzled by you \"atomic\" proof below</p>\n<p>lemma \"(⋀x. P x) ≡ Trueprop (∀x. P x)\"<br>\n   by (rule) (rule allI, assumption, rule spec)</p>\n<p>and wanted to see the details myself. But using step-by-step apply commands<br>\nthis  was the only way I could solve the goal:</p>\n<p>lemma \"(⋀x. P x) ≡ Trueprop (∀x. P x)\"<br>\n   apply (rule)<br>\n   apply (rule allI)<br>\n   apply (assumption)<br>\n   apply (rename_tac x0)<br>\n   apply (erule allE)<br>\n   apply (assumption)<br>\ndone</p>\n<p>That is to say,  I had to use \"allE\" instead of \"spec\". The renaming above<br>\nwas<br>\nincluded because I was a little confused by a scope of a specific arbitrary<br>\nvariable.</p>\n<p>best!</p>",
        "id": 294161558,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853315
    }
]