[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Kawin,</p>\n<p>Probability Mass Functions are indeed discrete distributions, not random <br>\nvariables. But you can fairly easily build complex distributions out of <br>\nsimple ones, using the monadic sequencing operator bind_pmf. The <br>\nfunction map_pmf is not as powerful.</p>\n<p>For example, to get a distribution over lists of booleans that are all <br>\nsampled independently, you could write the following probabilistic program:</p>\n<p>fun w_list_pmf :: \"nat =&gt; bool list pmf\" where<br>\n   \"w_list_pmf 0 = return_pmf []\"<br>\n| \"w_list_pmf n =<br>\n    bind_pmf (w_list_pmf (n - 1)) (%xs.<br>\n    bind_pmf (bernoulli_pmf *(1 - e) / 2)) (%x.<br>\n    return_pmf (x # xs)))\"</p>\n<p>You can also define the function Δ_n using monadic programming:</p>\n<p>definition Δ_n where \"Δ_n n =<br>\n   bind_pmf (w_list_pmf (n + 1)) (%xs.<br>\n   return_pmf (f xs - f (tl xs)))\"</p>\n<p>However, you cannot express Δ_n in terms of Φ_i, because as you have <br>\nrightly observed, once you project from the list of Bernoulli choices to <br>\na single index, then all dependencies between the choices are lost.</p>\n<p>The expectation function always takes a function to transform the <br>\nelementary events into real numbers. In case they are already real <br>\nnumbers, then the identity function id is indeed the right choice. This <br>\nadditional parameter is important to obtain nice laws for bind_pmf.</p>\n<p>The Archive of Formal Proofs contains a few entries which build on 'a <br>\npmf, but AFAIK none of them solves the issue with random variables. <br>\nEssentially, you can view a discrete random variable X as a function <br>\nfrom a probability distribution p to some other space. With 'a pmf, <br>\nyou'd model this by the term map_pmf f p.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294733873,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189076
    },
    {
        "content": "<p>From: Kawin Worrasangasilpa &lt;<a href=\"mailto:kw448@cam.ac.uk\">kw448@cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>I have been trying to deal with random variables in Isabelle/HOL for some<br>\ntime and I still can't find out how to deal with them exactly. I found in<br>\n\"HOL/Probability/Probability_Mass_Function.thy\" on how to define an \" 'a<br>\npmf \" value briefly. For example, I could use map_pmf to change to<br>\ndifferent space:</p>\n<p>context<br>\n  fixes ε :: real<br>\nbegin</p>\n<p>definition w_n :: \"nat pmf\" where<br>\n \"w_n = map_pmf (λb. (if b then 1 else 0)) (bernoulli_pmf ((1-ε)/2))\"</p>\n<p>(<em>this is to change from {True, False} to {1, 0}</em>)</p>\n<p>definition W_n :: \"int pmf\" where<br>\n \"W_n = map_pmf (λb. (-1) ^ (if b then 0 else 1)) (bernoulli_pmf ((1-ε)/2))\"<br>\n(<em>this is to change from {True, False} to {1, -1}</em>)</p>\n<p>or use lift_definition:</p>\n<p>lift_definition w_list_pmf :: \"nat ⇒ bool list pmf\" is<br>\n  \"λn (l::bool list).<br>\n    if size l = n then (((1-ε)/2)^(count (mset l) True))*((1+ε/2)^(count<br>\n(mset l) False)) else 0\"<br>\n(*this is to have a bool list random variable of fixed length and all<br>\nmembers are independent Bernoulli random variables with p = (1-ε)/2*)</p>\n<p>But when it becomes more complicated and the random variables are dependent<br>\nI have no idea how to phrase it. For example, Let us say I have a sequence<br>\nof random variables Φ_i = f (w_1w_2...w_i) (all w_i are independent<br>\nBernoulli random variables),<br>\nand then construct Δ_i = Φ_i - Φ_(i-1). The complication, in this case, is<br>\nΦ_i =  f (w_1w_2...w_i) and Φ_(i-1) f (w_1w_2...w_(i-1)) use the same w_t<br>\nsequence which are w_1,w_2,...,w_(i-1), but the first Φ also uses w_i for<br>\nthe last element in the list. So, I tried,</p>\n<p>lift_definition w_list_pmf :: \"nat ⇒ bool list pmf\" is<br>\n  \"λn (l::bool list).<br>\n    if size l = n then (((1-ε)/2)^(count (mset l) True))*((1+ε/2)^(count<br>\n(mset l) False)) else 0\"<br>\n  sorry</p>\n<p>definition Φ_n :: \"nat ⇒ real pmf\" where<br>\n  \"Φ_n n = map_pmf (λl. f l) (w_list_pmf n)\"<br>\n(*with f being any function in \"bool list =&gt; real\" and \"n\" is the lenth of<br>\nthe input list*)</p>\n<p>definition Δ_n :: \"nat ⇒ real pmf\" where<br>\n  \"Δ_n n = map_pmf<br>\n    (λp. fst p - snd p) (pair_pmf (Φ_n n) (Φ_n (n -1)))\",</p>\n<p>But I guess this makes  (Φ_n n)  and  (Φ_n(n-1)) completely independent<br>\nwhich is not what I want<br>\nsince they use common random variables in their generating process:<br>\nw_1,w_2,...,w_(i-1). So I realised that these constants of \" 'a pmf\" type<br>\nare not supposed to be used as random variables but distribution (please<br>\ncorrect me on this).</p>\n<p>Also, I would like to calculate these random variables' expectation, for<br>\nwhich I tried</p>\n<p>lemma \"n &gt; 0 ⟶<br>\n  prob_space.expectation (Δ_n n) (id) &lt; -ε\"<br>\n  sorry</p>\n<p>,and felt really doubtful of the existence of the function \"id\" since if  \"Δ_n<br>\nn\" could be used as a random variable, it wouldn't need any function to be<br>\ninvolved in calculating the expectation.<br>\nCould I ask whether there are any better ways or repositories I should<br>\ncheck to sort out this random variables issue and their expectations?</p>\n<p>Thanks,<br>\nKawin</p>",
        "id": 294736661,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661190035
    }
]