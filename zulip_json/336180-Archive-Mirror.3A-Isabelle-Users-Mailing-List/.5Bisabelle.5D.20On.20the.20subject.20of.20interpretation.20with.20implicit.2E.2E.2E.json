[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Alexander Krauss,</p>\n<p>Thank you for your reply. It is very useful to know that it is very<br>\nunlikely that it is possible to develop a general-purpose infrastructure<br>\nfor the interpretation with quantification over types. At the very least it<br>\ngives me a certain level of confidence in that the methodology that I have<br>\ndeveloped for my application cannot be significantly improved.</p>",
        "id": 294762333,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200229
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p><em>Part 1</em></p>\n<p>I am in need of an infrastructure that provides a functionality similar to<br>\nthe locale interpretation mechanism but allows one to work with the<br>\nassumptions that contain implicit quantification over types modelled via<br>\nthe use of the schematic type variables (I use the word assumption in the<br>\nmost general sense and not, necessarily, in the sense of the term that is<br>\nassociated with the Isabelle/Pure context assumptions). Thus, for example,<br>\ngiven a set A that may contain terms of different types and a polymorphic<br>\nconstant f::'a=&gt;'b=&gt;'c, such infrastructure would enable one to state that<br>\n(A, f) is a semigroup and generate the relevant semigroup theorems<br>\nautomatically in their most general form.</p>\n<p>If what I am trying to do can be easily achieved using the existing<br>\ntechnology, then I would appreciate if someone could point me in the right<br>\ndirection. If such technology is not available at the moment, in Part 2 of<br>\nthe question I describe my idea for the implementation of such<br>\ninfrastructure, but also mention certain problems with this idea. I can<br>\nonly hope that there exists a better solution and someone will be kind<br>\nenough to share it with me. Otherwise, I guess, I will have to proceed with<br>\nthe implementation of the idea that I have already developed.</p>\n<p><em>Part 2</em></p>\n<p>The second part of the question is presented in the form of an Isabelle<br>\ntheory (also please see the attachment):</p>\n<p>section ‹Example›<br>\ntheory example<br>\n  imports Main<br>\nbegin</p>\n<p>text‹Consider the following definition of a polymorphic constant<br>\n\\&lt;^text&gt;‹mkid›:›<br>\ndefinition mkid :: \"'a ⇒ 'b ⇒ 'c ⇒ 'c\"<br>\n  where \"mkid a b = id\"</p>\n<p>text‹<br>\nThe constant \\&lt;^const&gt;‹mkid› acts as a semigroup on the set of terms</p>\n<p>\\&lt;^text&gt;‹SG = {T. ∃σ. T::σ ⇒ σ}›,</p>\n<p>i.e.</p>\n<p>\\&lt;^text&gt;‹∀a b c ∈ SG. mkid a (mkid b c) = mkid (mkid a b) c›</p>\n<p>and</p>\n<p>\\&lt;^text&gt;‹∀a b ∈ SG. mkid a b = mkid b a›.</p>\n<p>It is my understanding that the theorems above can be formalized in Isabelle<br>\nunder the assumption that the schematic type variables provide a model of<br>\nthe quantification over types:<br>\n›<br>\nlemma make_id_assoc:<br>\n  \"mkid (a::'a⇒'a) (mkid (b::'b⇒'b) (c::'c⇒'c)) = mkid (mkid a b) c\"<br>\n  unfolding mkid_def by simp<br>\nlemma make_id_commute: \"mkid (a::'a⇒'a) (b::'b⇒'b) = mkid b a\"<br>\n  unfolding mkid_def by simp</p>\n<p>text ‹Given the associativity and the commutativity of \\&lt;^const&gt;‹mkid› it<br>\nis possible to prove the usual properties of the commutative semigroups for<br>\n \\&lt;^text&gt;‹(SG, mkid)›:›<br>\nlemma make_id_left_commute:<br>\n  \"mkid (b::'b⇒'b) (mkid (a::'a⇒'a) (c::'c⇒'c)) = mkid a (mkid b c)\"<br>\n  by<br>\n    (<br>\n      rule trans[<br>\n        OF make_id_assoc[<br>\n          of b a c,<br>\n          unfolded make_id_commute[of b a]<br>\n          ]<br>\n        make_id_assoc[of a b c, symmetric]<br>\n        ]<br>\n    )</p>\n<p>text ‹More generally, consider an arbitrary polymorphic constant<br>\n\\&lt;^text&gt;‹f›:›<br>\nconsts f :: \"'a ⇒ 'b ⇒ 'c\"</p>\n<p>text ‹It is possible to write a command (e.g. \\&lt;^text&gt;‹comm_sg›) that<br>\ngenerates<br>\nthe statement of the associativity and the commutativity from the<br>\nspecification<br>\nof the constant and discharges the relevant proof obligations, e.g.</p>\n<p>\\&lt;^text&gt;‹comm_sg› \\&lt;^const&gt;‹f›</p>\n<p>proof-</p>\n<p>show assoc: \"\\&lt;^const&gt;‹f› a (\\&lt;^const&gt;‹f› b c) = \\&lt;^const&gt;‹f› (\\&lt;^const&gt;‹f›<br>\na b) c\"<br>\n  for a b c<br>\n  by simp</p>\n<p>show commute: \"\\&lt;^const&gt;‹f› a b = \\&lt;^const&gt;‹f› b a\" for a b by simp</p>\n<p>qed</p>\n<p>›<br>\nlemma assoc: \"f (a::'a) (f (b::'b) (c::'c)) ≡ f (f a b) c\" sorry<br>\nlemma commute: \"f (a::'a) (b::'b) ≡ f b a\" sorry</p>\n<p>text‹<br>\nOnce the statements of the associativity and the commutativity are proven,<br>\nthe command can generate the theorems of interest that are associated with<br>\nthe<br>\ncommutative semigroups for the constant \\&lt;^const&gt;‹f›.</p>\n<p>The problem, however, is that the only method that I can think of for<br>\ngenerating such theorems is forward reasoning in ML. Effectively,<br>\nthe package would need to store the functions that can transform the<br>\ntheorems</p>\n<p>@{thm assoc}</p>\n<p>and</p>\n<p>@{thm commute}</p>\n<p>to other theorems about commutative semigroups.</p>\n<p>Therefore, I am curious whether there exists a methodology that could<br>\nsimplify<br>\nthe task of generating and proving further results given the statements<br>\nof @{thm [source] assoc} and @{thm [source] commute}. Ideally, one would<br>\nlike to develop the theory of commutative semigroups in Isar and then<br>\ninstantiate it for particular constants. However, I cannot immediately see<br>\nhow this can be achieved.<br>\n›</p>\n<p>ML ‹</p>\n<p>val ctxt = @{context};<br>\nval assoc_thm = @{thm assoc};<br>\nval commute_thm = @{thm commute};<br>\nval dS = \\&lt;^sort&gt;‹HOL.type›</p>\n<p>fun mk_left_commute ctxt =<br>\n  let</p>\n<p>val ctxt' = Variable.variant_fixes [\"a\", \"b\", \"c\"] ctxt |&gt; snd;</p>\n<p>val aT = TFree (\"'a\", dS)<br>\n    val bT = TFree (\"'b\", dS)<br>\n    val cT = TFree (\"'c\", dS)<br>\n    val fT = TFree (\"'f\", dS)<br>\n    val at = Free (\"a\", aT);<br>\n    val bt = Free (\"b\", bT);<br>\n    val ct = Free (\"c\", cT);<br>\n    val saT = TVar ((\"'a\", 0), dS)<br>\n    val sbT = TVar ((\"'b\", 0), dS)<br>\n    val scT = TVar ((\"'c\", 0), dS)<br>\n    val sfT = TVar ((\"'f\", 0), dS)<br>\n    val sat = Var ((\"a\", 0), saT);<br>\n    val sbt = Var ((\"b\", 0), sbT);<br>\n    val sct = Var ((\"c\", 0), scT);</p>\n<p>fun mk_insts (sTs, Ts) (sts, ts) =<br>\n      let<br>\n        fun mk_instsT (sTs, Ts) =<br>\n          (sTs |&gt; map dest_TVar) ~~ (Ts |&gt; map (Thm.ctyp_of ctxt'))<br>\n        val instsT = mk_instsT (sTs, Ts)<br>\n        val map_terms =<br>\n          (AList.lookup op= (instsT |&gt; map (apsnd Thm.typ_of)) #&gt; the)<br>\n          |&gt; map_type_tvar<br>\n          |&gt; map_types<br>\n        val instst =<br>\n          (sts |&gt; map map_terms |&gt; map dest_Var) ~~<br>\n          (ts |&gt; map (Thm.cterm_of ctxt))<br>\n      in (instsT, instst) end</p>\n<p>val insts = mk_insts ([saT, sbT, scT], [bT, aT, fT]) ([sat, sbt], [bt,<br>\nat])<br>\n    val step1 = Drule.instantiate_normalize insts commute_thm;</p>\n<p>val insts =<br>\n      mk_insts<br>\n        ([saT, sbT, scT, sfT], [bT, aT, cT, fT])<br>\n        ([sat, sbt, sct], [bt, at, ct]);<br>\n    val step2 = Drule.instantiate_normalize insts assoc_thm;</p>\n<p>val step3 = Local_Defs.unfold ctxt' (step1 |&gt; single) step2;</p>\n<p>val insts =<br>\n      mk_insts<br>\n        ([saT, sbT, scT, sfT], [aT, bT, cT, fT])<br>\n        ([sat, sbt, sct], [at, bt, ct]);<br>\n    val step4 = assoc_thm<br>\n      |&gt; Drule.instantiate_normalize insts<br>\n      |&gt; Thm.symmetric;<br>\n    val step5 = Thm.transitive step3 step4</p>\n<p>val result = singleton (Proof_Context.export ctxt' ctxt) step5</p>\n<p>in result end;</p>\n<p>val left_commute_thm = mk_left_commute ctxt;</p>\n<p>›</p>\n<p>local_setup ‹<br>\nLocal_Theory.note ((@{binding left_commute}, []), [left_commute_thm]) #&gt; snd<br>\n›</p>\n<p>thm left_commute</p>\n<p>end</p>\n<p>Thank you<br>\n<a href=\"/user_uploads/14278/TWlqyhRBc-cK3Fz6LD1eBvGs/example.thy\">example.thy</a></p>",
        "id": 294763632,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200824
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nAm 30.09.2019 um 01:51 schrieb mailing-list anonymous:</p>\n<blockquote>\n<p><em>Part 1</em></p>\n<p>I am in need of an infrastructure that provides a functionality similar to<br>\nthe locale interpretation mechanism but allows one to work with the<br>\nassumptions that contain implicit quantification over types modelled via<br>\nthe use of the schematic type variables</p>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p><em>Part 2</em></p>\n<p>Therefore, I am curious whether there exists a methodology that could<br>\nsimplify<br>\nthe task of generating and proving further results given the statements<br>\nof @{thm [source] assoc} and @{thm [source] commute}. Ideally, one would<br>\nlike to develop the theory of commutative semigroups in Isar and then<br>\ninstantiate it for particular constants. However, I cannot immediately see<br>\nhow this can be achieved.</p>\n</blockquote>\n<p>Experience suggests (but cannot prove) that there is no such methodology.</p>\n<p>Tools in ML can help in specific well-defined cases, but a general<br>\nlocale-like mechanism cannot exist, since we cannot state polymorphic<br>\nassumptions in HOL, so the main interpretation property cannot be stated<br>\nas a general theorem in HOL. So the only thing one can do is replay the<br>\nproof, which is what the ML function does.</p>\n<p>The typical ways out of this dilemma:</p>\n<ul>\n<li>A stronger logic with explicit polymorphism</li>\n<li>A theory that does not depend so much on polymorphism (such as set theory)</li>\n<li>Finding workarounds in concrete cases, without trying to solve the<br>\ngeneral case. What is your motivation for this?</li>\n</ul>\n<p>Alex</p>",
        "id": 294763656,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200836
    }
]