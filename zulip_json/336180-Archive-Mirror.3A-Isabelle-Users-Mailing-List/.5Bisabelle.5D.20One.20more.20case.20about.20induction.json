[
    {
        "content": "<p>From: Tambet &lt;<a href=\"mailto:qtvali@gmail.com\">qtvali@gmail.com</a>&gt;<br>\nI'm still stuck with inductive proofs. I did seek manuals of inductive<br>\nfunctions, searched Google about induction etc., but they all seem to lack<br>\nsomething.</p>\n<p>Case 1:<br>\n(* If someone would hint, how to make this a subclass of nat so that lemmas<br>\nabout nat would be used and I could use it in fix part of lemmas, it would<br>\nbe nice *)<br>\ndefinition cnat :: \"nat =&gt; bool\"     where \"cnat n = (0 &lt; n)\"</p>\n<p>(* This one is already proven - thanks to Lawrence and Rafal *)<br>\nlemma cn_is_cnat: \"cnat n ==&gt; cnat (cn n)\"</p>\n<p>(* This defines the following function - an ordered list, which will go to<br>\ninfinite cycle at end. This would be nice to have a constructor for list,<br>\nwhich contains those elements, but currently this basic syntax should be<br>\nenough? *)<br>\ninductive cf :: \"nat =&gt; nat =&gt; bool\" where<br>\n cnf[intro!]:<br>\n  \"cnat n ==&gt; cf (cn n) n\" |<br>\n cff[intro!]:<br>\n  \"cf m n ==&gt; cf (cn m) n\"</p>\n<p>(* This follows directly from cf_def and cn_is_cnat. *)<br>\nlemma cf_is_cnat: \"cnat n ==&gt; cf m n ==&gt; cnat m\"</p>\n<p>I did try strategies described in<br>\n<a href=\"http://www.mkm-ig.org/meetings/mkm06/Presentations/Wenzel.pdf\">http://www.mkm-ig.org/meetings/mkm06/Presentations/Wenzel.pdf</a></p>\n<p>For example, this:<br>\nlemma cf_is_cnat:<br>\n  assumes \"cnat n\"<br>\n  assumes f: \"cf m n\"<br>\n  shows \"cnat m\"<br>\nusing f<br>\nproof (induct n fixing: m)</p>\n<p>I would read it as that if I fix m, then I can prove general statements,<br>\nwhich hold for any m. Then I could have case with cnf followed by case with<br>\ncff and it would be proven.</p>\n<p>Anyway, what I get is that I actually could not fix m:<br>\n*** method \"HOL.induct\": bad arguments<br>\n***   : m<br>\n*** At command \"proof\".</p>\n<p>lemma cf_is_cnat:<br>\n  assumes \"cnat n\"<br>\n  assumes \"cf m n\"<br>\n  shows \"cnat m\"<br>\nproof -<br>\n  fix x<br>\n  show \"cf (cn x) x ==&gt; cnat (cn x)\"<br>\n*** Local statement will fail to refine any pending goal<br>\n*** Failed attempt to solve goal by exported rule:<br>\n***   cf (cn (?x2::nat)) ?x2 ==&gt; cnat (cn ?x2)<br>\n*** At command \"show\".</p>\n<p>Now, how could I extract the cases of definition - first case<br>\n(non-inductive) is the case \"cf (cn x) x\"; second case is the inductive case<br>\n\"cf (cn y) x\", where y is resulting \"cn ?\" from first or second case. It<br>\nshould be proven if I show that first case gives me number with property<br>\ncnat and inductive case gives me number with property cnat if it's given<br>\nnumber with property cnat.</p>\n<p>Anyway, I am unable to close such circle. I am unable to define that these<br>\nare the cases and all cases.</p>\n<p>This is the pattern from isar-overview I also tried:<br>\nlemma cf_is_cnat:<br>\n  assumes \"cnat n\"<br>\n  assumes f: \"cf m n\"<br>\n  shows \"cnat m\"<br>\nusing f<br>\nproof (induct m)<br>\n  fix x<br>\n  case \"cnat n ==&gt; cf (cn n) n\"<br>\n  case \"cnat n\"<br>\n  case \"cn n\"<br>\n  case cnf</p>\n<p>That last list of cases is all kinds of things I tried to use to point out<br>\nthat I mean the first, noninductive case there.</p>\n<p>I can understand that the best way to prove something about recursive<br>\nfunction is:</p>\n<p>- Show that the parts of function, which are not recursive (\"entry<br>\n   points\") will be True if values given have property x (and False otherwise).</p>\n<p>- Show that the parts of function, which are recursive and call those<br>\n   parts will be True if values given have property x (and False otherwise).</p>\n<p>This could be extended by having properties x, y and z and paths, which have<br>\nthis property. This is finite task to create all possible paths from one to<br>\nanother and show that iff given values have property x, y or z, then all<br>\ncalls they make have property z, y or x (for example) and thus, all paths<br>\nlead to True if input has any of such properties; then to show that some<br>\nsuch property is assumed.</p>\n<p>Anyway, I am probably lacking some critical bit of knowledge to actually<br>\ncreate such path and show about those properties ...manuals give this rather<br>\nby example, but my current tries to generalize them to my case do not meet<br>\nsome constraint if any of them is interpreted as meant at all.</p>\n<p>How to solve such cases - example for concrete examples would be nice, link<br>\nto general manual not needing too much foreknowledge would be also very<br>\nnice. Because this is totally critical for me to have such things proven to<br>\ncontinue - I can already handle the simple non-recursive proofs in many<br>\ncases, but I do not catch the logic(s?) behind cases.</p>\n<p>Tambet</p>",
        "id": 294113239,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837503
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nTambet wrote:</p>\n<blockquote>\n<p>I'm still stuck with inductive proofs. I did seek manuals of inductive<br>\nfunctions, searched Google about induction etc., but they all seem to lack<br>\nsomething.</p>\n<p>Case 1:<br>\n(* If someone would hint, how to make this a subclass of nat so that lemmas<br>\nabout nat would be used and I could use it in fix part of lemmas, it would<br>\nbe nice *)<br>\ndefinition cnat :: \"nat =&gt; bool\"     where \"cnat n = (0 &lt; n)\"</p>\n<p>(* This one is already proven - thanks to Lawrence and Rafal *)<br>\nlemma cn_is_cnat: \"cnat n ==&gt; cnat (cn n)\"</p>\n<p>(* This defines the following function - an ordered list, which will go to<br>\ninfinite cycle at end. This would be nice to have a constructor for list,<br>\nwhich contains those elements, but currently this basic syntax should be<br>\nenough? *)<br>\ninductive cf :: \"nat =&gt; nat =&gt; bool\" where<br>\n cnf[intro!]:<br>\n  \"cnat n ==&gt; cf (cn n) n\" |<br>\n cff[intro!]:<br>\n  \"cf m n ==&gt; cf (cn m) n\"</p>\n<p>(* This follows directly from cf_def and cn_is_cnat. *)<br>\nlemma cf_is_cnat: \"cnat n ==&gt; cf m n ==&gt; cnat m\"</p>\n</blockquote>\n<p>lemma cf_is_cnat: \"cf m n ==&gt; n&gt;0 ==&gt; m&gt;0\"<br>\napply(induct rule: cf.induct)<br>\napply (metis cn_is_cnat)<br>\nby (metis cn_is_cnat)</p>\n<p>You can easily turn into a structured proof.</p>\n<p>I have eliminated cnat - I don't see the point of it. More importantly,<br>\nyour whole approach is overly complicated. You want to iterate function<br>\ncn. Well, simply use function iteration: (cn^^k)(n) is the result of the<br>\nk-fold application of cn to n. See compower in theory Nat.thy.</p>\n<p>Tobias</p>\n<blockquote>\n<p>I did try strategies described in<br>\n<a href=\"http://www.mkm-ig.org/meetings/mkm06/Presentations/Wenzel.pdf\">http://www.mkm-ig.org/meetings/mkm06/Presentations/Wenzel.pdf</a></p>\n<p>For example, this:<br>\nlemma cf_is_cnat:<br>\n  assumes \"cnat n\"<br>\n  assumes f: \"cf m n\"<br>\n  shows \"cnat m\"<br>\nusing f<br>\nproof (induct n fixing: m)</p>\n<p>I would read it as that if I fix m, then I can prove general statements,<br>\nwhich hold for any m. Then I could have case with cnf followed by case with<br>\ncff and it would be proven.</p>\n<p>Anyway, what I get is that I actually could not fix m:<br>\n*** method \"HOL.induct\": bad arguments<br>\n***   : m<br>\n*** At command \"proof\".</p>\n<p>lemma cf_is_cnat:<br>\n  assumes \"cnat n\"<br>\n  assumes \"cf m n\"<br>\n  shows \"cnat m\"<br>\nproof -<br>\n  fix x<br>\n  show \"cf (cn x) x ==&gt; cnat (cn x)\"<br>\n*** Local statement will fail to refine any pending goal<br>\n*** Failed attempt to solve goal by exported rule:<br>\n***   cf (cn (?x2::nat)) ?x2 ==&gt; cnat (cn ?x2)<br>\n*** At command \"show\".</p>\n<p>Now, how could I extract the cases of definition - first case<br>\n(non-inductive) is the case \"cf (cn x) x\"; second case is the inductive case<br>\n\"cf (cn y) x\", where y is resulting \"cn ?\" from first or second case. It<br>\nshould be proven if I show that first case gives me number with property<br>\ncnat and inductive case gives me number with property cnat if it's given<br>\nnumber with property cnat.</p>\n<p>Anyway, I am unable to close such circle. I am unable to define that these<br>\nare the cases and all cases.</p>\n<p>This is the pattern from isar-overview I also tried:<br>\nlemma cf_is_cnat:<br>\n  assumes \"cnat n\"<br>\n  assumes f: \"cf m n\"<br>\n  shows \"cnat m\"<br>\nusing f<br>\nproof (induct m)<br>\n  fix x<br>\n  case \"cnat n ==&gt; cf (cn n) n\"<br>\n  case \"cnat n\"<br>\n  case \"cn n\"<br>\n  case cnf</p>\n<p>That last list of cases is all kinds of things I tried to use to point out<br>\nthat I mean the first, noninductive case there.</p>\n<p>I can understand that the best way to prove something about recursive<br>\nfunction is:</p>\n<p>- Show that the parts of function, which are not recursive (\"entry<br>\n   points\") will be True if values given have property x (and False otherwise).<br>\n   - Show that the parts of function, which are recursive and call those<br>\n   parts will be True if values given have property x (and False otherwise).</p>\n<p>This could be extended by having properties x, y and z and paths, which have<br>\nthis property. This is finite task to create all possible paths from one to<br>\nanother and show that iff given values have property x, y or z, then all<br>\ncalls they make have property z, y or x (for example) and thus, all paths<br>\nlead to True if input has any of such properties; then to show that some<br>\nsuch property is assumed.</p>\n<p>Anyway, I am probably lacking some critical bit of knowledge to actually<br>\ncreate such path and show about those properties ...manuals give this rather<br>\nby example, but my current tries to generalize them to my case do not meet<br>\nsome constraint if any of them is interpreted as meant at all.</p>\n<p>How to solve such cases - example for concrete examples would be nice, link<br>\nto general manual not needing too much foreknowledge would be also very<br>\nnice. Because this is totally critical for me to have such things proven to<br>\ncontinue - I can already handle the simple non-recursive proofs in many<br>\ncases, but I do not catch the logic(s?) behind cases.</p>\n<p>Tambet</p>\n</blockquote>",
        "id": 294113301,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837521
    }
]