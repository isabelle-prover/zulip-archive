[
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nHi!</p>\n<p>I‚Äôm looking for a proof method that is like <code>transfer</code> but transforms<br>\ninto the opposite direction.</p>\n<p>Consider, for example, the following code:</p>\n<p>axiomatization equivalence :: \"[nat, nat] ‚áí bool\" where<br>\n      is_equi<br>\nvalence:<br>\n        \"equivp equivalence\"<br>\n    and<br>\n      is_compatible_with_plus<br>\n:<br>\n        \"‚ü¶equivalence n n'; equivalence m m'‚üß ‚üπ<br>\n        equivalence (n +<br>\nm) (n' + m')\"</p>\n<p>quotient_type abstract = nat / equivalence<br>\n      using is_equivalence .</p>\n<p>lift_definition abstract_plus :: \"[abstract, abstract] ‚áí abstract\"<br>\n      is \"(+)\"<br>\n      using is_compatible_with_plus .</p>\n<p>The <code>transfer</code> method can replace equalities of <code>abstract</code> values by<br>\nequivalences of <code>nat</code> values:</p>\n<p>lemma \"abstract_plus a b = abstract_plus c d\"<br>\n    proof transfer<br>\n      ‚Äï ‚Äπyields \\&lt;^term&gt;‚Äπ‚ãÄa b c d. equivalence (a + b) (c + d)‚Ä∫‚Ä∫<br>\n      oops</p>\n<p>However, it does not perform the opposite conversion:</p>\n<p>lemma \"equivalence (a + b) (c + d)\"<br>\n    proof transfer<br>\n      ‚Äï ‚Äπalso yields \\&lt;^term&gt;‚Äπ‚ãÄa b c d. equivalence (a + b) (c + d)‚Ä∫‚Ä∫<br>\n      oops</p>\n<p>Is there a proof method that replaces equivalences by equalities on a<br>\ncorresponding quotient type? I know that there‚Äôs the <code>transferred</code><br>\nattribute, but this works only for facts, not for goals.</p>\n<p>The background of my question is that I‚Äôd like to employ the simplifier<br>\nfor reasoning with arbitrary equivalences. The idea is to reduce a goal<br>\nthat states an equivalence to a goal that states a corresponding<br>\nequality on a quotient type and then let the simplifier do equational<br>\nreasoning in that quotient type.</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759380,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198852
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nOne step in the right direction might be to invoke the simplifier using<br>\nequations auto-generated by <code>quotient_type</code> and <code>lift_definition</code>, like<br>\nso:</p>\n<p>lemma \"equivalence (a + b) (c + d)\"<br>\n    proof (simp only: abstract.abs_eq_iff [THEN sym] abstract_plus.abs_eq [THEN sym])<br>\n      ‚Äï ‚Äπyields \\&lt;^term&gt;‚Äπabstract_plus (abs_abstract a) (abs_abstract b) = abstract_plus (abs_abstract c) (abs_abstract d)‚Ä∫‚Ä∫<br>\n      oops</p>\n<p>However, I wouldn‚Äôt like to specify the rewrite rules manually like in<br>\nthis code snippet. Is there a way to automatically gather all<br>\n<code>abs_eq_iff</code> and <code>abs_eq</code> rules or perhaps only those that are related<br>\nto the equivalence relation used in the goal?</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759555,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198916
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Wolfgang,</p>\n<p>Collecting the rewrite rules will not get you very far in general, because you need a <br>\nrelational approach to deal with that; think of something like</p>\n<p>list_all2 equivalence (map ((+) x) xs) (map ((+) y) ys)</p>\n<p>That's why the transfer package uses a relation approach that is beyond the simplifier's <br>\nreach.</p>\n<p>Now, unfortunately, the transfer package does not offer a proof method to from a raw type <br>\n(nat) to an abstract type. AFAIK the main reason for that is that it typically will not <br>\nwork well. The transfer method assumes that only constants need to be replaced. This is <br>\nviolated for lift_definition when the right-hand side is a compound term, which is the <br>\nusual case.</p>\n<p>However, the whole machinery can also be made to work in the other directions; it's just <br>\nnot implemented. Alternatively, you can manually define the reversed correspondence <br>\nrelation rev_cr :: \"nat =&gt; abstract =&gt; bool\" as \"rev_cr = conversep cr_abstract\" and adapt <br>\nthe transfer rules accordingly. But that's quite a bit of manual work.</p>\n<p>Finally, the old quotient package by Cezary and Urban supports transferring in both <br>\ndirections (Section 11.9.4 in isar-ref: quotient_definition instead of lift_definition, <br>\nmethods lifting and descending). They also have the restriction in place that the raw term <br>\nmust be a constant. Note however that this package is not so well integrated into the HOL <br>\nlibrary as transfer.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294759871,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199051
    },
    {
        "content": "<p>From: \"Thiemann, Ren√©\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nHi Wolfgang,</p>\n<p>I‚Äôm unsure whether there is a proof method, however there is the ‚Äúuntransferred‚Äù attribute that<br>\nworks in the opposite direction. So also transfer is to a certain extend bidirectional.</p>\n<p>lemma \"equivalence (a + b) (c + d)\"<br>\nproof -<br>\n  have \"abstract_plus a b = abstract_plus c d\" for a b c d sorry<br>\n  from this[untransferred] show ?thesis .<br>\nqed</p>\n<p>Perhaps this solves your goal.</p>\n<p>Best,<br>\nRen√©</p>",
        "id": 294759936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199075
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nDear Andreas,</p>\n<p>thanks a lot for your response.</p>\n<blockquote>\n<p>Collecting the rewrite rules will not get you very far in general,<br>\nbecause you need a relational approach to deal with that; think of<br>\nsomething like</p>\n<p>list_all2 equivalence (map ((+) x) xs) (map ((+) y) ys)</p>\n<p>That‚Äôs why the transfer package uses a relation approach that is<br>\nbeyond the simplifier‚Äôs reach.</p>\n</blockquote>\n<p>Well, in my use cases, premises and conclusions are always applications<br>\nof equivalence relations. I guess invoking those rewrite rules will work<br>\nfor turning these applications of equivalence relations into equalities<br>\non the quotient type. However, I‚Äôd still like to avoid this approach,<br>\nsince it means too much manual work for my taste.</p>\n<blockquote>\n<p>Finally, the old quotient package by Cezary and Urban supports<br>\ntransferring in both directions (Section 11.9.4 in <code>isar-ref</code>:<br>\n<code>quotient_definition</code> instead of <code>lift_definition</code>, methods <code>lifting</code><br>\nand <code>descending</code>).</p>\n</blockquote>\n<p>I tried with the old quotient package, but it didn‚Äôt work for me.<br>\nConsider my example code adapted to the old package:</p>\n<p>axiomatization equivalence :: \"[nat, nat] ‚áí bool\" where<br>\n      is_equivalence:<br>\n        \"equivp equivalence\"<br>\n    and<br>\n      is_compatible_with_plus:<br>\n        \"‚ü¶equivalence n n'; equivalence m m'‚üß ‚üπ<br>\n        equivalence (n + m) (n' + m')\"</p>\n<p>quotient_type abstract = nat / equivalence<br>\n      using is_equivalence .</p>\n<p>quotient_definition \"abstract_plus :: [abstract, abstract] ‚áí abstract\"<br>\n      is \"(+) :: [nat, nat] ‚áí nat\"<br>\n      using is_compatible_with_plus .</p>\n<p>Now assume I have a goal <code>equivalence (a + b) (c + d)</code> and I want it to<br>\nbe turned into the goal <code>abstract_plus x y = abstract_plus z u</code>. Neither<br>\napplying <code>lifting</code> nor applying <code>descending</code> does that: <code>lifting</code> leaves<br>\nthe goal in place; <code>descending</code> just adds explicit universal<br>\nquantification of the variables via <code>‚ãÄ</code>. What am I doing wrong here?</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759961,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199087
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nHi, Ren√©!</p>\n<p>Thanks a lot for your response.</p>\n<p>Technically, your solution would work. However, it would mean that the<br>\nuser would have to add a considerable amount of boilerplate, because<br>\nstating the equations on the quotient types is necessary.</p>\n<p>Maybe I should explain a bit more the background of my question.</p>\n<p>I‚Äôm working with a process calculus. I have an algebraic data type<br>\n<code>process</code> of processes (or rather process terms) and several<br>\nbisimilarity relations, which describe different notions of behavioral<br>\nequivalence.</p>\n<p>Most of the proofs I‚Äôm conducting are proofs of bisimilarities, proving<br>\ngoals of the form <code>p ‚àº q</code> where <code>p</code> and <code>q</code> are processes and <code>(‚àº)</code> is<br>\none of the bisimilarity relations. In many of these proofs, I‚Äôm using<br>\ncalculational reasoning, exploiting the fact that <code>(‚àº)</code> is transitive.</p>\n<p>There are certain core facts about the bisimilarity relations that state<br>\nthings like transitivity and commutativity of certain process operators<br>\nmodulo bisimilarity, things like <code>(p ‚à• q) ‚à• r ‚àº p ‚à• (q ‚à• r)</code> and <code>p ‚à• q\n‚àº q ‚à• p</code>. Having to apply these facts manually in the proofs is really<br>\npainful. My goal is to have a proof method that applies such technical<br>\nfacts as rewrite rules, analogously to what the simplifier does with<br>\nequations.</p>\n<p>For example, in a proof I might have something like the following:</p>\n<p>from \"p ‚àº q ‚à• r\" have \"p ‚à• q ‚àº r ‚à• (q ‚à• q)\" sorry</p>\n<p>I‚Äôd like to replace the <code>sorry</code> with something as simple as <code>by simp</code>.<br>\nWhile your approach would work, it would mean I had to add a quotient<br>\ntype version of every single proof step.</p>\n<p>Of course, it would be an option to translate the overall bisimilarity<br>\ngoal of each proof into a goal about quotient type equations and then<br>\nreason in the quotient type throughout the proof. However, this would<br>\nfeel quite unnatural to me. The main reason is that there‚Äôs not a single<br>\nbest bisimilarity but there are multiple ones; so I would have to work<br>\nwith several quotient types and convert back and forth between them.</p>\n<p>I was considering using quotient types only internally as a means to<br>\nmake the simplifier reason with arbitrary equivalences. The basic idea<br>\nis to translate both the goal and the rewrite rules (like <code>p ‚à• q ‚àº\nq ‚à• p</code>) into statements that use equality on quotient types and then<br>\nemploy the simplifier to solve the new goals entirely.</p>\n<p>I‚Äôm wondering how others reason with equivalence relations. Somehow I<br>\ncan‚Äôt imagine that a situation like mine is so rare; so I‚Äôd be surprised<br>\nif there isn‚Äôt an approach to performing ‚Äúequivalence reasoning‚Äù<br>\nconveniently. Any hints?</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759971,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199093
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>I‚Äôm wondering how others reason with equivalence relations. Somehow I<br>\ncan‚Äôt imagine that a situation like mine is so rare; so I‚Äôd be<br>\nsurprised<br>\nif there isn‚Äôt an approach to performing ‚Äúequivalence reasoning‚Äù<br>\nconveniently. Any hints?</p>\n</blockquote>\n<p>Coq has a setoid rewrite engine, which might be what you want here?.<br>\nThe idea is to rewrite wrt arbitrary preorders.</p>\n<p>Up to my knowledge, such a thing has not yet been implemented in<br>\nIsabelle (though I'm collecting possible applications, as I might<br>\nimplement such a thing sooner or later ;) )</p>",
        "id": 294759982,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199100
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nAm Donnerstag, den 04.07.2019, 17:26 +0100 schrieb Peter Lammich:</p>\n<blockquote>\n<blockquote>\n<p>I‚Äôm wondering how others reason with equivalence relations. Somehow<br>\nI can‚Äôt imagine that a situation like mine is so rare; so I‚Äôd be<br>\nsurprised if there isn‚Äôt an approach to performing ‚Äúequivalence<br>\nreasoning‚Äù conveniently. Any hints?</p>\n</blockquote>\n<p>Coq has a setoid rewrite engine, which might be what you want here?</p>\n</blockquote>\n<p>Well, I‚Äôd want something like that for Isabelle. üòâ</p>\n<p>I have a considerable amount of Isabelle code, which I wouldn‚Äôt like to<br>\ntranslate to Coq, for three reasons:</p>\n<p>* The translation would take a lot of time.</p>\n<p>* The translation would perhaps not be straightforward because of<br>\n    Coq‚Äôs constructivity.</p>\n<p>* Coq doesn‚Äôt have a proper proof language along the lines of Isar.</p>\n<blockquote>\n<p>Up to my knowledge, such a thing has not yet been implemented in<br>\nIsabelle (though I‚Äôm collecting possible applications, as I might<br>\nimplement such a thing sooner or later üòâ).</p>\n</blockquote>\n<p>Please implement it! <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294760010,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199118
    }
]