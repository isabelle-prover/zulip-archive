[
    {
        "content": "<p>From: David Sanán &lt;<a href=\"mailto:sananbad@scss.tcd.ie\">sananbad@scss.tcd.ie</a>&gt;<br>\nDear Andreas and Florian,</p>\n<p>Thanks for your valuables comment. I will follow your suggestions. </p>\n<p>Code generation is not an actual concern. However combining the use of Tobia's index and Florian suggestion </p>\n<p>assumes \"n &lt; length (Enum.enum :: 'a list) ==&gt; (Enum.enum ! ordinal x) = x\"</p>\n<p>would release the needed to prove manually the instantiation \"ordinal dat0 = 0\" \"ordinal dat1 = 1\" \"ordinal dat2 = 2\" ...  am I right?</p>\n<p>Before reading your last posts I had already tried to prove \"n &lt; length (Enum.enum :: 'a list) ==&gt; (Enum.enum ! ordinal x) = x\" in a general function (not within an instantiation), but I could not (I need more experience!). I will try with instantiations then. </p>\n<p>Thanks again and best regards,<br>\nDavid.</p>",
        "id": 294243828,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908117
    },
    {
        "content": "<p>From: David Sanán &lt;<a href=\"mailto:sananbad@scss.tcd.ie\">sananbad@scss.tcd.ie</a>&gt;<br>\nI reply to myself, <br>\nJust defining the class and with the assumption \"ordinal = index enum_class.enum\" datatype instantiations are straightforward using definitions.</p>\n<p>Thanks and best regards,<br>\nDavid.</p>",
        "id": 294243834,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908121
    },
    {
        "content": "<p>From: David Sanan &lt;<a href=\"mailto:sananbad@scss.tcd.ie\">sananbad@scss.tcd.ie</a>&gt;<br>\nDear all,</p>\n<p>I am starting with Isabelle and I am trying something I consider a <br>\nbasic thing but I can't see how to do it.</p>\n<p>From a datatype which I have instantiated to enum, I want to get the <br>\nordinal of an element as defined in the Enum.enum list.</p>\n<p>So if I define</p>\n<p>datatype my_data = dat0|<br>\n                   dat1|<br>\n                   dat2</p>\n<p>lemma user_my_data_induct: \"P dat0 &lt;--&gt; P dat1 ==&gt; P dat2 ==&gt; P x\"<br>\nby (cases x) auto</p>\n<p>lemma UNIV_my_data [no_atp]: \"UNIV = { dat0, dat1, dat2}\"<br>\n    apply (safe)<br>\n    apply (case_tac x)<br>\n    apply (auto intro:user_my_data_induct)<br>\n   done</p>\n<p>instantiation my_data :: enum begin<br>\ndefinition \"enum_my_data= [dat0, dat1, dat2]\"<br>\ndefinition \"enum_all_my_data P &lt;--&gt; P dat0 /\\ P dat1 /\\ P dat2\"<br>\ndefinition \"enum_ex_my_data P &lt;--&gt; P dat0 \\/ P dat1 \\/ P dat2\"<br>\ninstance proof<br>\nqed (simp_all only: enum_my_data_def enum_all_my_data_def <br>\nenum_ex_my_data_def UNIV_my_data, simp_all)<br>\nend</p>\n<p>I want to map dat0 to 0, dat1 to 1 ...</p>\n<p>Is there define any function for that? I have looking but I could not <br>\nfind anything.</p>\n<p>I can always create it, of course but I would like to know whether <br>\nthere is something for this or not.</p>\n<p>Thanks and best regards,<br>\nDavid.</p>",
        "id": 294245511,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908734
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi David,</p>\n<p>From what you write, I guess that you want to have an operation ordinal :: 'a :: enum =&gt; <br>\nnat such that \"ordinal x\" returns the position of x in the enumeration list enum_class.enum.</p>\n<p>I am not aware of any pre-defined setup for this use case in the Isabelle/HOL library. You <br>\ncan of course define</p>\n<p>\"ordinal x =<br>\n  (THE i. i &lt; length (enum_class.enum :: 'a list) &amp; enum_class.enum !! i = x)\"</p>\n<p>but that won't be fun to work with. The entry List_Index in the Archive of Formal Proofs <br>\n(<a href=\"http://afp.sourceforge.net/entries/List-Index.shtml\">http://afp.sourceforge.net/entries/List-Index.shtml</a>), however, defines a function index <br>\nsuch that \"ordinal = index enum_class.enum\". That should fit your purpose.</p>\n<p>You still have to prove the assignment manually for your instantiation, i.e.,</p>\n<p>\"ordinal dat0 = 0\" \"ordinal dat1 = 1\" \"ordinal dat2 = 2\"</p>\n<p>but this will be automatic with index.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294245519,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908741
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nAn alternative could be:</p>\n<p>class index = enum +<br>\n          fixes ordinal :: \"'a =&gt; nat\"<br>\n          assumes \"n &lt; length (Enum.enum :: 'a list) ==&gt; ordinal<br>\n(Enum.enum ! n :: 'a) = n\"<br>\n          assumes \"n &lt; length (Enum.enum :: 'a list) ==&gt; (Enum.enum !<br>\nordinal x) = x\"  -- {* disclaimer: not checked in Isabelle yet *}</p>\n<p>I.e. the THE-definition of ordinal is absorbed into a constructive type<br>\nclass.  This leaves you still to provided reasonable instance<br>\ndefinitions for ordinal for each instance type, but this might turn out<br>\nsimple if you have a look at the corresponding Enum.enum instances.</p>\n<p>Practice shows which approach is more appropriate.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Fi_eDt2FKEkMpdkrbcXrJWdy/signature.asc\">signature.asc</a></p>",
        "id": 294245586,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908772
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian and David,</p>\n<p>If code generation is a concern, Florian is right: a separate type class with the index <br>\noperation is preferable, because then, you can tailor the code equations for ordinal to <br>\nevery datatype you are using. If you use large datatypes, I expect that this will improve <br>\nthe run-time considerably. However, I did not see from the original post that code <br>\ngeneration was intended (although the enum class mainly serves for code generation).</p>\n<p>However, even then, I suggest to build on Tobias' AFP entry as follows:</p>\n<p>class index = enum +<br>\n   fixes ordinal :: \"'a =&gt; nat\"<br>\n   assumes ordinal_conv_index: \"ordinal = index enum_class.enum\"</p>\n<p>As ordinal is fully specified, the assumption of the type class can directly be <br>\ndefinitional. (You can even start working with \"index enum_class.enum\" directly and later <br>\non introduce such a type class for code generation, but that leads too far here.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294245617,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908784
    },
    {
        "content": "<p>From: David Sanán &lt;<a href=\"mailto:sananbad@scss.tcd.ie\">sananbad@scss.tcd.ie</a>&gt;<br>\nHi Again,</p>\n<p>After successfully includes an \"ordinal\" operation for datatypes instantiating enum, I have included the reverse operation \"data\", which gives a datatype from an natural in case the given natural is within the datatype range. So I have extended the index class adding the new data operation fixes data :: \"nat ⇒ 'a option\" and the following assumption type_conv_ordinal: \"data (ordinal (x)) = Some x\".  </p>\n<p>The problem comes when I am instantiating some datatype to index. When proving the assumption, which apparently can be done well \"by auto\", well using \"by (simp_all add: ordinal_conv_index data_my_data_def  enum_UNIV)\". For this instantiation</p>\n<p>instantiation my_data:: index<br>\nbegin<br>\ndefinition<br>\n\"index_class.ordinal (a::my_data) ≡  index enum_class.enum a\"</p>\n<p>definition<br>\n\"<a href=\"http://index_class.data\">index_class.data</a> (n::nat) ≡  <br>\n                                if n &lt; size (enum_class.enum::(my_data list)) <br>\n                                    then Some (nth  enum_class.enum  n)::(my_data option)<br>\n                                    else None::(my_data option)\"</p>\n<p>instance proof<br>\n  fix m::my_data<br>\n  show \"index_class.ordinal m = index enum_class.enum m\"  by (simp_all add: ordinal_my_data_def)<br>\n  show \"data (ordinal (m)) = Some m\" by (simp_all add: ordinal_conv_index data_my_data_def  enum_UNIV)<br>\n  qed<br>\nend</p>\n<p>Although the proof finishes well, the second \"show\" is marked with a forbid symbol and \"by (simp_all add: ordinal_conv_index data_my_data_def  enum_UNIV)\" is red highlighted and the output shows the following:</p>\n<p>show data (ordinal m) = Some m <br>\nSuccessful attempt to solve goal by exported rule:<br>\n  data (ordinal ?m2) = Some ?m2 <br>\nproof (state): step 6</p>\n<p>this:<br>\n  data (ordinal m) = Some m</p>\n<p>goal:<br>\nNo subgoals! <br>\nFailed to finish proof:<br>\ngoal (1 subgoal):<br>\ndata (ordinal m) = Some m</p>\n<ol>\n<li>(ordinal m &lt; length enum_class.enum ⟶ enum_class.enum ! ordinal m = m) ∧ ordinal m &lt; length enum_class.enum</li>\n</ol>\n<p>why is this happening? </p>\n<p>The whole index class and the instantiation are below. </p>\n<p>Thanks and best regards,<br>\nDavid.</p>\n<p>class index = enum +<br>\nfixes ordinal :: \"'a ⇒ nat\"<br>\nfixes data :: \"nat ⇒ 'a option\"<br>\nassumes ordinal_conv_index: \"ordinal m = index enum_class.enum m\"<br>\nand type_conv_ordinal: \"data (ordinal (x)) = Some x\"<br>\nend</p>\n<p>datatype my_data = dat0<br>\n                  |dat1<br>\n                  |dat2</p>\n<p>lemma my_data_induct: \"P dat0 ⟹ P dat1 ⟹ P dat2 ⟹ P x\"<br>\nby (cases x) auto</p>\n<p>lemma UNIV_my_data [no_atp]: \"UNIV = { dat0,dat1,dat2}\"<br>\n   apply (safe)<br>\n   apply (case_tac x)<br>\n   apply (auto intro:my_data_induct)<br>\n  done</p>\n<p>instantiation my_data :: enum begin<br>\ndefinition \"enum_my_data = [dat0,dat1,dat2]\"<br>\ndefinition \"enum_all_my_data P ⟷ P dat0 ∧ P dat1 ∧ P dat2\"<br>\ndefinition \"enum_ex_my_data P ⟷ P dat0 ∨ P dat1 ∨ P dat2 \"<br>\ninstance proof<br>\nqed (simp_all only: enum_my_data_def enum_all_my_data_def enum_ex_my_data_def UNIV_my_data, simp_all)<br>\nend</p>\n<p>instantiation my_data:: index<br>\nbegin<br>\ndefinition<br>\n\"index_class.ordinal (a::my_data) ≡  index enum_class.enum a\"</p>\n<p>definition<br>\n\"<a href=\"http://index_class.data\">index_class.data</a> (n::nat) ≡  <br>\n                                if n &lt; size (enum_class.enum::(my_data list)) <br>\n                                    then Some (nth  enum_class.enum  n)::(my_data option)<br>\n                                    else None::(my_data option)\"</p>\n<p>instance proof<br>\n  fix m::my_data<br>\n  show \"index_class.ordinal m = index enum_class.enum m\"  by (simp_all add: ordinal_my_data_def)<br>\n  show \"data (ordinal (m)) = Some m\" by auto<br>\n  qed<br>\nend</p>",
        "id": 294247445,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909446
    },
    {
        "content": "<p>From: David Sanán &lt;<a href=\"mailto:sananbad@scss.tcd.ie\">sananbad@scss.tcd.ie</a>&gt;<br>\nI partially answer myself...</p>\n<p>The proof was not already done (or was it?)although it said there was not any subgoals left and there was no error in the end of the instance proof... Instead of using \"by\" I have used \"apply\" and now the proof steps look clearer to me. </p>\n<p>Finally I have solved it just adding another definition to the simplification method and the final proof is:</p>\n<p>instance proof<br>\n fix m::my_data<br>\n show \"index_class.ordinal m = index enum_class.enum m\"  by (simp_all add: ordinal_my_data_def) <br>\n show \"data (ordinal (m)) = Some m\" by (simp_all add: data_my_data_def ordinal_my_data_def enum_UNIV)  <br>\n qed<br>\nend</p>\n<p>However, shouldn't the whole instance proof be marked as incomplete (that is the end of the proof should not be clear) in my first attempt?</p>\n<p>Also If I remove the definition \"data_my_data_def\" from the simplification I have:</p>\n<p>Successful attempt to solve goal by exported rule:<br>\n  data (ordinal ?m2) = Some ?m2 <br>\nFailed to finish proof:<br>\ngoal (1 subgoal):<br>\ndata (ordinal m) = Some m</p>\n<ol>\n<li>data (index enum_class.enum m) = Some m <br>\nproof (state): step 6</li>\n</ol>\n<p>this:<br>\n  data (ordinal m) = Some m</p>\n<p>goal:<br>\nNo subgoals!</p>\n<p>Does it means that the proof is done??? It seems so to me, but when I try to build the model I have:</p>\n<p>Failed to finish proof (line 210 of \"List-Index/List_Index.thy\"):<br>\n*** goal (1 subgoal):<br>\n*** data (ordinal m) = Some m<br>\n***  1. data (index enum_class.enum m) = Some m<br>\n*** At command \"by\" (line 210 of \"List-Index/List_Index.thy\")</p>\n<p>Thanks and regards,<br>\nDavid.</p>",
        "id": 294247485,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909465
    }
]