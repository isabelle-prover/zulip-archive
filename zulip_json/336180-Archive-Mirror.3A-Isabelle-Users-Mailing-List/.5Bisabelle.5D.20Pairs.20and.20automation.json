[
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:christian.urban@kcl.ac.uk\">christian.urban@kcl.ac.uk</a>&gt;<br>\nDear Isabelle-Wizards,</p>\n<p>I have a theory where I need to define functions<br>\nover tuples, say this contrived one</p>\n<p>fun test where<br>\n  \"test (a, b) = False\"</p>\n<p>Now I like to prove lemmas like</p>\n<p>lemma \"test x ==&gt; P\"<br>\napply(case_tac x)<br>\napply(simp) <br>\ndone</p>\n<p>As can be seen this can be proved, but needs the explicit <br>\ncase_tac in order to make Isabelle aware the x is in fact <br>\na pair.</p>\n<p>Is there a way I can make Isabelle figure this out automatically?</p>\n<p>If I had a !!-quantifier around x, then this seems<br>\nto do the job:</p>\n<p>lemma \"!!x. test x ==&gt; P\"<br>\napply(simp add: split_paired_all)<br>\ndone</p>\n<p>I toyed with definitions like</p>\n<p>fun test2<br>\nwhere<br>\n  \"test2 x = (let (a, b) = x in False)\"</p>\n<p>lemma \"test2 x ==&gt; P\"<br>\napply(simp)<br>\ndone</p>\n<p>But I am wondering whether there is some other magic that<br>\nlets my problem go away (automatically). Does anybody else<br>\nencountered this problem?</p>\n<p>Best wishes,<br>\nChristian</p>",
        "id": 294233268,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903549
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Christian,</p>\n<p>You could prove split rules for your functions, similar to prod.splits:</p>\n<p>lemma test_split:<br>\n   \"!!x. P (test x) = (!a b. x = (a, b) --&gt; P (test (a, b)))\"<br>\n   \"!!x. P (test x) = (~ (∃a b. x = (a, b) &amp; ~ P (test (a, b))))\"<br>\nby(simp_all add: split_paired_all)</p>\n<p>lemma \"test x ==&gt; P\"<br>\napply(simp split: test_split)<br>\ndone</p>\n<p>But these split rules are aggressive, they split the parameter for every <br>\noccurrence of test. And they make the simplifier loop if the rhs <br>\noccurrence of test does not get simplified away (there's less danger if <br>\nyou replace the \"test (a, b)\" on the rhs with the rhs of the function <br>\ndefinition, but then the theorems are less canoncial). Fortunately, the <br>\nsimplifier tries split rules after applying its simplification steps, so <br>\nthis should normally work.</p>\n<p>Andreas</p>",
        "id": 294233278,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903554
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Christian,</p>\n<p>Let's pick a different example:</p>\n<p>fun test where \"test (a, b) = (a * a = b + 4)\"</p>\n<p>Then, the split lemma should split the x parameter and do the rewrite <br>\nwith test.simps in one step:</p>\n<p>lemma test_split:<br>\n   \"!!x. P (test x) = (!a b. x = (a, b) --&gt; P (a * a = b + 4))\"<br>\n   \"!!x. P (test x) = (~ (?a b. x = (a, b) &amp; ~ P (a * a = b + 4)))\"</p>\n<p>The first form splits x if \"test x\" occurs in the conclusion of a goal, <br>\nthe second does so if \"test x\" occurs in one of the assumptions. The <br>\nformat of split rules is a bit non-intuitive.</p>\n<p>I do not know how well the split rules work if you have a recursive call <br>\nto test on the rhs, as I am no expert on how exactly the splitter works. <br>\nHowever, I would expect that the same rules as for the simplifier apply, <br>\ni.e., if the recursive call is hidden under another operator with a <br>\nsuitable congruence rule, you're safe - otherwise, it will loop.</p>\n<p>Best wishes<br>\nAndreas</p>",
        "id": 294233460,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903634
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 12/02/2013 08:39, schrieb Andreas Lochbihler:</p>\n<blockquote>\n<p>I do not know how well the split rules work if you have a recursive call to test<br>\non the rhs, as I am no expert on how exactly the splitter works. However, I<br>\nwould expect that the same rules as for the simplifier apply, i.e., if the<br>\nrecursive call is hidden under another operator with a suitable congruence rule,<br>\nyou're safe - otherwise, it will loop.</p>\n</blockquote>\n<p>The splitter ignores congruence rules.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Best wishes<br>\nAndreas</p>\n<p>On 02/11/2013 06:55 PM, Christian Urban wrote:</p>\n<blockquote>\n<p>Dear Andreas,</p>\n<p>Thanks a lot for the answer!</p>\n<blockquote>\n<p>there's less danger if<br>\nyou replace the \"test (a, b)\" on the rhs with the rhs of the function<br>\ndefinition, but then the theorems are less canoncial</p>\n</blockquote>\n<p>I am not sure I understand this. Do you mean I should<br>\ninstead of proving</p>\n<p>lemma test_split:<br>\n    \"!!x. P (test x) = (!a b. x = (a, b) --&gt; P (test (a, b)))\"</p>\n<p>I should prove something like</p>\n<p>lemma test_split:<br>\n    \"!!x. P (test x) = (!a b. x = (a, b) --&gt; P (rhs (a, b)))\"</p>\n<p>where rhs is the \"expanded\" version of the rhs of the function.<br>\nBut how would that work if the function is defined by<br>\nfun via pattern matching. Then I would get some big<br>\ncase-expression on the right. Is this what you had in mind?</p>\n<p>Also one more question: I can see the purpose of the<br>\ntheorem above, but when is the following used?</p>\n<p>\"!!x. P (test x) = (~ (∃a b. x = (a, b) &amp; ~ P (test (a, b))))\"</p>\n<p>Best wishes and thanks a lot again!<br>\nChristian<br>\n</p>\n</blockquote>\n<p>On Monday, February 11, 2013 at 16:54:34 (+0100), Andreas Lochbihler wrote:</p>\n<blockquote>\n<blockquote>\n<p>But these split rules are aggressive, they split the parameter for every<br>\noccurrence of test. And they make the simplifier loop if the rhs<br>\noccurrence of test does not get simplified away (there's less danger if<br>\nyou replace the \"test (a, b)\" on the rhs with the rhs of the function<br>\ndefinition, but then the theorems are less canoncial). Fortunately, the<br>\nsimplifier tries split rules after applying its simplification steps, so<br>\nthis should normally work.</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294233469,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903640
    }
]