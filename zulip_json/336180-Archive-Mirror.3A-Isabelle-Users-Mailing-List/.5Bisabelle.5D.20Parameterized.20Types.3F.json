[
    {
        "content": "<p>From: Robert Lamar &lt;<a href=\"mailto:rlamar@stetson.edu\">rlamar@stetson.edu</a>&gt;<br>\nI am attempting to develop a theory of rings which features quotients.  So far, I have defined rings through axiomatic classes and ideals through a predicate constant.  There are several approaches to defining the quotient ring which present themselves, but the next step would be to prove that the quotient is an instance of the ring class.  Is there a straightforward way to do this without specifying a particular ideal?  My goal, as I imagine it, is to define a type which is parameterized, essentially, by subsets of \"UNIV::('a::ring set)\" (or more specifically, by subsets which satisfy my is_ideal predicate).  Is this possible?  Is there a different (better) way to approach this problem?</p>\n<p>Thanks,<br>\nRobert Lamar<br>\nStetson University</p>",
        "id": 293905037,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745701
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nDear Robert,</p>\n<p>what you require are dependent types, but these are not supported by <br>\nIsabelle.  Instead, we propagate the use of \"locales\" for <br>\nformalisations of algebra.  See the main trunk of session HOL-Algebra.</p>\n<p>Quotient rings have not been formalised in this framework (neither have <br>\nquotient fields, which you could get also with type classes), so this <br>\nwould be a welcome contribution.</p>\n<p>Clemens</p>",
        "id": 293905043,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745702
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@csee.ogi.edu\">brianh@csee.ogi.edu</a>&gt;<br>\nOn Sunday 19 March 2006 21:55, Robert Lamar wrote:</p>\n<blockquote>\n<p>I am attempting to develop a theory of rings which features quotients.  So<br>\nfar, I have defined rings through axiomatic classes and ideals through a<br>\npredicate constant.  There are several approaches to defining the quotient<br>\nring which present themselves, but the next step would be to prove that the<br>\nquotient is an instance of the ring class.  Is there a straightforward way<br>\nto do this without specifying a particular ideal? </p>\n</blockquote>\n<p>One possibility would be to prove some theorems with type_definition <br>\npredicates as assumptions. In the Isabelle sources, HOLCF/Pcpodef.thy <br>\ncontains several examples of this, such as:</p>\n<p>theorem typedef_cpo:<br>\n  fixes Abs :: \"'a::cpo =&gt; 'b::po\"<br>\n  assumes type: \"type_definition Rep Abs A\"<br>\n    and less: \"op &lt;&lt; == %x y. Rep x &lt;&lt; Rep y\"<br>\n    and adm: \"adm (%x. x : A)\"<br>\n  shows \"OFCLASS('b, cpo_class)\"</p>\n<p>Assumption \"type\" basically says that type 'b is defined as a predicate <br>\nsubtype of 'a, and is isomorphic to the set A::'a set. An instantiation of <br>\nthe type_definition predicate is what gets axiomatized whenever you use the <br>\n\"typedef\" command; take a look at HOL/Typedef.thy to see how it is defined. <br>\nAssumption \"less\" says that the overloaded \"&lt;&lt;\" relation on type 'b is <br>\ndefined in terms of \"&lt;&lt;\" on type 'a, and finally \"adm\" places some <br>\nrestrictions on the set A. The conclusion is exactly the proposition you <br>\nwould get as a subgoal if you tried to prove that 'b is an instance of class <br>\n\"cpo\".</p>\n<blockquote>\n<p>My goal, as I imagine <br>\nit, is to define a type which is parameterized, essentially, by subsets of<br>\n\"UNIV::('a::ring set)\" (or more specifically, by subsets which satisfy my<br>\nis_ideal predicate).  Is this possible?  Is there a different (better) way<br>\nto approach this problem?</p>\n</blockquote>\n<p>In your case, you could prove the following theorem:<br>\ntheorem typedef_ring:<br>\n  fixes Abs :: \"'a::ring =&gt; 'b::{zero,plus,times}\"<br>\n  assumes type: \"type_definition Rep Abs A\"<br>\n    and zero: \"0 == Abs 0\"<br>\n    and plus: \"op + == %x y. Abs (Rep x + Rep y)\"<br>\n    and times: \"op * == %x y. Abs (Rep x * Rep y)\"<br>\n    and ideal: \"is_ideal A\"<br>\n  shows \"OFCLASS('b, ring_class)\"</p>\n<p>You wouldn't get a parameterized type, but you would be able to define new <br>\ntypes one at a time using typedef, and then prove that each new type is in <br>\nthe ring class using theorem typedef_ring.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 293905050,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745703
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@csee.ogi.edu\">brianh@csee.ogi.edu</a>&gt;<br>\nHi Robert,</p>\n<p>On Tuesday 28 March 2006 14:28, Robert Lamar wrote:</p>\n<blockquote>\n<p>My only question for the moment arises from my attempt to prove a lemma,<br>\nthat the sum of two elements of a quotient is in the quotient.  I am unable<br>\nto get past a certain step, which I isolate in the following lemma:</p>\n<p>lemma \"EX s. S = coset I s ==&gt; EX s. S = {i + s | i. i \\&lt;in&gt; I}\"<br>\n  proof -<br>\n    assume \"EX s. S = coset I s\"<br>\n    from this coset_def [of I s] show \"EX s. S = {i + s | i. i \\&lt;in&gt; I}\"<br>\n    by simp<br>\n  qed</p>\n<p>I have defined</p>\n<p>constdefs<br>\n    coset ::  \"[('a::ring) set, 'a] =&gt; 'a set\"<br>\n              \"coset I a == {i + a | i. i \\&lt;in&gt; I}\"<br>\n</p>\n</blockquote>\n<p>The problem with this proof is caused by your usage of the \"of\" theorem <br>\nattribute. Specifically, coset_def [of I s] instantiates coset_def with the <br>\nfree variables \"I\" and \"s\" (on my system Proof General renders these in <br>\nblue), where the term you want to replace uses \"s\" as a bound variable <br>\n(rendered in green). Replace this with coset_def [of I] and the proof works.</p>\n<blockquote>\n<p>and would like to think that it is a straightforward matter of<br>\nsubstitution.  However, I know that section 5.11 of the tutorial makes it<br>\nclear that reasoning about existential operators can be very tricky.  Am I<br>\nmissing something crucial?</p>\n<p>Robert Lamar</p>\n</blockquote>\n<p>When you instantiate coset_def with free variables \"I\" and \"s\", you get an <br>\nassumption that is too weak, since it only asserts the equality for a single <br>\nvalue of \"s\". For simp to perform a substitution under a quantifier, on a <br>\nterm containing bound variables, the equality needs to hold for all possible <br>\nvalues of the bound variables. Leaving a variable uninstantiated has the <br>\neffect of a universal quantification over that variable, and simp is able to <br>\nmatch it against a bound variable.</p>\n<p>It appears that [of I] is still necessary to instantiate the free type <br>\nvariable in coset_def. Apparently, leaving a type variable uninstantiated <br>\ndoes not have the same effect as an uninstantiated term variable, as far as <br>\nsimp is concerned; simp cannot match the types and it fails.</p>\n<p>As a simpler alternative, you can give coset_def as an argument to simp or <br>\nunfold, which avoids the problems with instantiating type variables:</p>\n<p>lemma \"EX s. S = coset I s ==&gt; EX s. S = {i + s | i. i \\&lt;in&gt; I}\"<br>\n  proof -<br>\n    assume \"EX s. S = coset I s\"<br>\n    then show \"EX s. S = {i + s | i. i \\&lt;in&gt; I}\"<br>\n    by (unfold coset_def)<br>\n  qed </p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 293905138,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745728
    }
]