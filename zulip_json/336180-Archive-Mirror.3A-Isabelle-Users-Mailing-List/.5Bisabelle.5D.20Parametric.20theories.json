[
    {
        "content": "<p>From: Daniel Schoepe &lt;<a href=\"mailto:daniel@schoepe.org\">daniel@schoepe.org</a>&gt;<br>\nHi,</p>\n<p>I'm trying to build a theory that is parametric in some types and<br>\nwould like to know the recommended way for doing that. I realize that<br>\nthis topic has come up before and that this problem is partially(?)<br>\nsolved by locales. From what I have read on this list (for example in<br>\n[1]), my choices are the following:</p>\n<ol>\n<li>Use type variables everywhere -- this will get very tiresome very<br>\nquickly. Locales don't seem to offer a complete way around that either,<br>\nat least the following does not seem to work:</li>\n</ol>\n<p>locale Foo = fixes x :: \"'a\"<br>\nbegin<br>\n  type_synonym bar = \"'a \\times 'a\"<br>\nend</p>\n<ol start=\"2\">\n<li>Use typedecl, consts, and similar commands. This seems ideal apart<br>\nfrom instantiating the theory later. Here I think I have two choices:<br>\nUse the AWE tool [2], which seems to do exactly what I want, but was<br>\nlast updated for Isabelle 2009-1, or a post-hoc axiomatization using<br>\ndirectives like type_definition and axioms.</li>\n</ol>\n<p>Am I overlooking some possibility, or is that basically it? If so, is<br>\nthere an up-to-date version of AWE, or does someone know how much work<br>\nit would take to update it (I noticed that at least the isar-keywords.el<br>\nfiles of 2011-1 and AWE have diverged, but there are probably more<br>\ncomplicated conflicts than that).</p>\n<p>Is there some \"convention\" on how deal with this issue, as I can imagine<br>\nthis comes up quite often?</p>\n<p>Regards,<br>\nDaniel</p>\n<p>[1] <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2009-July/msg00111.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2009-July/msg00111.html</a><br>\n[2] <a href=\"http://www.informatik.uni-bremen.de/~cxl/awe/\">http://www.informatik.uni-bremen.de/~cxl/awe/</a></p>",
        "id": 294155803,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851151
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 11 Apr 2012, Daniel Schoepe wrote:</p>\n<blockquote>\n<p>I'm trying to build a theory that is parametric in some types and<br>\nwould like to know the recommended way for doing that.</p>\n</blockquote>\n<p>It depends what \"parameteric on types\" shall mean exactly.  Depending on <br>\nplain type parameters in the manner of schematic polymorphism works quite <br>\npainlessly, and type inference sorts out things most of the time, without <br>\ntoo much explicit type annotations.</p>\n<p>In contrast, depending on type <em>constructors</em> with their own type <br>\narguments does not work within the logic, and requires something like AWE <br>\nfrom Bremen.</p>\n<blockquote>\n<p>Use type variables everywhere -- this will get very tiresome very <br>\nquickly. Locales don't seem to offer a complete way around that either, <br>\nat least the following does not seem to work:</p>\n<p>locale Foo = fixes x :: \"'a\"<br>\nbegin<br>\n type_synonym bar = \"'a \\times 'a\"<br>\nend</p>\n</blockquote>\n<p>Normally you just refer to 'a, 'b, 'c in your specifications causally (or <br>\nimplicitly), without introducing too many explicit types mentioned in the <br>\nformal text.  So it might not be as tiresome as anticipated, depending on <br>\nthe application.</p>\n<p>A type_synonym within a local theory context could be made to work, but it <br>\nis not so often required in practice to induce significant demands to <br>\nimplement that.  Other things are more urgent, sich as datatype and record <br>\ntypes within local contexts.</p>\n<p>Makarius</p>",
        "id": 294156012,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851235
    },
    {
        "content": "<p>From: Daniel Schoepe &lt;<a href=\"mailto:daniel@schoepe.org\">daniel@schoepe.org</a>&gt;<br>\nOn Sat, 14.04.2012 22:02, Makarius wrote:</p>\n<blockquote>\n<p>It depends what \"parameteric on types\" shall mean exactly.  Depending on <br>\nplain type parameters in the manner of schematic polymorphism works quite <br>\npainlessly, and type inference sorts out things most of the time, without <br>\ntoo much explicit type annotations.</p>\n<p>In contrast, depending on type <em>constructors</em> with their own type <br>\narguments does not work within the logic, and requires something like AWE <br>\nfrom Bremen.</p>\n</blockquote>\n<p>Luckily, just ordinary type parameters are needed in my case.</p>\n<blockquote>\n<blockquote>\n<p>Use type variables everywhere -- this will get very tiresome very <br>\nquickly. Locales don't seem to offer a complete way around that either, <br>\nat least the following does not seem to work:</p>\n<p>locale Foo = fixes x :: \"'a\"<br>\nbegin<br>\n type_synonym bar = \"'a \\times 'a\"<br>\nend</p>\n</blockquote>\n<p>Normally you just refer to 'a, 'b, 'c in your specifications causally (or <br>\nimplicitly), without introducing too many explicit types mentioned in the <br>\nformal text.  So it might not be as tiresome as anticipated, depending on <br>\nthe application.</p>\n</blockquote>\n<p>While I do have only three or four type parameters, I am using<br>\nmore or less intricate combinations of them quite often, such as<br>\n\"(('a \\&lt;times&gt; 'b) list \\&lt;times&gt; ('c \\&lt;Rightarrow&gt; 'd)\"</p>\n<p>Hence I would prefer to have the ability to give these constructs a name<br>\nwithout having to mention the parameters each time again. (I could<br>\nconstruct a type_synonym that needs to be applied to some parameters,<br>\nbut then I'd still have to write \"('a, 'b, 'c, 'd) SomeSynonym\").</p>\n<p>I guess I'll give using AWE with the current Isabelle version a shot,<br>\nand use type_synonyms with parameters if that fails.</p>\n<p>Anyway, thanks for your detailed answer!</p>\n<p>A related issue I'm curious about: What was the rationale for<br>\nintroducing typedecl without a straight-forward way to instantiate it?<br>\nBeing able to define something that has only been declared earlier seems<br>\nrather natural to me.</p>\n<p>Regards,<br>\nDaniel</p>",
        "id": 294156283,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851336
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 18 Apr 2012, Daniel Schoepe wrote:</p>\n<blockquote>\n<p>I could construct a type_synonym that needs to be applied to some <br>\nparameters, but then I'd still have to write \"('a, 'b, 'c, 'd) <br>\nSomeSynonym\".</p>\n</blockquote>\n<p>Yes, that's the normal way.  Moreover, you can often suppress type <br>\ninformation in the input, say you write some of the type arguments as \"_\" <br>\nand let type inference take care of the rest.  Or you don't write types at <br>\nall.</p>\n<p>BTW, most names in Isabelle are normally just lower case like \"foo_bar\", <br>\nincluding type names.  Capitalization like Foo_Bar is always used for <br>\ntheory names, datatype constructors, and sometimes for special operators. <br>\nCamel-case is generally out of fashion.</p>\n<blockquote>\n<p>A related issue I'm curious about: What was the rationale for <br>\nintroducing typedecl without a straight-forward way to instantiate it? <br>\nBeing able to define something that has only been declared earlier seems <br>\nrather natural to me.</p>\n</blockquote>\n<p>The classic canon for axiomatic specifications consists of typedecl, <br>\nconsts, axioms.  You can do whatever you want here, but there are no <br>\nsanity checks.  For example you can first \"declare\" some types, and then <br>\n\"define\" them -- all axiomatically.  Here is an old example from HOL/Bali <br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2011-1/src/HOL/Bali/Example.thy#l66\">http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2011-1/src/HOL/Bali/Example.thy#l66</a></p>\n<p>Historically, Isabelle theories were always axiomatic like that.  Later <br>\nthe vacous axiomatization of 'consts' followed by a definitional <br>\naxiomatization of 'defs' (i.e. 'axioms' with some checks) were called <br>\ndefinitions.</p>\n<p>Much later, an actual definitional concept was made the main principle of <br>\nthe local theory infrastructure that is commonplace today.  It performs <br>\nthe usual simultaneous declaration-definition of entities seen in most <br>\nother provers and in mathematics.  There are also technical and conceptual <br>\nreasons for it -- definitions that depend on local contexts work out <br>\nbetter if the RHS is explicitly given.</p>\n<p>The surface syntax wraps up these truly definitional primitives as <br>\n'definition', 'function', 'induction' etc.  For types, this is still a bit <br>\nlimited, though.  (Back to start of thread.)</p>\n<p>Makarius</p>",
        "id": 294156294,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851340
    }
]