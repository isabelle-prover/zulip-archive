[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nDear Isabelle list,</p>\n<p>when doing Group Theory in Isabelle, for example in the Free Groups<br>\nsubmission to AFP, I keep proving facts that are “obvious” to the<br>\nmathematician and where I would expect a type system to do the work for<br>\nme, but I was told that this cannot be done in Isabelle because it does<br>\nnot support dependent types. This leads to code as in<br>\n<a href=\"http://afp.sourceforge.net/browser_info/devel/HOL/Free-Groups/PingPongLemma.html\">http://afp.sourceforge.net/browser_info/devel/HOL/Free-Groups/PingPongLemma.html</a><br>\n(unfortunately, the lines have no anchors, but search for “The following<br>\nlemmas establish all” and see how I defined mems).</p>\n<p>Note how almost all these lemmas would be trivial if we had “X = UNIV”<br>\nand “carrier G = UNIV”, or put differently, if these were types of their<br>\nown. But they are not, these are sets, although I do _not_ use any<br>\nproperty of their elements and I do _not_ anywhere require elements of<br>\nthe set’s carrier type that are not in the set.</p>\n<p>I was wondering if a parametricity argument as follows is sound, and if<br>\nit is, if it can somehow be used in Isabelle to simplify the proofs<br>\n(Syntax somewhat liberal, I hope I get the idea across):</p>\n<p>If for a free type variable 'a, “P(UNIV :: 'a)” holds,<br>\n        and given “S ≠ Ø”,<br>\n        we know “P S” holds.</p>\n<p>Assume this ideas was provided as a lemma attribute. Then I could much<br>\nmore easily prove, for example,</p>\n<p>lift_is_hom':<br>\n        [[ group G;  f ∈ gens -&gt; carrier G; carrier G = UNIV :: 'a ]]<br>\n            ==&gt; G.lift g ∈ hom (free_group X) G</p>\n<p>and obtain the result that I want,</p>\n<p>lift_is_hom:<br>\n        [[ group G ; f ∈ gens -&gt; carrier G ]]<br>\n            ==&gt; G.lift g ∈ hom (free_group X) G</p>\n<p>by something like</p>\n<p>lift_is_hom = lift_is_hom'[parametricity 'a \"carrier G\", simp].</p>\n<p>Greetings,<br>\nJoachim</p>\n<p>PS: I posed a related question in December 2010 and Alexander Krauss<br>\ndangled a possible solution:</p>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-December/msg00040.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-December/msg00040.html</a></p>\n<p>did anything come out of this already?<br>\n<a href=\"/user_uploads/14278/_OP0vQVsZbwzN7xTFx7-xUXK/signature.asc\">signature.asc</a></p>",
        "id": 294153144,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850074
    },
    {
        "content": "<p>From: Stephan Merz &lt;<a href=\"mailto:Stephan.Merz@loria.fr\">Stephan.Merz@loria.fr</a>&gt;<br>\nBut suppose</p>\n<p>P S == ALL x. x : S</p>\n<p>Then you have</p>\n<p>P (UNIV :: 'a set)</p>\n<p>for any type 'a but not P S for an arbitrary non-empty set S. Or am I completely off-track?</p>\n<p>Stephan</p>",
        "id": 294153148,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850077
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nHi,</p>\n<p>hmm, not completely. But it seems there is more to do than just replace<br>\nUNIV by S, e.g. every (ALL x :: 'a. P) would become (∀x∈S. P), and<br>\nsimilarly for existential quantifiers. Then<br>\n        P S == ALL x. x ∈ S<br>\nbecomes<br>\n        P S == ∀x∈S. x ∈ S<br>\nand things are sound again. I’m not deep into the theory of HOL enough<br>\nto completely describe the required transformation though. \"undefined\"<br>\ncomes to mind, this needs to be replaced by \"Some S\".</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/8gw3CRIVgjYSAxLovsCB7_dm/signature.asc\">signature.asc</a></p>",
        "id": 294153159,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850082
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nUnfortunately, Alex Krauss is not pursuing this angle anymore. I don't<br>\nthink there is a general parametricity theorem for HOL, but I am sure<br>\none could transform a certain class of HOL proofs and raise the<br>\ntheorem from a type to a set. But it takes some work to automate this.</p>\n<p>Tobias</p>\n<p>Am 24/02/2012 16:27, schrieb Joachim Breitner:</p>\n<blockquote>\n<p>Dear Isabelle list,</p>\n<p>when doing Group Theory in Isabelle, for example in the Free<br>\nGroups submission to AFP, I keep proving facts that are “obvious”<br>\nto the mathematician and where I would expect a type system to do<br>\nthe work for me, but I was told that this cannot be done in<br>\nIsabelle because it does not support dependent types. This leads to<br>\ncode as in <br>\n<a href=\"http://afp.sourceforge.net/browser_info/devel/HOL/Free-Groups/PingPongLemma.html\">http://afp.sourceforge.net/browser_info/devel/HOL/Free-Groups/PingPongLemma.html</a></p>\n<p>(unfortunately, the lines have no anchors, but search for “The following<br>\nlemmas establish all” and see how I defined mems).</p>\n<p>Note how almost all these lemmas would be trivial if we had “X =<br>\nUNIV” and “carrier G = UNIV”, or put differently, if these were<br>\ntypes of their own. But they are not, these are sets, although I do<br>\n_not_ use any property of their elements and I do _not_ anywhere<br>\nrequire elements of the set’s carrier type that are not in the<br>\nset.</p>\n<p>I was wondering if a parametricity argument as follows is sound,<br>\nand if it is, if it can somehow be used in Isabelle to simplify the<br>\nproofs (Syntax somewhat liberal, I hope I get the idea across):</p>\n<p>If for a free type variable 'a, “P(UNIV :: 'a)” holds, and given “S<br>\n≠ Ø”, we know “P S” holds.</p>\n<p>Assume this ideas was provided as a lemma attribute. Then I could<br>\nmuch more easily prove, for example,</p>\n<p>lift_is_hom': [[ group G;  f ∈ gens -&gt; carrier G; carrier G = UNIV<br>\n:: 'a ]] ==&gt; G.lift g ∈ hom (free_group X) G</p>\n<p>and obtain the result that I want,</p>\n<p>lift_is_hom: [[ group G ; f ∈ gens -&gt; carrier G ]] ==&gt; G.lift g ∈<br>\nhom (free_group X) G</p>\n<p>by something like</p>\n<p>lift_is_hom = lift_is_hom'[parametricity 'a \"carrier G\", simp].</p>\n<p>Greetings, Joachim</p>\n<p>PS: I posed a related question in December 2010 and Alexander<br>\nKrauss dangled a possible solution:</p>\n<blockquote>\n<p>This is a notorious problem, and there is no satisfactory<br>\nsolution. From 2011 on I'll be working on an infrastructure to<br>\ndeal with this (basically recovering what type systems do on the<br>\nlevel of reasoning), but I am not expecting to have something<br>\nusable for quite some time.</p>\n</blockquote>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-December/msg00040.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-December/msg00040.html</a></p>\n<p>did anything come out of this already?<br>\n</p>\n</blockquote>",
        "id": 294153181,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850095
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>I thought more about using parametricity to ease working with<br>\ndefinitions that only make sense on a set of values, and where lots of<br>\nlemmata will have such a set membership as an assumption. Right now I am<br>\nwondering if the transfer package can be of some help here.</p>\n<p>So I start with some abstract set:</p>\n<p>axiomatization a_set :: \"nat set\" where ne: \"a_set ≠ {}\"</p>\n<p>and I want to prove something like</p>\n<p>lemma goal: assumes \"list_all (λx. x ∈ a_set) xs\"<br>\n              and \"∀x ∈ a_set. f x ∈ a_set\"<br>\n              shows \"list_all (λx. x ∈ a_set) (map f xs)\"</p>\n<p>where \"map\" is just an example for a possibly much more complicated<br>\npolymophic expression.</p>\n<p>To make working with closed functions on the set easier, I create a type<br>\nand set it up for the transfer package:</p>\n<p>typedef (open) a_type = a_set using ne by auto<br>\n        setup_lifting type_definition_a_type</p>\n<p>The idea is that if I can do some calculation on this type that’s<br>\nrelated to a calculation on a_set, then the result will also be in the<br>\nset:</p>\n<p>lemma untransfer: \"list_all2 cr_a_type x y ⟹ list_all (λx. x∈a_set) x\"<br>\n          by (induct rule: list_all2_induct, auto simp add:cr_a_type_def Rep_a_type)</p>\n<p>And indeed I can prove the goal:</p>\n<p>lemma goal: assumes \"list_all (λx. x ∈ a_set) xs\"<br>\n              and \"∀x ∈ a_set. f x ∈ a_set\"<br>\n              shows \"list_all (λx. x ∈ a_set) (map f xs)\"<br>\n        proof-<br>\n          have \"list_all2 cr_a_type xs (map Abs_a_type xs)\" (is \"list_all2 _ _ ?xs'\")<br>\n            using assms(1)<br>\n            by (auto simp add:list_all2_def cr_a_type_def set_zip list_all_length Abs_a_type_inverse) <br>\n          moreover<br>\n          have \"fun_rel cr_a_type cr_a_type f (λ x. Abs_a_type (f (Rep_a_type x)))\" (is \"fun_rel _ _ _ ?f'\")<br>\n            using assms(2)<br>\n            by (auto simp add:cr_a_type_def Abs_a_type_inverse Rep_a_type)<br>\n          ultimately<br>\n          have \"list_all2 cr_a_type (map f xs) (map ?f' ?xs')\"<br>\n            by -(rule fun_relD[OF fun_relD[OF map_transfer]])<br>\n          thus ?thesis<br>\n            by (rule untransfer)<br>\n        qed</p>\n<p>Note that everything related to the actual operation I am doing on f and<br>\nx is just mechanical application of transfer rules. Also the first two<br>\nsteps are what the lifting package does all the time. So it seems that<br>\nthis pattern can be automated.</p>\n<p>The main problem seems to be that this only works well for a<br>\nglobally-defined set \"a_set\". Trying to make goal abstract in \"a_set\"<br>\nusing a context fails</p>\n<p>context fixes S :: \"nat set\" assumes ne:\"S ≠ {}\"<br>\n        begin<br>\n          typedef (open) S_type = S using ne by auto<br>\n          setup_lifting type_definition_a_type<br>\n          (* ... *)</p>\n<p>with</p>\n<p>Illegal variables in representing set: \"S\"<br>\n        The error(s) above occurred in typedef \"S_type\".</p>\n<p>So one question is: Is it fundamentally not possible (i.e. unsound) to<br>\ndefine a type within a context that depends on a parameter? Or is<br>\ntheoretically acceptable as long as the type does not escape the<br>\ncontext, i.e. only lemmas are available to the outside that do not<br>\nmention this type?</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/JzyyIJSsLUs6428PkDGd5Zr1/signature.asc\">signature.asc</a></p>",
        "id": 294219854,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896867
    }
]