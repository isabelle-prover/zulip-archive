[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear list,</p>\n<p>Dmitriy and I are struggling with a proof about parametricity of a constant in <br>\nIsabelle/HOL. Suppose we have a natural functor 'a F and a parametric function foo</p>\n<p>bnf_axiomatization 'a F<br>\n   consts foo :: \"'a F =&gt; ('a =&gt; 'c G) =&gt; 'c G\"<br>\n   axiomatization where<br>\n     foo_param: \"!!A. rel_fun (rel_F A) (rel_fun (rel_fun A (rel_G B)) (rel_G B)) foo foo\"</p>\n<p>where 'b G is some type expression for which rel_G is the appropriate relator (G can be a <br>\nBNF, too, if this helps in any way).</p>\n<p>Further, we know that for given x :: 'a F and y :: 'b F with \"rel_F A x y\", the function <br>\nfoo ignores its second argument, i.e.,</p>\n<p>!!f g. foo x f = foo x g<br>\n   !!f g. foo y f = foo y g</p>\n<p>Can we deduce from all of the above that \"rel_G C (foo x f) (foo y g)\" for any f and g? <br>\nAnd if so, how?</p>\n<p>Intuitively, the reasoning goes as follows. Parametricity expresses that foo cannot create <br>\nvalues of type 'c out of nothing. By its type signature, it can only create such values by <br>\nusing the second argument. However, for the given arguments x and y, we know that foo x <br>\nand foo y ignore their second arguments, so foo cannot create a value in 'c. That is, foo <br>\nmust return a value of type 'c G which does not contain any 'c values at all. Therefore, <br>\nthere exist values a and b such that rel_G C a b for any relation C. Hence,</p>\n<p>rel_fun A (rel_G C) (%_. a) (%_. b)</p>\n<p>and therefore foo x f = foo x (%_. a) <code>rel_G C</code> foo y (%_. b) = foo y g.</p>\n<p>Is there a flaw in our intuitive reasoning? If not, how could this be formally expressed <br>\nin HOL?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294677624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175499
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Andreas,</p>\n<p>I guess the question is weird enough to require my competence.  [<span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span>]</p>\n<p>I think your intuition is correct, and the fact that G is a BNF is helpful.</p>\n<p>AFAIS, the missing hole in your argument can be filled if you prove that,</p>\n<p>(1) for a fixed type K and a unary BNF G,</p>\n<p>any function u : (K -&gt; 'a G) -&gt; 'a G that is both constant (i.e., ignores its arguments) and 'a-parametric has it's image consisting of an element</p>\n<p>y with no a'-atoms, i.e., such that Gset y = {}</p>\n<p>(2) For any BNF G, any element y with no atoms is G-related to itself, i.e., Grel R y y holds for any relation R on 'a.</p>\n<p>Now, (1) should follow by contradiction: assume otherwise, and use the parametricity of u for the graphs of the functions (% a. True) and (%a. False)</p>\n<p>to contradict that u is constant. (2) should follow using the connection between Grel and Gset, via Gmap.</p>\n<p>Andrei<br>\n<a href=\"/user_uploads/14278/1Ym6-JSy3PcYQSw3EUUoxaPD/OutlookEmoji-.png\">OutlookEmoji-ðŸ˜Š.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/1Ym6-JSy3PcYQSw3EUUoxaPD/OutlookEmoji-.png\" title=\"OutlookEmoji-ðŸ˜Š.png\"><img src=\"/user_uploads/14278/1Ym6-JSy3PcYQSw3EUUoxaPD/OutlookEmoji-.png\"></a></div>",
        "id": 294677649,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175512
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Andrei,</p>\n<p>Thanks for the idea of using map_G (%_. True) and map_G (%_. False). Rather than going for <br>\na contradiction and using set_G, I can derive from this that</p>\n<p>rel_G (%_ _. False) (foo x f) (foo x f)</p>\n<p>and thus \"rel_G B (foo x f) (map undefined (foo x f))\" by monotonicity. That's enough to <br>\nshow the rest.</p>\n<p>My proof needs the following five properties of rel_G:</p>\n<p>\"rel_G op = = op =\"<br>\n  \"â‹€R f x y. rel_G R (map_G f x) y = rel_G (Î»x. R (f x)) x y\"<br>\n  \"â‹€R f x y. rel_G R x (map_G f y) = rel_G (Î»x y. R x (f y)) x y\"<br>\n  \"â‹€R R' x y. R &lt;= R' âŸ¹ rel_G R &lt;= rel_G R'\"<br>\n  \"â‹€R R'. rel_G (R OO R') = rel_G R OO rel_G R'\"</p>\n<p>I am not sure how much they differ from the BNF requirements, but at least I don't need a <br>\nset function (and certainly no bound).</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294677693,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175530
    }
]