[
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nHi Andreas,<br>\nthe good news is that there is a ML interface that you could use, but it <br>\nrequires some setup.</p>\n<p>I don't know why you decided to define the transfer relation from 'a <br>\noption to 'a set and not the other way around. I would say that 'a set <br>\nis the representation type for 'a option. If we turn the direction <br>\naround, there is a quite straightforward solution since we can use <br>\nsetup_lifting to set up the whole machinery for us.</p>\n<p>definition set_option_inv :: \"'a set =&gt; 'a option\" where \"set_option_inv <br>\n= inv set_option\"</p>\n<p>lemma td_option: \"type_definition set_option set_option_inv {A . card A <br>\n≤ 1}\"<br>\nsorry</p>\n<p>setup_lifting td_option<br>\n(* setup lifting defines cr_option and pcr_option for you *)</p>\n<p>lemma join_option_transfer: \"(pcr_option (pcr_option op=) ===&gt; <br>\npcr_option op=) Union join_option\"<br>\nsorry</p>\n<p>(* this is the step where you have to unfortunately use the ML interface *)</p>\n<p>ML{*<br>\nLifting_Def.generate_parametric_transfer_rule @{context} @{thm <br>\njoin_option_transfer} @{thm Union_transfer}<br>\n*}</p>\n<p>If you insist on the other direction the things get considerably more <br>\nhackish. I would like to refine the infrastructure such that this <br>\nfunctionality would not be so much Lifting dependent and could be used <br>\nindependently in the Transfer world, but this is nothing that would <br>\nhappen in the next two months. But still hopefully before the next release.</p>\n<p>Hope this helps.</p>\n<p>Bests,<br>\nOndrej</p>\n<p>.</p>",
        "id": 294649922,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165689
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Ondrej,</p>\n<p>Thanks for the quick answer. I chose the direction from 'a option to 'a set such that I <br>\ncould get a reasonable transfer rule for set_option, namely</p>\n<p>(op = ===&gt; cr_option_set) (%x. x) set_option</p>\n<p>If we turn the direction around, we get</p>\n<p>(op = ===&gt; cr_set_option) set_option (%x. x)</p>\n<p>and I had a bad gut feeling about registering a transfer rule with \"%x. x\" on the <br>\nright-hand side. I do not have any concrete example where this might cause trouble, but as <br>\nit is often cumbersome to figure out why transfer/transfer_prover in a big statement, I <br>\ntry to stay away from problems. Do you know whether such a rule is safe or of a better format?</p>\n<p>I also tried setup_lifting with another monad, say type ('a, 'b, 'c) my_monad (where 'b <br>\nand 'c are just additional type parameters which are fixed for the monad instance; <br>\nmy_monad is defined with the datatype package where 'c is dead). Unfortunately, <br>\nsetup_lifting refused the registration of the td lemma because the raw type has extra type <br>\nvariables 'b and 'c. Can I somehow work around this as well?</p>\n<p>Best,<br>\nAndreas</p>\n<p>PS: And don't worry about release cycles. I am again hooked on the repository anyway.</p>",
        "id": 294650433,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165892
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nOn 08/05/2015 08:26 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Hi Ondrej,</p>\n<p>Thanks for the quick answer. I chose the direction from 'a option to 'a<br>\nset such that I could get a reasonable transfer rule for set_option, namely</p>\n<p>(op = ===&gt; cr_option_set) (%x. x) set_option</p>\n<p>If we turn the direction around, we get</p>\n<p>(op = ===&gt; cr_set_option) set_option (%x. x)</p>\n<p>and I had a bad gut feeling about registering a transfer rule with \"%x.<br>\nx\" on the right-hand side. I do not have any concrete example where this<br>\nmight cause trouble, but as it is often cumbersome to figure out why<br>\ntransfer/transfer_prover in a big statement, I try to stay away from<br>\nproblems. Do you know whether such a rule is safe or of a better format?</p>\n</blockquote>\n<p>In my proposal, the setup_lifting command generates automatically the <br>\nfollowing (fully parametrized) transfer rule for set_option:</p>\n<p>option.rep_transfer: (pcr_option ?T ===&gt; rel_set ?T) (λx. x) set_option</p>\n<p>Is this rule reasonable for you as well or did I miss something?</p>\n<blockquote>\n<p>I also tried setup_lifting with another monad, say type ('a, 'b, 'c)<br>\nmy_monad (where 'b and 'c are just additional type parameters which are<br>\nfixed for the monad instance; my_monad is defined with the datatype<br>\npackage where 'c is dead). Unfortunately, setup_lifting refused the<br>\nregistration of the td lemma because the raw type has extra type<br>\nvariables 'b and 'c. Can I somehow work around this as well?</p>\n</blockquote>\n<p>I'm afraid most probably not since it is one of the basic invariants of <br>\nLifting. Dead variables are not (yet) supported as well.</p>\n<p>Ondrej</p>",
        "id": 294651703,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166328
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear experts of lifting and transfer,</p>\n<p>The command lift_definition can generate parametric transfer rules from non-parametric <br>\nones if a parametricity theorem for the raw term is given. I would like to use this <br>\ntransformation also for other transfer rules between constants that are not defined with <br>\nlift_definition.</p>\n<p>Consider, for example, the option monad can be embedded in the monad on sets. Thus, one <br>\ncan define the correspondence relation and prove appropriate transfer rules for the monad <br>\noperations.</p>\n<p>definition cr_option_set :: \"'a option ⇒ 'a set ⇒ bool\"<br>\nwhere \"cr_option_set x A ⟷ A = set_option x\"</p>\n<p>lemma<br>\n   \"(cr_option_set ===&gt; (op = ===&gt; cr_option_set) ===&gt; cr_option_set)<br>\n   Option.bind Set.bind\"<br>\nby(auto simp add: cr_option_set_def rel_fun_def)</p>\n<p>Now, if I have two functions defined over the option monad and the set monad, <br>\nrespectively, then transfer_prover can show that the second is an embedding of the first. <br>\nUnfortunately, this does not work for the join operation on monads, because the types are <br>\nnested: join_option :: \"'a option option =&gt; 'a option\" and Union :: \"'a set set =&gt; 'a set\".</p>\n<p>So, I'd like to use parametrised transfer rules, but proving them directly is a pain. Can <br>\nI somehow use the magic behind lift_definition for deriving the parametrised rules?</p>\n<p>Thanks,<br>\nAndreas</p>",
        "id": 294652257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166591
    }
]