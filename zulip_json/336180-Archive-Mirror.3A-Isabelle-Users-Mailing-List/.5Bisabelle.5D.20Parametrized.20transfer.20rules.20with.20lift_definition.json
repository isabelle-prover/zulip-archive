[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Ondrej,</p>\n<p>Thanks for the explanations. I am still not sure whether this merging can be used for what <br>\nI have in mind.</p>\n<p>Here is some background: For the translator from HOL4 to CakeML, Myreen and Owens came up <br>\nwith a small calculus to automatically prove transfer relations from well-founded function <br>\ndefinitions. I would like to adapt their approach for deriving parametricity theorems for <br>\n\"function\" definitions. In essence, rather than proving</p>\n<p>(rel_P A ===&gt; rel_R A) f f</p>\n<p>for a function f :: 'a P =&gt; 'a R, they prove</p>\n<p>(fix x (rel_P A) ===&gt; rel_R A) f f</p>\n<p>by induction on x using f.induct where</p>\n<p>fix x R = (%y z. x = y &amp; R y z)</p>\n<p>The cases of the induction proofs then look very much like a transfer proof (more like <br>\nPeter Lammich's transfer prover than your skeleton approach in transfer). However, for all <br>\nthe operators whose congruence rules were used in the function definition, the ordinary <br>\nparametricity rules for those operators do not suffice. For example, for map, one needs</p>\n<p>list_all2 A xs ys<br>\n   ==&gt; (!!x. x : set xs ==&gt; (fix x A ===&gt; B) f g)<br>\n   ==&gt; list_all2 B (map f xs) (map g ys)</p>\n<p>My idea was now to see whether one can derive this rule automatically from the <br>\nparametricity of map and its congruence rule, namely as the merge of</p>\n<p>list_all2 op = xs ys<br>\n   ==&gt; (!!x. x :    set xs ==&gt; (fix x (op =) ===&gt; op =) f g)<br>\n   ==&gt; list_all2 op = (map f xs) (map g ys)</p>\n<p>and</p>\n<p>list_all2 A xs ys<br>\n   ==&gt; (A ===&gt; B) f g<br>\n   ==&gt; list_all2 B (map f xs) (map g xs)</p>\n<p>because fix distributes nicely over OO: fix x (R OO S) = fix x R OO S<br>\nThinking backwards, I want to split the relation about f and g into two, namely</p>\n<p>fix x op = ===&gt; op =<br>\n   A ===&gt; B</p>\n<p>Thus, only one of them depends on the x (and this part then simplifies to the congruence <br>\nrule) and the other corresponds to the transfer rule. As all this happens in a premise, <br>\n===&gt; is in a negative position, so neg_fun_distr* come into play. And so far I was not <br>\nable to find a set of side conditions such that the merging (or splitting) works with \"fix <br>\nx op = ===&gt; op =\" on the left-hand side. Can you see whether any of your additional rules <br>\nfor fun_distr would work here?</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294675777,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174892
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nI'm a little bit confused. Is my understanding right that you want to <br>\nget some rules that allows you to infer the following?</p>\n<p>(fix x A ===&gt; B) &lt;= ((fix x op= ===&gt; op=) OO (A ===&gt; B))</p>\n<p>That property doesn't hold :(</p>\n<p>Ondrej</p>",
        "id": 294675789,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174898
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Ondrej,</p>\n<p>Your understanding is right. So my idea will not work :-(.</p>\n<p>Andreas</p>",
        "id": 294675809,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174904
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Lifting experts,</p>\n<p>I am looking for some documentation on how the Lifting tool derives the parametrised <br>\ntransfer rules from the parametricity theorem. In some cases, lift_definition reports that <br>\nit was not able to merge certain terms. I'd like to understand how this works and its <br>\nlimitations. I have a different application in mind (strengthening parametricity theorems <br>\nwith congruence rules) and would like to understand whether the same approach could work <br>\nthere.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294677034,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175303
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nHi Andreas,<br>\nthere is a brief description of the algorithm in my thesis in §4.3. That <br>\ndescription should give you a good overview how the procedure works.</p>\n<p>I can answer additional questions if needed.</p>\n<p>Bests,<br>\nOndrej</p>",
        "id": 294677156,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175346
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Ondrej,</p>\n<p>Thanks for the pointer. The last sentence of this section is what I am wondering about:</p>\n<p>I implemented a procedure that can do all of those steps automatically.</p>\n<p>The problem is that the function relator rel_fun does not distribute over relation <br>\ncomposition op OO. The comment in Lifting.thy indicates that the theorems pos_fun_distr, <br>\nneg_fun_distr1, and neg_fun_distr2 take the role of distributivity for functions. It seems <br>\nas if the latter two are used only for higher-order arguments, but it is not yet clear to <br>\nme which of the two covers which cases.</p>\n<p>They have preconditions on the relations like left_unique and right_total. How do you make <br>\nsure that they can be used for the relations? neg_fun_distr2 only has assumptions about <br>\nthe relations on the right hand side of OO, so this will affect only the correspondence <br>\nrelation, so lift_definition has some control over this. But what about neg_fun_distr1 and <br>\nits assumptions on relations on the left?</p>\n<p>Also, one could prove two more rules of the kind of neg_fun_distr1 and neg_fun_distr2. For <br>\nexample,</p>\n<p>lemma neg_fun_distr3:<br>\n   assumes 1: \"left_unique R\" \"right_total R\"<br>\n   and 2: \"right_unique S\" \"left_total S\"<br>\n   shows \"R OO R' ===&gt; S OO S' ≤ (R ===&gt; S) OO (R' ===&gt; S')\"<br>\n   using functional_converse_relation[OF 1] functional_relation[OF 2]<br>\n   unfolding rel_fun_def OO_def<br>\n   apply clarify<br>\n   apply (subst all_comm)<br>\n   apply (subst all_conj_distrib[symmetric])<br>\n   apply (intro choice)<br>\n   by metis</p>\n<p>Why are these rules not needed?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294677177,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175352
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nI looked at the procedure again and here is a more detailed description:</p>\n<p>Let say you have a transfer rule of the form \"T t f\" and a parametric <br>\ntransfer rule of the form \"par_R t' t\". From that you obtain \"(par_R' OO <br>\nT) t' f\". (par_R' is an instance of par_R).</p>\n<p>Now you want to do some massaging on the relation \"par_R' OO T\". I call <br>\nit merging and it is enough if you prove (par_R' OO T) &lt;= desired_T, <br>\nfrom which you obtain \"desired_T t' f\".</p>\n<p>How to prove \"(par_R OO T) &lt;= desired_T\"? In principle, you use rules <br>\nsuch as list_all R OO list_all S &lt;= list_all (R OO S) (obtained from <br>\nlist_all R OO list_all S = list_all (R OO S)). But before applying that <br>\nrule, we should not forget that we have to also do merging recursively <br>\non R and S by using this rule:<br>\nR &lt;= R' ==&gt; list_all R &lt;= list_all R' (monotonicity of list_all).</p>\n<p>As you know, some relators (yes it is ===&gt;) have contra-variant <br>\npositions and thus<br>\nR &gt;= R' ==&gt; S &lt;= S' ==&gt; (R ===&gt; S) &lt;= (R' ===&gt; S')<br>\nThus, we are suddenly proving the other direction R &gt;= R'.</p>\n<p>This is how it happens that we need neg_fun_distr1 and and neg_fun_distr2.<br>\nYes, they are used for higher-order arguments, if you want. But only for <br>\nnegative positions. When you get to double-negative positions (i.e., <br>\npositive again) pos_fun_distr is your friend again.</p>\n<p>Thus, switching the direction also requires rules such as list_all R OO <br>\nlist_all S &gt;= list_all (R OO S).</p>\n<p>On the topic of side-conditions: in general there might be multiple <br>\nrules for \"distributivity\" for one relator and they can have side <br>\nconditions. The rules are ordered by the time when they were registered. <br>\nThe merging procedure searches for the first one for which it can <br>\ndischarge all the side conditions after the rule is applied. The side <br>\nconditions are always of the form [right|left|bi][unique|total] and they <br>\nare simply discharged by the Transfer tool.</p>\n<p>Overall: for a given relator RR, you obtain all the above-used rules <br>\nautomatically if (RR R1 ... Rn) OO (RR S1 ... Sn) = RR (R1 OO S1) ... <br>\n(Rn OO Sn) and if you have the monotonicity rule (i.e., all BNFs fall in <br>\nthis category). If this is not the case, you have to do something <br>\nmanually as for the function type.</p>\n<p>You noticed that there are other variants of neg_fun_distr. Once I <br>\nproved even more of them (6 or 8, I can't remember) and included only <br>\nsome of them. My quick inspection showed that at higher-order negative <br>\npositions you are merging only equalities anyway. If you came across <br>\ndifferent examples, let me know. We can add the other rules as well.</p>\n<p>Ondrej</p>",
        "id": 294677670,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175521
    }
]