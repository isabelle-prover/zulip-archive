[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nNote that the normal programming interface for abbreviations is<br>\nLocal_Theory.abbrev. In contrast, Specification.abbreviation is the<br>\nuser-interface -- it corresponds the 'specification' command in Isar<br>\nsyntax. When building other definitional packages, the internal<br>\nprogramming interfaces are usually easier to use and more robust than<br>\ntoplevel commands, e.g. open-ended mechanisms like type-inference and<br>\nvarious \"term check\" phases are omitted (the results of that are<br>\ndifficult to predict in general).</p>\n<p>The included example illustrates the above situation with proper use of<br>\nLocal_Theory.abbrev and some further details.</p>\n<p>The local theory concept comprises various contexts, notably:</p>\n<p>* The hypothetical context is what you build up cumulatively in the<br>\ndefinitional package: lthy, lthy', lthy'' etc. after adding<br>\nspecifications like Local_Theory.define/note/abbrev.</p>\n<p>* The target context is the result that is seen at the end of the<br>\npackage (sometimes several packages are composed internally). A typical<br>\nexample is the locale target.</p>\n<p>* The foundation (or background) context reduces the fancy local<br>\ntheory concepts to the reality of the logic at the bottom.</p>\n<p>Your observation boils down to the question: What is the meaning of<br>\nLocal_Theory.abbrev in terms of different context? (Only the first two<br>\nmatter for regular use, the foundation is merely an implementation detail.)</p>\n<p>For Local_Theory.abbrev we see the following, when looking at the<br>\ndescription in Isabelle/ML<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/annotate/Isabelle2017/src/Pure/Isar/local_defs.ML#l118\">http://isabelle.in.tum.de/repos/isabelle/annotate/Isabelle2017/src/Pure/Isar/local_defs.ML#l118</a><br>\nand the main application in the inductive package<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/annotate/Isabelle2017/src/HOL/Tools/inductive.ML#l1188\">http://isabelle.in.tum.de/repos/isabelle/annotate/Isabelle2017/src/HOL/Tools/inductive.ML#l1188</a></p>\n<p>(1) In the hypothetical context an abbreviation is more like a local<br>\ndefinition: it needs to be expanded explicitly as required (definitional<br>\npackages might have different requirements in different situations).</p>\n<p>(2) In the target context an abbreviation is really expanded in the<br>\nabstract syntax \"term check\" phase, this is the normal behavior for<br>\nend-users working with the results of such specifications.</p>\n<p>I don't remember all the reasons why point 1) emerged the way it works<br>\ntoday -- actually already in Isabelle2007 (November 2007), but here is<br>\nsome historical evidence for it:</p>\n<p>changeset:   25029:3a72718c5ddd<br>\nuser:        wenzelm<br>\ndate:        Sun Oct 14 16:13:45 2007 +0200<br>\nfiles:       src/HOL/Tools/inductive_package.ML<br>\ndescription:<br>\ngen_add_inductive_i: treat abbrevs as local defs, expand by export;<br>\ntuned;</p>\n<p>changeset:   25114:7aa178165ee4<br>\nuser:        wenzelm<br>\ndate:        Sat Oct 20 18:54:28 2007 +0200<br>\nfiles:       src/HOL/Tools/inductive_package.ML<br>\ndescription:<br>\nadd_inductive: more careful handling of abbrevs -- do not expand<br>\nprematurely;</p>\n<p>changeset:   25143:2a1acc88a180<br>\nuser:        wenzelm<br>\ndate:        Mon Oct 22 15:24:58 2007 +0200<br>\nfiles:       src/HOL/Bali/DeclConcepts.thy<br>\nsrc/HOL/Tools/inductive_package.ML<br>\ndescription:<br>\nabbrevs within inductive definitions may no longer depend on each other<br>\n(reflects in internal organization, particularly for output);</p>\n<p>In the included Scratch.thy, I have wrapped up an expand operation for<br>\nprecisely the abbreviated term, by peeking at the definition of<br>\nLocal_Defs.fixed_abbrev. It could be also done with various export<br>\noperations from the modules Proof_Context, Local_Theory, Assumption, but<br>\nthat also exports wrt. other things added to the context in between,<br>\ne.g. actual Local_Theory.define.</p>\n<p>The programming interface for Local_Theory.abbrev could be more<br>\nconvenient in that respect, but it is used so rarely that no serious<br>\ndemand arose so far. De-facto, the 'inductive' package defines its<br>\nmeaning and purpose.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/BGKBbAyAMXLOGROJquAon7qd/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294728681,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187254
    },
    {
        "content": "<p>From: Cezary Kaliszyk &lt;<a href=\"mailto:cezarykaliszyk@gmail.com\">cezarykaliszyk@gmail.com</a>&gt;<br>\nDear Isabelle list,</p>\n<p>After I add an abbreviation to a local context, the parser seems to ignore<br>\nit.<br>\nIs there a way to get parsing without prefixes working for abbreviations in<br>\nmy local context?</p>\n<p>Minimal example of this strange behavior:</p>\n<p>theory t imports HOL begin<br>\nlocal_setup {* fn lthy =&gt;<br>\n  let<br>\n    val lthy2 = Specification.abbreviation Syntax.mode_default<br>\n      NONE [] @{term \"asd == True\"} true lthy<br>\n    val _ = tracing (@{make_string} (Syntax.read_term lthy2 \"asd\")<br>\n  in lthy2 end<br>\n*}</p>\n<p>Displays \"Free asd\" rather than \"Const True\".</p>\n<p>Surprisingly, I get \"Const True\" if I prefix it by the theory<br>\nname (as in \"t.asd\") or if I reset the context, as in:<br>\n    val lthy3 = Proof_Context.init_global (Proof_Context.theory_of lthy2)<br>\nboth of which I believe I should not be doing myself, so how can I get<br>\nparsing for abbreviations to work in a local context?</p>\n<p>Regards,<br>\nCezary</p>",
        "id": 294729653,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187567
    }
]