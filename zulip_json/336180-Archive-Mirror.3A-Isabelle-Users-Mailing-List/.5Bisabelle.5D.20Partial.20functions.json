[
    {
        "content": "<p>From: Jesper Bengtson &lt;<a href=\"mailto:jesper.bengtson@it.uu.se\">jesper.bengtson@it.uu.se</a>&gt;<br>\nGreetings</p>\n<p>I am trying out the new functions package which shipped with Isabelle 2007. The<br>\nfunction I am trying to create a function for parallel substitution where I<br>\nwant to reason about the domain and range of the substitution at top level,<br>\ni.e. I want to be able to write P[xvec:=Tvec] where xvec and Tvec are lists<br>\nrather than P[S] where S is a tuple list. The problem with this approach is<br>\nthat the function is only defined if the lists xvec and Tvec are of the same<br>\nlength. I tried writing the following function:</p>\n<p>function (domintros) substName :: \"name =&gt; name list =&gt; trm list =&gt; trm\"<br>\n(\"_[_:=_]\" [100, 100, 100] 100)<br>\nwhere<br>\n  \"substName a [] [] = (Name a)\"<br>\n| \"length xs = length Ts ==&gt; substName a (x#xs) (T#Ts) = (if a = x then T else<br>\n(substName a xs Ts))\"</p>\n<p>But at the top of the proof obligations I get a goal which seems pretty<br>\nunsolvable to me:</p>\n<p>/\\P x. [|a. x = (a, [], []) ==&gt; P;<br>\n         /\\xs Ts a xa T. [|length xs = length Ts;<br>\n                           x = (a, xa # xs, T # Ts)|] ==&gt; P|]<br>\n       ==&gt; P</p>\n<p>It seems to be some sort of completeness condition for the function.</p>\n<p>I've read through the guide of the function package and it is a bit unclear if<br>\nit is possible to do what I'm trying to do. There are of course work arounds,<br>\nbut this would be nicer.</p>\n<p>Many thanks.</p>\n<p>/Jesper</p>",
        "id": 294060081,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823263
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nJesper,</p>\n<blockquote>\n<p>I am trying out the new functions package which shipped with Isabelle 2007. The<br>\nfunction I am trying to create a function for parallel substitution where I<br>\nwant to reason about the domain and range of the substitution at top level,<br>\ni.e. I want to be able to write P[xvec:=Tvec] where xvec and Tvec are lists<br>\nrather than P[S] where S is a tuple list. The problem with this approach is<br>\nthat the function is only defined if the lists xvec and Tvec are of the same<br>\nlength. I tried writing the following function:</p>\n<p>function (domintros) substName :: \"name =&gt; name list =&gt; trm list =&gt; trm\"<br>\n(\"_[_:=_]\" [100, 100, 100] 100)<br>\nwhere<br>\n  \"substName a [] [] = (Name a)\"<br>\n| \"length xs = length Ts ==&gt; substName a (x#xs) (T#Ts) = (if a = x then T else<br>\n(substName a xs Ts))\"</p>\n</blockquote>\n<p>This is not partiality in the sense of the function package. The special <br>\nsupport with domain predicate, domintros and all that is for functions <br>\nwhich have a possibly nonterminating recursion. Here, you simply want to <br>\nomit some cases and leave them undefined in some sense.</p>\n<p>What you would do is simply</p>\n<p>function (sequential) substName :: \"name =&gt; name list =&gt; trm list =&gt; trm\"<br>\n  (\"_[_:=_]\" [100, 100, 100] 100)<br>\nwhere<br>\n   \"substName a [] [] = (Name a)\"<br>\n| \"substName a (x#xs) (T#Ts) =<br>\n     (if a = x then T else (substName a xs Ts))\"</p>\n<p>The (sequential) option will add the missing cases and map them to the <br>\nunspecified constant \"undefined\".</p>\n<p>You would only need section 7 from the function tutorial if you function <br>\nhad a recursion that could fail to terminate.</p>\n<blockquote>\n<p>But at the top of the proof obligations I get a goal which seems pretty<br>\nunsolvable to me:</p>\n<p>/\\P x. [|a. x = (a, [], []) ==&gt; P;<br>\n         /\\xs Ts a xa T. [|length xs = length Ts;<br>\n                           x = (a, xa # xs, T # Ts)|] ==&gt; P|]<br>\n       ==&gt; P</p>\n<p>It seems to be some sort of completeness condition for the function.</p>\n</blockquote>\n<p>Yes. And it is unsolvable, because your equations are incomplete. The <br>\n(sequential) option will add the remaining patterns, and you get a <br>\nbetter proof obligation. (solvable with the usual \"by pat_completeness <br>\nauto\"). Or, you simply use \"fun\", which has (sequential) implicit and <br>\ndoes all proofs for you...</p>\n<p>Cheers,<br>\nAlex</p>",
        "id": 294060091,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823267
    },
    {
        "content": "<p>From: \"Roger H.\" &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt;<br>\nHallo,</p>\n<p>i want to create a datatype that allows me to write functions from a nat subset to another nat subset.<br>\nfor example i wanna be able to write: </p>\n<p>definition f: {1,2,3} =&gt; {4,5} <br>\n                     1 --&gt;4,  2--&gt;4, 3--&gt;5</p>\n<p>or another one:     </p>\n<p>definition g : {6,8} =&gt; {2,3,4}</p>\n<p>So the thing i want to somehow parametrize is  \"which subset of the nat im using each time as domain and range\" ,</p>\n<p>I thought about creating a new datatype :    'a nat <br>\nThe problem with this is that 'a  is instantiated with datatypes, and not sets like {1,2,3}.</p>\n<p>Following solutions are bad:</p>\n<ol>\n<li>\n<p>Everytime i want declare a new function, i have to declare by \"typedef\" the nat subsets i want as domain and range</p>\n</li>\n<li>\n<p>definition f :  \"nat =&gt; nat\" where<br>\n       \"f x = (if x : {1,2,3} then ....  else undefined)</p>\n</li>\n</ol>\n<p>This second approach is bad, cause i dont want the domain to be decided as late as the second line of the declaration, cause after this i want to be able to program a selector \"domain f\"<br>\nthat returns me the domain of f, thats why i want the domain of f to be somehow incapsulated (parametrized) in the first line \"f: nat =&gt;nat \" so that i can use it later.</p>\n<p>What would you do in this situation?       </p>\n<p>Many thanks!</p>",
        "id": 294242535,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907582
    }
]