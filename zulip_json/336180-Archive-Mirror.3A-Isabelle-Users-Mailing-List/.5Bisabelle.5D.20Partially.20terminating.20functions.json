[
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nHi,</p>\n<p>Our Cryptol-&gt;Isabelle translator generates recursive function  <br>\ndefinitions that don't always terminate, but should terminate when the  <br>\ninputs satisfy certain conditions known to the user but not  <br>\nnecessarily to the translator, i.e. the functions are partially  <br>\nterminating.</p>\n<p>Here is a non-Cryptol example of what I'm talking about:</p>\n<p>function (domintros)<br>\n   fac_int :: \"int =&gt; int\" where<br>\n  \"fac_int n = (if n = 0 then 1 else n * fac_int (n - 1))\"<br>\nby pat_completeness auto</p>\n<p>I'd like to prove the following partial termination lemma for fac_int:</p>\n<p>lemma \"0 &lt;= n ==&gt; fac_int_dom n\"</p>\n<p>However, the termination rule for fac_int_dom seems to be too weak:</p>\n<p>lemma fac_int.termination:<br>\n   \"[|wf ?R;<br>\n     !!n. n ~= 0 ==&gt; (n - 1, n) \\&lt;in&gt; ?R|]<br>\n    ==&gt; !x. fac_int_dom x\"</p>\n<p>What I really need is a rule like this, where ?P is an arbitrary  <br>\nprecondition on input ?x:</p>\n<p>lemma fac_int.partial_termination:<br>\n   \"[|wf ?R;<br>\n     !!n. [|?P n; n ~= 0|] ==&gt; (n - 1, n) \\&lt;in&gt; ?R;<br>\n     ?P ?x|]<br>\n    ==&gt; fac_int_dom ?x\"</p>\n<p>I know I could generate a rule like this by changing the definition of  <br>\nfac_int, but we don't want the user to have to muck with Cryptol- <br>\ngenerated definitions just to prove partial termination.</p>\n<p>Is it possible to have the function package generate a partial  <br>\ntermination rule for recursive functions?</p>\n<p>Thanks,<br>\n-john</p>",
        "id": 294064130,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824825
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi John,</p>\n<blockquote>\n<p>function (domintros)<br>\n  fac_int :: \"int =&gt; int\" where<br>\n \"fac_int n = (if n = 0 then 1 else n * fac_int (n - 1))\"<br>\nby pat_completeness auto</p>\n<p>I'd like to prove the following partial termination lemma for fac_int:</p>\n<p>lemma \"0 &lt;= n ==&gt; fac_int_dom n\"</p>\n</blockquote>\n<p>Here is a proof:</p>\n<p>lemma \"0 &lt;= n ==&gt; fac_int_dom n\"<br>\nproof (induct rule: int_ge_induct)<br>\n   case base show ?case<br>\n     by (auto intro: accpI elim: fac_int_rel.cases)<br>\nnext<br>\n   case (step i)<br>\n   show ?case<br>\n     by (rule accpI) (auto intro: step elim!: fac_int_rel.cases )<br>\nqed</p>\n<blockquote>\n<blockquote>\n<p>However, the termination rule for fac_int_dom seems to be too weak:</p>\n</blockquote>\n<p>lemma fac_int.termination:</p>\n</blockquote>\n<p>The \".termination\" rule can only prove totality. You have to use the <br>\nrules for accessible part and the call relation, as above. Note that <br>\n\"fac_int_dom\" is just an abbreviation for \"accp fac_int_rel\".</p>\n<blockquote>\n<p>What I really need is a rule like this, where ?P is an arbitrary <br>\nprecondition on input ?x:</p>\n<p>lemma fac_int.partial_termination:<br>\n  \"[|wf ?R;<br>\n    !!n. [|?P n; n ~= 0|] ==&gt; (n - 1, n) \\&lt;in&gt; ?R;<br>\n    ?P ?x|]<br>\n   ==&gt; fac_int_dom ?x\"</p>\n</blockquote>\n<p>In fact, this rule is wrong: Take P as \"&gt;= - 10\" and<br>\nR as \"{(n - 1, n) | n. n &gt;= - 10 }\".</p>\n<p>For this to work, P must be preserved by recursive calls.</p>\n<blockquote>\n<p>Is it possible to have the function package generate a partial <br>\ntermination rule for recursive functions?</p>\n</blockquote>\n<p>At the moment, the best way is to use the definition of the domain <br>\ndirectly as above, together with a suitable induction. An alternative to <br>\nthe \"(rule accp) then (erule fac_int_rel.cases)\" is the \".domintro\" <br>\nrule, which makes the above proof much shorter:</p>\n<p>lemma \"0 &lt;= n ==&gt; fac_int_dom n\"<br>\nby (induct rule: int_ge_induct) (auto intro: fac_int.domintros)</p>\n<p>On the other hand, the domintros are sometimes a little ad-hoc (due to <br>\ninternal forward simplification), and some users had probolems with it. <br>\nBut the manual version using the definitions always works.</p>\n<p>Alex</p>",
        "id": 294064167,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824837
    },
    {
        "content": "<p>From: Thomas Arthur Leck Sewell &lt;<a href=\"mailto:tsewell@cse.unsw.EDU.AU\">tsewell@cse.unsw.EDU.AU</a>&gt;<br>\nHi John,</p>\n<p>We ran in to a problem somewhat like this. In fact, you have all the <br>\ninformation you need - use an ML antiquotation like</p>\n<p>ML {* @{term \"fac_int_dom\"} *}</p>\n<p>and you'll see that fac_int_dom is an abbreviation for the accessible part <br>\nof fac_int_rel, for which you have far more information. In particular, <br>\nyou should be able to prove that \"n &gt;= 0 ==&gt; fac_int_dom n\" from that, and <br>\nthen you will be able to use the psimps and pinduct rules.</p>\n<p>We were considering recommending that the function package produce an <br>\nappropriate rule so that you don't have to spot the abbreviation in order <br>\nto prove some precondition implies *_dom.</p>\n<p>Yours,<br>\n    Thomas.</p>",
        "id": 294064223,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824844
    },
    {
        "content": "<p>From: Thomas Arthur Leck Sewell &lt;<a href=\"mailto:tsewell@cse.unsw.EDU.AU\">tsewell@cse.unsw.EDU.AU</a>&gt;<br>\nThe confusion about partial termination in the function package could <br>\npossibly be solved by modifying the theorem searcher.</p>\n<p>Abbreviations such as rec_fun_dom are easily confused for constants. The <br>\nproblem is that the theorem searcher doesn't help to distinguish them.</p>\n<p>When accidentally searching for abbreviations within your own theories it <br>\nis usually clear that the theorem searcher is displaying less results <br>\nthan it should. Constants generated by automatic packages, however, are <br>\nassumed to be special cases. It is easy to believe that few rules are <br>\navailable.</p>\n<p>Perhaps the theorem searcher could solve these problems by warning that <br>\none of the input terms is an abbreviation, and that more facts might be <br>\navailable for its constituent parts. I'm not sure how to implement <br>\nthis, but I think it would save some confusion.</p>\n<p>Another solution would be to have yet another colour scheme in Proof <br>\nGenereal to help identify abbreviations. I suspect this might be overkill.</p>\n<p>Yours,<br>\n    Thomas.</p>",
        "id": 294064304,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824874
    },
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nHi Alex,</p>\n<blockquote>\n<p>Here is a proof:</p>\n<p>lemma \"0 &lt;= n ==&gt; fac_int_dom n\"<br>\nproof (induct rule: int_ge_induct)<br>\n case base show ?case<br>\n   by (auto intro: accpI elim: fac_int_rel.cases)<br>\nnext<br>\n case (step i)<br>\n show ?case<br>\n   by (rule accpI) (auto intro: step elim!: fac_int_rel.cases )<br>\nqed</p>\n</blockquote>\n<p>Thanks. I didn't realize the function package generated these extra  <br>\nlemmas for fac_int_rel, since I was just using find_theorems on  <br>\n\"fac_int_dom _\".</p>\n<blockquote>\n<blockquote>\n<p>What I really need is a rule like this, where ?P is an arbitrary  <br>\nprecondition on input ?x:<br>\nlemma fac_int.partial_termination:<br>\n \"[|wf ?R;<br>\n   !!n. [|?P n; n ~= 0|] ==&gt; (n - 1, n) \\&lt;in&gt; ?R;<br>\n   ?P ?x|]<br>\n  ==&gt; fac_int_dom ?x\"</p>\n</blockquote>\n<p>In fact, this rule is wrong: Take P as \"&gt;= - 10\" and<br>\nR as \"{(n - 1, n) | n. n &gt;= - 10 }\".</p>\n<p>For this to work, P must be preserved by recursive calls.</p>\n</blockquote>\n<p>Ah, right. I missed that extra constraint.</p>\n<p>Thanks,<br>\n-john</p>",
        "id": 294064562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824972
    },
    {
        "content": "<p>From: John Matthews &lt;<a href=\"mailto:matthews@galois.com\">matthews@galois.com</a>&gt;<br>\nHi Thomas, thanks for your help.</p>\n<p>I agree, it would be useful for the function package to automatically  <br>\ngenerate a partial termination rule, just not mine! :)</p>\n<p>Thanks,<br>\n-john</p>",
        "id": 294064569,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824978
    }
]