[
    {
        "content": "<p>From: <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a><br>\nHello isabelle-users.</p>\n<p>I've been thinking about partially-terminating recursive functions a <br>\nlittle over the<br>\nlast day or two. Here's a silly example:</p>\n<p>function<br>\n   escalate :: \"(nat =&gt; nat) =&gt; nat =&gt; nat =&gt; nat\"<br>\nwhere<br>\n   \"escalate m lim n = (if n &gt;= lim then n else escalate m lim (m n))\"<br>\nby pat_completeness auto</p>\n<p>Obviously this function doesn't always terminate, but perhaps it would if<br>\nwe first assumed something about the function m, for instance that it <br>\nincreases<br>\nn, or that it increases n on a key subset of the naturals.</p>\n<p>I thought I recalled that the function package could be used for this. <br>\nIf I inspect<br>\nthe theorems exported by the \"function\" command above (before any matching<br>\n\"termination), I see partial simp and induct rules named escalate.psimps<br>\nand escalate.pinduct. These are sufficient to prove what we need about the<br>\nescalate function, but only within its terminating domain \"escalate_dom\".</p>\n<p>Here's the problem. We have no rules whatsoever with which to prove anything<br>\nabout \"escalate_dom\". Everything is hidden. Even the rule <br>\nescalate.termination,<br>\nwhich I think I'm meant to use next, is hidden.</p>\n<p>Also, escalate.termination is only useful for proving total termination. <br>\nTo prove that<br>\nthe function terminates on some limited domain will require some other <br>\nstrategy.</p>\n<p>In short, my recollection that the function package could easily be used for<br>\npartially terminating functions was totally wrong. Is there somewhere else<br>\nI'm forgetting to look?</p>\n<p>In the attached theory, I use some ML-level tricks to \"see\" the hidden <br>\nrules, to see<br>\nthrough the abbreviation \"escalate_dom\", and to find the theorem <br>\nescalate_rel.cases<br>\nwhich I really need.</p>\n<p>I also prove a variant of the acc/wf connection from Wellformed which <br>\nallows us to<br>\nprove that some subset of elements is within the accessible part, using <br>\nthe regular<br>\nwf machinery. This is really needed if we're going to make much progress <br>\nhere.</p>\n<p>Finally I apply that to escalate, and prove a silly case about even numbers.</p>\n<p>OK. Is anyone maintaining this? Should the theorem escalate.termination <br>\nreally<br>\nbe hidden? Would it be useful to other users to have the function package<br>\nexpose something else, maybe a ptermination rule analagous to the<br>\ntermination rule, with which to prove anything about partially terminating<br>\nfunctions?</p>\n<p>It seems inconsistent to me that the package exposes these psimp rules but<br>\nno way to use them.</p>\n<p>Anyway, hope this might be of help to someone.</p>\n<p>Cheers,<br>\n     Thomas.<br>\n<a href=\"/user_uploads/14278/Bj4bje3U4UksyovOhg2QKVxw/Escalate.thy\">Escalate.thy</a></p>",
        "id": 294711114,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182229
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Thomas,</p>\n<blockquote>\n<p>Here's the problem. We have no rules whatsoever with which to prove anything<br>\nabout \"escalate_dom\". Everything is hidden. Even the rule <br>\nescalate.termination,<br>\nwhich I think I'm meant to use next, is hidden.</p>\n</blockquote>\n<p>you might need to do some tricks to be able to use the theorems, but<br>\nprobably not <em>that</em> low level.</p>\n<p>The function package exposes the ML function \"Function.get_info\" to<br>\nobtain a bunch of results about a function. \"R\" is the relation you're<br>\ninterested in, and \"Inductive.the_inductive\" will give you info about<br>\nthat. The resulting theorems can be used in an ML tactic.</p>\n<blockquote>\n<p>OK. Is anyone maintaining this? Should the theorem escalate.termination <br>\nreally<br>\nbe hidden? Would it be useful to other users to have the function package<br>\nexpose something else, maybe a ptermination rule analagous to the<br>\ntermination rule, with which to prove anything about partially terminating<br>\nfunctions?</p>\n</blockquote>\n<p>Nobody is maintaining this. But it's probably just a matter of removing<br>\nsome \"concealed\"s in the code.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294711127,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182235
    },
    {
        "content": "<p>From: Dominic Mulligan via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Thomas,</p>\n<p>It sounds like you want to use (domintros).  For example:</p>\n<p>function (domintros) foo  :: \"nat ⇒ nat\" where<br>\n  \"foo x = x\"<br>\n  by pat_completeness auto</p>\n<p>thm foo.domintros</p>\n<p>Also, see Section 8.2 of the Function package documentation supplied<br>\nwith Isabelle.</p>\n<p>Thanks,<br>\nDominic</p>",
        "id": 294711143,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182241
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI agree with Dominic that domintros is probably what you want to use and<br>\nthat the function package documentation is a good way to start.</p>\n<p>Here's how you could use domintros in your particular case:</p>\n<p>lemma bounded_nat_gt_induct [case_names base gt]:<br>\n  \"(⋀n::nat. n ≥ m ⟹ P n) ⟹ (⋀n. n &lt; m ⟹ (⋀n'. n' &gt; n ⟹ P n') ⟹ P n) ⟹ P n\"<br>\n  by induction_schema (force, rule wf_measure[of \"λn. m - n\"], auto)</p>\n<p>lemma<br>\n  assumes \"⋀x. x &lt; lim ⟹ m x &gt; x\"<br>\n  shows   \"escalate_dom (m, lim, n)\"<br>\nproof (induction n rule: bounded_nat_gt_induct [of lim])<br>\n  case (base n)<br>\n  thus ?case by (auto intro: escalate.domintros)<br>\nnext<br>\n  case (gt n)<br>\n  from gt.hyps have \"escalate_dom (m, lim, m n)\" by (intro gt.IH assms) auto<br>\n  thus ?case by (rule escalate.domintros)<br>\nqed</p>\n<p>There's also the \"partial_function\" command, which does not care about<br>\ntermination at all. It has two modes, but the most useful one is<br>\nprobably that where the function returns an \"'a option\" and<br>\nnon-termination returns a \"None\".</p>\n<p>Manuel</p>",
        "id": 294711157,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182247
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>There's also the \"partial_function\" command, which does not care<br>\nabout<br>\ntermination at all. It has two modes, but the most useful one is<br>\nprobably that where the function returns an \"'a option\" and<br>\nnon-termination returns a \"None\".</p>\n</blockquote>\n<p>Afterwards, one can prove that the function never returns None<br>\n(possibly with some preconditions), and use \"the\" to get the<br>\ncorresponding plain function.</p>",
        "id": 294711177,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182253
    },
    {
        "content": "<p>From: <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a><br>\nThanks for all the replies. Thanks indeed for pointing out Section 8.2<br>\nof the long function package document, which indeed seems to suggest<br>\nthat some of the hidden theorems I've found are canonical for use,<br>\ncuriously not including f.termination.</p>\n<p>Yes, there are workarounds. I can use partial_function, or tailrec mode,<br>\nor declare a type of well-behaved inputs, and derive (eventually) the <br>\nfunction<br>\nI want. This seems like overkill, however, since the function package <br>\ndefines<br>\n  function exactly as I want by default, it just surprises me by <br>\n\"hiding\" the rules<br>\nI needed to proceed.</p>\n<p>Yes, I could have inspected the package's ML interface. In principle, <br>\nanyway.<br>\nI'm embarrassed that I didn't read the manual, but I'm not embarrassed<br>\nthat I didn't look at the ML level. For other Isabelle packages I've <br>\nfound the<br>\nML info available to be low-level, verbose, and prone to change with future<br>\nrevisions.</p>\n<p>The \"domintros\" mode is probably what I was looking for. Now the rules <br>\nprovided<br>\ndo actually fully characterise the function. Phew. Honestly, the form of <br>\nthese rules<br>\nis annoying though. They really require me to phrase an inductive proof, <br>\nwhereas<br>\nit feels easier to just supply a well-founded relation and a subdomain <br>\nas I did in the<br>\nexample.</p>\n<p>Thanks for the replies everyone.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 294711219,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182265
    }
]