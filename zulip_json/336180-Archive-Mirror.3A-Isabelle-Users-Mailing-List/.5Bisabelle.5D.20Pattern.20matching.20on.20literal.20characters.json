[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all and Florian in particular,</p>\n<p>While update some old Isabelle files, I noticed that fun no longer support pattern <br>\nmatching on characters. It used to work in Isabelle2016, but does not in Isabelle2016-1 <br>\nand Isabelle2017. Here is an small example:</p>\n<p>fun test :: \"char ⇒ nat\" where<br>\n   \"test (CHR ''a'') = 0\"<br>\n| \"test (CHR ''b'') = 1\"<br>\n| \"test _ = 2\"</p>\n<p>Nowadays, fun complains about non-constructor patterns. Unfortunately, the NEWS file entry <br>\n\"Characters (type char) are modelled as finite algebraic type corresponding to {0..255}.\" <br>\ndoes not say how this is supposed to be done nowadays. I can of course rewrite my <br>\nfunctions as a longish cascade of ifs, but that's not really nice and I don't get any <br>\nuseful case analysis and simplification rules. Is there a better way to do it?<br>\n(Registering Char as a free constructor does not work because Char is not injective :-(.)</p>\n<p>Moreover, the Tutorial on Function Definitions still pretends as if pattern matching was <br>\npossible (section 7.4). In the underlying theory file, I found that this is just a <br>\nmanually typeset example. So this should be adapted to whatever is the canonical way nowadays.</p>\n<p>Andreas</p>",
        "id": 294722479,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185308
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nDear Andreas,</p>\n<p>I ran into this problem as well.</p>\n<p>While I do not have a nice solution, I wrote the attached theory that<br>\ndefines a datatype legacy_char (basically a copy of the old definition of<br>\nchar), and bijections between char and legacy_char.</p>\n<p>In some cases, this may simplify migration, because one can first convert a<br>\nchar into a legacy_char and then pattern match.<br>\n(Although not using the nice syntax CHR''a''.)</p>\n<p>I am aware that this is far from an ideal solution, and in many cases might<br>\nnot help at all, but I am providing it in case someone with Andreas'<br>\nproblem finds it useful. (For example, automated methods may work better on<br>\ndatatypes.)</p>\n<p>Best wishes,<br>\nDominique.<br>\n<a href=\"/user_uploads/14278/AwGke6PYJdE9eSfIUi48xEQI/Legacy_Char.thy\">Legacy_Char.thy</a></p>",
        "id": 294722492,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185315
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<p>that indeed is unsatisfactory.  But the current situation need not be<br>\nthe final word on this.</p>\n<p>How many clauses do you have?  For a small number of clauses, the<br>\nfollowing works:</p>\n<p>The disadvantage is that you have to spell out the »otherwise« in the<br>\nlast clause explicitly, which is burdening if there are many clauses.<br>\nAlso the »otherwise« is just a formal logical completion and not<br>\nsuitable for execution.</p>\n<p>If there are many clauses, I would think about introducing an explicit<br>\ncase selector for char and registering that using free_constructors, but<br>\nI don't know yet how this will scale.</p>\n<p>Paritcularly wrt. executability, depending on your application it might<br>\nalso be feasible to constructor some kind of lookup association list<br>\nusing »zip (Enum.enum :: char list) …« or similar.</p>\n<p>What is your particular application?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/u4-b7JqJjFiA3SWoG_ns9v3H/signature.asc\">signature.asc</a></p>",
        "id": 294722506,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185321
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>I ran into this problem while porting the solution to an assignment in our Isabelle course <br>\nat ETH (analysing cryptographic messages in a Dolev-Yao intruder model). In there, there <br>\nwere always just a few cases (no more than three) that involved matching on characters. So <br>\nit's not a huge problem because I know how to rewrite them into if-then-else. <br>\nNevertheless, the definitions somewhat get redundant because I have to repeat the <br>\notherwise case several times. Moreover, the characters are not top-level arguments, but <br>\nthe nesting occurs somewhere deep down in the message terms, say</p>\n<p>...<br>\n| \"f a (Enc m (Key ''I'')) = ...\"<br>\n...<br>\n| \"f b _ = otherwise b\"</p>\n<p>i.e., the pattern match on CHR ''I'' is happens inside \"Enc _ (Key (Cons _ Nil))\". So the <br>\nsequential option to function is really an essential convenience here. Executability is <br>\nalso a key issue for us.</p>\n<p>Regarding the case combinator for char, I don't yet see how this solves the problem. We'd <br>\nhave to register a free constructor for chars and the parse translation for CHR would have <br>\nto use this constructor. Otherwise we cannot use the pattern matching. On the plus side, <br>\nthe predicate compiler should then also be able to match against chars and strings again. <br>\n(We're not using the predicate compiler for this at the moment.).</p>\n<p>Andreas</p>",
        "id": 294722566,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185326
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Andreas,</p>\n<p>to offer yet another point in the design space: I have created a type<br>\nfor bytes that is essentially an 8-tuple of bools. It's not efficient,<br>\nbut it does have the advantage that it's a free constructor \"for free\".<br>\nCombined with a parse/print translation it should satisfy all your<br>\nrequirements.</p>\n<p>In the attached theory there's some additional stuff to make the code<br>\ngenerator use bytes as implementation for chars.</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/zP1qRKdNnq8ohsNOoZehX9V2/Byte.thy\">Byte.thy</a></p>",
        "id": 294722578,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185333
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>I take this opportunity to set out some thoughts that have guarded my<br>\nwork on characters before sketching possible solutions to the pattern<br>\nmatching problem.</p>\n<p>a) Using num to represent characters dramatically simplifies any kind of<br>\n»exporting« literal expressions like characters or numerals, since there<br>\nis only one constituting »literal« type to represent them, »num«.</p>\n<p>b) Why having a different representation for characters in the regular<br>\nlogic and in code equations seems to be a bad idea.</p>\n<p>For illustration, have a look at the following example:</p>\n<p>definition max_int :: int<br>\n  where \"max_int = 32767\"</p>\n<p>definition overflow :: \"int ⇒ int option\"<br>\n  where \"overflow k = (if k &gt; max_int then None else Some k)\"</p>\n<p>code_thms overflow</p>\n<p>Here »32767« has to be represented differently to accomplish code<br>\ngeneration; but the loss of readability is bearable since numeral<br>\nliterals most times are not used directly, but as symbolic constants.</p>\n<p>Compare this with an example involving a literal string:</p>\n<p>definition overflow' :: \"int ⇒ int\"<br>\n  where \"overflow' k = (if k &gt; max_int then Code.abort (STR <code>Integer\noverflow</code>) (λ_. k) else k)\"</p>\n<p>code_thms overflow'</p>\n<p>Since string literals are likely to be used as rather arbitrary<br>\nnotification, the appear scattered over the whole code equations;<br>\nreplacing them by something without readable syntax obfuscates<br>\neverything considerably.</p>\n<p>c) What to do next?</p>\n<p>Disregarding b), there is always the possibility to re-establish a<br>\ncanonical datatype representation for char, where I have slightly more<br>\nsympathy for Lars' suggestion than the quite involved traditional nibble<br>\nconstruction.</p>\n<p>What IMHO should be thought about alternatively is to separate bytes and<br>\ncharacters, which is how programming languages deal with the fact that<br>\nin the world of unicode a particular glyph is one thing and its bit<br>\nrepresentation another.</p>\n<p>This could work along the following lines:</p>\n<ul>\n<li>\n<p>Type »char« is isomorphic to »nat«, i. e. a type representing an<br>\nunbounded set of possible glyphs.</p>\n</li>\n<li>\n<p>Type »string« remains an alias for »char list«.</p>\n</li>\n<li>\n<p>Type »char« is treated wrt. code generation more or less as now, using<br>\nexplicit conversion functions from integers if a particular code point<br>\nis not directly representable in a particular target language.</p>\n</li>\n<li>\n<p>Type »byte« is isomorphic to [0..&lt;256]; some representants have<br>\nsuggestive character syntax, e. g. »BYTE <code>A</code>«, cf. type »char« in ANSI C.</p>\n</li>\n<li>\n<p>Type »byte« is a proper datatype.</p>\n</li>\n<li>Type »byte« is not treated specifically by code generation.</li>\n<li>Some canonical conversion functions between »char« and »byte« can be<br>\nspecified, e.g. »utf8_of_char :: char =&gt; byte list« and »string_of_utf8<br>\n:: byte list =&gt; string«</li>\n</ul>\n<p>Curious for comments,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/tjId8y0gO5MTRbHAoHwyhhBH/signature.asc\">signature.asc</a></p>",
        "id": 294723056,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185517
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Lars,</p>\n<p>just a few remarks on your theory:</p>\n<ul>\n<li>»nat_of_bool«: there is already »of_bool«</li>\n<li>»n mod 2 = 1«: usually better to write »odd n«</li>\n<li>»nth_or_else«: there is already »nth_default« in More_List.thy</li>\n</ul>\n<p>Generally, I like your idea for using proper bit representations rather<br>\nthe quite ad-hoc traditional nibble auxiliary.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/HTtx5EK1KIqDUF1pmCDMdlz5/signature.asc\">signature.asc</a></p>",
        "id": 294723092,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185529
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<ul>\n<li>»nat_of_bool«: there is already »of_bool«</li>\n<li>»n mod 2 = 1«: usually better to write »odd n«</li>\n<li>»nth_or_else«: there is already »nth_default« in More_List.thy</li>\n</ul>\n</blockquote>\n<p>Thanks, that made some things easier.</p>\n<blockquote>\n<p>Generally, I like your idea for using proper bit representations rather<br>\nthe quite ad-hoc traditional nibble auxiliary.</p>\n</blockquote>\n<p>I specifically created this theory to make interop between CakeML native<br>\ncharacters and HOL characters easier. There, I have hand-written<br>\nfunctions that convert between bytes and CakeML characters.</p>\n<p>It could be potentially used for other target languages. \"byte\" can be<br>\ncode-adapted to machine bytes (e.g. \"Byte\" in Scala). This would make it<br>\nmore efficient, but still won't give us integration into target language<br>\nstrings. But at least it's correct.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294723106,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185535
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Florian,</p>\n<blockquote>\n<p>Disregarding b), there is always the possibility to re-establish a<br>\ncanonical datatype representation for char, where I have slightly more<br>\nsympathy for Lars' suggestion than the quite involved traditional nibble<br>\nconstruction.</p>\n</blockquote>\n<p>this will only work assuming everything is ASCII. Unfortunately the<br>\nsituation in the various target languages is not uniform.</p>\n<p>Haskell: \"Char\" is an opaque type representing Unicode codepoints,<br>\n\"String = [Char]\", but everybody uses \"Text\" that comes in strict and<br>\nlazy flavours</p>\n<p>Scala: \"char\" is 16 bits for what was thought to be the final say<br>\n(UCS-2), \"strings\" are allegedly sequences of these \"char\"s, but a<br>\nproper iteration over them requires taking surrogate pairs into account<br>\n(UTF-16)</p>\n<p>OCaml/SML: everything is ASCII, lol</p>\n<blockquote>\n<p>What IMHO should be thought about alternatively is to separate bytes and<br>\ncharacters, which is how programming languages deal with the fact that<br>\nin the world of unicode a particular glyph is one thing and its bit<br>\nrepresentation another.</p>\n</blockquote>\n<p>Minor nitpick: \"glyph\" → \"codepoint\"</p>\n<blockquote>\n<ul>\n<li>Type »char« is isomorphic to »nat«, i. e. a type representing an<br>\nunbounded set of possible glyphs.</li>\n</ul>\n</blockquote>\n<p>Yes. but it is still not clear how we can make pattern matching work<br>\nwith that. Hypothetically, if \"Chr\" is the morphism for \"char\", we can<br>\nregister \"Chr\" as a free constructor. Then, \"CHR ''a''\" could be a<br>\nparse-translation resulting in \"Chr 97\". But</p>\n<p>fun f :: \"nat ⇒ nat\" where<br>\n\"f 97 = 97\"</p>\n<p>is not an acceptable function definition.</p>\n<p>(Even if it were, it would probably take horribly long to be defined.)</p>\n<blockquote>\n<ul>\n<li>Type »string« remains an alias for »char list«.</li>\n</ul>\n</blockquote>\n<p>Also yes.</p>\n<blockquote>\n<ul>\n<li>Type »char« is treated wrt. code generation more or less as now, using<br>\nexplicit conversion functions from integers if a particular code point<br>\nis not directly representable in a particular target language.</li>\n</ul>\n</blockquote>\n<p>Not sure how this can be made to work sort of uniformly, but I'm open to<br>\nsuggestions.</p>\n<blockquote>\n<ul>\n<li>Type »byte« is isomorphic to [0..&lt;256]; some representants have<br>\nsuggestive character syntax, e. g. »BYTE <code>A</code>«, cf. type »char« in ANSI C.</li>\n</ul>\n</blockquote>\n<p>Are you suggesting to only allow pattern matching on bytes (0..255)<br>\ninstead of codepoints? I could live with that, and I guess others could,<br>\ntoo.</p>\n<p>Adapting \"byte\" to target languages would probably require a functrans<br>\nakin to what we have for \"nat\".</p>\n<blockquote>\n<ul>\n<li>Type »byte« is a proper datatype.</li>\n<li>Type »byte« is not treated specifically by code generation.</li>\n</ul>\n</blockquote>\n<p>Yes.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294723129,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185547
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 16/11/17 15:56, Lars Hupel wrote:</p>\n<blockquote>\n<p>Scala: \"char\" is 16 bits for what was thought to be the final say<br>\n(UCS-2), \"strings\" are allegedly sequences of these \"char\"s, but a<br>\nproper iteration over them requires taking surrogate pairs into account<br>\n(UTF-16)</p>\n</blockquote>\n<p>That is indeed very complicated. It shows the full failure of the<br>\nUnicode project over the past decades. Just a few weeks ago, I was again<br>\nstruggling with problems of performance and correctness in some corner<br>\ncases of Unicode in Isabelle/Scala.</p>\n<blockquote>\n<p>OCaml/SML: everything is ASCII, lol</p>\n</blockquote>\n<p>ASCII has actually only 7 bits, but OCaml and SML strings consist of<br>\nclean well-defined 8-bit bytes. Thus they fit nicely into the following<br>\nscheme <a href=\"http://utf8everywhere.org\">http://utf8everywhere.org</a> and turn out more modern than Java,<br>\nScala, Python etc. who attempted a bit too early to get on the wrong train.</p>\n<blockquote>\n<blockquote>\n<p>What IMHO should be thought about alternatively is to separate bytes and<br>\ncharacters, which is how programming languages deal with the fact that<br>\nin the world of unicode a particular glyph is one thing and its bit<br>\nrepresentation another.</p>\n</blockquote>\n<p>Minor nitpick: \"glyph\" → \"codepoint\"</p>\n</blockquote>\n<p>It is even more complicated. See again <a href=\"http://utf8everywhere.org\">http://utf8everywhere.org</a> for<br>\nmore details of Unicode that nobody really understands.</p>\n<p>Makarius</p>",
        "id": 294723152,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185555
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>after some personally discussions, I come up with the following sketch<br>\nhow to regain pattern matching on HOL chars while at the same time<br>\nclarifying some historical misperceptions around strings and code<br>\ngeneration.</p>\n<p>Details would have be to figured out iteratively.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/1ZnlWq3SWefNTOaWEi-9XM3p/signature.asc\">signature.asc</a></p>",
        "id": 294723413,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185628
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>Your agenda looks good, but I would like to point out one further usage requirement for <br>\nstrings:</p>\n<p>Strings are used to exchange data between generated and hand-written code. At the moment, <br>\nthe functions String.implode and String.explode provide this interface between char list <br>\nand String.literal. IMO we should provide such an interface after the refactoring, too. <br>\nThis does not have to be between char list and String.literal; some other element type for <br>\ntarget-language strings (brand: type character, akin to integer and natural) should do as <br>\nwell.</p>\n<p>Andreas</p>",
        "id": 294723443,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185640
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>I take the opportunity to post two patches (applicable on isabelle<br>\nb5e29bf0aeab and efd58f8b1659) containing a refinement of string-like<br>\ntypes as sketched in this mail thread.</p>\n<p>There are still some AFP sessions to be sorted out, but the way to go<br>\nhas become reasonable clear.  Quoth NEWS:</p>\n<p>* Type \"char\" is now a proper datatype of 8-bit values.</p>\n<p>* Conversions \"nat_of_char\" and \"char_of_nat\" are gone; use more<br>\n    general conversions \"of_char\" and \"char_of\" with suitable<br>\n    type constraints instead.</p>\n<p>* The zero character is just written \"CHR 0x00\", not<br>\n    \"0\" any longer.</p>\n<p>* Type \"String.literal\" (for code generation) is now isomorphic<br>\n    to lists of 7-bit (ASCII) values; concrete values can be written<br>\n    as \"STR ''...''\" for sequences of printable characters and<br>\n    \"ASCII 0x...\" for one single ASCII code point given<br>\n    as hexadecimal numeral.</p>\n<p>* Type \"String.literal\" supports concatenation \"... + ...\"<br>\n    for all standard target languages.</p>\n<p>* Theory Library/Code_Char is gone; study the explanations concerning<br>\n    \"String.literal\" in the tutorial on code generation to get an idea<br>\n    how target-language string literals can be converted to HOL string<br>\n    values and vice versa.</p>\n<p>* Imperative-HOL: operation \"raise\" directly takes a value of type<br>\n    \"String.literal\" as argument, not type \"string\".</p>\n<p>When open ends are finally ironed out, there remain still some minor<br>\nquestions:</p>\n<ul>\n<li>\n<p>Renaming of type \"char\" to \"byte\", to make its semantics clear once<br>\nand forall.</p>\n</li>\n<li>\n<p>Avoid the ASCII marker for literals – use \"STR\" uniformly.</p>\n</li>\n<li>\n<p>Revisit the Syntax for literals more deeply.  The \"STR\" is traditional<br>\nbut need not be the last word on that topic.  Suggestions welcome.</p>\n</li>\n</ul>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/DhFnETs7YwSP1FsEjLOz51q5/char_8_bitchar\">char_8_bit@char</a><br>\n<a href=\"/user_uploads/14278/bmpE2XACz0gQgigtscmti02a/char_8_bitchar\">char_8_bit@char</a><br>\n<a href=\"/user_uploads/14278/49Apv_fNZdZBbV0Nd3ID_Uea/signature.asc\">signature.asc</a></p>",
        "id": 294730966,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188031
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Florian,</p>\n<p>Thanks for moving this forward. Could you please name all the lemmas that you declare as <br>\n[transfer_rule]? Without the name, it becomes much harder to remove them later in case <br>\nthey confuse the transfer prover in applications. (I haven't tried your rules yet; it's <br>\njust my experience that there may easily be unexpected interactions between rules.)</p>\n<p>As for the AFP entry Native_Word, I am puzzled that deleted the conversions between char <br>\nand uint8. Do you plan to unify the two types uint8 and char?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294731002,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188045
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nSee now 1f9f973eed2a including follow-ups ad4b8b6892c3 and 27ba50c79328<br>\nfor the current matter of affairs.</p>\n<p>I am still considering two further refinements:</p>\n<p>a) Renaming of type \"char\" to \"byte\", to make its semantics clear once<br>\nand forall.</p>\n<p>b) The \"STR\" syntax for values of type String.literal has a certain<br>\ntradition but is not very suggestive.</p>\n<p>At the moment I am inclined to pursue a) further but I am open for comments.</p>\n<p>Concerning b), I have no better idea at hand and would put that aside.<br>\nBut maybe there are innovative ideas around (cartouches instead of<br>\n''…''?) that would allow to reconsider that question.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/rHCVeP_UFckNdc6Xi1pE9J0x/signature.asc\">signature.asc</a></p>",
        "id": 294731090,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188082
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>Thanks for moving this forward. Could you please name all the lemmas&gt; that you declare as [transfer_rule]? Without the name, it becomes<br>\nmuch&gt; harder to remove them later in case they confuse the transfer<br>\nprover in&gt; applications. (I haven't tried your rules yet; it's just my<br>\nexperience&gt; that there may easily be unexpected interactions between rules.)</p>\n</blockquote>\n<p>I am happy to name them but so far this has never been done for the<br>\ntransfer rules e. g. on integer.  They are not used by default<br>\n(lifting_update / lifting_forget) – is there really a need to address<br>\nthem as single theorems by name?  (This is an open question to me)</p>\n<blockquote>\n<p>As for the AFP entry Native_Word, I am puzzled that deleted the&gt; conversions between char and uint8. Do you plan to unify the two<br>\ntypes&gt; uint8 and char?</p>\n</blockquote>\n<p>By its very nature the HOL char type by itself has no guaranteed<br>\nconnection to possibly existing char types in target languages.<br>\nExplicit conversions to target-language types can be done e.g. using<br>\nchar_of and of_char with suitable constraints or intermediate conversions.</p>\n<p>It would still be an option to map char to e.g. Word8.word in SML<br>\ndirectly in Native_Word, but it seems to be a better idea to have a<br>\nparticular target-language-specific mapping from the very beginning –<br>\nand not to optionally add it later on.  This tradition has emerged with<br>\nthe integer type (in contrast to int) and is now pervasive.</p>\n<p>Am I missing something?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Yno52ZAjV6QqHHynrk4e-gUo/signature.asc\">signature.asc</a></p>",
        "id": 294731134,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188088
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nConcerning type string (not String.literal) I am still hoping that we<br>\nmay eventually replace the double-single quotes ''...'' by normal double<br>\nquotes \"...\", and thus make it less surprising for the world out there.</p>\n<p>De-facto, this requires to use cartouches to embed inner syntax within<br>\nouter syntax by default, instead of old-fashioned double quotes. A<br>\nsystematic conversion for existing sources requires batch-builds with a<br>\nPIDE markup database, to know precisely where inner syntax items need to<br>\nbe replaced. This is not available yet, but we are close to have that soon.</p>\n<p>Another reason why only a very small elite has adopted cartouches for<br>\ninner syntax quotation so far: the notation in LaTeX looks a bit odd,<br>\nbecause \\&lt;open&gt; and \\&lt;close&gt; are not really French single-quotes, but<br>\nangle brackets with adhoc manipulation of the size. Maybe anybody has a<br>\nbetter idea to get the \"guillemets simples\" right in LaTeX.</p>\n<p>This is all for type string, but there might be reasons to treat<br>\nString.literal the same way, or reasons not to treat it the same.</p>\n<p>A cartouche without additional marker is always somewhat special: it is<br>\nthe \"one shot for free\" principle for nested sub-languages. E.g. in<br>\nIsabelle/ML a plain cartouche is a literal for uninterpreted<br>\nInput.source, and in the document language for uninterpreted formal text.</p>\n<p>My feeling is that type String.literal is too exotic for the prominent<br>\nnotation of cartouche without marker. Or maybe, type string could use<br>\ndouble quotes and type String.literal double single quotes, now without<br>\nmarker.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/XkkYaIFof3KE1p3OZYII33Qt/signature.asc\">signature.asc</a></p>",
        "id": 294731146,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188094
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi Florian,</p>\n<blockquote>\n<blockquote>\n<p>Thanks for moving this forward. Could you please name all the lemmas&gt; that you declare <br>\nas [transfer_rule]? Without the name, it becomes<br>\nmuch&gt; harder to remove them later in case they confuse the transfer<br>\nprover in&gt; applications. (I haven't tried your rules yet; it's just my<br>\nexperience&gt; that there may easily be unexpected interactions between rules.)</p>\n</blockquote>\n<p>I am happy to name them but so far this has never been done for the<br>\ntransfer rules e. g. on integer.  They are not used by default<br>\n(lifting_update / lifting_forget) – is there really a need to address<br>\nthem as single theorems by name?  (This is an open question to me)</p>\n</blockquote>\n<p>OK, I overlooked the lifting_forget part. In that case, it is indeed less likely that <br>\ntransfer gets confused about them. But it is nevertheless good practice to name all lemmas <br>\nthat end up in some list of theorems. The style guides for the AFP, e.g., demand that:</p>\n<p>Only named lemmas should carry attributes such as [simp].<br>\n<a href=\"https://www.isa-afp.org/submitting.html\">https://www.isa-afp.org/submitting.html</a></p>\n<p>At least when I simulate transfer for debugging or manually write a transfer proof, it is <br>\na pain to do so if I have to extract those unnamed rules from transfer_raw with an index.</p>\n<p>Thanks for the explanation. So the type char (soon to be called byte) could be the logical <br>\ntype of bytes that an implementation theory akin to Code_Target_Int links to an <br>\nimplementation type of bytes like uint8. That sounds like a good plan.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294731163,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188100
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear list,</p>\n<p>after an explorative try this seems out of scope for me: there are too<br>\nmany references to the well-established name »char« to make that<br>\neconomically feasible.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/8b3JCWTHJi610tzCRllfTUNh/signature.asc\">signature.asc</a></p>",
        "id": 294732578,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188616
    }
]