[
    {
        "content": "<p>From: Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;<br>\nHi all,</p>\n<p>I am trying to define a randomized algorithm in order to prove it is correct. On this purpose, I defined following objects:</p>\n<p>\"bernoulli p ≡ point_measure (UNIV :: bool set) (% True =&gt; p | False =&gt; 1 - p)\"</p>\n<p>interpretation rs:product_prob_space \"(λi. bernoulli p)\" \"UNIV::(nat × Proc) set\" for p<br>\nproof  (unfold_locales, auto)<br>\n have \"(UNIV :: bool set) = { True, False }\" by auto<br>\n thus \"emeasure (bernoulli p) (space (bernoulli p)) = ∞ ⟹ False\"<br>\n using emeasure_point_measure_finite finite_UNIV<br>\n proof (unfold bernoulli_def, blast) qed<br>\n...</p>\n<p>Proof goes fine (just ends with \"no subgoals\") but at \"qed\" I obtain the following error:</p>\n<p>Pending sort hypotheses:<br>\n{finite,perfect_space,real_normed_vector} </p>\n<p>Does anyone have any idea on how to solve this issue ?</p>\n<p>Thanks in advance,<br>\nHenri.</p>",
        "id": 294163019,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853861
    },
    {
        "content": "<p>From: Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;<br>\nThanks a lot for your help, Makarius.</p>\n<p>Unfolding the definition...Hum, I feel a little silly here...</p>\n<p>Your solution works...partially. That is, it solves the sort_contraint goal. However, when closing the proof block, here is the error I get :</p>\n<p>exception TERM raised (line 137 of \"more_thm.ML\"):<br>\ndest_equals<br>\nSORT_CONSTRAINT(?'a∷{finite,perfect_space,real_normed_vector}) </p>\n<p>any idea ?</p>\n<p>H.</p>",
        "id": 294165351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854542
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Donnerstag, den 28.06.2012, 12:40 +0200 schrieb Henri DEBRAT:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I am trying to define a randomized algorithm in order to prove it is correct. On this purpose, I defined following objects:</p>\n<p>\"bernoulli p ≡ point_measure (UNIV :: bool set) (% True =&gt; p | False =&gt; 1 - p)\"</p>\n<p>interpretation rs:product_prob_space \"(λi. bernoulli p)\" \"UNIV::(nat × Proc) set\" for p<br>\nproof  (unfold_locales, auto)<br>\n have \"(UNIV :: bool set) = { True, False }\" by auto<br>\n thus \"emeasure (bernoulli p) (space (bernoulli p)) = ∞ ⟹ False\"<br>\n using emeasure_point_measure_finite finite_UNIV<br>\n proof (unfold bernoulli_def, blast) qed<br>\n...</p>\n<p>Proof goes fine (just ends with \"no subgoals\") but at \"qed\" I obtain the following error:</p>\n<p>Pending sort hypotheses:<br>\n{finite,perfect_space,real_normed_vector} </p>\n</blockquote>\n<p>Huh, where does this come from? There should be no additional sort<br>\nconstraint.</p>\n<blockquote>\n<p>Does anyone have any idea on how to solve this issue ?</p>\n</blockquote>\n<p>The interpretation as you try it will unfortunately not work. You need<br>\nto clamp the probability p between 0 and 1:</p>\n<p>definition clamp :: \"real ⇒ real\" where \"clamp p = min 0 (max 1 p)\"</p>\n<p>definition<br>\n\"bernoulli p ≡ point_measure (UNIV :: bool set) (% True =&gt; ereal (clamp p) | False =&gt; 1 - ereal (clamp p))\"</p>\n<p>Important note: If p is a real the following proofs are much simpler!</p>\n<p>The next is: For product_prob_space you just need to show that<br>\n\"bernoulli p\" is a probabilty space. This does work directly with<br>\nunfold_locales, but with prob_spaceI which is a default rule. This is a<br>\nlittle ugly but saves a couple of sublocales in the probability theory.</p>\n<p>interpretation rs: product_prob_space \"(λi. bernoulli p)\" \"UNIV::(nat × nat) set\" for p :: real<br>\nproof -<br>\n  have \"emeasure (bernoulli p) (space (bernoulli p)) = <br>\n    (∑i∈UNIV. case i of True =&gt; clamp p | False =&gt; 1 - clamp p)\"<br>\n    by (simp add: bernoulli_def space_point_measure emeasure_point_measure_finite<br>\n                  clamp_def max_def min_def split: bool.split)<br>\n  also have \"… = 1\"<br>\n    by (simp add: UNIV_bool one_ereal_def)<br>\n  finally interpret prob_space \"bernoulli p\"<br>\n    by rule  -- {* Here prob_spaceI is applied *}<br>\n  show \"product_prob_space (λi. bernoulli p)\" <br>\n    .. -- {* This is also unfold_locales, but this time the interpret from above is used *}<br>\nqed</p>\n<p>Maybe even better is:</p>\n<p>interpretation bernoulli: \"bernoulli p\" for p :: real<br>\nproof -<br>\n  have \"emeasure (bernoulli p) (space (bernoulli p)) = <br>\n    (∑i∈UNIV. case i of True =&gt; clamp p | False =&gt; 1 - clamp p)\"<br>\n    by (simp add: bernoulli_def space_point_measure emeasure_point_measure_finite<br>\n                  clamp_def max_def min_def split: bool.split)<br>\n  also have \"… = 1\"<br>\n    by (simp add: UNIV_bool one_ereal_def)<br>\n  finally show \"prob_space (bernoulli p)\"<br>\n    by rule  -- {* Here prob_spaceI is applied *}<br>\nqed</p>\n<p>interpretation rs: product_prob_space \"(λi. bernoulli p)\" \"UNIV::(nat × nat) set\" for p :: real ..</p>\n<blockquote>\n<p>Thanks in advance,<br>\nHenri.</p>\n</blockquote>",
        "id": 294165501,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854609
    },
    {
        "content": "<p>From: Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;<br>\nThanks a lot, Johannes.  The code you provide me with does work, thanks a lot.<br>\nYou are right, I had some axiomatic constraints on p so that it is in ] 0 ; 1[ I just forgot to say it.</p>\n<p>Yet, some great mystery lies here concerning sort_constraint and the exception it raises.<br>\nIn case it might be an interesting issue to solve, I copy here two piece of code.<br>\nThey look pretty similar, however, the first goes fine while the second raise the famous sort_constraint error.</p>\n<p>typedecl Proc<br>\narities Proc :: finite</p>\n<p>axiomatization<br>\n bp::real<br>\nwhere<br>\n bpdef:\"bp &gt; 0 ∧ bp &lt; 1\"</p>\n<p>definition<br>\n\"bernoulli ≡ point_measure (UNIV :: bool set) (% True =&gt; ereal bp | False =&gt; 1 - ereal bp)\"</p>\n<p>**** CODE WHICH FAILS AT THE LAST \"QED\" (sort_constraint error):</p>\n<p>interpretation rs:product_prob_space \"(λi::nat × Proc. bernoulli)\" \"UNIV::(nat × Proc) set\"<br>\nwhere \"SORT_CONSTRAINT('a::{finite,perfect_space,real_normed_vector} )\"<br>\nproof(unfold_locales, auto)<br>\n  have \"UNIV = { True, False }\" by auto<br>\n  thus \"emeasure bernoulli (space bernoulli) = 1\"<br>\n  using space_point_measure finite_UNIV<br>\n    by (blast dest:emeasure_point_measure_finite)<br>\nnext<br>\n  have \"UNIV = { True, False }\" by auto<br>\n  thus \"emeasure bernoulli (space bernoulli) = ∞ ⟹ False\"<br>\n  using finite_UNIV space_point_measure <br>\n  by (blast dest:emeasure_point_measure_finite)<br>\nnext<br>\n  have \"UNIV = { True, False }\" by auto<br>\n moreover<br>\n  obtain A where \"A = (λi::nat. if i = 0 then space bernoulli else {})\" by auto<br>\n  hence \"range A ⊆ sets bernoulli\" and \"(⋃x::nat. A x) = space bernoulli\"<br>\n  by auto<br>\n ultimately<br>\n  show \"∃A. range A ⊆ sets bernoulli ∧ (⋃x::nat. A x)<br>\n    = space bernoulli ∧ (∀i. emeasure bernoulli (A i) ≠ ∞)\"<br>\n  using finite_UNIV<br>\n  by (blast dest:emeasure_point_measure_finite)<br>\nqed</p>\n<p>*** CODE WHICH ENDS FINE (thanks to Johannes) :</p>\n<p>interpretation rs:product_prob_space \"(λi. bernoulli)\" \"UNIV::(nat × Proc) set\"<br>\nproof(unfold_locales, auto)<br>\n from bpdef show \"emeasure bernoulli (space bernoulli) = 1\"<br>\n   by (auto simp: UNIV_bool one_ereal_def bernoulli_def<br>\n  space_point_measure emeasure_point_measure_finite split: bool.split)<br>\nnext<br>\n  from bpdef show \"emeasure bernoulli (space bernoulli) = ∞ ⟹ False\"<br>\n   by (auto simp: UNIV_bool one_ereal_def bernoulli_def<br>\n  space_point_measure emeasure_point_measure_finite split: bool.split)<br>\nnext<br>\n  obtain A where Adef:\"A = (λi::nat. if i = 0 then space bernoulli else {})\" by auto<br>\n  hence \"range A ⊆ sets bernoulli\" and \"(⋃x::nat. A x) = space bernoulli\"<br>\n  by auto<br>\n moreover<br>\n  from Adef bpdef have \"∀i. emeasure bernoulli (A i) ≠ ∞\"<br>\n   by(auto simp: UNIV_bool one_ereal_def bernoulli_def<br>\n  space_point_measure emeasure_point_measure_finite split: bool.split)<br>\n ultimately<br>\n  show \"∃A. range A ⊆ sets bernoulli ∧ (⋃x::nat. A x)<br>\n    = space bernoulli ∧ (∀i. emeasure bernoulli (A i) ≠ ∞)\"<br>\n  by auto<br>\nqed</p>\n<p>I hope this might be useful.</p>\n<p>H.</p>",
        "id": 294216987,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895431
    },
    {
        "content": "<p>From: Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;<br>\nOh, I forgot to say that if i start the first proof with  \"proof (unfold_locales, auto simp:sort_constraint_def)\", as suggested by Makarius, the exception still raises :</p>\n<p>exception TERM raised (line 137 of \"more_thm.ML\"):<br>\ndest_equals<br>\nSORT_CONSTRAINT<br>\n(?'a∷{finite,perfect_space,real_normed_vector}) </p>\n<p>H.</p>",
        "id": 294217116,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895505
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 03.07.2012 18:53, Henri DEBRAT wrote:</p>\n<blockquote>\n<p>Yet, some great mystery lies here concerning sort_constraint and the exception it raises.<br>\nIn case it might be an interesting issue to solve, I copy here two piece of code.</p>\n</blockquote>\n<p>The first proof does not go through for me (Isabelle 2012) -- the proof <br>\nof obtains in the 3rd block fails and there is some remaining goal.</p>\n<blockquote>\n<p>definition<br>\n\"bernoulli ≡ point_measure (UNIV :: bool set) (% True =&gt;  ereal bp | False =&gt;  1 - ereal bp)\"<br>\n[...]<br>\ninterpretation rs:product_prob_space \"(λi::nat × Proc. bernoulli)\" \"UNIV::(nat × Proc) set\"<br>\nwhere \"SORT_CONSTRAINT('a::{finite,perfect_space,real_normed_vector} )\"<br>\nproof(unfold_locales, auto)<br>\n   have \"UNIV = { True, False }\" by auto<br>\n   thus \"emeasure bernoulli (space bernoulli) = 1\"<br>\n   using space_point_measure finite_UNIV<br>\n     by (blast dest:emeasure_point_measure_finite)</p>\n</blockquote>\n<p>This looks already a bit suspicious -- you proof something about <br>\nbernoulli without ever using its definition (definitions are not <br>\nunfolded automatically). Indeed it turns out, that you can prove False here:</p>\n<p>interpretation rs:product_prob_space \"(λi::nat × Proc. bernoulli)\" <br>\n\"UNIV::(nat × Proc) set\"<br>\nwhere \"SORT_CONSTRAINT('a::{finite,perfect_space,real_normed_vector} )\"<br>\nproof(unfold_locales, auto)<br>\n   have A: \"UNIV = { True, False }\" by auto<br>\n   then have False using finite_UNIV<br>\n     by (blast dest:emeasure_point_measure_finite)</p>\n<p>This means, you assumptions are inconsistent. The SORT_CONSTRAINT you <br>\ngave adds the assumption, that there exists a type, which is finite, a <br>\nperfect_space, and a real_normed_vector. I guess such a type does not <br>\nexist -- maybe somebody more familiar with this field can confirm this?</p>\n<p>These sort constraints are necessary to keep the system consistent, when <br>\ntype variables vanish from a term: If you have a type class c with <br>\ninconsistent assumptions, then you can easily derive False from it. But <br>\nthe term False does not contain references to c anymore. Hence, Isabelle <br>\nattaches the additional sort constraint \"c\" to this theorem. This <br>\nbasically encodes \"If the type class c is not empty, then this theorem <br>\nholds\". If there is already an instance of this class, the additional <br>\nsort constraint is automatically discharged.</p>\n<p>So, in your case, somehow blast is able to find a proof which basically <br>\nruns into above situation -- i.e., it is not really a proof.</p>\n<p>-- Lars</p>",
        "id": 294217645,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895775
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nreal_normed_vector includes open_dist, which together with finite<br>\nforces it to be a discrete topology, i.e. \"!!x. open {x}\".<br>\nThe opposite of a perfect space \"!!x. ~ open {x}\". </p>\n<p>However, I have now idea how blast can deduce False by itself. I don't<br>\nthink there is any theorem in the library which relates finite with<br>\ntopology.</p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294217770,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895842
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nI had now a look in the proof terms. One can see, that this proof uses <br>\nin particular the following three theorems:</p>\n<p>not_bounded_univ:<br>\n   \"¬bounded (UNIV :: ('a :: {perfect_space,real_normed_vector})  set)\"</p>\n<p>finite_imp_bounded:<br>\n   \"finite (S :: ('a :: metric_space) set) ⟹ bounded S\"</p>\n<p>finite_UNIV:<br>\n   \"finite (UNIV :: ('a :: finite) set)\"</p>\n<p>If there existed a type 'a satisfying these four sorts, we could prove <br>\nfalse (a real_normed_vector is in particular a metric space, so we only <br>\nneed to mention three sorts explicitly):</p>\n<p>lemma Y:<br>\n   assumes S: <br>\n\"SORT_CONSTRAINT('a::{finite,perfect_space,real_normed_vector})\"<br>\n   shows False<br>\nproof -<br>\n   from finite_UNIV have \"bounded (UNIV :: 'a set)\"<br>\n     by (rule finite_imp_bounded)<br>\n   moreover have \"¬bounded (UNIV :: 'a set)\"<br>\n     by (rule not_bounded_UNIV)<br>\n   ultimately show False by metis<br>\nqed</p>\n<p>So, blast did not really find a proof for you, it just gave you an error <br>\nmessage which might lead you into thinking it found a proof.</p>\n<p>-- Lars</p>",
        "id": 294218201,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896045
    },
    {
        "content": "<p>From: <a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a><br>\nHi,</p>\n<p>Thanks a lot for all your previous explanations.</p>\n<p>Now, let's try some really dummy test.</p>\n<p>lemma  univbool_a: \"UNIV = { True, False }\" by auto</p>\n<p>(* this is nothing but the standard UNIV_bool theorem *)<br>\nlemma  univbool_b: \"UNIV = { False, True }\" by auto</p>\n<p>lemma test_a: \"False\" using univbool_a  finite_UNIV<br>\n   by (blast dest:emeasure_point_measure_finite)</p>\n<p>lemma test_b: \"False\" using univbool_b  finite_UNIV<br>\n   by (blast dest:emeasure_point_measure_finite)</p>\n<p>The proof of test_a ends with the usual sort_contraint error, while test_b just makes the CPU go mad. I just cannot understand what is happening here !<br>\nH.</p>",
        "id": 294218335,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896113
    },
    {
        "content": "<p>From: <a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a><br>\nHi all,</p>\n<p>Ok, I solved my problem all by myself :-)</p>\n<p>Just in case it might be useful to someone, here is the solution:</p>\n<p>interpretation rs:product_prob_space \"(λi. bernoulli bp)\" \"UNIV::(nat × Proc) set\"<br>\nwhere \"SORT_CONSTRAINT('a::{finite,perfect_space,real_normed_vector} )\"<br>\nproof [...]</p>\n<p>H</p>",
        "id": 294218805,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896333
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI am impressed.  How did you figure that out?</p>\n<p>The pro-forma proposition \"SORT_CONSTRAINT('a::sort)\" is indeed the way to <br>\nhelp out in situations where certain sort occurrences in a proof need to <br>\nbe specified statically in the result, to avoid the \"Pending sort <br>\nhypotheses\" problem.</p>\n<p>This vacous proposition is later stripped away in the HHF normalization of <br>\nIsabelle rule statements.  So it does its job of introducing sorts <br>\nformally, without changing the result.  It occurs in are situations as <br>\n'assumes' in the standard collection of Isabelle applications shipped with <br>\nthe release.</p>\n<p>Makarius</p>",
        "id": 294219195,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896535
    },
    {
        "content": "<p>From: Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;<br>\nHi,</p>\n<p>Well, I used the grep command to discover the word \"sort\" in the Isabelle directory : doing this, I discovered some lemmas had \"assumes SORT_CONSTRAINT\" in their header.<br>\nThen I have seen in the old isar-ref.pdf file that interpretation could take an optional \"where\" clause...and I tried to mix up the whole thing ! Kind of a dirty method, I admit.</p>\n<p>Anyway, that is not so magic. It does not fully solve my issue: in the end, I discovered that a new goal had appeared in the \"proof\" block of the interpretation command. And guess what, this new goal is:</p>\n<p>\"SORT_CONSTRAINT('a::{finite,perfect_space,real_normed_vector} )\"</p>\n<p>So I am blocked again, even thought I could put an end to all other goals, which is already a little step forward.</p>\n<p>By the way, I do not know what  \"HHF normalization\" stands for so I do not really understand what's happening here.</p>\n<p>Thanks a lot for your help !<br>\nH.</p>",
        "id": 294219325,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896603
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOK, I was half suspecting that, but did not try your example. This is how <br>\nyou can establish these vacuous propositions as conclusions:</p>\n<p>lemma \"SORT_CONSTRAINT('a::ord)\" unfolding sort_constraint_def .<br>\nlemma \"SORT_CONSTRAINT('a::ord)\" by (rule sort_constraintI)</p>\n<p>The first form works, because it reveals the definition of this trick in <br>\nterms of TERM/TYPE wrappers in Isabelle/Pure: a TERM proposition is always <br>\nimplicitly provable via \".\", ie. \"by this\".</p>\n<p>The second is the more explicit direct introduction.  I am considering to <br>\nmake this a default intro in Pure, so that one could write \"..\" instead <br>\nnext time.</p>\n<p>Makarius</p>",
        "id": 294219457,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896670
    }
]