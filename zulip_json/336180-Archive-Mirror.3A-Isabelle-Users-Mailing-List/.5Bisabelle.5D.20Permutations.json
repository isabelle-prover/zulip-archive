[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nOn 06/23/2016 12:24 PM, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>Am 23.06.2016 um 10:02 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>It is not clear to me at all how these things can be unified. The<br>\nnotions of permutations as ‘all lists with elements of a given<br>\nset/multiset/list’ and permutations as ‘a bijection from a finite sets<br>\nto itself’ are clearly related, but how can this relation be formalised<br>\nin the best way?</p>\n</blockquote>\n<p>what I have in mind is a clarification of terminology here: permutations<br>\nas functions and list permutations should be introduced in separate<br>\ntheories, where I guess that multisets as quotient type of permutated<br>\nlists can absorb a lot of the latter.</p>\n<p>If an application needs this relation, it can still formalize it.  I did<br>\nnot see any example for that in the theories.</p>\n<p>Am 23.06.2016 um 10:02 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>After dabbling with permutations a bit, I think that one may even want<br>\nto have a type of permutations, implemented with Mappings by default.</p>\n</blockquote>\n<p>Am 23.06.2016 um 11:01 schrieb Johannes Hölzl:</p>\n<blockquote>\n<p>The type \"'a bij\" would be nice.</p>\n</blockquote>\n<p>Note that a bijection is not necessarily a permutation: in a<br>\npermutation, each element a has a finite order, ie. some n &gt; 0 such that<br>\n(f ^^ n) a = a.</p>\n<p>Am 23.06.2016 um 12:01 schrieb Christian Sternagel:</p>\n<blockquote>\n<p>And in IsaFoR in</p>\n<p><a href=\"http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy\">http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy</a></p>\n<p>definition perms :: \"('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nwhere<br>\n  \"perms = {f. bij f \\&lt;and&gt; finite {x. f x \\&lt;noteq&gt; x}}\"</p>\n<p>typedef 'a perm = \"perms :: ('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nby standard (auto simp: perms_def)</p>\n<p>where permutations have a type parameter and thus we have local-based<br>\napplication of permutations instead of type-class-based (but otherwise I<br>\ngot everything from the Nominal2 development, thanks).</p>\n</blockquote>\n<p>I don't quite understand the last paragraph.  Which type-class are you<br>\nreferring to?</p>\n</blockquote>\n<p>I was referring to Nominal(2) and the type-class of \"permutation-types\"<br>\n(i.e., types whose inhabitants allow application of permutations). So<br>\nthis is not strictly about permutations but just about a specific<br>\napplication of them.</p>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<p>Cheers,<br>\n  Florian</p>\n<blockquote>\n<p>In any case, any kind of change here will probably lead to a lot of<br>\nadjustments in every work that uses permutations. This reform will not<br>\nbe an easy task.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n</blockquote>\n<p>On 23/06/16 09:47, Florian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi all,</p>\n<p>recently I did a full text search concerning permutations and I found<br>\nthat the existing material is quite dispersed.</p>\n<blockquote>\n<ul>\n<li>Predicates for permutations (functions)<br>\n    * Library/Permutations.thy<br>\n        * Permutations.permutation :: \"('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.permutes :: \"('a ⇒ 'a) ⇒ 'a set ⇒ bool\"</li>\n<li>Representation as swaps<br>\n    * Library/Permutations.thy<br>\n        * Permutations.swapidseq :: \"nat ⇒ ('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.evenperm :: \"('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.sign :: \"('a ⇒ 'a) ⇒ int\"<br>\n    * Planarity_Certificates/Planarity/Permutations_2.thy<br>\n        * Permutations_2.funswapid :: \"'a ⇒ 'a ⇒ 'a ⇒ 'a\"<br>\n        * Permutations_2.perm_swap :: \"'a ⇒ 'a ⇒ ('a ⇒ 'a) ⇒ 'a ⇒ 'a\"<br>\n        * Permutations_2.perm_rem :: \"'a ⇒ ('a ⇒ 'a) ⇒ 'a ⇒ 'a\"<br>\n    * Jordan_Normal_Form/Missing_Permutations.thy<br>\n        * Missing_Permutations.signof :: \"(nat ⇒ nat) ⇒ 'a\"</li>\n<li>Representation as cycles<br>\n    * Planarity_Certificates/Planarity/Executable_Permutations.thy</li>\n<li>Permuting lists<br>\n    * Library/Permutations.thy<br>\n        * Permutations.permute_list :: \"(nat ⇒ nat) ⇒ 'a list ⇒ 'a list\"<br>\n    * Library/Permutation.thy<br>\n        * Permutation.perm :: \"'a list ⇒ 'a list ⇒ bool\"<br>\n            * btw that equivalence relation would be expressed better<br>\nas »mset xs = mset ys« anyway</li>\n<li>Derangements<br>\n    * Derangements/Derangements.thy<br>\n        * Derangements.derangements :: \"nat set ⇒ (nat ⇒ nat) set\"<br>\n        * Derangements.count_derangements :: \"nat ⇒ nat\"</li>\n<li>Representation as association lists<br>\n    * Library/Permutations.thy<br>\n        * Permutations.list_permutes :: \"('a × 'a) list ⇒ 'a set ⇒ bool\"<br>\n        * Permutations.permutation_of_list :: \"('a × 'a) list ⇒ 'a ⇒ 'a\"<br>\n        * Permutations.inverse_permutation_of_list ::  \"('a × 'a)<br>\nlist ⇒ 'a ⇒ 'a\"</li>\n<li>Various theorems<br>\n    * Jordan_Normal_Form/Missing_Permutations.thy<br>\n    * Completeness/PermutationLemmas.thy</li>\n</ul>\n</blockquote>\n<p>In the mid-run there is clearly room for improvement here. I would<br>\nsuggest one theory Library/Permutation.thy which introduces the basics<br>\n(predicates, swaps, cycles) consistently with all available<br>\ncorresponding theorems. The more specialized things (association lists<br>\netc) could go to separate theories. But this rough sketch has still time<br>\nfor consideration.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p>(For the curious, I stumbled over that issue as follows: first, I<br>\ninspected the sources for occurrences of »no_notation« since these are<br>\npossible candidates to user syntax bundles; one of these has been the<br>\ninfix syntax »_ choose _« for binomial coefficients, which lead me to<br>\nreconsider other combinatorial coefficients (Stirling numbers) as well;<br>\nhence the interest in permutations.)</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/dvulPyC2YWYJfZaLaZq3KSiz/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294675625,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174857
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>Am 23.06.2016 um 10:02 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>After dabbling with permutations a bit, I think that one may even want<br>\nto have a type of permutations, implemented with Mappings by default.</p>\n</blockquote>\n<p>Am 23.06.2016 um 11:01 schrieb Johannes Hölzl:</p>\n<blockquote>\n<p>The type \"'a bij\" would be nice.</p>\n</blockquote>\n<p>Note that a bijection is not necessarily a permutation: in a<br>\npermutation, each element a has a finite order, ie. some n &gt; 0 such that<br>\n(f ^^ n) a = a.</p>\n<p>Am 23.06.2016 um 12:01 schrieb Christian Sternagel:</p>\n<blockquote>\n<p>And in IsaFoR in</p>\n<p><a href=\"http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy\">http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy</a></p>\n<p>definition perms :: \"('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nwhere<br>\n  \"perms = {f. bij f \\&lt;and&gt; finite {x. f x \\&lt;noteq&gt; x}}\"</p>\n<p>typedef 'a perm = \"perms :: ('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nby standard (auto simp: perms_def)</p>\n<p>where permutations have a type parameter and thus we have local-based<br>\napplication of permutations instead of type-class-based (but otherwise I<br>\ngot everything from the Nominal2 development, thanks).</p>\n</blockquote>\n<p>I don't quite understand the last paragraph.  Which type-class are you<br>\nreferring to?</p>\n</blockquote>\n<p>I was referring to Nominal(2) and the type-class of \"permutation-types\"<br>\n(i.e., types whose inhabitants allow application of permutations). So<br>\nthis is not strictly about permutations but just about a specific<br>\napplication of them.</p>\n</blockquote>\n<p>I see.</p>\n<p>My conclusion is that an abstract type of permutations</p>\n<p>Abs_perm :: ('a =&gt; 'a) =&gt; 'a perm<br>\n    apply :: 'a perm =&gt; 'a =&gt; 'a<br>\n    affected :: 'a perm =&gt; 'a set<br>\n      where \"a in affected p &lt;--&gt; apply p a != a\"</p>\n<p>makes really sense.  E.g. it is easy to define the order of an element:</p>\n<p>order :: 'a perm =&gt; 'a =&gt; nat<br>\n    order p a =<br>\n          Min {0 &lt; n &lt;= Suc (card (affected p)). (f ^^ n) a = a}</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<blockquote>\n<p>Cheers,<br>\n Florian</p>\n<blockquote>\n<p>In any case, any kind of change here will probably lead to a lot of<br>\nadjustments in every work that uses permutations. This reform will not<br>\nbe an easy task.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n</blockquote>\n<p>On 23/06/16 09:47, Florian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi all,</p>\n<p>recently I did a full text search concerning permutations and I found<br>\nthat the existing material is quite dispersed.</p>\n<blockquote>\n<ul>\n<li>Predicates for permutations (functions)<br>\n    * Library/Permutations.thy<br>\n        * Permutations.permutation :: \"('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.permutes :: \"('a ⇒ 'a) ⇒ 'a set ⇒ bool\"</li>\n<li>Representation as swaps<br>\n    * Library/Permutations.thy<br>\n        * Permutations.swapidseq :: \"nat ⇒ ('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.evenperm :: \"('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.sign :: \"('a ⇒ 'a) ⇒ int\"<br>\n    * Planarity_Certificates/Planarity/Permutations_2.thy<br>\n        * Permutations_2.funswapid :: \"'a ⇒ 'a ⇒ 'a ⇒ 'a\"<br>\n        * Permutations_2.perm_swap :: \"'a ⇒ 'a ⇒ ('a ⇒ 'a) ⇒ 'a ⇒ 'a\"<br>\n        * Permutations_2.perm_rem :: \"'a ⇒ ('a ⇒ 'a) ⇒ 'a ⇒ 'a\"<br>\n    * Jordan_Normal_Form/Missing_Permutations.thy<br>\n        * Missing_Permutations.signof :: \"(nat ⇒ nat) ⇒ 'a\"</li>\n<li>Representation as cycles<br>\n    * Planarity_Certificates/Planarity/Executable_Permutations.thy</li>\n<li>Permuting lists<br>\n    * Library/Permutations.thy<br>\n        * Permutations.permute_list :: \"(nat ⇒ nat) ⇒ 'a list ⇒ 'a list\"<br>\n    * Library/Permutation.thy<br>\n        * Permutation.perm :: \"'a list ⇒ 'a list ⇒ bool\"<br>\n            * btw that equivalence relation would be expressed better<br>\nas »mset xs = mset ys« anyway</li>\n<li>Derangements<br>\n    * Derangements/Derangements.thy<br>\n        * Derangements.derangements :: \"nat set ⇒ (nat ⇒ nat) set\"<br>\n        * Derangements.count_derangements :: \"nat ⇒ nat\"</li>\n<li>Representation as association lists<br>\n    * Library/Permutations.thy<br>\n        * Permutations.list_permutes :: \"('a × 'a) list ⇒ 'a set ⇒ bool\"<br>\n        * Permutations.permutation_of_list :: \"('a × 'a) list ⇒ 'a ⇒ 'a\"<br>\n        * Permutations.inverse_permutation_of_list ::  \"('a × 'a)<br>\nlist ⇒ 'a ⇒ 'a\"</li>\n<li>Various theorems<br>\n    * Jordan_Normal_Form/Missing_Permutations.thy<br>\n    * Completeness/PermutationLemmas.thy</li>\n</ul>\n</blockquote>\n<p>In the mid-run there is clearly room for improvement here. I would<br>\nsuggest one theory Library/Permutation.thy which introduces the basics<br>\n(predicates, swaps, cycles) consistently with all available<br>\ncorresponding theorems. The more specialized things (association lists<br>\netc) could go to separate theories. But this rough sketch has still time<br>\nfor consideration.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p>(For the curious, I stumbled over that issue as follows: first, I<br>\ninspected the sources for occurrences of »no_notation« since these are<br>\npossible candidates to user syntax bundles; one of these has been the<br>\ninfix syntax »_ choose _« for binomial coefficients, which lead me to<br>\nreconsider other combinatorial coefficients (Stirling numbers) as well;<br>\nhence the interest in permutations.)<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/Choh7ujhFk_RfoKUQ-8X2PEE/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294675645,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174862
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>recently I did a full text search concerning permutations and I found<br>\nthat the existing material is quite dispersed.</p>\n<p>In the mid-run there is clearly room for improvement here. I would<br>\nsuggest one theory Library/Permutation.thy which introduces the basics<br>\n(predicates, swaps, cycles) consistently with all available<br>\ncorresponding theorems. The more specialized things (association lists<br>\netc) could go to separate theories. But this rough sketch has still time<br>\nfor consideration.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p>(For the curious, I stumbled over that issue as follows: first, I<br>\ninspected the sources for occurrences of »no_notation« since these are<br>\npossible candidates to user syntax bundles; one of these has been the<br>\ninfix syntax »_ choose _« for binomial coefficients, which lead me to<br>\nreconsider other combinatorial coefficients (Stirling numbers) as well;<br>\nhence the interest in permutations.)<br>\n<a href=\"/user_uploads/14278/rBeQHGu1moBp2zrATkCaRhnM/signature.asc\">signature.asc</a></p>",
        "id": 294677794,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175565
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nYou are right, this is pretty dispersed. To make matters worse, I <br>\nrecently committed something called \"Set_Permutations\" for the set of <br>\nall distinct lists consisting of elements of a set.</p>\n<p>Additionally, I still have some old material lying around about the set <br>\nof all permutations of a multilist (and, as a direct consequence of <br>\nthat, of a list). That should probably also be added at some point.</p>\n<p>It is not clear to me at all how these things can be unified. The <br>\nnotions of permutations as ‘all lists with elements of a given <br>\nset/multiset/list’ and permutations as ‘a bijection from a finite sets <br>\nto itself’ are clearly related, but how can this relation be formalised <br>\nin the best way?</p>\n<p>After dabbling with permutations a bit, I think that one may even want <br>\nto have a type of permutations, implemented with Mappings by default.</p>\n<p>In any case, any kind of change here will probably lead to a lot of <br>\nadjustments in every work that uses permutations. This reform will not <br>\nbe an easy task.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294677807,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175568
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nThere is also a special type of sort-respecting permutations in<br>\nNominal2:</p>\n<p>$AFP/Nominal2/Nominal2_Base.thy</p>\n<p>definition<br>\n  \"perm \\&lt;equiv&gt; {f. bij f \\&lt;and&gt; finite {a. f a \\&lt;noteq&gt; a} \\&lt;and&gt;<br>\n     (&lt;forall&gt;a. sort_of (f a) = sort_of a)}\"</p>\n<p>typedef perm = \"perm\"</p>\n<p>The type \"'a bij\" would be nice.</p>\n<p>- Johannes</p>",
        "id": 294677839,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175579
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:christian.urban@kcl.ac.uk\">christian.urban@kcl.ac.uk</a>&gt;<br>\n...and by transitivity also of course in Nominal1 in</p>\n<p>$src/HOL/Nominal/Nominal.thy</p>\n<p>type_synonym <br>\n  'x prm = \"('x \\&lt;times&gt; 'x) list\"</p>\n<p>;o)</p>\n<p>Christian</p>\n<p>On Thursday, June 23, 2016 at 11:01:30 (+0200), Johannes Hölzl wrote:</p>\n<blockquote>\n<p>There is also a special type of sort-respecting permutations in<br>\nNominal2:</p>\n<p>$AFP/Nominal2/Nominal2_Base.thy</p>\n<p>definition<br>\n  \"perm \\&lt;equiv&gt; {f. bij f \\&lt;and&gt; finite {a. f a \\&lt;noteq&gt; a} \\&lt;and&gt;<br>\n     (&lt;forall&gt;a. sort_of (f a) = sort_of a)}\"</p>\n<p>typedef perm = \"perm\"</p>\n<p>The type \"'a bij\" would be nice.</p>\n<p>- Johannes<br>\n</p>\n</blockquote>\n<blockquote>\n<p>Am Donnerstag, den 23.06.2016, 10:02 +0200 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>You are right, this is pretty dispersed. To make matters worse, I <br>\nrecently committed something called \"Set_Permutations\" for the set<br>\nof <br>\nall distinct lists consisting of elements of a set.</p>\n<p>Additionally, I still have some old material lying around about the<br>\nset <br>\nof all permutations of a multilist (and, as a direct consequence of <br>\nthat, of a list). That should probably also be added at some point.</p>\n<p>It is not clear to me at all how these things can be unified. The <br>\nnotions of permutations as ‘all lists with elements of a given <br>\nset/multiset/list’ and permutations as ‘a bijection from a finite<br>\nsets <br>\nto itself’ are clearly related, but how can this relation be<br>\nformalised <br>\nin the best way?</p>\n<p>After dabbling with permutations a bit, I think that one may even<br>\nwant <br>\nto have a type of permutations, implemented with Mappings by default.</p>\n<p>In any case, any kind of change here will probably lead to a lot of <br>\nadjustments in every work that uses permutations. This reform will<br>\nnot <br>\nbe an easy task.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n</blockquote>\n<p>On 23/06/16 09:47, Florian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi all,</p>\n<p>recently I did a full text search concerning permutations and I<br>\nfound<br>\nthat the existing material is quite dispersed.</p>\n<blockquote>\n<ul>\n<li>Predicates for permutations (functions)<ul>\n<li>Library/Permutations.thy<br>\n     * Permutations.permutation :: \"('a ⇒ 'a) ⇒ bool\"<br>\n     * Permutations.permutes :: \"('a ⇒ 'a) ⇒ 'a set ⇒ bool\"</li>\n</ul>\n</li>\n<li>Representation as swaps<ul>\n<li>Library/Permutations.thy<br>\n     * Permutations.swapidseq :: \"nat ⇒ ('a ⇒ 'a) ⇒ bool\"<br>\n     * Permutations.evenperm :: \"('a ⇒ 'a) ⇒ bool\"<br>\n     * Permutations.sign :: \"('a ⇒ 'a) ⇒ int\"</li>\n<li>Planarity_Certificates/Planarity/Permutations_2.thy<br>\n     * Permutations_2.funswapid :: \"'a ⇒ 'a ⇒ 'a ⇒ 'a\"<br>\n     * Permutations_2.perm_swap :: \"'a ⇒ 'a ⇒ ('a ⇒ 'a) ⇒ 'a<br>\n⇒ 'a\"<br>\n     * Permutations_2.perm_rem :: \"'a ⇒ ('a ⇒ 'a) ⇒ 'a ⇒ 'a\"</li>\n<li>Jordan_Normal_Form/Missing_Permutations.thy<br>\n     * Missing_Permutations.signof :: \"(nat ⇒ nat) ⇒ 'a\"</li>\n</ul>\n</li>\n<li>Representation as cycles<ul>\n<li>Planarity_Certificates/Planarity/Executable_Permutations.thy</li>\n</ul>\n</li>\n<li>Permuting lists<ul>\n<li>Library/Permutations.thy<br>\n     * Permutations.permute_list :: \"(nat ⇒ nat) ⇒ 'a list ⇒<br>\n'a list\"</li>\n<li>Library/Permutation.thy<br>\n     * Permutation.perm :: \"'a list ⇒ 'a list ⇒ bool\"<br>\n         * btw that equivalence relation would be<br>\nexpressed better as »mset xs = mset ys« anyway</li>\n</ul>\n</li>\n<li>Derangements<ul>\n<li>Derangements/Derangements.thy<br>\n     * Derangements.derangements :: \"nat set ⇒ (nat ⇒ nat)<br>\nset\"<br>\n     * Derangements.count_derangements :: \"nat ⇒ nat\"</li>\n</ul>\n</li>\n<li>Representation as association lists<ul>\n<li>Library/Permutations.thy<br>\n     * Permutations.list_permutes :: \"('a × 'a) list ⇒ 'a<br>\nset ⇒ bool\"<br>\n     * Permutations.permutation_of_list :: \"('a × 'a) list ⇒<br>\n'a ⇒ 'a\"<br>\n     * Permutations.inverse_permutation_of_list ::  \"('a ×<br>\n'a) list ⇒ 'a ⇒ 'a\"</li>\n</ul>\n</li>\n<li>Various theorems<ul>\n<li>Jordan_Normal_Form/Missing_Permutations.thy</li>\n<li>Completeness/PermutationLemmas.thy<br>\nIn the mid-run there is clearly room for improvement here. I would<br>\nsuggest one theory Library/Permutation.thy which introduces the<br>\nbasics<br>\n(predicates, swaps, cycles) consistently with all available<br>\ncorresponding theorems. The more specialized things (association<br>\nlists<br>\netc) could go to separate theories. But this rough sketch has still<br>\ntime<br>\nfor consideration.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>Cheers,<br>\n Florian</p>\n<p>(For the curious, I stumbled over that issue as follows: first, I<br>\ninspected the sources for occurrences of »no_notation« since these<br>\nare<br>\npossible candidates to user syntax bundles; one of these has been<br>\nthe<br>\ninfix syntax »_ choose _« for binomial coefficients, which lead me<br>\nto<br>\nreconsider other combinatorial coefficients (Stirling numbers) as<br>\nwell;<br>\nhence the interest in permutations.)</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294677867,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175592
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nAnd in IsaFoR in<br>\n<a href=\"http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy\">http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy</a></p>\n<p>definition perms :: \"('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nwhere<br>\n  \"perms = {f. bij f \\&lt;and&gt; finite {x. f x \\&lt;noteq&gt; x}}\"</p>\n<p>typedef 'a perm = \"perms :: ('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nby standard (auto simp: perms_def)</p>\n<p>where permutations have a type parameter and thus we have local-based<br>\napplication of permutations instead of type-class-based (but otherwise I<br>\ngot everything from the Nominal2 development, thanks).</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294677892,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175598
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>Am 23.06.2016 um 10:02 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>It is not clear to me at all how these things can be unified. The<br>\nnotions of permutations as ‘all lists with elements of a given<br>\nset/multiset/list’ and permutations as ‘a bijection from a finite sets<br>\nto itself’ are clearly related, but how can this relation be formalised<br>\nin the best way?</p>\n</blockquote>\n<p>what I have in mind is a clarification of terminology here: permutations<br>\nas functions and list permutations should be introduced in separate<br>\ntheories, where I guess that multisets as quotient type of permutated<br>\nlists can absorb a lot of the latter.</p>\n<p>If an application needs this relation, it can still formalize it.  I did<br>\nnot see any example for that in the theories.</p>\n<p>Am 23.06.2016 um 10:02 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>After dabbling with permutations a bit, I think that one may even want<br>\nto have a type of permutations, implemented with Mappings by default.</p>\n</blockquote>\n<p>Am 23.06.2016 um 11:01 schrieb Johannes Hölzl:</p>\n<blockquote>\n<p>The type \"'a bij\" would be nice.</p>\n</blockquote>\n<p>Note that a bijection is not necessarily a permutation: in a<br>\npermutation, each element a has a finite order, ie. some n &gt; 0 such that<br>\n(f ^^ n) a = a.</p>\n<p>Am 23.06.2016 um 12:01 schrieb Christian Sternagel:</p>\n<blockquote>\n<p>And in IsaFoR in</p>\n<p><a href=\"http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy\">http://cl2-informatik.uibk.ac.at/rewriting/mercurial.cgi/IsaFoR/file/968059663689/thys/Auxiliaries/Renaming.thy</a></p>\n<p>definition perms :: \"('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nwhere<br>\n  \"perms = {f. bij f \\&lt;and&gt; finite {x. f x \\&lt;noteq&gt; x}}\"</p>\n<p>typedef 'a perm = \"perms :: ('a \\&lt;Rightarrow&gt; 'a) set\"<br>\nby standard (auto simp: perms_def)</p>\n<p>where permutations have a type parameter and thus we have local-based<br>\napplication of permutations instead of type-class-based (but otherwise I<br>\ngot everything from the Nominal2 development, thanks).</p>\n</blockquote>\n<p>I don't quite understand the last paragraph.  Which type-class are you<br>\nreferring to?</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<p>In any case, any kind of change here will probably lead to a lot of<br>\nadjustments in every work that uses permutations. This reform will not<br>\nbe an easy task.</p>\n<p>Cheers,</p>\n<p>Manuel</p>\n<p>On 23/06/16 09:47, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>recently I did a full text search concerning permutations and I found<br>\nthat the existing material is quite dispersed.</p>\n<blockquote>\n<ul>\n<li>Predicates for permutations (functions)<br>\n    * Library/Permutations.thy<br>\n        * Permutations.permutation :: \"('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.permutes :: \"('a ⇒ 'a) ⇒ 'a set ⇒ bool\"</li>\n<li>Representation as swaps<br>\n    * Library/Permutations.thy<br>\n        * Permutations.swapidseq :: \"nat ⇒ ('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.evenperm :: \"('a ⇒ 'a) ⇒ bool\"<br>\n        * Permutations.sign :: \"('a ⇒ 'a) ⇒ int\"<br>\n    * Planarity_Certificates/Planarity/Permutations_2.thy<br>\n        * Permutations_2.funswapid :: \"'a ⇒ 'a ⇒ 'a ⇒ 'a\"<br>\n        * Permutations_2.perm_swap :: \"'a ⇒ 'a ⇒ ('a ⇒ 'a) ⇒ 'a ⇒ 'a\"<br>\n        * Permutations_2.perm_rem :: \"'a ⇒ ('a ⇒ 'a) ⇒ 'a ⇒ 'a\"<br>\n    * Jordan_Normal_Form/Missing_Permutations.thy<br>\n        * Missing_Permutations.signof :: \"(nat ⇒ nat) ⇒ 'a\"</li>\n<li>Representation as cycles<br>\n    * Planarity_Certificates/Planarity/Executable_Permutations.thy</li>\n<li>Permuting lists<br>\n    * Library/Permutations.thy<br>\n        * Permutations.permute_list :: \"(nat ⇒ nat) ⇒ 'a list ⇒ 'a list\"<br>\n    * Library/Permutation.thy<br>\n        * Permutation.perm :: \"'a list ⇒ 'a list ⇒ bool\"<br>\n            * btw that equivalence relation would be expressed better<br>\nas »mset xs = mset ys« anyway</li>\n<li>Derangements<br>\n    * Derangements/Derangements.thy<br>\n        * Derangements.derangements :: \"nat set ⇒ (nat ⇒ nat) set\"<br>\n        * Derangements.count_derangements :: \"nat ⇒ nat\"</li>\n<li>Representation as association lists<br>\n    * Library/Permutations.thy<br>\n        * Permutations.list_permutes :: \"('a × 'a) list ⇒ 'a set ⇒ bool\"<br>\n        * Permutations.permutation_of_list :: \"('a × 'a) list ⇒ 'a ⇒ 'a\"<br>\n        * Permutations.inverse_permutation_of_list ::  \"('a × 'a)<br>\nlist ⇒ 'a ⇒ 'a\"</li>\n<li>Various theorems<br>\n    * Jordan_Normal_Form/Missing_Permutations.thy<br>\n    * Completeness/PermutationLemmas.thy</li>\n</ul>\n</blockquote>\n<p>In the mid-run there is clearly room for improvement here. I would<br>\nsuggest one theory Library/Permutation.thy which introduces the basics<br>\n(predicates, swaps, cycles) consistently with all available<br>\ncorresponding theorems. The more specialized things (association lists<br>\netc) could go to separate theories. But this rough sketch has still time<br>\nfor consideration.</p>\n<p>Cheers,<br>\n    Florian</p>\n<p>(For the curious, I stumbled over that issue as follows: first, I<br>\ninspected the sources for occurrences of »no_notation« since these are<br>\npossible candidates to user syntax bundles; one of these has been the<br>\ninfix syntax »_ choose _« for binomial coefficients, which lead me to<br>\nreconsider other combinatorial coefficients (Stirling numbers) as well;<br>\nhence the interest in permutations.)<br>\n</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/1Amv8Hw9TlMokak4mIl2_MMs/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294677947,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175604
    }
]