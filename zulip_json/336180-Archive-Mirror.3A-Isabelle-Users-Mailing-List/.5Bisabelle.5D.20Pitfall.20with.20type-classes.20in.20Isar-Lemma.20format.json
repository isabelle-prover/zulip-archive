[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi all,</p>\n<p>(Referring to Isabelle2011-1)</p>\n<p>I recently ran into the following pitfall:</p>\n<p>lemma pitfall1:<br>\n  notes [[show_sorts]]<br>\n  notes test = refl[where 'a='a]<br>\n  fixes x::\"'a::default\"<br>\n  shows \"x=x\"<br>\n  thm test -- \"'a has the wrong sort here!\"<br>\n  using test apply -</p>\n<p>Now it outputs:<br>\ntype variables:<br>\n  'a :: type<br>\n  'a :: default</p>\n<p>and, of course, apply (rule test) fails. When inspecting this failure,<br>\nthe already confused user gets the following trace from the unifier<br>\n(even with show_sorts turned on!)</p>\n<p>The following types do not unify:<br>\n'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool<br>\n'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool</p>\n<p>I would expect that a type-variable with the same name should also have<br>\nthe same sort -- at least when I introduce it within the<br>\nscope of the very same lemma.</p>\n<p>And even more strange, this pitfall can be resolved by just swapping the<br>\nnotes and the fixes declaration:</p>\n<p>lemma pitfall1_resolved:<br>\n  fixes x::\"'a::default\"<br>\n  notes [[show_sorts]]<br>\n  notes test = refl[where 'a='a]<br>\n  shows \"x=x\"<br>\n  by (rule test)</p>\n<p>Regards,<br>\n  Peter</p>",
        "id": 294150485,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849139
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIs this just an exercise in driving the system into an unspecified / <br>\nuninhabitable state, or does it have some practical significance?</p>\n<p>There are many things happening in a compund theorem statement, and the <br>\nuse of the above words of \"wrong\", \"expect\", \"strange\" are meaningless in <br>\nthis context. Where is it ever specified that it should behave like that?<br>\nThe above forms are very uncommon, so uncommon effects are to be expected.</p>\n<p>I am not going to explain here the accidental behaviour of certain <br>\nboundary cases in complex theorem statements: certain things are <br>\nsimultaneous here, other things are sequential, other things undefined.</p>\n<p>Anyway, I've required some time to guess that \"trace from the unifier\" <br>\nprobably means Pattern.trace_unify_fail := true.  But that is a global ML <br>\nreference, so it already indicates that the related operations are not yet <br>\n\"localized\".  That means they don't observe the local context resulting <br>\nfrom your \"notes [[show_sorts]]\", which is a bit odd anyway.</p>\n<p>So when you say \"even with show_sorts turned on\", it is actually not <br>\nturned on for the pattern unification module.  When doing the more usual <br>\n\"declare [[show_sorts]]\" before the lemma statement you get the sort <br>\ninformation printed as expected.</p>\n<p>Makarius</p>",
        "id": 294152291,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849751
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Is this just an exercise in driving the system into an unspecified / <br>\nuninhabitable state, or does it have some practical significance?</p>\n</blockquote>\n<p>I have distilled that from a practical example, that went like this:</p>\n<p>schematic_lemma <br>\n  notes [refine_transfer] = &lt;Some lemmas that only makes sense for this<br>\nparticular refinement proof&gt;<br>\n  shows \"?concrete_program &lt;= abstract_program\"<br>\n  by (tactic that uses lemmas declared with attribute <br>\n    \"refine_transfer\" (which is a NamedThms structure)</p>\n<p>As I do not know how to refer to the schematic<br>\nvariable ?concrete_program when I do <br>\n  proof - note [refine_transfer] = ... show \"xxx\" ...<br>\n   (For xxx, neither ?thesis nor \"?concrete_program &lt;= abstract_program\"<br>\nworks),<br>\nI used the notes-syntax.</p>\n<p>An alternative would be to pass the lemmas as parameters to my tactic,<br>\nwhich I have already (partially) implemented (after writing the first<br>\nmail ;) ).</p>\n<p>Peter</p>",
        "id": 294152304,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849757
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 15 Feb 2012, Peter Lammich wrote:</p>\n<blockquote>\n<blockquote>\n<p>Is this just an exercise in driving the system into an unspecified /<br>\nuninhabitable state, or does it have some practical significance?</p>\n</blockquote>\n<p>I have distilled that from a practical example, that went like this:</p>\n<p>schematic_lemma<br>\n notes [refine_transfer] = &lt;Some lemmas that only makes sense for this<br>\nparticular refinement proof&gt;<br>\n shows \"?concrete_program &lt;= abstract_program\"<br>\n by (tactic that uses lemmas declared with attribute<br>\n  \"refine_transfer\" (which is a NamedThms structure)</p>\n</blockquote>\n<p>BTW, the thing given as arguments to the command 'by' is called \"proof <br>\nmethod\" or just \"method\" in Isar terminology.  There are further <br>\nexplanations and some examples in section 6.2 of the <br>\nIsabelle/Implementation manual.  (The same manual also explains the <br>\ntraditional concept of \"tactic\" in Isabelle/ML, see section 4.1.)</p>\n<blockquote>\n<p>An alternative would be to pass the lemmas as parameters to my tactic, <br>\nwhich I have already (partially) implemented</p>\n</blockquote>\n<p>This would indeed follow the standard convention: a method that accepts <br>\nimplicit arguments via the context also allows the same as explicit <br>\narguments on the spot.  The my_simp' example from the quoted section 6.2 <br>\nabove does exactly that.</p>\n<p>Makarius</p>",
        "id": 294152313,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849763
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>BTW, the thing given as arguments to the command 'by' is called \"proof <br>\nmethod\" or just \"method\" in Isar terminology.  <br>\nsorry for the confusion here.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>An alternative would be to pass the lemmas as parameters to my tactic, <br>\nwhich I have already (partially) implemented</p>\n</blockquote>\n<p>This would indeed follow the standard convention: a method that accepts <br>\nimplicit arguments via the context also allows the same as explicit <br>\narguments on the spot.  </p>\n</blockquote>\n<p>For my application, it has, however, the disadvantage that the setup has<br>\nto be repeated each time I apply a method. For example, I want to<br>\nsupport proofs like:</p>\n<p>schematic_lemma <br>\n  notes [refine_transfer] = some lengthy setup<br>\n  notes [...] = ...<br>\n  shows \"?c &lt;= a\"<br>\n  apply (my_method)<br>\n  apply (some user-specified proof of subgoal, thereby instantiating<br>\nschematics on that the rest of the proof depends)<br>\n  apply (my_method)<br>\n  apply (some user-specified instantiation)<br>\n  apply (my_method)<br>\n  ...<br>\n  done</p>\n<p>When I do the setup locally for the proof method, I have to repeat it<br>\neach time I apply the method. What I really want is to do the setup for<br>\nthe whole proof.</p>\n<p>Perhaps, what I'm doing here is an abuse of the original intention of<br>\nschematic_lemma ??</p>\n<p>Peter</p>",
        "id": 294152343,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849775
    }
]