[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 22 Apr 2014, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>I went through lots of iterations looking for the right language.</p>\n</blockquote>\n<p>The \"right language\" depends a lot on what you want to do with it, but <br>\nthat should be common folklore anyway.</p>\n<blockquote>\n<p>Part of first passing over OCaml was that it doesn't come installed with <br>\nCygwin, where Perl and Python do.</p>\n</blockquote>\n<p>As a Windows user you might be interested in F# <a href=\"http://fsharp.org/\">http://fsharp.org/</a> which <br>\nseems to have taken over most of the potential market share of OCaml in <br>\nrecent years.  OCaml was once a big thing, but now it is just another <br>\nscripting language performance-wise, since it is still not multicore <br>\ncapable.</p>\n<blockquote>\n<p>But, though It's very easy for me to install OCaml and Ruby on Cygwin, <br>\nwith Cygwin-Setup.bat, it might not be easy for someone who has never <br>\ndone it before.</p>\n<p>If OCaml and Ruby came as part of Cygwin, in the contrib folder, then <br>\nthings would be closer to working by magic, if someone was trying to do <br>\nwhat I'm doing.</p>\n</blockquote>\n<p>I don't see the point.  The Cygwin-Setup.bat is there to add whatever <br>\nmight be interesting in addition to the default packages that are <br>\nnecessary to run Isabelle and its standard tools.  The Cygwin installation <br>\ndialog is not ultra user-friendly, but any requests for improvements <br>\nshould be directed to the Cygwin guys and gals, especially Corinna <br>\nVinschen.</p>\n<blockquote>\n<p>I attach a zip file. I don't expect anyone to look at it, but I attach <br>\nit to show, as part of the request, that my request has something behind <br>\nit.</p>\n</blockquote>\n<p>I did look at it, but not very systematically.  Here are a few notes:</p>\n<ul>\n<li>\n<p>Load all files relatively to the implicit master directory of the<br>\n   enclosing theory.  This avoids absolute file-system references, and<br>\n   keeps your application \"portable\", i.e. you don't have to ask people to<br>\n   put things into a specific place.</p>\n</li>\n<li>\n<p>Watch out for global side-effects of Isar command declarations<br>\n   ('keywords') and their subsequent definitions in ML part of a theory.<br>\n   This implicit statefulness of the command table is TTY / Proof General<br>\n   legacy and easily leads to mistakes in the Prover IDE.</p>\n</li>\n<li>\n<p>Instead of fragile echo within the shell and its complicated rules for<br>\n   quoting, better use a temp file and stdin redirection (via \"&lt;\").  See<br>\n   also the Isabelle/ML operation Isabelle_System.create_tmp_path or<br>\n   better the higher-order wrapper Isabelle_System.with_tmp_file.</p>\n</li>\n<li>\n<p>The type 'a Unsynchronized.ref in Isabelle/ML is just an alias of<br>\n   regular 'a ref, to empasize its unsynchronized nature, and to make it<br>\n   easier to get old ML code right with the help of static analysis: fewer<br>\n   ref operations are pervasive by default, so it is easier to locate its<br>\n   remaining uses.  The easiest way to give that up that discipline is ML<br>\n   \"open Unsynchronized\", but you should not do this in production code.</p>\n</li>\n<li>\n<p>A mutable HashArray is a very old-fashioned (and in general inefficient)<br>\n   data structure. Mutability belongs into the bucket with the label<br>\n   \"premature optimization is the root of all evil\".  On today's parallel<br>\n   hardware it is often less efficient by default, and actually plain wrong<br>\n   without special precautions.  See @{file \"~~/src/Pure/General/table.ML\"}<br>\n   for an efficient immutable data structure that can be used by default<br>\n   almost everywhere, without requiring extra thinking about correctness or<br>\n   efficiency.</p>\n<p>If you want to make a global cache of certain items, the canonical way<br>\n is via some immutable table that is stored within a Synchronized.var.<br>\n Moving mutability away from the data structures to some topmost position<br>\n is the first step to get things right (correct and efficient).</p>\n</li>\n</ul>\n<blockquote>\n<p>Part of the work is related to dealing with the statelessness of the <br>\nPIDE. It's not that complex to implement, but my current is idea is to <br>\nuse a hash table along with a random number generator to get a name. <br>\nThere's a number of them available, but I guess I'll use the one from <br>\nLarry Paulson's book that I acquired recently from the SML/NJ import. <br>\nThe SML/NJ Library manual has some things to say about it.</p>\n</blockquote>\n<p>Much could be said about random numbers, e.g. see <br>\n<a href=\"http://dilbert.com/strips/comic/2001-10-25/\">http://dilbert.com/strips/comic/2001-10-25/</a> what Scott Adams says.  We <br>\nhave our own old jokes and running gags about the various random <br>\ngenerators that are floating around in the Isabelle sources.</p>\n<p>It is generally difficult to produce unique indentifiers that are actually <br>\nunique in a sufficiently large scope.  Within a running Isabelle/ML <br>\nprocess you can use \"serial ()\" or \"serial_string ()\" for that, but it is <br>\nalso not 100% fool-proof if such ids persist over unrelated Isabelle <br>\nsessions.</p>\n<p>Makarius</p>",
        "id": 294274005,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918146
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nMy hint was more basic that this.  Your ML_file references where all <br>\nabsolute, but by just removing a prefix it becaume relative to the master <br>\ndirectory of the enclosing theory, and thus became \"portable\".</p>\n<p>Makarius</p>",
        "id": 294274519,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918317
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIt is about HOL-Zero and Ocaml as unsafe programming language etc.<br>\nA very entangled variant of several related and unrelated threads around <br>\nthis can be seen here on the HOL mailing list:</p>\n<p><a href=\"http://sourceforge.net/p/hol/mailman/hol-info/thread/E1SN77r-0007Os-05%40mta0.cl.cam.ac.uk/#msg29180495\">http://sourceforge.net/p/hol/mailman/hol-info/thread/E1SN77r-0007Os-05%40mta0.cl.cam.ac.uk/#msg29180495</a></p>\n<p>Title of the thread: \"Re: rigorous axiomatic geometry proof in HOL Light\".</p>\n<p>Makarius</p>",
        "id": 294274617,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918342
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nIncidentally, the gmane interface to the mailing list, at for example</p>\n<p><a href=\"http://article.gmane.org/gmane.comp.mathematics.hol/1605/\">http://article.gmane.org/gmane.comp.mathematics.hol/1605/</a></p>\n<p>is much nicer than the antiquated UI available through sourceforge.</p>\n<p>Michael</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294274637,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918348
    }
]