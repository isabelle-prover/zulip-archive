[
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@gmail.com\">munddr@gmail.com</a>&gt;<br>\nHi,</p>\n<p>If I have the following:</p>\n<p>typedecl A<br>\ntypedecl B</p>\n<p>axiomatization<br>\nf :: \"'a =&gt; nat\"</p>\n<p>axioms<br>\nax1 : \"f (x::A) = 0\"<br>\nax2 : \"f (x::B) = 1\"</p>\n<p>Is the mechanism for \"inspecting\" the type of the argument of f<br>\nessentially defining a type class, or is it something else? If it's<br>\nindeed something else, then why isn't a type class used instead?</p>\n<p>Any input will be appreciated. Thanks.</p>\n<p>John</p>",
        "id": 294145905,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847493
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi John,</p>\n<p>logically, equational theorems are just »rules« with a certain typing,<br>\nand this typing »decides« which »rules« actually can be applied to a<br>\nredex.  This does not need any special mechanisms since the logic is not<br>\na programming language: all types are present at all time.</p>\n<p>Another story is how constants can be <em>defined</em> overloaded.  The<br>\nend-user mechanism used mostly nowadays are indeed type classes similar<br>\nto Haskell, but on the foundational level this manifests as a special<br>\ndiscipline of admissible overloaded definition – ask if you want to know<br>\nmore on that.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/csIHRhufmLalW-SZODjjr-xJ/signature.asc\">signature.asc</a></p>",
        "id": 294145945,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847508
    }
]