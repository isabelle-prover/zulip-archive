[
    {
        "content": "<p>From: Domagoj Stolfa &lt;<a href=\"mailto:ds815@cam.ac.uk\">ds815@cam.ac.uk</a>&gt;<br>\nHi all:</p>\n<p>I've tried naively writing a function that filters some values in the codomain of an fmap. It resulted in a function that looks a little bit like:</p>\n<p>fun filter_types_clause :: \"(var, (ty × nat)) fmap ⇒ (var, (ty × nat)) fmap\" where<br>\n\"filter_types_clause m = fmfilter<br>\n                          (λx .<br>\n                            (let r = fmlookup m x in<br>\n                              case r of None ⇒ False<br>\n                                       | Some res ⇒ let scp = snd res in<br>\n                                                      if scp = 2 ∨ scp = 3<br>\n                                                        then True<br>\n                                                        else False))<br>\n                          m\"</p>\n<p>However, Isabelle wasn't happy with the function and outputted the following error:</p>\n<p>exception THM 0 raised (line 86 of \"goal.ML\"):<br>\n  Proof failed.</p>\n<p>1. ⋀ma. fmfilter<br>\n             (λx. case fmlookup ma x of None ⇒ False<br>\n                  | Some res ⇒ let scp = snd res in (scp = 2 ∨ scp = 3 ⟶ True) ∧ (¬ (scp = 2 ∨ scp = 3) ⟶ False))<br>\n             ma =<br>\n            fmfilter<br>\n             (λx. Let (fmlookup ma x)<br>\n                   (case_option False<br>\n                     (λres. let scp = snd res in (scp = 2 ∨ scp = 3 ⟶ True) ∧ (¬ (scp = 2 ∨ scp = 3) ⟶ False))))<br>\n             ma<br>\n  (⋀ma. fmfilter<br>\n          (λx. case fmlookup ma x of None ⇒ False<br>\n               | Some res ⇒ let scp = snd res in (scp = 2 ∨ scp = 3 ⟶ True) ∧ (¬ (scp = 2 ∨ scp = 3) ⟶ False))<br>\n          ma =<br>\n         fmfilter<br>\n          (λx. Let (fmlookup ma x)<br>\n                (case_option False<br>\n                  (λres. let scp = snd res in (scp = 2 ∨ scp = 3 ⟶ True) ∧ (¬ (scp = 2 ∨ scp = 3) ⟶ False))))<br>\n          ma) ⟹<br>\n  ((⋀a. Wellfounded.accp filter_types_clause_rel a ⟹ ∃!y. filter_types_clause_graph a y) &amp;&amp;&amp;<br>\n   (⋀P x. (⋀m. x = m ⟹ P) ⟹ P))<br>\n    [filter_types_clause_graph ≡ ??.tinyd.filter_types_clause_graph]</p>\n<p>Writing the function without the first let, and instead putting the expression (fmlookup m x) in the case expression eliminates the bug. Moreover, writing it as a definition instead of a function in the above form also gets rid of the problem (as it's non-recursive to begin with). After talking to Lars (who also suggested writing it down as a definition instead of a function), we seem to have reached a conclusion that it may be a bug in Finite_Map -- could anyone confirm/reproduce this? The \"var\" type is a String.literal and \"ty\" is just a sum type with four constructors, ty_int, ty_array, ty_bool and ty_unit.</p>\n<p>The version of Isabelle is 2018 and I've been running it on Mac OS X.</p>\n<p>Thanks!</p>\n<p>—<br>\nDomagoj<br>\n<a href=\"/user_uploads/14278/xGKWpmmcYbKBZoWJgrdPNjSg/signature.asc\">signature.asc</a></p>",
        "id": 294744328,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661192808
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nThis appears to be a problem with \"auto\".</p>\n<p>Here is a smaller reproducer:</p>\n<p>\"filter_types_clause m = fmfilter<br>\n                          (λx .<br>\n                            (let r = fmlookup m x in<br>\n                              case r of  Some res ⇒  snd res = 2))<br>\n                          m\"</p>\n<p>When defining this function \"function (sequential)\", \"pat_completeness\"<br>\ndischarges the first subgoal as it should. But \"auto\", instead of<br>\nsolving the remaining one, produces this goal state:</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>⋀ma.<br>\n  fmfilter (λx. case fmlookup ma x of Some res ⇒ snd res = 2) ma =<br>\n  fmfilter (λx. Let (fmlookup ma x) (case_option undefined (λres. snd<br>\nres = 2))) ma</li>\n</ol>\n<p>For some reason, it unfolds the \"Let\" in the first half of the equation,<br>\nbut not in the second half.</p>\n<p>Without the let simproc, it works:</p>\n<p>declare [[simproc del: let_simp]]</p>\n<p>Maybe someone who knows how that simproc works could take a look.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294744351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661192820
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi Lars,</p>\n<p>I briefly looked into this. To me, let_simp does not seem to be the culprit. From looking <br>\nat simp_trace and simp_debug, It seems as if there is an unfortunate interaction between <br>\nthe congruence rule for fmfilter and the case_option simp rules. For if I delete the <br>\nfmfilter_cong congruence rule, the proof succeeds.</p>\n<p>Andreas</p>",
        "id": 294744449,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661192867
    }
]