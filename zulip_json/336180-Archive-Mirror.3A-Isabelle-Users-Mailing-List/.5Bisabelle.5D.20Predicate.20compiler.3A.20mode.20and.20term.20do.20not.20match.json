[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear all,</p>\n<p>I have three mutually-defined inductive predicates:</p>\n<blockquote>\n<p>inductive<br>\n  evaluate_match :: \"bool ⇒ all_env ⇒(v)count_store ⇒ v ⇒(pat<em>exp)list ⇒ v ⇒(v)count_store</em>((v),(v))result ⇒ bool\"  <br>\n  and<br>\n  evaluate_list :: \"bool ⇒ all_env ⇒(v)count_store ⇒(exp)list ⇒(v)count_store*(((v)list),(v))result ⇒ bool\"  <br>\n  and<br>\n  evaluate :: \"bool ⇒ all_env ⇒(v)count_store ⇒ exp ⇒(v)count_store*((v),(v))result ⇒ bool\"</p>\n</blockquote>\n<p>As far as I can see, their rules are relatively straightforward. I can<br>\nmake proofs over them just fine by repeated application of \"rule\" and<br>\nsome unfolding.</p>\n<p>Now, I want to make them executable. The obvious invocation</p>\n<blockquote>\n<p>code_pred evaluate .</p>\n</blockquote>\n<p>fails: despite there being no subgoals, the command fails after \".\" with:</p>\n<blockquote>\n<p>exception Fail raised (line 356 of \"~~/src/HOL/Tools/Predicate_Compile/predicate_compile_aux.ML\"): split_map_mode: mode and term do not match</p>\n</blockquote>\n<p>I also tried to specify the mode explicitly, but to no avail:</p>\n<blockquote>\n<p>code_pred (modes: i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool as compute_evaluate) evaluate .</p>\n</blockquote>\n<p>(same error message)</p>\n<p>What am I doing wrong?</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294283674,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921164
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>It is hard to say what goes wrong here given that I do not know what your types in the <br>\nsignature of the inductive predicates are. From the error message, I guess that something <br>\ngoes wrong during the higher-order mode analysis in the predicate compiler. As a first <br>\nstep, I recommend to specify the modes for all predicates. The syntax looks as follows:</p>\n<p>code_pred<br>\n   (modes: evaluate_match: ... as ..<br>\n       and evaluate_list: ... as ..<br>\n       and evaluate: ... as ..)<br>\n   evaluate .</p>\n<p>If that does not solve the problem:<br>\nHow are the types all_env, count_store, v, pat, list, and result defined? If any of these <br>\nis a type synonym that expands to a function with boolean result, you might try to specify <br>\na higher-order mode for these.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294283756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921188
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>It is hard to say what goes wrong here given that I do not know what<br>\nyour types in the signature of the inductive predicates are. From the<br>\nerror message, I guess that something goes wrong during the higher-order<br>\nmode analysis in the predicate compiler.</p>\n</blockquote>\n<p>as far as I can tell, there is no higher-order-ness involved.</p>\n<blockquote>\n<p>As a first step, I recommend to<br>\nspecify the modes for all predicates. The syntax looks as follows:</p>\n<p>code_pred<br>\n  (modes: evaluate_match: ... as ..<br>\n      and evaluate_list: ... as ..<br>\n      and evaluate: ... as ..)<br>\n  evaluate .</p>\n</blockquote>\n<p>This gives an even lower-level error:</p>\n<blockquote>\n<p>exception THM 1 raised (line 332 of \"drule.ML\"):<br>\n  RSN: no unifiers<br>\n  xh  [xh]<br>\n  ?s = ?t ⟹ ?t = ?s</p>\n</blockquote>\n<p>I have attached a self-contained zip file. The problematic invocation is<br>\nin \"Scratch.thy\", which should be loaded with the \"CakeML\" image (see ROOT).</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/yqJoawWLQnY4_iyMB_BlVl10/cakeml_bigstep.zip\">cakeml_bigstep.zip</a></p>",
        "id": 294283794,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921199
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>I don't know either what it is that triggers this exception, but I suspect that it has <br>\nsomething to do with all those tuples in your types. If you enable exception tracing, you <br>\ncan see that the error occurs only during the correctness proof of the compiled <br>\nexpression. If you just want to execute evaluate for some test cases, it might be <br>\nsufficient to trust the predicate compiler and disable the proofs with the option <br>\n[skip_proof]. Then, code_pred digests your semantics. Otherwise, you probably have to look <br>\ninto the proof tactic.</p>\n<p>However, for values, you also have to do the termination proofs for the functions pmatch, <br>\ndo_eq and pat_bindings. In summary, the following works in Isabelle2013-2:</p>\n<p>code_pred<br>\n   (modes: evaluate:       i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool<br>\n       and evaluate_list:  i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool<br>\n       and evaluate_match: i ⇒ i ⇒ i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool)<br>\n   [skip_proof]<br>\n   evaluate .</p>\n<p>termination pmatch by lexicographic_order<br>\ntermination do_eq by lexicographic_order<br>\ntermination pat_bindings by lexicographic_order</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294283907,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921219
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>I don't know either what it is that triggers this exception, but I suspect that it has<br>\nsomething to do with all those tuples in your types. If you enable exception tracing, you<br>\ncan see that the error occurs only during the correctness proof of the compiled<br>\nexpression. If you just want to execute evaluate for some test cases, it might be<br>\nsufficient to trust the predicate compiler and disable the proofs with the option<br>\n[skip_proof]. Then, code_pred digests your semantics. Otherwise, you probably have to look<br>\ninto the proof tactic.</p>\n<p>However, for values, you also have to do the termination proofs for the functions pmatch,<br>\ndo_eq and pat_bindings. In summary, the following works in Isabelle2013-2:</p>\n<p>code_pred<br>\n   (modes: evaluate:       i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool<br>\n       and evaluate_list:  i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool<br>\n       and evaluate_match: i ⇒ i ⇒ i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool)<br>\n   [skip_proof]<br>\n   evaluate .</p>\n<p>termination pmatch by lexicographic_order<br>\ntermination do_eq by lexicographic_order<br>\ntermination pat_bindings by lexicographic_order</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294283927,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921225
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>I don't know either what it is that triggers this exception, but I<br>\nsuspect that it has something to do with all those tuples in your types.</p>\n</blockquote>\n<p>I'm afraid I can't change these definitions; this is code which is being<br>\nautomatically generated by Lem from the CakeML sources.</p>\n<blockquote>\n<p>However, for values, you also have to do the termination proofs for the<br>\nfunctions pmatch, do_eq and pat_bindings. In summary, the following<br>\nworks in Isabelle2013-2:</p>\n<p>code_pred<br>\n  (modes: evaluate:       i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool<br>\n      and evaluate_list:  i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool<br>\n      and evaluate_match: i ⇒ i ⇒ i ⇒ i ⇒ i ⇒ i ⇒ o ⇒ bool)<br>\n  [skip_proof]<br>\n  evaluate .</p>\n<p>termination pmatch by lexicographic_order<br>\ntermination do_eq by lexicographic_order<br>\ntermination pat_bindings by lexicographic_order</p>\n</blockquote>\n<p>Great, that works like a charm. In the end, I'm probably not going to<br>\nneed the code setup, but it might be worth investigating anyway why this<br>\nfails. I don't see any special things going on here.</p>\n<p>Thanks for your help!<br>\nLars</p>",
        "id": 294283949,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921232
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Lars,</p>\n<p>I would appreciate if you invest some effort here.</p>\n<p>Just the usual warning to refrain from ad-hoc changes before a release.<br>\n Good things take their while.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/AEPD3B3Imn0gnqKHR32EjuZ8/signature.asc\">signature.asc</a></p>",
        "id": 294284020,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921250
    }
]