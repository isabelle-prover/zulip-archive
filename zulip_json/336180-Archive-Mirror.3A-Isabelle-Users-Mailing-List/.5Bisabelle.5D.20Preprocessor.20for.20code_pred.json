[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nI'm currently trying to reactivate the Execute theory of CoreC++ in the AFP. For <br>\nhistorical reasons, it defines many inductive predicates as sets, which the <br>\npredicate compiler cannot handle, but I do not want to change their definitions. <br>\nInstead, I tried to use the predicate that inductive_set internally generates. <br>\nUnfortunately, I do not know how to instruct the predicate compiler to use the <br>\ncompiled predicates instead of the sets when it compiles subsequent predicates. <br>\nI have found three attributes (code_pred_inline, code_pred_def, and <br>\ncode_pred_simp), but none of them seems to do the preprocessing that I want.</p>\n<p>Here is a small fictitious example of what happens frequently in CoreC++:</p>\n<p>inductive_set minus2 :: \"(nat * nat) set\"<br>\n   where \"n â‰¥ 2 ==&gt; (n, n - 2) : minus2\"<br>\ncode_pred (modes: i =&gt; o =&gt; bool) minus2p .</p>\n<p>abbreviation (input) minus_even :: \"nat =&gt; nat =&gt; bool\"<br>\n   where \"minus_even n m == (n, m) : minus2^*\"</p>\n<p>lemma [code_pred_def, code_pred_inline, code_pred_simp]:<br>\n   \"((n, m) : minus2^*) = minus2p^** n m\" sorry</p>\n<p>inductive test :: \"nat =&gt; nat =&gt; bool\"<br>\n   where \"minus_even n m ==&gt; test n m\"<br>\ncode_pred<br>\n   (modes: i =&gt; o =&gt; bool)<br>\n   [show_steps, show_intermediate_results, show_mode_inference]<br>\n   test<br>\n. (* Fails to infer the specified mode *)</p>\n<p>Obviously, I could derive an introduction rule for test that does not go through <br>\nthe sets. But then, I have to prove the corresponding elimination rule, which <br>\ncan become very tedious. Is there any way I can instruct the predicate compiler <br>\nto remove such detours via sets?</p>\n<p>Andreas</p>",
        "id": 294226223,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900118
    }
]