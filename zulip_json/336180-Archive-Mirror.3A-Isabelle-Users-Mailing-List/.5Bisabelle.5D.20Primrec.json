[
    {
        "content": "<p>From: Peter Chapman &lt;<a href=\"mailto:pc@cs.st-and.ac.uk\">pc@cs.st-and.ac.uk</a>&gt;<br>\nHi</p>\n<p>I have a polymorphic datatype as follows</p>\n<p>datatype 'a form:<br>\n   ff<br>\n| Cpd 'a ('a form list)</p>\n<p>I also have a function which, given a list of naturals, returns the  <br>\nlargest, called max_list.  I want to define a function on my datatype  <br>\nas follows:</p>\n<p>primrec depth  :: 'a form =&gt; nat<br>\n   depth ff = 0<br>\n   depth Cpd f fs = max_list (map depth fs) + 1</p>\n<p>Isabelle doesn't like it, giving me the error message</p>\n<p>*** Entity to be defined occurs on rhs<br>\n*** The error(s) above occurred in definition \"depth_form_def\":<br>\n***   \"depth =_ form_rec_1 (\\ i. 0) (\\ f fs fsa. max_list (map depth  <br>\nfs) + 1) 0 undefined undefined\"<br>\n*** At command \"primrec\".</p>\n<p>(where =_ is the identity symbol, and \\ is a lambda).  Is this not a  <br>\nproper recursive call?  I think it should be.  For instance, if it is  <br>\nwritten as</p>\n<p>depth Cpd f [p,...q] = max_list [depth p,..., depth q]</p>\n<p>then I think it is a recursive call.  Can anyone point out how to fix  <br>\nthis, or why I am wrong in my belief?</p>\n<p>Cheers</p>\n<p>Peter</p>",
        "id": 294072098,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827548
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nPeter Chapman wrote:<br>\nHi Peter,</p>\n<p>unfortunately, the primrec command is rather restrictive as far as the recursion<br>\nscheme of the function is concerned. More precisely, it requires that the recursion<br>\nscheme of the function exactly matches the recursion scheme of the datatype. Since<br>\nthe datatype \"'a form\" involves nested recursion through the list type constructor,<br>\nthe type of lists is \"unfolded\" when constructing the datatype, as can be seen<br>\nfrom the induction rule</p>\n<p>[| P1 ff; !!list. P2 list ==&gt; P1 (Cpd a list); P2 [];<br>\n   !!form list. [| P1 form; P2 list |] ==&gt; P2 (form # list) |] ==&gt;<br>\n   P1 form &amp; P2 list</p>\n<p>which involves two predicates P1 and P2. Consequently, primrec also expects you<br>\nto define your depth function as two mutually recursive functions, where one of<br>\nthe functions is on \"'a form\", while the other one is on \"'a form list\":</p>\n<p>primrec depth :: \"'a form =&gt; nat\" and depth_list :: \"'a form list =&gt; nat list\" where<br>\n  \"depth ff = 0\"<br>\n| \"depth (Cpd f fs) = max_list (depth_list fs) + 1\"<br>\n| \"depth_list [] = []\"<br>\n| \"depth_list (f # fs) = depth f # depth_list fs\"</p>\n<p>Alternatively, you can also use the more general \"fun\" command for defining<br>\nfunctions by well-founded recursion, which accepts your definition right away:</p>\n<p>fun depth :: \"'a form =&gt; nat\" where<br>\n  \"depth ff = 0\"<br>\n| \"depth (Cpd f fs) = max_list (map depth fs) + 1\"</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294072162,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827567
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@ipd.info.uni-karlsruhe.de\">lochbihl@ipd.info.uni-karlsruhe.de</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<p>datatype 'a form:<br>\n  ff<br>\n| Cpd 'a ('a form list)</p>\n</blockquote>\n<p>the problem is that Cpd does not take a parameter of type \"'a form\", but <br>\nthe \"'a form\" is nested inside the list type constructor. Internally, <br>\nsuch nested datatypes are converted into mutually recursive datatypes, <br>\nwhich becomes visible when you try to use primrec.</p>\n<p>If you want to use primrec, you must define mutually recursive <br>\nfunctions, i.e. the following should work:</p>\n<p>primrec depth  :: 'a form =&gt; nat and depths :: 'a form list =&gt; nat list<br>\nwhere<br>\n   depth ff = 0<br>\n| depth Cpd f fs = max_list (depths fs) + 1<br>\n| depths [] = []<br>\n| depths (x # xs) = (depth x) # (depths xs)</p>\n<p>Then, you can later on prove a lemma saying<br>\n\"depth Cpd f fs = max_list (map depth fs)\"<br>\nby induction on fs.</p>\n<p>Alternatively, you can use the function package instead of primrec, <br>\nwhich allows arbitrary pattern matchings and recursion. Since Isabelle <br>\n2008, the termination prover usually handles such primitive recursion <br>\nfor nested datatypes.</p>\n<p>Andreas</p>",
        "id": 294072192,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827579
    }
]