[
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;<br>\nFrom my previous posts you may be aware that I am still looking for <br>\nthe best possible way to do the kind of mathematical induction that <br>\nis typically taught first in a course on discrete mathematics. After <br>\nlooking over the various replies I have gotten, I would like very <br>\nmuch, for most of this, to use Int.int_ge_induct: \"?k &lt;= ?i ==&gt; ?P ?k <br>\n==&gt; (!!i. ?k &lt;= i ==&gt; ?P i ==&gt; ?P (i + 1)) ==&gt; ?P ?i\".<br>\nThis assumes that the induction variable is an int, not a nat, so <br>\ninductions starting at negative numbers can be covered, as well as <br>\nnumbers greater than zero. It can also be applied to course-of-values <br>\ninduction.<br>\nHaving made this decision, I now tried a very simple case, namely <br>\nproving by induction that if x &gt;= 0, then x &lt;= x*x. Most of what <br>\nInt.int_ge_induct is supposed to be doing seems to be working fine, <br>\nbut, at the end, I am getting the message: \"Failed to finish proof: <br>\ngoal (1 subgoal): 1. 0 &lt;= 0\". Well, it's true that (0::int) &lt;= 0 <br>\nwould be true by simp, but 0 &lt;= 0 is not (and it makes sense to me <br>\nthat it is not, since 0 might be a label, for instance). But my <br>\nquestion now is: Why am I getting 0 &lt;= 0 in that form? Here is my <br>\nproof, in which I have replaced every occurrence of 0 by (0::int), in <br>\norder to try (unsuccessfully) to stop generating a subgoal involving <br>\n0 rather than 0::int:<br>\ntheory IntInduct imports Main begin<br>\nlemma \"[|x &gt;= (0::int)|] ==&gt; (x::int) &lt;= x*x\" proof-<br>\nassume \"x &gt;= (0::int)\"<br>\nthen have 1: \"(0::int) &lt;= x\" by simp<br>\nhave 2: \"[|(0::int) &lt;= (0::int)|] ==&gt; (0::int) &lt;= (0::int)*(0::int)\" by simp<br>\nhave 3: \"!!i. (0::int) &lt;= i ==&gt; (i::int) &lt;= i*i ==&gt; (i::int)+1 &lt;= <br>\n(i+1)*(i+1)\" sorry<br>\nfrom 1 and 2 and 3 show \"(x::int) &lt;= x*x\" by (rule Int.int_ge_induct)<br>\nqed<br>\nend<br>\nI have also tried this starting with lemma fixes x::int assumes 4: <br>\n\"x &gt;= (0::int)\" shows \"x &lt;= x*x\" proof- from 4 have 1: \"(0::int) &lt;= <br>\nx\" by simp<br>\nwith the same result. -Douglas<br>\nP. S. Might there be a problem with Int.int_ge_induct having a <br>\nvariable called ?i and a (presumably different) bound variable called <br>\ni? -WDM</p>",
        "id": 294634041,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159416
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 14.04.2015 06:40, W. Douglas Maurer wrote:</p>\n<blockquote>\n<p>From my previous posts you may be aware that I am still looking for<br>\nthe best possible way to do the kind of mathematical induction that is<br>\ntypically taught first in a course on discrete mathematics. After<br>\nlooking over the various replies I have gotten, I would like very<br>\nmuch, for most of this, to use Int.int_ge_induct: \"?k &lt;= ?i ==&gt; ?P ?k<br>\n==&gt; (!!i. ?k &lt;= i ==&gt; ?P i ==&gt; ?P (i + 1)) ==&gt; ?P ?i\".<br>\nThis assumes that the induction variable is an int, not a nat, so<br>\ninductions starting at negative numbers can be covered, as well as<br>\nnumbers greater than zero. It can also be applied to course-of-values<br>\ninduction.<br>\nHaving made this decision, I now tried a very simple case, namely<br>\nproving by induction that if x &gt;= 0, then x &lt;= x*x. Most of what<br>\nInt.int_ge_induct is supposed to be doing seems to be working fine,<br>\nbut, at the end, I am getting the message: \"Failed to finish proof:<br>\ngoal (1 subgoal): 1. 0 &lt;= 0\". Well, it's true that (0::int) &lt;= 0 would<br>\nbe true by simp, but 0 &lt;= 0 is not (and it makes sense to me that it<br>\nis not, since 0 might be a label, for instance).<br>\nBy default, Isabelle does not print the types (and in 2014, it also does<br>\nnot show them on hovering in the output, unfortunately), but your goal<br>\nis indeed \"(0 :: int) &lt;= 0\", so it can be discharged by simp.</p>\n</blockquote>\n<p>You get these goals, because of the way rule works, you still need to<br>\ndischarge the assumptions of 2, 3 after rule application. As you don't<br>\nneed the assumption in 2, just get rid of it. BTW, 3 is easily proved by<br>\nsimp.</p>\n<blockquote>\n<p>theory IntInduct imports Main begin<br>\nlemma \"[|x &gt;= (0::int)|] ==&gt; (x::int) &lt;= x*x\" proof-<br>\nassume \"x &gt;= (0::int)\"<br>\nthen have 1: \"(0::int) &lt;= x\" by simp<br>\nhave 2: \"[|(0::int) &lt;= (0::int)|] ==&gt; (0::int) &lt;= (0::int)*(0::int)\"<br>\nby simp<br>\nhave 3: \"!!i. (0::int) &lt;= i ==&gt; (i::int) &lt;= i*i ==&gt; (i::int)+1 &lt;=<br>\n(i+1)*(i+1)\" sorry<br>\nfrom 1 and 2 and 3 show \"(x::int) &lt;= x*x\" by (rule Int.int_ge_induct)<br>\nqed<br>\nend<br>\nThe standard way of applying this induction rule would be:</p>\n</blockquote>\n<p>lemma<br>\n  fixes x :: int<br>\n  assumes \"0 ≤ x\"<br>\n  shows \"x ≤ x * x\"<br>\n  using assms<br>\nproof (induct x rule: Int.int_ge_induct)<br>\n  case base then show ?case by simp<br>\nnext<br>\n  case (step i) then show ?case by simp<br>\nqed</p>\n<p>or -- if you prefer to spell out assumptions and conclusions (which I<br>\nguess makes sense for teaching):</p>\n<p>lemma<br>\n  fixes x :: int<br>\n  assumes \"0 ≤ x\"<br>\n  shows \"x ≤ x * x\"<br>\n  using assms<br>\nproof (induct x rule: Int.int_ge_induct)<br>\n  show \"(0 :: int) ≤ 0 * 0\" by simp<br>\nnext<br>\n  fix i :: int<br>\n  assume \"0 ≤ i\" \"i ≤ i * i\"<br>\n  then show \"i + 1 ≤ (i + 1) * (i + 1)\"<br>\n    by simp<br>\nqed</p>\n<p>Even if you don't want your students to use the induct method, I would<br>\nstill suggest to use a structured proof:</p>\n<p>lemma<br>\n  fixes x :: int<br>\n  assumes \"0 ≤ x\"<br>\n  shows \"x ≤ x * x\"<br>\n  using assms<br>\nproof (rule Int.int_ge_induct)<br>\n  show \"(0 :: int) ≤ 0 * 0\" by simp<br>\nnext<br>\n  fix i :: int<br>\n  assume \"0 ≤ i\" \"i ≤ i * i\"<br>\n  then show \"i + 1 ≤ (i + 1) * (i + 1)\"<br>\n    by simp<br>\nqed</p>\n<p>Which looks almost the same here as the one using the induction method.<br>\nBut this will change once the goals get more complex.</p>\n<blockquote>\n<p>P. S. Might there be a problem with Int.int_ge_induct having a<br>\nvariable called ?i and a (presumably different) bound variable called<br>\ni? -WDM<br>\nNo :)</p>\n</blockquote>\n<p>-- Lars</p>",
        "id": 294634067,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159428
    },
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;</p>\n<blockquote>\n<p>Message: 7<br>\nDate: Tue, 14 Apr 2015 07:40:33 +0200<br>\nFrom: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nSubject: Re: [isabelle] Problem with Int.int_ge_induct<br>\nTo: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nMessage-ID: &lt;<a href=\"mailto:552CA851.7000501@in.tum.de\">552CA851.7000501@in.tum.de</a>&gt;<br>\nContent-Type: text/plain; charset=UTF-8</p>\n<p>On 14.04.2015 06:40, W. Douglas Maurer wrote:</p>\n<blockquote>\n<p>From my previous posts you may be aware that I am still looking for<br>\n the best possible way to do the kind of mathematical induction that is<br>\n typically taught first in a course on discrete mathematics. After<br>\n looking over the various replies I have gotten, I would like very<br>\n much, for most of this, to use Int.int_ge_induct: \"?k &lt;= ?i ==&gt; ?P ?k<br>\n ==&gt; (!!i. ?k &lt;= i ==&gt; ?P i ==&gt; ?P (i + 1)) ==&gt; ?P ?i\".<br>\n This assumes that the induction variable is an int, not a nat, so<br>\n inductions starting at negative numbers can be covered, as well as<br>\n numbers greater than zero. It can also be applied to course-of-values<br>\n induction.<br>\n Having made this decision, I now tried a very simple case, namely<br>\n proving by induction that if x &gt;= 0, then x &lt;= x*x. Most of what<br>\n Int.int_ge_induct is supposed to be doing seems to be working fine,<br>\n but, at the end, I am getting the message: \"Failed to finish proof:<br>\n goal (1 subgoal): 1. 0 &lt;= 0\". Well, it's true that (0::int) &lt;= 0 would<br>\n be true by simp, but 0 &lt;= 0 is not (and it makes sense to me that it<br>\n is not, since 0 might be a label, for instance).<br>\nBy default, Isabelle does not print the types (and in 2014, it also does<br>\nnot show them on hovering in the output, unfortunately), but your goal<br>\nis indeed \"(0 :: int) &lt;= 0\",</p>\n</blockquote>\n</blockquote>\n<p>How can I tell that the rule involves (0 :: int)? Is there some <br>\nconstruction in Isar that I can use, to find this out?</p>\n<blockquote>\n<p>so it can be discharged by simp.</p>\n</blockquote>\n<p>I tried discharging this by writing:<br>\nhave 5: \"(0 :: int) &lt;= 0\" by simp<br>\nI tried this just before, and also just after, the step starting with <br>\n\"from 1 and 2 and 3\". In both cases I still get the same message on <br>\n\"by (rule Int.int_ge_induct)\", namely<br>\nFailed to finish proof: goal (1 subgoal): 1. 0 &lt;= 0<br>\nAm I misunderstanding what \"discharged\" means?</p>\n<blockquote>\n<p>You get these goals, because of the way rule works, you still need to<br>\ndischarge the assumptions of 2, 3 after rule application. As you don't<br>\nneed the assumption in 2, just get rid of it. BTW, 3 is easily proved by<br>\nsimp.</p>\n<blockquote>\n<p>theory IntInduct imports Main begin<br>\n lemma \"[|x &gt;= (0::int)|] ==&gt; (x::int) &lt;= x*x\" proof-<br>\n assume \"x &gt;= (0::int)\"<br>\n then have 1: \"(0::int) &lt;= x\" by simp<br>\n have 2: \"[|(0::int) &lt;= (0::int)|] ==&gt; (0::int) &lt;= (0::int)*(0::int)\"<br>\n by simp<br>\n have 3: \"!!i. (0::int) &lt;= i ==&gt; (i::int) &lt;= i*i ==&gt; (i::int)+1 &lt;=<br>\n (i+1)*(i+1)\" sorry<br>\n from 1 and 2 and 3 show \"(x::int) &lt;= x*x\" by (rule Int.int_ge_induct)<br>\n qed<br>\n end<br>\nThe standard way of applying this induction rule would be:</p>\n</blockquote>\n<p>lemma<br>\n  fixes x :: int<br>\n  assumes \"0 ? x\"<br>\n  shows \"x ? x * x\"<br>\n  using assms</p>\n</blockquote>\n<p>I've never needed \"using assms\" before, and its position in this <br>\nproof confuses me. \"Programming and Proving in Isabelle/HOL\" <br>\n(prog_prove) states (p. 43): \"There are two further linguistic <br>\nvariations: (have|show) prop using facts = from facts (have|show) <br>\nprop...The 'using' idiom de-emphasizes the used facts by moving them <br>\nbehind the proposition.\" This, however, is for \"using\" within a <br>\nproof, not before the word \"proof.\" Then (pp. 43-44), <br>\nfixes-assumes-shows is introduced, with the meaning of assms; but <br>\nthere is no reference here to \"using\" immediately after <br>\nfixes-assumes-shows and before \"proof.\" No further occurrences of <br>\n\"using\" in prog_prove involve \"using\" before the word \"proof.\" Is <br>\nthere a better writeup which explains this?</p>\n<blockquote>\n<p>proof (induct x rule: Int.int_ge_induct)<br>\n  case base then show ?case by simp</p>\n</blockquote>\n<p>In this particular proof, the base case is the case \"x=0\". However, <br>\nInt.int_ge_induct also works for proofs with other base cases. If I <br>\nwere to prove something with base case \"x=1\", would I still be able <br>\nto write \"case base then show\" here? Or would I write something <br>\nslightly different? Or would I have to spell out assumptions and <br>\nconclusions, as you have done below?</p>\n<blockquote>\n<p>next<br>\n  case (step i) then show ?case by simp<br>\nqed</p>\n</blockquote>\n<p>You appear, here, to be making use of \"base\" and \"step\" as what I <br>\nbelieve are called minor keywords within the case construction. Where <br>\nare minor keywords (if that's what they're called) defined?</p>\n<blockquote>\n<p>or -- if you prefer to spell out assumptions and conclusions (which I<br>\nguess makes sense for teaching):</p>\n<p>lemma<br>\n  fixes x :: int<br>\n  assumes \"0 ? x\"<br>\n  shows \"x ? x * x\"<br>\n  using assms<br>\nproof (induct x rule: Int.int_ge_induct)<br>\n  show \"(0 :: int) ? 0 * 0\" by simp<br>\nnext<br>\n  fix i :: int<br>\n  assume \"0 ? i\" \"i ? i * i\"<br>\n  then show \"i + 1 ? (i + 1) * (i + 1)\"<br>\n    by simp<br>\nqed</p>\n</blockquote>\n<p>(snip)</p>\n<blockquote>\n<p>-- Lars<br>\n</p>\n</blockquote>\n<p>Thanks! -Douglas</p>",
        "id": 294634371,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159533
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 16.04.2015 04:41, W. Douglas Maurer wrote:</p>\n<blockquote>\n<blockquote>\n<p>Message: 7<br>\nDate: Tue, 14 Apr 2015 07:40:33 +0200<br>\nFrom: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nSubject: Re: [isabelle] Problem with Int.int_ge_induct<br>\nTo: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nMessage-ID: &lt;<a href=\"mailto:552CA851.7000501@in.tum.de\">552CA851.7000501@in.tum.de</a>&gt;<br>\nContent-Type: text/plain; charset=UTF-8</p>\n</blockquote>\n<p>On 14.04.2015 06:40, W. Douglas Maurer wrote:</p>\n<blockquote>\n<blockquote>\n<p>From my previous posts you may be aware that I am still looking for<br>\n the best possible way to do the kind of mathematical induction that is<br>\n typically taught first in a course on discrete mathematics. After<br>\n looking over the various replies I have gotten, I would like very<br>\n much, for most of this, to use Int.int_ge_induct: \"?k &lt;= ?i ==&gt; ?P ?k<br>\n ==&gt; (!!i. ?k &lt;= i ==&gt; ?P i ==&gt; ?P (i + 1)) ==&gt; ?P ?i\".<br>\n This assumes that the induction variable is an int, not a nat, so<br>\n inductions starting at negative numbers can be covered, as well as<br>\n numbers greater than zero. It can also be applied to course-of-values<br>\n induction.<br>\n Having made this decision, I now tried a very simple case, namely<br>\n proving by induction that if x &gt;= 0, then x &lt;= x*x. Most of what<br>\n Int.int_ge_induct is supposed to be doing seems to be working fine,<br>\n but, at the end, I am getting the message: \"Failed to finish proof:<br>\n goal (1 subgoal): 1. 0 &lt;= 0\". Well, it's true that (0::int) &lt;= 0 would<br>\n be true by simp, but 0 &lt;= 0 is not (and it makes sense to me that it<br>\n is not, since 0 might be a label, for instance).<br>\nBy default, Isabelle does not print the types (and in 2014, it also does<br>\nnot show them on hovering in the output, unfortunately), but your goal<br>\nis indeed \"(0 :: int) &lt;= 0\",</p>\n</blockquote>\n</blockquote>\n<p>How can I tell that the rule involves (0 :: int)? Is there some<br>\nconstruction in Isar that I can use, to find this out?<br>\nIn Isabelle 2015, you will be able to see the types of constants by<br>\nhovering over them. In Isabelle 2014, this is hard to see. To get a<br>\nhint, replace</p>\n</blockquote>\n<p>by (rule ...)</p>\n<p>by</p>\n<p>apply (rule ...)<br>\n   using [[show_consts]]</p>\n<p>This will give you a list of all constants with their types.</p>\n<blockquote>\n<blockquote>\n<p>so it can be discharged by simp.</p>\n</blockquote>\n<p>I tried discharging this by writing:<br>\nhave 5: \"(0 :: int) &lt;= 0\" by simp<br>\nI tried this just before, and also just after, the step starting with<br>\n\"from 1 and 2 and 3\". In both cases I still get the same message on<br>\n\"by (rule Int.int_ge_induct)\", namely<br>\nFailed to finish proof: goal (1 subgoal): 1. 0 &lt;= 0<br>\nAm I misunderstanding what \"discharged\" means?<br>\nYou are misunderstanding how \"rule\" works, I think. When used with<br>\nchained facts (this is what \"from 1 and 2 and 3\" does -- it chains the<br>\nfacts 1, 2, 3), it uses the first fact to discharge the first premise of<br>\nthe rule, the second for the second and so on.</p>\n</blockquote>\n<p>When you use a fact \"A1 ==&gt; ... ==&gt; Am ==&gt; B\" to discharge a premise \"C1<br>\n==&gt; ... ==&gt; Cn ==&gt; B\", you will get m new subgoals, you need to prove:</p>\n<p>\"C1 ==&gt; ... ==&gt; Cn ==&gt; A1\"<br>\n    ...<br>\n    \"C1 ==&gt; ... ==&gt; Cn ==&gt; Am\".</p>\n<p>Let's have a look at your proof again:</p>\n<p>assume \"x &gt;= (0::int)\"<br>\n    then have 1: \"(0::int) &lt;= x\" by simp<br>\n    have 2: \"[|(0::int) &lt;= (0::int)|] ==&gt; (0::int) &lt;= (0::int)*(0::int)\"<br>\nby simp<br>\n    have 3: \"!!i. (0::int) &lt;= i ==&gt; (i::int) &lt;= i*i ==&gt; (i::int)+1 &lt;=<br>\n(i+1)*(i+1)\" sorry<br>\n    from 1 and 2 and 3 show \"(x::int) &lt;= x*x\" by (rule Int.int_ge_induct)</p>\n<p>The rule Int.int_ge_induct has three premises, you are chaining in three<br>\nfacts. The first fact has no premise, so no new subgoal arises for that.<br>\nThe second fact has one premise, \"(0::int) &lt;= (0::int)\" and the second<br>\npremise of Int.int_ge_induct has no premises. This gives you one new subgoal</p>\n<p>(0::int) &lt;= (0::int)            (which Isabelle prints as 0 ≤ 0)</p>\n<p>Similarly, from the third fact and premise arise the subgoals</p>\n<p>⋀i. 0 ≤ i ⟹ i ≤ i * i ⟹ 0 ≤ i<br>\n  ⋀i. 0 ≤ i ⟹ i ≤ i * i ⟹ i ≤ i * i</p>\n<p>Rule is a basic tool and does nothing more then combining the chained<br>\nfacts with the given rule in the way I described above and apply this to<br>\nthe goal. In particular, it does not pick up any other facts you may<br>\nhave proven before.</p>\n<p>You can see these three subgoals if you write \"apply (rule<br>\nInt.int_ge_induct)\" instead of \"by (rule Int.int_ge_induct)\".</p>\n<p>So, why does your proof \"by (rule Int.int_ge_induct)\" complain only<br>\nabout the subgoal \"0 ≤ 0\" and not the other subgoals? This is because<br>\nthe \"by\" tries to solve any remaining subgoals with \"assumption\" and<br>\nthis obviously succeeds for the subgoals 2 and 3.</p>\n<p>So, that being explained, how can you fix your proof (without rewriting<br>\nit completely)? \"by\" can take two proof methods: an initial step to<br>\ntransform the goal and a second step to finish the remaining subgoals.<br>\nIn your case, simp (or simp_all) suffices:</p>\n<p>by (rule Int.int_ge_induct) simp_all</p>\n<blockquote>\n<blockquote>\n<p>You get these goals, because of the way rule works, you still need to<br>\ndischarge the assumptions of 2, 3 after rule application. As you don't<br>\nneed the assumption in 2, just get rid of it. BTW, 3 is easily proved by<br>\nsimp.</p>\n<blockquote>\n<p>theory IntInduct imports Main begin<br>\n lemma \"[|x &gt;= (0::int)|] ==&gt; (x::int) &lt;= x*x\" proof-<br>\n assume \"x &gt;= (0::int)\"<br>\n then have 1: \"(0::int) &lt;= x\" by simp<br>\n have 2: \"[|(0::int) &lt;= (0::int)|] ==&gt; (0::int) &lt;= (0::int)*(0::int)\"<br>\n by simp<br>\n have 3: \"!!i. (0::int) &lt;= i ==&gt; (i::int) &lt;= i*i ==&gt; (i::int)+1 &lt;=<br>\n (i+1)*(i+1)\" sorry<br>\n from 1 and 2 and 3 show \"(x::int) &lt;= x*x\" by (rule Int.int_ge_induct)<br>\n qed<br>\n end<br>\nThe standard way of applying this induction rule would be:</p>\n</blockquote>\n<p>lemma<br>\n  fixes x :: int<br>\n  assumes \"0 &lt;= x\"<br>\n  shows \"x &lt;= x * x\"<br>\n  using assms</p>\n</blockquote>\n<p>I've never needed \"using assms\" before, and its position in this proof<br>\nconfuses me. \"Programming and Proving in Isabelle/HOL\" (prog_prove)<br>\nstates (p. 43): \"There are two further linguistic variations:<br>\n(have|show) prop using facts = from facts (have|show) prop...The<br>\n'using' idiom de-emphasizes the used facts by moving them behind the<br>\nproposition.\" This, however, is for \"using\" within a proof, not before<br>\nthe word \"proof.\" Then (pp. 43-44), fixes-assumes-shows is introduced,<br>\nwith the meaning of assms; but there is no reference here to \"using\"<br>\nimmediately after fixes-assumes-shows and before \"proof.\" No further<br>\noccurrences of \"using\" in prog_prove involve \"using\" before the word<br>\n\"proof.\" Is there a better writeup which explains this?<br>\nWhile these usages may look different, they are exactly the same. All of<br>\n\"have\", \"show\" and \"lemma\" switch into proof mode. In proof mode, you can</p>\n</blockquote>\n<p>* do one-line proofs (\"by ...\"),<br>\n  * structured proofs (\"proof ... qed\"),<br>\n  * apply-style proofs (\"apply ...\"), or<br>\n  * add additional chained facts \"using ...\")-</p>\n<p>Both \"apply\" and \"using\" modify the proof state and leave you in proof mode.</p>\n<blockquote>\n<blockquote>\n<p>proof (induct x rule: Int.int_ge_induct)<br>\n  case base then show ?case by simp</p>\n</blockquote>\n<p>In this particular proof, the base case is the case \"x=0\". However,<br>\nInt.int_ge_induct also works for proofs with other base cases. If I<br>\nwere to prove something with base case \"x=1\", would I still be able to<br>\nwrite \"case base then show\" here?<br>\nYes. This is determined by the single fact you chained in.<br>\nInt.int_ge_induct is</p>\n</blockquote>\n<p>?k &lt;= ?i ==&gt; ?P ?k ==&gt; (!!i. ?k &lt;= i ==&gt; ?P i ==&gt; ?P (i + 1)) ==&gt; ?P ?i</p>\n<p>so resolving this with \"0 &lt;= x\" leaves you with</p>\n<p>\"?P 0 ==&gt; (!!i. 0 &lt;= 0 ==&gt; ?P i ==&gt; ?P (i + 1)) ==&gt; ?P ?i</p>\n<p>Had you chained in \"1 &lt;= x\", base would refer to 1 instead.</p>\n<blockquote>\n<p>You appear, here, to be making use of \"base\" and \"step\" as what I<br>\nbelieve are called minor keywords within the case construction. Where<br>\nare minor keywords (if that's what they're called) defined?<br>\nThese are no keywords, it is just what the author of the induction rule<br>\nthought the cases ought to be called.</p>\n</blockquote>\n<p>The induction method sets up cases according to some additional<br>\ninformation stored in the induction rule. To see which cases are there,<br>\nyou can type \"print_cases\" (or select \"cases\" in the \"print context\" tab<br>\nof the \"Query\" panel) after the initial \"proof (induct ...)\" step.</p>\n<p>Basically, a case is a shortcut for the fix/assume I did manually in my<br>\nexample below and sets up \"?case\" to refer to the correct goal.</p>\n<p>-- Lars</p>",
        "id": 294634407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159551
    }
]