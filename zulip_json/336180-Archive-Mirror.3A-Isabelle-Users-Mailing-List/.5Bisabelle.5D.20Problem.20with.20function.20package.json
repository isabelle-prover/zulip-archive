[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>today we stumbled over a strange behavior of the function package, which refused some very standard function definition that relies upon locally fixed parameters.</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>locale foo =<br>\n  fixes x :: nat<br>\nbegin</p>\n<p>function f :: \"nat =&gt; nat\" where<br>\n  \"f y = (if y &gt; x then f (y - 1)  else y)\"<br>\napply pat_completeness <br>\napply auto (* works and leaves no proof obligations *)<br>\ndone (* post processing of function package fails:<br>\nexception THM 0 raised (line 726 of \"thm.ML\"):<br>\n  forall_intr: variable \"x\" free in assumptions<br>\n  (⋀y. x = y ⟹ P) ⟹ P *)<br>\nend<br>\nend</p>\n<p>The above function was accepted without problems until Isabelle2013, and is refused in Isabelle2013-1/2, 2014, and also in todays repository snapshot. Perhaps it is related to the news entry for Isabelle2013-1:</p>\n<ul>\n<li>\n<p>Function package: For each function f, new rules f.elims are<br>\ngenerated, which eliminate equalities of the form \"f x = t\".</p>\n</li>\n<li>\n<p>New command 'fun_cases' derives ad-hoc elimination rules for<br>\nfunction equations as simplified instances of f.elims, analogous to<br>\ninductive_cases.  See ~~/src/HOL/ex/Fundefs.thy for some examples.</p>\n</li>\n</ul>\n<p>Kind regards,<br>\nChristian, Florian, and René</p>",
        "id": 294325587,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928434
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nOh dear. This looks like something I am probably responsible for. I<br>\nshall look into it in the next few days.</p>\n<p>My first guess would be that it has something to do with my very poor<br>\nunderstanding of contexts.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294325603,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928440
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nI mae a first analysis</p>\n<p>in function_elims.ML</p>\n<blockquote>\n<p>fun mk_funeq 0 T (acc_vars, acc_lhs) =<br>\n              let val y = Free(\"y\", T)<br>\n              in (y :: acc_vars, (HOLogic.mk_Trueprop (HOLogic.mk_eq<br>\n(acc_lhs, y))), T) end<br>\n          | mk_funeq n (Type (@{type_name \"fun\"}, [S, T])) (acc_vars,<br>\nacc_lhs) =<br>\n              let val xn = Free (\"x\" ^ Int.toString n, S)<br>\n              in mk_funeq (n - 1) T (xn :: acc_vars, acc_lhs $ xn) end<br>\n          | mk_funeq _ _ _ = raise TERM (\"Not a function.\", [f]);</p>\n</blockquote>\n<p>This looks suspicious since you cannot assume that \"x\\d\" and \"y\" are<br>\nfresh.  You should use a pattern like</p>\n<p>Name.variant \"x\" (Proof_Context.names_of ctxt)</p>\n<p>Hope this helps,<br>\n    Florian</p>\n<p>Am 27.01.2015 um 18:59 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>Oh dear. This looks like something I am probably responsible for. I<br>\nshall look into it in the next few days.</p>\n<p>My first guess would be that it has something to do with my very poor<br>\nunderstanding of contexts.</p>\n<p>Cheers,<br>\nManuel</p>\n<p>On 27/01/15 18:34, René Thiemann wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>today we stumbled over a strange behavior of the function package, which refused some very standard function definition that relies upon locally fixed parameters.</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>locale foo =<br>\n  fixes x :: nat<br>\nbegin</p>\n<p>function f :: \"nat =&gt; nat\" where<br>\n  \"f y = (if y &gt; x then f (y - 1)  else y)\"<br>\napply pat_completeness <br>\napply auto (* works and leaves no proof obligations *)<br>\ndone (* post processing of function package fails:<br>\nexception THM 0 raised (line 726 of \"thm.ML\"):<br>\n  forall_intr: variable \"x\" free in assumptions<br>\n  (⋀y. x = y ⟹ P) ⟹ P *)<br>\nend<br>\nend</p>\n<p>The above function was accepted without problems until Isabelle2013, and is refused in Isabelle2013-1/2, 2014, and also in todays repository snapshot. Perhaps it is related to the news entry for Isabelle2013-1:</p>\n<ul>\n<li>\n<p>Function package: For each function f, new rules f.elims are<br>\ngenerated, which eliminate equalities of the form \"f x = t\".</p>\n</li>\n<li>\n<p>New command 'fun_cases' derives ad-hoc elimination rules for<br>\nfunction equations as simplified instances of f.elims, analogous to<br>\ninductive_cases.  See ~~/src/HOL/ex/Fundefs.thy for some examples.</p>\n</li>\n</ul>\n<p>Kind regards,<br>\nChristian, Florian, and René</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/zD0ipd0tllCyPhRGkO033GTY/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294325627,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928446
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThe issue was actually not the one you highlighted, but another instance<br>\nof the same problem in mutual.ML.</p>\n<p>I fixed all the occurrences of this problem in the function package and<br>\neverything seems to be running smoothly now. I already pushed the bug fix.</p>\n<p>Thanks for your analysis and telling me how to fix it.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294325678,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928466
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust from to wording of it, is a dangerous claim to have \"fixed\" \"all\" <br>\n\"bugs\".  It is important to develop a sense of realism of what a change <br>\nreally does. The Isabelle mailing lists are full of postings of myself, <br>\nwhere I try to explain that over and over again.</p>\n<p>In particular it does not make any sense to produe Isabelle changesets <br>\n\"like fixed bug\" -- some actual information needs to be put into a <br>\nchangelog.</p>\n<p>Here is some general information on Isabelle development:</p>\n<p>* README_REPOSITORY</p>\n<p>* The \"implementation\" manual, esp. chapter 0 and chapter 1 as a start.</p>\n<p>* Existing examples that are known to be done properly.</p>\n<p>Makarius</p>",
        "id": 294325698,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928471
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Just from to wording of it, is a dangerous claim to have \"fixed\" \"all\"<br>\n\"bugs\".<br>\nThat is not what I said. I said I fixed all occurrences of _this one<br>\nclass_ of bug in the function package, i.e. choosing fixed names for<br>\nvariables that may not be fresh in the given context. I am reasonably<br>\nsure that I caught them all, seeing as I am the one who introduced them.<br>\nNot 100% sure, but reasonably so.</p>\n</blockquote>\n<p>I would have put information in a change log if I had found such a<br>\nchange log. The only thing I was aware of was the NEWS file, but that<br>\ndid not seem a suitable place. Where /am/ I supposed to describe the<br>\nchange? The top of the changed file itself?</p>\n<p>I did read most of the information you suggested, but could not find any<br>\nreference of where to describe such changes.</p>\n<p>Manuel</p>",
        "id": 294325717,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928477
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 28 Jan 2015, Manuel Eberl wrote:</p>\n<blockquote>\n<p>I would have put information in a change log if I had found such a <br>\nchange log.</p>\n</blockquote>\n<p>The changlog is what you write as commit message.  It ends up in the <br>\npersistent and immutable history, which is the main documentation of the <br>\nongoing Isabelle development process.  README_REPOSITORY tries to explain <br>\nall that a bit.</p>\n<p>Such history entries are essential for future archeaological diggings, <br>\nwhen new problems are exposed, usually on older attempts to \"fix bugs\". <br>\nIn such situations it is important to see what was really going on at a <br>\ncertain point of time, and what the author of a change was thinking.  So <br>\n\"fixed bug in foo\" is not informative, but is equivalent to an empty <br>\nchangelog entry.</p>\n<blockquote>\n<p>The top of the changed file itself?</p>\n</blockquote>\n<p>People did that before RCS and CVS.  We have Mercurial today, with the <br>\nhistory in the history, and the source in the source.  I.e. clearly <br>\nseparated meta-data and data.</p>\n<p>Makarius</p>",
        "id": 294325731,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928483
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThat works in many situations, but is a bit low-level.  The Variable <br>\nmodule provides canonical entry points to work with local variables, e.g. <br>\nvia Variable.variant_frees or Variable.variant_fixes.</p>\n<p>Makarius</p>",
        "id": 294325746,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928489
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Manuel,</p>\n<blockquote>\n<p>Thanks for your analysis and telling me how to fix it.</p>\n</blockquote>\n<p>well, it was no more than a rush first analysis.</p>\n<p>It is indeed best here to use the existing infrastructure in<br>\nvariable.ML, as Makarius pointed out.</p>\n<p>One technical comment:</p>\n<p>val name_ctxt = Variable.names_of ctxt<br>\n        val (free_vars, prop, ranT, name_ctxt) =<br>\n          mk_funeq arity (fastype_of f) name_ctxt ([], f);</p>\n<p>This pattern (deliberate shadowing of names) is dangerous since it is<br>\nnot robust against changed line positions.  »Not robust« in the sense<br>\nthat the compiler cannot detect such slips.</p>\n<p>There are two approaches to avoid this:</p>\n<p>a) In smooth cases, the funny combinators ||&gt;&gt; and |-&gt; (##&gt;&gt; and #-&gt;)<br>\ncan save you from mentioning sth more than once (see the Isabelle/ML<br>\nchapter in the implementation manual).</p>\n<p>b) In complex cases, this is not feasible.  Then you have to swallow the<br>\nbitter pill and give explicit indices.  Popular schemas are (foo, foo',<br>\nfoo'') for little occurrences and (foo1, foo2, foo3, …) for many<br>\noccurrences.  In extreme cases also explicit application-domain prefixes<br>\ncan be seen (cf.<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/df5dc24ca712/src/Pure/Isar/expression.ML#l857\">http://isabelle.in.tum.de/repos/isabelle/file/df5dc24ca712/src/Pure/Isar/expression.ML#l857</a>).<br>\n  Looks like a parody on ancient line-number based programming, but is<br>\nrobust against accidental position swapping.</p>\n<p>Hope this helps,<br>\n    Florian</p>\n<blockquote>\n<p>Cheers,<br>\nManuel</p>\n<p>On 28/01/15 08:26, Florian Haftmann wrote:</p>\n<blockquote>\n<p>I mae a first analysis</p>\n<p>in function_elims.ML</p>\n<blockquote>\n<p>fun mk_funeq 0 T (acc_vars, acc_lhs) =<br>\n              let val y = Free(\"y\", T)<br>\n              in (y :: acc_vars, (HOLogic.mk_Trueprop (HOLogic.mk_eq<br>\n(acc_lhs, y))), T) end<br>\n          | mk_funeq n (Type (@{type_name \"fun\"}, [S, T])) (acc_vars,<br>\nacc_lhs) =<br>\n              let val xn = Free (\"x\" ^ Int.toString n, S)<br>\n              in mk_funeq (n - 1) T (xn :: acc_vars, acc_lhs $ xn) end<br>\n          | mk_funeq _ _ _ = raise TERM (\"Not a function.\", [f]);<br>\nThis looks suspicious since you cannot assume that \"x\\d\" and \"y\" are<br>\nfresh.  You should use a pattern like</p>\n</blockquote>\n<p>Name.variant \"x\" (Proof_Context.names_of ctxt)</p>\n<p>Hope this helps,<br>\n Florian</p>\n<p>Am 27.01.2015 um 18:59 schrieb Manuel Eberl:</p>\n<blockquote>\n<p>Oh dear. This looks like something I am probably responsible for. I<br>\nshall look into it in the next few days.</p>\n<p>My first guess would be that it has something to do with my very poor<br>\nunderstanding of contexts.</p>\n<p>Cheers,<br>\nManuel<br>\n</p>\n</blockquote>\n<p>On 27/01/15 18:34, René Thiemann wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear all,</p>\n<p>today we stumbled over a strange behavior of the function package, which refused some very standard function definition that relies upon locally fixed parameters.</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>locale foo =<br>\n  fixes x :: nat<br>\nbegin</p>\n<p>function f :: \"nat =&gt; nat\" where<br>\n  \"f y = (if y &gt; x then f (y - 1)  else y)\"<br>\napply pat_completeness <br>\napply auto (* works and leaves no proof obligations *)<br>\ndone (* post processing of function package fails:<br>\nexception THM 0 raised (line 726 of \"thm.ML\"):<br>\n  forall_intr: variable \"x\" free in assumptions<br>\n  (⋀y. x = y ⟹ P) ⟹ P *)<br>\nend<br>\nend</p>\n<p>The above function was accepted without problems until Isabelle2013, and is refused in Isabelle2013-1/2, 2014, and also in todays repository snapshot. Perhaps it is related to the news entry for Isabelle2013-1:</p>\n<ul>\n<li>\n<p>Function package: For each function f, new rules f.elims are<br>\ngenerated, which eliminate equalities of the form \"f x = t\".</p>\n</li>\n<li>\n<p>New command 'fun_cases' derives ad-hoc elimination rules for<br>\nfunction equations as simplified instances of f.elims, analogous to<br>\ninductive_cases.  See ~~/src/HOL/ex/Fundefs.thy for some examples.</p>\n</li>\n</ul>\n<p>Kind regards,<br>\nChristian, Florian, and René<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/CLo6hZbMYl8h6tCe1JcuRyN3/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294325819,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928515
    }
]