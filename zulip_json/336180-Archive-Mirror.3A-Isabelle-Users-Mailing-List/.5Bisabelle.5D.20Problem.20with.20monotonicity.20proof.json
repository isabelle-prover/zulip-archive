[
    {
        "content": "<p>From: Mark Wassell &lt;<a href=\"mailto:mpwassell@gmail.com\">mpwassell@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I have a simple inductive predicate:</p>\n<p>inductive Q' :: \"nat ⇒ bool\" where<br>\nQ'0: \"Q' 0\" |<br>\nQ'n: \"List.list_all (λk. Q' k) [0..&lt;n] ⟹ Q' n\"</p>\n<p>The monotonicity proof for this fails. I take the goal from the error<br>\nwindow and prove it:</p>\n<p>lemma xx [mono]: \"mono (λp x. x = 0 ∨ (∃n. x = n ∧ list_all p [0..&lt;n]))\"<br>\nunfolding pred_list_def mono_def<br>\nproof((rule allI)+,rule impI)<br>\n  fix x and y::\"nat⇒bool\"<br>\n  assume \"x≤y\"<br>\n  show \"(λxa. xa = 0 ∨ (∃n. xa = n ∧ Ball (set [0..&lt;n]) x))<br>\n           ≤ (λx. x = 0 ∨ (∃n. x = n ∧ Ball (set [0..&lt;n]) y))\" using ‹x ≤<br>\ny› by blast<br>\nqed</p>\n<p>However the monotonicity proof for the predicate still doesn't work. It has<br>\nbeen added to the 'mono' list and if I include the line 'monos xx' after<br>\nthe inductive predicate definition, there is still no proof.</p>\n<p>The  inductive predicate</p>\n<p>inductive Q :: \"nat ⇒ bool\" where<br>\nQ0: \"Q 0\" |<br>\nQn: \"(∀k∈set[0..&lt;n]. Q k) ⟹ Q n\"</p>\n<p>is ok. I believe that Q' and Q and equivalent.</p>\n<p>Cheers</p>\n<p>Mark</p>",
        "id": 294698300,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178505
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Mark,</p>\n<p>The monotonicity prover of the inductive package requires a specific format for <br>\nmonotonicity rules. In particular, there is no point in proven the monotonicity statement <br>\nyourself and adding it.</p>\n<p>In general, you need a separate monotonicity preservation statement for every higher-order <br>\ncombinator that is apply to the inductively defined constant. For your definition of Q' <br>\nwith List.list_all, you have to prove and declare the corresponding monotonicity rule. In <br>\nthe other definition, you use bounded universal quantification, for which there is already <br>\na monotonicity rule in place.</p>\n<p>You can infer the format by looking at the goal state of the failed proof attempt. For <br>\nlist_all, the right rule is this:</p>\n<p>(!!x. P x --&gt; Q x) ==&gt; list_all P xs --&gt; list_all Q xs</p>\n<p>Monotonicity must be expressed using HOL implication and Pure quantification.</p>\n<p>Another remark: I recommend to use universal quantification instead of list_all, because <br>\nlist_all is used almost exclusively for code generation, i.e., proof automation will be <br>\nless good. In particular, the proof method induction works much better with universal <br>\nquantifiers than any other higher-order combinator.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294699010,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178554
    }
]