[
    {
        "content": "<p>From: Mattias Ulbrich &lt;<a href=\"mailto:mulbrich@ira.uka.de\">mulbrich@ira.uka.de</a>&gt;<br>\nHello everyone,</p>\n<p>I experienced problems with a HOL formalisation written for an older version <br>\nof Isabelle. It successfully makes use of several mutual inductions but I <br>\ncannot redo these proofs in Isabelle2008.</p>\n<p>The problem boils down to the observation that a mutual induction can only be <br>\nperformed if a proof obligation has at least two 'parts':</p>\n<p>----------8&lt;-------------</p>\n<p>(*   Problem with mutual induction   *)</p>\n<p>theory foobar<br>\nimports Main<br>\nbegin</p>\n<p>datatype foo = Foo bar | Empty<br>\n  and bar = Bar foo</p>\n<p>(* this works: thesis has two parts *)<br>\nlemma <br>\n  shows \"P (f::foo) (b::bar)\"<br>\n  and True<br>\napply (induct b and f)<br>\nsorry</p>\n<p>(* this does NOT work: Error message<br>\n*** empty result sequence -- proof command failed<br>\n*** At command \"apply\".<br>\n*)<br>\nlemma<br>\n  shows \"P (f::foo) (b::bar)\"<br>\napply (induct b and f)<br>\nsorry</p>\n<p>----------8&lt;-------------</p>\n<p>Is this behaviour intended? Shouldn't be the induction also possible in the <br>\nsecond case?</p>\n<p>Thank you very much for an answer!</p>\n<p>Kind regards<br>\n    Mattias</p>",
        "id": 294067659,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826004
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYes, the \"induct\" method merely assembles given induction rules in a <br>\ncertain way (that is occasionally hard to analyse when things go wrong) <br>\nexpecting that the goal structure matches the basic rule outline. Writing <br>\n(induct b and f) refers to the simultaneous rule of the corresponding <br>\nsimultaneous type.</p>\n<p>Maybe src/HOL/Induct/Common_Patterns.thy helps to get a practical grip on <br>\nhow things work.  There are further sophistications of induct in the <br>\npipeline, and there might also be some kind of interactive proof scheme <br>\nsynthesis coming at some later stage.</p>\n<p>Since \"projected inductions\" where some predicates are always True are a <br>\ncommon case, the packages that produce induction rules could do a bit <br>\nbetter in providing these additional version: foo.induct and bar.induct <br>\nwhere one part of the full foo_bar.inducts is already instantiated with <br>\nTrue.</p>\n<p>If you have a dire need for such rules you may also produce them yourself <br>\nfor your specific definitions.  The \"induct\" method will accept them when <br>\nspecified with \"rule: ...\" for example.</p>\n<p>Makarius</p>",
        "id": 294067664,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826009
    }
]