[
    {
        "content": "<p>From: Sven Schneider &lt;<a href=\"mailto:svens@cs.tu-berlin.de\">svens@cs.tu-berlin.de</a>&gt;<br>\nHello mailinglist</p>\n<p>I have a problem defining a mutually recursive primrec. My problem is of <br>\ncourse more complex than the examples below. They are reduced versions.</p>\n<p>_section_ 1<br>\n    In this example it becomes obvious that primrec has a problem with case <br>\nand option.</p>\n<p>_section_ 2<br>\n    In this example the same code as before is used but the fun (instead of <br>\nthe primrec) is capable to proof the termination.</p>\n<p>_section_ 3<br>\n    In this example the problem is more close to my problem and the primrec <br>\ndoes not get the calls right. f1 and f2 indeed have calls to each other, <br>\ntherefore they should be at least mutually recursive... The message is a <br>\nbit confusion in my opinion. At least if the real problem is that the <br>\nprimrec again cannot 'proof' termination.</p>\n<p>_section_ 4<br>\n    This example shows that f1 and f2 (defined as in section 3) depend on <br>\neach other... This seems to be a contradiction to me.<br>\nIt seems that 'mutually recursive iff circular dependent' is incorrect <br>\n(of course more than mutually recursion is necessary to be able to <br>\ndefine a terminating function)?</p>\n<p>_section_ 5<br>\n    Using functions instead does not solve the problem. A termination <br>\nargument is not found automaticly. Attempts to do it manually didn't <br>\nresolve the problem.</p>\n<p>_Questions_<br>\nIf you haven't yet extracted any questions ;-) here they are:<br>\n1) What is the problem of the primrec exactly that the fun can resolve <br>\n(section 1+2)?<br>\n2) How to prove termination and finish the definition in section 3-5?</p>\n<p>Bye,<br>\nSven</p>\n<p>_CODE_</p>\n<p>theory test<br>\nimports Main begin</p>\n<p>datatype phi2 =<br>\n   Fin<br>\n   | Con \"phi2 option\"</p>\n<p>section {* 1: f0 should be primrec but isn't. *}<br>\n(*<br>\nconsts<br>\n   f0:: \"phi2 \\&lt;Rightarrow&gt; phi2\"<br>\nprimrec<br>\n   \"f0 Fin = Fin\"<br>\n   \"f0 (Con x) = (case x of None \\&lt;Rightarrow&gt; Fin | (Some y) <br>\n\\&lt;Rightarrow&gt; Con (Some(f0 y)))\"<br>\n*)<br>\n(*<br>\n*** Entity to be defined occurs on rhs<br>\n*** The error(s) above occurred in definition \"f0_phi2_def\":<br>\n***   \"f0 \\&lt;equiv&gt; phi2_rec_1 Fin (\\&lt;lambda&gt;x xa. case x of None <br>\n\\&lt;Rightarrow&gt; Fin | Some y \\&lt;Rightarrow&gt; Con (Some (f0 y))) undefined <br>\nundefined\"<br>\n*** At command \"primrec\".<br>\n*)</p>\n<p>section {* 2: f3 (which is 'equal' to f0) is a function though. *}<br>\nfun f3:: \"phi2 \\&lt;Rightarrow&gt; phi2\"<br>\nwhere<br>\n    \"f3 Fin = Fin\"<br>\n|  \"f3 (Con x) = (case x of None \\&lt;Rightarrow&gt; Fin | (Some y) <br>\n\\&lt;Rightarrow&gt; Con (Some(f3 y)))\"</p>\n<p>section {* 3: f1,f2 call each other but they are not mutually recursive <br>\n(primrecs).*}<br>\n(*<br>\nconsts<br>\n   f1 :: \"phi2 \\&lt;Rightarrow&gt; phi2\"<br>\n   f2 :: \"phi2 option \\&lt;Rightarrow&gt; phi2 option\"<br>\nprimrec<br>\n   \"f1 Fin = Fin\"<br>\n   \"f1 (Con f) = Con (case f of None \\&lt;Rightarrow&gt; None | Some x <br>\n\\&lt;Rightarrow&gt; f2 (Some x))\"<br>\n   \"f2 None = None\"<br>\n   \"f2 (Some a) = Some (f1 a)\"<br>\n*)<br>\n(*<br>\n*** Primrec definition error:<br>\n*** functions \"test.f1\", \"test.f2\"<br>\n*** are not mutually recursive<br>\n*** At command \"primrec\".<br>\n*)</p>\n<p>section {* 4: f1,f2 call each other, they are not mutually recursive but <br>\nthere is a circular dependency between them.*}<br>\n(*<br>\nconsts<br>\n   f1 :: \"phi2 \\&lt;Rightarrow&gt; phi2\"<br>\n   f2 :: \"phi2 option \\&lt;Rightarrow&gt; phi2 option\"<br>\nprimrec<br>\n   \"f1 Fin = Fin\"<br>\n   \"f1 (Con f) = Con (case f of None \\&lt;Rightarrow&gt; None | Some x <br>\n\\&lt;Rightarrow&gt; f2 (Some x))\"<br>\nprimrec<br>\n   \"f2 None = None\"<br>\n   \"f2 (Some a) = Some (f1 a)\"<br>\n*)<br>\n(*<br>\n*** Circular dependency of constant test.f1 -&gt; test.f1<br>\n*** The error(s) above occurred in definition \"f2_option_def\":<br>\n***   \"f2 \\&lt;equiv&gt; option_rec None (\\&lt;lambda&gt;a. Some (f1 a))\"<br>\n*** At command \"primrec\".<br>\n*)</p>\n<p>section {* 5: f1,f2 call each other but no termination argument is found.*}<br>\n(*<br>\nfun<br>\n      f1 :: \"phi2 \\&lt;Rightarrow&gt; phi2\"<br>\nand  f2 :: \"phi2 option \\&lt;Rightarrow&gt; phi2 option\"<br>\nwhere<br>\n    \"f1 Fin = Fin\"<br>\n|  \"f1 (Con f) = Con (case f of None \\&lt;Rightarrow&gt; None | Some x <br>\n\\&lt;Rightarrow&gt; f2 (Some x))\"<br>\n|  \"f2 None = None\"<br>\n|  \"f2 (Some a) = Some (f1 a)\"<br>\n*)<br>\n(*<br>\n*** Unfinished subgoals: (..)<br>\n*)</p>\n<p>end</p>",
        "id": 294058407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822537
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nSven,</p>\n<blockquote>\n<p>datatype phi2 =<br>\n  Fin<br>\n  | Con \"phi2 option\"</p>\n</blockquote>\n<p>Your datatype has nested recursion: The recursive occurrence occurs <br>\nunder the \"option\" type. Isabelle internally expresses this with a <br>\nmutual recursion and requires you to express your primrecs with mutual <br>\nrecursion of a certain fixed form. The funny error messages you are <br>\ngetting are because you are not following that schema.</p>\n<p>Section 3.4.2 in the Tutorial describes nested recursion of datatypes, <br>\nand primrecs about such types.</p>\n<p>The \"fun\" command is much more liberal about the form of the <br>\ndefinitions, but proving termination can be an issue.</p>\n<blockquote>\n<p>section {* 3: f1,f2 call each other but they are not mutually recursive <br>\n(primrecs).*}<br>\n(*<br>\nconsts<br>\n  f1 :: \"phi2 \\&lt;Rightarrow&gt; phi2\"<br>\n  f2 :: \"phi2 option \\&lt;Rightarrow&gt; phi2 option\"<br>\nprimrec<br>\n  \"f1 Fin = Fin\"<br>\n  \"f1 (Con f) = Con (case f of None \\&lt;Rightarrow&gt; None | Some x <br>\n\\&lt;Rightarrow&gt; f2 (Some x))\"<br>\n  \"f2 None = None\"<br>\n  \"f2 (Some a) = Some (f1 a)\"</p>\n</blockquote>\n<p>Obviously they <em>are</em> mutually recursive, but primrec is confused because <br>\nyou are not following the schema: \"f1 (Con f)\" should call \"f2 f\".</p>\n<blockquote>\n<p>section {* 4: f1,f2 call each other, they are not mutually recursive but <br>\nthere is a circular dependency between them.*}</p>\n</blockquote>\n<p>The same, but the confusion is slightly different, so you get a <br>\ndifferent error (from a different component of the system).</p>\n<blockquote>\n<p>section {* 5: f1,f2 call each other but no termination argument is found.*}<br>\n(*<br>\nfun<br>\n     f1 :: \"phi2 \\&lt;Rightarrow&gt; phi2\"<br>\nand  f2 :: \"phi2 option \\&lt;Rightarrow&gt; phi2 option\"<br>\nwhere<br>\n   \"f1 Fin = Fin\"<br>\n|  \"f1 (Con f) = Con (case f of None \\&lt;Rightarrow&gt; None | Some x <br>\n\\&lt;Rightarrow&gt; f2 (Some x))\"<br>\n|  \"f2 None = None\"<br>\n|  \"f2 (Some a) = Some (f1 a)\"<br>\n*)</p>\n</blockquote>\n<p>The automatic termination prover does not deal very well with nested <br>\ndatatypes yet. Section 4 of the (separate) tutorial on functions <br>\nexplains how to do termination proofs manually. You should also read <br>\nSection 5 about mutual recursive functions.</p>\n<p>Hope this helps</p>\n<p>Alex</p>",
        "id": 294058454,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822557
    }
]