[
    {
        "content": "<p>From: Vaidas Gasiunas &lt;<a href=\"mailto:gasiunas@st.informatik.tu-darmstadt.de\">gasiunas@st.informatik.tu-darmstadt.de</a>&gt;<br>\nHello,</p>\n<p>Most of my Isabelle/Isar proofs are based on induction, and sometimes I<br>\nhave problems when extracting the premises of the current inductive case,<br>\nsomething like:</p>\n<p>lemma \"?Q xs ==&gt; ?P xs\"<br>\nproof (induct xs)<br>\n  case (Cons x xs) hence \"?Q xs\" by auto ...</p>\n<p>Sometimes I can extract the premises with \".\", but in the most of cases I<br>\nneed to apply \"auto\". However, even this method is some cases does not<br>\nwork. I attached a small test case which does not work. I use the build of<br>\n2006 Sep 12. Am I doing something wrong? If not, is there any workaround<br>\nfor this?</p>\n<p>Greetings,<br>\nVaidas<br>\n<a href=\"/user_uploads/14278/JxUXOxDWnx9oMp051CYeBHx5/Test.thy\">Test.thy</a></p>",
        "id": 294041691,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815574
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sat, 16 Sep 2006, Vaidas Gasiunas wrote:</p>\n<blockquote>\n<p>I have problems when extracting the premises of the current inductive <br>\ncase, something like:</p>\n<p>lemma \"?Q xs ==&gt; ?P xs\"<br>\nproof (induct xs)<br>\n  case (Cons x xs) hence \"?Q xs\" by auto ...</p>\n<p>Sometimes I can extract the premises with \".\", but in the most of cases I<br>\nneed to apply \"auto\".</p>\n</blockquote>\n<p>Here the facts stemming from the Cons case consist of several things <br>\nsimultaneously.  The auto method silently ignores unused facts, while <br>\nsingle-step methods insist on being more thourough.  This means a \".\" <br>\nproof has to be able to apply all given facts, which fails in the above <br>\napplication.</p>\n<p>You can try something like this to specify facts more precisely:</p>\n<p>from Cons.hyps have \"...\" .</p>\n<p>Another option is to retrieve premises out of the blue:</p>\n<p>have \"...\" .</p>\n<blockquote>\n<p>I use the build of 2006 Sep 12.</p>\n</blockquote>\n<p>In that case you might want to read the NEWS file, which explains a few <br>\nadditions to the induction setup, including common proof patterns.  In <br>\nparticular, the above from/have/. invocation can be replaced by</p>\n<p>from <code>...</code></p>\n<p>Note that your example in Test.thy will need a type constraint of<br>\n\"!!ys :: 'a list. ...\" here.  This may change eventually, when the <code>...</code> <br>\nnotation becomes polymorphic.</p>\n<p>Makarius</p>",
        "id": 294041742,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815601
    },
    {
        "content": "<p>From: Vaidas Gasiunas &lt;<a href=\"mailto:gasiunas@informatik.tu-darmstadt.de\">gasiunas@informatik.tu-darmstadt.de</a>&gt;</p>\n<blockquote>\n<p>Here the facts stemming from the Cons case consist of several things<br>\nsimultaneously.  The auto method silently ignores unused facts, while<br>\nsingle-step methods insist on being more thourough.  This means a \".\"<br>\nproof has to be able to apply all given facts, which fails in the <br>\nabove<br>\napplication.</p>\n<p>You can try something like this to specify facts more precisely:</p>\n<p>from Cons.hyps have \"...\" .</p>\n</blockquote>\n<p>I have tried following in my example:</p>\n<p>from Cons.hyps have \"!!ys. [| length zs = length ys; a \\&lt;in&gt; set zs |] <br>\n==&gt; !y. lookupEq zs ys a = Some y\" .</p>\n<p>It does not work, \"by auto\" does not help here either. At the end I <br>\nproved the lemma without explicifying the hypothesis, just by referring <br>\nto the fact  Cons.hyps by its name. But I am still curious why \".\" or <br>\n\"apply\" cannot deal with such seemingly trivial step.</p>\n<blockquote>\n<p>Another option is to retrieve premises out of the blue:</p>\n<p>have \"...\" .</p>\n</blockquote>\n<p>If  I write</p>\n<p>have \"[| length zs = length ys; a \\&lt;in&gt; set zs |] ==&gt; !y. lookupEq zs ys <br>\na = Some y\" .</p>\n<p>then it works, but</p>\n<p>have \"!!ys. [| length zs = length ys; a \\&lt;in&gt; set zs |] ==&gt; !y. lookupEq <br>\nzs ys a = Some y\" .</p>\n<p>does not work. But the latter is the hypothesis, which I see in the <br>\ncontext.</p>\n<blockquote>\n<blockquote>\n<p>I use the build of 2006 Sep 12.</p>\n</blockquote>\n<p>In that case you might want to read the NEWS file, which explains a <br>\nfew<br>\nadditions to the induction setup, including common proof patterns.  In<br>\nparticular, the above from/have/. invocation can be replaced by</p>\n<p>from <code>...</code></p>\n</blockquote>\n<p>Thanks, this can be very useful to make the proof more readable, because <br>\nnow I invent a lot of fancy names to refer to the known facts.</p>\n<blockquote>\n<p>Note that your example in Test.thy will need a type constraint of<br>\n\"!!ys :: 'a list. ...\" here.  This may change eventually, when the <br>\n<code>...</code><br>\nnotation becomes polymorphic.</p>\n</blockquote>\n<p>I don't know, but I somehow proved it without additional type <br>\nannotations.</p>\n<p>Thanks,<br>\nVaidas</p>",
        "id": 294041813,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815619
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 18 Sep 2006, Vaidas Gasiunas wrote:</p>\n<blockquote>\n<p>I have tried following in my example:</p>\n<p>from Cons.hyps have \"!!ys. [| length zs = length ys; a \\&lt;in&gt; set zs |] <br>\n==&gt; !y. lookupEq zs ys a = Some y\" .</p>\n<p>It does not work, \"by auto\" does not help here either.</p>\n</blockquote>\n<p>You also need a type constraints \"!!ys :: 'a list. ...\" here.  Otherwise <br>\nthis closed formula will be syntactically unrelated to the context of the <br>\nproblem.</p>\n<blockquote>\n<p>At the end I proved the lemma without explicifying the hypothesis, just <br>\nby referring to the fact Cons.hyps by its name.</p>\n</blockquote>\n<p>This is a good strategy.  It is usually easier (and more informative) to <br>\nderive immediate conclusions from the induction hypotheses, rather than <br>\nduplicate them literally.</p>\n<blockquote>\n<p>But I am still curious why \".\" or \"apply\" cannot deal with such <br>\nseemingly trivial step.</p>\n</blockquote>\n<p>Note that 'apply' merely applies a proof method.  The \".\" abbreviates <code>by \nthis'', which can be expanded to </code>apply this .'' The latter allows more <br>\nfine-grained debugging.</p>\n<p>The single step methods (notably \"this\" and \"rule\") insist on being able <br>\nto apply all chained facts, without ignoring anything.  Thus providing <br>\nexcessive facts makes the method invocation fail.</p>\n<p>This principle is important to achive some degree of robustness and <br>\npredictability of structured proof checking.  In contrast, automated <br>\nmethods readily ignore irrelevant facts.  So it is easy to write proofs <br>\nthat tell the wrong story, e.g. like this:</p>\n<p>assume a: A<br>\n  assume b: B</p>\n<p>from a and b have C by auto</p>\n<p>Here the ``auto'' step can ignore either a or b, or even worse ignore both <br>\nand use different facts declared in the context.  The relevance of facts <br>\nis a fundamental problem in most automated proof tools.</p>\n<blockquote>\n<p>If  I write</p>\n<p>have \"[| length zs = length ys; a \\&lt;in&gt; set zs |] ==&gt; !y. lookupEq zs ys <br>\na = Some y\" .</p>\n<p>then it works, but</p>\n<p>have \"!!ys. [| length zs = length ys; a \\&lt;in&gt; set zs |] ==&gt; !y. lookupEq <br>\nzs ys a = Some y\" .</p>\n<p>does not work. But the latter is the hypothesis, which I see in the <br>\ncontext.</p>\n</blockquote>\n<p>This is again a problem with unexpectedly general types.  The first form <br>\nrefers to the fixed variable ys of the context, i.e. gets the expected <br>\ntype.  The second is detached due to !! closure and gets a fresh type.</p>\n<p>Makarius</p>",
        "id": 294041846,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815643
    },
    {
        "content": "<p>From: Vaidas Gasiunas &lt;<a href=\"mailto:gasiunas@informatik.tu-darmstadt.de\">gasiunas@informatik.tu-darmstadt.de</a>&gt;<br>\nIndeed, when I write</p>\n<p>from Cons.hyps have \"!!(ys::'a list). [| length zs = length ys; a \\&lt;in&gt; <br>\nset zs |] ==&gt; !y. lookupEq zs ys a = Some y\" .</p>\n<p>then it works. Now I will know how to deal with such cases.</p>\n<p>Thanks,<br>\nVaidas</p>",
        "id": 294041887,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815661
    }
]