[
    {
        "content": "<p>From: c_feller &lt;<a href=\"mailto:c_feller@informatik.uni-kl.de\">c_feller@informatik.uni-kl.de</a>&gt;<br>\nHallo,</p>\n<p>I have a problem when I try to use a overloaded function in a<br>\ninductive definition. I've made a small example to illustrate that:</p>\n<p>consts lifu :: \"'a =&gt; 'b\"</p>\n<p>overloading lifu1 == \"lifu::'a list =&gt; int\"<br>\n            lifu2 == \"lifu::int =&gt; nat\"<br>\nbegin<br>\ndefinition lifu1 where \"lifu1 == length\"<br>\ndefinition lifu2 where \"lifu2 == nat\"<br>\nend</p>\n<p>inductive ind_lifu :: \"int list =&gt; int =&gt; bool\"<br>\nwhere<br>\nbase: \"lifu (a::int list) = lifu (b::int) ==&gt; ind_lifu a b\"</p>\n<p>If i try to give that to Isabelle/HOL, i get the message:</p>\n<p>Specification depends on extra type variables: \"'a::{}\"</p>\n<p>Did I do something wrong or is this a bug?</p>\n<p>Thanks,<br>\nChristoph Feller</p>",
        "id": 294073209,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827910
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Christoph,</p>\n<p>Your inductive specification fixes the argument type of each use of  <br>\n\"lifu\", but it doesn't specify what the return type is. Do you intend  <br>\nthe equality comparison to be at type \"nat\", \"int\", or something else?  <br>\nThis is why you get the message about an extra type variable.</p>\n<p>You'll need to add extra type annotations, like this:</p>\n<p>inductive ind_lifu :: \"int list =&gt; int =&gt; bool\"<br>\nwhere<br>\nbase: \"(lifu a :: nat) = (lifu b :: nat) ==&gt; ind_lifu a b\"</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>\n<p>Quoting c_feller &lt;<a href=\"mailto:c_feller@informatik.uni-kl.de\">c_feller@informatik.uni-kl.de</a>&gt;:</p>",
        "id": 294073289,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827944
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nQuoting c fe &lt;<a href=\"mailto:zehfee@googlemail.com\">zehfee@googlemail.com</a>&gt;:</p>\n<p>I'll give an example from the Isabelle libraries.</p>\n<p>The libraries define a polymorphic function \"of_nat :: nat =&gt; 'a\" that  <br>\ncan convert from the naturals to any other semiring type. Lots of  <br>\ngeneric lemmas are proved about it.</p>\n<p>The function \"int :: nat =&gt; int\" used to be defined as a separate  <br>\nconstant, but now it is defined as an abbreviation for \"of_nat :: nat  <br>\n=&gt; int\". Since it is just an abbreviation, we can use all the lemmas  <br>\nabout \"of_nat\" for reasoning about \"int\" as well. Back when it was a  <br>\nseparate constant, the libraries had two separate versions of each  <br>\nlemma, one for \"of_nat\" and one for \"int\".</p>\n<p>So if you have any generic lemmas about \"lifu\", then that might be an  <br>\nargument for using overloading+abbreviations instead of separate  <br>\nconstants.</p>\n<p>On the other hand, if all of your lemmas about \"lifu\" are specific to  <br>\ncertain types, maybe you would be better off using separate functions.  <br>\n(Unless you think it is really important to have the shared \"lifu\"  <br>\nsyntax.)</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294073385,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827969
    },
    {
        "content": "<p>From: c fe &lt;<a href=\"mailto:zehfee@googlemail.com\">zehfee@googlemail.com</a>&gt;<br>\nBut why then use overloading in the first place? If I'm going to use<br>\nlifu_nat from your example isn't it almost the same as declaring lifu<br>\nand lifu_nat as seperate functions?</p>\n<p>Christoph</p>",
        "id": 294073396,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827973
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nQuoting c fe &lt;<a href=\"mailto:zehfee@googlemail.com\">zehfee@googlemail.com</a>&gt;:</p>\n<p>Any time you have functions overloaded to such an extent (i.e.  <br>\noverloaded with respect to more than one type variable), you are bound  <br>\nto need a lot of those ugly type annotations.</p>\n<p>A possible workaround is to use abbreviations for type-specific  <br>\ninstances. For example, if you have a lot of type annotations like  <br>\n\"(lifu whatever :: nat)\" in your theory, then you would probably  <br>\nbenefit by making a nat-specific abbreviation, like this:</p>\n<p>consts lifu :: \"'a =&gt; 'b\"</p>\n<p>abbreviation<br>\n   lifu_nat :: \"'a =&gt; nat\"<br>\nwhere<br>\n   \"lifu_nat == lifu\"</p>\n<p>inductive ind_lifu :: \"int list =&gt; int =&gt; bool\"<br>\nwhere<br>\nbase: \"lifu_nat a = lifu_nat b ==&gt; ind_lifu a b\"</p>\n<p>Type-specific abbreviations are helpful for output too, since they can  <br>\nindicate type information that is usually hidden, even when \"show  <br>\ntypes\" is enabled. For example, without the abbreviation lifu_nat, the  <br>\ncommand \"thm base\" would give you no indication of what return type  <br>\n\"lifu\" is used at, but with the abbreviation you can tell that it is  <br>\nused at type nat.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294073755,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828094
    },
    {
        "content": "<p>From: \"Dr. Brendan Patrick Mahony\" &lt;<a href=\"mailto:brendan.mahony@dsto.defence.gov.au\">brendan.mahony@dsto.defence.gov.au</a>&gt;<br>\nThis whole \"instantiate your favourite generic constant\" game has been  <br>\ndriving me nuts for ages. I actually do define abbreviations for the  <br>\nmost common generics, but slightly more general ones than you suggest eg</p>\n<p>syntax (xsymbols)<br>\n   \"_UNIV\" :: \"type =&gt; 'a set\" (\"\\&lt;aleph&gt;-[_]\")<br>\n   \"_empty\" :: \"type =&gt; 'a set\" (\"\\&lt;emptyset&gt;-[_]\")</p>\n<p>translations<br>\n   \"\\&lt;aleph&gt;-[t]\" \\&lt;rightharpoonup&gt; \"UNIV::(t)set\"<br>\n   \"\\&lt;emptyset&gt;-[t]\" \\&lt;rightharpoonup&gt; \"{}::(t)set\"</p>\n<p>Still, even defining such syntax for every generic gets tiresome, so  <br>\nyou've inspired me to write a totally general operator for  <br>\ninstantiating the generics of constants.</p>\n<p>syntax<br>\n   \"_type_inst\" :: \"[logic, types] =&gt; logic\" (\"_-[_]\" [1000, 0] 1000)</p>\n<p>parse_translation (advanced) {*</p>\n<p>let</p>\n<p>fun type_inst_tr ctxt [term, typs] =<br>\nlet</p>\n<p>val thy = ProofContext.theory_of ctxt;<br>\nval map_sort = Sign.intern_sort thy;<br>\nval get_sort = Sign.get_sort thy (Variable.def_sort ctxt)</p>\n<p>fun typ_of_term t =<br>\nlet<br>\n   val env = (Syntax.term_sorts map_sort t);<br>\n   val T = Sign.intern_typ thy (Syntax.typ_of_term (get_sort env)  <br>\nmap_sort t)<br>\nin<br>\n   ProofContext.cert_typ ctxt T<br>\nend;</p>\n<p>fun mk_types (Const(\"_types\", _) $ T $ Ts) = (typ_of_term T):: <br>\n(mk_types Ts)<br>\n  |  mk_types T = [typ_of_term T];</p>\n<p>fun mk_name const_space (Free(nm, _)) = Consts.intern const_space nm<br>\n  |  mk_name const_space (Const(nm, _)) = Consts.intern const_space nm;</p>\n<p>val const_space = Sign.consts_of thy;<br>\n   val Ts = mk_types typs;<br>\n   val inm = mk_name const_space term;<br>\n   val CT = Sign.const_instance thy (inm, Ts);<br>\nin<br>\n   Const(inm, CT)<br>\nend;</p>\n<p>in</p>\n<p>[ (\"_type_inst\", type_inst_tr) ]</p>\n<p>end;</p>\n<p>*}</p>\n<p>Then you just write \"Domain-[nat, 'a]\" for \"Domain::(nat * 'a) set =&gt;  <br>\n'a set\", which is quicker to write and a lot easier to read as well.</p>\n<p>It seems to work okay (with minimum testing). If any of the Isabelle  <br>\ncode wizards would like to check over the way sorts are treated in  <br>\nparticular, I'd appreciate it. Some of this stuff is really hard to  <br>\nuntangle!</p>\n<p>It would be nice to see something like this in the standard  <br>\ndistribution.</p>\n<p>Cheers,</p>\n<p>Brendan</p>\n<hr>\n<p>Dr Brendan Mahony<br>\nC3I Division                                    ph +61 8 8259 6046<br>\nDefence Science and Technology Organisation     fx +61 8 8259 5589<br>\nEdinburgh, South Australia      <a href=\"mailto:Brendan.Mahony@dsto.defence.gov.au\">Brendan.Mahony@dsto.defence.gov.au</a></p>\n<p>Important: This document remains the property of the Australian<br>\nGovernment Department of Defence and is subject to the jurisdiction<br>\nof the Crimes Act section 70. If you have received this document in<br>\nerror, you are requested to contact the sender and delete the document.</p>\n<p>IMPORTANT: This email remains the property of the Australian Defence Organisation and is subject to the jurisdiction of section 70 of the CRIMES ACT 1914.  If you have received this email in error, you are requested to contact the sender and delete the email.</p>",
        "id": 294074181,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828233
    },
    {
        "content": "<p>From: c fe &lt;<a href=\"mailto:zehfee@googlemail.com\">zehfee@googlemail.com</a>&gt;<br>\nHallo Brian,</p>\n<p>Thanks, that really helped. But it lead to me having to annotated<br>\nquite a lot of expressions which made my terms look rather convoluted.<br>\nAnd as I think that those terms are important I want them to look as<br>\ncomprehensible as possible. So I'm now back to different functions<br>\nwith the same mixfix syntax and keep getting ambiguous input warnings<br>\nbut the definitions look ok.</p>\n<p>But thanks, nevertheless. I don't know how long I would have been<br>\ntrying to solve this.</p>\n<p>Greeting,<br>\nChristoph</p>",
        "id": 294074380,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828296
    }
]