[
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi René,</p>\n<blockquote>\n<p>I just encountered the following problem. When writing a pretty printer <br>\nfor rational numbers the standard function I  would like to write is:</p>\n<p>show_rat (Fract a b) = (if b = 1 then show_int a else show_int a @ ''/'' <br>\n@ show_int b)\"</p>\n<p>However, since Fract is a only a code_datatype and not a datatype, <br>\nIsabelle refused this function definition. (And it must refuse, since <br>\nFract 1 2 = Fract 2 4, but show_rat .. = 1/2  !=  2/4 = show_rat .. <br>\nHence, show_rat is not a function.)</p>\n</blockquote>\n<p>Right. This cannot work.</p>\n<blockquote>\n<p>Are there for example <br>\nfunctions like \"get_numerator\" and \"get_denominator\" which return unique <br>\nresults independent of whether using (Fract 1 2) or (Fract 2 4) which I <br>\noverlooked in Rational.thy?</p>\n</blockquote>\n<p>There aren't, but it seems that they should be there, so contributions<br>\nare welcome (probably a function that returns (int * int) is best). It<br>\ncan be defined using THE.</p>\n<p>Alex</p>",
        "id": 294092028,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832167
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThe function should be called \"normalize :: rat =&gt; int * int\" and should<br>\nalso take care of the sign: the denominator should be positive. Since<br>\ngcd is there already, it is easy to define directly. Any takers?</p>\n<p>Tobias</p>\n<p>Alexander Krauss wrote:</p>",
        "id": 294092054,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832173
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;</p>\n<blockquote>\n<p>The function should be called \"normalize :: rat =&gt; int * int\" and  <br>\nshould<br>\nalso take care of the sign: the denominator should be positive. Since<br>\ngcd is there already, it is easy to define directly. Any takers?</p>\n</blockquote>\n<p>I have a solution which (I think) is too long for this mailing list.  <br>\nHowever, please contact me if you want to have the theory-file.</p>\n<p>Cheers,<br>\nRené</p>\n<blockquote>\n<p>Tobias</p>\n<p>Alexander Krauss wrote:</p>\n<blockquote>\n<p>Hi René,</p>\n<blockquote>\n<p>I just encountered the following problem. When writing a pretty<br>\nprinter for rational numbers the standard function I  would like to<br>\nwrite is:</p>\n<p>show_rat (Fract a b) = (if b = 1 then show_int a else show_int a @<br>\n''/'' @ show_int b)\"</p>\n<p>However, since Fract is a only a code_datatype and not a datatype,<br>\nIsabelle refused this function definition. (And it must refuse,  <br>\nsince<br>\nFract 1 2 = Fract 2 4, but show_rat .. = 1/2  !=  2/4 = show_rat ..<br>\nHence, show_rat is not a function.)</p>\n</blockquote>\n<p>Right. This cannot work.</p>\n<blockquote>\n<p>Are there for example functions like \"get_numerator\" and<br>\n\"get_denominator\" which return unique results independent of whether<br>\nusing (Fract 1 2) or (Fract 2 4) which I overlooked in Rational.thy?</p>\n</blockquote>\n<p>There aren't, but it seems that they should be there, so  <br>\ncontributions<br>\nare welcome (probably a function that returns (int * int) is best).  <br>\nIt<br>\ncan be defined using THE.</p>\n<p>Alex<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294092208,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832209
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I just encountered the following problem. When writing a pretty  <br>\nprinter for rational numbers the standard function I  would like to  <br>\nwrite is:</p>\n<p>show_rat (Fract a b) = (if b = 1 then show_int a else show_int a @  <br>\n''/'' @ show_int b)\"</p>\n<p>However, since Fract is a only a code_datatype and not a datatype,  <br>\nIsabelle refused this function definition. (And it must refuse, since  <br>\nFract 1 2 = Fract 2 4, but show_rat .. = 1/2  !=  2/4 = show_rat ..  <br>\nHence, show_rat is not a function.)</p>\n<p>Instead, I now added an axiom</p>\n<p>consts show_rat<br>\naxioms show_rat_def[code]: \"show_rat (Fract a b) = (if b = 1 then  <br>\nshow_int a else show_int a @ ''/'' @ show_int b)\"</p>\n<p>Now, the code-generator is working. However, I do not like to add  <br>\naxioms to my theory, so is there a better way around? Are there for  <br>\nexample functions like \"get_numerator\" and \"get_denominator\" which  <br>\nreturn unique results independent of whether using (Fract 1 2) or  <br>\n(Fract 2 4) which I overlooked in Rational.thy?</p>\n<p>Thanks a lot,<br>\nRené</p>",
        "id": 294093272,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832546
    }
]