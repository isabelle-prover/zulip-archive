[
    {
        "content": "<p>From: Lucas Dixon &lt;<a href=\"mailto:ldixon@inf.ed.ac.uk\">ldixon@inf.ed.ac.uk</a>&gt;<br>\nHi Peter,</p>\n<p>Peter Lammich wrote:</p>\n<blockquote>\n<p>Consider the following subgoal</p>\n<ol>\n<li>\"!!x y a b. f ((x = y) = (a = b)) = ?P x y a b\" now, I do: apply<br>\n(subst (1 3) eq_commute)</li>\n</ol>\n<p>and get: goal (1 subgoal): 1. !!x y a b. f ((y = x) = (b = a)) = ?P6<br>\nx x x y y y a a a b b b flex-flex pairs: %x y a b. ?P6 x x x y y y a<br>\na a b b b =?= %x y a b. ?P4 x x y y a a b b</p>\n<p>In my concrete proof, ?P also occurs in other subgoals, it is the<br>\nresult of applying exI to a goal of the form EX P. a1=P &amp; a2=P. The<br>\nlist of flex-flex pairs and newly introduced schematics with <br>\nduplicate parameters gets very long until Isabelle only spits out<br>\ntons of trace output and does not terminate any more.</p>\n<p>What happens here?</p>\n</blockquote>\n<p>I think this is caused by Isabelle doing gratuitous lifting of<br>\nparameters as it applies substitution. Lifting is necessary if some part <br>\nof the proof state not under the bound parameters also contains the <br>\nmeta-variable (also called schematic variables) - which is the general <br>\nassumption when Isabelle performs resolution.</p>\n<p>If you do fix your parameters to free variables, then you get something<br>\nmore reasonable:</p>\n<p>lemma \"(A ?P) ==&gt; f ((x = y) = (a = b)) = ?P x\"<br>\napply (subst (1 3) eq_commute)<br>\n...<br>\nfixed variables: A, f, x, y, a, b<br>\ngoal (lemma, 1 subgoal):</p>\n<p>1. A ?P ==&gt; f ((y = x) = (b = a)) = ?P2 x<br>\nflex-flex pairs:<br>\n   ?P2 x =?= ?P1 x<br>\n   ?P1 x =?= ?P x</p>\n<p>But, depending on your context (other subgoals, assumptions etc), that<br>\nmay give incorrect results as it allows meta-variables to capture the<br>\nbounds (which are being represented as Frees) - if the meta-variable<br>\nalso occurs outside of the scope of the parameters and is instantiated<br>\nto a term containing the bound variable, you end up with a badly formed<br>\ninstantiation w.r.t. the context.</p>\n<p>However, I think something funny is going on in the substitution tactic <br>\nhere: there seems to be an extra flex-flex pair, and I didn't think that<br>\nwas necessary, and is probably also the reason for the duplication of<br>\nthe bound variables... I remember doing lifting by hand very carefully, <br>\nbut it seems the code has changed slightly... I also vaguely recall not <br>\nbeing sure if I could get rid of extra lifting in the tactic without <br>\ndoing something very different... actually I think I remember discussing <br>\nit in 2004... I'll look through my old email and I'll have a think about <br>\nit again... thanks for reminding me of the issue :)</p>\n<blockquote>\n<p>Is there a way to get rid of introducing new schematics during subst,<br>\nand get the desired subgoal: 1. !!x y a b. f ((y = x) = (b = a)) = ?P<br>\nx y a b</p>\n<p>Something that simplifies the subgoal after each substitution step<br>\nwould also be ok.</p>\n</blockquote>\n<p>In the meantime, if you can't just fix the parameters, a horrible hack <br>\nis to instantiate your meta-variables to lambda terms that throw away <br>\nduplicated arguments. You then simply apply this after substitution.</p>\n<p>best,<br>\nlucas</p>",
        "id": 294066260,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825530
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nPeter Lammich wrote:<br>\nSome years ago I wrote some code based on the \"conversionals\" of HOL, to <br>\ndo this sort of thing more easily.  Thus, for example,</p>\n<p>Goal \"!!x y a b. f ((x = y) = (a = b)) = P x y a b\" ;<br>\nby ((Conv.CONV_TAC o Conv.TDSTOP_CONV) (eqc eq_commute)) ;<br>\n(applies conversions top-down, but stopping (ie, not descending into a <br>\nresulting term upon success)</p>\n<ol>\n<li>\n<p>!!x y a b. P x y a b = f ((x = y) = (a = b))<br>\nby ((Conv.CONV_TAC o Conv.TOPDN_CONV) (eqc eq_commute)) ;<br>\n(applies conversions top down)</p>\n</li>\n<li>\n<p>!!x y a b. f ((b = a) = (y = x)) = P x y a b<br>\nby ((Conv.CONV_TAC o Conv.BUSTOP_CONV) (eqc eq_commute)) ;<br>\n(applies conversions bottom up, stopping upon any success)</p>\n</li>\n<li>\n<p>!!x y a b. f ((a = b) = (x = y)) = P x y a b</p>\n</li>\n</ol>\n<p>With these, I usually don't need the following, which makes a conversion <br>\nsucceed only the first and third times it would otherwise have succeeded).<br>\nby ((Conv.CONV_TAC o Conv.TOPDN_CONV o Conv.NTH_CONV [1,3]) (eqc <br>\neq_commute)) ;</p>\n<ol>\n<li>!!x y a b. P x y a b = f ((b = a) = (x = y))</li>\n</ol>\n<p>Incidentally, I found my code doesn't work with schematic variables (I <br>\ndon't know why), so to use it you'd have to wrap your goal in <br>\nfreeze_thaw.  Which would presumably solve your problem anyway.</p>\n<p>But if you're interested in my code, it's at<br>\n<a href=\"http://users.rsise.anu.edu.au/~jeremy/isabelle/2005/gen/{conv.ML,eq_conv.ML}\">http://users.rsise.anu.edu.au/~jeremy/isabelle/2005/gen/{conv.ML,eq_conv.ML}</a></p>\n<p>Regards,</p>\n<p>Jeremy</p>",
        "id": 294066277,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825536
    }
]