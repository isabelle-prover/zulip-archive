[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I'm currently having a question concerning class-constraints:</p>\n<p>In a locale where I just fix some constants without assuming anything about them, it<br>\nis always possible to get rid of the \"locale-constraint\".</p>\n<p>So my question is, whether this is also possible for class-constraints? I.e., if I just<br>\nfix some function (emb in the example below) without making any assumptions about it, <br>\ncan one get rid of the sort constraint (i.e., replace the \"('a :: embed)list by ('a list)\").</p>\n<p>In the proof below, I just require the exakt definition of emb for lists, but it does not matter how emb<br>\nis defined on type 'a for the elements of the list.</p>\n<p>In principle, I have shown \"!! xs :: ('a :: embed) list. len_dom xs\", and I would like to derive<br>\n\"!! xs :: 'a list. len_dom xs\" without the embed sort-constraint.</p>\n<p>class embed =<br>\n  fixes emb :: \"'a ⇒ nat\"</p>\n<p>instantiation list :: (embed) embed <br>\nbegin<br>\n  fun emb_list where <br>\n    \"emb_list [] = 0\" <br>\n  | \"emb_list (x # xs) = emb x + 2 * emb xs + 1\"<br>\ninstance ..<br>\nend</p>\n<p>function len :: \"('a :: embed) list =&gt; nat\"<br>\n  where \"len [] = 0\"<br>\n      | \"len (x # xs) = Suc (len xs)\"<br>\n  by pat_completeness auto</p>\n<p>termination len (* goal: All len_dom *)<br>\nproof <br>\n  let ?r = \"inv_image ({(x,y). x &lt; y}) (emb :: 'a list =&gt; nat)\"<br>\n  show \"wf ?r\"<br>\n    by (rule wf_inv_image[OF wf_less])<br>\n  fix x xs<br>\n  show \"(xs, x # xs) ∈ ?r\" by simp<br>\nqed</p>\n<p>Best regards,<br>\nRené</p>",
        "id": 294163594,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854137
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear René,</p>\n<blockquote>\n<p>So my question is, whether this is also possible for class-constraints?<br>\nNo. Type classes are explicitly made to prevent applications of overloaded <br>\nconstants when it is not clear that there is an instantiation.</p>\n</blockquote>\n<blockquote>\n<p>I.e., if I just<br>\nfix some function (emb in the example below) without making any assumptions<br>\nabout it, can one get rid of the sort constraint (i.e., replace the<br>\n\"('a :: embed)list by ('a list)\").</p>\n<p>In the proof below, I just require the exakt definition of emb for lists, but<br>\nit does not matter how emb is defined on type 'a for the elements of the list.<br>\nI do not see why you need a type class in this case at all. You could equally <br>\nwell define emb_list inside the proof itself and not introduce the type <br>\nconstraint at all:</p>\n</blockquote>\n<p>function len :: \"'a list =&gt; nat\"<br>\n   where \"len [] = 0\"<br>\n       | \"len (x # xs) = Suc (len xs)\"<br>\n   by pat_completeness auto</p>\n<p>termination len (* goal: All len_dom *)<br>\nproof<br>\n   def emb == \"list_rec 0 (%x xs res. undefined + 2 * res + 1) :: 'a list =&gt; nat\"<br>\n   let ?r = \"inv_image ({(x,y). x &lt; y}) emb\"<br>\n   show \"wf ?r\"<br>\n     by (rule wf_inv_image[OF wf_less])<br>\n   fix x xs<br>\n   show \"(xs, x # xs) : ?r\" by(simp add: emb_def)<br>\nqed</p>\n<p>Obviously, definitions inside proofs are not as convenient as top-level <br>\ndefinitions. You could also define emb_list only for lists and use that, but <br>\npossibly, your real use case is more complex and you do want to use the global emb.</p>\n<p>If you want to do overloading without sort constraints, there's the overloading <br>\ncommand (Isar-Ref manual 5.8) or the old-fashioned consts+defs (overloaded) <br>\npattern, without type classes at all. Note, however, that you then will lose the <br>\nability to generate code for whatever is to be implemented in terms of emb. To <br>\nthat end, you would have reintroduce the type class for code generation as follows:</p>\n<p>(* not tested *)<br>\nconsts emb :: \"'a =&gt; nat\"<br>\ndefs (overloaded) emb_list_def:<br>\n   \"emb = list_rec 0 (%x xs res. emb x + 2 * res + 1)\"</p>\n<p>class emb_code =<br>\n   fixes emb_code :: \"'a =&gt; nat\"<br>\n   assumes emb_code: \"emb = emb_code\"</p>\n<p>declare emb_code[code]</p>\n<p>instantiation list :: (emb) emb begin<br>\ndefinition \"emb_code :: 'a list =&gt; nat == emb\"<br>\ninstance by(intro_locales)(simp add: emb_code_def)<br>\nend</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294163627,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854156
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Andreas,</p>\n<blockquote>\n<p>Dear René,</p>\n<blockquote>\n<p>So my question is, whether this is also possible for class-constraints?<br>\nNo. Type classes are explicitly made to prevent applications of overloaded constants when it is not clear that there is an instantiation.</p>\n</blockquote>\n</blockquote>\n<p>thanks, this was the expected answer, which tells me that I have to do some work.</p>\n<blockquote>\n<p>I do not see why you need a type class in this case at all. You could equally well define emb_list inside the proof itself and not introduce the type constraint at all:<br>\nObviously, definitions inside proofs are not as convenient as top-level definitions. You could also define emb_list only for lists and use that, but possibly, your real use case is more complex and you do want to use the global emb.</p>\n</blockquote>\n<p>Exactly, for my presented (short) proof, it is easy to do it within the proof. In the general setting, I'll have to think about how to solve this problem.</p>\n<blockquote>\n<p>If you want to do overloading without sort constraints, there's the overloading command (Isar-Ref manual 5.8) or the old-fashioned consts+defs (overloaded) pattern, without type classes at all. Note, however, that you then will lose the ability to generate code for whatever is to be implemented in terms of emb. To that end, you would have reintroduce the type class for code generation as follows:</p>\n</blockquote>\n<p>Thanks for the pointers. I'll have a look into it whether these techniques can be utilized to solve my problem.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294163636,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854161
    }
]