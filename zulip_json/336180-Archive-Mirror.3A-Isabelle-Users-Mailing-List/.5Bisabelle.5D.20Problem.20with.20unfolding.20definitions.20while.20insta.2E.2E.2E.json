[
    {
        "content": "<p>From: Nils Jähnig &lt;<a href=\"mailto:nils.jaehnig@tu-berlin.de\">nils.jaehnig@tu-berlin.de</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>I am trying to instantiate a class, and can not see how to unfold the<br>\npredefined fixed definitions.<br>\nMy question is: how do I figure out the right rules or definition names?</p>\n<p>I'll use two example to explain:</p>\n<hr>\n<hr>\n<p>Example 1</p>\n<p>theory fun_ccpo<br>\nimports Complete_Partial_Order<br>\nbegin</p>\n<p>instantiation \"fun\" :: (type, ccpo) ccpo<br>\nbegin<br>\ninstance<br>\napply(intro_classes)<br>\n(* First subgoal:</p>\n<ol>\n<li>⋀A x. chain op ≤ A ⟹ x ∈ A ⟹ x ≤ ⨆A<br>\n *)<br>\n(* I found those two definition and can unfold them*)<br>\napply(unfold chain_def)[]<br>\napply(unfold le_fun_def)[]<br>\n(* but I am not able to find the right Sup definition<br>\nneither do I know how to overwrite the Sup definition *)<br>\nthm Sup_fun_def<br>\n(* Those don't work *)<br>\napply(unfold Sup_fun_def)<br>\napply(simp add: Sup_fun_def)<br>\nsorry</li>\n</ol>\n<p>end<br>\nend</p>\n<hr>\n<hr>\n<p>Example 2, uses HOLCF</p>\n<p>theory fun_pcpo<br>\nimports Fun_Cpo<br>\nbegin</p>\n<p>datatype nat_bot = N nat | Bot</p>\n<p>instantiation nat_bot :: pcpo<br>\nbegin<br>\ndefinition \"below_nat_bot a b == a=b ∨ a=Bot\"<br>\ninstance<br>\napply(default)<br>\napply(unfold below_nat_bot_def, simp)[]<br>\napply(unfold below_nat_bot_def, auto)[]<br>\napply(unfold below_nat_bot_def, auto)[]<br>\n(* First Subgoal</p>\n<ol>\n<li>⋀S. chain S ⟹ ∃x. range S &lt;&lt;| x<br>\n*)<br>\n(* How do i unfold chain, range and &lt;&lt;| *)<br>\nthm chain_def<br>\nthm is_lub_def<br>\nsorry</li>\n</ol>\n<p>end<br>\nend</p>\n<hr>\n<hr>\n<p>Thanks for any help<br>\nNils</p>",
        "id": 294280015,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920031
    },
    {
        "content": "<p>From: David Cock &lt;<a href=\"mailto:davec@cse.unsw.edu.au\">davec@cse.unsw.edu.au</a>&gt;<br>\nNils,<br>\n   Your problem in the first instance is that Sup_fun is only defined <br>\nwhere the result type is a complete lattice.  Try:</p>\n<p>declare [[show_sorts = true]]<br>\nthm Sup_fun_def</p>\n<p>Sup_fun_def won't unfold, as you're assuming that the result type is in <br>\nclass ccpo, not complete_lattice.  This is a bit of a nuisance, as the <br>\ndefinition of Sup_fun only really needs the result type to be in class Sup.</p>\n<p>Dave</p>",
        "id": 294280035,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920037
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 06/06/2014 11:15, Nils Jähnig wrote:</p>\n<blockquote>\n<p>Hello Dave,</p>\n<p>thanks for the information! I was suspecting this, but was not sure.</p>\n<p>Is there any way to re-define Sup_fun for ccpos?<br>\nWhen there is no definition at all, I am asked to give a definition (e.g.<br>\nwhen I instantiate Sup with nat). I would like to override definitions in<br>\nthe same way.</p>\n</blockquote>\n<p>This is not possible. As Dave pointed out, the problem goes away if in Main the<br>\ninstantiation of \"fun\" on class complete_lattice is done in stages, where in a<br>\nfirst step one merely instantiates Sup and Inf.</p>\n<p>@ Florian: any objections to that?</p>\n<blockquote>\n<p>And is it just me not understanding the type classes or overloading, or is<br>\nit really strange that definitions of one type class use definitions of<br>\nanother (stronger!) type class?</p>\n</blockquote>\n<p>What do you mean?</p>\n<blockquote>\n<p>I would also be grateful for explanations why it doesn't work, or why I am<br>\ntrying in a wrong direction.</p>\n</blockquote>\n<p>As Dave said, it is not your fault, the setup in Main is not fine-grained<br>\nenough. You can modify Complete_Lattice as follows to make it work, but your<br>\ntheories will no longer work with the distribution: replace the block</p>\n<p>instantiation \"fun\" :: (type, complete_lattice) complete_lattice<br>\n...<br>\nend</p>\n<p>by the following:</p>\n<p>instantiation \"fun\" :: (type, Inf) Inf<br>\nbegin</p>\n<p>definition<br>\n  \"\\&lt;Sqinter&gt;A = (\\&lt;lambda&gt;x. \\&lt;Sqinter&gt;f\\&lt;in&gt;A. f x)\"</p>\n<p>lemma Inf_apply [simp, code]:<br>\n  \"(\\&lt;Sqinter&gt;A) x = (\\&lt;Sqinter&gt;f\\&lt;in&gt;A. f x)\"<br>\n  by (simp add: Inf_fun_def)</p>\n<p>instance ..</p>\n<p>end</p>\n<p>instantiation \"fun\" :: (type, Sup) Sup<br>\nbegin</p>\n<p>definition<br>\n  \"\\&lt;Squnion&gt;A = (\\&lt;lambda&gt;x. \\&lt;Squnion&gt;f\\&lt;in&gt;A. f x)\"</p>\n<p>lemma Sup_apply [simp, code]:<br>\n  \"(\\&lt;Squnion&gt;A) x = (\\&lt;Squnion&gt;f\\&lt;in&gt;A. f x)\"<br>\n  by (simp add: Sup_fun_def)</p>\n<p>instance ..</p>\n<p>end</p>\n<p>instantiation \"fun\" :: (type, complete_lattice) complete_lattice<br>\nbegin</p>\n<p>instance proof<br>\nqed (auto simp add: le_fun_def intro: INF_lower INF_greatest SUP_upper SUP_least)</p>\n<p>end</p>\n<p>Tobias</p>\n<p>PS Do not import individual theories that are part of Main (like<br>\nComplete_Partial_Order), start from Main instead. Otherwise you get some<br>\nfragment of Main with unpredictable behaviour.</p>\n<blockquote>\n<p>Thanks in advance<br>\nNils</p>\n<p>2014-06-06 0:10 GMT+02:00 David Cock &lt;<a href=\"mailto:davec@cse.unsw.edu.au\">davec@cse.unsw.edu.au</a>&gt;:</p>\n<blockquote>\n<p>Nils,<br>\n  Your problem in the first instance is that Sup_fun is only defined where<br>\nthe result type is a complete lattice.  Try:</p>\n<p>declare [[show_sorts = true]]<br>\nthm Sup_fun_def</p>\n<p>Sup_fun_def won't unfold, as you're assuming that the result type is in<br>\nclass ccpo, not complete_lattice.  This is a bit of a nuisance, as the<br>\ndefinition of Sup_fun only really needs the result type to be in class Sup.</p>\n<p>Dave</p>\n</blockquote>\n<p>On 05/06/14 00:40, Nils Jähnig wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear Isabelle Users,</p>\n<p>I am trying to instantiate a class, and can not see how to unfold the<br>\npredefined fixed definitions.<br>\nMy question is: how do I figure out the right rules or definition names?</p>\n<p>I'll use two example to explain:</p>\n<hr>\n<p>-</p>\n<hr>\n<p>Example 1</p>\n<p>theory fun_ccpo<br>\nimports Complete_Partial_Order<br>\nbegin</p>\n<p>instantiation \"fun\" :: (type, ccpo) ccpo<br>\nbegin<br>\ninstance<br>\napply(intro_classes)<br>\n(* First subgoal:<br>\n  1. ⋀A x. chain op ≤ A ⟹ x ∈ A ⟹ x ≤ ⨆A<br>\n  *)<br>\n(* I found those two definition and can unfold them*)<br>\napply(unfold chain_def)[]<br>\napply(unfold le_fun_def)[]<br>\n(* but I am not able to find the right Sup definition<br>\nneither do I know how to overwrite the Sup definition *)<br>\nthm Sup_fun_def<br>\n(* Those don't work *)<br>\napply(unfold Sup_fun_def)<br>\napply(simp add: Sup_fun_def)<br>\nsorry</p>\n<p>end<br>\nend</p>\n<hr>\n<p>-</p>\n<hr>\n<p>Example 2, uses HOLCF</p>\n<p>theory fun_pcpo<br>\nimports Fun_Cpo<br>\nbegin</p>\n<p>datatype nat_bot = N nat | Bot</p>\n<p>instantiation nat_bot :: pcpo<br>\nbegin<br>\ndefinition \"below_nat_bot a b == a=b ∨ a=Bot\"<br>\ninstance<br>\napply(default)<br>\napply(unfold below_nat_bot_def, simp)[]<br>\napply(unfold below_nat_bot_def, auto)[]<br>\napply(unfold below_nat_bot_def, auto)[]<br>\n(* First Subgoal<br>\n  1. ⋀S. chain S ⟹ ∃x. range S &lt;&lt;| x<br>\n*)<br>\n(* How do i unfold chain, range and &lt;&lt;| *)<br>\nthm chain_def<br>\nthm is_lub_def<br>\nsorry</p>\n<p>end<br>\nend</p>\n<hr>\n<p>-</p>\n<hr>\n<p>Thanks for any help<br>\nNils</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294280068,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920048
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nNo.  This would finally conclude the »syntactification« of Sup and Inf<br>\ninitiated by Larry (AFAIR).</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/RmQTS7BUgtGDcQoFYSVCni1W/signature.asc\">signature.asc</a></p>",
        "id": 294280138,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920072
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Nils,</p>\n<blockquote>\n<p>I'm not sure if I am thinking to object oriented.</p>\n</blockquote>\n<p>without following you in detail, your use of the phrase »object<br>\noriented« suggests that you see a relationship between classes as<br>\ninlanguages like Java and Isabelle's type classes.  But there is, well,<br>\nnone.</p>\n<p>If you want to approach Isabelle's type classes from a programming<br>\nlanguage perspective, Haskell's type classes are their nearest cousins.<br>\n There is also a tutorial on type classes coming with the Isabelle<br>\ndistribution which gives some examples.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/sSvq6EpdhGKARu2ja_YX4Onc/signature.asc\">signature.asc</a></p>",
        "id": 294280155,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920079
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 06/06/2014 15:17, Nils Jähnig wrote:</p>\n<blockquote>\n<p>Hello Tobias,</p>\n<p>thank you for your answer.</p>\n<blockquote>\n<blockquote>\n<p>And is it just me not understanding the type classes or overloading, or<br>\nis<br>\nit really strange that definitions of one type class use definitions of<br>\nanother (stronger!) type class?</p>\n</blockquote>\n<p>What do you mean?<br>\n</p>\n</blockquote>\n<p>I expected the following behavior:<br>\n\"fun\"::(type, ccpo) does not care about definitions for \"fun\"::(type,<br>\nlattice) [1]. Different type, different definitions.</p>\n</blockquote>\n<p>In order to have most general types, the set of all instantiations must satisfy<br>\ncertain constraints.</p>\n<p>Tobias</p>\n<blockquote>\n<p>If the type \"inherits\" from another type (i.e. is a supertype, as ccpo is<br>\nto order and sup), then it is wanted to \"inherit\" defintions [2].<br>\nI'm not sure if I am thinking to object oriented.</p>\n<p>I thought locals introduce some sort of namespace, which could be used to<br>\ndifferentiate between different Sup definitions for different types.</p>\n<blockquote>\n<blockquote>\n<p>I would also be grateful for explanations why it doesn't work, or why I<br>\nam<br>\ntrying in a wrong direction.</p>\n</blockquote>\n<p>As Dave said, it is not your fault, the setup in Main is not fine-grained<br>\nenough. You can modify Complete_Lattice as follows to make it work, but<br>\nyour<br>\ntheories will no longer work with the distribution: replace the block [...]<br>\n</p>\n</blockquote>\n<p>Thank you for the tip, but I don't want to modify the distribution<br>\ntheories. I was hoping more for something lika a \"redefine\" command inside<br>\nof a type instantiation.<br>\nJust out of curiosity, is there a place where I could vote for a change of<br>\nComplete_lattices.thy? And would it be a complete waste of time to do so?</p>\n<blockquote>\n<p>PS Do not import individual theories that are part of Main (like<br>\nComplete_Partial_Order), start from Main instead. Otherwise you get some<br>\nfragment of Main with unpredictable behaviour.</p>\n<p>I was hoping to not load Complete_lattices and its definitions this way,<br>\nand thereby be prompted to define Sup_fun by myself.</p>\n</blockquote>\n<p>Nils</p>\n<p>[1]:</p>\n<p>attempting to<br>\ninstantiation \"fun\" :: (type, ccpo) sup<br>\nbegin</p>\n<p>threw the error<br>\nConflict of type arities:<br>\n  fun :: (type, ccpo) sup and<br>\n  fun :: (type, lattice) sup</p>\n<p>[2]:<br>\nI solved my other problem, how to access the definition for chain while<br>\ninstantiating pcpo, by instantiating cpo first, where the defintion was<br>\navailable.<br>\nMy (unmet) expectation was that either I am prompted to define, or it is<br>\ndefined (and the definition accessible).<br>\n</p>\n</blockquote>",
        "id": 294280169,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920084
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIt is in now. This means that with the next release one can use Inf and Sup on<br>\nfunctions without forcing things to be complete lattices.</p>\n<p>Tobias</p>",
        "id": 294280179,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920090
    }
]