[
    {
        "content": "<p>From: Matej Urbas &lt;<a href=\"mailto:mu232@cam.ac.uk\">mu232@cam.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>I am having a bit of problems using 'compose_tac' with an intermediate<br>\ntheorem (produced with mk_implies + Goal.prove). I hope you do not mind<br>\nif I ask for a hint.</p>\n<p>Here is the problematic example:</p>\n<p>I have this subgoal (call it sg1):</p>\n<p>⋀s1 s2. ⟦distinct [s1, s2]; s1 ∈ A; s1 ∈ B; s2 ∈ A; s2 ∉ B⟧ ⟹<br>\n        ∃s1 s2. distinct [s1, s2] ∧ s1 ∈ A ∧ s2 ∈ B</p>\n<p>Then an external tool is invoked, which returns another goal (call it<br>\nsg2):</p>\n<p>⋀s1 s2. ⟦distinct[s1, s2]; s1 ∈ A ∩ B; s2 ∈ A - B⟧ ⟹ (∃s1 s2.<br>\n        distinct[s1, s2] ∧ s1 ∈ A ∧ s2 ∈ B)</p>\n<p>I want to 'replace' the current subgoal sg1 with sg2. Therefore I make a<br>\nmeta-implication and prove it with 'Goal.prove':</p>\n<p>val intert = Logic.mk_implies (sg2, sg1)<br>\n        val interThm = Goal.prove ctxt [] [] inter1 (K ((auto_tac<br>\n        (clasimpset_of ctxt)) THEN (ALLGOALS (Intuitionistic.prover_tac<br>\n        ctxt NONE))))</p>\n<p>where interThm becomes:</p>\n<p>⟦⋀s1 s2. ⟦distinct [s1, s2]; s1 ∈ A ∩ B; s2 ∈ A - B⟧ ⟹ ∃s1 s2.<br>\n        distinct [s1, s2] ∧ s1 ∈ A ∧ s2 ∈ B; distinct<br>\n        [?s1.0, ?s2.0]; ?s1.0 ∈ A; ?s1.0 ∈ B; ?s2.0 ∈ A; ?s2.0 ∉ B⟧ ⟹<br>\n        ∃s1 s2. distinct [s1, s2] ∧ s1 ∈ A ∧ s2 ∈ B</p>\n<p>The next step is to use interThm in 'compose_tac', which is applied on<br>\nthe original goal sg1:</p>\n<p>compose_tac (false, interThm, 1) i</p>\n<p>which fails.</p>\n<p>Does it fail because of schematic variables? Is it possible to tell<br>\n'Goal.prove' to not produce them?</p>\n<p>Apologies for the length, and thank you in advance for your help.</p>\n<p>Best,</p>\n<hr>\n<p>Matej<br>\n<a href=\"/user_uploads/14278/SWxXu9pnoNqY48uMiEyLA9pW/signature.asc\">signature.asc</a></p>",
        "id": 294140988,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845805
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nHi Matej,</p>\n<p>Two interesting things have happened. The first is that Goal.prove has lifted your meta-quantified conclusion (/\\s1 s2. P s1 s2) into a schematically quantified theorem (P ?s1 ?s2). The internal ==&gt; implications within your conclusion sg2 are now treated together with the sg1 ==&gt; sg2 implication as a group of assumptions. This may make compose_tac surprise you. You've told it you want to have only 1 new goal - if I recall correctly that will be the final assumption of the supplied theorem, so try rotating the sg1 assumption to the end.</p>\n<p>If that fails, you could try to stop Goal.prove lifting your meta-quantification. Playing around with the (invisible) protect constant might help you - look up protectI or protectD, No promises. Alternatively you could sidestep Goal.prove entirely by creating Thm.trivial from sg1 ==&gt; sg2 and applying your tactic to eliminate the first assumption.</p>\n<p>Can't be bothered firing up Isabelle on a weekend to test any of these strategies for you. Good luck.</p>\n<p>Yours,<br>\n    Thomas.</p>",
        "id": 294141303,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845911
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is all a bit indirect -- working against the natural flow of <br>\nreasoning in Isabelle/Pure.  Note that compose_tac is outside the normal <br>\nrule composition paradigm, i.e. you are standing naked in the cold rain.</p>\n<p>When you have a structured goal with its own !! and ==&gt; the canonical <br>\nproof enters that context and establishes the conclusion, e.g. see <br>\nSUBGOAL.FOCUS and similar (which are mentioned in the \"implementation\" <br>\nmanual).</p>\n<p>There are sometimes reasons to bypass the primary structure, but it should <br>\nbe only done if there are explicit reasons for it.  My favourite internal <br>\noperation for that is Thm.compose_no_flatten, but that is not for the <br>\nfaint-hearted.</p>\n<p>Makarius</p>",
        "id": 294141348,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845929
    },
    {
        "content": "<p>From: Matej Urbas &lt;<a href=\"mailto:mu232@cam.ac.uk\">mu232@cam.ac.uk</a>&gt;<br>\nOn Sun, 2011-07-10 at 21:43 +0200, Makarius wrote:</p>\n<blockquote>\n<p>This is all a bit indirect -- working against the natural flow of <br>\nreasoning in Isabelle/Pure.</p>\n</blockquote>\n<p>Sadly, there is specific demand for it. An external reasoner produces an<br>\n'inference step instance' of the form:</p>\n<p>sg2<br>\n        ------- (magic)<br>\n          sg1</p>\n<p>and I have to 'replace' sg1 with sg2, as it were. (While verifying this<br>\ninference step instance with Isabelle's tactics.)</p>\n<blockquote>\n<p>Note that compose_tac is outside the normal <br>\nrule composition paradigm, i.e. you are standing naked in the cold rain.</p>\n</blockquote>\n<p>I am sorry, but I do not understand this analogy. Could you please<br>\nelaborate on why compose_tac is fragile?</p>\n<blockquote>\n<p>When you have a structured goal with its own !! and ==&gt; the canonical <br>\nproof enters that context and establishes the conclusion, e.g. see <br>\nSUBGOAL.FOCUS and similar (which are mentioned in the \"implementation\" <br>\nmanual).</p>\n</blockquote>\n<p>Thank you very much. I will try and use this.</p>\n<p>Sadly, however, a quick glance at the documentation did not reveal a way<br>\nto 'inject' my 'target term' (sg2) into the clockwork of FOCUS et al. It<br>\ncould be possible if I constructed my own instance of the 'focus'<br>\nrecord. However, I would suspect expert users to frown at that thought<br>\n-- am I right in assuming this? Still, why would be the type 'focus'<br>\nspecified concretely in the SUBGOAL signature if not intended for users<br>\nto use?</p>\n<blockquote>\n<p>There are sometimes reasons to bypass the primary structure, but it should <br>\nbe only done if there are explicit reasons for it.  My favourite internal <br>\noperation for that is Thm.compose_no_flatten, but that is not for the <br>\nfaint-hearted.</p>\n</blockquote>\n<p>My particular use case dictates behaviour as was previously described.<br>\nFrankly, I do not mind how I achieve it. The initially mentioned method<br>\n(with compose_tac) was just the first one I discovered. I must admit, it<br>\nis hard to see right for wrong -- especially since there are no hints<br>\nthat could steer me away from the wrong path.</p>\n<p>Also, do you mind if I ask for a pointer to some documentation regarding<br>\nthe 'compose_no_flatten' function. It seems that Thomas' suggestion with<br>\n'protect' could be related to this one.</p>\n<p>Apologies for the length.</p>\n<p>Best,</p>\n<hr>\n<p>Matej<br>\n<a href=\"/user_uploads/14278/MyB8IP7uDS0ZhWUq9DDC9iNX/signature.asc\">signature.asc</a></p>",
        "id": 294141366,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845936
    },
    {
        "content": "<p>From: Matej Urbas &lt;<a href=\"mailto:mu232@cam.ac.uk\">mu232@cam.ac.uk</a>&gt;<br>\nOn Sun, 2011-07-10 at 20:16 +1000, Thomas Sewell wrote:</p>\n<blockquote>\n<p>Hi Matej,</p>\n<p>Two interesting things have happened. The first is that Goal.prove has lifted your meta-quantified conclusion (/\\s1 s2. P s1 s2) into a schematically quantified theorem (P ?s1 ?s2). The internal ==&gt; implications within your conclusion sg2 are now treated together with the sg1 ==&gt; sg2 implication as a group of assumptions. This may make compose_tac surprise you. You've told it you want to have only 1 new goal - if I recall correctly that will be the final assumption of the supplied theorem, so try rotating the sg1 assumption to the end.</p>\n<p>If that fails, you could try to stop Goal.prove lifting your meta-quantification. Playing around with the (invisible) protect constant might help you - look up protectI or protectD, No promises. Alternatively you could sidestep Goal.prove entirely by creating Thm.trivial from sg1 ==&gt; sg2 and applying your tactic to eliminate the first assumption.</p>\n</blockquote>\n<p>Thank you very much Thomas. I will try both.</p>\n<p>Do you think using 'Goal.protect' or 'Goal.conclude' would do the job?</p>\n<blockquote>\n<p>Can't be bothered firing up Isabelle on a weekend to test any of these strategies for you. Good luck.</p>\n</blockquote>\n<p>Still, thank you very much for the pointers. :)</p>\n<p>Best,</p>\n<hr>\n<p>Matej<br>\n<a href=\"/user_uploads/14278/2bAaY__7HT1stOYUhHp4ejQz/signature.asc\">signature.asc</a></p>",
        "id": 294141385,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845942
    },
    {
        "content": "<p>From: Holger Gast &lt;<a href=\"mailto:gast@informatik.uni-tuebingen.de\">gast@informatik.uni-tuebingen.de</a>&gt;<br>\nHi Matej,</p>\n<p>The short answer is: If you use Goal.prove_internal instead of Goal.prove,<br>\nyour approach works just fine. (See the code below.)</p>\n<p>The function Goal.prove_internal is merely a wrapper for Goal.init /<br>\nGoal.conclude (+ introducing &amp; discharging assumptions), and init/conclude<br>\nperform the internal fiddling with the invisible protect constant for you.<br>\nA quick grep over the sources shows that prove_internal and compose_tac are<br>\nused by tools and internal code, presumably to do similar low-level goal<br>\nmanipulations.</p>\n<p>I'm sure this solution is not entirely orthodox, but since it worked<br>\nfor me in many similar situations where I needed precise control over<br>\nthe entire subgoal structure, I thought I'd share it none the less.</p>\n<p>Holger</p>\n<p>lemma sg1:<br>\n  \"⋀s1 s2. ⟦distinct [s1, s2]; s1 ∈ A; s1 ∈ B; s2 ∈ A; s2 ∉ B⟧ ⟹<br>\n        ∃s1 s2. distinct [s1, s2] ∧ s1 ∈ A ∧ s2 ∈ B\"<br>\n  apply (tactic {*<br>\n    SUBGOAL<br>\n     (fn (sg1,i) =&gt;<br>\n       let val ctxt = @{context}<br>\n           val sg2 = @{term \"⋀s1 s2. ⟦distinct[s1, s2]; s1 ∈ A ∩ B; s2 ∈ A - B⟧<br>\n⟹ (∃s1 s2.<br>\n                       distinct[s1, s2] ∧ s1 ∈ A ∧ s2 ∈ B)\"}<br>\n           val intert = Logic.mk_implies (sg2, sg1)<br>\n           val intert_cterm = Thm.cterm_of (ProofContext.theory_of ctxt) intert<br>\n           val _ = tracing (\"Have \"^Syntax.string_of_term @{context} intert)<br>\n           val interThm = Goal.prove_internal [] intert_cterm<br>\n                (K ((auto_tac (clasimpset_of ctxt)) THEN (ALLGOALS<br>\n(Intuitionistic.prover_tac<br>\n                    ctxt NONE))))<br>\n           val _ = tracing (\"Interm: \"^Display.string_of_thm @{context} interThm)<br>\n       in<br>\n          compose_tac (false, interThm, 1) i<br>\n      end) 1<br>\n  *})</p>",
        "id": 294141397,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845948
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 10 Jul 2011, Matej Urbas wrote:</p>\n<blockquote>\n<p>My particular use case dictates behaviour as was previously described. <br>\nFrankly, I do not mind how I achieve it. The initially mentioned method <br>\n(with compose_tac) was just the first one I discovered. I must admit, it <br>\nis hard to see right for wrong -- especially since there are no hints <br>\nthat could steer me away from the wrong path.</p>\n<p>Also, do you mind if I ask for a pointer to some documentation regarding <br>\nthe 'compose_no_flatten' function. It seems that Thomas' suggestion with <br>\n'protect' could be related to this one.</p>\n</blockquote>\n<p>When I hear \"dictates\", I am almost certain that it only accidental to the <br>\nattempts so far to get this done quickly, and not inherent to the problem. <br>\nI reckon that we can safely forget any tricks with \"compose_no_flatten\" or <br>\n\"protect\" for the rest of this thread, and use the natural Isabelle rule <br>\ncomposition schemes instead.</p>\n<blockquote>\n<p>Sadly, there is specific demand for it. An external reasoner produces an <br>\n'inference step instance' of the form:</p>\n<p>sg2<br>\n       ------- (magic)<br>\n         sg1</p>\n<p>and I have to 'replace' sg1 with sg2, as it were. (While verifying this <br>\ninference step instance with Isabelle's tactics.)</p>\n</blockquote>\n<blockquote>\n<p>I am having a bit of problems using 'compose_tac' with an intermediate<br>\ntheorem (produced with mk_implies + Goal.prove).</p>\n</blockquote>\n<blockquote>\n<p>The next step is to use interThm in 'compose_tac', which is applied on<br>\nthe original goal sg1:</p>\n<p>compose_tac (false, interThm, 1) i</p>\n<p>which fails.</p>\n</blockquote>\n<p>Above you say \"While verifying this inference step instance with <br>\nIsabelle's tactics\".  If this is so, then it is natural to stay within the <br>\nregular framework, as these tactics do anyway.  What is the purpose of <br>\nmk_implies + Goal.prove?  Normally you can just work in-place, by <br>\naddressing the subgoal using SUBGOAL, or on an isolated state via <br>\nSELECT_GOAL or Subgoal.FOCUS.</p>\n<p>If the \"magic\" above is by a totally alien tool, you can also apply <br>\nObject_Logic.full_atomize_tac first, then work on a close HOL proposition, <br>\nthen apply the result using plain resolve_tac. (A common trap is to get <br>\ntypes too general in examples, then the statement cannot be internalized <br>\ninto HOL.)</p>\n<p>Makarius</p>",
        "id": 294141418,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845954
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nGrepping through the sources (or using hypersearch in jEdit) is indeed <br>\nvery important to get an idea how common certain operations are.</p>\n<p>Goal.prove_internal shows up very rarely, in special situations or ported <br>\nversions of quite old tools (the latter aspect can be seen from the <br>\nMercurial history, if this extra time is spent with it).</p>\n<p>We are getting at an interesting collection of odds and ends of internal <br>\nsystem tools.  I maintain that it is possible to ignore all this for <br>\nregular applications, and just use the standard system structures around <br>\nthe Pure rule calculus and its goal format, without lots of workarounds.</p>\n<p>Makarius</p>",
        "id": 294141430,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845960
    },
    {
        "content": "<p>From: Matej Urbas &lt;<a href=\"mailto:mu232@cam.ac.uk\">mu232@cam.ac.uk</a>&gt;<br>\nFantastic, thank you very much, Holger. This solved my problems<br>\nperfectly.</p>\n<p>Kind regards,</p>\n<hr>\n<p>Matej<br>\n<a href=\"/user_uploads/14278/MgXSP4N7hnoVsDMHOvFzO1xh/signature.asc\">signature.asc</a></p>",
        "id": 294141497,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845973
    },
    {
        "content": "<p>From: Matej Urbas &lt;<a href=\"mailto:mu232@cam.ac.uk\">mu232@cam.ac.uk</a>&gt;<br>\nI see. It makes perfect sense (under the assumption that the definition<br>\nof 'regular applications' leans favourably and reasonably towards users'<br>\nrequirements).</p>\n<p>In any case, is it possible to get the same fine-grained control (and<br>\nexactly the same behaviour) as Holger's proposal using the standard<br>\nworkflow?</p>\n<p>Best,</p>\n<hr>\n<p>Matej<br>\n<a href=\"/user_uploads/14278/nqjF8LXofrzomFZ-BouqMTlD/signature.asc\">signature.asc</a></p>",
        "id": 294141505,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845979
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 11 Jul 2011, Matej Urbas wrote:</p>\n<blockquote>\n<p>I see. It makes perfect sense (under the assumption that the definition <br>\nof 'regular applications' leans favourably and reasonably towards users' <br>\nrequirements).</p>\n</blockquote>\n<p>Yes it does.  These things have taken a certain form over many years. It <br>\nis unwise to ignore all the experience behind it.  By doing this the <br>\n\"canonical way\", it is easier to get them right, and easier to read and <br>\nmaintain.  All the obvious things ...</p>\n<blockquote>\n<p>In any case, is it possible to get the same fine-grained control (and <br>\nexactly the same behaviour) as Holger's proposal using the standard <br>\nworkflow?</p>\n</blockquote>\n<p>You still did not explain what you are trying to do exactly.  I was about <br>\nto disprove your assumptions.</p>\n<p>There are <em>rare</em> situations where one needs to step outside the standard <br>\nframework, e.g. when implementing new infrastructure.  Empirically it is <br>\nvery unlikely that this is the situation here, unless you prove it <br>\notherwise.</p>\n<p>Makarius</p>",
        "id": 294141513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845985
    },
    {
        "content": "<p>From: Sascha Boehme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt;<br>\nMakarius wrote:<br>\nIt would be of much help if you further clarified your application,<br>\nespecially what kind of problems you are solving and how you connect<br>\nthe external tool (i.e., how you feed the subgoal to the external tool<br>\nand what comes of out it afterwards).  As Makarius already pointed<br>\nout, it is likely that your integration can be tuned towards standard<br>\noperations (which won't be deprecated in the next Isabelle release).</p>\n<p>In the meantime, here is a somewhat more standard approach to solve<br>\nyour issue, although still using the odd detour via Goal.prove:</p>\n<p>ML {*<br>\n  fun replace_subgoal_tac ctxt t =<br>\n    Object_Logic.full_atomize_tac<br>\n    THEN' SUBGOAL (fn (u, i) =&gt;<br>\n      let<br>\n        val thm = Goal.prove ctxt [] [] (Logic.mk_implies (t, u))<br>\n          (fn {context, ...} =&gt; auto_tac (clasimpset_of context))<br>\n      in Tactic.rtac thm i end)<br>\n*}</p>\n<p>lemma<br>\n  \"\\&lt;And&gt;s1 s2.<br>\n     \\&lt;lbrakk&gt;distinct [s1, s2]; s1 \\&lt;in&gt; A; s1 \\&lt;in&gt; B; s2 \\&lt;in&gt; A;<br>\n       s2 \\&lt;notin&gt; B\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt;<br>\n     \\&lt;exists&gt;s1 s2. distinct [s1, s2] \\&lt;and&gt; s1 \\&lt;in&gt; A \\&lt;and&gt;<br>\n       s2 \\&lt;in&gt; B\"<br>\n  apply (tactic {* replace_subgoal_tac @{context} @{term<br>\n    \"\\&lt;And&gt;s1 s2.<br>\n       \\&lt;lbrakk&gt;distinct[s1, s2]; s1 \\&lt;in&gt; A \\&lt;inter&gt; B;<br>\n         s2 \\&lt;in&gt; A - B\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt;<br>\n       \\&lt;exists&gt;s1 s2. distinct[s1, s2] \\&lt;and&gt; s1 \\&lt;in&gt; A \\&lt;and&gt;<br>\n         s2 \\&lt;in&gt; B\"} 1 *})</p>\n<p>Cheers,<br>\nSascha</p>",
        "id": 294141559,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846003
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is one more trick using more modern concepts -- I have just seen in <br>\nan incoming changset by Florian Haftmann:</p>\n<p>notepad<br>\nbegin</p>\n<p>have \"!!x y. x = y ==&gt; y = x\"<br>\n     apply (fact sym)<br>\n     done</p>\n<p>end</p>\n<p>In ML this is ProofContext.fact_tac.  It unifies rules against each other, <br>\nwithout taking the implication structure apart.</p>\n<p>The nice thing about using \"canonical\" soluations is that you can switch <br>\nbetween Isar source language and ML back and forth in the exploration. <br>\nIn contrast, odd things like Goal.prove_internal are not part of the Isar <br>\ninfrastructure.  This is what I meant by \"standing naked in the rain\".</p>\n<p>Makarius</p>",
        "id": 294141566,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846009
    }
]