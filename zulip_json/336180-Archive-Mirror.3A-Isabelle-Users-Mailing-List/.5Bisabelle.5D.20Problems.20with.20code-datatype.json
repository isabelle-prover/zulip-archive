[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I currently have some trouble when trying to build code for types with invariants.<br>\nIn principle, I have some </p>\n<p>typedef foo = {b :: bar. P b} ...</p>\n<p>and now want to construct some function which creates objects of type bar as follows:</p>\n<p>setup_lifting type_definition_foo</p>\n<p>lift_definition create_foo :: \"bar =&gt; foo option\" is \"% b. if P b then Some b else None\" ...</p>\n<p>However, then I cannot create code for create_foo:<br>\na simple <br>\n  export_code create_foo in Haskell<br>\nfails.</p>\n<p>Reading the manual on code-generation and \"Data Refinement in Isabelle/HOL\", I realized that<br>\npage 109 it is mentioned that for abstract type A and concrete type C one can<br>\nlift a function f :: C =&gt; (C)θ =&gt; C to a function f whose type should be A =&gt; (A)θ =&gt; A.<br>\nSo does that mean that I won't be able to define my function create_foo as essentially it is<br>\nof type C =&gt; A?</p>\n<p>Any help is appreciated,</p>\n<p>Kind regards,<br>\nRené</p>\n<p>PS: Below you find a more detailed example</p>\n<p>theory Test<br>\nimports  <br>\n  Main<br>\nbegin</p>\n<p>datatype test = A | B | C<br>\ntypedef no_B = \"{ t :: test. t ~= B}\" by auto</p>\n<p>setup_lifting type_definition_no_B</p>\n<p>lift_definition get_test :: \"no_B =&gt; test\" <br>\n  is \"% x. x\" .</p>\n<p>lift_definition get_no_B :: \"test =&gt; no_B option\" <br>\n  is \"% t. if t = B then None else Some t\" <br>\n  by auto</p>\n<p>export_code get_test in Haskell <br>\n(* works fine *)</p>\n<p>export_code get_no_B in Haskell<br>\n(* No code equations for get_no_B *)</p>\n<p>declare get_no_B.abs_eq[code]</p>\n<p>export_code get_no_B in Haskell<br>\n(* Abstraction violation<br>\n(in code equation get_no_B ?x ≡<br>\n                  map_option Abs_no_B<br>\n                   (if equal_test_inst.equal_test ?x<br>\n                        B<br>\n                    then None else Some ?x)):<br>\nconstant Abs_no_B *)<br>\n(* somehow the violation is just because the criterion seems to be purely<br>\n   syntactic. Via the if-then-else it is guaranteed that the invariant of <br>\n   no_B is satisfied ! *)</p>",
        "id": 294306952,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924619
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear René,</p>\n<p>This is not quite true, as you can define</p>\n<p>lift_definition g:: \"test =&gt; no_B \"<br>\n   is \"% t. if t = B then A else t\"<br>\n   by auto</p>\n<p>and the code generation works fine. In terms of</p>\n<p>lift_definition get_no_B :: \"test =&gt; no_B option\"<br>\n   is \"% t. if t = B then None else Some t\"<br>\n   by auto</p>\n<p>I think the problem is with</p>\n<p>get_no_B.rep_eq: map_option Rep_no_B (get_no_B ?x) = (if ?x = B then <br>\nNone else Some ?x)</p>\n<p>An ideal code abstract equation for type no_B is of the form</p>\n<p>Rep_no_B (f ...) = ...</p>\n<p>so that code equations that preserve invariants of no_B could be derived <br>\nfor f. Lemma get_no_B.rep_eq does not match such format, and I guess <br>\nthat is why code generation fails for get_no_B (although in theory I <br>\nthink we can still derive code equations in such cases). Experts on data <br>\nrefinements should be able to comment more ;-)</p>\n<p>Hope this helps,<br>\nWenda</p>",
        "id": 294306967,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924625
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Wenda,</p>\n<blockquote>\n<blockquote>\n<p>Reading the manual on code-generation and \"Data Refinement in Isabelle/HOL\", I realized that<br>\npage 109 it is mentioned that for abstract type A and concrete type C one can<br>\nlift a function f :: C =&gt; (C)? =&gt; C to a function f whose type should be A =&gt; (A)? =&gt; A.<br>\nSo does that mean that I won't be able to define my function create_foo as essentially it is<br>\nof type C =&gt; A?</p>\n</blockquote>\n<p>This is not quite true, as you can define</p>\n<p>lift_definition g:: \"test =&gt; no_B \"<br>\n is \"% t. if t = B then A else t\"<br>\n by auto</p>\n<p>and the code generation works fine. In terms of</p>\n<p>lift_definition get_no_B :: \"test =&gt; no_B option\"<br>\n is \"% t. if t = B then None else Some t\"<br>\n by auto</p>\n<p>I think the problem is with</p>\n<p>get_no_B.rep_eq: map_option Rep_no_B (get_no_B ?x) = (if ?x = B then None else Some ?x)</p>\n</blockquote>\n<p>I fully agree.</p>\n<blockquote>\n<p>An ideal code abstract equation for type no_B is of the form</p>\n<p>Rep_no_B (f ...) = ...</p>\n<p>so that code equations that preserve invariants of no_B could be derived for f. Lemma get_no_B.rep_eq does not match such format, and I guess that is why code generation fails for get_no_B (although in theory I think we can still derive code equations in such cases).</p>\n</blockquote>\n<p>Again I agree, in principle the test ensures that no bad terms can walk below an Abs_no_B.</p>\n<blockquote>\n<p>Experts on data refinements should be able to comment more ;-)</p>\n<p>Hope this helps,</p>\n</blockquote>\n<p>Definitely it was helpful, thanks a lot. Based on your definition of get_no_B I now could modify my code as follows to my original setting, which now is code-exportable.</p>\n<p>datatype test = A | B | C<br>\ntypedef no_B = \"{ t :: test. t ~= B}\" by auto</p>\n<p>setup_lifting type_definition_no_B</p>\n<p>lift_definition get_test :: \"no_B =&gt; test\" <br>\n  is \"% x. x\" .</p>\n<p>lift_definition get_no_B' :: \"test =&gt; no_B\" <br>\n  is \"% t. if t = B then A else t\" <br>\n  by auto</p>\n<p>definition get_no_B :: \"test =&gt; no_B option\" where<br>\n  \"get_no_B t = (if t = B then None else Some (get_no_B' t))\"</p>\n<p>lemma get_no_B: \"get_no_B t = Some no_b ==&gt; <br>\n  get_test no_b = t\" <br>\n  unfolding get_no_B_def<br>\n  by (cases \"t = B\", simp_all, transfer, auto)</p>\n<p>export_code get_test in Haskell <br>\nexport_code get_no_B in Haskell </p>\n<p>However, this solution has the small problem, that the test \"t = B\" is done in both<br>\nget_no_B and get_no_B'. In my real application this test \"t = B\" is a bit more complicated to<br>\ncompute, so still the solution is not optimal. (The original definition of get_no_B only had <br>\none test \"t = B\")</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294306993,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924633
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi René,</p>\n<p>You can avoid the duplicate test by lifting the invariant no_B to the type \"no_B option\". <br>\nTo that end, you have to introduce another type constructor, say no_B_option (see below <br>\nfor an adaptation of your example). The tricky bit is to get from no_B_option back to no_B <br>\noption. There, you must not use lifting in the result type; otherwise, the same problem <br>\nreoccurs. Here, I use a a case combinator, but your real use case might require something <br>\nelse.</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>datatype test = A | B | C<br>\ntypedef no_B = \"{ t :: test. t ~= B}\" by auto</p>\n<p>setup_lifting type_definition_no_B</p>\n<p>lift_definition A_no_B :: \"no_B\" is A by simp<br>\nlift_definition C_no_B :: \"no_B\" is C by simp</p>\n<p>typedef no_B_option = \"{x. B ∉ set_option x}\" by auto</p>\n<p>setup_lifting type_definition_no_B_option</p>\n<p>lift_definition get_no_B' :: \"test ⇒ no_B_option\"<br>\nis \"λt . if t = B then None else Some t\" by simp</p>\n<p>lift_definition unpack_no_B_option :: \"no_B_option ⇒ no_B option\"<br>\nis \"λx. (case x of None ⇒ None | Some A ⇒ Some A_no_B | Some C ⇒ Some C_no_B)\" .</p>\n<p>definition get_no_B :: \"test ⇒ no_B option\"<br>\nwhere \"get_no_B t = unpack_no_B_option (get_no_B' t)\"</p>\n<p>export_code get_no_B</p>",
        "id": 294307056,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924662
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<blockquote>\n<p>However, this solution has the small problem, that the test \"t = B\" is done in both<br>\nget_no_B and get_no_B'. In my real application this test \"t = B\" is a bit more complicated to<br>\ncompute, so still the solution is not optimal. (The original definition of get_no_B only had<br>\none test \"t = B\")<br>\nYou can avoid the duplicate test by lifting the invariant no_B to the type \"no_B option\". To that end, you have to introduce another type constructor, say no_B_option (see below for an adaptation of your example). The tricky bit is to get from no_B_option back to no_B option. There, you must not use lifting in the result type; otherwise, the same problem reoccurs.</p>\n</blockquote>\n</blockquote>\n<p>First of all, thanks for your hints.</p>\n<p>Unfortunately I was not able to adapt your proposed solution to my case for the following reasons.</p>\n<p>1) I do not see why in your solution there is only one test \"t = B\":<br>\n   in get_noB' there definitely is one \"t = B\" test, and the second one is hidden in<br>\n   unpack_no_B_option, where again you make a case analysis which seems similar to a \"t = B\" test,<br>\n   i.e., here you have to choose the reason why the value is in no_B (whether it is the reason A or C)</p>\n<p>2) I did not understand why the type-copy no_B_option should help at all: with A_no_B and C_no_B at hand you can<br>\n   more easily and directly define</p>\n<p>definition get_no_B :: \"test =&gt; no_B option\" where<br>\n     \"get_no_B t == if t = B then None else case t of A =&gt; Some A_no_B | C =&gt; Some C_no_B\"</p>\n<p>or even </p>\n<p>definition get_no_B :: \"test =&gt; no_B option\" where<br>\n     \"get_no_B t == case t of A =&gt; Some A_no_B | B =&gt; None | C =&gt; Some C_no_B\"</p>\n<blockquote>\n<p>Here, I use a a case combinator, but your real use case might require something else.</p>\n</blockquote>\n<p>3) Exactly. In my real case I have </p>\n<p>typedef special_functions = \"{ f :: nat =&gt; nat. P f}\" </p>\n<p>where P is some predicate of interest on functions. Here, I do not see how I can easily write functions similar to \"A_no_B\" or \"C_no_B\" <br>\nwhich always create objects of special_function type (without actually checking P). <br>\nThis would then again lead to two invocations of checking P: one in the function corresponding to \"A_no_B\", and the other similar to get_no_B <br>\nwith then checks whether it should return None or Some.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294307260,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924729
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi René,</p>\n<p>On 30/09/14 15:14, René Thiemann wrote:</p>\n<blockquote>\n<p>1) I do not see why in your solution there is only one test \"t = B\":<br>\n    in get_noB' there definitely is one \"t = B\" test, and the second one is hidden in<br>\n    unpack_no_B_option, where again you make a case analysis which seems similar to a \"t = B\" test,<br>\n    i.e., here you have to choose the reason why the value is in no_B (whether it is the reason A or C)<br>\nThat's right. I just thought that a case analysis is faster than a complicated predicate <br>\ntest, but at second thought it does not buy you anything.</p>\n</blockquote>\n<blockquote>\n<p>2) I did not understand why the type-copy no_B_option should help at all: with A_no_B and C_no_B at hand you can<br>\n    more easily and directly define</p>\n<p>definition get_no_B :: \"test =&gt; no_B option\" where<br>\n      \"get_no_B t == if t = B then None else case t of A =&gt; Some A_no_B | C =&gt; Some C_no_B\"</p>\n<p>or even</p>\n<p>definition get_no_B :: \"test =&gt; no_B option\" where<br>\n      \"get_no_B t == case t of A =&gt; Some A_no_B | B =&gt; None | C =&gt; Some C_no_B\"<br>\nThe idea for the type copy comes from the paper on Data Refinement, as I have answered on <br>\nstackexchange some time ago:</p>\n</blockquote>\n<p><a href=\"http://stackoverflow.com/questions/16040064/isabelles-code-generation-abstraction-lemmas-for-containers\">http://stackoverflow.com/questions/16040064/isabelles-code-generation-abstraction-lemmas-for-containers</a></p>\n<p>However, this does not solve your problem with duplicate testing. In a follow-up thread, <br>\nJoachim describes a solution to avoid duplicate tests:</p>\n<p><a href=\"http://stackoverflow.com/questions/16273812/working-with-isabelles-code-generator-data-refinement-and-higher-order-functio\">http://stackoverflow.com/questions/16273812/working-with-isabelles-code-generator-data-refinement-and-higher-order-functio</a></p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294307324,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924754
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nHi Andreas,</p>\n<p>thanks for this reference. Joachim's solution can perfectly be adapted to our application, and indeed now we also require only one test.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294317120,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925784
    }
]