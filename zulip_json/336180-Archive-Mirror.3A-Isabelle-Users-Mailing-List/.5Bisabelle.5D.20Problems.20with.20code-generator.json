[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>below you find an example where target-language<br>\nnatural numbers are not properly supported in combination<br>\nwith pattern matching. </p>\n<p>Consider the following theory:</p>\n<p>theory Test<br>\nimports  <br>\n  \"~~/src/HOL/Library/Code_Binary_Nat\"  <br>\nbegin</p>\n<p>fun foo :: \"nat * 'a list =&gt; bool\" where<br>\n  \"foo (Suc 0, (x # xs)) = True\"<br>\n| \"foo (Suc 0, []) =  False\"<br>\n| \"foo p = True\"</p>\n<p>export_code foo in Haskell</p>\n<p>Using Code_Binary_Nat, the export_code raises an error<br>\n\"Nat.Suc\" is not a constructor, on left hand side of equation, in theorem:<br>\nfoo (Suc ?vc, ?x # ?xs) ≡ if equal_nat_inst.equal_nat ?vc zero_nat_inst.zero_nat then True else True</p>\n<p>whereas it does not occur if Code_Binary_Nat is not imported.</p>\n<p>Moreover, the error does not occur if I only do pattern matching on <br>\nnatural numbers, but not on the lists.</p>\n<p>The problem occurs in both Isabelle2013-2 and development version ede82d6e0abd.</p>\n<p>Kind regards,<br>\nRené</p>",
        "id": 294272515,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917655
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi René,</p>\n<p>Code_Binary_Nat contains an ML function that tries to replace Suc patterns on left-hand <br>\nsides while preprocessing the code equations. When natural numbers are implemented by <br>\ntarget-language numbers, Suc patterns must not appear on the left-hand sides of equations <br>\nany more. It is well-known that the conversion function is not complete, e.g. from this <br>\nthread from 2011:</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-April/msg00012.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-April/msg00012.html</a></p>\n<p>You probably have to manually write a code equation for foo that pattern-matches on Suc <br>\nonly on right-hand sides or not at all.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294272621,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917694
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>Code_Binary_Nat contains an ML function that tries to replace Suc patterns on left-hand sides while preprocessing the code equations. When natural numbers are implemented by target-language numbers, Suc patterns must not appear on the left-hand sides of equations any more.</p>\n</blockquote>\n<p>The latter is obvious.</p>\n<blockquote>\n<p>It is well-known that the conversion function is not complete, e.g. from this thread from 2011:</p>\n</blockquote>\n<p>I missed this knowledge and supposed that the conversion would/should be complete.</p>\n<blockquote>\n<p>You probably have to manually write a code equation for foo that pattern-matches on Suc only on right-hand sides or not at all.</p>\n</blockquote>\n<p>Obviously, hand written code-equations circumvent the problem (which is what I currently do). However, no one wants to<br>\nprovide manual code-equations for each function that performs pattern matching on Suc.<br>\nThis is why I hoped for completeness of the ML function to convert Suc patterns.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294272628,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917698
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nAm 17.03.2014 09:22, schrieb Andreas Lochbihler:</p>\n<blockquote>\n<p>Hi René,</p>\n<p>Code_Binary_Nat contains an ML function that tries to replace Suc <br>\npatterns on left-hand sides while preprocessing the code equations. <br>\nWhen natural numbers are implemented by target-language numbers, Suc <br>\npatterns must not appear on the left-hand sides of equations any more. <br>\nIt is well-known that the conversion function is not complete, e.g. <br>\nfrom this thread from 2011:</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-April/msg00012.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-April/msg00012.html</a> </p>\n<p>You probably have to manually write a code equation for foo that <br>\npattern-matches on Suc only on right-hand sides or not at all.<br>\ncase_of_simps (cf. HOL/Library/Simps_Case_Conv.thy and <br>\nHOL/ex/Simps_Case_Conv_Examples.thy) might help automating this task.</p>\n</blockquote>\n<p>Dmitriy</p>\n<blockquote>\n<p>Best,<br>\nAndreas</p>\n<p>On 14/03/14 20:06, René Thiemann wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>below you find an example where target-language<br>\nnatural numbers are not properly supported in combination<br>\nwith pattern matching.</p>\n<p>Consider the following theory:</p>\n<p>theory Test<br>\nimports<br>\n   \"~~/src/HOL/Library/Code_Binary_Nat\"<br>\nbegin</p>\n<p>fun foo :: \"nat * 'a list =&gt; bool\" where<br>\n   \"foo (Suc 0, (x # xs)) = True\"<br>\n| \"foo (Suc 0, []) =  False\"<br>\n| \"foo p = True\"</p>\n<p>export_code foo in Haskell</p>\n<p>Using Code_Binary_Nat, the export_code raises an error<br>\n\"Nat.Suc\" is not a constructor, on left hand side of equation, in <br>\ntheorem:<br>\nfoo (Suc ?vc, ?x # ?xs) ≡ if equal_nat_inst.equal_nat ?vc <br>\nzero_nat_inst.zero_nat then True else True</p>\n<p>whereas it does not occur if Code_Binary_Nat is not imported.</p>\n<p>Moreover, the error does not occur if I only do pattern matching on<br>\nnatural numbers, but not on the lists.</p>\n<p>The problem occurs in both Isabelle2013-2 and development version <br>\nede82d6e0abd.</p>\n<p>Kind regards,<br>\nRené<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294272654,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917704
    }
]