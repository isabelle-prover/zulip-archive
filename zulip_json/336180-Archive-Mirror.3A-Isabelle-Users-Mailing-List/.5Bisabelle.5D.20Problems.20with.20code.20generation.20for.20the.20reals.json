[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Jesus,</p>\n<blockquote>\n<p>we were trying to generate code<br>\nfor matrices of real numbers; we had been doing some experiments with<br>\nreal numbers represented in SML by fractions of elements of type<br>\n\"<a href=\"http://IntInf.int\">IntInf.int</a>\", but doing some profiling we detected that most of the<br>\nexecution time was spent in computing the functions \"gcd\", \"divmod\",<br>\n\"quotrem\", \"normalize\" and so on, instead of on performing the<br>\noperations over matrices that were really interesting for us.</p>\n<p>We thought that giving a chance to Code_Real_Approx_By_Float could be<br>\nworth (even if we read about its potential accuracy matters), just to<br>\nsee if we could reduce computing times of the arithmetic operations.</p>\n<p>Unfortunately, we got some problems with the Library, when generating<br>\ncode, that we don't know how to avoid.</p>\n</blockquote>\n<p>The sort answer: insert the following snippet at the beginning of your<br>\nexample theory:</p>\n<blockquote>\n<p>code_const Ratreal (SML)</p>\n<p>definition Realfract :: \"int ⇒ int ⇒ real\"<br>\nwhere<br>\n  \"Realfract p q = of_int p / of_int q\"</p>\n<p>code_datatype Realfract</p>\n<p>code_const Realfract<br>\n  (SML \"Real.fromInt _/ '// Real.fromInt _\")</p>\n<p>lemma [code]:<br>\n  \"Ratreal r = split Realfract (quotient_of r)\"<br>\n  by (cases r) (simp add: Realfract_def quotient_of_Fract of_rat_rat)</p>\n<p>lemma [code, code del]:<br>\n  \"(plus :: real ⇒ real ⇒ real) = plus\"<br>\n  ..</p>\n<p>lemma [code, code del]:<br>\n  \"(times :: real ⇒ real ⇒ real) = times\"<br>\n  ..</p>\n<p>lemma [code, code del]:<br>\n  \"(divide :: real ⇒ real ⇒ real) = divide\"<br>\n  ..</p>\n<p>lemma [code]:<br>\n  fixes r :: real<br>\n  shows \"inverse r = 1 / r\"<br>\n  by (fact inverse_eq_divide)</p>\n</blockquote>\n<p>Code_Real_Approx_By_Float seems indeed to be very approximative since it<br>\ncannot handle real numerals.  This snippet amends this by a specific<br>\ndatatype constructor Realfract which is then mapped to a SML expression.</p>\n<p>This renders all code equations using the original datatype constructor<br>\nRatreal invalid, and they must be dropped explicitly using the funny<br>\n[code, code del] pattern on reflexive equations.  I added only the ones<br>\nnecessary for your examples, their might be more.  Inversions seems not<br>\nbe implemented in Code_Real_Approx_By_Float, but it can be easily<br>\ndelegated to division on reals which is.</p>\n<p>@Johannes: Maybe this stuff should be added to Code_Real_Approx_By_Float?</p>\n<blockquote>\n<p>In the file there can be also found some definitions from the SML<br>\nstructure \"Vector\" (or type iarray, in Isabelle); we read your comment<br>\non <a href=\"http://isabelle.in.tum.de/library/HOL/HOL-Library/IArray.html\">http://isabelle.in.tum.de/library/HOL/HOL-Library/IArray.html</a> and<br>\nthought that the functions might be useful for someone else.</p>\n</blockquote>\n<p>This is indeed work by Tobias.  I did not experience any problem with it<br>\nin your examples.</p>\n<p>To get back to your original observation:</p>\n<blockquote>\n<p>we had been doing some experiments with<br>\nreal numbers represented in SML by fractions of elements of type<br>\n\"<a href=\"http://IntInf.int\">IntInf.int</a>\", but doing some profiling we detected that most of the<br>\nexecution time was spent in computing the functions \"gcd\", \"divmod\",<br>\n\"quotrem\", \"normalize\" and so on, instead of on performing the<br>\noperations over matrices that were really interesting for us.</p>\n</blockquote>\n<p>It is indeed questionable whether it is a good idea to normalize<br>\nquotients always.  What do others implementations do here (e.g. Ocaml)?<br>\n The implementation of rational numbers can be changed in user space<br>\nusing the usual mechanisms of datatype refinement (see the tutorial on<br>\ncode generation and the upcoming ITP paper<br>\n<a href=\"http://isabelle.in.tum.de/~haftmann/pdf/data_refinement_haftmann_kuncar_krauss_nipkow.pdf\">http://isabelle.in.tum.de/~haftmann/pdf/data_refinement_haftmann_kuncar_krauss_nipkow.pdf</a>).</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/OYcKZdvCyVg-FMWvdOjFVTK-/signature.asc\">signature.asc</a></p>",
        "id": 294238974,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906123
    },
    {
        "content": "<p>From: Jesus Aransay &lt;<a href=\"mailto:jesus-maria.aransay@unirioja.es\">jesus-maria.aransay@unirioja.es</a>&gt;<br>\nDear all,</p>\n<p>regarding the mail I sent to Florian, I just wanted to add some<br>\nfigures about the performance of our algorithm computing the reduced<br>\nrow echelon form of a matrix; the algorithm is refined to \"iarrays\"<br>\n(<a href=\"http://isabelle.in.tum.de/library/HOL/HOL-Library/IArray.html\">http://isabelle.in.tum.de/library/HOL/HOL-Library/IArray.html</a>) to<br>\nrepresent matrices. We implemented the algorithm over fields, and<br>\ngenerated the ML code associated to the algorithm. We used MLton to<br>\ncompile the code and execute it over some instances of matrices; the<br>\nresults obtained when profiling are the following ones.</p>\n<p>The following example is a randomly generated matrix of dimension<br>\n70*70 matrix with entries in the field \"Z / 2Z\"; these elements are<br>\ngenerated to \"0::<a href=\"http://IntInf.int\">IntInf.int</a>\" and \"1::<a href=\"http://IntInf.int\">IntInf.int</a>\", and the field<br>\noperations are defined by means of ad - hoc \"fun\" definitions<br>\n(execution time is 0.02 seconds).</p>\n<p>(*<br>\n0.02 seconds of CPU time (0.00 seconds GC)<br>\n         function            cur    raw</p>\n<hr>\n<p>Sequence.tabulate           50.0% (0.01s)<br>\nexample_70_x_70_Z2.plus_z2a 50.0% (0.01s)<br>\n*)</p>\n<p>The following are the results obtained for the very same matrix as in<br>\nthe previous example, but now the elements are labelled as being of<br>\ntype \"real\"; following the standard setup for code generation of reals<br>\nthey are generated in SML to fractions  of \"<a href=\"http://IntInf.int\">IntInf.int</a>\" (execution<br>\ntime gets multiplied by 100, most of the time is spent in computing<br>\nquotients and remainders):</p>\n<p>(*<br>\n2.46 seconds of CPU time (0.03 seconds GC)<br>\n                  function                    cur    raw</p>\n<hr>\n<p>Primitive.IntInf.bigQuot                     28.1% (0.70s)<br>\nPrimitive.IntInf.bigRem                      28.1% (0.70s)<br>\nPrimitive.IntInf.bigDivMod                   12.4% (0.31s)<br>\nPrimitive.IntInf.make                        12.0% (0.30s)<br>\nexample_70_x_70_binary_rat.abs_int            5.2% (0.13s)<br>\nexample_70_x_70_binary_rat.sgn_int            3.6% (0.09s)<br>\nexample_70_x_70_binary_rat.gcd_int            2.8% (0.07s)<br>\nexample_70_x_70_binary_rat.divmod_int         2.0% (0.05s)<br>\nexample_70_x_70_binary_rat.mod_int            1.6% (0.04s)<br>\n&lt;gc&gt;                                          1.2% (0.03s)<br>\nSequence.tabulate                             1.2% (0.03s)<br>\nexample_70_x_70_binary_rat.div_int            0.4% (0.01s)<br>\nexample_70_x_70_binary_rat.divmod_int.fn      0.4% (0.01s)<br>\nexample_70_x_70_binary_rat.apsnd              0.4% (0.01s)<br>\nexample_70_x_70_binary_rat.mult_iarray.fn.fn  0.4% (0.01s)<br>\n*)</p>\n<p>Finally, this third example is the result of applying the algorithm to<br>\na randomly generated \"70*70\" matrix, but in this case of real numbers<br>\nbetween 0 and 1000; they are again generated in SML to fractions of<br>\n\"<a href=\"http://IntInf.int\">IntInf.int</a>\":</p>\n<p>(*<br>\n46.14 seconds of CPU time (1.19 seconds GC)<br>\n            function               cur    raw</p>\n<hr>\n<p>Primitive.IntInf.bigRem           32.5% (15.37s)<br>\nPrimitive.IntInf.bigQuot          24.2% (11.46s)<br>\nPrimitive.IntInf.make             11.3%  (5.37s)<br>\nPrimitive.IntInf.bigDivMod         9.5%  (4.51s)<br>\nexample_70_x_70_rat.sgn_int        7.6%  (3.62s)<br>\nexample_70_x_70_rat.abs_int        6.1%  (2.87s)<br>\nexample_70_x_70_rat.divmod_int     2.9%  (1.35s)<br>\n&lt;gc&gt;                               2.5%  (1.19s)<br>\nexample_70_x_70_rat.gcd_int        1.4%  (0.65s)<br>\nexample_70_x_70_rat.mod_int        0.9%  (0.43s)<br>\nexample_70_x_70_rat.divmod_int.fn  0.7%  (0.34s)<br>\nexample_70_x_70_rat.apsnd          0.3%  (0.12s)<br>\nSequence.sub                       0.0%  (0.01s)<br>\nexample_70_x_70_rat.plus_rata      0.0%  (0.01s)<br>\nexample_70_x_70_rat.uminus_rata    0.0%  (0.01s)<br>\nexample_70_x_70_rat.div_int        0.0%  (0.01s)<br>\nPrimitive.IntInf.extdFromWord32    0.0%  (0.01s)<br>\n*)</p>\n<p>We thought that, in order to increase performance, it could be a good<br>\nidea  to try to use the SML \"Real\" type (as proposed in<br>\n<a href=\"http://isabelle.in.tum.de/library/HOL/HOL-Library/Code_Real_Approx_By_Float.html\">http://isabelle.in.tum.de/library/HOL/HOL-Library/Code_Real_Approx_By_Float.html</a>),<br>\ninstead of fractions of \"<a href=\"http://IntInf.int\">IntInf.int</a>\". Any other ideas would be also<br>\nwarmly welcome.</p>\n<p>Any suggestions are welcome,</p>\n<p>Jesus</p>",
        "id": 294239039,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906150
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust curious: How does that compared to Poly/ML, instead of Mlton?  It is <br>\nimportant here to distinguish Poly/ML with GNU MP and without.  (The <br>\nversion that is shipped with Isabelle2013 includes libgmp only for Linux, <br>\nand it should work for Windows/Cygwin as well, but not for Mac OS X -- I <br>\ndid not know how to compile that in a portable manner.)</p>\n<p>Makarius</p>",
        "id": 294241893,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907322
    },
    {
        "content": "<p>From: Jesus Aransay &lt;<a href=\"mailto:jesus-maria.aransay@unirioja.es\">jesus-maria.aransay@unirioja.es</a>&gt;<br>\nHi Makarius,</p>\n<p>the times compare as follows; a matrix of dimension 70 * 70 of real<br>\nnumbers (randomly generated, with entries between 0 and 1000) mapped<br>\nto fractions of \"<a href=\"http://IntInf.int\">IntInf.int</a>\" elements takes:</p>\n<ul>\n<li>\n<p>with MLton, 9 seconds to compile the stand-alone executable, 45<br>\nseconds of execution;</p>\n</li>\n<li>\n<p>with PolyML 5.5 (the version dispatched with Isabelle 2013), 111<br>\nseconds of execution;</p>\n</li>\n<li>\n<p>just for the record, with PolyML 5.2 (the version packaged for<br>\nubuntu), 350 seconds of execution.</p>\n</li>\n</ul>\n<p>Thanks for your interest,</p>\n<p>Jesus</p>",
        "id": 294242078,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907401
    }
]