[
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Akihisa,</p>\n<blockquote>\n<p>On 3 Oct 2017, at 17:58, Yamada, Akihisa &lt;<a href=\"mailto:Akihisa.Yamada@uibk.ac.at\">Akihisa.Yamada@uibk.ac.at</a>&gt; wrote:</p>\n<p>Dear Dmitriy,</p>\n<p>thanks for the explanation. If it sees \"sr :: real\" in the lemma statement but not in the proof, why does the following fail?</p>\n<p>lemma \"{x. cmod x = sr} = range (op * sr)\"<br>\nproof -<br>\nshow \"{x. cmod x = (sr :: real)} = range (op * (sr::real))\"<br>\noops</p>\n</blockquote>\n<p>It is the other way round: the show statement yields \"sr :: real\" annotations (since sr is fixed in the context). In the lemma statement \"sr\" is just a free type variable and its precise type is the result of type inference.</p>\n<blockquote>\n<p>If I further annotate the lemma statement, it will work.</p>\n<p>Anyway, if it's not a surprising outcome of the design, I'll be surprised by the design.</p>\n</blockquote>\n<p>I guess you are not surprised that the following fails (fortunately):</p>\n<p>lemma<br>\n  \"f x = x\"<br>\nproof -<br>\n  define f :: \"'a ⇒ 'a\" where \"f = id\"<br>\n  show \"f x = x\" unfolding f_def by simp<br>\nqed</p>\n<p>This example demonstrates that parsing in Isabelle is heavily context-dependent. You can not expect the same string to always evaluate to the same result. Admittedly, in your example the context modification happens implicitly (by fixing the free variables of a lemma in the context), while here the define is quite explicit.</p>\n<p>From the point of view of coercion inference, there is absolutely no way to view the two different input terms as the same.</p>\n<p>Cheers,<br>\nDmitriy</p>\n<blockquote>\n<p>Cheers,<br>\nAkihisa</p>\n<p>On 3 Oct 2017, at 13:39, Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi René,</p>\n<p>interesting observation, but not really surprising.</p>\n<p>After parsing (and inserting coercions into) the lemma statement, sr gets declared in the context (as a real). Coercion inference must respect such declarations. To do so, instead of a free variable sr, it will now see \"sr :: real\". I.e., the term that the constraint inference sees at \"show\" is not the same as the one at \"lemma\". This influences the internal constraint solving and affects the end result in this case.</p>\n<p>A workaround is to fix the type of sr in the context using the long goal format, before the lemma's statement is parsed.</p>\n<p>Cheers,<br>\nDmitriy</p>\n<p>On 3 Oct 2017, at 12:41, Thiemann, Rene &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear All,</p>\n<p>consider the following theory</p>\n<p>theory Test<br>\nimports HOL.Complex <br>\nbegin</p>\n<p>lemma \"{x. cmod x = sr} = range (op * sr)\"<br>\nproof -<br>\nshow \"{x. cmod x = sr} = range (op * sr)\"<br>\n(* failed to refine any pending goal *)<br>\ntext ‹proof line is parsed as @{term \"{x. cmod (complex_of_real x) = sr} = range (op * sr)\"}› <br>\ntext ‹goal is parsed as       @{term \"{x. cmod x = sr} = range (op * (complex_of_real sr))\"}›<br>\noops</p>\n<p>end</p>\n<p>Here, the same formula is parsed differently in the lemma-statement and in the proof,<br>\nwhich at least I found quite confusing.</p>\n<p>The effect appears in both Isabelle 2017-RC3 as well as in c90fb8bee1dd.</p>\n<p>Cheers,<br>\nRené</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294720561,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184646
    },
    {
        "content": "<p>From: \"Yamada, Akihisa\" &lt;<a href=\"mailto:Akihisa.Yamada@uibk.ac.at\">Akihisa.Yamada@uibk.ac.at</a>&gt;<br>\nDear Dmitriy,</p>\n<p>thanks for the explanation. If it sees \"sr :: real\" in the lemma statement but not in the proof, why does the following fail?</p>\n<p>lemma \"{x. cmod x = sr} = range (op * sr)\"<br>\nproof -<br>\nshow \"{x. cmod x = (sr :: real)} = range (op * (sr::real))\"<br>\noops</p>\n<p>If I further annotate the lemma statement, it will work.</p>\n<p>Anyway, if it's not a surprising outcome of the design, I'll be surprised by the design.</p>\n<p>Cheers,<br>\nAkihisa</p>",
        "id": 294720676,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184689
    },
    {
        "content": "<p>From: \"Yamada, Akihisa\" &lt;<a href=\"mailto:Akihisa.Yamada@uibk.ac.at\">Akihisa.Yamada@uibk.ac.at</a>&gt;<br>\nDear Dmitriy,</p>\n<blockquote>\n<p>It is the other way round: the show statement yields \"sr :: real\" annotations (since sr is fixed in the context). In the lemma statement \"sr\" is just a free type variable and its precise type is the result of type inference.</p>\n</blockquote>\n<p>ah, I see. So if I understand correctly, coercion is performed before <br>\nthe type inference, and its behavior will change when types are inferred.</p>\n<blockquote>\n<p>I guess you are not surprised that the following fails (fortunately):</p>\n<p>lemma<br>\n   \"f x = x\"<br>\nproof -<br>\n   define f :: \"'a ⇒ 'a\" where \"f = id\"<br>\n   show \"f x = x\" unfolding f_def by simp<br>\nqed</p>\n</blockquote>\n<p>Definitely not, because everyone sees that `define f' will define f. I <br>\nhope not all Isabelle users have to understand the behavior of coercion <br>\nmechanism...</p>\n<p>Cheers,<br>\nAkihisa</p>\n<blockquote>\n<p>This example demonstrates that parsing in Isabelle is heavily context-dependent. You can not expect the same string to always evaluate to the same result. Admittedly, in your example the context modification happens implicitly (by fixing the free variables of a lemma in the context), while here the define is quite explicit.</p>\n<p>From the point of view of coercion inference, there is absolutely no way to view the two different input terms as the same.</p>\n<p>Cheers,<br>\nDmitriy</p>\n<blockquote>\n<p>Cheers,<br>\nAkihisa</p>\n<p>On 3 Oct 2017, at 13:39, Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi René,</p>\n<p>interesting observation, but not really surprising.</p>\n<p>After parsing (and inserting coercions into) the lemma statement, sr gets declared in the context (as a real). Coercion inference must respect such declarations. To do so, instead of a free variable sr, it will now see \"sr :: real\". I.e., the term that the constraint inference sees at \"show\" is not the same as the one at \"lemma\". This influences the internal constraint solving and affects the end result in this case.</p>\n<p>A workaround is to fix the type of sr in the context using the long goal format, before the lemma's statement is parsed.</p>\n<p>Cheers,<br>\nDmitriy</p>\n<p>On 3 Oct 2017, at 12:41, Thiemann, Rene &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear All,</p>\n<p>consider the following theory</p>\n<p>theory Test<br>\nimports HOL.Complex<br>\nbegin</p>\n<p>lemma \"{x. cmod x = sr} = range (op * sr)\"<br>\nproof -<br>\nshow \"{x. cmod x = sr} = range (op * sr)\"<br>\n(* failed to refine any pending goal *)<br>\ntext ‹proof line is parsed as @{term \"{x. cmod (complex_of_real x) = sr} = range (op * sr)\"}›<br>\ntext ‹goal is parsed as       @{term \"{x. cmod x = sr} = range (op * (complex_of_real sr))\"}›<br>\noops</p>\n<p>end</p>\n<p>Here, the same formula is parsed differently in the lemma-statement and in the proof,<br>\nwhich at least I found quite confusing.</p>\n<p>The effect appears in both Isabelle 2017-RC3 as well as in c90fb8bee1dd.</p>\n<p>Cheers,<br>\nRené</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294720687,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184694
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Akihisa,</p>\n<blockquote>\n<p>On 4 Oct 2017, at 12:31, Yamada, Akihisa &lt;<a href=\"mailto:Akihisa.Yamada@uibk.ac.at\">Akihisa.Yamada@uibk.ac.at</a>&gt; wrote:</p>\n<p>Dear Dmitriy,</p>\n<blockquote>\n<p>It is the other way round: the show statement yields \"sr :: real\" annotations (since sr is fixed in the context). In the lemma statement \"sr\" is just a free type variable and its precise type is the result of type inference.</p>\n</blockquote>\n<p>ah, I see. So if I understand correctly, coercion is performed before <br>\nthe type inference, and its behavior will change when types are inferred.</p>\n</blockquote>\n<p>Chapter 3 of the implementation manual (isabelle doc implementation) gives a high-level overview of how type checking/inference work in Isabelle. Coercion inference is implemented as a \"check phase\" and runs quite early in the stack of check phases. (Most check phases assume their input to be well-typed, while the coercion inference tries to repairs badly-typed terms. For well-typed terms, coercion inference behaves as plain Hindley-Milner type inference.)</p>\n<blockquote>\n<blockquote>\n<p>I guess you are not surprised that the following fails (fortunately):</p>\n<p>lemma<br>\n  \"f x = x\"<br>\nproof -<br>\n  define f :: \"'a ⇒ 'a\" where \"f = id\"<br>\n  show \"f x = x\" unfolding f_def by simp<br>\nqed</p>\n</blockquote>\n<p>Definitely not, because everyone sees that `define f' will define f. I <br>\nhope not all Isabelle users have to understand the behavior of coercion <br>\nmechanism…</p>\n</blockquote>\n<p>I'd say all users of coercions (not equal to all Isabelle users) need to understand what they are \"buying into\" by using coercions:</p>\n<ul>\n<li>coercion inference will not modify type-correct terms</li>\n<li>for not type-correct terms it will try to repair them using the coercions it knows</li>\n<li>in case there are different ways to repair a term, one way will be chosen (the choice depends on the input term*)</li>\n</ul>\n<p>The potential ambiguity makes it necessary to carefully inspect the terms and if needed to manually adjust them by adding type annotations or coercion functions.</p>\n<p>Cheers,<br>\nDmitriy</p>\n<p>[*] To be very precise: the input term that coercion inference receives when the user writes a string s in the context ctxt is:</p>\n<p>s<br>\n     |&gt; Syntax.parse_term ctxt<br>\n     |&gt; singleton (snd o Proof_Context.prepare_sorts ctxt)<br>\n     |&gt; singleton (fst o Type_Infer_Context.prepare_positions ctxt)<br>\n     |&gt; singleton (snd o Type_Infer_Context.prepare ctxt)</p>",
        "id": 294720708,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661184701
    },
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear All,</p>\n<p>consider the following theory</p>\n<p>theory Test<br>\n  imports HOL.Complex <br>\nbegin</p>\n<p>lemma \"{x. cmod x = sr} = range (op * sr)\"<br>\nproof -<br>\n  show \"{x. cmod x = sr} = range (op * sr)\"<br>\n  (* failed to refine any pending goal *)<br>\n  text ‹proof line is parsed as @{term \"{x. cmod (complex_of_real x) = sr} = range (op * sr)\"}› <br>\n  text ‹goal is parsed as       @{term \"{x. cmod x = sr} = range (op * (complex_of_real sr))\"}›<br>\n  oops</p>\n<p>end</p>\n<p>Here, the same formula is parsed differently in the lemma-statement and in the proof,<br>\nwhich at least I found quite confusing.</p>\n<p>The effect appears in both Isabelle 2017-RC3 as well as in c90fb8bee1dd.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294721764,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185068
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi René,</p>\n<p>interesting observation, but not really surprising.</p>\n<p>After parsing (and inserting coercions into) the lemma statement, sr gets declared in the context (as a real). Coercion inference must respect such declarations. To do so, instead of a free variable sr, it will now see \"sr :: real\". I.e., the term that the constraint inference sees at \"show\" is not the same as the one at \"lemma\". This influences the internal constraint solving and affects the end result in this case.</p>\n<p>A workaround is to fix the type of sr in the context using the long goal format, before the lemma's statement is parsed.</p>\n<p>Cheers,<br>\nDmitriy</p>",
        "id": 294721985,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661185136
    }
]