[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>we currently have problems setting up the right cong-rules for our<br>\nparser such termination is provable.</p>\n<p>Here, the major problems are parsers which call themselves twice in a  <br>\nrow.</p>\n<p>Consider the following theory:</p>\n<p>theory Test imports Main<br>\nbegin</p>\n<p>types<br>\n   ('t, 'a) parser = \"'t list =&gt; string + ('a x 't list)\"</p>\n<p>take a token list and produce a string error-message or a pair of  <br>\nresult and remaining token list</p>\n<p>(state-monad with errors)</p>\n<p>now we can define the standard return and bind operations</p>\n<p>abbreviation<br>\n   return :: \"'a =&gt; ('t, 'a)parser\"<br>\nwhere<br>\n   \"return x = (%ts. Inr (x, ts))\"</p>\n<p>definition<br>\n   bind :: \"('t, 'a) parser =&gt; ('a =&gt; ('t, 'b) parser) =&gt; ('t, 'b)  <br>\nparser\"<br>\nwhere<br>\n   \"bind m f ts = (case m ts of<br>\n       Inl e =&gt; Inl e<br>\n     | Inr (x,ts') =&gt; f x ts')\"</p>\n<p>consuming one character</p>\n<p>fun consume :: \"('t,'t)parser\"<br>\nwhere \"consume [] = Inl ''error''\"<br>\n    |  \"consume (t # ts) = Inr (t, ts)\"</p>\n<p>now, here is the difficult function:</p>\n<p>function foo :: \"('t, 't list)parser\"<br>\nwhere \"foo ts = (bind consume<br>\n                    (% t. bind foo<br>\n                    (% us. bind foo<br>\n                    (% vs. return (t # us @ vs))))) ts\"<br>\nby pat_completeness auto<br>\ntermination<br>\nproof<br>\n(*  impossible, since there is no link between input ts and the list<br>\n     of tokens that is used for recursive foo-calls *)<br>\noops</p>\n<p>so, let us add some congruence rule:</p>\n<p>lemma bind_cong[fundef_cong]:<br>\n   fixes m1 :: \"('t,'a)parser\"<br>\n   assumes \"m1 ts1 = m2 ts1\" and \"!! y ts. m1 ts1 = Inr (y,ts) ==&gt; f1  <br>\ny ts = f2 y ts\" and \"ts1 = ts2\"<br>\n   shows \"((bind m1 f1) ts1) = ((bind m2 f2) ts2)\"<br>\nusing assms unfolding bind_def by (cases \"m1 ts1\", auto)</p>\n<p>now, indeed a simplied version of foo can be proven to be terminating  <br>\n(if there is only one recursive call)</p>\n<p>function foo' :: \"('t, 't list)parser\"<br>\nwhere \"foo' ts = (bind consume<br>\n                    (% t. bind foo'<br>\n                    (% vs. return (t # vs)))) ts\"<br>\nby pat_completeness auto<br>\ntermination by ... tedious reasoning</p>\n<p>but, if we want to have the full version which two recursive calls,  <br>\nthen not even the function<br>\ndefinition is accepted:</p>\n<p>function foo'' :: \"('t, 't list)parser\"<br>\nwhere \"foo'' ts = (bind consume<br>\n                    (% t. bind foo''<br>\n                    (% us. bind foo''<br>\n                    (% vs. return (t # us @ vs))))) ts\"<br>\n(*<br>\nexception THM 0 raised (line 709 of \"thm.ML\"): implies_elim: major  <br>\npremise<br>\n*)</p>\n<p>Does someone have an idea, what went wrong in this case?</p>\n<p>Best regards,<br>\nRené</p>\n<p>PS: The small theory file is attached.<br>\n<a href=\"/user_uploads/14278/k1ELn1MEI9X0wFtg2utoE0L_/Test.thy\">Test.thy</a></p>",
        "id": 294110748,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836733
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nNot an answer but a thought: maybe result checking can simplify your<br>\nlife? Maybe you can write your parser directly in ML and verify each run<br>\nof the parser by unparsing and comparison with the input?</p>\n<p>Tobias</p>\n<p>René Thiemann schrieb:</p>",
        "id": 294110820,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836760
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nRené Thiemann schrieb:</p>\n<blockquote>\n<blockquote>\n<p>Not an answer but a thought: maybe result checking can simplify your<br>\nlife? Maybe you can write your parser directly in ML and verify each run<br>\nof the parser by unparsing and comparison with the input?</p>\n</blockquote>\n<p>Yes and no: We do unparsing and comparison in any way, however, we<br>\ncannot write<br>\nour parser in ML as we want to have the parser also in the<br>\ntarget-language from<br>\nthe code-generator (as the generated verifier has to parse), or can the<br>\ncode-generator<br>\ngenerate (Haskell)-code from ML (in the new release)?</p>\n</blockquote>\n<p>I see. No, Haskell code from ML code is not possible.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Hence, we need a parser in HOL which does not have to satisfy any<br>\nproperties since<br>\ncomparison against the input is performed. However, for the<br>\ncode-generator we need<br>\ntermination of all functions we would like to export (including the<br>\nparser).<br>\nAnd since termination of the parser is currently the only axiom we use,<br>\nwe would<br>\nlike to get rid of this axiom by actually proving termination.</p>\n<p>Best,<br>\nRené</p>\n<blockquote>\n<blockquote>\n<p>Dear all,</p>\n<p>we currently have problems setting up the right cong-rules for our<br>\nparser such termination is provable.</p>\n<p>Here, the major problems are parsers which call themselves twice in a<br>\nrow.</p>\n<p>Consider the following theory:</p>\n<p>theory Test imports Main<br>\nbegin</p>\n<p>types<br>\n ('t, 'a) parser = \"'t list =&gt; string + ('a x 't list)\"</p>\n<p>take a token list and produce a string error-message or a pair of result<br>\nand remaining token list</p>\n<p>(state-monad with errors)</p>\n<p>now we can define the standard return and bind operations</p>\n<p>abbreviation<br>\n return :: \"'a =&gt; ('t, 'a)parser\"<br>\nwhere<br>\n \"return x = (%ts. Inr (x, ts))\"</p>\n<p>definition<br>\n bind :: \"('t, 'a) parser =&gt; ('a =&gt; ('t, 'b) parser) =&gt; ('t, 'b) parser\"<br>\nwhere<br>\n \"bind m f ts = (case m ts of<br>\n     Inl e =&gt; Inl e<br>\n   | Inr (x,ts') =&gt; f x ts')\"</p>\n<p>consuming one character</p>\n<p>fun consume :: \"('t,'t)parser\"<br>\nwhere \"consume [] = Inl ''error''\"<br>\n  |  \"consume (t # ts) = Inr (t, ts)\"</p>\n<p>now, here is the difficult function:</p>\n<p>function foo :: \"('t, 't list)parser\"<br>\nwhere \"foo ts = (bind consume<br>\n                  (% t. bind foo<br>\n                  (% us. bind foo<br>\n                  (% vs. return (t # us @ vs))))) ts\"<br>\nby pat_completeness auto<br>\ntermination<br>\nproof<br>\n(*  impossible, since there is no link between input ts and the list<br>\n   of tokens that is used for recursive foo-calls *)<br>\noops</p>\n<p>so, let us add some congruence rule:</p>\n<p>lemma bind_cong[fundef_cong]:<br>\n fixes m1 :: \"('t,'a)parser\"<br>\n assumes \"m1 ts1 = m2 ts1\" and \"!! y ts. m1 ts1 = Inr (y,ts) ==&gt; f1 y<br>\nts = f2 y ts\" and \"ts1 = ts2\"<br>\n shows \"((bind m1 f1) ts1) = ((bind m2 f2) ts2)\"<br>\nusing assms unfolding bind_def by (cases \"m1 ts1\", auto)</p>\n<p>now, indeed a simplied version of foo can be proven to be terminating<br>\n(if there is only one recursive call)</p>\n<p>function foo' :: \"('t, 't list)parser\"<br>\nwhere \"foo' ts = (bind consume<br>\n                  (% t. bind foo'<br>\n                  (% vs. return (t # vs)))) ts\"<br>\nby pat_completeness auto<br>\ntermination by ... tedious reasoning</p>\n<p>but, if we want to have the full version which two recursive calls, then<br>\nnot even the function<br>\ndefinition is accepted:</p>\n<p>function foo'' :: \"('t, 't list)parser\"<br>\nwhere \"foo'' ts = (bind consume<br>\n                  (% t. bind foo''<br>\n                  (% us. bind foo''<br>\n                  (% vs. return (t # us @ vs))))) ts\"<br>\n(*<br>\nexception THM 0 raised (line 709 of \"thm.ML\"): implies_elim: major<br>\npremise<br>\n*)</p>\n<p>Does someone have an idea, what went wrong in this case?</p>\n<p>Best regards,<br>\nRené</p>\n<p>PS: The small theory file is attached.</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294110837,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836766
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi René,</p>\n<blockquote>\n<p>we currently have problems setting up the right cong-rules for our<br>\nparser such termination is provable.<br>\n[...]</p>\n</blockquote>\n<blockquote>\n<p>Does someone have an idea, what went wrong in this case?</p>\n</blockquote>\n<p>I think your cong rule is slightly wrong. When I change it to</p>\n<p>lemma bind_cong[fundef_cong]:<br>\n   fixes m1 :: \"('t,'a)parser\"<br>\n   assumes \"m1 ts2 = m2 ts2\"<br>\n   and \"\\&lt;And&gt; y ts. m2 ts2 = Inr (y,ts) ==&gt; f1 y ts = f2 y ts\"<br>\n   and \"ts1 = ts2\"<br>\n   shows \"((bind m1 f1) ts1) = ((bind m2 f2) ts2)\"</p>\n<p>then the function definition works for me. (I haven't attempted a <br>\ntermination proof, but the proof obligation looks reasonable.)</p>\n<p>The difference is that you have to refer to the \"2\"-variables in the <br>\nassumptions of the branches, cf. eg. if_cong.</p>\n<p>It would be nice if there was a helpful error at the time where you <br>\ndeclare the rule, but I do not know what the general check would have to <br>\nbe... The format of cong-rules isn't really well-defined, except for the <br>\nway they are used internally.</p>\n<p>Since you are working with a state-exception monad, the termination <br>\nproof isn't actually crucial: I recently prototyped a function <br>\ndefinition facility for monadic functions of this kind which needs no <br>\ntermination proof at all. You may be interested in this, since it fits <br>\nperfectly to your problem (the Ceta-Parser is actually mentioned in the <br>\npaper as an application):<br>\n<a href=\"http://www4.in.tum.de/~krauss/mrec/\">http://www4.in.tum.de/~krauss/mrec/</a><br>\nHowever, the tool is not quite ready for integration yet, but if you are <br>\nnot in a hurry, the problem might solve itself in a few months :-)</p>\n<p>Alex</p>",
        "id": 294110863,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836776
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;</p>\n<blockquote>\n<p>Not an answer but a thought: maybe result checking can simplify your<br>\nlife? Maybe you can write your parser directly in ML and verify each  <br>\nrun<br>\nof the parser by unparsing and comparison with the input?</p>\n</blockquote>\n<p>Yes and no: We do unparsing and comparison in any way, however, we  <br>\ncannot write<br>\nour parser in ML as we want to have the parser also in the target- <br>\nlanguage from<br>\nthe code-generator (as the generated verifier has to parse), or can  <br>\nthe code-generator<br>\ngenerate (Haskell)-code from ML (in the new release)?</p>\n<p>Hence, we need a parser in HOL which does not have to satisfy any  <br>\nproperties since<br>\ncomparison against the input is performed. However, for the code- <br>\ngenerator we need<br>\ntermination of all functions we would like to export (including the  <br>\nparser).<br>\nAnd since termination of the parser is currently the only axiom we  <br>\nuse, we would<br>\nlike to get rid of this axiom by actually proving termination.</p>\n<p>Best,<br>\nRené</p>\n<blockquote>\n<blockquote>\n<p>Dear all,</p>\n<p>we currently have problems setting up the right cong-rules for our<br>\nparser such termination is provable.</p>\n<p>Here, the major problems are parsers which call themselves twice in  <br>\na row.</p>\n<p>Consider the following theory:</p>\n<p>theory Test imports Main<br>\nbegin</p>\n<p>types<br>\n ('t, 'a) parser = \"'t list =&gt; string + ('a x 't list)\"</p>\n<p>take a token list and produce a string error-message or a pair of  <br>\nresult<br>\nand remaining token list</p>\n<p>(state-monad with errors)</p>\n<p>now we can define the standard return and bind operations</p>\n<p>abbreviation<br>\n return :: \"'a =&gt; ('t, 'a)parser\"<br>\nwhere<br>\n \"return x = (%ts. Inr (x, ts))\"</p>\n<p>definition<br>\n bind :: \"('t, 'a) parser =&gt; ('a =&gt; ('t, 'b) parser) =&gt; ('t, 'b)  <br>\nparser\"<br>\nwhere<br>\n \"bind m f ts = (case m ts of<br>\n     Inl e =&gt; Inl e<br>\n   | Inr (x,ts') =&gt; f x ts')\"</p>\n<p>consuming one character</p>\n<p>fun consume :: \"('t,'t)parser\"<br>\nwhere \"consume [] = Inl ''error''\"<br>\n  |  \"consume (t # ts) = Inr (t, ts)\"</p>\n<p>now, here is the difficult function:</p>\n<p>function foo :: \"('t, 't list)parser\"<br>\nwhere \"foo ts = (bind consume<br>\n                  (% t. bind foo<br>\n                  (% us. bind foo<br>\n                  (% vs. return (t # us @ vs))))) ts\"<br>\nby pat_completeness auto<br>\ntermination<br>\nproof<br>\n(*  impossible, since there is no link between input ts and the list<br>\n   of tokens that is used for recursive foo-calls *)<br>\noops</p>\n<p>so, let us add some congruence rule:</p>\n<p>lemma bind_cong[fundef_cong]:<br>\n fixes m1 :: \"('t,'a)parser\"<br>\n assumes \"m1 ts1 = m2 ts1\" and \"!! y ts. m1 ts1 = Inr (y,ts) ==&gt; f1 y<br>\nts = f2 y ts\" and \"ts1 = ts2\"<br>\n shows \"((bind m1 f1) ts1) = ((bind m2 f2) ts2)\"<br>\nusing assms unfolding bind_def by (cases \"m1 ts1\", auto)</p>\n<p>now, indeed a simplied version of foo can be proven to be terminating<br>\n(if there is only one recursive call)</p>\n<p>function foo' :: \"('t, 't list)parser\"<br>\nwhere \"foo' ts = (bind consume<br>\n                  (% t. bind foo'<br>\n                  (% vs. return (t # vs)))) ts\"<br>\nby pat_completeness auto<br>\ntermination by ... tedious reasoning</p>\n<p>but, if we want to have the full version which two recursive calls,  <br>\nthen<br>\nnot even the function<br>\ndefinition is accepted:</p>\n<p>function foo'' :: \"('t, 't list)parser\"<br>\nwhere \"foo'' ts = (bind consume<br>\n                  (% t. bind foo''<br>\n                  (% us. bind foo''<br>\n                  (% vs. return (t # us @ vs))))) ts\"<br>\n(*<br>\nexception THM 0 raised (line 709 of \"thm.ML\"): implies_elim: major  <br>\npremise<br>\n*)</p>\n<p>Does someone have an idea, what went wrong in this case?</p>\n<p>Best regards,<br>\nRené</p>\n<p>PS: The small theory file is attached.</p>\n</blockquote>\n</blockquote>",
        "id": 294110894,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836785
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nHi Alex,</p>\n<blockquote>\n<p>I think your cong rule is slightly wrong. When I change it to</p>\n<p>lemma bind_cong[fundef_cong]:<br>\n fixes m1 :: \"('t,'a)parser\"<br>\n assumes \"m1 ts2 = m2 ts2\"<br>\n and \"\\&lt;And&gt; y ts. m2 ts2 = Inr (y,ts) ==&gt; f1 y ts = f2 y ts\"<br>\n and \"ts1 = ts2\"<br>\n shows \"((bind m1 f1) ts1) = ((bind m2 f2) ts2)\"</p>\n<p>then the function definition works for me. (I haven't attempted a  <br>\ntermination proof, but the proof obligation looks reasonable.)</p>\n<p>The difference is that you have to refer to the \"2\"-variables in the  <br>\nassumptions of the branches, cf. eg. if_cong.</p>\n</blockquote>\n<p>thanks, that was it. Now termination of the XML-parser is proven.</p>\n<blockquote>\n<p>It would be nice if there was a helpful error at the time where you  <br>\ndeclare the rule, but I do not know what the general check would  <br>\nhave to be... The format of cong-rules isn't really well-defined,  <br>\nexcept for the way they are used internally.</p>\n</blockquote>\n<p>:-) I never would have seen from the error message, that I just would  <br>\nhave to swap the 1's and 2's.</p>\n<blockquote>\n<p>Since you are working with a state-exception monad, the termination  <br>\nproof isn't actually crucial: I recently prototyped a function  <br>\ndefinition facility for monadic functions of this kind which needs  <br>\nno termination proof at all. You may be interested in this, since it  <br>\nfits perfectly to your problem (the Ceta-Parser is actually  <br>\nmentioned in the paper as an application):<br>\n<a href=\"http://www4.in.tum.de/~krauss/mrec/\">http://www4.in.tum.de/~krauss/mrec/</a><br>\nHowever, the tool is not quite ready for integration yet, but if you  <br>\nare not in a hurry, the problem might solve itself in a few months :-)</p>\n</blockquote>\n<p>okay, nice to know. Perhaps we'll wait a bit before proving  <br>\ntermination of the full CPF-parser.</p>\n<p>René</p>",
        "id": 294110966,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660836809
    }
]