[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nI've defined some extended interleaving operator, that has a parameter<br>\n\\&lt;alpha&gt;. I used recdef:</p>\n<p>consts cil :: \"('a \\&lt;Rightarrow&gt; ('m set \\&lt;times&gt; 'm set)) \\&lt;times&gt; ('a<br>\nlist) \\&lt;times&gt; ('a list) \\&lt;Rightarrow&gt; 'a list set\"</p>\n<p>syntax<br>\n  cons_interleave :: \"'a list \\&lt;Rightarrow&gt; ('a \\&lt;Rightarrow&gt; ('m set<br>\n\\&lt;times&gt; 'm set)) \\&lt;Rightarrow&gt; 'a list \\&lt;Rightarrow&gt; 'a list set\" (\"_<br>\n\\&lt;otimes&gt;\\&lt;^bsub&gt;_\\&lt;^esub&gt; _\" [64,64,64] 64)<br>\ntranslations<br>\n  \"a\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt;b\" == \"cil (\\&lt;alpha&gt;,a,b)\"</p>\n<p>recdef \"cil\" \"measure (\\&lt;lambda&gt;(\\&lt;alpha&gt;,x,y). length x + length y)\"<br>\n  \"[] \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt; \\&lt;^esub&gt; w = {w}\"<br>\n  \"w \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; [] = {w}\"<br>\n  \"e1#w1 \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; e2#w2 = (if fst (\\&lt;alpha&gt; e1)<br>\n\\&lt;inter&gt; foldl (op \\&lt;union&gt;) {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e)<br>\n\\&lt;union&gt; snd (\\&lt;alpha&gt; e)) (e2#w2)) = {} then e1\\&lt;cdot&gt;(w1<br>\n\\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; e2#w2) else {}) \\&lt;union&gt;<br>\n                     (if fst (\\&lt;alpha&gt; e2) \\&lt;inter&gt; foldl (op \\&lt;union&gt;)<br>\n{} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e) \\&lt;union&gt; snd (\\&lt;alpha&gt; e))<br>\n(e1#w1)) = {} then e2\\&lt;cdot&gt;(e1#w1 \\&lt;otimes&gt;\\&lt;^bsub&gt;\\&lt;alpha&gt;\\&lt;^esub&gt; w2)<br>\nelse {})\"</p>\n<p>This generates an induction theorem:<br>\nthm cil.induct<br>\n(*<br>\n\\&lt;lbrakk&gt;\\&lt;And&gt;\\&lt;alpha&gt;. ?P \\&lt;alpha&gt; [] []; \\&lt;And&gt;\\&lt;alpha&gt; ad ae. ?P<br>\n\\&lt;alpha&gt; [] (ad # ae); \\&lt;And&gt;\\&lt;alpha&gt; z aa. ?P \\&lt;alpha&gt; (z # aa) [];<br>\n \\&lt;And&gt;\\&lt;alpha&gt; e1 w1 e2 w2.<br>\n    \\&lt;lbrakk&gt;fst (\\&lt;alpha&gt; e2) \\&lt;inter&gt;<br>\n     foldl op \\&lt;union&gt; {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e) \\&lt;union&gt;<br>\nsnd (\\&lt;alpha&gt; e)) (e1 # w1)) =<br>\n     {} \\&lt;longrightarrow&gt;<br>\n     ?P \\&lt;alpha&gt; (e1 # w1) w2;<br>\n     fst (\\&lt;alpha&gt; e1) \\&lt;inter&gt;<br>\n     foldl op \\&lt;union&gt; {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e) \\&lt;union&gt;<br>\nsnd (\\&lt;alpha&gt; e)) (e2 # w2)) =<br>\n     {} \\&lt;longrightarrow&gt;<br>\n     ?P \\&lt;alpha&gt; w1 (e2 # w2)\\&lt;rbrakk&gt;<br>\n    \\&lt;Longrightarrow&gt; ?P \\&lt;alpha&gt; (e1 # w1) (e2 # w2)\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; ?P ?u ?v ?w<br>\n*)<br>\nThis induction theorem is too general for my intended use, where the<br>\nparameter \\&lt;alpha&gt; is always fixed. My first question is:<br>\nCan I automatically generate an induction theorem where \\&lt;alpha&gt; is<br>\nfixed (or tell induct to fix \\&lt;alpha&gt;) ?</p>\n<p>I tried to work around, and thought some theorem like the one below<br>\nmight do (I simply removed \\&lt;alpha&gt; from the \\&lt;And&gt;-quantifier binding):</p>\n<p>lemma \"\\&lt;lbrakk&gt;?P \\&lt;alpha&gt; [] []; \\&lt;And&gt;ad ae. ?P \\&lt;alpha&gt; [] (ad #<br>\nae); \\&lt;And&gt;z aa. ?P \\&lt;alpha&gt; (z # aa) [];<br>\n \\&lt;And&gt;e1 w1 e2 w2.<br>\n    \\&lt;lbrakk&gt;fst (\\&lt;alpha&gt; e2) \\&lt;inter&gt;<br>\n     foldl op \\&lt;union&gt; {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e) \\&lt;union&gt;<br>\nsnd (\\&lt;alpha&gt; e)) (e1 # w1)) =<br>\n     {} \\&lt;longrightarrow&gt;<br>\n     ?P \\&lt;alpha&gt; (e1 # w1) w2;<br>\n     fst (\\&lt;alpha&gt; e1) \\&lt;inter&gt;<br>\n     foldl op \\&lt;union&gt; {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e) \\&lt;union&gt;<br>\nsnd (\\&lt;alpha&gt; e)) (e2 # w2)) =<br>\n     {} \\&lt;longrightarrow&gt;<br>\n     ?P \\&lt;alpha&gt; w1 (e2 # w2)\\&lt;rbrakk&gt;<br>\n    \\&lt;Longrightarrow&gt; ?P \\&lt;alpha&gt; (e1 # w1) (e2 # w2)\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; ?P \\&lt;alpha&gt; ?v ?w\"</p>\n<p>I tried to prove this with auto:</p>\n<p>apply (auto elim: cil.induct)</p>\n<p>and isabelle prints: No subgoals.<br>\nbut when I issue a done:<br>\ndone</p>\n<p>I get the following error message:</p>\n<p>(*<br>\n*** Proved a different theorem: \\&lt;lbrakk&gt;True; \\&lt;And&gt;ad ae. True;<br>\n\\&lt;And&gt;z aa. True;<br>\n***  \\&lt;And&gt;e1 w1 e2 w2.<br>\n***     \\&lt;lbrakk&gt;fst (\\&lt;alpha&gt; e2) \\&lt;inter&gt;<br>\n***      foldl op \\&lt;union&gt; {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e)<br>\n\\&lt;union&gt; snd (\\&lt;alpha&gt; e)) (e1 # w1)) =<br>\n***      {} \\&lt;longrightarrow&gt;<br>\n***      True;<br>\n***      fst (\\&lt;alpha&gt; e1) \\&lt;inter&gt;<br>\n***      foldl op \\&lt;union&gt; {} (map (\\&lt;lambda&gt;e. fst (\\&lt;alpha&gt; e)<br>\n\\&lt;union&gt; snd (\\&lt;alpha&gt; e)) (e2 # w2)) =<br>\n***      {} \\&lt;longrightarrow&gt;<br>\n***      True\\&lt;rbrakk&gt;<br>\n***     \\&lt;Longrightarrow&gt; True\\&lt;rbrakk&gt;<br>\n*** \\&lt;Longrightarrow&gt; True<br>\n*** At command \"done\".<br>\n*)</p>\n<p>Now I'm completely confused. I neither understand how to do induction<br>\nnicely when the parameter \\&lt;alpha&gt; is fixed. (Probably I can always<br>\nrewrite my goal and add a \"\\&lt;alpha&gt;=fixedExp\", where fixedExp is my<br>\nfixed parameter. But is this writing overhead necessary?) nor do I<br>\nunderstand what this error message about proving a different theorem means ?</p>\n<p>Thanks in advance for any help/explanations<br>\n  Peter</p>",
        "id": 294052487,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820133
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nI found the second problem myself: I left placeholders (?X, etc) in the<br>\nlemma, that probably got instantiated to some special values ...<br>\nBut the first problem is still there: How to generate an appropriate<br>\ninduction theorem for fixed parameter \\&lt;alpha&gt; ?</p>\n<p>Peter Lammich wrote:</p>",
        "id": 294052499,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820139
    }
]