[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear Florian and Peter,</p>\n<p>thanks again. However, there now seems to be an incompatibility of Char_ord with RBTMapImpl from the AFP:</p>\n<p>If I try to load both modules (to use RBTMaps with strings as keys), then there is class conflict <br>\nsince the dependent theories of Char_ord and RBTMapImpl both define the ordering on pairs <br>\n(Product_ord and AFP/common/Misc).</p>\n<p>Peter, can you remove the pair-ordering in common/Misc and load Product_ord instead (it is the same definition)?</p>\n<p>I have the following workaround, but of course this should be fixed in a better way.</p>\n<p>theory Linorders<br>\nimports List_lexord Char_nat (* but not Char_prod *)<br>\nbegin</p>\n<p>instantiation char :: linorder<br>\nbegin<br>\nfun less_eq_char :: \"char \\&lt;Rightarrow&gt; char \\&lt;Rightarrow&gt; bool\" where \"less_eq_char c d = (nat_of_char c \\&lt;le&gt; nat_of_char d)\"<br>\nfun less_char :: \"char \\&lt;Rightarrow&gt; char \\&lt;Rightarrow&gt; bool\" where \"less_char c d = (nat_of_char c &lt; nat_of_char d)\"</p>\n<p>instance<br>\nproof<br>\n  fix x y :: char<br>\n  assume \"x \\&lt;le&gt; y\" and \"y \\&lt;le&gt; x\"<br>\n  hence \"nat_of_char x = nat_of_char y\" (is \"?x = ?y\") by auto<br>\n  hence \"char_of_nat ?x = char_of_nat ?y\" by simp<br>\n  thus \"x = y\" unfolding char_of_nat_of_char .<br>\nqed auto<br>\nend</p>\n<p>Afterwards strings are in class linorder, code-generation works also after Code_Char_chr,<br>\nand I can use RBTMapImpl as there is no conflict between Misc and Product_ord.</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294131994,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843163
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;</p>\n<blockquote>\n<p>Peter, can you remove the pair-ordering in common/Misc and load Product_ord instead (it is the same definition)?<br>\n</p>\n</blockquote>\n<p>If it is the same definition, and Product_ord is in the Isabelle<br>\nstandard library, it should of course be changed to avoid duplication<br>\nand clashes!<br>\n  @Rene: For the first time, you should change it in your local copy. If<br>\nyou are using the stable version, there is no other way.<br>\n     For the development version, someone (probably me or some of the<br>\nafp maintainers) should setup a development snapshot, do the change,<br>\ntest if nothing breaks, and push it into the hg-repository.</p>\n<p>Otherwise, it highlights some general problem with type classes:<br>\n  If there is more than one way to say order a datatype, which one<br>\nshould go into the typeclass.<br>\n  I think there is such a problem for multisets, where there are two<br>\norderings that are both \"the natural\" one when viewed from the right<br>\nperspective.<br>\n  And, if formalizations get large, there may be parts where one order<br>\nis the \"natural\" one, and other parts where the other order is the<br>\n\"natural\" one, and<br>\n  then things seems to clash ...</p>\n<p>Unfortunately, the ICF interfaces are currently not parameterizable by<br>\nthe used order, hash-function, equality-operator, ...<br>\n  @Andreas: What was the state of discussion there, is it possible/worth<br>\nthe effort to parameterize?</p>\n<p>Best,<br>\n  Peter</p>\n<blockquote>\n<p>I have the following workaround, but of course this should be fixed in a better way.</p>\n<p>theory Linorders<br>\nimports List_lexord Char_nat (* but not Char_prod *)<br>\nbegin</p>\n<p>instantiation char :: linorder<br>\nbegin<br>\nfun less_eq_char :: \"char \\&lt;Rightarrow&gt; char \\&lt;Rightarrow&gt; bool\" where \"less_eq_char c d = (nat_of_char c \\&lt;le&gt; nat_of_char d)\"<br>\nfun less_char :: \"char \\&lt;Rightarrow&gt; char \\&lt;Rightarrow&gt; bool\" where \"less_char c d = (nat_of_char c &lt; nat_of_char d)\"</p>\n<p>instance<br>\nproof<br>\n  fix x y :: char<br>\n  assume \"x \\&lt;le&gt; y\" and \"y \\&lt;le&gt; x\"<br>\n  hence \"nat_of_char x = nat_of_char y\" (is \"?x = ?y\") by auto<br>\n  hence \"char_of_nat ?x = char_of_nat ?y\" by simp<br>\n  thus \"x = y\" unfolding char_of_nat_of_char .<br>\nqed auto<br>\nend</p>\n<p>Afterwards strings are in class linorder, code-generation works also after Code_Char_chr,<br>\nand I can use RBTMapImpl as there is no conflict between Misc and Product_ord.</p>\n<p>Cheers,<br>\nRené<br>\n</p>\n</blockquote>",
        "id": 294132076,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843190
    },
    {
        "content": "<p>From: Jeremy Siek &lt;<a href=\"mailto:jeremy.siek@colorado.edu\">jeremy.siek@colorado.edu</a>&gt;<br>\n2011/3/4 Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>Peter, can you remove the pair-ordering in common/Misc and load<br>\nProduct_ord instead (it is the same definition)?<br>\n</p>\n</blockquote>\n<p>If it is the same definition, and Product_ord is in the Isabelle<br>\nstandard library, it should of course be changed to avoid duplication<br>\nand clashes!<br>\n @Rene: For the first time, you should change it in your local copy. If<br>\nyou are using the stable version, there is no other way.<br>\n    For the development version, someone (probably me or some of the<br>\nafp maintainers) should setup a development snapshot, do the change,<br>\ntest if nothing breaks, and push it into the hg-repository.</p>\n<p>Otherwise, it highlights some general problem with type classes:<br>\n If there is more than one way to say order a datatype, which one<br>\nshould go into the typeclass.<br>\n I think there is such a problem for multisets, where there are two<br>\norderings that are both \"the natural\" one when viewed from the right<br>\nperspective.<br>\n And, if formalizations get large, there may be parts where one order<br>\nis the \"natural\" one, and other parts where the other order is the<br>\n\"natural\" one, and<br>\n then things seems to clash ...<br>\n</p>\n</blockquote>\n<p>Can't help but comment on this... there are alternative designs for<br>\ntype classes in which instance declarations are lexically scoped.<br>\nThis allows different instance declarations to be in effect for different<br>\nscopes.</p>\n<p>@inproceedings{Siek:2005:ELS:1065010.1065021,<br>\n author = {Siek, Jeremy G. and Lumsdaine, Andrew},<br>\n title = {Essential language support for generic programming},<br>\n booktitle = {Proceedings of the 2005 ACM SIGPLAN conference on<br>\nProgramming language design and implementation},<br>\n series = {PLDI '05},<br>\n year = {2005},<br>\n isbn = {1-59593-056-6},<br>\n location = {Chicago, IL, USA},<br>\n pages = {73--84},<br>\n numpages = {12},<br>\n url = {http://doi.acm.org/10.1145/1065010.1065021},<br>\n doi = {http://doi.acm.org/10.1145/1065010.1065021},<br>\n acmid = {1065021},<br>\n publisher = {ACM},<br>\n address = {New York, NY, USA},<br>\n keywords = {C++, Haskell, generic programming, polymorphism, standard ML},</p>\n<p>}</p>\n<p>@inproceedings{Dreyer:2007:MTC:1190216.1190229,<br>\n author = {Dreyer, Derek and Harper, Robert and Chakravarty, Manuel M.<br>\nT. and Keller, Gabriele},<br>\n title = {Modular type classes},<br>\n booktitle = {Proceedings of the 34th annual ACM SIGPLAN-SIGACT<br>\nsymposium on Principles of programming languages},<br>\n series = {POPL '07},<br>\n year = {2007},<br>\n isbn = {1-59593-575-4},<br>\n location = {Nice, France},<br>\n pages = {63--70},<br>\n numpages = {8},<br>\n url = {http://doi.acm.org/10.1145/1190216.1190229},<br>\n doi = {http://doi.acm.org/10.1145/1190216.1190229},<br>\n acmid = {1190229},<br>\n publisher = {ACM},<br>\n address = {New York, NY, USA},<br>\n keywords = {modules, type classes, type inference, type systems},<br>\n}</p>\n<p>Cheers,<br>\nJeremy</p>\n<blockquote>\n<p>Unfortunately, the ICF interfaces are currently not parameterizable by<br>\nthe used order, hash-function, equality-operator, ...<br>\n @Andreas: What was the state of discussion there, is it possible/worth<br>\nthe effort to parameterize?</p>\n<p>Best,<br>\n Peter</p>\n<blockquote>\n<p>I have the following workaround, but of course this should be fixed in a<br>\nbetter way.</p>\n<p>theory Linorders<br>\nimports List_lexord Char_nat (* but not Char_prod *)<br>\nbegin</p>\n<p>instantiation char :: linorder<br>\nbegin<br>\nfun less_eq_char :: \"char \\&lt;Rightarrow&gt; char \\&lt;Rightarrow&gt; bool\" where<br>\n\"less_eq_char c d = (nat_of_char c \\&lt;le&gt; nat_of_char d)\"<br>\nfun less_char :: \"char \\&lt;Rightarrow&gt; char \\&lt;Rightarrow&gt; bool\" where<br>\n\"less_char c d = (nat_of_char c &lt; nat_of_char d)\"</p>\n<p>instance<br>\nproof<br>\n  fix x y :: char<br>\n  assume \"x \\&lt;le&gt; y\" and \"y \\&lt;le&gt; x\"<br>\n  hence \"nat_of_char x = nat_of_char y\" (is \"?x = ?y\") by auto<br>\n  hence \"char_of_nat ?x = char_of_nat ?y\" by simp<br>\n  thus \"x = y\" unfolding char_of_nat_of_char .<br>\nqed auto<br>\nend</p>\n<p>Afterwards strings are in class linorder, code-generation works also<br>\nafter Code_Char_chr,<br>\nand I can use RBTMapImpl as there is no conflict between Misc and<br>\nProduct_ord.</p>\n<p>Cheers,<br>\nRené<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294132084,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843194
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>the problem I have is as follows: </p>\n<ul>\n<li>I want to use the AFP/Collection/RBT... theories to have efficient implementations of sets.</li>\n<li>to use this framework, the carrier has to be in the class linorder</li>\n<li>moreover, I need to operate on sets of strings<br>\n==&gt; strings (= char list) must be in the class linorder</li>\n</ul>\n<p>unfortunately, neither char nor list are contained in the linorder class.<br>\nSo here I have three questions:</p>\n<p>1) are there already theories which make char and string members of linorder</p>\n<p>2) I have defined my own class instance for char as follows:</p>\n<p>fun nibble_to_nat :: \"nibble =&gt; nat\" where <br>\n  \"nibble_to_nat Nibble0 = 0\"<br>\n| \"nibble_to_nat Nibble1 = 1\"<br>\n...</p>\n<p>fun char_to_nat :: \"char =&gt; nat\" where <br>\n  \"char_to_nat (Char n1 n2) = (16 * nibble_to_nat n1 + nibble_to_nat n2)\"</p>\n<p>fun less_eq_char :: \"char =&gt; char =&gt; bool\" <br>\n  where \"less_eq_char c d = (char_to_nat c &lt;= char_to_nat d)\"</p>\n<p>and then proven that this implementation satisfies the class conditions.<br>\nUnfortunately, after loading Code_Char_chr I cannot export the code anymore<br>\nsince it is complains as follows:<br>\n*** Illegal character expression,<br>\n*** in equation char_to_nat (Char ?n1.0 ?n2.0) \\&lt;equiv&gt;<br>\n*** plus_nat_inst.plus_nat<br>\n***  (times_nat_inst.times_nat<br>\n***    (nat (number_int_inst.number_of_int<br>\n***           (Int.Bit0 (Int.Bit0 (Int.Bit0 (Int.Bit0 (Int.Bit1 Int.Pls)))))))<br>\n***    (nibble_to_nat ?n1.0))<br>\n***  (nibble_to_nat ?n2.0)</p>\n<p>3) In reality I need linorder not only for strings, but also for more<br>\n   complex datatypes like the following for labeled symbols:</p>\n<p>datatype ('f,'l)lab = <br>\n  Lab \"('f,'l)lab\" 'l <br>\n| Funlab \"('f,'l)lab\" \"('f,'l)lab list\" <br>\n| Unlab 'f </p>\n<p>The generation of an arbitrary linearization of each<br>\n   datatype is trivial via a lexicographic comparison. However, the proof<br>\n   obligations are tedious to prove. Is there some automatic way to<br>\n   let Isabelles generate a linearization?</p>\n<p>Best regards,<br>\nRené</p>",
        "id": 294132240,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843231
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi René,</p>\n<blockquote>\n<p>1) are there already theories which make char and string members of linorder</p>\n</blockquote>\n<p>there are theories in HOL/Library, e.g. Char_ord and List_lexord and<br>\nList_Prefix -- note that strings are just char lists, no type on their own</p>\n<blockquote>\n<p>2) I have defined my own class instance for char as follows:</p>\n</blockquote>\n<blockquote>\n<p>and then proven that this implementation satisfies the class conditions.<br>\nUnfortunately, after loading Code_Char_chr I cannot export the code anymore<br>\nsince it is complains as follows:</p>\n</blockquote>\n<p>Does this persists if you use the »official« Char_ord theory?</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/eIBhqPG_OWqf2cKO_cNtt4dd/signature.asc\">signature.asc</a></p>",
        "id": 294132421,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843299
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nPeter Lammich schrieb:<br>\nThere is no theoretical problem to parametrise ordering, equality, <br>\nhash-functions, etc. However, the current state results from what has been <br>\navailable before: The Isabelle Collections Framework reuses various existing <br>\nformalisations, e.g. red black trees (RBT), associative and distinct lists from <br>\nHOL/Library. All of them have been phrased in terms of type class operators (\"op <br>\n&lt;=\" and \"op &lt;\" for rbts) or HOL equality \"op =\". If one of these is to be <br>\nparametrised, these developments must first be changed or replicated. Thus, this <br>\nis mainly an engineering problem.</p>\n<p>In fact, a few weeks ago, I changed the red black tree development on my local <br>\ncopy such that the type class constraint vanishes and the ordering can now be a <br>\nparameter. It was not a big deal, but the new version is not backward-compatible <br>\n  (w.r.t. HOL/Library/RBT_Impl), because I had to rename operations to avoid <br>\nname clashes. The key was to shift the definitions and lemmas in RBT_Impl from <br>\nthe theory context with sort constraint linorder to the locale context <br>\nord/order/linorder that is associated with the respective type class.<br>\nThe locale context takes the order as parameter, i.e. only few changes are <br>\nnecessary to the rbt formalisation (except for name clashes, etc.).</p>\n<p>Since the ICF supports explicit invariants, different order implementations for <br>\ndifferent RBTs should be relatively easy: In addition to the RBT itself, each <br>\nmap also stores the comparison operation. Upon the first creation of the (empty) <br>\nmap, one has to decide which order to use and stick with that. Even operations <br>\non multiple RBTs like union and intersection are no problems if they are <br>\nimplemented via iterators.</p>\n<p>However, the ICF currently builds on the type RBT.rbt from HOL/Library/RBT, <br>\nwhich hides the data structure invariant of the raw implementation RBT_Impl.rbt <br>\nin a typedef. Hence, the red black tree implementation from the ICF requires <br>\n<em>no</em> invariants. If one wants to hide the invariant from one's formalisation, <br>\nthere are two options:</p>\n<p>Either, one introduces a typedef of its own for each order operation of <br>\ninterest. This scales only to a few and requires to replicate HOL/Library/RBT <br>\nfor each of them.</p>\n<p>Or, one defines the type of all well-formed red black trees together with their <br>\nordering, and adapts HOL/Library/RBT once for this more general type. But now, <br>\nequality tests via \"op =\" are no longer computable because equality of the order <br>\noperations is not. Thus, one would also have to replace \"op =\" with a <br>\nuser-defined equality operation and redo all the above. With \"op =\", however, it <br>\ndoes not suffice to shift definitions from the theory context to a locale <br>\ncontext because \"op =\" is a HOL constant, not a type class parameter. Hence, <br>\neverything that depends on \"op =\" would have to be generalised w.r.t. an <br>\nexplicit equality operator. Since \"op =\" is at the very core of HOL, this would <br>\nprobably be a lot of work.</p>\n<p>All the above should work fine for the ICF. HOL/Library also contains Mapping <br>\nand Cset as isomorphic types for 'a =&gt; 'b option and 'a set, and a setup to <br>\nimplement these types via associative lists and red black trees. If you want to <br>\ntake the above approach to Mapping and Cset, this would require even more work <br>\nand thought.</p>\n<p>To sum everything up: I think it would be no big deal to provide a map and set <br>\nimplementation for a variant of red black trees where the user can specify his <br>\nown ordering of the keys. User-specified equality would be a much bigger task.</p>\n<p>Andreas</p>",
        "id": 294133016,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843482
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>1) are there already theories which make char and string members of linorder</p>\n</blockquote>\n<p>there are theories in HOL/Library, e.g. Char_ord and List_lexord and<br>\nList_Prefix</p>\n</blockquote>\n<p>thanks Florian for the pointers.</p>\n<blockquote>\n<blockquote>\n<p>2) I have defined my own class instance for char as follows:</p>\n</blockquote>\n<blockquote>\n<p>and then proven that this implementation satisfies the class conditions.<br>\nUnfortunately, after loading Code_Char_chr I cannot export the code anymore<br>\nsince it is complains as follows:</p>\n</blockquote>\n<p>Does this persists if you use the »official« Char_ord theory?</p>\n</blockquote>\n<p>Unfortunately: yes.</p>\n<p>theory Test<br>\nimports Char_ord Code_Char_chr<br>\nbegin</p>\n<p>definition f where \"f x \\&lt;equiv&gt; (x :: char) &lt;= x\"<br>\nexport_code f in Haskell file -</p>\n<p>yields a similar error message as my own definition of &lt;= on characters.</p>",
        "id": 294133057,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843501
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHallo René,</p>\n<blockquote>\n<blockquote>\n<p>Does this persists if you use the »official« Char_ord theory?</p>\n</blockquote>\n<p>Unfortunately: yes.</p>\n<p>theory Test<br>\nimports Char_ord Code_Char_chr<br>\nbegin</p>\n<p>definition f where \"f x \\&lt;equiv&gt; (x :: char) &lt;= x\"<br>\nexport_code f in Haskell file -</p>\n<p>yields a similar error message as my own definition of &lt;= on characters.</p>\n</blockquote>\n<p>the key issue is that the code lemmas for less_eq, less on char should<br>\nuse nat_of_char rather than relying on the exact representation of nats.</p>\n<blockquote>\n<p>lemma [code]:<br>\n  \"c1 \\&lt;le&gt; c2 \\&lt;longleftrightarrow&gt; nat_of_char c1 \\&lt;le&gt; nat_of_char c2\"</p>\n</blockquote>\n<blockquote>\n<p>lemma [code]:<br>\n  \"c1 &lt; c2 \\&lt;longleftrightarrow&gt; nat_of_char c1 &lt; nat_of_char c2\"</p>\n</blockquote>\n<p>I would appreciate if these would go to the Char_ord theory.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/bydbXxmTIb6FYnn4nRSqRjW7/signature.asc\">signature.asc</a></p>",
        "id": 294133524,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843636
    }
]