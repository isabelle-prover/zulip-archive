[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear experts of parametricity and the transfer package,</p>\n<p>I am struggling to prove parametricity of a big function defined by primitive recursion <br>\nover a largish tree datatype. I thought I'd use the transfer prover from the transfer <br>\npackage. Unfortunately, it is driving me almost crazy as it appears as completely <br>\nnon-deterministic to me when it is able to prove the parametricity statement and when not <br>\n(even if parametricity rules for all constants have been declared as [transfer_rule]).</p>\n<p>Here are two minimised examples which I do not understand. They are also in the attached <br>\ntheory (tested with Isabelle2015 and Isabelle/c1b7793c23a3). Why does transfer_prover fail <br>\nto prove the rules? And what can I do to make transfer_prover work?</p>\n<ol>\n<li>The problem seems to be related to how \"op =\" is treated as a relation.</li>\n</ol>\n<p>interpretation lifting_syntax .<br>\nconsts f :: \"nat ⇒ nat\"</p>\n<p>lemma<br>\n   \"(op = ===&gt; B ===&gt; rel_option (rel_prod op = B))<br>\n      (λx y. Option.bind x (λx. Some (f x, y)))<br>\n      (λx y. Option.bind x (λx. Some (f x, y)))\"<br>\nby transfer_prover (* fails *)</p>\n<p>lemma (* same lemma, but the first \"op =\" is expanded to \"rel_option op =\" *)<br>\n   \"(rel_option op = ===&gt; B ===&gt; rel_option (rel_prod op = B))<br>\n      (λx y. Option.bind x (λx. Some (f x, y)))<br>\n      (λx y. Option.bind x (λx. Some (f x, y)))\"<br>\nby transfer_prover (* succeeds *)</p>\n<ol start=\"2\">\n<li>Transfer prover is not able to prove the parametricity rule at all, even though all <br>\nrules are available (as the manual proof shows).</li>\n</ol>\n<p>datatype nonce = PNonce nat | ANonce \"bool list\"<br>\ndatatype ('a, 'b, dead 'c) gpv = Done 'a</p>\n<p>lemma case_nonce_transfer [transfer_rule]:<br>\n   \"((op = ===&gt; A) ===&gt; (op = ===&gt; A) ===&gt; op = ===&gt; A) case_nonce case_nonce\"<br>\nby(auto simp add: rel_fun_def split: nonce.split)</p>\n<p>consts pnonce :: \"nat ⇒ 's ⇒ nat ⇒ (bool list × 's, 'call, 'ret) gpv\"<br>\nconsts η :: nat<br>\nlemma pnonce_transfer [transfer_rule]: \"(op = ===&gt; S ===&gt; op = ===&gt; rel_gpv (rel_prod op = <br>\nS) C) pnonce pnonce\" sorry</p>\n<p>lemma \"(op = ===&gt; S ===&gt; rel_gpv (rel_prod op = S) C)<br>\n      (λnonce s. case nonce of PNonce x ⇒ pnonce η s x | ANonce bs ⇒ Done (bs, s))<br>\n      (λnonce s. case nonce of PNonce x ⇒ pnonce η s x | ANonce bs ⇒ Done (bs, s))\"<br>\napply transfer_prover</p>\n<p>apply(rule rel_funI)+<br>\napply(rule case_nonce_transfer[THEN rel_funD, THEN rel_funD, THEN rel_funD])<br>\napply(rule pnonce_transfer[THEN rel_funD, THEN rel_funD])<br>\napply(rule refl)<br>\napply assumption<br>\napply(rule rel_funI)<br>\napply(rule gpv.ctr_transfer[THEN rel_funD])<br>\napply(erule (1) Pair_transfer[THEN rel_funD, THEN rel_funD])<br>\napply assumption<br>\ndone</p>\n<p>Best,<br>\nAndreas<br>\n<a href=\"/user_uploads/14278/iNDdjUHthmoHv1M7ipYF-3wK/Transfer_Prover_Problem.thy\">Transfer_Prover_Problem.thy</a></p>",
        "id": 294647288,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164629
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nThe first problem looks familiar to me.</p>\n<p>The type of option.bind is <br>\n  \"'a option =&gt; ('a =&gt; 'b option) =&gt; 'b option\"<br>\nand its transfer rule is accordingly.<br>\nHowever, in the first term, you specify just \"op =\" as relator, but bind<br>\nwants something of the form \"rel_option A\".</p>\n<p>One workaround is to expand the \"op =\" - relators, based on their type,<br>\nas much as possible, e.g., by simplification rules. </p>\n<p>Another workaround would be a custom \"relator unification\" procedure<br>\nbuilt into transfer, which is able to handle those cases ... I tried<br>\nsomething similar for Autoref, but quickly gave up on it.</p>",
        "id": 294647304,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164635
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nThe problem2 is the same as the problem1.<br>\nIf you write<br>\n  \"(op = ===&gt; S ===&gt; rel_gpv (rel_prod (list_all2 op=) S) C)<br>\nfor the relation, transfer_prover works.</p>\n<p>Funnily enough, Jasmin Blanchette sent me the same bug report two weeks ago.</p>\n<p>The transfer_prover should work for your examples. You shouldn't be <br>\nforced to expand op= in the statements of your theorems. I put some code <br>\nin transfer_prover to support this some time ago. Apparently, I made it <br>\nwrong.</p>\n<p>Since I'm at the (terminal) stage of writing my PhD thesis, it might <br>\ntake some time before I get to fix this.</p>\n<p>Ondrej</p>",
        "id": 294647340,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164647
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Ondřej and Peter,</p>\n<p>Thanks for your quick replies. For the time being, I will expand the relator-equality <br>\ntheorems manually before I invoke transfer_prover. Given your replies I assume that this <br>\nis a safe operation.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294647361,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164653
    }
]