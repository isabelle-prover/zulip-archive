[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>are there any tools to profile tactics in Isabelle?</p>\n<p>I basically have a tactic of the form</p>\n<p>REPEAT ( tac1 ORELSE ... ORELSE tacN )</p>\n<p>I want to figure out how long each of the tactics runs, to identify<br>\nhot-spots for optimization. </p>\n<p>I may need to do this in a nested way, e.g.</p>\n<p>tac1 = tac12 THEN simp_tac ...</p>\n<p>and I want to know how much time is spent on the simplification.</p>\n<p>Is there any (how basic so-ever) support for such profiling? I'm only<br>\naware of the timing panel, which is very cumbersome to use for this<br>\ncase, as it displays the timings of all commands, and cannot be focused<br>\non the command(s) I'm interested in. </p>\n<p>For first, It would be enough if \"apply\" and \"back\" could output the<br>\nrequired time, depending on a configuration flag (this option used to<br>\nbe in old Isabelles, but has apparently be removed in favour of the<br>\ntiming panel?) Then I could unfold a particular run of my tactic into a<br>\nsequence of apply and back, and see the relevant timings.</p>\n<p>Of course I would be happy to hear of any more advanced profiling<br>\ntechniques available for Isabelle.</p>",
        "id": 294729313,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187462
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nProfiling in Isabelle/ML works via the following combinators:<br>\nprofile_time, profile_time_thread, profile_allocations -- these are<br>\nbased on mechanisms provided by the Poly/ML runtime system.</p>\n<p>The result is somewhat unstructured, though: it measures everything that<br>\nhappens globally in the running ML program. For profile_time_thread that<br>\nis restricted to the current thread -- it may be used only on a single<br>\nthread at a time.</p>\n<p>Profiling tactics is more challenging, due to lazy evaluation and<br>\nmultiple results (for potential backtracking). I usually do this by<br>\npushing the profiling to the bottom of it (e.g. the Simplifier<br>\ninvocation behind simp_tac) or to the top (e.g. the outermost apply<br>\ncommand: it has only one result).</p>\n<p>Here is also a tactical (from src/HOL/Tools/Nitpick/nitpick_util.ML)<br>\nthat make a tactic behave like a strict deterministic function and<br>\napplies a timeout to it:</p>\n<p>fun DETERM_TIMEOUT delay tac st =<br>\n  Seq.of_list (the_list (Timeout.apply delay (fn () =&gt; SINGLE tac st) ()))</p>\n<p>The same approach should work e.g. with profile_time_thread instead of<br>\nTimeout.apply, but the potential for backtracking will get lost.</p>\n<p>Makarius</p>",
        "id": 294729948,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187652
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe timing tooltip for 'back' was last working before this changeset:</p>\n<p>changeset:   51595:8e9746e584c9<br>\nuser:        wenzelm<br>\ndate:        Tue Apr 02 11:41:50 2013 +0200<br>\nfiles:       src/Pure/Isar/toplevel.ML src/Pure/PIDE/command.ML<br>\ndescription:<br>\nmore centralized command timing;<br>\nclarified old-style timing message;</p>\n<p>The change is not directly relevant, though. The deeper reason is an<br>\naccidental change of order of markup for a command with arguments<br>\n('apply') and one that consists of a single keyword ('back'). Apparently<br>\nnobody noticed it, because 'back' is used very rarely these days.</p>\n<p>I have now refined that here:</p>\n<p>changeset:   67933:604da273e18d<br>\ntag:         tip<br>\nuser:        wenzelm<br>\ndate:        Fri Mar 23 17:09:36 2018 +0100<br>\nfiles:       src/Pure/PIDE/rendering.scala<br>\ndescription:<br>\nmore robust timing info: do not rely on order of markup;</p>\n<p>Included is a small example. I have used the APPEND tactical here,<br>\nbecause it preserves all possibilities for backtracking. The ORELSE<br>\ntactical (which corresponds to \"|\" in Isar) commits on the first success<br>\nand ignores the remaining possibilities.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/FJRi-yaRmYNdcBfcIdN0BWe2/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294729961,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187659
    }
]