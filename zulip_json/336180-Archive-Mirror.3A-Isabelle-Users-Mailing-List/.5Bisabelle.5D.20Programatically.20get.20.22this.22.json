[
    {
        "content": "<p>From: Joshua Chen &lt;<a href=\"mailto:joshua.chen@uibk.ac.at\">joshua.chen@uibk.ac.at</a>&gt;<br>\nDear all, is there a canonical way in Isabelle/ML to get the value of <br>\nthe Isar fact \"this\"? I'm currently using</p>\n<p>let<br>\n   val fs = Proof_Context.facts_of @{context}<br>\nin<br>\n   Facts.lookup (Context.Proof @{context}) fs \"local.this\"<br>\nend</p>\n<p>but am unsure if there are more direct ways.</p>\n<p>Thanks,<br>\nJosh</p>",
        "id": 294750494,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195250
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 07/02/2019 16:55, Joshua Chen wrote:</p>\n<blockquote>\n<p>Dear all, is there a canonical way in Isabelle/ML to get the value of<br>\nthe Isar fact \"this\"?</p>\n</blockquote>\n<p>It depends what you mean precisely, and what your application actually is.</p>\n<blockquote>\n<p>I'm currently using<br>\nlet<br>\n  val fs = Proof_Context.facts_of @{context}<br>\nin<br>\n  Facts.lookup (Context.Proof @{context}) fs \"local.this\"<br>\nend</p>\n<p>but am unsure if there are more direct ways.</p>\n</blockquote>\n<p>Since you are using the compile-time @{context}, i.e. a constant, the<br>\nexample is equivalent to:</p>\n<p>ML_val ‹<br>\n    @{thm this}<br>\n  ›</p>\n<p>So when experimenting with ML inside Isar, it is better to bind some<br>\ninitial constants like this:</p>\n<p>ML_val ‹<br>\n    val ctxt = @{context};</p>\n<p>...<br>\n  ›</p>\n<p>Later on, ctxt can be abstracted as arguments of a function, while the<br>\nbody \"...\" remains unchanged.</p>\n<p>Moreover, string literals of guessed internal names should be avoided:<br>\nsuch names change routinely over the years of continued Isabelle<br>\ndevelopment. (In particular, the \"local\" prefix is an odd artifact that<br>\nshould disappear eventually.)</p>\n<p>So here is my version of your initial example, following these principles:</p>\n<p>notepad<br>\nbegin<br>\n  assume a: A<br>\n  ML_val ‹<br>\n    val ctxt = @{context};</p>\n<p>val this_name =<br>\n      Name_Space.full_name (Proof_Context.naming_of ctxt) (<a href=\"http://Binding.name\">Binding.name</a><br>\nAuto_Bind.thisN);<br>\n    val this = #thms (the (Proof_Context.lookup_fact ctxt this_name));<br>\n  ›<br>\nend</p>\n<p>Nonetheless, it is unlikely that you actually need that in the<br>\napplication. The \"this\" entry in the facts space is merely for end-users<br>\nwriting Isar proof texts. Tools normally access specifically the some<br>\ninternal slots of the proof engine.</p>\n<p>A proof method gets the used facts (formerly \"this\") in the proof as<br>\nmain argument. Nothing special to do: merely need to omit the<br>\nSIMPLE_METHOD wrapper.</p>\n<p>A proof command can access the full Proof.state and retrieve this<br>\ninformation from it via Proof.goal: the ML_val command includes some<br>\nspecial tricks to support this in experiments:</p>\n<p>notepad<br>\nbegin<br>\n  assume A<br>\n  from this have B<br>\n    ML_val ‹<br>\n      val using_this = #facts @{Isar.goal};<br>\n    ›<br>\n    sorry<br>\nend</p>\n<p>An example for this in production is the 'sledgehammer' command: it uses<br>\nProof.goal to get to the \"chained facts\", i.e. the former \"this\" that is<br>\nrelevant for the pending goal.</p>\n<p>Makarius</p>",
        "id": 294750660,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195305
    },
    {
        "content": "<p>From: Joshua Chen &lt;<a href=\"mailto:joshua.chen@uibk.ac.at\">joshua.chen@uibk.ac.at</a>&gt;</p>\n<blockquote>\n<p>Since you are using the compile-time @{context}, i.e. a constant, the<br>\nexample is equivalent to:</p>\n<p>ML_val ‹<br>\n     @{thm this}<br>\n   ›</p>\n<p>So when experimenting with ML inside Isar, it is better to bind some<br>\ninitial constants like this:</p>\n<p>ML_val ‹<br>\n     val ctxt = @{context};</p>\n<p>...<br>\n   ›</p>\n<p>Later on, ctxt can be abstracted as arguments of a function, while the<br>\nbody \"...\" remains unchanged.</p>\n</blockquote>\n<p>I picked up on this soon after, but I do find I often forget this..</p>\n<p>Thanks very much for the pointers! As a beginner, it's often unclear <br>\nwhich of the multiple similarly plausible-sounding functions I should <br>\nuse to accomplish what I want, so I greatly appreciate the advice.</p>\n<blockquote>\n<p>It depends what you mean precisely, and what your application actually is.</p>\n</blockquote>\n<p>I'm implementing syntax parse rules for Isabelle/HoTT that should <br>\nautomatically fill in object-level type information for terms, so that <br>\nend users can leave some type information implicit for the logic to <br>\ninfer. For instance, given that one has proved/assumed facts \"f: A -&gt; B\" <br>\nand \"g: B -&gt; C\" visible in the current proof context, one should be able <br>\nto write 'show \"g o f\"' and have the logic fill in the domain type to <br>\ngive \"compose A g f\".</p>\n<p>It seems to me that I do need direct access to the fact space since this <br>\nis a translation issue, in particular one that occurs before any proof <br>\nmethods/commands are called. Though again, I'm not 100% sure about this.</p>\n<p>Best,<br>\nJosh</p>",
        "id": 294750677,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195318
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 10/02/2019 18:53, Joshua Chen wrote:</p>\n<blockquote>\n<p>As a beginner, it's often unclear<br>\nwhich of the multiple similarly plausible-sounding functions I should<br>\nuse to accomplish what I want, so I greatly appreciate the advice.</p>\n</blockquote>\n<p>The usual strategy is two-fold:</p>\n<p>* look at the text of the definitions of things, using the Prover IDE</p>\n<p>* look at the context of applications, and try to figure out typical uses</p>\n<p>Moreover it is often helpful to study documentation or ask on the<br>\nmailing list.</p>\n<blockquote>\n<p>I'm implementing syntax parse rules for Isabelle/HoTT that should<br>\nautomatically fill in object-level type information for terms, so that<br>\nend users can leave some type information implicit for the logic to<br>\ninfer. For instance, given that one has proved/assumed facts \"f: A -&gt; B\"<br>\nand \"g: B -&gt; C\" visible in the current proof context, one should be able<br>\nto write 'show \"g o f\"' and have the logic fill in the domain type to<br>\ngive \"compose A g f\".</p>\n<p>It seems to me that I do need direct access to the fact space since this<br>\nis a translation issue, in particular one that occurs before any proof<br>\nmethods/commands are called. Though again, I'm not 100% sure about this.</p>\n</blockquote>\n<p>Tools normally do not look at the fact name space, it is mainly for<br>\nend-users and thus somewhat accidental what it contains and what it<br>\nomits (e.g. unnamed facts don't show up).</p>\n<p>A more robust scheme works via declarations of facts to tool-specific<br>\nparts of the context.</p>\n<p>For example, Isabelle/ZF has a \"TC\" declaration attribute, which<br>\nmaintains context data as defined in $ISABELLE_HOME/src/ZF/Tools/typechk.ML</p>\n<p>It is also possible to use the Isar command 'named_theorems' and thus<br>\nbypass the details of handwritten context-data. E.g. search<br>\nnamed_theorems and Named_Theorems.get in .thy and .ML files to get some<br>\nideas.</p>\n<p>Thus your language will require explicit hints in the text, e.g.</p>\n<p>assume a[TC]: A<br>\n  have b[TC]: B</p>\n<p>This is more robust than magic operations on the fact name space, but<br>\nalso a bit awkward. Several people who are building non-HOL object<br>\nlogics have pointed this out in the past few months.  There is some<br>\nconcrete chance that something will happen soon, shortly before or after<br>\nthe Isabelle2019 release.</p>\n<p>Makarius</p>",
        "id": 294750693,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195324
    },
    {
        "content": "<p>From: Joshua Chen &lt;<a href=\"mailto:joshua.chen@uibk.ac.at\">joshua.chen@uibk.ac.at</a>&gt;</p>\n<blockquote>\n<p>The usual strategy is two-fold:</p>\n</blockquote>\n<p>This is what I have been doing intermittently over the past year and a <br>\nhalf ;) I do think the contributors are doing a heroic job of <br>\nmaintenance and development, but it is indeed a less-than-optimal state <br>\nof affairs that Isabelle/ML is not yet very well-documented (even the <br>\nincomplete Cookbook is already fairly out-of-date). I'd like to help out <br>\nwith that at some point after I learn things better for myself.</p>\n<blockquote>\n<p>For example, Isabelle/ZF has a \"TC\" declaration attribute, which<br>\nmaintains context data as defined in $ISABELLE_HOME/src/ZF/Tools/typechk.ML</p>\n<p>It is also possible to use the Isar command 'named_theorems' and thus<br>\nbypass the details of handwritten context-data. E.g. search<br>\nnamed_theorems and Named_Theorems.get in .thy and .ML files to get some<br>\nideas.<br>\nGreat, this is also an approach I considered and will look into!</p>\n</blockquote>\n<blockquote>\n<p>Thus your language will require explicit hints in the text, e.g.</p>\n<p>assume a[TC]: A<br>\n   have b[TC]: B</p>\n<p>This is more robust than magic operations on the fact name space, but<br>\nalso a bit awkward. Several people who are building non-HOL object<br>\nlogics have pointed this out in the past few months.  There is some<br>\nconcrete chance that something will happen soon, shortly before or after<br>\nthe Isabelle2019 release.<br>\nIndeed this is a little annoying, I look forward to possible <br>\ndevelopments on this!</p>\n</blockquote>\n<p>Best,<br>\nJosh</p>",
        "id": 294750700,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195329
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAs the Prover IDE supports more and more Isabelle/ML development, that<br>\ninteractive environment becomes an important source of implicit<br>\ninformation. Just a few years ago, reading Isabelle/ML sources required<br>\nmuch more arcane knowledge.</p>\n<p>E.g. you can open $ISABELLE_HOME/src/Pure/ROOT.ML and browse through (a<br>\ncopy of) Isabelle/Pure within itself, with full annotations provided by<br>\nthe Poly/ML compiler.</p>\n<p>You can also browse through $ISABELLE_HOME/src/Doc/Implementation and<br>\nits chapters as theory sources.</p>\n<p>Browsing through Isabelle/ML tools is more awkward: it requires to start<br>\nfrom Pure (e.g. \"isabelle jedit -l Pure\") and wait a long time until its<br>\nMain.thy material is loaded.</p>\n<p>Makarius</p>",
        "id": 294750712,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195336
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe space of named facts is mainly for the end-user, by there is an <br>\nalternative view of all facts that are literally accessible in the <br>\ncurrent context. This is used e.g. for the backquote/cartouche notation <br>\nof facts or the \"fact\" proof method.</p>\n<p>Here is an example to access this \"cloud\" of literal facts of the context:</p>\n<p>ML ‹<br>\n   val literal_facts = Proof_Context.facts_of #&gt; Facts.props;<br>\n›</p>\n<p>notepad<br>\nbegin<br>\n   {<br>\n     fix x y z :: nat<br>\n     {<br>\n       assume \"x = y\"<br>\n       assume \"y = z\"<br>\n       from ‹x = y› and ‹y = z› have \"x = z\" by (rule trans)<br>\n       moreover from ‹x = z› have \"z = x\" by (rule sym)<br>\n       print_facts<br>\n       ML_val ‹literal_facts \\&lt;^context&gt;›<br>\n       moreover note calculation<br>\n     }<br>\n     print_facts<br>\n     ML_val ‹literal_facts \\&lt;^context&gt;›<br>\n   }<br>\n   print_facts<br>\n   ML_val ‹literal_facts \\&lt;^context&gt;›<br>\nend</p>\n<p>You could try to use that by default, potentially with a declaration <br>\nattribute to suppress unwanted literal facts.</p>\n<p>Makarius</p>",
        "id": 294750777,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195366
    }
]