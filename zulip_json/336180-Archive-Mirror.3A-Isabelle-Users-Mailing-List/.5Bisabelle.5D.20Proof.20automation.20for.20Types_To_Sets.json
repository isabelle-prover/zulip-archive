[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear list, dear Ondrej and Andrei,</p>\n<p>I've tried out the new Types_To_Set and I find it very convenient to clean my proofs from <br>\nunnecessary invariants. However, I am a bit unsatisfied with the level of proof <br>\nautomation. In the ITP2016 paper, it says that the transfer \"tool is able to perform the <br>\nrelativization completely automatically\". So I was wondering what I am doing wrong.</p>\n<p>My typical use case looks like in the following example. Let's define a while loop <br>\noperator on subprobability mass functions (import HOL-Probability for this to work) and <br>\nprove a lemma about probabilistic termination and parametricity of the constants involved:</p>\n<p>locale loop_spmf =<br>\n   fixes guard :: \"'a ⇒ bool\"<br>\n   and body :: \"'a ⇒ 'a spmf\"<br>\nbegin</p>\n<p>partial_function (spmf) while :: \"'a ⇒ 'a spmf\" where<br>\n   \"while s = (if guard s then bind_spmf (body s) while else return_spmf s)\"</p>\n<p>lemma termination_0_1:<br>\n   assumes p: \"⋀s. guard s ⟹ spmf (map_spmf guard (body s)) False ≥ p\"<br>\n   and p_pos: \"0 &lt; p\"<br>\n   and lossless: \"⋀s. guard s ⟹ lossless_spmf (body s)\"<br>\n   shows \"lossless_spmf (while s)\"<br>\n   sorry</p>\n<p>end</p>\n<p>context includes lifting_syntax begin<br>\nlemma lossless_spmf_parametric [transfer_rule]:<br>\n   \"(rel_spmf A ===&gt; op =) lossless_spmf lossless_spmf\"<br>\n   sorry</p>\n<p>lemma while_spmf_parametric [transfer_rule]:<br>\n   \"((S ===&gt; op =) ===&gt; (S ===&gt; rel_spmf S) ===&gt; S ===&gt; rel_spmf S)<br>\n   loop_spmf.while loop_spmf.while\"<br>\n   sorry<br>\nend</p>\n<p>lemma loop_spmf_while_cong:<br>\n   \"⟦ guard = guard'; ⋀s. guard' s ⟹ body s = body' s ⟧<br>\n   ⟹ loop_spmf.while guard body = loop_spmf.while guard' body'\"<br>\n   sorry</p>\n<p>Now, I would like to add an invariant I on the state of the loop in the termination lemma. <br>\nAt the moment, my proof looks as shown below. I would not call this completely automatic, <br>\nso I am wondering what I am doing wrong. Can I improve this somehow?</p>\n<p>I use this scheme to add invariants to a bunch of lemmas about loops. At the moment, I <br>\njust copy-paste the setup script and have it all over the place. Does anyone have an idea <br>\nhow to make this more concise and possibly abstract over it?</p>\n<p>lemma termination_0_1_invar:<br>\n   fixes I :: \"'s ⇒ bool\"<br>\n   assumes p: \"⋀s. ⟦ guard s; I s ⟧ ⟹ spmf (map_spmf guard (body s)) False ≥ p\"<br>\n   and p_pos: \"0 &lt; p\"<br>\n   and lossless: \"⋀s. ⟦ guard s; I s ⟧ ⟹ lossless_spmf (body s)\"<br>\n   and invar: \"⋀s s'. ⟦ s' ∈ set_spmf (body s); I s; guard s ⟧ ⟹ I s'\"<br>\n   and I: \"I s\"<br>\n   shows \"lossless_spmf (loop_spmf.while guard body s)\"<br>\n   including lifting_syntax<br>\nproof -<br>\n   { assume \"∃(Rep :: 's' ⇒ 's) Abs. type_definition Rep Abs {s. I s}\"<br>\n     then obtain Rep :: \"'s' ⇒ 's\" and Abs where td: \"type_definition Rep Abs {s. I s}\"<br>\n       by blast<br>\n     then interpret td: type_definition Rep Abs \"{s. I s}\" .<br>\n     def cr ≡ \"λx y. x = Rep y\"<br>\n     have [transfer_rule]: \"bi_unique cr\" \"right_total cr\" using td cr_def<br>\n       by(rule typedef_bi_unique typedef_right_total)+<br>\n     have [transfer_domain_rule]: \"Domainp cr = I\"<br>\n       using type_definition_Domainp[OF td cr_def] by simp</p>\n<p>def guard' ≡ \"(Rep ---&gt; id) guard\"<br>\n     have [transfer_rule]: \"(cr ===&gt; op =) guard guard'\"<br>\n       by(simp add: rel_fun_def cr_def guard'_def)<br>\n     def body1 ≡ \"λs. if guard s then body s else return_pmf None\"<br>\n     def body1' ≡ \"(Rep ---&gt; map_spmf Abs) body1\"<br>\n     have [transfer_rule]: \"(cr ===&gt; rel_spmf cr) body1 body1'\"<br>\n       by(auto simp add: rel_fun_def body1'_def body1_def cr_def spmf_rel_map<br>\n               td.Rep[simplified] invar td.Abs_inverse intro!: rel_spmf_reflI)<br>\n     def s' ≡ \"Abs s\"<br>\n     have [transfer_rule]: \"cr s s'\" by(simp add: s'_def cr_def I td.Abs_inverse)</p>\n<p>have \"⋀s. guard' s ⟹ p ≤ spmf (map_spmf guard' (body1' s)) False\"<br>\n       by(transfer fixing: p)(simp add: body1_def p)<br>\n     moreover note p_pos<br>\n     moreover have \"⋀s. guard' s ⟹ lossless_spmf (body1' s)\"<br>\n       by transfer(simp add: lossless body1_def)<br>\n     ultimately have \"lossless_spmf (loop_spmf.while guard' body1' s')\"<br>\n       by(rule loop_spmf.termination_0_1_immediate)<br>\n     hence \"lossless_spmf (loop_spmf.while guard body1 s)\" by transfer }<br>\n   from this[cancel_type_definition] I show ?thesis by(auto cong: loop_spmf_while_cong)<br>\nqed</p>\n<p>Thanks,<br>\nAndreas</p>",
        "id": 294701052,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179198
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAt ITP / Nancy I have actually encouraged Ondrej and Andrei to put this<br>\nexperiment into shape for the Isabelle2016-1.</p>\n<p>So far the release branch has nothing else than the \"initial commit\"<br>\n<a href=\"https://bitbucket.org/isabelle_project/isabelle-release/commits/ae53f4d901a3\">https://bitbucket.org/isabelle_project/isabelle-release/commits/ae53f4d901a3</a><br>\nwithout any official description in NEWS whatsoever.</p>\n<p>This is OK, but it should be made clear that it is just a<br>\nproof-of-concept that accompanies the very first conference paper<br>\nintroducing the ideas behind it (I have myself looked at the paper only<br>\nfor 2h: from 3am to 5am one summer night at Nancy).</p>\n<p>Makarius</p>",
        "id": 294702301,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179573
    }
]