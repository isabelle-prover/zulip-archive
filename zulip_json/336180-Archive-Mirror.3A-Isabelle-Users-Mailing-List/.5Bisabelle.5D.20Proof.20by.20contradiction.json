[
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nI'm struggling with trying to encode a proof by contradiction in Isar.</p>\n<p>In the euclidean plane, I'm trying to prove that if two vertical lines l<br>\nand k lie at different x-coordinates, then they have no points in common.<br>\nIn a math book, I'd write:</p>\n<p>Suppose (u,v) is on both x = a and x = b, and a \\ne b; then u = a and u =<br>\nb, so a = b. Contradiction.</p>\n<p>With Isabelle in the back of my mind, perhaps I'd write this:</p>\n<p>Proof: Because l is vertical, it's defined by an equation  x = a ;<br>\nsimilarly k is defined by x = b, and we're given that a \\ne b.<br>\nSuppose T = (u,v) lies on both. Then u = a because T is on l, and u = b<br>\nbecause T is on k, and thus a = b. That's a contradiction with the given<br>\nfact a \\ne b. Hence T cannot lie on both lines. QED.</p>\n<p>I've attempted to mimic this proof in Isar below, and it's fairly readable,<br>\nI hope. \"a2meets P m\" is my way of saying \"the point P is on the line m\",<br>\nand it's written this way to make it consistent with other stuff I'm<br>\nwriting about general affine geometries.</p>\n<p>Although the resulting proof is wordy,  I feel as if I'm headed in the<br>\nright direction. But I cannot figure out the syntax for saying \"OK, I've<br>\nproved False. Surely we can conclude the theorem by contradiction!\":</p>\n<p>theory Brief6<br>\nimports Complex_Main<br>\nbegin  datatype a2pt = A2Point \"real\" \"real\"</p>\n<p>datatype a2ln = A2Ordinary \"real\" \"real\"<br>\n                | A2Vertical \"real\"<br>\n  text \"Ordinary m b represents the line y = mx+b; Vertical xo is the line<br>\nx = xo \"</p>\n<p>fun a2meets :: \"a2pt ⇒ a2ln ⇒ bool\" where<br>\n    \"a2meets (A2Point x y) (A2Ordinary m b) = (y = m*x + b)\" |<br>\n    \"a2meets (A2Point x y) (A2Vertical xi) = (x = xi)\"</p>\n<p>(* Lemma: vertical lines with different x-coords are disjoint *)<br>\nlemma A2_vert: \"x0 ≠ x1 ∧ l = A2Vertical x0 ∧ k = A2Vertical x1   ⟹  ¬ (∃<br>\nT. a2meets T l  ∧ a2meets T k)\"<br>\nproof -<br>\n  assume diff_x: \"x0 ≠ x1\"<br>\n  assume l_form: \"l = A2Vertical x0\"<br>\n  assume k_form: \"k = A2Vertical x1\"<br>\n  have \"¬ (∃ T. a2meets T l  ∧ a2meets T k)\"<br>\n  proof (rule ccontr)<br>\n    assume \"∃ T. a2meets T l  ∧ a2meets T k\"<br>\n    fix u v<br>\n    assume T_form: \"T = A2Point u v\"<br>\n    have T_on_l: \"a2meets T l\"<br>\n      by (metis ‹∃T. a2meets T l ∧ a2meets T k› a2meets.elims(2)<br>\na2meets.simps(2) diff_x k_form l_form)<br>\n    have T_on_k: \"a2meets T k\"<br>\n      by (metis ‹∃T. a2meets T l ∧ a2meets T k› a2meets.elims(2)<br>\na2meets.simps(2) diff_x k_form l_form)<br>\n    have \"u = x0\"<br>\n      using T_form T_on_l l_form by auto<br>\n    have \"u = x1\"<br>\n      using T_form T_on_k k_form by auto<br>\n    have False<br>\n      using ‹u = x0› ‹u = x1› diff_x by blast<br>\n  qed<br>\n=======</p>\n<p>I'd appreciate it if (a) someone could add whatever last line or two is<br>\nneeded to finish this proof, and (b) someone could show how to make the<br>\nproof more idiomatic and perhaps briefer (which might entail rewriting the<br>\nlemma itself, and if that's necessary, it's fine with me).</p>\n<p>--John</p>",
        "id": 294753235,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661196252
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMaybe you are over complicating things with your definitions. Isn’t your statement simply the thing below?</p>\n<p>lemma \"a ≠ b ⟹ disjnt (range (λy. (a,y))) (range (λy. (b,y)))\"<br>\n  by (auto simp: disjnt_def)</p>\n<p>Larry Paulson</p>",
        "id": 294753247,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661196259
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi John,</p>\n<blockquote>\n<p>On 28. Mar 2019, at 14:39, John F. Hughes &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt; wrote:</p>\n<p>I'm struggling with trying to encode a proof by contradiction in Isar.</p>\n<p>In the euclidean plane, I'm trying to prove that if two vertical lines l<br>\nand k lie at different x-coordinates, then they have no points in common.<br>\nIn a math book, I'd write:</p>\n<p>Suppose (u,v) is on both x = a and x = b, and a \\ne b; then u = a and u =<br>\nb, so a = b. Contradiction.</p>\n<p>With Isabelle in the back of my mind, perhaps I'd write this:</p>\n<p>Proof: Because l is vertical, it's defined by an equation  x = a ;<br>\nsimilarly k is defined by x = b, and we're given that a \\ne b.<br>\nSuppose T = (u,v) lies on both. Then u = a because T is on l, and u = b<br>\nbecause T is on k, and thus a = b. That's a contradiction with the given<br>\nfact a \\ne b. Hence T cannot lie on both lines. QED.</p>\n<p>I've attempted to mimic this proof in Isar below, and it's fairly readable,<br>\nI hope. \"a2meets P m\" is my way of saying \"the point P is on the line m\",<br>\nand it's written this way to make it consistent with other stuff I'm<br>\nwriting about general affine geometries.</p>\n<p>Although the resulting proof is wordy,  I feel as if I'm headed in the<br>\nright direction. But I cannot figure out the syntax for saying \"OK, I've<br>\nproved False. Surely we can conclude the theorem by contradiction!\":</p>\n<p>theory Brief6<br>\nimports Complex_Main<br>\nbegin  datatype a2pt = A2Point \"real\" \"real\"</p>\n<p>datatype a2ln = A2Ordinary \"real\" \"real\"<br>\n               | A2Vertical \"real\"<br>\n text \"Ordinary m b represents the line y = mx+b; Vertical xo is the line<br>\nx = xo \"</p>\n<p>fun a2meets :: \"a2pt ⇒ a2ln ⇒ bool\" where<br>\n   \"a2meets (A2Point x y) (A2Ordinary m b) = (y = m*x + b)\" |<br>\n   \"a2meets (A2Point x y) (A2Vertical xi) = (x = xi)\"</p>\n<p>(* Lemma: vertical lines with different x-coords are disjoint *)<br>\nlemma A2_vert: \"x0 ≠ x1 ∧ l = A2Vertical x0 ∧ k = A2Vertical x1   ⟹  ¬ (∃<br>\nT. a2meets T l  ∧ a2meets T k)\"<br>\nproof -<br>\n assume diff_x: \"x0 ≠ x1\"<br>\n assume l_form: \"l = A2Vertical x0\"<br>\n assume k_form: \"k = A2Vertical x1\"<br>\n have \"¬ (∃ T. a2meets T l  ∧ a2meets T k)\"<br>\n proof (rule ccontr)<br>\n   assume \"∃ T. a2meets T l  ∧ a2meets T k\"<br>\n   fix u v<br>\n   assume T_form: \"T = A2Point u v\"<br>\n   have T_on_l: \"a2meets T l\"<br>\n     by (metis ‹∃T. a2meets T l ∧ a2meets T k› a2meets.elims(2)<br>\na2meets.simps(2) diff_x k_form l_form)<br>\n   have T_on_k: \"a2meets T k\"<br>\n     by (metis ‹∃T. a2meets T l ∧ a2meets T k› a2meets.elims(2)<br>\na2meets.simps(2) diff_x k_form l_form)<br>\n   have \"u = x0\"<br>\n     using T_form T_on_l l_form by auto<br>\n   have \"u = x1\"<br>\n     using T_form T_on_k k_form by auto<br>\n   have False<br>\n     using ‹u = x0› ‹u = x1› diff_x by blast<br>\n qed<br>\n=======</p>\n<p>I'd appreciate it if (a) someone could add whatever last line or two is<br>\nneeded to finish this proof,</p>\n</blockquote>\n<p>There are several things which don't work in your proof:</p>\n<p>* First, T (from \"T = A2Point u v\") is not bound. Isabelle/jEdit is showing that with the different background. You want something along:<br>\n    obtain T where<br>\n      ‹…›</p>\n<p>* Similarly, you have to use obtain for u and v, not fix.</p>\n<p>* Then the last step has to be \"show False\" instead of \"have False\". Then you will get an error (\"Failed to refine any pending goal\"), because \"rule ccontr is only negating once more ‹¬ (∃ T. a2meets T l  ∧ a2meets T k)›. You can fix that by removing \"rule ccontr\" and rely on the default rule to do the right thing.</p>\n<p>This brings us to this proof:</p>\n<p>lemma A2_vert: \"x0 ≠ x1 ∧ l = A2Vertical x0 ∧ k = A2Vertical x1   ⟹  ¬ (∃<br>\nT. a2meets T l  ∧ a2meets T k)\"<br>\nproof -<br>\n assume diff_x: \"x0 ≠ x1\"<br>\n assume l_form: \"l = A2Vertical x0\"<br>\n assume k_form: \"k = A2Vertical x1\"<br>\n have \"¬ (∃ T. a2meets T l  ∧ a2meets T k)\"<br>\n proof<br>\n   assume \"∃ T. a2meets T l  ∧ a2meets T k\"<br>\n   then obtain T where T_on_l: ‹a2meets T l› and T_on_k: ‹a2meets T k›<br>\n     by blast<br>\n   obtain u v where T_form: \"T = A2Point u v\"<br>\n     by (cases T)<br>\n   have \"u = x0\"<br>\n     using T_form T_on_l l_form by auto<br>\n   have \"u = x1\"<br>\n     using T_form T_on_k k_form by auto<br>\n   show False<br>\n     using ‹u = x0› ‹u = x1› diff_x by blast<br>\n qed</p>\n<p>A version with fewer repetition is:</p>\n<p>lemma A2_vert:<br>\n  assumes<br>\n    diff_x: ‹x0 ≠ x1› and<br>\n    l_form: ‹l = A2Vertical x0› and <br>\n    k_form: ‹k = A2Vertical x1›<br>\n  shows ‹¬ (∃T. a2meets T l  ∧ a2meets T k)›<br>\nproof<br>\n  assume \"∃ T. a2meets T l  ∧ a2meets T k\"<br>\n  then obtain T where T_on_l: ‹a2meets T l› and T_on_k: ‹a2meets T k›<br>\n    by blast<br>\n  obtain u v where T_form: \"T = A2Point u v\"<br>\n    by (cases T)<br>\n  have \"u = x0\"<br>\n    using T_form T_on_l l_form by auto<br>\n  have \"u = x1\"<br>\n    using T_form T_on_k k_form by auto<br>\n  show False<br>\n    using ‹u = x0› ‹u = x1› diff_x by blast<br>\nqed</p>\n<p>Now, you might wonder, why did the proof actually work in the first place with the free T? And why does metis warn that \"Metis: The assumptions are inconsistent\"? That happens because metis is able to find the contradiction directly, which leads to the following shorter proof:</p>\n<p>lemma A2_vert: <br>\n  assumes<br>\n    diff_x: ‹x0 ≠ x1› and<br>\n    l_form: ‹l = A2Vertical x0› and <br>\n    k_form: ‹k = A2Vertical x1›<br>\n  shows ‹¬ (∃T. a2meets T l  ∧ a2meets T k)›<br>\n  by (metis assms a2meets.elims(2)<br>\n      a2meets.simps(2) diff_x k_form l_form)</p>\n<blockquote>\n<p>and (b) someone could show how to make the<br>\nproof more idiomatic and perhaps briefer (which might entail rewriting the<br>\nlemma itself, and if that's necessary, it's fine with me).</p>\n</blockquote>\n<p>Additionally, I would replace the assumptions on l and k by a defines, remove the exist quantifier, use cartouche, reverse the theorem, and use auto:</p>\n<p>lemma A2_vert2:<br>\n  fixes x0 x1 :: real<br>\n  defines l_form: ‹l ≡ A2Vertical x0› <br>\n  defines k_form: ‹k ≡ A2Vertical x1›<br>\n  assumes ‹a2meets T l› and ‹a2meets T k›<br>\n  shows ‹l = k› <br>\n  by (cases T) (use assms in auto)</p>\n<p>However, that is only a matter of taste. This version means something slightly different (if two parallel vertical intersect, then they are equal).</p>\n<p>Mathias</p>\n<blockquote>\n<p>--John</p>\n</blockquote>",
        "id": 294753258,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661196263
    },
    {
        "content": "<p>From: \"John F. Hughes\" &lt;<a href=\"mailto:jfh@cs.brown.edu\">jfh@cs.brown.edu</a>&gt;<br>\nThanks...this is <em>exactly</em> what I was looking for. It leads me to a few<br>\nmore questions, though,</p>\n<ul>\n<li>First, T (from \"T = A2Point u v\") is not bound. Isabelle/jEdit is showing<blockquote>\n<p>that with the different background. You want something along:<br>\n    obtain T where<br>\n      ‹…›<br>\n  * Similarly, you have to use obtain for u and v, not fix.</p>\n</blockquote>\n</li>\n</ul>\n<p>Can you suggest somewhere that I can learn the distinction between \"obtain\"<br>\nand \"fix\"? The reference manual has a paragraph that's too cryptic for my<br>\ncurrent understanding of logic (which is quite basic); Ballarin's tutorial<br>\nslides basically say \"they're different\". I think I need something in the<br>\nmiddle. :)</p>\n<p>* Then the last step has to be \"show False\" instead of \"have False\". Then</p>\n<blockquote>\n<p>you will get an error (\"Failed to refine any pending goal\"), because \"rule<br>\nccontr is only negating once more ‹¬ (∃ T. a2meets T l  ∧ a2meets T k)›.<br>\nYou can fix that by removing \"rule ccontr\" and rely on the default rule<br>\nto do the right thing.</p>\n</blockquote>\n<p>If I actually <em>wanted</em> to do a proof by contradiction, even though it's not<br>\nnecessary here, would I have to start with</p>\n<p>proof (rule ccontr)<br>\n    assume \"¬¬ (∃ T. a2meets T l  ∧ a2meets T k)\"</p>\n<p>Perhaps choosing a theorem with a negation in the conclusion was a bad<br>\nplace to start trying to use proof-by-contradiction. But I'd really like to<br>\nsee how to do such a proof.</p>\n<p>Later you suggest restating the theorem as its contrapositive (which may or<br>\nmay not be a good idea...I don't know whether Isabelle can use the<br>\ncontrapositive as effectively for what I need to do next), and propose<br>\nthree things (which I've reordered):</p>\n<ul>\n<li>use cartouche</li>\n<li>use \"defines\" instead of \"assumes\"</li>\n<li>remove the \"exist\" quantifier</li>\n</ul>\n<p>My questions:</p>\n<p>-- Typing double-quotes is easy; typing cartouches is tough (for me) ---<br>\nis there some simple way to do this, and are they the preferred form now?<br>\n -- the reference manual, page 102) says that 'defines\" defines a<br>\npreviously declared parameter, but in your use</p>\n<blockquote>\n<p>lemma A2_vert2:<br>\n  fixes x0 x1 :: real<br>\n  defines l_form: ‹l ≡ A2Vertical x0›<br>\n  defines k_form: ‹k ≡ A2Vertical x1›<br>\n  assumes ‹a2meets T l› and ‹a2meets T k›<br>\n  shows ‹l = k›<br>\n  by (cases T) (use assms in auto)</p>\n<p>the parameters l and k haven't been previously  declared (as far as I can<br>\ntell). Of course, that description of \"defines\" is in the section about<br>\nlocales in the reference manual, so it's probably the wrong one. But it's<br>\nthe only mention of that keyword in the whole manual, so I'm at a loss for<br>\nwhat this actually means here.</p>\n</blockquote>\n<p>-- does this form of the statement really remove the \"exists\" quantifier?<br>\nOr is there an implicit \"exists\" in the \"assumes\" line? And does removing<br>\nit (assuming it's really gone) make things easier for the prover?</p>\n<p>--John</p>",
        "id": 294753269,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661196268
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nHave you studied the tutorial “Programming and Proving in Isabelle/HOL”<br>\n(<code>prog-prove</code>)? I find it extremely helpful for getting started with<br>\nIsabelle. It also mentions <code>obtain</code>.</p>\n<p>You use <code>fix</code> if you want to prove a <code>⋀</code>-statement; <code>fix x</code> means that<br>\nthe following lines work under the assumption that an <code>x</code> is given to<br>\nyou. You use <code>obtain x where P</code> if you can prove that there is an <code>x</code><br>\nfor which <code>P</code> is true and you want to get hold of such an <code>x</code>.</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294753288,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661196281
    }
]