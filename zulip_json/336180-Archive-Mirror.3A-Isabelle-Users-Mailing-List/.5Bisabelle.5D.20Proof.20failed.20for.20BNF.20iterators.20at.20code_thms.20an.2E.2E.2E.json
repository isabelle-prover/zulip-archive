[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Isabelle developers,</p>\n<p>I usually find the commands code_thms and export_code very useful while I work on setting <br>\nup the code generator. In combination with the BNF codatatype command, however, they <br>\nsometimes abort with \"Proof failed.\" It reliably happens if the iterator or recursor for <br>\nthe codatatype is reachable in the code dependency graphs and I have forgotten to provide <br>\ncode equations for them. Here's a minimal example for Isabelle2013-1:</p>\n<p>theory Scratch imports \"~~/src/HOL/BNF/BNF\" begin<br>\ncodatatype foo = Foo | Bar foo<br>\ncode_datatype Foo Bar<br>\ncode_thms foo_unfold</p>\n<p>At code_thms, I get \"Proof failed.\" and a huge goal state talking about the internal BNF <br>\nconstruction for the the foo instead of the usual list of theorems that I would like to <br>\ninspect. The same happens at export_code and value [code].</p>\n<p>I know that code generation for codatatypes is not yet set up in Isabelle2013-1, so it is <br>\nkind of my own fault that I have forgotten to declare the relevent code equations. <br>\nNevertheless, why does the code generator even try to prove anything at all? And how can <br>\nthis fail?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294255045,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912275
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<p>I did not inspect the code, but I guess it happens since internal proofs<br>\nare forked, which are only forced when the code generator is invoked.<br>\nMaybe the BNF gurus can tell you more.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/_w5En653QIuirr97uysAHOnk/signature.asc\">signature.asc</a></p>",
        "id": 294255085,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912291
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nThat would imply that with</p>\n<p>ML {* parallel_proofs := 0 *}</p>\n<p>the error should occur at the codatatype command already. This is not <br>\nthe case.</p>\n<p>After some minimization it turns out that this has nothing to do with <br>\ncodatatypes at all:</p>\n<p>consts c :: \"nat ⇒ bool\"<br>\nconsts b :: \"bool\"<br>\ndefinition \"X = {(Kl :: nat set, lab) |Kl lab. ((∀kl∈Kl. b) ∧ (∀kl. kl ∉ <br>\nKl ⟶ b)) ∧ c lab}\"<br>\ncode_thms X</p>\n<p>What is code_thms actually trying to prove?</p>\n<p>Dmitriy</p>",
        "id": 294255089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912293
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nOn 16.11.2013 13:14, Dmitriy Traytel wrote:</p>\n<blockquote>\n<p>Am 16.11.2013 09:57, schrieb Florian Haftmann:</p>\n<blockquote>\n<p>Hi Andreas,</p>\n<blockquote>\n<p>theory Scratch imports \"~~/src/HOL/BNF/BNF\" begin<br>\ncodatatype foo = Foo | Bar foo<br>\ncode_datatype Foo Bar<br>\ncode_thms foo_unfold</p>\n<p>At code_thms, I get \"Proof failed.\" and a huge goal state talking about<br>\nthe internal BNF construction for the the foo instead of the usual list<br>\nof theorems that I would like to inspect. The same happens at<br>\nexport_code and value [code].<br>\nI did not inspect the code, but I guess it happens since internal proofs<br>\nare forked, which are only forced when the code generator is invoked.<br>\nMaybe the BNF gurus can tell you more.<br>\nThat would imply that with</p>\n</blockquote>\n</blockquote>\n<p>ML {* parallel_proofs := 0 *}</p>\n<p>the error should occur at the codatatype command already. This is not<br>\nthe case.</p>\n<p>After some minimization it turns out that this has nothing to do with<br>\ncodatatypes at all:</p>\n<p>consts c :: \"nat ⇒ bool\"<br>\nconsts b :: \"bool\"<br>\ndefinition \"X = {(Kl :: nat set, lab) |Kl lab. ((∀kl∈Kl. b) ∧ (∀kl. kl ∉<br>\nKl ⟶ b)) ∧ c lab}\"<br>\ncode_thms X</p>\n<p>What is code_thms actually trying to prove?</p>\n</blockquote>\n<p>Interesting.  The code generator internally only does rewriting and<br>\ninstantiation, no backward proofs, except for case certificates<br>\n(Pure/Isar/code.ML):</p>\n<blockquote>\n<p>fun case_cong thy case_const (num_args, (pos, _)) =<br>\n  let<br>\n    val ([x, y], ctxt) = fold_map Name.variant [\"A\", \"A'\"] Name.context;<br>\n    val (zs, _) = fold_map Name.variant (replicate (num_args - 1) \"\") ctxt;<br>\n    val (ws, vs) = chop pos zs;<br>\n    val T = Logic.unvarifyT_global (Sign.the_const_type thy case_const);<br>\n    val Ts = binder_types T;<br>\n    val T_cong = nth Ts pos;<br>\n    fun mk_prem z = Free (z, T_cong);<br>\n    fun mk_concl z = list_comb (Const (case_const, T), map2 (curry Free) (ws @ z :: vs) Ts);<br>\n    val (prem, concl) = pairself Logic.mk_equals (pairself mk_prem (x, y), pairself mk_concl (x, y));<br>\n    fun tac { context, prems } = Simplifier.rewrite_goals_tac prems<br>\n      THEN ALLGOALS (Proof_Context.fact_tac [Drule.reflexive_thm]);<br>\n  in Goal.prove_sorry_global thy (x :: y :: zs) [prem] concl tac end;</p>\n</blockquote>\n<p>But this should hold regardless of the logical properties of the case<br>\ncombinator.</p>\n<p>Have you tried to obtain a traceback?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/mqsFxmGwwBAR7xLbpq6qZjHK/signature.asc\">signature.asc</a></p>",
        "id": 294255141,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912309
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nI tried to do it now (see below). It points to the <br>\nset_comprehension_simproc that is installed as a code preprocessor in <br>\nProduct_Type:</p>\n<p>setup {*<br>\n   Code_Preproc.map_pre (fn ctxt =&gt; ctxt addsimprocs<br>\n     [Raw_Simplifier.make_simproc {name = \"set comprehension\", lhss = <br>\n[@{cpat \"Collect ?P\"}],<br>\n     proc = K Set_Comprehension_Pointfree.code_simproc, identifier = []}])<br>\n*}</p>\n<p>Dmitriy</p>\n<p>Exception trace - Proof failed.</p>\n<p>1. \\&lt;And&gt;a ba aa baa. (aa, baa) \\&lt;in&gt; (\\&lt;lambda&gt;Kl. Kl) <code> \n(\\&lt;lambda&gt;Kl. Kl) </code> {Kl. \\&lt;forall&gt;kl\\&lt;in&gt;Kl. b} \\&lt;times&gt; UNIV \\&lt;inter&gt; <br>\n(\\&lt;lambda&gt;Kl. Kl) <code> (\\&lt;lambda&gt;Kl. Kl) </code> {Kl. \\&lt;forall&gt;kl. kl \\&lt;notin&gt; Kl <br>\n\\&lt;longrightarrow&gt; b} \\&lt;times&gt; UNIV \\&lt;inter&gt; UNIV \\&lt;times&gt; (\\&lt;lambda&gt;lab. <br>\nlab) <code> Collect c \\&lt;Longrightarrow&gt; c baa\nThe error(s) above occurred for the goal statement:\n{(Kl, lab) |Kl lab. ((\\&lt;forall&gt;kl\\&lt;in&gt;Kl. b) \\&lt;and&gt; (\\&lt;forall&gt;kl. kl \n\\&lt;notin&gt; Kl \\&lt;longrightarrow&gt; b)) \\&lt;and&gt; c lab} =\n(\\&lt;lambda&gt;(Kl, lab). (Kl, lab)) </code> ((\\&lt;lambda&gt;Kl. Kl) <code> (\\&lt;lambda&gt;Kl. Kl) \n</code> {Kl. \\&lt;forall&gt;kl\\&lt;in&gt;Kl. b} \\&lt;times&gt; UNIV \\&lt;inter&gt; (\\&lt;lambda&gt;Kl. Kl) <code> \n(\\&lt;lambda&gt;Kl. Kl) </code> {Kl. \\&lt;forall&gt;kl. kl \\&lt;notin&gt; Kl \\&lt;longrightarrow&gt; <br>\nb} \\&lt;times&gt; UNIV \\&lt;inter&gt; UNIV \\&lt;times&gt; (\\&lt;lambda&gt;lab. lab) ` {lab. c lab})<br>\n  (line 10 of \"/home/traytel/Scratch3.thy\")<br>\nGoal.prove_common(7)result(1)<br>\nGoal.prove_common(7)<br>\nSet_Comprehension_Pointfree.conv(2)<br>\nSet_Comprehension_Pointfree.code_simproc(2)<br>\nRaw_Simplifier.rewritec(4)proc_rews(1)<br>\nRaw_Simplifier.rewritec(4)<br>\nRaw_Simplifier.bottomc(3)botc(3)<br>\nRaw_Simplifier.bottomc(3)try_botc(1)(1)<br>\nCode.eqn_conv(2)<br>\nConv.fconv_rule(2)<br>\nList.map(2)()<br>\nLibrary.singleton(1)(1)<br>\nList.map(2)()<br>\nBasics.#&gt;(1)(1)<br>\nCode_Preproc.obtain_eqns(3)<br>\nCode_Preproc.ensure_fun(5)<br>\nCode_Preproc.extend_arities_eqngr(5)<br>\nCode_Thingol.code_depgr(2)<br>\nCode_Thingol.code_thms(1)<br>\nToplevel.apply_tr(3)(1)</p>",
        "id": 294255239,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912336
    }
]