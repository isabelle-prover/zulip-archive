[
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nConcerning the previous discussion, I believe there was no talking at cross purposes,<br>\nas prior to your new reference to [Cohn, 1989] we were discussing within the realm of mathematics only.<br>\nEspecially the design of Mark's HOL Zero, which was chosen as an example by Peter and Makarius,<br>\nfocuses on</p>\n<ul>\n<li>level 1: the logical kernel (the logic and its internal representation), and</li>\n<li>\n<p>level 2: the printer and parser (external representation),<br>\nbut [Cohn, 1989, in particular section 6.1., available online at <a href=\"https://doi.org/10.1007/BF00243000\">https://doi.org/10.1007/BF00243000</a> ]<br>\nmainly discusses the correspondence between the 2nd level (e.g., the mathematical model/description of a microprocessor) and</p>\n</li>\n<li>\n<p>level 3: the concept/reality (e.g., the intended design or the actual device)<br>\nwhich goes beyond mathematics itself.</p>\n</li>\n</ul>\n<p>Some of the recent issues were<br>\na) preserving logical dependencies (respectively, its lack in the case of type class instantiation) - <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00020.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00020.html</a><br>\n   which might be used to construe an inconsistency - <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00049.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00049.html</a><br>\nb) the previous inconsistency, again caused by type classes - p. 2 (example 2) at <a href=\"http://www21.in.tum.de/~kuncar/documents/kuncar-popescu-itp2015.pdf\">http://www21.in.tum.de/~kuncar/documents/kuncar-popescu-itp2015.pdf</a><br>\nClearly, these are (should be) matters of the logical kernel.<br>\nTherefore, it is reasonable to expect the kernel to preserve logical dependencies,<br>\nand not a \"fanciful interpretation of the documentation\" - <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00022.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00022.html</a><br>\nwhich again is an argument for getting rid of the responsibility for logical consistency,<br>\nthe purpose the logical kernel is designed for.</p>\n<p>I agree with Peter that the logical kernel (level 1) should be sound independent of whether the user is malicious or not.</p>\n<p>Concerning the printer and parser (level 2), immunity against a malicious user is desirable,<br>\nbut probably possible only in less interactive provers/checkers like HOL Zero or R0.<br>\nFor this immunity, both<br>\nI. Freek Wiedijk's notion of Pollack-consistency - <a href=\"http://www.sciencedirect.com/science/article/pii/S157106611200028X/pdf?md5=04ceb92a245b5bde8c4eca0610032293&amp;pid=1-s2.0-S157106611200028X-main.pdf\">http://www.sciencedirect.com/science/article/pii/S157106611200028X/pdf?md5=04ceb92a245b5bde8c4eca0610032293&amp;pid=1-s2.0-S157106611200028X-main.pdf</a><br>\nII. and Mark's notion of faithfulness - <a href=\"http://www.proof-technologies.com/papers/hzsyntax_itp2016.pdf\">http://www.proof-technologies.com/papers/hzsyntax_itp2016.pdf</a><br>\nshould be implemented, as was done for R0.<br>\nIn these papers, both authors actually assume the role of the malicious user in order to examine the various systems.</p>\n<p>For Isabelle, I have attached an exploit of the type class instantiation such that the 'taint' of the inconsistency in hidden,<br>\nbut still the \"sorry\" workaround has to be used.</p>\n<p>For R0, I have attached an implementation of Mark's scenario:<br>\n\"A printer that printed false as true and true as false might be Pollack-consistent but would not be faithful.\"<br>\n<a href=\"http://www.proof-technologies.com/papers/hzsyntax_itp2016.pdf\">http://www.proof-technologies.com/papers/hzsyntax_itp2016.pdf</a> (p. 2)<br>\n(This is not possible in standard mode, i.e., without explicitly passing the flag \"–allow-definition-removal\" and<br>\nwith the standard definitions in \"basics.r0.txt\" either as first command line argument or included at the beginning of the file.)</p>\n<hr>\n<p>Ken Kubota<br>\n<a href=\"http://doi.org/10.4444/100\">http://doi.org/10.4444/100</a></p>\n<p>Commands:<br>\n    ./R0 --allow-definition-removal no_faithfulness.r0.txt<br>\n    ./R0 --allow-definition-removal no_faithfulness.r0.txt &gt; no_faithfulness.r0.out.txt<br>\n    ./R0 basics.r0.txt no_faithfulness.r0.txt</p>\n<hr>\n<p>Scratch.thy</p>\n<hr>\n<p>(* check which oracles a theorem depends on from the ML level *)<br>\n(* source: <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00019.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00019.html</a> *)</p>\n<p>theory Scratch<br>\n  imports Main<br>\n  keywords \"check_sorry\" :: diag<br>\nbegin</p>\n<p>ML ‹<br>\nval get_oracles = Proofterm.all_oracles_of o Proofterm.strip_thm o<br>\nThm.proof_body_of</p>\n<p>val contains_sorry = exists (fn (a, _) =&gt; a = \"Pure.skip_proof\") o<br>\nget_oracles</p>\n<p>fun report_sorry ctxt =<br>\n  if Context_Position.is_visible ctxt then<br>\n<a href=\"http://Output.report\">Output.report</a> [Markup.markup Markup.bad \"Proof arises from sorry oracle!\"]<br>\n  else ();</p>\n<p>fun check_sorry ctxt th =<br>\n    if contains_sorry th then report_sorry ctxt else ()</p>\n<p>fun check_sorry_cmd thm_ref st =<br>\n  let<br>\n    val ctxt = Toplevel.context_of st<br>\n    val th = Proof_Context.get_fact_single ctxt thm_ref<br>\n  in check_sorry ctxt th end</p>\n<p>val _ =<br>\n  Outer_Syntax.command @{command_keyword check_sorry} \"Check theorem for sorry\"<br>\n    (Parse.thm &gt;&gt; (fn (th, _) =&gt; Toplevel.keep (check_sorry_cmd th)));<br>\n›</p>\n<p>(* Usage: *)<br>\nlemma one_add_1_eq_3:<br>\n  \"1 + 1 = 3\"<br>\n  sorry</p>\n<p>check_sorry HOL.refl<br>\ncheck_sorry one_add_1_eq_3</p>\n<p>(* hide the 'taint' of a theorem by going through a type class instantiation *)<br>\n(* source: <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00020.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-July/msg00020.html</a> *)</p>\n<p>class foo = semiring_1 +<br>\n  assumes foo: \"1 + 1 = 3\"</p>\n<p>instance nat :: foo<br>\n  by intro_classes (rule one_add_1_eq_3)</p>\n<p>lemmas one_add_1_eq_3' = foo [where ?'a = nat]</p>\n<p>check_sorry one_add_1_eq_3'</p>\n<p>(* inconsistency without explicit dependency on sorry *)<br>\n(* new (no source) *)</p>\n<p>lemma incons_one_add_1_eq_3:<br>\n  \"(1::nat) + 1 = 3 ∧ 1 + 1 ≠ 3\"<br>\n  sorry</p>\n<p>class incons_foo = semiring_1 +<br>\n  assumes incons_foo: \"1 + 1 = 3 ∧ 1 + 1 ≠ 3\"</p>\n<p>instance nat :: incons_foo<br>\n by intro_classes (rule incons_one_add_1_eq_3)</p>\n<p>lemmas false' = incons_foo [where ?'a = nat]</p>\n<p>check_sorry false'</p>\n<p>theorem False<br>\n  using false' by auto</p>\n<hr>\n<p>no_faithfulness.r0.txt</p>\n<hr>\n<h2>read some standard definitions including T and F</h2>\n<p>&lt;&lt; definitions1.r0.txt</p>\n<h2>define symbol 'MYDEF' as truth (T),</h2>\n<h2>and also show the full definition of truth (===)</h2>\n<h2>:= MYDEF T</h2>\n<p>:= MYDEF T</p>\n<h2>definition of truth (T) in Q0: Q=Q</h2>\n<h2><a href=\"https://plato.stanford.edu/entries/type-theory-church/#ForBasEqu\">https://plato.stanford.edu/entries/type-theory-church/#ForBasEqu</a></h2>\n<h2>definition of truth (T) in R0: ===</h2>\n<h2><a href=\"http://www.owlofminerva.net/files/formulae.pdf\">http://www.owlofminerva.net/files/formulae.pdf</a> (p. 359)</h2>\n<h2>now show MYDEF by establishing: MYDEF = MYDEF</h2>\n<h2>(the program will automatically use the shortest label, in this case T)</h2>\n<h2>§= MYDEF</h2>\n<p>§= MYDEF</p>\n<h2>remove definition labels T and F</h2>\n<p>:= T<br>\n:= F</p>\n<h2>(maliciously) attach definition label F to truth (===)</h2>\n<p>:= F ((={{{o,@},@}}_={@}){{o,@}}_={@})</p>\n<h2>show MYDEF again by establishing: MYDEF = MYDEF</h2>\n<h2>§= MYDEF</h2>\n<p>§= MYDEF</p>\n<h2>Note: truth (usually T) appeared as F!</h2>\n<hr>\n<p>no_faithfulness.r0.out.txt</p>\n<hr>\n<h2>read some standard definitions including T and F</h2>\n<p>&lt;&lt; definitions1.r0.txt</p>\n<h2>define symbol 'MYDEF' as truth (T),</h2>\n<h2>and also show the full definition of truth (===)</h2>\n<h2>:= MYDEF T</h2>\n<p>:= MYDEF ((={{{o,@},@}}_={@}){{o,@}}_={@})</p>\n<h1>wff      12 :  ((=_=)_=)                                  :=  MYDEF  T</h1>\n<h2>definition of truth (T) in Q0: Q=Q</h2>\n<h2><a href=\"https://plato.stanford.edu/entries/type-theory-church/#ForBasEqu\">https://plato.stanford.edu/entries/type-theory-church/#ForBasEqu</a></h2>\n<h2>definition of truth (T) in R0: ===</h2>\n<h2><a href=\"http://www.owlofminerva.net/files/formulae.pdf\">http://www.owlofminerva.net/files/formulae.pdf</a> (p. 359)</h2>\n<h2>now show MYDEF by establishing: MYDEF = MYDEF</h2>\n<h2>(the program will automatically use the shortest label, in this case T)</h2>\n<h2>§= MYDEF</h2>\n<p>§= T</p>\n<h1>((=_T)_T)</h1>\n<h2>remove definition labels T and F</h2>\n<p>:= T<br>\n:= F</p>\n<h2>(maliciously) attach definition label F to truth (===)</h2>\n<p>:= F ((={{{o,@},@}}_={@}){{o,@}}_={@})</p>\n<h1>wff      12 :  ((=_=)_=)                                  :=  F  MYDEF</h1>\n<h2>show MYDEF again by establishing: MYDEF = MYDEF</h2>\n<h2>§= MYDEF</h2>\n<p>§= F</p>\n<h1>((=_F)_F)</h1>\n<h2>Note: truth (usually T) appeared as F!</h2>\n<hr>",
        "id": 294714014,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183149
    }
]