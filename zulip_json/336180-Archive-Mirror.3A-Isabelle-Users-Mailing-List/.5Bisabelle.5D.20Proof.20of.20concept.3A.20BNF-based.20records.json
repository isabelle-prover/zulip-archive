[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThanks to everybody who contributed to this thread.</p>\n<p>Here is a summary of important points that are relevant for the next<br>\nround of renovation of the Isabelle/HOL record package.</p>\n<ul>\n<li>\n<p>Scalability and extensibility are both used in applications and very<br>\nrelevant. 100-1000 record fields and max. 5 record extensions occur<br>\nroutinely -- e.g. in the seL4 project by Data61 (usually generated from<br>\nprograms / specifications).</p>\n</li>\n<li>\n<p>Some connection of records with datatypes is occasionally useful, e.g.<br>\nfor recursion through record types or convenient notation for datatype<br>\nconstructors (with updates), but it works against scalability demands<br>\nfor records, because datatypes are very heavy.</p>\n</li>\n</ul>\n<p>Some partial solutions (for small records) are:</p>\n<p><a href=\"https://github.com/seL4/l4v/tree/master/tools/c-parser/recursive_records\">https://github.com/seL4/l4v/tree/master/tools/c-parser/recursive_records</a></p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/file/3107dcea3493/src/HOL/Library/Datatype_Records.thy\">http://isabelle.in.tum.de/repos/isabelle/file/3107dcea3493/src/HOL/Library/Datatype_Records.thy</a></p>\n<ul>\n<li>\n<p>Instead of providing a separate datatype_record or record_datatype<br>\npackage, it might be better to have a plugin for the existing BNF<br>\ndatatype package to provide certain notational conveniences of records.</p>\n</li>\n<li>\n<p>There are existing techniques to connect records and datatypes<br>\nmanually, e.g. with 'copy_bnf'.</p>\n</li>\n<li>\n<p>The record package is still awaiting localization, in order to make it<br>\nwork in local contexts (locale, class, context, experiment etc.). Some<br>\nkey challenges:</p>\n<ul>\n<li>\n<p>The package is very large and complex, with many cumulative<br>\nadditions over time, by several authors.</p>\n</li>\n<li>\n<p>Record syntax needs to be somehow localized; conceptually it should<br>\nwork, because the syntax is \"constant\", only the record field names,<br>\ntypes, and extensions depend on the context.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Update syntax is actually generic, there is no direct connection to<br>\nrecords.</p>\n</li>\n<li>\n<p>There are some open questions concerning code-generation for records.</p>\n</li>\n<li>\n<p>Instead of using records (with predicates over them) it is often more<br>\nconvenient to use locales (with individual parameters and assumptions)<br>\nand let the locale + interpretation infrastructure handle merges,<br>\ninstantiation etc.</p>\n</li>\n<li>\n<p>The Isabelle mailing lists have accumulated various non-conclusive<br>\nthreads about records vs. datatypes over the past few years, e.g. see<br>\nhere<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-August/msg00016.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-August/msg00016.html</a></p>\n<p>Makarius</p>\n</li>\n</ul>",
        "id": 294725549,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186291
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear list,</p>\n<p>I'd like to demonstrate that it is quite simple to base records on BNFs.</p>\n<p>The short story is: it takes about 160 lines of ML code and 50 lines of <br>\nsyntax declarations to achieve almost (one big caveat, see below) <br>\nfeature parity to the standard record package (sources attached).</p>\n<p>Looking for your input on whether this is useful, and whether it belongs <br>\ninto HOL-Library, the AFP, or the bin.</p>\n<p>What is supported? Pretty much the old syntax:</p>\n<p>bnf_record ('a, 'b) foo =<br>\n     field_1 :: 'a<br>\n     field_2 :: 'b</p>\n<p>term \"⦇ field_1 = 3, field_2 = () ⦈\"<br>\n   term \"foo ⦇ field_1 := y ⦈\"</p>\n<p>Also, record construction syntax is supported out of the box for <br>\narbitrary single-free-constructor types:</p>\n<p>datatype x = X (a: int) (b: int)</p>\n<p>term \"⦇ a = 1, b = 2 ⦈\"</p>\n<p>Update syntax for existing types can be installed like this:</p>\n<p>local_setup ‹BNF_Record.mk_update_defs @{type_name x}›</p>\n<p>term \"(X 1 2) ⦇ b := 3 ⦈ = X 1 3\"</p>\n<p>What isn't supported?</p>\n<ul>\n<li>No extensions (i.e. \"_ext\", \"_scheme\" etc.).</li>\n<li>\n<p>Full flags and options of the datatype package (e.g. declaring type <br>\nvariables as dead, disabling plugins).</p>\n</li>\n<li>\n<p>Any kind of compatibility between standard and BNF records.</p>\n</li>\n</ul>\n<p>How is it implemented?</p>\n<ol>\n<li>Define a single-constructor datatype.</li>\n<li>Generate update functions for each field.</li>\n<li>Lots of syntax sugar.</li>\n</ol>\n<p>Why?</p>\n<p>The short reason: the \"record\" package isn't localized.</p>\n<p>The longer reason: there are more problems with records, e.g. there is <br>\nno support for nested recursion (they do not constitute BNFs), and even <br>\n\"copy_bnf\" can't fix the absence of a suitable \"size\" function (which <br>\nmakes termination proofs impossible).</p>\n<p>Why not?</p>\n<p>The internal construction of standard records is much faster. Half of <br>\nthe 50 lines to declare syntax is required to un-declare record syntax. <br>\nUnfortunately raw \"syntax\" rules can't be bundle-d. Importing the theory <br>\nbreaks all existing record syntax.</p>\n<p>What is the motivation for this?</p>\n<p>Lem supports records. CakeML uses them for some core types, and <br>\nspecifies nested recursion through them. Whenever CakeML updates, I can <br>\neither change the generated sources to include a bunch of magic <br>\nincantations to make termination proofs work, or I can change Lem to <br>\nemit \"bnf_record\" instead of \"record\".* As a third option (somewhere <br>\nbetween band-aid and proper solution), Jasmin has already suggested a <br>\nfew months to port the size plugin to records. I attempted that but <br>\nunfortunately it took me too much time and ultimately I didn't manage <br>\nto. This here was much quicker to pull off (approx. 3 h) and fixes an <br>\nimmediate problem I had. (Jasmin did however prevent me from writing a <br>\nplugin that generates update functions for all datatypes.)</p>\n<p>Cheers<br>\nLars</p>\n<ul>\n<li>Changing Lem to emit \"datatype\" doesn't solve the absence of updating <br>\nfunctions that are also required for Lem/CakeML.<br>\n<a href=\"/user_uploads/14278/EtIRP6SpiQof_KDWirwi79o_/bnf_record.ML\">bnf_record.ML</a><br>\n<a href=\"/user_uploads/14278/tPHl4OrYQvcK7F2NasOMU0wG/BNF_Record.thy\">BNF_Record.thy</a><br>\n<a href=\"/user_uploads/14278/EHuB-q2XvUZi-eBAxh5f6DVF/Test_BNF_Record.thy\">Test_BNF_Record.thy</a></li>\n</ul>",
        "id": 294726705,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186647
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 08/02/18 22:36, Lars Hupel wrote:</p>\n<blockquote>\n<p>I'd like to demonstrate that it is quite simple to base records on BNFs.</p>\n<p>The short story is: it takes about 160 lines of ML code and 50 lines of<br>\nsyntax declarations to achieve almost (one big caveat, see below)<br>\nfeature parity to the standard record package (sources attached).</p>\n</blockquote>\n<p>This is all very strange. No discussion whatsoever and now there is even<br>\na change on the Isabelle repository:<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/7929240e44d4\">http://isabelle.in.tum.de/repos/isabelle/rev/7929240e44d4</a></p>\n<p>The history of the official Isabelle record package is long and<br>\nentangled. Initially its main idea was to support extensible records in<br>\na simple manner (see the paper by Naraschewski and Wenzel from 1998).<br>\nLater, some guys from Sydney added many more features to make the<br>\npackage scalable for the L4.verified project -- that made the<br>\nimplementation also very complex. Thus it has become difficult to update<br>\nand \"localize\" it. Moreover any connection to BNF datatypes (which are<br>\nvery resource hungry) is likely to bomb applications with many record<br>\nfields (or record extensions).</p>\n<p>It is presently unclear to me, where the scalability features are used<br>\nin practice. If L4.verified no longer requires that, we can probably<br>\nremove 80% of the record package and then update it easily. If scalable<br>\nrecords are still required, it will need more work to update.</p>\n<p>Can some Data61 people say more about their current applications of the<br>\nrecord package?</p>\n<blockquote>\n<p>Looking for your input on whether this is useful, and whether it belongs<br>\ninto HOL-Library, the AFP, or the bin.</p>\n</blockquote>\n<p>Spontaneously, I would have said HOL-ex or the bin. By putting it in<br>\nHOL-Library, you make certain claims of quality and sustained<br>\nmaintenance. I.e. the first posting I can imagine on isabelle-users:</p>\n<p>\"I've found out about HOL-Library.Datatype_Records by accident -- there<br>\nis no NEWS entry and no documentation whatsoever. That tool appears to<br>\nbe in conflict with the existing record package. Can anybody please fix<br>\nthis ASAP, such that I can use theories with regular records together<br>\nwith these new BNF records? Anyway, what is the roadmap? Can I expect<br>\nnew BNF records will eventually supersede old-fashioned typedef records?\"</p>\n<blockquote>\n<p>What is supported? Pretty much the old syntax:</p>\n<p>bnf_record ('a, 'b) foo =<br>\n    field_1 :: 'a<br>\n    field_2 :: 'b</p>\n<p>term \"⦇ field_1 = 3, field_2 = () ⦈\"<br>\n  term \"foo ⦇ field_1 := y ⦈\"</p>\n<p>Also, record construction syntax is supported out of the box for<br>\narbitrary single-free-constructor types:</p>\n<p>datatype x = X (a: int) (b: int)</p>\n<p>term \"⦇ a = 1, b = 2 ⦈\"</p>\n<p>Update syntax for existing types can be installed like this:</p>\n<p>local_setup ‹BNF_Record.mk_update_defs @{type_name x}›</p>\n<p>term \"(X 1 2) ⦇ b := 3 ⦈ = X 1 3\"</p>\n</blockquote>\n<p>That is record notation with \"make\" and \"update\" operations on top of<br>\nexisting datatypes. It was actually the plan in 1996/1997, before the<br>\nextensible record scheme emerged in 1998. We did not do this by fancy,<br>\nbut it was based on requirements from applications.</p>\n<blockquote>\n<p>Why?</p>\n<p>The longer reason: there are more problems with records, e.g. there is<br>\nno support for nested recursion (they do not constitute BNFs), and even<br>\n\"copy_bnf\" can't fix the absence of a suitable \"size\" function (which<br>\nmakes termination proofs impossible).</p>\n</blockquote>\n<p>Can you explain this further? Is there an inherent problem of the<br>\ngeneral idea of the regular record package wrt. BNFs? Can the BNF<br>\nexperts comment on that?</p>\n<blockquote>\n<p>Why not?</p>\n<p>The internal construction of standard records is much faster. Half of<br>\nthe 50 lines to declare syntax is required to un-declare record syntax.<br>\nUnfortunately raw \"syntax\" rules can't be bundle-d. Importing the theory<br>\nbreaks all existing record syntax.</p>\n</blockquote>\n<p>BTW, there is an old Isabelle development principle to be monotonic wrt.<br>\nexisting tools. A fork and clone is bad enough, one that disrupts what<br>\nis already there is worse: entropy, decay.</p>\n<blockquote>\n<p>What is the motivation for this?</p>\n<p>Lem supports records. CakeML uses them for some core types, and<br>\nspecifies nested recursion through them. Whenever CakeML updates, I can<br>\neither change the generated sources to include a bunch of magic<br>\nincantations to make termination proofs work, or I can change Lem to<br>\nemit \"bnf_record\" instead of \"record\".* As a third option (somewhere<br>\nbetween band-aid and proper solution), Jasmin has already suggested a<br>\nfew months to port the size plugin to records. I attempted that but<br>\nunfortunately it took me too much time and ultimately I didn't manage<br>\nto. This here was much quicker to pull off (approx. 3 h) and fixes an<br>\nimmediate problem I had. (Jasmin did however prevent me from writing a<br>\nplugin that generates update functions for all datatypes.)</p>\n</blockquote>\n<p>This hints at various discussions in the dark. We have relatively little<br>\ntraffic on the isabelle-users and isabelle-dev mailing lists, so why not<br>\nuse them for proper discussions?</p>\n<p>As a reminder:</p>\n<p>* isabelle-users is for anything that is relevant to users of official<br>\nIsabelle releases (past, present, future releases).</p>\n<p>* isabelle-dev is for anything concerning the ongoing development<br>\nprocess of Isabelle repository versions between releases.</p>\n<p>* It does not make sense to cross-post on both lists; isabelle-dev is<br>\nthe smaller list, essentially a subset of isabelle-users.</p>\n<p>Mailing lists are not for real-time \"chats\". Often the relevant people<br>\nare not immediately reactive (e.g. busy somewhere else or even on<br>\nvacation). This means it needs more than just a few days to draw<br>\nconclusions from the absence of postings.</p>\n<p>Makarius</p>",
        "id": 294727080,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186751
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nLars discussed this with me. There is no harm in putting it in Library as long <br>\nas the functionality and limitations of this approach are clearly stated in the <br>\ntheory, which they are currently not. This needs to be included. Then people <br>\nknow what they are letting themselves in for.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/NbnlwNq9HAtGqjBBDc8lVFys/smime.p7s\">smime.p7s</a></p>",
        "id": 294727105,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186757
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Can you explain this further? Is there an inherent problem of the<br>\ngeneral idea of the regular record package wrt. BNFs? Can the BNF<br>\nexperts comment on that?</p>\n</blockquote>\n<p>I explained that in my email. \"copy_bnf\" makes a record a BNF. But for<br>\nit to be able to be used in a function definition, it also requires size<br>\nsetup, which as of now, is manual.</p>\n<blockquote>\n<p>BTW, there is an old Isabelle development principle to be monotonic wrt.<br>\nexisting tools. A fork and clone is bad enough, one that disrupts what<br>\nis already there is worse: entropy, decay.</p>\n</blockquote>\n<p>As I said, raw syntax cannot be bundled. I expect people to have a brief<br>\nlook over what they're including, and the way the syntax setup works is<br>\nexceedingly obvious.</p>\n<blockquote>\n<p>This hints at various discussions in the dark. We have relatively little<br>\ntraffic on the isabelle-users and isabelle-dev mailing lists, so why not<br>\nuse them for proper discussions?</p>\n</blockquote>\n<p>The problems with record + nested recursion had been laid out on the<br>\nmailing lists a few months ago.</p>",
        "id": 294727142,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186762
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nFair point. I will add a few paragraphs there.</p>",
        "id": 294727175,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186769
    },
    {
        "content": "<p>From: <a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a></p>\n<blockquote>\n<p>It is presently unclear to me, where the scalability features are used<br>\nin practice. If L4.verified no longer requires that, we can probably<br>\nremove 80% of the record package and then update it easily. If scalable<br>\nrecords are still required, it will need more work to update.</p>\n<p>Can some Data61 people say more about their current applications of the<br>\nrecord package?</p>\n</blockquote>\n<p>We still do require it, and in fact make more use of the scalability than ever, because seL4 keeps growing and we keep adding support for further architectures.</p>\n<p>We also depend on extensibility of records in a few places.</p>\n<blockquote>\n<blockquote>\n<p>Looking for your input on whether this is useful, and whether it belongs<br>\ninto HOL-Library, the AFP, or the bin.</p>\n</blockquote>\n<p>Spontaneously, I would have said HOL-ex or the bin. By putting it in<br>\nHOL-Library, you make certain claims of quality and sustained<br>\nmaintenance. I.e. the first posting I can imagine on isabelle-users:</p>\n<p>\"I've found out about HOL-Library.Datatype_Records by accident -- there<br>\nis no NEWS entry and no documentation whatsoever. That tool appears to<br>\nbe in conflict with the existing record package. Can anybody please fix<br>\nthis ASAP, such that I can use theories with regular records together<br>\nwith these new BNF records? Anyway, what is the roadmap? Can I expect<br>\nnew BNF records will eventually supersede old-fashioned typedef records?”</p>\n</blockquote>\n<p>:-)</p>\n<p>I must admit that we have been maintaining a similar (very bare-bones) additional datatype record package on the side for about a decade. We use it in addition to the standard record package to model C structs, because they can contain recursive pointer types, which we couldn’t do with normal records. I.e. it might make sense to have both, as long as it is clear what each is for, what the differences are, and why they can’t/shouldn’t be the same.</p>\n<blockquote>\n<blockquote>\n<p>The longer reason: there are more problems with records, e.g. there is<br>\nno support for nested recursion (they do not constitute BNFs), and even<br>\n\"copy_bnf\" can't fix the absence of a suitable \"size\" function (which<br>\nmakes termination proofs impossible).</p>\n</blockquote>\n<p>Can you explain this further? Is there an inherent problem of the<br>\ngeneral idea of the regular record package wrt. BNFs? Can the BNF<br>\nexperts comment on that?</p>\n</blockquote>\n<p>I’d be interested in that too. It’d be nice to properly localise and BNF-ify records eventually.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294727249,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186793
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nCan you point to the sources of a few such big record definitions?</p>\n<p>Such examples will be required even to a canonical localization effort<br>\nof the package that retains its feature richness.</p>\n<p>Makarius</p>",
        "id": 294727290,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186806
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nPeople often don't have a choice: imports are often indirect. E.g. when<br>\nyou use theories from HOL-Algebra, the regular record package will be<br>\nused. Combining this which bnf_record will break it.</p>\n<p>It is normally possible to add new things without disrupting existing<br>\nthings, and thus retain the good manners of monotonicity.</p>\n<p>Makarius</p>",
        "id": 294727309,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186813
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nCan you point to the sources of this alternative datatype record<br>\npackage? How does it treat record syntax?</p>\n<p>One important aspect of localizing the record package is actually the<br>\nconcrete syntax. When that is done properly, syntax could be attached to<br>\ndifferent term constructions, independently of the underlying record<br>\nrepresentation.</p>\n<p>Makarius</p>",
        "id": 294727424,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186849
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nIs there a way to do advanced syntax (e.g. nonterminal, syntax,<br>\ntranslations, parse_translation, print_ast_translation) properly (e.g.<br>\nlocalized)?</p>",
        "id": 294727441,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186854
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYes, one merely needs to connect local entities with global items in the<br>\nbackground theory (the so-called foundation), according to the usual<br>\npolicies of local_theory contexts.</p>\n<p>Here the foundation consists of raw syntax and translations, and the<br>\nconnection might require further tricks that have not been used before.</p>\n<p>The whole localization business is about such tricks -- to make things<br>\npossible that look impossible at first sight.</p>\n<p>Makarius</p>",
        "id": 294727516,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186878
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nSo I don't feel so bad anymore about writing syntax translations tgat depend<br>\non a configuration flag from the local context ... I did this trick recently<br>\nto enable advanced syntax in a bundle ... the problem was that some<br>\ntranslations that match on the outermost constant of an expression are not<br>\nsupposed to return identity ... this required further workarounds and makes it<br>\nall feel like a bad hack.  </p>\n<p>Peter</p>",
        "id": 294727578,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186885
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nCan you point to the sources?</p>\n<p>Makarius</p>",
        "id": 294727595,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186891
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nNo, but I can include a stripped-down example. Basically, the print and<br>\nparse translations will raise Match if they are disabled by a<br>\nconfiguration option.</p>\n<p>See the last lines of attached text to see an example how it is<br>\nsupposed to work.</p>\n<p>The decomposition of strings looks ughly, I basically copied it from<br>\nString_Syntax.ML</p>",
        "id": 294727624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186904
    },
    {
        "content": "<p>From: <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a><br>\nHi all. I'm the guy from Sydney who added stuff to the record package.<br>\nI'm just back from holiday, and I should try to clear up some<br>\nmisunderstandings.</p>\n<ul>\n<li>1 - It's OK for other packages to use the record update syntax.</li>\n</ul>\n<p>I think the BNF record extension mechanism is fine. I think (but haven't<br>\nchecked) that it's the record update syntax which is being used. This is<br>\njust syntax for any constant whose name ends in \"_update\". You can play<br>\nwith this by hand, if you want, define the constant spam_update<br>\nand use the syntax \"r (| spam := 1 |)\". This won't create conflicts with<br>\nthe record package, since the record package knows which constants<br>\nit \"owns\".</p>\n<ul>\n<li>2 - I changed the record package, but I tried to avoid \"features\".</li>\n</ul>\n<p>The history, as I recall, is that the extensible record mechanism is <br>\nquite old.<br>\nNorbert Schirmer's Simpl package tends to require large records, so<br>\nhe adjusted the implementation. He managed to support about 100 variables,<br>\nand then I adjusted it again to get up to 1000.</p>\n<p>My adjustment made a lot of changes to how the record type is defined<br>\ninternally. But I tried to avoid changing the \"surface layer\" which users<br>\ninteract with. I think Makarius is slightly wrong to describe this as <br>\nnew features,<br>\nit was meant to just be a performance upgrade within the machinery.</p>\n<p>I did make a mistake. I didn't understand the code generator well, and <br>\nin fact I<br>\nstill don't. I had hoped at the time that my changes were benign, and <br>\nwould result<br>\nin code being generated fairly normally. I was wrong, apparently. Other <br>\nauthors<br>\nsubsequently added quite a lot of code to produce theorems that allow <br>\nthe code<br>\ngenerator to simulate a simpler definition for records. This conflicts <br>\nwith my<br>\nperformance goals somewhat. With all these changes together, the package is<br>\nnow quite complicated.</p>\n<ul>\n<li>3 - The L4.verified performance constraints aren't complicated.</li>\n</ul>\n<p>We can't \"quote\" the big record definition that is done, because it's <br>\ncalled in ML by<br>\nanother package. But we can describe the performance constraints very <br>\neasily:<br>\nsomewhere upwards of 700 variables. I think that our most challenging <br>\nconfiguration<br>\nmight be up well about 1000 now.</p>\n<p>There's one key big record for any given inclusion of a C program, i.e. <br>\none in any<br>\nimage. It's a flat record, not an extension and never extended.</p>\n<p>Quoting myself on this list from nearly 10 years ago, you can run test <br>\nan n-variable<br>\nrecord definition quite easily:</p>\n<p>ML {*<br>\nfun add_test_rec b n = let<br>\n     fun var i = (Binding.suffix_name (string_of_int i) b, @{typ bool}, <br>\nMixfix.NoSyn)<br>\n   in Record.add_record {overloaded = false} ([], b)<br>\n     NONE (map var (1 upto n))<br>\n   end<br>\n*}</p>\n<p>setup {* add_test_rec @{binding test_rec} 20 *}<br>\nsetup {* add_test_rec @{binding test_rec_b} 200 *}</p>\n<p>We also use a number of smaller records, and do use the extension <br>\nfeature, but<br>\nI don't think we're different to other users in any interesting way.</p>\n<ul>\n<li>4 - Past performance problems.</li>\n</ul>\n<p>We had a live discussion about record performance problems more than 5 years<br>\nago. Around then we were having critical difficulties getting images to <br>\nbuild on<br>\npretty much any hardware. I tracked down the problem at the time. It was due<br>\nto both the code generator support for extra record features and a <br>\nchange to the<br>\nway proof terms were stored.</p>\n<p>This problem was then solved in PolyML. When David Matthews added<br>\nshareCommonData as a feature that the GC called occasionally, the problem<br>\nwent away. Now the relevant image builds are just slow. I can explain <br>\nthis in more<br>\ndetail, if anyone really cares, but on our side we no longer need to do <br>\nanything<br>\nabout it.</p>\n<ul>\n<li>5 - Future maintenance.</li>\n</ul>\n<p>The record package is now quite complicated. Various people would like <br>\nto localise<br>\nit. Part of the problem is that it doesn't have a single author any <br>\nmore. I made a quick<br>\nattempt to do some localising in the past, but I quickly hit bits of the <br>\nsyntax translations<br>\nand simprocs that I avoided changing in the past and that I still don't <br>\nunderstand.</p>\n<p>There are probably many other agendas as well.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 294727717,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186941
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nBack from vacation here as well. I'll try to clarify some things from the BNF perspective. BTW: the term \"datatype-base\" for Lars' tool would be more appropriate than \"BNF-based\" (whereas the datatypes themselves are \"BNF-based\"). </p>\n<blockquote>\n<p>On 14 Feb 2018, at 15:01, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>The history of the official Isabelle record package is long and<br>\nentangled. Initially its main idea was to support extensible records in<br>\na simple manner (see the paper by Naraschewski and Wenzel from 1998).<br>\nLater, some guys from Sydney added many more features to make the<br>\npackage scalable for the L4.verified project -- that made the<br>\nimplementation also very complex. Thus it has become difficult to update<br>\nand \"localize\" it. Moreover any connection to BNF datatypes (which are<br>\nvery resource hungry) is likely to bomb applications with many record<br>\nfields (or record extensions).</p>\n</blockquote>\n<p>I dimly remember that Andeas Lochbihler had an application of a long sequence of record extensions (depth 5 or 6), but can not find the corresponding formalization in Isabelle+AFP.</p>\n<blockquote>\n<blockquote>\n<p>Why?</p>\n<p>The longer reason: there are more problems with records, e.g. there is<br>\nno support for nested recursion (they do not constitute BNFs), and even<br>\n\"copy_bnf\" can't fix the absence of a suitable \"size\" function (which<br>\nmakes termination proofs impossible).</p>\n</blockquote>\n<p>Can you explain this further? Is there an inherent problem of the<br>\ngeneral idea of the regular record package wrt. BNFs? Can the BNF<br>\nexperts comment on that?</p>\n</blockquote>\n<p>As Lars has pointed out: there is no problem with records w.r.t. BNFs. One can register any record as a BNF using the copy_bnf command (potentially inheriting some dead variables from the underlying product type used in the construction of records). A BNF does not give one a size function though.</p>\n<blockquote>\n<blockquote>\n<p>Jasmin has already suggested a<br>\nfew months to port the size plugin to records. I attempted that but<br>\nunfortunately it took me too much time and ultimately I didn't manage<br>\nto. This here was much quicker to pull off (approx. 3 h) and fixes an<br>\nimmediate problem I had. (Jasmin did however prevent me from writing a<br>\nplugin that generates update functions for all datatypes.)</p>\n</blockquote>\n<p>This hints at various discussions in the dark. We have relatively little<br>\ntraffic on the isabelle-users and isabelle-dev mailing lists, so why not<br>\nuse them for proper discussions?</p>\n</blockquote>\n<p>Actually, this was on the mailing list and I am surprised that nobody has posted the link yet:</p>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-August/msg00016.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-August/msg00016.html</a> &lt;<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-August/msg00016.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2017-August/msg00016.html</a>&gt;</p>\n<p>However, for some reason, I can't find the last mail from Jasmin (to Lars, cc'ing me and isabelle-users) in this thread in the mailman archives. So I guess we should call it \"in the twilight\" rather than \"in the dark\". Here is its content (of which in particular the last paragraph is relevant in this thread):</p>\n<blockquote>\n<p>On 13 Aug 2017, at 17:47, Blanchette, J.C. &lt;<a href=\"mailto:j.c.blanchette@vu.nl\">j.c.blanchette@vu.nl</a>&gt; wrote:</p>\n<p>Hi Lars,</p>\n<blockquote>\n<p>A good starting point could be to decouple record syntax from record<br>\ndefinitions. There's no reason why</p>\n<p>datatype foo = Bar (x: nat) (y: nat)</p>\n<p>couldn't be treated as a record, including update functions.</p>\n</blockquote>\n<p>I'm not sure what you mean exactly by \"treated as a record\". Records have a quite different feel, with their polymorphic \"more\" field.</p>\n<p>I remember looking at records a few years ago and finding out that many of the properties and concepts shared with datatypes (or the \"ctr_sugar\" abstraction) have different names or different forms. A thorough analysis of the current situation would be a good idea before adding anything.</p>\n<blockquote>\n<p>I'm already working on a plugin that produces \"*_update\" functions (this allows for<br>\nrecord update syntax, albeit not construction syntax).</p>\n</blockquote>\n<p>I'm not sure what your plans are, but I would argue against using the datatype plugin for this, because such plugins are enabled by default. More than enough constants are already generated for datatypes. Perhaps we could discuss alternatives offline if you like.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>\n</blockquote>\n<p>Stepping back and looking at the different requirements (of Lars and Data61) gives me the impression, that it would be useful to have a plugin to enable record syntax and update-functions for datatypes. There are many questions that need to be discussed: Should it work for single-constructor datatypes only? What about recursive single-constructor datatypes? (The answer to the latter seems yes thinking of Data61's recursive pointer type.)</p>\n<p>However, this plugin definitely needs to be disabled by default. </p>\n<p>There are ways to achieve this (c.f. the \"transfer\" option and plugin of primrec in src/HOL/Tools/BNF/bnf_lfp_rec_sugar.ML and src/HOL/Tools/BNF/bnf_lfp_rec_sugar_transfer.ML), but they feel more like a workaround, rather than the solution: we are using an additional configuration option to disable the plugin by default. Ideally, there would be a cleaner way to specify the defaults directly in the plugin infrastructure when creating a plugin interpretation (i.e. in the Plugin.interpretation function).</p>\n<p>This plugin would be clearly conceptually separated from the record package (which we will never supersede with datatypes because of efficiency). Probably much of the tool that Lars' created can be reused in such a plugin, but without introducing a new record package and the confusion associated to it.</p>\n<p>Dmitriy</p>",
        "id": 294727773,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186965
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;</p>\n<blockquote>\n<p>I dimly remember that Andeas Lochbihler had an application of a long sequence of record extensions (depth 5 or 6), but can not find the corresponding formalization in Isabelle+AFP.</p>\n</blockquote>\n<p>Such a long sequence appeared in early versions of my Monomorphic_Monad formalisation in <br>\nthe AFP. (There was a record for a monad, an extension for exceptions, another one for <br>\nstate, etc.) But I dropped the whole record approach because the fixed order of record <br>\nextensions made the whole approach too inflexible. Today, Monomorphic_Monad is based on <br>\nlocales.</p>\n<p>All my records are small in terms of fields and I have frequently used extensions, but <br>\nusually no deeper than three levels. Some examples can be found in the unfinished FSCPI <br>\nformalisation at:</p>\n<p><a href=\"https://www.ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/information-security-group-dam/research/projects/FCSPI/CoSP.zip\">https://www.ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/information-security-group-dam/research/projects/FCSPI/CoSP.zip</a></p>\n<p>Andreas</p>",
        "id": 294727878,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186996
    },
    {
        "content": "<p>From: \"Achim D. Brucker\" &lt;<a href=\"mailto:brucker@spamfence.net\">brucker@spamfence.net</a>&gt;<br>\n(re-sending, as I first used a non-subscribed email address)</p>\n<p>Hi,<br>\nWe are currently porting (at this point in time, manually) the<br>\nextensible encoding for class model from my PhD thesis [A] to<br>\nrecords. Our main application at the moment is a formalization of the<br>\nDocument Object Model (DOM) and partly HTML (as an extension of the<br>\nDOM) for reasoning over browser APIs that modify DOM/HTML instances<br>\n(a first AFP submission is planned for the near future).</p>\n<p>Here, we easily end up with 5 and more extensions and also rather<br>\ncomplex type polynoms as extension types. </p>\n<p>We moved from a datatype-based approach to record to benefit from the<br>\nrecords syntax and also to re-use the existing extensibility of records<br>\n(instead of implementing our own using records or tuples as we did in<br>\nour old object-oriented datatype package). </p>\n<p>Best,<br>\n        Achim</p>\n<p>[A] Achim D. Brucker, Burkhart Wolff: An Extensible Encoding of<br>\n    Object-oriented Data Models in hol. J. Autom. Reasoning 41(3-4):<br>\n    219-249 (2008)<br>\n<a href=\"https://www.brucker.ch/bibliography/abstract/brucker.ea-extensible-2008-b\">https://www.brucker.ch/bibliography/abstract/brucker.ea-extensible-2008-b</a><br>\n<a href=\"/user_uploads/14278/L0hDYtAuiKsnVJ56LrYk05yc/signature.asc\">signature.asc</a></p>",
        "id": 294728021,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187030
    }
]