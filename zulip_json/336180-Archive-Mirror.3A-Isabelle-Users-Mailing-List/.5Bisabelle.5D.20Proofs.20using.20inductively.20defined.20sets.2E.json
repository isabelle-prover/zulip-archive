[
    {
        "content": "<p>From: D Mulligan &lt;<a href=\"mailto:s0346804@sms.ed.ac.uk\">s0346804@sms.ed.ac.uk</a>&gt;<br>\nHi,<br>\n   I've been formulating some Prolog relations in Isabelle using <br>\ninductively defined sets.  I've managed to prove some theorems about <br>\nrelations that are defined entirely within themselves (i.e. plus), but <br>\nwhen I try to prove theorems about relations defined in terms of other <br>\nrelations, for example the reverse of a list, defined in terms of <br>\nitself and append, I hit a wall.  My reverse definition is below:</p>\n<p>consts<br>\n     reverse_inductive :: \"('a list * 'a list) set\"<br>\n   syntax<br>\n     reverse :: \"'a list =&gt; 'a list =&gt; bool\"<br>\n   translations<br>\n     \"reverse l r\" == \"(l, r) \\&lt;in&gt; reverse_inductive\"<br>\n   inductive reverse_inductive<br>\n     intros<br>\n       nil [intro!]: \"reverse [] []\"<br>\n       notnil [intro!]: \"(append r [h] a) /\\ (reverse t r) ==&gt; (reverse <br>\n(h#t) a)\"</p>\n<p>I'm attempting to prove that the reverse of a reverse of a list is the <br>\nsame list.  I have a lemma that states that states \\&lt;exists&gt;c. append a <br>\nb c.  It's been suggested to me that I use this lemma with rule exE[OF <br>\n..] in the proof, but no matter how I attempt to use it I cannot get <br>\nthe proof to go through.</p>\n<p>An attempt at the proof is included below:</p>\n<p>theorem reverse_reverse_l:<br>\n     \"\\&lt;exists&gt;l'.(reverse l l') /\\ (reverse l' l)\"<br>\n     apply(induct_tac l)<br>\n     apply(rule exI)<br>\n     apply(rule conjI)<br>\n     apply(rule reverse_inductive.nil)+<br>\n     apply(rule exE[OF ex_append])<br>\n     apply(rule exI)<br>\n     apply(erule exE)<br>\n     apply(erule conjE)<br>\n     apply(rule conjI)<br>\n     apply(rule reverse_inductive.notnil)<br>\n     apply(rule conjI)<br>\n     apply(assumption)<br>\n       sorry (* Stuck! *)</p>\n<p>The problem (as I see it) is in the step case when I apply <br>\nreverse_inductive.notnil.  Is anybody able to offer any advice as to <br>\nhow I would go about proving this theorem?</p>\n<p>Please note, I'm not using the Isar proof style for a reason.  For your <br>\nconvenience I've attached a theory file with my relations and proofs in <br>\n(scroll to the bottom for the relevant proof attempt).</p>\n<p>Many thanks for any help offered,<br>\nDominic Mulligan<br>\n<a href=\"/user_uploads/14278/VRB-gF3mUbCpIP1WsEnuB4ui/PrologInductiveSets.thy\">PrologInductiveSets.thy</a></p>",
        "id": 294042625,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815973
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@csee.ogi.edu\">brianh@csee.ogi.edu</a>&gt;<br>\nHi Dominic,</p>\n<p>Since you do not instantiate variables in your rule applications, your proof <br>\nstate often contains schematic variables that are instantiated later as <br>\nneeded. (These are the ones written with a leading question mark.)</p>\n<p>You need to pay attention to the parameters that these schematic variables <br>\nhave. In particular, a schematic variable can not be instantiated to a term <br>\nthat contains variables that were created after the schematic variable was. </p>\n<p>In your proof below, \"rule exE[OF ex_append]\" introduces two schematic <br>\nvariables, and afterward \"erule exE\" obtains a new variable l'. Later, you <br>\nwould like to instantiate the schematic variable to l' but you can't, because <br>\nl' did not exist when the schematic variable was created. You might want to <br>\ntry putting \"erule exE\" a few steps earlier.</p>\n<p>Having unbound schematic variables in your proof state is often very <br>\nconfusing. I would recommend instantiating your rules as you apply them <br>\ninstead, i.e. use something like (rule_tac x=\"list\" in exI) instead of just <br>\n(rule exI).</p>\n<p>Hope this helps.</p>\n<ul>\n<li>Brian</li>\n</ul>\n<p>On Wednesday 04 October 2006 04:57, D Mulligan wrote:<br>\n...</p>\n<blockquote>\n<p>I'm attempting to prove that the reverse of a reverse of a list is the<br>\nsame list.  I have a lemma that states that states \\&lt;exists&gt;c. append a<br>\nb c.  It's been suggested to me that I use this lemma with rule exE[OF<br>\n..] in the proof, but no matter how I attempt to use it I cannot get<br>\nthe proof to go through.</p>\n<p>An attempt at the proof is included below:</p>\n<p>theorem reverse_reverse_l:<br>\n     \"\\&lt;exists&gt;l'.(reverse l l') /\\ (reverse l' l)\"<br>\n     apply(induct_tac l)<br>\n     apply(rule exI)<br>\n     apply(rule conjI)<br>\n     apply(rule reverse_inductive.nil)+<br>\n          -- variables from induction rule: a, list<br>\n     apply(rule exE[OF ex_append])<br>\n          -- introduces schematic variables parameterized on a, list<br>\n          -- obtains variable x<br>\n     apply(rule exI)<br>\n          -- introduces schematic variable parameterized on a, list, x<br>\n     apply(erule exE)<br>\n          -- obtains variable l'<br>\n     apply(erule conjE)<br>\n     apply(rule conjI)<br>\n     apply(rule reverse_inductive.notnil)<br>\n     apply(rule conjI)<br>\n     apply(assumption)<br>\n          -- can't apply assumption again because schematic variable<br>\n          -- must not depend on l'<br>\n       sorry (* Stuck! *)</p>\n</blockquote>",
        "id": 294042646,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815981
    },
    {
        "content": "<p>From: Lucas Dixon &lt;<a href=\"mailto:ldixon@inf.ed.ac.uk\">ldixon@inf.ed.ac.uk</a>&gt;<br>\nI think you will also need a lemma:</p>\n<p>theorem reverse_append2:<br>\n     \"\\&lt;lbrakk&gt; append r [h] l; reverse r t \\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; <br>\nreverse l (h#t)\"<br>\n     sorry</p>\n<p>This is the opposite case of your reverse definition. With this you <br>\nshould be able to prove:</p>\n<p>theorem reverse_reverse_l:<br>\n     \"\\&lt;exists&gt;l'.(reverse l l') \\&lt;and&gt; (reverse l' l)\"<br>\n     apply(induct_tac l)<br>\n     apply(rule exI)<br>\n     apply(rule conjI)<br>\n     apply(rule reverse_inductive.nil)+<br>\n     apply(erule exE)<br>\n     apply(erule conjE)<br>\n     apply(rule exE) (* the exE step you mentioned: for the result of <br>\nappend in the definition of reverse *)<br>\ndefer<br>\n     apply(rule exI)<br>\n     apply(rule conjI)<br>\n     apply(rule reverse_inductive.notnil)<br>\n     apply(rule conjI)<br>\ndefer<br>\n     apply assumption<br>\n     apply(rule reverse_append2)<br>\ndefer<br>\n     apply assumption<br>\ndefer<br>\n     apply assumption<br>\n     apply assumption<br>\n     apply (rule ex_append)<br>\ndone</p>\n<p>I'm not sure if this is the most efficient proof... the structure of the <br>\nproof is hard to see in apply style. But with this you can at least see <br>\nthe incremental instantiation of the introduced meta-variables.</p>\n<p>best,<br>\nlucas</p>\n<p>D Mulligan wrote:</p>",
        "id": 294042657,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660815987
    }
]