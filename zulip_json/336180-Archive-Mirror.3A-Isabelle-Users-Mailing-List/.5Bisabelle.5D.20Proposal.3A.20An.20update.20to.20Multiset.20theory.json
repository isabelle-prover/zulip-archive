[
    {
        "content": "<p>From: Bertram Felgenhauer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Isabelle users and maintainers,</p>\n<p>I have been working with the multiset extension from the HOL library<br>\nrecently. In the course of doing so, I proved that the multiset<br>\nextension is cancellative w.r.t. the multiset union, to wit:</p>\n<p>lemma mult_cancel:<br>\n    assumes \"trans s\" \"irrefl s\"<br>\n    shows \"(X + Z, Y + Z) ∈ mult s ⟷ (X, Y) ∈ mult s\" (is \"?L ⟷ ?R\")</p>\n<p>I believe that this lemma is generally useful and would be a good<br>\ncandidate for inclusion in the Isabelle HOL library. However, it<br>\noverlaps with the <code>decreasing_parts_disj</code> lemma from the recent addition<br>\nof an executable version of the multiset extension (f2177f5d2aed).<br>\nI propose to eliminate the latter lemma in favor of mult_cancel.</p>\n<p>See the attached theory for details. To summarize, I propose to</p>\n<ul>\n<li>\n<p>remove lemma decreasing_parts_disj,</p>\n</li>\n<li>\n<p>add lemmas:<br>\n  mult_cancel: ... (X + Z, Y + Z) ∈ mult s ⟷ (X, Y) ∈ mult s<br>\n  mult_cancel_max: ... (X, Y) ∈ mult s ⟷ (X - X #∩ Y, Y - X #∩ Y) ∈ mult s<br>\n  multp_iff: ... multp P N M ⟷ (N, M) ∈ mult R<br>\n    (and corresponding definition of multp)</p>\n</li>\n<li>\n<p>reprove the existing lemma<br>\n  multeqp_iff: multeqp P N M ⟷ (N, M) ∈ (mult R)⇧=</p>\n</li>\n<li>\n<p>optionally add trivial lemmas:<br>\n  mono_mult1: assumes \"s ⊆ s'\" shows \"mult1 s ⊆ mult1 s'\"<br>\n  mono_mult: assumes \"s ⊆ s'\" shows \"mult s ⊆ mult s'\"</p>\n</li>\n</ul>\n<p>The reason for adding the multp version of multeqp is that multp_iff is<br>\n(to me) a natural intermediate result on the way towards the proof of<br>\nthe existing lemma multeqp_iff.</p>\n<p>The mult_cancel_max lemma is used in the proof of multp_iff.</p>\n<p>What do you think? Also, are there any users of the<br>\ndecreasing_parts_disj lemma?</p>\n<p>Cheers,</p>\n<p>Bertram</p>",
        "id": 294678073,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175671
    },
    {
        "content": "<p>From: Bertram Felgenhauer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\n(Once more with an attachment)</p>\n<p>Dear Isabelle users and maintainers,</p>\n<p>I have been working with the multiset extension from the HOL library<br>\nrecently. In the course of doing so, I proved that the multiset<br>\nextension is cancellative w.r.t. the multiset union, to wit:</p>\n<p>lemma mult_cancel:<br>\n    assumes \"trans s\" \"irrefl s\"<br>\n    shows \"(X + Z, Y + Z) ∈ mult s ⟷ (X, Y) ∈ mult s\" (is \"?L ⟷ ?R\")</p>\n<p>I believe that this lemma is generally useful and would be a good<br>\ncandidate for inclusion in the Isabelle HOL library. However, it<br>\noverlaps with the <code>decreasing_parts_disj</code> lemma from the recent addition<br>\nof an executable version of the multiset extension (f2177f5d2aed).<br>\nI propose to eliminate the latter lemma in favor of mult_cancel.</p>\n<p>See the attached theory for details. To summarize, I propose to</p>\n<ul>\n<li>\n<p>remove lemma decreasing_parts_disj,</p>\n</li>\n<li>\n<p>add lemmas:<br>\n  mult_cancel: ... (X + Z, Y + Z) ∈ mult s ⟷ (X, Y) ∈ mult s<br>\n  mult_cancel_max: ... (X, Y) ∈ mult s ⟷ (X - X #∩ Y, Y - X #∩ Y) ∈ mult s<br>\n  multp_iff: ... multp P N M ⟷ (N, M) ∈ mult R<br>\n    (and corresponding definition of multp)</p>\n</li>\n<li>\n<p>reprove the existing lemma<br>\n  multeqp_iff: multeqp P N M ⟷ (N, M) ∈ (mult R)⇧=</p>\n</li>\n<li>\n<p>optionally add trivial lemmas:<br>\n  mono_mult1: assumes \"s ⊆ s'\" shows \"mult1 s ⊆ mult1 s'\"<br>\n  mono_mult: assumes \"s ⊆ s'\" shows \"mult s ⊆ mult s'\"</p>\n</li>\n</ul>\n<p>The reason for adding the multp version of multeqp is that multp_iff is<br>\n(to me) a natural intermediate result on the way towards the proof of<br>\nthe existing lemma multeqp_iff.</p>\n<p>The mult_cancel_max lemma is used in the proof of multp_iff.</p>\n<p>What do you think? Also, are there any users of the<br>\ndecreasing_parts_disj lemma?</p>\n<p>Cheers,</p>\n<p>Bertram<br>\n<a href=\"/user_uploads/14278/QP_RGAaRNFDW7Z4hOB63Qi5H/Multiset_new.thy\">Multiset_new.thy</a></p>",
        "id": 294678082,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175677
    },
    {
        "content": "<p>From: Bertram Felgenhauer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nBertram Felgenhauer via Cl-isabelle-users wrote:</p>\n<blockquote>\n<p>(Once more with an attachment)</p>\n</blockquote>\n<p>And once more. This version works with the current development version<br>\nof Isabelle (3a0f40a6fa42). Sorry for the spam!</p>\n<p>Cheers,</p>\n<p>Bertram<br>\n<a href=\"/user_uploads/14278/4lbedaSorgu61rsPf8pTM353/Multiset_new.thy\">Multiset_new.thy</a></p>",
        "id": 294678110,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175690
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nDear Bertram,</p>\n<p>I see. I cannot find any use of \"multeqp\" in the repositories I mentioned in my previous email, except for some occurrences in IsaFoR. But \"multeqp\" can be implemented more efficiently than \"multp\" (and these predicates appear to be designed for code generation).</p>\n<p>If nobody speaks up against or for one or the other predicate, I suggest you proceed with your intended change.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294679925,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176339
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nRight, code generation was my only reason to investigate this in the<br>\nfirst place (since we had situations where CeTA timed out while trying<br>\nto compare \"tiny\" -- around 10 elements -- multisets), so that's the<br>\nonly reason why I went with multeqp instead of multp.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294680110,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176407
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>I have no objection towards Bertram's proposed extension.</p>\n<p>There is, however, one point which I don't understand:</p>\n<blockquote>\n<p>But \"multeqp\" can be implemented more efficiently than \"multp\" (and these predicates appear to be designed for code generation).</p>\n</blockquote>\n<p>Comparing the two definitions</p>\n<blockquote>\n<p>definition multeqp :: \"('a ⇒ 'a ⇒ bool) ⇒ 'a multiset ⇒ 'a multiset ⇒ bool\" where<br>\n  \"multeqp P N M =<br>\n    (let Z = M #∩ N; X = M - Z; Y = N - Z in<br>\n    (∀y ∈ set_mset Y. ∃x ∈ set_mset X. P y x))\"</p>\n<p>definition multp :: \"('a ⇒ 'a ⇒ bool) ⇒ 'a multiset ⇒ 'a multiset ⇒ bool\" where<br>\n  \"multp P N M =<br>\n    (let Z = M #∩ N; X = M - Z; Y = N - Z in<br>\n    X ≠ {#} ∧ (∀y ∈ set_mset Y. ∃x ∈ set_mset X. P y x))\"</p>\n</blockquote>\n<p>it is difficult to see why this should actually be the case.  The only<br>\ndifference is the emptiness check for the local X, which should be<br>\nefficient to execute.  Maybe the emptiness check has to be carried out<br>\nmore earlier</p>\n<blockquote>\n<p>lemma [code]:<br>\n  \"multp P N M ⟷ (let Z = M #∩ N; X = M - Z<br>\n   in X ≠ {#} ∧ (let Y = N - Z in (∀y∈#Y. Multiset.Bex X (P y))))\"<br>\n  by (simp add: multp_def)</p>\n</blockquote>\n<p>for an efficient execution.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/odxrXkp0VDjvsNxdgZqQbfc3/signature.asc\">signature.asc</a></p>",
        "id": 294680458,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176534
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nHi Florian,</p>\n<p>Indeed. You can forget my comment. I misparsed the emptiness check as the disequality check \"M ~= N\" in the Huet-Oppen formulation of the multiset extension (cf. less_multiset\\&lt;^sub&gt;H\\&lt;^sub&gt;O in Multiset_Order.thy).</p>\n<p>Jasmin</p>",
        "id": 294680476,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176542
    },
    {
        "content": "<p>From: Bertram Felgenhauer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<p>I have no objection towards Bertram's proposed extension.</p>\n</blockquote>\n<p>Nice!</p>\n<p>How shall we proceed? As I hinted at earlier I do not have (nor want, at<br>\nthis point) push access, but I can prepare a patch or clone of the repo,<br>\nif that helps, or just provide a plain theory file that works with the<br>\ndevelopment version of Isabelle.</p>\n<blockquote>\n<blockquote>\n<p>lemma [code]:<br>\n  \"multp P N M ⟷ (let Z = M #∩ N; X = M - Z<br>\n   in X ≠ {#} ∧ (let Y = N - Z in (∀y∈#Y. Multiset.Bex X (P y))))\"<br>\n  by (simp add: multp_def)</p>\n</blockquote>\n<p>for an efficient execution.</p>\n</blockquote>\n<p>That's an easy change to make; in fact we can simply adjust the<br>\ndefinition of multp itself accordingly, without losing any proofs.</p>\n<p>Does this affect the verdict on having both multp and multeqp?</p>\n<p>Cheers,</p>\n<p>Bertram</p>",
        "id": 294680665,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176597
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Bertram,</p>\n<blockquote>\n<p>How shall we proceed? As I hinted at earlier I do not have (nor want, at<br>\nthis point) push access, but I can prepare a patch or clone of the repo,<br>\nif that helps, or just provide a plain theory file that works with the<br>\ndevelopment version of Isabelle.</p>\n</blockquote>\n<p>a repo URL or a patch is indeed the best thing to proceed: there is not<br>\n»the« development version but an ongoing agile development.</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>lemma [code]:<br>\n  \"multp P N M ⟷ (let Z = M #∩ N; X = M - Z<br>\n   in X ≠ {#} ∧ (let Y = N - Z in (∀y∈#Y. Multiset.Bex X (P y))))\"<br>\n  by (simp add: multp_def)</p>\n</blockquote>\n<p>for an efficient execution.</p>\n</blockquote>\n<p>That's an easy change to make; in fact we can simply adjust the<br>\ndefinition of multp itself accordingly, without losing any proofs.</p>\n</blockquote>\n<p>OK.</p>\n<blockquote>\n<p>Does this affect the verdict on having both multp and multeqp?</p>\n</blockquote>\n<p>Both make sense: reflexive and strict order often occur as pairs in<br>\ntheory Isabelle developments.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/KhN3d9_xTrJaBFn7uwfdLDIg/signature.asc\">signature.asc</a></p>",
        "id": 294680690,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176613
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nDear Bertram,</p>\n<blockquote>\n<p>I have been working with the multiset extension from the HOL library<br>\nrecently. In the course of doing so, I proved that the multiset<br>\nextension is cancellative w.r.t. the multiset union, to wit:</p>\n<p>lemma mult_cancel:<br>\n   assumes \"trans s\" \"irrefl s\"<br>\n   shows \"(X + Z, Y + Z) ∈ mult s ⟷ (X, Y) ∈ mult s\" (is \"?L ⟷ ?R\")</p>\n<p>I believe that this lemma is generally useful and would be a good<br>\ncandidate for inclusion in the Isabelle HOL library. However, it<br>\noverlaps with the <code>decreasing_parts_disj</code> lemma from the recent addition<br>\nof an executable version of the multiset extension (f2177f5d2aed).<br>\nI propose to eliminate the latter lemma in favor of mult_cancel.</p>\n</blockquote>\n<p>This sounds reasonable to me.</p>\n<blockquote>\n<p>The reason for adding the multp version of multeqp is that multp_iff is<br>\n(to me) a natural intermediate result on the way towards the proof of<br>\nthe existing lemma multeqp_iff.</p>\n</blockquote>\n<p>I was hoping Florian would comment this part, since it's related to the code setup. I'm not sure it's a gain to add yet another concept, esp. if the motivation is only a minor simplification of an existing proof. Or did I misunderstand your motivation?</p>\n<blockquote>\n<p>What do you think? Also, are there any users of the<br>\ndecreasing_parts_disj lemma?</p>\n</blockquote>\n<p>Previous queries on the mailing list revealed that few formalizations use multisets much. The main consumers of Multisets would appear to be the Isabelle distribution, the AFP, IsaFoR, and IsaFoL [*]. A quick grep in these repositories reveals nothing. I would be in favor of that simplification.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>\n<p>[*] <a href=\"https://bitbucket.org/jasmin_blanchette/isafol/wiki/Home\">https://bitbucket.org/jasmin_blanchette/isafol/wiki/Home</a></p>",
        "id": 294680755,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176653
    },
    {
        "content": "<p>From: Bertram Felgenhauer via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Jasmin,<br>\nI believe multp is the more fundamental of the two predicates; after<br>\nall, the rest of the theory is mostly concerned with the strict multiset<br>\nextension. But I was reluctant to drop the existing multeqp predicate in<br>\nfavor of multp.</p>\n<p>Maybe Christian Sternagel can comment on this?</p>\n<p>Cheers,</p>\n<p>Bertram</p>",
        "id": 294681660,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176922
    }
]