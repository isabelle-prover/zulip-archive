[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nDear list,</p>\n<p>for a current project of mine, I have to talk about the set of<br>\nsubexpressions of a syntax tree and I need both the fact that this set<br>\nis finite and the individual introduction rules.</p>\n<p>My first attempt, which can be seen at<br>\n<a href=\"http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/CPSUtils.thy;h=b76dbbe68a4002b277fc7abbe930d235ff5cc85b;hb=df00ade5a418f1666624f8334ea253accf05d1c1\">http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/CPSUtils.thy;h=b76dbbe68a4002b277fc7abbe930d235ff5cc85b;hb=df00ade5a418f1666624f8334ea253accf05d1c1</a><br>\nwas to define the set of subexpressions using the fun package. Showing<br>\nfiniteness was easily done by induction. But proving the local rules I<br>\nneed (e.g. lambdas1, lambdas2, app1, app2,... in that file) turned out<br>\nto be very inelegant, repetitive and ugly.</p>\n<p>If I had defined the sets of subexpressions inductively, these rules<br>\nwould be provided directly, but then the proof of finiteness is harder.<br>\nI worked on a general solution and the result so far can be seen at<br>\n<a href=\"http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/Finite_Inductive_Set.thy;h=23bc9d27951e270342404b546546ccb77caf303c;hb=df00ade5a418f1666624f8334ea253accf05d1c1\">http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/Finite_Inductive_Set.thy;h=23bc9d27951e270342404b546546ccb77caf303c;hb=df00ade5a418f1666624f8334ea253accf05d1c1</a></p>\n<p>The main result is</p>\n<p>84 lemma lfp_finite:<br>\n  85   assumes mono: \"mono F\"<br>\n  86       and finite: \"finiteness_preserving F\"<br>\n  87       and desc: \"descending_functional p F\"<br>\n  88   shows \"finite (lfp F)\"</p>\n<p>where finiteness_preserving means that F S is finite if S already is and<br>\ndescending_functional means that newly added elements are smaller than<br>\npreviously added elements when measured with \"p\" (for which I later only<br>\nuse the size function).</p>\n<p>Here is an example application of the system. I define an inductive set<br>\ngiving the tails of a list:</p>\n<p>194 inductive tails for l<br>\n 195   where \"tails l l\"<br>\n 196       | \"tails l (x#xs) \\&lt;Longrightarrow&gt; tails l xs\"</p>\n<p>207 lemma \"finite (tails l)\"<br>\n 208 unfolding tails_def<br>\n 209 proof (induct rule: lfp_finite[of _ size, case_names mono finiteness desc])<br>\n 210 case mono show ?case by mono<br>\n 211 next<br>\n 212 case finiteness show ?case by (intro finiteness_preserving_lemmas, simp)<br>\n 213 next<br>\n 214 case desc show ?case<br>\n 215   by (rule, auto simp add: Bex_def mem_def fun_diff_def bool_diff_def)<br>\n 216 qed</p>\n<p>For the proof of monotonicity, I copied the ML code from inductive.ML<br>\ninto a custom method.</p>\n<p>For the proof of finiteness preserving I wrote some intro rules breaking<br>\ndown the functional generated by inductive_set and handling the types of<br>\nclauses I observed so far.</p>\n<p>For the proof that the functional is descending I had to persuade<br>\nIsabelle not to be confused by sets vs. predicates, then it went through<br>\neasily (at least in this simple case).</p>\n<p>So far so nice. For these kind of inductive sets, the result is quite<br>\nsatisfying, and maybe can be useful for others as well.</p>\n<p>Unfortunately, in my case, I need mutually recursive sets. Line 29 of<br>\nCPSUtils has \"inductive_set lambdas' and calls' and values'\"<br>\ndemonstrating the issue, but a smaller example is at the end of<br>\nFinite_Inductive_Set.thy:</p>\n<p>296 inductive tails' and elems' for l<br>\n 297   where \"tails' l l\"<br>\n 298       | \"tails' l (x#xs) \\&lt;Longrightarrow&gt; tails' l xs\"<br>\n 299       | \"tails' l (x#xs) \\&lt;Longrightarrow&gt; elems' l x\"</p>\n<p>The problem is that inducive_set generates a combined fixed point of<br>\ntype \"bool =&gt; 'a list =&gt; 'a =&gt; bool\". This large set is then projected<br>\nonto \"'a list =&gt; bool\" or \"'a =&gt; bool\" by extracting those elements<br>\nwhere the boolean flag fits and where the “other” field is undefined.</p>\n<p>I wrote a rule that converts such a fixed point to one with uncurried<br>\narguments, i.e. \"((bool \\&lt;times&gt; 'a list) \\&lt;times&gt; 'a) =&gt; bool\" in<br>\nlfp_curry and the variant lfp_curryD which carries the monotonicity<br>\nrequirement along. This way I end up at a fixed point where I can apply<br>\nlfp_finite. Unfortunately, these fixed points do not preserve<br>\nfiniteness, as can be seen by this unsolvable goal:</p>\n<p>finiteness_preserving (λp x. ¬ fst (fst x) ∧ snd x = l)</p>\n<p>This rule, which comes from the first equation about tails', adds all<br>\ntriples where the first field is False and the last field is l (as<br>\nexpected), but makes no statement about the second fields. I.e. this<br>\nrule adds one element per member of 'a! And naturally, this makes my<br>\nwhole process fail.</p>\n<p>The other rules share the same problem in that they do not specify all<br>\nfields.</p>\n<p>I’m not sure how to proceed from here. A workaround would be to define a<br>\ncombined set using Inl/Inr:</p>\n<p>inductive tailselems for l<br>\n  where \"tailselems l (Inl l)\"<br>\n      | \"tailselems l (Inl (x#xs)) ⟹ tailselems l (Inl xs)\"<br>\n      | \"tailselems l (Inl (x#xs)) ⟹ tailselems l (Inr x)\"</p>\n<p>But this would get quickly very unwieldy, especially as I need to<br>\nrecursively define more than one set.</p>\n<p>Another possible fix could involve changes to inducitve_set. Why not set<br>\nall invalid fields of the added members to undefined, and thus do not<br>\nadd all those never-used elements? BTW, what is the reason not to use<br>\nInl/Inr there in the first place?</p>\n<p>Or is there maybe a completely different solution that I’m just not<br>\nseeing yet?</p>\n<p>Thanks in advance,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/OgRa9V7jkJYdTaDNFFmi7Els/signature.asc\">signature.asc</a></p>",
        "id": 294118693,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839116
    }
]