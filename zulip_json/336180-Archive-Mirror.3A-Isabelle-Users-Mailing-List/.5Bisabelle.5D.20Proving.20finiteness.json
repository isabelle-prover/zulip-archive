[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all,</p>\n<p>I wonder whether there is a cheap (best: fully automatic) way for<br>\nproving finiteness of sets of the form { f a1...an | a1...an. g a1...an<br>\n: S } if S is known to be finite.<br>\nActually, I have some inductive datatype:<br>\n  datatype ('a,'b,'c) test = A 'a 'b 'c | B 'a 'b</p>\n<p>And need to prove the following:<br>\n  lemma \"finite S ==&gt; finite { f a b c | a b c. A a b c : S }\"</p>\n<p>The only way I succeed to prove this, is to manually convert this into<br>\nthe form: g ` ({s:S. P s}), where g and P are defined appropriately.<br>\nHowever, this is tedious and I wished to have an automatic way to prove<br>\nthis.</p>\n<p>Thanks in advance for any hints,<br>\n  Peter</p>",
        "id": 294078971,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830015
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Peter,</p>\n<p>Hmmm... at least you will need to use the fact that g is injective <br>\nsomehow, because otherwise it might not hold... Imagine g being a <br>\nconstant function...</p>\n<p>Alex</p>",
        "id": 294078980,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830020
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nAndreas Lochbihler wrote:</p>\n<blockquote>\n<p>Hi Peter,</p>\n<blockquote>\n<p>I wonder whether there is a cheap (best: fully automatic) way for<br>\nproving finiteness of sets of the form { f a1...an | a1...an. g a1...an<br>\n: S } if S is known to be finite.<br>\nIn this general case, this is not true, e.g. if g is a constant<br>\nfunction, i.e. not injective, but datatype constructors are injective.</p>\n</blockquote>\n<p>I suggest that you prove some nice lemmata such that the rewriting<br>\nworks automatically.</p>\n<p>Thank you very much, your finite_Collect - lemma is such a nice lemma,<br>\nthat solved my problem!</p>\n</blockquote>\n<p>Peter</p>\n<blockquote>\n<blockquote>\n<p>Actually, I have some inductive datatype:<br>\n  datatype ('a,'b,'c) test = A 'a 'b 'c | B 'a 'b</p>\n<p>And need to prove the following:<br>\n  lemma \"finite S ==&gt; finite { f a b c | a b c. A a b c : S }\"</p>\n</blockquote>\n<p>For this concrete example, try the following:</p>\n<p>lemma Ex_contract:<br>\n  \"(\\&lt;exists&gt;a b. P a b) = (\\&lt;exists&gt;ab. P (fst ab) (snd ab))\"<br>\nby auto</p>\n<p>This will bundle the multiple existential quantifiers, that are<br>\nimplicit in the Collect notation into a single one, to which one can<br>\napply image_Collect subsequently. Then, you also need one to get rid<br>\nof the function application, e.g.</p>\n<p>lemma finite_Collect:<br>\n  assumes fin: \"finite S\" and inj: \"inj f\"<br>\n  shows \"finite {a. f a : S}\"<br>\nproof -<br>\n  def S' == \"S \\&lt;inter&gt; range f\"<br>\n  hence \"{a. f a : S} = {a. f a : S'}\" by auto<br>\n  also have \"... = (inv f) <code> S'\"\n  proof\n    show \"{a. f a : S'} &lt;= inv f </code> S'\"<br>\n      using inj by(force intro: image_eqI)<br>\n    show \"inv f <code> S' &lt;= {a. f a : S'}\"\n    proof\n      fix x\n      assume \"x : inv f </code> S'\"<br>\n      then obtain y where \"y : S'\" \"x = inv f y\" by blast<br>\n      moreover from <code>y : S'</code> obtain x' where \"f x' = y\"<br>\n        unfolding S'_def by blast<br>\n      hence \"f (inv f y) = y\" unfolding inv_def by(rule someI)<br>\n      ultimately show \"x : {a. f a : S'}\" by simp<br>\n    qed<br>\n  qed<br>\n  also have \"finite S'\" using fin unfolding S'_def by blast<br>\n  ultimately show ?thesis by simp<br>\nqed</p>\n<p>With these two lemmata, your lemma is very easy:</p>\n<p>lemma \"finite S ==&gt; finite { f a b c | a b c. A a b c : S }\"<br>\napply(simp only: Ex_contract image_Collect[symmetric])<br>\napply(fastsimp intro: finite_imageI finite_Collect inj_onI)<br>\ndone</p>\n<p>If you massage the simp_set a bit, you will probably be able to do it<br>\nin just one step.</p>\n<p>Andreas</p>\n</blockquote>",
        "id": 294079024,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830032
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@ipd.info.uni-karlsruhe.de\">lochbihl@ipd.info.uni-karlsruhe.de</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<p>I wonder whether there is a cheap (best: fully automatic) way for<br>\nproving finiteness of sets of the form { f a1...an | a1...an. g a1...an<br>\n: S } if S is known to be finite.<br>\nIn this general case, this is not true, e.g. if g is a constant <br>\nfunction, i.e. not injective, but datatype constructors are injective.</p>\n</blockquote>\n<p>I suggest that you prove some nice lemmata such that the rewriting works <br>\nautomatically.</p>\n<blockquote>\n<p>Actually, I have some inductive datatype:<br>\n  datatype ('a,'b,'c) test = A 'a 'b 'c | B 'a 'b</p>\n<p>And need to prove the following:<br>\n  lemma \"finite S ==&gt; finite { f a b c | a b c. A a b c : S }\"</p>\n</blockquote>\n<p>For this concrete example, try the following:</p>\n<p>lemma Ex_contract:<br>\n   \"(\\&lt;exists&gt;a b. P a b) = (\\&lt;exists&gt;ab. P (fst ab) (snd ab))\"<br>\nby auto</p>\n<p>This will bundle the multiple existential quantifiers, that are implicit <br>\nin the Collect notation into a single one, to which one can apply <br>\nimage_Collect subsequently. Then, you also need one to get rid of the <br>\nfunction application, e.g.</p>\n<p>lemma finite_Collect:<br>\n   assumes fin: \"finite S\" and inj: \"inj f\"<br>\n   shows \"finite {a. f a : S}\"<br>\nproof -<br>\n   def S' == \"S \\&lt;inter&gt; range f\"<br>\n   hence \"{a. f a : S} = {a. f a : S'}\" by auto<br>\n   also have \"... = (inv f) <code> S'\"\n   proof\n     show \"{a. f a : S'} &lt;= inv f </code> S'\"<br>\n       using inj by(force intro: image_eqI)<br>\n     show \"inv f <code> S' &lt;= {a. f a : S'}\"\n     proof\n       fix x\n       assume \"x : inv f </code> S'\"<br>\n       then obtain y where \"y : S'\" \"x = inv f y\" by blast<br>\n       moreover from <code>y : S'</code> obtain x' where \"f x' = y\"<br>\n         unfolding S'_def by blast<br>\n       hence \"f (inv f y) = y\" unfolding inv_def by(rule someI)<br>\n       ultimately show \"x : {a. f a : S'}\" by simp<br>\n     qed<br>\n   qed<br>\n   also have \"finite S'\" using fin unfolding S'_def by blast<br>\n   ultimately show ?thesis by simp<br>\nqed</p>\n<p>With these two lemmata, your lemma is very easy:</p>\n<p>lemma \"finite S ==&gt; finite { f a b c | a b c. A a b c : S }\"<br>\napply(simp only: Ex_contract image_Collect[symmetric])<br>\napply(fastsimp intro: finite_imageI finite_Collect inj_onI)<br>\ndone</p>\n<p>If you massage the simp_set a bit, you will probably be able to do it in <br>\njust one step.</p>\n<p>Andreas</p>",
        "id": 294079134,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830075
    }
]