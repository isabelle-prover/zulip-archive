[
    {
        "content": "<p>From: Michael Walker &lt;<a href=\"mailto:mike@barrucadu.co.uk\">mike@barrucadu.co.uk</a>&gt;<br>\nHi,</p>\n<p>I've been getting into Isabelle recently, and I have a problem with<br>\nfunction termination: I have a recursive data type, and a function<br>\nchecking some property of it, but I'm not sure how to approach the<br>\ntermination proof:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span> <span class=\"n\">MinimalExample</span>\n<span class=\"kp\">imports</span> <span class=\"n\">Main</span> <span class=\"s\">\"~~/src/HOL/Library/FSet\"</span> <span class=\"n\">Map</span>\n<span class=\"k\">begin</span>\n\n<span class=\"k\">datatype</span> <span class=\"n\">ThreadId</span> <span class=\"o\">=</span> <span class=\"n\">UserThread</span> <span class=\"n\">nat</span>\n\n<span class=\"k\">datatype</span> <span class=\"n\">POR</span> <span class=\"o\">=</span> <span class=\"n\">POR</span> <span class=\"s\">\"ThreadId fset\"</span> <span class=\"s\">\"ThreadId fset\"</span> <span class=\"s\">\"ThreadId ⇀ POR\"</span>\n\n<span class=\"kn\">function</span>\n  <span class=\"n\">por_well_formed</span> <span class=\"o\">::</span> <span class=\"s\">\"POR ⇒ bool\"</span>\n<span class=\"kp\">where</span>\n  <span class=\"s\">\"por_well_formed por ⟷ (case por of (POR runnable todo done) ⇒</span>\n<span class=\"s\">   ( todo |⊆| runnable</span>\n<span class=\"s\">   ∧ dom done ⊆ fset runnable</span>\n<span class=\"s\">   ∧ fset todo ∩ dom done = {})</span>\n<span class=\"s\">   ∧ (∀ p ∈ ran done. por_well_formed p))\"</span>\n<span class=\"k\">by</span> <span class=\"n\">auto</span>\n<span class=\"kn\">termination</span> <span class=\"gr\">sorry</span>\n\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>My informal termination argument goes like this: because POR is data,<br>\nnot codata, there can't be an infinite sequence POR1 -&gt; POR2 -&gt; POR3<br>\n-&gt; ... (following the links in the map). This means that the recursive<br>\ncase in por_well_formed will terminate. However, I'm not sure how to<br>\nformalise that.</p>\n<p>Any suggestions for this in particular, or termination proofs in<br>\ngeneral, would be greatly appreciated.</p>",
        "id": 294659624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169431
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nJust to document it for the mailing list: this question was also asked <br>\nin the #isabelle IRC channel on Freenode yesterday, and it received two <br>\nanswers, one by someone called ‘int-e’ and one by me:</p>\n<p>int-e's answer was:</p>\n<p>termination<br>\nproof -<br>\n   let ?R = \"{(y,POR runnable todo don) | runnable todo don y s. s ∈ range don ∧ y ∈ set_option s }\"<br>\n   {<br>\n     fix P x<br>\n     assume *: \"⋀x. (⋀y. (y, x) ∈ ?R ⟹ P y) ⟹ P x\"<br>\n     have \"P x\"<br>\n       by (induct x rule: POR.induct) (auto intro: *)<br>\n   }<br>\n   then have \"wf ?R\" by (auto simp: wf_def)<br>\n   then show ?thesis<br>\n     by (relation ?R) (auto simp: ran_def image_def, metis)<br>\nqed</p>\n<p>It's really stupid because it's a bona fide inductive definition on the data type definition; morally it <em>is</em> primitive recursive. but the underlying well-founded relation on POR is not readily available; that's what I'm defining as ?R in the proof (or so I believe, I'd be happy to be shown wrong)</p>\n<p>My answer was:</p>\n<p>definition por_well_formed where \"por_well_formed = rec_POR (λrunnable <br>\ntodo done. todo |⊆| runnable ∧ dom done ⊆ fset runnable ∧ fset todo ∩ <br>\ndom done = {} ∧ (∀p ∈ ran done. snd p))\" lemma por_well_formed_simps: <br>\n\"por_well_formed (POR runnable todo done) ⟷ ( todo |⊆| runnable ∧ dom <br>\ndone ⊆ fset runnable ∧ fset todo ∩ dom done = {}) ∧ (∀ p ∈ ran done. <br>\npor_well_formed p)\" unfolding por_well_formed_def by (simp add: <br>\ndom_map_option ran_map_option o_def)</p>\n<p>int-e is correct, this is a primitively-recursive function, so the easiest way to define it is to define it as one.<br>\nThe problem is that \"primrec\" is apparently not smart enough to figure out that your definition is primitively-recursive I just did it by hand and proved the \"simp\" rule separately afterwards</p>\n<p>Two more remarks:</p>\n<ol>\n<li>\n<p>your datatype is essentially an infinitely-branching tree, which means you can have potentially unbounded traversal paths in it, so there simply is no sensible \"size\" function for them, which makes proving termination more painful (although in this case, it can be done with relatively little effort, as shown by int-e)</p>\n</li>\n<li>\n<p>your function implicitly enforces the domain of \"done\" to be finite, so you could actually define a \"size\" function for this case, and it would be something \"size (POR _ _ done) = 1 + Max (size ` ran done)\". But you'd also have to add conj_cong as a fundef_cong rule or rewrite your definition with if _ then _ else in order to be able to use the fact that \"done\" has finite domain</p>\n</li>\n</ol>",
        "id": 294659684,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169450
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nPrimec supports a syntactic fragment where for nested recursion (here nesting through the function type and option) one has to use the corresponding map functions. For the function type this is “o” (which is allowed to be unfolded as well, see below) and for option this is map_option. So tuning the function’s specification a bit makes it accepted by primrec:</p>\n<p>primrec<br>\n por_well_formed :: \"POR ⇒ bool\"<br>\nwhere<br>\n \"por_well_formed (POR runnable todo done) =<br>\n  ( todo |⊆| runnable<br>\n  ∧ dom done ⊆ fset runnable<br>\n  ∧ fset todo ∩ dom done = {}<br>\n  ∧ (∀ p. map_option por_well_formed (done p) ≠ Some False))”</p>\n<p>Then one can derive the original equation by (induct por) (auto simp: ran_def).</p>\n<p>Dmitriy</p>",
        "id": 294659751,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169481
    }
]