[
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Isabelle experts,</p>\n<p>I have defined a function to convert rational polynomials to real ones, <br>\nand want to prove this function respects some other operations on <br>\npolynomials.</p>\n<p>theory Scratch1<br>\n   imports Complex_Main \"~~/src/HOL/Library/Polynomial\"<br>\nbegin</p>\n<p>lift_definition real_poly:: \"rat poly ⇒ real poly\" is<br>\n  \"%p. real_of_rat o p \" unfolding almost_everywhere_zero_def by auto</p>\n<p>lemma real_poly_plus: \"real_poly (p + q) = real_poly p + real_poly q\"<br>\n   (<em>apply transfer</em>)<br>\nusing real_poly.rep_eq Rat.of_rat_add by (intro poly_eqI,auto)</p>\n<p>end</p>\n<p>Although the lemma real_poly_plus can be proved by \"using <br>\nreal_poly.rep_eq Rat.of_rat_add by (intro poly_eqI,auto)\", I really want <br>\nto use the transfer method to convert goals from abstract types to <br>\nrepresentation types as many lemmas related to \"of_rat\" do. However, <br>\nafter \"apply transfer\" the lemma real_poly_plus becomes:</p>\n<ol>\n<li>\n<p>!!p q. almost_everywhere_zero p ==&gt;<br>\n            almost_everywhere_zero q ==&gt; real_of_rat ∘ ?ad16 p q = ?ae16 <br>\n(real_of_rat ∘ p) (real_of_rat ∘ q)</p>\n<ol start=\"2\">\n<li>\n<p>Transfer.Rel (rel_fun (pcr_poly op =) (rel_fun (pcr_poly op =) <br>\n(pcr_poly op =))) ?ad16 op +</p>\n</li>\n<li>\n<p>Transfer.Rel (rel_fun (pcr_poly op =) (rel_fun (pcr_poly op =) <br>\n(pcr_poly op =))) ?ae16 op +</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>which I don't know how to proceed. Is there anything I can do to use the <br>\ntransfer method properly in my case?</p>\n<p>Many thanks,<br>\nWenda</p>",
        "id": 294294697,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924238
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Isabelle experts,</p>\n<p>I have investigated my previous problem. The problem can be solved by <br>\nproviding an alternative plus operation for polynomials:</p>\n<p>lift_definition plus_poly1 :: \"'a::comm_monoid_add poly ⇒ 'a poly ⇒ 'a <br>\npoly\"<br>\n   is \"%p q n. p n + q n\" sorry</p>\n<p>lemma real_poly_plus: \"real_poly (plus_poly1 p q) = plus_poly1 <br>\n(real_poly p) (real_poly q)\"<br>\n   apply transfer<br>\n   (<em>as desired</em>)</p>\n<p>Compared to the original plus operation for polynomials:</p>\n<p>lift_definition plus_poly :: \"'a poly ⇒ 'a poly ⇒ 'a poly\"<br>\n   is \"%p q n. coeff p n + coeff q n\"</p>\n<p>then only difference between plus_poly1 and plus_poly is that plus_poly1 <br>\ntakes its arguments as<br>\nrepresentation types for polynomials (i.e. \"nat =&gt; 'a\") while plus_poly <br>\ntakes its arguments as abstract types (i.e. \"'a poly\"). In my case, <br>\nplus_poly1 works much better for the transfer method than plus_poly.</p>\n<p>Therefore, it occurs to me when we are using lift_defition, shall we try <br>\nto use representation types and avoid abstract types? I have checked <br>\nInt.thy, Rat.thy and Real.thy, and they all fit my hypothesis, while <br>\ndefinitions in Polynomial.thy confuse me.</p>\n<p>Many thanks for any help,<br>\nWenda</p>",
        "id": 294306036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924324
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nHi Wenda,</p>\n<p>You are completely right about the uses of lift_definition in the<br>\nPolynomial theory. The point of lift_definition is to avoid writing<br>\ndefinitions in terms of the Rep/Abs functions for types. Function<br>\n\"coeff\" is the Rep function for the polynomial type, and so it should<br>\nbe avoided when using lift_definition.</p>\n<p>Polynomial.thy was written before lift_definition/transfer existed, so<br>\nthe original definitions all used \"coeff\" explicitly. When it was<br>\nported over to use lift_definition (apparently by Florian Haftmann<br>\nsome time last year), I guess some redundant uses of \"coeff\" were<br>\noverlooked.</p>\n<p>If it makes the \"transfer\" method more useful, it would probably be a<br>\ngood idea to change the definitions in Polynomial.thy to match the<br>\nstyle of your \"plus_poly1\". Perhaps Florian is willing to take this<br>\non?</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294306082,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924336
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Wenda &amp; al.</p>\n<blockquote>\n<p>You are completely right about the uses of lift_definition in the<br>\nPolynomial theory. The point of lift_definition is to avoid writing<br>\ndefinitions in terms of the Rep/Abs functions for types. Function<br>\n\"coeff\" is the Rep function for the polynomial type, and so it should<br>\nbe avoided when using lift_definition.</p>\n</blockquote>\n<p>the issue is related to the fact that lifting always operates on<br>\nexpressions of a certain type, not on expressions consisting of certain<br>\n»transferable« operations.  Hence, if an expression you want to lift<br>\ncontains operations not defined using lift_definition, you get<br>\nunexpected (unusable) results from transfer.</p>\n<p>There are a couple of subissues actually arising here, which should not<br>\nbother you at the moment and I will set them out in a separate thread.<br>\nFor the moment just note that you can often help yourself using the<br>\nfollowing pattern</p>\n<p>lemma …<br>\nunfolding (*) proof transfer<br>\n  …<br>\nqed</p>\n<p>where in * you place equational theorems which unfold the<br>\n»untransferable« operations to »transferable« ones.</p>\n<blockquote>\n<p>If it makes the \"transfer\" method more useful, it would probably be a<br>\ngood idea to change the definitions in Polynomial.thy to match the<br>\nstyle of your \"plus_poly1\". Perhaps Florian is willing to take this<br>\non?</p>\n</blockquote>\n<p>I am currently absorbed in preparing a co-work for an AFP submission<br>\nconcerning multivariate polynomials.  After that the future of<br>\nPolynomial.thy can come on the agenda again.</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<ul>\n<li>Brian</li>\n</ul>\n<p>On Thu, Sep 18, 2014 at 6:24 AM, Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Isabelle experts,</p>\n<p>I have investigated my previous problem. The problem can be solved by<br>\nproviding an alternative plus operation for polynomials:</p>\n<p>lift_definition plus_poly1 :: \"'a::comm_monoid_add poly ⇒ 'a poly ⇒ 'a poly\"<br>\n  is \"%p q n. p n + q n\" sorry</p>\n<p>lemma real_poly_plus: \"real_poly (plus_poly1 p q) = plus_poly1 (real_poly p)<br>\n(real_poly q)\"<br>\n  apply transfer<br>\n  (<em>as desired</em>)</p>\n<p>Compared to the original plus operation for polynomials:</p>\n<p>lift_definition plus_poly :: \"'a poly ⇒ 'a poly ⇒ 'a poly\"<br>\n  is \"%p q n. coeff p n + coeff q n\"</p>\n<p>then only difference between plus_poly1 and plus_poly is that plus_poly1<br>\ntakes its arguments as<br>\nrepresentation types for polynomials (i.e. \"nat =&gt; 'a\") while plus_poly<br>\ntakes its arguments as abstract types (i.e. \"'a poly\"). In my case,<br>\nplus_poly1 works much better for the transfer method than plus_poly.</p>\n<p>Therefore, it occurs to me when we are using lift_defition, shall we try to<br>\nuse representation types and avoid abstract types? I have checked Int.thy,<br>\nRat.thy and Real.thy, and they all fit my hypothesis, while definitions in<br>\nPolynomial.thy confuse me.</p>\n<p>Many thanks for any help,<br>\nWenda</p>\n</blockquote>\n<p>On 2014-09-16 13:14, Wenda Li wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear Isabelle experts,</p>\n<p>I have defined a function to convert rational polynomials to real<br>\nones, and want to prove this function respects some other operations<br>\non polynomials.</p>\n<p>theory Scratch1<br>\n  imports Complex_Main \"~~/src/HOL/Library/Polynomial\"<br>\nbegin</p>\n<p>lift_definition real_poly:: \"rat poly ⇒ real poly\" is<br>\n \"%p. real_of_rat o p \" unfolding almost_everywhere_zero_def by auto</p>\n<p>lemma real_poly_plus: \"real_poly (p + q) = real_poly p + real_poly q\"<br>\n  (<em>apply transfer</em>)<br>\nusing real_poly.rep_eq Rat.of_rat_add by (intro poly_eqI,auto)</p>\n<p>end</p>\n<p>Although the lemma real_poly_plus can be proved by \"using<br>\nreal_poly.rep_eq Rat.of_rat_add by (intro poly_eqI,auto)\", I really<br>\nwant to use the transfer method to convert goals from abstract types<br>\nto representation types as many lemmas related to \"of_rat\" do.<br>\nHowever, after \"apply transfer\" the lemma real_poly_plus becomes:</p>\n<ol>\n<li>!!p q. almost_everywhere_zero p ==&gt;<br>\n           almost_everywhere_zero q ==&gt; real_of_rat ∘ ?ad16 p q =<br>\n?ae16 (real_of_rat ∘ p) (real_of_rat ∘ q)</li>\n<li>Transfer.Rel (rel_fun (pcr_poly op =) (rel_fun (pcr_poly op =)<br>\n(pcr_poly op =))) ?ad16 op +</li>\n<li>Transfer.Rel (rel_fun (pcr_poly op =) (rel_fun (pcr_poly op =)<br>\n(pcr_poly op =))) ?ae16 op +</li>\n</ol>\n<p>which I don't know how to proceed. Is there anything I can do to use<br>\nthe transfer method properly in my case?</p>\n<p>Many thanks,<br>\nWenda</p>\n</blockquote>\n<p>--<br>\nWenda Li<br>\nPhD Candidate<br>\nComputer Laboratory<br>\nUniversity of Cambridge<br>\n</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/TepfdEYwqUPK12yWVWIkoLh2/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294306121,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924350
    }
]