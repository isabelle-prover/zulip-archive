[
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nHi Florian and Andreas,</p>\n<p>Many thanks for your previous emails. I now have some further <br>\nconfusions.</p>\n<p>Suppose I have a type A:</p>\n<p>consts P:: \"real ⇒ bool\"<br>\ntypedef A=\"{x::real. P x}\" sorry</p>\n<p>Then, I provide a pseudo constructor C for A:</p>\n<p>consts C:: \"nat ⇒ A\"<br>\nconsts C':: \"A ⇒ nat\"<br>\nlemma [code abstype]:\"C (C' x) = x\" sorry</p>\n<p>After that, I define a function g and provide an code equation:</p>\n<p>consts g::\"A ⇒ bool\"<br>\nlemma [code]:  \"g (C 0) = True\" sorry</p>\n<p>Now, I want to check code equations for g and see evaluation of g (C 0):</p>\n<p>code_thms g<br>\nvalue \"g (C 0)\"</p>\n<p>but both fail due to</p>\n<p>\"C\" is not a constructor, on left hand side of equation, in theorem:<br>\ng (C zero_nat_inst.zero_nat) ≡ True</p>\n<p>However, if I specify</p>\n<p>code_datatype C</p>\n<p>then everything goes as expected. I am a little confused by the <br>\nbehaviour, since I was assuming both \"code abstype\" and \"code_datatype\" <br>\nprovide a way to construct a pseudo constructor.</p>\n<p>Many thanks for any advice,<br>\nWenda</p>",
        "id": 294306185,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924367
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda,</p>\n<p>If you declare a pseudo-constructor via code_abstype, then the pseudo-constructor is must <br>\nnot occur in any code equation. Instead, you have to phrase all theorems using the <br>\ndestructor. The reason behind this is that such pseudo-constructors are normally used for <br>\ntypes with invariants, and these invariants cannot be expressed by pattern matching. In <br>\nthis style, your example should be written as follows:</p>\n<p>lemma [code]: \"g x = (case C x' of 0 =&gt; True)\"</p>\n<p>If your function returns another value of an code_abstype type, you have to apply the <br>\ndestructor to the left-hand side.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294306220,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924380
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear data refinement experts,</p>\n<p>I am trying to learn something about code generation. Based on what I <br>\nhave seen so far, there are two ways to introduce a pseudo constructor <br>\nfor an abstract type A:<br>\n     1) define constant f:: C =&gt; A and g::A =&gt; C, and then prove<br>\n            lemma [code abstype]: f (g x) = x<br>\n        ,and f becomes a pseudo constructor for the abstract type A<br>\n     2) define constant f:: C =&gt; A, and then declare<br>\n            code_datatype f<br>\nBased on my observations, only one of them is used at a time:<br>\n     \"Int.thy\": code_datatype \"0::int\" Pos Neg<br>\n     \"Real.thy\": code_datatype Ratreal<br>\n     \"Multiset.thy\": code_datatype multiset_of<br>\nhave adopted the second approach, while<br>\n     \"Rat.thy\": lemma [code abstype]:\"Frct (quotient_of q) = q\"<br>\n     \"Polynomial.thy\": lemma Poly_coeffs [simp, code abstype]: \"Poly <br>\n(coeffs p) = p\"<br>\nhave adopted the first approach.</p>\n<p>It seems that the \"code_datatype\" approach is more flexible than the <br>\n\"abstype\" approach, as multiple constructors can be introduced (I am not <br>\nsure if it is not case for the \"abstype\" approach) and the cardinality <br>\nof C can be smaller than that of A (e.g. Ratreal in \"Real.thy\").</p>\n<p>My question is: what is the main difference between these two <br>\napproaches? When shall I choose one over the other?</p>\n<p>Many thanks in advance,<br>\nWenda</p>",
        "id": 294306546,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924478
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Wenda,</p>\n<p>I am not sure which documentation you have read so far.  The »Tutorial<br>\non code generation« contains some explanations and examples concerning<br>\ndatatype abstraction.  There is also a substantial publication »Data<br>\nRefinement in Isabelle/HOL«.</p>\n<p>In short, it is helpful to thinkg about pseudo constructors as<br>\nmorphisms.  A pseudo constructor declared using »code_datatype« must be<br>\nsurjective.  A pseudo constructor declared using »[code abstype]« must<br>\nbe injective.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/zTMVi5rBL6F2DBwbfijq_gJV/signature.asc\">signature.asc</a></p>",
        "id": 294307092,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924681
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nHi Florian,</p>\n<p>Many thanks for your clarification, it helps a lot.</p>",
        "id": 294307419,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924791
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Wenda,</p>\n<p>On 04.09.2014 14:12, Wenda Li wrote:</p>\n<blockquote>\n<p>Hi Florian,</p>\n<p>Many thanks for your clarification, it helps a lot.</p>\n<blockquote>\n<p>A pseudo constructor declared using »code_datatype« must be<br>\nsurjective.  A pseudo constructor declared using »[code abstype]« must<br>\nbe injective.</p>\n</blockquote>\n<p>Do you mean the other way around? Ratreal::\"rat =&gt; real\" in \"Real.thy\"<br>\n(declared using \"code_datatype\") is an injective but not surjective<br>\nfunction, while Frct:: \"int \\times int =&gt; rat\" (declared using \"[code<br>\nabstype]\") is a surjective but not injective function. Sorry if I have<br>\nmessed with any definitions.</p>\n</blockquote>\n<p>thanks for clarifying, I have made a slip here.</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<p>Best,<br>\nWenda</p>\n<p>On 2014-09-04 08:14, Florian Haftmann wrote:</p>\n<blockquote>\n<p>Hi Wenda,</p>\n<p>I am not sure which documentation you have read so far.  The »Tutorial<br>\non code generation« contains some explanations and examples concerning<br>\ndatatype abstraction.  There is also a substantial publication »Data<br>\nRefinement in Isabelle/HOL«.</p>\n<p>In short, it is helpful to thinkg about pseudo constructors as<br>\nmorphisms.  A pseudo constructor declared using »code_datatype« must be<br>\nsurjective.  A pseudo constructor declared using »[code abstype]« must<br>\nbe injective.</p>\n<p>Cheers,<br>\n    Florian<br>\n</p>\n</blockquote>\n<p>On 03.09.2014 21:41, Wenda Li wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear data refinement experts,</p>\n<p>I am trying to learn something about code generation. Based on what I<br>\nhave seen so far, there are two ways to introduce a pseudo constructor<br>\nfor an abstract type A:<br>\n    1) define constant f:: C =&gt; A and g::A =&gt; C, and then prove<br>\n           lemma [code abstype]: f (g x) = x<br>\n       ,and f becomes a pseudo constructor for the abstract type A<br>\n    2) define constant f:: C =&gt; A, and then declare<br>\n           code_datatype f<br>\nBased on my observations, only one of them is used at a time:<br>\n    \"Int.thy\": code_datatype \"0::int\" Pos Neg<br>\n    \"Real.thy\": code_datatype Ratreal<br>\n    \"Multiset.thy\": code_datatype multiset_of<br>\nhave adopted the second approach, while<br>\n    \"Rat.thy\": lemma [code abstype]:\"Frct (quotient_of q) = q\"<br>\n    \"Polynomial.thy\": lemma Poly_coeffs [simp, code abstype]: \"Poly<br>\n(coeffs p) = p\"<br>\nhave adopted the first approach.</p>\n<p>It seems that the \"code_datatype\" approach is more flexible than the<br>\n\"abstype\" approach, as multiple constructors can be introduced (I am not<br>\nsure if it is not case for the \"abstype\" approach) and the cardinality<br>\nof C can be smaller than that of A (e.g. Ratreal in \"Real.thy\").</p>\n<p>My question is: what is the main difference between these two<br>\napproaches? When shall I choose one over the other?</p>\n<p>Many thanks in advance,<br>\nWenda<br>\n</p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/7TDmkWhyR1nQfZf2E9kj3Ubi/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294307510,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924804
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Wenda and Florian,</p>\n<p>Just my 50 cents: pseudo-constructors with code_datatype can be neither injective nor <br>\nsurjective. List.set and List.coset are examples of this case.</p>\n<p>Andreas</p>",
        "id": 294307537,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924809
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>this time I strongly hope that I am more awake than when I wrote the<br>\nother two mails ;-).</p>\n<p>It's indeed not about surjective vs. injective, but about surjective vs.<br>\ntotal.</p>\n<p>Have C :: s =&gt; t</p>\n<p>If C is a total function, then it is suitable for code_datatype.<br>\nIf C is surjective (but not necessarily total), then it is suitable for<br>\n[code abstype].</p>\n<p>Note that in the sense of HOL each function is total.  »C is partial«<br>\nhere means that in generated code C will only be applied to certain<br>\nvalues of s (»abstract datatype«).</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/74j7WU6WAqLjlkV91t3FbIFm/signature.asc\">signature.asc</a></p>",
        "id": 294307617,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924829
    }
]