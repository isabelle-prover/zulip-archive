[
    {
        "content": "<p>From: Giuliano Losa &lt;<a href=\"mailto:giuliano@losa.fr\">giuliano@losa.fr</a>&gt;<br>\nHello,<br>\nI would like to use AFP/Collections, monadic refinement, and autoref to<br>\ngenerate code that computes the sum of all values in a map, as follows:</p>\n<p>theory Scratch<br>\n  imports Main \"$AFP/Collections/Refine_Dflt\"<br>\nbegin</p>\n<p>definition test_spec :: \"(nat ⇀ nat) ⇒ nat nres\"<br>\n  where \"test_spec m ≡ SPEC (λ n . n = (∑ x ∈ (dom m) . the (m x)))\"</p>\n<p>definition test :: \"(nat ⇀ nat) ⇒ nat nres\"<br>\n  where \"test m ≡ FOREACH (dom m) (λ x r . RETURN (the (m x)+r)) 0\"</p>\n<p>lemma test_correct:<br>\n  assumes \"finite (dom m)\" shows \"test m ≤ test_spec m\"<br>\n  using assms unfolding test_def test_spec_def<br>\n  apply -<br>\n  apply (refine_vcg FOREACH_rule[where I=\"λit r . r = (∑ x ∈ (dom m -<br>\nit) . the (m x))\"])<br>\n    apply (auto simp add:it_step_insert_iff)<br>\n  done</p>\n<p>schematic_goal test_impl:<br>\n  assumes [autoref_rules]: \"(r,m)∈⟨nat_rel,nat_rel⟩dflt_rm_rel\"<br>\n  shows \"(RETURN ?c, test m) ∈ ⟨nat_rel⟩nres_rel\"<br>\n  unfolding test_def<br>\n  apply (autoref_monadic(trace)) (* phase id_op fails *)<br>\n  oops<br>\nend</p>\n<p>I did not find any map-interface operation that corresponds to dom,<br>\nwhich probably explains why id_op fails. But, I do not see how to make<br>\nit work otherwise. Can anybody suggest how I could do this (I am using<br>\nIsabelle2016-1-RC2 and afp-devel)? Is iterating over a map with FOREACH<br>\nnot supported by autoref?</p>\n<p>Thanks,<br>\nGiuliano<br>\n<a href=\"/user_uploads/14278/DOerXunCt4lBY73JgKxi_4ux/signature.asc\">signature.asc</a></p>",
        "id": 294700735,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179090
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi Giuliano,</p>\n<p>you can iterate over the set of key-value pairs of a map, using<br>\nmap_to_set. Find your modified example below.</p>\n<p>Best,<br>\n  Peter</p>\n<p>definition test_spec :: \"(nat ⇀ nat) ⇒ nat nres\"<br>\n  where \"test_spec m ≡ SPEC (λ n . n = (∑ x ∈ (dom m) . the (m x)))\"</p>\n<p>definition test :: \"(nat ⇀ nat) ⇒ nat nres\"<br>\n  where \"test m ≡ FOREACH (map_to_set m) (λ (k,v) r . RETURN (v+r)) 0\"</p>\n<p>lemma test_correct:<br>\n  assumes \"finite (dom m)\" shows \"test m ≤ test_spec m\"<br>\n  using assms unfolding test_def test_spec_def<br>\n  apply -<br>\n  apply (refine_vcg FOREACH_rule[where <br>\n          I=\"λit r . r = (∑ (k,v) ∈ (map_to_set m - it) . v)\"])<br>\n  apply (auto simp add:it_step_insert_iff finite_map_to_set)<br>\n  apply (rule sum.reindex_cong[where l=\"λk. (k,the (m k))\"])<br>\n  apply (auto simp: map_to_set_def)<br>\n  done</p>\n<p>schematic_goal test_impl:<br>\n  assumes [autoref_rules]: \"(r,m)∈⟨nat_rel,nat_rel⟩dflt_rm_rel\"<br>\n  shows \"(RETURN ?c, test m) ∈ ⟨nat_rel⟩nres_rel\"<br>\n  unfolding test_def<br>\n  (<em>supply [[autoref_trace_failed_id]]  (</em>enable id-op tracing*) *)<br>\n  apply (autoref_monadic(trace)) (* phase id_op fails *)<br>\n  done<br>\nend</p>",
        "id": 294700752,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661179098
    }
]