[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello,</p>\n<p>I have the following class definition:</p>\n<p>class well_founded_transitive = ord +<br>\n   assumes order_trans1: \"x &lt; y ==&gt; y &lt; z ==&gt;  y &lt; z\"<br>\n   and less_eq_def: \"x &lt;= y =( x = y \\/ x &lt; y)\"<br>\n   and less_induct1 [case_names less]: \"(!!x . (!!y . y &lt; x ==&gt; y) ==&gt; <br>\nx) ==&gt; a\"<br>\nbegin<br>\ndefinition<br>\n   \"Sup_less P w = SUPR {v . v &lt; w} P\";<br>\nend</p>\n<p>and I have the following definition</p>\n<p>definition<br>\n   \"Sup_less2 pair X (u::'a::well_founded_transitive) i = SUPR {v . pair <br>\nv i &lt; u} (% v . X v i)\";</p>\n<p>However, what I am interested in is something like:</p>\n<p>definition<br>\n   \"Sup_less2 X u i = SUPR {v . (v, i) &lt; u} (% v . X v i)\";</p>\n<p>However, with the second definition I get the error message:</p>\n<p>*** Type unification failed: No type arity * :: ord<br>\n*** Type error in application: Incompatible operand type</p>\n<hr>\n<p>*** Operator:  op &lt; :: ??'a × ??'b =&gt; ??'a × ??'b =&gt; bool<br>\n*** Operand:   (v, i) :: ??'a × ??'b</p>\n<hr>\n<p>*** At command \"definition\".</p>\n<p>Is there a way to achieve the second kind of definition for Sup_less2?<br>\nI need the order to be over pairs, however, I must have an un-instantiated<br>\norder relation.</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294102882,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834319
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nThe problem is that Isabelle doesn't know what you mean by \"(v, i) &lt;<br>\nu\", since the comparison operators have not been defined for pairs.<br>\n(That's what \"No type arity * :: ord\" is supposed to tell you.)</p>\n<p>There are two ways to solve this problem:</p>\n<ol>\n<li>Define the less-than operator for pairs, by giving an instance of<br>\nthe ord class:</li>\n</ol>\n<p>instantiation \"*\" :: (ord, ord) ord<br>\nbegin<br>\ndefinition \"a &lt; b = fst a &lt; fst b | (fst a = fst b &amp; snd a &lt; snd b)\"<br>\ninstance ..<br>\nend</p>\n<p>The above definition is the lexicographic ordering, but other<br>\ndefinitions are certainly possible. You could also define less-than<br>\npointwise:</p>\n<p>instantiation \"*\" :: (ord, ord) ord<br>\nbegin<br>\ndefinition \"a &lt; b = fst a &lt; fst b &amp; snd a &lt; snd b\"<br>\ninstance ..<br>\nend</p>\n<p>The drawback is that once you give a type class instance, you are<br>\nstuck with it: You must use the same definition of less-than for pairs<br>\nthroughout the remainder of your theory.</p>\n<ol start=\"2\">\n<li>Instead of writing \"(v, i) &lt; u\" in your definition, unfold whatever<br>\ndefinition of less-than on pairs that you mean. For example, if you<br>\nwant the lexicographic ordering, you could define Sup_less2 like this:</li>\n</ol>\n<p>definition<br>\n \"Sup_less2 X u i = SUPR {v . v &lt; fst u | (v = fst u &amp; i &lt; snd u)} (%<br>\nv . X v i)\";</p>\n<p>On the other hand, if you want a point-wise less-than ordering, you<br>\nwould use this definition:</p>\n<p>definition<br>\n \"Sup_less2 X u i = SUPR {v . v &lt; fst u &amp; i &lt; snd u} (% v . X v i)\";</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294102940,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834325
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Brian,</p>\n<p>Thank you for your answer. Unfortunately both of the approaches<br>\nyou suggested require defining the order in terms of possible orders on<br>\nthe components, and this is something I don't want. I need to<br>\nhave an un-interpreted order on pairs, and later I need to<br>\ninstantiate it differently for different examples. The first definition<br>\nI used</p>\n<p>Sup_less2 pair X u i = SUPR {v . pair v i &lt; u} (% v . X v i)</p>\n<p>could give me what I need. In examples I can instantiate both<br>\nthe order and the function pair. However this approach,<br>\nusing classes, does not bring any advantage because<br>\neverything becomes simpler if I use directly the order as a<br>\nparameter:</p>\n<p>Sup_less2 lesspairs X u i = SUPR {v . lesspairs (v, i) u} (% v . X v i)</p>\n<p>I have also tried to have the function pair defined by the class,<br>\nbut then it was not possible to be of the type:<br>\npair:: 'b * 'c =&gt; 'a.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294102965,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834331
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Viorel,</p>\n<p>something like</p>\n<p>class pair_ord =<br>\n  fixes pair_less_eq :: \"'a * 'b =&gt; 'a * 'b =&gt; bool\"<br>\n  assumes ...</p>\n<p>is indeed beyond the rather restricted Isabelle polymorphism.</p>\n<p>Perhaps a possible solution is to formulate this order as locale and<br>\ndevelope your specfication relative to this:</p>\n<p>locale pair_ord =<br>\n  fixes pair_less_eq :: \"'a * 'b =&gt; 'a * 'b =&gt; bool\"<br>\n  assumes ...<br>\nbegin</p>\n<p>definition ...</p>\n<p>lemma ...</p>\n<p>primrec ...</p>\n<p>...</p>\n<p>end</p>\n<p>This could then be interpreted on different pair order predicates:</p>\n<p>definition pair_less_eq_nat_int :: \"nat * int =&gt; nat * int =&gt; bool\"<br>\nwhere ...</p>\n<p>definition pair_less_eq_list_unit :: 'a list * unit =&gt; 'a list * unit =&gt;<br>\nbool\" where ...</p>\n<p>interpretation pair_ord_nat_int: pair_ord pair_less_eq_nat_int ...</p>\n<p>interpretation pair_ord_list_unit: pair_ord pair_less_eq_list_unit ...</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/ctgN-HydU-oJIDym2Tog9viU/signature.asc\">signature.asc</a></p>",
        "id": 294102989,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834338
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Florian,</p>\n<p>Thank you for your answer. In my development I need the order<br>\non 'a types as well as on  pairs 'a * 'b, and I have a general<br>\nresult using a order on 'a which is instantiated later to a order on pairs.</p>\n<p>I think that I have finally reached a conclusion which is flexible enough,<br>\nand also sound.</p>\n<p>I will define the class of well founded and transitive relations</p>\n<p>class well_founded_transitive = ord +<br>\n  assumes order_trans1: \"x &lt; y /\\ y &lt; z ==&gt; x &lt; z\"<br>\n  ...<br>\n  begin...end</p>\n<p>I will also declare an uninterpreted constant</p>\n<p>consts<br>\n  pair:: \"'a =&gt; 'b =&gt; 'c::well_founded_transitive\"</p>\n<p>and I will prove all results based on these facts</p>\n<p>Later for concrete examples I instantiate both the<br>\nclass for pairs, as well as I define the pair<br>\nusing an axiom:</p>\n<p>instantiation \"*\":: (well_founded_transitive, well_founded_transitive) <br>\nwell_founded_transitive<br>\nbegin ...end</p>\n<p>axioms pair_def: \"pair a b = (a, b)\";</p>\n<p>I have tested this approach and it seems to work. I also<br>\nthink that I am not introducing inconsistencies, because<br>\nI only introduce this axiom once after I instantiate<br>\nthe class for pairs.</p>\n<p>Viorel</p>\n<p>Florian Haftmann wrote:</p>",
        "id": 294103290,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834436
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Viorel,</p>\n<p>Yes, since your axiom is nothing else than a definition -- a copy of<br>\nPair :: 'a =&gt; 'b =&gt; 'a * 'b, essentially.  In that case you should use<br>\nthe \"overloading\" target (see §5.7. of the Isabelle reference manual).</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/SElbqhUqidEICLaN9hR42uuu/signature.asc\">signature.asc</a></p>",
        "id": 294103395,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834467
    }
]