[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nHi all.</p>\n<p>We have some theory A, that defines, among others, the functions:<br>\n  foldl, foldr, insert</p>\n<p>Inside A, and inside theories extending A, these names make perfectly <br>\nsense, and we do not want to change them to, say, \"A_foldl\".</p>\n<p>However, some theories based on A are now to be used a bigger context, <br>\nwhere the details of A (including foldl, etc.) are no longer important.<br>\nNevertheless, the constants remain defined and overwrite the standard <br>\nconstants from List.thy and Set.thy, which is embarrassing.</p>\n<p>What's the right solution to this problem?<br>\nI know the hide_const (open) construct, however, its annoying to <br>\nexplicitly having to list all constants of the theory again (and perhaps <br>\nforgetting one).<br>\nMoreover, if the constants are hidden \"too early\", its impossible to use <br>\nthem by unqualified names in theories extending A.</p>\n<p>Alternatively, I thought of defining a locale:<br>\n  locale A_loc begin<br>\n     definition foldl, foldr, insert, ...<br>\n  end<br>\n  interpretation A: A_loc .</p>\n<p>And proving extensions to A inside the locale.<br>\nThe interpretation is required for code generation, as the code generator<br>\nseems not to generate code for \"A_loc.foldl\", etc.</p>\n<p>Am I on the right track? Is there a simpler solution?</p>\n<p>Best,<br>\n  Peter</p>",
        "id": 294115443,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838159
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Peter,</p>\n<blockquote>\n<p>However, some theories based on A are now to be used a bigger context, <br>\nwhere the details of A (including foldl, etc.) are no longer important.<br>\nNevertheless, the constants remain defined and overwrite the standard <br>\nconstants from List.thy and Set.thy, which is embarrassing.<br>\nThis sounds like the theory A and some of its descendents form some kind of <br>\nmodule, so I would suggest to set up a theory file of its own which specifies <br>\nthe canonical entry point. Inside this \"interface\" theory, you can hide all <br>\n\"internal\" constants as with hide_const (open). If you want to access the <br>\nconstants unqualified, you just have to do this in a theory whose imports bypass <br>\nthe interface theory. However, this does not solve the problem of having to <br>\nexplicitly hide every internal constant.</p>\n</blockquote>\n<blockquote>\n<p>Alternatively, I thought of defining a locale:<br>\n locale A_loc begin<br>\n    definition foldl, foldr, insert, ...<br>\n end<br>\n interpretation A: A_loc .</p>\n<p>And proving extensions to A inside the locale.<br>\nThe interpretation is required for code generation, as the code generator<br>\nseems not to generate code for \"A_loc.foldl\", etc.<br>\nNote that the interpretation is executed only once, i.e. if you later add <br>\ndefinitions/code equations to locale A, they will not be carried through the <br>\ninterpretation automatically. And, AFAIK, there is no way to force a <br>\nre-interpretation of A. If you want to go that way, I recommend that you do your <br>\ncode generator setup manually by declaring all necessary equations OUTSIDE the <br>\nlocale context as [code].</p>\n</blockquote>\n<blockquote>\n<p>Am I on the right track? Is there a simpler solution?<br>\nIf the constant that gets hidden is not visible at the point where the other <br>\nconstant of the same name is defined, you could exploit the order of theory <br>\nmerges. But this can make your developments very fragile and possibly hard to <br>\nmaintain. Here is an example:</p>\n</blockquote>\n<p>theory Foo imports Plain begin<br>\ndefinition foldl :: \"nat\" where \"foldl = 0\"<br>\nend</p>\n<p>theory Bar imports Main Foo begin<br>\n-- \"foldl now refers to Foo.foldl\"<br>\nend</p>\n<p>theory Bar2 imports Foo Main begin<br>\n-- \"foldl now refers to List.foldl\"<br>\nend</p>\n<p>Another option is to abuse notation, which also allows to unhide the constant again:</p>\n<p>theory Foo imports Main begin<br>\ndefinition foldl :: \"nat\" where \"foldl = 0\"</p>\n<p>notation List.foldl (\"foldl\")<br>\nterm \"foldl\" -- \"List.foldl\"</p>\n<p>no_notation List.fold (\"foldl\")<br>\nterm \"foldl\" -- \"Foo.foldl\"<br>\nend</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294115501,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838165
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFor tricks like this I recommend using 'abbreviation' instead, since it <br>\ndoes not spoil the token table of the syntax with literal \"foldl\" etc.</p>\n<p>More hardcore manipulations can be done with name space aliases in <br>\nIsabelle2009-2, e.g. like this:</p>\n<p>setup {* Sign.const_alias @{binding fold} @{const_name List.foldr} *}<br>\n   hide_const List.foldr</p>\n<p>term fold<br>\n   term foldr  -- \"free variable\"</p>\n<p>Workarounds with aliases are not much worse than 'hide_const' etc. Of <br>\ncourse, we are all waiting for proper name space management at the level <br>\nof theory \"modules\", \"packages\", whatever.  After a few more rounds of <br>\n\"localization\" of old packages we are getting closer and closer to that.</p>\n<p>Makarius</p>",
        "id": 294115522,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838171
    }
]