[
    {
        "content": "<p>From: \"Eugene W. Stark\" &lt;<a href=\"mailto:isabelle-users@starkeffect.com\">isabelle-users@starkeffect.com</a>&gt;<br>\nI attempted to do as shown below (also see attached).<br>\nI tried to follow the \"Tutorial on Functions\" to prove something<br>\nabout the mutually recursive definition, but I am thwarted by:</p>\n<p>proof (prove)<br>\n  goal (1 subgoal):</p>\n<p>1. (⋀b. P a b ⟹ Q a b) &amp;&amp;&amp; (R a ⟹ S a)<br>\n  Ill-typed instantiation:<br>\n    a :: 'b</p>\n<p>Can some kind soul explain what is happening here?  Thanks.</p>\n<p>BTW, I deleted a few irrelevant clauses from the \"term\" datatype for the purposes<br>\nof this example and the processing time for the \"fun\" definition dropped<br>\nfrom about 9 minutes for the original to less than 20 seconds on the excerpt<br>\nshown here.</p>\n<p>- Gene Stark</p>\n<p>theory Barf<br>\nimports Main<br>\nbegin</p>\n<p>datatype (discs_sels) 't \"term\" =<br>\n      Prim 't<br>\n    | Unit<br>\n    | Tensor \"'t term * 't term\"<br>\n    | Comp \"'t term * 't term\"<br>\n    | Lunit \"'t term\"<br>\n    | Runit \"'t term\"<br>\n    | Assoc \"'t term * 't term * 't term\"</p>\n<p>fun normalize :: \"'t term ⇒ 't term\"<br>\n    where \"normalize t = t\"</p>\n<p>fun redTensor<br>\n    and red<br>\n    where \"redTensor (Unit, Unit) = Lunit Unit\"<br>\n        | \"redTensor (Prim f, Unit) = Runit (Prim f)\"<br>\n        | \"redTensor (Tensor (a, b), Unit) = Comp (redTensor (a, b), Runit (Tensor (a, b)))\"<br>\n        | \"redTensor (Unit, a) = Lunit a\"<br>\n        | \"redTensor (Prim f, a) = Tensor (Prim f, a)\"<br>\n        | \"redTensor (Tensor (a, b), c) =<br>\n              Comp (redTensor (a, normalize (Tensor (b, c))), Tensor (a, redTensor (b, c)))\"<br>\n        | \"redTensor (a, b) = Tensor (a, b)\"</p>\n<p>| \"red Unit = Unit\"<br>\n        | \"red (Prim f) = Prim f\"<br>\n        | \"red (Tensor (a, Unit)) = Comp (red a, Runit a)\"<br>\n        | \"red (Tensor (Unit, a)) = Comp (red a, Lunit a)\"<br>\n        | \"red (Tensor (Prim f, a)) = Tensor (Prim f, red a)\"<br>\n        | \"red (Tensor (Tensor (a, b), c)) =<br>\n             Comp (redTensor (red a, redTensor (red b, red c)), Assoc (a, b, c))\"<br>\n        | \"red a = a\"</p>\n<p>lemma<br>\n    shows \"⋀b. P a b ⟹ Q a b\"<br>\n    and \"R a ⟹ S a\"<br>\n    proof (induct a and a rule: redTensor_red.induct)<br>\n      show ?thesis<br>\n      sorry<br>\n    qed</p>\n<p>end<br>\n<a href=\"/user_uploads/14278/_DupCBgYAhN1xLtlySQh6N37/Barf.thy\">Barf.thy</a></p>",
        "id": 294704896,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180352
    },
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear Gene,</p>\n<p>there is a problem with the types of your expressions.</p>\n<p>From the function definition you have <br>\n  redTensor :: 'a term * ‘a term =&gt; 'a term<br>\n  red :: 'a term =&gt; 'a term</p>\n<p>Consequently the induction rule for redTensor/red expects two arguments a and b<br>\nso that the type of a and b are an instance of 'a term * ‘a term and ‘a term. </p>\n<p>In particular this means that </p>\n<p>(induct a and a rule: redTensor_red.induct)</p>\n<p>must fail, because term term “a\" cannot be an instance of 'a term * ‘a term and ‘a term<br>\nfor the same instance of “‘a”.  </p>\n<p>Moreover, in your example you do not restrict “a” to be of type “‘a term” at all:<br>\nyour “a” is of arbitrary type “‘a”. </p>\n<p>The following invocation applies the induction rule, </p>\n<p>lemma fixes a :: \"'a term × 'a term\" and b :: \"'a term\" <br>\n    shows \"⋀c. P a c ⟹ Q a c\"<br>\n    and \"R b ⟹ S b\"<br>\n    proof (induct a and b rule: redTensor_red.induct)</p>\n<p>Hope this helps,<br>\nRené</p>",
        "id": 294704914,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180357
    }
]