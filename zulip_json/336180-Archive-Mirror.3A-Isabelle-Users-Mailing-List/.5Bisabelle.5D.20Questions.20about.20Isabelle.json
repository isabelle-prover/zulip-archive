[
    {
        "content": "<p>From: Tambet &lt;<a href=\"mailto:qtvali@gmail.com\">qtvali@gmail.com</a>&gt;<br>\nSorry for reposting, but I had a few errors (whole day played with Isabelle,<br>\nnow a bit blurry). This is the same message with errors fixed (hope that<br>\nmoderator catches the previous one).</p>\n<p>Hello!</p>\n<p>I would like to ask a few questions about Isabelle, because in a day of<br>\nreading manuals and testing things, I have some questions needed to do<br>\nanything at all left unanswered.</p>\n<p>I did, in previous few days, study about Coq, but found out that Isabelle<br>\nlanguage use is much more intuitive to me and it has some tools built-in,<br>\nwhich Coq lacks.</p>\n<p>However, now I have a number of problems:</p>\n<p>- Loading built-in libraries is extremely slow. Is there any kind of<br>\n   caching, compilation or preloading technique to make it faster?</p>\n<p>- Built-in heuristics tool does not solve things and I think that this is<br>\n   related to some bias in my understanding of semantics, because things are<br>\n   really trivial.</p>\n<p>- Search of patterns is extremely slow - is Isabelle meant only for<br>\n   supercomputers and clusters?</p>\n<p>Next thing that I quite much do not understand the Class semantics. I am<br>\nused to programming languages, mostly imperative, but with many plays with<br>\nothers, but it's a first try I try to use prover. I am actually completely<br>\nlost with that.</p>\n<p>I give concrete examples about what I want to do to get on track:</p>\n<p>I want to prove several things about Collatz sequences. For that, I tried<br>\n(taking fibonaccy series and primes theories as examples) to just formulate<br>\na class, which contains all positive naturals. I did write fixes clause with<br>\n'a =&gt; bool and definition that it's over zero. After that I tried to prove<br>\nwith heuristics, that even integers of that class are bigger than one - this<br>\nfailed. I tried to unfold the definition from class, but wasn't able to do<br>\nthat. Now I think that maybe this class does not provide me that check at<br>\nall? It's basically copy of similar class from primes with definitions for<br>\nnaturals removed as I thought that maybe it does not have enough rules for<br>\nnaturals.</p>\n<p>Also, as I'm not even conscious about what exactly to ask, is this possible<br>\nto just give me random important hints about good strategies and common<br>\nbiases related to proving similar things:</p>\n<p>I would like to define the following properties to numbers:</p>\n<p>Collatz itself, is this OK:</p>\n<p>fun<br>\n  collatzNext :: \"int \\&lt;Rightarrow&gt; int\"<br>\nwhere<br>\n  \"collatzNext n =<br>\n   (if (n \\&lt;in&gt; even) then (n div (2::int)) else<br>\n   (if (n \\&lt;in&gt; odd) then ((3::int) * n) + (1::int) else<br>\n   1))\"</p>\n<p>I am somewhat worried about this last else clause - it should not be \"1\",<br>\nbut undefined. Such output is not possible as I'm considering only the<br>\ntypical version of Collatz with naturals. I would like to do in one step:<br>\ncreate class that collatz(i) or smth. is positive natural so that I could<br>\nuse it in definitions (instead of writing everywhere the clause &gt;0) and<br>\nprove that thus, it's output is also positive natural (I imagine that this<br>\nproof will be automatically asked from me when defining such function?) I<br>\nwasn't able to prove this trivial thing - actually I wasn't able to even<br>\nprove that things belonging to my class of positive naturals are always<br>\nbigger than zero. Thus, maybe the class was totally wrong? I haven't done<br>\nclasses with Haskell, I am only tried Haskell for a few days as my<br>\ngirlfriend learns it (sometimes) and I do not want to take the fun away by<br>\nknowing better. Anyway, I am now stuck with Isabelle classes - or do I need<br>\na class at all?</p>\n<p>Second, I would like to define such things:<br>\n\"follows a b\" for a comes after b in series.<br>\n\"nextto a b\" for b is right after a.<br>\nI would better like to use something like a \\&lt;before&gt; b and a \\&lt;rightbefore&gt;<br>\nb.</p>\n<p>I would like to have everything after a available as sequence for this class<br>\nof rules:<br>\nhead (collatzSequence a) \\&lt;in&gt; even.<br>\nfirst (collatzSequence a) \\&lt;in&gt; even. - how to argument about concrete<br>\nposition, for example that third element is first even element and thus,<br>\nsecond element is last odd element in this series?</p>\n<p>I would also like to (check and) prove the following lemmas:</p>\n<p>I am playing with Coq and Isabelle now :) Formalizing the following:</p>\n<p>fun p(a) = if (p(a) % 2 = 0) then (p(a div 2)) else (a).<br>\nThe greatest divisor of a, which is power of two = p(a).</p>\n<p>I want to show that the number of multiplication-addition series always<br>\nequals p(a+1) and gives odd result for odd, even result for even and follows<br>\nthe formula (((3/2)*<em>(p(a+1)))</em>a+1)-1.<br>\nThis should be trivial by binary analysis - how to use that and mix with<br>\nother parts?</p>\n<p>I want to show that because of this even-odd differentiation, 3n+1 series is<br>\nnever called more than twice in a row. This follows from upper.</p>\n<p>I want to show that for any even number, all following even numbers will<br>\nhave p(n) &gt;= a(n) and that when looked from the position of n/2, that will<br>\ncome back to even if n/2 it started with was odd and vice versa, because<br>\ndiv2 can't possibly change oddity of any upper level.</p>\n<p>Thus, starting from even it leads to odd (next number) and starting from odd<br>\nit leads to even (smaller number). Modulus is built in such way that p(n)<br>\nfor each even number is p(n)+1 related to it's division by two and this p(n)<br>\nis how many times it will be divided by two, thus p(n) for any following<br>\neven is big enough to lead to smaller number (n/2+1 for next one, as numbers<br>\ngrow, also this p(n) grows and thus, even leads to following(n)&lt;=n+1).</p>\n<p>I want, thus, to show that the sequence always eventually leads to smaller<br>\nnumber than it started from or 1.</p>\n<p>Which classes and other stuff I should use for all that?</p>\n<p>Tambet</p>\n<p>Brute-force (python) check for those lemmas follows:</p>\n<h1>-<em>- coding: utf-8 -</em>-</h1>\n<p>def iterCollatz(number, included=False):<br>\n  if number == 0:<br>\n    return<br>\n  if included:<br>\n    yield number<br>\n  while number != 4:<br>\n    while number % 2 == 0:<br>\n      number /= 2<br>\n      yield number<br>\n    number *= 3<br>\n    number += 1<br>\n    if number != 4:<br>\n      yield number<br>\n    else:<br>\n      return</p>\n<p>def pow(number, p):<br>\n  # For integers<br>\n  if p == 0:<br>\n    return 1<br>\n  r = 1<br>\n  for a in range(0,p):<br>\n    r *= number<br>\n  return r</p>\n<p>def maxp2(number):<br>\n  # Count the zeros at end of number<br>\n  a = number<br>\n  p = 0<br>\n  while a % 2 == 0 and a &gt; 1:<br>\n    a /= 2<br>\n    p += 1<br>\n  return p</p>\n<p>def nextp2(number):<br>\n  b = 1<br>\n  while b &lt; number:<br>\n    b *= 2<br>\n  return b</p>\n<p>def simulate(number):<br>\n  times = maxp2(number+1)<br>\n  result = pow(3, times) * (number + 1) / pow(2, times) - 1<br>\n  # print \"Guess: \" + str(result)<br>\n  for b in iterCollatz(number):<br>\n    if b == result:<br>\n      # print \"Guess correct\"<br>\n      return<br>\n  print \"Guess wrong\"</p>\n<p>def pattern(start, length, highlight=-1):<br>\n  s = \"\"<br>\n  for a in range(start, start+length):<br>\n    if a &lt; 0:<br>\n      n = \"-\"<br>\n    elif maxp2(a) == 0:<br>\n      n = \"o\"<br>\n    elif maxp2(a) &gt; 9:<br>\n      n = \"+\"<br>\n    else:<br>\n      n = \"%1d\" % maxp2(a)<br>\n    if a == highlight:<br>\n      n = \"*%s\" % n<br>\n    elif highlight != -1:<br>\n      n = \" %s\" % n<br>\n    s += n<br>\n  return s</p>\n<p>def patternDiff(start, start2, length, highlight=-1):<br>\n  s = \"\"<br>\n  for a in range(0, length):<br>\n    d = maxp2(a+start) - maxp2(a+start2)<br>\n    if a+start &lt; 0 or a+start2 &lt; 0:<br>\n      n = \"-\"<br>\n    if d == 0:<br>\n      n = \"o\"<br>\n    if d == -1:<br>\n      n = \"A\"<br>\n    if d == -2:<br>\n      n = \"B\"<br>\n    if d == -3:<br>\n      n = \"C\"<br>\n    elif d &lt; 0:<br>\n      n = \"!\"<br>\n    elif d &gt; 9:<br>\n      n = \"+\"<br>\n    else:<br>\n      n = \"%1d\" % (maxp2(a+start) - maxp2(a+start2))<br>\n    if a+start == highlight:<br>\n      n = \"*%s\" % n<br>\n    elif highlight != -1:<br>\n      n = \" %s\" % n<br>\n    s += n<br>\n  return s</p>\n<p>def patternShiftSeq(start, length, count):<br>\n  print \"Init: %8d %s\" % (start, pattern(start, length))<br>\n  for i in range(0, count):<br>\n    print \"Diff: %8d %s %d\" % (start + length*i, patternDiff(start +<br>\nlength*i, start, length), start)<br>\n    print \"Self: %8d %s\" % (start + length<em>i, pattern(start + length</em>i,<br>\nlength))</p>\n<p>def patternMulSeq(number, length, count):<br>\n  print \"Init: %8d %s\" % (number, pattern(number, length))<br>\n  for i in range(0, count):<br>\n    print \"Diff: %8d %s %d\" % (number * pow(2, i), patternDiff(number *\npow(2, i), number, length), number)<br>\n    print \"Self: %8d %s\" % (number * pow(2, i), pattern(number * pow(2, i),<br>\nlength))</p>\n<p>def patternMul3Seq(start, length, count, shift, difp=-1):<br>\n  if shift % 2 == 0:<br>\n    print \"Error: there is no 3n for even value\"<br>\n  for i in range(1 + shift, count * length + shift, length):<br>\n    print \"Diff: %8d %s %d\" % (((start + i)*3+1)/2, patternDiff(((start +<br>\ni)*3+1)/2, start + i, length), start + i)<br>\n    print \"Prev: %8d %s\" % (start + i, pattern(start, length))<br>\n    if difp != -1:<br>\n      print \"Dif+: %8d %s %d\" % (((start + i)*3+1)/2, patternDiff(((start +<br>\ni)*3+1)/2, start + difp, length), start + difp)<br>\n      print \"Pre+: %8d %s\" % (start + difp, pattern(start + difp, length))<br>\n    print \"Next: %8d %s\" % (((start + i)*3+1)/2, pattern(((start +<br>\ni)*3+1)/2, length))</p>\n<p>def collatzPattern(number):<br>\n  for b in iterCollatz(number):<br>\n    print \"%4d %s\" % (b, pattern(b-25, 25, b))</p>\n<p>def Series(a):<br>\n  s = \"\"<br>\n  d = []<br>\n  while a != 1:<br>\n    a = a + 1<br>\n    p = 0<br>\n    while a % 2 == 0:<br>\n      #s += \" \"<br>\n      d += [1]<br>\n      a = a / 2<br>\n      p += 1<br>\n    s += str(p)<br>\n  return s</p>\n<p>def Collatz1(a):<br>\n  t = 0<br>\n  b = a / pow(2, maxp2(a))<br>\n  c = a / pow(2, maxp2(a))<br>\n  for a in iterCollatz(a):<br>\n    if a % 2 == 1:<br>\n      if t == 0:<br>\n        c = a<br>\n      if t &gt; 1 and b % 2 == 0:<br>\n        print \"Error\"<br>\n      if t &gt; 1 and c+1 &lt; a == 0:<br>\n        c = a<br>\n      if t &gt; 1 and b &lt; a:<br>\n        print \"Error\"<br>\n      #print t, b &gt; a<br>\n      #print \"%10d %30s\" % (a, Series(a)), b<br>\n      t = 0<br>\n      b = a<br>\n    else:<br>\n      t += 1</p>\n<p>for a in range(1, 100000):<br>\n  Collatz1(a)</p>",
        "id": 294112364,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837245
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI took a quick look at your problem and attach a small theory file, in which I define your collatzNext function and prove a trivial property of it. To undertake the project you describe, you just have to do one step at a time, and your first step should be to read the tutorial: <a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle/doc/tutorial.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle/doc/tutorial.pdf</a></p>\n<p>It will take a while before you can become proficient enough to do a challenging project.<br>\nLarry Paulson</p>\n<p>theory Collatz<br>\nimports Parity<br>\nbegin</p>\n<p>definition<br>\n collatzNext :: \"nat \\&lt;Rightarrow&gt; nat\"<br>\nwhere<br>\n \"collatzNext n = (if even n then (n div 2) else 3*n + 1)\"</p>\n<p>lemma \"0&lt;n \\&lt;Longrightarrow&gt; 0 &lt; collatzNext n\"<br>\napply (auto simp add: collatzNext_def)<br>\napply (metis Suc_n_div_2_gt_zero lemma_even_div2)<br>\ndone</p>",
        "id": 294112390,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837251
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIf you do not need negative numbers, I suggest to use nat instead of int.</p>\n<p>Tobias</p>\n<p>Tambet schrieb:</p>",
        "id": 294112407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837257
    }
]