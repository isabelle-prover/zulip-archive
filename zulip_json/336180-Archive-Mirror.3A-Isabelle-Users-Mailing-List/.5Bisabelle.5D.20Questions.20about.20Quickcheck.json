[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>I am wondering about the following things w.r.t. Quickcheck:</p>\n<p>– What is the real difference between exhaustive and full_exhaustive? <br>\nThere are a sentence or two on this in isar-ref about term <br>\nreconstruction, but it's not quite clear to me what that actually means.</p>\n<p>– Why does quickcheck not fall back to random testing when exhaustive <br>\ntesting is not available?</p>\n<p>– Why is Quickcheck for multisets only set up for random and <br>\nfull_exhaustive, but not for exhaustive?</p>\n<p>– Is there any reason not to simply replace the entire Quickcheck setup <br>\nfor multisets with \"quickcheck_generator multiset construtors: mset\"? (I <br>\nhave done that locally and it seems to work well)</p>\n<p>Manuel</p>",
        "id": 294673682,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174199
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<blockquote>\n<p>– What is the real difference between exhaustive and full_exhaustive? There are a sentence<br>\nor two on this in isar-ref about term reconstruction, but it's not quite clear to me what<br>\nthat actually means.</p>\n</blockquote>\n<p>AFAIK exchaustive and full_exhaustive are two different compilation schemes, but I don't know<br>\nthe details. You can switch between the two schemes with the option quickcheck_full_support.<br>\nSince this option is enabled by default, the exhaustive tester is essentially untested.<br>\nMost types in the library do not have any setup for exhaustive any more (in particular all <br>\nthe datatypes, it seems).</p>\n<blockquote>\n<p>– Is there any reason not to simply replace the entire Quickcheck setup for multisets with<br>\n\"quickcheck_generator multiset construtors: mset\"? (I have done that locally and it seems<br>\nto work well)<br>\nAFAICS, you get essentially the same testers.</p>\n</blockquote>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294673723,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174211
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:lukas.bulwahn@gmail.com\">lukas.bulwahn@gmail.com</a>&gt;<br>\nDear Manuel,</p>\n<p>since I am subscribed the isabelle users' mailing list for a couple of<br>\ndays now, I can tell you some of the rationales for the design<br>\ndecisions in quickcheck.</p>\n<p>Three years ago, I did some profiling of quickcheck's execution and<br>\nobserved that much time was actually spent constructing and<br>\ndeconstructing the term representations for printing no matter if<br>\ncounterexamples were found or not. For fair comparison between<br>\ndifferent testing approaches that all are based on the same code<br>\ngeneration setup and are quasi-complete, in the sense, if there is a<br>\ncounterexample, it will eventually be found (assuming the<br>\ncounterexample can be represented as ground term with the given code<br>\ngeneration setup), the testing performance is essential. The overall<br>\ntesting performance would render one approach superior or inferior to<br>\nanother one.</p>\n<p>Exhaustive generators are more performant than full-exhaustive, but do<br>\nnot allow to print terms when functions are involved.<br>\nFull_exhaustive generator are less performant but can always print the<br>\nterms, and hence, are generally more useful.</p>\n<p>I was always hoping that a lifting and transfer mechanism would allow<br>\nto transfer the function space of whole theory developments into the<br>\nAndreas' FinFuns function space and make this automatic transferred<br>\ncode setup usable for quickcheck. This would make the fast exhaustive<br>\ngenerators as powerful as the full_exhaustive ones, but (I believe)<br>\nthis development has not happened yet.</p>\n<p>In practice (thanks to much work on the IDE, non-blocking interaction<br>\nand use of multiple cores), quickcheck is powerful and useful even if<br>\nit is not the slightly optimized version yet.</p>\n<p>Commonly, the manual and automatic setup for random and exhaustive<br>\ntesting is done in one go. So both strategies would usually work and<br>\nstart searching for counterexamples or both would fail, as they rely<br>\non the same code generation setup. So then to find counterexamples<br>\nquickly, applying one strategy after the other seems awkward, and I<br>\npreferred to implement that multiple strategies can be applied in<br>\nparallel. As back in 2012, we still had a blocking IDE in wider use,<br>\nthe blocking auto-quickcheck was limited to only one strategy; I<br>\ndecided for exhaustive testing.</p>\n<p>Without further investigation of the past, I cannot tell you the<br>\nreason for the definition of the current Multiset quickcheck setup.<br>\nPossibly, during some work on the new datatype package or on code<br>\ngeneration of multisets, some one touched the quickcheck setup, but<br>\nwas not aware of the quickcheck_generator command---but that's just a<br>\nwild guess from my side; one would really need to look at the relevant<br>\nchangesets and their context. The multiset theory has quite some<br>\nevolution since I looked deeply into that file.</p>\n<p>I hope that helps.</p>\n<p>Best regards,</p>\n<p>Lukas</p>",
        "id": 294675593,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174845
    }
]