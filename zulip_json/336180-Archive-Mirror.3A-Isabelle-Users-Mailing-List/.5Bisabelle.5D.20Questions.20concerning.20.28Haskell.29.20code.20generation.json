[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi René,</p>\n<blockquote>\n<p>1.) It is in someway possible to make the generated code have an<br>\nexplicit export list? So something like</p>\n<p>export_code bla foo [export] in Haskell module_name Code file -</p>\n<p>that results in the following module definition</p>\n<p>module Code (bla, foo) where ...?</p>\n<p>The reason is, that w/o an explicit export list the compiler assumes<br>\nthat all functions are exported and therefore does not inline them or<br>\nuses other code optimizations (see [1]).</p>\n</blockquote>\n<p>this is an interesting observation.  Up until now, I did not pay much<br>\nattention to export lists, in order to keep things as simple as<br>\npossible.  So far I did not consider inlining issues.  There are<br>\nimportant enough to reconsider hiding and exporting anew.  Anyway,<br>\nanalysis and implementation will take considerable time.</p>\n<blockquote>\n<p>2.) I noted that when using \"Efficient_Nat\", I got two new types for<br>\nnatural numbers in code: Natural and Nat. The code of both looks nearly<br>\nidentical (see attached files) and also only one of them (Nat) is used<br>\nthroughout the rest of the code. Is there a deeper reason behind having<br>\nthem both?</p>\n</blockquote>\n<p>Consider type classes: there is only one instantiation of a type per<br>\nclass;  this prohibits to map two different types in the logic onto the<br>\nsame type in Haskell.  This affects all languages with implicit<br>\ndictionaries, i.e. also Scala, but not SML/Ocaml.</p>\n<p>Cheers,<br>\n    Florian</p>",
        "id": 294148714,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848494
    },
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:lists@necoro.eu\">lists@necoro.eu</a>&gt;<br>\nAm 12.12.2011 13:03, schrieb Florian Haftmann:</p>\n<blockquote>\n<p>Hi René,</p>\n<blockquote>\n<p>1.) It is in someway possible to make the generated code have an<br>\nexplicit export list? So something like</p>\n<p>export_code bla foo [export] in Haskell module_name Code file -</p>\n<p>that results in the following module definition</p>\n<p>module Code (bla, foo) where ...?</p>\n<p>The reason is, that w/o an explicit export list the compiler assumes<br>\nthat all functions are exported and therefore does not inline them or<br>\nuses other code optimizations (see [1]).</p>\n</blockquote>\n<p>this is an interesting observation.  Up until now, I did not pay much<br>\nattention to export lists, in order to keep things as simple as<br>\npossible.  So far I did not consider inlining issues.  There are<br>\nimportant enough to reconsider hiding and exporting anew.  Anyway,<br>\nanalysis and implementation will take considerable time.</p>\n</blockquote>\n<p>This sounds like you plan on adding some sort of automated generation of<br>\nexport lists. Would be as hard to implement some additional syntax that<br>\ngives the user the choice of specifying the export list that is going to<br>\nbe generated (I don't know though whether this concept is useful for the<br>\nother languages...)? Just to avoid having to edit auto-generated files.</p>\n<blockquote>\n<blockquote>\n<p>2.) I noted that when using \"Efficient_Nat\", I got two new types for<br>\nnatural numbers in code: Natural and Nat. The code of both looks nearly<br>\nidentical (see attached files) and also only one of them (Nat) is used<br>\nthroughout the rest of the code. Is there a deeper reason behind having<br>\nthem both?</p>\n</blockquote>\n<p>Consider type classes: there is only one instantiation of a type per<br>\nclass;  this prohibits to map two different types in the logic onto the<br>\nsame type in Haskell.  This affects all languages with implicit<br>\ndictionaries, i.e. also Scala, but not SML/Ocaml.</p>\n</blockquote>\n<p>Thanks for the explanation.</p>\n<ul>\n<li>René</li>\n</ul>",
        "id": 294148732,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848500
    },
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:lists@necoro.eu\">lists@necoro.eu</a>&gt;<br>\nHi,</p>\n<p>I have two questions regarding the Haskell-code generation in Isabelle<br>\n2011-1:</p>\n<p>1.) It is in someway possible to make the generated code have an<br>\nexplicit export list? So something like</p>\n<p>export_code bla foo [export] in Haskell module_name Code file -</p>\n<p>that results in the following module definition</p>\n<p>module Code (bla, foo) where ...?</p>\n<p>The reason is, that w/o an explicit export list the compiler assumes<br>\nthat all functions are exported and therefore does not inline them or<br>\nuses other code optimizations (see [1]). For my test-case this makes<br>\nindeed a huge difference:</p>\n<p>without export list:</p>\n<hr>\n<p>benchmarking fully 200<br>\ncollecting 100 samples, 1 iterations each, in estimated 33.55970 s<br>\nmean: 337.4847 ms, lb 336.8887 ms, ub 338.2864 ms, ci 0.950<br>\nstd dev: 3.518088 ms, lb 2.850222 ms, ub 5.044390 ms, ci 0.950</p>\n<p>with export list:</p>\n<hr>\n<p>benchmarking fully 200<br>\ncollecting 100 samples, 1 iterations each, in estimated 30.92251 s<br>\nmean: 103.9187 us, lb 99.45309 us, ub 119.4683 us, ci 0.950<br>\nstd dev: 37.75363 us, lb 11.42921 us, ub 84.93836 us, ci 0.950</p>\n<p>Note the difference of 300ms vs. 0.1ms.</p>\n<p>2.) I noted that when using \"Efficient_Nat\", I got two new types for<br>\nnatural numbers in code: Natural and Nat. The code of both looks nearly<br>\nidentical (see attached files) and also only one of them (Nat) is used<br>\nthroughout the rest of the code. Is there a deeper reason behind having<br>\nthem both? Or is it the result of some refactoring and forgetting to<br>\nremove the old version?</p>\n<p>Thanks :)<br>\nRené<br>\n<a href=\"/user_uploads/14278/RplFfHePVI0zIR_RHzxpKyCp/Nat.hs\">Nat.hs</a><br>\n<a href=\"/user_uploads/14278/jXTmkwv6TwphL9q_YFK0Z1BR/Natural.hs\">Natural.hs</a></p>",
        "id": 294149615,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848810
    }
]