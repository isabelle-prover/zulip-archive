[
    {
        "content": "<p>From: Alessandro Coglio &lt;<a href=\"mailto:coglio@kestrel.edu\">coglio@kestrel.edu</a>&gt;<br>\nHello,</p>\n<p>Since a (non-empty) finite lattice is also complete, I would like to define</p>\n<p>class finite_lattice = finite + lattice</p>\n<p>and then prove</p>\n<p>instance finite_lattice &lt; complete_lattice</p>\n<p>after giving suitable definitions for Inf/Sup/bot/top.</p>\n<p>But apparently</p>\n<p>instance A &lt; B</p>\n<p>requires A to have (at definition time) all the operators of B. Are <br>\nthere \"deep\" reasons for this requirement, or could it be relaxed with <br>\nrelative ease to allow the extra operators to be defined after A has <br>\nbeen defined and then used to show that A is a subclass of B?</p>\n<p>Anyhow, given the current situation, one approach is to define <br>\nfinite_lattice as above, define Inf/Sup/bot/top on finite_lattice, and <br>\nprove that finite_lattice is a sublocale of complete_lattice. In this <br>\nway, after proving that a type L has class finite_lattice, all the <br>\noperators and theorems of complete_lattice should be available for L. <br>\nThe drawback of this approach is that L will not have class <br>\ncomplete_lattice, and so, for example, existing operations that take <br>\ncomplete_lattice arguments cannot be used on L.</p>\n<p>Another approach is to define class finite_lattice to include <br>\nInf/Sup/bot/top, along with assumptions that define these four operators <br>\nin terms of the existing operators of finite_lattice. In this way, <br>\nfinite_lattice can be a subclass of complete_lattice. The drawback is <br>\nthat proving that a type L has class finite_lattice will require more <br>\nwork because of the extra operators and assumptions that must be <br>\nsatisfied (but perhaps this work can be eased by proving and using <br>\ngeneral lemmas that relate Inf/Sup/bot/top to inf and sup). Furthermore, <br>\nthe approach seems (to me) methodologically less clean than the previous <br>\none.</p>\n<p>A third approach is to define</p>\n<p>class finite_lattice = finite + complete_lattice</p>\n<p>and avoid proving subclass relations altogether. The drawback is that <br>\nproving that a type L has class finite_lattice is even more work (but <br>\nagain perhaps this work can be eased by suitable general lemmas). This <br>\nseems to be the approach taken in the library definition of class <br>\ncomplete_lattice, which includes bounded_lattice explicitly, even though <br>\nInf and Sup suffice. Also, this approach seems (to me) methodologically <br>\nless clean than the previous two.</p>\n<p>Does anybody have comments on the three approaches sketched above? <br>\nRelative pros and cons? Other approaches?</p>\n<p>Thank you in advance!<br>\n<a href=\"/user_uploads/14278/4wxGjRx5xtfIzGlVpythKRVK/smime.p7s\">smime.p7s</a></p>",
        "id": 294227589,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900766
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Alessandro,</p>\n<blockquote>\n<p>Since a (non-empty) finite lattice is also complete, I would like to<br>\ndefine</p>\n<p>class finite_lattice = finite + lattice</p>\n<p>and then prove</p>\n<p>instance finite_lattice &lt; complete_lattice</p>\n<p>after giving suitable definitions for Inf/Sup/bot/top.</p>\n<p>But apparently</p>\n<p>instance A &lt; B</p>\n<p>requires A to have (at definition time) all the operators of B. Are<br>\nthere \"deep\" reasons for this requirement, or could it be relaxed with<br>\nrelative ease to allow the extra operators to be defined after A has<br>\nbeen defined and then used to show that A is a subclass of B?</p>\n</blockquote>\n<p>this is a well-known restriction of type classes.  The short answer is,<br>\nno, this restriction cannot be lifted.  This is the price you have to<br>\npay to have operations <em>and</em> assumptions about them: in order for a<br>\nstructure to be a complete lattice, it is not necessary that there exist<br>\noperations which satisfy its properties, but these operations must be<br>\nexplicitly defined for that particular type.</p>\n<blockquote>\n<p>Anyhow, given the current situation, one approach is to define<br>\nfinite_lattice as above, define Inf/Sup/bot/top on finite_lattice</p>\n</blockquote>\n<p>Such definitions would be rejected, since they violate the rules for<br>\noverloading: Inf/Sup/bot/top can only be instantiated on particular type<br>\nconstructors, not (sort-constrained) type variables.</p>\n<blockquote>\n<p>Another approach is to define class finite_lattice to include<br>\nInf/Sup/bot/top, along with assumptions that define these four operators<br>\nin terms of the existing operators of finite_lattice. In this way,<br>\nfinite_lattice can be a subclass of complete_lattice. The drawback is<br>\nthat proving that a type L has class finite_lattice will require more<br>\nwork because of the extra operators and assumptions that must be<br>\nsatisfied (but perhaps this work can be eased by proving and using<br>\ngeneral lemmas that relate Inf/Sup/bot/top to inf and sup). Furthermore,<br>\nthe approach seems (to me) methodologically less clean than the previous<br>\none.</p>\n</blockquote>\n<p>IMHO it is the cleanest one you can achieve inside the current<br>\ninfrastructure.  E.g.</p>\n<blockquote>\n<p>lemma finite_complete_lattice:<br>\n  assumes Inf: \"\\&lt;And&gt;A. (Inf :: ('a::{Inf, Sup, bounded_lattice, finite}) set ⇒ 'a) A =<br>\n    (if A = {} then top else Inf_fin A)\"<br>\n  assumes Sup: \"\\&lt;And&gt;A. (Sup :: ('a::{Inf, Sup, bounded_lattice, finite}) set ⇒ 'a) A =<br>\n    (if A = {} then top else Sup_fin A)\"<br>\n  shows \"OFCLASS('a::{Inf, Sup, bounded_lattice, finite}, complete_lattice_class)\"<br>\nproof</p>\n</blockquote>\n<blockquote>\n<p>A third approach is to define</p>\n<p>class finite_lattice = finite + complete_lattice</p>\n<p>and avoid proving subclass relations altogether. The drawback is that<br>\nproving that a type L has class finite_lattice is even more work (but<br>\nagain perhaps this work can be eased by suitable general lemmas).</p>\n</blockquote>\n<p>This does indeed save you nothing on instance proofs.</p>\n<blockquote>\n<p>This<br>\nseems to be the approach taken in the library definition of class<br>\ncomplete_lattice, which includes bounded_lattice explicitly, even though<br>\nInf and Sup suffice. Also, this approach seems (to me) methodologically<br>\nless clean than the previous two.</p>\n</blockquote>\n<p>The issue is that class bot already demands assumptions on bot and thus<br>\nyou cannot instantiate bot without actually proving these.</p>\n<p>There have been two ideas around to lift this somehow:</p>\n<ul>\n<li>\n<p>Provide purely syntactic classes for operations without further<br>\nassumptions; this has a long tradition in isabelle (cf. plus, times,<br>\nzero etc.), but has the disadvantage that you can write down things<br>\nsyntactically which do not obey properties you would expect naively<br>\n(i.e. \"a + 0 = a\" does not hold in general).</p>\n</li>\n<li>\n<p>Build a fancy wrapper around instantiation in the spirit of Haskell<br>\ndefault class method definitions.  Since this must also cover proofs, it<br>\nwould be a tedious affair and maybe not worth doing it.</p>\n</li>\n</ul>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/EwAZli8poIkfV-XQm7sCSKu_/signature.asc\">signature.asc</a></p>",
        "id": 294227830,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900885
    }
]