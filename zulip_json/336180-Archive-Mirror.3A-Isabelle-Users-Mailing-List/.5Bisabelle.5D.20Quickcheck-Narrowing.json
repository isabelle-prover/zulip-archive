[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Peter,</p>\n<p>You can still install custom narrowing generators for types by using the functions that <br>\nare only hidden openly. I've added narrowing generators for the Coinductive entry, but I <br>\nam unable to push. I repeat them here such that you can take some inspiration from them:</p>\n<p>instantiation llist :: (narrowing) narrowing begin<br>\nfunction narrowing_llist where<br>\n   \"narrowing_llist n = Quickcheck_Narrowing.sum<br>\n     (Quickcheck_Narrowing.cons LNil)<br>\n     (Quickcheck_Narrowing.apply (Quickcheck_Narrowing.apply<br>\n       (Quickcheck_Narrowing.cons LCons) narrowing) narrowing_llist)<br>\n     n\"<br>\nby pat_completeness simp<br>\ntermination by(relation \"measure nat_of_integer\")(simp_all, transfer, simp)</p>\n<p>instance ..<br>\nend</p>\n<p>Regarding Native_Word, it is important to think about the generation strategy. The <br>\nnarrowing engine calls the generators whenever it encounters an variable in a goal in <br>\norder to refine it. For datatypes, the generator returns a list of refined terms such as <br>\nthe constructors of the datatype. The generator for ints, however, just returns the <br>\nnumbers around 0. A first attempt for words could be to produce the first few values of <br>\nthe word, but I would expect better results if it also generates larger word values. In <br>\nprinciple, one can consider a word as a list of bits of fixed length and have the <br>\ngenerator behave similarly to the one for list.</p>\n<p>Since Native_Word has a custom serialisation, you also have to provide the partial_term_of <br>\ninstantiation. I have not yet figured out how it interacts with the generators but it <br>\nlooks as if they must work together. Lukas should know more.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294267792,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916164
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Peter,</p>\n<p>Here are a few more thoughts on this. Refinement works for datatypes, because the <br>\nfunctions on them are defined by pattern-matching. That is, when a variable is refined to <br>\nthe list of possible constructors, evaluation can continue and might even report a <br>\ndefinitive value without examining the data structure any further. Since Native_Word maps <br>\nthe word types to atomic types in the target language, and operations to built-in <br>\noperations which are usually strict, we cannot exploit incremental refinements here, <br>\nbecause we cannot symbolically represent such words. Therefore, it is probably best to <br>\njust enumerate values, maybe in some clever way. Narrowing in Quickcheck adapts <br>\nLazySmallCheck from Haskell (<a href=\"http://hackage.haskell.org/package/lazysmallcheck\">http://hackage.haskell.org/package/lazysmallcheck</a>), so I had <br>\na look there. Its generators for the primitive Haskell types also just enumerates some values.</p>\n<p>Andreas</p>",
        "id": 294267882,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916189
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi List.</p>\n<p>Is there a way to extend quickcheck-narrowing for your own types,<br>\nfor example the native-word types from the Native_Word library.</p>\n<p>In attempting so, I had trouble to even define the instantiation, as all<br>\nthe required types and constants are hidden with a hide_XXX command at<br>\nthe end of Quickcheck_Narrowing.thy. The proof obligation reads like</p>\n<p>instantiation<br>\nuint32 :: narrowing<br>\nnarrowing_uint32 == narrowing ::<br>\n  integer \\&lt;Rightarrow&gt; uint32 ??.Quickcheck_Narrowing.narrowing_cons</p>\n<p>But I cannot see the type \"??.Quickcheck_Narrowing.narrowing_cons\" any<br>\nmore.</p>",
        "id": 294270624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917090
    }
]