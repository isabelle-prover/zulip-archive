[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear list,</p>\n<p>is there any reason why there's no Quickcheck setup for finite sets? I<br>\ncouldn't find any, so I tried setting it up (see attached theory). I'm<br>\nhardly a Quickcheck expert, so I have no idea whether it makes sense –<br>\nat least it works for some cases I tried.</p>\n<p>Slightly related question: How does the interaction between the datatype<br>\npackage and Quickcheck work? It appears that it produces instances of<br>\nfull_exhaustive in certain cases and not in others, but I'm not quite<br>\nsure in which cases. (Current working hypothesis: It doesn't when nested<br>\nrecursion is involved.) Is there any other way to conveniently obtain<br>\nfull_exhaustive instances?</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/WB7ke7PdwmKi2uPuo9qxLewV/FSet_Quickcheck.thy\">FSet_Quickcheck.thy</a></p>",
        "id": 294649003,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165335
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>quickcheck in its current form was mainly developed by Lukas Bulwahn, who left academia <br>\nbefore fset became usable. So far, nobody cared to add the quickcheck setup. From my <br>\nexperience with quickcheck, your setup is fine. However, you could also just have used the <br>\ncommand</p>\n<p>quickcheck_generator fset constructors: \"{||}\", finsert</p>\n<p>which generates almost the same instances as you did manually. The difference is that the <br>\nyour instances check whether an new element is already present in the set and if so, they <br>\nskip the execution assuming that it has been tested before. This is just an optimisation <br>\nwhich avoids to run the code on equivalent test case several times, but I doubt that this <br>\nredundancy causes any problems in practice.</p>\n<p>According to the documentation in isar-ref, quickcheck installs random and exhaustive <br>\ngenerators for first-order datatypes. I do not know whether the documentation has been <br>\nkept up to date during the transition to the BNF package, but it looks as if it is still <br>\ncorrect. So no nested recursion.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294649284,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165432
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>However, you could also just have used the command</p>\n<p>quickcheck_generator fset constructors: \"{||}\", finsert</p>\n<p>which generates almost the same instances as you did manually.</p>\n</blockquote>\n<p>first of all, I didn't know about that command :-)</p>\n<p>Anyway, the way I implemented the generator for 'fset's was to copy the<br>\ngenerator for 'set's and changed the constants (e.g. 'insert' → 'finsert').</p>\n<p>If nobody objects, I would add these instances to the 'FSet' theory in<br>\nHOL-Library.</p>\n<blockquote>\n<p>According to the documentation in isar-ref, quickcheck installs random<br>\nand exhaustive generators for first-order datatypes. I do not know<br>\nwhether the documentation has been kept up to date during the transition<br>\nto the BNF package, but it looks as if it is still correct. So no nested<br>\nrecursion.</p>\n</blockquote>\n<p>Maybe this is a candidate for consolidation with the 'Derive' AFP entry.<br>\n(On the other hand, as far as I know, that one doesn't support nested<br>\nrecursion through non-datatypes.)</p>\n<p>Because you mentioned it in your mail, I also tried<br>\n'quickcheck_generator' on my datatype, but it (silently!) fails to<br>\nproduce instances.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294649302,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165438
    }
]