[
    {
        "content": "<p>From: Filip Marić &lt;<a href=\"mailto:filipmatfbgacrs@gmail.com\">filipmatfbgacrs@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I am using the quotient package in Isabelle 2013 and I get an error<br>\nwhen I try to use the descending method and the type real is involved<br>\nin the quotient_definition. Here is a (simlified) example.</p>\n<p>(* Homogeneous coordinates in the complex plane *)<br>\nfun homo_coords_eq :: \"complex \\&lt;times&gt; complex \\&lt;Rightarrow&gt; complex<br>\n\\&lt;times&gt; complex \\&lt;Rightarrow&gt; bool\" where<br>\n  \"homo_coords_eq (z1, z2) (w1, w2) \\&lt;longleftrightarrow&gt; (\\&lt;exists&gt;<br>\nk::complex. k \\&lt;noteq&gt; 0 \\&lt;and&gt; w1 = k * z1 \\&lt;and&gt; w2 = k * z2)\"</p>\n<p>quotient_type<br>\n  complex_homo_coords = \"complex \\&lt;times&gt; complex\" / homo_coords_eq<br>\nproof (rule equivpI)<br>\n  show \"reflp homo_coords_eq\" unfolding reflp_def by (auto, rule_tac<br>\nx=1 in exI, simp)<br>\nnext<br>\n  show \"symp homo_coords_eq\" unfolding symp_def by (auto, rule_tac<br>\nx=\"1/k\" in exI, simp)<br>\nnext<br>\n  show \"transp homo_coords_eq\" unfolding transp_def by (auto, rule_tac<br>\nx=\"k*ka\" in exI, simp)<br>\nqed</p>\n<p>(* Zero *)<br>\ndefinition zero_rep :: \"complex \\&lt;times&gt; complex\"  where \"zero_rep = (0, 1)\"<br>\nquotient_definition zero where \"zero :: complex_homo_coords\" is zero_rep<br>\ndone</p>\n<p>(* Coercion of complex number - everything is OK *)<br>\ndefinition of_complex_rep :: \"complex \\&lt;Rightarrow&gt; complex \\&lt;times&gt;<br>\ncomplex\" where \"of_complex_rep x = (x, 1)\"<br>\nquotient_definition of_complex where \"of_complex :: complex<br>\n\\&lt;Rightarrow&gt; complex_homo_coords\" is of_complex_rep<br>\ndone</p>\n<p>lemma \"of_complex 0 = zero\"<br>\nby (descending) (auto simp add: zero_rep_def of_complex_rep_def)</p>\n<p>(* Coercion of real number - descending raises an error *)<br>\ndefinition of_real_rep :: \"real \\&lt;Rightarrow&gt; complex \\&lt;times&gt;<br>\ncomplex\" where \"of_real_rep x = (complex_of_real x, 1)\"<br>\nquotient_definition of_real where \"of_real :: real \\&lt;Rightarrow&gt;<br>\ncomplex_homo_coords\" is of_real_rep<br>\ndone</p>\n<p>lemma \"of_real 0 = zero\"<br>\napply (descending)</p>\n<p>*** [regularize (constant mismatch)<br>\n*** tmp.of_real::(nat \\&lt;Rightarrow&gt; (nat \\&lt;times&gt; nat) \\&lt;times&gt; nat<br>\n\\&lt;times&gt; nat) \\&lt;Rightarrow&gt; complex \\&lt;times&gt; complex<br>\n*** tmp.of_real::real \\&lt;Rightarrow&gt; complex_homo_coords]<br>\n*** The quotient theorem<br>\n*** tmp.of_real 0 = zero</p>\n<hr>\n<p>*** does not match with original theorem<br>\n*** homo_coords_eq (tmp.of_real 0) zero_rep<br>\n*** At command \"apply\" (line 40 of \"/home/filip/Dropbox/moebius/tmp.thy\")</p>\n<p>The same behavior occurs with every quotient definition where the type<br>\nreal is involved - it seems that instead of real the system expects<br>\n(nat \\&lt;Rightarrow&gt; (nat \\&lt;times&gt; nat) \\&lt;times&gt; nat \\&lt;times&gt; nat) - I<br>\nsuppose that is because real type itself is defined as a quotient? Is<br>\nthere a way to make the given example work and to use the type real in<br>\nquotient definitions as any other type?</p>\n<p>Thank you!<br>\nFilip</p>",
        "id": 294255423,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912416
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nHello Filip,</p>\n<p>I cannot say anything about the descending method, but your example <br>\nworks fine with Lifting and Transfer in Isabelle 2013 (see below). And <br>\nsince there are plans to eventually remove the Quotient package <br>\n(<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2013-March/msg00026.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2013-March/msg00026.html</a>), <br>\nI would recommend to use these more recent tools.</p>\n<p>Dmitriy</p>\n<p>(* Homogeneous coordinates in the complex plane *)<br>\nfun homo_coords_eq :: \"complex × complex ⇒ complex<br>\n× complex ⇒ bool\" where<br>\n\"homo_coords_eq (z1, z2) (w1, w2) ⟷ (∃<br>\nk::complex. k ≠ 0 ∧ w1 = k * z1 ∧ w2 = k * z2)\"</p>\n<p>quotient_type<br>\ncomplex_homo_coords = \"complex × complex\" / homo_coords_eq<br>\nproof (rule equivpI)<br>\nshow \"reflp homo_coords_eq\" unfolding reflp_def by (auto, rule_tac<br>\nx=1 in exI, simp)<br>\nnext<br>\nshow \"symp homo_coords_eq\" unfolding symp_def by (auto, rule_tac<br>\nx=\"1/k\" in exI, simp)<br>\nnext<br>\nshow \"transp homo_coords_eq\" unfolding transp_def by (auto, rule_tac<br>\nx=\"k*ka\" in exI, simp)<br>\nqed</p>\n<p>(* Zero *)<br>\ndefinition zero_rep :: \"complex × complex\" where \"zero_rep = (0, 1)\"<br>\nlift_definition zero :: \"complex_homo_coords\" is zero_rep<br>\nunfolding zero_rep_def by simp</p>\n<p>definition of_complex_rep :: \"complex ⇒ complex × complex\" where <br>\n\"of_complex_rep x = (x, 1)\"<br>\nlift_definition of_complex :: \"complex ⇒ complex_homo_coords\" is <br>\nof_complex_rep<br>\nunfolding of_complex_rep_def by simp</p>\n<p>lemma \"of_complex 0 = zero\"<br>\nby transfer (auto simp add: zero_rep_def of_complex_rep_def)</p>\n<p>definition of_real_rep :: \"real ⇒ complex ×<br>\ncomplex\" where \"of_real_rep x = (complex_of_real x, 1)\"<br>\nlift_definition of_real :: \"real ⇒ complex_homo_coords\" is of_real_rep<br>\nunfolding of_real_rep_def by simp</p>\n<p>lemma \"of_real 0 = zero\"<br>\nby transfer (auto simp add: zero_rep_def of_real_rep_def)</p>",
        "id": 294255438,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912422
    },
    {
        "content": "<p>From: Filip Marić &lt;<a href=\"mailto:filipmatfbgacrs@gmail.com\">filipmatfbgacrs@gmail.com</a>&gt;<br>\nDmitriy,</p>\n<p>I have successfully migrated my formalization - it was quite easy to<br>\ndo, and everything works fine now. Thank you very much for your<br>\nadvice!</p>\n<p>Filip!</p>",
        "id": 294255479,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912440
    }
]