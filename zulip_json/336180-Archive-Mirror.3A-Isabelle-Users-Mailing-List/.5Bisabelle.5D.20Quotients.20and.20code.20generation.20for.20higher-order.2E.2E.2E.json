[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I am currently stuck at setting up code generation for a quotient type. To that end, I <br>\nhave declared an embedding from the raw type to the quotient type as pseudo-constructor <br>\nwith code_datatype and am now trying to prove equations that pattern-match on the <br>\npseudo-constructor. There are no canonical representatives in my raw type, so I cannot <br>\ndefine an executable function from the quotient type to the raw type.</p>\n<p>I am stuck at lifting functions in which the quotient type occurs as the result of <br>\nhigher-order functions. The problem is that I do not know how to pattern-match on a <br>\npseudo-constructor in the result of a function. Here is an example:</p>\n<p>datatype 'a foo = Stop 'a | Go \"nat ⇒ 'a foo\"</p>\n<p>primrec bind :: \"'a foo ⇒ ('a ⇒ 'b foo) ⇒ 'b foo\" where<br>\n     \"bind (Stop x) f = f x\"<br>\n   | \"bind (Go c) f = Go (λx. bind (c x) f)\"</p>\n<p>axiomatization rel :: \"'a foo ⇒ 'a foo ⇒ bool\" where rel_eq: \"equivp rel\"<br>\n   quotient_type 'a bar = \"'a foo\" / rel by(rule rel_eq)<br>\n   code_datatype abs_bar</p>\n<p>lift_definition bind_bar :: \"'a bar ⇒ ('a ⇒ 'b bar) ⇒ 'b bar\" is bind sorry</p>\n<p>My problem is now to state and prove code equations for bind_bar. Obviously,</p>\n<p>lemma \"bind_bar (abs_bar x) f = abs_bar (bind x f)\"</p>\n<p>does not work, as bind expects f to return a foo, but f returns a bar. My next attempt is <br>\nto inline the recursion of bind. The case for Stop is easy, but I am out of ideas for Go.</p>\n<p>lemma \"bind_bar (abs_bar (Stop x)) f = f x\"<br>\n         \"bind_bar (abs_bar (Go c)) f = ???\"</p>\n<p>Is there a solution to my problem? Or am I completely on the wrong track.</p>\n<p>Thanks for any ideas,<br>\nAndreas</p>",
        "id": 294647751,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164794
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nHi Andreas,</p>\n<p>How about</p>\n<p>lemma [code]:\"bind_bar (abs_bar x) f = abs_bar (bind x (λu. rep_bar (f <br>\nu)))\" sorry</p>\n<p>Can you prove this in your theory?</p>\n<p>Best,<br>\nWenda</p>",
        "id": 294647800,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164803
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Wenda,</p>\n<p>On 24/07/15 13:05, Wenda Li wrote:</p>\n<blockquote>\n<p>lemma [code]:\"bind_bar (abs_bar x) f = abs_bar (bind x (λu. rep_bar (f u)))\" sorry</p>\n<p>Can you prove this in your theory?<br>\nOf course, this type-checks and is provable. However, I'd need a code equation for rep_bar <br>\nin the form \"rep_bar (Abs_bar x) = ...\". And for this, I'd need a notion of canonical <br>\nrepresentative in the raw type, which I don't have at the moment. It would require a lot <br>\nof work (in Isabelle) to define such a notion. Moreover, the generated code would have to <br>\ntransform everything into the normal form, which can be computationally prohibitive.</p>\n</blockquote>\n<p>Best,<br>\nAndreas</p>\n<blockquote>\n<p>On 2015-07-24 07:51, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>I am currently stuck at setting up code generation for a quotient<br>\ntype. To that end, I have declared an embedding from the raw type to<br>\nthe quotient type as pseudo-constructor with code_datatype and am now<br>\ntrying to prove equations that pattern-match on the<br>\npseudo-constructor. There are no canonical representatives in my raw<br>\ntype, so I cannot define an executable function from the quotient type<br>\nto the raw type.</p>\n<p>I am stuck at lifting functions in which the quotient type occurs as<br>\nthe result of higher-order functions. The problem is that I do not<br>\nknow how to pattern-match on a pseudo-constructor in the result of a<br>\nfunction. Here is an example:</p>\n<p>datatype 'a foo = Stop 'a | Go \"nat ⇒ 'a foo\"</p>\n<p>primrec bind :: \"'a foo ⇒ ('a ⇒ 'b foo) ⇒ 'b foo\" where<br>\n    \"bind (Stop x) f = f x\"<br>\n  | \"bind (Go c) f = Go (λx. bind (c x) f)\"</p>\n<p>axiomatization rel :: \"'a foo ⇒ 'a foo ⇒ bool\" where rel_eq: \"equivp rel\"<br>\n  quotient_type 'a bar = \"'a foo\" / rel by(rule rel_eq)<br>\n  code_datatype abs_bar</p>\n<p>lift_definition bind_bar :: \"'a bar ⇒ ('a ⇒ 'b bar) ⇒ 'b bar\" is bind sorry</p>\n<p>My problem is now to state and prove code equations for bind_bar. Obviously,</p>\n<p>lemma \"bind_bar (abs_bar x) f = abs_bar (bind x f)\"</p>\n<p>does not work, as bind expects f to return a foo, but f returns a bar.<br>\nMy next attempt is to inline the recursion of bind. The case for Stop<br>\nis easy, but I am out of ideas for Go.</p>\n<p>lemma \"bind_bar (abs_bar (Stop x)) f = f x\"<br>\n        \"bind_bar (abs_bar (Go c)) f = ???\"</p>\n<p>Is there a solution to my problem? Or am I completely on the wrong track.</p>\n<p>Thanks for any ideas,<br>\nAndreas<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294647822,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164813
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Andreas,</p>\n<p>Thanks for reminding me of the non-canonical representation, I will have <br>\na similar issue in my formalization :-) However, in my understanding, a <br>\ncanonical representation is important when using \"code abstype\"/\"code <br>\nabstract\" to restore executability (e.g. Rat.thy Polynomial.thy), while <br>\nwith \"code_datatype\" it seems that we can deal with executability in a <br>\nmore flexible way (e.g. Real.thy).</p>\n<p>In this case, if we can prove</p>\n<p>lemma [code]:\"bind_bar (abs_bar x) f = abs_bar (bind x (λu. rep_bar (f <br>\nu)))\" sorry</p>\n<p>we should be able to evaluate</p>\n<p>value \"bind_bar (abs_bar (Stop (1::nat))) (λu. abs_bar(Stop (u+2)))\"</p>\n<p>value \"bind_bar (abs_bar (Go (λx::nat. Stop (x+2)))) (λu. abs_bar(Stop <br>\n(u+2)))\"</p>\n<p>Please correct me if I am wrong at any point.</p>\n<p>Wenda</p>",
        "id": 294647834,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164819
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda,</p>\n<p>code_abstype and code abstract are normally used for types carved out as a subset of some <br>\nother type. For rat, e.g., the subset consists of all the relatively prime pairs of <br>\nintegers where the second component is positive. Although rat is constructed as a quotient <br>\nfrom pairs of integers, the code generator setup considers rat as isomorphic to the subset <br>\nof pairs described in the previous sentence, i.e., we have carved out a subset. All code <br>\nequations ensure that only such normalised pairs occur at run-time, i.e., we have <br>\ncanonical representatives. Conversely, the code equations can exploit that rational <br>\nnumbers given as arguments are always normalised.</p>\n<p>With code_datatype, you do not need canonical representatives. In fact, you cannot even <br>\nexploit them. As the code equations pattern-match on the pseudo-constructors, all elements <br>\nin the domain of the pseudo-constructor are considered valid representations. Thus, you <br>\ncannot rely in the code equation on any invariant. For pseudo-constructors, the challenge <br>\nlies in defining the functions on the abstract type such that the desired code equation is <br>\nprovable.</p>\n<blockquote>\n<p>lemma [code]:\"bind_bar (abs_bar x) f = abs_bar (bind x (λu. rep_bar (f u)))\" sorry</p>\n</blockquote>\n<p>If we declare code_datatype abs_bar, then we can use this lemma as a code equation. <br>\nHowever, we also must provide a code equation for rep_bar. Obviously, we would like to <br>\nhave the following equation</p>\n<p>rep_bar (abs_bar x) = x</p>\n<p>However, this equation expresses that abs_bar does not discard any information in x, i.e., <br>\nabs_bar is injective. As bar is a (non-trivial) quotient of foo, abs_bar clearly is not <br>\ninjective, as it maps every x to the equivalence class of x. In fact, we cannot define any <br>\nfunction f such that f (abs_bar x) = x. Thus, we cannot find any such unpacking function <br>\nrep_bar at all. The only reason giving me some hope in the case above is that ultimately, <br>\nwe are applying abs_bar on the right-hand side again, i.e., we are ultimately throwing <br>\naway all the extra information contained in the raw type.</p>\n<p>Best,<br>\nAndreas</p>\n<p>PS: As bar is a quotient of foo, we know that \"abs_bar (rep_bar x) = x\", but this kind of <br>\nequation is only suitable for code_abstract, which requires canonical representatives.</p>",
        "id": 294647842,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164825
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear Andreas,</p>\n<p>Many thanks for your patience and comprehensive explanations, I now do <br>\nrealize my previous mistakes. My current impression is that, given a <br>\nterm</p>\n<p>Go (λx. bind (c x) f)</p>\n<p>\"bind (c x) f\" is of type foo. If \"f\" is of type \"'a =&gt; 'b bar\", we have <br>\nto find a mapping of type \"bar =&gt; foo\" somehow and somewhere, which <br>\nleads directly to the problem you were talking about. Therefore, it <br>\nseems that the problem is really about the function \"f\" of type \"'a =&gt; <br>\n'b bar\".</p>\n<p>A workaround may be to let \"f\" be of type \"'a =&gt; 'a foo\". That is,</p>\n<p>lift_definition bind_bar :: \"'a bar ⇒ ('a ⇒ 'b foo) ⇒ 'b bar\" is bind <br>\nsorry</p>\n<p>should have it code equations directly.</p>\n<p>Let me know if there is any other solutions. I am really interested in <br>\nthis topic :-)</p>\n<p>Best,<br>\nWenda</p>",
        "id": 294647860,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164837
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda, dear experts of the code generator and lifting/transfer,</p>\n<p>I have been able to reduce my problem further. Suppose that we have an infinitely <br>\nbranching tree, say</p>\n<p>datatype 'a tree = Leaf 'a | Node \"nat =&gt; 'a tree\"</p>\n<p>and an equivalence relation rel on tree which is a congruence for Node. We take the <br>\nquotient and lift the Node constructor:</p>\n<p>quotient_type 'a qtree = 'a tree / rel<br>\n   code_datatype abs_qtree<br>\n   lift_definition NODE :: \"(nat =&gt; 'a qtree) =&gt; 'a qtree\"</p>\n<p>Now, the question is, what is a suitable code equation for NODE?</p>\n<p>I do not know an answer myself. For a finitely branching tree (say we replace \"nat\" with <br>\n\"bool\"), I could use an isomorphic first-order constructor such as Node' :: 'a tree =&gt; 'a <br>\ntree =&gt; 'a tree to derive the code equation. But for infinitely branching trees, I have <br>\nrun out of ideas.</p>\n<p>Andreas</p>",
        "id": 294647947,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164880
    }
]