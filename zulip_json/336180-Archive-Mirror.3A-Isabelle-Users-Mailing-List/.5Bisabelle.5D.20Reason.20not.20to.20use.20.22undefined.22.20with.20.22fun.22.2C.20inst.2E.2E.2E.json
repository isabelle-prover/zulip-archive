[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nDmitriy (and Andreas),</p>\n<p>On 14-09-02 01:01, Dmitriy Traytel wrote:</p>\n<blockquote>\n<p>primrec has the option nonexhaustive, which hides the warning (works <br>\nfor datatype_new only). Thus, we should add it to this declaration of <br>\nlast. Thanks for reminding us.</p>\n</blockquote>\n<p>And from your \"Re: [isabelle] selector name in datatype_new causes proof <br>\nfailure\":</p>\n<blockquote>\n<p>if no selector is specified for datatypes, there will be none <br>\ngenerated (a recent policy change)...</p>\n</blockquote>\n<p>With \"nonexhaustive\", and with being able to define selector's in the <br>\ndatatype definition, those two will get rid of most warnings that can <br>\ncome from using underspecified functions. I switched my use of a \"fun\" <br>\nto an \"abbreviation\", which doesn't warn me about \"the None\", so that <br>\ngives me another way to get rid of warnings.</p>\n<p>I kept using the query panel to try and find the \"getter\" functions for <br>\na datatype, but I didn't see anything, so your comment above was useful, <br>\nand in going to look at \"the\" again, as an underspecified function, I <br>\nsaw that it is now defined in the datatype defintion, which showed me <br>\nhow to define a getter.</p>\n<p>Andreas,</p>\n<p>On 14-09-02 01:17, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Technically, you do not change the internal construction at all if you <br>\nadd the missing cases with undefined on the right-hand side. The <br>\nfunction package does the same internally. With primrec, it is <br>\nslightly different, because primrec internally abstracts over the <br>\nother parameters and then uses undefined with a function type rather <br>\nthan the parameters. So, if you pay attention to this, you do not <br>\nchange what you can prove in Isabelle about your definitions.</p>\n</blockquote>\n<p>I don't exactly know what \"pay attention to this\" means in regards to <br>\n\"primrec\", but I guess it means if I'm having proof problems when using <br>\n\"primrec\" and \"undefined\", then I can try to see if switching to \"fun\" <br>\nhelps, since \"fun\" is doing what I'm doing\".</p>\n<blockquote>\n<p>However, from a modelling perspective, it can make a difference. </p>\n</blockquote>\n<p>Modelling and semantics learning always stays at the end of the line, <br>\nbut I worked through your example, and it reminded me how \"undefined\" is <br>\nconcrete, in regards to existence and uniqueness for a particular type.</p>\n<p>Thanks to the both of you,<br>\nGB</p>",
        "id": 294306103,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924342
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nHi,</p>\n<p>The canonical way in the HOL sources, when there's no need for a total <br>\nfunction, is to not cover all the cases, like \"last\", which is not <br>\ncovered for []:</p>\n<p>primrec last :: \"'a list =&gt; 'a\" where<br>\n     \"last (x # xs) = (if xs = [] then x else last xs)\"</p>\n<p>I've been doing that kind of thing, but it occurred to me that I could <br>\nput \"undefined\" to good use, to get rid of the warnings, like this:</p>\n<p>datatype fooD = Bar | BarC \"nat option\"</p>\n<p>fun BarC_get :: \"fooD =&gt; nat\" where<br>\n     \"BarC_get Bar = undefined\"<br>\n    |\"BarC_get (BarC None) = undefined\"<br>\n    |\"BarC_get (BarC (Some n)) = n\"</p>\n<p>Instead of like the above:</p>\n<p>fun BarC_get2 :: \"fooD =&gt; nat\" where<br>\n     \"BarC_get2 (BarC (Some n)) = n\"</p>\n<p>Is there some, good, mysterious reason why I shouldn't do this to get <br>\nrid of the warnings?</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294307721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924864
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nHi Gottfried,</p>\n<p>On 02.09.2014 05:11, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>The canonical way in the HOL sources, when there's no need for a total <br>\nfunction, is to not cover all the cases, like \"last\", which is not <br>\ncovered for []:</p>\n<p>primrec last :: \"'a list =&gt; 'a\" where<br>\n    \"last (x # xs) = (if xs = [] then x else last xs)\"<br>\nprimrec has the option nonexhaustive, which hides the warning (works for <br>\ndatatype_new only). Thus, we should add it to this declaration of last. <br>\nThanks for reminding us.</p>\n</blockquote>\n<blockquote>\n<p>I've been doing that kind of thing, but it occurred to me that I could <br>\nput \"undefined\" to good use, to get rid of the warnings, like this:</p>\n<p>datatype fooD = Bar | BarC \"nat option\"</p>\n<p>fun BarC_get :: \"fooD =&gt; nat\" where<br>\n    \"BarC_get Bar = undefined\"<br>\n   |\"BarC_get (BarC None) = undefined\"<br>\n   |\"BarC_get (BarC (Some n)) = n\"</p>\n<p>Instead of like the above:</p>\n<p>fun BarC_get2 :: \"fooD =&gt; nat\" where<br>\n    \"BarC_get2 (BarC (Some n)) = n\"</p>\n<p>Is there some, good, mysterious reason why I shouldn't do this to get <br>\nrid of the warnings?<br>\nNo, I don't know one. At first I thought that in the latter case <br>\n\"BarC_get Bar = BarC_get (BarC None)\" would not be provable, but <br>\nSledgehammer helped me out: by (metis BarC_get.elims fooD.distinct(1) <br>\nfooD.inject option.distinct(1)).</p>\n</blockquote>\n<p>However, Nitpick also reported a non-spurious counterexample (empty <br>\nassignment), so I'm cc'ing Jasmin.</p>\n<p>Dmitriy</p>",
        "id": 294308030,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924932
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gottfried,</p>\n<p>Technically, you do not change the internal construction at all if you add the missing <br>\ncases with undefined on the right-hand side. The function package does the same <br>\ninternally. With primrec, it is slightly different, because primrec internally abstracts <br>\nover the other parameters and then uses undefined with a function type rather than the <br>\nparameters. So, if you pay attention to this, you do not change what you can prove in <br>\nIsabelle about your definitions.</p>\n<p>However, from a modelling perspective, it can make a difference. Say, you write the <br>\nfollowing definition:</p>\n<p>fun nth :: \"nat =&gt; 'a list =&gt; 'a\" where<br>\n   \"nth 0 (x # xs) = x\"<br>\n| \"nth (Suc n) (x # xs) = nth n xs\"<br>\n| \"nth n [] = undefined\"</p>\n<p>Then the last equation is part of the specification that fun exports for regular usage. <br>\n From a modelling point of view, all your theorems about nth then only apply to the real <br>\nworld if whenever you access a list (think array) beyond its end, you get the same back no <br>\nmatter how far you reach beyond the end. If you want to model array access in memory, this <br>\nis clearly unrealistic. Instead, if you omit the last equation (and do not pierce the veil <br>\nof abstraction that fun provides you - but there is currently no way to express this in <br>\nIsabelle), then you don't have this assumption about nth in your model.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294308261,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925000
    }
]