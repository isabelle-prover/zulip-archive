[
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nDear Makarius Wenzel, dear Lawrence C. Paulson,<br>\ndear Members of the Research Community,</p>\n<p>Catching up with the email discussion of the last weeks, I feel the need to <br>\ncomment on some statements by Makarius Wenzel and by Lawrence C. Paulson, e.g., <br>\nWenzel's claim:</p>\n<p>\"The assumption that any of the LCF-style provers is 100% correct is<br>\nwrong -- that was never the case in last decades. If your work depends<br>\non that assumption, you need to rethink what you are doing.\"<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00075.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00075.html</a></p>\n<p>In other contributions, similar statements are made. For example, in the <br>\nGerman-language presentation at<br>\n<a href=\"https://youtu.be/R8pyFwil9KY\">https://youtu.be/R8pyFwil9KY</a><br>\nfrom minute 30:18 on Wenzel argues that John Harrison's HOL Light has a <br>\nprovably safe kernel, but is implemented in the unsafe programming <br>\nlanguage/environment OCaml, claiming more or less all that HOL implementations <br>\nare subject to logical failures in the same way.</p>\n<p>Paulson adds the \"point of view of many mathematicians, [that] reliance on <br>\ncomputers introduces too much uncertainty\" also because of hardware failure due <br>\nto physical influence (\"cosmic rays and the like\").<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00080.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00080.html</a><br>\nThis is not convincing to me, not only because the human brain is subject to <br>\nphysical influence, too, but such effects can by minimized by repeating the <br>\nproof verification, which drastically reduces the likeliness of such errors <br>\n(with exponential decay depending on the number of independent systems, I <br>\nbelieve).</p>\n<p>In general, the aim of these arguments seems highly problematic to me, as they <br>\nseem to confuse violations of the LCF approach itself with minor technical <br>\nquestions.</p>\n<p>Of course, depending on the choice of the programming language/environment, <br>\nthere may be ways to bypass restrictions guarding the LCF logical kernel. But <br>\nthese are technical implementation details. Not every logician wants to create <br>\nand implement a new language for proof verification (however, I did with the R0 <br>\nimplementation), and therefore many have to rely upon ML, Standard ML, OCaml or <br>\nother software meta-languages, including their disadvantages such as offering <br>\nthe means to freely manipulate the kernel with some hack.<br>\nBut when carrying out a proof, the author clearly knows whether he uses regular <br>\nproof commands or some hacks of the software meta-language (e.g., ML or OCaml); <br>\nmoreover, such hacks can be easily identified in the proof script.</p>\n<p>These implementation details are a completely different issue than a flaw in <br>\nthe logical kernel, as recently discovered in Isabelle/HOL.</p>\n<p>For the same reason, the reference to Hugo Herbelin's email at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00077.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-December/msg00077.html</a><br>\nis inappropriate, since he only refers to either such weaknesses that are <br>\ntechnical implementation details as described above, or weaknesses where <br>\nimprovement attempts are already in progress (and which obviously have little <br>\nto do with the formal language, i.e., the logic, itself).</p>\n<p>The inconsistency in Isabelle/HOL found by Kuncar and Popescu in<br>\n<a href=\"http://doi.org/10.1007/978-3-319-22102-1_16\">http://doi.org/10.1007/978-3-319-22102-1_16</a><br>\n<a href=\"http://andreipopescu.uk/pdf/ITP2015.pdf\">http://andreipopescu.uk/pdf/ITP2015.pdf</a><br>\nclearly is a flaw in the logical kernel, and not only a matter of some <br>\ntechnical hack (exploiting some programming language/environment).</p>\n<p>Tobias Nipkow expressed it very clearly: \"This is not a minor issue with fonts <br>\nbut concerns and endangers the very core of what we are doing.\"<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00083.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00083.html</a></p>\n<p>If you believe that other HOL systems are affected in the same way, please <br>\nprovide the reference to papers on inconsistencies in that systems.<br>\nAs of my knowledge, rather the opposite is the case, e.g.,</p>\n<ul>\n<li>\n<p>HOL Light provides some self-verification:<br>\n<a href=\"http://www.cl.cam.ac.uk/~jrh13/papers/holhol.pdf\">http://www.cl.cam.ac.uk/~jrh13/papers/holhol.pdf</a></p>\n</li>\n<li>\n<p>and HOL Zero offers a reward for finding soundness-related flaws:<br>\n<a href=\"http://www.proof-technologies.com/holzero/unsoundnesses.html\">http://www.proof-technologies.com/holzero/unsoundnesses.html</a></p>\n</li>\n</ul>\n<p>But relativizing a flaw in the logical kernel itself by classifying it into the <br>\nsame category as a hack allowed by the technical implementation more or less <br>\nends up in giving up the LCF approach as a whole.</p>\n<p>Similarly, I disagree with some statements of Lawrence C. Paulson:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00075.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00075.html</a><br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00089.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00089.html</a><br>\nI can understand that Paulson is not very happy about such an incidence, but <br>\ndenying that the flaw is an inconsistency is not helpful, since it very <br>\nobviously has the two properties of a classical paradox: self-reference <br>\n(circularity) and negativity (negation).<br>\nMoreover, the source code should be subject to scrutiny, of course, otherwise <br>\nwe cannot talk of a system conforming to the LCF approach.</p>\n<p>Basically, I agree with the replies of Popescu and Kuncar:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00096.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00096.html</a><br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00097.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00097.html</a></p>\n<p>In the same manner, I somewhat disagree with Tobias Nipkow's following <br>\nstatement from 2015 I recently stumbled across:<br>\n\"The length of this dicussion puzzles me. Typedef can introduce <br>\ninconsistencies, nobody wants this behaviour and nobody needs this behaviour. <br>\nThere is a perfectly clear way to rule out this whole class of unwanted <br>\nbehaviours: do not allow certain cycles. This solution, including code, has <br>\nbeen on the table for a year now. By now not just mere users but also <br>\ncertification agencies are worried. This is a pressing issue and it is not <br>\nrocket science.\"<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00115.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-September/msg00115.html</a></p>\n<p>My impression is, that in the Isabelle group, the attitude is only that <br>\nself-reference (circularity) is a problem, but no further analysis is made, <br>\nincluding the comparison with other systems by trying to express the same <br>\nphenomenon within the other systems, and the search for the exact reason for <br>\nthe paradox, which goes beyond just self-reference.<br>\nSelf-reference in formal logic shows that some dependency is not properly <br>\nresolved.<br>\nThe proper way to correctly resolve these dependencies in order to avoid <br>\nparadoxes is a way by means of the formal language (in the tradition of Russell <br>\nand Church).</p>\n<p>For this reason, I consider the approach by Kuncar and Popescu as a rather <br>\npreliminary solution.<br>\nAs far as I have looked at it, it seems to keep track of the dependencies in <br>\nthe background.<br>\nIt may work, but the logician's desire for naturally expressing formal logic <br>\nand mathematics would be using the means of the formal language to keep track <br>\nof the dependencies (in order to avoid paradoxes). The same critique could be <br>\napplied to the type correctness conditions (TCCs) of PVS, where correctness is <br>\nchecked only afterwards, instead of directly preventing the expression of <br>\nincorrect terms (non-well-formed formulae / non-wffs) by means of the language.<br>\nIn R0, the same problem was solved using syntactical means only: type <br>\nabstraction, i.e., the binding of type variables with lambda.</p>\n<p>In my opinion, the inconsistency in Isabelle/HOL created by axiomatic type <br>\nclasses (ad hoc overloading of constants) has three reasons:</p>\n<ol>\n<li>The LCF approach is not implemented properly.</li>\n</ol>\n<p>Clearly, in the documentation a strict distinction between the kernel and the <br>\nrest is missing, not to speak of the inner kernel and the extension. In the <br>\noriginal HOL system, the logic is a separate part (Part III: The HOL Logic <br>\n[Gordon and Melham, 1993, pp. 191â€“232]), in current HOL4 a separate file <br>\n(<a href=\"http://freefr.dl.sourceforge.net/project/hol/hol/kananaskis-10/kananaskis-10-logic.pdf\">http://freefr.dl.sourceforge.net/project/hol/hol/kananaskis-10/kananaskis-10-logic.pdf</a>). <br>\nWithin the logic, the extension is easily identifiable (e.g., online <br>\nas the section \"2.5 Extensions of theories\"). I have discussed this earlier in <br>\nOct. 2016:<br>\n\"If one takes the LCF approach of a small trusted logical kernel for serious, <br>\nthe logic has to be described in a separate and clearly identifiable part, as <br>\nthe kernel should be a verified and therefore trusted, not a blindly trusted <br>\nkernel.<br>\nFurther, the extensions are clearly marked as 'extensions' in the table of <br>\ncontents, and the use of axioms ('Asserting an axiom', section 2.5.4 Extension <br>\nby type definition) is clearly named\"<br>\n<a href=\"https://sourceforge.net/p/hol/mailman/message/35437586/\">https://sourceforge.net/p/hol/mailman/message/35437586/</a></p>\n<p>Similar as in the documentation, in the source code the distinction between the <br>\nkernel and the rest seems to be missing, as otherwise the introduction of <br>\naxiomatic type classes (ad hoc overloading of constants) could not have <br>\nhappened, as discussed in the following section.</p>\n<ol start=\"2\">\n<li>The implementation of axiomatic type classes (ad hoc overloading of <br>\nconstants) in Isabelle/HOL introduces something between a constant and a <br>\nvariable, and hence clearly is not only an extension of the logic, but a <br>\nmodification of the inner kernel itself. In line 1 of example 2 in<br>\n<a href=\"http://andreipopescu.uk/pdf/ITP2015.pdf\">http://andreipopescu.uk/pdf/ITP2015.pdf</a> (p. 2)<br>\na constant c is declared, but specified later in line 3, making it practically <br>\na variable without imposing the restrictions on variables on it.<br>\nHence the inner kernel is modified in such a way that the restrictions on <br>\nvariables can be bypassed.<br>\nIn Q0 (which doesn't have type variables), these restrictions on variables are <br>\npart of Rule R' [Andrews, 2002, p. 214].<br>\nIn R0, type variables are introduced as variables (of type tau), which means <br>\nthat the restrictions on variables of Rule R' automatically cover the case of <br>\ntype variables, preventing such a paradox as the one in Isabelle/HOL by means <br>\nof the language in the form a uniform treatment of both regular variables and <br>\ntype variables (since types are not a separate syntactic category anymore, but <br>\nterms of type tau; hence, type variable are simply variables of type tau).<br>\nIn HOL, these restrictions on type variables are represented by condition (iii) <br>\nin both</li>\n</ol>\n<ul>\n<li>2.5.1 Extension b<br>\n[message truncated]</li>\n</ul>",
        "id": 294703827,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661180054
    }
]