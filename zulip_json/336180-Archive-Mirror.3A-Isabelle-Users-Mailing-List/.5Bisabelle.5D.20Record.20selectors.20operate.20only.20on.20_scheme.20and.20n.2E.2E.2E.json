[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear experts of the record package,</p>\n<p>Last week, Jasmin and I had a long discussion about integrating the record package further <br>\nwith the free_constructors package. In the end, we found out that things are not so <br>\nsimple. The main obstacle was the somewhat non-uniform treatment of record extensions when <br>\nit comes to the different generated constants. Let me illustrate the problem with an example.</p>\n<p>record foo = foo :: nat<br>\n   record bar = foo + bar :: int</p>\n<p>The first command creates a type \"'m1 foo_ext\"<br>\nand synonyms \"'m1 foo_scheme = 'm1 foo_ext\" and \"foo = unit foo_scheme\".<br>\nThe second a type \"'m2 bar_ext\"<br>\nand synonyms \"'m2 bar_scheme == 'm2 bar_ext foo_ext\" and \"bar = unit bar_scheme\".</p>\n<p>The record notation (| ... |) gets translated to constants foo_ext and bar_ext, which <br>\nserve as free constructors for the types foo_ext and bar_ext. Thus, a value of type 'm2 <br>\nbar_scheme is composed of two nested constructors, namely bar_ext in the extension <br>\nparameter for foo_ext. If it were only for this, it would be easy to register the <br>\nconstants foo_ext and bar_ext as free constructors of the respective types.</p>\n<p>However, the free_constructor command also supports selectors and therefore, it would be <br>\ngood to register them too. Unfortunately, I have not been able to find a proper selector <br>\nfor the bar_ext type. The selector bar is generated as a constant of its own rather than <br>\nan abbreviation like</p>\n<p>bar x == <a href=\"http://bar_ext.bar\">bar_ext.bar</a> (foo.more x) (* <a href=\"http://bar_ext.bar\">bar_ext.bar</a> does not exist at the moment *)</p>\n<p>Can anyone remember why the selectors for _scheme are constants rather than abbreviations <br>\nof selectors for the _ext types?</p>\n<p>In the present form, free_constructors cannot handle compound types such as bar_scheme. So <br>\nwe cannot register bar reasonably with free_constructors.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294647432,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164677
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHey Andreas.</p>\n<p>The record package builds records out of layers of \"ext\" record<br>\nextensions, as you've understood.</p>\n<p>In the distant past, the record package defined two layers of selectors<br>\nand updators, one (mostly hidden) for each \"ext\" layer, and surface<br>\nselectors/updators which operate on the \"completed\" type. These were all<br>\nnew constant definitions - it may be relevant that this design predates<br>\nabbreviations.</p>\n<p>When I last attacked the record package, I got rid of the duplication in<br>\norder to reduce the proof times, and just kept the surface<br>\nselectors/updators.</p>\n<p>In hindsight, we could have instead kept the layer-by-layer<br>\nselectors/updators, and turned them into the final selectors/updators<br>\nwith abbreviations or other syntax tricks. I didn't think of this at the<br>\ntime. Also, I wanted to change as little of the old design as possible,<br>\nin particular I didn't want to try to understand the syntax aspects.</p>\n<p>I suspect that making this change would require a modest amount of work,<br>\nprobably a few weeks for someone who knows what they're doing. It would<br>\nalso simplify the simprocs a little - they have to think a lot about the<br>\nspecial cases for the more/\"...\" selector/updator.</p>\n<p>A final complexity you might want to think about: the reason I got<br>\ninvolved in this in the first place is that the record package <em>can</em> be<br>\nused to define some really big records (&gt; 500 fields). I don't think<br>\nthat the corresponding datatype proofs can be done in a reasonable<br>\namount of time. This is one reason why records aren't given the datatype<br>\ntreatment by default. There might be an argument for switching the<br>\ndefault here, and providing a richer theorem set by default with a<br>\n\"simple mode\" switch available for bigger records.</p>\n<p>Cheers,<br>\n     Thomas.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294647484,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164684
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHey Thomas,</p>\n<p>Thanks for the quick reply. I still wonder how a change from selectors on _scheme to <br>\nlayer-by-layer would affect efficiency. With layer-by-layer, we'd get less <br>\nselector/updator pairs, because we only need them for the fields of one record <br>\nspecification, not for the fields inherited from existing records. On the other hand, <br>\nselectors then consist of several constants and pretty-printing has to collapse the <br>\nabbreviations. In the end, it certainly depends on the depth of the record extensions. I <br>\nmyself have never exceeded depth 5, but how about at NICTA?</p>\n<p>Despite the explanation at the beginning of Record.thy, I have not yet understood how you <br>\nmanage to state and prove O(n ^ 2) theorems (for the selector-updator rules) in <br>\nO(log(n)^2) step. In the end, there are O(n ^ 2) theorems, aren't there?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294647591,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164721
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nThe \"NICTA record problem\" is with a single flat record that has a lot<br>\nof fields (~ 500 I think). I don't think we use record extensions much<br>\nat all. I've never seen a record extension more than 2 deep.</p>\n<p>The change would impact syntax performance somehow, more work, or<br>\ndifferent work. I don't understand the syntax layer at all though, so I<br>\ncan't really comment on that.</p>\n<p>There are less selector/updator pairs, but this essentially doesn't<br>\nmatter. There are in any case far too many pairs (for a record with &gt;<br>\n100 fields) to generate all the simp rules ahead of time. Anyway, only a<br>\ntiny proportion of them would be syntactically encountered. The record<br>\nsimproc proves the relevant rules each time they are needed. The proof<br>\nof each one is O (log(n)), so we don't even bother to cache them.</p>\n<p>Your suggested change would make this simproc proof process fire<br>\nmultiple times for some cases where it currently fires once, but I think<br>\nthe total amount of work would stay about the same, so I suspect the<br>\nperformance impact would be minor.</p>\n<p>Cheers,<br>\n     Thomas.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294647692,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164764
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Thomas,</p>\n<p>Thanks for the clarification, I did not know that the theorems are only generated inside <br>\nthe simproc on demand. This indeed adds some complication.</p>\n<p>For the moment, I'll wait and see what Dmitriy's new tool for lifting BNFs over typedefs <br>\nbrings and how he integrates the record selectors.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294647716,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164776
    }
]