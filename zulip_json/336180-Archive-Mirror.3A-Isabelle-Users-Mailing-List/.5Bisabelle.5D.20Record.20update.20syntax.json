[
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nHi,</p>\n<p>when using records a common theme is to just update some fields of a <br>\nrecord and leave the others at is. To this end, many functional <br>\nlanguages have a record update syntax, e.g. in OCaml you can write {bar <br>\nwith x = 1} to obtain a new record that has all the same values as bar <br>\nexcept for x. As far as I can see, Isabelle/ML currently has no such <br>\nsyntax which can lead to quite a bit of bloat. For a pathological <br>\nexample, see src/Provers/order.ML where multiple functions are declared <br>\nthat each just update one field of the record, but you still have to <br>\nexplicitly provide all the other fields. It would be nice to have this <br>\nbuild into the language. An even more flexible solution would be to <br>\nimplement this as an ML antiquotation; however, this requires the <br>\nability to introspect the type of a record to obtain a list of all the <br>\nrecord members. I am not sure if this is currently (or at all) possible.</p>\n<p>Is there any interest in having such a language construct?</p>\n<p>Lukas</p>",
        "id": 294831403,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246786
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 28/07/2020 12:39, Lukas Stevens wrote:</p>\n<blockquote>\n<p>when using records a common theme is to just update some fields of a record<br>\nand leave the others at is. To this end, many functional languages have a<br>\nrecord update syntax, e.g. in OCaml you can write {bar with x = 1} to obtain a<br>\nnew record that has all the same values as bar except for x. As far as I can<br>\nsee, Isabelle/ML currently has no such syntax which can lead to quite a bit of<br>\nbloat.</p>\n</blockquote>\n<p>The bloat is not just in the syntax, but also in the implementation: a bulky<br>\nrecord needs to be copied to change just one field.</p>\n<p>Further note that record update is not as exciting as it seems. More important<br>\nis the \"map\" combinator for each individual field. The pair of (selector, map)<br>\nis called a \"lense\" in Haskell context (but we can work with it directly in<br>\nIsabelle/ML without the categorical overhead around it, and just compose<br>\ncombinators via infix \"o\").</p>\n<p>Here is a canonical example to cope reasonably well in the absence of<br>\ncompiler-generated record operations:<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104</a></p>\n<p>Another possibility to trim down complexity of syntax (and runtime behaviour)<br>\nis to nest records/tuples in stages. E.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141</a></p>\n<p>Yet another variant is to use tuples, i.e. records with fields named 1, 2, 3,<br>\n... and use the Isabelle/ML antiquotations to inline map combinators like<br>\n@{apply (3)1}, e.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60</a></p>\n<blockquote>\n<p>For a pathological example, see src/Provers/order.ML where multiple&gt;<br>\nfunctions are declared that each just update one field of the record, but you<br>\nstill have to explicitly provide all the other fields.</p>\n</blockquote>\n<p>That merely looks like an odd example, so it is better not to imitate it. When<br>\ninspecting existing material, you need to develop a feeling who did it at<br>\nwhich time, and estimate how well it was actually done.</p>\n<p>The \"order\" prover is from an undergraduate student project from many years<br>\nago. It looks like the source text could be deflated a lot, by making it more<br>\n\"canonical\" in terms of Isabelle/ML style and orthography.<br>\n(MoreoverIsabelleSourcesDoNotUseCamelCaseToImproveReadability.)</p>\n<p>The somewhat awkward type less_arith with its many homogenous fields could be<br>\njust a table that maps a rule name (type string) to a rule (type thm). See our<br>\nbread-and-butter module Pure/src/General/table.ML</p>\n<p>An alternative is to use a 19-tuple and the @{apply} antiquotation.</p>\n<blockquote>\n<p>It would be nice to<br>\nhave this build into the language. An even more flexible solution would be to<br>\nimplement this as an ML antiquotation; however, this requires the ability to<br>\nintrospect the type of a record to obtain a list of all the record members. I<br>\nam not sure if this is currently (or at all) possible.</p>\n<p>Is there any interest in having such a language construct?</p>\n</blockquote>\n<p>\"Nice to have\" is often a bad reason to add new features. Languages tend to<br>\naccumulate a lot of cruft over the years, and after some decades the<br>\n\"must-haves\" from the past become a heavy burden. (OCaml has a lot of that<br>\nwith its object-oriented twists.)</p>\n<p>Isabelle/ML has its own balance of frugality and richness, both in the same<br>\nlanguage. The rather ancient SML substrate works surprisingly well with the<br>\nminor add-ons provided Isabelle/ML.</p>\n<p>I often find the balance of Isabelle/ML better than Scala, which has many good<br>\nideas, but also tons of extra weight and gravity to bog it down. In<br>\nparticular, Scala \"cases classes\" with their record-update notation (\"copy\"<br>\nmethod) are not as smooth as they should be.</p>\n<p>Makarius</p>",
        "id": 294831470,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246817
    },
    {
        "content": "<p>From: \"Norrish, Michael (Data61, Acton)\" &lt;<a href=\"mailto:Michael.Norrish@data61.csiro.au\">Michael.Norrish@data61.csiro.au</a>&gt;<br>\nSee also  </p>\n<p><a href=\"http://mlton.org/FunctionalRecordUpdate\">http://mlton.org/FunctionalRecordUpdate</a></p>\n<p>for an SML solution, of sorts.</p>\n<p>Michael</p>\n<p>ï»¿<br>\nOn 29/7/20, 06:23, \"<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> on behalf of Makarius\" &lt;<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> on behalf of <a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<p>On 28/07/2020 12:39, Lukas Stevens wrote:</p>\n<blockquote>\n<p>when using records a common theme is to just update some fields of a record<br>\nand leave the others at is. To this end, many functional languages have a<br>\nrecord update syntax, e.g. in OCaml you can write {bar with x = 1} to obtain a<br>\nnew record that has all the same values as bar except for x. As far as I can<br>\nsee, Isabelle/ML currently has no such syntax which can lead to quite a bit of<br>\nbloat.</p>\n</blockquote>\n<p>The bloat is not just in the syntax, but also in the implementation: a bulky<br>\nrecord needs to be copied to change just one field.</p>\n<p>Further note that record update is not as exciting as it seems. More important<br>\nis the \"map\" combinator for each individual field. The pair of (selector, map)<br>\nis called a \"lense\" in Haskell context (but we can work with it directly in<br>\nIsabelle/ML without the categorical overhead around it, and just compose<br>\ncombinators via infix \"o\").</p>\n<p>Here is a canonical example to cope reasonably well in the absence of<br>\ncompiler-generated record operations:<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/variable.ML#l104</a></p>\n<p>Another possibility to trim down complexity of syntax (and runtime behaviour)<br>\nis to nest records/tuples in stages. E.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/context.ML#l141</a></p>\n<p>Yet another variant is to use tuples, i.e. records with fields named 1, 2, 3,<br>\n... and use the Isabelle/ML antiquotations to inline map combinators like<br>\n@{apply (3)1}, e.g. see<br>\n<a href=\"https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60\">https://isabelle.sketis.net/repos/isabelle/file/Isabelle2020/src/Pure/Tools/generated_files.ML#l60</a></p>\n<blockquote>\n<p>For a pathological example, see src/Provers/order.ML where multiple&gt;<br>\nfunctions are declared that each just update one field of the record, but you<br>\nstill have to explicitly provide all the other fields.</p>\n</blockquote>\n<p>That merely looks like an odd example, so it is better not to imitate it. When<br>\ninspecting existing material, you need to develop a feeling who did it at<br>\nwhich time, and estimate how well it was actually done.</p>\n<p>The \"order\" prover is from an undergraduate student project from many years<br>\nago. It looks like the source text could be deflated a lot, by making it more<br>\n\"canonical\" in terms of Isabelle/ML style and orthography.<br>\n(MoreoverIsabelleSourcesDoNotUseCamelCaseToImproveReadability.)</p>\n<p>The somewhat awkward type less_arith with its many homogenous fields could be<br>\njust a table that maps a rule name (type string) to a rule (type thm). See our<br>\nbread-and-butter module Pure/src/General/table.ML</p>\n<p>An alternative is to use a 19-tuple and the @{apply} antiquotation.</p>\n<blockquote>\n<p>It would be nice to<br>\nhave this build into the language. An even more flexible solution would be to<br>\nimplement this as an ML antiquotation; however, this requires the ability to<br>\nintrospect the type of a record to obtain a list of all the record members. I<br>\nam not sure if this is currently (or at all) possible.</p>\n<p>Is there any interest in having such a language construct?</p>\n</blockquote>\n<p>\"Nice to have\" is often a bad reason to add new features. Languages tend to<br>\naccumulate a lot of cruft over the years, and after some decades the<br>\n\"must-haves\" from the past become a heavy burden. (OCaml has a lot of that<br>\nwith its object-oriented twists.)</p>\n<p>Isabelle/ML has its own balance of frugality and richness, both in the same<br>\nlanguage. The rather ancient SML substrate works surprisingly well with the<br>\nminor add-ons provided Isabelle/ML.</p>\n<p>I often find the balance of Isabelle/ML better than Scala, which has many good<br>\nideas, but also tons of extra weight and gravity to bog it down. In<br>\nparticular, Scala \"cases classes\" with their record-update notation (\"copy\"<br>\nmethod) are not as smooth as they should be.</p>\n<p>Makarius</p>",
        "id": 294831491,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246826
    },
    {
        "content": "<p>From: Lukas Stevens &lt;lukas.stevens+isabelle-users@in.tum.de&gt;<br>\nThanks for the answer and the additional practical hints.</p>\n<p>Of course, the example is, as I said, pathological but you will find<br>\nclumsy usage of records in other places as well.</p>\n<p>I agree with you that introducing a new language feature would not be a<br>\ngood idea. Lenses would probably be a nice and flexible solution. The<br>\nproblem with those is that you have to write quite a bit of boilerplate<br>\nif you can't generate them automatically. To generate them<br>\nautomatically, one could define an ML antiquotation that reads a record<br>\ntype definition and defines the record type while automatically<br>\ngenerating the code for the lens as well. Or is there a way to generate<br>\nthe lens for an existing record type (which would make it more flexible)?</p>",
        "id": 294831513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246835
    }
]