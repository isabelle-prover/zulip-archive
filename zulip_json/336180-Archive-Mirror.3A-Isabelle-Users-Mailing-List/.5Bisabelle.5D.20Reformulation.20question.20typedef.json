[
    {
        "content": "<p>From: \"Roger H.\" &lt;<a href=\"mailto:s57076@hotmail.com\">s57076@hotmail.com</a>&gt;<br>\nHi,</p>\n<p>when i write</p>\n<hr>\n<p>typedef larger_three = \"{n :: nat. n &gt; 3}\"</p>\n<p>definition b :: larger_three where<br>\n\"b = Abs_larger_three 2\"</p>\n<hr>\n<p>i would like the compiler to reject this instantiation, cause 2 is not larger then 3.</p>\n<p>My best solution for this is that the compiler behaves like it accepts it, but secretly makes it undefined:</p>\n<hr>\n<p>typedef larger_three = \"{n :: nat. n &gt; 3}\"<br>\nsorry</p>\n<p>consts<br>\nconstructNr :: \"nat =&gt; larger_three\"</p>\n<p>defs<br>\nconstructNr_def:  \"constructNr k â‰¡ if k &gt; 3 then Abs_larger_three k else undefined\"</p>\n<p>definition b :: larger_three where<br>\n\"b = constructNr 2\"</p>\n<p>lemma \"b = undefined\"<br>\nby (simp add: b_def constructNr_def)</p>\n<hr>\n<p>I would like that the compiler immediately catches this as error, and not behaving as if accepting it and throwing it to undefined.</p>\n<p>Can you help me?</p>\n<p>Thank you</p>",
        "id": 294266610,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660915728
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Roger,</p>\n<p>Higher-order logic is a logic of total functions, i.e., if you apply a function to an<br>\nargument, and the argument has the type that the function expects, then the application is<br>\ntype-correct. 2 is a natural number and Abs_larger_three is a function from nat to<br>\nlarger_three, so the application is type-correct. There's nothing you can do about this on<br>\nthe level of the logic. If you want that, then you have to use some other logic, Agda and<br>\nCoq can express these kinds of things. But then you have to prove for every application of<br>\nAbs_larger_three that the argument is indeed greater than 3. For literal numbers, this may<br>\nbe easy, but for \"Abs_larger_three (some complicated expression)\", you also have to prove<br>\nthat \"some complicated expression\" is larger than 3.</p>\n<p>Of course, you could try to tweak Isabelle's parser such that whenever Abs_larger_three is<br>\napplied to a literal numeral, it checks that the number is really greater than 3. But<br>\napart from causing a lot of work, this can be fooled easily, e.g., \"Abs_larger_three (id 2)\".</p>\n<p>You have already found the canonical solution of defining a \"smart\" function that tries to<br>\nsomehow make some sense of unexpected input (although undefined is hardly any better than<br>\nthe non-specification for Abs_larger_three).</p>\n<p>Andreas</p>",
        "id": 294266628,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660915735
    }
]