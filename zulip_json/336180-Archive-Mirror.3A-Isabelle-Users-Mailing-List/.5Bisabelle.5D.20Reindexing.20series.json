[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I want to prove that the order of summation of a converging sequence of non-negative reals <br>\ndoes not matter. In Complex_Main, I'd express this as follows;</p>\n<p>lemma<br>\n   fixes f :: \"nat =&gt; real\"<br>\n   assumes \"summable f\"<br>\n   and \"bij g\"<br>\n   and \"!!x. 0 &lt;= f x\"<br>\n   shows summable_reindex: \"summable (f o g)\"<br>\n   and suminf_reindex: \"suminf (f o g) = suminf f\"</p>\n<p>My problem is that I have no clue how to prove this in Isabelle, because I am not so <br>\nfamiliar with the details of limits in Isabelle. I expect that I could prove <br>\nsummable_reindex using the lemma summable_Cauchy, but the proof definitely will not be <br>\nelegant. So I wonder:</p>\n<ol>\n<li>Is a better way to prove summable_reindex?</li>\n<li>How can I prove suminf_reindex?</li>\n<li>Can I generalise the type real to some type class (which)?</li>\n</ol>\n<p>Thanks in advance for any help,<br>\nAndreas</p>",
        "id": 294321956,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927189
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Montag, den 17.11.2014, 10:41 +0100 schrieb Andreas Lochbihler:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>I want to prove that the order of summation of a converging sequence of non-negative reals <br>\ndoes not matter. In Complex_Main, I'd express this as follows;</p>\n<p>lemma<br>\n   fixes f :: \"nat =&gt; real\"<br>\n   assumes \"summable f\"<br>\n   and \"bij g\"<br>\n   and \"!!x. 0 &lt;= f x\"<br>\n   shows summable_reindex: \"summable (f o g)\"<br>\n   and suminf_reindex: \"suminf (f o g) = suminf f\"</p>\n<p>My problem is that I have no clue how to prove this in Isabelle, because I am not so <br>\nfamiliar with the details of limits in Isabelle. I expect that I could prove <br>\nsummable_reindex using the lemma summable_Cauchy, but the proof definitely will not be <br>\nelegant. So I wonder:</p>\n<ol>\n<li>Is a better way to prove summable_reindex?</li>\n</ol>\n</blockquote>\n<p>summable_reindex depends on the order of reals, it does not work<br>\nwithout. So summable_Cauchy which is about metric is not so well suited.</p>\n<p>A better idea may be to use summation on extended reals, here you have<br>\n  suminf f = (SUP n. setsum f {..n})<br>\nand then antisymmetry (or better SUP_eq) to prove:<br>\n  (SUP n. setsum f {..n}) = (SUP n. setsum (f o g) {..n})</p>\n<p>A attached a proof using HOL-Probability, as it uses the non-negative<br>\nintegral on ereals, which is very easy to proof. (especially with<br>\ndistr_bij_count_space which I will add to the repository...)</p>\n<blockquote>\n<ol start=\"2\">\n<li>How can I prove suminf_reindex?<br>\nProve it first on ereal and then reduce it to the reals (see my proof)</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start=\"3\">\n<li>Can I generalise the type real to some type class (which)?</li>\n</ol>\n</blockquote>\n<p>You need order, so maybe:<br>\n  {ordered_comm_monoid_add, linorder_topology,<br>\nconditionally_complete_linorder}<br>\nat least that's what I used for summableI_nonneg_bounded.</p>\n<p>real_normed_vectors do not work, as you need to state that you somehow<br>\nalways run in the same direction.</p>\n<ul>\n<li>Johannes<br>\n<a href=\"/user_uploads/14278/saH7ItawVCAMEt5brSBM2nFw/Scratch.thy\">Scratch.thy</a></li>\n</ul>",
        "id": 294322059,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927220
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>it’s not so bad, using the sandwich theorem I gave it a shot and did all<br>\nreal-related proof-steps. There are just two holes related to \"nat ⇒<br>\nnat\" functions left as an exercise for the reader :-)</p>\n<p>theory Scratch imports Complex_Main begin</p>\n<p>lemma<br>\n   fixes f :: \"nat =&gt; real\"<br>\n   assumes \"summable f\"<br>\n   and \"bij g\"<br>\n   and pos: \"!!x. 0 &lt;= f x\"<br>\n   shows summable_reindex: \"summable (f o g)\"<br>\n   and suminf_reindex: \"suminf (f o g) = suminf f\"<br>\nproof-<br>\n  obtain m :: \"nat ⇒ nat\" where  \"subseq m\" and \"∀ n n'. n' &lt; m n ⟶ inv g n' &lt; n\" sorry<br>\n  hence m: \"⋀  n. {..&lt;m n} ⊆ g ` {..&lt;n}\"<br>\n    by (auto simp add: lessThan_def, metis (mono_tags) assms(2) bij_image_Collect_eq mem_Collect_eq)<br>\n  obtain M :: \"nat ⇒ nat\" where \"subseq M\" and n: \"∀ n n'. n' &lt; n ⟶ g n' &lt; M n\" sorry</p>\n<p>have inj: \"⋀ S. inj_on g S\" using  <code>bij g</code> by (metis bij_is_inj injD inj_onI)</p>\n<p>have \"(λn. ∑i&lt;n. f (g i)) ----&gt; suminf f\"<br>\n  proof (rule real_tendsto_sandwich[OF eventually_sequentiallyI  eventually_sequentiallyI])<br>\n    fix n<br>\n    have \"(∑i&lt;m n. f i) ≤ setsum f (g <code> {..&lt;n})\"\n      by (rule setsum_mono3) (auto simp add: pos m)\n    thus \"(∑i&lt;m n. f i) ≤ (∑i&lt;n. f (g i))\"\n      by (simp add:  setsum.reindex[OF inj])\n  next\n    fix n\n    have \"setsum f (g </code> {..&lt;n}) ≤ (∑i&lt;M n. f i)\"<br>\n      by (rule setsum_mono3) (auto simp add: pos n[rule_format])<br>\n    thus \"(∑i&lt;n. f (g i)) ≤ (∑i&lt;M n. f i)\"<br>\n      by (simp add:  setsum.reindex[OF inj])<br>\n  next<br>\n    from <code>summable f</code><br>\n    have \"(λx. setsum f {..&lt;x}) ----&gt; suminf f\" by (metis summable_LIMSEQ)<br>\n    from LIMSEQ_subseq_LIMSEQ[OF this <code>subseq m</code>]<br>\n    show \"(λx. setsum f {..&lt;m x}) ----&gt; suminf f\"<br>\n      by (simp add: comp_def)<br>\n  next<br>\n    from <code>summable f</code><br>\n    have \"(λx. setsum f {..&lt;x}) ----&gt; suminf f\" by (metis summable_LIMSEQ)<br>\n    from LIMSEQ_subseq_LIMSEQ[OF this <code>subseq M</code>]<br>\n    show \"(λx. setsum f {..&lt;M x}) ----&gt; suminf f\"<br>\n      by (simp add: comp_def)<br>\n  qed<br>\n  hence \"(f ∘ g) sums suminf f\" by (simp add: sums_def)<br>\n  thus \"summable (f o g)\" and  \"suminf (f o g) = suminf f\"<br>\n    by (auto simp add: sums_iff)<br>\nqed   </p>\n<p>The \"subseq\" requirement might be a bit too strong, but I did not see a <br>\nlemma like LIMSEQ_subseq_LIMSEQ (X ----&gt; L ⟹ subseq f ⟹ (X ∘ f) ----&gt; L)<br>\nthat would allow repeating elements.</p>\n<p>Hope it helps.</p>\n<p>Greetings<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/TFNNSzHSoj1cOI-il0dse1y-/signature.asc\">signature.asc</a></p>",
        "id": 294322081,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927226
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>yes, it’s possible without, and actually nicer:</p>\n<p>theory Scratch imports Complex_Main begin</p>\n<p>lemma<br>\n   fixes f :: \"nat =&gt; real\"<br>\n   assumes \"summable f\"<br>\n   and \"inj g\"<br>\n   and pos: \"!!x. 0 &lt;= f x\"<br>\n   shows summable_reindex: \"summable (f o g)\"<br>\n   and suminf_reindex_aux: \"suminf (f o g) ≤ suminf f\"<br>\nproof-<br>\n  have \"∀ n. ∀ n' ∈ (g <code> {..&lt;n}). n' &lt; Suc (Max (g </code> {..&lt;n}))\" <br>\n    by (metis Max_ge finite_imageI finite_lessThan not_le not_less_eq)<br>\n  hence \"∀ n. ∃ m. ∀ n'&lt;n. g n' &lt; m\"  by auto<br>\n  then obtain M :: \"nat ⇒ nat\" where  n: \"∀ n n'. n' &lt; n ⟶ g n' &lt; M n\" by metis</p>\n<p>have inj: \"⋀ S. inj_on g S\" using  <code>inj g</code> by (metis injD inj_onI)</p>\n<p>have smaller: \"⋀n. (∑i&lt;n. f (g i)) ≤ suminf f\"<br>\n  proof-<br>\n    fix n<br>\n    have \"setsum f (g <code> {..&lt;n}) ≤ (∑i&lt;M n. f i)\"\n      by (rule setsum_mono3) (auto simp add: pos n[rule_format])\n    hence \"(∑i&lt;n. f (g i)) ≤ (∑i&lt;M n. f i)\"\n      by (simp add:  setsum.reindex[OF inj])\n    also have \"… ≤ suminf f\"\n      using </code>summable f` <br>\n      by (rule setsum_le_suminf) (simp add: pos)<br>\n    finally<br>\n    show \"(∑i&lt;n. f (g i)) ≤ suminf f\".<br>\n  qed</p>\n<p>have \"incseq (λn. ∑i&lt;n. f (g i))\"<br>\n    by (rule incseq_SucI) (auto simp add: pos)<br>\n  moreover<br>\n  have \"∀n. (∑i&lt;n. f (g i)) ≤ suminf f\" by (auto intro: smaller)<br>\n  ultimately<br>\n  obtain L where L: \"(λ n. ∑i&lt;n. f (g i)) ----&gt; L\" by (rule incseq_convergent)<br>\n  hence \"(f ∘ g) sums L\" by (simp add: sums_def)<br>\n  thus \"summable (f o g)\" by (auto simp add: sums_iff)</p>\n<p>from <code>(f ∘ g) sums L</code><br>\n  have \"suminf (f ∘ g) = L\" by (auto simp add: sums_iff) </p>\n<p>from L<br>\n  have \"L ≤ suminf f\"<br>\n    by (rule LIMSEQ_le_const2) (auto intro: smaller)<br>\n  with <code>_ = L</code><br>\n  show \"suminf (f o g) ≤ suminf f\" by simp<br>\nqed</p>\n<p>lemma<br>\n   fixes f :: \"nat =&gt; real\"<br>\n   assumes \"summable f\"<br>\n   and \"bij g\"<br>\n   and pos: \"!!x. 0 &lt;= f x\"<br>\n   shows suminf_reindex: \"suminf (f o g) = suminf f\"<br>\nproof-<br>\n  from <code>bij g</code> have \"inj g\" by (rule bij_is_inj)<br>\n  from <code>bij g</code> have [simp]: \"⋀ x. g (inv g x) = x\"  by (metis bij_betw_imp_surj surj_f_inv_f)</p>\n<p>show \"suminf (f o g) = suminf f\"<br>\n  proof (rule antisym)<br>\n    show \"suminf (f ∘ g) ≤ suminf f\"<br>\n    by (rule suminf_reindex_aux[OF <code>summable f</code> <code>inj g</code> pos])<br>\n  next<br>\n    have \"summable (f ∘ g)\" by (rule summable_reindex[OF <code>summable f</code> <code>inj g</code> pos])<br>\n    moreover<br>\n    from <code>bij g</code><br>\n    have \"inj (inv g)\" by (metis  bij_betw_def surj_imp_inj_inv)<br>\n    moreover<br>\n    from pos<br>\n    have \"⋀ x. 0 ≤ (f ∘ g) x\" by simp<br>\n    ultimately<br>\n    have \"suminf ((f ∘ g) ∘ inv g) ≤ suminf (f ∘ g) \"<br>\n      by (rule suminf_reindex_aux)<br>\n    thus \"suminf f ≤ suminf (f ∘ g)\" by (simp add:comp_def)<br>\n  qed<br>\nqed</p>\n<p>And now I got to run, my colleages are going to watch a movie and I’m<br>\nalready late. Stupid addictivity of Isabelle :-)</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/PPF2cMCsGkZiWx0hSM5oYTkW/signature.asc\">signature.asc</a></p>",
        "id": 294322094,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927232
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Johannes and Joachim,</p>\n<p>Thanks a lot for your efforts. I'll generalise and polish Joachim's proof a bit and <br>\nultimately will add it to the repository. I won't try to abstract from reals to some type <br>\nclass because both of your proofs rely on lemmas about the reals.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294322164,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927257
    }
]