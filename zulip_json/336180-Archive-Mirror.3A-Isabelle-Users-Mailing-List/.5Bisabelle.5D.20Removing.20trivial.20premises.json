[
    {
        "content": "<p>From: Michael Färber &lt;<a href=\"mailto:michael.faerber@uibk.ac.at\">michael.faerber@uibk.ac.at</a>&gt;<br>\nDear mailing list,</p>\n<p>when I resolve theorems, I sometimes obtain trivial premises such as in <br>\nthis case:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">val</span> <span class=\"n\">th1</span> <span class=\"o\">=</span> <span class=\"n\">Thm.assume</span> <span class=\"err\">@</span><span class=\"ow\">{</span><span class=\"n\">cprop</span> <span class=\"s\">\"P ==&gt; Q\"</span><span class=\"ow\">}</span>\n<span class=\"n\">val</span> <span class=\"n\">th2</span> <span class=\"o\">=</span> <span class=\"n\">Thm.assume</span> <span class=\"err\">@</span><span class=\"ow\">{</span><span class=\"n\">cprop</span> <span class=\"s\">\"(P ==&gt; Q) ==&gt; R\"</span><span class=\"ow\">}</span>\n<span class=\"n\">val</span> <span class=\"n\">th3</span> <span class=\"o\">=</span> <span class=\"n\">th2</span> <span class=\"n\">OF</span> <span class=\"o\">[</span><span class=\"n\">th1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This produces a th3 with proposition \"(P ==&gt; P) ==&gt; R\".<br>\nHowever, I would like to obtain only \"R\".</p>\n<p>My ad-hoc solution was to create a function that strips away the first <br>\npremise if it is trivial,<br>\nand to apply it multiple times on a theorem (via <code>funpow</code>) if the <br>\ntheorem contains multiple trivial premises.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">remove_trivial_prem</span> <span class=\"n\">th</span> <span class=\"o\">=</span>\n   <span class=\"k\">let</span>\n     <span class=\"n\">val</span> <span class=\"n\">prem</span> <span class=\"o\">=</span> <span class=\"k\">case</span> <span class=\"n\">Thm.prems_of</span> <span class=\"n\">th</span> <span class=\"n\">of</span> <span class=\"n\">x</span><span class=\"o\">::_</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span> <span class=\"n\">x</span> <span class=\"o\">|</span> <span class=\"o\">_</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span> <span class=\"n\">raise</span> <span class=\"n\">Fail</span> <span class=\"s\">\"no</span>\n<span class=\"s\">premises\"</span>\n     <span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">=</span> <span class=\"n\">Logic.dest_implies</span> <span class=\"n\">prem</span>\n     <span class=\"n\">val</span> <span class=\"o\">_</span> <span class=\"o\">=</span> <span class=\"err\">@</span><span class=\"ow\">{</span><span class=\"n\">assert</span><span class=\"ow\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n     <span class=\"n\">val</span> <span class=\"n\">ctxt</span> <span class=\"o\">=</span> <span class=\"n\">Thm.theory_of_thm</span> <span class=\"n\">th</span> <span class=\"o\">|</span><span class=\"err\">&gt;</span> <span class=\"n\">Defs.global_context</span> <span class=\"o\">|</span><span class=\"err\">&gt;</span> <span class=\"n\">fst</span>\n     <span class=\"n\">val</span> <span class=\"n\">triv</span> <span class=\"o\">=</span> <span class=\"n\">Thm.trivial</span> <span class=\"o\">(</span><span class=\"n\">Thm.cterm_of</span> <span class=\"n\">ctxt</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n   <span class=\"kp\">in</span> <span class=\"n\">Thm.implies_elim</span> <span class=\"n\">th</span> <span class=\"n\">triv</span>\n   <span class=\"k\">end</span>\n\n<span class=\"n\">val</span> <span class=\"n\">th4</span> <span class=\"o\">=</span> <span class=\"n\">remove_trivial_prem</span> <span class=\"n\">th3</span>\n</code></pre></div>\n<p>This now yields a th3 with proposition \"R\".<br>\nHowever, I feel that this is a bad way to treat trivial premises, among <br>\nothers because I have to manually determine how many trivial premises <br>\nare present in the theorem.<br>\nSo what is the canonical way to deal with trivial premises?</p>\n<p>Cheers,<br>\nMichael</p>\n<p>P.S.: I know that in Isar, trivial premises can be eliminated when <br>\nclosing a proof with \".\", but I do not know how to do that in ML.<br>\nReading the source for hours unfortunately did not bring me <br>\nenlightenment yet. :)</p>",
        "id": 294674900,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174616
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy.dawson@anu.edu.au\">jeremy.dawson@anu.edu.au</a>&gt;<br>\nIn an older version of Isabelle you would just use <br>\nTRYALL atac th3<br>\nand take the head of the resulting sequence</p>\n<p>This may no longer be possible of course</p>\n<p>Jeremy</p>\n<p>Sent from my NOOK</p>\n<p>Michael Färber &lt;<a href=\"mailto:michael.faerber@uibk.ac.at\">michael.faerber@uibk.ac.at</a>&gt; wrote:</p>\n<p>Dear mailing list,</p>\n<p>when I resolve theorems, I sometimes obtain trivial premises such as in <br>\nthis case:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"n\">val</span> <span class=\"n\">th1</span> <span class=\"o\">=</span> <span class=\"n\">Thm.assume</span> <span class=\"err\">@</span><span class=\"ow\">{</span><span class=\"n\">cprop</span> <span class=\"s\">\"P ==&gt; Q\"</span><span class=\"ow\">}</span>\n<span class=\"n\">val</span> <span class=\"n\">th2</span> <span class=\"o\">=</span> <span class=\"n\">Thm.assume</span> <span class=\"err\">@</span><span class=\"ow\">{</span><span class=\"n\">cprop</span> <span class=\"s\">\"(P ==&gt; Q) ==&gt; R\"</span><span class=\"ow\">}</span>\n<span class=\"n\">val</span> <span class=\"n\">th3</span> <span class=\"o\">=</span> <span class=\"n\">th2</span> <span class=\"n\">OF</span> <span class=\"o\">[</span><span class=\"n\">th1</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>This produces a th3 with proposition \"(P ==&gt; P) ==&gt; R\".<br>\nHowever, I would like to obtain only \"R\".</p>\n<p>My ad-hoc solution was to create a function that strips away the first <br>\npremise if it is trivial,<br>\nand to apply it multiple times on a theorem (via <code>funpow</code>) if the <br>\ntheorem contains multiple trivial premises.</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">fun</span> <span class=\"n\">remove_trivial_prem</span> <span class=\"n\">th</span> <span class=\"o\">=</span>\n   <span class=\"k\">let</span>\n     <span class=\"n\">val</span> <span class=\"n\">prem</span> <span class=\"o\">=</span> <span class=\"k\">case</span> <span class=\"n\">Thm.prems_of</span> <span class=\"n\">th</span> <span class=\"n\">of</span> <span class=\"n\">x</span><span class=\"o\">::_</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span> <span class=\"n\">x</span> <span class=\"o\">|</span> <span class=\"o\">_</span> <span class=\"o\">=</span><span class=\"err\">&gt;</span> <span class=\"n\">raise</span> <span class=\"n\">Fail</span> <span class=\"s\">\"no</span>\n<span class=\"s\">premises\"</span>\n     <span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">=</span> <span class=\"n\">Logic.dest_implies</span> <span class=\"n\">prem</span>\n     <span class=\"n\">val</span> <span class=\"o\">_</span> <span class=\"o\">=</span> <span class=\"err\">@</span><span class=\"ow\">{</span><span class=\"n\">assert</span><span class=\"ow\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n     <span class=\"n\">val</span> <span class=\"n\">ctxt</span> <span class=\"o\">=</span> <span class=\"n\">Thm.theory_of_thm</span> <span class=\"n\">th</span> <span class=\"o\">|</span><span class=\"err\">&gt;</span> <span class=\"n\">Defs.global_context</span> <span class=\"o\">|</span><span class=\"err\">&gt;</span> <span class=\"n\">fst</span>\n     <span class=\"n\">val</span> <span class=\"n\">triv</span> <span class=\"o\">=</span> <span class=\"n\">Thm.trivial</span> <span class=\"o\">(</span><span class=\"n\">Thm.cterm_of</span> <span class=\"n\">ctxt</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n   <span class=\"kp\">in</span> <span class=\"n\">Thm.implies_elim</span> <span class=\"n\">th</span> <span class=\"n\">triv</span>\n   <span class=\"k\">end</span>\n\n<span class=\"n\">val</span> <span class=\"n\">th4</span> <span class=\"o\">=</span> <span class=\"n\">remove_trivial_prem</span> <span class=\"n\">th3</span>\n</code></pre></div>\n<p>This now yields a th3 with proposition \"R\".<br>\nHowever, I feel that this is a bad way to treat trivial premises, among <br>\nothers because I have to manually determine how many trivial premises <br>\nare present in the theorem.<br>\nSo what is the canonical way to deal with trivial premises?</p>\n<p>Cheers,<br>\nMichael</p>\n<p>P.S.: I know that in Isar, trivial premises can be eliminated when <br>\nclosing a proof with \".\", but I do not know how to do that in ML.<br>\nReading the source for hours unfortunately did not bring me <br>\nenlightenment yet. :)</p>",
        "id": 294674952,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174635
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 19/05/16 21:20, Michael Färber wrote:</p>\n<blockquote>\n<p>when I resolve theorems, I sometimes obtain trivial premises such as in<br>\nthis case:</p>\n<p>~~~<br>\nval th1 = Thm.assume @{cprop \"P ==&gt; Q\"}<br>\nval th2 = Thm.assume @{cprop \"(P ==&gt; Q) ==&gt; R\"}<br>\nval th3 = th2 OF [th1]<br>\n~~~</p>\n<p>This produces a th3 with proposition \"(P ==&gt; P) ==&gt; R\".<br>\nHowever, I would like to obtain only \"R\".</p>\n</blockquote>\n<p>Larry Paulson introduced the concept of \"elim-resolution\" for that<br>\naround 1989. Apart from the original papers from that time, it is also<br>\nbriefly explained in the \"implementation\" manual in section 4.2.1 – for<br>\ntactical backwards proof.</p>\n<p>In principle, it is possible to make elim versions of the forward proof<br>\ncombinators (RS, OF), but it is not done, because backwards proof scales<br>\nbetter to real applications.</p>\n<blockquote>\n<p>So what is the canonical way to deal with trivial premises?</p>\n</blockquote>\n<p>The canonical way is to avoid getting them in the first place, i.e. via<br>\nelim-resolution.</p>\n<blockquote>\n<p>P.S.: I know that in Isar, trivial premises can be eliminated when<br>\nclosing a proof with \".\", but I do not know how to do that in ML.<br>\nReading the source for hours unfortunately did not bring me<br>\nenlightenment yet. :)</p>\n</blockquote>\n<p>Reading sources is important, but one needs to have an idea about the<br>\ngeneral concepts behind them. Apart from the original published<br>\nliterature (which is naturally a bit outdated), the canonical entry<br>\npoints are the \"implementation\" manual and the \"isar-ref\" manual.</p>\n<p>The Prover IDE also helps a lot to navigate around, e.g. to find the<br>\nIsabelle/ML definitions of Isabelle/Isar commands.</p>\n<p>The implicit finishing of the left-over proof state in structured Isar<br>\nproofs is defined in src/Pure/Isar/method.ML as \"finish\". This is very<br>\nspecific for how Isar works. It is unlikely to make much sense in a<br>\ndifferent context.</p>\n<p>Makarius</p>",
        "id": 294675045,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174656
    }
]