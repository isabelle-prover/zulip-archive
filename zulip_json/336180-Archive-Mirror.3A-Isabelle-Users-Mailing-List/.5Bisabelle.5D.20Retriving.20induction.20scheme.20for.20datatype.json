[
    {
        "content": "<p>From: Moa Johansson &lt;<a href=\"mailto:jomoa@chalmers.se\">jomoa@chalmers.se</a>&gt;<br>\nHi,</p>\n<p>We are updating our tools for inductive theorem proving to Isabelle2015.</p>\n<p>We noticed that the Datatype package has changed, and wonder what the <br>\nproper way of fetching the induction theorem for a given datatype is now <br>\n(working on the ML-level, as we have a tactic for automated induction).</p>\n<p>We can get things to work by using \"Old_Datatype_Data.get_info\", and <br>\nregistering all our datatypes with<br>\n\"datatype_compat\". However, we would obviously want to do this in the <br>\nproper way intended instead.</p>\n<p>Grateful for help on where to look!</p>\n<p>Best,<br>\nMoa</p>",
        "id": 294654058,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167284
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Moa,</p>\n<p>the proper way would be as follows:</p>\n<p>ML ‹<br>\n   BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name list}<br>\n   |&gt; the<br>\n   |&gt; #fp_co_induct_sugar<br>\n   |&gt; #co_inducts;<br>\n›</p>\n<p>The fp_sugar records are quite rich in comparison to the old info record <br>\nof a datatype---they should contain everything that the datatype command <br>\nspits out.</p>\n<p>Note that for nested datatypes such as rose trees (datatype 'a tree = <br>\nNode 'a \"'a tree list\") the induction principle will look different from <br>\nthe one output by the old package. (Using datatype_compat is one way <br>\naround it, but the new format is more compositional---so there is a <br>\npoint of adjusting tools to work with it.)</p>\n<p>Dmitriy</p>",
        "id": 294654070,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167290
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nHi Moa,</p>\n<p>There are basically two options:</p>\n<ol>\n<li>Use the compatibility layer in \"HOL/Tools/BNF/bnf_lfp_compat.ML\". The function \"BNF_LFP_Compat.get_info\" has almost the same signature as the old \"get_info\" and gives you access to both old and new datatypes. The second argument specifies some preferences; you should probably just pass \"[]\". Examples:<p>ML {*<br>\n  BNF_LFP_Compat.get_info @{theory} [] @{type_name list}<br>\n  |&gt; the<br>\n  |&gt; #induct<br>\n  *}</p>\n<p>datatype 'a tree = Tree 'a \"'a tree list\"</p>\n<p>ML {*<br>\n  BNF_LFP_Compat.get_info @{theory} [] @{type_name tree}<br>\n  |&gt; the<br>\n  |&gt; #induct<br>\n  *}</p>\n<p>datatype_compat tree</p>\n<p>ML {*<br>\n  BNF_LFP_Compat.get_info @{theory} [] @{type_name tree}<br>\n  |&gt; the<br>\n  |&gt; #induct<br>\n  *}</p>\n</li>\n</ol>\n<p>Notice that for types with nesting (like \"list\"), you get a different induction scheme depending on whether you call \"datatype_compat\". You can pass the \"Keep_Nesting\" option if you prefer the new scheme. See our ITP 2014 paper for details about the nested vs. mutual styles.</p>\n<ol start=\"2\">\n<li>Use the new interface in \"HOL/Tools/BNF/bnf_fp_def_sugar.ML\".<p>ML {*<br>\n  BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name list}<br>\n  |&gt; the<br>\n  |&gt; #fp_co_induct_sugar<br>\n  |&gt; #co_inducts<br>\n  |&gt; hd<br>\n  *}</p>\n<p>datatype 'a tree = Tree 'a \"'a tree list\"</p>\n<p>ML {*<br>\n  BNF_FP_Def_Sugar.fp_sugar_of @{context} @{type_name tree}<br>\n  |&gt; the<br>\n  |&gt; #fp_co_induct_sugar<br>\n  |&gt; #co_inducts<br>\n  |&gt; hd<br>\n  *}</p>\n</li>\n</ol>\n<p>I hope this helps.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294654100,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167303
    }
]