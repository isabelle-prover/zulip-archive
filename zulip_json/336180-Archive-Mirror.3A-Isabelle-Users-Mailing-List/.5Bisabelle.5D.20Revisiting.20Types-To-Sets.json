[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I hope it is not entirely inappropriate to provide several further comments<br>\non the progress in the development of an extension of the framework<br>\nTypes-To-Sets in the form of a reply to a remark that was made in the<br>\nprevious thread on this subject:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-June/msg00072.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-June/msg00072.html</a>.</p>\n<p>I believe that I have finally reached the stage at which the full<br>\nautomation of the relativization process is possible in certain cases. If<br>\ncertain conditions are met, the users need not have almost any<br>\nunderstanding of the relativization algorithm and only a minimal amount of<br>\neffort is required on their part to perform the relativization. Moreover,<br>\nthis effort comes down to, primarily, providing lists of definitions and<br>\ntheorems that they would like to relativize. The enabling feature was the<br>\nimplementation of the algorithm for the relativization of definitions (the<br>\nalgorithm was suggested by Fabian Immler).</p>\n<p>After my signature, I provide an example of the relativization of a small<br>\nsection of the theory about preorders from the theory files Orderings.thy<br>\nand Set_Interval.thy. This theory provides, approximately, 12 relativized<br>\ndefinitions and 55 new relativized theorems for only one proof that needed<br>\nto be done by the user (the proof is that of the parametricity property<br>\nthat exists between the locale predicates of the class.preorder and the<br>\nnewly introduced locale preorder_ow). The example is available as part of<br>\nthe GitHub repository <a href=\"https://github.com/xanonec/HOL-TTS-Ext\">https://github.com/xanonec/HOL-TTS-Ext</a>, where the<br>\ndevelopment takes place.</p>\n<p>The conditions that I am referring to in the previous paragraph are that<br>\nonly the plain definitions are used in the type-based theory (at this<br>\nstage, the relativization of constants obtained using other specification<br>\nelements still needs to be performed explicitly by the user) and that the<br>\ndefinitions do not contain Hilbert choice, definite description operator,<br>\nundefined constants and other possible sources of 'non-determinism'.<br>\nHowever, usually, it is relatively easy to provide the relativization of<br>\nconstants obtained using the specification elements other than 'definition'<br>\nmanually.</p>\n<p>Effectively, the framework provides a convenient tool for synthesizing<br>\nsignificant parts of the libraries of relativized results (e.g.<br>\nHOL-Algebra) from the type-based counterparts in a nearly automated manner<br>\n(e.g. see <a href=\"https://github.com/xanonec/HOL-SML-Relativization\">https://github.com/xanonec/HOL-SML-Relativization</a>).</p>\n<p>I believe that I am reaching the stage at which the work can be considered<br>\nto be nearly feature-complete. Nevertheless, at this stage, I still welcome<br>\nsuggestions for the improvement of the functionality.</p>\n<p>The only downside is that, by now, I also realised that it will take a<br>\nsubstantial amount of time before I can provide a stable release of the<br>\nsoftware. There is still a very substantial amount of software engineering<br>\nwork that needs to be done before this work can be considered to be<br>\ncompleted. Also, it seems that I will not be able to afford to allow myself<br>\nto spend as much time on this project as I was able in the last couple of<br>\nmonths from the beginning of autumn.</p>\n<p>Thank you</p>\n<p>section ‚ÄπRelativization of the results about orders‚Ä∫<br>\ntheory Simple_Orders<br>\n  imports<br>\n    \"../TTS\"<br>\nbegin</p>\n<p>subsection ‚ÄπDefinitions I: user-defined relativizations‚Ä∫</p>\n<p>locale ord_ow =<br>\n  fixes ùîò :: \"'ao set\"<br>\n    and le :: \"['ao, 'ao] ‚áí bool\" (infix ‚Äπ‚â§‚á©o‚á©w‚Ä∫ 50)<br>\n    and ls :: \"['ao, 'ao] ‚áí bool\" (infix ‚Äπ&lt;‚á©o‚á©w‚Ä∫ 50)<br>\nbegin</p>\n<p>notation le (‚Äπ'(‚â§‚á©o‚á©w')‚Ä∫)<br>\n  and le (infix ‚Äπ‚â§‚á©o‚á©w‚Ä∫ 50)<br>\n  and ls (‚Äπ'(&lt;‚á©o‚á©w')‚Ä∫)<br>\n  and ls (infix ‚Äπ&lt;‚á©o‚á©w‚Ä∫ 50)</p>\n<p>abbreviation (input) ge (infix ‚Äπ‚â•‚á©o‚á©w‚Ä∫ 50) where \"x ‚â•‚á©o‚á©w y ‚â° y ‚â§‚á©o‚á©w x\"<br>\nabbreviation (input) gt (infix ‚Äπ&gt;‚á©o‚á©w‚Ä∫ 50) where \"x &gt;‚á©o‚á©w y ‚â° y &lt;‚á©o‚á©w x\"</p>\n<p>notation ge (‚Äπ'(‚â•‚á©o‚á©w')‚Ä∫)<br>\n  and ge (infix ‚Äπ‚â•‚á©o‚á©w‚Ä∫ 50)<br>\n  and gt (‚Äπ'(&gt;‚á©o‚á©w')‚Ä∫)<br>\n  and gt (infix ‚Äπ&gt;‚á©o‚á©w‚Ä∫ 50)</p>\n<p>end</p>\n<p>locale preorder_ow = ord_ow ùîò le ls<br>\n  for ùîò :: \"'ao set\" and le ls +<br>\n  assumes less_le_not_le:<br>\n    \"‚ü¶ x ‚àà ùîò; y ‚àà ùîò ‚üß ‚üπ x &lt;‚á©o‚á©w y ‚ü∑ x ‚â§‚á©o‚á©w y ‚àß ¬¨ (y ‚â§‚á©o‚á©w x)\"<br>\n    and order_refl[iff]: \"x ‚àà ùîò ‚üπ x ‚â§‚á©o‚á©w x\"<br>\n    and order_trans: \"‚ü¶ x ‚àà ùîò; y ‚àà ùîò; z ‚àà ùîò; x ‚â§‚á©o‚á©w y; y ‚â§‚á©o‚á©w z ‚üß ‚üπ x<br>\n‚â§‚á©o‚á©w z\"</p>\n<p>context<br>\n  includes lifting_syntax<br>\nbegin</p>\n<p>lemma preorder_transfer[transfer_rule]:<br>\n  assumes [transfer_rule]: \"right_total A\"<br>\n  shows<br>\n    \"((A ===&gt; A ===&gt; (=)) ===&gt; (A ===&gt; A ===&gt; (=))  ===&gt; (=))<br>\n    (preorder_ow (Collect (Domainp A))) class.preorder\"<br>\n  unfolding preorder_ow_def class.preorder_def<br>\n  apply transfer_prover_start<br>\n  apply transfer_step+<br>\n  by blast</p>\n<p>end</p>\n<p>subsection ‚ÄπDefinitions II: automated relativization‚Ä∫</p>\n<p>tts_unoverload_definitions<br>\n  (\"(‚â§)::?'a::ord‚áí?'a::ord‚áíbool\", \"(&lt;)::?'a::ord‚áí?'a::ord‚áíbool\")<br>\n  in lessThan_def (‚Äπ'(/with _ : (1{..&lt;_})/')‚Ä∫)<br>\n    and atMost_def (‚Äπ'(/with _ : (1{.._})/')‚Ä∫)<br>\n    and greaterThan_def (‚Äπ'(/with _ : (1{_&lt;..})/')‚Ä∫)<br>\n    and atLeast_def (‚Äπ'(/with _ : (1{_..})/')‚Ä∫)<br>\n    and greaterThanLessThan_def (‚Äπ'(/with _ : (1{_&lt;..&lt;_})/')‚Ä∫)<br>\n    and atLeastLessThan_def (‚Äπ'(/with _ _ : (1{_..&lt;_})/')‚Ä∫)<br>\n    and greaterThanAtMost_def (‚Äπ'(/with _ _ : (1{_&lt;.._})/')‚Ä∫)<br>\n    and atLeastAtMost_def (‚Äπ'(/with _ : (1{_.._})/')‚Ä∫ )<br>\n    and min_def (‚Äπ'(/with _ : ¬´min¬ª _ _/')‚Ä∫ [1000, 1000, 1000] 1000)<br>\n    and max_def (‚Äπ'(/with _ : ¬´max¬ª _ _/')‚Ä∫ [1000, 1000, 1000] 1000)</p>\n<p>tts_relativize_definitions<br>\n  types: (?'a ‚Äπùîò::'a set‚Ä∫)<br>\n  in lessThan_with_def (‚Äπ'(/on _ with _ : (1{..&lt;_})/')‚Ä∫)<br>\n    and atMost_with_def (‚Äπ'(/on _ with _ : (1{.._})/')‚Ä∫)<br>\n    and greaterThan_with_def (‚Äπ'(/on _ with _: (1{_&lt;..})/')‚Ä∫)<br>\n    and atLeast_with_def (‚Äπ'(/on _ with _ : (1{_..})/')‚Ä∫)<br>\n    and greaterThanLessThan_with_def (‚Äπ'(/on _ with _ : (1{_&lt;..&lt;_})/')‚Ä∫)<br>\n    and atLeastLessThan_with_def (‚Äπ'(/on _ with _ _ : (1{_..&lt;_})/')‚Ä∫)<br>\n    and greaterThanAtMost_with_def (‚Äπ'(/on _ with _ _ : (1{_&lt;.._})/')‚Ä∫)<br>\n    and atLeastAtMost_with_def (‚Äπ'(/on _ with _ : (1{_.._})/')‚Ä∫)<br>\n    and min_with_def<br>\n    and max_with_def</p>\n<p>tts_unoverload_definitions<br>\n  in bdd_above_def (‚Äπ'(/with _ : ¬´bdd'_above¬ª _/')‚Ä∫)<br>\n    and bdd_below_def (‚Äπ'(/with _ : ¬´bdd'_below¬ª _/')‚Ä∫)</p>\n<p>tts_relativize_definitions<br>\n  types: (?'a ‚Äπùîò::'a set‚Ä∫)<br>\n  in bdd_above_with_def (‚Äπ'(/on _ with _ : ¬´bdd'_above¬ª _/')‚Ä∫)<br>\n    and bdd_below_with_def (‚Äπ'(/on _ with _ : ¬´bdd'_below¬ª _/')‚Ä∫)</p>\n<p>subsubsection ‚ÄπRelativization of theorems‚Ä∫</p>\n<p>context preorder_ow<br>\nbegin</p>\n<p>tts_relativize_facts<br>\n  types: (?'a ùîò)<br>\n  substituting preorder_ow_axioms<br>\n  trying auto<br>\n  in preorder_class.less_irrefl<br>\n    and preorder_class.bdd_below_Ioc<br>\n    and preorder_class.bdd_above_Ioc<br>\n    and preorder_class.bdd_above_Iic<br>\n    and preorder_class.bdd_above_Iio<br>\n    and preorder_class.bdd_below_Ici<br>\n    and preorder_class.bdd_below_Ioi<br>\n    and preorder_class.bdd_above_Icc<br>\n    and preorder_class.bdd_above_Ioo<br>\n    and preorder_class.bdd_below_Icc<br>\n    and preorder_class.bdd_below_Ioo<br>\n    and preorder_class.bdd_above_Ico<br>\n    and preorder_class.bdd_below_Ico<br>\n    and preorder_class.Ioi_le_Ico<br>\n    and preorder_class.eq_refl<br>\n    and preorder_class.less_imp_le<br>\n    and preorder_class.less_not_sym<br>\n    and preorder_class.less_imp_not_less<br>\n    and preorder_class.less_asym'<br>\n    and preorder_class.less_imp_triv<br>\n    and preorder_class.less_trans<br>\n    and preorder_class.less_le_trans<br>\n    and preorder_class.le_less_trans<br>\n    and preorder_class.bdd_aboveI<br>\n    and preorder_class.bdd_belowI<br>\n    and preorder_class.less_asym<br>\n    and preorder_class.bdd_above_Int1<br>\n    and preorder_class.bdd_above_Int2<br>\n    and preorder_class.bdd_below_Int1<br>\n    and preorder_class.bdd_below_Int2<br>\n    and preorder_class.bdd_above_mono<br>\n    and preorder_class.bdd_below_mono<br>\n    and bdd_above_empty<br>\n    and preorder_class.bdd_below_empty</p>\n<p>tts_relativize_facts<br>\n  types: (?'a ùîò) and (?'b ‚Äπùîò‚á©2::'b set‚Ä∫)<br>\n  substituting preorder_ow_axioms<br>\n  trying (auto intro: bdd_above_empty bdd_below_empty)<br>\n  in preorder_class.bdd_belowI2<br>\n    and preorder_class.bdd_aboveI2</p>\n<p>end</p>\n<p>tts_statistics</p>\n<p>end</p>\n<hr>\n<p>Automatically generated unoverloaded definitions:</p>\n<p>theorem lessThan_with_def: (with ?less : {..&lt;?u}) ‚â° {x. ?less x ?u}<br>\ntheorem lessThan_with.overloaded: lessThan ‚â° lessThan_with (&lt;)<br>\ntheorem atMost_with_def: (with ?less_eq : {..?u}) ‚â° {x. ?less_eq x ?u}<br>\ntheorem atMost_with.overloaded: atMost ‚â° atMost_with (‚â§)<br>\ntheorem greaterThan_with_def: (with ?less : {?l&lt;..}) ‚â° {x. ?less ?l x}<br>\ntheorem greaterThan_with.overloaded: greaterThan ‚â° greaterThan_with (&lt;)<br>\ntheorem atLeast_with_def: (with ?less_eq : {?l..}) ‚â° {x. ?less_eq ?l x}<br>\ntheorem atLeast_with.overloaded: atLeast ‚â° atLeast_with (‚â§)<br>\ntheorem greaterThanLessThan_with_def: (with ?less : {?l&lt;..&lt;?u}) ‚â° (with<br>\n?less : {?l&lt;..}) ‚à© (with ?less : {..&lt;?u})<br>\ntheorem greaterThanLessThan_with.overloaded: greaterThanLessThan ‚â°<br>\ngreaterThanLessThan_with (&lt;)<br>\ntheorem atLeastLessThan_with_def: (with ?less_eq ?less : {?l..&lt;?u}) ‚â° (with<br>\n?less_eq : {?l..}) ‚à© (with ?less : {..&lt;?u})<br>\ntheorem atLeastLessThan_with.overloaded: atLeastLessThan ‚â°<br>\natLeastLessThan_with (‚â§) (&lt;)<br>\ntheorem greaterThanAtMost_with_def: (with ?less_eq ?less : {?l&lt;..?u}) ‚â°<br>\n(with ?less : {?l&lt;..}) ‚à© (with ?less_eq : {..?u})<br>\ntheorem greaterThanAtMost_with.overloaded: greaterThanAtMost ‚â°<br>\ngreaterThanAtMost_with (‚â§) (&lt;)<br>\ntheorem atLeastAtMost_with_def: (with ?less_eq : {?l..?u}) ‚â° (with ?less_eq<br>\n: {?l..}) ‚à© (with ?less_eq : {..?u})<br>\ntheorem atLeastAtMost_with.overloaded: atLeastAtMost ‚â° atLeastAtMost_with<br>\n(‚â§)<br>\ntheorem min_with_def: (with ?less_eq : ¬´min¬ª ?a ?b) ‚â° if ?less_eq ?a ?b<br>\nthen ?a else ?b<br>\ntheorem min_with.overloaded: min ‚â° min_with (‚â§)<br>\ntheorem max_with_def: (with ?less_eq : ¬´max¬ª ?a ?b) ‚â° if ?less_eq ?a ?b<br>\nthen ?b else ?a<br>\ntheorem max_with.overloaded: max ‚â° max_with (‚â§)</p>\n<p>theorem bdd_above_with_def: (with ?less_eq : ¬´bdd_above¬ª ?A) ‚â° ‚àÉM. ‚àÄx‚àà?A.<br>\n?less_eq x M<br>\ntheorem bdd_above_with.overloaded: bdd_above ‚â° bdd_above_with (‚â§)<br>\ntheorem bdd_below_with_def: (with ?less_eq : ¬´bdd_below¬ª ?A) ‚â° ‚àÉm. Ball ?A<br>\n(?less_eq m)<br>\ntheorem bdd_below_with.overloaded: bdd_below ‚â° bdd_below_with (‚â§)</p>\n<hr>\n<p>[message truncated]</p>",
        "id": 294761712,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199915
    }
]