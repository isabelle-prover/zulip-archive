[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I hope it is not entirely inappropriate to provide several further comments<br>\non the progress in the development of an extension of the framework<br>\nTypes-To-Sets in the form of a reply to a remark that was made in the<br>\nprevious thread on this subject:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-June/msg00072.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-June/msg00072.html</a>.</p>\n<p>I believe that I have finally reached the stage at which the full<br>\nautomation of the relativization process is possible in certain cases. If<br>\ncertain conditions are met, the users need not have almost any<br>\nunderstanding of the relativization algorithm and only a minimal amount of<br>\neffort is required on their part to perform the relativization. Moreover,<br>\nthis effort comes down to, primarily, providing lists of definitions and<br>\ntheorems that they would like to relativize. The enabling feature was the<br>\nimplementation of the algorithm for the relativization of definitions (the<br>\nalgorithm was suggested by Fabian Immler).</p>\n<p>After my signature, I provide an example of the relativization of a small<br>\nsection of the theory about preorders from the theory files Orderings.thy<br>\nand Set_Interval.thy. This theory provides, approximately, 12 relativized<br>\ndefinitions and 55 new relativized theorems for only one proof that needed<br>\nto be done by the user (the proof is that of the parametricity property<br>\nthat exists between the locale predicates of the class.preorder and the<br>\nnewly introduced locale preorder_ow). The example is available as part of<br>\nthe GitHub repository <a href=\"https://github.com/xanonec/HOL-TTS-Ext\">https://github.com/xanonec/HOL-TTS-Ext</a>, where the<br>\ndevelopment takes place.</p>\n<p>The conditions that I am referring to in the previous paragraph are that<br>\nonly the plain definitions are used in the type-based theory (at this<br>\nstage, the relativization of constants obtained using other specification<br>\nelements still needs to be performed explicitly by the user) and that the<br>\ndefinitions do not contain Hilbert choice, definite description operator,<br>\nundefined constants and other possible sources of 'non-determinism'.<br>\nHowever, usually, it is relatively easy to provide the relativization of<br>\nconstants obtained using the specification elements other than 'definition'<br>\nmanually.</p>\n<p>Effectively, the framework provides a convenient tool for synthesizing<br>\nsignificant parts of the libraries of relativized results (e.g.<br>\nHOL-Algebra) from the type-based counterparts in a nearly automated manner<br>\n(e.g. see <a href=\"https://github.com/xanonec/HOL-SML-Relativization\">https://github.com/xanonec/HOL-SML-Relativization</a>).</p>\n<p>I believe that I am reaching the stage at which the work can be considered<br>\nto be nearly feature-complete. Nevertheless, at this stage, I still welcome<br>\nsuggestions for the improvement of the functionality.</p>\n<p>The only downside is that, by now, I also realised that it will take a<br>\nsubstantial amount of time before I can provide a stable release of the<br>\nsoftware. There is still a very substantial amount of software engineering<br>\nwork that needs to be done before this work can be considered to be<br>\ncompleted. Also, it seems that I will not be able to afford to allow myself<br>\nto spend as much time on this project as I was able in the last couple of<br>\nmonths from the beginning of autumn.</p>\n<p>Thank you</p>\n<p>section â€¹Relativization of the results about ordersâ€º<br>\ntheory Simple_Orders<br>\n  imports<br>\n    \"../TTS\"<br>\nbegin</p>\n<p>subsection â€¹Definitions I: user-defined relativizationsâ€º</p>\n<p>locale ord_ow =<br>\n  fixes ğ”˜ :: \"'ao set\"<br>\n    and le :: \"['ao, 'ao] â‡’ bool\" (infix â€¹â‰¤â‡©oâ‡©wâ€º 50)<br>\n    and ls :: \"['ao, 'ao] â‡’ bool\" (infix â€¹&lt;â‡©oâ‡©wâ€º 50)<br>\nbegin</p>\n<p>notation le (â€¹'(â‰¤â‡©oâ‡©w')â€º)<br>\n  and le (infix â€¹â‰¤â‡©oâ‡©wâ€º 50)<br>\n  and ls (â€¹'(&lt;â‡©oâ‡©w')â€º)<br>\n  and ls (infix â€¹&lt;â‡©oâ‡©wâ€º 50)</p>\n<p>abbreviation (input) ge (infix â€¹â‰¥â‡©oâ‡©wâ€º 50) where \"x â‰¥â‡©oâ‡©w y â‰¡ y â‰¤â‡©oâ‡©w x\"<br>\nabbreviation (input) gt (infix â€¹&gt;â‡©oâ‡©wâ€º 50) where \"x &gt;â‡©oâ‡©w y â‰¡ y &lt;â‡©oâ‡©w x\"</p>\n<p>notation ge (â€¹'(â‰¥â‡©oâ‡©w')â€º)<br>\n  and ge (infix â€¹â‰¥â‡©oâ‡©wâ€º 50)<br>\n  and gt (â€¹'(&gt;â‡©oâ‡©w')â€º)<br>\n  and gt (infix â€¹&gt;â‡©oâ‡©wâ€º 50)</p>\n<p>end</p>\n<p>locale preorder_ow = ord_ow ğ”˜ le ls<br>\n  for ğ”˜ :: \"'ao set\" and le ls +<br>\n  assumes less_le_not_le:<br>\n    \"âŸ¦ x âˆˆ ğ”˜; y âˆˆ ğ”˜ âŸ§ âŸ¹ x &lt;â‡©oâ‡©w y âŸ· x â‰¤â‡©oâ‡©w y âˆ§ Â¬ (y â‰¤â‡©oâ‡©w x)\"<br>\n    and order_refl[iff]: \"x âˆˆ ğ”˜ âŸ¹ x â‰¤â‡©oâ‡©w x\"<br>\n    and order_trans: \"âŸ¦ x âˆˆ ğ”˜; y âˆˆ ğ”˜; z âˆˆ ğ”˜; x â‰¤â‡©oâ‡©w y; y â‰¤â‡©oâ‡©w z âŸ§ âŸ¹ x<br>\nâ‰¤â‡©oâ‡©w z\"</p>\n<p>context<br>\n  includes lifting_syntax<br>\nbegin</p>\n<p>lemma preorder_transfer[transfer_rule]:<br>\n  assumes [transfer_rule]: \"right_total A\"<br>\n  shows<br>\n    \"((A ===&gt; A ===&gt; (=)) ===&gt; (A ===&gt; A ===&gt; (=))  ===&gt; (=))<br>\n    (preorder_ow (Collect (Domainp A))) class.preorder\"<br>\n  unfolding preorder_ow_def class.preorder_def<br>\n  apply transfer_prover_start<br>\n  apply transfer_step+<br>\n  by blast</p>\n<p>end</p>\n<p>subsection â€¹Definitions II: automated relativizationâ€º</p>\n<p>tts_unoverload_definitions<br>\n  (\"(â‰¤)::?'a::ordâ‡’?'a::ordâ‡’bool\", \"(&lt;)::?'a::ordâ‡’?'a::ordâ‡’bool\")<br>\n  in lessThan_def (â€¹'(/with _ : (1{..&lt;_})/')â€º)<br>\n    and atMost_def (â€¹'(/with _ : (1{.._})/')â€º)<br>\n    and greaterThan_def (â€¹'(/with _ : (1{_&lt;..})/')â€º)<br>\n    and atLeast_def (â€¹'(/with _ : (1{_..})/')â€º)<br>\n    and greaterThanLessThan_def (â€¹'(/with _ : (1{_&lt;..&lt;_})/')â€º)<br>\n    and atLeastLessThan_def (â€¹'(/with _ _ : (1{_..&lt;_})/')â€º)<br>\n    and greaterThanAtMost_def (â€¹'(/with _ _ : (1{_&lt;.._})/')â€º)<br>\n    and atLeastAtMost_def (â€¹'(/with _ : (1{_.._})/')â€º )<br>\n    and min_def (â€¹'(/with _ : Â«minÂ» _ _/')â€º [1000, 1000, 1000] 1000)<br>\n    and max_def (â€¹'(/with _ : Â«maxÂ» _ _/')â€º [1000, 1000, 1000] 1000)</p>\n<p>tts_relativize_definitions<br>\n  types: (?'a â€¹ğ”˜::'a setâ€º)<br>\n  in lessThan_with_def (â€¹'(/on _ with _ : (1{..&lt;_})/')â€º)<br>\n    and atMost_with_def (â€¹'(/on _ with _ : (1{.._})/')â€º)<br>\n    and greaterThan_with_def (â€¹'(/on _ with _: (1{_&lt;..})/')â€º)<br>\n    and atLeast_with_def (â€¹'(/on _ with _ : (1{_..})/')â€º)<br>\n    and greaterThanLessThan_with_def (â€¹'(/on _ with _ : (1{_&lt;..&lt;_})/')â€º)<br>\n    and atLeastLessThan_with_def (â€¹'(/on _ with _ _ : (1{_..&lt;_})/')â€º)<br>\n    and greaterThanAtMost_with_def (â€¹'(/on _ with _ _ : (1{_&lt;.._})/')â€º)<br>\n    and atLeastAtMost_with_def (â€¹'(/on _ with _ : (1{_.._})/')â€º)<br>\n    and min_with_def<br>\n    and max_with_def</p>\n<p>tts_unoverload_definitions<br>\n  in bdd_above_def (â€¹'(/with _ : Â«bdd'_aboveÂ» _/')â€º)<br>\n    and bdd_below_def (â€¹'(/with _ : Â«bdd'_belowÂ» _/')â€º)</p>\n<p>tts_relativize_definitions<br>\n  types: (?'a â€¹ğ”˜::'a setâ€º)<br>\n  in bdd_above_with_def (â€¹'(/on _ with _ : Â«bdd'_aboveÂ» _/')â€º)<br>\n    and bdd_below_with_def (â€¹'(/on _ with _ : Â«bdd'_belowÂ» _/')â€º)</p>\n<p>subsubsection â€¹Relativization of theoremsâ€º</p>\n<p>context preorder_ow<br>\nbegin</p>\n<p>tts_relativize_facts<br>\n  types: (?'a ğ”˜)<br>\n  substituting preorder_ow_axioms<br>\n  trying auto<br>\n  in preorder_class.less_irrefl<br>\n    and preorder_class.bdd_below_Ioc<br>\n    and preorder_class.bdd_above_Ioc<br>\n    and preorder_class.bdd_above_Iic<br>\n    and preorder_class.bdd_above_Iio<br>\n    and preorder_class.bdd_below_Ici<br>\n    and preorder_class.bdd_below_Ioi<br>\n    and preorder_class.bdd_above_Icc<br>\n    and preorder_class.bdd_above_Ioo<br>\n    and preorder_class.bdd_below_Icc<br>\n    and preorder_class.bdd_below_Ioo<br>\n    and preorder_class.bdd_above_Ico<br>\n    and preorder_class.bdd_below_Ico<br>\n    and preorder_class.Ioi_le_Ico<br>\n    and preorder_class.eq_refl<br>\n    and preorder_class.less_imp_le<br>\n    and preorder_class.less_not_sym<br>\n    and preorder_class.less_imp_not_less<br>\n    and preorder_class.less_asym'<br>\n    and preorder_class.less_imp_triv<br>\n    and preorder_class.less_trans<br>\n    and preorder_class.less_le_trans<br>\n    and preorder_class.le_less_trans<br>\n    and preorder_class.bdd_aboveI<br>\n    and preorder_class.bdd_belowI<br>\n    and preorder_class.less_asym<br>\n    and preorder_class.bdd_above_Int1<br>\n    and preorder_class.bdd_above_Int2<br>\n    and preorder_class.bdd_below_Int1<br>\n    and preorder_class.bdd_below_Int2<br>\n    and preorder_class.bdd_above_mono<br>\n    and preorder_class.bdd_below_mono<br>\n    and bdd_above_empty<br>\n    and preorder_class.bdd_below_empty</p>\n<p>tts_relativize_facts<br>\n  types: (?'a ğ”˜) and (?'b â€¹ğ”˜â‡©2::'b setâ€º)<br>\n  substituting preorder_ow_axioms<br>\n  trying (auto intro: bdd_above_empty bdd_below_empty)<br>\n  in preorder_class.bdd_belowI2<br>\n    and preorder_class.bdd_aboveI2</p>\n<p>end</p>\n<p>tts_statistics</p>\n<p>end</p>\n<hr>\n<p>Automatically generated unoverloaded definitions:</p>\n<p>theorem lessThan_with_def: (with ?less : {..&lt;?u}) â‰¡ {x. ?less x ?u}<br>\ntheorem lessThan_with.overloaded: lessThan â‰¡ lessThan_with (&lt;)<br>\ntheorem atMost_with_def: (with ?less_eq : {..?u}) â‰¡ {x. ?less_eq x ?u}<br>\ntheorem atMost_with.overloaded: atMost â‰¡ atMost_with (â‰¤)<br>\ntheorem greaterThan_with_def: (with ?less : {?l&lt;..}) â‰¡ {x. ?less ?l x}<br>\ntheorem greaterThan_with.overloaded: greaterThan â‰¡ greaterThan_with (&lt;)<br>\ntheorem atLeast_with_def: (with ?less_eq : {?l..}) â‰¡ {x. ?less_eq ?l x}<br>\ntheorem atLeast_with.overloaded: atLeast â‰¡ atLeast_with (â‰¤)<br>\ntheorem greaterThanLessThan_with_def: (with ?less : {?l&lt;..&lt;?u}) â‰¡ (with<br>\n?less : {?l&lt;..}) âˆ© (with ?less : {..&lt;?u})<br>\ntheorem greaterThanLessThan_with.overloaded: greaterThanLessThan â‰¡<br>\ngreaterThanLessThan_with (&lt;)<br>\ntheorem atLeastLessThan_with_def: (with ?less_eq ?less : {?l..&lt;?u}) â‰¡ (with<br>\n?less_eq : {?l..}) âˆ© (with ?less : {..&lt;?u})<br>\ntheorem atLeastLessThan_with.overloaded: atLeastLessThan â‰¡<br>\natLeastLessThan_with (â‰¤) (&lt;)<br>\ntheorem greaterThanAtMost_with_def: (with ?less_eq ?less : {?l&lt;..?u}) â‰¡<br>\n(with ?less : {?l&lt;..}) âˆ© (with ?less_eq : {..?u})<br>\ntheorem greaterThanAtMost_with.overloaded: greaterThanAtMost â‰¡<br>\ngreaterThanAtMost_with (â‰¤) (&lt;)<br>\ntheorem atLeastAtMost_with_def: (with ?less_eq : {?l..?u}) â‰¡ (with ?less_eq<br>\n: {?l..}) âˆ© (with ?less_eq : {..?u})<br>\ntheorem atLeastAtMost_with.overloaded: atLeastAtMost â‰¡ atLeastAtMost_with<br>\n(â‰¤)<br>\ntheorem min_with_def: (with ?less_eq : Â«minÂ» ?a ?b) â‰¡ if ?less_eq ?a ?b<br>\nthen ?a else ?b<br>\ntheorem min_with.overloaded: min â‰¡ min_with (â‰¤)<br>\ntheorem max_with_def: (with ?less_eq : Â«maxÂ» ?a ?b) â‰¡ if ?less_eq ?a ?b<br>\nthen ?b else ?a<br>\ntheorem max_with.overloaded: max â‰¡ max_with (â‰¤)</p>\n<p>theorem bdd_above_with_def: (with ?less_eq : Â«bdd_aboveÂ» ?A) â‰¡ âˆƒM. âˆ€xâˆˆ?A.<br>\n?less_eq x M<br>\ntheorem bdd_above_with.overloaded: bdd_above â‰¡ bdd_above_with (â‰¤)<br>\ntheorem bdd_below_with_def: (with ?less_eq : Â«bdd_belowÂ» ?A) â‰¡ âˆƒm. Ball ?A<br>\n(?less_eq m)<br>\ntheorem bdd_below_with.overloaded: bdd_below â‰¡ bdd_below_with (â‰¤)</p>\n<hr>\n<p>[message truncated]</p>",
        "id": 294761712,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199915
    }
]