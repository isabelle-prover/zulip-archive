[
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:immler@in.tum.de\">immler@in.tum.de</a>&gt;<br>\nOn 8/5/2019 3:37 PM, mailing-list anonymous wrote:</p>\n<blockquote>\n<p>I would like to understand if one was to, hypothetically, implement a<br>\nlarge-scale overhaul of HOL-Algebra using the modern locale features, what<br>\nwould the structure of the new library look like?</p>\n</blockquote>\n<p>I never thought about what a \"modern\" HOL-Algebra would look like.</p>\n<blockquote>\n<p>However, I am still not certain as to what would be the best way to<br>\nstructure the set-based library. At the moment, the development follows the<br>\napproach that merely extends the locales that exist in the main HOL library<br>\nwith an additional locale parameter that represents a carrier set (or<br>\nseveral locale parameters for multiple carrier sets) - this approach is<br>\nconsistent with the existing library of relativised results (primarily,<br>\nabout vector spaces) that was previously developed by Bohua Zhan and Fabian<br>\nImmler. This approach, straightforward as it may seem, has several<br>\nproblems.</p>\n</blockquote>\n<p>All I can say is that we chose the locale-with-carrier approach not <br>\nbecause we thought it was a superior structuring mechanism, but because <br>\nit was easier to deal with in the context of relativising results <br>\nautomatically (e.g., no need to transfer record types).</p>\n<p>Fabian<br>\n<a href=\"/user_uploads/14278/Lw5zfidkKGrD7vMeFB10PaQW/smime.p7s\">smime.p7s</a></p>",
        "id": 294761247,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199683
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nHi,</p>\n<p>Here are my thoughts on this topic. I have played around with various <br>\noptions that you mention and I also ran into the problems you mentioned.</p>\n<p>Records in Isabelle/HOL provide only one extension slot. So fields must <br>\nbe added linearly. You cannot have one record (such as partial_object) <br>\nbe extended independently (ord and topology) and then later combine <br>\nthem. To do that smoothly, we would need to have a unification mechanism <br>\nthat can work modulo type isomorphisms, which basically adds the <br>\nconversions as needed. The coercions functionality implements something <br>\nlike that, but I could never get this to work properly because the <br>\nconversions are added during parsing and not during reasoning. I'm <br>\npretty sure, though, that one could implement such a coercion insertion <br>\nalgorithm, at least for first-order unification or higher-order pattern <br>\nmatching, in Isabelle/ML. Yet, this would not be integrated with all the <br>\nproof methods (simp, clarify, auto, ...) and therefore of little use.</p>\n<p>In my AFP entry Monomorphic_Monad [1], I therefore gave up on using <br>\nrecords and went for listing every parameter individually. I found that <br>\nI could get a long way by judiciously using nested<br>\n\"context fixes ... begin\" with interspersed \"interpretation\" commands.</p>\n<p>This approach works well with higher-order unification and all proof <br>\ntools. The main drawback is that the terms get rather large, in <br>\nparticular if you stack several algebraic constructions on top of each <br>\nother. Consequently, type checking the terms and folding the <br>\nabbreviations for displaying terms may get slow.</p>\n<p>If your types are sufficiently distinct, the notation problem can be <br>\nworked around with adhoc_overloading as follows:</p>\n<ol>\n<li>Define an uninterpreted constant for each operation of the right <br>\narity and attach the notation to it. For example,</li>\n</ol>\n<p>consts plus :: \"'a =&gt; 'a =&gt; 'a\"<br>\nnotation plus (infixl \"\\&lt;oplus&gt;\" 65)</p>\n<ol start=\"2\">\n<li>Register on demand the operations for which you want to use the notation:</li>\n</ol>\n<p>context<br>\n   fixes plus1 :: \"'a =&gt; 'a =&gt; 'a\"<br>\n   and plus2 :: \"'b =&gt; 'b =&gt; 'b\"<br>\nbegin</p>\n<p>adhoc_overloading plus plus1<br>\nadhoc_overloading plus plus2</p>\n<p>You can now use \\&lt;oplus&gt; for both plus1 and plus2 in your lemmas <br>\nprovided that type inference can unoverload all occurrences. You may <br>\nhave to add occasional type constraints. Clearly, this does not work if <br>\nthe types overlap.</p>\n<p>Finally, here's another proposal that might be worth a try: unrestricted <br>\noverloading. If Isabelle/HOL had multi-parameter type classes, we could <br>\nformalize all these things as type classes. In Haskell, we'd say</p>\n<p>class PartialObject a b where carrier :: a =&gt; b set</p>\n<p>with a dependency from a to b, i.e., if a is known, then so is b. In <br>\nIsabelle/HOL, type class operations may only have one type parameter, so <br>\nthis does not work directly. However, type classes are internally <br>\nimplemented with unrestricted overloading + some type inference magic. <br>\nSo we can achieve something if we don't care too much about the type <br>\ninference convenience. Here's a sketch:</p>\n<p>consts<br>\n   carrier :: \"'a =&gt; 'b set\"<br>\n   le :: \"'a =&gt; 'b =&gt; 'b =&gt; bool\"<br>\n   tau :: \"'a =&gt; 'b set =&gt; bool\"</p>\n<p>Here, the algebraic structure is left abstract as \"'a\" and you phrase <br>\nall your definitions and theorems such that the structure is always an <br>\nabstract type.</p>\n<p>For example, to specify that a structure of type 'a is an order on <br>\nelements of type 'b, you'd write</p>\n<p>definition order :: \"'a itself =&gt; 'b itself =&gt; bool\" where<br>\n   \"order G _ = (ALL x :: 'b. x \\&lt;in&gt; carrier G --&gt; le G x x) &amp; ...\"</p>\n<p>In practice, you'll have to add many type constraints to guide type <br>\ninference into the right direction. This can be alleviated with custom <br>\nsyntax that shortens the type syntax. An example for this is the <br>\nCARD('a) syntax from HOL-Library.Cardinality [2]. So you'd write</p>\n<p>\"ORDER('b) G\"</p>\n<p>instead of</p>\n<p>\"order G (Pure.type :: 'b itself)\"</p>\n<p>and \"CARRIER('b) G\" instead of \"carrier G :: 'b set\"</p>\n<p>Combining two structures in this way is then very simple, as the <br>\ndefinitions and proofs do not assume any particular repesentation of the <br>\nstructure. Accordingly, I'd recommend to also do constructions <br>\nabstractly. For example, the product construction would look like</p>\n<p>datatype ('a1, 'a2) product = Product (proj1: 'a1) (proj2: 'a2)</p>\n<p>overloading<br>\n   carrier_product == \"carrier :: ('a1, 'a2) product =&gt; ('b1 * 'b2) set\"<br>\nbegin</p>\n<p>definition carrier_product :: \"('a1, 'a2) product =&gt; ('b1 * 'b2) set\"<br>\nwhere<br>\n   \"carrier_product G =<br>\n    CARRIER('b1) (proj1 G) &lt;*&gt;<br>\n    CARRIER('b2) (proj2 G)\"</p>\n<p>end</p>\n<p>Here, I've introduced a separate type \"product\" for the generic product <br>\nconstruction such that we keep the types of abstract constructions (like <br>\nproducts) separate from types that may show up in normal applications <br>\n(like the type constructor for pairs).</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>[1] <a href=\"https://www.isa-afp.org/entries/Monomorphic_Monad.html\">https://www.isa-afp.org/entries/Monomorphic_Monad.html</a></p>\n<p>[2] <br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/5c1b2f616d15/src/HOL/Library/Cardinality.thy#l33\">http://isabelle.in.tum.de/repos/isabelle/file/5c1b2f616d15/src/HOL/Library/Cardinality.thy#l33</a></p>",
        "id": 294761289,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199708
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Fabian Immler and Andreas Lochbihler,</p>\n<p>Thank you very much for your replies.</p>\n<p>I believe that records with the support for multiple inheritance would<br>\nbe exceptionally useful for Isabelle/HOL users. However, I guess, it<br>\nwould be too much to hope that this technology will become available<br>\nin the near future.</p>\n<p>Having, to an extent, tried the various approaches that I was aware of<br>\nbefore asking the question and, also, the methods suggested by Andreas<br>\nLochbihler, I am beginning to converge on the thought that, for my use<br>\ncase, the best methodology might be the one that I am already using<br>\n(i.e. the methodology similar to the one used by Bohua Zhan and Fabian<br>\nImmler in their development). Unfortunately, by now, I have completely<br>\nconvinced myself that records are not suitable for libraries with<br>\ncomplex locale inheritance trees, primarily, due to the absence of<br>\nsupport for multiple inheritance.</p>\n<p>I liked the method proposed by Andreas Lochbihler that uses constants<br>\nparameterised by the spaces/algebraic structures themselves. However,<br>\neven ignoring the problem of the type inference, I am not certain how<br>\nwould one deal with the interpretation of the theorems stated for the<br>\nparametric constants using suitable arbitrary user-supplied terms.<br>\nWould it not be necessary for the users to combine and abstract the<br>\nterms as an element of some newly designed type before the can be<br>\nachieved? In this case, as it seems, making the interpretation<br>\nmechanism as convenient for the users as the locale interpretation for<br>\nthe approach that is used at the moment would require a substantial<br>\namount of effort for the developer.</p>\n<p>Thank you</p>",
        "id": 294761361,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661199732
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I would like to ask a question in the context of one of the existing<br>\nthreads:<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-April/msg00090.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-April/msg00090.html</a><br>\n.</p>\n<p>To set the context for the question, I would like to provide two quotes<br>\nfrom the aforementioned thread:</p>\n<p>On Fri, 12 Apr 2019 22:36:17 Clemens Ballarin wrote:</p>\n<p>&gt;</p>\n<p>... The approach of combining locales with records dates back to that time.</p>\n<blockquote>\n<p>Definitions in locales were unavailable, and the solution was to extract<br>\nthe signature part of an algebraic structure into a record, on which<br>\ndefinitions could be made globally.  ...</p>\n</blockquote>\n<p>On Fri, 12 Apr 2019 22:51:32 Manuel Eberl wrote (in reply to the comments<br>\nmade by Clemens Ballarin on Fri, 12 Apr 2019 22:36:17):</p>\n<p>&gt;</p>\n<p>... That's interesting. It would certainly be of interest to think of a</p>\n<blockquote>\n<p>large-scale overhaul of HOL-Algebra using modern locale features. ...<br>\n</p>\n</blockquote>\n<p>I would like to understand if one was to, hypothetically, implement a<br>\nlarge-scale overhaul of HOL-Algebra using the modern locale features, what<br>\nwould the structure of the new library look like? Would the records still<br>\nbe used or would it be implemented in the style of the main HOL library<br>\nwith all parameters stated explicitly and all definitions stated implicitly<br>\nin the locale context? Would it be too much to ask to provide a small<br>\nexample that demonstrates this modern approach based on the existing<br>\nlocales in HOL-Algebra?</p>\n<p>The primary reason why I am asking the question is that I would like to<br>\nunderstand what is considered to be a canonical methodology for the<br>\nimplementation of a library about abstract spaces/algebraic structures with<br>\nthe explicit carrier sets using locales.</p>\n<hr>\n<p>I provide further (and, perhaps, superfluous) details with regard to my<br>\nenquiry. I am working on the relativization of the main HOL library using<br>\nTypes-To-Sets: <a href=\"https://github.com/xanonec/HOL-SML-Relativization\">https://github.com/xanonec/HOL-SML-Relativization</a>. I believe<br>\nthat this development directly addresses some of the existing concerns of<br>\nthe users of HOL. For example, in the context of the previously referenced<br>\nthread:</p>\n<p>On Sat, 13 Apr 2019 10:37:23 Dominique Unruh wrote:</p>\n<blockquote>\n<p>The classes have the advantage of being easier to use than locales in many<br>\ncases (at least I feel that way), but they have the limitation of always<br>\nhaving UNIV as the carrier.<br>\n</p>\n</blockquote>\n<p>As far as I know, all proofs are simply done twice. And someone building a</p>\n<blockquote>\n<p>development on these things needs to pick on approach and is then \"locked<br>\nin\", which is problematic, since some material is only available in the HOL<br>\napproach and some only in the HOL-Algebra approach. In case of an overhaul,<br>\nperhaps these concepts could be unified as well?</p>\n</blockquote>\n<blockquote>\n<p>My own development, effectively, unifies both approaches using<br>\nTypes-To-Sets as the conceptual glue. The proofs of the set-based theorems<br>\nno longer need to be stated explicitly: the type-based theorems from the<br>\nmain library are converted to the set-based theorems automatically.<br>\nMoreover, the adopted methodology explicitly establishes an injection<br>\n(potentially, there can be several distinct relativisations of the same<br>\ntype-based theorem) from the set-based theorems to the type-based theorems<br>\nand this injection can be visualised using the features of the framework.</p>\n</blockquote>\n<p>However, I am still not certain as to what would be the best way to<br>\nstructure the set-based library. At the moment, the development follows the<br>\napproach that merely extends the locales that exist in the main HOL library<br>\nwith an additional locale parameter that represents a carrier set (or<br>\nseveral locale parameters for multiple carrier sets) - this approach is<br>\nconsistent with the existing library of relativised results (primarily,<br>\nabout vector spaces) that was previously developed by Bohua Zhan and Fabian<br>\nImmler. This approach, straightforward as it may seem, has several<br>\nproblems. Firstly, whenever reasoning about the spaces/algebraic structures<br>\nthemselves, the long list of the locale parameters always needs to be<br>\nprovided explicitly in each theorem. This problem is exaggerated further<br>\nwhenever dealing with pairs/triples of spaces/algebraic structures - the<br>\nlists of parameters can become dramatically long. For example, a context<br>\nthat describes a pair of complete lattices would look similar to (of<br>\ncourse, explicit context can be replaced with a locale named, for example,<br>\ncomplete_lattice_pair_ow, but the problem remains the same)</p>\n<p>context<br>\n  fixes ùîòA :: \"'at set\"<br>\n  fixes ùîòB :: \"'bt set\"<br>\n  fixes lea leb<br>\n    and lsa lsb<br>\n    and infa infb<br>\n    and supa supb<br>\n    and bota botb<br>\n    and topa topb<br>\n    and Infa Infb<br>\n    and Supa Supb<br>\n  assumes clow_a: \"complete_lattice_ow ùîòA Infa Supa infa lea lsa supa bota<br>\ntopa\"<br>\n  assumes clow_b: \"complete_lattice_ow ùîòB Infb Supb infb leb lsb supb botb<br>\ntopb\"</p>\n<p>Furthermore, the notation associated with the locale parameters for a<br>\nsingle space/algebraic structure, as far as I know, cannot be reused<br>\ndirectly when dealing with pairs/triples of spaces/algebraic structures due<br>\nto overlaps. Also, I am not aware of any methodology that would enable one<br>\nto make the notation associated with the locale parameters to depend on,<br>\nfor example, other locale parameters. In the context of the example above,<br>\nif one is to define the notation for Infa as (‚Äπ‚®Ö‚á©o‚á©w‚á©a‚Ä∫), then it becomes<br>\nnon-sensical if ùîòA is interpreted as a set named ùîòB and ùîòB is<br>\ninterpreted as a set named ùîòA. The same problem also occurs when trying to<br>\ntransfer the notation for the implicit definitions (i.e. definitions stated<br>\nin a locale context) from a single space/algebraic structure to a pair of<br>\nspaces/algebraic structures. Moreover, even restating the notation for the<br>\nlocale parameters and implicit definitions when providing the locales for<br>\nthe pairs/triples of algebraic structures/abstract spaces can be a very<br>\nirritating, tedious and error-prone process that results in a substantial<br>\namount of seemingly boilerplate code.</p>\n<p>I believe that the use of records/schemes with the explicitly stated<br>\ndefinitions (i.e. outside of the context of locales), as archaic as it may<br>\nseem, resolves all of the aforementioned issues. However, the lack of<br>\nsupport for multiple inheritance creates its own problems. While in some<br>\ncases, using a scheme that has more fields than necessary is bearable (as<br>\nthe referenced example from HOL-Algebra demonstrates), in certain cases, it<br>\nbecomes impossible. For example, in my attempt to use records/structures in<br>\nthe library of relativised results, I defined</p>\n<p>record 'a ord =  \"'a partial_object\" +<br>\n  le :: \"['a, 'a] ‚áí bool\" (infix ‚Äπ‚äëƒ±‚Ä∫ 50)<br>\n  ls :: \"['a, 'a] ‚áí bool\" (infix ‚Äπ‚äèƒ±‚Ä∫ 50)</p>\n<p>and</p>\n<p>record 'a topology = \"'a partial_object\" +<br>\n  œÑ :: \"'a set ‚áí bool\" (‚ÄπœÑƒ±‚Ä∫)</p>\n<p>Now, I would like to define an order topology. It does not seem that<br>\nrecords provide a natural way to combine the two concepts together. The<br>\nbest methodology that I was able to come up with is exhibited via the<br>\nfollowing locale that uses two structures:</p>\n<p>locale order_topology_ow =<br>\n  order_ow ùí™ for ùí™ :: \"('at, 'bt) ord_scheme\" (structure) +<br>\n  fixes ùíØ :: \"('at, 'bt) topology_scheme\" (structure)<br>\n    and ùîò :: \"'at set\"<br>\n  assumes ùîòùí™: \"ùîò = carrier ùí™\"<br>\n    and ùîòùíØ: \"ùîò = carrier ùíØ\"<br>\n    and open_generated_order:<br>\n      \"s ‚äÜ ùîò ‚üπ œÑ‚áòùíØ‚áô s = generate_topology_on ((Œªa. {..‚äèa}) <code> ùîò ‚à™ (Œªa.\n{a‚äè..}) </code> ùîò) ùîò s\"</p>\n<p>In my view, this approach is still better than providing all definitional<br>\nelements explicitly. However, this approach is still quite limiting and, in<br>\ncertain cases, even the list of schemes can become quite long.</p>\n<p>I would be curious to know if anyone has dealt with similar problems in the<br>\npast and knows a solution that is better than using explicitly listed<br>\nparameters. Alternatively, perhaps, someone could suggest a canonical<br>\napproach for combining two distinct schemes into one scheme with a 'shared'<br>\nfield.</p>\n<p>Thank you</p>",
        "id": 294761988,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200058
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I would like to submit a short errata for two of my posts in the thread<br>\n\"Revisiting records, structures, locales, abelian_group, HOL-Algebra and<br>\nTypes-To-Sets\". Unfortunately, recently, I noticed that my posts contain<br>\ntwo grievous errors (I believe that it is best to classify them as<br>\ntypographical errors because I am unable to identify their root cause):</p>\n<p>The first error occurs in the statement of the question (<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00006.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00006.html</a><br>\n):</p>\n<blockquote>\n<p>... the adopted methodology explicitly establishes an injection<br>\n(potentially, there can be several distinct relativisations of the same<br>\ntype-based theorem) from the set-based theorems to the type-based theorems<br>\n...</p>\n<p>Of course, the excerpt above can be interpreted as equivalent to<br>\n(‚àÄf::sb_to_tb. injective f) ‚àß (‚àÉf::sb_to_tb. ¬¨injective f) and, of course,<br>\nmy goal was to emphasize that a function that maps the set-based theorems<br>\nto their type-based counterparts (represented as a term of a type sb_to_tb<br>\nabove) is not, necessarily, injective. I am not certain why I stated that<br>\nthe function of this type is always injective immediately before stating<br>\nthat there exist non-injective functions of this type.</p>\n</blockquote>\n<p>The second error occurs in my first answer in the thread (<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00020.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-August/msg00020.html</a><br>\n):</p>\n<blockquote>\n<p>...locale inheritance trees...</p>\n<p>Of course, I meant to use the word 'graphs' instead of the word 'trees' and<br>\nthe phrase 'sublocale relations' instead of 'locale inheritance'.</p>\n</blockquote>\n<p>Please accept my sincere apologies for making these errors. I will try to<br>\nbe more careful in the future.</p>\n<p>Thank you</p>\n<p>On Mon, Aug 5, 2019 at 4:37 PM mailing-list anonymous &lt;<br>\n<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear All,</p>\n<p>I would like to ask a question in the context of one of the existing<br>\nthreads:</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-April/msg00090.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2019-April/msg00090.html</a><br>\n.</p>\n<p>To set the context for the question, I would like to provide two quotes<br>\nfrom the aforementioned thread: ...</p>\n<p>--<br>\nPlease accept my apologies for posting anonymously. This is done to<br>\nprotect my privacy. I can make my identity and my real contact details<br>\navailable upon request in private communication under the condition that<br>\nthey are not to be mentioned on the mailing list.</p>\n<p>...</p>\n</blockquote>",
        "id": 294762180,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200155
    }
]