[
    {
        "content": "<p>From: Zhe Hou &lt;<a href=\"mailto:zhe.hou@hotmail.com\">zhe.hou@hotmail.com</a>&gt;<br>\nHi,</p>\n<p>I found that Isabelle doesn’t round negative fractions in the way I expected. For example, I expect</p>\n<p>(18406909::int) div (- 2240)</p>\n<p>to be -8217, but Isabelle says it’s -8218. I tried it in a few other languages such as Ocaml, C++. They all reported -8217. In SML, the rounding mode IEEEReal.TO_NEGINF results in -8218.</p>\n<p>However, Isabelle says </p>\n<ul>\n<li>((18406909::int) div 2240)</li>\n</ul>\n<p>is -8217.</p>\n<p>As a result, I can prove the following in Isabelle (2015 version):</p>\n<p>lemma \"(18406909::int) div (- 2240) ≠ - ((18406909::int) div (2240))\"<br>\nby auto</p>\n<p>I think this is unusual. If anyone could point me to an alternative way to do division in Isabelle, I’d be very grateful.</p>\n<p>Thank you.</p>\n<p>Zhe</p>",
        "id": 294655578,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167898
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nDear Zhe, thanks for your query.</p>\n<p>I don’t have a book with me at the moment to cite, but my understanding is that mathematicians normally define the sign of the remainder to match that of the divisor. Thus 1 div 2 = 0 with remainder 1, but 1 div ~2 = -1 with remainder -1. (And -1 * -2 + -1 = 2-1 = 1.) </p>\n<p>The sources I could find online didn’t seem to define division in the case of a negative divisor. However, note that -1 div 2 = -1 and -1 mod 2 = 1. When the divisor is positive, a negative remainder is definitely wrong.</p>\n<p>Standard ML was designed to follow this classical definition. Isabelle’s number theory libraries do the same. However, computer hardware designers (either because they didn’t know better, or to keep circuits as simple as possible) adopted the same sign rules for division as for multiplication. Languages such as C and OCaml give you what the hardware gives you. For example, OCaml gives -1 / 2 = 0 and -1 mod 2 = -1. These answers are simply wrong.</p>\n<p>Larry Paulson</p>",
        "id": 294656805,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168363
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Zhe,</p>\n<blockquote>\n<p>I don’t have a book with me at the moment to cite, but my<br>\nunderstanding is that mathematicians normally define the sign of the<br>\nremainder to match that of the divisor. Thus 1 div 2 = 0 with remainder<br>\n1, but 1 div ~2 = -1 with remainder -1. (And -1 * -2 + -1 = 2-1 = 1.)</p>\n</blockquote>\n<p>that is easily made plausible: the units of a ring (in case of int, +1<br>\nand -1) form a field.  In this segment you expect the conventional rules<br>\nof field division to hold:<br>\n    +1 div +1 = +1<br>\n    -1 div +1 = -1<br>\n    +1 div -1 = -1<br>\n    -1 div -1 = -1<br>\nAnd also<br>\n    a div b = (sgn a * abs a) div (sgn b * abs b) = (sgn a div sgn b) *\n(abs a div abs b)<br>\nwhere »abs a div abs b« is already explained and »sgn a * abs a« follows<br>\nthe rules above.</p>\n<p>The sign rules for mod follow naturally using the obviously desirable facts:<br>\n    b &lt;&gt; 0 ==&gt; a * b div b = a<br>\n    a div b * b + a mod b = a</p>\n<p>As far as I understand at the moment, this generalizes to each euclidean<br>\nring.</p>\n<p>So, the sign rules are computationally confusing at first sight, but<br>\nmake perfect sense from an algebraic point of view.</p>\n<p>Hope this helps,<br>\n    Florian</p>\n<blockquote>\n<p>The sources I could find online didn’t seem to define division in the case of a negative divisor. However, note that -1 div 2 = -1 and -1 mod 2 = 1. When the divisor is positive, a negative remainder is definitely wrong.</p>\n<p>Standard ML was designed to follow this classical definition. Isabelle’s number theory libraries do the same. However, computer hardware designers (either because they didn’t know better, or to keep circuits as simple as possible) adopted the same sign rules for division as for multiplication. Languages such as C and OCaml give you what the hardware gives you. For example, OCaml gives -1 / 2 = 0 and -1 mod 2 = -1. These answers are simply wrong.</p>\n<p>Larry Paulson</p>\n<p>On 1 Oct 2015, at 04:09, Zhe Hou &lt;<a href=\"mailto:zhe.hou@hotmail.com\">zhe.hou@hotmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I found that Isabelle doesn’t round negative fractions in the way I expected. For example, I expect</p>\n<p>(18406909::int) div (- 2240)</p>\n<p>to be -8217, but Isabelle says it’s -8218. I tried it in a few other languages such as Ocaml, C++. They all reported -8217. In SML, the rounding mode IEEEReal.TO_NEGINF results in -8218.</p>\n<p>However, Isabelle says </p>\n<ul>\n<li>((18406909::int) div 2240)</li>\n</ul>\n<p>is -8217.</p>\n<p>As a result, I can prove the following in Isabelle (2015 version):</p>\n<p>lemma \"(18406909::int) div (- 2240) ≠ - ((18406909::int) div (2240))\"<br>\nby auto</p>\n<p>I think this is unusual. If anyone could point me to an alternative way to do division in Isabelle, I’d be very grateful.</p>\n<p>Thank you.</p>\n<p>Zhe</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/X-YzEtVyl2JaEvNJBdsNtNxu/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294657618,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168702
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 01.10.2015 17:19, Florian Haftmann wrote:</p>\n<blockquote>\n<p>that is easily made plausible: the units of a ring (in case of int, +1<br>\nand -1) form a field.  In this segment you expect the conventional rules<br>\nof field division to hold:<br>\n[...]<br>\n  -1 div -1 = -1</p>\n</blockquote>\n<p>I guess you meant \"-1 div -1 = +1\"?</p>",
        "id": 294657827,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168769
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Zhe,</p>\n<p>Larry and Florian already wrote about why division on integers in Isabelle is defined the <br>\nway it is. If you want a different behaviour for division, you must define your own <br>\ndivision operator. Fortunately, you can achieve this probably quite easily by doing a few <br>\ncase distinctions on the sign of the operands. In my AFP entry JinjaThreads, I have done <br>\nsomething similar for division and modulo on fixed-size integers ('a word), because the <br>\ndivision operation in HOL-Word did not match the sign rules of Java. Have a look at the <br>\ntheory JinjaThreads/Common/BinOp.thy (search for word_sdiv); maybe this gives you some <br>\ninspiration.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294657983,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168836
    }
]