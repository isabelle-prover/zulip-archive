[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@ipd.info.uni-karlsruhe.de\">lochbihl@ipd.info.uni-karlsruhe.de</a>&gt;<br>\nHi,</p>\n<p>induction over a nested datatype usually involves two statements being <br>\ngiven to the induct method simultaneously. However, if the inductive <br>\nhypotheses for the constructors with the nested recursion are not <br>\nneeded, the statement about the nested case is not needed.</p>\n<p>For example:</p>\n<p>datatype dt = A<br>\n            | B dt \"dt list\"<br>\n            | C dt</p>\n<p>inductive foo :: \"dt =&gt; nat =&gt;  bool\"<br>\n   and foos :: \"dt list =&gt; nat =&gt; bool\"<br>\nwhere<br>\n   \"foo A 0\"<br>\n| \"[| foo dt n; foos dts n |] ==&gt; foo (B dt dts) n\"<br>\n| \"foo dt n ==&gt; foo (C dt) n\"<br>\n| \"foos [] n\"<br>\n| \"[| foo dt n; foos dts m |] ==&gt; foos (dt # dts) m\"</p>\n<p>lemma \"foo dt 1 ==&gt; False\"<br>\napply(induct dt)<br>\napply(auto elim: foo.cases)<br>\ndone</p>\n<p>Here, induct automatically figures out the approriate induction rule and <br>\nleaves the induction hypothesis for the list case open. However, this <br>\ndoes not give the cases as nicely as the induction rule provided by the <br>\ninductive package, in particular if foo/foos has far more cases.<br>\nHowever, if I want to prove the lemma with the induction rule for foo <br>\nand foos, I was only able to prove the lemma with a senseless second <br>\nstatement</p>\n<p>lemma \"foo dt 1 ==&gt; False\"<br>\n   and \"foos dts n ==&gt; True\"<br>\napply(induct dt n==\"1::nat\" rule: foo_foos.inducts)<br>\napply(auto)<br>\ndone</p>\n<p>So, is there an induction rule for foo/foos with which the second <br>\nstatement does not have to be written or a trick to tell induct that <br>\nonly one statement is relevant and the other is supposed to be left open?</p>\n<p>Andreas</p>",
        "id": 294063477,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824579
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe \"induct\" method merely uses the provided rules in a uniform way.  To <br>\nget the desired effect you need to produce a rule where the unwanted <br>\nbranches are specialized to \"True\", and maybe redundant occurences of such <br>\ntrivial statements are simplified. For larger inductive definitions this <br>\nis quite tedious.  In fact the inductive package could do it for you, and <br>\nprobably will so in the future.</p>\n<p>At the moment your example already represents the usual way to do it: <br>\nmerely state additional statements that will be ignored in the final <br>\nresult.  Inserting \"x : A ==&gt; True\" in the goal is much shorter than <br>\nwriting down long induction rule statements for this special case, unless <br>\nyou do that projected induction very often.</p>\n<p>Makarius</p>",
        "id": 294063493,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824585
    }
]