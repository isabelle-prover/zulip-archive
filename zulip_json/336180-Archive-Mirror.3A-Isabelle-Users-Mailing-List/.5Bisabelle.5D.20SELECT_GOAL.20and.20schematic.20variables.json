[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi all,</p>\n<p>I recently spotted down a problem with SELECT_GOAL and schematic<br>\nvariables. If new schematic variables are produced in the proof of the<br>\nselected goal, their names may clash with existing schematics in the<br>\nouter proof state, resulting in unexpected error messages:</p>\n<p>inductive P for x where I: \"P x\"<br>\n  lemma J: \"P (\\&lt;lambda&gt;_. R)\" by (rule I)</p>\n<p>schematic_lemma \"\\&lt;And&gt;a. P (?R a) \\&lt;or&gt; P (?R)\" \"TERM ?R3\"<br>\n    apply -<br>\n    apply (tactic {* SELECT_GOAL (<br>\n      rtac @{thm disjI2} 1 THEN rtac @{thm J} 1 <br>\n      (<em>THEN PRIMITIVE zero_var_indexes</em>)<br>\n      THEN print_tac \"Proof state after inner tactic\"<br>\n      ) 1<br>\n      *})</p>\n<p>*** exception TYPE raised (line 109 of \"envir.ML\"):<br>\n*** Variable \"?R3\" has two distinct types<br>\n*** 'c<br>\n*** 'd</p>\n<p>What happened here is that the tactic inside SELECT_GOAL produced the<br>\nproof state: \"\\&lt;And&gt;a b. P ?R3 \\&lt;or&gt; P (\\&lt;lambda&gt;_. ?R3)\"<br>\nAnd when retrofitting this into the outer proof state, ?R3 happens to<br>\nclash with the ?R3 there.</p>\n<p>Moreover, if one directly changes schematic variables that occur in the<br>\nselected goal, like the \"zero_var_indexes\" does in the commented out<br>\nline of the example, the unifier runs havoc and produces errors like:</p>\n<p>*** mk_ff_list<br>\n*** At command \"apply\" (line 9 of<br>\n\"/home/lammich/lehre/praktWS1112/cava/Libs/Refine/Autoref/Scratch.thy\")</p>\n<p>(I also got some exceptions about \"Var name confusion\" from the unifier,<br>\nthat I cannot reproduce any more)</p>\n<p>These observations result in two main questions:</p>\n<p>1. What are the conventions that tactics must stick to when<br>\ninstantiating schematic variables? E.g. is it ok to do <br>\n  PRIMITIVE zero_var_indexes or not?</p>\n<p>2. Is SELECT_GOAL implemented correctly and was never supposed to <br>\n    work with schematics, or should it be fixed?</p>\n<p>Regards and thanks for any comments/workarounds on this,<br>\n  Peter</p>",
        "id": 294236956,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905199
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI'm afraid that I really can't answer this question without a time machine.</p>\n<p>In the early days, I must have introduced SELECT_GOAL in the context of some specific application where it worked fine. Then it got put in the standard libraries of tacticals and more or less forgotten. I know that a lot of derivations that involve new variables in sub-proofs can go wrong as you describe. The usual method of getting around such problems was to freeze variables prior to applying the tactic, thawing them afterwards. That was a hack, but it generally worked. My impression is that Makarius has replaced such trickery by more robust methods, but it's possible that quite a lot about old code is still there and running. I'm not sure about the current best practice for dealing with this sort of situation.</p>\n<p>Larry Paulson</p>",
        "id": 294237518,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905438
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nUnfortunately, this problem does not only affect the (admittedly<br>\nlow-level) SELECT_GOAL, but also high-level proof scripts, as the<br>\nfollowing example demonstrates:</p>\n<p>inductive P for x where I: \"P x\"<br>\n  lemma J: \"P (\\&lt;lambda&gt;_. R)\" by (rule I)</p>\n<p>schematic_lemma \"\\&lt;And&gt;a b. P (?R a) \\&lt;or&gt; P (?R)\" \"TERM ?R4\"<br>\n    apply (rule disjI2, rule J) []<br>\n*** exception TYPE raised (line 109 of \"envir.ML\"):<br>\n*** Variable \"?R4\" has two distinct types<br>\n*** 'c<br>\n*** 'd</p>\n<p>note that everything works fine without the [].</p>",
        "id": 294237526,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905445
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 22 Mar 2013, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I'm afraid that I really can't answer this question without a time <br>\nmachine.</p>\n</blockquote>\n<p>In principle the time machine is Mercurial, but it also takes time to <br>\nstudy our immense history that has accumulated since changeset 0 from <br>\nSep-16 12:20:38 1993 (and more years of unwritten history before that).</p>\n<blockquote>\n<p>The usual method of getting around such problems was to freeze variables <br>\nprior to applying the tactic, thawing them afterwards. That was a hack, <br>\nbut it generally worked. My impression is that Makarius has replaced <br>\nsuch trickery by more robust methods, but it's possible that quite a lot <br>\nabout old code is still there and running. I'm not sure about the <br>\ncurrent best practice for dealing with this sort of situation.</p>\n</blockquote>\n<p>The ancient freeze_thaw and freeze_thaw_robust (which were actually both <br>\nfragile) have evolved over a long way to become the current FOCUS <br>\ncombinators, which are also mentioned in the \"implementation\" manual.</p>\n<p>This Isar technology for structured tactic programming is useful in many <br>\nsituations, but it does not really cover the schematic goal approach that <br>\nPeter appears to use a lot.  In fact, the continued retreat of genuine <br>\nlogic-programming with schematic variables in Isabelle tactics over the <br>\nyears had paved the way for these more recent high-level tacticals.</p>\n<p>Readers of the old \"intro\" manual by Larry might remember the final Prolog <br>\nexample.  Such techniques are now extremely rare, so it is no surprise <br>\nthat certain tools choke.</p>\n<p>(I will have a close look later at what is actually happening here, when I <br>\nhave catched up with various other open threads.)</p>\n<p>Makarius</p>",
        "id": 294237542,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905451
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI've had a first round of studying 10-15 years of Isabelle source history <br>\nyesterday.</p>\n<p>SELECT_GOAL and Subgoal.FOCUS represent different strands of tradition, <br>\nonly the latter (much younger) uses high-end Isar infrastructure -- <br>\ncontext import/export operations that vaguely resemble old \"freeze_thaw\" <br>\nby Larry.</p>\n<p>SELECT_GOAL is also used for the \"[...]\" notation for Isar proof methods.</p>\n<p>SELECT_GOAL was good old code by Larry in the nostalgic style of 1980-ies <br>\nIsabelle until 31-Aug-2001. Then Stefan Berghofer \"Tidied function <br>\nSELECT_GOAL\".  I think before and after the behaviour wrt. newly invented <br>\nschematic was the same as it is still now.  Much later I merely modified <br>\nits internal terminology and general setup to make it look more like <br>\nSubgoal.FOCUS, e.g. using certain \"extract\" and \"retrofit\" operations.</p>\n<p>Beyond historical anecdotes, I have made one round of experiments to see <br>\nif SELECT_GOAL can be converged a bit more towards the way how the (very <br>\nsophisticated) Subgoal.FOCUS works, but it breaks various classic tactics. <br>\nReasons still need to be explored, I can say more after the next round of <br>\ninvestigation.</p>\n<p>Makarius</p>",
        "id": 294240369,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906708
    }
]