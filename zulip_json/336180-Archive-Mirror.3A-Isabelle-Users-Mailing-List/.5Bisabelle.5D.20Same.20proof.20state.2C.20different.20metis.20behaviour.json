[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>Am Donnerstag, den 04.10.2012, 10:57 +0200 schrieb Jasmin Blanchette:</p>\n<blockquote>\n<p>Could you specify precisely which version of Nominal2 and of Isabelle you're using? I'm using the latest of both and get this error from Nominal2:</p>\n</blockquote>\n<p>I am using 87d1e815aa59 for Nominal2, but it is reproducible with the<br>\ntarball from <a href=\"http://isabelle.in.tum.de/nominal/download\">http://isabelle.in.tum.de/nominal/download</a>; both on the<br>\nIsabelle2012 release.</p>\n<blockquote>\n<p>That certainly sounds strange. Are the goals really identical, or is<br>\none using metaequality and the other object-level equality?</p>\n</blockquote>\n<p>Well, they looked identical... until Andreas told me about <br>\n  using [[eta_contract=false]]<br>\nand now one (the working) has<br>\n    ⋀p∷perm. p ∙ (λa∷'a fset. fset a) = (λa∷'a fset. fset a)<br>\nand the other has<br>\n    ⋀p∷perm. p ∙ fset = fset</p>\n<p>Sorry for the interruption, please carry on, nothing to see here,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/nuXOty1iAXVshx0cDBM47b97/signature.asc\">signature.asc</a></p>",
        "id": 294224525,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899269
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Joachim,</p>\n<p>Well, there is something to see here. Ideally, \"metis\" would behave the same modulo eta. I'll add this to my TODO list (and come back to it after a paper deadline).</p>\n<p>Thanks for the report!</p>\n<p>Regards,</p>\n<p>Jasmin</p>",
        "id": 294224641,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899333
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>consider this theory, which uses Nominal2</p>\n<p>theory strangemetis<br>\nimports \"Nominal/Nominal/Nominal2\"<br>\nbegin</p>\n<p>lemma  \"x ♯ d ⟹ x ♯ fset d\"<br>\n  using [[show_sorts]] [[show_consts]]<br>\n  apply (erule fresh_fun_eqvt_app[rotated])<br>\n  apply (rule eqvtI)<br>\n  apply (rule eq_reflection)<br>\n  by (metis  fset_eqvt permute_fun_def permute_minus_cancel(1))</p>\n<p>lemma  \"x ♯ d ⟹ x ♯ fset d\"<br>\n  apply (erule fresh_fun_eqvt_app[rotated])<br>\n  using [[show_sorts]] [[show_consts]]<br>\n  unfolding eqvt_def<br>\n  apply rule<br>\n  by (metis  fset_eqvt permute_fun_def permute_minus_cancel(1))</p>\n<p>Before the call to metis, the proof state is identical, at least as far<br>\nas I could get jedit to tell me about it:</p>\n<p>proof (prove): step 4</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>⋀p∷perm. p ∙ fset = fset<br>\nconstants:<br>\n  fresh :: atom ⇒ 'a set ⇒ bool<br>\n  fresh :: atom ⇒ 'a fset ⇒ bool<br>\n  prop :: prop ⇒ prop<br>\n  fset :: 'a fset ⇒ 'a set<br>\n  permute :: perm ⇒ ('a fset ⇒ 'a set) ⇒ 'a fset ⇒ 'a set<br>\n  op = :: ('a fset ⇒ 'a set) ⇒ ('a fset ⇒ 'a set) ⇒ bool<br>\n  Trueprop :: bool ⇒ prop<br>\n  all :: (perm ⇒ prop) ⇒ prop<br>\n  op ⟹ :: prop ⇒ prop ⇒ prop<br>\nvariables:<br>\n  d :: 'a fset<br>\n  x :: atom<br>\ntype variables:<br>\n  'a :: pt </li>\n</ol>\n<p>Nevertheless, in the first lemma, metis finds the proof sufficiently<br>\nfast, while in the second, it does not find any proof. As this is<br>\nprobably not the intended behavior I was told to report that here.</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/XDVQXrFnhEx_Q1462dBAQEXN/signature.asc\">signature.asc</a></p>",
        "id": 294225582,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899818
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Joachim,</p>\n<blockquote>\n<p>consider this theory, which uses Nominal2</p>\n</blockquote>\n<p>Could you specify precisely which version of Nominal2 and of Isabelle you're using? I'm using the latest of both and get this error from Nominal2:</p>\n<p>*** Error (line 251 of \"/Users/blanchet/misc/nominal2/Nominal/nominal_dt_alpha.ML\"):<br>\n*** Type error in function application.<br>\n***    Function: Inductive.add_inductive_i :<br>\n***       inductive_flags -&gt;<br>\n***       ((binding * typ) * mixfix) list -&gt;<br>\n***       (string * typ) list -&gt; (Attrib.binding * term) list -&gt; thm list -&gt; local_theory -&gt; inductive_result * local_theory<br>\n***    Argument: {quiet_mode = true, verbose = false, alt_name = Binding.empty, coind = false, no_elim = ..., ...} :<br>\n***       {coind: bool,<br>\n***        no_ind: bool, no_elim: bool, verbose: bool, alt_name: binding, fork_mono: bool, skip_mono: bool, quiet_mode: bool}<br>\n***    Reason:<br>\n***    Can't unify {coind: bool, no_ind: bool, no_elim: bool, verbose: bool, alt_name: binding, skip_mono: bool, quiet_mode: bool}<br>\n***       to {coind: bool,<br>\n***           no_ind: bool, no_elim: bool, verbose: bool, alt_name: binding, fork_mono: bool, skip_mono: bool, quiet_mode: bool}<br>\n***       (Different number of fields)</p>\n<hr>\n<p>*** At command \"use\" (line 27 of \"/Users/blanchet/misc/nominal2/Nominal/Nominal2.thy\")</p>\n<blockquote>\n<p>Nevertheless, in the first lemma, metis finds the proof sufficiently<br>\nfast, while in the second, it does not find any proof. As this is<br>\nprobably not the intended behavior I was told to report that here.</p>\n</blockquote>\n<p>That certainly sounds strange. Are the goals really identical, or is one using metaequality and the other object-level equality?</p>\n<p>Jasmin</p>",
        "id": 294225714,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899885
    }
]