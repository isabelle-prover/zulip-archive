[
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nDear all,</p>\n<p>in writing Scala wrappers around code generated by the Isabelle Scala<br>\ngenerator I'm realising that things start becoming hard to maintain.</p>\n<p>For now I'm mainly generating code for a few functions in one Isabelle<br>\ntheory, but soon I will generate code from multiple Isabelle theories;<br>\nlet's call them A.thy and B.thy.</p>\n<p>Both Isabelle theories have shared dependencies in the Isabelle library.<br>\n This gives me redundant copies of such code, e.g. I end up having an<br>\n\"object Set\" defined both in A.scala and B.scala.  Thus another thing I<br>\nwant to do becomes infeasible:</p>\n<p>I would like to implement user interfaces around A.scala and B.scala,<br>\nlet me call them A_UI.scala and B_UI.scala, and these user interfaces<br>\nwill need functions such as a pretty-printer that turns Set(List(1, 2))<br>\ninto \"{1, 2}\".  This pretty-printer I would like to implement once,<br>\ncentrally, in a shared Scala module Shared.scala.  However, this would<br>\nrequire me to be able to instruct the code generator to:</p>\n<ul>\n<li>write \"object Set\" into another module, say, Set.scala</li>\n<li>and to let A.scala and B.scala import Set.scala instead of having<br>\ntheir own copies of \"object Set\".</li>\n</ul>\n<p>I did notice section \"6.4 Intimate connection between logic and system<br>\nruntime\" in the codegen manual, but I'm not sure whether this is of<br>\ngeneral interest (and whether it's relevant to my problem), or whether<br>\nit only applies to ML code generation.</p>\n<p>Assuming that what I want is not currently possible, is there at least a<br>\nworkaround?  What do other code generator users do?</p>\n<p>I understand that once more it makes the generated code less trustable,<br>\nas now we'd also have to trust the module system of the target language.<br>\n But still I'd like to be able to maintain software that uses generated<br>\ncode.</p>\n<p>Cheers, and thanks in advance for any help,</p>\n<p>Christoph</p>",
        "id": 294244781,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908474
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Christoph,</p>\n<p>The code generator always outputs all code for what is needed to implement the specified <br>\nconstants. From a modularity point of view, this is a bit unsatisfactory. I usually use <br>\none of two workarounds:</p>\n<p>a) Do not use module_name when exporting code. Then, the code generator puts every theory <br>\ninto a separate module (you can configure this to some extent with code_modulename). <br>\nUnless you have naming conflicts between your theories, this should give you the same <br>\nobject Set for A.thy and B.thy (if both use the same operations on sets). This works <br>\nparticularly well for Haskell because the code generator already puts every module into a <br>\nseparate file. So if you set the same output directory for A and B, you just get the <br>\nmodule once. For SML and Scala, all modules are in a single file for A and once more in a <br>\nsingle file for B. But you can just split the files at the module boundaries with a simple <br>\nscript.</p>\n<p>Note that without module_name in the export_code statement, you face the notorious <br>\n\"dependency cycle\" problem. This occurs particularly if you heavily employ the refinement <br>\nfeatures of the code generator. Then, you have to manually adjust the module assignment <br>\nwith code_modulename.</p>\n<p>b) Define a shared theory AB.thy that imports A and B and export all functions of A and B <br>\nin one export_code statement. Then, you only have one file and one instance of every <br>\nmodule. Your user interfaces then simply ignore the code that do not belong to A or B, resp.</p>\n<p>To go this way, you must be able to merge theories A and B. In particular, they must not <br>\nhave each a theory of the same name, and they must not instantiate the same type class for <br>\nthe same type. You can avoid the former by renaming theories. And if the latter occurs, <br>\nsharing gets you in trouble anyway. For example, suppose that A uses the prefix order on <br>\nlists and B the lexicographic order from the appropriate HOL/Library theories.<br>\nIf you shared the List module between A and B, your code would probably become incorrect, <br>\nbecause the List module also contains the instantiations for the type classes, i.e., you <br>\nwould either run A with the lexicographic order or B with the prefix order.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294244871,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908498
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christoph,</p>\n<p>beyond what Andreas has mentioned, future Isabelle releases will bring<br>\noptions for fine-grained control over the module name space of generated<br>\ncode.  This could also give a (partial) answer to your issues.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/TCd4YrI_se2oGtW4WYW2Bwm9/signature.asc\">signature.asc</a></p>",
        "id": 294245599,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908778
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<p>thanks for your help, and sorry for replying so late.  I was at a<br>\nconference and on holiday and only resumed working with generated code<br>\ntoday.</p>\n<p>2013-07-08 08:44 Andreas Lochbihler:<br>\nThis is what I will try for now.</p>\n<p>I wrote the following script; feel free to reuse it.</p>\n<p><a href=\"https://codex.cs.bham.ac.uk/svn/langec/formare/code/auction/isabelle/Auction/code/split-scala-modules.pl\">https://codex.cs.bham.ac.uk/svn/langec/formare/code/auction/isabelle/Auction/code/split-scala-modules.pl</a><br>\n(user: guest, password: guest)</p>\n<p>For now please bear with the access control, but we are planning to move<br>\nto Github.</p>\n<p>I will also make the script available in a nicer way at<br>\n<a href=\"http://www.cs.bham.ac.uk/research/projects/formare/code/auction-theory/isabelle\">http://www.cs.bham.ac.uk/research/projects/formare/code/auction-theory/isabelle</a>.</p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294246239,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909026
    }
]