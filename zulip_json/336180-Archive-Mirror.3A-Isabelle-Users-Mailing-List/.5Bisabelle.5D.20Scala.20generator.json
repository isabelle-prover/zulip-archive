[
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nOn 02/01/2011 03:23 PM, Christian Sternagel wrote:</p>\n<blockquote>\n<p>I tried almost the same example and found that the reason for the <br>\nerror is that a definition</p>\n<p>def myfun: Boolean = {<br>\n  (_: Boolean) =&gt; true;<br>\n  true<br>\n}</p>\n<p>is parsed as</p>\n<p>def myfun: Boolean = {<br>\n  (_: Boolean) =&gt; { true; true };<br>\n}</p>\n<p>by the scala compiler. I'm not sure whether this is intended from the <br>\nScala side. However, a (hopefully) easy workaround in the Isabelle <br>\nsetup is to provide additional parentheses around function literals.<br>\n</p>\n</blockquote>\n<p>We have improved the Scala code generation to add parentheses around <br>\nfunction literals as suggested,<br>\nand provide a fix as changeset 3450e57264b3 in the development version.</p>\n<p>This changeset can possibly also be applied to the release version <br>\nIsabelle2011, for those which require it for Scala code generation.</p>\n<p>@Rene: I hope we can also identify and fix the other quirks with the <br>\nScala code generation; just provide us some further pointers.</p>\n<p>Thank you all for the help identifying the problem.</p>\n<p>Lukas</p>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<p>On 02/01/2011 03:12 PM, bnord wrote:</p>\n<blockquote>\n<p>Am 01.02.2011 14:46, schrieb René Thiemann:</p>\n<blockquote>\n<p>we have not yet simplified and localized the exact problem<br>\nThe problem seems to be that the code generator doesn't generate the<br>\nnecessary \"val ... = \" parts for values that are not used anywhere and<br>\nthe resulting anonymous function isn't a valid statement on it's own.</p>\n</blockquote>\n<p>A simpler example might be:</p>\n<p>theory Test<br>\nimports Main<br>\nbegin</p>\n<p>definition myfun :: \"bool\"<br>\nwhere \"myfun \\&lt;equiv&gt; let x = \\&lt;lambda&gt; l::bool. True<br>\nin True\"</p>\n<p>export_code myfun in Scala file \"Test.scala\"<br>\nend</p>\n<p>which produces:</p>\n<p>object Test {</p>\n<p>def myfun: Boolean = {<br>\n(_: Boolean) =&gt; true;<br>\ntrue<br>\n}</p>\n<p>} /* object Test */<br>\n</p>\n</blockquote>\n<p>Thank</p>\n</blockquote>",
        "id": 294130378,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842592
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;</p>\n<blockquote>\n<p>We have improved the Scala code generation to add parentheses around function literals as suggested,<br>\nand provide a fix as changeset 3450e57264b3 in the development version.</p>\n</blockquote>\n<p>Thanks.</p>\n<blockquote>\n<p>@Rene: I hope we can also identify and fix the other quirks with the Scala code generation; just provide us some further pointers.</p>\n</blockquote>\n<p>Here is another one.</p>\n<p>class class0 = fixes elem :: 'a<br>\nclass class1 = class0<br>\nclass class2 = class0<br>\ndefinition f :: \"'a :: {class1, class2}\" where \"f \\&lt;equiv&gt; elem\"<br>\nexport_code f in Scala file \"Problem.scala\"</p>\n<p>Then the file Problem.scala is created:</p>\n<p>object Problem {</p>\n<p>trait class0[A] {<br>\n  val <code>Problem.elem</code>: A<br>\n}<br>\ndef elem<a href=\"http://implicit%20A:%20class0[A]\">A</a>: A = A.<code>Problem.elem</code></p>\n<p>trait class1[A] extends class0[A] {<br>\n}</p>\n<p>trait class2[A] extends class0[A] {<br>\n}</p>\n<p>def f[A: class1: class2]: A = elem[A] /* line 14 */</p>\n<p>} /* object Problem */</p>\n<p>which does not compile:<br>\nProblem.scala:14: error: ambiguous implicit values:<br>\n both value evidence$1 of type Problem.class1[A]<br>\n and value evidence$2 of type Problem.class2[A]<br>\n match expected type Problem.class0[A]<br>\ndef f[A: class1: class2]: A = elem[A]</p>\n<p>René</p>",
        "id": 294130631,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842673
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nOn 02/03/2011 08:07 AM, René Thiemann wrote:</p>\n<blockquote>\n<blockquote>\n<p>We have improved the Scala code generation to add parentheses around function literals as suggested,<br>\nand provide a fix as changeset 3450e57264b3 in the development version.<br>\nThanks.</p>\n</blockquote>\n<blockquote>\n<p>@Rene: I hope we can also identify and fix the other quirks with the Scala code generation; just provide us some further pointers.<br>\nHere is another one.</p>\n</blockquote>\n<p>class class0 = fixes elem :: 'a<br>\nclass class1 = class0<br>\nclass class2 = class0<br>\ndefinition f :: \"'a :: {class1, class2}\" where \"f \\&lt;equiv&gt;  elem\"<br>\nexport_code f in Scala file \"Problem.scala\"</p>\n<p>Then the file Problem.scala is created:</p>\n<p>object Problem {</p>\n<p>trait class0[A] {<br>\n   val <code>Problem.elem</code>: A<br>\n}<br>\ndef elem<a href=\"http://implicit%20A:%20class0[A]\">A</a>: A = A.<code>Problem.elem</code></p>\n<p>trait class1[A] extends class0[A] {<br>\n}</p>\n<p>trait class2[A] extends class0[A] {<br>\n}</p>\n<p>def f[A: class1: class2]: A = elem[A] /* line 14 */</p>\n<p>} /* object Problem */</p>\n<p>which does not compile:<br>\nProblem.scala:14: error: ambiguous implicit values:<br>\n  both value evidence$1 of type Problem.class1[A]<br>\n  and value evidence$2 of type Problem.class2[A]<br>\n  match expected type Problem.class0[A]<br>\ndef f[A: class1: class2]: A = elem[A]</p>\n<p>This can be only fixed by someone, who understands how type classes were <br>\nthought to be modelled as implicits, i.e., our code generation guru Florian.</p>\n</blockquote>\n<p>Florian's thoughts have been partly recorded on <br>\n<a href=\"http://www.scala-lang.org/node/6698\">http://www.scala-lang.org/node/6698</a>, but he can probably say more about <br>\nthis \"diamond problem\".</p>\n<p>Lukas</p>\n<blockquote>\n<p>René</p>\n</blockquote>",
        "id": 294130646,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842679
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>after updating our theories to Isabelle 2011 we wanted to try out the  <br>\nScala code generator, but unfortunately we have some problems since  <br>\nthe generated code does not compile (it complies for other languages  <br>\nlike Haskell and OCaml).</p>\n<p>A simplified example is attached (theory file and generated scala  <br>\nfile), and scala 2.8 complains as follows:</p>\n<p>Test.scala:25: error: type mismatch;<br>\nfound   : (List[(A, Nat.nat)]) =&gt; Boolean<br>\nrequired: Boolean<br>\n    (a: List[(A, Nat.nat)]) =&gt;<br>\n                            ^<br>\none error found</p>\n<p>In the full generated code (20000 lines of Scala), we also detected  <br>\nother compilation problems</p>\n<p>Ceta.scala:13427: error: ambiguous implicit values:<br>\nboth method poly_carrier_rat in object Ceta of type =&gt;  <br>\nCeta.poly_carrier[Ceta.rat]<br>\nand method max_ordered_monoid_add_rat in object Ceta of type =&gt;  <br>\nCeta.max_ordered_monoid_add[Ceta.rat]<br>\nmatch expected type Ceta.non_strict_order[Ceta.rat]<br>\n   (mat_ge[rat],</p>\n<p>but we have not yet simplified and localized the exact problem.</p>\n<p>Any help is appreciated,<br>\nRené<br>\n<a href=\"/user_uploads/14278/QaFHudRq6Z-mLrUNvCcylVMX/Test.scala\">Test.scala</a><br>\n<a href=\"/user_uploads/14278/q-xaRs45VF26-p1RLFRthl9X/Test.thy\">Test.thy</a></p>",
        "id": 294130866,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842753
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>for a substantial solution I have to ask on the scala mailing list, this<br>\nwill take some time.</p>\n<p>Luckily there is a workaround for that: provide an explicit union of<br>\nboth classes s.t. the resulting constraint only mentions one class:</p>\n<p>class class3 = class1 + class2</p>\n<p>lemma [code]:<br>\n  \"(f :: 'a::class3) = elem\"<br>\n  by (simp add: f_def)</p>\n<p>Then it works fine.</p>\n<p>Note that the preprocessor propagates sort constraints through systems<br>\nof code equations, so it might be enough to provide a more specialized<br>\ncode lemma for exactly one operation.</p>\n<p>Hope this helps in the first place,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/Oj6F75KnZH6szzV6fCaqN6wW/signature.asc\">signature.asc</a></p>",
        "id": 294130900,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842764
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nBtw. the relevant paper for implementing type classes by implicits is<br>\n<a href=\"http://infoscience.epfl.ch/record/150280\">http://infoscience.epfl.ch/record/150280</a></p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/AdiNeWnAp4gdoJyF8MrpMyjT/signature.asc\">signature.asc</a></p>",
        "id": 294130925,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842771
    },
    {
        "content": "<p>From: bnord &lt;<a href=\"mailto:bnord01@googlemail.com\">bnord01@googlemail.com</a>&gt;<br>\nThe problem seems to be that the code generator doesn't generate the <br>\nnecessary \"val ... = \" parts for values that are not used anywhere and <br>\nthe resulting anonymous function isn't a valid statement on it's own.</p>\n<p>A simpler example might be:</p>\n<p>theory Test<br>\nimports Main<br>\nbegin</p>\n<p>definition myfun :: \"bool\"<br>\nwhere \"myfun \\&lt;equiv&gt; let x =  \\&lt;lambda&gt; l::bool. True<br>\n   in True\"</p>\n<p>export_code myfun in Scala file \"Test.scala\"<br>\nend</p>\n<p>which produces:</p>\n<p>object Test {</p>\n<p>def myfun: Boolean = {<br>\n                        (_: Boolean) =&gt; true;<br>\n                        true<br>\n                      }</p>\n<p>} /* object Test */</p>",
        "id": 294131052,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842820
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nThe problem there is actually precedence. The following version works as<br>\nexpected, and the Scala compiler should be able to remove that piece of<br>\ndead code.</p>\n<p>object Test {</p>\n<p>def myfun: Boolean = {<br>\n                       {(_: Boolean) =&gt; true;}<br>\n                       true<br>\n                     }</p>\n<p>} /* object Test */<br>\n<a href=\"/user_uploads/14278/DWZnuHAfI3qiLjCamyWXzYpa/smime.p7s\">smime.p7s</a></p>",
        "id": 294131240,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842891
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nI tried almost the same example and found that the reason for the error <br>\nis that a definition</p>\n<p>def myfun: Boolean = {<br>\n   (_: Boolean) =&gt; true;<br>\n   true<br>\n}</p>\n<p>is parsed as</p>\n<p>def myfun: Boolean = {<br>\n   (_: Boolean) =&gt; { true; true };<br>\n}</p>\n<p>by the scala compiler. I'm not sure whether this is intended from the <br>\nScala side. However, a (hopefully) easy workaround in the Isabelle setup <br>\nis to provide additional parentheses around function literals.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294131608,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843022
    }
]