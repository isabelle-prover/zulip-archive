[
    {
        "content": "<p>From: Timothy Bourke &lt;<a href=\"mailto:timothybourke@gmail.com\">timothybourke@gmail.com</a>&gt;<br>\nManually running:<br>\n    find_theorems solves<br>\nor<br>\n    C-c C-f solves</p>\n<p>should have the desired effect.</p>\n<p>You could also make a more specific key binding if you need this<br>\noften.</p>\n<p>Tim.<br>\n<a href=\"/user_uploads/14278/EMXvqRrinKYWgRgj758Xq0oJ/signature.asc\">signature.asc</a></p>",
        "id": 294102519,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834221
    },
    {
        "content": "<p>From: grechukbogdan &lt;<a href=\"mailto:grechukbogdan@yandex.ru\">grechukbogdan@yandex.ru</a>&gt;<br>\nDear Isabelle Users,<br>\nI am working on project, which includes 1) convex analysis formalization in Isabelle, and 2) provide a feedback about Isabelle, including comments and suggestions.<br>\nHere is my first feedback letter, mostly about the search in Isabelle.<br>\nWhen I want to prove some result, the first question is if this result new or not, and it would be nice to know this without reading the theories from the Library. Fortunately, if I guess the exact formulation of existing lemma, I can do search, or just formulate the lemma and get message like “The current goal could be solved directly with...”. The first important problem here is that if I formulate such a lemma inside the proof in command “have”, no suggestion is given, and it is hard to guess to check every time, as a result I already reproved some existing results. </p>\n<p>Suggestion 1. The message like  “The current goal could be solved directly with...” should appear not only after I formulate the existing result as a lemma, but also when I formulate it inside the proof, say after have. Ideally, something like this should work when the existing result appears as a subgoal in the proof, etc. </p>\n<p>The first part of this (about “have”) I have suggested during my first visit in June, and the reply was “good point. We will think about it”. This is very important because it will help to avoid duplicate job. Is it hard for realization?</p>\n<p>Unfortunately, this mechanism is very sensitive for reformulations. For example, there exist a lemma “id x = x”, but I have no suggestions for lemma “x = id x”. In this and many similar cases Sledgehammer can help, but the same question arises: is it possible to run it in the background automatically, every time when I formulate a lemma or “have” statement? </p>\n<p>Suggestion 2: It should be a possibility to run Sledgehammer in the background automatically, every time when I formulate a lemma or “have” statement . If this is already possible, the suggestion is to make it more clear how to turn it on, because I cannot find the way to do this.</p>\n<p>Unfortunately, even Sledgehammer does not help for a little bit more complicated lemmas. For example, it cannot prove the lemma <br>\nf = g ↔ (!x. f x = g x)                            (1)<br>\nalthough this lemma is present in the library. As a result, a reformulation like<br>\nf = g ↔ (!x. g x = f x)                            (2)<br>\nis not addressed neither by Sledgehammer nor by lemma suggestion mechanism, and  I see no simple way for the user to find out that this lemma is not essentially new. May be, this way exists, and I just do not know about it?</p>\n<p>Suggestion 3: As a minimum, merge lemma suggestion with Sledgehammer to create a new Sledgehammer which would prove at least (1). Ideally, it should be a mechanism which proves a reformulations like (2), and it should work automatically, to prevent user from reproving result. If there is another simple way to see that statements like (2) are not essentially new, it should be more clear documented,  because I cannot find a simple way to do this.</p>\n<p>In my work, I need a definition of dimension. It states<br>\ndim V = (SOME n. EX B&lt;=V. independent B &amp; V&lt;=span B &amp; card B =n)   <br>\nI know from the tutorial that SOME is Hilbert operator, but when I tried to find the definition of SOME in Isabelle, the search failed. It turned out this was because SOME is an abbreviation, but it took me a long time and finally I needed help of another person.</p>\n<p>Suggestion 4: There should be a simple way to see the any definition in Isabelle, even if I do not know in advance, is this a lemma, method, term, abbreviation,  notation, or something else. </p>\n<p>But even knowing the definition, I do not know how to work with this SOME. For example, if I assume that “dim V = m” I have “(SOME n. EX B&lt;=V. independent B &amp; V&lt;=span B &amp; card B =n) = m”, but I do not know how to extract this B from this definition and derive, say, that <br>\ndim V = m ==&gt; (EX B&lt;=V. independent B &amp; V&lt;=span B &amp; card B =m)            (3)<br>\nIdeally, together with definition it should be small set of example how to work with, say, SOME, but may be it is too much to formulate this as a suggestion (although such a help exists in many systems like Mathematica). Ok, could you please just tell me how to work with SOME, for example, how to prove (3)?<br>\nAlso, to proceed with proof of my lemma, I will need to obtain this B and say that it is a basis in R^n, whence affine hull V = R^n But again, I cannot understand the definition of basis in Isabelle, because it contains symbol \\&lt;chi&gt;, which is not in table A.1 in the tutorial, and it is hard to find what it means, see suggestion 4. Could you please explain me this notation, and how to work with basis, for example, how to prove that n independent vectors form a basis in R^n.</p>\n<p>Sincerely,<br>\nBogdan.</p>",
        "id": 294104197,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834707
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>In my work, I need a definition of dimension. It states<br>\ndim V = (SOME n. EX B&lt;=V. independent B &amp; V&lt;=span B &amp; card B =n)   </p>\n</blockquote>\n<p>Such definitions are notoriously tricky to work with. In particular,</p>\n<p>dim V = m ==&gt; (EX B&lt;=V. independent B &amp; V&lt;=span B &amp; card B =m) (3)</p>\n<p>does not hold. What if V has no dimension? Then \"dim V\" is still<br>\ndefined, but you don't know what it is. In it cannot possibly fulfill<br>\nthe defining predicate. Another way to see that (3) is strange,<br>\ninstantiate m with \"dim V\" in (3).</p>\n<p>The rules for working with SOME are all in Hilbert_Choice. The closest<br>\nyou can get to (3) is</p>\n<p>lemma someI2: \"[| P a;  !!x. P x ==&gt; Q x |] ==&gt; Q (SOME x. P x)\"</p>\n<p>This requires that you know that there is an \"a\" that satisfies P.<br>\nSome further hints:</p>\n<ul>\n<li>\n<p>There is also THE and LEAST which may or may not be more convenient<br>\nthan SOME.</p>\n</li>\n<li>\n<p>Look though the \"What's in Main\" manual (it's only 10 pages) to<br>\ndiscover what there is. You can also use the pdf search facility to<br>\nsearch for symbols in there.</p>\n</li>\n<li>\n<p>There is also THE and LEAST which may or may not be more convenient<br>\nthan SOME.</p>\n</li>\n<li>\n<p>Sometimes it is convenient to set \"undefined\" values to a fixed value.<br>\nFor example, card A = 0 if A is infinite. Maybe something similar makes<br>\nsense for dim.</p>\n</li>\n</ul>\n<p>Tobias</p>",
        "id": 294104317,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834742
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 25 Mar 2010, grechukbogdan wrote:</p>\n<blockquote>\n<p>Suggestion 1. The message like “The current goal could be solved <br>\ndirectly with...” should appear not only after I formulate the existing <br>\nresult as a lemma, but also when I formulate it inside the proof, say <br>\nafter have. Ideally, something like this should work when the existing <br>\nresult appears as a subgoal in the proof, etc.</p>\n</blockquote>\n<p>The goal-print-hook mechanism is essentially just a temporary workaround <br>\n(since some years already). There is a fundamental bottle-neck in the <br>\nsynchronous interaction model of Proof General here, which is inherited <br>\nfrom the plain tty model.  I.e. there is just a single read-eval-print <br>\nloop, and while the system is trying to find smart suggestions the user <br>\nhas to wait for it.</p>\n<p>Activating this crude suggestion mechanism in more places would degrade <br>\nsystem reactivity even further.</p>\n<blockquote>\n<p>Suggestion 2: It should be a possibility to run Sledgehammer in the <br>\nbackground automatically, every time when I formulate a lemma or “have” <br>\nstatement . If this is already possible, the suggestion is to make it <br>\nmore clear how to turn it on, because I cannot find the way to do this.</p>\n</blockquote>\n<p>Same problem, even worse. Users certainly do not want to wait several <br>\nseconds until they can continue typing.</p>\n<p>The crude asynchronous mode of Sledgehammer is also just a temporary <br>\nworkaround.</p>\n<p>Quite some time ago, I've started an effort to introduce true interaction <br>\ninto interactive theorem proving, by giving up the tty read-eval-print <br>\nloop, and Proof General, heading towards a document-oriented editor model.</p>\n<p>This is much easier said then done.  There are many technical issues, part <br>\nof them already solved.  At least initially it was hard to find a <br>\nreplacement for the Emacs operating system (with its modest <br>\nsingle-threaded editor).  What has emerged already is this new <br>\nIsabelle/Pure.jar Scala library for system programming, and a small demo <br>\napplication based on the powerful jEdit, which is a real editor, not an <br>\noperating sytem like Emacs or Eclipse.</p>\n<p>I hope to see some usuable asynchronous proof editor within the next few <br>\nmonths.  The asynchronous model will provide a natural playground for <br>\nvarious \"user agents\" based on find_theorems, external ATPs etc.  There is <br>\nlots of implementation work still ahead of us -- as well as unlearning the <br>\nway of thinking in terms of a TTY-loop.</p>\n<blockquote>\n<p>Suggestion 4: There should be a simple way to see the any definition in <br>\nIsabelle, even if I do not know in advance, is this a lemma, method, <br>\nterm, abbreviation, notation, or something else.</p>\n</blockquote>\n<p>You cannot easily have a \"whatis FOO\" command that tells you about an <br>\nuncategorized entity FOO -- it would violate the internal data abstraction <br>\nof Isabelle tools and packages.  But such a command would belong to the <br>\nold TTY world anyway.</p>\n<p>What works already is a universal markup mechanism that decorates all <br>\ninput and output of the system by formal references to defining and <br>\nreferencing locations etc.  For example, looking at some bit of text like <br>\n\"SOME x. P x\" that has been digested by the system at some point, you<br>\ncould click on the \"SOME\" or even the \".\" to refer to the formal entity <br>\nbehind it, say a constant definition with notation for concrete syntax.</p>\n<p>Too bad there is still no user interface, or even just HTML browser to <br>\nmake use of this information emitted by Isabelle.  The Proof General setup <br>\nstrips it all away -- the single LISP thread would choke on all that <br>\nsemantic information anyway.</p>\n<p>Moreover, if you look at modern Isabelle documentation, it is all based on <br>\nformal theories.  Manuals such as isar-ref have further formal markup in <br>\nthe running text, say @{method_def induct} (defining position) or <br>\n@{method_ref induct} (interesting referencing position), or @{method <br>\ninduct} (other reference).  Right now this is only used to produce a <br>\ntraditional LaTeX index, but the pointing and clicking on formal entities <br>\nas sketched above could be applied as well.</p>\n<p>For example, lets say you look at some bits of theory somewhere in the <br>\nlibrary:</p>\n<p>lemma fixes n :: nat shows \"P n\" by (induct n) auto</p>\n<p>To understand what \"induct\" is, you merely right-click and select from <br>\nwhatever manuals are presented there, you should quickly get to <br>\nreference-manual style definitions of it, or some specially marked <br>\nexamples etc.</p>\n<p>Isabelle already provides a good portion of such mechanisms internally, <br>\nbut the front-ends are still lacking.  Something like two years ago I've <br>\nstarted to engage myself into the Scala/JVM programming language, to get <br>\naccess to JVM based editor and browser technologies, without having to <br>\nwork with the crude oil industry stuff around Java.  Thus the ML (and HOL) <br>\nculture of Isabelle can be extended into the JVM, thanks to the smart guys <br>\nfrom EPF Lausanne.</p>\n<p>Stay tuned for more to come here soon.</p>\n<p>If anybody wants to help me out, what I desparately need is:</p>\n<p>* A really good PDF browser for the JVM (as pure jar, no JNI crap);<br>\n     hyperlinks and copy-paste need to work properly.</p>\n<p>* A really good HTML browser in the same manner.  Presently I am using<br>\n     Lobo/Cobra, which is quite good, but also has some shortcomings.<br>\n     (I've tried Flying Saucer already.)</p>\n<p>Of course, all of that needs to be Open Source.</p>\n<p>Makarius</p>",
        "id": 294104337,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834748
    }
]