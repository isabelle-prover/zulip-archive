[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIsabelle is not as constructivistic as Coq, especially the Isar layer is <br>\nvery platonistic, with many non-logical ideas being expressed as abstract <br>\ndatatypes instead of lambda terms.  This means there is not a single <br>\nconcrete \"term\" structure that holds all the information.  It depends on <br>\nyour application which kind of proof information you want to retrieve from <br>\nthe system.</p>\n<p>For example, consider the following Isar proof:</p>\n<p>lemma \"A &amp; B --&gt; B &amp; A\"<br>\nproof<br>\n  assume \"A &amp; B\"<br>\n  then obtain B and A ..<br>\n  then show \"B &amp; A\" ..<br>\nqed</p>\n<p>The \"real\" Isar proof is just the source as shown here -- Isabelle does <br>\nnot store it in that form, you need to refer to the UI / editor to get <br>\nhold of it.</p>\n<p>The internal Isar representation of a partially proof text can be <br>\nretrieved at any point like this:</p>\n<p>ML_val {* Toplevel.proof_of (Isar.state ()) *}</p>\n<p>but this gives the the abstract datatype only (with operations provided in <br>\nsrc/Pure/Isar/proof.ML).</p>\n<p>Alternatively you may look at the primitive derivation objects behind <br>\nparts of Isar proofs.  E.g. like this:</p>\n<p>ML \"proofs := 2\"</p>\n<p>lemma a: \"A &amp; B --&gt; B &amp; A\"<br>\nproof<br>\n  assume \"A &amp; B\"<br>\n  prf this<br>\n  then obtain B and A ..<br>\n  prf this<br>\n  then show \"B &amp; A\" ..<br>\n  prf this<br>\nqed</p>\n<p>prf a</p>\n<p>You may also want to look at the goal states (there can be many of them at <br>\neach level of the structure).  Cf. ML {* Isar.goal () *}</p>\n<p>Makarius</p>",
        "id": 294064721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825039
    },
    {
        "content": "<p>From: Lionel Elie Mamane &lt;<a href=\"mailto:lionel@mamane.lu\">lionel@mamane.lu</a>&gt;<br>\nHi,</p>\n<p>Is there any command to see / dump / pretty-print a (partial) proof in<br>\nIsabelle? What I mean is:</p>\n<ul>\n<li>\n<p>Before one has done \"qed\", while one is proving a theorem, there is<br>\n   (I presume) a partial proof somewhere in the internals of the<br>\n   system; maybe in the shape of a \\lambda-term with (typed) holes /<br>\n   placeholders, or in the shape of a tree of what rule / tactic<br>\n   brought what proof state to what proof state, or both.</p>\n<p>Can I see that partial proof? (People that know Coq will recognise<br>\n the \"Show Proof.\" and \"Show Tree.\" commands of Coq.)</p>\n</li>\n<li>\n<p>After one has done the \"qed\", the same data as before, except that<br>\n   there will be proof will be complete.</p>\n<p>(Something like \"Print theorem_name.\" in Coq.)</p>\n</li>\n</ul>\n<p>Thanks for the information,</p>",
        "id": 294065397,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660825260
    }
]