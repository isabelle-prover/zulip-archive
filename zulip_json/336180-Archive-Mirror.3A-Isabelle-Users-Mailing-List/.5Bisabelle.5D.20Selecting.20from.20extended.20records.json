[
    {
        "content": "<p>From: Ferdinand Vesely &lt;<a href=\"mailto:csfvesely@swansea.ac.uk\">csfvesely@swansea.ac.uk</a>&gt;<br>\nDear mailing list,</p>\n<p>I'm trying to develop a theory using modular records built from smaller<br>\nrecords in an arbitrary way. That is, I don't want to have to commit to<br>\nthe order right at the beginning by using the \"+\" notation for<br>\nextending records. This seems to be partly achievable but has<br>\nlimitations in that, e.g., selectors are not applicable. For example, I<br>\ndefine the component records:</p>\n<p>record out = out :: string<br>\n  record env = env :: \"(string * val) list\"</p>\n<p>I can then define operations on these smaller records that carry over<br>\nto the bigger ones, e.g. a notion of composition:</p>\n<p>class composable = <br>\n    fixes compose :: \"'a =&gt; 'a =&gt; 'a\" (infix \";;\" 60)</p>\n<p>instantiation unit :: composable<br>\n  begin<br>\n    definition compose_unit_def:<br>\n      \"u1 ;; u2 = ()\"<br>\n  ...</p>\n<p>instantiation out_ext :: (composable) composable<br>\n  begin<br>\n  definition compose_out_def: <br>\n    \"r1 ;; r2 = <br>\n     (| out = (out r1) @ (out r2), ... = (out.more r1) ;; (out.more<br>\n  r2)  |)\"<br>\n  ...</p>\n<p>instantiation env_ext :: (composable) composable<br>\n  begin<br>\n    definition compose_env_def:<br>\n      \"r1 ;; r2 = ( <br>\n        if (env r1 = env r2) then<br>\n          (| env = env r2, ... |) = (env.more r1) ;; (env.more r2) |)<br>\n        else undefined)\"<br>\n   ...</p>\n<p>Now I can have values of combined record types (\"env out_ext\" or \"out<br>\nenv_ext\"), e.g.</p>\n<p>value \"(| out = ''abc'', env = [ (''x'', v) ] |)\"</p>\n<p>I can apply the overloaded operations to such values:</p>\n<p>value \"(| env = [ (''x'', v) ], out = ''abc'' |) ;;<br>\n         ;; (| env = [ (''x'', v) ], out = ''def'' |)\"</p>\n<p>and I can also select the first element:</p>\n<p>value \"out (| out = ''abc'', env = [ (''x'', v) ] |)\"</p>\n<p>However, since the selector for, e.g., env is only defined on \"'a<br>\nenv_scheme\", I cannot apply it if env is not the first element in the<br>\nrecord:</p>\n<p>value \"env (| out = ''abc'', env = [ (''x'', v) ] |)\"</p>\n<p>Is there a way to select any element from such mix-and-match records?</p>\n<p>If this is currently not possible, is there an inherent limitation in<br>\nthe underlying ML implementation of records? I've had a brief look at<br>\n\"HOL/Tools/record.ML\" but didn't have much time to dive into it yet.</p>\n<p>It is possible to define an overloaded selector using via type classes<br>\n(see attached theory), but this seems too much work.</p>\n<p>Alternatively, I think it would also be interesting to have a more<br>\ngeneral record definition construct, such as:</p>\n<p>record out = ...<br>\n  record env = ...<br>\n  record big_record = out + env + ...</p>\n<p>which would have the effect of:</p>\n<p>record out = ...<br>\n  record env = out + ...<br>\n  record big_record = env + ...</p>\n<p>My example theory is attached.</p>\n<p>Kind regards,<br>\nFerdinand<br>\n<a href=\"/user_uploads/14278/qFYo9vEti5XmBR9M-bsG-gIC/RecordsExample.thy\">RecordsExample.thy</a></p>",
        "id": 294320279,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926656
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHello Ferdinand.</p>\n<p>You have an interesting idea there. I have to warn you that interesting<br>\nideas to improve the record package come up from time to time, and are<br>\nusually resolved to be too much work.</p>\n<p>It would be possible to use class-based polymorphism to allow all<br>\naccessors and updators to apply to all relevant record constructions no<br>\nmatter what order they were constructed in. That would complicate the<br>\nformal definitions quite a bit, and the record package is already quite<br>\ncomplicated. There would also remain the fundamental limit that records<br>\ncan only be constructed as a linear composition of record extensions,<br>\nwhereas I think some users would like to be able to merge a binary pair<br>\nof record environments.</p>\n<p>It might be of interest to you to point out that Norbert Schirmer fought<br>\nwith these restrictions a while ago, and came up with an approach in<br>\nwhich the record type, updators and accessors are simply introduced in a<br>\nlocale. The locales can then be combined in any manner desired. The<br>\nfinal obligation (left until the proof is complete and assembled) is to<br>\nshow that the hypothesised super-record, updators and accessors exists.<br>\nThis only needs to be done once.</p>\n<p>I think that the code in the Isabelle repo in \"src/HOL/Statespace/\"<br>\nimplements this, but I might be confused about that.</p>\n<p>Good luck!</p>\n<p>Cheers,<br>\n     Thomas.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294320301,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926662
    }
]