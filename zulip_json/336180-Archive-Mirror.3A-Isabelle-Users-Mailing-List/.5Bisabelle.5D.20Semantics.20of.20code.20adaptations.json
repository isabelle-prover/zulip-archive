[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<p>indeed, there are no formal pointers whatsoever on adaptation.<br>\nInformally, there is the idea of adaptations describing an isomorphism, e.g.</p>\n<p>bool &lt;-&gt; bool<br>\n  True &lt;-&gt; true<br>\n  False &lt;-&gt; false</p>\n<p>Advanced instances of adaptation (e.g. numerals) are already more involved.</p>\n<p>What is done in Imperative-HOL is yet another story.</p>\n<p>I admit that in presence of abstract datatypes things get more delicate<br>\nalso.  But to approach a more rigorous treatment of adaptations, we<br>\nwould need a more abstract technical serialization stack: not directly<br>\ngoing from IML to, say, SML, but first to an abstract syntax tree on<br>\nwhich certain well-understood transformations can be carried out.</p>\n<p>When starting the code generator business almost one decade ago, I<br>\nrefrained from having such a full-blown stack: on the one hand side, it<br>\nwould be conceptually clearer, but from a practical point of view it<br>\nwould introduce yet another layer of trusted code â€“ unless the<br>\ntransition IML -&gt; abstract syntax tree is bolstered somehow.</p>\n<p>Maybe Lars Hupel can tell whether his work can contribute here.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/L49lYZ5qIEAJiws03n3-Owed/signature.asc\">signature.asc</a></p>",
        "id": 294316537,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925641
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear experts of the code generator,</p>\n<p>I am looking for a (formal) semantics of the adaptation facilities that the code generator <br>\noffers. I am aware of the correctness proof for the dictionary construction in Florian's <br>\nand Tobias' FLOPS 2010 paper (which essentially summarises Florian's PhD thesis) and the <br>\ncorrectness proof for the subtype translation (code abstract) in the data refinement paper <br>\nat ITP 2013. As I understand it, both take a closed-world perspective in that they assume <br>\nthat the code generator generates everything and nothing is serialised to target-language <br>\nprimitives (list, option, boolean, ...). So I am wondering whether there has been given <br>\nsome rigorous thought on the (formal) conditions on the adaptations that make these <br>\ncorrectness guarantees extend to code serialised with adaptations in place.</p>\n<p>Thanks in advance for any pointers.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294318140,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926103
    }
]