[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\n[This thread has become too voluminous to be followed in detail by a<br>\ncasual bystander, so I try here with »one issue – one mail«.]</p>\n<p>I am personally very sympathetic towards a refined, stricter, more<br>\naccurate, better understood consistency check. The separation of<br>\nIsabelle/Pure and Isabelle/HOL however is an integral part of the system<br>\ndesign and needs to be respected and reflected in the design of components.</p>\n<p>In the past, we always managed to leave typedef itself unchanged,<br>\nresisting obvious temptations like</p>\n<ul>\n<li>\n<p>replace sets by predicates (which is conceptually possible but would<br>\nbreak down the bridges to Gordon HOL);</p>\n</li>\n<li>\n<p>move typedef to Pure (which seems just to be wrong, although I have no<br>\nexample at hand for a valid Pure model that would be invalidated by that).</p>\n</li>\n</ul>\n<p>It is a capriole of Isabelle/Pure to provide types (»syntactic<br>\ncategories«) and overloading but no means to introduce new types with<br>\nspecific properties other than purely axiomatic statements. So I wonder<br>\nhow a check considering constant definitions and »type definitions« at<br>\nthe same time ought to be designed. Conceding that I don't know the<br>\nessence of previous discussions, two spontaneous ideas:</p>\n<ul>\n<li>\n<p>A hook design for defs.ML, where more specific checks can be plugged<br>\nin later?</p>\n</li>\n<li>\n<p>Shadow constants declared by typedef to mimic the additional<br>\ndependencies imposed by a stricter check?</p>\n</li>\n</ul>\n<p>Just a few bits,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/8R6yyweXdEFrB6qF6McA30TP/signature.asc\">signature.asc</a></p>",
        "id": 294653416,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167045
    },
    {
        "content": "<p>From: Larry Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI think this could work, using a meta-level predicate of course. It could closely resemble the version in HOL4. I haven’t thought this through, but the other thing it needs is an equality symbol, which we have in the meta-logic.</p>\n<p>Whether it would cause significant architectural upheavals is another question. There might be simpler solutions to the problem at hand. I don’t have a clear idea of how the circularity check works and whether typedef it could feed into it.</p>\n<p>Larry</p>",
        "id": 294653428,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167051
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nThere is a third solution, which I used in my proof-of-concept patch:</p>\n<ul>\n<li>\n<p>if c = t is defined in Pure you let c depend on all entities (in t) <br>\nthat are from Pure's logic and that have a global name, i.e., constants <br>\nand type constructors. I argue that is not an intrusion of Isabelle/HOL <br>\ninto Isabelle/Pure because the very notion of a type constructor is <br>\ndefined in Pure and therefore c must depend on the type constructors <br>\nfrom t nevertheless if we have a definitional mechanism for types at <br>\nthis point.</p>\n</li>\n<li>\n<p>if there is an object logic that provides additional definitional <br>\nmechanisms (e.g., typedef in Isabelle/HOL), this object logic can add <br>\nadditional \"edges\" to the graph of dependencies, as it is already done <br>\nnowadays for example for Abs and Rep morphisms. E.g., if I define tau = <br>\nS, I let tau depend on all entities from S.</p>\n</li>\n<li>\n<p>As you can see no hooks and no shadow constants are needed and we can <br>\nstill keep separation between the meta-logic and object logics.</p>\n</li>\n<li>\n<p>From a technical/implementation point of view: the only conceptual <br>\nchange of the code is that you have to separate name spaces of types and <br>\nconstants in defs.ML. But because the implementation of defs.ML is <br>\nalready visionary, this is the only change that has to be done. You can <br>\ntreat type instances of type constructors and constants in an uniform <br>\nway, i.e., there is not any change in the algorithm's itself. You just <br>\nneed a more complicated type for names of the nodes in the graph.</p>\n</li>\n</ul>\n<p>Ondrej</p>",
        "id": 294653515,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167082
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Ondřej,</p>\n<p>[...]</p>\n<p>thanks for explaining this so thoroughly.</p>\n<p>So, the technical complication in the first instance is a name space issue.</p>\n<p>To maintain the »visionary« property of defs.ML, it could also be<br>\ngeneralized to administrate dependencies of »named symbols« in general,<br>\ne.g. by using some kind of name space tagging etc. instead of hard-coded<br>\nconstructors.  These could serve potential specification object logics<br>\ndealing with different kinds of entities than type constructors and<br>\nconstants also, but this is highly speculative.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/5HhVBbJMWPVFnQ5YSrLEGugn/signature.asc\">signature.asc</a></p>",
        "id": 294653536,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167088
    },
    {
        "content": "<p>From: Burkhart Wolff &lt;<a href=\"mailto:Burkhart.Wolff@lri.fr\">Burkhart.Wolff@lri.fr</a>&gt;</p>\n<blockquote>\n<ul>\n<li>move typedef to Pure (which seems just to be wrong, although I have no<br>\nexample at hand for a valid Pure model that would be invalidated by that).</li>\n</ul>\n</blockquote>\n<p>Well, this seems to be highly problematic to me. Coq like systems would consider<br>\nnot a function space like ‘a =&gt; bool but ‘a =&gt; prop and start to build al sorts of<br>\n“setoid constructions” as basis of a type… Meaning that complements of setoids <br>\ndo not necessarily exist.</p>\n<p>I am afraid that any attempt to build a typedef in the Pure - Framework will<br>\nwill be too special and ad-hoc for the generality that Pure adresses …</p>\n<p>In my view, the entire construction of typedef’s makes one sense in the<br>\ncontext of a classical set notion (be it ZF like or HOL like).</p>\n<p>bu</p>\n<p>[ … ]</p>",
        "id": 294653552,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661167094
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis \"speculative\" treatment of specification items that may be either <br>\nconsts or types is already part of the Isabelle code base for the coming <br>\nrelease.  I even added a 'print_definitions' command that prints a keyword <br>\n\"type\" with PIDE markup, to make it easier to spot these extremely rare <br>\noccurrences of overloaded type constructors.  Moreover, the syntax <br>\n\"typedef (overloaded)\" makes clear to the user where traditional HOL <br>\ninterpretation according to A. Pitts is transcended.</p>\n<p>Formally all of this is just a certain abstract service of Isabelle/Pure, <br>\nwhich is used inside Pure itself for constant definitions.  Object-logics <br>\nlike Isabelle/HOL then add their own axiomatization schemes with extra <br>\ndependencies, and then call them \"definitional\".  The explanation how this <br>\ncan be justified is in the ITP paper, despite some gaps compared to the <br>\nactual code.</p>\n<p>Thus we are back to the standard invariant of Isabelle development over 3 <br>\ndecades, that the concepts behind the implementation and the concepts <br>\nbehind published papers are slightly divergent.</p>\n<p>Makarius</p>",
        "id": 294657153,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168517
    }
]