[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@infosun.fim.uni-passau.de\">lochbihl@infosun.fim.uni-passau.de</a>&gt;<br>\nHi Peter,</p>\n<p>if you look in the original TransitiveClosure theory of HOL, you also<br>\nfind an extra rule for pairs.<br>\nHowever, you do not have to prove the induction rule by hand, but you<br>\ncan have Isabelle generate it for you:</p>\n<p>In TransitiveClosure.thy:<br>\nlemmas rtrancl_induct2 =<br>\nrtrancl_induct[of \"(ax,ay)\" \"(bx,by)\", split_format (complete),<br>\nconsumes 1, case_names refl step]</p>\n<p>So, your trcl_pair_induct could be written as<br>\nlemmas trcl_pair_induct =<br>\ntrcl_induct[of \"(xc1,xc2)\" \"xb\" \"(xa1,xa2)\", split_format (complete),<br>\nconsumes 1, case names empty cons]</p>\n<p>Induction over inductive sets where the element to be in the set in the<br>\npremises is not of the most general form is always a problem because<br>\ninduct discards everything like pairs, a fixed parameter and the like.</p>\n<p>An alternative would be to reformulate the lemma you want to prove, but<br>\nthis is very tedious if you have to do it multiple times.</p>\n<p>lemma preserves_cl: \"[| (c,w,c') : trcl T; c = (a, b); c' = (a', b') |]<br>\n     \\&lt;Longrightarrow&gt; Prop a b \\&lt;Longrightarrow&gt; Prop a' b'\"</p>\n<p>Regards,<br>\nAndreas</p>",
        "id": 294051577,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819704
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nI have the following problem with set induction and pair datatypes,<br>\nillustrated in the pice of code below:</p>\n<p>-- \"Defining transitive closure of labeled transition system as<br>\ninductive set\"<br>\ntypes ('c,'a) LTS = \"('c \\&lt;times&gt; 'a \\&lt;times&gt; 'c) set\"</p>\n<p>text {* Transitive closure of LTS *}<br>\nconsts trcl :: \"('c,'a) LTS \\&lt;Rightarrow&gt; ('c,'a list) LTS\"</p>\n<p>inductive \"trcl t\"<br>\nintros<br>\n  empty[simp]: \"(c,[],c) \\&lt;in&gt; trcl t\"<br>\n  cons[simp]: \"\\&lt;lbrakk&gt; (c,a,c') \\&lt;in&gt; t; (c',w,c'') \\&lt;in&gt; trcl t<br>\n\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; (c,a#w,c'') \\&lt;in&gt; trcl t\"</p>\n<p>-- \"Now do some very simple inductive proof, using trcl.induct\"<br>\nconsts T':: \"(nat \\&lt;times&gt; bool \\&lt;times&gt; nat) set\"<br>\nconsts Prop':: \"nat \\&lt;Rightarrow&gt; bool\"</p>\n<p>lemma preserves': \"(a,e,a')\\&lt;in&gt;T' \\&lt;Longrightarrow&gt; Prop' a<br>\n\\&lt;Longrightarrow&gt; Prop' a'\" sorry</p>\n<p>lemma preserves_trcl': \"(a,w,a')\\&lt;in&gt;trcl T' \\&lt;Longrightarrow&gt; Prop' a<br>\n\\&lt;Longrightarrow&gt; Prop' a'\"<br>\n  apply (induct rule: trcl.induct)<br>\n  apply (auto simp add: preserves')<br>\ndone<br>\n-- \"Ok, this works fine !\"</p>\n<p>-- \"Now we want to do the same for states that are pairs: \"<br>\nconsts T:: \"((nat \\&lt;times&gt; nat) \\&lt;times&gt; bool \\&lt;times&gt; (nat \\&lt;times&gt;<br>\nnat)) set\"<br>\nconsts Prop:: \"nat \\&lt;Rightarrow&gt; nat \\&lt;Rightarrow&gt; bool\"</p>\n<p>lemma preserves: \"((a,b),e,(a',b'))\\&lt;in&gt;T \\&lt;Longrightarrow&gt; Prop a b<br>\n\\&lt;Longrightarrow&gt; Prop a' b'\" sorry</p>\n<p>lemma preserves_cl: \"((a,b),w,(a',b'))\\&lt;in&gt;trcl T \\&lt;Longrightarrow&gt; Prop<br>\na b \\&lt;Longrightarrow&gt; Prop a' b'\"<br>\n  apply (induct rule: trcl.induct)<br>\n  oops<br>\n  This did not get the induction correctly, there are the following<br>\nsubgoals:</p>\n<p>1. \\&lt;And&gt;c. Prop a b \\&lt;Longrightarrow&gt; Prop a' b'<br>\n    2. \\&lt;And&gt;aa c c' c'' w. \\&lt;lbrakk&gt;(c, aa, c') \\&lt;in&gt; T; (c', w, c'')<br>\n\\&lt;in&gt; trcl T; Prop a b \\&lt;Longrightarrow&gt; Prop a' b'; Prop a b\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; Prop a' b'<br>\n  the first one is obviously not provable</p>\n<p>What can I do about this ? Currently I'm working around by providing a<br>\nspecialized induction rule for pairs:<br>\nlemma trcl_pair_induct[induct set]:<br>\n  \"\\&lt;lbrakk&gt;((xc1,xc2), xb, (xa1,xa2)) \\&lt;in&gt; trcl t; \\&lt;And&gt;c1 c2. P c1<br>\nc2 [] c1 c2; \\&lt;And&gt;a c1 c2 c1' c2' c1'' c2'' w. \\&lt;lbrakk&gt;((c1,c2), a,<br>\n(c1',c2')) \\&lt;in&gt; t; ((c1',c2'), w, (c1'',c2'')) \\&lt;in&gt; trcl t; P c1' c2'<br>\nw c1'' c2''\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; P c1 c2 (a # w) c1'' c2''\\&lt;rbrakk&gt;<br>\n  \\&lt;Longrightarrow&gt; P xc1 xc2 xb xa1 xa2\"<br>\n  using trcl.induct[of \"(xc1,xc2)\" xb \"(xa1,xa2)\" t \"\\&lt;lambda&gt;c w c'.<br>\nlet (c1,c2)=c in let (c1',c2')=c' in P c1 c2 w c1' c2'\"] by auto</p>\n<p>Is this the way to go, or is there another (nicer) possibility, i.e. one<br>\ngeneric scheme that can handle pairs, triples and so on</p>\n<p>Many thanks in advance, yours<br>\nPeter</p>",
        "id": 294052040,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819906
    }
]