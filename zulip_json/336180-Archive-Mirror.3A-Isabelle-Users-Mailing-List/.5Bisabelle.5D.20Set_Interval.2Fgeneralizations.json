[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I noticed that many theorems in the theory Set_Interval (part of the main<br>\nHOL library) can be generalized. For example, certain theorems that are<br>\nstated for linear orders are applicable to partial orders and certain<br>\ntheorems that are stated for partial orders are applicable to preorders:<br>\nthe code listing below provides a non-exhaustive list of examples (I use<br>\nIsabelle2019 as a reference, but, I believe, the situation is similar in<br>\nIsabelle-dev). Was there a good reason for not stating these theorems in<br>\nthe more general form? Also, please let me know whether it is worth<br>\nmentioning other similar issues on the mailing list.</p>\n<p>Thank you</p>\n<p>(* The proofs were obtained using Sledgehammer. However, of course, I can<br>\nprovide proofs of reasonable quality upon request, if necessary. *)</p>\n<p>section ‹Example›<br>\ntheory example<br>\n  imports Main<br>\nbegin</p>\n<p>(*lemma atLeast_eq_iff [iff]:<br>\n     \"(atLeast x = atLeast y) = (x = (y::'a::linorder))\"<br>\nby (blast intro: order_antisym order_trans)*)</p>\n<p>lemma atLeast_eq_iff [iff]: \"(atLeast x = atLeast y) = (x = (y::'a::order))\"<br>\n  by (metis antisym atLeast_iff order_refl)</p>\n<p>(*lemma atMost_eq_iff [iff]: \"(atMost x = atMost y) = (x =<br>\n(y::'a::linorder))\"<br>\n  by (blast intro: order_antisym order_trans)*)</p>\n<p>lemma atMost_eq_iff [iff]: \"(atMost x = atMost y) = (x = (y::'a::order))\"<br>\n  by (metis atLeastAtMost_def atLeastAtMost_singleton_iff)</p>\n<p>(*lemma single_Diff_lessThan [simp]: \"!!k:: 'a::order. {k} - lessThan k =<br>\n{k}\"<br>\n  by auto*)</p>\n<p>lemma single_Diff_lessThan[simp]: \"!!k:: 'a::preorder. {k} - lessThan k =<br>\n{k}\"<br>\n  by auto</p>\n<p>(*lemma atLeast_subset_iff[iff]:<br>\n     \"(atLeast x ⊆ atLeast y) = (y ≤ (x::'a::order))\"<br>\n  by (blast intro: order_trans)*)</p>\n<p>lemma atLeast_subset_iff'[iff]:<br>\n     \"(atLeast x ⊆ atLeast y) = (y ≤ (x::'a::preorder))\"<br>\n  by (meson atLeast_iff in_mono order_refl order_trans subsetI)</p>\n<p>(*lemma atMost_subset_iff[iff]: \"(atMost x ⊆ atMost y) = (x ≤<br>\n(y::'a::order))\"<br>\n  by (blast intro: order_trans)*)</p>\n<p>lemma atMost_subset_iff[iff]: \"(atMost x ⊆ atMost y) = (x ≤<br>\n(y::'a::preorder))\"<br>\n  by (meson atMost_iff in_mono order_refl order_trans subsetI)</p>\n<p>subsubsection‹Emptyness, singletons, subset›</p>\n<p>(* The following theorems are stated in the context of Orderings.order in<br>\nthe theory Set_Interval. *)<br>\ncontext Orderings.preorder<br>\nbegin</p>\n<p>lemma atLeastatMost_empty[simp]:<br>\n  \"b &lt; a ⟹ {a..b} = {}\"<br>\n  by (metis equals0I local.less_le_not_le local.order_trans<br>\nord.atLeastAtMost_iff)</p>\n<p>lemma atLeastatMost_empty_iff[simp]:<br>\n  \"{a..b} = {} ⟷ (¬ a ≤ b)\"<br>\n  by (metis empty_iff equals0I local.order_refl local.order_trans<br>\nord.atLeastAtMost_iff)</p>\n<p>lemma atLeastatMost_empty_iff2[simp]:<br>\n  \"{} = {a..b} ⟷ (¬ a ≤ b)\"<br>\n  using local.atLeastatMost_empty_iff by blast</p>\n<p>lemma atLeastLessThan_empty[simp]:<br>\n  \"b &lt;= a ⟹ {a..&lt;b} = {}\"<br>\n  by (metis equals0I local.le_less_trans local.less_le_not_le<br>\nord.atLeastLessThan_iff)</p>\n<p>lemma atLeastLessThan_empty_iff[simp]:<br>\n  \"{a..&lt;b} = {} ⟷ (¬ a &lt; b)\"<br>\n  using local.le_less_trans by auto</p>\n<p>lemma atLeastLessThan_empty_iff2[simp]:<br>\n  \"{} = {a..&lt;b} ⟷ (¬ a &lt; b)\"<br>\n  using local.atLeastLessThan_empty_iff by blast</p>\n<p>lemma greaterThanAtMost_empty[simp]: \"l ≤ k ==&gt; {k&lt;..l} = {}\"<br>\n  by (metis equals0I local.less_le_not_le local.less_le_trans<br>\nord.greaterThanAtMost_iff)</p>\n<p>lemma greaterThanAtMost_empty_iff[simp]: \"{k&lt;..l} = {} ⟷ ¬ k &lt; l\"<br>\n  using local.greaterThanAtMost_def local.less_le_trans by auto</p>\n<p>lemma greaterThanAtMost_empty_iff2[simp]: \"{} = {k&lt;..l} ⟷ ¬ k &lt; l\"<br>\n  using local.greaterThanAtMost_empty_iff by blast</p>\n<p>lemma greaterThanLessThan_empty[simp]:\"l ≤ k ==&gt; {k&lt;..&lt;l} = {}\"<br>\n  by (metis equals0I local.le_less_trans local.less_irrefl local.less_trans<br>\nord.greaterThanLessThan_iff)</p>\n<p>lemma atLeastatMost_subset_iff[simp]:<br>\n  \"{a..b} ≤ {c..d} ⟷ (¬ a ≤ b) ∨ c ≤ a ∧ b ≤ d\"<br>\n  by (meson local.atLeastAtMost_iff local.eq_refl local.order_trans subsetD<br>\nsubsetI)</p>\n<p>lemma atLeastatMost_psubset_iff:<br>\n  \"{a..b} &lt; {c..d} ⟷<br>\n   ((¬ a ≤ b) ∨ c ≤ a ∧ b ≤ d ∧ (c &lt; a ∨ b &lt; d)) ∧ c ≤ d\"<br>\n  by (smt local.atLeastatMost_subset_iff local.less_le_not_le psubset_eq<br>\nsubset_not_subset_eq)</p>\n<p>lemma Icc_subset_Ici_iff[simp]:<br>\n  \"{l..h} ⊆ {l'..} = (¬ l≤h ∨ l≥l')\"<br>\n  by (metis emptyE local.atLeastAtMost_iff local.atLeastatMost_empty_iff<br>\nlocal.eq_refl ord.atLeast_iff subsetD subsetI)</p>\n<p>lemma Icc_subset_Iic_iff[simp]:<br>\n  \"{l..h} ⊆ {..h'} = (¬ l≤h ∨ h≤h')\"<br>\n  by (metis Int_iff Int_subset_iff empty_subsetI inf_absorb2<br>\nlocal.atLeastAtMost_iff local.atLeastatMost_empty_iff2<br>\nlocal.atLeastatMost_subset_iff local.atMost_iff local.order_refl<br>\nord.atLeastAtMost_def)</p>\n<p>lemma not_Ici_eq_empty[simp]: \"{l..} ≠ {}\"<br>\n  by blast</p>\n<p>lemma not_Iic_eq_empty[simp]: \"{..h} ≠ {}\"<br>\n  by blast</p>\n<p>end</p>\n<p>end</p>",
        "id": 294763067,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200572
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYes, there are many such issues. Whenever a theorem can be straightforwardly generalised, please let us know so that we can fix it.</p>\n<p>Larry Paulson</p>",
        "id": 294763177,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200628
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Lawrence Paulson,</p>\n<p>Thank you for your email. I am glad that the information that I provided<br>\nwas useful. Please find a list of several further results that can be<br>\neasily generalized in the code listing below.</p>\n<p>Thank you</p>\n<p>section ‹Example›<br>\ntheory example<br>\n  imports Complex_Main<br>\nbegin</p>\n<p>(<em>from order</em>)<br>\ncontext preorder<br>\nbegin</p>\n<p>(<em>Transitive_Closure</em>)<br>\nlemma acyclicI_order:<br>\n  fixes f :: \"'b ⇒ 'a\"<br>\n  assumes *: \"⋀a b. (a, b) ∈ r ⟹ f b &lt; f a\"<br>\n  shows \"acyclic r\"<br>\n  sorry</p>\n<p>end</p>\n<p>(<em>from linorder</em>)<br>\ncontext order<br>\nbegin</p>\n<p>(<em>Orderings</em>)<br>\nlemma antisym_conv1: \"¬ x &lt; y ⟹ x ≤ y ⟷ x = y\"<br>\n  sorry</p>\n<p>(<em>Orderings</em>)<br>\nlemma antisym_conv2: \"x ≤ y ⟹ ¬ x &lt; y ⟷ x = y\"<br>\n  sorry</p>\n<p>(<em>Orderings</em>)<br>\nlemma leD: \"y ≤ x ⟹ ¬ x &lt; y\"<br>\n  sorry</p>\n<p>(<em>Topological_Spaces</em>)<br>\nlemma less_separate:<br>\n  assumes \"x &lt; y\"<br>\n  shows \"∃a b. x ∈ {..&lt; a} ∧ y ∈ {b &lt;..} ∧ {..&lt; a} ∩ {b &lt;..} = {}\"<br>\n  sorry</p>\n<p>end</p>\n<p>(<em>from dense_linorder</em>)<br>\ncontext linorder<br>\nbegin</p>\n<p>(<em>Set_Interval</em>)<br>\nlemma atLeastAtMost_subseteq_atLeastLessThan_iff:<br>\n  \"{a .. b} ⊆ { c ..&lt; d } ⟷ (a ≤ b ⟶ c ≤ a ∧ b &lt; d)\"<br>\n  sorry</p>\n<p>end</p>",
        "id": 294763240,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661200664
    }
]