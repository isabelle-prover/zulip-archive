[
    {
        "content": "<p>From: Peter Chapman &lt;<a href=\"mailto:pc@cs.st-and.ac.uk\">pc@cs.st-and.ac.uk</a>&gt;<br>\nHi</p>\n<p>I wish to prove a theorem that uses induction based on a pair of  <br>\nnatural numbers.  To make this concrete, I have that</p>\n<p>wf (less_than &lt;<em>lex</em>&gt; less_than)</p>\n<p>and then I have proved the induction scheme</p>\n<p>lemma my_wf_induct_pair:<br>\n  assumes    b: \"/\\x. [| /\\y. ((fst y,snd y),(fst x,snd x))<br>\n                                     \\&lt;in&gt; (less_than &lt;<em>lex</em>&gt;  <br>\nless_than) -&gt; P y |] =&gt; P x\"<br>\n  shows \"P x\"<br>\n(proof omitted)<br>\ndone</p>\n<p>Now, in the lemma I wish to prove, I have two natural numbers, one of  <br>\nwhich is computed using a function form =&gt; nat called \"depth\", and the  <br>\nother which is the sum of two other natural numbers, n and m.  So, I  <br>\nwrote</p>\n<p>lemma cutAdmissibility:<br>\nfixes A :: \"form\"<br>\n   and n m :: \"nat\"<br>\nassumes a: \"Gam =&gt;* A at n\" \"Gam + {#A#} =&gt;* C at m\"<br>\nshows \"\\&lt;exists&gt; k. Gam =&gt;* C at k\"<br>\nusing a<br>\nproof (induct \"depth A\" \"n+m+1\" arbitrary: Gam C rule:  <br>\nmy_wf_induct_pair)</p>\n<p>but I get the error message</p>\n<p>*** Ill-typed instantiation:<br>\n***   depth A :: nat<br>\n*** At command \"proof\".</p>\n<p>How do I get Isabelle to do the induction based on the lexicographic  <br>\npath ordering of (depth A, n+m+1)?  I've tried putting</p>\n<p>proof (induct (\"depth A\",n+m+1) arbitrary : Gam C  <br>\nrule:,my_wf_induct_pair)</p>\n<p>but then I get a \"bad argument\" error.</p>\n<p>Many thanks</p>\n<p>Peter</p>",
        "id": 294057233,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822089
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis fails because the induction priciple is only about a single argument <br>\n(a nat pair), not two individual nats.</p>\n<p>Here is my version of the induction principle:</p>\n<p>abbreviation<br>\n  less_prod_nat  (infix \"&lt;&lt;\" 50) where<br>\n  \"p &lt;&lt; q == (p, q) : less_than &lt;<em>lex</em>&gt; less_than\"</p>\n<p>lemma nat_prod_induct [case_names less]:<br>\n  fixes x y :: nat<br>\n  assumes induct_step: \"!!x y. (!!u v. (u, v) &lt;&lt; (x, y) ==&gt; P u v) ==&gt; P x y\"<br>\n  shows \"P x y\"<br>\nproof -<br>\n  have \"wf (less_than &lt;<em>lex</em>&gt; less_than)\" by blast<br>\n  then show ?thesis<br>\n  proof (induct p == \"(x, y)\" arbitrary: x y)<br>\n    case (less p)<br>\n    show \"P x y\"<br>\n    proof (rule induct_step)<br>\n      fix u v<br>\n      assume \"(u, v) &lt;&lt; (x, y)\"<br>\n      with less show \"P u v\" by simp<br>\n    qed<br>\n  qed<br>\nqed</p>\n<p>This may already serve as an example how to deal with tricky inductions in <br>\ngeneral (see also src/HOL/Induct/Common_Patterns.thy for further <br>\npatterns).  The idea is to represent the pair p as a concrete expression <br>\n\"(x, y)\" for arbitrary x and y, and pass this information through the <br>\ninduction.  In the body, the \"less\" case (which is the only case of the <br>\ninduction scheme) will hold all this information, although in a slightly <br>\ncrude form involving explicit equalities again.  The Simplifier manages to <br>\nreduce this in the final step, towards a clean result.</p>\n<p>Here is an example application of the above rule:</p>\n<p>lemma<br>\n  fixes a :: 'a<br>\n    and f g :: \"'a =&gt; nat\"<br>\n  assumes \"A (f a) (g a)\"<br>\n  shows \"P (f a) (g a)\"<br>\nusing assms<br>\nproof (induct x == \"f a\" y == \"g a\" arbitrary: a rule: nat_prod_induct)<br>\n  case (less x y)<br>\n  then have \"!!b. A (f b) (g b) ==&gt;<br>\n      (f b, g b) &lt;&lt; (x, y) ==&gt; P (f b) (g b)\"<br>\n    by simp<br>\n  note <code>x = f a</code> and <code>y = g a</code><br>\n  note <code>A (f a) (g a)</code><br>\n  show \"P (f a) (g a)\" sorry<br>\nqed</p>\n<p>The best way of spelling out the body of an induction proof depends a <br>\nlittle on your particular application.  Above the raw constituents are <br>\npresented in a reasonably digestible form.  At some point the \"induct\" <br>\nproof method might get smarter in taking care of equational reductions <br>\nwithout requiring the above \"simp\" steps.</p>\n<p>Makarius</p>",
        "id": 294057379,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822157
    }
]