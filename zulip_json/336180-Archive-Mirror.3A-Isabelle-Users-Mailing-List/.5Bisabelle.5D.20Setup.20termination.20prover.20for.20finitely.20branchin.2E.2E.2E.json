[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nNo idea about why what you are doing does not work, but the following<br>\ndoes work:</p>\n<p>lemma le_setsum_nat [termination_simp]:<br>\n  assumes \"finite A\" \"x ∈ A\"<br>\n  shows   \"f (g x) ≤ (∑x∈A. f (g x) :: nat)\"<br>\nproof -<br>\n  have \"f (g x) = (∑x∈{x}. f (g x))\" by simp<br>\n  also from assms have \"… ≤ (∑x∈A. f (g x))\" by (intro setsum_mono2) auto<br>\n  finally show ?thesis by simp<br>\nqed</p>\n<p>Note that it doesn't work if you replace \"f (g x)\" with just \"f x\".<br>\nUnification problem, perhaps?</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294660068,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169585
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>Thanks for the suggestion, your rule does suffice to prove the termination of my given <br>\nexample. It differs from the existing estimation rules in that the left hand side of the <br>\nconclusion must be exactly of the summation form. The existing rules encode a transitivity <br>\nstep</p>\n<p>\"[| y &lt;= f (g x); f (g x) &lt;= (∑x∈A. f (g x)) |] ==&gt; y &lt;= (∑x∈A. f (g x))\"</p>\n<p>and this is what introduces the schematic variable ?x in the assumptions which cause all <br>\nthe trouble. And in general, this transitivity step is indeed needed (and your rule fails <br>\nthere). For example, if the recursion in the datatype goes through another type.</p>\n<p>datatype (plugins del: size) 'a tree2 = Leaf2 | Node2 'a \"char ⇒ 'a tree2 × 'a\"</p>\n<p>instantiation tree2 :: (type) size begin<br>\nprimrec size_tree2 :: \"'a tree2 ⇒ nat\"<br>\nwhere<br>\n   \"size_tree2 Leaf2 = 0\"<br>\n| \"size_tree2 (Node2 x ts) =<br>\n    Suc (setsum (Suc ∘ fst ∘ (map_prod size_tree2 id ∘ ts)) UNIV)\"<br>\ninstance ..<br>\nend</p>\n<p>fun zip_prod where \"zip_prod f g (x, y) (u, v) = (f x u, g y v)\"</p>\n<p>fun zip_tree2 :: \"'a tree2 ⇒ 'b tree2 ⇒ ('a × 'b) tree2\"<br>\nwhere<br>\n   \"zip_tree2 (Node2 x ts) (Node2 y ts') =<br>\n    Node2 (x, y) (λz. zip_prod zip_tree2 Pair (ts z) (ts' z))\"<br>\n| \"zip_tree2 _ _ = Leaf2\"</p>\n<p>Do you think one can generalise your rule in a way such that it still works with <br>\nlexicographic_order?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294660090,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169591
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear experts of the simplifier and/or the function package,</p>\n<p>For a datatype of finitely branching trees, I would like to setup the terminiation prover <br>\nof the function package such that it can automatically prove termination of my recursive <br>\nfunctions. My problem is that I cannot mimick the setup for other datatypes like lists and <br>\nI am running out of ideas how this can be fit into lexicographic order.</p>\n<p>Here is my usecase and the analysis of the problem. The datatype tree recurses through the <br>\nfunction type, but the domain of the functions is finite. Thus, it is possible to define a <br>\nsize function, although this must be done manually in Isabelle2015 (using setsum for <br>\nsumming the sizes of the subtrees).</p>\n<p>datatype (plugins del: size) 'a tree = Leaf | Node 'a \"char ⇒ 'a tree\"</p>\n<p>instantiation tree :: (type) size begin<br>\nprimrec size_tree :: \"'a tree ⇒ nat\" where<br>\n   \"size_tree Leaf = 0\"<br>\n| \"size_tree (Node x ts) = Suc (setsum (size_tree ∘ ts) UNIV)\"<br>\ninstance ..<br>\nend</p>\n<p>Now, I would like lexicographic_order to prove termination of a function definition such <br>\nas the following:</p>\n<p>fun zip_tree :: \"'a tree ⇒ 'b tree ⇒ ('a × 'b) tree\"<br>\nwhere<br>\n   \"zip_tree (Node x ts) (Node y ts') = Node (x, y) (λz. zip_tree (ts z) (ts' z))\"<br>\n| \"zip_tree _ _ = Leaf\"</p>\n<p>Without further setup, the termination proof fails because the proof tactic cannot solve <br>\ngoals such as the following.</p>\n<ol>\n<li>⋀ts' xa. size (ts' xa) &lt; Suc (∑x∈UNIV. size (ts' x))</li>\n</ol>\n<p>For recursion through lists, there is a custom setup, namely the theorems <br>\nsize_list_estimation and size_list_estimation' which are declared as [termination_simp].</p>\n<p>thm size_list_estimation'   ⟦?x ∈ set ?xs; ?y ≤ ?f ?x⟧ ⟹ ?y ≤ size_list ?f ?xs</p>\n<p>Now I tried to mimick this setup for the setsum operator:</p>\n<p>lemma setsum_estimation'[termination_simp]:<br>\n   \"(y :: nat) ≤ f x ⟹ finite (UNIV :: 'a set) ⟹ y ≤ setsum f (UNIV :: 'a set)\"</p>\n<p>From what I could see from the code, these *_estimation rules work as follows:</p>\n<ul>\n<li>\n<p>lexicographic_order internally uses the proof method (auto simp add: termination_simp)<br>\nto solve the goals, that is, the termination proof are solved mostly by conditional rewriting.</p>\n</li>\n<li>\n<p>In particular, termination_simp contains the rule ?m ≤ ?n ⟹ ?m &lt; Suc ?n, so the above <br>\nsubgoal 1. can be solved if the simplifier can prove \"size (ts' xa) &lt;= (∑x∈UNIV. size (ts' <br>\nx))\". And this is where *_estimation' triggers.</p>\n</li>\n</ul>\n<p>Unfortunately, the simplifier does not like setsum_estimation' as much as it likes <br>\nsize_list_estimation'. Both rules contain the free variable ?x in the assumptions that is <br>\nnot bound by the conclusion, so trouble is to be expected.</p>\n<p>In the case of size_list_estimation', the first premise <code>?x : set ?xs</code> instantiates the ?x <br>\nbecause the termination goal typically contains an assumption <code>x : set xs</code> due to a <br>\ncongrence rule (and the simplifier calls the HOL unsafe solver, which instantiates the <br>\nvariable as a matching assumption is available). Thus, the second assumption <code>?y &lt;= ?f ?x</code> <br>\nno longer contains schematic variables and the simplifier can usually discharge the goal.</p>\n<p>In case of setsum_estimation', there is no such first premise that could instantiate ?x <br>\n(because the corresponding assumption would be \"?x : UNIV\" which holds trivially). Thus, <br>\nthe recursive invocation of the simplifier is left with a goal such as</p>\n<p>\"!!x. f x &lt;= f (?x x)\"</p>\n<p>Simplification fails (because there is no suitable solver) and thus it cannot prove <br>\ntermination.</p>\n<p>If I add a solver to the simpset which applies the rule \"order_refl\", then the termination <br>\nproof succeeds. Yet, my feeling says that such a solver is not a good idea in general, <br>\nbecause it will instantiate variables too aggressively. So this looks like a hack that is <br>\nbetter avoided.</p>\n<p>Are there ideas for a better size function or a better setup for termination_simp? Has <br>\nanyone else run into this problem before?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294661383,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661170033
    }
]