[
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>Recently, I started using the functionality of Isabelle/HOL that is<br>\nassociated with \"types to sets\". However, I am not certain if I am using<br>\nthis functionality in the most appropriate manner. Questions 1-3 are<br>\ngeneral questions about the functionality of \"types to sets\" and its<br>\napplications in HOL; question 4 is specific to my application and not<br>\ndirectly related to \"types to sets\".</p>\n<ol>\n<li>I was not able to find the documentation for the functionality<br>\nassociated with \"types to sets\" in the standard distribution of<br>\nIsabelle/HOL. I would appreciate if anyone could point me in the right<br>\ndirection.</li>\n</ol>\n<p>I would like to apologise in advance for asking questions 2 and 3 if the<br>\nanswers to these questions are already available in the documentation or in<br>\nanother post on the mailing list.</p>\n<ol start=\"2\">\n<li>\n<p>Theories Finite.thy and T2_Spaces.thy in the folder<br>\nHOL/Types_To_Sets/Examples contain the following line: \"The aforementioned<br>\ndevelopment can be automated. The main part is already automated by the<br>\ntransfer_prover.\". This comment follows immediately after the specification<br>\nof the 'relativised' definitions and the transfer rules for these<br>\ndefinitions (e.g. lines 27-103 in the theory T2_Spaces.thy). I would like<br>\nto understand how exactly one should approach the automation of the<br>\nspecification of the 'relativised' definitions and the transfer rules for<br>\nthem. Indeed, some of the transfer rules that are used in my application do<br>\nnot seem to be entirely trivial to prove. It would also be useful to be<br>\nable to generate definitions automatically. However, the aforementioned<br>\nexamples do not elaborate on how this can be done. I would appreciate if<br>\nsomeone with experience in using 'types to sets' could provide an example<br>\nof an application of the automation to the lines 27-103 in the theory<br>\nT2_Spaces.thy.</p>\n</li>\n<li>\n<p>At the moment I am in the process of the relativisation of several<br>\ntheorems about topological spaces in HOL (e.g. results in<br>\nAnalysis/Topology_Euclidean_Space). However, I am curious to know if<br>\nthe main results about topological spaces have already been relativised<br>\nsomewhere. If not, are there any plans to do it in the context of the<br>\nofficial development of HOL. I find it rather odd that the relativised<br>\nversions of theorems about topological spaces in HOL do not seem to be<br>\navailable anywhere in the standard distribution (unless, of course, they<br>\nare and I am not being able to find them).</p>\n</li>\n<li>\n<p>The final question is technical in nature and not directly related to<br>\n\"types to sets\". The theory Analysis/Topology_Euclidean_Space defines the<br>\nclass \"second_countable_topology\". This class provides an explicit type<br>\nsort constraint in the specification of its assumptions:</p>\n</li>\n</ol>\n<p>class second_countable_topology = topological_space +<br>\n  assumes ex_countable_subbasis:<br>\n    \"∃B::<em>'a::topological_space set set</em>. countable B ∧ open =<br>\ngenerate_topology B\"</p>\n<p>This seems to cause a problem when using \"class.second_countable_topology\"<br>\nas an explicit predicate. For example, anecdotally, it is possible to prove</p>\n<p>definition \"Sorgenfrey_Basis_ll = {x. x ∈ {x::real set. ∃a b. x = {a..&lt;b}}}\"<br>\ndefinition \"Sorgenfrey_Line_ll = generate_topology Sorgenfrey_Basis_ll\"</p>\n<p>interpretation real : second_countable_topology \"Sorgenfrey_Line_ll\"<br>\n  sorry</p>\n<p>because the goal of the interpretation unfolds to 'class.topological_space<br>\nSorgenfrey_Line_ll ∧ class.second_countable_topology_axioms <em>TYPE(real)</em>'</p>\n<p>The same issue causes problems for other use cases of the<br>\n\"class.second_countable_topology\" as an explicit predicate (e.g. in the<br>\nspecification of the transfer rules for a relativised definition following<br>\nthe methodology in the example T2_Spaces.thy). Thus, I would like to<br>\nunderstand if there is any method that one can use to resolve the issue and<br>\nensure that the \"class.second_countable_topology\" can be used as an<br>\nexplicit predicate with the 'intended' meaning of 'open'.</p>\n<p>Thank you</p>",
        "id": 294748883,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194630
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nAs it happens, I have been porting large sections of the HOL Light metric space library, which includes many results about topological spaces relativized to explicit topologies (as opposed to the topological_space type class). I have gradually been transferring these results into the Analysis library, where they will become visible in the development version of Isabelle and ultimately in the next release.</p>\n<p>I’m interested in the “types to sets” mechanism, but I have never been able to figure it out.</p>\n<p>Larry Paulson</p>",
        "id": 294748897,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194636
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is the initial NEWS entry from Isabelle2016-1 (December 2016):</p>\n<ul>\n<li>Session HOL-Types_To_Sets provides an experimental extension of<br>\nHigher-Order Logic to allow translation of types to sets.</li>\n</ul>\n<p>That was the proof-of-concept implementation from the ITP2016 paper by<br>\nOndrej Kuncar and Andrei Popescu.</p>\n<p>There was still quite a lot missing for production quality. Already in<br>\nsummer 2016 I had sent a many concrete hints to the authors to improve<br>\nthe implementation, but hardly anything has happened since then.</p>\n<p>More recently, Fabian Immler has polished this preliminary version a<br>\nbit, see NEWS in Isabelle2018 (August 2018):</p>\n<ul>\n<li>Session HOL-Types_To_Sets: more tool support (unoverload_type combines<br>\ninternalize_sorts and unoverload) and larger experimental application<br>\n(type based linear algebra transferred to linear algebra on subspaces).<p>Makarius</p>\n</li>\n</ul>",
        "id": 294748912,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194644
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMany thanks. I hope it will be usable soon, though I’m not sure whether it will ever replace large-scale porting efforts such as the one I’m engaged in (as opposed to allowing one-off instantiations of important theorems within proofs).</p>\n<p>Larry</p>",
        "id": 294748938,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194655
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Professor Lawrence Paulson,</p>\n<p>Thank you for your reply. If possible, I would like to understand if the<br>\ndevelopment work that you are referring to is related to the type<br>\n'topology' (line 19 in the theory Analysis/Abstract_Topology.thy in the<br>\ndevelopment version of Isabelle). In this case, of course, I am familiar<br>\nwith some of the content of the theories that are related to this type.<br>\nIndeed, my intention is to use \"types to sets\" as an interface between the<br>\ntype class 'topological_space' (and its subclasses) and the type 'topology'.</p>\n<p>As a side note, I would like to clarify for anyone else who might wish to<br>\nprovide any comments in relation to my original query that in Question 3 in<br>\nmy email I am referring specifically to the relativisation of the results<br>\nabout the type class 'topological_spaces' (and its subclasses) using the<br>\nmethodology associated with \"types to sets\" (nevertheless, of course, any<br>\nfurther comments about similar developments are highly appreciated). Thus,<br>\nto be more specific, I would like to understand if anyone is using \"types<br>\nto sets\" for the relativisation of the results about the type class<br>\n'topological_spaces' (and its subclasses) to sets.</p>\n<p>Thank you</p>",
        "id": 294748966,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194667
    },
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:immler@in.tum.de\">immler@in.tum.de</a>&gt;<br>\nI am not using it, but I would like to use \"types to sets\" at some point <br>\nfor the purpose of relativizing topological results.</p>\n<p>Just recently (isabelle/ab5a8a2519b0), I added some more tooling towards <br>\nthis goal: automatically defining unoverloaded constants from overloaded <br>\ndefinitions. A \"print_theorems\" after the unoverload_definition command <br>\nin src/HOL/Types_To_Sets/Examples/Unoverload_Def.thy should give an <br>\nintuition about what it is supposed to achieve.</p>\n<p>Best regards,<br>\nFabian<br>\n<a href=\"/user_uploads/14278/HIgOdz4RE1O5naH7MvsJx6bc/smime.p7s\">smime.p7s</a></p>",
        "id": 294748976,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194674
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Fabian Immler,</p>\n<p>Thank you for your reply.</p>\n<p>Unfortunately, I did not update the repository immediately before asking<br>\nthe question and it was several days out of date. Thus, I was not aware of<br>\nyour work on 'unoverload_definition'. Indeed, the functionality that is<br>\nprovided by this tool is very useful and partially answers Question 2 from<br>\nmy original query. Also, I look forward to seeing your version of the<br>\nrelativised results about the topological spaces in HOL.</p>\n<p>To complete my understanding of the current status of the development of<br>\n\"types to sets\" (from the 'user' perspective), I would like to know if, at<br>\nthe moment, it is necessary to prove the transfer rules for each definition<br>\nmanually. It seems that for some definitions the goals for the transfer<br>\nrules are not trivial to prove automatically, i.e. it seems to be necessary<br>\nto use a substantial amount of code for such proofs (although, indeed, all<br>\nproofs follow a very similar outline). Perhaps, I am not familiar enough<br>\nwith the methods that one would normally use for such proofs. For example,<br>\nthe only method that I know that can be used to prove</p>\n<p>inductive generate_topology_on :: \"'a set set ⇒ 'a set ⇒ 'a set ⇒ bool\"<br>\n  for S :: \"'a set set\"<br>\n  where<br>\n    UNIV: \"generate_topology_on S A A\"<br>\n  | Int: \"generate_topology_on S A (a ∩ b)\"<br>\n  if \"generate_topology_on S A a\" and \"generate_topology_on S A b\" and<br>\n    \"a ⊆ A\" and \"b ⊆ A\"<br>\n  | UN: \"generate_topology_on S A (⋃K)\"<br>\n    if \"(⋀k. k ∈ K ⟹ k ⊆ A ⟹ generate_topology_on S A k)\"<br>\n  | Basis: \"generate_topology_on S A s\" if \"s ∈ S\" and \"s ⊆ A\"</p>\n<p>lemma [transfer_rule]:<br>\n  includes lifting_syntax<br>\n  assumes [transfer_rule]: \"right_total T\" \"bi_unique T\"<br>\n  shows<br>\n    \"((rel_set (rel_set T)) ===&gt; (rel_set T ===&gt; (=)))<br>\n    (λB. generate_topology_on B (Collect (Domainp T))) generate_topology\"</p>\n<p>is induction used explicitly in both directions. The resulting proof is<br>\nover one hundred lines long. Therefore, it seems that the required effort<br>\nis not reasonable for something that should be possible to automate. Even<br>\npartial advice on either one of the queries in this paragraph will be<br>\nhighly appreciated.</p>\n<p>Thank you</p>",
        "id": 294749041,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194685
    },
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:immler@in.tum.de\">immler@in.tum.de</a>&gt;<br>\nHi  ,</p>\n<p>On 1/21/2019 5:59 PM, mailing-list anonymous wrote:</p>\n<blockquote>\n<p>To complete my understanding of the current status of the development of<br>\n\"types to sets\" (from the 'user' perspective), I would like to know if, at<br>\nthe moment, it is necessary to prove the transfer rules for each definition<br>\nmanually.<br>\nIn a way, yes. At the moment, you need to state the transfer rule for <br>\neach of your constants manually. For plain definitions, the method <br>\n\"transfer_prover\" will automatically prove those rules.</p>\n</blockquote>\n<p>For definitions that involve e.g., choice, the situation is not so <br>\nclear. I guess it usually helps to define a similar constant that <br>\ndefaults to a parametric value when the choice is non-unique.<br>\nSee for example the definition of sum_with:<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Types_To_Sets/Examples/Group_On_With.thy#l290\">http://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Types_To_Sets/Examples/Group_On_With.thy#l290</a></p>\n<blockquote>\n<p>It seems that for some definitions the goals for the transfer<br>\nrules are not trivial to prove automatically, i.e. it seems to be necessary<br>\nto use a substantial amount of code for such proofs (although, indeed, all<br>\nproofs follow a very similar outline). Perhaps, I am not familiar enough<br>\nwith the methods that one would normally use for such proofs. For example,<br>\nthe only method that I know that can be used to prove</p>\n<p>inductive generate_topology_on :: \"'a set set ⇒ 'a set ⇒ 'a set ⇒ bool\"<br>\n   for S :: \"'a set set\"<br>\n   where<br>\n     UNIV: \"generate_topology_on S A A\"<br>\n   | Int: \"generate_topology_on S A (a ∩ b)\"<br>\n   if \"generate_topology_on S A a\" and \"generate_topology_on S A b\" and<br>\n     \"a ⊆ A\" and \"b ⊆ A\"<br>\n   | UN: \"generate_topology_on S A (⋃K)\"<br>\n     if \"(⋀k. k ∈ K ⟹ k ⊆ A ⟹ generate_topology_on S A k)\"<br>\n   | Basis: \"generate_topology_on S A s\" if \"s ∈ S\" and \"s ⊆ A\"</p>\n<p>lemma [transfer_rule]:<br>\n   includes lifting_syntax<br>\n   assumes [transfer_rule]: \"right_total T\" \"bi_unique T\"<br>\n   shows<br>\n     \"((rel_set (rel_set T)) ===&gt; (rel_set T ===&gt; (=)))<br>\n     (λB. generate_topology_on B (Collect (Domainp T))) generate_topology\"</p>\n<p>is induction used explicitly in both directions.<br>\nAnother option might be to prove transfer rules for lfp (like in the <br>\nattached Scratch.thy). It looks like the named theorems collection <br>\n\"nitpick_unfold\" contains definitions of inductive predicates in terms <br>\nof lfp (I am not sure where they come from, though). It could be that <br>\nthis helps to carry out the proof without induction and in a more <br>\nprincipled way.</p>\n</blockquote>\n<p>Fabian<br>\n<a href=\"/user_uploads/14278/rS4L6nHrlaif588hL2rUd7gf/Scratch.thy\">Scratch.thy</a><br>\n<a href=\"/user_uploads/14278/4Tmgv4EjE3UpaYhIc1HfzHYp/smime.p7s\">smime.p7s</a></p>",
        "id": 294749330,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194809
    },
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:immler@in.tum.de\">immler@in.tum.de</a>&gt;<br>\nAre you sure that this is the definition that you want?<br>\nEvery set that is not a subset of the \"carrier\" A is in the topology:<br>\nlemma \"generate_topology_on S A B\" if \"¬B ⊆ A\"<br>\n   using UN[of \"{B}\" A S] that<br>\n   by simp</p>\n<p>This probably won't play nicely with the topology type in <br>\nAbstract_Topology, which assumes that the carrier is the union of all <br>\nmembers of the topology.</p>\n<p>Fabian<br>\n<a href=\"/user_uploads/14278/CqBgYa2s8GR_dXq0NKBTDogI/smime.p7s\">smime.p7s</a></p>",
        "id": 294749347,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194815
    },
    {
        "content": "<p>From: Fabian Immler &lt;<a href=\"mailto:immler@in.tum.de\">immler@in.tum.de</a>&gt;<br>\nThis does indeed lead to strange effects. I removed the sort constraint <br>\nin isabelle/7aafd0472661.</p>\n<p>Fabian<br>\n<a href=\"/user_uploads/14278/yzlJmv5Tun4UlblOWgqZ0a67/smime.p7s\">smime.p7s</a></p>",
        "id": 294749364,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194821
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Fabian Immler/All,</p>\n<p>Thank you for your replies.</p>\n<p>At the moment, you need to state the transfer rule for</p>\n<blockquote>\n<p>each of your constants manually. For plain definitions, the method<br>\n\"transfer_prover\" will automatically prove those rules.<br>\n</p>\n</blockquote>\n<p>Thank you for clarifying this. I believe that the comment \"The<br>\naforementioned development can be automated. The main part is already<br>\nautomated by the transfer_prover.\" that could be found in some of the<br>\nexamples in HOL/Types_To_Sets/Examples is slightly confusing. Initially, I<br>\nmisinterpreted the comment \"The aforementioned development can be<br>\nautomated\" as an indication that the functionality for automation was<br>\nalready implemented in the context of the development of \"types to sets\",<br>\nbut the examples do not show how this functionality can be used.</p>\n<p>Another option might be to prove transfer rules for lfp (like in the</p>\n<blockquote>\n<p>attached Scratch.thy). It looks like the named theorems collection<br>\n\"nitpick_unfold\" contains definitions of inductive predicates in terms<br>\nof lfp (I am not sure where they come from, though). It could be that<br>\nthis helps to carry out the proof without induction and in a more<br>\nprincipled way.<br>\n</p>\n</blockquote>\n<p>Indeed, I suspected that my proof is naive. Also, thank you for pointing<br>\nout the existence of nitpick_unfold. I can foresee that the theorems from<br>\nthis collection may be useful for other purposes.</p>\n<blockquote>\n<p>Are you sure that this is the definition that you want?<br>\nEvery set that is not a subset of the \"carrier\" A is in the topology:<br>\nlemma \"generate_topology_on S A B\" if \"¬B ⊆ A\"<br>\n  using UN[of \"{B}\" A S] that<br>\n  by simp</p>\n<p>This probably won't play nicely with the topology type in<br>\nAbstract_Topology, which assumes that the carrier is the union of all<br>\nmembers of the topology.<br>\n</p>\n</blockquote>\n<p>Thank you for pointing out this 'impurity' in the definition. However, of<br>\ncourse, it was very easy to correct:</p>\n<p>inductive generate_topology_on :: \"'a set set ⇒ 'a set ⇒ 'a set ⇒ bool\"<br>\n  for S :: \"'a set set\"<br>\n  where<br>\n    UNIV: \"generate_topology_on S A A\"<br>\n  | Int: \"generate_topology_on S A (a ∩ b)\"<br>\n  if \"generate_topology_on S A a\" and \"generate_topology_on S A b\" and<br>\n    \"a ⊆ A\" and \"b ⊆ A\"<br>\n  | UN: \"generate_topology_on S A (⋃K)\"<br>\n  if \"K ⊆ Pow A\" and \"(⋀k. k ∈ K ⟹ generate_topology_on S A k)\"<br>\n  | Basis: \"generate_topology_on S A s\" if \"s ∈ S\" and \"s ⊆ A\"</p>\n<p>lemma \"generate_topology_on S A B ⟹ B ⊆ A\"<br>\n  by (induction rule: generate_topology_on.induct) auto</p>\n<p>The issue was left unnoticed because I have not yet used the definition in<br>\nthe context of the results about the type 'topology'. Thus far, it did not<br>\ncause any problems because the definition topological_space_on_with_def<br>\nfrom HOL/Types_To_Sets/Examples/T2_Spaces does not impose any restrictions<br>\non the sets for which O holds true, provided that these sets are not<br>\nelements of the power set of A, e.g.</p>\n<p>lemma \"topological_space_on_with A (λx. x ∈ {{}, A} ∨ x = UNIV)\"<br>\n  unfolding topological_space_on_with_def by blast</p>\n<p>In my own relativised theorems I restrict the statements to the carrier set<br>\nexplicitly (following the outline presented in<br>\nHOL/Types_To_Sets/Examples/T2_Spaces), e.g.</p>\n<p>lemma topological_basis_imp_subbasis_rel:<br>\n  fixes \"open\" and B and A and S<br>\n  assumes \"topological_space_on_with A open\"<br>\n    and \"B ⊆ Pow A\"<br>\n    and \"topological_basis_on_with A open B\"<br>\n    and \"S ⊆ A\"<br>\n  shows \"open S = generate_topology_on B A S\"</p>\n<p>However, I wonder if some of the statements of the relativised theorems<br>\ncould be simplified further if the definition topological_space_on_with<br>\ncould guarantee that all open sets are in the power set of the carrier.</p>\n<p>There is yet another minor issue that I would like to mention in the<br>\ncontext of the present discussion. The theorem compact_imp_closed_set_based<br>\nfrom the example HOL/Types_To_Sets/Examples/T2_Spaces is stated under the<br>\nassumption that the set A is not empty, i.e.</p>\n<p>lemma compact_imp_closed_set_based:<br>\n  assumes \"(A::'a set) ≠ {}\"<br>\n  shows \"∀open. t2_space_on_with A open ⟶ (∀S⊆A. compact_on_with A open S ⟶<br>\n    closed_on_with A open S)\"</p>\n<p>However, the assumption \"(A::'a set) ≠ {}\" is redundant:</p>\n<p>lemma compact_imp_closed_set_based_with_empty:<br>\n  \"∀open. t2_space_on_with A open ⟶<br>\n  (∀S⊆A. compact_on_with A open S ⟶ closed_on_with A open S)\"<br>\nproof(cases \"A={}\")<br>\n  case True then show ?thesis<br>\n    unfolding<br>\n      t2_space_on_with_def<br>\n      compact_on_with_def<br>\n      closed_on_with_def<br>\n      topological_space_on_with_def<br>\n    by simp<br>\nnext<br>\n  case False then show ?thesis by (rule compact_imp_closed_set_based)<br>\nqed</p>\n<p>In fact, many other relativised results about topological spaces hold even<br>\nif the carrier set is empty (e.g. see topological_basis_imp_subbasis_rel<br>\nabove). In my view, it would be useful to mention this in the example<br>\nHOL/Types_To_Sets/Examples/T2_Spaces.</p>\n<p>In conclusion, Questions 1 - 3 from my original query have now been<br>\nanswered in full. Most certainly, it would be nice to see the 'official'<br>\nversion of the relativised results about the topological spaces sooner<br>\nrather than later.</p>\n<p>As a side note, I am still not certain as to whether there is a way to<br>\ninterpret a type as a second_countable_topology (Question 4) with an<br>\nalternative predicate for 'open'. Of course, this issue is nearly<br>\northogonal to the main line of the inquiry.</p>\n<p>Thank you</p>",
        "id": 294749386,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194831
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I would like to apologise for making the remark \"As a side note, I am still<br>\nnot certain as to whether there is a way to interpret a type as a<br>\nsecond_countable_topology (Question 4) with an alternative predicate for<br>\n'open'.\" in my last email.</p>\n<p>The issue was resolved by Fabian Immler earlier today (<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00074.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-January/msg00074.html</a>)</p>\n<ul>\n<li>thank you.</li>\n</ul>\n<p>Therefore, all questions from my original inquiry were answered and I would<br>\nlike to propose to close this topic. Of course, if anyone has anything to<br>\nadd, I will appreciate further comments.</p>\n<p>Thank you</p>",
        "id": 294749391,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194833
    },
    {
        "content": "<p>From: \"Thiemann, René\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nAs far as I know, proving these transfer rules explicitly has to be done manually,<br>\nthough they are often easy to prove. The final deletion of the types via types-to-sets<br>\nis usually only a small last step that needs to be done. Therefore, I my opinion the<br>\ndescription in the initial Types-to-Sets paper is misleading as it, which indicates<br>\na lot more automation.</p>\n<p>I can further provide you with two developments where transfer + types-to-sets has been used<br>\nand can answer you questions on these developments. In both applications, we proved transfer<br>\nrules manually!</p>\n<ul>\n<li>\n<p>In AFP/Berlekamp_Zassenhaus there is quite a simple application of types-to-sets:<br>\n  prime-fields are modeled via types first, and later on several algorithms that<br>\n  work on types are basically copied to a setting where the prime is a term.<br>\n  A description is available at <a href=\"https://dl.acm.org/citation.cfm?doid=3018610.3018617\">https://dl.acm.org/citation.cfm?doid=3018610.3018617</a><br>\n  and you can contact me personally for an extended (submitted) journal version.</p>\n</li>\n<li>\n<p>In AFP/Perron_Frobenius there is a more involved setup where the type-based<br>\n  Brouwer’s fixpoint theorem has been converted into a set-based version,<br>\n  and where the HOL-Analysis vectors/matrices are connected to the ones in AFP/Jordan_Normal_Form.<br>\n  The corresponding description is at <a href=\"https://dl.acm.org/citation.cfm?doid=3176245.3167103\">https://dl.acm.org/citation.cfm?doid=3176245.3167103</a></p>\n</li>\n</ul>\n<p>Maybe, these examples are of interest.<br>\nCheers,<br>\nRené<br>\n<a href=\"/user_uploads/14278/Dh74HCJk4Xwc9MBDJ-zUZCAY/signature.asc\">signature.asc</a></p>",
        "id": 294749485,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194876
    }
]