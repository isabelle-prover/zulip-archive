[
    {
        "content": "<p>From: \"George K.\" &lt;<a href=\"mailto:g_karab@encs.concordia.ca\">g_karab@encs.concordia.ca</a>&gt;<br>\nHello all,</p>\n<p>I have been using Schirmer's Simpl for the past couple of months now.  <br>\nI am stuck when trying to reason with a procedure that deals with<br>\nreferences.  In particular, I cannot discharge the procedure's<br>\nspecification when the procedure calls other procedures that allocate<br>\nmemory and set field values.</p>\n<p>I am attaching a theory that illustrates the issues I have.  This theory<br>\ncontains:<br>\n1) A globals_memory hoarestate, containing a list of allocated<br>\nreferences and a free counter of available memory.  Taken straight out<br>\nof the examples of the AFP SIMPL distro.</p>\n<p>2) A globals_First hoarestate that declares a data structure that just<br>\nholds a single field of int type</p>\n<p>3) A procedure First() that is, in essence, a constructor.</p>\n<p>4) A globals_Second hoarestate which contain two fields each one being a<br>\n\"ref =&gt; ref\".  The intent is to model a data structure that contains<br>\nreferences to other structures.</p>\n<p>5) A Second_1 procedure that is a constructor accepting a two<br>\nreferences.</p>\n<p>6) A Second_2 procedure that is also a constructor--however, we pass<br>\ninteger values and invoke the First() procedure twice.  It is this<br>\nprocedure I cannot prove the functional specification.</p>\n<p>The functional spec looks as follows:<br>\n  lemma (in Second_2_impl) Second_2_spec:<br>\n    \"<br>\n      ∀σ x1 x2. Γ,Θ ⊢⇩t<br>\n        ⦃σ. ´x1 = x1 ∧ ´x2 = x2 ∧ (sz_Second + sz_First + sz_First) ≤<br>\n        ´free ⦄<br>\n        ´result' :== PROC Second_2(´x1,´x2)<br>\n        ⦃ <br>\n          ´result' ≠ Null ∧ ´result'→´Y ≠ Null ∧ ´result'→´Z ≠ Null ∧<br>\n          ´free = ⇗σ⇖free - sz_Second - sz_First - sz_First ∧<br>\n          ´result'→´Z→´X = x2 ∧ <br>\n          ´result'→´Y→´X = x1 ∧<br>\n          ´result' ∈ set ´alloc<br>\n        ⦄<br>\n    \"</p>\n<p>The last two conjucts (i.e. ´result'→´Y→´X = x1 ∧ ´result' ∈ set ´alloc)<br>\nare giving me hard time.  I believe the issues I have are related to<br>\nletting Isabelle know that the references allocated within the Second_2<br>\nprocedure are distinct (at least this is what I understand when reading<br>\non the split heap model used in Simpl).  Unfortunately, I am not sure<br>\nhow I can express this kind of distinctness in Isabelle.  </p>\n<p>Furthermore, I am unsure on whether I need to abstract simple data<br>\nstructures (such as the one in the attached theory) in HOL, similarly to<br>\nthe manner linked lists in the heap are abstracted to HOL lists using<br>\nthe List predicate.</p>\n<p>Any help is appreciated.</p>\n<p>George.<br>\n<a href=\"/user_uploads/14278/lOhsqjbxsDAfGeA9t6VxNTma/SimplMemTester.thy\">SimplMemTester.thy</a></p>",
        "id": 294274494,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918308
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHello George.</p>\n<p>Indeed you need a lot of distinctness. The problem with this kind of <br>\nhoare level reasoning about heaps is that you need to establish not only <br>\nthat the modified values are modified as expected, but that everything <br>\nelse is unchanged.</p>\n<p>I can fix your proof by extending First_spec as follows:</p>\n<p>lemma (in First_impl) First_spec:<br>\n     \"<br>\n       \\&lt;forall&gt;\\&lt;sigma&gt; x. \\&lt;Gamma&gt;,\\&lt;Theta&gt; \\&lt;turnstile&gt;\\&lt;^sub&gt;t<br>\n          \\&lt;lbrace&gt;\\&lt;sigma&gt;. \\&lt;acute&gt;x = x \\&lt;and&gt; sz_First \\&lt;le&gt; <br>\n\\&lt;acute&gt;free \\&lt;rbrace&gt;<br>\n          \\&lt;acute&gt;result' :== PROC First(\\&lt;acute&gt;x)<br>\n          \\&lt;lbrace&gt; \\&lt;acute&gt;result' \\&lt;noteq&gt; Null \\&lt;and&gt; <br>\n\\&lt;acute&gt;result'\\&lt;rightarrow&gt;\\&lt;acute&gt;X = x \\&lt;and&gt;<br>\n            \\&lt;acute&gt;result' \\&lt;in&gt; set \\&lt;acute&gt;alloc \\&lt;and&gt; <br>\n\\&lt;acute&gt;result' \\&lt;notin&gt; set (\\&lt;^bsup&gt;\\&lt;sigma&gt;\\&lt;^esup&gt;alloc)<br>\n            \\&lt;and&gt; set \\&lt;acute&gt;alloc = insert \\&lt;acute&gt;result' (set <br>\n(\\&lt;^bsup&gt;\\&lt;sigma&gt;\\&lt;^esup&gt;alloc))<br>\n            \\&lt;and&gt; \\&lt;acute&gt;free = \\&lt;^bsup&gt;\\&lt;sigma&gt;\\&lt;^esup&gt;free - sz_First<br>\n            \\&lt;and&gt; (\\&lt;forall&gt;x \\&lt;in&gt; set <br>\n(\\&lt;^bsup&gt;\\&lt;sigma&gt;\\&lt;^esup&gt;alloc). x\\&lt;rightarrow&gt;\\&lt;acute&gt;X = <br>\nx\\&lt;rightarrow&gt;\\&lt;^bsup&gt;\\&lt;sigma&gt;\\&lt;^esup&gt;X )\\&lt;rbrace&gt;<br>\n     \"</p>\n<p>(you might have to save that and load it in jEdit to read it).</p>\n<p>I've additionally asserted that the allocated address was not previously <br>\nallocated, that the set of allocated addresses has grown by the one <br>\nallocated address, and that all values previously allocated are unchanged.</p>\n<p>The current fashion is to avoid this tedious enumeration of everything <br>\nthat stays the same by using some kind of separation logic. Perhaps you <br>\nshould investigate whether Simpl provides something like that, or some <br>\nstandard idiom for expressing what hasn't changed.</p>\n<p>Good luck,<br>\n     Thomas.</p>",
        "id": 294274678,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918366
    },
    {
        "content": "<p>From: Holger Gast &lt;<a href=\"mailto:gast@informatik.uni-tuebingen.de\">gast@informatik.uni-tuebingen.de</a>&gt;<br>\nHello George,</p>\n<p>Thomas mentions using separation logic in his reply.<br>\nAs it happens, I have build the usual symbolic<br>\nexecution approach on top of Simpl for a project [1].<br>\nThe basic idea is to reconstruct the original execution<br>\nsequence of heap operations as much as necessary in the form<br>\nof nested let expressions, by considering the nesting<br>\nof the heap access expressions and various side-conditions.</p>\n<p>The latest version of the implementation is available from<br>\nthe homepage of last year's lecture on software verification:<br>\n<a href=\"https://www21.in.tum.de/teaching/isv/SS13\">https://www21.in.tum.de/teaching/isv/SS13</a><br>\nThe file SimplC.zip also contains a (rudimentary)<br>\nC parser, translator to Simpl, the reconstruction<br>\nmentioned above, and symbolic execution/heap matching.</p>\n<p>Hope this helps,</p>\n<p>Holger</p>\n<p>[1] Gast, H. \"Semi-automatic proofs about object graphs in separation logic\",<br>\n  in: Merz, S. and Lüttgen, G.: Automated Verification of Critical Systems<br>\n  (AVoCS '12)</p>",
        "id": 294274703,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918374
    },
    {
        "content": "<p>From: \"George K.\" &lt;<a href=\"mailto:g_karab@encs.concordia.ca\">g_karab@encs.concordia.ca</a>&gt;<br>\nThank you Thomas!  Indeed this is tedious, but it does make sense.  My<br>\ninitial understanding was that specifying the frame condition would<br>\nsuffice but I was wrong.  </p>\n<p>I will start tackling Separation Logic as soon as I can.</p>\n<p>Cheers,<br>\nGeorge</p>",
        "id": 294274822,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918422
    },
    {
        "content": "<p>From: \"George K.\" &lt;<a href=\"mailto:g_karab@encs.concordia.ca\">g_karab@encs.concordia.ca</a>&gt;<br>\nThank you Holger.  I will certainly have look at your extensions.<br>\nCheers,<br>\nGeorge</p>",
        "id": 294274845,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660918434
    }
]