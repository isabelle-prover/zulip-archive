[
    {
        "content": "<p>From: Thomas Genet &lt;<a href=\"mailto:thomas.genet@irisa.fr\">thomas.genet@irisa.fr</a>&gt;<br>\nDear all Isabelle users,</p>\n<p>For our \"formal software engineering\" course (1), we use Isabelle/HOL to <br>\ngenerate Scala code to be integrated into bigger Scala developments.</p>\n<p>One problem that we have is that when generating the code for a function <br>\nf ranging over a datatype T the code of the datatype is systematically <br>\ngenerated. Is it possible to filter out some types/functions for the <br>\ngeneration by export_code? and how?</p>\n<p>We need this because, if the code for T is already present somewhere <br>\nelse in the project, we have to manually edit the generated code.</p>\n<p>Thanks in advance,</p>\n<p>Thomas<br>\n(1) <a href=\"http://www.irisa.fr/celtique/genet/ACF/\">http://www.irisa.fr/celtique/genet/ACF/</a></p>",
        "id": 294308331,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925013
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Thomas,</p>\n<p>Isabelle's code generator always generates self-contained code, i.e., it generates <br>\neverything on which your functions depend. The only execption is if you adapt the <br>\nserialisation such that pre-defined functions are used (as is done, e.g., for 'a list). <br>\nThis can be done with code_printing, see the code generator tutorial for details.</p>\n<p>A word of warning, though. With respect to \"correctness of the generated code\", adapting <br>\nthe serialiser is like adding axioms to your theory. There are no checks that it is <br>\nsemantically correct whay you do, and you can even derive False when you prove by evaluation.</p>\n<p>Andreas</p>",
        "id": 294308511,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925054
    },
    {
        "content": "<p>From: Thomas Genet &lt;<a href=\"mailto:thomas.genet@irisa.fr\">thomas.genet@irisa.fr</a>&gt;<br>\nDear Andreas,</p>\n<p>Le 11/09/14 08:28, Andreas Lochbihler a écrit :</p>\n<blockquote>\n<p>Dear Thomas,</p>\n<p>Isabelle's code generator always generates self-contained code, i.e., it<br>\ngenerates everything on which your functions depend. The only execption<br>\nis if you adapt the serialisation such that pre-defined functions are<br>\nused (as is done, e.g., for 'a list). This can be done with<br>\ncode_printing, see the code generator tutorial for details.</p>\n</blockquote>\n<p>thank you for the pointer to the code generator manual. However I <br>\nalready looked (rapidly though) to this manual and also to the source <br>\nfiles List.thy and also to the Code_Integer etc. file to figure out how <br>\nto achieve my goal... But I did not manage to do it. My feeling is that <br>\nthe reason for this is that I cannot associate to my Isabelle type any <br>\nexisting Scala type but only one that has been generated separately.</p>\n<p>Let me explain on a small example:</p>\n<p>If I have the following Isabelle code:</p>\n<hr>\n<p>datatype toto= M | T</p>\n<p>fun f2::\"toto ⇒ bool\"<br>\nwhere<br>\n\"f2 M = True\" |<br>\n\"f2 _ = False\"</p>\n<hr>\n<p>It produces Scala code:</p>\n<hr>\n<p>object test2 {<br>\nabstract sealed class toto<br>\nfinal case class M() extends toto<br>\nfinal case class T() extends toto</p>\n<p>def f2(x0: toto): Boolean = x0 match {<br>\n   case M() =&gt; true<br>\n   case T() =&gt; false<br>\n}<br>\n} /* object test2 */</p>\n<hr>\n<p>But I would like to be abble to select what abstract data type <br>\ndefinitions to generate. For instance I would like to avoid to generate the</p>\n<hr>\n<p>abstract sealed class toto<br>\nfinal case class M() extends toto<br>\nfinal case class T() extends toto</p>\n<hr>\n<p>part but only the function declaration f2. I found the \"code_abort\" <br>\ncommand that permits to avoid the generation for constants but (as far <br>\nas I understand) not for datatype declarations.<br>\nI tried also with a code_printing command something of the form:</p>\n<p>code_printing<br>\n   type_constructor toto ⇀ (Scala) \"toto\"</p>\n<p>It was accepted by Isabelle but export_code then fails.</p>\n<blockquote>\n<p>A word of warning, though. With respect to \"correctness of the generated<br>\ncode\", adapting the serialiser is like adding axioms to your theory.<br>\nThere are no checks that it is semantically correct whay you do, and you<br>\ncan even derive False when you prove by evaluation.</p>\n</blockquote>\n<p>Yes of course... this is only for a basic \"software engineering\" <br>\npurpose. Distinct program parts use the same \"toto\" type: one part that <br>\nhas been programmed in Scala and one that has been verified and exported <br>\nfrom Isabelle. If generation exports again the \"toto\" implementation <br>\nthis imposes to manually edit the generated file before integration. <br>\nThis can be rapidly done when one datatype is under concern... but not <br>\nthat fast when 5, 10, ... datatypes are concerned... and this has to be <br>\ndone each time that you correct your Isabelle file and re-generate :/</p>\n<p>Best regards,</p>\n<p>Thomas</p>",
        "id": 294308528,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925061
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Thomas,</p>\n<blockquote>\n<hr>\n<p>datatype toto= M | T</p>\n<p>fun f2::\"toto ⇒ bool\"<br>\nwhere<br>\n\"f2 M = True\" |<br>\n\"f2 _ = False\"</p>\n<hr>\n<p>In the following, I assume that you have already generated the Scala code for toto in the <br>\nmodule Scratch, say</p>\n</blockquote>\n<p>object Scratch {</p>\n<p>abstract sealed class toto<br>\nfinal case class M() extends toto<br>\nfinal case class T() extends toto</p>\n<p>} /* object Scratch */</p>\n<p>Then, the following code_printing declarations for the type and its type constructors suffice.</p>\n<p>code_printing type_constructor toto ⇀ (Scala) \"Scratch.toto\"<br>\n| constant M ⇀ (Scala) \"Scratch.M\"<br>\n| constant T ⇀ (Scala) \"Scratch.T\"</p>\n<p>Then, \"export_code f2 in Scala module_name Foobar\" yields</p>\n<p>object Foobar {</p>\n<p>def f2(x0: Scratch.toto): Boolean = x0 match {<br>\n   case Scratch.M =&gt; true<br>\n   case Scratch.T =&gt; false<br>\n}</p>\n<p>} /* object Foobar */</p>\n<blockquote>\n<p>code_printing<br>\n   type_constructor toto ⇀ (Scala) \"toto\"</p>\n<p>It was accepted by Isabelle but export_code then fails.<br>\nYou also have to provide serialisation instructions for all the constructors of the <br>\ndatatype. Unfortunately, the error messages from export_code are not particularly informative.</p>\n</blockquote>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294308583,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925079
    },
    {
        "content": "<p>From: Thomas Genet &lt;<a href=\"mailto:thomas.genet@irisa.fr\">thomas.genet@irisa.fr</a>&gt;<br>\nLe 11/09/14 10:01, Andreas Lochbihler a écrit :</p>\n<blockquote>\n<p>Hi Thomas,</p>\n<blockquote>\n<hr>\n<p>datatype toto= M | T</p>\n<p>fun f2::\"toto ⇒ bool\"<br>\nwhere<br>\n\"f2 M = True\" |<br>\n\"f2 _ = False\"</p>\n<hr>\n<p>In the following, I assume that you have already generated the Scala<br>\ncode for toto in the module Scratch, say</p>\n</blockquote>\n<p>object Scratch {</p>\n<p>abstract sealed class toto<br>\nfinal case class M() extends toto<br>\nfinal case class T() extends toto</p>\n<p>} /* object Scratch */</p>\n<p>Then, the following code_printing declarations for the type and its type<br>\nconstructors suffice.</p>\n<p>code_printing type_constructor toto ⇀ (Scala) \"Scratch.toto\"<br>\n| constant M ⇀ (Scala) \"Scratch.M\"<br>\n| constant T ⇀ (Scala) \"Scratch.T\"</p>\n<p>Then, \"export_code f2 in Scala module_name Foobar\" yields</p>\n<p>object Foobar {</p>\n<p>def f2(x0: Scratch.toto): Boolean = x0 match {<br>\n   case Scratch.M =&gt; true<br>\n   case Scratch.T =&gt; false<br>\n}</p>\n<p>} /* object Foobar */<br>\n</p>\n</blockquote>\n<p>Yes! Thanks, that's exactly what I was looking for.</p>\n<p>Bonus question: do you know how to perform this in Isabelle2012?<br>\nWith code_type?</p>\n<blockquote>\n<blockquote>\n<p>code_printing<br>\n   type_constructor toto ⇀ (Scala) \"toto\"</p>\n<p>It was accepted by Isabelle but export_code then fails.<br>\nYou also have to provide serialisation instructions for all the<br>\nconstructors of the datatype. Unfortunately, the error messages from<br>\nexport_code are not particularly informative.</p>\n</blockquote>\n</blockquote>\n<p>True, as you say \"this is not particularly informative\" :-)</p>\n<blockquote>\n<p>Hope this helps,</p>\n</blockquote>\n<p>Oh yes! Thanks again,</p>\n<p>Thomas</p>",
        "id": 294308591,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925085
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Thomas,</p>\n<p>I don't have Isabelle2012 installed any more, but IIRC, the syntax was as follows:</p>\n<p>code_type toto (Scala \"Scratch.toto\")<br>\ncode_const M (Scala \"Scratch.M\")<br>\ncode_const T (Scala \"Scratch.T\")</p>\n<p>Andreas</p>",
        "id": 294308613,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925091
    },
    {
        "content": "<p>From: Thomas Genet &lt;<a href=\"mailto:thomas.genet@irisa.fr\">thomas.genet@irisa.fr</a>&gt;<br>\nYes, thanks to the explanation you gave me in your last e-mail + the <br>\nList.thy file I just managed to get it right by myself.</p>\n<p>Thanks a lot,</p>\n<p>Best regards,</p>\n<p>Thomas</p>",
        "id": 294308637,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925097
    },
    {
        "content": "<p>From: Thomas Genet &lt;<a href=\"mailto:thomas.genet@irisa.fr\">thomas.genet@irisa.fr</a>&gt;<br>\nDear all,</p>\n<p>In my case it was also necessary to NOT re-generate the code for <br>\nequality on the datatype (HOL.equal) and for some other given functions <br>\n(here f).<br>\nThe function generated for equality on datatype toto is equal_toto so it <br>\nis enough to use this identifier directly in the code_printing command <br>\n(with a ' to quote the _)</p>\n<p>To sum-up my code for Isabelle2014 is:</p>\n<hr>\n<p>code_printing<br>\n   type_constructor toto ⇀ (Scala) \"toto\"<br>\n   | constant M ⇀ (Scala) \"M\"<br>\n   | constant T ⇀ (Scala) \"T\"<br>\n   | constant f ⇀ (Scala) \"f\"<br>\n   | constant \"HOL.equal :: toto ⇒ toto ⇒ bool\" ⇀ (Scala) \"equal'_toto\"</p>\n<hr>\n<p>And for Isabelle2012 it is:</p>\n<hr>\n<p>code_abort f</p>\n<p>code_type toto<br>\n   (Scala \"toto\")</p>\n<p>code_const M<br>\n   (Scala \"M\")</p>\n<p>code_const T<br>\n   (Scala \"T\")</p>\n<p>code_const \"HOL.equal ::\"toto ⇒ toto ⇒ bool\"<br>\n   (Scala \"equal'_toto\")</p>\n<hr>\n<p>Best regards and thank you to Andreas!</p>\n<p>Thomas</p>",
        "id": 294308700,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925116
    }
]