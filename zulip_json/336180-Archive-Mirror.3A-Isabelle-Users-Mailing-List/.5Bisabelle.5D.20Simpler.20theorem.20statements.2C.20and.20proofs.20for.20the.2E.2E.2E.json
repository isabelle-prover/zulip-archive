[
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:c.lange@cs.bham.ac.uk\">c.lange@cs.bham.ac.uk</a>&gt;<br>\n2012-10-31 20:09 Lawrence Paulson:</p>\n<blockquote>\n<p>On 31 Oct 2012, at 18:28, Christoph LANGE &lt;<a href=\"mailto:c.lange@cs.bham.ac.uk\">c.lange@cs.bham.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<ul>\n<li>In statements such as \"!x. p x --&gt; q x\" it is tedious (and always the same) to break their structure down to a level where the actually interesting work starts.</li>\n</ul>\n</blockquote>\n<p>It is almost never necessary or helpful to state a theorem in that format.</p>\n</blockquote>\n<p>Thanks for your advice!  However simply changing my statements to …</p>\n<blockquote>\n<p>I suggest</p>\n<p>lemma \"p x ==&gt; q x\"</p>\n<p>for a straightforward proof, or</p>\n<p>lemma assumes \"p x\" shows \"q x\"</p>\n<p>for a more complicated structured proof.</p>\n</blockquote>\n<p>… such a structure doesn't always work; I think the proofs will also <br>\nneed some adaptation.</p>\n<p>The following lemma (reduced to the structural outline) has a <br>\n(anti-)pattern that is typical for my formalisation:</p>\n<p>lemma skip_index_keeps_non_negativity :<br>\n   fixes n::nat and v::real_vector<br>\n   assumes non_empty: \"n &gt; 0\"<br>\n     and non_negative: \"non_negative_real_vector n v\"<br>\n   shows \"\\&lt;forall&gt;i::nat . in_range n i \\&lt;longrightarrow&gt; <br>\nnon_negative_real_vector (n-(1::nat)) (skip_index v i)\"<br>\nproof<br>\n   fix i::nat<br>\n   show \"in_range n i \\&lt;longrightarrow&gt; non_negative_real_vector <br>\n(n-(1::nat)) (skip_index v i)\"<br>\n   proof<br>\n     assume \"in_range n i\"<br>\n     ...<br>\n     show \"non_negative_real_vector (n-(1::nat)) (skip_index v i)\" sorry<br>\n   qed<br>\nqed</p>\n<p>How would I have to adapt the proof when rephrasing the statement as <br>\nshows \"in_range n i \\&lt;Longrightarrow&gt; ...\" ?</p>\n<p>(I'll be happy to accept \"RTFM\" as an answer, if you could give me a <br>\npointer.)</p>\n<p>Cheers, and thanks,</p>\n<p>Christoph</p>",
        "id": 294225843,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899953
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou should look at the documentation on the induct/induction proof methods. They achieve the effect of performing induction on a formula such as</p>\n<p>\"\\&lt;forall&gt;i::nat . P i \\&lt;longrightarrow&gt; Q i\"</p>\n<p>while completely hiding the tedious manipulations of these logical connectives that would normally be required.</p>\n<p>Larry Paulson</p>",
        "id": 294226193,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900093
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:c.lange@cs.bham.ac.uk\">c.lange@cs.bham.ac.uk</a>&gt;<br>\nDear Larry, dear all,</p>\n<p>I'm now back at our auction formalisation and catching up with emails.</p>\n<p>I have taken into account the advice I got from you and the others; <br>\nbasically I managed to change my statements from</p>\n<p>shows \"!i . p x --&gt; q x\"</p>\n<p>to</p>\n<p>fixes ... and i<br>\nassumes \"p x\"<br>\nshows \"q x\"</p>\n<p>This and similar changes helped to shorten the overall formalisation <br>\nfrom 1145 to 1045 lines (see <br>\n<a href=\"http://cs.bham.ac.uk/research/projects/formare/code/auction-theory/Vickrey.thy\">http://cs.bham.ac.uk/research/projects/formare/code/auction-theory/Vickrey.thy</a>). <br>\n  I'm sure I can do even better.</p>\n<p>I have not yet made any further simplifications, such as doing a lot of <br>\nthings at once in a style like</p>\n<p>... by (induct i arbitrary: xs) (case_tac xs, simp_all)+</p>\n<p>that Chris used in his example of a lemma about lists.  At the moment I <br>\ndon't even know how to get started using such proof methods.</p>\n<p>2012-11-01 12:03 Lawrence Paulson:</p>\n<blockquote>\n<p>You should look at the documentation on the induct/induction proof methods.</p>\n</blockquote>\n<p>Where can I find that documentation?  The Tutorial mainly uses <br>\napply(induct_tac), which is probably something else.  Is there a single, <br>\nup to date reference manual that documents all proof methods?</p>\n<p>BTW, changing induction proofs to \"assumes ... shows ...\" did not always <br>\nmake them shorter.  Is there a way of not having to explicitly restate <br>\nthe assumption for (Suc n) in the induction step?</p>\n<p>E.g. I have one lemma of the following structure, which proves some <br>\nproperty of a function \"fun maximum\":</p>\n<p>lemma maximum_sufficient :<br>\n   fixes n::nat and ...<br>\n   assumes assm1: \"p n\"<br>\n       and assm2: \"q n\"<br>\n       and assm3: \"r n\"<br>\n   shows \"s n\"<br>\n     using assms (* &lt;-- now this became necessary,<br>\n       otherwise even \"case 0\" would fail, but why? *)<br>\nproof (induct n)<br>\n   case 0<br>\n   then show ?case by simp<br>\nnext<br>\n   case (Suc n)<br>\n   (* and now I have to explicitly restate all assumptions: *)<br>\n   assume assm1: \"p (Suc n)\"<br>\n   assume assm2: \"q (Suc n)\"<br>\n   assume assm3: \"r (Suc n)\"<br>\n   ...<br>\n   show \"s (Suc n)\" ...<br>\nqed</p>\n<p>Cheers, and thanks for any help,</p>\n<p>Christoph</p>",
        "id": 294226291,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900149
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 22/11/2012 15:13, schrieb Christoph LANGE:</p>\n<blockquote>\n<p>Dear Larry, dear all,</p>\n<p>I'm now back at our auction formalisation and catching up with emails.</p>\n<p>I have taken into account the advice I got from you and the others; basically I<br>\nmanaged to change my statements from</p>\n<p>shows \"!i . p x --&gt; q x\"</p>\n<p>to</p>\n<p>fixes ... and i<br>\nassumes \"p x\"<br>\nshows \"q x\"</p>\n</blockquote>\n<p>Unless you want to give the type of i, you don't need to fix it.</p>\n<blockquote>\n<p>This and similar changes helped to shorten the overall formalisation from 1145<br>\nto 1045 lines (see<br>\n<a href=\"http://cs.bham.ac.uk/research/projects/formare/code/auction-theory/Vickrey.thy\">http://cs.bham.ac.uk/research/projects/formare/code/auction-theory/Vickrey.thy</a>).<br>\n I'm sure I can do even better.</p>\n<p>I have not yet made any further simplifications, such as doing a lot of things<br>\nat once in a style like</p>\n<p>... by (induct i arbitrary: xs) (case_tac xs, simp_all)+</p>\n<p>that Chris used in his example of a lemma about lists.  At the moment I don't<br>\neven know how to get started using such proof methods.</p>\n<p>2012-11-01 12:03 Lawrence Paulson:</p>\n<blockquote>\n<p>You should look at the documentation on the induct/induction proof methods.</p>\n</blockquote>\n<p>Where can I find that documentation?  The Tutorial mainly uses<br>\napply(induct_tac), which is probably something else.</p>\n</blockquote>\n<p>This is what I suggested to you 3 weeks back:</p>\n<p>\"If you look at the documentation page<br>\n<a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a> you will find that the first<br>\ndocument is the relatively new Programming and Proving in Isabelle/HOL, which<br>\ndoes cover structured proofs (which is why I wrote it). The Tutorial is now only<br>\nsecond choice because of the foucus on \"apply\".\"</p>\n<p>That is also where you find the induction method.</p>\n<blockquote>\n<p>Is there a single, up to<br>\ndate reference manual that documents all proof methods?</p>\n</blockquote>\n<p>Yes, the reference manual (more or less).</p>\n<blockquote>\n<p>BTW, changing induction proofs to \"assumes ... shows ...\" did not always make<br>\nthem shorter.  Is there a way of not having to explicitly restate the assumption<br>\nfor (Suc n) in the induction step?</p>\n</blockquote>\n<p>Indeed, for inductions, the most convenient way is stating them as implications<br>\n(with ==&gt;). The manuals above will also tell you about the naming conventions of<br>\nassumptions in each case.</p>\n<p>Tobias</p>\n<blockquote>\n<p>E.g. I have one lemma of the following structure, which proves some property of<br>\na function \"fun maximum\":</p>\n<p>lemma maximum_sufficient :<br>\n  fixes n::nat and ...<br>\n  assumes assm1: \"p n\"<br>\n      and assm2: \"q n\"<br>\n      and assm3: \"r n\"<br>\n  shows \"s n\"<br>\n    using assms (* &lt;-- now this became necessary,<br>\n      otherwise even \"case 0\" would fail, but why? *)<br>\nproof (induct n)<br>\n  case 0<br>\n  then show ?case by simp<br>\nnext<br>\n  case (Suc n)<br>\n  (* and now I have to explicitly restate all assumptions: *)<br>\n  assume assm1: \"p (Suc n)\"<br>\n  assume assm2: \"q (Suc n)\"<br>\n  assume assm3: \"r (Suc n)\"<br>\n  ...<br>\n  show \"s (Suc n)\" ...<br>\nqed</p>\n<p>Cheers, and thanks for any help,</p>\n<p>Christoph<br>\n</p>\n</blockquote>",
        "id": 294226323,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900158
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 22.11.2012 15:13, Christoph LANGE wrote:</p>\n<blockquote>\n<p>assumes assm1: \"p n\"<br>\nand assm2: \"q n\"<br>\nand assm3: \"r n\"<br>\nshows \"s n\"<br>\nusing assms (* &lt;-- now this became necessary,<br>\notherwise even \"case 0\" would fail, but why? *)<br>\nproof (induct n)<br>\n[...]<br>\ncase (Suc n)<br>\n(* and now I have to explicitly restate all assumptions: *)<br>\nassume assm1: \"p (Suc n)\"<br>\nassume assm2: \"q (Suc n)\"<br>\nassume assm3: \"r (Suc n)\"<br>\n...</p>\n</blockquote>\n<p>You don't need to restate your assumptions here: They are all stored in <br>\n\"Suc\" (or Suc.prems, which omits the hypotheses added by induction).</p>\n<p>-- Lars</p>",
        "id": 294226338,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900167
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nA few more hints on the version that happens to be behind this inversion <br>\nlink right now:</p>\n<p>* 'definition' with Pure equality (==) is quite old-fashioned.  Normally<br>\n     you just use HOL = or its abbreviation for bool &lt;-&gt; here, as you would<br>\n     for 'primrec', 'fun', 'function'</p>\n<p>(In contrast HOL --&gt; and ! are old-fashioned/cumbersome, where Pure<br>\n     ==&gt; and !! would do the job better.)</p>\n<p>* I recommend to put the whole 'head' of some definition on one line,<br>\n     this works best with jEdit folding:</p>\n<p>definition a :: A<br>\n       where \"a = t\"</p>\n<p>fun b :: B<br>\n       where \"b x = t\"</p>\n<p>Where the 'where' goes depends on the length of A and t; it is not<br>\n     informative for the head, so I prefer to have it second by default.</p>\n<p>* 'done' should be indented like the 'apply' script.  Don't ask why,<br>\n     Isar indentation is an arcane discipline, and still awaits tool<br>\n     support in Isabelle/jEdit.</p>\n<p>BTW, the shortest structured proof that is not a script looks like<br>\n     this:</p>\n<p>lemma A unfolding a_def b_def c_def auto</p>\n<p>instead of your apply unfold, apply auto, done</p>\n<p>* About your funny comments (* by contradiction *): according to the<br>\n     Isar philosophy, you always strive to make things clear by formal<br>\n     means, and avoid comments.  Thus can be done by putting a suitable<br>\n     \"proof (rule ...)\" standard step here.</p>\n<p>According to my experience, informal or semi-formal people often have<br>\n     problems to understand what not-introduction, not-elimination, and<br>\n     classical reasoning means.  The following examples explore this in the<br>\n     formal playground:</p>\n<p>notepad<br>\nbegin</p>\n<p>have \"¬ A\"<br>\n   proof (rule notI)<br>\n     assume A<br>\n     then show False sorry<br>\n   qed</p>\n<p>next</p>\n<p>have \"¬ A\" sorry<br>\n   have A sorry<br>\n   from <code>¬ A</code> and <code>A</code> have C by (rule notE)</p>\n<p>from <code>¬ A</code> and <code>A</code> have C by contradiction<br>\n   from <code>A</code> and <code>¬ A</code> have C by contradiction</p>\n<p>next</p>\n<p>have C<br>\n   proof (rule ccontr)<br>\n     assume \"¬ C\"<br>\n     then show False sorry<br>\n   qed</p>\n<p>next</p>\n<p>have C<br>\n   proof (rule classical)<br>\n     assume \"¬ ?thesis\"<br>\n     then show ?thesis sorry<br>\n   qed</p>\n<p>next</p>\n<p>have C<br>\n   proof (rule classical)<br>\n     assume \"¬ ?thesis\"<br>\n     then have False sorry<br>\n     then show ?thesis by (rule FalseE)<br>\n   qed</p>\n<p>end</p>\n<p>Here the rule steps with notI, notE, FalseE have been made explicit for <br>\nillustration: these default rules are normally omitted, i.e. you would <br>\njust write 'proof' without anything or '..' in instead of 'by (rule ...)'.</p>\n<p>The Isar method \"contradiction\" allows to present to two preconditions in <br>\neither order -- this often happens in practice.  For notE the negated <br>\nformula has to come first, to eliminate it properly.</p>\n<p>There is nothing special behind any of these intro/elim steps so far: just <br>\nplain intuitionistic natural deduction.  Nonetheless, people sometimes <br>\nthink that notI is \"proof by contradiction\", because they have to show <br>\nFalse in the end.</p>\n<p>This might also stem from the ccontr rule above, which is often seen in <br>\ntext books (without this Isabelle-specific name).  I usually prefer the <br>\none called \"classical\", because it lacks the builtin False step and <br>\nillustrates the brutality of classical reasoning in a pure way: you may <br>\nassume that the thesis does not hold, then you have to show that it holds. <br>\nThe latter proof often works \"by contradiction\" in the above formal sense, <br>\nto explain once more while you might get confused informally.</p>\n<p>Formally, everything should be clear at this pure Isar level, because <br>\nthere is no magic built-in apart from higher-order unification and <br>\nproof-by-assumption to solve trivial \"end-games\" in natural deduction.</p>\n<p>Makarius</p>",
        "id": 294226362,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900179
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:c.lange@cs.bham.ac.uk\">c.lange@cs.bham.ac.uk</a>&gt;<br>\n2012-11-22 16:04 Lars Noschinski:<br>\nThanks, that's very helpful!</p>\n<p>For readability I'd sometimes like to make it explicit to what <br>\nassumption I'm referring when there is more than one.</p>\n<p>When explicitly restating them with 'assume \"... (Suc n) ...\"' that's no <br>\nproblem.  With \"Suc\" I found, e.g., Suc.prems(1) to work.  A symbolic <br>\nname, e.g. Suc.prems(foo), if the original statement says 'assumes foo: <br>\n\"...\"', would be even nicer – but that's not possible, I suppose.</p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294226370,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900185
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 22.11.2012 17:56, Makarius wrote:</p>\n<blockquote>\n<ul>\n<li>'definition' with Pure equality (==) is quite old-fashioned. Normally<br>\nyou just use HOL = or its abbreviation for bool &lt;-&gt; here, as you would<br>\nfor 'primrec', 'fun', 'function'</li>\n</ul>\n<p>(In contrast HOL --&gt; and ! are old-fashioned/cumbersome, where Pure<br>\n==&gt; and !! would do the job better.)</p>\n</blockquote>\n<p>Is there actually a drawback when using == instead of = or is it a mere <br>\nmatter of style? I like using Pure equality because it saves me a level <br>\nof parentheses when I have a binder on the right hand side.</p>\n<blockquote>\n<p>BTW, the shortest structured proof that is not a script looks like<br>\nthis:</p>\n<p>lemma A unfolding a_def b_def c_def auto</p>\n</blockquote>\n<p>To avoid confusion: There is a \"by\" missing:</p>\n<p>lemma A unfolding a_def b_def c_def by auto</p>\n<blockquote>\n<p>The Isar method \"contradiction\" allows to present to two preconditions<br>\nin either order -- this often happens in practice. For notE the negated<br>\nformula has to come first, to eliminate it properly.</p>\n</blockquote>\n<p>Never saw this method before. I'll have a look.</p>\n<p>-- Lars</p>",
        "id": 294226380,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900192
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nIt is simpler:</p>\n<p>a) Uniformity</p>\n<p>definition foo :: …<br>\n  where \"foo … = …\"</p>\n<p>vs.</p>\n<p>primrec foo :: …<br>\n  where \"foo … = …\"<br>\n      | …<br>\n      | \"foo … = …\"</p>\n<p>vs.</p>\n<p>fun(ction) foo :: …<br>\n  where \"foo … = …\"<br>\n      | …<br>\n      | \"foo … = …\"</p>\n<p>b) Less symbols</p>\n<p>Why care about »foo« anyway?</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/rjxp_6ytZ3m_KouX76wsDzH2/signature.asc\">signature.asc</a></p>",
        "id": 294226391,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900198
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 22.11.2012 18:41, Florian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>(In contrast HOL --&gt;  and ! are old-fashioned/cumbersome, where Pure<br>\n==&gt;  and !! would do the job better.)</p>\n</blockquote>\n<p>Is there actually a drawback when using == instead of = or is it a mere<br>\nmatter of style? I like using Pure equality because it saves me a level<br>\nof parentheses when I have a binder on the right hand side.</p>\n</blockquote>\n<p>It is simpler:</p>\n<p>a) Uniformity<br>\nb) Less symbols</p>\n</blockquote>\n<p>Ok, these are stylistic reasons and both only hold when always using =, <br>\nand not &lt;-&gt; (&lt;-&gt; can be used for all of definition, primrec, fun(ction), <br>\nbut only for boolean valued functions. And I don't like it for <br>\ndefinitions anyway ;)).</p>\n<blockquote>\n<p>Why care about »foo« anyway?</p>\n</blockquote>\n<p>This I don't understand. The situation I'm talking about is</p>\n<p>definition foo :: …<br>\n   where \"foo … = (∀x. …)\"</p>\n<p>vs.</p>\n<p>definition foo :: …<br>\n   where \"foo … ≡ ∀x. …\"</p>\n<p>(there are also other cases)</p>\n<p>-- Lars</p>",
        "id": 294226451,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900210
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Is there actually a drawback when using == instead of = or is it a mere<br>\nmatter of style? I like using Pure equality because it saves me a level<br>\nof parentheses when I have a binder on the right hand side.</p>\n</blockquote>\n<p>It is simpler:</p>\n<p>a) Uniformity<br>\nb) Less symbols</p>\n</blockquote>\n<p>Ok, these are stylistic reasons and both only hold when always using =,<br>\nand not &lt;-&gt; (&lt;-&gt; can be used for all of definition, primrec, fun(ction),<br>\nbut only for boolean valued functions. And I don't like it for<br>\ndefinitions anyway ;)).</p>\n</blockquote>\n<p>The matter &lt;-&gt; vs. = is orthogonal to == vs. =</p>\n<blockquote>\n<blockquote>\n<p>Why care about »foo« anyway?</p>\n</blockquote>\n</blockquote>\n<p>This should have read »Why care about »==« anyway?«.  The statement is<br>\nthat end-users need not to even now about »==« in most situations (the<br>\nonly exception known to me are rules like split_paired_All (all?) where<br>\nyou rewrite framework-level connectives).  So why burden them with it?</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/vvAt6ztyyE_hY6qVAfxOVx9t/signature.asc\">signature.asc</a></p>",
        "id": 294226480,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900235
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nUsing == for definitions is one of these things that can be explained only <br>\nhistorically.  Many many years ago, you would have used consts/defs or <br>\neven consts/axioms or even consts/rules to spell out definitional axioms <br>\nusing directly the == primitive of Pure.  Larry explained it &gt; 20 yeas ago <br>\nas \"Pure == is used to represent definitions\".</p>\n<p>If you look at modern times, a \"definitional package\" is some mechanism <br>\nthat accepts a specification (via terms or propositions) about what should <br>\nbe provided by the system by means of some derived definitional concept. <br>\nSo in 'primrec' and 'fun' you state equations, and the system will give <br>\nthem you as theorems (and more things), in 'inductive' you write rules <br>\nabout some relation, and you get them as theorems for introduction (and <br>\nmore things for elimination and induction).</p>\n<p>Long ago, the old 'defs' primitive has been superseded by such a <br>\ndefinitional package called 'definition', to do the same for basic <br>\ndefinitions without pattern matching or recursion.  So 'definition' is <br>\nmore like 'function' or 'theorem' than the primitive def that happens at <br>\nthe bottom.  That foundation of the definition does use Pure == <br>\ninternally, but the user never has to see it in practice.  In Isabelle2012 <br>\nthese primitive defs behind 'definition' are particulary hard to retrieve, <br>\nand nobody has noticed so far :-)</p>\n<p>Makarius</p>",
        "id": 294226586,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900285
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nRestating case/assume is not a big deal, it is done occasionally and not <br>\nbad style, only a bit redundant and less formally checked than could be <br>\ndone otherwise.</p>\n<p>To make it more tight, you can do it via literal fact references or the <br>\ncorresponing \"fact\" method like this:</p>\n<p>notepad<br>\nbegin</p>\n<p>fix n :: nat</p>\n<p>have \"P n\"<br>\n   proof (induct n)<br>\n     case 0<br>\n     then show ?case sorry<br>\n   next<br>\n     case (Suc n)<br>\n     then show ?case sorry<br>\n   qed</p>\n<p>have \"P n\"<br>\n   proof (induct n)<br>\n     case 0<br>\n     show \"P 0\" sorry<br>\n   next<br>\n     case (Suc n)<br>\n     from <code>P n</code> show \"P (Suc n)\" sorry<br>\n   qed</p>\n<p>have \"P n\"<br>\n   proof (induct n)<br>\n     case 0<br>\n     show \"P 0\" sorry<br>\n   next<br>\n     case (Suc n)<br>\n     have \"P n\" by fact<br>\n     then show \"P (Suc n)\" sorry<br>\n   qed</p>\n<p>have \"P n\"<br>\n   proof (induct n)<br>\n     case 0<br>\n     show \"P 0\" sorry<br>\n   next<br>\n     case (Suc n)<br>\n     assume \"P n\"<br>\n     then show \"P (Suc n)\" sorry<br>\n   qed</p>\n<p>have \"P n\"<br>\n   proof (induct n)<br>\n     show \"P 0\" sorry<br>\n   next<br>\n     fix n<br>\n     assume \"P n\"<br>\n     then show \"P (Suc n)\" sorry<br>\n   qed</p>\n<p>end</p>\n<p>BTW, according to the way the logical framework works, you can have <br>\nredundant 'assume' statements in your proof body, but not redundant 'fix'. <br>\nThe \"fix n\" is already part of the case (Suc n). Another fix n would <br>\npostulate a different hyptothetical entity in the context, that is not the <br>\nsame, and its assumptions unrelated to what you have already after <br>\ninvoking the case.</p>\n<p>The funny thing is that textbook logicians often omit the formal \"fix n\" <br>\naltogether.  I've seen this even in some implementations of logic, where <br>\nthe global absence of a declaration over the whole text is taken as an <br>\nimplicit fix of a local variable.</p>\n<p>Makarius</p>",
        "id": 294226612,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900304
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nRecall that 'definition', 'primrec', 'fun', 'function' are all the same <br>\ncategory of \"derived definitional concept\", although of different strength <br>\nand power invested in the mechanisms behind it.</p>\n<p>Makarius</p>",
        "id": 294226743,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900357
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Christoph,</p>\n<p>Consider the proofs:</p>\n<p>lemma 1:<br>\n   \"ALL i. i &lt; length xs --&gt; xs ! i = hd (drop i xs)\"<br>\nproof<br>\n   fix i<br>\n   show \"i &lt; length xs --&gt; xs ! i = hd (drop i xs)\"<br>\n   proof<br>\n     assume \"i &lt; length xs\"<br>\n     then show \"xs ! i = hd (drop i xs)\"<br>\n       by (induct i arbitrary: xs) (case_tac xs, simp_all)+<br>\n   qed<br>\nqed<br>\nthm 1<br>\nthm 1 [rule_format]</p>\n<p>lemma 2:<br>\n   \"!!i. i &lt; length xs ==&gt; xs ! i = hd (drop i xs)\"<br>\nproof -<br>\n   fix i<br>\n   assume \"i &lt; length xs\"<br>\n   then show \"xs ! i = hd (drop i xs)\"<br>\n     by (induct i arbitrary: xs) (case_tac xs, simp_all)+<br>\nqed<br>\nthm 2</p>\n<p>lemma 3:<br>\n   assumes \"i &lt; length xs\"<br>\n   shows \"xs ! i = hd (drop i xs)\"<br>\n   using assms<br>\n     by (induct i arbitrary: xs) (case_tac xs, simp_all)+<br>\nthm 3</p>\n<p>I hope the example proofs still cover the structure that was important <br>\nto you (I changed them only to have some lemma I could actually prove). <br>\nNote the following points:</p>\n<p>1) In lemma 3 we do not explicitly all-quantify i, thus it is handled as <br>\n\"arbitrary but fixed\" throughout the proof (and implicitly <br>\nall-quantified after the proof is finished; in fact \"thm 2\" and \"thm 3\" <br>\ngive exactly the same result). This can always be done when we do not <br>\nneed to vary/instantiate i inside the proof itself.</p>\n<p>2) The attribute [rule_format] turns (some) HOL connectives into Pure <br>\nconnectives (which are used to present natural deduction style rules in <br>\nIsabelle, hence the name).</p>\n<p>3) For Isar proofs (i.e., structured proofs, as opposed to <br>\nproof-scripts) the style of lemma 3 is the most idiomatic, if such a <br>\nstyle is not possible (since we need to generalize a variable like i), <br>\nthen the style of lemma 2 is the next most idiomatic. As Larry already <br>\npointed out, the style of lemma 1 is the least idiomatic nowadays.</p>\n<p>hope that helps,</p>\n<p>chris</p>",
        "id": 294227380,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900658
    }
]