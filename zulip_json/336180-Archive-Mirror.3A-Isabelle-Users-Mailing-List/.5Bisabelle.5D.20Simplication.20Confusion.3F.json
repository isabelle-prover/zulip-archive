[
    {
        "content": "<p>From: Richard Warburton &lt;<a href=\"mailto:richard.warburton@gmail.com\">richard.warburton@gmail.com</a>&gt;<br>\nI have an equivalence relation that I am trying to prove symmetric,<br>\nwhich is defined as</p>\n<p>lemma \"(p,q) : \\&lt;smile&gt; ==&gt; (q,p) : \\&lt;smile&gt;\"</p>\n<p>It seems a very trivia proof to me, simply unfold the definition of<br>\nthe induction, use the symmetry of disjunction and equality and then<br>\napply the rules of the inductive definition, I want to do something<br>\nlike:</p>\n<p>lemma \"(p,q) : \\&lt;smile&gt; ==&gt; (q,p) : \\&lt;smile&gt;\" (* symmetry *)<br>\nproof -<br>\n  assume \"(p, q) : \\&lt;smile&gt;\"<br>\n  hence \"(ALL i. (terminated(exec(p,i)) --&gt; (exec(p,i) = exec(q,i)) |<br>\n(terminated(exec(q,i)) --&gt; (exec(p,i) = exec(q,i)))))\" by (rule<br>\nterminequivalent.induct)<br>\n  hence \"(ALL i. (terminated(exec(q,i)) --&gt; (exec(q,i) = exec(p,i)) |<br>\n(terminated(exec(p,i)) --&gt; (exec(q,i) = exec(p,i)))))\" by simp<br>\n  thus \"(q, p) : \\&lt;smile&gt;\" by (rule terminequivalent.step)<br>\nqed</p>\n<p>However the middle simp step fails, it is happy to deduce \"(ALL i.<br>\n(terminated(exec(q,i)) --&gt; (exec(q,i) = exec(p,i)) |<br>\n(terminated(exec(p,i)) --&gt; (exec(p,i) = exec(q,i)))))\" or \"(ALL i.<br>\n(terminated(exec(q,i)) --&gt; (exec(p,i) = exec(q,i)) |<br>\n(terminated(exec(p,i)) --&gt; (exec(q,i) = exec(p,i)))))\" but it (and<br>\nsuccessive simp attempts) fail to recognise that equality is<br>\nsymmetric.  I initially thought this might be a precedence/binding<br>\nproblem (which motivated the extensive bracket use) but it didn't seem<br>\nto resolve anything.  I apologise if this seems like a trivial<br>\nproblem, but I am rather confused as to why simp is happy to exchange<br>\nthe terms in either place, but not both.</p>\n<p>Richard</p>",
        "id": 294050886,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819422
    },
    {
        "content": "<p>From: Steven Obua &lt;<a href=\"mailto:obua@in.tum.de\">obua@in.tum.de</a>&gt;<br>\nRichard Warburton wrote:</p>\n<p>maybe \"auto\" instead of \"simp\" works there.</p>\n<p>Steven</p>",
        "id": 294050897,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819427
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nI discovered some interesting simplifier quirks when I tried this out.</p>\n<p>This term:<br>\n \"(ALL i. (terminated(exec(p,i)) --&gt; (exec(p,i) = exec(q,i)) |<br>\n  (terminated(exec(q,i)) --&gt; (exec(p,i) = exec(q,i)))))\"</p>\n<p>simplifies to this:<br>\n  \"ALL i. terminated (exec (p, i))  --&gt;<br>\n        terminated (exec (q, i))  --&gt; exec (p, i) = exec (q, i)\"</p>\n<p>When the above term is present in the assumptions, I assumed that the <br>\nsimplifier would add a conditional rewrite like this:<br>\n  \"!!i. [| terminated (exec (p, i)); terminated (exec (q, i)) |]<br>\n        ==&gt; exec (p, i) == exec (q, i)\"</p>\n<p>That rewrite would have been sufficient to solve the next subgoal. But when I <br>\nlooked at the simplifier trace, I found this rewrite instead:<br>\n  \"!!i. [| terminated (exec (p, i)); terminated (exec (q, i)) |]<br>\n        ==&gt; (exec (p, i) = exec (q, i)) == True\"</p>\n<p>Very strange!</p>\n<p>I tried tracing a few simple examples to figure out how the simplifier <br>\nconverts assumptions into rewrites, and here is what I found:</p>\n<p>Assumption: \"P --&gt; x = y\"<br>\nRewrite: \"P ==&gt; x == y\"</p>\n<p>Assumption: \"P y --&gt; x = y\"<br>\nRewrite: \"P y ==&gt; x == y\"</p>\n<p>Assumption: \"P x --&gt; x = y\"<br>\nRewrite: \"P x ==&gt; y == x\"  (* notice reversed orientation! *)</p>\n<p>Assumption: \"P x y --&gt; x = y\"<br>\nRewrite: \"P x y ==&gt; (x = y) == True\"  (* similar to example above *)</p>\n<p>I imagine that this behavior took some extra work to implement, so there must <br>\nhave been a reason for it. Can anyone explain?</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294050918,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819440
    },
    {
        "content": "<p>From: Richard Warburton &lt;<a href=\"mailto:richard.warburton@gmail.com\">richard.warburton@gmail.com</a>&gt;<br>\nThanks for the suggestion, but I have already tried auto as well, in<br>\nfact I have even tried the more powerful methods like best.  Its also<br>\nthe case that this fails to prove in a two step scenario, ie I can't<br>\nsimplify to one of the intermediate goals and then simplify again to<br>\nthe desired goal.  Is there a way of seeing a 'trace' of the automatic<br>\nmethod in order to better identify what is happening?</p>\n<p>Richard</p>",
        "id": 294050968,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819446
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nBrian Huffman schrieb:</p>\n<blockquote>\n<p>On Tuesday 14 August 2007, Richard Warburton wrote:</p>\n<blockquote>\n<p>lemma \"(p,q) : \\&lt;smile&gt; ==&gt; (q,p) : \\&lt;smile&gt;\" (* symmetry *)<br>\nproof -<br>\n  assume \"(p, q) : \\&lt;smile&gt;\"<br>\n  hence \"(ALL i. (terminated(exec(p,i)) --&gt; (exec(p,i) = exec(q,i)) |<br>\n(terminated(exec(q,i)) --&gt; (exec(p,i) = exec(q,i)))))\" by (rule<br>\nterminequivalent.induct)<br>\n  hence \"(ALL i. (terminated(exec(q,i)) --&gt; (exec(q,i) = exec(p,i)) |<br>\n(terminated(exec(p,i)) --&gt; (exec(q,i) = exec(p,i)))))\" by simp<br>\n  thus \"(q, p) : \\&lt;smile&gt;\" by (rule terminequivalent.step)<br>\nqed</p>\n<p>However the middle simp step fails, it is happy to deduce \"(ALL i.<br>\n(terminated(exec(q,i)) --&gt; (exec(q,i) = exec(p,i)) |<br>\n(terminated(exec(p,i)) --&gt; (exec(p,i) = exec(q,i)))))\" or \"(ALL i.<br>\n(terminated(exec(q,i)) --&gt; (exec(p,i) = exec(q,i)) |<br>\n(terminated(exec(p,i)) --&gt; (exec(q,i) = exec(p,i)))))\" but it (and<br>\nsuccessive simp attempts) fail to recognise that equality is<br>\nsymmetric.</p>\n</blockquote>\n<p>I discovered some interesting simplifier quirks when I tried this out.</p>\n<p>This term:<br>\n \"(ALL i. (terminated(exec(p,i)) --&gt; (exec(p,i) = exec(q,i)) |<br>\n  (terminated(exec(q,i)) --&gt; (exec(p,i) = exec(q,i)))))\"</p>\n<p>simplifies to this:<br>\n  \"ALL i. terminated (exec (p, i))  --&gt;<br>\n        terminated (exec (q, i))  --&gt; exec (p, i) = exec (q, i)\"</p>\n<p>When the above term is present in the assumptions, I assumed that the <br>\nsimplifier would add a conditional rewrite like this:<br>\n  \"!!i. [| terminated (exec (p, i)); terminated (exec (q, i)) |]<br>\n        ==&gt; exec (p, i) == exec (q, i)\"</p>\n<p>That rewrite would have been sufficient to solve the next subgoal. But when I <br>\nlooked at the simplifier trace, I found this rewrite instead:<br>\n  \"!!i. [| terminated (exec (p, i)); terminated (exec (q, i)) |]<br>\n        ==&gt; (exec (p, i) = exec (q, i)) == True\"</p>\n<p>Very strange!</p>\n</blockquote>\n<p>Admittedly, I had to ponder this for quite some time before I realized <br>\nwhat was going on: Isabelle tried to orient the rule in either direction <br>\nbut failed because this would immediately lead to death by <br>\nnontermination: both exec(p,i) and exec(q,i) appear in the premises and <br>\nthis would lead to a recursive call of the simplifier again and again. <br>\nHence all that is left is the == True version - better than nothing.</p>\n<blockquote>\n<p>I tried tracing a few simple examples to figure out how the simplifier <br>\nconverts assumptions into rewrites, and here is what I found:</p>\n<p>Assumption: \"P --&gt; x = y\"<br>\nRewrite: \"P ==&gt; x == y\"</p>\n<p>Assumption: \"P y --&gt; x = y\"<br>\nRewrite: \"P y ==&gt; x == y\"</p>\n<p>Assumption: \"P x --&gt; x = y\"<br>\nRewrite: \"P x ==&gt; y == x\"  (* notice reversed orientation! *)</p>\n</blockquote>\n<p>This one is easy. The direction x==y is no good: which y should we take <br>\nwhen applying the rule? The chosen orientation means that any y will get <br>\nrewritten to some x for which we happen to have the fact \"P x\" available.</p>\n<blockquote>\n<p>Assumption: \"P x y --&gt; x = y\"<br>\nRewrite: \"P x y ==&gt; (x = y) == True\"  (* similar to example above *)</p>\n</blockquote>\n<p>Same as above, this is the only way to avoid nontermination.</p>\n<blockquote>\n<p>I imagine that this behavior took some extra work to implement, so there must <br>\nhave been a reason for it. Can anyone explain?</p>\n</blockquote>\n<p>Yes :-)</p>\n<blockquote>\n<ul>\n<li>Brian</li>\n</ul>\n</blockquote>\n<p>Tobias</p>",
        "id": 294050983,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819452
    }
]