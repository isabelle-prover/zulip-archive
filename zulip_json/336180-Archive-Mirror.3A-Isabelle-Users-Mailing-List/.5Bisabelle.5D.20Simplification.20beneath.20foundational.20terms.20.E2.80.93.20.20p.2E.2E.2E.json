[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi</p>\n<blockquote>\n<ul>\n<li>\n<p>A congruence rule can only be provided on a per-definition base,<br>\nnot<br>\non a per-interpretation base: the critical syntactic constant c.f<br>\nappears in <em>any</em> interpretation.</p>\n</li>\n<li>\n<p>Having a default congruence rules that must be <em>removed</em> in certain<br>\nnon-trivial situations is a bad idea: few users are getting in touch<br>\nwith congruence rules ever.<br>\n</p>\n</li>\n</ul>\n</blockquote>\n<p>what are the special situations where you actually <em>want</em><br>\nsimplification of locale parameters?</p>\n<p>In my memory, I only remember very odd effects due to unwanted<br>\nsimplifications, but I never wanted to simplify locale parameters fixed<br>\nby an interpretation. </p>\n<p>The only case I can imagine right now are partial interpretations, like<br>\nin this artificial example:</p>\n<p>locale Invariant = fixes A B state<br>\nbegin<br>\n  definition \"I == A state &amp; B state\"<br>\n  ...<br>\nend</p>\n<p>interpretation my_inv: Invariant (%s. assn1 s) (%s. assn2 s) state <br>\n    for state .</p>\n<p>and the subsequent usage of \"my_inv.I\" as a predicate over states.<br>\nIn this case, in term \"my_inv.I s\" == \"Invariant.I assn1 assn2 s\", I<br>\nwant s to be simplified, but not assn1 and assn2.</p>",
        "id": 294827204,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245031
    }
]