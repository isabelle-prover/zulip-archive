[
    {
        "content": "<p>From: Juan Antonio Navarro PÃ©rez &lt;<a href=\"mailto:juannavarroperez@gmail.com\">juannavarroperez@gmail.com</a>&gt;<br>\nHi all!</p>\n<p>Suppose I have some unary predicate P, and I have proved that it has a<br>\nunique satisfying solution. That is, I prove the theorem:</p>\n<p>theorem unique [simp]: \"[| P a; P b |] ==&gt; a = b\"</p>\n<p>It seems that, even after declaring the rule as a simplification, the<br>\nrule is not always applied by Isabelle. As an example, the following<br>\nproof attempt fails.</p>\n<p>theorem foo: \"[| P a; P b |] ==&gt; f a = f b\"<br>\napply (simp)</p>\n<p>Alternatively, I've been doing something like</p>\n<p>theorem foo: \"[| P a; P b |] ==&gt; f a = f b\"<br>\nby (drule unique, assumption, simp)</p>\n<p>I can see why the simplification rule wont always be applied by<br>\nIsabelle, as it would easily loop forever.</p>\n<p>Still, what would be the best way to deal with this kind of<br>\npredicates? So that most of the deductions with them, and simple<br>\nexamples such as theorem \"foo\", could be proved automatically?</p>\n<p>Thanks!</p>\n<p>Juan</p>",
        "id": 294093456,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832602
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Juan,</p>\n<p>When you declare \"unique\" as a simp rule, Isabelle's simplifier<br>\nimmediately notices that it would cause looping in its original form.<br>\nInstead, it uses this rule for simplification:</p>\n<p>\"[| P a; P b |] ==&gt; (a = b) == True\"</p>\n<p>(I determined this by doing \"simp add: unique\" with \"Trace Simplifier\" enabled.)<br>\nThis modified form won't loop, but it is not sufficient to prove your<br>\ntheorem \"foo\".</p>\n<p>One possibility is to use \"unique\" with auto, as a dest rule:</p>\n<p>theorem foo: \"[| P a; P b |] ==&gt; f a = f b\"<br>\nby (auto dest: unique)</p>\n<p>The effect of \"dest: unique\" is that when auto finds \"P a\" and \"P b\"<br>\nin the assumptions, it will remove \"P a\" and replace it by \"a = b\".</p>\n<p>Another possibility is to do some trickery with Isabelle's<br>\ndefinite-choice operator. This method works using only ordinary simp<br>\nrules, but you will need to prove existence as well as uniqueness, and<br>\nit also requires the definition of an extra constant.</p>\n<p>lemma exists: \"EX x. P x\"<br>\nsorry</p>\n<p>lemma exists1: \"EX! x. P x\"<br>\nusing exists unique by (rule ex_ex1I)</p>\n<p>definition \"theP = (THE x. P x)\"</p>\n<p>lemma P_iff: \"P a = (a = theP)\"<br>\nunfolding theP_def<br>\napply safe<br>\napply (rule the1_equality [symmetric])<br>\napply (rule exists1)<br>\napply assumption<br>\napply (rule theI')<br>\napply (rule exists1)<br>\ndone</p>\n<p>Unlike \"unique\", lemma \"P_iff\" is a well-behaved simp rule.</p>\n<p>theorem foo: \"[| P a; P b |] ==&gt; f a = f b\"<br>\nby (simp add: P_iff)</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294093472,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832608
    }
]