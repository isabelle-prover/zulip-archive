[
    {
        "content": "<p>From: John Ridgway &lt;<a href=\"mailto:john@jacelridge.com\">john@jacelridge.com</a>&gt;<br>\nI'm having a problem.  Given the following lemma:</p>\n<p>lemma \"<br>\n!! C tau_0 epsilon_0 rs Rs cx w tau_11 epsilon_11 tau_10 epsilon_10 y.<br>\n       [| C = valconfig w (exntoprimmech cx) Rs tau_11 epsilon_11; <br>\n      tau_0 = tau_10;<br>\n      epsilon_0 = epsilon_10;<br>\n          rs = dom Rs; <br>\n          Rs : validmechanisms; <br>\n      exntoprimmech cx : rs; <br>\n      (w, tau_11) : mvalhastype;<br>\n          exception cx tau_11 : epsilon_11;<br>\n          \\&lt;forall&gt;cx' tau_11'. exception cx' tau_11' : epsilon_11 --&gt; cx' = cx \\&lt;and&gt; tau_11' = tau_11;<br>\n      tau_10 = tau_11;<br>\n          epsilon_10 = epsilon_11; <br>\n      Rs : validmechanisms; <br>\n      isemptyrs (exntoprimmech cx) Rs; <br>\n      tau_11 : istype;<br>\n          Rs (exntoprimmech cx) = Some y |]<br>\n       ==&gt; (\\&lt;exists&gt;C' tau_1 epsilon_1.<br>\n              (C, C') : onestep \\&lt;and&gt;<br>\n              (C', tau_1, epsilon_1) : configurationhastype \\&lt;and&gt; (tau_1, tau_0) : issubtype \\&lt;and&gt; epsilon_1 \\&lt;subseteq&gt; epsilon_0) \\&lt;or&gt;<br>\n              (\\&lt;exists&gt;w r Rs tau_0 epsilon_0. isemptyrs r Rs \\&lt;and&gt; C = valconfig w r Rs tau_0 epsilon_0)\"</p>\n<p>I try apply(simp) as the first step in my proof, and Isabelle goes away for a long time.  I don't know whether it ever comes back; I gave up on it before then.  Removing the premise<br>\n          \\&lt;forall&gt;cx' tau_11'. exception cx' tau_11' : epsilon_11 --&gt; cx' = cx \\&lt;and&gt; tau_11' = tau_11;<br>\nallows the whole mess to be proved by simp.  What about that premise is causing the trouble?  Or is it likely an interaction with other stuff?  How do I figure out which it is?</p>\n<p>Thanks in advance for your help.</p>\n<p>Peace</p>\n<ul>\n<li>John Ridgway<br>\nVisiting Assistant Professor<br>\nTrinity College<br>\nHartford, CT</li>\n</ul>",
        "id": 294148969,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848592
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThis is a tricky situation. The simplifier diverges and you want to find<br>\nout why. In principle the answer is simple: switch on the simplifier<br>\ntrace. In practice, this can overload the interface (Proof General and<br>\njedit) because an infinite rewrite tends to produce an infinite trace.<br>\nYou may be lucky because the infinity of the trace only manifests itself<br>\nwhen the trace depth is set sufficiently high (initially it is 1). Or<br>\nyou may be able to abort the simp command quickly enough before the<br>\ninterface freezes up.</p>\n<p>I general it is hard to figure out why something diverges just by<br>\nlooking at the initial proof state because it may involve some<br>\nunexpected interaction between the hundreds of existing rewrite rules<br>\nand the goal state. In you goal, the offending assumption will be turned<br>\ninto two rewrite rules by the simplifier:</p>\n<p>exception ?cx' ?tau_11' : epsilon_11 ==&gt; (?cx' = cx) = True<br>\nexception ?cx' ?tau_11' : epsilon_11 ==&gt; (?tau_11' = tau_11) = True</p>\n<p>Not sure why that could lead to a problem.</p>\n<p>Tobias</p>\n<p>PS The \"!! ...\" prefix is not needed.</p>",
        "id": 294148980,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848598
    },
    {
        "content": "<p>From: Holger Gast &lt;<a href=\"mailto:gast@informatik.uni-tuebingen.de\">gast@informatik.uni-tuebingen.de</a>&gt;<br>\nHi John,</p>\n<p>if you find you have to invoke the simplifier trace, you may want to<br>\ntry the I3P interface for the purpose:<br>\nit copes with the stream of messages with minimal processing overhead<br>\n(by lazy rendering) and always allows you to \"interrupt\"<br>\nthe prover to examine the message already received :)<br>\n(Just revoke the command, I3P keeps sending INT to Isabelle until<br>\nit succeeds. Also, there is a \"local option\" that turns on<br>\nthe trace for a single command; right-click to the left gutter in the<br>\neditor.)</p>\n<p>In your example, I found that the following pattern repeats:</p>\n<p>[1]Applying instance of rewrite rule \"??.unknown\":<br>\nexception ?x ?xa3 ∈ epsilon_11 ⟹ cx ≡ ?x</p>\n<p>[1]Trying to rewrite:<br>\nexception ?x ?xa3 ∈ epsilon_11 ⟹ cx ≡ ?x</p>\n<p>[2]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\nexception ?x ?xa3 ∈ epsilon_11</p>\n<p>[1]SUCCEEDED<br>\ncx ≡ cx</p>\n<p>Hope this helps,</p>\n<p>Holger</p>",
        "id": 294149044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848605
    },
    {
        "content": "<p>From: John Ridgway &lt;<a href=\"mailto:john@jacelridge.com\">john@jacelridge.com</a>&gt;<br>\nI now have a bare-bones theory which demonstrates this problem:</p>\n<p>theory temp imports Main begin</p>\n<p>lemma \"<br>\n  \\&lt;lbrakk&gt; (x::nat,y::nat) \\&lt;in&gt; xys;<br>\n    \\&lt;forall&gt;x' y'. (x', y') \\&lt;in&gt; xys \\&lt;longrightarrow&gt; x'=x \\&lt;and&gt; y'=y;<br>\n    y'' = y \\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt;<br>\n  True\"<br>\napply(simp)<br>\ndone</p>\n<p>end</p>\n<p>Note that I'm importing from Main (HOL), so nothing I've added is causing any problems.  If I can't do this, how do I say that a particular constructed value is in a set, and that any constructed value in the set is equal to this one?  The y''=y premise is essential to causing the simplifier to loop (x''=x also causes a loop).  I'm at a loss.</p>\n<p>Peace</p>\n<ul>\n<li>John</li>\n</ul>",
        "id": 294149083,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848622
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nNothing in Isabelle can really be trusted to solve your problems as a <br>\nblack box. In this situation you can do two things. One is to try lots <br>\nof variants, and the other is to try to understand exactly how the <br>\nsystem works.</p>\n<p>The simp variants (simp(no_asm)) and (simp(no_asm_use)) can sometimes <br>\nhelp with these problems by rewriting your assumptions before using them <br>\nas rewrites. This won't help in this case. Many other solvers which <br>\ndon't call the simplifier can solve your reduced example (metis, blast, <br>\nsafe).</p>\n<p>In summary: before thinking, always blindly type a bunch of nonsense.</p>\n<p>This may not solve your real problem, and keeping the simplifier on your <br>\nside is usually necessary. The simplifier (in assumption-using mode, the <br>\ndefault) treats assumptions as rewrite rules as though they'd been <br>\nsupplied with [simp]. This causes it to diverge frequently since they <br>\nmay loop in various ways. In this case, it's treating your rule as a way <br>\nof rewriting <em>any</em> natural into x or y by showing it is a component of a <br>\nmember of xys. This includes naturals that have already been rewritten <br>\nto x or y, as well as the naturals in the assumption it must prove to <br>\nuse this rule (it really is that stupid). In short, you can't let this <br>\nassumption stay in this form.</p>\n<p>You can probably finesse your way around this by using the logically <br>\nequivalent assumption<br>\n   \"ALL x' y'. ((x', y') : xys) = (x' = x &amp; y' = y &amp; xys ~= {})\"</p>\n<p>(This can be proven equal to your assumption by fast)</p>\n<p>The simplifier is now not being given a license to rewrite any x or y, <br>\nbut only terms of the form (x', y') : xys. This should hopefully be a <br>\nforce for good and not evil.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294149111,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848632
    },
    {
        "content": "<p>From: John Ridgway &lt;<a href=\"mailto:john@jacelridge.com\">john@jacelridge.com</a>&gt;<br>\nI actually went with </p>\n<p>(x,y) \\&lt;in&gt; xys<br>\n  and<br>\nALL x' y'. (x' \\&lt;notequal&gt; x \\&lt;or&gt; y' \\&lt;notequal&gt; y) --&gt; ((x',y') \\&lt;notin&gt; xys)</p>\n<p>and that seems to work better.  Thanks for your help.</p>\n<p>Peace</p>\n<ul>\n<li>John</li>\n</ul>",
        "id": 294149115,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848635
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nTom, your analysis is not quite accurate: the rewrite rules coming out<br>\nof the hypothesis do not rewrite <em>any</em> natural number. The simplifier is<br>\nintelligent enough to avoid that. As I pointed out in my previous email,<br>\nit derives the rewrite rule</p>\n<p>(?x', ?y') : xys ==&gt;  (?x'=x) = True<br>\n(?x', ?y') : xys ==&gt;  (?y'=y) = True</p>\n<p>They are harmless. However, I failed to see that it also derives</p>\n<p>(?x', ?y') : xys ==&gt;  x = ?x'<br>\n(?x', ?y') : xys ==&gt;  y = ?y'</p>\n<p>Either of them causes a problem together with (x,y) : xys, because they<br>\nallow x = x = x = ... or y = y = y = ... .</p>\n<p>Tobias</p>",
        "id": 294149143,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848647
    }
]