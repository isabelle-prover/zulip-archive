[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>I've been playing around with normalisation of monad expressions and <br>\nhave run into a few problems.</p>\n<p>First of all, one thing I noticed is that the simplifier sometimes fails <br>\nto apply permutative rules when I thought it should, e.g. minimal example:</p>\n<p>typedecl a<br>\ntypedecl b<br>\ntypedecl c<br>\ntypedecl d</p>\n<p>axiomatization<br>\n   a :: \"(a ⇒ a ⇒ c) ⇒ d\" and<br>\n   b :: \"b ⇒ b ⇒ c\" and<br>\n   c :: \"a ⇒ a ⇒ b\"<br>\n   where<br>\n     a_commute: \"a (λx y. b (f x y) (g x y)) ≡ a (λx y. b (g x y) (f x y))\"</p>\n<p>ML_val ‹<br>\n   let<br>\n     val ctxt = @{context} addsimps @{thms a_commute}<br>\n     val ct = @{cterm \"a (λx y. b (c x y) (c y x))\"}<br>\n     val ct' = @{cterm \"a (λy x. b (c x y) (c y x))\"}<br>\n   in<br>\n     (ct,ct') |&gt; apply2 (Raw_Simplifier.rewrite_cterm <br>\n(false,false,false) (K (K NONE)) ctxt)<br>\n   end<br>\n›</p>\n<p>I would have expected the simplifier to rewrite one of these terms to <br>\nthe other – but it doesn't do anything for either of them. After adding <br>\nsome tracing code, I believe that the reason is that the simplifier does <br>\nnot β-normalise terms before comparing them. Is this the intended behaviour?</p>\n<p>In any case, for monad normalisation, the simplifier's idea of what <br>\nconstitutes a permutative rule is too restrictive in any case, so I set <br>\nup a \"TERM_ORD\" dummy constant similar to the \"NO_MATCH\" and <br>\n\"ASSUMPTION\" constants. \"TERM_ORD a b\" gets rewritten to \"True\" by a <br>\nsimproc iff the first argument is strictly smaller than the second. <br>\n(cong rules ensure that TERM_ORD's arguments do not get simplified <br>\nthemselves) For the reasons outlined above, it also performs <br>\nβ-η-reduction before comparing the terms.</p>\n<p>This works very well in most cases, but I found one pathological example <br>\nof the form</p>\n<p>t := bind A (λx. bind A (λy. bind (B x y) (λ_. bind (B y x) (λ_. e))))</p>\n<p>The commutativity rule for bind, which is</p>\n<p>bind A (λx. bind B (λy. C x y)) = bind B (λy. bind A (λx. C x y)) ,</p>\n<p>can be applied either to the whole of t (flipping the first two binds) <br>\nor to the third bind (flipping the 3rd and 4th bind). In both cases, we <br>\nget the term</p>\n<p>t' := bind A (λx. bind A (λy. bind (B y x) (λ_. bind (B x y) (λ_. e))))</p>\n<p>The problem is now that when flipping the first two binds, the arguments <br>\nof B are \"Bound 1\" and \"Bound 0\". However, when flipping the last two <br>\nbinds, they are \"Free \":001\"\" and \"Free \":002\"\" because the simplifier <br>\ninstantiates bound variables to free variables like this when passing an <br>\nabstraction. This exactly reverses the term order, since the Bounds are <br>\ncounted inside-out and the Frees are counted outside-in. This means that <br>\n\"TERM_ORD\" will be rewritten to \"True\" in both cases and we get an <br>\ninfinite rewriting cycle.</p>\n<p>What is the best way to solve this problem? Can the simplifier ever run <br>\ninto a problem like this or is that prevented by the fact that it <br>\ndoesn't do β normalisation?</p>\n<p>The most robust way would probably be to replace the Free variables with <br>\n(dangling) bound variables before performing the term order comparison, <br>\nbut I don't think the necessary information is publicly available in the <br>\ncontext.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294676838,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175242
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThe fact that the simplifier does not β-normalise terms before comparing them is <br>\npossibly a combination of the fact that I never expected it to be used in such <br>\nsituations and the potential cost of the normalisation. I suspect it would break <br>\ntoo many proofs if we changed that behaviour, although I would of course make <br>\nsense from a logical point of view.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/gXBOEeWojBRqduS5_rh2nrN-/smime.p7s\">smime.p7s</a></p>",
        "id": 294676989,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175285
    }
]