[
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHello Isabelle users.</p>\n<p>I've been putting a little time into updating the l4.verified proofs to <br>\nisabelle-2014 (partly because I wanted to know what fraction of the <br>\nproblems would be caused by my hypsubst change). I've had a few problems <br>\nI will soon report on. The simplest problem to report involves the <br>\nsimplifier.</p>\n<p>I haven't been following closely, but I take it the simplifier is now a <br>\nbit more aggressive in figuring out how to instantiate assumptions. This <br>\nis probably a good thing, and has shrunk a few of the proofs in the <br>\nrepository already.</p>\n<p>The problem is that this new mechanism sometimes leads to divergence, <br>\nand I don't know how to turn it off. Here's an example I came across (or <br>\nsee the attached theory):</p>\n<p>theory Scratch imports Main begin</p>\n<p>lemma foo:<br>\n   \"⋀a aa b ba ab bb bc.<br>\n        pasDomainAbs initial_aag (cur_domain b)<br>\n        ∈ subjectReads (pasPolicy initial_aag) (OrdinaryLabel a) ⟹<br>\n        u = Partition a ⟹<br>\n        s = ((aa, b), ba) ⟹<br>\n        s' = ((ab, bb), bc) ⟹<br>\n        states_equiv_for<br>\n         (λx. pasObjectAbs initial_aag x ∈ subjectReads (pasPolicy <br>\ninitial_aag) (OrdinaryLabel a))<br>\n         (λx. pasIRQAbs initial_aag x ∈ subjectReads (pasPolicy <br>\ninitial_aag) (OrdinaryLabel a))<br>\n         (λx. pasASIDAbs initial_aag x ∈ subjectReads (pasPolicy <br>\ninitial_aag) (OrdinaryLabel a))<br>\n         (λx. pasDomainAbs initial_aag x ∈ subjectReads (pasPolicy <br>\ninitial_aag) (OrdinaryLabel a))<br>\n         (λx. ptr_range x 12) b bb ⟹<br>\n        pasDomainAbs initial_aag (cur_domain b)<br>\n        ∈ subjectReads (pasPolicy initial_aag) (OrdinaryLabel a) ⟶<br>\n        cur_domain b = cur_domain bb ∧<br>\n        globals_equiv b bb ∧<br>\n        scheduler_action b = scheduler_action bb ∧<br>\n        work_units_completed b = work_units_completed bb ∧<br>\n        equiv_irq_state (machine_state b) (machine_state bb) ∧<br>\n        (user_modes ba ⟶ aa = ab) ∧<br>\n        ba = bc ∧ equiv_for (λx. pasObjectAbs initial_aag x = SilcLabel) <br>\nkheap b bb ⟹<br>\n        pasDomainAbs initial_aag (cur_domain bb)<br>\n        ∈ subjectReads (pasPolicy initial_aag) (OrdinaryLabel a) ⟶<br>\n        cur_domain b = cur_domain bb ∧<br>\n        globals_equiv b bb ∧<br>\n        scheduler_action b = scheduler_action bb ∧<br>\n        work_units_completed b = work_units_completed bb ∧<br>\n        equiv_irq_state (machine_state b) (machine_state bb) ∧<br>\n        (user_modes ba ⟶ aa = ab) ∧<br>\n        ba = bc ∧ equiv_for (λx. pasObjectAbs initial_aag x = SilcLabel) <br>\nkheap b bb ⟹<br>\n        (user_modes ba ⟶ aa = ab) ∧ ba = bc<br>\n   \"</p>\n<p>This is just a copy of a goal that came up in a proof somewhere. I don't <br>\nknow what any of this means either, and it turns out it doesn't matter. <br>\nThe behaviour is the same in a scratch theory with none of the constants <br>\ndefined.</p>\n<p>This problem will cause \"simp\" or \"(simp only: )\" to loop. It will be <br>\nsolved immediately by clarify or blast. It can be solved by metis if we <br>\nadjust the problem a little to ensure the type variables all have sorts.</p>\n<p>The news file suggests that [[simp_legacy_precond]] might be relevant to <br>\nthis issue, but it doesn't seem to change anything.</p>\n<p>In detail, this problem is solved by simplifying the implication whose <br>\npremise is already known, i.e. apply (drule(1) mp). It happens the <br>\nscript \"apply (drule(1) mp, simp)\" solves the goal.</p>\n<p>This weakness of simp is quite frustrating. To generate the above goal, <br>\nI had to work around the possible simp divergence by simplifying in stages:<br>\n   apply (simp add: uwr_def sameFor_def sameFor_subject_def)<br>\n   apply clarify<br>\n   apply (simp(no_asm_use))<br>\n   apply clarify</p>\n<p>I'm willing to accept the argument that this is not a bug but rather a <br>\ntradeoff, with the default behaviour now being to solve more problems <br>\nbut sometimes time out more often. However I'd really like a way to turn <br>\nthis off. I've already had to dance around the problem in a couple of <br>\nplaces, and it seems to be a generally unpleasant experience. My usual <br>\nworkarounds (simp only: ) and (simp(no_asm_use)) can't help me here.</p>\n<p>I attach my scratch theory with this problem.</p>\n<p>I hope there's a simple fix.</p>\n<p>Cheers,<br>\n     Thomas.<br>\n<a href=\"/user_uploads/14278/kDxRJQv8zq5-cPwir1cBIN8D/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294288241,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922563
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Thomas,</p>\n<p>I just tried your file with Isabelle2013-2 and simp looped. This corroborates<br>\nyour experience that [[simp_legacy_precond]] doesn't do anything, because the<br>\ndivergence is not related to it. In any case, the only simplifier change I am<br>\naware of relates to the handling of conjunctions in the premises of conditional<br>\nrewrite rules, and [[simp_legacy_precond]] switches that off.</p>\n<p>Tobias</p>",
        "id": 294288275,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922575
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nIt's been pointed out to me that this particular behaviour of the <br>\nsimplifier predates Isabelle2014.</p>\n<p>Apologies to everyone. I assumed that the extracted example was <br>\nrepresentative because it also caused the simplifier to loop. Instead it <br>\nlooks like the context somehow previously allowed the simplifier not to <br>\nloop, and this has changed. I will have to investigate further.</p>\n<p>Apologies once again,<br>\n     Thomas.</p>",
        "id": 294288304,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922588
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nThe mystery deepens. This problem is somehow my fault.</p>\n<p>It is the presence of the three completely redundant equalities \"u = <br>\nPartition a\" \"s = ((aa, b), ba)\" \"s' = ((ab, bb), bc)\" which causes the <br>\nsimplifier to loop. These have been preserved by the hypothesis <br>\nsubstitution change.</p>\n<p>In either case, the simplifier initially loops on the assumption it has<br>\n   \"pasDomainAbs initial_aag (cur_domain b)<br>\n        ∈ subjectReads (pasPolicy initial_aag) (OrdinaryLabel a) ⟶<br>\n        cur_domain b = cur_domain bb\"</p>\n<p>But in the old world, the simplifier goes down the rabbit hole - up to a <br>\nrecursive depth of 100 - then realises it is stuck, gives up, and solves <br>\nthe problem instead.</p>\n<p>In the new world, the simplifier does the same things. But once it has <br>\ndone that, it starts thinking about the preserved subgoal containing <br>\n\"aa\" which provides a use for one of the conditional rewrites \"aa = ab\" <br>\nfloating around. Somehow the simplifier has multiple options now, so <br>\ninstead of running to a depth of 100 and then giving up and coming back, <br>\nit starts backtracking different approaches, and will never finish.</p>\n<p>In hindsight this all makes sense, and is entirely my problem. I hope <br>\nnoone else has to deal with anything this awful as a result of this change.</p>\n<p>Thanks to everyone for listening to me talk to myself about simplifier <br>\nmysteries.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 294288318,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922594
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis thread seems to be resolved for now.  I just want to make sure that <br>\nthere is nothing left to reconsider for the Isabelle2014 release, which <br>\nwill be shipped next week.</p>\n<p>Some months ago there was a similar surprise about simplifier depth limit <br>\nconcerning simprocs.  See the subject line \"Product_Type.split_beta fails\" <br>\nin October 2013 with the conclusion here: <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-February/msg00056.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-February/msg00056.html</a></p>\n<p>The changeset mentioned there is:</p>\n<p>changeset:   55375:d79c057c68f0<br>\nuser:        wenzelm<br>\ndate:        Mon Feb 10 13:04:08 2014 +0100<br>\nfiles:       src/Pure/raw_simplifier.ML<br>\ndescription:<br>\nmore elementary put_simpset: exchange the simplifier configuration <br>\noutright, which is particularly relevant concerning cumulative depth, e.g. <br>\nfor Product_Type.split_beta in the subsequent example:</p>\n<p>lemma \"P (\\&lt;lambda&gt;s. (case s of (x, y) \\&lt;Rightarrow&gt; c))\"<br>\n     using [[simp_depth_limit = 1]]<br>\n     apply simp<br>\n     oops</p>\n<p>It falls in the interval between the last release Isabelle2013-2 and the <br>\nemerging one Isabelle2014.  Thus it might be relevant concerning potential <br>\nregressions of Simplifier behaviour due to a change that was meant to <br>\nimprove the situation.</p>\n<p>Makarius</p>",
        "id": 294289003,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922815
    }
]