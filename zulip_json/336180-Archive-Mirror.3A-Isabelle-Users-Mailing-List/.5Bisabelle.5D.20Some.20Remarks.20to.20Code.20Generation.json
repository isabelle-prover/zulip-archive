[
    {
        "content": "<p>From: Patrick Michel &lt;<a href=\"mailto:uni@pbmichel.de\">uni@pbmichel.de</a>&gt;<br>\nHi!</p>\n<p>I am currently using the code generation facility (mostly for Scala).<br>\nAll in all it works very well so far, the generated code compiles, I have tried data type refinement, code equation replacement, etc. </p>\n<p>So thank you for this great feature!</p>\n<p>There are some minor oddities I stumbled on, however, some of which might be worth a change in the library:</p>\n<p>A) I was a bit shocked that after proving every function to be total in Isabelle and using proven code equations for refinement, I could make the generated code loop quite easily.</p>\n<p>I don't think this is discussed in the code equation chapter of the code generation tutorial.</p>\n<p>I stumbled upon it while giving some (admittedly very stupid) equation for an \"equal_class.equal\" implementation and first thought it would only be a corner case, as equality is handled in a quite special way.</p>\n<p>As it turns out it is quite easy to prove a code equation that obviously leads to non-terminating execution.<br>\nI guess it is non-trivial to find out if code equations screw you over, so there is not much that can be done here...</p>\n<p>B) Code_Integer uses reference equality on BigInt in Scala. That seems to be a bad idea… I had a hard time figuring out why my code did not behave as expected and it turned out that some zeros were not equal to zero (same with some ones). Replacing the equality in the generated code with \"inta.equals(int)\" fixed all my problems.</p>\n<p>I don't know how to adjust the part in Code_Integer to fix the code generator instead, so any advise there would be helpful.</p>\n<p>C) Tail recursion. I got stack overflows (with increased stack size) from many of my own functions and some of the library functions. I solved mine by data type refinement and code equations, which leaves the ones in the library.</p>\n<p>I think there was a discussion involving fold variants some time ago and which was more \"canonical\".<br>\nThe situation now seems to be that there is fold, foldl and foldr in List.thy:</p>\n<blockquote>\n<p>primrec fold :: \"('a =&gt; 'b =&gt; 'b) =&gt; 'a list =&gt; 'b =&gt; 'b\"<br>\nwhere<br>\n  fold_Nil:  \"fold f [] = id\"<br>\n| fold_Cons: \"fold f (x # xs) = fold f xs o f x\" -- {* natural argument order *}</p>\n<p>primrec foldr :: \"('a =&gt; 'b =&gt; 'b) =&gt; 'a list =&gt; 'b =&gt; 'b\"<br>\nwhere<br>\n  foldr_Nil:  \"foldr f [] = id\"<br>\n| foldr_Cons: \"foldr f (x # xs) = f x o foldr f xs\" -- {* natural argument order *}</p>\n<p>primrec foldl :: \"('b =&gt; 'a =&gt; 'b) =&gt; 'b =&gt; 'a list =&gt; 'b\"<br>\nwhere<br>\n  foldl_Nil:  \"foldl f a [] = a\"<br>\n| foldl_Cons: \"foldl f a (x # xs) = foldl f (f a x) xs\"</p>\n</blockquote>\n<p>Of these three, only foldl is tail recursive. My generated code had to tackle _extremely large_ parameters, so it was a good benchmark to test for tail recursion…</p>\n<p>Most notably the rev function on lists is not tail recursive, as its code equations are based on fold:</p>\n<blockquote>\n<p>lemma rev_conv_fold [code]:<br>\n  \"rev xs = fold Cons xs []\"<br>\n  by (simp add: fold_Cons_rev)</p>\n</blockquote>\n<p>I see no good reason for this as rev is the most basic of all tail recursive functions, so I replaced its code equations:</p>\n<blockquote>\n<p>declare rev_conv_fold [code del]</p>\n<p>lemma rev_foldl_general:<br>\n  \"rev m @ n = foldl (λl e. e # l) n m\"<br>\n  by (induct m, auto) (metis fold_Cons_rev foldr_conv_fold foldr_conv_foldl rev_rev_ident)</p>\n<p>lemma rev_foldl [code]:<br>\n  \"rev = foldl (λl e. e # l) []\"<br>\n  by (rule ext, fold rev_foldl_general) simp</p>\n</blockquote>\n<p>The parameters needed to be flipped, which is not perfect, but I did no longer get stack overflows from rev.</p>\n<p>The other function I noticed was map, which is of course a totally different story. It also produced stack overflows for me, so I had to replace it, yet I don't think this is a good idea in general, as map is just not tail recursive.</p>\n<blockquote>\n<p>fun rev_map where<br>\n  \"rev_map f = foldl (λl e. f e # l) []\"</p>\n<p>theorem rev_map_eq:<br>\n  \"rev_map f l = rev (map f l)\"<br>\n  by (induct l rule: rev_induct) auto</p>\n<p>declare map.simps [code del]</p>\n<p>lemma map_tail [code]:<br>\n  \"map f l = rev (rev_map f l)\"<br>\n  by (metis rev_map_eq rev_swap)</p>\n</blockquote>\n<p>Thanks again for an overall amazing and extremely powerful feature!</p>\n<p>Patrick Michel<br>\nSoftware Technology Group<br>\nUniversity of Kaiserslautern</p>",
        "id": 294218566,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896226
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nI've not reached that point (still learning Isabelle and HOL), but I'm  <br>\nalready interested in this, as I will generate SML programs from proofs.  <br>\nCan you please, provide a concrete example of an erroneous proof of a  <br>\nnon‑terminating function?</p>",
        "id": 294218583,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896235
    },
    {
        "content": "<p>From: Patrick Michel &lt;<a href=\"mailto:uni@pbmichel.de\">uni@pbmichel.de</a>&gt;<br>\nHi!</p>\n<p>Here is a small example:</p>\n<p>theory Scratch imports Main<br>\nbegin</p>\n<p>fun fib :: \"nat \\&lt;Rightarrow&gt; nat\" where<br>\n \"fib 0 = 0\"<br>\n| \"fib (Suc 0) = Suc 0\"<br>\n| \"fib (Suc (Suc n)) = fib (Suc n) + fib n\"</p>\n<p>value \"map (fib o nat) [0..10]\"</p>\n<p>theorem fib_loop [code]:<br>\n \"fib n = fib n\"<br>\n by simp</p>\n<p>export_code fib in Scala file \"Fib.scala\"</p>\n<p>end</p>\n<p>Patrick Michel</p>",
        "id": 294218593,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896241
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 31/07/2012 18:13, schrieb Patrick Michel:</p>\n<blockquote>\n<p>Hi!</p>\n<p>I am currently using the code generation facility (mostly for Scala).<br>\nAll in all it works very well so far, the generated code compiles, I have tried data type refinement, code equation replacement, etc. </p>\n<p>So thank you for this great feature!</p>\n<p>There are some minor oddities I stumbled on, however, some of which might be worth a change in the library:</p>\n<p>A) I was a bit shocked that after proving every function to be total in Isabelle and using proven code equations for refinement, I could make the generated code loop quite easily.</p>\n<p>I don't think this is discussed in the code equation chapter of the code generation tutorial.</p>\n<p>I stumbled upon it while giving some (admittedly very stupid) equation for an \"equal_class.equal\" implementation and first thought it would only be a corner case, as equality is handled in a quite special way.</p>\n<p>As it turns out it is quite easy to prove a code equation that obviously leads to non-terminating execution.</p>\n</blockquote>\n<p>Indeed: \"f x = f x\".</p>\n<p>This is not a bug but a feature. Code equations give the user a lot of power,<br>\nfor example to optimize his/her code, but also to shoot yourself in the foot. To<br>\nlook at it from the intended positive side: it allows you to generate partial<br>\nfunctions, something that some other provers cannot.</p>\n<p>Tobias</p>\n<blockquote>\n<p>I guess it is non-trivial to find out if code equations screw you over, so there is not much that can be done here...</p>\n<p>B) Code_Integer uses reference equality on BigInt in Scala. That seems to be a bad idea… I had a hard time figuring out why my code did not behave as expected and it turned out that some zeros were not equal to zero (same with some ones). Replacing the equality in the generated code with \"inta.equals(int)\" fixed all my problems.</p>\n<p>I don't know how to adjust the part in Code_Integer to fix the code generator instead, so any advise there would be helpful.</p>\n<p>C) Tail recursion. I got stack overflows (with increased stack size) from many of my own functions and some of the library functions. I solved mine by data type refinement and code equations, which leaves the ones in the library.</p>\n<p>I think there was a discussion involving fold variants some time ago and which was more \"canonical\".<br>\nThe situation now seems to be that there is fold, foldl and foldr in List.thy:</p>\n<blockquote>\n<p>primrec fold :: \"('a =&gt; 'b =&gt; 'b) =&gt; 'a list =&gt; 'b =&gt; 'b\"<br>\nwhere<br>\n  fold_Nil:  \"fold f [] = id\"<br>\n| fold_Cons: \"fold f (x # xs) = fold f xs o f x\" -- {* natural argument order *}</p>\n<p>primrec foldr :: \"('a =&gt; 'b =&gt; 'b) =&gt; 'a list =&gt; 'b =&gt; 'b\"<br>\nwhere<br>\n  foldr_Nil:  \"foldr f [] = id\"<br>\n| foldr_Cons: \"foldr f (x # xs) = f x o foldr f xs\" -- {* natural argument order *}</p>\n<p>primrec foldl :: \"('b =&gt; 'a =&gt; 'b) =&gt; 'b =&gt; 'a list =&gt; 'b\"<br>\nwhere<br>\n  foldl_Nil:  \"foldl f a [] = a\"<br>\n| foldl_Cons: \"foldl f a (x # xs) = foldl f (f a x) xs\"</p>\n</blockquote>\n<p>Of these three, only foldl is tail recursive. My generated code had to tackle _extremely large_ parameters, so it was a good benchmark to test for tail recursion…</p>\n<p>Most notably the rev function on lists is not tail recursive, as its code equations are based on fold:</p>\n<blockquote>\n<p>lemma rev_conv_fold [code]:<br>\n  \"rev xs = fold Cons xs []\"<br>\n  by (simp add: fold_Cons_rev)</p>\n</blockquote>\n<p>I see no good reason for this as rev is the most basic of all tail recursive functions, so I replaced its code equations:</p>\n<blockquote>\n<p>declare rev_conv_fold [code del]</p>\n<p>lemma rev_foldl_general:<br>\n  \"rev m @ n = foldl (λl e. e # l) n m\"<br>\n  by (induct m, auto) (metis fold_Cons_rev foldr_conv_fold foldr_conv_foldl rev_rev_ident)</p>\n<p>lemma rev_foldl [code]:<br>\n  \"rev = foldl (λl e. e # l) []\"<br>\n  by (rule ext, fold rev_foldl_general) simp</p>\n</blockquote>\n<p>The parameters needed to be flipped, which is not perfect, but I did no longer get stack overflows from rev.</p>\n<p>The other function I noticed was map, which is of course a totally different story. It also produced stack overflows for me, so I had to replace it, yet I don't think this is a good idea in general, as map is just not tail recursive.</p>\n<blockquote>\n<p>fun rev_map where<br>\n  \"rev_map f = foldl (λl e. f e # l) []\"</p>\n<p>theorem rev_map_eq:<br>\n  \"rev_map f l = rev (map f l)\"<br>\n  by (induct l rule: rev_induct) auto</p>\n<p>declare map.simps [code del]</p>\n<p>lemma map_tail [code]:<br>\n  \"map f l = rev (rev_map f l)\"<br>\n  by (metis rev_map_eq rev_swap)</p>\n</blockquote>\n<p>Thanks again for an overall amazing and extremely powerful feature!</p>\n<p>Patrick Michel<br>\nSoftware Technology Group<br>\nUniversity of Kaiserslautern<br>\n</p>\n</blockquote>",
        "id": 294218639,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896247
    },
    {
        "content": "<p>From: Magnus Myreen &lt;<a href=\"mailto:mom22@cam.ac.uk\">mom22@cam.ac.uk</a>&gt;</p>\n<blockquote>\n<p>2) The only guarantee code-generation gives (and that is quite a strong one)<br>\nis that the generated code is a sound rewriting engine for the function<br>\ndefined in the logic (assuming that every tool in the typical chain -- e.g.,<br>\ncompiler, OS -- is correct).</p>\n</blockquote>\n<p>I think you should add to that list of assumptions that the soundness<br>\nof the Isabelle code generator must also be assumed. To my knowledge<br>\n(correct me if I'm wrong!), Isabelle's code generator comes with no<br>\nformal guarantee of producing code that is correct w.r.t. the<br>\nsemantics of the generated code. By formal guarantee, I mean a theorem<br>\nin Isabelle/HOL's logic relating the given input (equations in<br>\nIsabelle/HOL) to the semantics of the generated code (ML, Haskell,<br>\nScala ...).</p>\n<p>Scott Owens and I have developed a code generator (for HOL4) which<br>\nprovides such guarantees, see:</p>\n<p>Magnus O. Myreen and Scott Owens.<br>\n  Proof-Producing Synthesis of ML from Higher-Order Logic.<br>\n  To appear in ICFP'12.<br>\n<a href=\"http://www.cl.cam.ac.uk/~mom22/miniml/hol2miniml.pdf\">http://www.cl.cam.ac.uk/~mom22/miniml/hol2miniml.pdf</a></p>\n<p>Our code generator takes normal HOL functions as input, translates<br>\nthese into ML and proves that the generated ML code <em>terminates</em> and<br>\ncorrectly implements the given input functions according to an<br>\noperational semantics of our ML language (called MiniML, which is a<br>\npure subset of ML and Haskell).</p>\n<p>Example:</p>\n<p>As an example, if we were to translate HOL4's library function for<br>\nFOLDL:</p>\n<p>|- (forall f e. FOLDL f e [] = e) /\\<br>\n    (forall f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l)</p>\n<p>The tool generates some MiniML code (shown here in SML syntax):</p>\n<p>datatype ('a) list =<br>\n      Cons of 'a * ('a) list<br>\n    | Nil ;</p>\n<p>fun FOLDL v3 =<br>\n    (fn v4 =&gt;<br>\n      (fn v5 =&gt;<br>\n        (case v5 of<br>\n            Nil =&gt; v4<br>\n          | (Cons (v2, v1)) =&gt; (((FOLDL v3) ((v3 v4) v2)) v1)))) ;</p>\n<p>and our code generator automatically proves that this code correctly<br>\nimplements the HOL function FOLDL according to an operational<br>\nsemantics of MiniML (Eval below).  Here code_for_FOLDL_in asserts that<br>\nthe above code is in the environment env, and --&gt; is an infix<br>\n\"refinement invariant combinator\" explained in the paper.</p>\n<p>|- code_for_FOLDL_in env ==&gt;<br>\n    Eval env (Var \"FOLDL\")<br>\n      (((b --&gt; a --&gt; b) --&gt; b --&gt; LIST a --&gt; b) FOLDL)</p>\n<p>We call such theorems 'certificate theorems'.</p>\n<p>End of Example.</p>\n<p>I should also mention that we (Ramana Kumar, Scott Owens and I) are<br>\nconstructing a verified MiniML implementation (including dynamic<br>\ncompilation to x86), so that the trust story can be extended all the<br>\nway down to concrete x86/ARM machine code.</p>\n<blockquote>\n<p>See also \"Code Generation via Higher-Order Rewrite Systems\" by Haftmann and<br>\nNipkow, where they state:</p>\n</blockquote>\n<p>Interesting. I wasn't aware of this paper. It seems that this paper<br>\nhas proved that an internal phase (dictionary translation) does the<br>\nright thing w.r.t. a model of HRSs.</p>\n<blockquote>\n<p>[...] partial correctness of the generated programs w.r.t. the<br>\n  original equational theorems is guaranteed.</p>\n</blockquote>\n<p>Note that your \"[...]\" omission hides the big assumption: \"If the code<br>\ngenerator preserves [the semantics of] the equations from the logic<br>\nwhen turning them into programs\"</p>\n<blockquote>\n<p>No claims are stated for aspects which have no explicit<br>\n  representation in the logic, in particular termination or<br>\n  runtime complexity.</p>\n</blockquote>\n<p>Our code generator proves termination. It does this by using the<br>\ninduction theorems that arise from function definition (and their<br>\ntotality proofs).</p>\n<p>By the way, the last part of the following sentence from Haftmann and<br>\nNipkow's FLOPS'10 paper is a brave statement with no justification:</p>\n<p>\"The transformation of an intermediate program to a program in a<br>\n   full-blown SML or Haskell-like target language is again a mere<br>\n   syntactic adjustment and does not change the equational semantics.\"</p>\n<p>Cheers,<br>\nMagnus</p>\n<p>On 1 August 2012 03:12, Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt; wrote:</p>\n<blockquote>\n<p>On 08/01/2012 01:38 AM, Yannick Duchêne (Hibou57) wrote:</p>\n<blockquote>\n<p>Le Tue, 31 Jul 2012 18:13:12 +0200, Patrick Michel &lt;<a href=\"mailto:uni@pbmichel.de\">uni@pbmichel.de</a>&gt; a<br>\nécrit:</p>\n<blockquote>\n<p>As it turns out it is quite easy to prove a code equation that<br>\nobviously leads to non-terminating execution.</p>\n</blockquote>\n<p>I've not reached that point (still learning Isabelle and HOL), but I'm<br>\nalready interested in this, as I will generate SML programs from proofs.<br>\nCan you please, provide a concrete example of an erroneous proof of a<br>\nnon-terminating function?</p>\n</blockquote>\n<p>Just to clarify. There is nothing \"erroneous\" going on here. There are just<br>\ntwo different perspectives:</p>\n<p>1) In HOL only functions that are provably total are accepted (but being<br>\ntotal does not mean that the same function when executed as a functional<br>\nprogram is terminating, since in HOL there is nothing like an evaluation<br>\nstrategy). Consider, e.g.,</p>\n<p>definition ite where<br>\n    \"ite b x y == if b then x else y\"</p>\n<p>lemmas ite_cong [fundef_cong] =  if_cong [folded ite_def]</p>\n<p>fun f :: \"nat =&gt; nat\" where<br>\n    \"f x = ite (x = 0) 1 (f (x - 1) * x)\"</p>\n<p>The call relation of f is well-founded (since in every recursive call the<br>\nargument is decreased by one). However when exporting code in any language<br>\nwith strict evaluation, the result will loop on any input.</p>\n<p>2) The only guarantee code-generation gives (and that is quite a strong one)<br>\nis that the generated code is a sound rewriting engine for the function<br>\ndefined in the logic (assuming that every tool in the typical chain -- e.g.,<br>\ncompiler, OS -- is correct). Being a sound rewriting engine means that every<br>\nequation that can be derived by evaluation in the programming language is<br>\nalso an equation of HOL.</p>\n<p>See also \"Code Generation via Higher-Order Rewrite Systems\" by Haftmann and<br>\nNipkow, where they state:</p>\n<p>[...] partial correctness of the generated programs w.r.t. the<br>\n  original equational theorems is guaranteed.<br>\n  No claims are stated for aspects which have no explicit<br>\n  representation in the logic, in particular termination or<br>\n  runtime complexity.</p>\n<p>cheers</p>\n<p>chris<br>\n</p>\n</blockquote>",
        "id": 294219982,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896947
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nJust to clarify. There is nothing \"erroneous\" going on here. There are <br>\njust two different perspectives:</p>\n<p>1) In HOL only functions that are provably total are accepted (but being <br>\ntotal does not mean that the same function when executed as a functional <br>\nprogram is terminating, since in HOL there is nothing like an evaluation <br>\nstrategy). Consider, e.g.,</p>\n<p>definition ite where<br>\n     \"ite b x y == if b then x else y\"</p>\n<p>lemmas ite_cong [fundef_cong] =  if_cong [folded ite_def]</p>\n<p>fun f :: \"nat =&gt; nat\" where<br>\n     \"f x = ite (x = 0) 1 (f (x - 1) * x)\"</p>\n<p>The call relation of f is well-founded (since in every recursive call <br>\nthe argument is decreased by one). However when exporting code in any <br>\nlanguage with strict evaluation, the result will loop on any input.</p>\n<p>2) The only guarantee code-generation gives (and that is quite a strong <br>\none) is that the generated code is a sound rewriting engine for the <br>\nfunction defined in the logic (assuming that every tool in the typical <br>\nchain -- e.g., compiler, OS -- is correct). Being a sound rewriting <br>\nengine means that every equation that can be derived by evaluation in <br>\nthe programming language is also an equation of HOL.</p>\n<p>See also \"Code Generation via Higher-Order Rewrite Systems\" by Haftmann <br>\nand Nipkow, where they state:</p>\n<p>[...] partial correctness of the generated programs w.r.t. the<br>\n   original equational theorems is guaranteed.<br>\n   No claims are stated for aspects which have no explicit<br>\n   representation in the logic, in particular termination or<br>\n   runtime complexity.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294220866,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897419
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Magnus,</p>\n<blockquote>\n<p>By the way, the last part of the following sentence from Haftmann and<br>\nNipkow's FLOPS'10 paper is a brave statement with no justification:</p>\n<p>\"The transformation of an intermediate program to a program in a<br>\n   full-blown SML or Haskell-like target language is again a mere<br>\n   syntactic adjustment and does not change the equational semantics.\"</p>\n</blockquote>\n<p>here you are comparing apples with bananas.  We do not claim anything<br>\nbeyond preservation of equational semantics, and argue that our abstract<br>\nintermediate language is appropriately close to ML or Haskell such that<br>\nthe final transition »only« involves turning abstract into concrete<br>\nsyntax, but no transformations introducing new equations etc.  This,<br>\nnaturally, is technically involved, but if I have a look at your<br>\nreference, it also admits that a formal treatment of this is beyond scope:</p>\n<blockquote>\n<p>We have not attempted to solve the problem of verified<br>\nparsing or pretty printing.</p>\n</blockquote>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/VkdB_sLU0mkAglLDvXpCGQd8/signature.asc\">signature.asc</a></p>",
        "id": 294221500,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897734
    },
    {
        "content": "<p>From: Magnus Myreen &lt;<a href=\"mailto:mom22@cam.ac.uk\">mom22@cam.ac.uk</a>&gt;<br>\nHi Florian,</p>\n<p>Admittedly our pretty printing from abstract syntax to concrete SML<br>\nsyntax is ad hoc at the moment. However, we do perform this<br>\ntranslation inside the logic, i.e. by inferences inside the logic, and<br>\nhope to prove it correct w.r.t. an SML parser function. You can find<br>\nthe definition of the \"dec_to_sml_string\" function in the following<br>\nLem file</p>\n<p><a href=\"https://github.com/mn200/HOL/blob/master/examples/miniML/semantics/print_ast.lem\">https://github.com/mn200/HOL/blob/master/examples/miniML/semantics/print_ast.lem</a></p>\n<p>which is used to generate the HOL4 definition. For evaluation inside<br>\nthe logic, we use HOL4's standard EVAL conversion, which is not super<br>\nfast but fast enough.</p>\n<p>My original comment was not so much to do with parsing and printing,<br>\nbut more with the fact that you claim with no justification that the<br>\nsemantics of \"full-blown SML\" matches the equational semantics of your<br>\nHRSs.</p>\n<p>This is not to say that our work solves that problem completely<br>\neither! We worry that our MiniML semantics doesn't perfectly match<br>\n\"full-blown SML\". That is partly our motivation for implementing a<br>\nverified runtime for MiniML, so that we can extend this guarantee down<br>\nto the machine code (where e.g. concrete syntax is trivial).</p>\n<p>Cheers,<br>\nMagnus</p>",
        "id": 294221517,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897744
    }
]