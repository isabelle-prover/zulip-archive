[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Brian,</p>\n<p>Thank you for your answer. Almost for sure I would have an inconsistency <br>\nsimilar<br>\nto what you showed if I would use the axiomatic approach. I have used <br>\nthe locale<br>\nto introduce the extra types. Moreover, my definition depends also on a <br>\nconstant<br>\n(pair) and I fixed that in the locale too.</p>\n<p>This solution is satisfactory, but reading your example, I realized that <br>\nwhat I would<br>\nneed is an existential quantification on the extra type:</p>\n<p>axioms f_def2: \"f (a::'a) = (EX 'b::type . (EX (g::'b =&gt; 'a). inj g))\"</p>\n<p>Like this there is no danger of inconsistencies. Is there something in <br>\nIsabelle which<br>\nwould allow something similar to this?</p>\n<p>Viorel</p>",
        "id": 294102349,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834184
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nViorel,</p>\n<p>I am bit confused by:</p>\n<p>(pair a b) = (b a)</p>\n<p>-- b does not have a function type.</p>\n<p>If you want 'a and 'b to be fixed-but-arbitrary, define another locale, e.g.:</p>\n<p>locale AB =<br>\n fixes a :: \"'a :: order\"<br>\n fixes b :: \"'b :: order\"</p>\n<p>and use sublocale to interpret the locales containing the lemmas of interest. There was a recent thread with subject \"Locale Import\" initiated by Andreas Lochbihler that clearly presents the approach. Intuitively you need to define every context (set of assumptions) you want the lemmas to work in as a locale.</p>\n<p>Note that you have to ensure that the order on 'a * 'b is the lexicographic one by examining the class instances -- you only get to define one instance per type.</p>\n<p>Hope this helps.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294102404,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834198
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello,</p>\n<p>I am trying to define a constant which depends on an extra type<br>\nvariable. A simplified version of the definition looks like:</p>\n<p>definition<br>\n  \"f a = (?g . !u . g u = a)\";</p>\n<p>I have found an answer to a similar question in the Isabelle archive<br>\nwhich suggests having a dummy parameter for f which gives the<br>\nmissing type:</p>\n<p>definition<br>\n  f :: \"'a =&gt; ('b itself) =&gt; bool\" where<br>\n  \"f a x = (?g . !u . g (u::'b) = a)\";</p>\n<p>However like this I have to use x as parameter for f everywhere.<br>\nMoreover, I am defining Hoare triples for some kind of programs,<br>\nand I want to use the syntax \"|- _ {| _ |} _\", but with this approach<br>\nI need a place for the extra dummy parameter also.</p>\n<p>The fact is that the type 'b must be a type variable. I cannot <br>\ninstantiate it<br>\nat this point.</p>\n<p>Another approach which seem to work is by defining an uninterpreted<br>\nconstant, and give its concrete definition using an axiom:</p>\n<p>consts<br>\n  f :: \"'a =&gt; bool\";</p>\n<p>axioms f_def:<br>\n  \"f a = (? g . !u . g u = a)\";</p>\n<p>Is the axiomatic solution unsound?</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294104379,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834761
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Fri, Mar 26, 2010 at 5:49 AM, Viorel Preoteasa<br>\n&lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I am trying to define a constant which depends on an extra type<br>\nvariable.<br>\n...<br>\nAnother approach which seem to work is by defining an uninterpreted<br>\nconstant, and give its concrete definition using an axiom:</p>\n<p>consts<br>\n f :: \"'a =&gt; bool\";</p>\n<p>axioms f_def:<br>\n \"f a = (? g . !u . g u = a)\";</p>\n<p>Is the axiomatic solution unsound?</p>\n</blockquote>\n<p>In this particular case, axiom f_def is sound. But this style of axiom<br>\nwill be unsound in all but the most trivial of instances.</p>\n<p>For clarity, here's a type-annotated version of your axiom:</p>\n<p>axioms f_def: \"f (a::'a) = (EX (g::'b =&gt; 'a) . ALL (u::'a). g u = a)\"</p>\n<p>When you write an axiom with a free type variable (or a free term<br>\nvariable, for that matter) it like declaring an infinite collection of<br>\naxioms all at once, one for each possible instantiation of the free<br>\nvariables.</p>\n<p>Your axiom f_def happens to be sound, but only because the RHS is<br>\nalways true no matter what 'b is. (Constant functions exist for every<br>\ntype 'b.) So you might as well have written</p>\n<p>axioms f_def: \"f (a::'a) = True\"</p>\n<p>But I'd guess that your real example is not so trivial. Here's a<br>\nvariation where the value of the RHS actually does depend on which<br>\ntype 'b is instantiated to, since injective functions exist between<br>\nsome pairs of types, but not all.</p>\n<p>axioms f_def2: \"f (a::'a) = (EX (g::'b =&gt; 'a). inj g)\"</p>\n<p>Let's look at two different type instances of axiom f_def2:</p>\n<p>\"f (a::bool) = (EX (g::bool =&gt; bool). inj g)\"<br>\n\"f (a::bool) = (EX (g::nat =&gt; bool). inj g)\"</p>\n<p>The first one is equivalent to \"f (a::bool) = True\", and the second is<br>\nequivalent to \"f (a:bool) = False\". This is clearly unsound. The<br>\ngeneral lesson here is that declaring axioms is dangerous, and you<br>\nshould avoid doing so whenever possible.</p>\n<p>If you really want to avoid explicitly passing around an extra dummy<br>\nparameter, here's what I would recommend: Declare a locale that fixes<br>\nthe dummy type parameter of type \"'b itself\", and define your<br>\nconstants (which may refer to the locally-fixed type 'b) inside the<br>\nlocale.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294104493,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834797
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nViorel,</p>\n<p>Can I suggest you look into locales?</p>\n<p>locale L =<br>\n  fixes unused_x :: \"'b\"<br>\nbegin</p>\n<p>definition<br>\n  \"f a = (?g. !u. g (u::'b) = a)\"</p>\n<p>end</p>\n<p>(untested, but I can expand on this if you think it might be a profitable approach.)</p>\n<p>You can later instantiate 'b with a sublocale or interpretation command.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294104581,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834810
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Peter,</p>\n<p>Thank you for our answer. I could get the definitions using locales. <br>\nHowever my<br>\ncase is more involved compared to the dummy example I presented in my<br>\nearlier message. The locale depends actually on three type parameters:</p>\n<p>locale HoareRule =<br>\n   fixes pair:: \"'a =&gt; 'b =&gt; ('c::order)\"<br>\n   begin</p>\n<p>definition<br>\n   \"SUP_L_P X u i = SUPR {v . pair v i &lt; u} (%v . X v i)\";</p>\n<p>definition<br>\n   Hoare_dgr :: \"('b =&gt; ('u::complete_lattice)) =&gt; ('b × 'b =&gt; 'u =&gt; 'u) <br>\n=&gt; ('b =&gt; 'u) =&gt; bool\"  ( \"|- (_){| _ |}(_) \"  [900,0,900] 900) where<br>\n   \"|- P {| D |} Q = (? X . (! w i j .  X w i &lt;= D(i, j) (SUP_L_P X <br>\n(pair w i) j)) /\\ P = SUP X /\\ Q = (SUP X))\"</p>\n<p>I have succeeded to develop this general theory, but I have problem <br>\ninstantiating it<br>\nfor concrete types. I need it instantiated for 'c = 'a * 'b where 'a and <br>\n'b are orders<br>\nand the order on 'c is the lexicographic order. (pair a b) = (b a). I <br>\nhave built the<br>\nlexicographic order on pairs, but I don't know how to instantiate this <br>\nlocale.<br>\nAll examples I found with locales had only one type parameter.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294104672,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834841
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Viorel,</p>\n<p>syntax is a delicate issue.  Can you provide me with the whole example<br>\ncontaining the interpretation?  Then perhaps I can explain why things<br>\nbehave as they do.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/rLm6XvZQt2hqKX7VfUI9URVD/signature.asc\">signature.asc</a></p>",
        "id": 294105283,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835007
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHi Florian,</p>\n<p>I have a a theory which is developed in few files. However I have <br>\ncreated a smaller example which<br>\ncontains many of the Isabelle features I am using. I have listed the <br>\nfile at the end of the email.</p>\n<p>There I have a definition for correctness of a collection of mutually <br>\nrecursive procedures. This<br>\ndefinition has associated the notation |- P {| F |} Q where P, Q are <br>\nfamilies of predicates (one<br>\nfor each procedure) and F defines the mutually recursive procedures. <br>\nThis rule is defined<br>\nin the context of a locale which fixes 'b the indexes of procedures, and <br>\n'a an arbitrary type.<br>\npair applied to an index and an element from 'a ranges over a well <br>\nfounded set, and this set<br>\nis used for termination.</p>\n<p>I have a correctness theorem which states that the rule is correct with <br>\nrespect to the least<br>\nfixpoint semantics.</p>\n<p>Next I instantiate the locale for a single procedure, and I prove the <br>\nrule for a single<br>\nrecursive procedure using the rule for mutually recursive procedures.</p>\n<p>However, I cannot use the notation (|- _ {| _ |} _ ) in the locale instance.</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<p>=================================================================</p>\n<p>header {*  Hoare Rule for Mutually Recursive Procedures *}</p>\n<p>theory RecursiveProcedures</p>\n<p>imports Inductive Datatype</p>\n<p>begin</p>\n<p>definition<br>\n   \"Hoare (p::'a::complete_lattice) S q = (p \\&lt;le&gt; S q)\";</p>\n<p>locale RecursiveProcedures =<br>\n   fixes pair::\"'a =&gt; 'b=&gt; ('c::wellorder)\"<br>\n   begin</p>\n<p>definition<br>\n     \"sup_less P (u::'c) i = SUPR {v . (pair v i) &lt; u} (% v . P v i)\";</p>\n<p>definition<br>\n     HoareProc:: \"('b =&gt; ('d::complete_lattice)) =&gt; (('b =&gt; ('e =&gt; 'd)) <br>\n=&gt; ('b =&gt; ('e =&gt; 'd))) =&gt; ('b =&gt; 'e) =&gt; bool\"<br>\n    (\"|- (_){| _ |}(_) \" [0,0,900] 900) where<br>\n    \"|- P {| F |} Q =<br>\n       (EX X . P \\&lt;le&gt; SUPR UNIV X &amp; (ALL S v i. (ALL j . Hoare <br>\n(sup_less X (pair v i) j) (S j) (Q j)) --&gt; Hoare (X v i) (F S i) (Q i)))\";</p>\n<p>theorem correctness:<br>\n    \"mono F ==&gt; |- P {| F |} Q ==&gt; Hoare (P i) ((lfp F) i) (Q i)\";<br>\n   sorry;<br>\nend;</p>\n<p>datatype Single = single;</p>\n<p>interpretation RecursiveProcedures \"% (n::nat) (a :: Single) . n\";<br>\ndone;</p>\n<p>definition<br>\n   \"HoareSingleProc P F Q = (EX X . P &lt;= SUPR UNIV X &amp; (ALL S (n::nat) . <br>\nHoare (SUPR {k . k &lt; n} X) S Q --&gt; Hoare (X n) (F S) Q))\";</p>\n<p>theorem [simp]:<br>\n     \"lfp (% S a . F (S a)) = (% a . lfp F)\";<br>\n     sorry</p>\n<p>theorem [simp]:<br>\n     \"mono F ==&gt; mono (% S a . F (S a))\";<br>\n     by (simp add: mono_def le_fun_def);</p>\n<p>theorem correctnesssingle:<br>\n   \"mono F \\&lt;Longrightarrow&gt; HoareSingleProc P F Q ==&gt; Hoare P (lfp F) Q\";</p>\n<p>(<em>apply (case_tac \"|- (% a . P) {| (% S a . F (S a)) |} (% a . Q)\");</em>)</p>\n<p>apply (case_tac \"HoareProc (% a . P) (% S a . F (S a)) (% a . Q)\");<br>\n     apply (case_tac \"mono (% S a . F (S a))\");<br>\n     apply (drule_tac P=\"% (a::Single) . P\" and F=\"(% S a . F (S a))\" <br>\nand Q = \"% (a::Single) . Q\" in correctness);<br>\n     apply auto;<br>\n     apply (erule notE);<br>\n     apply (simp_all add: HoareProc_def HoareSingleProc_def);<br>\n     apply auto;<br>\n     apply (rule_tac x = \"% n a . X n\" in exI);<br>\n     apply (simp add: sup_less_def le_fun_def SUPR_def Sup_fun_def);<br>\n     apply (case_tac \"range X = {y\\&lt;Colon&gt;'b. EX f\\&lt;Colon&gt;nat. y = X f}\");<br>\n     by auto;<br>\nend;</p>",
        "id": 294105634,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835110
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Viorel,</p>\n<blockquote>\n<p>theory RecursiveProcedures<br>\nimports Inductive Datatype</p>\n</blockquote>\n<p>remark: it is not recommend to import theories beneath Main for<br>\napplications.  Just stick with Main.</p>\n<blockquote>\n<p>begin</p>\n</blockquote>\n<blockquote>\n<p>locale RecursiveProcedures =<br>\n  fixes pair::\"'a =&gt; 'b=&gt; ('c::wellorder)\"<br>\n  begin</p>\n<p>definition<br>\n    HoareProc:: \"('b =&gt; ('d::complete_lattice)) =&gt; (('b =&gt; ('e =&gt; 'd))<br>\n=&gt; ('b =&gt; ('e =&gt; 'd))) =&gt; ('b =&gt; 'e) =&gt; bool\"<br>\n   (\"|- (_){| _ |}(_) \" [0,0,900] 900) where<br>\n   \"|- P {| F |} Q =<br>\n      (EX X . P \\&lt;le&gt; SUPR UNIV X &amp; (ALL S v i. (ALL j . Hoare (sup_less<br>\nX (pair v i) j) (S j) (Q j)) --&gt; Hoare (X v i) (F S i) (Q i)))\";</p>\n<p>end;</p>\n<p>datatype Single = single;</p>\n<p>interpretation RecursiveProcedures \"% (n::nat) (a :: Single) . n\";<br>\ndone;</p>\n</blockquote>\n<p>Contrary to classes, definitions relative to locales are not considered<br>\nspecially for interpretation.  Only an <em>input</em> abbreviation is<br>\ngenerated.  To restore the syntax, isse something like</p>\n<p>abbreviation HoareProc2 (\"|- (_){| _ |}(_) \" [0,0,900] 900) where<br>\n\"HoareProc2 ≡ RecursiveProcedures.HoareProc (% (n::nat) (a :: Single) . n)\"</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/tiDu2LHUrUUpzneWmwtYX2xD/signature.asc\">signature.asc</a></p>",
        "id": 294105695,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835135
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Peter,</p>\n<p>Thank you again for your answer. I have finally figured out how to interpret<br>\nthe locale. What I needed was every easy:</p>\n<p>locale HoareRule =<br>\n  fixes pair::\"'a =&gt; 'b =&gt; ('c::well_founded_transitive)\"<br>\n  begin<br>\n  ...<br>\n  end</p>\n<p>interpretation HoareRule \"% (a::'a::well_founded_transitive) <br>\n(b::('b::well_founded_transitive)) . (b, a)\";<br>\ndone;</p>\n<p>The tutorial on locales is a bit misleading. There an arbitrary order is <br>\ninterpreted as order<br>\non integers, and the name int is used for this interpretation. I thought <br>\nof this name as being<br>\nthe instantiation of the locale for the int type, when actually this was <br>\njust a name for the interpretation.<br>\nThe fact that the type name is used when interpreting a class has <br>\ncontributed to this confusion.<br>\nBecause of this misinterpretation I could not figure out how to give <br>\ninterpretation to something<br>\nwhich depends on more than one type.</p>\n<p>There is still something which does not work as expected. The syntax <br>\ndefined in the<br>\nlocale cannot be used in the interpretation. Moreover, when I use facts <br>\nfrom the locale in the<br>\ninterpretation they are parametrized by the instance for the function <br>\npair. On the other<br>\nhand when using classes things work more as I would expect them to work.</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<p>Peter Gammie wrote:</p>",
        "id": 294106100,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835257
    }
]