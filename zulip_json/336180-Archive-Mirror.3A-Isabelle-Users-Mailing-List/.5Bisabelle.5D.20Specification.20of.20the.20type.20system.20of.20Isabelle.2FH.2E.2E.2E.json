[
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-July/msg00070.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-July/msg00070.html</a></p>\n<p>Thank you for bringing this to my attention. Let me first comment on the <br>\nmanuals before getting back to the type system.</p>\n<p>It would be desirable to have such information - on the nature of the <br>\n\"datatype\" declarations - as well as on the low-level routines for type <br>\ninference and type introduction available in the manuals. Also, in order to <br>\navoid misunderstanding, it should be pointed out that \"BNF\" is an abbreviation <br>\nof \"Bounded natural functor\" and not \"Backus-Naur form\".</p>\n<p>For any type theory, including Isabelle/HOL, the type system is essential. <br>\nHence, one would wish for a concise specification of the logical core, i.e., <br>\nboth the type system and the rules of inference. For example, Andrews' system <br>\nQ0 - the type system, symbols, wffs, axioms, and the single rule of inference - <br>\nis fully specified in a very precise manner on only a few pages [cf. Andrews, <br>\n2002, pp. 210-215].</p>\n<p>Moreover, one would wish for a tutorial on how to inspect both the types <br>\nintroduced by the datatype declarations as well as the type of any well-formed <br>\nformula, such that the user can look behind the surface and examine the <br>\n(actual) type system. In my R0 implementation, it is possible to display the <br>\nfully typed expression of any wff (including that of any primitive or derived <br>\ntype), e.g., the logical AND (&amp;), with a simple print command, which yields the <br>\ntype (e.g., o -&gt; o -&gt; o [written as \"{{o,o},o}\", lambda is denoted by '\\', and <br>\nlambda application is denoted by '_']):<br>\n\":print &amp;</p>\n<h1>wff      47 :  [\\x.[\\y.((=_[\\g.((g_T)_T)])_[\\g.((g_x)_y)])]]</h1>\n<h1>:=  &amp;</h1>\n<h1>w typd   47 :  [\\x{o}{o}.[\\y{o}{o}.((={{{o,@},@}}_[\\g{{{o,o},o}}{{{o,o},o}}.((</h1>\n<p>g{{{o,o},o}}{{{o,o},o}}_T{o}){{o,o}}_T{o}){o}]{@}){{o,@}}_[\\g{{{o,o},o}}{{{o,o},<br>\no}}.((g{{{o,o},o}}{{{o,o},o}}_x{o}{o}){{o,o}}_y{o}{o}){o}]{@}){o}]{{o,o}}]</p>\n<h1>{ {{o,o},o} }</h1>\n<h1>:=  &amp;</h1>\n<p>type     #   0:  {{o,o},o}                                   =  35\"<br>\nFor a formatted PDF version, see<br>\n<a href=\"http://www.kenkubota.de/files/R0_draft_excerpt_with_definitions_and_groups.pdf\">http://www.kenkubota.de/files/R0_draft_excerpt_with_definitions_and_groups.pdf</a> (p. 356)</p>\n<p>Concerning the type system, the most informative explanation I could find in <br>\nthe documentation was at the very beginning of Part III (Isabelle/HOL) of The <br>\nIsabelle/Isar Reference Manual (February 17, 2016):<br>\n\"Andrews'[ ] book [1] is a full description of the original Church-style <br>\nhigher-order logic, with proofs of correctness and completeness wrt. certain <br>\nset-theoretic interpretations. The particular extensions of Gordon-style HOL <br>\nare explained semantically in two chapters of the 1993 HOL book [50].\"<br>\n<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf</a> (p. 236)</p>\n<p>Again, a brief description of the type system in the online documentation, <br>\ninstead of only literature references, would be desirable.<br>\nPlease allow me a minor correction here. In both the first edition [Andrews, <br>\n1986] referenced by the manual as well as the current second edition [Andrews, <br>\n2002] Andrews does not only provide a \"full description of the original <br>\nChurch-style higher-order logic\", but, more exactly, a description of his own <br>\nsystem Q0, which is roughly equivalent, but much more elegant. For example, in <br>\nChurch's simple type theory, Modus Ponens is a primitive rule (the fifth of <br>\naltogether six rules) [cf. Church, 1940, p. 60; Andrews, 2014, available online <br>\nat<br>\n<a href=\"http://plato.stanford.edu/archives/spr2014/entries/type-theory-church/#AxiRulInf\">http://plato.stanford.edu/archives/spr2014/entries/type-theory-church/#AxiRulInf</a><br>\n], whereas in Andrews' Q0, Modus Ponens is a derived rule [cf. Andrews, 2002, <br>\np. 224 (5224)] obtained from the single rule of inference of Q0. The type <br>\nsystem is identical, allowing only 'i' (iota) and 'o' (omicron), and <br>\ncombinations of them (i.e., simple type theory, having no type variables).<br>\nIn the dependent type theory R0, not only type variables, but also an <br>\nadditional type inference mechanism is implemented, which seems to resemble <br>\n\"Gordon['s] [...] facility to introduce new types as semantic subtypes from <br>\nexisting types\"<br>\n<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf</a> (p. 261)<br>\n: \"Whenever a sentence of the form p_(oα)c_(α) is inferred [...], type p is <br>\nadded to c, such that c_p becomes a well-formed formula.\" [Kubota, 2015, p. 32] <br>\nIf it isn't already, p becomes (also) a type, by additionally assigning the <br>\ntype of types (tau) to it.</p>\n<p>The abstract of the article by Traytel et al. you referred to via the DOI link<br>\n<a href=\"http://dx.doi.org/10.1109/LICS.2012.75\">http://dx.doi.org/10.1109/LICS.2012.75</a><br>\nstarts as follows: \"Interactive theorem provers based on higher-order logic <br>\n(HOL) traditionally follow the definitional approach, reducing high-level <br>\nspecifications to logical primitives.\" This elegant formulation on the <br>\n\"definitional approach\" coincides with what Andrews calls \"expressiveness\" <br>\n[Andrews, 2002, p. 205], except that the reduction (or, in turn, the <br>\nexpressiveness of the few primitive symbols and rules) does not only apply to <br>\nsymbols, but also to the rules, such that the basis of Q0 consists of only</p>\n<ul>\n<li>two primitive symbols (identity and description),</li>\n<li>\n<p>two primitive type symbols (the type of propositions 'o' and the type of <br>\nindividuals 'i'),</p>\n</li>\n<li>\n<p>and only a single rule of inference (substitution),<br>\nfrom which everything can be expressed (within the limits of simple type <br>\ntheory).<br>\nFor extending expressiveness to dependent type theory, in R0, type iota ('i') <br>\nis replaced by type omega (the universal type), and type tau (the type of <br>\ntypes) is introduced. Furthermore, it is possible to bind type variables with <br>\nlambda.</p>\n</li>\n</ul>\n<p>If one consequently follows Andrews' approach of expressiveness at all levels, <br>\nthen Hilbert-style deductive systems are preferred, since they allow the rules <br>\nto be reduced to a single rule of inference. An extra rule for induction such <br>\nas that given at<br>\n<a href=\"https://www4.in.tum.de/~wenzelm/papers/lausanne2009.pdf\">https://www4.in.tum.de/~wenzelm/papers/lausanne2009.pdf</a> (p. 5)<br>\ncan be avoided by making induction part of the definition of N [cf. Andrews, <br>\n2002, p. 260]. In the same spirit, a primitive type for natural numbers can be <br>\navoided by using a combination of 'i' and 'o' as carrier type ( nat := (o(oi)) <br>\n) [cf. ibid.].<br>\nThe pairing operation used by Andrews [cf. Andrews, 2002, p. 208] (see also the <br>\ndefinition of the logical AND (&amp;) above, wff 47) is better suited for lambda <br>\ncalculus than the one suggested at<br>\n<a href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-175.pdf\">https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-175.pdf</a> (p. 13),<br>\nand in R0, it can be used to form both a type restricted as well as a <br>\npolymorphic pairing operator (by the use of type omega).</p>\n<p>According to this approach, a proliferation of primitive types and type <br>\ninference mechanisms should be avoided, and rules should be kept as simple as <br>\npossible, e.g., as quoted above: \"Whenever a sentence of the form p_(oα)c_(α) <br>\nis inferred [...].\"<br>\nIn one of the manuals it is stated:<br>\n\"If you introduce a new type axiomatically, i.e. via typedecl and <br>\naxiomatization (§5.5), the minimum requirement is that it has a non-empty <br>\nmodel, to avoid immediate collapse of the logical environment.\"<br>\n<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf</a> (p. 115)<br>\nBut what does this mean exactly, having \"a non-empty model\"? Is this the same <br>\nas the existence of a proven theorem of the form \"p_(oα)c_(α)\", which shows <br>\nthat p is non-empty?</p>\n<p>It will take some time until I am able to read through the article by Traytel <br>\net al., but at first glance a more complex semantic reasoning seems to be <br>\nbehind it:<br>\n\"An inductive definition specifies the least predicate or set R closed under <br>\ngiven rules: applying a rule to elements of R yields a result within R. For <br>\nexample, a structural operational semantics is an inductive definition of an <br>\nevaluation relation.<br>\n[...]<br>\nBoth inductive and coinductive definitions are based on the Knaster-Tarski <br>\nfixed-point theorem for complete lattices. The collection of introduction rules <br>\ngiven by the user determines a functor on subsets of set-theoretic relations.\"<br>\n<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/isar-ref.pdf</a> (p. 238)</p>\n<p>Please allow me, where appropriate, to postpone answers, as I would like to <br>\nfocus on my forthcoming publication of R0 [Kubota, 2015].</p>\n<p>Kind regards,</p>\n<p>Ken Kubota</p>\n<p>References</p>\n<p>Andrews, Peter B. (1986), An Introduction to Mathematical Logic and Type <br>\nTheory: To Truth Through Proof. Orlando: Academic Press.</p>\n<p>Andrews, Peter B. (2002), An Introduction to Mathematical Logic and Type <br>\nTheory: To Truth Through Proof. Second edition. Dordrecht / Boston / London: <br>\nKluwer Academic Publishers. ISBN 1-4020-0763-9. DOI: 10.1007/978-94-015-9934-4.</p>\n<p>Andrews, Peter B. (2014), \"Church's Type Theory\". In: Stanford Encyclopedia of <br>\nPhilosophy (Spring 2014 Edition). Ed. by Edward N. Zalta. Available online at <br>\n<a href=\"http://plato.stanford.edu/archives/spr2014/entries/type-theory-church/\">http://plato.stanford.edu/archives/spr2014/entries/type-theory-church/</a> (July 2, <br>\n2016).</p>\n<p>Church, Alonzo (1940), \"A Formulation of the Simple Theory of Types\". In: <br>\nJournal of Symbolic Logic 5, pp. 56-68.</p>\n<p>Kubota, Ken (2015), On the Theory of Mathematical Forms (draft from May 18, <br>\n2015). Unpublished manuscript. SHA-512: a0dfe205eb1a2cb29efaa579d68fa2e5 <br>\n45af74d8cd6c270cf4c95ed1ba6f7944 fdcffaef2e761c8215945a9dcd535a50 <br>\n011d8303fd59f2c8a4e6f64125867dc4. DOI: 10.4444/100.10. See: <br>\n<a href=\"http://dx.doi.org/10.4444/100.10\">http://dx.doi.org/10.4444/100.10</a></p>\n<p>Kubota, Ken (2015a), Excerpt from [Kubota, 2015] (pp. 356-364, pp. 411-420, and <br>\npp. 754-755). Available online at <br>\n<a href=\"http://www.kenkubota.de/files/R0_draft_excerpt_with_definitions_and_groups.pdf\">http://www.kenkubota.de/files/R0_draft_excerpt_with_definitions_and_groups.pdf</a> <br>\n(January 24, 2016). SHA-512: 67a48ee12a61583bd82c286136459c0c <br>\n9fd77f5fd7bd820e8b6fe6384d977eda 4d92705dac5b3f97e7981d7b709fc783 <br>\n3d1047d1831bc357eb57b263b44c885b.</p>\n<hr>\n<p>Ken Kubota<br>\ndoi: 10.4444/100<br>\n<a href=\"http://dx.doi.org/10.4444/100\">http://dx.doi.org/10.4444/100</a></p>",
        "id": 294678038,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175659
    }
]