[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi List,</p>\n<p>I have a problem with Specification.definition: </p>\n<p>I want to implement the following functionality on ML-level:</p>\n<p>context <br>\n    fixes a::'a<br>\n  begin  </p>\n<p>(* Want to implement these 3 definitions: *)<br>\n    definition \"bar = ((a,1::nat),(a,True))\"<br>\n    definition \"foo b = (a,b)\"<br>\n    lemmas test = bar_def[folded foo_def]<br>\n    &gt;&gt;&gt; theorem test: <a href=\"http://local.bar\">local.bar</a> = (<a href=\"http://local.foo\">local.foo</a> 1, <a href=\"http://local.foo\">local.foo</a> True)</p>\n<p>My first attempt was:</p>\n<p>context <br>\n    fixes a::'a<br>\n  begin  </p>\n<p>local_setup ‹fn lthy =&gt; let<br>\n        val ((_,(_,bar'_thm)),lthy) = Specification.definition (NONE,<br>\n((Binding.empty,[]),@{prop \"bar' = ((a,1::nat),(a,True))\"})) lthy<br>\n        val ((_,(_,foo'_thm)),lthy) = Specification.definition (NONE,<br>\n((Binding.empty,[]),@{prop \"foo' b = (a,b)\"})) lthy</p>\n<p>val _ = @{make_string} [foo'_thm, bar'_thm] |&gt; tracing</p>\n<p>val test_thm = Local_Defs.fold lthy [foo'_thm] bar'_thm</p>\n<p>val (_,lthy) = Local_Theory.note ((@{binding test'},[]),<br>\n[test_thm]) lthy</p>\n<p>in<br>\n        lthy<br>\n      end<br>\n      ›<br>\n    thm test'</p>\n<p>However, the theorem does not look as expected, foo is not folded. A<br>\nquick inspection of the generated theorems (see tracing-output) quickly<br>\nreveals the reason for that:</p>\n<p>tracing output is: <br>\n  [\"foo' ?b = (a, ?b)\"  [.], \"bar' = ((a, 1), a, True)\"  [.]]</p>\n<p>where foo' and bar' are free variables (!) rather than constants, and<br>\nthe type of ?b is ?b::'b, which, obviously, does not unify with nat nor<br>\nbool.</p>\n<p>My question:<br>\n  What is the correct way to implement the above in Isabelle-ML? <br>\n  Is there a way to get a _def-theorem that contains a Const rather than<br>\na Free, and a ?b::?'b rather than ?b::'b  ?</p>\n<p>Thanks in advance for any help,<br>\n  Peter</p>",
        "id": 294677753,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175548
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Peter,</p>\n<p>that you get frees/tfrees out of Specification.definition is as<br>\nexpected. In order to obtain something with schematic variables, you<br>\nneed to look, or rather, obtain the \"foundation\" of the newly-introduced<br>\ndefinitions. This can be done with appropriate morphisms:</p>\n<p>local_setup ‹fn lthy =&gt;<br>\n    let<br>\n      val (_, lthy') = Local_Theory.open_target lthy</p>\n<p>val ((_,(_,bar'_thm)),lthy') = Specification.definition<br>\n        (NONE, ((Binding.empty,[]),<br>\n           @{prop \"bar' = ((a,1::nat),(a,True))\"})) lthy'<br>\n      val ((_,(_,foo'_thm)),lthy') = Specification.definition<br>\n        (NONE, ((Binding.empty,[]),@{prop \"foo' b = (a,b)\"})) lthy'</p>\n<p>val _ = map (Thm.pretty_thm lthy') [foo'_thm, bar'_thm]<br>\n        |&gt; Pretty.big_list \"before\" |&gt; Pretty.writeln</p>\n<p>val lthy'' = Local_Theory.close_target lthy'</p>\n<p>val phi = Proof_Context.export_morphism lthy' lthy''</p>\n<p>val foo'_thm = Morphism.thm phi foo'_thm<br>\n      val bar'_thm = Morphism.thm phi bar'_thm</p>\n<p>val _ = map (Thm.pretty_thm lthy') [foo'_thm, bar'_thm]<br>\n        |&gt; Pretty.big_list \"after\" |&gt; Pretty.writeln</p>\n<p>val test_thm = Local_Defs.fold lthy'' [foo'_thm] bar'_thm</p>\n<p>val (_, lthy'') =<br>\n        Local_Theory.note ((@{binding test'},[]), [test_thm]) lthy''<br>\n    in<br>\n      lthy''<br>\n    end›</p>\n<p>thm test'</p>\n<p>The pattern open_target/close_target is used all over BNF, presumably<br>\nwith the same intent, although I'm not quite sure whether I've<br>\nreproduced it fully canonically here.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294677765,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175554
    }
]