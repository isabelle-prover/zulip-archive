[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nYes. This may also happen to the \"tactic\" method:</p>\n<p>ML‹<br>\n    structure Method = struct<br>\n      fun set_tactic _ = I<br>\n    end<br>\n  ›</p>\n<p>lemma True<br>\n  apply (tactic ‹all_tac›)</p>\n<p>(* exception Fail raised (line 284 of \"Isar/method.ML\"):<br>\n     Undefined ML tactic *)</p>\n<p>Hygiene is often a problem in languages which support nesting and<br>\n(anti)quotation of language elements.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294643623,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163151
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear list,</p>\n<p>we've had antiquotations for a while now -- a syntactic method to embed<br>\nformal entities into ML code. I've been wondering about the opposite<br>\ndirection -- embedding (properly typed) ML values into a formal context.<br>\nWith the arrival of cartouches, this is actually possible now. The<br>\nattached theory allows one to write:</p>\n<p>term \"(λx. SPLICE ‹Bound 0›)\"</p>\n<p>... which results in a formal expression logically equivalent to</p>\n<p>term \"(λx. x)\"</p>\n<p>This also works with theorems:</p>\n<p>ML‹val mythm = @{thm conjI[where P = True]}›<br>\n  lemmas mythm = [[splice ‹mythm›]]</p>\n<p>Of course, this is not very useful by itself. But it can also be used to<br>\ncompute larger terms using ML, e.g. for lemma statements:</p>\n<p>lemma \"0 &lt; SPLICE ‹HOLogic.mk_number @{typ nat} (1+1)›\"<br>\n  oops</p>\n<p>... produces the goal \"0 &lt; 2\". There might be use cases in program<br>\nsynthesis here.</p>\n<p>A nice side effect of using cartouches is that markup works out of the<br>\nbox, i.e. all the ML entities (and embedded antiquotations) can be<br>\nCtrl-clicked.</p>\n<p>Disclaimer: Do not use this for production purposes.</p>\n<p>Comments welcome!</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/uMNKFlM8QbOkP06yEWmqHd8F/splice.ML\">splice.ML</a><br>\n<a href=\"/user_uploads/14278/Y3MCa5GpIkavayctc9vH8n1X/Splice.thy\">Splice.thy</a><br>\n<a href=\"/user_uploads/14278/dPmd28WR123ErUHuxy6selAq/Splice_Examples.thy\">Splice_Examples.thy</a></p>",
        "id": 294646836,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164445
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Lars,</p>\n<p>This looks like an interesting experiment. Do you think that something similar could be <br>\ndone for formal comments inside types and terms, i.e., to change from the term language to <br>\nthe language context \"document\", as discussed in a thread from last year?</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-September/msg00056.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2014-September/msg00056.html</a></p>\n<p>Andreas</p>",
        "id": 294646897,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164482
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nCertainly. I only discovered that terms may contain cartouches by<br>\naccident, but given that, the possibilities for embedded syntax are endless:</p>\n<p>syntax \"_doc\" :: \"cartouche_position ⇒ 'a ⇒ 'a\" (\"DOC _ (_)\")</p>\n<p>This allows you to write</p>\n<p>term \"(DOC ‹abc› 3) + 4\"</p>\n<p>Of course, a suitable parse translation is required to make some sense<br>\nof \"abc\".</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294646912,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164487
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nCartouches were indeed introduced to make arbitrary nesting of languages <br>\nsynactically easy, although the concept of sublanguages has been there in <br>\nIsabelle from early on.</p>\n<p>There are endless possibilities, but it also needs some efforts to make <br>\nconcrete applications work robustly with the endless features we have <br>\nalready accumulated.</p>\n<p>Just a few notes on this particular experiment:</p>\n<p>* There is no need to poke into global refs.  The implicit ML context<br>\n     can be used to transport values in and out of ML \"eval\" in a<br>\n     value-oriented manner.  See the implementation of the \"tactic\" proof<br>\n     method, with its Method.set_tactic slot.</p>\n<p>* Term translations operate on rather raw parse trees.  You have already<br>\n     discovered that in the examples: referring to a local \"x\" is not<br>\n     immediately clear.  It would require some mechanism to \"protect\"<br>\n     already internal terms within the parse tree, but that would have to<br>\n     cooperate properly with the other syntax phases and the term \"check\"<br>\n     phases (type inference etc.).</p>\n<p>* Morphisms, which are particularly important for attribute expressions,<br>\n     introduce another dimension of higher abstract nonsense.  One needs to<br>\n     look closely that embedded ML works with that, but not all aspects are<br>\n     properly implemented in the system and existing antiquotations.<br>\n     E.g. ML antiquotations themselves ignore morphisms.</p>\n<p>Isabelle/ML in Isabelle2015 also provides literal token syntax for formal <br>\ninput source.  Here is an example of this madness, used together with the <br>\nSPLICE inner syntax:</p>\n<p>theory Scratch<br>\nimports Main \"~/tmp/Splice\"<br>\nbegin</p>\n<p>ML ‹<br>\n   val ctxt = @{context};<br>\n   val input = ‹λx. x + y + SPLICE ‹Bound 0››;</p>\n<p>val t = Syntax.read_term ctxt (Syntax.implode_input input);<br>\n›</p>\n<p>end</p>\n<p>You see how the nested source inside the ML block gets formally annotated <br>\nby PIDE markup.</p>\n<p>Makarius</p>",
        "id": 294646929,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164500
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou can of course embed something that looks like document source within <br>\nterms, or any other Isabelle language.</p>\n<p>The remaining problem, though, is to have the document preparation system <br>\npresent it properly: that is a bit old, it only looks at the outer syntax <br>\nfor pretty printing.</p>\n<p>To get this right, a substantial reform of the Isabelle document <br>\npreparation is required, to \"print\" everything formally from the depths of <br>\narbitrary nesting.</p>\n<p>Makarius</p>",
        "id": 294646944,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164506
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Lars and Makarius,</p>\n<p>Thanks for the quick replies.</p>\n<p>The parse translation is the problem, as Makarius has pointed out. At the moment, I use <br>\ninformal comments (* abc *) inside terms - they are neither checked nor printed. If I knew <br>\nhow to formally check these comments in a parse translation, this would already be one <br>\nstep further, as I could then use document antiquotation to check terms, types and <br>\nconstants automatically. Document preparation should still work, although it would be fine <br>\nfor me in the first iteration to ignore these comments (as (* *) are at the moment). Is <br>\nsomething like this possible in the current situation?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294646958,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164512
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nFirst of all, thanks for your valuable comments.</p>\n<blockquote>\n<p>There are endless possibilities, but it also needs some efforts to make<br>\nconcrete applications work robustly with the endless features we have<br>\nalready accumulated.</p>\n</blockquote>\n<p>Indeed. That's why I posted this particular use case here in order to<br>\nget an idea of whether this is something people would like to use.</p>\n<blockquote>\n<p>* There is no need to poke into global refs.  The implicit ML context<br>\n    can be used to transport values in and out of ML \"eval\" in a<br>\n    value-oriented manner.  See the implementation of the \"tactic\" proof<br>\n    method, with its Method.set_tactic slot.</p>\n</blockquote>\n<p>While refactoring my code to use theory/context data slots, I got<br>\ncarried away and implemented a general mechanism for typed evaluation. I<br>\nuploaded it to a dedicated repository: &lt;<a href=\"http://git.io/vINfn\">http://git.io/vINfn</a>&gt;</p>\n<p>It can be used like this:</p>\n<p>typed_evaluation foo = ‹int›</p>\n<p>Typed_Evaluation.eval @{token foo} ‹3› @{context}</p>\n<p>There might be a way to get rid of the explicit registration of the<br>\n\"token\", but I haven't found one yet.</p>\n<blockquote>\n<p>* Term translations operate on rather raw parse trees.  You have already<br>\n    discovered that in the examples: referring to a local \"x\" is not<br>\n    immediately clear.  It would require some mechanism to \"protect\"<br>\n    already internal terms within the parse tree, but that would have to<br>\n    cooperate properly with the other syntax phases and the term \"check\"<br>\n    phases (type inference etc.).</p>\n</blockquote>\n<p>I haven't quite understood the mechanics yet. It appears that already<br>\nthe parsing fails, which makes me wonder whether it'd be sufficient to<br>\nleave a spliced ML expression uninterpreted until checking. This would<br>\nprobably warrant a separate check phase.</p>\n<blockquote>\n<p>* Morphisms, which are particularly important for attribute expressions,<br>\n    introduce another dimension of higher abstract nonsense.  One needs to<br>\n    look closely that embedded ML works with that, but not all aspects are<br>\n    properly implemented in the system and existing antiquotations.<br>\n    E.g. ML antiquotations themselves ignore morphisms.</p>\n</blockquote>\n<p>I don't understand at all how morphisms come into play here. Are you<br>\nsuggesting that the embedded ML should somehow have access to a<br>\nmorphism? Which morphism?</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294647153,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164583
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Lars,</p>\n<blockquote>\n<p>While refactoring my code to use theory/context data slots, I got<br>\ncarried away and implemented a general mechanism for typed evaluation. I<br>\nuploaded it to a dedicated repository: &lt;<a href=\"http://git.io/vINfn\">http://git.io/vINfn</a>&gt;</p>\n<p>It can be used like this:</p>\n<p>typed_evaluation foo = ‹int›</p>\n<p>Typed_Evaluation.eval @{token foo} ‹3› @{context}</p>\n<p>There might be a way to get rid of the explicit registration of the<br>\n\"token\", but I haven't found one yet.</p>\n</blockquote>\n<p>this looks definitely interesting.</p>\n<p>Can a malicious attacker with access to the ML name space »hijack« your<br>\nevaluation machinery, e.g. by defining it own structure<br>\nTyped_Evaluation?  This is something difficult to handle?</p>\n<p>We should discuss this on my next visit to TUM.</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<blockquote>\n<p>* Term translations operate on rather raw parse trees.  You have already<br>\n    discovered that in the examples: referring to a local \"x\" is not<br>\n    immediately clear.  It would require some mechanism to \"protect\"<br>\n    already internal terms within the parse tree, but that would have to<br>\n    cooperate properly with the other syntax phases and the term \"check\"<br>\n    phases (type inference etc.).</p>\n</blockquote>\n<p>I haven't quite understood the mechanics yet. It appears that already<br>\nthe parsing fails, which makes me wonder whether it'd be sufficient to<br>\nleave a spliced ML expression uninterpreted until checking. This would<br>\nprobably warrant a separate check phase.</p>\n<blockquote>\n<p>* Morphisms, which are particularly important for attribute expressions,<br>\n    introduce another dimension of higher abstract nonsense.  One needs to<br>\n    look closely that embedded ML works with that, but not all aspects are<br>\n    properly implemented in the system and existing antiquotations.<br>\n    E.g. ML antiquotations themselves ignore morphisms.</p>\n</blockquote>\n<p>I don't understand at all how morphisms come into play here. Are you<br>\nsuggesting that the embedded ML should somehow have access to a<br>\nmorphism? Which morphism?</p>\n<p>Cheers<br>\nLars</p>\n<p><a href=\"/user_uploads/14278/M7H1vm1ZorbbeTe8MZyx5KZQ/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294647169,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164592
    }
]