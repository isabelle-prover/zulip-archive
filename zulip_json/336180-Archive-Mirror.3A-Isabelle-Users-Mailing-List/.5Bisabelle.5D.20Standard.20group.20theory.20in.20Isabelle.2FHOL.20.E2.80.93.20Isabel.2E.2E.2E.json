[
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nWhere can I find this paper?</p>\n<p>How are the type dependencies in expressing group theory covered, as type abstraction, as suggested by Mike Gordon, still isn’t implemented in HOL?</p>\n<p><a href=\"https://owlofminerva.net/kubota/software-implementation-of-the-mathematical-logic-r0-available-for-download/#type_abstraction\">https://owlofminerva.net/kubota/software-implementation-of-the-mathematical-logic-r0-available-for-download/#type_abstraction</a><br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2018-September/msg00045.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2018-September/msg00045.html</a><br>\n<a href=\"https://sympa.inria.fr/sympa/arc/coq-club/2020-02/msg00138.html\">https://sympa.inria.fr/sympa/arc/coq-club/2020-02/msg00138.html</a> (see section: B. Kevin Buzzard on Isabelle/HOL)</p>\n<hr>\n<p>Ken Kubota<br>\n<a href=\"https://doi.org/10.4444/100\">https://doi.org/10.4444/100</a></p>",
        "id": 294831007,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246626
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Where can I find this paper?<br>\nSee here: <a href=\"https://doi.org/10.1007/s10817-019-09537-9\">https://doi.org/10.1007/s10817-019-09537-9</a></p>\n</blockquote>\n<blockquote>\n<p>How are the type dependencies in expressing group theory covered, as type abstraction, as suggested by Mike Gordon, still isn’t implemented in HOL?</p>\n</blockquote>\n<p>I don't know why people keep claiming you need dependent types/type<br>\nabstraction/whatever to do abstract algebra.</p>\n<p>We've had abstract algebra in Isabelle for well over 10 years (the<br>\nHOL-Algebra library, which is distinct from the new experimental<br>\napproach presented in the above paper, which is more like a proof of<br>\nconcept). There was even a paper about the existence of the algebraic<br>\nclosure of fields at ITP 2020, which is a very advanced result. (I don't<br>\nthink any other system has that result yet, although Lean is well on its<br>\nway and Coq has it at least for countable fields).</p>\n<p>We don't have schemes, but that is not, as Kevin suggests, because<br>\nIsabelle/HOL is too weak to define schemes – indeed I did it for him a<br>\nwhile ago in response to that very article just to demonstrate that it<br>\ncan be done and it's not difficult (although whether it is pleasant to<br>\nwork with them is another matter; I cannot say because I have not<br>\ntried). The main reason why we don't have schemes is quite simply<br>\nbecause there are not /that/ many mathematicians in the Isabelle<br>\ncommunity and none of the ones who are seemed to care about schemes<br>\nenough to formalise them. I barely know what schemes are, and I would<br>\nimagine it is the same for most of the Isabelle community, so why should<br>\nI formalise something that I know virtually nothing about? In order to<br>\nformalise something, it is good to have a good informal understanding of<br>\nit first. If I had some concrete goal and schemes were the way to get<br>\nthere, I would look into it, but otherwise, I'd rather stick to doing<br>\nthings that are closer to my field of expertise.</p>\n<p>That said, it is of course entirely possible that there is some<br>\nmathematics that is too tedious to do in Isabelle/HOL due to a lack of<br>\ndependent types; some people, like Sébastien Gouëzel, have said<br>\nsomething to that effect. But saying that abstract algebra in general is<br>\nnot possible without them is certainly a huge overstatement.</p>\n<p>The way abstract algebra is done in Isabelle is simply to have some big<br>\nenough type and the carrier of your group is then only a subset of that<br>\ntype and not the entire type. HOL-Algebra additionally also packages the<br>\ngroup operations up into a record and uses locales to bundle all the<br>\ngroup axioms together. It's a bit painful and perhaps not as natural as<br>\nit is in Coq and Lean, but it undoubtedly works.</p>\n<p>HOL-Analysis has similar \"relativised\" notions of topologies. Normally,<br>\nthe topology of a type always spans the entire type and is fixed for<br>\nthat type using type classes, but one can also have topologies as values<br>\nand then say that a set is open w.r.t. a particular topology.</p>\n<p>The main disadvantage of this is that you have two parallel<br>\ndevelopments: the typeclass-based ones and the relativised ones. That is<br>\ncertainly a drawback, but people (cf. Mikhail Chekhov) seem to be<br>\nworking on making this smoother.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294831008,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246626
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThis is nothing. Too often I hear claims that dependent types are <em>necessary</em> to do formal mathematics. I have seen “proof assistant” defined as “software implementing the propositions-as-types principle\". And there is a widespread idea that the “LCF architecture” is an instance of propositions-as-types. Not very long ago, I had to explain at great length how LCF's use of an abstract type eliminated the need to store proofs (to a person exceptionally familiar with functional programming). Such preconceptions seem to be widespread even among some experienced professionals.</p>\n<p>Larry</p>",
        "id": 294831031,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246639
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nIt is not legitimate to mix up the question of dependent types (or type abstraction) with other, obviously wrong approaches.</p>\n<p>And I find it difficult to call Mike Gordon's suggestion as well as the clear statements by John Harrison, Freek Wiedijk, and others on the limitations of the HOL type system \"nothing\".</p>\n<p>Often some features can be emulated by auxiliary techniques, as this has already been the case with the traditional HOL system.<br>\nBut then the mathematical expression is less natural, and usually not all formal statements can be expressed.<br>\nIf there is an obvious dependency, clearly it is desirable to express this symbolically in formal logic.</p>\n<hr>\n<p>Ken Kubota<br>\n<a href=\"https://doi.org/10.4444/100\">https://doi.org/10.4444/100</a></p>",
        "id": 294831086,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246645
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;</p>\n<blockquote>\n<p>Am 23.07.2020 um 14:44 schrieb Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;:</p>\n<blockquote>\n<p>Where can I find this paper?<br>\nSee here: <a href=\"https://doi.org/10.1007/s10817-019-09537-9\">https://doi.org/10.1007/s10817-019-09537-9</a></p>\n</blockquote>\n</blockquote>\n<p>Thank you very much.<br>\nI will try to have a look at it soon.</p>\n<blockquote>\n<blockquote>\n<p>How are the type dependencies in expressing group theory covered, as type abstraction, as suggested by Mike Gordon, still isn’t implemented in HOL?</p>\n</blockquote>\n<p>I don't know why people keep claiming you need dependent types/type<br>\nabstraction/whatever to do abstract algebra.</p>\n</blockquote>\n<blockquote>\n<p>The way abstract algebra is done in Isabelle is simply to have some big<br>\nenough type and the carrier of your group is then only a subset of that<br>\ntype and not the entire type. HOL-Algebra additionally also packages the<br>\ngroup operations up into a record and uses locales to bundle all the<br>\ngroup axioms together. It's a bit painful and perhaps not as natural as<br>\nit is in Coq and Lean, but it undoubtedly works.</p>\n<p>HOL-Analysis has similar \"relativised\" notions of topologies. Normally,<br>\nthe topology of a type always spans the entire type and is fixed for<br>\nthat type using type classes, but one can also have topologies as values<br>\nand then say that a set is open w.r.t. a particular topology.</p>\n<p>The main disadvantage of this is that you have two parallel<br>\ndevelopments: the typeclass-based ones and the relativised ones. That is<br>\ncertainly a drawback, but people (cf. Mikhail Chekhov) seem to be<br>\nworking on making this smoother.</p>\n</blockquote>\n<p>Let me ask directly. Is it possible to:</p>\n<ol>\n<li>Prove a property in an abstract way for all groups (e.g., the uniqueness of the identity element),</li>\n<li>and then, given a certain group, transfer (instantiate) this theorem for that particular group without having to carry out the proof again?<br>\nIf so, please provide a link.</li>\n</ol>\n<p>Your description above doesn't look like a natural representation at all.<br>\na) Circumlocations are necessary (\"have some big enough type and the carrier of your group is then only a subset of that type\").<br>\nb) Duplication of structures (\"two parallel developments: the typeclass-based ones and the relativised ones\").<br>\nc) Auxiliary structures like type classes are needed.<br>\nd) Extra work is required to unify the parallel developments (\"working on making this smoother\").</p>\n<p>I'm not too familiar with Isabelle's type classes.<br>\nBut I vaguely remember that in the past they lead to an inconsistency (antinomy: negative self-reference) in Isabelle/HOL, and the way this was fixed was by manually tracking the dependencies, if I'm not mistaken.<br>\nHowever, this clearly contradicts the very idea of type theory, in which the formal language (the syntax: types) prevents the formulation of antinomies from the very beginning.<br>\nOne may accept the fix as an auxiliary solution, but not more.</p>\n<p>So altogether the impression is, that simply because the formal language (the type system) used here is too poor, a lot of problems and extra work are created.<br>\nThere is no sense in defending an impoverished type system, in which trivial ideas such as the link (the dependency) between the type and the term level cannot be expressed naturally.<br>\nIn particular, since it can easily be expressed using the lambda variable binder, as suggested by Mike Gordon.</p>\n<hr>\n<p>Ken Kubota<br>\n<a href=\"https://doi.org/10.4444/100\">https://doi.org/10.4444/100</a> &lt;<a href=\"https://doi.org/10.4444/100\">https://doi.org/10.4444/100</a>&gt;</p>",
        "id": 294831102,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246651
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nOn 23/07/2020 23:24, Ken Kubota wrote:</p>\n<blockquote>\n<p>Let me ask directly. Is it possible to:<br>\n1. Prove a property in an abstract way for all groups (e.g., the<br>\nuniqueness of the identity element),</p>\n</blockquote>\n<p>Of course:</p>\n<p>lemma (in monoid) one_unique:<br>\n  assumes \"u ∈ carrier G\"<br>\n    and \"⋀x. x ∈ carrier G ⟹ u ⊗ x = x\"<br>\n  shows \"u = 𝟭\"</p>\n<p>What you cannot do (due to lack of type-level quantification) is write<br>\ndown a statement like \"there exists a group G such that …\" without<br>\nfixing the type of G. But I've never seen that cause problems in practice.</p>\n<blockquote>\n<ol start=\"2\">\n<li>and then, given a certain group, transfer (instantiate) this theorem<br>\nfor that particular group without having to carry out the proof again?<br>\nIf so, please provide a link.</li>\n</ol>\n</blockquote>\n<p>All you have to prove is that the structure you're looking at is indeed<br>\na monoid and then you get that theorem. For instance, HOL-Number_Theory<br>\ndefines</p>\n<p>definition residue_ring :: \"int ⇒ int ring\"<br>\n  where<br>\n    \"residue_ring m =<br>\n      ⦇carrier = {0..m - 1},<br>\n       mult = λx y. (x * y) mod m,<br>\n       one = 1,<br>\n       zero = 0,<br>\n       add = λx y. (x + y) mod m⦈\"</p>\n<p>and then proves that this is a commutative ring for \"m &gt; 1\". That gives<br>\nyou for free that the additive and multiplicative subgroup are abelian<br>\ngroups (and therefore monoids) and you can use the above fact. You can<br>\nalso talk about subgroups of these groups and apply the result to them.</p>\n<blockquote>\n<p>Your description above doesn't look like a natural representation at all.<br>\na) Circumlocations are necessary (\"have some big enough type and the<br>\ncarrier of your group is then only a subset of that type\").<br>\nb) Duplication of structures (\"two parallel developments: the<br>\ntypeclass-based ones and the relativised ones\").<br>\nc) Auxiliary structures like type classes are needed.<br>\nd) Extra work is required to unify the parallel developments (\"working<br>\non making this smoother\").</p>\n</blockquote>\n<p>Yes, it's not great. But if you want to make a system work for practical<br>\nuse, you always have to make some compromises and/or do a lot of<br>\nengineering. If I recall correctly, the Coq people have been investing a<br>\nlot of work into their type classes as well because they were found to<br>\nbe insufficient for practical use. The Lean people recently overhauled<br>\ntheir system as well because (I think) it was too slow and unpredictable.</p>\n<blockquote>\n<p>I'm not too familiar with Isabelle's type classes.<br>\nBut I vaguely remember that in the past they lead to an inconsistency<br>\n(antinomy: negative self-reference) in Isabelle/HOL, and the way this<br>\nwas fixed was by manually tracking the dependencies, if I'm not mistaken.</p>\n</blockquote>\n<p>The problem wasn't type classes per se, but the low-level mechanism that<br>\nthey use (overloaded constant definitions). These are now well<br>\nunderstood; I think there's even some kind of mechanised soundness proof<br>\nand more is on the way.</p>\n<blockquote>\n<p>However, this clearly contradicts the very idea of type theory, in which<br>\nthe formal language (the syntax: types) prevents the formulation of<br>\nantinomies from the very beginning.<br>\nOne may accept the fix as an auxiliary solution, but not more.</p>\n</blockquote>\n<p>You may oppose this on a philosophical and aesthetic level and that is<br>\nfine (I will hardly prescribe you your sense of aesthetics), but I for<br>\none don't care much about such foundational issues as long as things are<br>\nsound. I just want a system that allows me to do stuff, and Isabelle/HOL<br>\nusually works great in practice.</p>\n<blockquote>\n<p>So altogether the impression is, that simply because the formal language<br>\n(the type system) used here is too poor, a lot of problems and extra<br>\nwork are created.<br>\nThere is no sense in defending an impoverished type system, in which<br>\ntrivial ideas such as the link (the dependency) between the type and the<br>\nterm level cannot be expressed naturally.<br>\nIn particular, since it can easily be expressed using the lambda<br>\nvariable binder, as suggested by Mike Gordon.</p>\n</blockquote>\n<p>I don't know anything about that lambda variable binder since I am not a<br>\nfoundational guy; perhaps somebody else can comment on that. But I would<br>\nbe surprised if it didn't make some things more difficult.</p>\n<p>You criticise Isabelle/HOL as unnatural because you sometimes have to<br>\nexpress things in a certain way. But when I look at e.g. Coq<br>\ndevelopments like the group theory behind Feit–Thompson, I was told they<br>\nrestrict everything to finite groups represented them as lists. That<br>\ndoesn't sound like a natural representation to me either. I'm sure they<br>\n/could/ have done it in a different, more natural way, but they chose<br>\nnot to for some (probably technical) reason, and that's my point.</p>\n<p>Systems like Coq and Lean also have the difference between Bool and Prop<br>\nand between definitional equality and other types of equality. I'm<br>\npretty sure most mathematician find such distinctions very strange.<br>\nIsabelle/HOL also has two kinds of equality and a distinction between<br>\nbool and prop, but the logic allows hiding the difference completely in<br>\npractice.</p>\n<p>(Just in case that your opinion is that Lean and Coq are also bad and<br>\nsome other system X is the real solution: I am focusing on Lean and Coq<br>\nbecause they are the other two really big systems that have stronger<br>\nlogics than Isabelle/HOL and it only makes sense to compare Isabelle/HOL<br>\nto systems of roughly comparable size.)</p>\n<p>The way I see it, theorem proving is not a game of type-theoretic<br>\none-upmanship. The objective is not to just pick the most powerful logic<br>\nimaginable and then you win. Expressiveness often comes with a price. I<br>\nthink it is widely agreed upon that Isabelle has exceptionally good<br>\nautomation and performance, and I'm sure that has a lot to do with the<br>\nLCF approach and the foundational choices (although I am hardly an<br>\nexpert on this). Some Lean people, for instance, told me that their<br>\nsimplifier is still very slow.</p>\n<p>Another big advantage of Isabelle/HOL is that there is a huge library!<br>\nIn my opinion, good libraries are far more important in practice than<br>\npowerful logical foundations. If you want to do some work requiring<br>\nanalytic combinatorics (an example chosen because it is close to my<br>\nheart), the very expressive type systems of Coq and Lean and Agda will<br>\nnot be particularly helpful, since none of them have any complex<br>\nanalysis, let alone analytic combinatorics.</p>\n<p>You're certainly right that we Isabelle/HOL people sometimes have to go<br>\nout of our way to do certain things (such as the duplication of<br>\nHOL-Computational_Algebra vs HOL-Algebra) and we are well aware of that.<br>\nOccasionally, you have to take a step back and figure out if the extra<br>\nwork you have to do is still worth doing or whether you are working<br>\nagainst the system more than you are working with it. If that ever<br>\nhappens, I might well consider switching to another, more suitable<br>\nsystem, but it hasn't happened so far.</p>\n<p>If someone were to come along and make a system that offers the<br>\nadvantages of Isabelle/HOL (structured proofs, good automation,<br>\nscalability) with the addition of dependent types, I would very<br>\nseriously consider switching as well (although the library issue remains).</p>\n<p>Theorem provers are not artworks to be displayed on a wall in a gallery<br>\nfor everyone to marvel at their beautiful and elegant design. They are<br>\nsoftware intended for practical use by many people for a large variety<br>\nof different use cases, and they succeed or fail in practical applications.</p>\n<p>Isabelle/HOL has worked well for a lots of practical use cases in<br>\ncomputer science and mathematics. If it will someday be the case that<br>\nother systems are clearly and unequivocally better, it will probably<br>\njust die.</p>\n<p>But I think we're still far away from that.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294831126,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246663
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nFor sure. I have been noticing since the 1990s that with certain well-known systems you have to build a new library for each project. Precisely why isn’t clear; perhaps it is quite difficult to judge how heavy a use to make of dependent types. That the most popular Coq library (SSREFLECT) emphasises computable representations of mathematics seems remarkable, since it goes against the natural objective reasoning abstractly.</p>\n<p>We have a similar situation ourselves with the Algebra library, where the use of records may have been a mistake. But at least we don’t feel compelled to throw it away and start fresh.</p>\n<p>As I keep saying: the precise role of dependent types in the formalisation of mathematics is one of the key scientific questions of our field. It can only be answered empirically.</p>\n<p>Larry</p>",
        "id": 294831141,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246669
    }
]