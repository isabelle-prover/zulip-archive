[
    {
        "content": "<p>From: Richard Molitor &lt;<a href=\"mailto:gattschardo@googlemail.com\">gattschardo@googlemail.com</a>&gt;<br>\nHello Florian,</p>\n<p>thanks for your reply!</p>\n<p>On Thu, 12 Mar 2015, Florian Haftmann wrote:</p>\n<blockquote>\n<p>a) Your »workaround« with Local_Theory.background_theory is correct – as<br>\nlong as you want to store data in background theories only.  There are a<br>\ncouple of applications where this indeed is feasible, but it is usually<br>\nnot what you want.</p>\n</blockquote>\n<p>The background for this is that I had my data stored in a Theory_Data struct<br>\nbefore, so my ``workaround'' just does exactly what I did before, except it's<br>\nnow wrapped in a generic context. Which somehow does not seem to be what I<br>\nwant.</p>\n<p>My \"dream\" here was that the generic context would magically convert between<br>\ntheory data and proof data for me, which was maybe a bit too much to whish<br>\nfor.</p>\n<p>In general I think I'm fine with just having the data in the background theory<br>\nonly, the main problem is that I need to somewhat awkwardly extract it when<br>\nI'm in a local theory context.</p>\n<blockquote>\n<p>b) The established pattern to store data generically is</p>\n<p>Local_Theory.declaration (fn phi =&gt; …)</p>\n<p>As a simple example, you might study src/HOL/Tools/functor.ML.</p>\n<p>The idea is basically the following:</p>\n<p>fun foo … lthy =<br>\n let<br>\n   (We are relative to some local theory lthy here<br>\n   and have some entities (terms t, theorems thm, …) relative<br>\n   to lthy flying around as ML values here)<br>\n   fun decl phi =<br>\n     let<br>\n       (We are called for each instance (interpretation)<br>\n       of the original lthy, including lthy itself; the<br>\n       logical difference is represented by morphism phi,<br>\n       which we can apply (using Morphism.…) to transform our<br>\n       original entities t, thm to obtain their appropriate<br>\n       shape to do something with them relative<br>\n       to the current instance)<br>\n     in Data.put (a data record resulting from suitable) end;<br>\n in<br>\n   lthy<br>\n   |&gt; Local_Theory.declaration decl<br>\n end;</p>\n<p>Put differently:\n* Your data is of a certain type T.\n* You explain how a fundamental morphism phi is applied to a value of<br>\ntype T by giving a suitable lifting f :: morphism -&gt; T -&gt; T\n* Then your declaration for a particular x :: T looks as follows:<br>\n   fun decl phi = Data.put (f phi x)</p>\n<p>Unfortunately, there is no elaborate section on this in the<br>\nimplementation manual yet.</p>\n</blockquote>\n<p>I will look into this. I had seen the morphisms before, but given the lack of<br>\ndocumentation, I decided to use the well-documented old-fashioned way of doing<br>\nthings. Maybe reading functor.ML will enlighten me, thanks for the pointer!</p>\n<blockquote>\n<p>If you can tell more about the application you are aiming towards, a<br>\nmore concrete description than this generic abstract nonsense can be given.</p>\n</blockquote>\n<p>The application is the ``open inductive'' [1] [2] package that I developed for<br>\nmy master's thesis. It is in a working (but not pretty) state right now, what<br>\nI am trying to do is refine the code as best as I can, so it can be submitted<br>\nto the AFP in a somewhat maintainable state.</p>\n<p>Greetings,</p>\n<p>Richard</p>\n<p>[1] documentation: <a href=\"http://pp.info.uni-karlsruhe.de/thesis.php?id=253\">http://pp.info.uni-karlsruhe.de/thesis.php?id=253</a><br>\n[2] code: <a href=\"https://github.com/gattschardo/open-inductive\">https://github.com/gattschardo/open-inductive</a></p>",
        "id": 294328900,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929560
    },
    {
        "content": "<p>From: Richard Molitor &lt;<a href=\"mailto:gattschardo@googlemail.com\">gattschardo@googlemail.com</a>&gt;<br>\nHello again,</p>\n<p>I managed to implement the suggested morphsim variant to some success now,<br>\nthanks to your example!</p>\n<p>What somewhat worries me is that I end up ignoring the morphism argument<br>\ncompletely, since it can contain thms and terms and (I think) they do not<br>\naffect the outcome of my commands, since they are just storing data.</p>\n<p>When I figure out which additional thms may affect my commands though, this<br>\nway at least the infrastructure is in place in contrast to just storing in the<br>\nbackground theory as I did before [1], so I think I stick with this for now.</p>\n<p>In the last part of the linked commit, I have a local_theory_to_proof command.<br>\nWhat I do now is store the result I get in after_qed using background_theory,<br>\nI could not get declaration to work here: No matter how I produce the initial<br>\ngeneric context, either from the local or the background theory, I somehow<br>\nalways end up needing the other variant in the end.</p>\n<p>Richard</p>\n<p>[1]: <a href=\"https://github.com/gattschardo/open-inductive/commit/62a4bd010e91540a00427b18c5a5656f57686591\">https://github.com/gattschardo/open-inductive/commit/62a4bd010e91540a00427b18c5a5656f57686591</a></p>",
        "id": 294328972,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929587
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Richard,</p>\n<p>I just glanced quickly over your code, so the following might not be 100% accurate, but <br>\nhere are my observations nevertheless.</p>\n<p>Your data structure for the open theorems looks rather unusual, because as far as I can <br>\nsee, you are storing the literal string input rather than the parsed terms and theorems. <br>\nOf course, there is no infrastructure in Isabelle to apply the morphisms to strings.<br>\n From what I know about open inductive, I can see why you store the strings, but I am <br>\npretty sure that this will eventually get you into trouble. Ultimately, you have to parse <br>\nthe strings, but the context may have changed in between -- just think of deleting a <br>\nnotation and installing the same notation for some other constant. That is, you probably <br>\nget parsing with respect to dynamic contexts. because you no longer have access to the old <br>\ncontext. So I recomment that you immediately convert the strings into logical entities <br>\n(terms, types, theorems) and push them through the morphism as intended.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294328986,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929593
    },
    {
        "content": "<p>From: Richard Molitor &lt;<a href=\"mailto:gattschardo@googlemail.com\">gattschardo@googlemail.com</a>&gt;<br>\nHello Andreas,</p>\n<p>you have the correct answer! Converting these strings had been on my to-do<br>\nlist, I just failed to realize that now is the moment were I need it done.</p>\n<p>Thanks for your feedback, sometimes it takes a second pair of eyes :)</p>\n<p>Richard</p>",
        "id": 294329001,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929599
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Richard,</p>\n<blockquote>\n<p>you have the correct answer! Converting these strings had been on my to-do<br>\nlist, I just failed to realize that now is the moment were I need it done.</p>\n</blockquote>\n<p>text representation of entities like terms, theorems are indeed always<br>\nparsed at the very place of their occurence in a theory text.  The whole<br>\nmachinery in the background then proceeds with proper internalized ML<br>\nvalues of type term, thm, etc.</p>\n<p>So I would suggest to modify this accordingly and come back here for<br>\nfurther counsel.</p>\n<p>Hope this helps,<br>\n    Florian</p>\n<blockquote>\n<p>Thanks for your feedback, sometimes it takes a second pair of eyes :)</p>\n<p>Richard</p>\n<p>On Thu, 12 Mar 2015, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Dear Richard,</p>\n<p>I just glanced quickly over your code, so the following might not be<br>\n100% accurate, but here are my observations nevertheless.</p>\n<p>Your data structure for the open theorems looks rather unusual,<br>\nbecause as far as I can see, you are storing the literal string input<br>\nrather than the parsed terms and theorems. Of course, there is no<br>\ninfrastructure in Isabelle to apply the morphisms to strings.<br>\nFrom what I know about open inductive, I can see why you store the<br>\nstrings, but I am pretty sure that this will eventually get you into<br>\ntrouble. Ultimately, you have to parse the strings, but the context<br>\nmay have changed in between -- just think of deleting a notation and<br>\ninstalling the same notation for some other constant. That is, you<br>\nprobably get parsing with respect to dynamic contexts. because you no<br>\nlonger have access to the old context. So I recomment that you<br>\nimmediately convert the strings into logical entities (terms, types,<br>\ntheorems) and push them through the morphism as intended.</p>\n<p>Best,<br>\nAndreas</p>\n</blockquote>\n<p>On 12/03/15 18:38, Richard Molitor wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hello again,</p>\n<p>I managed to implement the suggested morphsim variant to some success<br>\nnow,<br>\nthanks to your example!<br>\n</p>\n</blockquote>\n<p>On Thu, 12 Mar 2015, Richard Molitor wrote:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Put differently:\n* Your data is of a certain type T.\n* You explain how a fundamental morphism phi is applied to a value of<br>\ntype T by giving a suitable lifting f :: morphism -&gt; T -&gt; T\n* Then your declaration for a particular x :: T looks as follows:<br>\n   fun decl phi = Data.put (f phi x)</p>\n<p>Unfortunately, there is no elaborate section on this in the<br>\nimplementation manual yet.</p>\n</blockquote>\n<p>I will look into this. I had seen the morphisms before, but given<br>\nthe lack of<br>\ndocumentation, I decided to use the well-documented old-fashioned<br>\nway of doing<br>\nthings. Maybe reading functor.ML will enlighten me, thanks for the<br>\npointer!</p>\n</blockquote>\n<p>What somewhat worries me is that I end up ignoring the morphism argument<br>\ncompletely, since it can contain thms and terms and (I think) they do<br>\nnot<br>\naffect the outcome of my commands, since they are just storing data.</p>\n<p>When I figure out which additional thms may affect my commands<br>\nthough, this<br>\nway at least the infrastructure is in place in contrast to just<br>\nstoring in the<br>\nbackground theory as I did before [1], so I think I stick with this<br>\nfor now.</p>\n<p>In the last part of the linked commit, I have a local_theory_to_proof<br>\ncommand.<br>\nWhat I do now is store the result I get in after_qed using<br>\nbackground_theory,<br>\nI could not get declaration to work here: No matter how I produce the<br>\ninitial<br>\ngeneric context, either from the local or the background theory, I<br>\nsomehow<br>\nalways end up needing the other variant in the end.</p>\n<p>Richard</p>\n<p>[1]:<br>\n<a href=\"https://github.com/gattschardo/open-inductive/commit/62a4bd010e91540a00427b18c5a5656f57686591\">https://github.com/gattschardo/open-inductive/commit/62a4bd010e91540a00427b18c5a5656f57686591</a></p>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/WfR_zjGJ5418gEdz2SOKBbYH/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294329203,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929667
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThese are very important observations.  I've point out some of this <br>\nalready privately.</p>\n<p>The whole complex of \"locality\" in Isabelle is rather complex; it is not <br>\neasily disassembled to understand how it really works.  Ultimately, it is <br>\nall about \"abstract concepts\" of contexts, morphisms, declarations etc.</p>\n<p>The main strategies of survival are:</p>\n<p>(1) Study published documents (the \"implementation\" manual with cited<br>\n       papers) about the concepts themselves.  I know that the manual is<br>\n       not finished in that respect yet, but it does contain some<br>\n       information, notably some references to papers by Chaieb, Haftmann,<br>\n       Wenzel.</p>\n<p>(2) Figure out the canonical way to do it, by looking closely at<br>\n       existing examples.  Find such examples, by asking the question<br>\n       \"Which existing things are close to what I need?\".  Then look<br>\n       through the sources, and make educated guesses about their quality,<br>\n       ask experts about them etc.</p>\n<p>Often people say \"I don't understand localization so I better stick with <br>\nold-fashioned global theory contexts\".  This only works in limited <br>\nsituations, and usually turns into a much harder problem to make it work <br>\nin general: both locality and globality need to be understood, instead of <br>\njust using locality in the proper way.</p>\n<p>Makarius</p>",
        "id": 294329545,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929765
    },
    {
        "content": "<p>From: Richard Molitor &lt;<a href=\"mailto:gattschardo@googlemail.com\">gattschardo@googlemail.com</a>&gt;<br>\nHello,</p>\n<p>I have a question concerning the usage of Generic_Data in conjunction with an<br>\nOuter_Syntax.local_theory command. The parameter to my handler function is of<br>\ntype local_theory, which can be used initialize a generic context using<br>\nContext.Proof, which can then be used to store some data:</p>\n<p>fun test_thy_cmd name =<br>\n        Context.Proof #&gt; Data.put name #&gt; Context.proof_of</p>\n<p>val _ = Outer_Syntax.local_theory @{command_spec \"test_thy\"}<br>\n        \"test\" (<a href=\"http://Parse.name\">Parse.name</a> &gt;&gt; test_thy_cmd)</p>\n<p>I would expect to have it stored back in the background theory when the<br>\ncommand completes, so using it like this:</p>\n<p>test_thy foo</p>\n<p>ML_val {* Data.get (Context.Theory @{theory}) *}</p>\n<p>I would expect to get \"foo\" back, but i stays at the default value.</p>\n<p>The workaround I found was wrapping the whole function in background_theory<br>\nand initializing the generic context from the theory:</p>\n<p>fun test_prf_cmd name =<br>\n        Local_Theory.background_theory (Context.Theory #&gt; Data.put name #&gt; Context.theory_of)</p>\n<p>val _ = Outer_Syntax.local_theory @{command_spec \"test_prf\"}<br>\n        \"test\" (<a href=\"http://Parse.name\">Parse.name</a> &gt;&gt; test_prf_cmd)</p>\n<p>Using this:<br>\n      test_prf bar</p>\n<p>ML_val {* Data.get (Context.Theory @{theory}) *}</p>\n<p>I get \"bar\" back.</p>\n<p>Is this behaviour intended? If modify the local theory in other ways (i.e.<br>\nnote theorems) the data seems to be transferred as I expect (in my first<br>\nexample above).</p>\n<p>Kind regards<br>\nRichard</p>\n<p>P.S.: A full working example is attached<br>\n<a href=\"/user_uploads/14278/3qEnF2z_IpUWnXfOI9Am5oJl/Generic.thy\">Generic.thy</a></p>",
        "id": 294633270,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159140
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Richard,</p>\n<p>my answer is twofold.</p>\n<p>a) Your »workaround« with Local_Theory.background_theory is correct – as<br>\nlong as you want to store data in background theories only.  There are a<br>\ncouple of applications where this indeed is feasible, but it is usually<br>\nnot what you want.</p>\n<p>b) The established pattern to store data generically is</p>\n<p>Local_Theory.declaration (fn phi =&gt; …)</p>\n<p>As a simple example, you might study src/HOL/Tools/functor.ML.</p>\n<p>The idea is basically the following:</p>\n<p>fun foo … lthy =<br>\n  let<br>\n    (We are relative to some local theory lthy here<br>\n    and have some entities (terms t, theorems thm, …) relative<br>\n    to lthy flying around as ML values here)<br>\n    fun decl phi =<br>\n      let<br>\n        (We are called for each instance (interpretation)<br>\n        of the original lthy, including lthy itself; the<br>\n        logical difference is represented by morphism phi,<br>\n        which we can apply (using Morphism.…) to transform our<br>\n        original entities t, thm to obtain their appropriate<br>\n        shape to do something with them relative<br>\n        to the current instance)<br>\n      in Data.put (a data record resulting from suitable) end;<br>\n  in<br>\n    lthy<br>\n    |&gt; Local_Theory.declaration decl<br>\n  end;</p>\n<p>Put differently:</p>\n<ul>\n<li>Your data is of a certain type T.</li>\n<li>\n<p>You explain how a fundamental morphism phi is applied to a value of<br>\ntype T by giving a suitable lifting f :: morphism -&gt; T -&gt; T</p>\n</li>\n<li>\n<p>Then your declaration for a particular x :: T looks as follows:<br>\n    fun decl phi = Data.put (f phi x)</p>\n</li>\n</ul>\n<p>Unfortunately, there is no elaborate section on this in the<br>\nimplementation manual yet.</p>\n<p>If you can tell more about the application you are aiming towards, a<br>\nmore concrete description than this generic abstract nonsense can be given.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/z1X0sHri407oipTVsKiWLm4T/signature.asc\">signature.asc</a></p>",
        "id": 294633596,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159275
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Richard,</p>\n<p>as far as I discern, these are indeed the relevant patterns, although I<br>\npersonally prefer to think about this without historic references like<br>\n»old way« ;-).</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/uVZ5BpvM48C-leuMYhDFa7R3/signature.asc\">signature.asc</a></p>",
        "id": 294650426,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165886
    },
    {
        "content": "<p>From: Richard Molitor via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSorry for resurrecting this somewhat dated thread. It seems the same saying<br>\nthat applies to PhD thesis also applies to Masters: They are never finished,<br>\nonly abandoned.</p>\n<p>The strings are now out of my implementation, (actually for several months<br>\nnow) and all my usages of the global Local_Theory.background_theory are now<br>\nreplaced by using generic contexts and calls to Local_Theory.declaration, as<br>\nwas suggested here. ^1</p>\n<p>Studying some other occurences in the code as suggested by Makarius I made the<br>\nfollowing observations for \"How to converted global to localized code\" in this<br>\nsetting:</p>\n<ul>\n<li>\n<p>If the command needs to store Generic_Data, Local_Theory.declaration is a<br>\n   drop-in replacement for the old way (provided terms are parsed and not kept<br>\n   as strings), as explained here before.</p>\n</li>\n<li>\n<p>If the command transitions to the proof state and needs to store<br>\n   Generic_Data afterwards, the call to Local_Theory.declaration needs to be in<br>\n   the after_qed continuation function.</p>\n</li>\n<li>\n<p>If the Generic_Data is not to be modified by the command, reading it can be<br>\n   accomplished by instantiating a generic context explicitly e.g. using<br>\n   Context.Proof ^2</p>\n</li>\n</ul>\n<p>I have attached a theory file that demonstrates these on a toy example. I<br>\nthink that these are the appropriate solutions, but please point out any<br>\nerrors if I have gone wrong somewhere. Otherwise I hope these example may be<br>\nhelpful to others that want to update their older Isabelle/ML code.</p>\n<p>Kind regards<br>\nRichard</p>\n<p>1: <a href=\"https://github.com/gattschardo/open-inductive/blob/master/src/open_inductive.ML\">https://github.com/gattschardo/open-inductive/blob/master/src/open_inductive.ML</a><br>\n2: $ISABELLE_HOME/src/HOL/Eisbach/method_closure.ML contains an example of<br>\n    this<br>\n<a href=\"/user_uploads/14278/fMM4KtZoXlw0QHztkLDPAMwJ/Generic.thy\">Generic.thy</a></p>",
        "id": 294651746,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166347
    }
]