[
    {
        "content": "<p>From: Gidon Ernst &lt;<a href=\"mailto:gidon.ernst@unimelb.edu.au\">gidon.ernst@unimelb.edu.au</a>&gt;<br>\nHi all,</p>\n<p>I have feedback wrt. documentation and a question (I guess a feature request).<br>\nSorry if these points have been raised before.</p>\n<p>I really like obtains in lemmas with the ability to specify multiple cases.<br>\nIt helped to streamline my Isar proofs a lot and I think it should be advertised more in the documentation.<br>\nThe documentation could be more explicit about the fact(s) \"that\" which you can use to prove such lemmas (e.g. in Sec 2.2.2), as I found out about it accidentally via sledgehammer only (it is mentioned in fact somewhere at the very end of the manual, but hard to spot).<br>\nAlso, I'd note that \"that\" in an inductive lemma<br>\n  assumes A obtains B using A proof (induction ...)<br>\nrefers to the outer context, not the properly generalized one, and is therefore useless. Could this be fixed somehow?</p>\n<p>Secondly, how about a similar construct for introduction rules?<br>\nApplying an introduction lemma for C<br>\n assumes a: \"!!x. A ==&gt; B\" shows C<br>\ncould generate a structure comparable to a cases rule that does the \"fix x assume a: A show B\" for you, possibly extending to multiple assumptions.<br>\nIs there a mechanism for this? It would amount to multiple \"case ...\" with <em>different</em> conclusions, which I understand does not work currently.</p>\n<p>Thanks a lot and best regards,<br>\n  Gidon</p>",
        "id": 294750839,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195395
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 13/02/2019 10:12, Gidon Ernst wrote:</p>\n<blockquote>\n<p>I really like obtains in lemmas with the ability to specify multiple cases.</p>\n</blockquote>\n<p>Note that in a proof body you have a few more such structuring<br>\nprinciples for statements: \"have C if A for x\", \"consider A | B | C\",<br>\nand then \"obtain x where A\" as a special case.</p>\n<p>The \"that\" fact shows up here as well: historically 'obtains' was first,<br>\nbut I have retrofitted it into this general setup a few years ago.</p>\n<blockquote>\n<p>Also, I'd note that \"that\" in an inductive lemma<br>\n  assumes A obtains B using A proof (induction ...)<br>\nrefers to the outer context, not the properly generalized one, and is therefore useless. Could this be fixed somehow?</p>\n</blockquote>\n<p>A proof method mainly operates on the goal state, but local facts are<br>\nnot part of that. The \"cases\" / \"induct\" family of proof methods make an<br>\nexception in providing named cases as small local proof contexts to be<br>\nactivated later. This is a concession to the requirements of complex<br>\ninduction schemes.</p>\n<blockquote>\n<p>Secondly, how about a similar construct for introduction rules?<br>\nApplying an introduction lemma for C<br>\n assumes a: \"!!x. A ==&gt; B\" shows C<br>\ncould generate a structure comparable to a cases rule that does the \"fix x assume a: A show B\" for you, possibly extending to multiple assumptions.<br>\nIs there a mechanism for this? It would amount to multiple \"case ...\" with <em>different</em> conclusions, which I understand does not work currently.</p>\n</blockquote>\n<p>Some decades ago, I was thinking about that but dismissed it.</p>\n<p>The next time when I will revisit this question there will be some<br>\nProver IDE support to copy-paste parts of the goal state into the source<br>\ndocument.</p>\n<p>Makarius</p>",
        "id": 294751032,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195465
    },
    {
        "content": "<p>From: Gidon Ernst &lt;<a href=\"mailto:gidon.ernst@unimelb.edu.au\">gidon.ernst@unimelb.edu.au</a>&gt;<br>\nHi Makarius,</p>\n<p>On 2/18/19 1:54 AM, Makarius wrote:&gt; On 13/02/2019 10:12, Gidon Ernst wrote:</p>\n<blockquote>\n<blockquote>\n<p>I really like obtains in lemmas with the ability to specify multiple<br>\ncases.</p>\n</blockquote>\n<p>Note that in a proof body you have a few more such structuring<br>\nprinciples for statements: \"have C if A for x\", \"consider A | B | C\",<br>\nand then \"obtain x where A\" as a special case.</p>\n</blockquote>\n<p>Thanks for the pointer. I've seen obtain and used it occasionally, and<br>\nit permits one to name facts as in \"obtain x where a: A\".<br>\nIs there a similar mechanism for \"obtains\" in lemma definitions?<br>\nI've noted that you <em>can</em> in fact write \"shows a: A\", but I haven't<br>\nfigured out where the \"a\" comes into play...</p>\n<p>Having names for conclusions of lemmas that \"shows a: A B\" that get<br>\nimported into a proof state could be a cool feature for maintenance:<br>\nthere is no need to spell out \"A\" or refer to it by position \"a(1)\" when<br>\nyou use it -&gt; proofs remain intact even if \"A\" changes or more<br>\nconclusions get added to a lemma.</p>\n<blockquote>\n<blockquote>\n<p>Secondly, how about a similar construct for introduction rules?<br>\nApplying an introduction lemma for C<br>\n assumes a: \"!!x. A ==&gt; B\" shows C<br>\ncould generate a structure comparable to a cases rule that does the&gt;&gt; \"fix x assume a: A show B\" for you, possibly extending to multiple<br>\nassumptions.<br>\nIs there a mechanism for this? It would amount to multiple \"case ...\"<br>\nwith <em>different</em> conclusions, which I understand does not work<br>\ncurrently.</p>\n</blockquote>\n<p>Some decades ago, I was thinking about that but dismissed it.</p>\n<p>The next time when I will revisit this question there will be some<br>\nProver IDE support to copy-paste parts of the goal state into the source<br>\ndocument.</p>\n</blockquote>\n<p>That would be great! (Do you still remember why you dismissed that<br>\nIdea?). Same argument about naming would apply here, though.</p>\n<p>That said, I've been using Isabelle for ~6 month now and I quite enjoy it.</p>\n<p>Best,<br>\n Gidon</p>",
        "id": 294751094,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195490
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 18.02.19 02:16, Gidon Ernst wrote:</p>\n<blockquote>\n<p>Thanks for the pointer. I've seen obtain and used it occasionally, and<br>\nit permits one to name facts as in \"obtain x where a: A\".<br>\nIs there a similar mechanism for \"obtains\" in lemma definitions?</p>\n</blockquote>\n<p>\"lemma obtains\" corresponds to \"consider\" within a proof body: it states <br>\nan elimination (possible) with case split. \"obtain\" is for a one-arm <br>\ncase split where the rule is used on the spot to augment the local <br>\ncontext, and later dispose the assumptions again thanks to the proven rule.</p>\n<blockquote>\n<p>I've noted that you <em>can</em> in fact write \"shows a: A\", but I haven't<br>\nfigured out where the \"a\" comes into play...</p>\n</blockquote>\n<p>\"lemma shows\" is merely a syntactic device of the long form of rule <br>\nstatements \"fixes-assumes-shows\". The name attached there is the name of <br>\nthe overall conclusion of the lemma.</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>Secondly, how about a similar construct for introduction rules?<br>\nApplying an introduction lemma for C<br>\n  assumes a: \"!!x. A ==&gt; B\" shows C<br>\ncould generate a structure comparable to a cases rule that does the&gt;&gt; \"fix x assume a: A show B\" for you, possibly extending to multiple<br>\nassumptions.<br>\nIs there a mechanism for this? It would amount to multiple \"case ...\"<br>\nwith <em>different</em> conclusions, which I understand does not work<br>\ncurrently.</p>\n</blockquote>\n<p>Some decades ago, I was thinking about that but dismissed it.</p>\n<p>The next time when I will revisit this question there will be some<br>\nProver IDE support to copy-paste parts of the goal state into the source<br>\ndocument.</p>\n</blockquote>\n<p>That would be great! (Do you still remember why you dismissed that<br>\nIdea?). Same argument about naming would apply here, though.</p>\n</blockquote>\n<p>The generic problem is to find just the right amount of explicitness in <br>\nproofs that they become readable and maintainable. Being too implicit <br>\ncan destroy this delicate balance (e.g. via automatic name bindings for <br>\nobscure goal artifacts); the same can happen by being too explicit (e.g. <br>\nbig generated goal statements copied into the text, without symbolic <br>\nabbreviations for certain sub-terms).</p>\n<p>Existing Isar (the current version from 2016) already spans a broad <br>\nrange of possibilities: it is often just a matter of style how to use it <br>\nin applications. The language also tolerates \"improper\" elements like <br>\n\"apply\" or \"supply\" and semi-proper ones like \"subgoal\" and \"goal_cases\" <br>\n(see the index of the isar-ref manual).</p>\n<p>In particular, the last two might help in your applications, but it is <br>\nhard to tell without looking at the applications concretely.</p>\n<p>Makarius</p>",
        "id": 294751119,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195502
    }
]