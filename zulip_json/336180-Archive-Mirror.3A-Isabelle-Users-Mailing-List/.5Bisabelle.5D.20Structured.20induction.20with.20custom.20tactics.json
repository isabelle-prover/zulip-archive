[
    {
        "content": "<p>From: Palle Raabjerg &lt;<a href=\"mailto:palle.raabjerg@it.uu.se\">palle.raabjerg@it.uu.se</a>&gt;<br>\nI am currently trying to write custom tactics to resolve different<br>\ninstances of some induction proofs. With some help from Christian Urban<br>\non [nominal-isabelle], I found out how to invoke nominal_induct_tac from<br>\nthe ML level, which has been a great help so far (thanks Christian!).</p>\n<p>But while it is possible to do much simply by combining an induction<br>\ntactic with a number of other tactics, I increasingly find that it would<br>\nbe useful (possibly even necessary) in many cases to be able to<br>\nstructure the tactics so that</p>\n<ol>\n<li>\n<p>The base case and the inductive cases are separated, such that<br>\ndifferent tactics can be used for each.</p>\n</li>\n<li>\n<p>We have access to the induction term in each case.</p>\n</li>\n</ol>\n<p>Example. If we have the following datatype:<br>\nnominal_datatype trm = Name name | Pair trm trm</p>\n<p>The Isar-proof might be structured like this:<br>\nproof(induct T rule: trm.strong_inducts)<br>\n  case(Name a)<br>\n  ...<br>\n  case(Pair N M)<br>\n  ...<br>\nqed</p>\n<p>So we want to keep the cases separate in the tactic, or at least the<br>\nbase case separate from the inductive steps.<br>\nAnd whenever we do a nested proof in the base case, for instance, we can<br>\nrefer directly to 'a' as the induction term. This might not work well in<br>\ngeneral in a tactic if we cannot assume knowledge about the datatype we<br>\ndo the induction on, but in most cases at least, the base case would be<br>\nthe same.<br>\nAny pointers on how this might be achieved, if it is possible?</p>\n<p>Best Regards,<br>\nPalle Raabjerg</p>",
        "id": 294100686,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833679
    },
    {
        "content": "<p>From: Palle Raabjerg &lt;<a href=\"mailto:palle.raabjerg@it.uu.se\">palle.raabjerg@it.uu.se</a>&gt;<br>\nIt occurs to me that I may not have been very clear or specific in my<br>\nprevious mail on this subject. I am also wondering: Would this be more<br>\nappropriate for the [isabelle-dev] list, as we are dealing with Isabelle/ML?</p>\n<p>But in short, what I want to do is automate/manipulate Isar style<br>\nstructured proofs in ML.</p>\n<p>Since the last mail I have been looking around to find out more. The<br>\nIsabelle Programming Tutorial has a section intended for the subject of<br>\nstructured proofs in ML. But that section is marked TBD, and there is<br>\nonly a very short example on a single page.<br>\nThe Isabelle/Isar Implementation Manual has a chapter intended for Isar<br>\n(supposedly to explain how to manipulate Isar style proofs on the ML<br>\nlevel). It contains the empty sections \"Proof commands\", \"Proof methods\"<br>\nand \"Attributes\".</p>\n<p>If we look at the source files, it would seem that Pure/Isar/proof.ML<br>\ncorresponds to \"Proof commands\", Pur/Isar/method.ML corresponds to<br>\n\"Proof methods\" and Pure/Isar/attrib.ML to \"Attributes\". And indeed,<br>\nmany of the functions look interesting to me. I have been experimenting<br>\na bit, but much of it still feels like a bit of a mystery.</p>\n<p>But am I on the right track at least?<br>\nI may well be on the wrong track, in which case most of the questions<br>\nbelow are probably pointless.</p>\n<p>It seems clear that most of the functions in proof.ML manipulate a proof<br>\nstate. 'Proof.init @{context}' will give me a new (empty) proof state,<br>\nwhich looks promising. I can populate the state with facts using<br>\nProof.put_facts and so on, but have so far been unable to give the state<br>\na goal.</p>\n<p>Using 'Proof.theorem_i' as follows:<br>\nProof.theorem_i NONE (K I) [[(@{prop \"A ==&gt; A\"}, [])]] @{context}<br>\nseems to yield a state with a stack of 3 nodes, the _second_ node<br>\nincluding the goal \"A ==&gt; A\", the other two empty. Puzzling. Maybe<br>\ntheorem_i is not what I am looking for.</p>\n<p>So a few questions on this:<br>\nWhat is the intention of Proof.theorem/theorem_i?<br>\nHow do we get an initial state with a goal we want to prove?<br>\nIs state-manipulation a recommended way of doing this in ML?<br>\nI am under the impression that the node stack corresponds to the levels<br>\n(scopes) of an Isar proof. Is that correct?</p>\n<p>Moving on to possibly the most puzzling subject: Methods. Or Proof<br>\nmethods, as the implementation manual seems to call it.<br>\nThere are two prevalent Method types seen in method.ML and proof.ML:<br>\nMethod.method and Method.text</p>\n<p>A Method.method is simply a function type: thm list -&gt; cases_tactic<br>\nThere are a number of basic methods in method.ML that seem to correspond<br>\nto some basic tactics (assumption, erule, drule...), and Method.text can<br>\nbe a 'Basic of (Proof.context -&gt; method) * Position.T'.<br>\nMethod.text can also be 'Source of src', which seems to indicate that we<br>\nmay be able to include Isar code in a Method.text.</p>\n<p>Intuitively, it seems we should be able to use Proof.apply to apply<br>\nelements of type Method.text to states, and perform proofs that way. But<br>\nthe 'Position.T' element indicates that this is not the whole story.</p>\n<p>So a few more questions:<br>\nWhat are Method.method and Method.text really intended for?<br>\nAre there functions for creating proof methods?<br>\nCan Isar scripts be included in a Method.text element?</p>\n<p>Best Regards,<br>\nThe inquisitive<br>\nPalle Raabjerg</p>",
        "id": 294100945,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833755
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nHi Palle,</p>\n<p>I am afraid I cannot give an answer to all your questions.</p>\n<p>Palle Raabjerg writes:</p>\n<blockquote>\n<p>But in short, what I want to do is automate/manipulate Isar style<br>\nstructured proofs in ML.</p>\n<p>Since the last mail I have been looking around to find out more. The<br>\nIsabelle Programming Tutorial has a section intended for the subject of<br>\nstructured proofs in ML. But that section is marked TBD, and there is<br>\nonly a very short example on a single page.</p>\n</blockquote>\n<p>Sorry. Writing tutorials takes time and it is usually<br>\na thankless task (in terms of paper-counts etc). What<br>\nI thought I will describe in this section is how to <br>\ndeal with manipulations of contexts. If I understood <br>\nyour original question correctly, this will not be of<br>\nmuch help to you.</p>\n<blockquote>\n<p>Using 'Proof.theorem_i' as follows:<br>\nProof.theorem_i NONE (K I) [[(@{prop \"A ==&gt; A\"}, [])]] @{context}<br>\nseems to yield a state with a stack of 3 nodes, the _second_ node<br>\nincluding the goal \"A ==&gt; A\", the other two empty. Puzzling. Maybe<br>\ntheorem_i is not what I am looking for.</p>\n</blockquote>\n<p>Usually, if you want to set up a goal to be proved, then you<br>\nneed to use the function Goal.prove. For this you need a tactic <br>\nthat completely solves the goal. Not sure whether this is what<br>\nyou want.</p>\n<blockquote>\n<p>What is the intention of Proof.theorem/theorem_i?</p>\n</blockquote>\n<p>The function theorem is for \"outer layers\" where the terms<br>\nare given as strings. Theorem_i is the \"internal\" interface<br>\nwhere parsing has been already done and terms are given<br>\nas \"real\" terms. Having said that, forget this convention <br>\nquickly, as it is already obsolete. I think today, functions<br>\nfor \"outer layers\" are called foo_cmd, while the internal<br>\nfunctions are just called foo.</p>\n<p>To give more help, maybe it would be helpful if you describe <br>\nexactly what you like to do. In your last email you described <br>\nyour problem in abstract terms. Judging from the absence of<br>\nreplies, it seems nobody was able to give an appropriate<br>\nanswer. Maybe a concrete example or even a small theory<br>\nfile would be more helpful....though no promises ;o)</p>\n<p>Best wishes,<br>\nChristian</p>",
        "id": 294101022,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833782
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFine-grained control over the \"structure\" of proof states is usually very <br>\ndelicate, but it can be done.  The proof methods \"induct\" and <br>\n\"nominal_induct\" are the most sophisticated examples for that.</p>\n<p>As a starting point, I recommend looking at the relatively new FOCUS <br>\ncombinators in Isabelle2009-1/src/Pure/subgoal.ML -- the plain <br>\nSubgoal.focus versions together with Isar.goal() in interactive mode <br>\nshould give you some idea how to get hold of the basic fix/assume/show <br>\nlayout of a goal state.</p>\n<p>Makarius</p>",
        "id": 294101036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833786
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 12 Feb 2010, Palle Raabjerg wrote:</p>\n<blockquote>\n<p>It occurs to me that I may not have been very clear or specific in my <br>\nprevious mail on this subject. I am also wondering: Would this be more <br>\nappropriate for the [isabelle-dev] list, as we are dealing with <br>\nIsabelle/ML?</p>\n</blockquote>\n<p>Isabelle/ML is definitely part of the \"user space\" of Isabelle.  As long <br>\nas we speak about official releases for end-users, this is the correct <br>\nmailing list.</p>\n<blockquote>\n<p>If we look at the source files, it would seem that Pure/Isar/proof.ML<br>\ncorresponds to \"Proof commands\", Pur/Isar/method.ML corresponds to<br>\n\"Proof methods\" and Pure/Isar/attrib.ML to \"Attributes\". And indeed,<br>\nmany of the functions look interesting to me. I have been experimenting<br>\na bit, but much of it still feels like a bit of a mystery.</p>\n<p>But am I on the right track at least?<br>\nI may well be on the wrong track, in which case most of the questions<br>\nbelow are probably pointless.</p>\n</blockquote>\n<p>I am impressed how far you've got in figuring out the sources.  These <br>\nmodules implement the main concepts of the Isar proof language.  Chapter 2 <br>\nof the Isar reference manual provides some high-level explanations of all <br>\nthis. You do not need to understand all these details to implement <br>\nadvanced proof methods, though.</p>\n<blockquote>\n<p>It seems clear that most of the functions in proof.ML manipulate a proof <br>\nstate. 'Proof.init @{context}' will give me a new (empty) proof state, <br>\nwhich looks promising. I can populate the state with facts using <br>\nProof.put_facts and so on, but have so far been unable to give the state <br>\na goal.</p>\n<p>Using 'Proof.theorem_i' as follows:<br>\nProof.theorem_i NONE (K I) [[(@{prop \"A ==&gt; A\"}, [])]] @{context}<br>\nseems to yield a state with a stack of 3 nodes, the _second_ node<br>\nincluding the goal \"A ==&gt; A\", the other two empty. Puzzling. Maybe<br>\ntheorem_i is not what I am looking for.</p>\n</blockquote>\n<p>It is unlikely that you will need any of this.  The proof state is already <br>\ngiven by the user -- you can access it via Isar.state() in interactive ML.</p>\n<p>The Proof.theorem_i function is the most basic entry point for producing a <br>\ntoplevel goal; the 'theorem' command does this in regular user space (with <br>\nlots of extra sophistication).  The stack implements Isar block structure <br>\n-- just an internal detail.</p>\n<blockquote>\n<p>How do we get an initial state with a goal we want to prove?</p>\n</blockquote>\n<p>lemma \"A ==&gt; A\"<br>\n   ML_prf {* Isar.goal() *}</p>\n<p>You can also say this:</p>\n<p>apply (tactic {* ... *})</p>\n<p>but you need to give a closed ML expression of type tactic on the spot, so <br>\nit is advisable to play around with ML_prf or ML_val first.</p>\n<blockquote>\n<p>Is state-manipulation a recommended way of doing this in ML?</p>\n</blockquote>\n<p>No, unless you want to come up with new primary Isar commands, which <br>\nusually requires several years of intensive study of the machinery.</p>\n<blockquote>\n<p>I am under the impression that the node stack corresponds to the levels <br>\n(scopes) of an Isar proof. Is that correct?</p>\n</blockquote>\n<p>Yes.  User code normally only needs the top-of-stack, though.</p>\n<blockquote>\n<p>Moving on to possibly the most puzzling subject: Methods. Or Proof <br>\nmethods, as the implementation manual seems to call it. There are two <br>\nprevalent Method types seen in method.ML and proof.ML: Method.method and <br>\nMethod.text</p>\n</blockquote>\n<p>Method.method is what you need; the Method.text merely represents source <br>\ntext.</p>\n<blockquote>\n<p>Are there functions for creating proof methods?</p>\n</blockquote>\n<p>Method.METHOD etc.  You should also grep for method_setup or Method.setup <br>\nin the existing theory/ML sources to get an idea how it is usually done <br>\n(but there are occasionally old forms that should not be copied blindly).</p>\n<p>Wrapping up a tactic as a proof method involves some standard boiler <br>\nplate, but the hard part is the logic behind the tactic itself.  Maybe we <br>\nshould go back to some concrete examples from you nominal application.</p>\n<blockquote>\n<p>Can Isar scripts be included in a Method.text element?</p>\n</blockquote>\n<p>Not really.  You can probably ignore Method.text altogether for your <br>\npurposes.</p>\n<p>Makarius</p>",
        "id": 294101049,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833791
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAccording to Stefan Berghofer, this is how to implement sophisticated <br>\nproof tools:</p>\n<p>(1) Make some typical examples (in plain Isar source language).<br>\n   (2) You see the general idea.<br>\n   (3) Implement the general idea in ML.</p>\n<p>Steps 2 and 3 are not so trivial.  I recommend to take the concrete Isar <br>\nproofs and inspect intermediate situations with Isar.goal(), Isar.state() <br>\netc. in ML.  Don't try to reconstruct situtions in ML by hand, let Isar <br>\nproduce them and merely look at the results.</p>\n<p>For the actual goal manipulation part, combinators like SUBPROOF or <br>\nSubgoal.FOCUS can be helpful, beause they represent Isar structure quite <br>\nclosely at the ML level.</p>\n<p>Makarius</p>",
        "id": 294101060,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833797
    }
]