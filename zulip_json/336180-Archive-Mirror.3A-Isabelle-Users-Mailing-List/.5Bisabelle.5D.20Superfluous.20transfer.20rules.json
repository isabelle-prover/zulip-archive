[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nWhen I use the transfer package, I frequently have to prove extra transfer rules <br>\nfor some operations when tuples are involved. Some examples can be found in <br>\nCoinductive_Stream.thy in the AFP entry Coinductive (development version <br>\ndd789a56473c). Here's a typical one:</p>\n<p>lemma SCons_prod_transfer [transfer_rule]:<br>\n   \"(prod_rel op = op = ===&gt; cr_stream ===&gt; cr_stream) LCons SCons\"<br>\nunfolding prod_rel_eq by(rule SCons.transfer)</p>\n<p>These rules are straightforward to prove (by unfolding prod_rel_eq, fun_rel_eq, <br>\netc. and using existing transfer rules), so I would prefer not having to state <br>\nand declare them separately. Is this to due insufficient declarations of mine or <br>\na general limitation of the current implementation?</p>\n<p>In case of the former: What do I have to do to avoid these kind of boilerplate <br>\nrules?</p>\n<p>Andreas</p>",
        "id": 294162717,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853738
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nThis is a limitation of the current implementation -- not of the<br>\ntransfer method per se, but of the form of transfer rules generated by<br>\nthe lift_definition command.</p>\n<p>When lifting a polymorphic constant, the ideal transfer rule should<br>\nhave a form that looks just like the constant's type signature, with<br>\nrelation variables in place of type variables. For quotient types with<br>\ntype parameters, the transfer relation should ideally also have a<br>\nrelation parameter too, like this:</p>\n<p>SCons_prod.transfer [transfer_rule]:<br>\n \"(A ===&gt; cr_stream A ===&gt; cr_stream A) LCons SCons\"</p>\n<p>A slightly less ambitious implementation might just replace<br>\noccurrences of \"op =\" at type 'a with a variable, which is separately<br>\nconstrained to be an equality relation:</p>\n<p>definition \"is_equality R = (R = (op =))\"<br>\nlemma is_equality_intros [transfer_rule]:<br>\n  \"is_equality (op =)\"<br>\n  \"is_equality A ==&gt; is_equality B ==&gt; is_equality (fun_rel A B)\"<br>\n  \"is_equality A ==&gt; is_equality B ==&gt; is_equality (prod_rel A B)\"</p>\n<p>SCons_prod.transfer [transfer_rule]:<br>\n \"is_equality A ==&gt; (A ===&gt; cr_stream ===&gt; cr_stream) LCons SCons\"</p>\n<p>I tested the latter style of rules on Coinductive_Stream.thy, and<br>\neverything seems to work fine with just one transfer rule per<br>\nconstant. I guess we'll try to make lift_definition generate rules<br>\ndirectly in this format.</p>\n<p>Anyway, thanks for the feedback on lifting/transfer!</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294162756,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853756
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Brian,</p>\n<p>Thanks for looking into this.</p>\n<blockquote>\n<p>A slightly less ambitious implementation might just replace<br>\noccurrences of \"op =\" at type 'a with a variable, which is separately<br>\nconstrained to be an equality relation:</p>\n<p>definition \"is_equality R = (R = (op =))\"<br>\nlemma is_equality_intros [transfer_rule]:<br>\n   \"is_equality (op =)\"<br>\n   \"is_equality A ==&gt;  is_equality B ==&gt;  is_equality (fun_rel A B)\"<br>\n   \"is_equality A ==&gt;  is_equality B ==&gt;  is_equality (prod_rel A B)\"</p>\n<p>SCons_prod.transfer [transfer_rule]:<br>\n  \"is_equality A ==&gt;  (A ===&gt;  cr_stream ===&gt;  cr_stream) LCons SCons\"<br>\nThis approach looks promising because most of the other rules I have also just <br>\nto thread \"op =\" through.</p>\n</blockquote>\n<blockquote>\n<p>Anyway, thanks for the feedback on lifting/transfer!<br>\nWhen I'm at it: There's one FIXME comment in Coinductive_Stream. szip_iterates <br>\nis actually lzip_iterates from Coinductive_List_Lib lifted over the morphism. <br>\nUnfortunately, the transfer method only replaces the left hand side, but not the <br>\nright hand side, so I had to prove the equation directly.</p>\n</blockquote>\n<p>If you have time to look into that, it would be great to know why it does not <br>\nwork here as expected.</p>\n<ul>\n<li>Andreas</li>\n</ul>",
        "id": 294162826,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853775
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Thu, Jun 28, 2012 at 10:23 AM, Andreas Lochbihler<br>\n&lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt; wrote:</p>\n<blockquote>\n<blockquote>\n<p>A slightly less ambitious implementation might just replace<br>\noccurrences of \"op =\" at type 'a with a variable, which is separately<br>\nconstrained to be an equality relation:</p>\n<p>definition \"is_equality R = (R = (op =))\"<br>\nlemma is_equality_intros [transfer_rule]:<br>\n  \"is_equality (op =)\"<br>\n  \"is_equality A ==&gt;  is_equality B ==&gt;  is_equality (fun_rel A B)\"<br>\n  \"is_equality A ==&gt;  is_equality B ==&gt;  is_equality (prod_rel A B)\"</p>\n<p>SCons_prod.transfer [transfer_rule]:<br>\n \"is_equality A ==&gt;  (A ===&gt;  cr_stream ===&gt;  cr_stream) LCons SCons\"<br>\n[...]<br>\nWhen I'm at it: There's one FIXME comment in Coinductive_Stream.<br>\nszip_iterates is actually lzip_iterates from Coinductive_List_Lib lifted<br>\nover the morphism. Unfortunately, the transfer method only replaces the left<br>\nhand side, but not the right hand side, so I had to prove the equation<br>\ndirectly.</p>\n</blockquote>\n<p>If you have time to look into that, it would be great to know why it does<br>\nnot work here as expected.</p>\n</blockquote>\n<p>It seems that this was an instance of the same kind of problem. After<br>\ngeneralizing the transfer rules, the transfer proof works now. See the<br>\nchangeset on AFP:</p>\n<p><a href=\"http://afp.hg.sourceforge.net/hgweb/afp/afp/rev/a05edd1f98f8\">http://afp.hg.sourceforge.net/hgweb/afp/afp/rev/a05edd1f98f8</a></p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294162841,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853781
    }
]