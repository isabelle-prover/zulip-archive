[
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nHi all proof lovers,</p>\n<p>After the Isar reference, I typed this in Isabelle/jEdit:</p>\n<p>notepad<br>\n   begin<br>\n     fix n :: nat<br>\n     have \"P n\"<br>\n     proof (induct n)<br>\n       case 0<br>\n         show ?case sorry<br>\n     next<br>\n       case (Suc n)<br>\n         from Suc.hyps show ?case sorry<br>\n    qed<br>\n   end</p>\n<p>As the syntax from the PDF is not always exact (mainly characters issues),  <br>\nI though there was an error there too, and felt “(Suc n)” should be  <br>\nenclosed in quote, as an HOL expression. But doing so, I get this in the  <br>\nOutput pan:</p>\n<p>Unknown case: \"(Suc n)\"</p>\n<p>Is “(Suc n)”, and HOL or Isar expression? If that's an HOL expression as I  <br>\nbelieve, then why do I get that error report?</p>",
        "id": 294220531,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897215
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nYannick,</p>\n<p>You can get the sources for any of the Isabelle2012 documentation.</p>\n<p>The direct link is this:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/archive/21c42b095c84.tar.gz\">http://isabelle.in.tum.de/repos/isabelle/archive/21c42b095c84.tar.gz</a></p>\n<p>The link that would get you to the link for that file is here:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/\">http://isabelle.in.tum.de/repos/isabelle/</a></p>\n<p>You click on \"files\" beside \"2 months ago Isabelle2012\". You would then <br>\nclick on \"gz\" at the top of the page.</p>\n<p>You unzip the tar file, and for isar-ref.pdf, you find the folder  <br>\n\"isabelle-21c42b095c84\\doc-src\\IsarRef\\Thy\".</p>\n<p>You then have to search around on those files with grep or something to <br>\nfind the file that contains the desired code.</p>\n<p>The source files keep you from having to type in the code, keep you from <br>\ncopying bogus characters from the PDF, and they teach you something <br>\nabout how the author produced what you see in the PDF.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294220648,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897284
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nLe Wed, 01 Aug 2012 23:30:18 +0200, Gottfried Barrow  <br>\n&lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt; a écrit:</p>\n<blockquote>\n<p>You can get the sources for any of the Isabelle2012 documentation.</p>\n<p>The direct link is this:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/archive/21c42b095c84.tar.gz\">http://isabelle.in.tum.de/repos/isabelle/archive/21c42b095c84.tar.gz</a></p>\n<p>The link that would get you to the link for that file is here:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/\">http://isabelle.in.tum.de/repos/isabelle/</a></p>\n</blockquote>\n<p>Thanks Gottfried, those links are worth to be bookmarked :-P</p>\n<blockquote>\n<p>You click on \"files\" beside \"2 months ago Isabelle2012\". You would then  <br>\nclick on \"gz\" at the top of the page.</p>\n<p>You unzip the tar file, and for isar-ref.pdf, you find the folder   <br>\n\"isabelle-21c42b095c84\\doc-src\\IsarRef\\Thy\".</p>\n<p>You then have to search around on those files with grep or something to  <br>\nfind the file that contains the desired code.<br>\n</p>\n</blockquote>\n<p>I got it, that's in “Synopsis.thy”, and modulo the indentation, that's the  <br>\nsame, there is no quote too:</p>\n<p>notepad<br>\n   begin<br>\n     fix n :: nat<br>\n     have \"P n\"<br>\n     proof (induct n)<br>\n       case 0<br>\n       show ?case sorry<br>\n     next<br>\n       case (Suc n)<br>\n       from Suc.hyps show ?case sorry<br>\n     qed<br>\n   end</p>\n<p>So, what's the expression type of “(Suc n)” at the line whose text is  <br>\n“case (Suc n)”? Isn't “(Suc n)” an HOL expression? It appears in the text  <br>\nas if it was an Isar expression, but I feel sure it's not. I'm lost with  <br>\nthat point.</p>\n<blockquote>\n<p>The source files keep you from having to type in the code, keep you from  <br>\ncopying bogus characters from the PDF, and they teach you something  <br>\nabout how the author produced what you see in the PDF.</p>\n</blockquote>\n<p>They also will teach me a bit of LaTex, which I've never practiced  <br>\n(red‑face)</p>",
        "id": 294220765,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897351
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI don't know much more than you, so you should keep that in mind for the <br>\nfuture.</p>\n<p>\"Suc\" is the successor function, and it comes from <br>\n\"Isabelle2012/src/HOL/Nat.thy\". This is where those \"declare\" commands <br>\ncome in handy. I attach \"I.thy\". It has all the declare and print <br>\ncommands I found that looked useful. Delete what you don't want, or <br>\ndon't use any of it. I keep it open in jEdit all the time, that's why it <br>\nhas a short name.</p>\n<p>In particular, I used:</p>\n<p>declare[[names_unique=true]]   declare[[show_consts=true]]</p>\n<p>In the output panel, it shows me:</p>\n<p>constants:<br>\n   prop :: (prop ⇒ prop)<br>\n   Nat.Suc :: (Nat.nat ⇒ Nat.nat)</p>\n<p>Isar as a language is independent of HOL. Isar can be used in any logic, <br>\nsuch as Isabelle/ZF.</p>\n<p>HOL is one of the many logics in Isabelle2012/src, although it's the <br>\nmost popular one.</p>\n<p>\"Expression\" is an ambiguous word that can be used in lots of different <br>\nways.</p>\n<p>Isar, as I understand it, is a link between the \"inner syntax\" and the <br>\n\"outer syntax\", where HOL expressions would be \"inner syntax\". This is <br>\ncovered in Chapter 3 of isar-ref.pdf, and on Page 5 of prog-prove.pdf. I <br>\nthink \"outer syntax\" is related to the meta-logic which comes from <br>\n\"src/Pure\". Isar is tied into Pure, and Pure is the foundation for <br>\nlogics such as HOL.</p>\n<p>Putting in extraneous information here, where I use the ambiguous term <br>\n\"expression\", I'll go out on a limb and say, \"A HOL expression is always <br>\nan Isar expression, but an Isar expression is not always a HOL expression.\"</p>\n<p>I attach a screen shot to show you the useful information you get from <br>\nfive of the declare commands being true.</p>\n<p>Regards,<br>\nGB<br>\n<a href=\"/user_uploads/14278/DQSAses0AgE3-iIcPOTmYQwP/case_Suc_n.png\">case_Suc_n.png</a><br>\n<a href=\"/user_uploads/14278/sUetNWZEBgdDZKri0K1-v-vy/I.thy\">I.thy</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/DQSAses0AgE3-iIcPOTmYQwP/case_Suc_n.png\" title=\"case_Suc_n.png\"><img src=\"/user_uploads/14278/DQSAses0AgE3-iIcPOTmYQwP/case_Suc_n.png\"></a></div>",
        "id": 294220880,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897428
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nTo answer the original question:</p>\n<p>Here 'case (Suc n)' as well as 'case 0' (above) are part of Isar not <br>\nHOL. We could also just use 'case 0' and 'case Suc', then it is more <br>\nclear that we are just giving names of facts (those names are <br>\nautomatically established when starting with 'proof (induct n)'). The <br>\nvariant 'case (Suc n)' of 'case Suc' is just a nicety to allow giving <br>\nexplicit names to variables (which makes proofs more robust). If you <br>\nwant to see to what fact 'Suc' refers, just use 'from Suc' directly <br>\nbelow the 'case' line.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294221006,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897492
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nChristian already gave you the answer, but I was hot on the trail <br>\nbecause it occurred to me to use \"print_theorem\" under \"case (Suc n)\", <br>\nwhich Christian had given as a tip some days ago. This all ties into <br>\ndifferentiating between Isar and HOL.</p>\n<p>\"case\" is an Isar command that's described on page 129 of isar-ref.pdf. <br>\nIf you try to put quotes like this:</p>\n<p>case (\"Suc n\")</p>\n<p>then you get the error:</p>\n<p>Outer syntax error: name declaration expected, but keyword ) was found</p>\n<p>The outer syntax error substantiates that \"case\" is not HOL syntax, <br>\nbecause HOL syntax is inner syntax.</p>\n<p>Put \"print_theorems\" under \"case (Suc n)\", and you get this:</p>\n<p>facts:<br>\n&lt;unnamed&gt;: ((P∷(Nat.nat ⇒ HOL.bool)) (n∷Nat.nat))<br>\n   local.Suc: ((P∷(Nat.nat ⇒ HOL.bool)) (n∷Nat.nat))</p>\n<p>Somebody like me might not know what it means, but it definitely tells <br>\nme that \"Suc\" isn't the the HOL function \"Nat.Suc::(nat =&gt; nat)\", like I <br>\nhad told you. You can't always know what something means, but you can <br>\nknow what it isn't sometimes.</p>\n<p>Page 45 of prog-prove.pdf explains \"case\".</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294221137,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897560
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nChris,</p>\n<p>Is this right? There's Isar syntax, which is defined in Pure. There's <br>\nHOL syntax, which is defined using Isar keywords. And there is the HOL <br>\nlogic which is a combination of Isar syntax and HOL syntax.</p>\n<p>What I'm thinking about in particular is that the proof of a HOL theorem <br>\nis a HOL proof, but it may contain Isar commands.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294221284,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897627
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Gottfried,</p>\n<p>I would really prefer to hand this question over to a wizard ;)</p>\n<p>But let me give it a try. What I think (but that does not necessarily <br>\nmean that it's true) is the following:</p>\n<ul>\n<li>Pure is a kind of minimal logic independent from Isar.</li>\n<li>\n<p>Isar syntax is not part of Pure, but the \"Isar-language\" is <br>\nwell-integrated on top of Pure.</p>\n</li>\n<li>\n<p>HOL syntax is defined via commands (not sure whether those are really <br>\npart of Isar or rather independent; my guess would be that they are just <br>\nconvenience tools built on top of the Isabelle/ML layer... but then, <br>\nwhat is not?)</p>\n</li>\n<li>\n<p>HOL as a logic is independent from Isar.</p>\n</li>\n<li>\n<p>Proofs are irrelevant, thus they can't be part of the logic, i.e., <br>\nthey are not part of HOL.</p>\n</li>\n<li>\n<p>In the end, a proof is just a step-wise manipulation of the abstract <br>\ndata type 'thm' through a well-defined interface (sometimes called the <br>\ntrusted Kernel).</p>\n</li>\n</ul>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294221319,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897646
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nChris, thanks for the explanation. There's lots of interesting <br>\ninformation there, but I reduced everything down to this statement, \"I <br>\njust want to know what word to use for Isabelle's programming language\". <br>\nI was in doubt for a while, and then it occurred to me, \"Oh yea, it is <br>\ncalled the Isar reference manual\".</p>\n<p>In Chapter 5, page 76, it says, \"Isabelle/Isar theories are defined via <br>\ntheory files...\" It then says that \"theory\" and \"end\" are Isar commands.</p>\n<p>As far as I'm concerned, everything between \"theory\" and \"end\" is the <br>\nIsar programming language. There is the ML in the \"ML{ ... }\", but other <br>\nthan that, it's all Isar to me now.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294221329,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897652
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThe Isar command \"case\" (in its long form) takes a case name and a list <br>\nof inner syntax expressions (probably what you mean with HOL <br>\nexpressions). The case name \"Suc\" happens to be the same as the name of <br>\nthe constructor \"Suc\"; but this is just coincidence:</p>\n<p>notepad<br>\n   begin<br>\n   fix n :: nat and P<br>\n   proof (induct n rule: nat.induct[case_names Foo Bar])<br>\n     case Foo show ?case sorry<br>\n   next<br>\n     case (Bar n) show ...</p>",
        "id": 294221362,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897670
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 8/1/2012 9:18 PM, Christian Sternagel wrote:</p>\n<blockquote>\n<ul>\n<li>Pure is a kind of minimal logic independent from Isar.</li>\n<li>Isar syntax is not part of Pure, but the \"Isar-language\" is <br>\nwell-integrated on top of Pure.</li>\n<li>HOL syntax is defined via commands (not sure whether those are <br>\nreally part of Isar or rather independent; my guess would be that they <br>\nare just convenience tools built on top of the Isabelle/ML layer... <br>\nbut then, what is not?)</li>\n</ul>\n</blockquote>\n<p>My questions about syntax end up being the easy (easier, but not <br>\ncompletely answered) questions. Your reply below as to what HOL is as a <br>\nlogic becomes the \"not so easily understood\" reply.</p>\n<p>Here's what I found: Isar outer syntax is defined in <br>\n~/src/Pure/isar_syn.ML.</p>\n<p>(*  Title:      Pure/Isar/isar_syn.ML<br>\n     Author:     Markus Wenzel, TU Muenchen</p>\n<p>Isar/Pure outer syntax.<br>\n*)</p>\n<p>So Isar/Pure outer syntax is used to define inner syntax (I guess), such <br>\nas HOL's inner syntax, because in that file there are the usual Isar <br>\ncommands that are documented in isar-ref.pdf:</p>\n<p>line 154: Outer_Syntax.command (\"judgement<br>\nline 158: Outer_Syntax.command (\"consts<br>\nline 207: Outer_Syntax.command (\"axioms<br>\nline 219: Outer_Syntax.command (\"defs<br>\nline 228: Outer_Syntax.command (\"definition<br>\nline 249: Outer_Syntax.local_theory (\"notation<br>\netc.</p>\n<p>Well, life is not so simple. \"datatype\" is not specific to Isar. It's <br>\ndefined in ~/src/HOL/Datatype.thy, and is somehow defined with <br>\n~/src/HOL/Tools/Datatype/datatype.ML.</p>\n<p>I type \"datatype\" without typing anything else, and I get the error <br>\n\"Outer syntax error\".</p>\n<p>That's enough of that stuff for now.</p>\n<blockquote>\n<ul>\n<li>HOL as a logic is independent from Isar.</li>\n<li>Proofs are irrelevant, thus they can't be part of the logic, i.e., <br>\nthey are not part of HOL.</li>\n<li>In the end, a proof is just a step-wise manipulation of the abstract <br>\ndata type 'thm' through a well-defined interface (sometimes called the <br>\ntrusted Kernel).</li>\n</ul>\n</blockquote>\n<p>Yea, so I guess we could do it all in ML, where ML is the language of <br>\nthe foundation.</p>\n<p>Your second two statements are the \"something to think about\".</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294221426,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897690
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nThis calls for a \"dude expression\" using \"dude syntax\" interpreted with <br>\nstandard \"dude semantics\", as in, \"Man, dude, if you (meaning me) would <br>\nonly open the source files and do some brainless scrolling around, you <br>\nwouldn't clutter up the list with as many emails for a single subject.\"</p>\n<p>At the bottom of ~/src/HOL/Tools/Datatype/datatype.ML, we get this:</p>\n<p>val _ =<br>\n   Outer_Syntax.command @{command_spec \"datatype\"} \"define inductive <br>\ndatatypes\"<br>\n     (Parse.and_list1 spec_cmd</p>\n<blockquote>\n<blockquote>\n<p>(Toplevel.theory o (snd oo add_datatype_cmd <br>\nDatatype_Aux.default_config)));</p>\n</blockquote>\n</blockquote>\n<p>So some HOL syntax is defined with Isar commands, and some HOL syntax is <br>\ndefined with ML, where some HOL syntax is added as outer syntax.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294221432,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897695
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\n\"HOL syntax\" is not a very useful term here. In Isabelle/Isar, we <br>\ndistinguish between outer and inner syntax. The inner syntax is the <br>\nsyntax used to input terms (and types). Apart from trivial cases, inner <br>\nsyntax needs to be quoted.</p>\n<p>The outer syntax is everything else. Most of it is already part of Pure <br>\n(i.e. independent of any logic), mainly everything which makes up proof <br>\nand document structure; but logics often add additional commands for <br>\nlogic-specific operations (e.g. \"fun\" and \"inductive\" for HOL).</p>\n<p>Both syntaxes can be extended, but after bootstrapping, the outer syntax <br>\nusually stays pretty static; where as the inner syntax is changed with <br>\nany definition or syntax annotation you issue. I think, by default there <br>\nis no tool on the Isar level which would modify the outer syntax (just <br>\nas there is no construct on the term level, which would modify the inner <br>\nsyntax).</p>\n<p>-- Lars.</p>",
        "id": 294221442,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897701
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOne last comment, hopefully.</p>\n<p>Outer_syntax is defined in src/Pure/Isar/outer_syntax.ML:</p>\n<p>(*  Title:      Pure/Isar/outer_syntax.ML<br>\n         Author:     Markus Wenzel, TU Muenchen</p>\n<p>The global Isabelle/Isar outer syntax.</p>\n<p>I was wanting to start using the phrase \"the Pure programming language\", <br>\nbut \"Outer_syntax.command\" is an Isar command, so the HOL outer syntax <br>\n\"datatype\" is defined as HOL syntax using an Isar command.</p>\n<p>My use of \"the Pure programming language\" will have to wait until I <br>\nunderstand whether there's any HOL syntax which can be defined using ML, <br>\nbut which cannot be defined using Isar.</p>\n<p>I like to have the vocabulary locked down. I go with these ideas until <br>\nsomeone tells me different.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294221453,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897707
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 8/2/2012 10:42 AM, Lars Noschinski wrote:</p>\n<blockquote>\n<p>On 02.08.2012 15:58, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>So some HOL syntax is defined with Isar commands, and some HOL syntax is<br>\ndefined with ML, where some HOL syntax is added as outer syntax.</p>\n</blockquote>\n<p>\"HOL syntax\" is not a very useful term here. In Isabelle/Isar, we <br>\ndistinguish between outer and inner syntax. The inner syntax is the <br>\nsyntax used to input terms (and types). Apart from trivial cases, <br>\ninner syntax needs to be quoted.</p>\n</blockquote>\n<p>Lars, I sent the last email before I got this one. But in prog-prove, <br>\nTobias says,</p>\n<p>\"When Isabelle prints a syntax error message, it refers to the HOL <br>\nsyntax as the inner syntax<br>\n    and the enclosing theory language as the outer syntax.\"</p>\n<p>I'm trying to pin down \"what is the Isar programming language\". I want <br>\nto speak of one programming language, \"Isar\", but if it's not that <br>\nsimple, then I want to be more sophisticated about it.</p>\n<p>I understand that between \"theory MyTheory\" and \"end\" in \"MyTheory.thy\" <br>\nthere are things like Latex and ML. But I can consider any of that as <br>\npart of an argument to an Isar command like \"ML{ .... }\" or \"text{ ... <br>\n}\".  I'm trying to figure out if there's anything between \"theory\" and <br>\n\"end\" that someone would have to say, \"Most of what's between 'theory' <br>\nand 'end' is Isar, but there are exceptions.\"</p>\n<blockquote>\n<p>The outer syntax is everything else. Most of it is already part of <br>\nPure (i.e. independent of any logic), mainly everything which makes up <br>\nproof and document structure; but logics often add additional commands <br>\nfor logic-specific operations (e.g. \"fun\" and \"inductive\" for HOL).</p>\n</blockquote>\n<p>But if you can't combine \"HOL syntax\" with \"inner syntax\" and \"outer <br>\nsyntax\", then it makes it hard to talk about what's specific to HOL. <br>\nThere's the HOL specific outer syntax \"datatype\". I want to call that <br>\n\"HOL syntax\", or at least \"HOL outer syntax\".</p>\n<blockquote>\n<p>Both syntaxes can be extended, but after bootstrapping, the outer <br>\nsyntax usually stays pretty static; where as the inner syntax is <br>\nchanged with any definition or syntax annotation you issue. I think, <br>\nby default there is no tool on the Isar level which would modify the <br>\nouter syntax (just as there is no construct on the term level, which <br>\nwould modify the inner syntax).<br>\n</p>\n</blockquote>\n<p>This brings up \"Outer_syntax.command\", which I mentioned in the email I <br>\nsent out before this one.</p>\n<p>I'm going to call \"Outer_syntax.command\" an Isar command, and it's used <br>\nin Datatype.thy to define \"datatype\" as outer syntax. If I don't call it <br>\nan Isar command, then what am I going to call it? If I call it an ML <br>\ncommand or a Pure command, then I can't say that Isar is the programming <br>\nlanguage that's being used to define \"datatype\". If that's the case, <br>\nthen there's a lower level programming language that I'm using. If there <br>\nis, I want to know what to call it.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294221465,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897713
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nML is a programming language. You write programs in ML.</p>\n<p>Pure is not a programming language. It is a logical formalism, specifically, the logical framework that is the basis of Isabelle.</p>\n<p>HOL is also a programming language, namely higher-order logic.</p>\n<p>Isar is a formal language for proof developments. These are not programs and it is not a programming language.</p>\n<p>Larry Paulson</p>",
        "id": 294221475,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897719
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 8/2/2012 11:17 AM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>ML is a programming language. You write programs in ML.</p>\n<p>Pure is not a programming language. It is a logical formalism, specifically, the logical framework that is the basis of Isabelle.</p>\n<p>HOL is also a programming language, namely higher-order logic.</p>\n<p>Isar is a formal language for proof developments. These are not programs and it is not a programming language.</p>\n</blockquote>\n<p>Larry, thanks. I'm making some progress here. I've acquired some <br>\nresolution for the word \"language\". A language that's used on a computer <br>\nis not necessarily a \"programming language\". Sounds reasonable. I guess. <br>\nIt's hard for me not to think of a sequence of instructions as a program.</p>\n<p>Now all I have to do is figure out exactly what the \"Isar proof <br>\nlanguage\" is, and what between \"theory\" and \"end\" isn't Isar.</p>\n<p>It gets a little difficult to sort it all out. ML is a programming <br>\nlanguage which is used to implement Isar, which is a formal language, <br>\nbut not a programming language, and Isar is used to implement HOL, which <br>\nis a programming language, and the syntax for Isar and \"HOL syntax\" is <br>\nall intertwined, where you occasionally drop down into the ML <br>\nprogramming language to use an \"Isar command\", like <br>\n\"Outer_syntax.command\", to define syntax for the HOL programming language.</p>\n<p>I'll check out on this thread, and store away any other comments that <br>\ncome in for future reference.</p>\n<p>Regards,<br>\nGB</p>\n<blockquote>\n<p>Larry Paulson</p>\n<p>On 2 Aug 2012, at 16:46, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>One last comment, hopefully.</p>\n<p>Outer_syntax is defined in src/Pure/Isar/outer_syntax.ML:</p>\n<p>(*  Title:      Pure/Isar/outer_syntax.ML<br>\n        Author:     Markus Wenzel, TU Muenchen</p>\n<p>The global Isabelle/Isar outer syntax.</p>\n<p>I was wanting to start using the phrase \"the Pure programming language\", but \"Outer_syntax.command\" is an Isar command, so the HOL outer syntax \"datatype\" is defined as HOL syntax using an Isar command.</p>\n<p>My use of \"the Pure programming language\" will have to wait until I understand whether there's any HOL syntax which can be defined using ML, but which cannot be defined using Isar.</p>\n<p>I like to have the vocabulary locked down. I go with these ideas until someone tells me different.</p>\n<p>Regards,<br>\nGB</p>\n</blockquote>\n</blockquote>",
        "id": 294221485,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897725
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;</p>\n<ul>\n<li>\n<p>The content of a theory file between 'theory' and the final 'end' is by<br>\n   definition the Isar source language.</p>\n</li>\n<li>\n<p>Isar is a general framework to define \"domain-specific formal<br>\n   languages\".  It allows to nest various sub-languages easily, most<br>\n   notably the Isar proof language.  Other more exotic language embeddings<br>\n   are here:</p>\n</li>\n</ul>\n<p>notepad<br>\nbegin<br>\n   (* Isar proof language here *)<br>\n   fix a b :: nat<br>\n   fix n :: nat<br>\n   assume a: \"⋀m. n + m &gt; 0\"<br>\n     ML_val {*<br>\n       (* ML inside Isar proof context here *)</p>\n<p>(* antiquotation of logical entities here:*)<br>\n       fun foo th = th RS @{thm a}</p>\n<p>(* further nesting: term language inside fact language: *)<br>\n       fun bar th = th RS @{thm a [of \"a + b\"]}<br>\n     *}<br>\nend</p>\n<p>end</p>\n<p>* Note that above the Prover IDE markup will tell you about the formal<br>\n     entities occurring in the nested sublanguages.  E.g. CTRL-hover over<br>\n     \"a + b\" parts will do the same as if they would occur directly as<br>\n     terms within the main Isar source language (statements, proofs).</p>\n<p>* ML has a special role in the game: it is the platform for first<br>\n     bootstrapping the Isar language framework, and later gets re-embedded<br>\n     into the Isar source language, with the above antiquotation<br>\n     mechanisms to get some parts of Isar back into ML.  E.g. like this:</p>\n<p>ML {*<br>\n       val my_thm = @{lemma \"⋀x. x = x\" by (rule refl)}<br>\n     *}</p>\n<p>* Formal latex is another special sub-language.  For example, it allows<br>\n     to embed ML with embedded formal entities like this:</p>\n<p>text {*<br>\n        blah blah; this is mainly {\\LaTeX}, but with some antiquotations<br>\n        @{ML \"<br>\n          (* this is again ML inside the Isar context *)<br>\n          let val my_thm = @{lemma \\\"⋀x. x = x\\\" by (rule refl)}<br>\n          in Thm.prop_of my_thm end\"}<br>\n      *}</p>\n<p>Here the incremental parser of Isabelle/jEdit sometimes gets problems<br>\n     with the nested quotes, but in the end you should get proper formal<br>\n     markup of everything to hover over, and understand this formal<br>\n     gibberish.</p>\n<p>* Outer_syntax.command that was left somewhat myterious above is not<br>\n     very special.  It is just an Isabelle/ML function that defines new<br>\n     Isar commands.  Similar to the ML function Method.setup to define<br>\n     proof methods, but the latter also has an Isar source language<br>\n     counterpart called method_setup; both Method.setup and<br>\n     method_setup take an ML expression for the method implementation as<br>\n     argument: ML that is embedded into Isar in the usual way.</p>\n<p>It is just a historical accident, that Outer_syntax.command is still<br>\n     not fully-integrated into the self-defining self-embedding game of<br>\n     formal languages.  (Just today I've made further stepts towards that,<br>\n     and found out that only 'theory' needs to be given from outside; all<br>\n     other Isar commands can be defined inside the Isar framework.)</p>\n<p>On now to make sophisticated specifications and serious proofs in <br>\nIsabelle/HOL ...</p>\n<p>Makarius</p>",
        "id": 294221505,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897738
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI think I have it.</p>\n<p>HOL imports pure, therefore it inherits the Isar language and a default <br>\nset of Isar outer syntax commands, where new outer syntax can be defined <br>\nwith \"Outer_syntax.command\". Everything in a .thy file is Isar syntax <br>\nand everything is HOL syntax, so there's no need to talk about HOL <br>\nsyntax, since, again, everything is HOL syntax. We could, however, <br>\ncompare Isabelle/HOL syntax with Isabelle/FOL syntax, where they would <br>\nboth share the default Isar outer syntax commands.</p>\n<p>The word \"term\" doesn't have a lot of significance to me. I assume you <br>\nmean \"lambda calculus term\", but I see very little lambda calculus in <br>\nexpressions between double quotes, so it doesn't completely help me to <br>\nknow what to put in double quotes.</p>\n<p>However, it is useful to know that if I see something in double quotes, <br>\nI know it must be either a type or a lambda calculus term, even if the <br>\nlambda calculus doesn't look like lambda calculus.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294221743,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897854
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nExcept for the technical details about which I didn't investigate, I feel  <br>\nto understand about the same as I read documents explaining Isabelle  <br>\n(actually, Markus Wenzel's thesis you pointed to, a captivating document):  <br>\nthe distinction between inner and outer syntax, does not map the  <br>\ndistinction between Isabelle‑Pure and the rest. If all is defined by  <br>\nextension in terms derived and derived‑derived from the Isabelle‑Pure  <br>\ncore, and if extension can apply to both the outer and inner syntax, then  <br>\nthe distinction is not that meaningful. Finally, may inner syntax is for  <br>\nsome kind of expressions, and expressions which are not lexically atomic.  <br>\nPerhaps that's a layout choice inspired by simplifying parsing. Can we say  <br>\nwhat is a value (ex. contains variables of all kinds) and is not lexically  <br>\natomic (or is lexically atomic, but whose name is not a simple name), have  <br>\nto be written in quotes? Just that?</p>",
        "id": 294221802,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897891
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI've been totally focused on the frontend languages, ML, Isar, and HOL, <br>\nwhile knowing nothing about what the backend prover does with them.</p>\n<p>I now have a way to make sense of it all being Isar syntax, the HOL <br>\nsyntax being a part of the Isar syntax, and HOL not being dependent on Isar.</p>\n<p>It could be that Isar is a framework that HOL uses to state lambda <br>\ncalculus terms, and the backend strips away all the outer syntax, where <br>\nall that's left is the HOL lambda calculus terms. That idea lines up <br>\nwith Christian saying that proofs are irrelevant.</p>\n<p>Now I sit on the two ideas and wait to see if I read something that <br>\nsupports one of the two ideas, that HOL inherits Isar and makes it its <br>\nown, or Isar is a framework that gets stripped away by the backend. <br>\nToday, right now, I'm leaning towards the idea that much of the Isar <br>\ngets stripped away.</p>\n<p>(I do see \"framework\" in \"Chapter 2 The Isabelle/Isar Framework\", which <br>\nis where I must have gotten \"framework\". I don't see \"stripped away\" <br>\nanywhere yet. There's a lot I haven't read yet.)</p>\n<p>I don't really care to know the details of what the backend does, it <br>\nwould take years to learn about it, but it's nice to make sense of <br>\nimportant high-level concepts.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294222001,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897984
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nI believe HOL inherits/use Isar, but I can't prove it (cheese).</p>\n<p>Along with this, for others interested in the original question too, here  <br>\nis an evidence that what you write in quotes, is not specifically HOL: you  <br>\nwrite lemma's conclusion to prove in quotes, and that's obviously not HOL,  <br>\nwhich I believe is object logic only. Ex. the “==&gt;” is meta‑level logic.</p>\n<p>So here comes an updated definitions perhaps, of what you have to put in  <br>\nquotes: you write in quotes, every expressions which involves mix‑fix  <br>\nnotations (I don't know any of these outside of quotes), to which is to be  <br>\nadded previously mentioned type expressions when not syntactically atomic  <br>\nand names when not simples (ex. containing dash, math symbols and the  <br>\nlike).</p>\n<p>P.S. I've not read all replies to that thread in deep details so far, so I  <br>\napologies for any contradictions with what others may have said if ever  <br>\nthere are some.</p>",
        "id": 294222286,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898136
    }
]