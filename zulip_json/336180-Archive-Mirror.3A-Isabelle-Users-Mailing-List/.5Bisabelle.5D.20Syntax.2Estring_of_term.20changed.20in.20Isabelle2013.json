[
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nIn Isabelle2012 the function</p>\n<p>fun term_to_str t = Print_Mode.setmp [] (Syntax.string_of_term<br>\n      (Proof_Context.init_global (Thy_Info.get_theory \"Isac\"))) t;</p>\n<p>term_to_string @{term \"a+1::int\"}</p>\n<p>delivered</p>\n<p>\"a+1\": string</p>\n<p>which we need for checks in our test suite.</p>\n<p>In Isabelle2013 the respective functions in \"Syntax\" deliver strings <br>\napparently for the fontend ( \"&lt;markup&gt; ...\"). Where do we get a <br>\n(combination of) function(s) with signature</p>\n<p>: _ -&gt; term -&gt; string</p>\n<p>in Isabelle2013 ?</p>\n<p>PS: We cound't find an answer neither in isar-ref.pdf \"7.1.Printing <br>\nlogical entities\" nor in implementation.pdf \"3.2.Parsing and unparsing\" <br>\n(the FIXME might concern our question --- nevertheless, thanks for the <br>\never-increasing quality of the manuals !!!).</p>",
        "id": 294245912,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908906
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is an example that works better:</p>\n<p>ML {*<br>\n   fun term_to_string ctxt t =<br>\n     let<br>\n       val ctxt' = Config.put show_markup false ctxt;<br>\n     in Print_Mode.setmp [] (Syntax.string_of_term ctxt') t end;</p>\n<p>term_to_string (Proof_Context.init_global @{theory Main}) @{term \"a+1::int\"}<br>\n*}</p>\n<p>Note that show_markup is the key thing here.  You should also avoid <br>\nThy_Info.get_theory, since it only works in certain situations (theory <br>\nproduced TTY or batch mode).</p>\n<p>What are you doing with the string output anyway?  It is relatively hard <br>\nto rely on exact behaviour of inner syntax layers, apart from the normal <br>\nmode of operation as user input / output.</p>\n<p>Makarius</p>",
        "id": 294245932,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908918
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nOn 07/21/2013 11:03 AM, Makarius wrote:</p>\n<blockquote>\n<p>On Sat, 20 Jul 2013, Walther Neuper wrote:</p>\n<blockquote>\n<p>In Isabelle2012 the function</p>\n<p>fun term_to_str t = Print_Mode.setmp [] (Syntax.string_of_term<br>\n    (Proof_Context.init_global (Thy_Info.get_theory \"Isac\"))) t;<br>\n:<br>\nin Isabelle2013 ?</p>\n</blockquote>\n<p>Here is an example that works better:</p>\n<p>ML {*<br>\n  fun term_to_string ctxt t =<br>\n    let<br>\n      val ctxt' = Config.put show_markup false ctxt;<br>\n    in Print_Mode.setmp [] (Syntax.string_of_term ctxt') t end;</p>\n<p>term_to_string (Proof_Context.init_global @{theory Main}) @{term <br>\n\"a+1::int\"}<br>\n*}</p>\n<p>Note that show_markup is the key thing here.  You should also avoid <br>\nThy_Info.get_theory, since it only works in certain situations (theory <br>\nproduced TTY or batch mode).</p>\n</blockquote>\n<p>Thanks a lot for the function (we got stuck with Pretty.T) and the note ...</p>\n<blockquote>\n<p>What are you doing with the string output anyway?  It is relatively <br>\nhard to rely on exact behaviour of inner syntax layers, apart from the <br>\nnormal mode of operation as user input / output.</p>\n</blockquote>\n<p>... because a considerable part of our regression tests still uses this <br>\nfunction.</p>\n<p>We shall narrow the gap to Isabelle standards also in isac's test <br>\nconfiguration, but that will take time (and won't start before all tests <br>\nare running on Isabelle2013 ;-)</p>\n<p>Walther</p>",
        "id": 294245960,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908931
    }
]