[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I am looking for bindings of rational numbers to the target languages of the code <br>\ngenerator. Has anyone done something in this direction? E.g., something analogous to <br>\nCode_Numeral.integer and Code_Target_Int.thy?</p>\n<p>Haskell and OCaml support arbitrary-precision rational numbers in their libraries <br>\n(Rational and Num.num) and there is a library for Scala (<a href=\"https://github.com/non/spire\">https://github.com/non/spire</a>), <br>\nbut I have not found anything for SML. Does anyone know of such a library for SML?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294660615,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169775
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nHi Andreas,</p>\n<p>As far as I know, src/Tools/rat.ML is an implementation of rational <br>\nnumber in Isabelle/ML and MetiTarski <br>\n(<a href=\"https://bitbucket.org/lcpaulson/metitarski/src\">https://bitbucket.org/lcpaulson/metitarski/src</a>) uses another <br>\nimplementation that is inherited from John Harrison somehow.</p>\n<p>I have considered this question before, but considering there is no <br>\nstandard implementation of rational number in the standard PolyML <br>\nlibrary, I thought it is risky to do such binding...</p>\n<p>Hope this helps,<br>\nWenda</p>",
        "id": 294660659,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169790
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nThere is an implementation used in HOL4 at</p>\n<p><a href=\"https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/portableML/Arbrat.{sig,sml}\">https://github.com/HOL-Theorem-Prover/HOL/blob/master/src/portableML/Arbrat.{sig,sml}</a></p>\n<p>Michael</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294660668,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169794
    },
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@email.gwu.edu\">maurer@email.gwu.edu</a>&gt;<br>\nThe main problem with standard treatments of rational numbers, as I see it, is: how often do you reduce to lowest terms? For example: (1/3+1/6)+1/2 -- do you reduce 1/3+1/6 to 1/2 immediately, and then add 1/2 to get 2/2, reducing to 1? Or do you leave 1/3+1/6 as 9/18 and then add 1/2 to get 36/36, reducing only at the end? The problem is that reducing to lowest terms is slow, in the worst case. You can ask the user when to reduce, potentially saving time, but would users necessarily know the best times to reduce? Is anyone aware of a good general solution to this problem? -WDMaurer</p>\n<p>Sent from my iPhone</p>",
        "id": 294660724,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169817
    },
    {
        "content": "<p>From: Lochbihler  Andreas &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Wenda, Michael and Mr. Douglas Maurer,</p>\n<p>Thanks for your input.</p>\n<p>The libraries for rational numbers in Isabelle and HOL4 are very similar, so I guess that it makes sense to add binding to Isabelle's implementation in the Eval target of the code generator (because Eval runs in the namespace of Isabelle, so everything is available. I still have to check whether this improves evaluation times at all (compared to using Code_Target_Int), because the code in rat.ML is in principle quite similar to what would be executed if we use the existing code setup for rat.</p>\n<p>Meanwhile, I have started to setup bindings to Haskell and OCaml, and there I noticed a nice speedup (ca. 3X for Haskell and 10X for OCaml) over the existing setup for rat with Code_Target_Int in place.</p>\n<p>As for the normalisation business, the current setup always reduces rational numbers to lowest terms. This is also what happens in the implementations in rat.ML and in HOL4. The Haskell standard library also does that (<a href=\"http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Real.html#line-372\">http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Real.html#line-372</a>). In OCaml's library Num, the user can set a flag whether rationals should be kept in lowest terms. It seems as if this is set to false by default. The Spire library for Scala also always reduces rationals (<a href=\"https://github.com/non/spire/blob/32345c24a598369388763abf7e5aed8621af1d15/core/shared/src/main/scala/spire/math/Rational.scala#L377\">https://github.com/non/spire/blob/32345c24a598369388763abf7e5aed8621af1d15/core/shared/src/main/scala/spire/math/Rational.scala#L377</a>).</p>\n<p>For the target language bindings, we do not have to commit to any strategy, as long as the rationals are only manipulated by the target language library. Only when we convert them back into nominator and denominator in Isabelle, normalisation makes a difference. And it seems as if in this case (I guess a rather rare case) we can normalise if necessary.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294660733,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169818
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nMy own, perhaps somewhat naïve, thoughts on this: What is the advantage<br>\nof using target-language rats? Are they really faster than the code that<br>\nIsabelle produces?</p>\n<p>Intuitively, I would think that the basic operations on rational numbers<br>\ntranslate to operations on integers very clearly and obviously and that<br>\nthere is not much room for creativity – except for the question of if<br>\nand when to reduce the numerator and denominator.</p>\n<p>A FFI-based implementation using the GNU Multiple Precision Arithmetic<br>\nLibrary (GMP) might be faster because it reduces overhead, but even<br>\nHaskell (which uses GMP for its integers) does not do that and relies on<br>\n‘pure’ rational numbers implemented as a datatype instead.</p>\n<p>On the question of normalisation, let me remark that the GMP always<br>\nassumes that rats are in canonical form and also brings all results into<br>\ncanonical form, and the GMP people generally seem know their stuff, so<br>\nthis is probably a good idea. (I think they also offer ‘raw’ functions<br>\nwithout this normalisation though)</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294660751,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169826
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nthe existing setup for rat with Code_Target_Int in place.</p>\n<p>I find that a bit surprising, considering how rats are implemented in<br>\nHaskell. One possible explanation that I have is that perhaps the<br>\nexported code uses Isabelle's GCD operation on natural numbers, whereas<br>\nthe Haskell version uses the GCD operation that GMP provides, and which<br>\nis probably much faster.</p>\n<p>Another possible reason is perhaps some issue with lazyness; Haskell's<br>\n\"Ratio\" datatype is declared with strict fields, whereas Isabelle<br>\nprobably declares \"rat\" with the lazy fields. Perhaps this can cause<br>\nlarge unevaluated chunks to hang around longer than they should?</p>\n<p>However, the fact that the difference is even more pronounced in OCaml<br>\nseems to speak against that. I don't know the OCaml implementation, so I<br>\ndon't know if the GCD thing might also be an explanation there.</p>",
        "id": 294660767,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169831
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>On 18/12/15 09:29, Manuel Eberl wrote:</p>\n<blockquote>\n<p>On 18/12/15 09:01, Lochbihler Andreas wrote:</p>\n<blockquote>\n<p>I noticed a nice speedup (ca. 3X for Haskell and 10X for OCaml) over<br>\nthe existing setup for rat with Code_Target_Int in place.</p>\n</blockquote>\n<p>I find that a bit surprising, considering how rats are implemented in<br>\nHaskell. One possible explanation that I have is that perhaps the<br>\nexported code uses Isabelle's GCD operation on natural numbers, whereas<br>\nthe Haskell version uses the GCD operation that GMP provides, and which<br>\nis probably much faster.<br>\nYour guess seems to be right. If I serialise the gcd operation on integer to the target <br>\nlanguage implementation, the differences almost vanish.</p>\n</blockquote>\n<blockquote>\n<p>Another possible reason is perhaps some issue with lazyness; Haskell's<br>\n\"Ratio\" datatype is declared with strict fields, whereas Isabelle<br>\nprobably declares \"rat\" with the lazy fields. Perhaps this can cause<br>\nlarge unevaluated chunks to hang around longer than they should?</p>\n<p>However, the fact that the difference is even more pronounced in OCaml<br>\nseems to speak against that. I don't know the OCaml implementation, so I<br>\ndon't know if the GCD thing might also be an explanation there.</p>\n<p>It is.</p>\n</blockquote>\n<p>Thanks,<br>\nAndreas</p>",
        "id": 294660788,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169836
    },
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nDear all,</p>\n<p>in my AFP about the Gauss-Jordan algorithm I worked with rational matrices,<br>\nso I serialised the rational numbers from Isabelle to Haskell, see:<br>\n<a href=\"http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Rational.html\">http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Rational.html</a></p>\n<p>For exporting code to SML, I just used the file Code_Target_Int together<br>\nwith serialisations from gcd to PolyML.IntInf.gcd and MLton.IntInf.gcd (as<br>\nfar as I know, there is no gcd implementation in the standard library). I<br>\nalso serialised the operations div and mod, see<br>\n<a href=\"http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Generation_IArrays_SML.html\">http://afp.sourceforge.net/browser_info/current/AFP/Gauss_Jordan/Code_Generation_IArrays_SML.html</a>.<br>\nWithout such GCD serialisations, i.e. only using Code_Target_Int, times<br>\nwere 20 times slower in my case.</p>\n<p>Best,<br>\nJose</p>",
        "id": 294660845,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169843
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Jose,</p>\n<p>Did you measure how much you gained from serialising rat to Haskell's Rational type <br>\n(compared with using Code_Target_Int plus an appropriate setup to implement gcd on integer <br>\nand int with Prelude.gcd)? In my quick experiment this morning, I could not see a <br>\nsignificant speed-up.</p>\n<p>I was also a bit surprised by your comparison of serialisation options for divmod_integer <br>\nin Code_Generation_IArrays_SML. In SML, quotRem and divMod behave differently when it <br>\ncomes to negative numbers. In that respect, quotRem is the wrong choice. For example,<br>\nquotRem (~10, 6) evaluates to (~4, ~6) and divMod (~10, 6) to (~2, 2). In Isabelle/HOL,<br>\nvalue [nbe] \"divmod_integer (-10, 6)\" gives (-2, 2). So the generated code may actually <br>\nreturn a different result than what you have proved. (I do not know whether such negative <br>\nnumbers can occur in your application).</p>\n<p>Given that the generated ML code should work for all ML systems, I think we cannot take <br>\nthe serialisations of gcd into the distribution by default.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294660910,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169862
    },
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nDear Andreas,</p>\n<p>Did you measure how much you gained from serialising rat to Haskell's</p>\n<blockquote>\n<p>Rational type (compared with using Code_Target_Int plus an appropriate<br>\nsetup to implement gcd on integer and int with Prelude.gcd)? In my quick<br>\nexperiment this morning, I could not see a significant speed-up.<br>\n</p>\n</blockquote>\n<p>Yes, I did. I also carried out quick experiments and noticed more or less<br>\nthe same as you: Haskell's Rational type was just a little bit faster,<br>\nalmost insignificant.</p>\n<blockquote>\n<p>I was also a bit surprised by your comparison of serialisation options for<br>\ndivmod_integer in Code_Generation_IArrays_SML. In SML, quotRem and divMod<br>\nbehave differently when it comes to negative numbers. In that respect,<br>\nquotRem is the wrong choice. For example,<br>\nquotRem (~10, 6) evaluates to (~4, ~6) and divMod (~10, 6) to (~2, 2). In<br>\nIsabelle/HOL,<br>\nvalue [nbe] \"divmod_integer (-10, 6)\" gives (-2, 2). So the generated code<br>\nmay actually return a different result than what you have proved. (I do not<br>\nknow whether such negative numbers can occur in your application).<br>\n</p>\n</blockquote>\n<p>Good point, let me take a glance at it.</p>\n<blockquote>\n<p>Given that the generated ML code should work for all ML systems, I think<br>\nwe cannot take the serialisations of gcd into the distribution by default.<br>\n</p>\n</blockquote>\n<p>Yes, you are completely right. Each time I exported code, I had to decide<br>\nwhich serialisation was going to be used depending on the ML interpreter.</p>\n<p>Best,<br>\nJose</p>",
        "id": 294660933,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169871
    },
    {
        "content": "<p>From: Jose Divasón &lt;<a href=\"mailto:jose.divasonm@unirioja.es\">jose.divasonm@unirioja.es</a>&gt;<br>\nI think it works for my concrete case (integer numbers are only used for<br>\nrepresenting rational numbers), however for a general integer manipulation<br>\nthis is not a correct serialisation.</p>\n<p>In my exported code, quot is only used when nomalising rational numbers (by<br>\nmeans of the Rat.normalise definition). If I am not wrong, for such a<br>\nfunction it is the same using \"div\" as using \"quot\".</p>\n<p>So, \"-20 div 6\" would return different results (as expected), but normalize<br>\n(-20,6) the same:</p>\n<p>code_printing<br>\nconstant \"op div :: integer =&gt; _ =&gt; _\" ⇀ (SML) \"(IntInf.div ((_), (_)))\"<br>\n| constant \"op mod :: integer =&gt; _ =&gt; _\" ⇀ (SML) \"(IntInf.mod ((_), (_)))\"</p>\n<p>value[code] \"-20 div 6::int\" (<em>Result: - 4</em>)<br>\nvalue[code] \"Rat.normalize (-20,6)\" (<em>Result: (-10,3) :: \"int × int\"</em>)</p>\n<p>code_printing<br>\nconstant \"op div :: integer =&gt; _ =&gt; _\" ⇀ (SML) \"(IntInf.quot ((_), (_)))\"<br>\n| constant \"op mod :: integer =&gt; _ =&gt; _\" ⇀ (SML) \"(IntInf.rem ((_), (_)))\"</p>\n<p>value[code] \"-20 div 6::int\" (<em>Result: - 3 :: \"int\"</em>)<br>\nvalue[code] \"Rat.normalize (-20,6)\" (<em>Result: (-10,3) :: \"int × int\"</em>)</p>\n<p>Then, I took advantage of it and decided to use quot, since it is supposed<br>\nto be faster. Nevertheless, I have to study it carefully again because<br>\nmaybe I am wrong.</p>\n<p>Best,<br>\nJose</p>",
        "id": 294660938,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169873
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Jose,</p>\n<p>Rat.normalise only divides by divisors, so the remainder is always 0 and the problem <br>\nshould not occur in this case.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294660956,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169879
    },
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>concerning division on integers, I also observed some optimization potential, which is save in a way that<br>\nit only invokes the divmod on positive numbers. At least<br>\nin my application gave a significant speedup, cf.</p>\n<p><a href=\"http://afp.sourceforge.net/browser_info/current/AFP/Algebraic_Numbers/Improved_Code_Equations.html\">http://afp.sourceforge.net/browser_info/current/AFP/Algebraic_Numbers/Improved_Code_Equations.html</a></p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294661120,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169948
    }
]