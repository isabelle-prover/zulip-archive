[
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nScott West wrote:</p>\n<p>This example, and others similar to it, are described in the paper by<br>\nSlind and Owens, available from</p>\n<p><a href=\"http://www.cs.utah.edu/~slind/papers/hosc.regexp/\">http://www.cs.utah.edu/~slind/papers/hosc.regexp/</a></p>\n<p>Michael.</p>",
        "id": 294075195,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828580
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Scott,</p>\n<p>This is nonterminating in general, unless the obj type is finite. So <br>\nthere can't be just a simple \"measure\".</p>\n<p>If your application does not require the functional view (like for code <br>\ngeneration), you best define all_children as an inductive set or <br>\npredicate, which avoids all termination issues and is usually much simpler.</p>\n<p>You can define partial functions in Isabelle (see the function tutorial <br>\nfor a small example), but this introduces explicit domain predicates and <br>\nin particular prevents code generation unless your function is <br>\ntail-recursive (this is how it is done in Stefan's formalization...)</p>\n<p>But if you really just need all_children defined somehow, then just use <br>\n\"inductive\"</p>\n<p>Alex</p>",
        "id": 294075211,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828587
    },
    {
        "content": "<p>From: Stephan Merz &lt;<a href=\"mailto:Stephan.Merz@loria.fr\">Stephan.Merz@loria.fr</a>&gt;<br>\nBasically you'll have to take the complement of your set \"seen\" with <br>\nrespect to the set of reachable nodes (i.e., the transitive closure of <br>\nthe children function from the node \"src\"). And yes, you'll have to <br>\nprove that transitive closure to be a finite set, otherwise the function <br>\nwouldn't terminate.</p>\n<p>We have recently formalized a very similar function in the context of an <br>\nautomaton construction for model checking, and I could send you the <br>\ntheories and a paper (off-list) if you are interested.</p>\n<p>Regards,<br>\nStephan</p>\n<p>Scott West wrote:<br>\n<a href=\"/user_uploads/14278/O3e3Ex8w6DU675OINJXcYZTR/Stephan_Merz.vcf\">Stephan_Merz.vcf</a></p>",
        "id": 294075261,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828606
    },
    {
        "content": "<p>From: Konrad Slind &lt;<a href=\"mailto:slind@cs.utah.edu\">slind@cs.utah.edu</a>&gt;<br>\nThe termination of a similar operation (depth-first traversal)<br>\non a graph given by a function is discussed on pages 8-10<br>\nof</p>\n<p><a href=\"http://www.cs.utah.edu/~slind/papers/hosc.regexp/paper.pdf\">http://www.cs.utah.edu/~slind/papers/hosc.regexp/paper.pdf</a></p>\n<p>It uses a lexicographic combination of measure functions.</p>\n<p>Cheers,<br>\nKonrad.</p>",
        "id": 294075271,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660828610
    },
    {
        "content": "<p>From: Scott West &lt;<a href=\"mailto:scott.west@inf.ethz.ch\">scott.west@inf.ethz.ch</a>&gt;<br>\nHello all,</p>\n<p>I have recently been trying to write a function, which Isabelle would <br>\nlike to know terminates. The basic task is to find reachability, but I <br>\ndon't have an explicit graph, I have a function which returns children <br>\nof the current node.</p>\n<p>So I recursively define this function to essentially be something like:</p>\n<p>all_children :: obj =&gt; obj set =&gt; obj set<br>\nall_children src seen =<br>\n   if src \\&lt;in&gt; seen<br>\n     then seen<br>\n     else<br>\n       foldr all_children (children src) (seen \\&lt;union&gt; {src})</p>\n<p>I can't for the life of me figure out what the measure function should <br>\nbe in this case. Been thinking on it for a few days and I don't know how <br>\nto state a termination proof in a way that Isabelle will understand. I <br>\nshould preface that by saying I only know of the \"measure\" method... and <br>\neven then, not really well.</p>\n<p>If anyone could provide some hint on how to go about this, then that <br>\nwould be great.</p>\n<p>Regards,<br>\nScott</p>",
        "id": 294077031,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829286
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nScott West wrote:<br>\nHello Scott,</p>\n<p>when defining the above function with \"fun\", you also have to supply<br>\na suitable congruence rule for foldr in order to be able to prove<br>\ntermination. However, it might actually be easier to define all_children<br>\nwithout using foldr, i.e. by turning the first parameter into a list<br>\nof objects that still have to be inspected:</p>\n<p>all_children :: obj list =&gt; obj set =&gt; obj set<br>\n   all_children [] seen = seen<br>\n   all_children (src # srcs) seen =<br>\n     if src \\&lt;in&gt; seen<br>\n       then all_children srcs seen<br>\n       else<br>\n         all_children (children src @ srcs) (seen \\&lt;union&gt; {src})</p>\n<p>This approach is used in the formalization of depth first search<br>\nby Nishihara an Minamide, which you can find in the AFP:</p>\n<p><a href=\"http://afp.sourceforge.net/entries/Depth-First-Search.shtml\">http://afp.sourceforge.net/entries/Depth-First-Search.shtml</a></p>\n<p>I recently generalized this formalization a little (using locales),<br>\nallowing the user to freely choose the representation of \"obj set\",<br>\nas well as the implementation of the children, \\&lt;union&gt;, and \\&lt;in&gt;<br>\noperators. You can currently find the generalized version at</p>\n<p><a href=\"http://www.in.tum.de/~berghofe/papers/automata/DFS.thy\">http://www.in.tum.de/~berghofe/papers/automata/DFS.thy</a></p>\n<p>For examples of how to apply this version of DFS, see</p>\n<p><a href=\"http://www.in.tum.de/~berghofe/papers/automata/Automata.thy\">http://www.in.tum.de/~berghofe/papers/automata/Automata.thy</a></p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294077045,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829290
    },
    {
        "content": "<p>From: Scott West &lt;<a href=\"mailto:scott.west@inf.ethz.ch\">scott.west@inf.ethz.ch</a>&gt;<br>\nHello Alex,</p>\n<blockquote>\n<p>Exactly! You will need to define a set \"L\" which contains all the nodes <br>\nthat can be \"seen\". Instead of \"measures\" I would prefer the use of <br>\n\"psubset\" here.<br>\n</p>\n</blockquote>\n<p>I'll look at psubset, thanks!</p>\n<blockquote>\n<p>But this is not the only problem you have here. Moreover the use of <br>\n\"foldr\" complicates the proof. When you start your termination proof, <br>\nyou will notice, that there is no call of \"foldr\" anymore. Here the <br>\n\"Higher Order Recursion\" <br>\n(<a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf</a>, chapter 9) <br>\ncomes into play. \"foldr\" is eliminated using the congruence rule <br>\n'foldr_cong' (from List.thy) I think. But this rule 'abstracts' over the <br>\nsecond argument (of f), so that you are not able state anything about it <br>\n(and you will need it to proof termination). Therefore you have probably <br>\nfirst to find the right congruence rule for 'foldr' that somehow <br>\npreserves the information, that the second argument of f is always a <br>\nsubset of \"L\".</p>\n</blockquote>\n<p>I read the functions.pdf that you pointed me to, however I still dont' <br>\nfeel as if I know how the congruence mechanism works in practice. How <br>\ndoes it <code>abstract' over the second argument of </code>f' ?</p>\n<p>If I do need to reformulate the foldr_cong rule to fit my needs, are <br>\nthere any good examples of how these rules are applied during the proof, <br>\nso I can see what's going wrong?</p>\n<blockquote>\n<p>Maybe it is a better idea to eliminate the use of foldr (if possible) <br>\ncompletely.<br>\n</p>\n</blockquote>\n<p>I do now have a version that I created without foldr that I can prove <br>\ntermination. However eventually I will be doing things where foldr <br>\nbecomes important (modeling imperative code, so the accumulated <br>\nparameter will be the state). So I guess I'm going down a more difficult <br>\nroad ;).</p>\n<p>Thanks again for the help!</p>\n<p>Regards,<br>\nScott</p>",
        "id": 294077504,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829431
    },
    {
        "content": "<p>From: Alexander Schimpf &lt;<a href=\"mailto:info@hitstec.de\">info@hitstec.de</a>&gt;<br>\nDear Scott,</p>\n<p>Scott West schrieb:</p>\n<blockquote>\n<p>Hello Alex,</p>\n<blockquote>\n<p>Exactly! You will need to define a set \"L\" which contains all the <br>\nnodes that can be \"seen\". Instead of \"measures\" I would prefer the <br>\nuse of \"psubset\" here.<br>\n</p>\n</blockquote>\n<p>I'll look at psubset, thanks!</p>\n<blockquote>\n<p>But this is not the only problem you have here. Moreover the use of <br>\n\"foldr\" complicates the proof. When you start your termination proof, <br>\nyou will notice, that there is no call of \"foldr\" anymore. Here the <br>\n\"Higher Order Recursion\" <br>\n(<a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf</a>, chapter <br>\n9) comes into play. \"foldr\" is eliminated using the congruence rule <br>\n'foldr_cong' (from List.thy) I think. But this rule 'abstracts' over <br>\nthe second argument (of f), so that you are not able state anything <br>\nabout it (and you will need it to proof termination). Therefore you <br>\nhave probably first to find the right congruence rule for 'foldr' <br>\nthat somehow preserves the information, that the second argument of f <br>\nis always a subset of \"L\".</p>\n</blockquote>\n<p>I read the functions.pdf that you pointed me to, however I still dont' <br>\nfeel as if I know how the congruence mechanism works in practice. How <br>\ndoes it <code>abstract' over the second argument of </code>f' ?</p>\n<p>If I do need to reformulate the foldr_cong rule to fit my needs, are <br>\nthere any good examples of how these rules are applied during the <br>\nproof, so I can see what's going wrong?<br>\nWell, I am not really sure if there are any. But I've created a small <br>\nexample, that I think addresses your problem. Instead of using foldr <br>\nexplicitly and to avoid the problems arise with congruence rules, I've <br>\njust used mutual recursion <br>\n(<a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/functions.pdf</a>, Chapter 5) <br>\nto achieve the same behavior. In my example (see Test.thy) the function <br>\n'f' is similar to your 'all_children' function, the (abstract) function <br>\n'g' is somewhat similar to your 'children' function.<br>\nAfter the function definition is established and the completeness is <br>\nproofed, the termination proof is considered, which relies on the fact, <br>\nthat there is an function called 'lim' which computes an upper bound for <br>\n'f' (and therefore for its second argument). So far, 'lim' is not really <br>\ndefined in my example (that's up to you), but requires some properties <br>\nto be true (for example finiteness, etc.)<br>\nAfter that a special partial termination property (called 'subset_prop') <br>\nfor the function 'f' and its mutual recursive counterpart 'foldr_f' is <br>\nproofed, since it is required in the termination proof. This property is <br>\nimportant and I don't think you can get a similar property when you use <br>\n'foldr' directly (but I've not verified that!)<br>\nAt the end the termination proof is established using a special <br>\ntermination ordering (called 'my_term_ord'), which is a lexicographical <br>\ncombination of 'finite_psubset' and the 'less_than' relation. The latter <br>\nis needed since in my mutual recursive version the termination of the <br>\nfoldr replacement have to also to be proofed.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>Maybe it is a better idea to eliminate the use of foldr (if possible) <br>\ncompletely.<br>\n</p>\n</blockquote>\n<p>I do now have a version that I created without foldr that I can prove <br>\ntermination. However eventually I will be doing things where foldr <br>\nbecomes important (modeling imperative code, so the accumulated <br>\nparameter will be the state). So I guess I'm going down a more <br>\ndifficult road ;).<br>\nJust try using the mutual recursive version that I've suggested in the <br>\nexample. After finishing the termination it is probably possible to <br>\nproof, that the mutual recursive (helphing) funciton 'foldr_f' is in <br>\nfact (in some sense) equal to the ordinary 'foldr' function, so that it <br>\ncan be replaced.</p>\n</blockquote>\n<blockquote>\n<p>Thanks again for the help!<br>\nNo problem, so far!</p>\n</blockquote>\n<p>Regards,<br>\nAlex<br>\n<a href=\"/user_uploads/14278/dn1Un-HNCnJ9nS3vxgbKL2tC/Test.thy\">Test.thy</a></p>",
        "id": 294077784,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829566
    }
]