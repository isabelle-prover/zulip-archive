[
    {
        "content": "<p>From: Jason Dagit &lt;<a href=\"mailto:dagitj@gmail.com\">dagitj@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I was trying to prove termination for the following definition:<br>\n\\begin{code}<br>\ntheory Termination<br>\nimports Nat Multiset Divides Datatype</p>\n<p>begin</p>\n<p>inductive_set even :: \"nat set\" where<br>\nzero[intro!]: \"0 ∈ even\" |<br>\nstep[intro!]: \"n ∈ even ⟹ (Suc (Suc n)) ∈ even\"</p>\n<p>function (sequential) foo :: \"nat ⇒ nat list\" where<br>\n\"foo 0             = [0]\" |<br>\n\"foo (Suc 0)       = [1]\" |<br>\n\"foo n = (case n ∈ even of<br>\n          True  ⇒ n # foo (n div 2) |<br>\n          False ⇒ n # foo (Suc n))\"<br>\nby pat_completeness auto<br>\ntermination<br>\napply (relation \"measures [Suc, λn. n div 2]\")<br>\napply auto<br>\noops<br>\n\\end{code}</p>\n<p>I know I can change the definition slightly for foo to make it pass the<br>\ntermination checker using the standard lexicographical measure.  I'm<br>\nlearning about function package and specifically, how to write termination<br>\nproofs so I want to avoid the easy route here.  I'm following this<br>\ndocumentation in particular:<br>\n<a href=\"http://isabelle.in.tum.de/doc/functions.pdf\">http://isabelle.in.tum.de/doc/functions.pdf</a></p>\n<p>My understanding of the above proof attempt is that it will never work<br>\nbecause the well founded relation needs for the \"n \\&lt;notin&gt; even\" case to<br>\ndecrease or stay the same, but instead it gets larger in the recursive call.</p>\n<p>I can also imagine a proof of termination based on the fact that if n is odd<br>\nthen Suc n will be even and the next call to foo will cause the argument to<br>\nshrink by more than it grew.  Is it possible to write such a proof and lease<br>\nthe termination checker?  Perhaps there is something that can be done with<br>\nthe function domain in the same way partial functions are handled?  Advice<br>\non how to get started with such a proof?  Perhaps there are examples of this<br>\nsomewhere already?</p>\n<p>Thanks,<br>\nJason</p>",
        "id": 294123036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840413
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nJason Dagit schrieb:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I was trying to prove termination for the following definition:<br>\n\\begin{code}<br>\ntheory Termination<br>\nimports Nat Multiset Divides Datatype</p>\n</blockquote>\n<p>Just a small remark: Nat, Divides and Datatype are subtheories of Main<br>\nand should not be imported selectively, they may not work as expect in<br>\nthe absence of the rest of Main. In your case it was not a problem<br>\nbecause Multiset includes Main.</p>\n<p>I'll let Alex answer your actual question.</p>\n<p>Tobias</p>\n<blockquote>\n<p>begin</p>\n<p>inductive_set even :: \"nat set\" where<br>\nzero[intro!]: \"0 ∈ even\" |<br>\nstep[intro!]: \"n ∈ even ⟹ (Suc (Suc n)) ∈ even\"</p>\n<p>function (sequential) foo :: \"nat ⇒ nat list\" where<br>\n\"foo 0             = [0]\" |<br>\n\"foo (Suc 0)       = [1]\" |<br>\n\"foo n = (case n ∈ even of<br>\n          True  ⇒ n # foo (n div 2) |<br>\n          False ⇒ n # foo (Suc n))\"<br>\nby pat_completeness auto<br>\ntermination<br>\napply (relation \"measures [Suc, λn. n div 2]\")<br>\napply auto<br>\noops<br>\n\\end{code}</p>\n<p>I know I can change the definition slightly for foo to make it pass the<br>\ntermination checker using the standard lexicographical measure.  I'm<br>\nlearning about function package and specifically, how to write termination<br>\nproofs so I want to avoid the easy route here.  I'm following this<br>\ndocumentation in particular:<br>\n<a href=\"http://isabelle.in.tum.de/doc/functions.pdf\">http://isabelle.in.tum.de/doc/functions.pdf</a></p>\n<p>My understanding of the above proof attempt is that it will never work<br>\nbecause the well founded relation needs for the \"n \\&lt;notin&gt; even\" case to<br>\ndecrease or stay the same, but instead it gets larger in the recursive call.</p>\n<p>I can also imagine a proof of termination based on the fact that if n is odd<br>\nthen Suc n will be even and the next call to foo will cause the argument to<br>\nshrink by more than it grew.  Is it possible to write such a proof and lease<br>\nthe termination checker?  Perhaps there is something that can be done with<br>\nthe function domain in the same way partial functions are handled?  Advice<br>\non how to get started with such a proof?  Perhaps there are examples of this<br>\nsomewhere already?</p>\n<p>Thanks,<br>\nJason</p>\n</blockquote>",
        "id": 294123044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840416
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Jason,</p>\n<blockquote>\n<p>theory Termination<br>\nimports Nat Multiset Divides Datatype</p>\n</blockquote>\n<p>First, you should import Parity, which already has the \"even\" predicate. <br>\nAnd as Tobias said, if you don't import Main, you may not get the tools <br>\nyou expect, just some unfinished pieces lying around.</p>\n<blockquote>\n<p>inductive_set even :: \"nat set\" where<br>\nzero[intro!]: \"0 ∈ even\" |<br>\nstep[intro!]: \"n ∈ even ⟹ (Suc (Suc n)) ∈ even\"</p>\n</blockquote>\n<p>If you define even yourself, proving a rewrite rule<br>\n\"Suc n : even &lt;-&gt; ~ n : even\" helps in the termination proof.</p>\n<blockquote>\n<p>function (sequential) foo :: \"nat ⇒ nat list\" where<br>\n\"foo 0             = [0]\" |<br>\n\"foo (Suc 0)       = [1]\" |<br>\n\"foo n = (case n ∈ even of<br>\n          True  ⇒ n # foo (n div 2) |<br>\n          False ⇒ n # foo (Suc n))\"<br>\nby pat_completeness auto<br>\ntermination<br>\napply (relation \"measures [Suc, λn. n div 2]\")<br>\napply auto<br>\noops</p>\n</blockquote>\n<blockquote>\n<p>My understanding of the above proof attempt is that it will never work<br>\nbecause the well founded relation needs for the \"n \\&lt;notin&gt; even\" case to<br>\ndecrease or stay the same, but instead it gets larger in the recursive call.</p>\n</blockquote>\n<p>Yes. This measure does not work. In such a situation where there is a <br>\ntemporary increase like this, you can anticipate this in the definition <br>\nof the measure, and assign a measure that already corresponds to the <br>\nincreased value.</p>\n<p>The following works for this example, assuming the [simp] rule mentioned <br>\nabove:</p>\n<p>termination<br>\napply (relation \"measures<br>\n   [%n. if n &lt;= 1 then 0 else if n : even then n else Suc n,<br>\n    %n. if n : even then 0 else 1]\")<br>\napply auto<br>\ndone</p>\n<blockquote>\n<p>I can also imagine a proof of termination based on the fact that if n is odd<br>\nthen Suc n will be even and the next call to foo will cause the argument to<br>\nshrink by more than it grew.  Is it possible to write such a proof and lease<br>\nthe termination checker?</p>\n</blockquote>\n<p>I would assume that the idea above works in general.</p>\n<p>There is also a different approach to handle this in the termination <br>\nprower itself, not in the measure function. It is sketched in Sect. 6 of <br>\nthis paper: <br>\n<a href=\"http://www4.informatik.tu-muenchen.de/~krauss/shallowdp/shallowdp.pdf\">http://www4.informatik.tu-muenchen.de/~krauss/shallowdp/shallowdp.pdf</a><br>\nBut I never finished the implementation, mainly because these functions <br>\ndon't arise so often, and if they do, there is always a simple manual <br>\nsolution. Moreover, detecting the situation automatically is not so easy.</p>\n<p>Hope this helps...<br>\nAlex</p>",
        "id": 294123067,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840424
    },
    {
        "content": "<p>From: Jason Dagit &lt;<a href=\"mailto:dagitj@gmail.com\">dagitj@gmail.com</a>&gt;<br>\nOn Sun, Dec 19, 2010 at 3:20 AM, Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Jason,</p>\n<p>theory Termination</p>\n<blockquote>\n<p>imports Nat Multiset Divides Datatype<br>\n</p>\n</blockquote>\n<p>First, you should import Parity, which already has the \"even\" predicate.<br>\nAnd as Tobias said, if you don't import Main, you may not get the tools you<br>\nexpect, just some unfinished pieces lying around.<br>\n</p>\n</blockquote>\n<p>Thanks, that's good to know.  I must have overlooked this advice in the<br>\nIsabelle tutorial as I don't recall hearing it before.</p>\n<blockquote>\n<p>Hope this helps...<br>\n</p>\n</blockquote>\n<p>Yes, your email was very helpful.  I was able to get the proof to go through<br>\nand learned a bit about how it works in the process.  I hope to send a<br>\nfollow up email soon, as I have a few more questions now. I'm a bit short on<br>\ntime at the moment so it may not be till the new year.</p>\n<p>Thanks,<br>\nJason</p>",
        "id": 294123182,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840452
    }
]