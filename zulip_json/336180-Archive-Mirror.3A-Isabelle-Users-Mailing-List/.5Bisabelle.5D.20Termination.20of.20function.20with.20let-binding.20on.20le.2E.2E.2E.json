[
    {
        "content": "<p>From: Mathieu Giorgino &lt;<a href=\"mailto:mathieu.giorgino@IRIT.FR\">mathieu.giorgino@IRIT.FR</a>&gt;<br>\nHi all,</p>\n<p>I just noticed a problem with \"let\" bindings on left-nested tuples in function <br>\ndefinitions.</p>\n<p>For example, these 2 functions -- each written with \"function\" and \"fun\" -- <br>\nare exactly the same, excepted for the nesting of tuples.</p>\n<hr>\n<p>theory Scratch imports Main<br>\nbegin</p>\n<p>function (sequential) f1 :: \"(nat * nat * nat) \\&lt;Rightarrow&gt; unit\"<br>\n  where<br>\n  \"f1 (_, _, 0) = ()\"<br>\n| \"f1 n = (let (a1, a2, a3) = n in f1 (a2+2, a1+1, a3 - 1))\"<br>\nby pat_completeness auto<br>\ntermination<br>\n  apply (relation \"measure (snd o snd)\")<br>\n  apply (auto simp del:in_measure)<br>\n  by auto</p>\n<p>fun f1' :: \"(nat * nat * nat) \\&lt;Rightarrow&gt; unit\"<br>\n  where<br>\n  \"f1' (_, _, 0) = ()\"<br>\n| \"f1' n = (let (a1, a2, a3) = n in f1' (a2+2, a1+1, a3 - 1))\"</p>\n<p>function (sequential) f2 :: \"((nat * nat) * nat) \\&lt;Rightarrow&gt; unit\"<br>\n  where<br>\n  \"f2 ((_, _), 0) = ()\"<br>\n| \"f2 n = (let ((a1, a2), a3) = n in f2 ((a2+2,a1+1), a3 - 1))\"<br>\n  by pat_completeness auto<br>\ntermination<br>\n  apply (relation \"measure snd\")<br>\n  apply (auto simp del:in_measures)<br>\n  oops</p>\n<p>fun f2' :: \"((nat * nat) * nat) \\&lt;Rightarrow&gt; unit\"<br>\n  where<br>\n  \"f2' ((_, _), 0) = ()\"<br>\n| \"f2' n = (let ((a1, a2), a3) = n in f2' ((a2+2, a1+1), a3 - 1))\"</p>\n<hr>\n<p>Then it seems impossible to prove the termination of f2 (and \"fun f2'\" fails). <br>\nIn the termination proof, we can see there is no equality relation for the <br>\nsecond component of the outermost pair.</p>\n<p>It seems to be related to congruence rules in some way but I couldn't figure <br>\nout the exact problem.</p>\n<p>In these examples, the let could be replaced by the function pattern matching <br>\nbut this problem also prevents those let-bindings in more complicated <br>\nfunctions.</p>\n<p>An idea on what is going wrong ?</p>\n<p>Thanks,</p>\n<p>Mathieu</p>",
        "id": 294140089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845549
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Mathieu,</p>\n<p>I'm pretty sure that this is a bug in the function package.</p>\n<p>If I do a theorem search for \"f2_dom\" during the termination proof, I<br>\nsee the following rule, which is apparently derived from f2.pinduct:</p>\n<p>local.termination:<br>\n  ⟦wf ?R;<br>\n   ⋀v vb x xa y xb ya xc.<br>\n      ⟦x = (v, Suc vb); (xa, y) = x; (xb, ya) = xa⟧<br>\n      ⟹ (((ya + 2, xb + 1), xc - 1), v, Suc vb) ∈ ?R⟧<br>\n  ⟹ All f2_dom</p>\n<p>This rule is completely useless, because it does not let you assume<br>\nanything about the variable xc. The correct form of this rule should<br>\nhave \"xc\" replaced with \"y\".</p>\n<p>Compare this with the similar rule we get for the termination proof of f1:</p>\n<p>local.termination:<br>\n  ⟦wf ?R;<br>\n   ⋀v vb vd x xa y xb ya.<br>\n      ⟦x = (v, vb, Suc vd); (xa, y) = x; (xb, ya) = y⟧<br>\n      ⟹ ((xb + 2, xa + 1, ya - 1), v, vb, Suc vd) ∈ ?R⟧<br>\n  ⟹ All f1_dom</p>\n<p>Here, the local assumptions imply that (v, vb, Suc vd) = (xa, xb, ya),<br>\nmaking the rule possible to use in practice.</p>\n<p>Unfortunately I can't think of a good workaround for this problem,<br>\nunless you want to manually prove a corrected form of f2.pinduct and<br>\nthe termination rule, based on unfolding the definition of f2_dom. You<br>\nwill probably just have to wait for a bug fix from the developers.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294140116,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845559
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Matthieu,</p>\n<blockquote>\n<p>function (sequential) f2 :: \"((nat * nat) * nat) \\&lt;Rightarrow&gt;  unit\"<br>\n   where<br>\n   \"f2 ((_, _), 0) = ()\"<br>\n| \"f2 n = (let ((a1, a2), a3) = n in f2 ((a2+2,a1+1), a3 - 1))\"<br>\n   by pat_completeness auto<br>\n[...]<br>\nThen it seems impossible to prove the termination of f2 (and \"fun f2'\" fails).<br>\nIn the termination proof, we can see there is no equality relation for the<br>\nsecond component of the outermost pair.</p>\n<p>It seems to be related to congruence rules in some way but I couldn't figure<br>\nout the exact problem.</p>\n</blockquote>\n<p>Thanks for reporting this issue. The root of the problem lies in the way <br>\nthe function package extracts recursive calls from the definition. This <br>\ninformation is then used in the construction of pretty much everything: <br>\nthe function itself, the graph, the domain, the rules etc.</p>\n<p>The extraction process, guided by congruence rules, is necessarily <br>\nheuristic in nature and known to be imprecise in some cases, which can <br>\nthen lead to unprovable termination conditions. This is also the case <br>\nhere (the code behaves exactly as specified), but the example is <br>\nespecially disturbing, since the problem is so easy and completely <br>\nfirst-order.</p>\n<p>Here is a different instance of the same problem, which is a bit clearer:</p>\n<p>function f3 :: \"bool =&gt; nat =&gt; nat\"<br>\nwhere<br>\n   \"f3 _ 0 = 0\"<br>\n| \"f3 b (Suc n) = (case b of True =&gt; f3 True | False =&gt; id) n\"</p>\n<p>Note that he branches of the case are functions, and one is a recursive <br>\ncall. But the argument to the call sits at the other end of the term. A <br>\nsimilar thing happens in your example.</p>\n<p>It seems that, unlike in most other situations, this cannot be solved <br>\n(in general) by adding some cong rules. Since I'd like the process to be <br>\ncomplete for situations like this one, I am considering adding special <br>\ntreatment for tuple patterns, but this is not trivial...</p>\n<p>Alex</p>",
        "id": 294140159,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845577
    }
]