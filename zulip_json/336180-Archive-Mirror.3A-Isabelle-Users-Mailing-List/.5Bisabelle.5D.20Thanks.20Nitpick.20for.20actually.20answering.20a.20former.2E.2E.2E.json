[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHello,</p>\n<p>It's not like I call up Bill Gates to learn about Windows 7, and if it <br>\nsounds like I'm complaining, that would be a sound similar to <br>\ncomplaining. I'm not complaining. I'm just talking because I'm allowed to.</p>\n<p>Like two months ago, I specifically asked, in a fairly precise way, <br>\n\"What's the difference between free variables and universally quantified <br>\nvariables, and is there a reason I shouldn't use free variables?\"</p>\n<p>I will now give you a reasonably close, informal, one sentence answer.</p>\n<p>ANSWER: A universally quantified bound variable is a logical statement, <br>\nwhere a free variable is an argument to a function.</p>\n<p>That's kind of huge difference don't you think? But two months ago, <br>\nbased on the zero answers like the above, I eventually started treating <br>\nfree variables like universally quantified variables.</p>\n<p>Who straightened me out? Nitpick.</p>\n<p>So I looked at the tutorials again, and \"instantiation of free <br>\nvariables\" became more clear. However, if I didn't write the software, <br>\nhow was I supposed to know how the proof engine is instantiating free <br>\nvariables when proving a theorem? Who's to say that it's not <br>\ninstantiating them in way that makes them equivalent to a universally <br>\nquantified variable? Obviously not.</p>\n<p>This substantiates my general guiding principle that it's a fool who <br>\npicks a field of study or a software product that doesn't provide enough <br>\ndocumentation and tools for people to be self-sufficient. To clarify, I <br>\nhaven't played the fool in this context.</p>\n<p>So I had four forms of an axiom that I thought were logically <br>\nequivalent. For my own reasons, I was going to axiomatize all four of <br>\nthem. However, being properly paranoid, I was trying to prove they were <br>\nequivalent, which led to me trying to disprove what had been for me a <br>\nbasic logic error, which led to counter examples on both the theorem and <br>\nits negation, which led to me understanding how free variables work.</p>\n<p>Thank you Nitpick, for automating the holding of my hand.</p>\n<p>theorem<br>\n\"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\nnitpick[sat_solver=MiniSat_JNI,timeout=172800,verbose,user_axioms]<br>\n(*Nitpick found a counterexample:<br>\nFree variables:<br>\n(A∷bool) = True<br>\n(B∷bool) = True *)<br>\noops</p>\n<p>theorem<br>\n\"(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B)\"<br>\nnitpick[sat_solver=MiniSat_JNI,timeout=172800,verbose,user_axioms]<br>\n(*Nitpick found a counterexample:<br>\nFree variables:<br>\n(A∷bool) = True<br>\n(B∷bool) = False*)<br>\noops</p>\n<p>theorem<br>\n\"~(!A. !B.(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\nnitpick[sat_solver=MiniSat_JNI,timeout=172800,verbose,user_axioms]<br>\n(<em>Nitpick found no counterexample.</em>)<br>\nby auto</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294223631,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898805
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 11.09.2012 22:07, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>Hello,<br>\nLike two months ago, I specifically asked, in a fairly precise way,<br>\n\"What's the difference between free variables and universally quantified<br>\nvariables, and is there a reason I shouldn't use free variables?\"<br>\n[...]<br>\nFor a free variable a not bound in any enclosing context, 'lemma \"P a\"'<br>\nis always equivalent to 'lemma \"!a. P a\"' in that each of these lemmas <br>\ncan be derived from the other.</p>\n</blockquote>\n<p>But the implicit all quantification happens on the outermost level of <br>\nthe term, which explains your examples below. They can be simplified as <br>\nfollows:</p>\n<blockquote>\n<p>theorem<br>\n\"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"</p>\n</blockquote>\n<p>\"!a b. ~(P a b)\"</p>\n<blockquote>\n<p>theorem<br>\n\"(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B)\"</p>\n</blockquote>\n<p>\"!a b. P a b\"</p>\n<blockquote>\n<p>theorem<br>\n\"~(!A. !B.(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"</p>\n</blockquote>\n<p>\"~(!a b. P a b)\"</p>\n<p>-- Lars</p>",
        "id": 294223644,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898811
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI really don't understand what you mean. Bound variables are not logical statements. And whether a variable is free or bound has no bearing on whether or not it can appear as a function's argument.</p>\n<p>Larry Paulson</p>",
        "id": 294223651,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898817
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 11.09.2012 22:07, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>Hello,<br>\nLike two months ago, I specifically asked, in a fairly precise way,<br>\n\"What's the difference between free variables and universally quantified<br>\nvariables, and is there a reason I shouldn't use free variables?\"<br>\n[...]<br>\nFor a free variable a not bound in any enclosing context, 'lemma \"P a\"'<br>\nis always equivalent to 'lemma \"!a. P a\"' in that each of these lemmas <br>\ncan be derived from the other.</p>\n</blockquote>\n<p>But the implicit all quantification happens on the outermost level of <br>\nthe term, which explains your examples below. They can be simplified as <br>\nfollows:</p>\n<blockquote>\n<p>theorem<br>\n\"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"</p>\n</blockquote>\n<p>\"!a b. ~(P a b)\"</p>\n<blockquote>\n<p>theorem<br>\n\"(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B)\"</p>\n</blockquote>\n<p>\"!a b. P a b\"</p>\n<blockquote>\n<p>theorem<br>\n\"~(!A. !B.(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"</p>\n</blockquote>\n<p>\"~(!a b. P a b)\"</p>\n<p>-- Lars</p>",
        "id": 294223661,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898823
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nI believe a more helpful insight here is simply that a formula with<br>\nfree variables may be contingent (i.e., its truth value may depend on<br>\nthe interpretation of the free variables, so that neither the formula<br>\nnor its negation are theorems), while a formula without free variables<br>\nis either true or false.</p>\n<p>See <a href=\"http://en.wikipedia.org/wiki/First-order_logic\">http://en.wikipedia.org/wiki/First-order_logic</a> (especially the first<br>\nthree sections) for further background.</p>\n<p>Best regards,<br>\nTjark</p>",
        "id": 294223672,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898830
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nDear Isabelle users</p>\n<blockquote>\n<p>Like two months ago, I specifically asked, in a fairly precise way,<br>\n\"What's the &gt;difference between free variables and universally quantified<br>\nvariables, and is &gt;there a reason I shouldn't use free variables?\"</p>\n</blockquote>\n<p>Whenever I see this kind of discussion I remember that I am  actually<br>\ninterested in  the (logical ) difference [in Isabelle]<br>\nbetween unknown variables and universally quantified variables,</p>\n<p>For instance, the different roles of variables in the following    two<br>\npropositions :</p>\n<p>all x. all y. all y. (x+y)+z =  x + (y+z)</p>\n<p>and</p>\n<p>(?x + ?y) + ?z = ?x + (?y + ?z).</p>\n<blockquote>\n<p>From what I read, the operational meaning of the second matches the<br>\nsemantics of the first. But from a logical point of view, in the second<br>\nproposition the variables are free, while in the first they are bound,<br>\nso I get confused about it. I believe I \"understand\" this,  but then reality<br>\nstrikes and I think \"who am I kidding\"?</p>\n</blockquote>\n<p>Cheers</p>\n<p>On Tue, Sep 11, 2012 at 5:07 PM, Gottfried Barrow<br>\n&lt;gottfried.barrow@gmx.com&gt;wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>It's not like I call up Bill Gates to learn about Windows 7, and if it<br>\nsounds like I'm complaining, that would be a sound similar to complaining.<br>\nI'm not complaining. I'm just talking because I'm allowed to.</p>\n<p>Like two months ago, I specifically asked, in a fairly precise way,<br>\n\"What's the difference between free variables and universally quantified<br>\nvariables, and is there a reason I shouldn't use free variables?\"</p>\n<p>I will now give you a reasonably close, informal, one sentence answer.</p>\n<p>ANSWER: A universally quantified bound variable is a logical statement,<br>\nwhere a free variable is an argument to a function.</p>\n<p>That's kind of huge difference don't you think? But two months ago, based<br>\non the zero answers like the above, I eventually started treating free<br>\nvariables like universally quantified variables.</p>\n<p>Who straightened me out? Nitpick.</p>\n<p>So I looked at the tutorials again, and \"instantiation of free variables\"<br>\nbecame more clear. However, if I didn't write the software, how was I<br>\nsupposed to know how the proof engine is instantiating free variables when<br>\nproving a theorem? Who's to say that it's not instantiating them in way<br>\nthat makes them equivalent to a universally quantified variable? Obviously<br>\nnot.</p>\n<p>This substantiates my general guiding principle that it's a fool who picks<br>\na field of study or a software product that doesn't provide enough<br>\ndocumentation and tools for people to be self-sufficient. To clarify, I<br>\nhaven't played the fool in this context.</p>\n<p>So I had four forms of an axiom that I thought were logically equivalent.<br>\nFor my own reasons, I was going to axiomatize all four of them. However,<br>\nbeing properly paranoid, I was trying to prove they were equivalent, which<br>\nled to me trying to disprove what had been for me a basic logic error,<br>\nwhich led to counter examples on both the theorem and its negation, which<br>\nled to me understanding how free variables work.</p>\n<p>Thank you Nitpick, for automating the holding of my hand.</p>\n<p>theorem<br>\n\"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\nnitpick[sat_solver=MiniSat_<strong>JNI,timeout=172800,verbose,</strong>user_axioms]<br>\n(*Nitpick found a counterexample:<br>\nFree variables:<br>\n(A∷bool) = True<br>\n(B∷bool) = True *)<br>\noops</p>\n<p>theorem<br>\n\"(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B)\"<br>\nnitpick[sat_solver=MiniSat_<strong>JNI,timeout=172800,verbose,</strong>user_axioms]<br>\n(*Nitpick found a counterexample:<br>\nFree variables:<br>\n(A∷bool) = True<br>\n(B∷bool) = False*)<br>\noops</p>\n<p>theorem<br>\n\"~(!A. !B.(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\nnitpick[sat_solver=MiniSat_<strong>JNI,timeout=172800,verbose,</strong>user_axioms]<br>\n(<em>Nitpick found no counterexample.</em>)<br>\nby auto</p>\n<p>Regards,<br>\nGB</p>\n</blockquote>",
        "id": 294223688,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898836
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYour question is about logic, not Isabelle.</p>\n<p>The formula (?x + ?y) + ?z = ?x + (?y + ?z) expresses a property about three quantities denoted by ?x, ?y and ?z. It is a convention in logic that any theorem involving free variables denotes the \"universal closure\" of that formula, here</p>\n<p>\"all x. all y. all y. (x+y)+z =  x + (y+z)\".</p>\n<p>Isabelle is designed to work best a minimum of logical symbols, hence the preference for stating theorems like</p>\n<p>P1 ==&gt; … Pn ==&gt; Q.</p>\n<p>Hardly any mathematics paper states such theorems as</p>\n<p>!x1 … xm. P1 &amp; … &amp; Pn —&gt; Q.</p>\n<p>Larry Paulson</p>",
        "id": 294223799,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898885
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nLars,</p>\n<p>And Makarius had talked some about outermost quantifiers in an email, <br>\nand how they get stripped away.</p>\n<p>Using Isabelle as a logic calculator, the basic idea is, \"GB, with your <br>\nlogic calculator, check yourself compulsively on the most basic of logic <br>\nideas, before claiming what is wrong. They will be embarrassed for you.\"</p>\n<p>However, I didn't have utmost confidence that, for the free variable <br>\nformula, there was an equivalent formula with bound variables, and that <br>\nI just needed to discover the rules, because I thought Nitpick had <br>\ntaught me the rules, when all it had done was slap my hand.</p>\n<p>In this case, my logical calculator doesn't help me use trial and error, <br>\nwith a little understanding, to prove the equivalency of a \"free <br>\nvariable formula\" with its equivalent \"bound variable formula\".</p>\n<p>Consider:</p>\n<p>theorem \"(!a. P a) &lt;-&gt; (!b. P b)\" apply auto done</p>\n<p>I want to make \"b\" a free variable so that I can prove, stated <br>\ninformally here,</p>\n<p>\"(!a. P a) &lt;-&gt; (P b)\"</p>\n<p>But once I make \"b\" free, I explicitly end up with,</p>\n<p>theorem \"!b. (!a. P a) &lt;-&gt; (P b)\" apply auto oops</p>\n<p>My logic calculator can never show me how free variables are implicitly <br>\nquantified. I just have to know. (I get in trouble when I make emphatic <br>\nclaims.)</p>\n<p>I can prove these two equivalent forms of a theorem, one with free <br>\nvariables, and one with bound:</p>\n<p>theorem<br>\n--\"3 implications proves 3 propositions are equivalent.\"<br>\n   \"!A B C.(A --&gt; B) &amp; (B --&gt; C) &amp; (C --&gt; A) &lt;-&gt;   (A &lt;-&gt; B) &amp; (A &lt;-&gt; C) <br>\n&amp; (B &lt;-&gt; C)\"<br>\nby auto</p>\n<p>theorem<br>\n--\"Now with free variables.\"<br>\n   \"(A --&gt; B) &amp; (B --&gt; C) &amp; (C --&gt; A) &lt;-&gt;   (A &lt;-&gt; B) &amp; (A &lt;-&gt; C) &amp; (B <br>\n&lt;-&gt; C)\"<br>\nby auto</p>\n<p>But I can't use the safety net of mechanized proofs to make sure that <br>\nI'm using free variables the way I think I'm using them, which I would <br>\ndo, even if something looked obvious.</p>\n<p>If you say, \"You've proved they're equivalent,\" then I say, \"No, I've <br>\nonly proved that they're both true.\" I have to take your word for it <br>\nthat, in the software, they are logically equivalent.</p>\n<p>Oh, well. Faith is required when I can't read the source code.</p>\n<p>Thanks for the help.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294223806,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898891
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nTjark,</p>\n<p>I think I'm straightened out, but the least little difference in what <br>\npeople say can make me wonder if I'm straightened out.</p>\n<p>I think what confused me is that I was assuming that how Nitpick uses a <br>\nformula in a theorem, such as,</p>\n<p>theorem \"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\noops</p>\n<p>is the same way the prover engine uses it. (I still wouldn't know what <br>\nthe software is doing.)</p>\n<p>If you had said before my email, \"GB, the truth value of '~((A --&gt; B --&gt; <br>\nA) --&gt; (A &lt;-&gt; B))' cannot be determined until you assign truth values to <br>\nA and B\", then at worst, I would have said, \"Tjark, I remember that now. <br>\nI used to be so good at thinking in terms of truth tables before <br>\nIsabelle started overloading me with information.\"</p>\n<p>Anyway, I always get a little extra out of these exchanges, even if I <br>\ndon't start them off right.</p>\n<p>Whatever is actually happening in Nitpick's engine and the provers <br>\nengine, I now know that with free variables, I can consider that Nitpick <br>\nis checking a \"theorem\" like this:</p>\n<p>definition false_formula::\"bool =&gt; bool =&gt; bool\" where<br>\n     \"false_formula A B == ~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\nvalue \"false_formula True True\" (*Output panel: \"False\" :: \"bool\" *)</p>\n<p>That helps a lot, because I was in this mindset that when Nitpick found <br>\ncounterexamples for both a \"theorem\" and its negation, that it had found <br>\nan inconsistency.</p>\n<p>On the other hand, I now consider that the prover engine has converted <br>\nmy theorem above to</p>\n<p>theorem \"!A B. ~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\noops</p>\n<p>even though Makarius has talked about quantifiers getting stripped away.</p>\n<p>Thanks for the help,<br>\nGB</p>",
        "id": 294223819,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898903
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;<br>\nThank you Paulson!</p>\n<p>I was assuming that the only possibility would be this folklore<br>\n(convention). I feel more<br>\nrelaxed now.</p>\n<p>However, in your book (ML for the Working Programmer, chapter 6, Reasoning<br>\nabout Functional<br>\nPrograms) you are [to my personal taste] very careful, and<br>\nall the theorems are stated with proper quantification, albeit expressed in<br>\n[English]<br>\nmetalanguage.</p>\n<p>Only the application of existential and universal introduction rules are<br>\nleft implicit (as<br>\nis common in usual mathematical prose).</p>\n<p>All the Best!</p>",
        "id": 294223833,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898915
    },
    {
        "content": "<p>From: Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt;</p>\n<blockquote>\n<p>However, in your book (ML for the Working Programmer, chapter 6, Reasoning<br>\nabout Functional<br>\nPrograms) you are [to my personal taste] very careful</p>\n</blockquote>\n<p>I mean this in the most positive way possible!</p>\n<p>On Wed, Sep 12, 2012 at 10:47 AM, Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Your question is about logic, not Isabelle.</p>\n<p>The formula (?x + ?y) + ?z = ?x + (?y + ?z) expresses a property about<br>\nthree quantities denoted by ?x, ?y and ?z. It is a convention in logic that<br>\nany theorem involving free variables denotes the \"universal closure\" of<br>\nthat formula, here</p>\n<p>\"all x. all y. all y. (x+y)+z =  x + (y+z)\".</p>\n<p>Isabelle is designed to work best a minimum of logical symbols, hence the<br>\npreference for stating theorems like</p>\n<p>P1 ==&gt; … Pn ==&gt; Q.</p>\n<p>Hardly any mathematics paper states such theorems as</p>\n<p>!x1 … xm. P1 &amp; … &amp; Pn —&gt; Q.</p>\n<p>Larry Paulson</p>\n<p>On 11 Sep 2012, at 23:26, Alfio Martini &lt;<a href=\"mailto:alfio.martini@acm.org\">alfio.martini@acm.org</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Isabelle users</p>\n<blockquote>\n<p>Like two months ago, I specifically asked, in a fairly precise way,<br>\n\"What's the &gt;difference between free variables and universally quantified<br>\nvariables, and is &gt;there a reason I shouldn't use free variables?\"</p>\n</blockquote>\n<p>Whenever I see this kind of discussion I remember that I am  actually<br>\ninterested in  the (logical ) difference [in Isabelle]<br>\nbetween unknown variables and universally quantified variables,</p>\n<p>For instance, the different roles of variables in the following    two<br>\npropositions :</p>\n<p>all x. all y. all y. (x+y)+z =  x + (y+z)</p>\n<p>and</p>\n<p>(?x + ?y) + ?z = ?x + (?y + ?z).</p>\n<blockquote>\n<p>From what I read, the operational meaning of the second matches the<br>\nsemantics of the first. But from a logical point of view, in the second<br>\nproposition the variables are free, while in the first they are bound,<br>\nso I get confused about it. I believe I \"understand\" this,  but then<br>\nreality<br>\nstrikes and I think \"who am I kidding\"?</p>\n</blockquote>\n<p>Cheers<br>\n</p>\n</blockquote>\n<p>On Tue, Sep 11, 2012 at 5:07 PM, Gottfried Barrow</p>\n<blockquote>\n<p>&lt;gottfried.barrow@gmx.com&gt;wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>It's not like I call up Bill Gates to learn about Windows 7, and if it<br>\nsounds like I'm complaining, that would be a sound similar to<br>\ncomplaining.<br>\nI'm not complaining. I'm just talking because I'm allowed to.</p>\n<p>Like two months ago, I specifically asked, in a fairly precise way,<br>\n\"What's the difference between free variables and universally quantified<br>\nvariables, and is there a reason I shouldn't use free variables?\"</p>\n<p>I will now give you a reasonably close, informal, one sentence answer.</p>\n<p>ANSWER: A universally quantified bound variable is a logical statement,<br>\nwhere a free variable is an argument to a function.</p>\n<p>That's kind of huge difference don't you think? But two months ago,<br>\nbased<br>\non the zero answers like the above, I eventually started treating free<br>\nvariables like universally quantified variables.</p>\n<p>Who straightened me out? Nitpick.</p>\n<p>So I looked at the tutorials again, and \"instantiation of free<br>\nvariables\"<br>\nbecame more clear. However, if I didn't write the software, how was I<br>\nsupposed to know how the proof engine is instantiating free variables<br>\nwhen<br>\nproving a theorem? Who's to say that it's not instantiating them in way<br>\nthat makes them equivalent to a universally quantified variable?<br>\nObviously<br>\nnot.</p>\n<p>This substantiates my general guiding principle that it's a fool who<br>\npicks<br>\na field of study or a software product that doesn't provide enough<br>\ndocumentation and tools for people to be self-sufficient. To clarify, I<br>\nhaven't played the fool in this context.</p>\n<p>So I had four forms of an axiom that I thought were logically<br>\nequivalent.<br>\nFor my own reasons, I was going to axiomatize all four of them. However,<br>\nbeing properly paranoid, I was trying to prove they were equivalent,<br>\nwhich<br>\nled to me trying to disprove what had been for me a basic logic error,<br>\nwhich led to counter examples on both the theorem and its negation,<br>\nwhich<br>\nled to me understanding how free variables work.</p>\n<p>Thank you Nitpick, for automating the holding of my hand.</p>\n<p>theorem<br>\n\"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\nnitpick[sat_solver=MiniSat_<strong>JNI,timeout=172800,verbose,</strong>user_axioms]<br>\n(*Nitpick found a counterexample:<br>\nFree variables:<br>\n(A∷bool) = True<br>\n(B∷bool) = True *)<br>\noops</p>\n<p>theorem<br>\n\"(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B)\"<br>\nnitpick[sat_solver=MiniSat_<strong>JNI,timeout=172800,verbose,</strong>user_axioms]<br>\n(*Nitpick found a counterexample:<br>\nFree variables:<br>\n(A∷bool) = True<br>\n(B∷bool) = False*)<br>\noops</p>\n<p>theorem<br>\n\"~(!A. !B.(A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\"<br>\nnitpick[sat_solver=MiniSat_<strong>JNI,timeout=172800,verbose,</strong>user_axioms]<br>\n(<em>Nitpick found no counterexample.</em>)<br>\nby auto</p>\n<p>Regards,<br>\nGB</p>\n</blockquote>\n<p>--<br>\nAlfio Ricardo Martini<br>\nPhD in Computer Science (TU Berlin)<br>\nAssociate Professor at Faculty of Informatics (PUCRS)<br>\nCoordenador do Curso de Ciência da Computação<br>\nAv. Ipiranga, 6681 - Prédio 32 - Faculdade de Informática<br>\n90619-900 -Porto Alegre - RS - Brasil</p>\n</blockquote>\n</blockquote>",
        "id": 294223861,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898928
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis was about the Pure connectives !! and ==&gt; which are not the same as <br>\nHOL ! and --&gt; (and more), even though sometimes people prefer to smash <br>\nthat distinction.  The point of Pure connectives is to describe the <br>\nstructure of a rule statement declaratively, so that the system knows what <br>\nis meant and how to compose the rules (by back-chaining and unification).</p>\n<p>This is in contrast to the usual FOL view on logic with many connectives, <br>\nand application-specific operations (set-theory, lattices etc.). <br>\nAutomated tools turn all this object-logic material <em>and</em> the Pure !! and <br>\n==&gt; into hash-brown, and try to serve that to the user.  This often works, <br>\nbut is no longer Pure logic, the one underlying Isar proofs.</p>\n<p>So when you state</p>\n<p>lemma \"!x y. A x --&gt; B y\"</p>\n<p>your result is again compact \"!x y. A x --&gt; B y\" (with its implicit <br>\nTrueprop wrapping).</p>\n<p>But when you state</p>\n<p>lemma \"!!x y. A x ==&gt; B y\"</p>\n<p>your result is schematic \"A ?x ==&gt; B ?y\".  You can get the same rule by <br>\nwriting the statement with explicit \"eigen-context\" as follows:</p>\n<p>lemma fixes x y assumes \"A x\" shows \"B y\"</p>\n<p>or</p>\n<p>lemma assumes \"A x\" shows \"B y\"</p>\n<p>in most situations, where x and y are implicitly free and thus ready to be <br>\nfixed at the outermost level.</p>\n<p>In the latter two forms, the resulting rules emerge naturally, without <br>\nnavigating through logical connectives first.</p>\n<p>Makarius</p>",
        "id": 294223896,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898952
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\n(This reply never come back to me, and it's been hours since 2 other <br>\nemails came back that were sent out later. I made a few edits.)</p>\n<p>On 9/11/2012 3:55 PM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I really don't understand what you mean. Bound variables are not <br>\nlogical statements. And whether a variable is free or bound has no <br>\nbearing on whether or not it can appear as a function's argument.</p>\n</blockquote>\n<p>Larry, I was only saying that if I have a variable x, and I say \"for <br>\nevery x\", then it's an informal statement saying that something is true <br>\nfor every x, where formally, \"for every x\" is, of course, not a <br>\nwell-formed formula.</p>\n<blockquote>\n<p>Your question is about logic, not Isabelle.</p>\n</blockquote>\n<p>It's not that I don't make the most basic of mistakes, but once Nitpick <br>\ntells me that (P x) is used differently than (!x. P x), I stop assuming <br>\nanything but what I've explicitly been told. I don't subscribe to <br>\n\"assume the obvious\".</p>\n<blockquote>\n<p>...It is a convention in logic that any theorem involving free <br>\nvariables denotes the \"universal closure\" of that formula...</p>\n</blockquote>\n<p>But it's not convention that a \"theorem\" formula is also a function that <br>\ncan be called with arguments. Convention has it that theorems are <br>\nsymbols on a piece of paper, or in a PDF, probably generated by LaTeX. <br>\nThat's the world I come from. When it comes software, it's best to know <br>\nexplicitly what is implicitly stated.</p>\n<p>I might have eventually discovered my misunderstanding of basic logic, <br>\nbut I jumped to conclusions when I saw that Nitpick treats a false <br>\nformula with free variables different than an equivalent false formula <br>\nwith bound variables.</p>\n<p>(1) theorem \"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\", is disproved with free <br>\nvariables True and True.</p>\n<p>(2) theorem \"!A.!B.~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\", is disproved with <br>\nSkolem constants True and True.</p>\n<p>By all appearances, (1) is being disproved by using the formula as a <br>\nfunction, and (2) is being disproved differently. I don't know. Nitpick <br>\ndoesn't tell me, and I'd hate to email Jasmin asking for details.</p>\n<p>I've never read in the documentation how to make the quantification of <br>\nfree variables explicit, only that free variables become schematic <br>\nvariables. So when I saw formulas being called as functions, and it <br>\nwasn't me calling them, then the result was that I only understood.</p>\n<p>I don't know that it could have been any different, unless maybe a <br>\ncouple of months had passed for me to think about it and experiment.</p>\n<p>\"Theorem\" formulas also being functions is a new game, and on my own, <br>\nusing trial and error, I was reduced to using Isabelle as a logic <br>\ncalculator (a very important use for it) to try and figure what the <br>\nrules are.</p>\n<p>Information overload can lead to misunderstanding, but assuming the <br>\nsupposedly obvious is no good either. It's better to be told explicitly <br>\nthe rules. This rule could be there somewhere in the documentation. <br>\nThere's a whole lot to read that I haven't read.</p>\n<p>I'm not actually using theorems as functions which take arguments, so I <br>\ndon't know the details of passing values.</p>\n<p>Your software has so many features, it's taking me a long time to get to <br>\nthem all, especially if I've started to use the software after only <br>\nlearning a few features. And someone like me has a tendency to jump to <br>\nmany intermediate conclusions, some partially right, some partially <br>\nwrong, many totally wrong, and periodically, some totally right.</p>\n<p>Regards,<br>\nGB</p>\n<blockquote>\n<p>On 11 Sep 2012, at 21:07, Gottfried Barrow&lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;  <br>\nwrote:</p>\n<blockquote>\n<p>Like two months ago, I specifically asked, in a fairly precise way, <br>\n\"What's the difference between free variables and universally <br>\nquantified variables, and is there a reason I shouldn't use free <br>\nvariables?\"</p>\n<p>I will now give you a reasonably close, informal, one sentence answer.</p>\n<p>ANSWER: A universally quantified bound variable is a logical <br>\nstatement, where a free variable is an argument to a function.</p>\n</blockquote>\n</blockquote>",
        "id": 294223910,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898964
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 9/11/2012 3:55 PM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I really don't understand what you mean. Bound variables are not logical statements. And whether a variable is free or bound has no bearing on whether or not it can appear as a function's argument.</p>\n</blockquote>\n<p>Larry, I was only saying that if I have a variable x, and I say \"for <br>\nevery x\", then it's an informal statement saying that something is true <br>\nfor every x, where formally, \"for every x\" is, of course, not a <br>\nwell-formed formula.</p>\n<blockquote>\n<p>Your question is about logic, not Isabelle.</p>\n<p>...It is a convention in logic that any theorem involving free variables denotes the \"universal closure\" of that formula...</p>\n</blockquote>\n<p>But it's not convention that the statement of a theorem/conjecture is <br>\nalso a function that can be called with arguments.</p>\n<p>I might have eventually discovered my misunderstanding of basic logic, <br>\nbut I jumped to conclusions when I saw that Nitpick treats a false <br>\nformula with free variables different than an equivalent false formula <br>\nwith bound variables.</p>\n<p>(1) theorem \"~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\", is disproved with free <br>\nvariables True and True.</p>\n<p>(2) theorem \"!A.!B.~((A --&gt; B --&gt; A) --&gt; (A &lt;-&gt; B))\", is disproved with <br>\nSkolem constants True and True.</p>\n<p>By all appearances, (1) is being disproved by using the formula as a <br>\nfunction, and (2) is being disproved differently. I don't know. Nitpick <br>\ndoesn't tell me, and I'd hate to email Jasmin asking for details.</p>\n<p>I've never read in the documentation how to make the quantification of <br>\nfree variables explicit, only that free variables become schematic <br>\nvariables. So you throw in that formulas act as functions, and through <br>\ntrial and error, I only discovered what I shouldn't do. I don't know <br>\nthat it could have been any different, unless maybe a couple of months <br>\nhad passed to think about it and experiment.</p>\n<p>Theorem/conjecture formulas also being functions is a new game, and on <br>\nmy own, using trial and error, I was reduced to using Isabelle as a <br>\nlogic calculator (a very important use for it) to try and figure what <br>\nthe rules are.</p>\n<p>Information overload can lead to misunderstanding, but assuming the <br>\nsupposedly obvious is no good either. It's better to be told explicitly <br>\nthe rules. This rule could be there somewhere in the documentation. <br>\nThere's a whole lot to read that I haven't read.</p>\n<p>I'm not actually using theorems as functions which take arguments, so I <br>\ndon't know the details of passing values.</p>\n<p>Your software has so many features, it takes me long time to get to them <br>\nall, especially if I've started to use the software after only learning <br>\na few features. And someone like me has a tendency to jump to many <br>\nintermediate conclusions, some partially right, some partially wrong, <br>\nmany totally wrong, and periodically, some totally right.</p>\n<p>Regards,<br>\nGB</p>\n<blockquote>\n<p>On 11 Sep 2012, at 21:07, Gottfried Barrow&lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;  wrote:</p>\n<blockquote>\n<p>Like two months ago, I specifically asked, in a fairly precise way, \"What's the difference between free variables and universally quantified variables, and is there a reason I shouldn't use free variables?\"</p>\n<p>I will now give you a reasonably close, informal, one sentence answer.</p>\n<p>ANSWER: A universally quantified bound variable is a logical statement, where a free variable is an argument to a function.</p>\n</blockquote>\n</blockquote>",
        "id": 294223927,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898977
    }
]