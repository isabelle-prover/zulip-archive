[
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;<br>\nI've been looking at theory Option for some time now, and I've been <br>\nwondering why it isn't used more often than it is. If you're going to <br>\nhave a type with an extra element called None, an obvious use of this <br>\n(obvious to me, anyway) would be to interpret None as \"undefined.\" <br>\nDivision of real numbers, for example, could be a function from (real <br>\noption) x (real option) -&gt; real option, with x/0 = None and None/x = <br>\ny/None = None. This is in fact exactly how floating point numbers <br>\nwork on computers today, except that there None is called NaN, which <br>\nis an abbreviation for Not a Number.<br>\nThe advantage of this over the current system of using zero to mean <br>\n\"undefined\" is that there you can't tell the difference, after the <br>\nfact, between a zero meaning \"undefined\" and a real zero. Another <br>\nadvantage for me is that if I'm trying to explain Isar to <br>\nmathematicians who are complex analysts or other non-algebraists, as <br>\nI intend to try to do, it could take a lot of explaining to convince <br>\nthem that defining x/0 to be 0 (rather than None) doesn't lead to <br>\nabsurdities. I've done complex analysis myself (my theorem says that <br>\nif S and S' are countable dense sets on the complex plane, there <br>\nexists an entire function taking S onto S') so I should be believable <br>\nwhen talking to complex analysts.<br>\nIs there a good reason why this wouldn't work in practice?</p>",
        "id": 294316966,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925748
    },
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nDear W. Douglas,</p>\n<p>Am 07.10.2014 um 22:37 schrieb W. Douglas Maurer &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;:</p>\n<blockquote>\n<p>I've been looking at theory Option for some time now, and I've been <br>\nwondering why it isn't used more often than it is. If you're going to <br>\nhave a type with an extra element called None, an obvious use of this <br>\n(obvious to me, anyway) would be to interpret None as \"undefined.\" <br>\nDivision of real numbers, for example, could be a function from (real <br>\noption) x (real option) -&gt; real option, with x/0 = None and None/x = <br>\ny/None = None. This is in fact exactly how floating point numbers <br>\nwork on computers today, except that there None is called NaN, which <br>\nis an abbreviation for Not a Number.<br>\nThe advantage of this over the current system of using zero to mean <br>\n\"undefined\" is that there you can't tell the difference, after the <br>\nfact, between a zero meaning \"undefined\" and a real zero.</p>\n</blockquote>\n<p>Any scheme is bound to have advantages and inconvenients. The difficulty above arises when you pass the result of division to another operator, e.g. \"+\". Would addition also take two options as argument? If yes, this leads to a number of issues:</p>\n<ol>\n<li>At definition time: All operations must specify a behavior in case some of their arguments are \"None\".</li>\n<li>At lemma-stating time: Many properties only hold for non-\"None\" values and must hence be written carefully, e.g. \"x + 1 &gt; x\" becomes \"Some x + Some 1 &gt; Some x\".</li>\n<li>At reasoning time: In your proofs, you then need to perform case distinctions.</li>\n</ol>\n<p>If not, this means you must introduce a \"case\" construct or a \"the\" each time you have a division inside, say, a \"+\". (And \"the\" isn't much better than not using options at all.)</p>\n<p>The situation with NaN is illustrative -- how many actual programs work correctly once NaNs have started appearing in computations? Many procedures are written without considering the case where the inputs are NaN, nor is much thought given to when they may arise in much of the programming out there (with some noteworthy exceptions). Why? Because the alternative is clumsy and tedious, and without formal verification or a rich type system it's hard to catch all cases.</p>\n<blockquote>\n<p>Another  advantage for me is that if I'm trying to explain Isar to <br>\nmathematicians who are complex analysts or other non-algebraists, as <br>\nI intend to try to do, it could take a lot of explaining to convince <br>\nthem that defining x/0 to be 0 (rather than None) doesn't lead to <br>\nabsurdities.</p>\n</blockquote>\n<p>This doesn't have to be difficult.</p>\n<p>As far as absurdities are concerned, there is no risk between \"x/0\" is <em>defined</em> as meaning something, as opposed to axiomatized. One could also define \"2 + 2 = 5\" and use it to prove many things; this wouldn't lead to absurdities either (but would give addition different properties than what we are used to). Absurdities start arising when you overconstraint your specification, which can in principle only happen if you use axioms (or re-definitions, which Isabelle forbids).</p>\n<p>To take another example: Donald Knuth defines the binomial coefficients also for negative values of either numbers. This is nonstandard, but he won't be able to derive false that way. Problems will only occur if you combine his results with those from Joe Hacker, who also extends the binomial coefficients but in a different, incompatible way. Clearly, one cannot use two different, incompatible definitions for the same symbol and mix-and-match the corresponding theorems naively.</p>\n<p>This having been said, there is a slight catch with \"x/0 = 0\". If your main definitions and theorems use division, this must be born in mind when reading them, communicating them to fellow mathematicians, etc. (The same issue arises with Knuth's theorems about binomial coefficients.) This is regrettable, and much could be said in favor of leaving \"x/0\" unspecificed or equal to \"undefined\". Or you could avoid Isabelle's division in your main interface with mathematicians, relying on your own division operator instead that would be unspecified for 0.</p>\n<p>In short, if it takes a lot of convincing, this means that either the explanation is unclear or that they don't understand what a definition is. I would presume mathematicians are familiar enough with definitions.</p>\n<p>Regards,</p>\n<p>Jasmin</p>",
        "id": 294316984,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925755
    },
    {
        "content": "<p>From: Andrew Butterfield &lt;<a href=\"mailto:Andrew.Butterfield@scss.tcd.ie\">Andrew.Butterfield@scss.tcd.ie</a>&gt;<br>\nDear W. Douglas,</p>\n<p>Jasmin is quite right about the disadvantage of Option, but if you still feel the need<br>\nto use it, it might be worth looking at “monads” - specifically the technique adopted by<br>\nHaskell programmers to handle I/O and structure large programs.</p>\n<p>This allows a form of encapsulation of an Option type where the propagation of None<br>\nis done “under the hood”</p>\n<p>For the Haskell take on monads see : <a href=\"http://www.haskell.org/haskellwiki/Monad\">http://www.haskell.org/haskellwiki/Monad</a><br>\nand <a href=\"http://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad\">http://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad</a></p>\n<p>You want the “Maybe Monad”   -  “Maybe” is Haskell for “Option\"</p>\n<p>I’m not sure what Isabelle/HOL theory introduces monads, but I am sure one exists.</p>\n<p>We did a comparative study reasoning about I/O in pure lazy functional languages<br>\nback in the early/mid noughties, looking at both Haskell (uses monads for I/O)<br>\nand Clean (uses uniqueness (linear) typing) and found it was easier to <em>reason</em> about<br>\nClean I/O if we cast it into a monadic-style (quite easy to do).</p>\n<p>So if you do want to reason about Option, <br>\nand are happy for the rule  None <code>op</code> * = None =  * <code>op</code> None to hold,<br>\nthen a monadic approach should be the easiest.</p>\n<p>Andrew.</p>\n<hr>\n<p>Andrew Butterfield     Tel: +353-1-896-2517     Fax: +353-1-677-2204<br>\nLero@TCD, Head of Foundations &amp; Methods Research Group<br>\nSchool of Computer Science and Statistics,<br>\nRoom G.39, O'Reilly Institute, Trinity College, University of Dublin<br>\n<a href=\"http://www.scss.tcd.ie/Andrew.Butterfield/\">http://www.scss.tcd.ie/Andrew.Butterfield/</a></p>\n<hr>",
        "id": 294316991,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925760
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<blockquote>\n<p>I’m not sure what Isabelle/HOL theory introduces monads, but I am sure one exists.<br>\nthere is the Monad_Syntax theory<br>\n(<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/1329679abb2d/src/HOL/Library/Monad_Syntax.thy\">http://isabelle.in.tum.de/repos/isabelle/file/1329679abb2d/src/HOL/Library/Monad_Syntax.thy</a>).</p>\n</blockquote>\n<p>However, this provides only syntax – Isabelle doesn't have a<br>\nformalisation of the concept ‘monad’ in the way Haskell does. This would<br>\nrequire parametrised typeclasses, which Isabelle doesn't have. It /does/<br>\nhave specific monads, such as the option monad, the set monad, state<br>\nmonads, non-deterministic monads, etc.</p>\n<p>Even if you do use monads, you still have the problem that you have to<br>\nstate all of your lemmas in the form ’Just 1 + Just 1 = Just 2‘.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294317054,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925766
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nJust a side remark. Syntax for Haskell-style do notation is made <br>\navailable by ~~/src/HOL/Library/Monad_Syntax.thy (where also a bind <br>\noperation for the option type is registered).</p>\n<p>However, at least for this Isabelle/HOL version of monads I would argue <br>\nthat not much is done \"under the hood\". It's just notational convenience <br>\n(the famous \"syntactic sugar\") and does not make reasoning any easier.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294317075,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925772
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nIt seems to me, division in HOL is another example of the use of types <br>\nin Isabelle/HOL, without the benefit of types.</p>\n<p>If I knew anything much more about HOL numbers than that the successor <br>\nof 0 is 1, I would define a new type, real_minus_zero, using typedef of <br>\ncourse, and then I would define division so that the denominator of <br>\ndivision is of type real_minus_zero. You can't get divide by zero if the <br>\ntype guarantees no zero in the denominator.</p>\n<p>The use of real_minus_zero would be effortless, because it would <br>\nautomatically get coerced to real. Or maybe it wouldn't be effortless, <br>\nbecause now there would be two types to deal with, instead of just one.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294317138,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925790
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nAn excellent opportunity to reply to myself, since what I have to say is <br>\nto no one in particular.</p>\n<p>I guess division of real numbers is completely tied into type classes, <br>\nso things aren't so simple as I said.</p>\n<p>But it's actually a sign of great progress when people can do a lot of <br>\ntalking about what they don't understand, yet be doing legitimate work <br>\nin mathematics.</p>\n<p>For example, how is it possible, with \"only\" a foundation of college <br>\nalgebra and trig, that many students, with absolutely no previous <br>\nexposure to calculus, can blow through so much material in 3 to 4 months <br>\nof the first course of the \"mother of all foundational math sequence of <br>\ncourses\" (calculus, vector calculus, and differential equations)?</p>\n<p>The reason is one single word, \"textbooks\". Even novices work through <br>\nproofs using the delta-epsilon definition of a limit, which was <br>\nformalized as recently as about 1820 by Weierstrass.</p>\n<p>So how does Isabelle/HOL measure up when it comes to my ability to do <br>\nmath in Isabelle/HOL? It doesn't. I can't do any of combinatorics, <br>\nnumber theory, or real analysis in Isabelle/HOL. I could do the abstract <br>\npart of abstract algebra, but nothing involving concrete mathematics.</p>\n<p>The problem is not that I don't know enough. The problem is that I need <br>\nto know too much. My lack of knowledge is no obstacle to my being able <br>\nto work in math in a traditional manner. I actually understand way more <br>\nmath that I'm able to use in Isbelle/HOL.</p>\n<p>The problem? Concrete numbers. Arithmetic. That's the problem. That's <br>\nthe road block.</p>\n<p>We have this situation. Isabelle/HOL formalizes mathematics up to <br>\ncomplex numbers, which is its standard entry point. Even more, HOL <br>\nformalizes the standard number systems, N, Z, Q, R, and C, in a classic <br>\nway, therefore making it \"very mathematical\", as opposed to \"computer <br>\nsciencey\".</p>\n<p>You might think that makes me happy. It made me happy, past tense.</p>\n<p>Continuing with \"the situation\", I can't use the number systems for <br>\narithmetic because I don't know the details, and because I don't know <br>\nthe details, I don't even know that the classic formalizations are <br>\nactually sufficient for concrete arithmetic, so that I don't eventually <br>\nhit a brick wall, which is an ever present risk when trying to use <br>\nIsabelle/HOL.</p>\n<p>Now, I go back to that single word, \"textbooks\". The mechanics of how to <br>\nuse Isabelle/HOL, as a software product, is documented fairly well, but <br>\nthe mathematics that makes up the foundation of Isabelle/HOL, it's not <br>\ndocumented at all. A person might take exception to my generalizations, <br>\nbut they're close enough for me.</p>\n<p>Isabelle/HOL is a logic of its own, and it's used to lay a type-theory <br>\nfoundation of mathematics up to complex numbers. I ask, \"After more than <br>\n20 years of development of mathematics in HOL, how many textbooks are <br>\nthere that explain the basic mathematics that's developed in HOL?\" The <br>\nanswer is zero.</p>\n<p>It's not like I'm picky. I'm flexible. Combinatorics, number theory, <br>\nabstract algebra, or real analysis, I could go with any of those. I just <br>\nneed to work through some math, as it's developed and proved in HOL, <br>\nwhere there's some heavy use of numbers, and I need to do it in a <br>\nmethodical manner, as in \"textbook manner\".</p>\n<p>I say I have a need. I don't actually have a need at all. If I had a <br>\nneed, I'd be in big trouble, because computer scientists who develop <br>\nmathematics in HOL, those computer scientists don't write textbooks <br>\nabout HOL-based mathematics. What they do is develop libraries, and I <br>\nthink I understand why, because to teach what you know is to spend time <br>\nnot advancing where you want to go. Just because I understand doesn't <br>\nmean I let myself be happy.</p>\n<p>It's best to see that someone has published explanations of the details <br>\nof where I think I want to go. With HOL, it's not enough that someone <br>\nwould tell me, \"It's all there. The formalization of N, Z, Q, R, and C <br>\nin Isabelle/HOL, or in src/HOL, or the AFP, that gives you the <br>\nfoundation of what you need.\"</p>\n<p>That's not enough. I shouldn't trust someone that much.</p>\n<p>The consequence is that I have to start at the bottom, and slowly work <br>\nmy way up, even though the number systems are already there.</p>\n<p>Okay, given that fact, my first choice is to build on what others have <br>\ndone, so where do I find documented guidance, commonly called <br>\n\"textbooks\", to teach me the details of number systems? (These details, <br>\nI wouldn't have to know if I was content working in traditional math, or <br>\nif textbooks existed to start me out at a high level of math in HOL, <br>\nsuch as real analysis.)</p>\n<p>I don't find the details from computer scientists who have developed <br>\nmathematics in Isabelle/HOL, because rather than writing textbooks about <br>\nthe details they've implemented, they forge ahead, for their own <br>\npleasure and enjoyment, which, I grudgingly admit, has undoubtedly <br>\nresulted in better automation tools, which do their own form of teaching.</p>\n<p>The details come from electrical engineers, and computer scientists who <br>\ndo research in computer arithmetic, and who also have taken the time to <br>\nwrite textbooks. I've done the hard work of tracking these down. It <br>\nwasn't obvious that these are where the details would come from, and it <br>\ncould be I won't use any of them to do the required work, just to do <br>\narithmetic:</p>\n<p>1) Fundamentals of Digital Logic with Verilog Design, 3rd, by Brown &amp; <br>\nVranesic</p>\n<p>2) Computer Arithmetic and Verilog HDL Fundamentals, by Cavanagh</p>\n<p>3) Arithmetic and Logic in Computer Systems, by Lu</p>\n<p>4) Modern Computer Algebra, 3rd, by Gathen &amp; Gerhard</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294317246,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925835
    }
]