[
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nDear Ramana Kumar and List Members,</p>\n<p>Thank you for your comment at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00061.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00061.html</a></p>\n<p>concerning my contribution available at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00057.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-December/msg00057.html</a></p>\n<p>I would also like to thank other members for their comments, which have been <br>\nnoted. As Ramana Kumar directly addresses the crucial question, I would like to <br>\nconcentrate on and answer it in section 2 further below.</p>\n<ol>\n<li>The presentations of the proof by Andrews and Rautenberg</li>\n</ol>\n<p>Syntactically, of course, in Paulson's claimed theorem 'proved_iff_proved_PfP'<br>\n    &gt; a  &lt;-&gt;  &gt; PfP \"a\"<br>\nthe right-hand side (PfP \"a\") is an object-language statement. We agree on this <br>\npoint.</p>\n<p>I refer to the meaning (\"semantically\"), since I am basically trying to <br>\nsummarize the (incorrect) presentations of the proof by Andrews and Rautenberg, <br>\nin which neither the claimed lemma 'proved_iff_proved_PfP' nor an equivalent <br>\nlemma is proven, but is used as a rule implicitly or explicitly justified by <br>\nits meaning; for example, in Andrews' presentation from the statement of the <br>\nleft-hand side (a) the statement of the right-hand side (PfP \"a\") is inferred <br>\nwhile giving an informal argument only (\"since the wff Proof represents the <br>\nnumerical relation Proof\" [Andrews, 2002, p. 314 (7101)]), thus violating <br>\nAndrews' own strict formal (syntactic) standards. Therefore, I previously wrote <br>\nthat \"step 7101.4 has no syntactic justification\" at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-July/msg00170.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2015-July/msg00170.html</a></p>\n<p>The purpose of this passage about Andrews and Rautenberg is to show that the <br>\npresentations of the proof by both of them fail, as they do not prove the <br>\nclaimed lemma 'proved_iff_proved_PfP' at all, although this would be a <br>\nnecessary step.</p>\n<p>So in order to verify whether Goedel's First Incompleteness Theorem can be <br>\nformally obtained, I suggest focusing on and proceeding to Paulson's <br>\npresentation discussed below.</p>\n<ol start=\"2\">\n<li>The presentation of the proof by Paulson</li>\n</ol>\n<p>Not only the right-hand side (PfP \"a\"), but also the left-hand side (a) is an <br>\nobject-language statement, which in Q0 always have type 'o' (Boolean truth <br>\nvalues). Moreover, if the proposition 'a' has type 'o' (omicron), it cannot <br>\nhave a second type \"tm\" (for term) unless this is identical with 'o', since in <br>\nQ0 all mathematical objects, including propositions (object-language <br>\nstatements), have exactly and only one type. It is not possible in Q0 to assign <br>\na second type to a mathematical object.</p>\n<p>Furthermore, the type \"tm\" (for term) in Isabelle is intended for the notation, <br>\nwhich in Q0 is not part of the object language itself. The purpose of types in <br>\nQ0 is to categorize mathematical objects, but not their names. Obviously types <br>\nin Isabelle are used for non-mathematical purposes also.</p>\n<p>If you believe that the type \"tm\" (for term) is definable within Q0, you could<br>\na) negatively refute my argument that any Goedel encoding function violates <br>\ntype restrictions, or<br>\nb) positively present the definition of type \"tm\" (for term) within Q0 on the <br>\nbasis of the primitive types 'o' (omicron, for truth values) and 'i' (iota, for <br>\nindividuals) only [cf. Andrews, 2002, p. 210, and Church, 1940, p. 56], as, for <br>\nexample, similar to nat = (o(oi)).</p>\n<p>In Q0, there are two kinds of definitions:</p>\n<ol>\n<li>The first kind of definition are _metamathematical_ definitions in order to <br>\nset up the formal language, for example</li>\n</ol>\n<ul>\n<li>the definition of (the concept of) type symbols [cf. Andrews, 2002, p. 210] or</li>\n<li>the definition of (the concept of) wffs (well-formed formulae) [cf. Andrews, <br>\n2002, p. 211].<br>\nDefinitions of this sort are very often \"defined inductively\" [Andrews, 2002, <br>\npp. 210, 211], fostering metamathematical reasoning (i.e., via arithmetization) <br>\nabout the properties of the object language. Unlike the other kind of <br>\ndefinition described below, they also often ramify into several possibilities, <br>\nwhich in the literature appear as a list \"(a) [...] / (b) [...] / (c) [...]\" <br>\n[Andrews, 2002, pp. 210, 211], and in the software implementation by Paulson as <br>\na list separated by the propositional connective for the logical relation \"or\", <br>\nrepresented by the vertical bar (single pipe) '|'.</li>\n</ul>\n<ol start=\"2\">\n<li>The second kind of definition are _mathematical_ definitions, which do <br>\nnothing more than add a shorthand (a label) to a more complex wff (well-formed <br>\nformula) in order to increase readability. Typical examples are</li>\n</ol>\n<ul>\n<li>\n<p>the definitions of the propositional connectives and the universal and <br>\nexistential quantifiers [cf. Andrews, 2002, p. 212],</p>\n</li>\n<li>\n<p>the definitions of subset, power set, union, etc. [cf. Andrews, 2002, p. 231],</p>\n</li>\n<li>the definition of the uniqueness quantifier [cf. Andrews, 2002, p. 233], and</li>\n<li>the definitions of zero, the successor function, and the set of natural <br>\nnumbers [cf. Andrews, 2002, p. 260].<br>\nAll these definitions explicitly use the formulation \"stands for\" [Andrews, <br>\n2002, pp. 212, 231, 233, 260] in order to express that they are only shorthands <br>\nwhich can be replaced by the original wff. The single exception also implies <br>\nsubstitution: \"Let [nat] be the type symbol (o(oi)).\" [Andrews, 2002, p. 260]<br>\nSo if we discuss the definability of \"tm\" within Q0, the first kind of <br>\ndefinition is out of question, since it would modify Q0, and therefore go <br>\nbeyond Q0 instead of remaining within.</li>\n</ul>\n<p>The difference between these two kinds of definition can be demonstrated best <br>\nby looking at the different logical levels and comparing their implementation <br>\nin R0 [cf. Kubota, 2015] and Isabelle:</p>\n<p>Logical level                         R0 implementation        Isabelle</p>\n<ol>\n<li>definition of the formal language  C++ classes (<em>.cc)       theories (</em>.thy)</li>\n<li>theorems and wff definitions       proofs (<em>.r0)            theories (</em>.thy)</li>\n<li>(Hilbert-style) metatheorems       proof templates (<em>.r0t)  theories (</em>.thy)</li>\n</ol>\n<p>A PDF sheet is available online at:<br>\n<a href=\"http://www.kenkubota.de/files/Logical_Layers_in_R0_and_Isabelle.pdf\">http://www.kenkubota.de/files/Logical_Layers_in_R0_and_Isabelle.pdf</a></p>\n<p>Since Isabelle uses natural deduction, Hilbert-style (informal) metatheorems <br>\nbecome symbolically representable and part of the formal language itself, <br>\nalthough within the formal language, theorems and metatheorems are still <br>\ndistinguished (with \"Meta-logic\" [Nipkow, 2015, p. 11] operators having a lower <br>\nprecedence than the \"Logic\" [Nipkow, 2015, p. 11] operators). So in Isabelle, <br>\nboth Hilbert-style theorems (level 2) and Hilbert-style metatheorems (level 3) <br>\nare merged into the same sphere (Isabelle theory files).</p>\n<p>Further, unlike the R0 implementation, which uses the concept of _direct <br>\nencoding_, Isabelle provides a \"logical framework; I prefer to speak of a <br>\nmeta-logic\" [Paulson, 1988, p. 3]. Thus, even the definition of the formal <br>\nlanguage (the object language, defined in level 1), which is hard-coded in the <br>\nC++ source code of the R0 implementation, in Isabelle is specified in the <br>\nIsabelle theory files.</p>\n<p>In summary, all three logical levels in Isabelle are merged into the same <br>\nsphere (Isabelle theory files), which provides advantages for the practical <br>\npurpose of automation, but also creates the danger of confusion of these <br>\ndifferent levels in the implementation.</p>\n<p>The first kind of definition (_metamathematical_ definitions) such as the <br>\ndefinition of the concept of type symbols or of the concept of wffs belongs to <br>\nlevel 1.<br>\nThe second kind of definition (_mathematical_ definitions) such as the <br>\ndefinition of propositional connectives belongs to level 2.<br>\n(Note that the terms \"metamathematical\" or \"meta-language\" are, depending on <br>\nthe context, sometimes used for notions of level 1, sometimes for notions of <br>\nlevel 3.)</p>\n<p>For example, the definition of propositional connectives in R0 is outsourced <br>\ninto *.r0 proof files (level 2), but the (general) definition of the concept of <br>\ntype symbols and the concept of wffs as such in R0 is implemented in the C++ <br>\nsource code (level 1), as they modify (set up) the formal language and could <br>\nnot be specified at a later time (i.e., in levels 2 or 3).<br>\n(Note that in the dependent type theory R0, types are also mathematical objects </p>\n<ul>\n<li>wffs -, and definable in level 2.)</li>\n</ul>\n<p>But the definition of type \"tm\" (for term) is exactly this kind of <br>\n_metamathematical_ definition (level 1). According to Paulson at<br>\n<a href=\"http://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-ar.pdf\">http://www.cl.cam.ac.uk/~lp15/papers/Formath/Goedel-ar.pdf</a> (p. 5),<br>\n\"[t]he following datatype defines the syntax of terms in the HF theory:</p>\n<p>nominal_datatype tm = Zero | Var name | Eats tm tm</p>\n<p>The type name (of variable names) has been created using the nominal framework.\"<br>\nSo both \"tm\" and \"fm\" (cf. ibid.) are actually - in terms of computer science - <br>\ndatatypes (\"nominal_datatype\"), and - in terms of mathematics - <br>\nmetamathematical notions or notions of the meta-language that describe <br>\n(\"define[ ] the syntax of\") the formal language (the object language) itself.</p>\n<p>Paulson's implementation of the Goedel encoding function as specified at<br>\n<a href=\"http://afp.sourceforge.net/browser_info/current/AFP/Incompleteness/Coding.html\">http://afp.sourceforge.net/browser_info/current/AFP/Incompleteness/Coding.html</a><br>\nmaps from datatypes \"tm\" and \"fm\" to datatype \"tm\":<br>\n\"class quot =<br>\n  fixes quot :: \"'a =&gt; tm\"  (\"⌈_⌉\")</p>\n<p>instantiation tm :: quot<br>\nbegin<br>\n  definition quot_tm :: \"tm =&gt; tm\"<br>\n    where \"quot_tm t = quot_dbtm (trans_tm [] t)\"</p>\n<p>instance ..<br>\nend</p>\n<p>[...]</p>\n<p>instantiation fm :: quot<br>\nbegin<br>\n  definition quot_fm :: \"fm =&gt; tm\"<br>\n    where \"quot_fm A = quot_dbfm (trans_fm [] A)\"</p>\n<p>instance ..<br>\nend\"</p>\n<p>In the application of a Goedel numbering function (or Goedel encoding function) <br>\n'G' to an argument 'a' as in<br>\n    Ga = n<br>\naccording to the restrictions on lambda application (case (b) in the definition <br>\nof wffs [cf. Andrews, 2002, p. 211]), 'G' must be a function with a valid <br>\nmathematical input (domain) type and a valid mathematical output (codomain) <br>\ntype, and the input (domain) type must match the type of 'a' (which must be a <br>\nconcrete mathematical type symbol of level 2).</p>\n<p>But \"tm\", \"fm\" and \"dbtm\" are clearly metamathematical notions (level 1) and <br>\nnot concrete mathema<br>\n[message truncated]</p>",
        "id": 294664302,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171151
    }
]