[
    {
        "content": "<p>From: Kevin Van Horn &lt;<a href=\"mailto:kevin@ksvanhorn.com\">kevin@ksvanhorn.com</a>&gt;<br>\nI'm trying to figure out if Isabelle is the right theorem prover /  <br>\nproof assistant for my needs, or if I should use something else. I'm  <br>\nwriting a Bayesian model compiler, something that will turn a  <br>\nspecification of a joint probability distribution plus indication of  <br>\nwhat variables are observed into Markov chain Monte Carlo code for  <br>\nestimating the parameters.  There are existing software packages that  <br>\ndo something similar -- WinBUGS/OpenBUGS, JAGS, and hbc -- but they  <br>\nall have limitations that are unacceptable for my purposes, and it  <br>\nappears that I'll need some sort of theorem proving to overcome those  <br>\nlimitations.</p>\n<p>Here are the features I'm looking for:</p>\n<ul>\n<li>\n<p>Interactive theorem proving (Isabelle seems to do this very well).</p>\n</li>\n<li>\n<p>Ability to write new proof tactics.</p>\n</li>\n<li>\n<p>Ability to do derivational proofs where I know the form of what I  <br>\nwant to prove but don't know exactly what I'm proving until I reach  <br>\nthe end.  For example, I'm doing a chain of A1 = A2 = ... An, and only  <br>\nwhen I reach an An that has the form I want do I know I'm done and  <br>\nknow that A1 = An is what I'm proving.  Likewise, I might be trying to  <br>\nfind a usable upper bound: B1 &lt;= B2 &lt;= ... Bn.</p>\n</li>\n<li>\n<p>Ability to call the theorem prover as a software module in a larger  <br>\nsystem (no user interaction). This would be for tasks simple enough to  <br>\nfully automate with appropriate tactics, or to spit out subgoals for  <br>\nwhich the user will need to provide proofs in harder cases.</p>\n</li>\n</ul>\n<p>How does Isabelle rate on these?  Would a different theorem prover /  <br>\nproof assistant better fill these requirements?</p>\n<p>(BTW I'm also looking at  HOL Light and HOL 4, which appear have the  <br>\nlast three features above, but my impression is that Isabelle is  <br>\neasier to use for interactive proof and that the finished proofs are  <br>\neasier to read.)</p>",
        "id": 294132534,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843333
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Dienstag, den 15.03.2011, 09:11 -0600 schrieb Kevin Van Horn:</p>\n<blockquote>\n<p>I'm trying to figure out if Isabelle is the right theorem prover /  <br>\nproof assistant for my needs, or if I should use something else. I'm  <br>\nwriting a Bayesian model compiler, something that will turn a  <br>\nspecification of a joint probability distribution plus indication of  <br>\nwhat variables are observed into Markov chain Monte Carlo code for  <br>\nestimating the parameters.  There are existing software packages that  <br>\ndo something similar -- WinBUGS/OpenBUGS, JAGS, and hbc -- but they  <br>\nall have limitations that are unacceptable for my purposes, and it  <br>\nappears that I'll need some sort of theorem proving to overcome those  <br>\nlimitations.</p>\n</blockquote>\n<p>Which mathematical background theories do you need? We have measure /<br>\nprobability theory but no theorems about MCMC.</p>\n<blockquote>\n<p>Here are the features I'm looking for:</p>\n<ul>\n<li>Interactive theorem proving (Isabelle seems to do this very well).</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Ability to write new proof tactics.</li>\n</ul>\n</blockquote>\n<p>I only developed two small tactics in Isabelle, so I'm not very<br>\nexperienced. But I think it is very easy to do in the interactive mode<br>\nin ProofGeneral. Open a new theory and write </p>\n<p>theory test imports Main begin</p>\n<p>ML {*<br>\n    fun .....<br>\n  *}</p>\n<p>theorem \"...\"<br>\n    apply (tactic {* ML code *})</p>\n<p>This is a very nice playground for ideas, later you can of course move<br>\nyour code to its own ML-file.</p>\n<p>A introduction on how to write tactics is found in the Isabelle<br>\nCookbook:<br>\n<a href=\"http://www4.in.tum.de/~urbanc/cgi-bin/repos.cgi/isabelle-cookbook/raw-file/tip/progtutorial.pdf\">http://www4.in.tum.de/~urbanc/cgi-bin/repos.cgi/isabelle-cookbook/raw-file/tip/progtutorial.pdf</a></p>\n<p>For further information take a look at the reference manuals<br>\n<a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a></p>\n<blockquote>\n<ul>\n<li>Ability to do derivational proofs where I know the form of what I  <br>\nwant to prove but don't know exactly what I'm proving until I reach  <br>\nthe end.  For example, I'm doing a chain of A1 = A2 = ... An, and only  <br>\nwhen I reach an An that has the form I want do I know I'm done and  <br>\nknow that A1 = An is what I'm proving.  Likewise, I might be trying to  <br>\nfind a usable upper bound: B1 &lt;= B2 &lt;= ... Bn.</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>Ability to call the theorem prover as a software module in a larger  <br>\nsystem (no user interaction). This would be for tasks simple enough to  <br>\nfully automate with appropriate tactics, or to spit out subgoals for  <br>\nwhich the user will need to provide proofs in harder cases.</li>\n</ul>\n</blockquote>\n<p>Some proof methods in Isabelle work in this way. The most often used<br>\nproof method (simp) works in this way. The user states a goal, applies<br>\nthe simplifier and gets back the simplified goal where he can apply<br>\nfurther tactics. (This should also answer the previous question.)</p>\n<blockquote>\n<p>How does Isabelle rate on these?  Would a different theorem prover /  <br>\nproof assistant better fill these requirements?</p>\n<p>(BTW I'm also looking at  HOL Light and HOL 4, which appear have the  <br>\nlast three features above, but my impression is that Isabelle is  <br>\neasier to use for interactive proof and that the finished proofs are  <br>\neasier to read.)</p>\n</blockquote>\n<p>I have no experiences with HOL Light or HOL 4. When you write your<br>\nproofs in Isar (Isabelle's proof language) they are more readable.<br>\nHowever I assume the OCaml / ML internals of HOL Light / HOL 4 are<br>\neasier to understand.</p>\n<p>Greetings,<br>\n  Johannes</p>",
        "id": 294132544,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843336
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 15 Mar 2011, Kevin Van Horn wrote:</p>\n<blockquote>\n<ul>\n<li>Ability to call the theorem prover as a software module in a larger <br>\nsystem (no user interaction). This would be for tasks simple enough to <br>\nfully automate with appropriate tactics, or to spit out subgoals for <br>\nwhich the user will need to provide proofs in harder cases.</li>\n</ul>\n</blockquote>\n<p>It is not as simple as I would like it to have, but it works, and people <br>\nhave done it before, e.g. in the Isabelle/TLA+ IDE.  (The technology for <br>\nIsabelle integration is about to change substantially in the coming <br>\nyears.)</p>\n<blockquote>\n<p>How does Isabelle rate on these?  Would a different theorem prover / <br>\nproof assistant better fill these requirements?</p>\n<p>(BTW I'm also looking at HOL Light and HOL 4, which appear have the last <br>\nthree features above, but my impression is that Isabelle is easier to <br>\nuse for interactive proof and that the finished proofs are easier to <br>\nread.)</p>\n</blockquote>\n<p>The HOL systems are not fundamentally different.  There is mainly a <br>\ntendency towards more frugal system infrastructure -- HOL Light is <br>\nespecially minimalistic.</p>\n<p>The main alternative to Isabelle is actually Coq, but there are quite <br>\ndifferent logical foundations, and less system manuals.</p>\n<p>Makarius</p>",
        "id": 294132558,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843341
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMike Gordon has a snappy description of the differences between the systems: Isabelle provide a better out-of-the-box experience, while HOL is better as an API for writing code that performs inference.</p>\n<p>The various versions of HOL are much simpler internally than Isabelle, which simplifies programming. On the other hand, HOL provides less automation and its proof scripts are unintelligible.</p>\n<p>Larry Paulson</p>",
        "id": 294132571,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843348
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nLets say these systems are closer to the bare metal, so it is easier to <br>\nread through the full sources and get an impression how it works.</p>\n<p>In contrast, Isabelle is more like a Linux kernel over the bare logic, so <br>\nyou need to understand some higher structuring principles.  I would <br>\nnonetheless call it simple, in the same way a modern operating system is <br>\n\"simple\".</p>\n<p>BTW, the APIs of Isabelle have been cleaned up a lot in recent years, so <br>\nthe simplicity is now easier to see, without the historical baggage <br>\ngetting in the way.</p>\n<p>Makarius</p>",
        "id": 294132605,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843359
    },
    {
        "content": "<p>From: Kevin Van Horn &lt;<a href=\"mailto:kevin@ksvanhorn.com\">kevin@ksvanhorn.com</a>&gt;<br>\nOn Mar 16, 2011, at 4:14 AM, Johannes Hölzl wrote:</p>\n<blockquote>\n<p>Am Dienstag, den 15.03.2011, 09:11 -0600 schrieb Kevin Van Horn:</p>\n<blockquote>\n<p>... I'm  writing a Bayesian model compiler, something that will  <br>\nturn a<br>\nspecification of a joint probability distribution plus indication of<br>\nwhat variables are observed into Markov chain Monte Carlo code for<br>\nestimating the parameters. ... it  appears that I'll need some sort  <br>\nof theorem proving...</p>\n</blockquote>\n<p>Which mathematical background theories do you need? We have measure /<br>\nprobability theory but no theorems about MCMC.</p>\n</blockquote>\n<p>In addition to measure / probability theory, I'll need some linear  <br>\nalgebra (matrix/vector multiplication, inverse, determinants) and  <br>\nstandard probability density functions (gamma, normal, multivariate  <br>\nnormal, etc.).  A lot of what I'll be doing looks a lot more like  <br>\ncomputer algebra (transforming a function into an equivalent function,  <br>\nwhere equivalent means the same up to a constant of proportionality,  <br>\nand deriving gradients of multivariate functions), along with  <br>\nestablishing some upper bounds and proving some arithmetic results on  <br>\narray indices.</p>\n<p>I don't expect to be proving anything very deep. Mostly, I'm looking  <br>\nto automate (at least partially) a process that is currently done by  <br>\ndoing the math by hand following some pretty standard patterns; I need  <br>\nto be able to automate new patterns as they arise; and I need to be  <br>\nhighly confident that the results are correct.</p>\n<blockquote>\n<p>A introduction on how to write tactics is found in the Isabelle<br>\nCookbook:<br>\n<a href=\"http://www4.in.tum.de/~urbanc/cgi-bin/repos.cgi/isabelle-cookbook/raw-file/tip/progtutorial.pdf\">http://www4.in.tum.de/~urbanc/cgi-bin/repos.cgi/isabelle-cookbook/raw-file/tip/progtutorial.pdf</a></p>\n</blockquote>\n<p>Great!  This seems to have a lot of the missing pieces I couldn't find  <br>\nin the tutorial and reference manual.</p>\n<p>-- Kevin</p>",
        "id": 294132736,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843399
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou should also look at the \"implementation\" manual.</p>\n<p>Makarius</p>",
        "id": 294132749,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843402
    },
    {
        "content": "<p>From: Timothy McKenzie &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nI'm a little surprised that no-one has yet mentioned the \"also ... <br>\nalso ... finally ...\" constructions in Isabelle/Isar.  There's an <br>\nexample in isar-overview in the documentation provided with <br>\nIsabelle, and more technical documentation in isar-ref.  It can be <br>\nused with both = and &lt;= (and, I think, even mixing the two), but <br>\nit behaves unusually with &gt;=, because this is an abbreviation for <br>\n&lt;=, and the abbreviation seems to be expanded before Isabelle <br>\ndecides which is the left-hand side and which is the right-hand <br>\nside for the purposes of the next step.</p>\n<p>And if you don't know exactly what you want to prove before you've <br>\nproven it, you can make the statement of the lemma almost <br>\narbitrary until you've figured out what you want to prove, and <br>\nthen go back and change it.  I haven't used the other HOLs, but I <br>\nunderstand that they work backwards, manipulating the goal until <br>\nit becomes \"True\", so in those you'd need to state the lemma <br>\ncorrectly before you begin.</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/JCHlrTTFt5fPkSRIIcXKKlIw/signature.asc\">signature.asc</a></p>",
        "id": 294132768,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843409
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nTimothy McKenzie wrote:<br>\nWell, in either system you can always start with a goal of the form<br>\nP1 ==&gt; P2 ==&gt; ... ==&gt; Pn ==&gt; X<br>\nwhere Pi are your real assumptions, and X is literally just \"X\", a <br>\nplaceholder,<br>\nwhile you see what you can get from P1 to Pn - when you have decided <br>\nwhat X should be you go back and repeat the same proof</p>\n<p>Jeremy</p>",
        "id": 294132791,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843415
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIsar calculations are parameterized by a collection of rules that are <br>\ndeclared as \"trans\" and can be inspected via print_trans_rules.  This is a <br>\nvery general mechanism to combine relations in a forward manner. It also <br>\nworks with substitution of equalities or inequalities (with some care <br>\nabout higher-order unification).</p>\n<p>The &gt;= abbreviations indeed do not fit in here.  There were added as adhoc <br>\nfeature when I was not looking, and still await to be integrated properly.</p>\n<p>Makarius</p>",
        "id": 294132830,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843427
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nMaybe the recent 'notepad' is also of some interest here, it nicely shows <br>\nhow Isabelle/Isar works without goal states getting in the way:</p>\n<p>notepad<br>\nbegin</p>\n<p>fix x y z :: 'a<br>\n   assume \"x = y\"<br>\n   also assume \"... = z\"<br>\n   finally have \"x = z\" .</p>\n<p>end</p>\n<p>Makarius</p>",
        "id": 294132863,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843439
    }
]