[
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nHi!</p>\n<p>In my work on formalizing process calculi I tripped over an issue with<br>\nIsabelleâ€™s locale support that I donâ€™t fully understand. Iâ€™d like to<br>\nillustrate this issue here with some example code that is much simpler<br>\nthan my actual code but still illustrates the point.</p>\n<p>Letâ€™s first introduce a locale that describes an involution, which we<br>\ncall negation.</p>\n<p>locale negation =<br>\n      fixes neg :: \"'a â‡’ 'a\" (\"âŠ– _\" [81] 80)<br>\n      assumes neg_neg: \"âŠ– (âŠ– x) = x\"</p>\n<p>Next, we define a locale that captures structures with a zero and a<br>\nsubtraction. Any such structure gives rise to a negation and this<br>\nnegation has the property that it turns zero into zero.</p>\n<p>locale zero_subtraction =<br>\n      fixes zero :: 'a (\"ğŸ¬\")<br>\n      fixes sub :: \"['a, 'a] â‡’ 'a\" (infixl \"âŠ–\" 65)<br>\n      assumes sub_sub: \"x âŠ– (x âŠ– y) = y\"<br>\n      assumes sub_zero_2: \"x âŠ– ğŸ¬ = x\"<br>\n    begin</p>\n<p>abbreviation neg :: \"'a â‡’ 'a\" (\"âŠ– _\" [81] 80) where<br>\n      \"âŠ– x â‰¡ ğŸ¬ âŠ– x\"</p>\n<p>sublocale negation neg<br>\n    proof<br>\n      fix x<br>\n      show \"ğŸ¬ âŠ– (ğŸ¬ âŠ– x) = x\" using sub_sub .<br>\n    qed</p>\n<p>lemma neg_zero:<br>\n      shows \"âŠ– ğŸ¬ = ğŸ¬\"<br>\n      using sub_zero_2 .</p>\n<p>end</p>\n<p>Finally, we introduce a locale that captures structures with a negation,<br>\na zero, and an addition. We import the <code>negation</code> locale to provide the<br>\nnegation structure. Since we can construct subtraction from negation and<br>\naddition, we introduce a corresponding sublocale relationship. This<br>\nwould give us another instance of the <code>negation</code> locale through the<br>\n<code>zero_subtraction</code> locale, albeit with the same negation operator. To<br>\nprevent this, we use <code>rewrites</code>.</p>\n<p>locale negation_zero_addition =<br>\n      negation neg for neg :: \"'a â‡’ 'a\" (\"âŠ– _\" [81] 80) +<br>\n      fixes zero :: 'a (\"ğŸ¬\")<br>\n      fixes add :: \"['a, 'a] â‡’ 'a\" (infixl \"âŠ•\" 65)<br>\n      assumes add_zero_1: \"ğŸ¬ âŠ• x = x\"<br>\n      assumes add_zero_2: \"x âŠ• ğŸ¬ = x\"<br>\n      assumes neg_add: \"âŠ– (x âŠ• y) = (âŠ– x) âŠ• (âŠ– y)\"<br>\n      assumes add_cancel: \"x âŠ• ((âŠ– x) âŠ• y) = y\"<br>\n    begin</p>\n<p>abbreviation sub :: \"['a, 'a] â‡’ 'a\" (infixl \"âŠ–\" 65) where<br>\n      \"x âŠ– y â‰¡ x âŠ• (âŠ– y)\"</p>\n<p>sublocale zero_subtraction zero sub<br>\n      rewrites \"zero_subtraction.neg zero sub = neg\"<br>\n    proof unfold_locales<br>\n      fix x and y<br>\n      have \"x âŠ• (âŠ– (x âŠ• (âŠ– y))) = x âŠ• ((âŠ– x) âŠ• (âŠ– (âŠ– y)))\"<br>\n        (is \"?l = _\")<br>\n        by (simp add: neg_add)<br>\n      also have \"â€¦ = âŠ– (âŠ– y)\"<br>\n        using add_cancel .<br>\n      also have \"â€¦ = y\" (is \"_ = ?r\")<br>\n        using neg_neg .<br>\n      finally show \"?l = ?r\" .<br>\n    next<br>\n      fix x<br>\n      have \"x âŠ• (âŠ– ğŸ¬) = (âŠ– (âŠ– x)) âŠ• (âŠ– ğŸ¬)\" (is \"?l = _\")<br>\n        by (simp add: neg_neg)<br>\n      also have \"â€¦ = âŠ– (âŠ– x âŠ• ğŸ¬)\"<br>\n        by (simp add: neg_add)<br>\n      also have \"â€¦ = âŠ– (âŠ– x)\"<br>\n        by (simp add: add_zero_2)<br>\n      also have \"â€¦ = x\" (is \"_ = ?r\")<br>\n        using neg_neg .<br>\n      finally show \"?l = ?r\" .<br>\n    next<br>\n      show \"(Î»x. ğŸ¬ âŠ• (âŠ– x)) = (Î»x. âŠ– x)\"<br>\n        by (simp add: add_zero_1)<br>\n    qed</p>\n<p>end</p>\n<p>Now letâ€™s have an interpretation.</p>\n<p>interpretation int:<br>\n      negation_zero_addition â€¹uminus :: int â‡’ intâ€º â€¹0â€º â€¹(+)â€º<br>\n      by unfold_locales simp_all</p>\n<p>I would like to prove that integer negation applied to the integer 0 is<br>\nthe integer 0 again, using <code>neg_zero</code>. However, that doesnâ€™t work.</p>\n<p>lemma \"- (0 :: int) = 0\"<br>\n      using int.neg_zero<br>\n      oops</p>\n<p>The problem is that the goal refers to the negation operator of <code>int</code>,<br>\nwhile <code>int.neg_zero</code> refers to the negation operator that is derived<br>\nfrom zero and subtraction (where subtraction in turn is derived from<br>\nnegation and addition). Both negation operators are equal, and I have<br>\ncommunicated this equality by means of <code>rewrites</code>, but Isabelle<br>\napparently doesnâ€™t make use of it.</p>\n<p>How can I use facts like <code>int.neg_zero</code> in proofs of lemmas like the<br>\nabove one?</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759422,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198871
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Wolfgang Jeltsch,</p>\n<p>Given that there has not been an official answer for more than one day, at<br>\nleast, I can offer a plausible practical solution. Nevertheless, please<br>\nkeep in mind that I am not familiar with the implementation details of the<br>\nlocale interpretation and the associated rewrite algorithms (if you still<br>\ninsist on getting to the heart of the matter, it should possible to debug<br>\nthe source code).</p>\n<p>Using only the abbreviation âŠ– from negation_zero_addition, the suggested<br>\nrewrite rule is 'zero_subtraction.neg ğŸ¬ sub=neg', which stands for '(âŠ–)<br>\nğŸ¬=neg' (see print_abbrevs). The theorem neg_zero is '((âŠ–) ğŸ¬) ğŸ¬ = ğŸ¬'<br>\nafter the interpretation inside the context of negation_zero_addition.<br>\nTrying to (for example) unfold '((âŠ–) ğŸ¬) ğŸ¬ = ğŸ¬' with '(âŠ–) ğŸ¬=neg' leaves<br>\nthe theorem in the same state:</p>\n<p>lemma subst1: \"(âŠ–) ğŸ¬ â‰¡ neg\" by (simp add: add_zero_1)<br>\nlemma subst2: \"(âŠ–) ğŸ¬ x â‰¡ neg x\" by (simp add: add_zero_1)<br>\nlemma thm1: \"((âŠ–) ğŸ¬) ğŸ¬ â‰¡ ğŸ¬\" sorry<br>\nlemma thm2: \"f ((âŠ–) ğŸ¬) â‰¡ f ((âŠ–) ğŸ¬)\" by simp<br>\nthm thm1[unfolded subst1] (<em>unfold 'fails': ((âŠ–) ğŸ¬) ğŸ¬ â‰¡ ğŸ¬</em>)<br>\nthm thm1[unfolded subst2] (<em>unfold 'succeeds': âŠ– ğŸ¬ â‰¡ ğŸ¬</em>)<br>\nthm thm2[unfolded subst1] (<em>unfold 'succeeds': ?f neg â‰¡ ?f neg</em>)<br>\nthm thm2[unfolded subst2] (<em>unfold 'succeeds': ?f neg â‰¡ ?f neg</em>)</p>\n<p>I can only speculate as to whether the mechanism used for rewriting during<br>\nthe locale interpretation is not entirely different from the technique used<br>\nin the example above. As you can also see from the code listing above, the<br>\nrewrite rule '(âŠ–) ğŸ¬ x â‰¡ neg x' achieves the desired effect. Using the<br>\nabbreviation zero_subtraction.neg, this rule becomes 'zero_subtraction.neg<br>\nğŸ¬ sub x= neg x'. However, it may be even safer to replace the abbreviation<br>\nzero_subtraction.neg with a predefined constant (see the code listing<br>\nbelow). In this case, 'zero_subtraction.neg ğŸ¬ sub= neg' is, most likely,<br>\nthe best available option: I expect that with this rule all plausible<br>\nalgorithms would agree on the intuitively desired solution unanimously.</p>\n<p>It would be useful for me if someone who knows the details of the<br>\nimplementation could confirm/correct/provide further explanation of any<br>\naspects of what is stated above.</p>\n<p>Thank you</p>\n<p>locale negation =<br>\n  fixes neg :: \"'a â‡’ 'a\" (\"âŠ– _\" [81] 80)<br>\n  assumes neg_neg: \"âŠ– (âŠ– x) = x\"</p>\n<p>locale zero_subtraction =<br>\n  fixes zero :: 'a (\"ğŸ¬\")<br>\n  fixes sub :: \"['a, 'a] â‡’ 'a\" (infixl \"âŠ–\" 65)<br>\n  assumes sub_sub: \"x âŠ– (x âŠ– y) = y\"<br>\n  assumes sub_zero_2: \"x âŠ– ğŸ¬ = x\"<br>\nbegin</p>\n<p>definition neg :: \"'a â‡’ 'a\" (\"âŠ– _\" [81] 80) where<br>\n  \"âŠ– x â‰¡ ğŸ¬ âŠ– x\"</p>\n<p>sublocale negation neg<br>\nproof<br>\n  fix x<br>\n  show \"âŠ– (âŠ– x) = x\" unfolding neg_def using sub_sub .<br>\nqed</p>\n<p>lemma neg_zero:<br>\n  shows \"âŠ– ğŸ¬ = ğŸ¬\"<br>\n  unfolding neg_def using sub_zero_2 .</p>\n<p>end</p>\n<p>locale negation_zero_addition =<br>\n  negation neg for neg :: \"'a â‡’ 'a\" (\"âŠ– _\" [81] 80) +<br>\n  fixes zero :: 'a (\"ğŸ¬\")<br>\n  fixes add :: \"['a, 'a] â‡’ 'a\" (infixl \"âŠ•\" 65)<br>\n  assumes add_zero_1: \"ğŸ¬ âŠ• x = x\"<br>\n  assumes add_zero_2: \"x âŠ• ğŸ¬ = x\"<br>\n  assumes neg_add: \"âŠ– (x âŠ• y) = (âŠ– x) âŠ• (âŠ– y)\"<br>\n  assumes add_cancel: \"x âŠ• ((âŠ– x) âŠ• y) = y\"<br>\nbegin</p>\n<p>abbreviation sub :: \"['a, 'a] â‡’ 'a\" (infixl \"âŠ–\" 65) where<br>\n  \"x âŠ– y â‰¡ x âŠ• (âŠ– y)\"</p>\n<p>lemma zs: \"zero_subtraction zero sub\"<br>\nproof unfold_locales<br>\n  fix x and y<br>\n  have \"x âŠ• (âŠ– (x âŠ• (âŠ– y))) = x âŠ• ((âŠ– x) âŠ• (âŠ– (âŠ– y)))\"<br>\n    (is \"?l = _\")<br>\n    by (simp add: neg_add)<br>\n  also have \"â€¦ = âŠ– (âŠ– y)\"<br>\n    using add_cancel .<br>\n  also have \"â€¦ = y\" (is \"_ = ?r\")<br>\n    using neg_neg .<br>\n  finally show \"?l = ?r\" .<br>\nnext<br>\n  fix x<br>\n  have \"x âŠ• (âŠ– ğŸ¬) = (âŠ– (âŠ– x)) âŠ• (âŠ– ğŸ¬)\" (is \"?l = _\")<br>\n    by (simp add: neg_neg)<br>\n  also have \"â€¦ = âŠ– (âŠ– x âŠ• ğŸ¬)\"<br>\n    by (simp add: neg_add)<br>\n  also have \"â€¦ = âŠ– (âŠ– x)\"<br>\n    by (simp add: add_zero_2)<br>\n  also have \"â€¦ = x\" (is \"_ = ?r\")<br>\n    using neg_neg .<br>\n  finally show \"?l = ?r\" .<br>\nqed</p>\n<p>sublocale zero_subtraction zero sub<br>\n  rewrites \"zero_subtraction.neg zero sub = neg\"<br>\napply(rule zs)<br>\nunfolding zero_subtraction.neg_def[OF zs]<br>\nby (simp add: add_zero_1)</p>\n<p>thm neg_zero (* âŠ– ğŸ¬ = ğŸ¬ *)</p>\n<p>end</p>\n<p>interpretation int:<br>\n  negation_zero_addition â€¹uminus :: int â‡’ intâ€º â€¹0â€º â€¹(+)â€º<br>\n  by unfold_locales simp_all</p>\n<p>thm int.neg_zero (* - 0 = 0 *)</p>",
        "id": 294759484,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198885
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Wolfgang,</p>\n<p>The problem is that you have abbreviations on the left-hand sides of your rewrites instead <br>\nof definitions. Abbreviations are just for pretty-printing; in the underlying term <br>\nrepresentation, abbreviations are unfolded (and implicitly beta-reduced). If you change <br>\nthe abbreviations into definitions, then the rewriting works as expected. Let's look into <br>\nwhat's happening:</p>\n<p>The term sub in zero_subtraction expands to Î»x y. (+) x (uminus y).<br>\nSo the rewrite rule \"zero_subtraction.neg zero sub = neg\" becomes in the interpretation</p>\n<p>Î»x. int.sub 0 x = uminus</p>\n<p>This has a lambda on the left, i.e., it is not a proper higher-order rewrite rule. It will <br>\nonly kick in if there is a lambda abstraction in the term. However, in the theorem <br>\nneg_zero, the beta redex \"(Î»x. int.sub 0 x) 0\" has already been reduced so int.sub 0 0. So <br>\nthe rewrite rule will not trigger. If you turn the abbreviations into definitions, there <br>\nwill be no trouble with implicit beta-reductions and eta-expansions.</p>\n<p>Alternatively, you can add the eta-expanded version of the rewrite rule:</p>\n<p>sublocale zero_subtraction zero sub<br>\n       rewrites \"zero_subtraction.neg zero sub = neg\"<br>\n         and \"zero_subtraction.neg zero sub x = neg x\"</p>\n<p>Then it works as expected.</p>\n<p>Hope this helps<br>\nAndreas</p>",
        "id": 294759496,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198894
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nThanks a lot for your explanation.</p>\n<p>I cannot say that I fully understand whatâ€™s going on, but I think I have<br>\nat least some idea.</p>\n<p>Apparently, the problem has more to do with rewriting in general than<br>\nwith rewriting introduced by <code>rewrites</code> clauses. I understand that<br>\ndefining <code>(âŠ–)</code> as an abbreviation via <code>x âŠ– y â‰¡ x âŠ• ((âŠ–) y)</code> doesnâ€™t play<br>\nwell with using a partial application of it in the rewrite rule <code>(âŠ–) ğŸ¬ \n= neg</code>. While <code>(âŠ–) ğŸ¬</code> looks like an innocent partial application, it i<br>\ns in fact <code>Î»y. ğŸ¬ âŠ• ((âŠ–) y)</code>, and thus the rewrite rule doesnâ€™t match i<br>\nn places where <code>(âŠ–)</code> is fully applied, because full applications of<br>\nabbreviations donâ€™t use <code>Î»</code>.</p>\n<p>When using <code>definition</code> instead of <code>abbreviation</code>, rewriting takes place<br>\nin all your above four examples. I think Iâ€™ll fix my issue by switching<br>\nfrom <code>abbreviation</code> to <code>definition</code> for <code>(âŠ–)</code>.</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198899
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nThanks for this detailed explanation. It seems that the thoughts I just<br>\nsent as a response to mailing-list anonymous went in the right<br>\ndirection. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759573,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198922
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Wolfgang Jeltsch,</p>\n<p>Thank you for your reply. Indeed, my initial intention was to write a<br>\nreply with the fully expanded abbreviations (initially, in writing the<br>\nreply I analysed the structure of the terms in ML and used<br>\nConv.rewrs_conv instead of the attribute â€˜unfolded'). However, I<br>\nthought that the structure of the terms would be apparent anyway,<br>\nbecause there was only one abbreviation left to expand.</p>\n<p>Unfortunately, I have not studied, specifically, the HRS algorithms<br>\n(apparently) used for rewriting in lambda calculus/Isabelle.<br>\nTherefore, I did not wish to speculate any further as to why <code>Î»y. ğŸ¬ âŠ•\n((âŠ–) y)</code> is not suitable as the lhs of a rule. In any case, the answer<br>\nby Andreas Lochbihler provides a more complete explanation.</p>\n<p>Thank you</p>",
        "id": 294759653,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198959
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I apologise for posting the same message twice. The mistake is related<br>\nto making the first attempt to use a different email client that would<br>\nenable the modification of the email headers (related to my previous<br>\npost <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00110.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00110.html</a>).<br>\nI will make every attempt to ensure that this does not happen again.</p>\n<p>Thank you</p>",
        "id": 294759667,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198969
    }
]