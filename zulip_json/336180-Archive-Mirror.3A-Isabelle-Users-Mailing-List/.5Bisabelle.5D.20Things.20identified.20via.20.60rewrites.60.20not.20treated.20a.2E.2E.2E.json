[
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nHi!</p>\n<p>In my work on formalizing process calculi I tripped over an issue with<br>\nIsabelle’s locale support that I don’t fully understand. I’d like to<br>\nillustrate this issue here with some example code that is much simpler<br>\nthan my actual code but still illustrates the point.</p>\n<p>Let’s first introduce a locale that describes an involution, which we<br>\ncall negation.</p>\n<p>locale negation =<br>\n      fixes neg :: \"'a ⇒ 'a\" (\"⊖ _\" [81] 80)<br>\n      assumes neg_neg: \"⊖ (⊖ x) = x\"</p>\n<p>Next, we define a locale that captures structures with a zero and a<br>\nsubtraction. Any such structure gives rise to a negation and this<br>\nnegation has the property that it turns zero into zero.</p>\n<p>locale zero_subtraction =<br>\n      fixes zero :: 'a (\"𝟬\")<br>\n      fixes sub :: \"['a, 'a] ⇒ 'a\" (infixl \"⊖\" 65)<br>\n      assumes sub_sub: \"x ⊖ (x ⊖ y) = y\"<br>\n      assumes sub_zero_2: \"x ⊖ 𝟬 = x\"<br>\n    begin</p>\n<p>abbreviation neg :: \"'a ⇒ 'a\" (\"⊖ _\" [81] 80) where<br>\n      \"⊖ x ≡ 𝟬 ⊖ x\"</p>\n<p>sublocale negation neg<br>\n    proof<br>\n      fix x<br>\n      show \"𝟬 ⊖ (𝟬 ⊖ x) = x\" using sub_sub .<br>\n    qed</p>\n<p>lemma neg_zero:<br>\n      shows \"⊖ 𝟬 = 𝟬\"<br>\n      using sub_zero_2 .</p>\n<p>end</p>\n<p>Finally, we introduce a locale that captures structures with a negation,<br>\na zero, and an addition. We import the <code>negation</code> locale to provide the<br>\nnegation structure. Since we can construct subtraction from negation and<br>\naddition, we introduce a corresponding sublocale relationship. This<br>\nwould give us another instance of the <code>negation</code> locale through the<br>\n<code>zero_subtraction</code> locale, albeit with the same negation operator. To<br>\nprevent this, we use <code>rewrites</code>.</p>\n<p>locale negation_zero_addition =<br>\n      negation neg for neg :: \"'a ⇒ 'a\" (\"⊖ _\" [81] 80) +<br>\n      fixes zero :: 'a (\"𝟬\")<br>\n      fixes add :: \"['a, 'a] ⇒ 'a\" (infixl \"⊕\" 65)<br>\n      assumes add_zero_1: \"𝟬 ⊕ x = x\"<br>\n      assumes add_zero_2: \"x ⊕ 𝟬 = x\"<br>\n      assumes neg_add: \"⊖ (x ⊕ y) = (⊖ x) ⊕ (⊖ y)\"<br>\n      assumes add_cancel: \"x ⊕ ((⊖ x) ⊕ y) = y\"<br>\n    begin</p>\n<p>abbreviation sub :: \"['a, 'a] ⇒ 'a\" (infixl \"⊖\" 65) where<br>\n      \"x ⊖ y ≡ x ⊕ (⊖ y)\"</p>\n<p>sublocale zero_subtraction zero sub<br>\n      rewrites \"zero_subtraction.neg zero sub = neg\"<br>\n    proof unfold_locales<br>\n      fix x and y<br>\n      have \"x ⊕ (⊖ (x ⊕ (⊖ y))) = x ⊕ ((⊖ x) ⊕ (⊖ (⊖ y)))\"<br>\n        (is \"?l = _\")<br>\n        by (simp add: neg_add)<br>\n      also have \"… = ⊖ (⊖ y)\"<br>\n        using add_cancel .<br>\n      also have \"… = y\" (is \"_ = ?r\")<br>\n        using neg_neg .<br>\n      finally show \"?l = ?r\" .<br>\n    next<br>\n      fix x<br>\n      have \"x ⊕ (⊖ 𝟬) = (⊖ (⊖ x)) ⊕ (⊖ 𝟬)\" (is \"?l = _\")<br>\n        by (simp add: neg_neg)<br>\n      also have \"… = ⊖ (⊖ x ⊕ 𝟬)\"<br>\n        by (simp add: neg_add)<br>\n      also have \"… = ⊖ (⊖ x)\"<br>\n        by (simp add: add_zero_2)<br>\n      also have \"… = x\" (is \"_ = ?r\")<br>\n        using neg_neg .<br>\n      finally show \"?l = ?r\" .<br>\n    next<br>\n      show \"(λx. 𝟬 ⊕ (⊖ x)) = (λx. ⊖ x)\"<br>\n        by (simp add: add_zero_1)<br>\n    qed</p>\n<p>end</p>\n<p>Now let’s have an interpretation.</p>\n<p>interpretation int:<br>\n      negation_zero_addition ‹uminus :: int ⇒ int› ‹0› ‹(+)›<br>\n      by unfold_locales simp_all</p>\n<p>I would like to prove that integer negation applied to the integer 0 is<br>\nthe integer 0 again, using <code>neg_zero</code>. However, that doesn’t work.</p>\n<p>lemma \"- (0 :: int) = 0\"<br>\n      using int.neg_zero<br>\n      oops</p>\n<p>The problem is that the goal refers to the negation operator of <code>int</code>,<br>\nwhile <code>int.neg_zero</code> refers to the negation operator that is derived<br>\nfrom zero and subtraction (where subtraction in turn is derived from<br>\nnegation and addition). Both negation operators are equal, and I have<br>\ncommunicated this equality by means of <code>rewrites</code>, but Isabelle<br>\napparently doesn’t make use of it.</p>\n<p>How can I use facts like <code>int.neg_zero</code> in proofs of lemmas like the<br>\nabove one?</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759422,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198871
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Wolfgang Jeltsch,</p>\n<p>Given that there has not been an official answer for more than one day, at<br>\nleast, I can offer a plausible practical solution. Nevertheless, please<br>\nkeep in mind that I am not familiar with the implementation details of the<br>\nlocale interpretation and the associated rewrite algorithms (if you still<br>\ninsist on getting to the heart of the matter, it should possible to debug<br>\nthe source code).</p>\n<p>Using only the abbreviation ⊖ from negation_zero_addition, the suggested<br>\nrewrite rule is 'zero_subtraction.neg 𝟬 sub=neg', which stands for '(⊖)<br>\n𝟬=neg' (see print_abbrevs). The theorem neg_zero is '((⊖) 𝟬) 𝟬 = 𝟬'<br>\nafter the interpretation inside the context of negation_zero_addition.<br>\nTrying to (for example) unfold '((⊖) 𝟬) 𝟬 = 𝟬' with '(⊖) 𝟬=neg' leaves<br>\nthe theorem in the same state:</p>\n<p>lemma subst1: \"(⊖) 𝟬 ≡ neg\" by (simp add: add_zero_1)<br>\nlemma subst2: \"(⊖) 𝟬 x ≡ neg x\" by (simp add: add_zero_1)<br>\nlemma thm1: \"((⊖) 𝟬) 𝟬 ≡ 𝟬\" sorry<br>\nlemma thm2: \"f ((⊖) 𝟬) ≡ f ((⊖) 𝟬)\" by simp<br>\nthm thm1[unfolded subst1] (<em>unfold 'fails': ((⊖) 𝟬) 𝟬 ≡ 𝟬</em>)<br>\nthm thm1[unfolded subst2] (<em>unfold 'succeeds': ⊖ 𝟬 ≡ 𝟬</em>)<br>\nthm thm2[unfolded subst1] (<em>unfold 'succeeds': ?f neg ≡ ?f neg</em>)<br>\nthm thm2[unfolded subst2] (<em>unfold 'succeeds': ?f neg ≡ ?f neg</em>)</p>\n<p>I can only speculate as to whether the mechanism used for rewriting during<br>\nthe locale interpretation is not entirely different from the technique used<br>\nin the example above. As you can also see from the code listing above, the<br>\nrewrite rule '(⊖) 𝟬 x ≡ neg x' achieves the desired effect. Using the<br>\nabbreviation zero_subtraction.neg, this rule becomes 'zero_subtraction.neg<br>\n𝟬 sub x= neg x'. However, it may be even safer to replace the abbreviation<br>\nzero_subtraction.neg with a predefined constant (see the code listing<br>\nbelow). In this case, 'zero_subtraction.neg 𝟬 sub= neg' is, most likely,<br>\nthe best available option: I expect that with this rule all plausible<br>\nalgorithms would agree on the intuitively desired solution unanimously.</p>\n<p>It would be useful for me if someone who knows the details of the<br>\nimplementation could confirm/correct/provide further explanation of any<br>\naspects of what is stated above.</p>\n<p>Thank you</p>\n<p>locale negation =<br>\n  fixes neg :: \"'a ⇒ 'a\" (\"⊖ _\" [81] 80)<br>\n  assumes neg_neg: \"⊖ (⊖ x) = x\"</p>\n<p>locale zero_subtraction =<br>\n  fixes zero :: 'a (\"𝟬\")<br>\n  fixes sub :: \"['a, 'a] ⇒ 'a\" (infixl \"⊖\" 65)<br>\n  assumes sub_sub: \"x ⊖ (x ⊖ y) = y\"<br>\n  assumes sub_zero_2: \"x ⊖ 𝟬 = x\"<br>\nbegin</p>\n<p>definition neg :: \"'a ⇒ 'a\" (\"⊖ _\" [81] 80) where<br>\n  \"⊖ x ≡ 𝟬 ⊖ x\"</p>\n<p>sublocale negation neg<br>\nproof<br>\n  fix x<br>\n  show \"⊖ (⊖ x) = x\" unfolding neg_def using sub_sub .<br>\nqed</p>\n<p>lemma neg_zero:<br>\n  shows \"⊖ 𝟬 = 𝟬\"<br>\n  unfolding neg_def using sub_zero_2 .</p>\n<p>end</p>\n<p>locale negation_zero_addition =<br>\n  negation neg for neg :: \"'a ⇒ 'a\" (\"⊖ _\" [81] 80) +<br>\n  fixes zero :: 'a (\"𝟬\")<br>\n  fixes add :: \"['a, 'a] ⇒ 'a\" (infixl \"⊕\" 65)<br>\n  assumes add_zero_1: \"𝟬 ⊕ x = x\"<br>\n  assumes add_zero_2: \"x ⊕ 𝟬 = x\"<br>\n  assumes neg_add: \"⊖ (x ⊕ y) = (⊖ x) ⊕ (⊖ y)\"<br>\n  assumes add_cancel: \"x ⊕ ((⊖ x) ⊕ y) = y\"<br>\nbegin</p>\n<p>abbreviation sub :: \"['a, 'a] ⇒ 'a\" (infixl \"⊖\" 65) where<br>\n  \"x ⊖ y ≡ x ⊕ (⊖ y)\"</p>\n<p>lemma zs: \"zero_subtraction zero sub\"<br>\nproof unfold_locales<br>\n  fix x and y<br>\n  have \"x ⊕ (⊖ (x ⊕ (⊖ y))) = x ⊕ ((⊖ x) ⊕ (⊖ (⊖ y)))\"<br>\n    (is \"?l = _\")<br>\n    by (simp add: neg_add)<br>\n  also have \"… = ⊖ (⊖ y)\"<br>\n    using add_cancel .<br>\n  also have \"… = y\" (is \"_ = ?r\")<br>\n    using neg_neg .<br>\n  finally show \"?l = ?r\" .<br>\nnext<br>\n  fix x<br>\n  have \"x ⊕ (⊖ 𝟬) = (⊖ (⊖ x)) ⊕ (⊖ 𝟬)\" (is \"?l = _\")<br>\n    by (simp add: neg_neg)<br>\n  also have \"… = ⊖ (⊖ x ⊕ 𝟬)\"<br>\n    by (simp add: neg_add)<br>\n  also have \"… = ⊖ (⊖ x)\"<br>\n    by (simp add: add_zero_2)<br>\n  also have \"… = x\" (is \"_ = ?r\")<br>\n    using neg_neg .<br>\n  finally show \"?l = ?r\" .<br>\nqed</p>\n<p>sublocale zero_subtraction zero sub<br>\n  rewrites \"zero_subtraction.neg zero sub = neg\"<br>\napply(rule zs)<br>\nunfolding zero_subtraction.neg_def[OF zs]<br>\nby (simp add: add_zero_1)</p>\n<p>thm neg_zero (* ⊖ 𝟬 = 𝟬 *)</p>\n<p>end</p>\n<p>interpretation int:<br>\n  negation_zero_addition ‹uminus :: int ⇒ int› ‹0› ‹(+)›<br>\n  by unfold_locales simp_all</p>\n<p>thm int.neg_zero (* - 0 = 0 *)</p>",
        "id": 294759484,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198885
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:mail@andreas-lochbihler.de\">mail@andreas-lochbihler.de</a>&gt;<br>\nDear Wolfgang,</p>\n<p>The problem is that you have abbreviations on the left-hand sides of your rewrites instead <br>\nof definitions. Abbreviations are just for pretty-printing; in the underlying term <br>\nrepresentation, abbreviations are unfolded (and implicitly beta-reduced). If you change <br>\nthe abbreviations into definitions, then the rewriting works as expected. Let's look into <br>\nwhat's happening:</p>\n<p>The term sub in zero_subtraction expands to λx y. (+) x (uminus y).<br>\nSo the rewrite rule \"zero_subtraction.neg zero sub = neg\" becomes in the interpretation</p>\n<p>λx. int.sub 0 x = uminus</p>\n<p>This has a lambda on the left, i.e., it is not a proper higher-order rewrite rule. It will <br>\nonly kick in if there is a lambda abstraction in the term. However, in the theorem <br>\nneg_zero, the beta redex \"(λx. int.sub 0 x) 0\" has already been reduced so int.sub 0 0. So <br>\nthe rewrite rule will not trigger. If you turn the abbreviations into definitions, there <br>\nwill be no trouble with implicit beta-reductions and eta-expansions.</p>\n<p>Alternatively, you can add the eta-expanded version of the rewrite rule:</p>\n<p>sublocale zero_subtraction zero sub<br>\n       rewrites \"zero_subtraction.neg zero sub = neg\"<br>\n         and \"zero_subtraction.neg zero sub x = neg x\"</p>\n<p>Then it works as expected.</p>\n<p>Hope this helps<br>\nAndreas</p>",
        "id": 294759496,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198894
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nThanks a lot for your explanation.</p>\n<p>I cannot say that I fully understand what’s going on, but I think I have<br>\nat least some idea.</p>\n<p>Apparently, the problem has more to do with rewriting in general than<br>\nwith rewriting introduced by <code>rewrites</code> clauses. I understand that<br>\ndefining <code>(⊖)</code> as an abbreviation via <code>x ⊖ y ≡ x ⊕ ((⊖) y)</code> doesn’t play<br>\nwell with using a partial application of it in the rewrite rule <code>(⊖) 𝟬 \n= neg</code>. While <code>(⊖) 𝟬</code> looks like an innocent partial application, it i<br>\ns in fact <code>λy. 𝟬 ⊕ ((⊖) y)</code>, and thus the rewrite rule doesn’t match i<br>\nn places where <code>(⊖)</code> is fully applied, because full applications of<br>\nabbreviations don’t use <code>λ</code>.</p>\n<p>When using <code>definition</code> instead of <code>abbreviation</code>, rewriting takes place<br>\nin all your above four examples. I think I’ll fix my issue by switching<br>\nfrom <code>abbreviation</code> to <code>definition</code> for <code>(⊖)</code>.</p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759512,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198899
    },
    {
        "content": "<p>From: Wolfgang Jeltsch &lt;<a href=\"mailto:wolfgang-it@jeltsch.info\">wolfgang-it@jeltsch.info</a>&gt;<br>\nThanks for this detailed explanation. It seems that the thoughts I just<br>\nsent as a response to mailing-list anonymous went in the right<br>\ndirection. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>All the best,<br>\nWolfgang</p>",
        "id": 294759573,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198922
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear Wolfgang Jeltsch,</p>\n<p>Thank you for your reply. Indeed, my initial intention was to write a<br>\nreply with the fully expanded abbreviations (initially, in writing the<br>\nreply I analysed the structure of the terms in ML and used<br>\nConv.rewrs_conv instead of the attribute ‘unfolded'). However, I<br>\nthought that the structure of the terms would be apparent anyway,<br>\nbecause there was only one abbreviation left to expand.</p>\n<p>Unfortunately, I have not studied, specifically, the HRS algorithms<br>\n(apparently) used for rewriting in lambda calculus/Isabelle.<br>\nTherefore, I did not wish to speculate any further as to why <code>λy. 𝟬 ⊕\n((⊖) y)</code> is not suitable as the lhs of a rule. In any case, the answer<br>\nby Andreas Lochbihler provides a more complete explanation.</p>\n<p>Thank you</p>",
        "id": 294759653,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198959
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I apologise for posting the same message twice. The mistake is related<br>\nto making the first attempt to use a different email client that would<br>\nenable the modification of the email headers (related to my previous<br>\npost <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00110.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-July/msg00110.html</a>).<br>\nI will make every attempt to ensure that this does not happen again.</p>\n<p>Thank you</p>",
        "id": 294759667,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198969
    }
]