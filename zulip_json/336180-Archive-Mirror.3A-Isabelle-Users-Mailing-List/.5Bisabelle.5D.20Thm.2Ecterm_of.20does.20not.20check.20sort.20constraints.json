[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHello,</p>\n<p>I just noticed something odd. When a polymorphic constant has sort<br>\nconstraints, you normally cannot write it down with its type<br>\ninstantiated to a type that does not fulfil these constraints. For<br>\ninstance, term ‹-1 :: nat› or @{cterm \"-1 :: nat\"} do not work because<br>\n\"nat\" does not have the sort \"uminus\".</p>\n<p>However, when one constructs the term in ML and then certifies it with<br>\nThm.cterm_of, it works:</p>\n<p>ML_val ‹<br>\nlet<br>\n  val t =<br>\n    Const (@{const_name \"uminus\"}, @{typ \"nat ⇒ nat\"}) $ @{term \"1 :: nat\"}<br>\nin<br>\n  Thm.cterm_of @{context} t<br>\nend<br>\n›</p>\n<p>This outputs</p>\n<p>val it = \"- (1::nat)\": cterm</p>\n<p>It's not a soundness problem, but I still find this behaviour somewhat<br>\nunexpected. I would naïvely have thought it would be impossible to get<br>\nthe natural number \"-1\". Is this intended? Is this for performance reasons?</p>\n<p>(For those wondering why this is okay on a logical level, the negation<br>\noperator is essentially acting as an unspecified function, so \"-1 ::<br>\nnat\" is not /actually/ -1, but it is equal to some \"proper\" natural<br>\nnumber, we just don't know which one)</p>\n<p>Manuel</p>",
        "id": 294828056,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245350
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 29/05/2020 12:00, Manuel Eberl wrote:</p>\n<blockquote>\n<p>I just noticed something odd. When a polymorphic constant has sort<br>\nconstraints, you normally cannot write it down with its type<br>\ninstantiated to a type that does not fulfil these constraints. For<br>\ninstance, term ‹-1 :: nat› or @{cterm \"-1 :: nat\"} do not work because<br>\n\"nat\" does not have the sort \"uminus\".</p>\n<p>However, when one constructs the term in ML and then certifies it with<br>\nThm.cterm_of, it works:</p>\n<p>ML_val ‹<br>\nlet<br>\n  val t =<br>\n    Const (@{const_name \"uminus\"}, @{typ \"nat ⇒ nat\"}) $ @{term \"1 :: nat\"}<br>\nin<br>\n  Thm.cterm_of @{context} t<br>\nend<br>\n›</p>\n</blockquote>\n<p>That is the normal expected behaviour: sort constraints for constants are<br>\nmerely an extra sanity check in abstract syntax (Syntax.check operations), but<br>\nhave no relevance for the logic.</p>\n<p>Even more, there can be additional type constraints for constants that<br>\nSyntax.check will observe, but Thm.cterm_of doesn't.</p>\n<blockquote>\n<p>Is this for performance reasons?</p>\n</blockquote>\n<p>No, it is to get concepts right and have an implementation that fits to these<br>\nconcepts. Arriving there has required many years, approx. from 1994 to 2008.</p>\n<blockquote>\n<p>(For those wondering why this is okay on a logical level, the negation<br>\noperator is essentially acting as an unspecified function, so \"-1 ::<br>\nnat\" is not /actually/ -1, but it is equal to some \"proper\" natural<br>\nnumber, we just don't know which one)</p>\n</blockquote>\n<p>Conventional logic can always have terms that are uninterpreted or \"non-denoting\".</p>\n<p>Makarius</p>",
        "id": 294828112,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661245369
    }
]