[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 10/01/18 07:12, <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a> wrote:</p>\n<blockquote>\n<p>I have a query about what might be possible with timing data.</p>\n<p>Isabelle proofs sometimes go into infinite loops, leading to session <br>\nbuilds that run forever. The isabelle build process has a per-session <br>\ntimeout option, which can be specified in ROOT files.</p>\n</blockquote>\n<p>BTW, a timeout that is hardwired in ROOT is sometimes not right for<br>\ndifferent test hardware. In that case it may help to use something like<br>\nisabelle build -o timeout_scale=2 on the command line.</p>\n<blockquote>\n<p>I don't know how <br>\ncommon it is to use this. Our test apparatus also has a crude mechanism <br>\nfor killing a test after some length of time, and I guess that's pretty <br>\ncommon.</p>\n</blockquote>\n<p>How is that different from the builtin timeout mechanism (which is in<br>\nIsabelle/Scala)?</p>\n<blockquote>\n<p>My main question is, is there some way we could track slow commands <br>\nduring session builds?</p>\n<p>In interactive mode, commands that are running for a while are <br>\nhighlighted in the \"Running\" colour in jEdit (usually deep purple). My <br>\nunderstanding is that roughly the same PIDE infrastructure is in place <br>\nduring session builds.</p>\n</blockquote>\n<p>Session batch-builds still lack PIDE markup (and status) information. I<br>\nam working on that for many years, and maybe this week / month / year /<br>\ndecade it will actually materialize. A proper PIDE markup db file for<br>\nsession builds would have many benefits, e.g. for document preparation.</p>\n<p>The elapsed time for the \"purple\" status of a command could be<br>\ndefinitely observed and recorded via PIDE, but there can be<br>\nirregularities: global GC time can be quite long and interfere with all<br>\nrunning commands. We shall see how it works out when it is there.</p>\n<blockquote>\n<p>Would it be possible to log information about &gt; slow commands (e.g.<br>\nthose running more than one minute)? Could we set a<br>\nflag to send such information to an extra log file?</p>\n</blockquote>\n<p>Yes, when PIDE markup becomes available in batch-mode builds.</p>\n<p>Makarius</p>",
        "id": 294725204,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186181
    },
    {
        "content": "<p>From: <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a><br>\nHello isabelle-users, and implementors.</p>\n<p>I have a query about what might be possible with timing data.</p>\n<p>Isabelle proofs sometimes go into infinite loops, leading to session <br>\nbuilds that run forever. The isabelle build process has a per-session <br>\ntimeout option, which can be specified in ROOT files. I don't know how <br>\ncommon it is to use this. Our test apparatus also has a crude mechanism <br>\nfor killing a test after some length of time, and I guess that's pretty <br>\ncommon.</p>\n<p>A timeout result is our least desirable outcome. We learn very little. <br>\nIf our apparatus kills the build, we don't get a log file. When the <br>\ntimeout option fires, I haven't found any useful information in the log <br>\nfile.</p>\n<p>My main question is, is there some way we could track slow commands <br>\nduring session builds?</p>\n<p>In interactive mode, commands that are running for a while are <br>\nhighlighted in the \"Running\" colour in jEdit (usually deep purple). My <br>\nunderstanding is that roughly the same PIDE infrastructure is in place <br>\nduring session builds. Would it be possible to log information about <br>\nslow commands (e.g. those running more than one minute)? Could we set a <br>\nflag to send such information to an extra log file?</p>\n<p>Reporting (roughly) which line the infinite loop is in would be a <br>\nsubstantial improvement. Even reporting which theory the loop was in <br>\nwould help.</p>\n<p>Would this be useful to other users?</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 294725273,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186210
    },
    {
        "content": "<p>From: <a href=\"mailto:Thomas.Sewell@data61.csiro.au\">Thomas.Sewell@data61.csiro.au</a><br>\nThanks Makarius.</p>\n<p>Indeed, a hardwired timeout is an imprecise approach. We've used very <br>\ngenerous<br>\ntimeouts rather than fiddling with per-machine expectations. The point <br>\nis to ensure<br>\nthat test runs finish eventually, since otherwise we'd have to keep <br>\nfiddling with the<br>\ntest apparatus by hand.</p>\n<p>As you say, an external timeout is the same as an Isabelle timeout, for <br>\nIsabelle builds.<br>\nOur test runs test a mix of Isabelle builds and other things, so we have <br>\na similar<br>\nmechanism in the test-control script.</p>\n<p>I was confused a little about the batch builds. The overall framework <br>\n(Isabelle/Scala<br>\nand protocol) is the same during builds, but the kinds of protocol <br>\nmessages exchanged<br>\nare different.</p>\n<p>In the meanwhile, I've got around to implementing a version on the ML <br>\nside. It's just a<br>\nsimple task that runs every few seconds (via Event_Timer.request) and <br>\nblogs (to a file)<br>\na report about what's running and which tasks have been running for a <br>\nwhile. It's not<br>\nvery accurate but the log can still be interesting when a session times <br>\nout. I was going<br>\nto test it a bit more at this end before asking if anyone else wanted a <br>\ncopy.</p>\n<p>This is just a make-do solution. I'm sure you'd rather move toward a <br>\nmore canonical<br>\nimplementation with session builds running more of the document protocol <br>\nand a Scala<br>\nmodule producing similar output. I don't understand the Scala layer well <br>\nenough to<br>\ntry that though.</p>\n<p>Cheers,<br>\n     Thomas.</p>",
        "id": 294725345,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186235
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe PIDE protocol is still not used at all in batch-builds. This would<br>\nrequire some reworking in various respects, e.g. full parallel proof<br>\nchecking in PIDE.</p>\n<p>Getting that all into proper shape has a high priority for me, but it<br>\nmeans it could happen next week / month / year / decade.</p>\n<p>The current intermediate approach has some rudiments of<br>\nprotocol_message, which are not PIDE messages. See<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/annotate/Isabelle2017/src/Pure/Tools/build.ML#l75\">http://isabelle.in.tum.de/repos/isabelle/annotate/Isabelle2017/src/Pure/Tools/build.ML#l75</a></p>\n<p>There is actually some Markup.command_timing information that ends up in<br>\nthe build db file. Here is an example to access that in Isabelle/Scala<br>\n(Isabelle2017):</p>\n<p>$ isabelle scala<br>\n  import isabelle._<br>\n  val store = Sessions.store(system_mode = false)<br>\n  val name = \"HOL\"<br>\n  val database = store.find_database(name).get<br>\n  val db = SQLite.open_database(database)<br>\n  val command_timings = store.read_command_timings(db, name)</p>\n<p>The purpose of that is to fine-tune parallel checking of proofs in batch<br>\nmode. It does not handle the case of non-terminating commands, nor does<br>\nit take GC time into account.</p>\n<p>Makarius</p>",
        "id": 294725833,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661186376
    }
]