[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear developers of lifting/transfer,</p>\n<p>First of all, I'd like to thank all of you for this great tool, I am now using it all the <br>\ntime. Unfortunately, I keep proving different transfer rules for the constant undefined <br>\nover and over again, although they all have the same shape.</p>\n<p>The following example illustrates my setting:</p>\n<p>typedef my_int = \"UNIV :: int set\" .. setup_lifting type_definition_my_int<br>\ntypedef my_nat = \"UNIV :: nat set\" .. setup_lifting type_definition_my_nat</p>\n<p>lift_definition P :: \"my_int =&gt; bool\" is \"op &gt; 0\" .<br>\nlift_definition foo :: \"my_int =&gt; bool =&gt; my_nat\" is \"%i _. nat i\" .<br>\nlift_definition my_int_of_my_nat :: \"my_nat =&gt; my_int\" is int .</p>\n<p>definition bar :: \"my_int =&gt; bool =&gt; my_nat\"<br>\n   where \"bar i b = (if P i then undefined i b else foo i b)\"</p>\n<p>lemma \"foo (my_int_of_my_nat n) b = bar (my_int_of_my_nat n) b\"<br>\n   unfolding bar_def<br>\n   apply transfer</p>\n<p>This gives me the following second subgoal for undefined:</p>\n<p>Transfer.Rel (fun_rel cr_my_int (fun_rel op = cr_my_nat)) ?ah23 undefined</p>\n<p>So far, I just proved this transfer rule for an appropriate instantiation of ?ah23, but I <br>\nhave to prove similar goals with different combinations of fun_rel, cr_... etc. So I tried <br>\nto prove a generic transfer lemma for quotients:</p>\n<p>lemma undefined_transfer:<br>\n   assumes Q1: \"Quotient A Abs1 Rep1 cr1\"<br>\n   and Q2: \"Quotient B Abs2 Rep2 cr2\"<br>\n   shows \"(fun_rel cr2 cr1) (Rep1 o undefined o Abs2) undefined\"<br>\nby(auto dest!: Q2[unfolded Quotient_alt_def, THEN conjunct1, rule_format]<br>\n      intro!: Q1[unfolded Quotient_alt_def, THEN conjunct2, THEN conjunct1, rule_format])</p>\n<p>With this lemma, I can prove all these rules for undefined -- in the running example:</p>\n<p>apply(unfold Rel_def)<br>\napply(rule undefined_transfer fun_quotient identity_quotient<br>\n         Quotient_my_nat Quotient_my_int)+</p>\n<p>Unfortunately, I did not manage to have transfer prove these rules on the fly. How can I <br>\nget there? The following declarations do not suffice:</p>\n<p>lemmas [transfer_rule] =<br>\n   undefined_transfer Quotient_my_int Quotient_my_nat fun_quotient identity_quotient</p>\n<p>Thanks in advance for any help,<br>\nAndreas</p>\n<p>PS: The example is from Isabelle2013, but it is similar in the development version (id <br>\n13171b27eaca).</p>",
        "id": 294241271,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907077
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nHi Andreas,<br>\nthe issue with undefined is on my to-do list. I think your solution is <br>\non the right track. When I have more time, I will make something more <br>\nrobust to deal with undefined.</p>\n<p>OK, how to make your example working:<br>\n1) Quotient_my_int and Quotient_my_nat uses non-parametric <br>\ncorrespondence relation cr_my_int and cr_my_nat, whereas the transfer <br>\nrules uses pcr_my_int and pcr_my_nat. In this case you can just use <br>\nmy_int.pcr_cr_eq and my_nat.pcr_cr_eq to change the former relations to <br>\nthe latter ones.<br>\n2) identity_quotient should be always before all rules for other types, <br>\nthus it is used at the very end.<br>\n3) I think this theorem should be enough to generate transfer rules for <br>\nundefined on the fly:<br>\nlemma undefined_transfer_better:<br>\n   assumes \"Quotient R Abs Rep T\"<br>\n   shows \"T (Rep undefined) undefined\"<br>\nusing assms unfolding Quotient_alt_def by blast</p>\n<p>Thus the result is:<br>\nlemmas [transfer_rule] = identity_quotient fun_quotient<br>\n   Quotient_my_int[unfolded my_int.pcr_cr_eq[symmetric]]<br>\n   Quotient_my_nat[unfolded my_nat.pcr_cr_eq[symmetric]]<br>\n   undefined_transfer_better</p>\n<p>Ondrej</p>",
        "id": 294242773,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907679
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Ondřej,</p>\n<p>Thank you for your suggestion, it works like a charm.</p>\n<p>This only applies to the development version, e.g., 608afd26a476. As is good practice on <br>\nisabelle-users, I have back-ported my problem to Isabelle2013 where there are only <br>\nnon-parametric correspondence relations. But you rightly guessed that I am actually <br>\nworking with the development version.</p>\n<p>By the way, I wrap the type \"32 word\" in a type of its own to do the usual code generation <br>\nrefinement stuff. When I call setup_lifting with the type definition, it warns that it <br>\ncannot generate a parametrized correspondence relation failed because it could not find a <br>\nrelator for the type \"Numeral_Type.bit0\". Honestly, I have no clue what a relator for <br>\nthese numeral types should look like. Or is it OK to ignore the warning in this case?</p>\n<p>Thanks again,<br>\nAndreas</p>",
        "id": 294242782,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907685
    }
]