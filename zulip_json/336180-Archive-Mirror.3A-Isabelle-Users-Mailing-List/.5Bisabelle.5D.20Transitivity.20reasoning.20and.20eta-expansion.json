[
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nI have the following problem with the transitivity reasoning setup:</p>\n<p>given some partial order [&lt;\\le&gt;] on a function datatype, I want to do<br>\ntransitivity reasoning. So I declare the transitivity lemma as [trans].<br>\nThe problem is now, that everything works until I have a reflexivity<br>\nstep. In this case, the goal gets eta-expanded at the next 'also',<br>\ncausing the  transitivity reasoner to fail.</p>\n<p>My question is:<br>\n    Is there a workaround, and if the workaround is to add some extra<br>\ntransitivity rules, how do they have to look like ?</p>\n<p>I added a rule \"(%u. a u) = (%u. b u) ==&gt; P b ==&gt; P a\", with this rule,<br>\nthe reasoning worked sometimes (of the =-step is the first one in the<br>\nreasoning chain),  but the also command takes some time and produces<br>\nsome very strange output, repeatedly meantioning \"unification bound<br>\nexceeded\".</p>\n<p>Here the example:<br>\nconstdefs<br>\n  ah_leq :: \"('m \\&lt;Rightarrow&gt; 'm set) \\&lt;Rightarrow&gt; ('m \\&lt;Rightarrow&gt;<br>\n'm set) \\&lt;Rightarrow&gt; bool\" (infix \"[\\&lt;le&gt;]\" 50)<br>\n  \"h1 [\\&lt;le&gt;] h2 == \\&lt;forall&gt;m. h1 m \\&lt;subseteq&gt; h2 m\"</p>\n<p>interpretation ah_leq: partial_order[\"op [\\&lt;le&gt;]\"]<br>\n  apply (rule partial_order.intro)<br>\n  apply (unfold ah_leq_def)<br>\n  apply (auto intro!: ext)<br>\n  done </p>\n<p>declare ah_leq.below.trans[trans]</p>\n<p>lemma fixes h :: \"'m \\&lt;Rightarrow&gt; 'm set\" shows \"False\" proof -<br>\n  have \"h[\\&lt;le&gt;]h\" sorry<br>\n  also have \"h = h'\" sorry<br>\n  also (* Here we have calculation: (\\&lt;lambda&gt;u. h' u) [\\&lt;le&gt;]<br>\n(\\&lt;lambda&gt;u. h' u)*) have \"h' [\\&lt;le&gt;] h''\" sorry<br>\n  also &lt;- This fails</p>\n<p>My current workaround is to avoid =-steps, and only use [\\&lt;le&gt;] in the<br>\nreasoning chain.</p>\n<p>Regards and thanks for any hints,<br>\n  Peter</p>",
        "id": 294053024,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820390
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nEta-expansion should not be a problem here, because higher-order <br>\nunifications works module eta (and alpha and beta).  You should be able to <br>\ncompose these facts manually, using something like</p>\n<p>thm ah_leq.trans [OF fact1 fact2]</p>\n<p>The reason why 'also' fails is different: due to the reflexivity step in <br>\nthe chain, there is no progress in the calculation.  Such facts are <br>\nfiltered out from the sequence of possible results -- an empty sequence is <br>\nleft over.</p>\n<p>The deeper reason why this is done is higher-order unification again: <br>\ncertain pathological cases of substitution result in no-progress steps.  <br>\nThe filtering scheme nicely circumvents this.  So you merely loose <br>\nreflexivity (which is not very interesting anyway), but gain many useful <br>\napplications of substitution (of equalities or inequalities).</p>\n<p>Makarius</p>",
        "id": 294053034,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660820396
    }
]