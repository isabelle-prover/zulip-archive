[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 04/11/2011 17:55, schrieb Lawrence Paulson:</p>\n<blockquote>\n<p>Some of the other points that you mention relate to basic lambda-calculus. There is no need to study the lambda calculus in its full glory, as it is quite irrelevant to higher-order logic. Lambda-notation merely expresses the notion of a function, something that is curiously lacking in standard mathematical practice.</p>\n</blockquote>\n<p>Actually, \"x |-&gt; e\" is often used, and I wish Church had adopted it,<br>\nthat would make it unnecessary to explain to a mathematician what this<br>\nlambda means. But you are right that the |-&gt; notation is not really a<br>\nfirst-class citizen in mathematics.</p>\n<p>Tobias</p>\n<blockquote>\n<p>The type of the composition operator is a well-known device, known as currying, for expressing functions that take multiple arguments. Again, traditional mathematics is quite careless in such situations. You remark that functions have domains and ranges, but typically the function composition operator is not written in such terms at all, and is allowed to apply to any compatible pairs of functions whatever. In the language of set theory, it is a class function.</p>\n<p>Anything that you can define in higher-order logic is not merely explicable in traditional mathematical terms, but it is easily so. But there are plenty of things you can write in mathematics that are impossible to formalise in higher-order logic. This is because mathematics is essentially open-ended.</p>\n<p>Larry Paulson</p>\n<p>On 3 Nov 2011, at 18:45, James Frank wrote:</p>\n<blockquote>\n<p>I'll ask the easy question first. In my inbox, there's <a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a> and <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> . Does it make any difference which address I use to send in a question? If it doesn't, you don't need to answer that question.</p>\n<p>I've tried not to ask different forms of my next question. That's because after studying enough type theory, lambda calculus, functional programming, and files from ~~/src/HOL, I'll figure out most of the answers. But that could be up to a years worth of work, and I'm trying to get a feel for where this road is going, and whether I may need to travel the road less traveled.</p>\n<p>My question, stated very general, is this: \"Can I take a file such as ~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard math definitions and theorems, with a few changes to accommodate types, and have these standard definitions/theorems be describing the same objects as the Isabelle definitions and lemma?\" I'm not talking about starting with a different logical framework or set of axioms, and ending up at the same place.</p>\n<p>Below I ask related questions which are probably more straight forward to answer, and, if answered, might answer the question just posed.</p>\n<p>To get more specific, I'll ask some questions about \"definition comp\" in Fun.thy, which is the definition of function composition.</p>\n<p>First, here are some related goals to set the context, for why I'm thinking about this now:<br>\n1) I want to cater to mathematicians who are doing traditional mathematics. Therefore, the language of my definitions and theorems needs to be reasonably familiar to them. I'd like to start rephrasing Isabelle defs and thms now.<br>\n2) I want to build on, and learn from, what others have done. Therefore, my first choice is HOL rather than ZF, since the library is larger, even though HOL is not as \"traditional\".</p>\n<p>Here's the definition of comp from Fun.thy:</p>\n<p>definition comp :: \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c\" (infixl \"o\" 55) where<br>\n \"f o g = (\\&lt;lambda&gt;x. f (g x))\"</p>\n<p>Studying Haskell is what led me to Isabelle, and I studied just enough functional programming to know that comp is a function that takes type \"('b =&gt; 'c)\" and returns type (('a =&gt; 'b) =&gt; 'a =&gt; 'c)). I guess that's right, although I ask below about (\\&lt;lambda&gt;x. f (g x)), and about its domain and range.</p>\n<p>Functions have domains and ranges. You won't be surprised here, but never once have I seen \"function composition\" be defined with the domain being a set of functions, and the range being a set of functions whose elements are functions, which take functions, and return functions.</p>\n<p>Here's what I want out of \"definition comp\", using more standard math language:</p>\n<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o g):'a--&gt;'b, where (f o g)(x) = f(g(x)).</p>\n<p>Notice that I tweak the definition to use types rather than sets. I was also tempted to stick \"(f o g) = (%x. f(g x))\" in there, not that I know much more than what it symbolizes. The details and groundwork could be worked out if it's basically the same thing as \"comp\".</p>\n<p>A pertinent point here is that with a definition such as DEFINITION 1.1.1, I'm not making many demands on someone. They might be willing to go with it even with only an intuitive understanding of types and lambda calculus. However, it's important to me that something like DEFINITION 1.1.1 and \"comp\" be the same thing. Not be like, \"think of them as the same\", but \"are the same\".</p>\n<p>Okay, what I really want is something like this:<br>\n   (f o g) = {(a,c) in AxC | ThereExists b in B, such that (a,b) is in g and (b,c) is in f}.</p>\n<p>You can tell me different, but I assume I'm correct in saying that \"comp\" is not this set, and can't be this set, though with some work, some form of equivalence could be shown. Again, I guess that's right.</p>\n<p>Somewhere in this question is me trying to figure out how different \"comp\" is from a standard definition of composition. Is \"comp\" close enough to a standard definition to try and phrase it using standard language, or it's \"functional programming, type theory, and lambda calculus\", and I should just accept it for what it is. Regardless, it is what it is, and I want to describe it as what it is, but describe it using language other than Isabelle code.</p>\n<p>POINT 1: In a standard definition of function composition, there are typically three functions, \"f\", \"g\", and \"f o g\".</p>\n<p>POINT2: In \"comp\", there are four functions, \"f\", \"g\", \"(\\&lt;lambda&gt;x. f (g x))\", and the function of type<br>\n   \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c\".</p>\n<p>What I've said above might could be summarized with this question:<br>\n   What is this thing, this function \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c\"?</p>\n<p>If I have to incorporate that into my traditional-style definition, then it's no longer traditional-style. If I have to do that, then I'm doing something different.</p>\n<p>If it's necessary details, and a way of specifying \"g:'a--&gt;'b, f:'b--&gt;'c, and (f o g):'a--&gt;'b\", and I can easily formalize the connection prior to my function composition definition, then the situation is salvageable.</p>\n<p>Anyway, feel free to comment or not.</p>\n<p>Thanks,<br>\nJames</p>\n</blockquote>\n</blockquote>",
        "id": 294146956,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847872
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Fri, Nov 4, 2011 at 5:46 PM, James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt; wrote:</p>\n<blockquote>\n<blockquote>\n<p>Have you seen it [composition] being defined as a function before? If so, what was<br>\nits domain and range?</p>\n<p>(I also want to ask: how would you usually think of an ordinary<br>\nfunction that takes two arguments? This line would continue into a<br>\ndiscussion about currying, but I'll leave it out for now.)</p>\n</blockquote>\n<p>I could restate the essence of my first email: Currying is not a problem. It<br>\nnot being a part of the math literature is a problem. I don't understand<br>\ncurrying because I wasn't taught currying. My math professors didn't teach<br>\nme currying because they didn't understand currying. Most likely, they were<br>\nvery happy knowing nothing about currying. Most likely, they will die happy<br>\nknowing nothing about currying. That's not a problem unless I want them to<br>\nread something that I write that involves currying, but I will, or someone<br>\nlike them, so it's a problem.</p>\n</blockquote>\n<p>It's not too hard. I would encourage you to answer my two questions above.</p>\n<blockquote>\n<p>For example, when I use \"comp f g\" in my mind rather than \"f o g\", it gives<br>\nme better understanding.</p>\n</blockquote>\n<p>I agree. (That's why I like Lisp's syntax, or rather, lack of syntax.)</p>\n<blockquote>\n<p>I think I had figured out that the whole thing,<br>\n   \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c\"<br>\nis (%x. f(g x)), or \"f o g\", though initially I was mistaking (%x. f(g x))<br>\nfor the function of type ('a =&gt; `c), since in a traditional definition if<br>\ng:A--&gt;B and f: B--&gt;C, then (f o g):A--&gt;C.</p>\n</blockquote>\n<p>You got it right the first time. The type of (%x. f (g x)) is 'a =&gt; 'c.</p>\n<blockquote>\n<p>But if \"f\" is the function of type ('b =&gt; 'c), \"g\" is the function of type<br>\n('a  =&gt; 'b), and (%x. f(g x)) is the function of type \"('b =&gt; 'c)  =&gt; ('a<br>\n =&gt; 'b)  =&gt; 'a  =&gt; 'c\", then who is that function of type ('a =&gt; `c)?</p>\n</blockquote>\n<p>Since \"%x. f (g x)\" is the function of type 'a =&gt; 'c (and it is equal<br>\nby definition to \"f o g\"), the question should perhaps be what is the<br>\nfunction of type \"('b =&gt; 'c) =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'c\"? And the<br>\nanswer, as I mentioned before, is \"comp\". Let's see how this works in<br>\nfull detail.<br>\nWe have the following typings</p>\n<p>f :: 'b =&gt; 'c<br>\n  g :: 'a =&gt; 'b<br>\n  comp :: ('b =&gt; 'c) =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'c</p>\n<p>therefore</p>\n<p>comp f :: ('a =&gt; 'b) =&gt; 'a =&gt; 'c</p>\n<p>and thus</p>\n<p>comp f g :: 'a =&gt; 'c</p>\n<p>Done. For extra practice, consider the definition of \"comp f g\".<br>\nIt was given as \"%x. f (g x)\", and we now know that it is a function<br>\nof type 'a =&gt; 'c.<br>\nThat means \"x\" has type 'a, and f (g x) has type 'c.<br>\nAnd indeed that checks out:<br>\n  x :: 'a, so<br>\n  g x :: 'b, so<br>\n  f (g x) :: 'c</p>",
        "id": 294147045,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847886
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nI'm not used to using \"reply all\", so I put this back public, along with <br>\nmy previous response, where I admit that it's pretty foolish to be <br>\nwanting to eliminate something that's at the core. After this set, I <br>\ndon't want to be so guilty of cluttering up the mailing list with <br>\nnon-technical emails.</p>\n<p>On 11/4/2011 6:13 PM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>On 4 Nov 2011, at 19:31, James Frank wrote:</p>\n<blockquote>\n<p>The problem is with this ubiquitous \"'a =&gt;  'b =&gt;  'c\" type statement. It's not a part of 98% (a little less or little more) of the math world.<br>\nI can't believe that any serious mathematician would struggle with this.</p>\n</blockquote>\n<p>Larry Paulson<br>\n</p>\n</blockquote>\n<p>It never entered my mind that they couldn't understand it, it's my <br>\nassumption that they don't even want to, especially not for me.</p>\n<p>But that's an assumption for my purposes. You're Larry Paulson at <br>\nCambridge. You make waves. I ride waves. The only safe assumption for me <br>\nis that no one is going to learn functional programming concepts for me.</p>\n<p>We try and cater to the reader, some of us more than others. I'm trying <br>\nto set myself up now to do that in the future. I see the HOL wave and <br>\nthe ZF wave. The HOL wave is bigger, and I want the potential support <br>\nand opportunity that may come with it, so I initially pick the HOL wave.</p>\n<p>But you make it sound simple, this transition to math heavily tied into <br>\nfunctional programming. It's not that some of the basic concepts are <br>\nrocket science, but where's the satisfaction in just having a basic, <br>\nintuitive understanding of concepts? Having that attitude goes against <br>\nthe very core of seeking to justify everything in math.</p>\n<p>And then there's always the person who wants to take it to the next <br>\nlevel. It's not enough for him or her to do algebra, he or she has to go <br>\nwild with categories, and make me do lots of searches to find a decent <br>\ntextbook on categories for self-study, when algebra is perfectly fine <br>\nwithout another level of abstraction.</p>\n<p>It sounds like I'm lecturing. It's not really my place to do that here, <br>\nbut, obviously, I'm willing to do it.</p>\n<p>--James</p>\n<hr>\n<p>Dr. Paulson,</p>\n<blockquote>\n<p>There is a sense in which your question is not entirely meaningful...<br>\nI can see that. It would be like me saying, \"That epsilon in the <br>\ndefinition of limit is annoying me, because it annoys my students, and <br>\nthey don't want to learn about epsilons. What's an easy way for me to <br>\nget rid of it?\"</p>\n</blockquote>\n<p>But the realization that I was going to commit some \"rigor sins\" is what <br>\nbrought this on.</p>\n<p>The basic idea is that I have two parallel lines of language in a <br>\ndocument. Standard \"math English\", and the Isabelle code. The purpose is <br>\nto help me clarify ideas, and to make the math more interesting and <br>\nappealing to a typical mathematician.</p>\n<p>There's not a problem with something like \"lemma interior_ball: <br>\n\"x:interior S &lt;-&gt; (EX e&gt;0. ball x e &lt;= interior S)\".</p>\n<p>The problem is with this ubiquitous \"'a =&gt; 'b =&gt; 'c\" type statement. <br>\nIt's not a part of 98% (a little less or little more) of the math world.</p>\n<p>Initially, I thought, \"Okay, mask it with some other notation if you <br>\ncan, or talk about how, all together, the Isabelle code is equivalent to <br>\nmy math English\".</p>\n<p>I realized I can't do that. When I get to qed, I want to say, \"Look, <br>\nI've proved my math English theorem with Isabelle code.\" But if my math <br>\nEnglish is not a reasonable mirror of the Isabelle code, then I haven't <br>\nproved anything but the Isabelle code.</p>\n<p>It's not a real problem. I either broach a subject and give rigorous or <br>\nsemi-rigorous explanations, or I use certain math without explaining <br>\nwhat I'm doing, and let the reader figure it out.</p>\n<p>It's just that every analysis book in the world has a token introduction <br>\nto set theory, functions, etc.. With math, I'm an imitator, and easily <br>\nfollowing that pattern is blown out of the water with HOL.</p>\n<blockquote>\n<p>Anything that you can define in higher-order logic is not merely <br>\nexplicable in traditional mathematical terms, but it is easily so. But <br>\nthere are plenty of things you can write in mathematics that are <br>\nimpossible to formalise in higher-order logic.</p>\n</blockquote>\n<p>The good news is that different foundations converge at a higher point <br>\nwhere they a lot of math in common.</p>\n<p>Again, there's no real problem. Very few people have an in-depth <br>\nunderstanding of the foundations of math, so there's a lot of skipping <br>\nthat low level stuff anyway, or totally ignoring it.</p>\n<p>--James</p>\n<p>On 11/4/2011 11:55 AM, Lawrence Paulson wrote:<br>\nThere is a sense in which your question is not entirely meaningful, <br>\nbecause you're asking whether rigorous but informal mathematics is <br>\nadequately captured by a particular formalisation, and such issues are <br>\nultimately subjective. However, traditional mathematics is often assumed <br>\nto be based on set theory, and higher-order logic has very <br>\nstraightforward models in set theory. In particular, if you look at the <br>\nfunction f o g, then you get exactly the same set of ordered pairs by <br>\neither route, assuming you're in the mood to interpret a function as a <br>\nset of ordered pairs. The situation with higher-order logic is very <br>\ndifferent from that presented by various constructive type theories you <br>\nmay have seen, where you typically cannot regard a function as a set of <br>\npairs.</p>\n<p>Some of the other points that you mention relate to basic <br>\nlambda-calculus. There is no need to study the lambda calculus in its <br>\nfull glory, as it is quite irrelevant to higher-order logic. <br>\nLambda-notation merely expresses the notion of a function, something <br>\nthat is curiously lacking in standard mathematical practice. The type of <br>\nthe composition operator is a well-known device, known as currying, for <br>\nexpressing functions that take multiple arguments. Again, traditional <br>\nmathematics is quite careless in such situations. You remark that <br>\nfunctions have domains and ranges, but typically the function <br>\ncomposition operator is not written in such terms at all, and is allowed <br>\nto apply to any compatible pairs of functions whatever. In the language <br>\nof set theory, it is a class function.</p>\n<p>Anything that you can define in higher-order logic is not merely <br>\nexplicable in traditional mathematical terms, but it is easily so. But <br>\nthere are plenty of things you can write in mathematics that are <br>\nimpossible to formalise in higher-order logic. This is because <br>\nmathematics is essentially open-ended.</p>\n<p>Larry Paulson</p>\n<p>On 3 Nov 2011, at 18:45, James Frank wrote:</p>\n<p>I'll ask the easy question first. In my inbox, there's <br>\n<a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a> and <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> . Does <br>\nit make any difference which address I use to send in a question? If it <br>\ndoesn't, you don't need to answer that question.</p>\n<p>I've tried not to ask different forms of my next question. That's <br>\nbecause after studying enough type theory, lambda calculus, functional <br>\nprogramming, and files from ~~/src/HOL, I'll figure out most of the <br>\nanswers. But that could be up to a years worth of work, and I'm trying <br>\nto get a feel for where this road is going, and whether I may need to <br>\ntravel the road less traveled.</p>\n<p>My question, stated very general, is this: \"Can I take a file such as <br>\n~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard <br>\nmath definitions and theorems, with a few changes to accommodate types, <br>\nand have these standard definitions/theorems be describing the same <br>\nobjects as the Isabelle definitions and lemma?\" I'm not talking about <br>\nstarting with a different logical framework or set of axioms, and ending <br>\nup at the same place.</p>\n<p>Below I ask related questions which are probably more straight forward <br>\nto answer, and, if answered, might answer the question just posed.</p>\n<p>To get more specific, I'll ask some questions about \"definition comp\" in <br>\nFun.thy, which is the definition of function composition.</p>\n<p>First, here are some related goals to set the context, for why I'm <br>\nthinking about this now:<br>\n1) I want to cater to mathematicians who are doing traditional <br>\nmathematics. Therefore, the language of my definitions and theorems <br>\nneeds to be reasonably familiar to them. I'd like to start rephrasing <br>\nIsabelle defs and thms now.<br>\n2) I want to build on, and learn from, what others have done. Therefore, <br>\nmy first choice is HOL rather than ZF, since the library is larger, even <br>\nthough HOL is not as \"traditional\".</p>\n<p>Here's the definition of comp from Fun.thy:</p>\n<p>definition comp :: \"('b =&gt;  'c)  =&gt;  ('a  =&gt;  'b)  =&gt;  'a  =&gt;  'c\" <br>\n(infixl \"o\" 55) where<br>\n   \"f o g = (\\&lt;lambda&gt;x. f (g x))\"</p>\n<p>Studying Haskell is what led me to Isabelle, and I studied just enough <br>\nfunctional programming to know that comp is a function that takes type <br>\n\"('b =&gt;  'c)\" and returns type (('a =&gt;  'b) =&gt;  'a =&gt;  'c)). I guess <br>\nthat's right, although I ask below about (\\&lt;lambda&gt;x. f (g x)), and <br>\nabout its domain and range.</p>\n<p>Functions have domains and ranges. You won't be surprised here, but <br>\nnever once have I seen \"function composition\" be defined with the domain <br>\nbeing a set of functions, and the range being a set of functions whose <br>\nelements are functions, which take functions, and return functions.</p>\n<p>Here's what I want out of \"definition comp\", using more standard math <br>\nlanguage:</p>\n<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o <br>\ng):'a--&gt;'b, where (f o g)(x) = f(g(x)).</p>\n<p>Notice that I tweak the definition to use types rather than sets. I was <br>\nalso tempted to stick \"(f o g) = (%x. f(g x))\" in there, not that I know <br>\nmuch more than what it symbolizes. The details and groundwork could be <br>\nworked out if it's basically the same thing as \"comp\".</p>\n<p>A pertinent point here is that with a definition such as DEFINITION <br>\n1.1.1, I'm not making many demands on someone. They might be willing to <br>\ngo with it even with only an intuitive understanding of types and lambda <br>\ncalculus. However, it's important to me that something like DEFINITION <br>\n1.1.1 and \"comp\" be the same thing. Not be like, \"think of them as the <br>\nsame\", but \"are the same\".</p>\n<p>Okay, what I really want<br>\n[message truncated]</p>",
        "id": 294147072,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847899
    },
    {
        "content": "<p>From: Steven Obua &lt;<a href=\"mailto:steven.obua@googlemail.com\">steven.obua@googlemail.com</a>&gt;<br>\nHi James,</p>\n<p>you might be interested in following the progress of the \"ProofPeer\" (<a href=\"http://www.proofpeer.com\">www.proofpeer.com</a>) project which aims to build a cloud-based interactive theorem proving system. I hope that until the end of November a first prototype will be up and running that can be played with. You can already sign-up for it and login now, but not do much else. </p>\n<p>We were also faced with the question which language / logic to use for ProofPeer. In the end we settled for Higher-Order Logic Set Theory as a logic, and a functional programming language inspired by Standard ML, Scala and Isabelle/Isar. </p>\n<p>I think every serious mathematician will (want to) learn some pieces of higher-order logic and functional programming. At the same time, ZF set theory is a very flexible and elegant tool, and, as you pointed out, is familiar to all mathematicians. Our version of Higher-Order Set Theory provides a framework where you work in set theory most of the time and whenever you can, only becoming aware of and employing higher-order logic when you reach the boundaries of what can be done in a straightforward and comfortable way in ZF set theory. </p>\n<p>Cheers,</p>\n<p>Steven Obua</p>",
        "id": 294147086,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847905
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nRamana,</p>\n<p>Thanks for answering anyway, but this shows that a big part of the <br>\nbattle is getting the notation down. At least I was right that there are <br>\n4 functions instead of 3 (though I was actually wrong in the total <br>\nnumber, as I discovered below).</p>\n<p>I'm not used to a character that's been defined as an operator being <br>\nused by itself to refer to a function. Even now, I know I can talk of <br>\n\"comp\", but I don't know if I can talk of \"o\" without using it with f <br>\nand g. In Haskell I can refer to + by putting it in (+). All this would <br>\nfeel second nature if I had been doing much coding and using functions <br>\nlike sum(a,b) instead of \"a+b\".</p>\n<p>That's all notation, it's six of one, or a half dozen of the other.</p>\n<p>However, there's \"comp\", \"comp f\", and \"comp f g\", and those variations <br>\nare related to currying and the nifty things currying allows you to do <br>\nwhen defining other functions with \"comp\", as I understand it.</p>\n<p>First, I don't know how to use \"comp f g x\", where to put the <br>\nparentheses, but that's trivial, and shows I haven't worked far enough <br>\ninto the basic tutorials.</p>\n<p>More importantly, I'm trying to figure out what the simple analogy is <br>\nbetween set based function composition and functional programming <br>\nfunction composition. My short answer guess is, \"There is no simple <br>\nanalogy to be made using the set function composition notation and the <br>\nfunctional programming function composition notation\". Yes, they <br>\naccomplish the same thing, but no, they're not close enough. Their <br>\nnotational similarities will hurt you and make a fool out of you.</p>\n<p>Currying allows me to specify 3 related functions, \"comp\", \"comp f\", and <br>\n\"comp f g\". Wait. I need a fourth function which involves a variable...</p>\n<p>But, no, it's even worse, now that I've studied your comments below <br>\nmore. You listed five functions:<br>\n       f :: 'b =&gt; 'c<br>\n       g :: 'a =&gt; 'b<br>\n       comp :: ('b =&gt; 'c) =&gt; ('a =&gt; 'b) =&gt; 'a =&gt; 'c<br>\n       comp f :: ('a =&gt; 'b) =&gt; 'a =&gt; 'c<br>\n       comp f g :: 'a =&gt; 'c</p>\n<p>But that's helpful, along with comment on following the \"type path\". I <br>\nthink it's a little clearer now that the lambda notation is just a way <br>\nto specify the path that x::`a follows when used as an argument for g.</p>\n<p>It's currying. It can't be something else. That's why you guys <br>\nimmediately tied my questions into currying.</p>\n<p>But now, to answer your two questions:</p>\n<p>_Q1_: Have you seen it [composition] being defined as a function before? If so, what was<br>\nits domain and range?</p>\n<p>It's always defined as a function, where a function is a set of ordered pairs. If g:A--&gt;B and f:B--&gt;C, then the domain and range are determined for (f o g). We have to have (f o g):A--&gt;C, where A, B, and C can be any sets.</p>\n<p>_Q2_:(I also want to ask: how would you usually think of an ordinary function that takes two arguments? This line would continue into a discussion about currying, but I'll leave it out for now.)</p>\n<p>As a two variable function f(x,y).</p>\n<p>But it's not acceptable for me to think like that now. When I was studying functional programming for practical reasons, it was acceptable to think of \"f: 'a =&gt;  'b =&gt;  'c\" as a two variable function f(a,b), but once you make it part of a math definition, I'm only allowed to to think of it as what it is.</p>\n<p>The only option is to set up an equivalence that allows me to think the way I want to think.</p>\n<p>Thanks for the help,<br>\n--James</p>",
        "id": 294147106,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847911
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nAgain, I didn't hit the right reply button on a previous reply, so I put <br>\nthis back public. In my reply to Piotr, I said complementary things <br>\nabout both Mizar and Isabelle. Personally, I'd like to learn all the <br>\nproof assistants, just for the fun of it.</p>",
        "id": 294147118,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847917
    },
    {
        "content": "<p>From: Josef Urban &lt;<a href=\"mailto:josef.urban@gmail.com\">josef.urban@gmail.com</a>&gt;<br>\nHi,</p>\n<p>Piotr Rudnicki forwarded this thread, here is my view.</p>\n<p>I have seen the following justifications of doing formal<br>\nmathematics in simply typed HOL instead of in standard set theory:</p>\n<ol>\n<li>Better automation of type inference</li>\n<li>Better automation of (total) functions</li>\n</ol>\n<p>I do not think any of them is particularly valid today. It seems<br>\nto me that they are just deeply embedded in the LCF heritage (use<br>\nof ML, etc.). Larry himself has formalized ZF quite far in Isabelle.</p>\n<p>ad (1): Automation of type inference in existing HOL-based<br>\nsystems based on Hindley-Milner is quite simple in comparison to<br>\ndependent type systems, be it done foundationally as in Coq, or<br>\nas a soft type system as in Mizar. Additional type class<br>\nsystems (in Isabelle and Coq) are themselves soft type systems<br>\ngrafted on top of the systems' foundational cores, already<br>\nmotivated by user demand for improved (non-foundational)<br>\ntype-related automations.</p>\n<p>ad (2): Automation of working with (not just total) functions is<br>\nagain a fairly simple mechanism, implementable also in set<br>\ntheory.</p>\n<p>I think that any of the major systems (starting with Isabelle)<br>\nhas today integrated much more powerful automations, based on<br>\nbridges to automated tools working in propositional and<br>\nfirst-order (not higher-order) logic, and its decidable<br>\nfragments.</p>\n<p>I believe that the focus on total functions as foundational<br>\nobjects came from their success in programming, but it is foreign<br>\nto most of mathematics as done by mathematicians. The<br>\nset-theoretical world of HOL is different from standard set<br>\ntheory. Basic set-theoretical cosnstructs like von Neuman's<br>\nordinals do not work for HOL's standard \"sets\" because of the<br>\ntype constraints. The universe is sparser, because its sets are<br>\ntyped. When I see a set-theory-related development done<br>\nin (Isabelle/)HOL (last time this was measure theory), it leaves<br>\nme wondering about how/if various set-theoretical agendas and<br>\ntheir implications (e.g. the forcing methods, implications of the<br>\naxiom of choice) are answered.</p>\n<p>To sum up: I do not think that there are good pragmatic<br>\nautomation-related reasons for persuading mathematicians to work<br>\nin HOL instead of ZF. Given the very low penetration that formal<br>\nmathematics has so far among mathematicians, I think it would not<br>\nhurt the formal systems to go where the mathematicians are.</p>\n<p>Josef</p>",
        "id": 294147142,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847923
    },
    {
        "content": "<p>From: Serguei Mokhov &lt;<a href=\"mailto:serguei@gmail.com\">serguei@gmail.com</a>&gt;<br>\nJames,</p>\n<p>JFYI, perhaps you should bring up some of these questions on the<br>\nFoundations of Mathematics (FOM) mailing list to get some of the<br>\ninsight from the \"other side\" and see what they have to say about HOL<br>\nand FOM.</p>\n<p><a href=\"http://www.cs.nyu.edu/mailman/listinfo/fom\">http://www.cs.nyu.edu/mailman/listinfo/fom</a></p>\n<p>-s</p>",
        "id": 294147168,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847935
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jlcaadawson@netspeed.com.au\">jlcaadawson@netspeed.com.au</a>&gt;<br>\nUnfortunately \"where the mathematicians are\" is to use language in a way <br>\nwhich is typical of natural languages, which contain exactly the sort of <br>\ninconsistencies and ambiguities which lead people to use formal systems <br>\ninstead.</p>\n<p>For example, mathematicians say things like \"the derivative of f(x)\", <br>\nwhen they are referring to the derivative of f, and they say f(n) = <br>\nO(g(n)) (but that O(g(n)) is a set of functions), when they mean f is <br>\n_in the set_ O(g) - etc.</p>\n<p>Jeremy</p>",
        "id": 294147211,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847950
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Sat, Nov 5, 2011 at 5:21 PM, James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt; wrote:</p>\n<blockquote>\n<p>I'm not used to a character that's been defined as an operator being used by<br>\nitself to refer to a function. Even now, I know I can talk of \"comp\", but I<br>\ndon't know if I can talk of \"o\" without using it with f and g. In Haskell I<br>\ncan refer to + by putting it in (+). All this would feel second nature if I<br>\nhad been doing much coding and using functions like sum(a,b) instead of<br>\n\"a+b\".</p>\n<p>That's all notation, it's six of one, or a half dozen of the other.</p>\n</blockquote>\n<p>You're right, it's just syntax. You can talk about o on its own by<br>\nputting it in brackets (o), just like + in Haskell. (o) is the same<br>\nthing as comp.</p>\n<blockquote>\n<p>_Q1_: Have you seen it [composition] being defined as a function before? If<br>\nso, what was<br>\nits domain and range?</p>\n<p>It's always defined as a function, where a function is a set of ordered<br>\npairs. If g:A--&gt;B and f:B--&gt;C, then the domain and range are determined for<br>\n(f o g). We have to have (f o g):A--&gt;C, where A, B, and C can be any sets.</p>\n</blockquote>\n<p>No. I was asking whether you'd seen composition itself, just the (o),<br>\ndefined as a function before. You're saying that the result of<br>\ncomposition, f o g, is always a function. That's right. But I guess<br>\nusually you would think of the \"o\" there as an operator that can never<br>\nappear on its own without two arguments around it. From the<br>\nhigher-order perspective, as you've noticed, all of these are<br>\nfunctions: \"_ o _\", \"f o _\", \"_ o g\", and \"f o g\". The first one takes<br>\ntwo functions and returns a function. The second two take one function<br>\nand return a function. The last one takes something (maybe not a<br>\nfunction, depends on g) and returns something else (again, depends on<br>\nf).</p>\n<blockquote>\n<p>_Q2_:(I also want to ask: how would you usually think of an ordinary<br>\nfunction that takes two arguments? This line would continue into a<br>\ndiscussion about currying, but I'll leave it out for now.)</p>\n<p>As a two variable function f(x,y).</p>\n<p>But it's not acceptable for me to think like that now. When I was studying<br>\nfunctional programming for practical reasons, it was acceptable to think of<br>\n\"f: 'a =&gt;  'b =&gt;  'c\" as a two variable function f(a,b), but once you make<br>\nit part of a math definition, I'm only allowed to to think of it as what it<br>\nis.</p>\n</blockquote>\n<p>There are at least three ways to think about functions of multiple arguments.</p>\n<p>1) Have a new variation on the theme of \"function\" for every number of<br>\narguments it might take, so a function of two arguments is a different<br>\nalthough similar kind of entity as a function of one argument. It<br>\nmight be a set of triples as opposed to a set of pairs, for example.</p>\n<p>2) (Curried functions) Every function takes exactly one argument. To<br>\nget the effect of taking more arguments, return a function to consume<br>\nthe remaining arguments. For example, suppose we have f(x,y) = x + y.<br>\nAs a curried function, f would have type num =&gt; num =&gt; num, or, for<br>\nclarity, num =&gt; (num =&gt; num). When you apply it to one argument, it<br>\nreturns a function of type num =&gt; num. Thus f 3 :: num =&gt; num. Now if<br>\nyou apply that resulting function to one argument, it returns a<br>\nnumber. (f 3) 4 :: num (and (f 3) 4 = 7). We would usually write f 3 4<br>\nfor (f 3) 4, by making function application associate to the left.</p>\n<p>3) Every function takes exactly one argument. To get the effect of<br>\ntaking more arguments, take all your required arguments at once in a<br>\ntuple. The function f as above would in this case have type num * num<br>\n=&gt; num. You apply it to a pair of numbers (3,4), and get back a number<br>\nf (3,4) = 7.</p>\n<p>Representations 2 and 3 are closely related. Indeed, you can write a<br>\n(higher-order) function to transform a curried function into an<br>\nuncurried function (and vice versa).</p>\n<p>Are any of these close to how you usually think of functions of<br>\nmultiple arguments?</p>",
        "id": 294147222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847954
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nThis discussion reminds me of this thesis:<br>\n<a href=\"http://people.pwf.cam.ac.uk/mg262/GanesalingamMdis.pdf\">http://people.pwf.cam.ac.uk/mg262/GanesalingamMdis.pdf</a><br>\nI've only read fragments of it, but particularly relevant to what<br>\nstarted this whole discussion is the observation on page 189 that the<br>\nstandard set theory definition of functions doesn't reflect how<br>\nmathematicians actually think of functions.  In particular, according to<br>\nthat definition, functions don't have unique codomains.  (The footnote<br>\nabout this observation being novel indicates that the author was unaware<br>\nof page 19 of Topoi: <a href=\"http://tinyurl.com/7qx72ou\">http://tinyurl.com/7qx72ou</a> .  In the interests of<br>\nfull disclosure, the author of Topoi is Rob Goldblatt, who is my current<br>\nsupervisor.)</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/v7TGKbZs04_o7EIeDdvGfAcn/signature.asc\">signature.asc</a></p>",
        "id": 294147253,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847964
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nThanks for the link.</p>\n<p>The range/codomain part of function definition shows that much of math <br>\nis just logic games.</p>\n<p>To prove that f is a function, you have to show that for every element <br>\nin the domain, there exists an element in the codomain that it's mapped <br>\nto. But the best you might can do is show that it maps to an element in <br>\nsome interval. So someone, somewhere back  in history, conveniently <br>\ndecided to loosen up the definition of function to allow that. <br>\nOtherwise, a tighter definition of function becomes a big show stopper.</p>\n<p>Begin reasonably pragmatic, I'd say all these logic games are useless <br>\nother than the fact that it recently occurred to me that using the Axiom <br>\nof Choice is not just a useless logic game. If you can know two sets <br>\naren't equal, and the Axiom of Choice can give you that, then that's useful.</p>\n<p>As to how this applies to me, it's not my fault. I'm a product of a <br>\ncenturies old university system that has programmed me to have certain <br>\nexpectations, and want certain things.</p>\n<p>--James</p>",
        "id": 294147336,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847997
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nRamana,</p>\n<p>Thanks again for the help. I'll answer your last question first, and <br>\nthen go long-winded on you.</p>\n<p>_Q_:  Representations 2 and 3 are closely related. Indeed, you can write <br>\na (higher-order) function to transform a curried function into an <br>\nuncurried function (and vice versa).  Are any of these close to how you <br>\nusually think of functions of multiple arguments?</p>\n<p>Yes, #3 pretty much represents multi-variable calculus. It's all about <br>\nhaving a function f:R^n --&gt; R^m. N-tuples. It's all about n-tuples.</p>\n<p>As to currying, in the Haskell books, it was quickly pointed out that <br>\nthough curried functions were primarily being used, as you say, which <br>\nthey said, going back and forth between curried functions and uncurried <br>\nfunctions is not a problem. All these details about curried functions <br>\nwill help me if curried functions become a part of what I'm doing.</p>\n<p>However, the reason that we're having to talk about multi-variable <br>\nfunctions, in relation to function composition, is not because of how <br>\nfunction composition is implemented with sets, but how it's implemented <br>\nwithout sets.</p>\n<p>The definition of sets function composition doesn't make it a function <br>\nwhich takes multiple arguments. If the domain is a collection of <br>\nn-tuples, then we have a multi-variable function. If not... I always get <br>\nparanoid when making technical claims, even if they're basic.</p>\n<p>I'll stop here. All I have to do flip a mental switch. Initially, I make <br>\nit my goal to prove every theorem in Rudin just like he does. If I flip <br>\na switch, then I decide it's good to implement them with proofs founded <br>\non curried functions.</p>\n<p>But I still have questions, which you don't need to answer. Are curried <br>\nfunctions merely part of implementation, or can they be abstracted out?</p>\n<p>Where am I going to find the definition of function? I see that function <br>\nis already being used in Fun.thy. I see that Groups.thy is two levels up <br>\nfrom HOL.thy, and functions are used in groups. My guess is that I'm <br>\ngoing to find function at the compiler level.</p>\n<p>Thanks,<br>\nJames</p>",
        "id": 294147386,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848003
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Mon, Nov 7, 2011 at 6:08 PM, James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Ramana,<br>\nYes, #3 pretty much represents multi-variable calculus. It's all about<br>\nhaving a function f:R^n --&gt; R^m. N-tuples. It's all about n-tuples.</p>\n<p>As to currying, in the Haskell books, it was quickly pointed out that though<br>\ncurried functions were primarily being used, as you say, which they said,<br>\ngoing back and forth between curried functions and uncurried functions is<br>\nnot a problem. All these details about curried functions will help me if<br>\ncurried functions become a part of what I'm doing.</p>\n</blockquote>\n<p>Good. I'm glad they were both familiar already.</p>\n<blockquote>\n<p>But I still have questions, which you don't need to answer. Are curried<br>\nfunctions merely part of implementation, or can they be abstracted out?</p>\n</blockquote>\n<p>I'm not sure what you mean. You said \"or\" between two things that<br>\nwould go together. I think the answer is \"no\".</p>\n<blockquote>\n<p>Where am I going to find the definition of function? I see that function is<br>\nalready being used in Fun.thy. I see that Groups.thy is two levels up from<br>\nHOL.thy, and functions are used in groups. My guess is that I'm going to<br>\nfind function at the compiler level.</p>\n</blockquote>\n<p>Functions are fundamental to HOL, so you're right if you're calling<br>\nthat the \"compiler level\". (But you don't have to go to the ML<br>\ncompiler level!) The function type operator (the \"=&gt;\" we were using<br>\nbefore) is primitive, that is, not created by type definition. In the<br>\nusual model of HOL in set theory, it constructs function spaces.</p>",
        "id": 294147445,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848023
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nRamana,</p>\n<p>Makes sense, I guess. And even in src/ZF/ZF.thy I see that primitive.</p>\n<p>It's all functional programming. That's my revelation of yesterday. <br>\nAnything that gives me recursion is probably going to be functional <br>\nprogramming.</p>\n<p>My requirements have changed. All I want is the easiest possible way to <br>\nlearn a tool that allows me to do some logic and have the appearance of <br>\nsets. If there's a problem, it's false illusions.</p>\n<p>Thanks,<br>\nJames</p>",
        "id": 294147449,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848027
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nI'll ask the easy question first. In my inbox, there's <br>\n<a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a> and <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> . Does <br>\nit make any difference which address I use to send in a question? If it <br>\ndoesn't, you don't need to answer that question.</p>\n<p>I've tried not to ask different forms of my next question. That's <br>\nbecause after studying enough type theory, lambda calculus, functional <br>\nprogramming, and files from ~~/src/HOL, I'll figure out most of the <br>\nanswers. But that could be up to a years worth of work, and I'm trying <br>\nto get a feel for where this road is going, and whether I may need to <br>\ntravel the road less traveled.</p>\n<p>My question, stated very general, is this: \"Can I take a file such as <br>\n~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard <br>\nmath definitions and theorems, with a few changes to accommodate types, <br>\nand have these standard definitions/theorems be describing the same <br>\nobjects as the Isabelle definitions and lemma?\" I'm not talking about <br>\nstarting with a different logical framework or set of axioms, and ending <br>\nup at the same place.</p>\n<p>Below I ask related questions which are probably more straight forward <br>\nto answer, and, if answered, might answer the question just posed.</p>\n<p>To get more specific, I'll ask some questions about \"definition comp\" in <br>\nFun.thy, which is the definition of function composition.</p>\n<p>First, here are some related goals to set the context, for why I'm <br>\nthinking about this now:<br>\n1) I want to cater to mathematicians who are doing traditional <br>\nmathematics. Therefore, the language of my definitions and theorems <br>\nneeds to be reasonably familiar to them. I'd like to start rephrasing <br>\nIsabelle defs and thms now.<br>\n2) I want to build on, and learn from, what others have done. Therefore, <br>\nmy first choice is HOL rather than ZF, since the library is larger, even <br>\nthough HOL is not as \"traditional\".</p>\n<p>Here's the definition of comp from Fun.thy:</p>\n<p>definition comp :: \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c\" (infixl <br>\n\"o\" 55) where<br>\n   \"f o g = (\\&lt;lambda&gt;x. f (g x))\"</p>\n<p>Studying Haskell is what led me to Isabelle, and I studied just enough <br>\nfunctional programming to know that comp is a function that takes type <br>\n\"('b =&gt; 'c)\" and returns type (('a =&gt; 'b) =&gt; 'a =&gt; 'c)). I guess that's <br>\nright, although I ask below about (\\&lt;lambda&gt;x. f (g x)), and about its <br>\ndomain and range.</p>\n<p>Functions have domains and ranges. You won't be surprised here, but <br>\nnever once have I seen \"function composition\" be defined with the domain <br>\nbeing a set of functions, and the range being a set of functions whose <br>\nelements are functions, which take functions, and return functions.</p>\n<p>Here's what I want out of \"definition comp\", using more standard math <br>\nlanguage:</p>\n<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o <br>\ng):'a--&gt;'b, where (f o g)(x) = f(g(x)).</p>\n<p>Notice that I tweak the definition to use types rather than sets. I was <br>\nalso tempted to stick \"(f o g) = (%x. f(g x))\" in there, not that I know <br>\nmuch more than what it symbolizes. The details and groundwork could be <br>\nworked out if it's basically the same thing as \"comp\".</p>\n<p>A pertinent point here is that with a definition such as DEFINITION <br>\n1.1.1, I'm not making many demands on someone. They might be willing to <br>\ngo with it even with only an intuitive understanding of types and lambda <br>\ncalculus. However, it's important to me that something like DEFINITION <br>\n1.1.1 and \"comp\" be the same thing. Not be like, \"think of them as the <br>\nsame\", but \"are the same\".</p>\n<p>Okay, what I really want is something like this:<br>\n     (f o g) = {(a,c) in AxC | ThereExists b in B, such that (a,b) is in <br>\ng and (b,c) is in f}.</p>\n<p>You can tell me different, but I assume I'm correct in saying that <br>\n\"comp\" is not this set, and can't be this set, though with some work, <br>\nsome form of equivalence could be shown. Again, I guess that's right.</p>\n<p>Somewhere in this question is me trying to figure out how different <br>\n\"comp\" is from a standard definition of composition. Is \"comp\" close <br>\nenough to a standard definition to try and phrase it using standard <br>\nlanguage, or it's \"functional programming, type theory, and lambda <br>\ncalculus\", and I should just accept it for what it is. Regardless, it is <br>\nwhat it is, and I want to describe it as what it is, but describe it <br>\nusing language other than Isabelle code.</p>\n<p>POINT 1: In a standard definition of function composition, there are <br>\ntypically three functions, \"f\", \"g\", and \"f o g\".</p>\n<p>POINT2: In \"comp\", there are four functions, \"f\", \"g\", \"(\\&lt;lambda&gt;x. f <br>\n(g x))\", and the function of type<br>\n     \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c\".</p>\n<p>What I've said above might could be summarized with this question:<br>\n     What is this thing, this function \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; <br>\n'a  =&gt; 'c\"?</p>\n<p>If I have to incorporate that into my traditional-style definition, then <br>\nit's no longer traditional-style. If I have to do that, then I'm doing <br>\nsomething different.</p>\n<p>If it's necessary details, and a way of specifying \"g:'a--&gt;'b, <br>\nf:'b--&gt;'c, and (f o g):'a--&gt;'b\", and I can easily formalize the <br>\nconnection prior to my function composition definition, then the <br>\nsituation is salvageable.</p>\n<p>Anyway, feel free to comment or not.</p>\n<p>Thanks,<br>\nJames</p>",
        "id": 294147593,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848077
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nOn 08/11/11 05:00, James Frank wrote:</p>\n<blockquote>\n<p>To prove that f is a function, you have to show that for every element<br>\nin the domain, there exists an element in the codomain that it's mapped<br>\nto. But the best you might can do is show that it maps to an element in<br>\nsome interval.</p>\n</blockquote>\n<p>What?  Why?</p>\n<blockquote>\n<p>So someone, somewhere back  in history, conveniently<br>\ndecided to loosen up the definition of function to allow that.</p>\n</blockquote>\n<p>To allow what?  I'm not convinced that anyone deliberately decided that<br>\nthe definition of functions shouldn't correspond with how mathematicians<br>\nactually think about them.  I think it's just a long-standing imprecision.</p>\n<blockquote>\n<p>Otherwise, a tighter definition of function becomes a big show stopper.</p>\n</blockquote>\n<p>Why?  Can you give an example?</p>\n<blockquote>\n<p>--James</p>\n</blockquote>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/R5UbgueZFRMlACVJQ88oVSE6/signature.asc\">signature.asc</a></p>",
        "id": 294147694,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848119
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nThere are many ways to go about answering your question, and I'm sure<br>\nother people on the list will make better attempts than me. But I hope<br>\nmultiple answers will help you, at least for different perspectives.<br>\nThe main thing I want to say is that I think the situation is<br>\nsalvageable: functional programming, (simple) type theory, and lambda<br>\ncalculus are not so far removed from traditional mathematics.<br>\nYou may be interested also in looking at Higher Order Set Theory. But<br>\nfor now let's stick with HOL.<br>\nI'll make a few specific comments below, under the relevant bits of<br>\nyour message.</p>\n<p>On Thu, Nov 3, 2011 at 6:45 PM, James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt; wrote:</p>\n<blockquote>\n<p>My question, stated very general, is this: \"Can I take a file such as<br>\n~~/src/HOL/Fun.thy, rephrase the definitions in the language of standard<br>\nmath definitions and theorems, with a few changes to accommodate types, and<br>\nhave these standard definitions/theorems be describing the same objects as<br>\nthe Isabelle definitions and lemma?\" I'm not talking about starting with a<br>\ndifferent logical framework or set of axioms, and ending up at the same<br>\nplace.</p>\n</blockquote>\n<p>I think yes.</p>\n<blockquote>\n<p>Functions have domains and ranges. You won't be surprised here, but never<br>\nonce have I seen \"function composition\" be defined with the domain being a<br>\nset of functions, and the range being a set of functions whose elements are<br>\nfunctions, which take functions, and return functions.</p>\n</blockquote>\n<p>Have you seen it being defined as a function before? If so, what was<br>\nits domain and range?</p>\n<p>(I also want to ask: how would you usually think of an ordinary<br>\nfunction that takes two arguments? This line would continue into a<br>\ndiscussion about currying, but I'll leave it out for now.)</p>\n<blockquote>\n<p>Here's what I want out of \"definition comp\", using more standard math<br>\nlanguage:</p>\n<p>DEFINITION 1.1.1 (comp). Let g:'a--&gt;'b and f:'b--&gt;'c. Then (f o g):'a--&gt;'b,<br>\nwhere (f o g)(x) = f(g(x)).</p>\n</blockquote>\n<p>This looks like a definition of composition as an \"operator\", rather<br>\nthan a function. From a \"first-order\" perspective, since functions are<br>\non a higher level than the values they take and receive, we need a<br>\nseparate concept for things like comp that operate on functions<br>\nthemselves. Notice that Definition 1.1.1 doesn't ever say that \"o\"<br>\nitself is taking arguments and returning a value, rather, it specifies<br>\nwhat the function \"f o g\" (which is really a function and not an<br>\noperator) does by saying what it does on arguments.</p>\n<p>When you switch to the \"higher-order\" perspective, these distinctions<br>\nall disappear. Functions are values too, and operators that<br>\ntake/receive functions are also just functions. So the function<br>\ncomposition operator is itself a function.</p>\n<blockquote>\n<p>Okay, what I really want is something like this:<br>\n   (f o g) = {(a,c) in AxC | ThereExists b in B, such that (a,b) is in g and<br>\n(b,c) is in f}.</p>\n<p>You can tell me different, but I assume I'm correct in saying that \"comp\" is<br>\nnot this set, and can't be this set, though with some work, some form of<br>\nequivalence could be shown. Again, I guess that's right.</p>\n</blockquote>\n<p>It could be that set in a model of HOL, but the sets in the model<br>\nwouldn't be the same as the sets encoded in Set.thy for example. To<br>\navoid confusion, perhaps I should just say \"you're right, comp is not<br>\nthat set, but it is in some sense equivalent.\"</p>\n<blockquote>\n<p>POINT 1: In a standard definition of function composition, there are<br>\ntypically three functions, \"f\", \"g\", and \"f o g\".</p>\n<p>POINT2: In \"comp\", there are four functions, \"f\", \"g\", \"(\\&lt;lambda&gt;x. f (g<br>\nx))\", and the function of type<br>\n   \"('b =&gt; 'c)  =&gt; ('a  =&gt; 'b)  =&gt; 'a  =&gt; 'c\".</p>\n</blockquote>\n<p>The fourth function in \"comp\" is function composition itself (denoted by \"o\").</p>",
        "id": 294147772,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848144
    },
    {
        "content": "<p>From: James Frank &lt;<a href=\"mailto:james.isa@gmx.com\">james.isa@gmx.com</a>&gt;<br>\nTim,</p>\n<p>Thanks for the question, primarily so I can leave in a civilized manner <br>\nand say something positive. By asking my question, I've made about 3 <br>\ntransitions.</p>\n<p>It was functional programming, then proof assistants, and now it's all <br>\nthe same. In messing around with Isabelle for about a month, it raised <br>\nmy awareness so that I could see that Coq is a functional programming <br>\nlanguage. Coq provides me with a book which will teach me functional <br>\nprogramming and the proof assistant software at the same time. Isabelle <br>\nstarts at the intermediate level in regards to functional programming. <br>\nThat's too high for me.</p>\n<p>Everyone here has been very helpful, accessible, and professional. I'm <br>\nnot a professional, and I don't act like one.</p>\n<p>Now to your questions.</p>\n<p>SHORT ANSWER: Let f(x)=sin(x).</p>\n<p>REFERENCE: <a href=\"http://www.angelo.edu/faculty/cdiminni/\">http://www.angelo.edu/faculty/cdiminni/</a> . The area code is <br>\nactually 325, not 915.</p>\n<p>YOU ASK: What? Why?</p>\n<p>Because the definition requires it.</p>\n<p>Let f be a subset of AxB. Then f is a function if<br>\n1) for every x in A, their exists some y in B such that (x,y) is in f, and<br>\n2) if (x,y1) is in f, and (x,y2) is in f, then y1=y2.</p>\n<p>We call A the domain of f, and we call B the codomain of f. The range of <br>\nf is that subset of B... It's getting obnoxious at this point. The range <br>\nis the actual values that the x's are mapped to.</p>\n<p>YOU ASK AND SAY:  To allow what? I'm not convinced that anyone <br>\ndeliberately decided that the definition of functions shouldn't <br>\ncorrespond with how mathematicians actually think about them. I think <br>\nit's just a long-standing imprecision.</p>\n<p>I'm not a historian. I was speculating on the reasons. It doesn't make <br>\nsense to continue to have such a loose definition of function unless <br>\nthere's an advantage. EXAMPLE: Definition of limit. Newton and Liebniz <br>\nstarted limit (or used it). Weierstrass tightened it up. Everyone <br>\naccepted the tighter epsilon-delta definition.</p>\n<p>WE ARGUE:</p>",
        "id": 294147805,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848156
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nOn 11/11/11 06:28, James Frank wrote:</p>\n<blockquote>\n<p>SHORT ANSWER: Let f(x)=sin(x).</p>\n</blockquote>\n<p>This could define several different functions.  For example, it could<br>\ndefine a function from the complex numbers to the complex numbers; it<br>\ncould define a function from the real numbers to the real numbers; or,<br>\nit could define a function from the real numbers to [-1,1].  The point<br>\nis that according to the standard definition of functions, the last two<br>\nare identical.</p>\n<blockquote>\n<p>YOU ASK: What? Why?</p>\n<p>Because the definition requires it.</p>\n<p>Let f be a subset of AxB. Then f is a function if<br>\n1) for every x in A, their exists some y in B such that (x,y) is in f, and<br>\n2) if (x,y1) is in f, and (x,y2) is in f, then y1=y2.</p>\n<p>We call A the domain of f, and we call B the codomain of f.</p>\n</blockquote>\n<p>But \"the codomain\" isn't well defined.  I think the example from Topoi<br>\nillustrates my point quite well.  What is the identity function on the<br>\nnatural numbers?  According to the traditional definition, the answer is<br>\n{(0,0), (1,1), (2,2), ...}.<br>\nWhat is the injection function from the natural numbers to the integers?<br>\n{(0,0), (1,1), (2,2), ...}.<br>\nThe traditional definition requires that an identity function on a set A<br>\nis exactly the same function as every injection function from A to any<br>\nsuperset of A.  I don't believe that this is how mathematicians actually<br>\ntreat identity and injection functions.</p>\n<p>And the crucial thing is this:  If I ask \"What is the codomain of<br>\n{(0,0), (1,1), (2,2), ...}?\",<br>\nthe answer has to be that the codomain isn't uniquely defined, but must<br>\nbe some superset of the natural numbers.</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/c3tYe52JMJcvhyJ3kGkFkdOW/signature.asc\">signature.asc</a></p>",
        "id": 294147833,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848171
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThere is a sense in which your question is not entirely meaningful, because you're asking whether rigorous but informal mathematics is adequately captured by a particular formalisation, and such issues are ultimately subjective. However, traditional mathematics is often assumed to be based on set theory, and higher-order logic has very straightforward models in set theory. In particular, if you look at the function f o g, then you get exactly the same set of ordered pairs by either route, assuming you're in the mood to interpret a function as a set of ordered pairs. The situation with higher-order logic is very different from that presented by various constructive type theories you may have seen, where you typically cannot regard a function as a set of pairs.</p>\n<p>Some of the other points that you mention relate to basic lambda-calculus. There is no need to study the lambda calculus in its full glory, as it is quite irrelevant to higher-order logic. Lambda-notation merely expresses the notion of a function, something that is curiously lacking in standard mathematical practice. The type of the composition operator is a well-known device, known as currying, for expressing functions that take multiple arguments. Again, traditional mathematics is quite careless in such situations. You remark that functions have domains and ranges, but typically the function composition operator is not written in such terms at all, and is allowed to apply to any compatible pairs of functions whatever. In the language of set theory, it is a class function.</p>\n<p>Anything that you can define in higher-order logic is not merely explicable in traditional mathematical terms, but it is easily so. But there are plenty of things you can write in mathematics that are impossible to formalise in higher-order logic. This is because mathematics is essentially open-ended.</p>\n<p>Larry Paulson</p>",
        "id": 294148494,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848414
    }
]