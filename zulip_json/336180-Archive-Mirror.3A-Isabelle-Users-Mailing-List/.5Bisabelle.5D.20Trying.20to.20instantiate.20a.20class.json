[
    {
        "content": "<p>From: Andrew Gacek &lt;<a href=\"mailto:andrew.gacek@gmail.com\">andrew.gacek@gmail.com</a>&gt;<br>\nI have a class defined as</p>\n<p>class foo =<br>\n  fixes foo :: 'a</p>\n<p>and I am trying to instantiate it over the type \"string\" but I get an error:</p>\n<p>instantiation \"string\" :: foo<br>\nBad type name: \"String.string\"</p>\n<p>Knowing that string is \"char list\" I tried that instead, but still got an error:</p>\n<p>instantiation \"char list\" :: foo<br>\nUndefined type name: \"char list\"</p>\n<p>Is there any way to instantiate the class over the type \"string\" like I want?</p>\n<p>I know I could try to instantiate at \"char\" and then do something<br>\ngeneral for \"list\", but it turns out the definitions I want for the<br>\ntype \"char list\" are not the same as doing this for char and then<br>\nlifting it to lists.</p>\n<p>Perhaps I have to wrap \"string\" in a datatype to get what I want?</p>\n<p>Thanks,<br>\nAndrew</p>",
        "id": 294326620,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928759
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI'm afraid Isabelle's type classes are the classical Haskell ones, no <br>\nextensions. Either do it for lists in general or wrap string in a datatype. Or <br>\nuse a locale instead of a class.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/vqfHxxECehL-t4px4dXdKBlA/smime.p7s\">smime.p7s</a></p>",
        "id": 294326674,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928766
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Andrew,</p>\n<p>You can instantiate a type class only for a type constructor such as \"list\", not for <br>\ncompound types such as \"char list\". Since \"string\" is a type synonym of \"char list\", the <br>\ntype class instantiation for \"string\" must match the instantiation for \"char list\". If <br>\n\"char list\" and \"string\" must have different instantiations, then you have to use some <br>\nother type constructor that is isomorphic to string, and do the instantiation for it.</p>\n<p>Note that the type \"String.literal\"  from theory String is such a copy, but I recommend <br>\nthat you do not use this type copy for your purposes. String.literal has a specific <br>\npurpose for code generation, so if you ever want to generate code (especially in Haskell), <br>\nyou will run into problems with String.literal.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294326689,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928771
    },
    {
        "content": "<p>From: Andrew Gacek &lt;<a href=\"mailto:andrew.gacek@gmail.com\">andrew.gacek@gmail.com</a>&gt;<br>\nLet me step back and say that what I primarily want is a way to define<br>\na function at multiple different types so that I can use it with the<br>\nsame syntax in each case. Originally I did this just by using the same<br>\nsyntactic abbreviation for all of them, but the number of ambiguous<br>\nparses grows way too much.</p>\n<p>I want something like</p>\n<p>swap :: string =&gt; string =&gt; 'a =&gt; 'a</p>\n<p>which I will define at various types like string, exp, equation, exp<br>\nlist, string list, string =&gt; nat, etc. It would also be nice if the<br>\ncases for exp list and string list were derived from a general pattern<br>\nfor list.</p>\n<p>I've tried using locales just now, but I don't think it provides what<br>\nI'm looking for (or perhaps I'm using them wrong). If that's right,<br>\nthen it seems the only solution would be to wrap types like string and<br>\nstring =&gt; nat into datatypes so that I can instantiate a type class in<br>\nan ad-hoc fashion for them. The downside is that having something like<br>\nstring =&gt; nat wrapped in a datatype makes the it more cumbersome to<br>\nuse since I can no longer just apply it to a string to get back a nat.</p>\n<p>Is this an accurate assessment?</p>\n<p>Thanks,<br>\nAndrew</p>",
        "id": 294326700,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928777
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Andrew,</p>\n<p>There are two ways that approximate what you want.</p>\n<ol>\n<li>You can define swap at different types using the unrestricted overloading feature (see <br>\nsection 5.9 in the Isar reference manual). The types from the various definitions must not <br>\noverlap, so you cannot define it on 'a list and strings separately. Type inference does <br>\nnot check that all occurrences of swap in a term have a type that is covered by some <br>\ndefinition. Depending on your usage, you might end up with a lot of type annotations, but <br>\nyou can in principle use swap with abstract types. Moreover, code generation does not work <br>\nfor swap. Here's an example:</li>\n</ol>\n<p>consts swap :: \"string ⇒ string ⇒ 'a ⇒ 'a\"</p>\n<p>overloading swap_string ≡ \"swap :: string ⇒ string ⇒ char list ⇒ char list\" begin<br>\ndefinition \"swap_string = (undefined :: string ⇒ string ⇒ char list ⇒ char list)\"<br>\nend</p>\n<ol start=\"2\">\n<li>Use the package for adhoc overloading (section 11.9 in isar-ref, theory <br>\n~~/src/Tools/Adhoc_Overloading). You declare swap as a constant without definition, and a <br>\nseparate constant for every type you need. During type inference, occurrences of swap are <br>\nreplaced by one of the separate constants according on the type. Type checking ensures <br>\nthat there is a unique definition for every occurrence. Thus, you cannot use swap with an <br>\nabstract type, but code generation works as expected. With a little trick, you can even <br>\nhave generic implementations for type constructors and specialised ones taking precedence. <br>\nHere's an example:</li>\n</ol>\n<p>consts swap :: \"string ⇒ string ⇒ 'a ⇒ 'a\"</p>\n<p>definition swap_string :: \"string ⇒ string ⇒ string ⇒ string\"<br>\nwhere \"swap_string = undefined\"</p>\n<p>adhoc_overloading swap swap_string</p>\n<p>class swap_list</p>\n<p>definition swap_list :: \"string ⇒ string ⇒ 'a :: swap_list list ⇒ 'a list\"<br>\nwhere \"swap_list = undefined\"</p>\n<p>adhoc_overloading swap swap_list</p>\n<p>instance int :: swap_list ..</p>\n<p>lemma \"swap = (swap_list :: _ ⇒ _ ⇒ int list ⇒ _)\" ..<br>\nlemma \"swap = swap_string\" ..</p>\n<p>You have to instantiate the type class swap_list for all types that you want to use the <br>\ngeneric implementation from list. Since the type of the function swap_list is restricted <br>\nto lists over a type that inhabits the class swap_list, type inference will use <br>\nswap_string for \"char list\" (= \"string\") and swap_list for other types such as \"int list\".</p>\n<p>You cannot use this trick with such a marker type class in the first approach because you <br>\ncould later on instantiate char and thus create inconcistencies. Since the kernel of <br>\nIsabelle only sees the replaced constants swap_list, swap_string, etc., soundness is not a <br>\nproblem.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294326716,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928784
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nHi Andrew,</p>\n<p>Why don't you do it like this:</p>\n<p>class foo =<br>\n  fixes foo :: 'a</p>\n<p>instantiation \"list\" :: (type) foo<br>\n  begin<br>\n    instance proof qed<br>\n  end</p>\n<p>You create the instantiation for every kind of lists.<br>\nThe problem is that instead of char you have an<br>\narbitrary type. If you use some operations on<br>\nchars, then this is too abstract, but if you only<br>\nwork with operations on lists, then this should be<br>\nenough.</p>\n<p>If you need operations on char in the instantiation,<br>\nthen you can create another class</p>\n<p>class my_char =<br>\n  fixes \"operations on char that you need to abstract\"<br>\n  assumes \"properties of the operation on char that you need in the list<br>\n:: (type) foo instantiation\"</p>\n<p>Then you create an instantiation of char as my_char:</p>\n<p>class my_char =<br>\n  fixes my_op :: 'a</p>\n<p>class foo_str =<br>\n  fixes foo_str :: \"'a ⇒ 'a\"<br>\n  assumes foo_rule: \"foo_str x = foo_str y\"</p>\n<p>instantiation \"char\" :: my_char<br>\n  begin<br>\n    definition \"my_op = CHR ''a''\"<br>\n    instance proof qed<br>\n  end</p>\n<p>instantiation \"list\" :: (my_char) foo_str<br>\n  begin<br>\n    definition foo_my_char_def: \"foo_str x = [my_op]\"<br>\n    instance proof qed (simp add: foo_my_char_def)<br>\n  end</p>\n<p>lemma \"foo_str (x::string) = foo_str y\"<br>\n    by (rule foo_rule)</p>\n<p>This gives you the full power as you would get if<br>\nit would be possible to instantiate string as foo.<br>\nThe drawback is that you need to duplicate in<br>\nmy_char the operations on characters. You can<br>\ndo it easily by  assuming a bijective function between<br>\nmy_char and char.</p>\n<p>I needed something similar. In my case I needed<br>\nto instantiate (nat =&gt; 'a::SomeClass) as SomeClass, but it<br>\nwas not possible, so I created a class Nat, and<br>\nI instantiated nat as Nat, and I created the<br>\ninstance ('a::Nat =&gt; 'b::SomeClass) of SomeClass.</p>\n<p>You can see the details of this in the archive of formal proofs:</p>\n<p><a href=\"http://afp.sourceforge.net/entries/RefinementReactive.shtml\">http://afp.sourceforge.net/entries/RefinementReactive.shtml</a></p>\n<p>in the file Temporal.thy</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294326817,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928828
    },
    {
        "content": "<p>From: Andrew Gacek &lt;<a href=\"mailto:andrew.gacek@gmail.com\">andrew.gacek@gmail.com</a>&gt;<br>\nThanks for the suggestion. In the end, I wrapped my strings (and other<br>\ntypes) in a datatype. I added some abbreviations and new syntactic<br>\nnotation which makes this not as bad as I expected. Plus it now feels<br>\nlike I'm working with Isabelle rather than against it :-)</p>\n<p>-Andrew</p>",
        "id": 294326827,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928834
    }
]