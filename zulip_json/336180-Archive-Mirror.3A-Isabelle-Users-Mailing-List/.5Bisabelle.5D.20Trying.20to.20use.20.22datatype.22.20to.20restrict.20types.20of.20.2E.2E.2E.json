[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gottfried,</p>\n<p>I still did not quite get the meaning of the sT type. If I understand <br>\nyou correctly, you use the values over which a variable ranges (what you <br>\ncall \"mapped to\") also for the names of the variables.</p>\n<p>Anyway, let's look at your issue with the value command. This command <br>\nuse various evaluation strategies with Isabelle's code generator being <br>\nthe default (and usually the fastest). Now, the definition of sFOLf1 for <br>\nEq uses HOL equality on the right-hand side for the type sT:<br>\n   \"sFOLf1 E (Eq x y) = (E x = E y)\"<br>\nHowever, you have not told Isabelle how to compute equality on type sT, <br>\nwhich is done as an instance of the type class equal.</p>\n<p>The enum sort constraint comes from using the ! quantifier over sT in<br>\n   \"sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)\"<br>\nBy default, ! is implemented to enumerate all values for v and test for <br>\neach whether the predicate holds. Again, Isabelle does not know how to <br>\nenumerate all values of type sT. You can do so by instantiating the type <br>\nclass enum.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294229649,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901788
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 1/21/2013 1:34 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>I still did not quite get the meaning of the sT type. If I understand <br>\nyou correctly, you use the values over which a variable ranges (what <br>\nyou call \"mapped to\") also for the names of the variables.<br>\nAndreas,</p>\n</blockquote>\n<p>At this point, I stop trying to tell you \"how things are\" and only say <br>\n\"some of what I think is happening\". What you've given me so far has <br>\nsatisfied my basic urge to try and do this. To finish it out will <br>\nrequire me to know more, and it may not be needed or even desirable to <br>\nimplement.</p>\n<p>There's a lot of magic that goes on with Isabelle, and to a certain <br>\nextent, I'm blindly laying down some of the foundation based on having <br>\nlooked a little at HOL.thy, Set.thy, Larry's Isabelle/ZF and Obua's <br>\nHOLZF. Isabelle/HOL is magically proving standard theorems, and I'd say <br>\n\"I'm probably getting lucky\", but I think this is like playing the stock <br>\nmarket where \"luck don't get you very far\", and you're shut down fast if <br>\nwhat you're doing is completely based on guesswork.</p>\n<p>I don't think that variables of type sT really take on values in the <br>\nnormal sense. What takes on values is the predicate \"inS\" that they're <br>\nused in, which is of type bool, so the only real values I'm dealing with <br>\nare True and False, which ultimately come from my predicate of type \"sT <br>\n=&gt; sT =&gt; bool\".</p>\n<p>These five Isar statements set me up initially and demonstrate that <br>\nvariables of type sT get their meaning from being used in the predicate <br>\n\"inS\".</p>\n<p>--\"The primitive type.\"<br>\ntypedecl sT</p>\n<p>--\"The predicate 'is an element of'.\"<br>\nconsts inS :: \"sT =&gt; sT =&gt; bool\"</p>\n<p>--\"HOL equal is defined.\"<br>\naxiomatization where<br>\n   Ax_x: \"!q.!p. ( !x. (inS x q) &lt;-&gt; (inS x p) ) &lt;-&gt; (p = q)\"</p>\n<p>--\"The empty set constant.\"<br>\nconsts emS :: \"sT\"</p>\n<p>--\"The empty set constant axiomatized.\"<br>\naxiomatization where<br>\n   Ax_e: \"!x.~(inS x emS)\"</p>\n<p>Having only crept along at a snail's pace, I've used 4 out of the 10 <br>\naxioms I need, and Sledgehammer magically finds the right theorems to <br>\nprove other theorems, it times out when a \"theorem\" is false, and <br>\nNitpick sometimes magically shows that a false \"theorem\" is false.</p>\n<p>Several of the other 6 axioms have me worried, but it could all come to <br>\na screeching halt today, and I'd still be impressed by the magic.</p>\n<blockquote>\n<p>Anyway, let's look at your issue with the value command. This command <br>\nuse various evaluation strategies with Isabelle's code generator being <br>\nthe default (and usually the fastest). Now, the definition of sFOLf1 <br>\nfor Eq uses HOL equality on the right-hand side for the type sT:<br>\n  \"sFOLf1 E (Eq x y) = (E x = E y)\"<br>\nHowever, you have not told Isabelle how to compute equality on type <br>\nsT, which is done as an instance of the type class equal.</p>\n</blockquote>\n<p>Okay. I don't really compute equality, I define it as shown above by <br>\naxiom Ax_x. I stuck that axiom into the experimental fFOLdt theory and <br>\nit didn't get rid of the error.</p>\n<p>Even after only having made the statement \"typedecl sT\", HOL will prove <br>\nthat \"=\" for type \"sT\" is reflexive, symmetric, and transitive. So HOL <br>\nequal magically works for me in a basic way, because I've used it a <br>\nwhole lot based on the properties I've attached to \"=\" with axiom Ax_x.</p>\n<p>Thanks for the help. I need to make some more progress on getting the <br>\nfirst 9 axioms in. What will cause me logic problems is not necessarily <br>\nwhat I was trying to prevent by using my sFOLf function.</p>\n<p>Regards,<br>\nGB</p>\n<blockquote>\n<p>The enum sort constraint comes from using the ! quantifier over sT in<br>\n  \"sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)\"<br>\nBy default, ! is implemented to enumerate all values for v and test <br>\nfor each whether the predicate holds. Again, Isabelle does not know <br>\nhow to enumerate all values of type sT. You can do so by instantiating <br>\nthe type class enum.</p>\n<p>Best,<br>\nAndreas</p>\n<p>On 01/18/2013 06:50 PM, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>On 1/18/2013 1:28 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>you need to embed your formulas deeply in HOL, i.e., you cannot use<br>\nthe standard HOL connectives &amp;, |, !, etc. for your syntax. So you<br>\nmust use your formula datatype also for the subexpressions of your<br>\nconnectives:<br>\nHope this helps,<br>\nAndreas,</p>\n</blockquote>\n<p>It helped a lot. I wouldn't have gotten to this next step without a fix.</p>\n<p>I'll answer a few questions and then show you the failure I'm at now.</p>\n<blockquote>\n<p>I am not sure what sT is supposed to stand for. Is it the type for<br>\nvariable names or the type of values that variables can take. In the<br>\nformer case: what is the type of values?</p>\n</blockquote>\n<p>Type \"sT\" is a primitive type that represents a set. By \"can take\", I<br>\nguess you mean \"mapped to\" as shown by your \"env\" below.</p>\n<p>Semantically, I don't think a variable of type sT is mapped to another<br>\nvalue in the sense of a function.</p>\n<p>I have a function:</p>\n<p>consts seS :: \"sT =&gt; (sT =&gt; bool) =&gt; sT\"</p>\n<p>I then use a function of that type, (seS q P), in an axiom describing a<br>\nproperty for every (q::sT) and (P::(sT =&gt; bool)), where P is a property<br>\nthat holds for q. (Actually the (sT =&gt; bool) type function is what I'm<br>\ntrying to tighten up with this sFOLf function.)</p>\n<p>Variables of type sT are only used with the predicate \\&lt;in&gt;, such as<br>\n(x::sT \\&lt;in&gt; y::sT), or as a binder variable in \\&lt;exists&gt; or \\&lt;forall&gt;,<br>\nsuch as (!x. phi) or (? x. phi), where phi is a FOL formula built up<br>\nstarting with the atomic formulas (x \\&lt;in&gt; y) and (x = y).</p>\n<p>Variables of type sT are used in HOL functions, but that's only because<br>\nthat's how Isabelle makes me do it. The constant functions I define<br>\nrepresent sets, and axioms are used to state what is true about those<br>\nfunctions.</p>\n<p>I could get more detailed, but I now get wellsortedness errors when<br>\ntrying to use the function sFOLf in a \"value\" statement.</p>\n<p>The command</p>\n<p>value \"sFOLf1 sID (In x y)\"</p>\n<p>gives the error</p>\n<p>\"Wellsortedness error... Type sT not of sort equal. No type arity sT ::<br>\nequal\"</p>\n<p>A similar error with \"enum\" in place of \"equal\" is after the third<br>\n\"value\" command. The \"Eq\" and the \"Forall\" mess things up.</p>\n<p>I'm trying to keep this short, but I'm not all that clear on the<br>\n\"environment\" requirement. However, like I said, variables of type sT<br>\naren't really mapped anywhere.</p>\n<p>To use the \"value\" command, I just made my \"env\" function the identity<br>\nfunction.</p>\n<p>The code is below, and I attached it as a THY.</p>\n<p>Thanks for the help,<br>\nGB</p>\n<p>theory sts__sFOLdt<br>\nimports Complex_Main<br>\nbegin</p>\n<p>typedecl sT</p>\n<p>consts inS :: \"sT =&gt; sT =&gt; bool\"</p>\n<p>datatype sFOLdt =<br>\n   In sT sT<br>\n| Eq sT sT<br>\n| Forall sT sFOLdt</p>\n<p>type_synonym env = \"(sT =&gt; sT)\"</p>\n<p>definition sID :: \"sT =&gt; sT\" where<br>\n   \"sID s = s\"</p>\n<p>fun sFOLf :: \"env =&gt; sFOLdt =&gt; bool\" where<br>\n   \"sFOLf E (In x y) = inS x y\"</p>\n<p>value \"sFOLf sID (In x y)\"</p>\n<p>fun sFOLf1 :: \"env =&gt; sFOLdt =&gt; bool\" where<br>\n   \"sFOLf1 E (In x y) = inS x y\"<br>\n| \"sFOLf1 E (Eq x y) = (E x = E y)\"</p>\n<p>value \"sFOLf1 sID (In x y)\"</p>\n<p>fun sFOLf2 :: \"env =&gt; sFOLdt =&gt; bool\" where<br>\n   \"sFOLf2 E (In x y) = inS x y\"<br>\n| \"sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)\"</p>\n<p>value \"sFOLf2 sID (In x y)\"</p>\n<p>end</p>\n</blockquote>\n</blockquote>",
        "id": 294229661,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901801
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gottfried,</p>\n<blockquote>\n<p>--\"HOL equal is defined.\"<br>\naxiomatization where<br>\n   Ax_x: \"!q.!p. ( !x. (inS x q) &lt;-&gt; (inS x p) ) &lt;-&gt; (p = q)\"</p>\n<p>Okay. I don't really compute equality, I define it as shown above by<br>\naxiom Ax_x. I stuck that axiom into the experimental fFOLdt theory and<br>\nit didn't get rid of the error.<br>\nThe error remains because</p>\n</blockquote>\n<ol>\n<li>you did not declare the axiom Ax_x as a code equation, and</li>\n<li>it is not executable as the !x-quantifier ranges over sT for which <br>\nyou have not provided an implementation.</li>\n</ol>\n<p>The code generator will not work unless you provide a concrete <br>\nrepresentation for the elements of sT.</p>\n<blockquote>\n<p>Even after only having made the statement \"typedecl sT\", HOL will prove<br>\nthat \"=\" for type \"sT\" is reflexive, symmetric, and transitive.<br>\nNo, it is not HOL that proves these three properties, = on any type is <br>\nby axiom in HOL.thy reflexive, transitive and symmetric. As you use <br>\naxiomatization, it is your job to make sure that your specification is <br>\nconsistent with HOL's axioms.</p>\n</blockquote>\n<p>Regards,<br>\nAndreas</p>",
        "id": 294229667,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901805
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 1/21/2013 8:55 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>The error remains because<br>\n1. you did not declare the axiom Ax_x as a code equation, and<br>\n2. it is not executable as the !x-quantifier ranges over sT for which <br>\nyou have not provided an implementation.</p>\n<p>The code generator will not work unless you provide a concrete <br>\nrepresentation for the elements of sT.</p>\n</blockquote>\n<p>Andreas,</p>\n<p>\"Satisfying the code generator\" falls under what I had talked about <br>\nneeding, which is \"knowing more\". The learning curve for \"more\" in <br>\nregards to the foundations of Isabelle is \"huge\", so I put that off for <br>\nnow. I consider what I'm trying to do as something that should be done <br>\nby experts, but which the experts haven't taken time to do.</p>\n<p>Still, the phrase \"code generator\" tells me what to search on to try and <br>\nfinish the problem, so thanks for the tip.</p>\n<blockquote>\n<blockquote>\n<p>Even after only having made the statement \"typedecl sT\", HOL will prove<br>\nthat \"=\" for type \"sT\" is reflexive, symmetric, and transitive.<br>\nNo, it is not HOL that proves these three properties, = on any type is <br>\nby axiom in HOL.thy reflexive, transitive and symmetric. As you use <br>\naxiomatization, it is your job to make sure that your specification is <br>\nconsistent with HOL's axioms.</p>\n</blockquote>\n</blockquote>\n<p>Being the argumentative type (GB::argumentative), I'm under the <br>\nimpression that I can restate any axiom or theorem and \"prove it again\", <br>\nthat with my reflexive, transitive, and symmetric proofs, I'm <br>\neffectively proving \"A --&gt; A\" for previous axioms or theorems \"A\" in <br>\nHOL.thy. (I'm actually stating the 3 theorems after attaching additional <br>\nproperties to \"=\" with my axiom).</p>\n<p>I had looked previously at the axioms for \"=\" here in HOL.thy:</p>\n<p>axiomatization where<br>\n   refl: \"t = (t::'a)\" and<br>\n   subst: \"s = t \\&lt;Longrightarrow&gt; P s \\&lt;Longrightarrow&gt; P t\" and<br>\n   ext: \"(!!x::'a. (f x ::'b) = g x) ==&gt; (%x. f x) = (%x. g x)\"<br>\n     -- {*Extensionality is built into the meta-logic, and this rule <br>\nexpresses<br>\n          a related property.  It is an eta-expanded version of the <br>\ntraditional<br>\n          rule, and similar to the ABS rule of HOL*} and</p>\n<p>the_eq_trivial: \"(THE x. x = a) = (a::'a)\"</p>\n<p>Number 1 is classic \"reflexive\", number 2 makes sense, but I quit at 3 <br>\nand 4 at trying to understand why this gives us all the typical <br>\nproperties of equality.</p>\n<p>In the past, I had wondered whether HOL \"=\" has any special properties <br>\nthat would result in inconsistencies once my axiom was attached to it <br>\nfor type sT. Makarius said, paraphrasing, \"HOL equal just has the <br>\ntypical properties of equal.\" I decided, \"Okay, then I'll consider that <br>\nuntil I attach additional properties to it for my type sT, that it's <br>\nsimply reflexive, symmetric, and transitive.\" Consequently, I do proofs <br>\nfor those 3 things regardless of what I read in HOL.thy or what you or <br>\nMakarius tell me.</p>\n<p>I looked now a little further at this \"equal is symmetric\" theorem in <br>\nHOL.thy:</p>\n<p>lemma sym: \"s = t ==&gt; t = s\"<br>\n   by (erule subst) (rule refl)</p>\n<p>Still, my three theorems aren't exact restatements of anything in HOL. <br>\n(I didn't actually look much past \"lemma sym\", so they could be.) If <br>\nthey are restatements, it doesn't hurt to prove them again after I add <br>\nmy own \"equality\" axiom.</p>\n<p>If you say, \"You're restating the obvious\", I would say, \"But in <br>\nIsabelle, with automatic proof methods, it's so easy to restate and <br>\nprove the obvious. So I do it to be explicit, and to show what I can't <br>\nknow or haven't taken time to know based on \"imports Complex_Main\".</p>\n<blockquote>\n<p>As you use axiomatization, it is your job to make sure that your <br>\nspecification is consistent with HOL's axioms.</p>\n</blockquote>\n<p>And that is a major concern of mine, and my fFOLdt and fFOLf idea was an <br>\nattempt to deal with unknowns that might cause my logic to be inconsistent.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294229673,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901811
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nGottfried,</p>\n<p>If you want to prove that your notion of equality of sT is really <br>\nreflexive, transitive and symmetric, then you might do the following:</p>\n<p>definition eq :: \"sT =&gt; sT =&gt; bool\" where<br>\n   \"eq p q = (!x. inS x q &lt;--&gt; inS x p)\"</p>\n<p>lemma \"eq x x\" &lt;proof&gt;<br>\nlemma \"eq x y = eq y x\" &lt;proof&gt;<br>\nlemma \"eq x y ==&gt; eq y z ==&gt; eq x z\" &lt;proof&gt;</p>\n<p>By using your own predicate eq instead of =, you avoid that the <br>\nautomated proof methods use any of HOL's predefined properties.</p>\n<p>Andreas</p>",
        "id": 294229679,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901817
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nAndreas,</p>\n<p>Alright, I get this last part for free. I haven't tried it out yet, but <br>\nthere's enough temporary good news with my sFOLf that I go ahead and <br>\nsend this email off, since I now need to experiment with both what <br>\nyou've just given me and with the sFOLf, which might take a few days.</p>\n<p>Before talking about sFOLf, in the past, I had tried to create my own <br>\nprimitive \"=\" like this,</p>\n<p>consts eqS :: \"sT = &gt; sT =&gt; bool\",</p>\n<p>and then use it in its undefined form in my axiom which defines set <br>\nequality.</p>\n<p>Well, I don't just state trivial theorems to prove them, I also state <br>\nthem to run Nitpick on them, so I ran Nitpick on this theorem,</p>\n<p>theorem \"!x. !y. (eqS x y) &lt;-&gt; (x = y)\",</p>\n<p>and Nitpick found a counterexample, though the theorem was also proved <br>\n\"by auto\" or something simple like that.</p>\n<p>The scary part is that all the theorems I had proved still worked using <br>\nmy primitive eqS.</p>\n<p>As to my sFOLf, I looked at Larry's ZF.thy, when I was searching for <br>\n\"code generator\", and I saw this:</p>\n<p>typedecl i<br>\narities  i :: \"term\"</p>\n<p>After some trial and error, and seeing \"arity\", \"equal\", and \"enum\" in <br>\nthe error messages, I put in some \"arities\" like this:</p>\n<p>typedecl sT<br>\narities  sT :: equal<br>\narities  sT :: enum</p>\n<p>That got rid of the errors in the simplified code I include below. As to <br>\nit being legitimate, I guess I'll find out, but what I have learned is <br>\nthis: \"arities, it's an Isar command that is used periodically\". That <br>\ncould be a very important lesson.</p>\n<p>Thanks for the \"eq\" to help me try and isolate my equal from the HOL equal.</p>\n<p>Regards,<br>\nGB</p>\n<p>theory sTs__sFOLdt_130121b<br>\nimports Complex_Main<br>\nbegin<br>\ntypedecl sT<br>\narities  sT :: equal<br>\narities  sT :: enum</p>\n<p>consts inS :: \"sT =&gt; sT =&gt; bool\"</p>\n<p>datatype sFOLdt =<br>\n   In sT sT<br>\n| Eq sT sT<br>\n| Forall sT sFOLdt</p>\n<p>type_synonym env = \"(sT =&gt; sT)\"</p>\n<p>definition sID :: \"sT =&gt; sT\" where<br>\n   \"sID s = s\"</p>\n<p>fun sFOLf :: \"env =&gt; sFOLdt =&gt; bool\" where<br>\n   \"sFOLf E (In x y) = inS x y\"<br>\n| \"sFOLf E (Eq x y) = (E x = E y)\"<br>\n| \"sFOLf E (Forall x f) = (!v. sFOLf (E(x := v)) f)\"</p>\n<p>value \"sFOLf sID (In x y)\"<br>\nvalue \"sFOLf sID (Eq x y)\"<br>\nvalue \"sFOLf sID (Forall x (Eq x x) )\"<br>\nend</p>",
        "id": 294229735,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901844
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gottfried,</p>\n<p>arities declares that a type belongs to the given type class, but leaves <br>\nthe parameters of the type class uninterpreted and the assumptions <br>\nunproven. Thus, it is like axiomatisation: you can use it to introduce <br>\ninconsistencies. Here's an example:</p>\n<p>class false = assumes FalseI: \"x = x ==&gt; False\"</p>\n<p>typedecl my_type<br>\narities my_type :: false</p>\n<p>lemma \"False\"<br>\napply(rule FalseI)<br>\napply(rule refl)<br>\ndone</p>\n<p>Without the arities command, I could not finish the proof of the lemma, <br>\nbecause Isabelle does not know whether the type class \"false\" can be <br>\ninstantiated at all. With the arities command, I declare that my_type <br>\nsatisfies the axiom FalseI for all x of type my_type.</p>\n<p>Hence, arities (like axiomatization) belongs to the group of commands <br>\nfor an axiomatic approach to formalisations. As most people nowadays <br>\nprefer a definitional approach, I would not call arities frequently used.</p>\n<p>Have said all this, it is obvious that the arities declarations make the <br>\nerror messages for the values command go away. But not for the code <br>\ngenerator, it will continue to complain about missing code equations for <br>\nthe type class parameters. The second evaluation strategy (normalisation <br>\nby evaluation) works.</p>\n<p>Andreas</p>",
        "id": 294229841,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901885
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 1/22/2013 1:19 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>arities declares that a type belongs to the given type class, but <br>\nleaves the parameters of the type class uninterpreted and the <br>\nassumptions unproven. Thus, it is like axiomatisation: you can use it <br>\nto introduce inconsistencies. Here's an example:</p>\n</blockquote>\n<p>Andreas,</p>\n<p>So what we can say is that Isar commands that are axiomatic are <br>\nexcellent commands for getting rid of error messages.</p>\n<p>It looks like I have three options:</p>\n<p>(1) Learn about arities and see if I can or can't assign my type sT to <br>\ntype class \"enum\".<br>\n(2) Learn about code generation and figure out how to make my type sT <br>\ncomputable.<br>\n(3) Never use \"datatype\" and \"fun\" in such a way that it requires me to <br>\nhave a concrete representation of type sT.</p>\n<p>It appears that option (3) is working for me, at least for the simple <br>\nstuff I'm doing now. I think (3) would require that I be able to do <br>\ninduction and recursion without \"datatype\". That I will be able do that, <br>\nI don't know. Ideally I would want to, if it's practical enough.</p>\n<p>It finally sunk in that \"value\" is computing values, as you said, and so <br>\nI need a concrete representation.</p>\n<p>Actually, that last sentence doesn't \"represent the situation\". Isabelle <br>\ncan magically deal with a whole lot of things that haven't been <br>\ncompletely defined. So, what I really know is that in this particular <br>\nsituation, with how I tried to use \"value\", it finally got to where it <br>\nneeded a more concrete representation.</p>\n<p>Trial and error, with some informative error messages, and a little help <br>\ninterpreting them, can help teach a person the abstract limits of Isabelle.</p>\n<p>I renamed sFOLdt and sFOLf to \"sD\" and \"sF\", completely implemented the <br>\n9 FOL formulas, and then proved a few basic theorems.</p>\n<p>It turns out that \"sD\" and \"sF\" is a heavy weight solution. Theorems <br>\nthat Sledgehammer can easily prove without this layer of heavy <br>\nrecursion, it can't do with it in.</p>\n<p>It also messes up the value of metis proofs. Most of the facts that <br>\nmetis is now using for proofs aren't informative at all. I have big <br>\nplans for metis proofs, even in detailed proofs. I provide a step, I <br>\napply Sledgehammer to it, it finds the theorems that justifies the step, <br>\nI don't have to, up front, memorize hundreds of theorem names, and the <br>\nfacts in the metis proof can teach a person something, that is, if <br>\nthey're not facts like \"sF.simps(9)\", like I'm getting now.</p>\n<p>However, this recursive restriction of the HOL functions that can be <br>\nused is possibly a \"fallback\" solution, or a \"parallel\" solution.</p>\n<p>What I did got extra, in trying to make type sT computable, is the <br>\nbeginnings of a recursive definition of what a set is (possibly a bogus <br>\ndefinition), which is basically an attempt to implement the idea that <br>\nevery set is built from the empty set.</p>\n<p>I was going to try and prove something about it, like, \"Okay, let's see <br>\nif I got lucky, and see if Sledgehammer can prove that my recursive <br>\nfunction sTf satisfies the properties of the ordered pair axiom\". But <br>\nthen, I haven't defined what membership means for it yet.</p>\n<p>But first running a combination of Sledgehammer and Nitpick on a theorem <br>\nis always a winner. Nitpick can sometimes tells me in a few seconds what <br>\na loser idea I've come up with.</p>\n<p>In regards to the \"eq\" function that you gave me. That's basically my <br>\n\"equality axiom\", which I suppose you know. It would make proving <br>\nreflexive, etc less messy, but I already know that the \"equality axiom\" <br>\nis reflexive, symmetric, and transitive, so that wasn't what got me <br>\nmotivated. What motivated me was the idea of using it in a trick to <br>\ndefine my own \"=\" and not use the HOL \"=\".</p>\n<p>However, there is a cardinal rule I now live by, based on nothing any <br>\nexpert has told me. But it is this:</p>\n<p>\"Never, ever, leave HOL equal undefined for a type, and then add axioms <br>\nfor that type.\"</p>\n<p>So, if I have to define HOL equal for my type sT, then I might as well <br>\nuse HOL equal as my only equal, with whatever luggage it already comes <br>\nwith, which I assume is nothing bad for my type sT, even with the <br>\nadditional axioms, or we'd all probably be in trouble.</p>\n<p>You say:</p>\n<blockquote>\n<p>The second evaluation strategy (normalisation by evaluation) works.</p>\n</blockquote>\n<p>I think you're saying here that the non-arities approach, that is, <br>\nmaking my type sT concrete and computable (to \"satisfy the code <br>\ngenerator\"), would work, if I could do it.</p>\n<p>Thanks for the \"arities\" example of inconsistency.</p>\n<p>The theory below shows my simple use of the recursive \"sD\" and \"sF\" in a <br>\nway described in item (3) above. I have two versions of the axioms and <br>\ntwo versions of a theorem. One version with outermost universal <br>\nquantifiers, and one version without them, to try and make it easier for <br>\nthe theorem to be proved. Knowing, because of a previous thread, that <br>\nthe meta-logic will take care of outermost quantification for me, is <br>\nvery valuable information.</p>\n<p>At the very bottom is my infant, experimentation of defining a recursive <br>\nset.</p>\n<p>Also, thanks to Alfio for some points on recursion and the need for the <br>\nenvironment.</p>\n<p>Regards,<br>\nGB</p>\n<p>theory sTs__sF_130122_01<br>\nimports Complex_Main<br>\nbegin</p>\n<p>typedecl sT</p>\n<p>consts inS :: \"sT =&gt; sT =&gt; bool\"</p>\n<p>datatype sD =<br>\n   In sT sT<br>\n| Eq sT sT<br>\n| Not sD<br>\n| And sD sD<br>\n| Or sD sD<br>\n| Imp sD sD<br>\n| Iff sD sD<br>\n| Forall sT sD<br>\n| Exists sT sD</p>\n<p>type_synonym env = \"(sT =&gt; sT)\"</p>\n<p>definition sID :: \"sT =&gt; sT\" where<br>\n   \"sID s = s\"</p>\n<p>primrec sF :: \"env =&gt; sD =&gt; bool\"<br>\nwhere<br>\n   \"sF E (In x y) = inS x y\"<br>\n| \"sF E (Eq x y) = (E x = E y)\"<br>\n| \"sF E (Not f) = (¬(sF E f))\"<br>\n| \"sF E (And f g) = (sF E f &amp; sF E g)\"<br>\n| \"sF E (Or f g) = (sF E f | sF E g)\"<br>\n| \"sF E (Imp f g) = (sF E f --&gt; sF E g)\"<br>\n| \"sF E (Iff f g) = (sF E f &lt;-&gt; sF E g)\"<br>\n| \"sF E (Forall x f) = (!v. sF (E(x := v)) f)\"<br>\n| \"sF E (Exists x f) = (? v. sF (E(x := v)) f)\"</p>\n<p>--\"THE AXIOM OF EXTENSION: SET EQUALITY.\"<br>\naxiomatization where<br>\nAx_x: \"sF sID<br>\n   (Forall p<br>\n     (Forall q<br>\n       (Iff (Eq p q) (Forall x (Iff (In x p) (In x q))))<br>\n     )<br>\n   )\" and<br>\nAx_x2: \"sF sID<br>\n   (Iff (Eq p q) (Forall x (Iff (In x p) (In x q))))\"</p>\n<p>theorem \"(sF sID (In x y)) &lt;-&gt; (inS x y)\"<br>\n   by(simp)</p>\n<p>theorem \"(sF sID (Eq x y)) &lt;-&gt; (x = y)\"<br>\n   by (metis sF.simps(2) sID_def)</p>\n<p>--\"THE AXIOM OF EXISTENCE: THE EMPTY SET EXISTS.\"<br>\nconsts emS :: \"sT\"</p>\n<p>axiomatization where<br>\n   Ax_e:  \"sF sID (Forall x (Not (In x emS)))\" and<br>\n   Ax_e2: \"sF sID (Not (In x emS))\"</p>\n<p>--\"NO X EXISTS IN THE EMPTY SET.\"<br>\ntheorem \"sF sID (Not (Exists x (In x emS)) )\"<br>\n   by (metis Ax_e sF.simps(3) sF.simps(8) sF.simps(9))</p>\n<p>--\"THE EMPTY SET IS UNIQUE.\"<br>\ntheorem \"sF sID<br>\n(Forall q<br>\n   (Iff<br>\n     (Forall x (Not (In x q)))<br>\n     (Eq q emS)<br>\n   )<br>\n)\"<br>\noops</p>\n<p>theorem \"sF sID<br>\n   (Iff<br>\n     (Forall x (Not (In x q)))<br>\n     (Eq q emS)<br>\n   )\"<br>\n--\"Sledgehammer found a proof, but it takes longer to execute than I'm<br>\n    willing to wait.\"<br>\n--\"by (metis Ax_e2 Ax_x2 sF.simps(1) sF.simps(3) sF.simps(7) sF.simps(8))\"<br>\noops</p>\n<p>--\"THE RECURSIVE SET TYPE: Everything is built from emS.\"</p>\n<p>--\"The unordered pair set.\"<br>\nconsts upS :: \"sT =&gt; sT =&gt; sT\"</p>\n<p>--\"The separation set, 'all x in q such that P x'.\"<br>\nconsts seS :: \"sT =&gt; (sT =&gt; bool) =&gt; sT\"</p>\n<p>datatype sTd =<br>\n   emSd<br>\n| upSd sTd sTd<br>\n| seSd sTd \"sT =&gt; bool\"</p>\n<p>fun sTf :: \"sTd =&gt; sT\" where<br>\n   \"sTf emSd       = emS\"<br>\n| \"sTf (upSd p q) = upS (sTf p) (sTf q)\"<br>\n| \"sTf (seSd q P) = seS (sTf q) P\"</p>\n<p>value \"sTf emSd\"<br>\nvalue \"sTf ( upSd emSd emSd )\"<br>\nvalue \"sTf ( seSd q (%x. inS x emS) )\"<br>\nvalue \"sTf ( seSd emSd (%x. inS x emS) )\"<br>\nvalue \"sTf ( seSd emSd (%x. P) )\"</p>\n<p>end</p>",
        "id": 294229904,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901934
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I'm trying to set up this formula,</p>\n<p>!q. !P. ?u. (!x. x \\&lt;in&gt; u &lt;-&gt; (x \\&lt;in&gt; q &amp; P x)),</p>\n<p>so that P is only a FOL formula with a free variable x. I'm getting an <br>\nerror when I get to the part that uses quantification.</p>\n<p>Currently P is of type (sT =&gt; bool), but I want to restrict it according <br>\nto the following recursive definition:</p>\n<p>Let x and y be variables, and let f and g be formulas, then<br>\nx \\&lt;in&gt; y is a formula,<br>\nx = y is a formula,<br>\n~(f) is a formula,<br>\n(f &amp; g) is a formula,<br>\n(f | g) is a formula,<br>\n(f --&gt; g) is a formula,<br>\n(f &lt;-&gt; g) is formula,<br>\n(!x. f) is a formula,<br>\n(?x. f) is a formula, and<br>\nnothing else is a formula.</p>\n<p>Really, all I want to do is restrict the syntax that can be used, but P <br>\nhas to have a type, P has to be based on recursion, and I have to use <br>\npattern matching, so I guess I have to use \"datatype\".</p>\n<p>Here is what I have, where the last line causes an error, with the error <br>\nshown below.</p>\n<hr>\n<p>typedecl sT</p>\n<p>consts inS :: \"sT =&gt; sT =&gt; bool\" (infixl \"inS\" 55)</p>\n<p>datatype sFOLdt =<br>\nIn sT sT<br>\n|Eq sT sT<br>\n|Not bool<br>\n|And bool bool<br>\n|Or bool bool<br>\n|Imp bool bool<br>\n|Iff bool bool<br>\n|Forall sT bool</p>\n<p>function sFOLf :: \"sFOLdt =&gt; bool\" where<br>\n\"sFOLf (In u1 u2) = (u1 inS u2)\" |<br>\n\"sFOLf (Eq u1 u2) = (u1 = u2)\" |<br>\n\"sFOLf (Not f) = (~(f))\" |<br>\n\"sFOLf (And f1 f2) = (f1 &amp; f2)\" |<br>\n\"sFOLf (Or f1 f2) = (f1 | f2)\" |<br>\n\"sFOLf (Imp f1 f2) = (f1 --&gt; f2)\" |<br>\n\"sFOLf (Iff f1 f2) = (f1 &lt;-&gt; f2)\" |<br>\n\"sFOLf (Forall u f) = (!u. f)\"</p>\n<p>OUTPUT WINDOW ERROR:<br>\nAdditional type variable(s) in specification of \"sFOLf_graph\": 'a<br>\nSpecification depends on extra type variables: \"'a\"<br>\nThe error(s) above occurred in \"sTs.sFOLf_sumC_def\"<br>\nThe error(s) above occurred in definition \"sFOLf_sumC_def\":<br>\n\"(sFOLf_sumC ≡ (%(x::sFOLdt). (THE_default undefined (%(y::bool). <br>\n(sFOLf_graph TYPE('a) x y)))))\"</p>\n<hr>\n<p>I've attached a 33KB screen capture which shows the same thing. I <br>\nswitched the screen capture from JPG to PNG and it went from 244KB to <br>\n33KB, using <a href=\"http://lightscreen.sourceforge.net/\">http://lightscreen.sourceforge.net/</a></p>\n<p>Thanks,<br>\nGB<br>\n<a href=\"/user_uploads/14278/fggTZ31-tU3IWnHPU1jW_JXH/function-error.1.png\">function error.1.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/fggTZ31-tU3IWnHPU1jW_JXH/function-error.1.png\" title=\"function error.1.png\"><img src=\"/user_uploads/14278/fggTZ31-tU3IWnHPU1jW_JXH/function-error.1.png\"></a></div>",
        "id": 294232146,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903039
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nPlease change \"function\" to \"fun\".</p>\n<p>It still works out the same. Without the \"Forall\" lines in my \"datatype\" <br>\nand \"fun\", my sFOLf function terminates correctly with the message <br>\n\"Found termination order: \"{}\"\".</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294232162,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903045
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nPeople can ignore what I was talking about, unless someone wants to give <br>\nme a complete \"datatype\" and \"fun/primrec\" solution based on the <br>\ninformal, recursive definition I gave. Or a solution of another form <br>\nwould be okay.</p>\n<p>Trying to figure out how recursion works, I have this experimental code:</p>\n<p>typedecl sT<br>\nconsts inS :: \"sT =&gt; sT =&gt; bool\" (infixl \"inS\" 55)</p>\n<p>datatype sFOLdt =<br>\n   In     sT sT<br>\n  |And    bool bool<br>\n  |Rec    bool</p>\n<p>primrec sFOLf :: \"sFOLdt =&gt; bool\" where<br>\n   \"sFOLf (In u1 u2)   = (u1 inS u2)\"                           |<br>\n   \"sFOLf (And f1 f2)  = ((sFOLf (Rec f1)) &amp; (sFOLf (Rec f2)))\" |<br>\n   \"sFOLf (Rec f)      = True\"</p>\n<p>which gives the error: Extra variables on rhs: \"(sFOLf::(sFOLdt =&gt; bool))\"</p>\n<p>All that to say, trial and error has shown me I haven't understood <br>\ncertain basic things, but trial and error can be an excellent learning <br>\naid sometimes.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294232205,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903069
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nJohn,</p>\n<p>No, you're on the mark. Thanks for the tip. That gets rid of that <br>\nparticular error, but there are some major problems still. I'm not doing <br>\nany real recursion. Like for this statement,</p>\n<p>\"sFOLf (And f1 f2)  = (f1 &amp; f2)\",</p>\n<p>I would need to recurse on f1 and f2, but I'm not even close; that's all <br>\nmessed up. I get an error from trying</p>\n<p>value \"sFOLf (And True True)\"</p>\n<p>Alfio pointed out section 2.5.6 of the tutorial, page 19:</p>\n<p><a href=\"http://isabelle.in.tum.de/website-Isabelle2012/dist/Isabelle2012/doc/tutorial.pdf\">http://isabelle.in.tum.de/website-Isabelle2012/dist/Isabelle2012/doc/tutorial.pdf</a></p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294232284,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903088
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Gottfried,</p>\n<p>you need to embed your formulas deeply in HOL, i.e., you cannot use the <br>\nstandard HOL connectives &amp;, |, !, etc. for your syntax. So you must use <br>\nyour formula datatype also for the subexpressions of your connectives:</p>\n<p>datatype sFOLdt =<br>\n   In sT sT<br>\n| Eq sT sT<br>\n| Not sFOLdt<br>\n| And sFOLdt sFOLdt<br>\n| Or sFOLdt sFOLdt<br>\n| Imp sFOLdt sFOLdt<br>\n| Iff sFOLdt sFOLdt<br>\n| Forall sT sFOLdt</p>\n<p>I am not sure what sT is supposed to stand for. Is it the type for <br>\nvariable names or the type of values that variables can take. In the <br>\nformer case: what is the type of values? In the latter case: this would <br>\nbe a very unusual setup, to mix values of variables (like in Eq and In) <br>\nwith name binding (like in Forall); in that case, replace sT with some <br>\ntype of variable names, e.g., string.</p>\n<p>Your sFOLf function would then interpret such formulae in terms of HOL. <br>\nHowever, you need to deal with variables (sT) that occur freely in your <br>\nformula. They must be bound by some environment (I use val for the type <br>\nof values that variables can take).</p>\n<p>type_synonym env = (sT =&gt; val)</p>\n<p>Then, your sFOLf function should look like this:</p>\n<p>fun sFOLf :: \"env =&gt; sFOLdt =&gt; bool\"<br>\nwhere<br>\n   \"sFOLf E (In x y) = inS x y\"<br>\n| \"sFOLf E (Eq x y) = (E x = E y)<br>\n| \"sFOLf E (Not f) = \\&lt;not&gt; (sFOLf E f)\"<br>\n| \"sFOLf E (And f g) = (sFOLf E f &amp; sFOLf E g)\"<br>\n| \"sFOLf E (Forall x f) = (!v. sFOLf (E(x := v)) f)\"<br>\n| ,.. (* remaining cases *)</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294232292,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903094
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThis definition is not primitive recursive and hence rejected by primrec <br>\n(recursive calls my only make the arguments structurally smaller, so <br>\n\"sFOLf (Rec f1)\" is not valid on the rhs.</p>\n<p>-- Lars</p>",
        "id": 294232318,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903106
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nLars,</p>\n<p>That  was my experimental effort to force some termination; from that <br>\nand some other ideas, I figured out I was too far off to stumble on to <br>\nsomething that would make it all work.</p>\n<p>However, it's not obvious to me why \"sFOLf (Rec f1)\" is not smaller. No <br>\nmatter what \"f1\" is, it looks like I should get \"\"sFOLf (Rec f1) = True\" <br>\non the second call of sFOLf.</p>\n<p>On the other hand, \"((sFOLf (Rec f1)) &amp; (sFOLf (Rec f2)))\" starts out as <br>\n\"bool &amp; bool\", and it ends up as \"bool &amp; bool\", even with the recursive <br>\ncalls, so I guess that wouldn't be considered \"structurally smaller\". It <br>\nwould help if I had a more precise understanding of \"structurally <br>\nsmaller\", but I don't worry about that right now.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294232389,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903143
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nYou know that, but the primrec command doesn't. Quoting from Section<br>\n10.3 of the Isabelle/Isar reference manual<br>\n(<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2012/doc/isar-ref.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2012/doc/isar-ref.pdf</a>):</p>\n<p>Each equation needs to be of the form:<br>\n    f x1 ... xm (C y1 ... yk) z1 ... zn = rhs<br>\n  such that C is a datatype constructor, rhs contains only the free<br>\n  variables on the left-hand side (or from the context), and all<br>\n  recursive occurrences of f in rhs are of the form f ... yi ...<br>\n  for some i.</p>\n<p>Best regards,<br>\nTjark</p>",
        "id": 294232410,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903155
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 1/18/2013 1:28 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>you need to embed your formulas deeply in HOL, i.e., you cannot use <br>\nthe standard HOL connectives &amp;, |, !, etc. for your syntax. So you <br>\nmust use your formula datatype also for the subexpressions of your <br>\nconnectives:<br>\nHope this helps,<br>\nAndreas,</p>\n</blockquote>\n<p>It helped a lot. I wouldn't have gotten to this next step without a fix.</p>\n<p>I'll answer a few questions and then show you the failure I'm at now.</p>\n<blockquote>\n<p>I am not sure what sT is supposed to stand for. Is it the type for <br>\nvariable names or the type of values that variables can take. In the <br>\nformer case: what is the type of values?</p>\n</blockquote>\n<p>Type \"sT\" is a primitive type that represents a set. By \"can take\", I <br>\nguess you mean \"mapped to\" as shown by your \"env\" below.</p>\n<p>Semantically, I don't think a variable of type sT is mapped to another <br>\nvalue in the sense of a function.</p>\n<p>I have a function:</p>\n<p>consts seS :: \"sT =&gt; (sT =&gt; bool) =&gt; sT\"</p>\n<p>I then use a function of that type, (seS q P), in an axiom describing a <br>\nproperty for every (q::sT) and (P::(sT =&gt; bool)), where P is a property <br>\nthat holds for q. (Actually the (sT =&gt; bool) type function is what I'm <br>\ntrying to tighten up with this sFOLf function.)</p>\n<p>Variables of type sT are only used with the predicate \\&lt;in&gt;, such as <br>\n(x::sT \\&lt;in&gt; y::sT), or as a binder variable in \\&lt;exists&gt; or \\&lt;forall&gt;, <br>\nsuch as (!x. phi) or (? x. phi), where phi is a FOL formula built up <br>\nstarting with the atomic formulas (x \\&lt;in&gt; y) and (x = y).</p>\n<p>Variables of type sT are used in HOL functions, but that's only because <br>\nthat's how Isabelle makes me do it. The constant functions I define <br>\nrepresent sets, and axioms are used to state what is true about those <br>\nfunctions.</p>\n<p>I could get more detailed, but I now get wellsortedness errors when <br>\ntrying to use the function sFOLf in a \"value\" statement.</p>\n<p>The command</p>\n<p>value \"sFOLf1 sID (In x y)\"</p>\n<p>gives the error</p>\n<p>\"Wellsortedness error... Type sT not of sort equal. No type arity sT :: <br>\nequal\"</p>\n<p>A similar error with \"enum\" in place of \"equal\" is after the third <br>\n\"value\" command. The \"Eq\" and the \"Forall\" mess things up.</p>\n<p>I'm trying to keep this short, but I'm not all that clear on the <br>\n\"environment\" requirement. However, like I said, variables of type sT <br>\naren't really mapped anywhere.</p>\n<p>To use the \"value\" command, I just made my \"env\" function the identity <br>\nfunction.</p>\n<p>The code is below, and I attached it as a THY.</p>\n<p>Thanks for the help,<br>\nGB</p>\n<p>theory sts__sFOLdt<br>\nimports Complex_Main<br>\nbegin</p>\n<p>typedecl sT</p>\n<p>consts inS :: \"sT =&gt; sT =&gt; bool\"</p>\n<p>datatype sFOLdt =<br>\n   In sT sT<br>\n| Eq sT sT<br>\n| Forall sT sFOLdt</p>\n<p>type_synonym env = \"(sT =&gt; sT)\"</p>\n<p>definition sID :: \"sT =&gt; sT\" where<br>\n   \"sID s = s\"</p>\n<p>fun sFOLf :: \"env =&gt; sFOLdt =&gt; bool\" where<br>\n   \"sFOLf E (In x y) = inS x y\"</p>\n<p>value \"sFOLf sID (In x y)\"</p>\n<p>fun sFOLf1 :: \"env =&gt; sFOLdt =&gt; bool\" where<br>\n   \"sFOLf1 E (In x y) = inS x y\"<br>\n| \"sFOLf1 E (Eq x y) = (E x = E y)\"</p>\n<p>value \"sFOLf1 sID (In x y)\"</p>\n<p>fun sFOLf2 :: \"env =&gt; sFOLdt =&gt; bool\" where<br>\n   \"sFOLf2 E (In x y) = inS x y\"<br>\n| \"sFOLf2 E (Forall x f) = (!v. sFOLf2 (E(x := v)) f)\"</p>\n<p>value \"sFOLf2 sID (In x y)\"</p>\n<p>end<br>\n<a href=\"/user_uploads/14278/3OFFHEM4TzPXLfrwwEcwkyYr/sTs__sFOLdt.thy\">sTs__sFOLdt.thy</a></p>",
        "id": 294232420,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903162
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI was actually looking at that last night, but with all the dots and <br>\nwith other information overload, I didn't sort much of it out, so thanks <br>\nfor the clarification.</p>\n<p>I was mainly looking for examples to use as plug 'n play templates, <br>\nwhich can get me some progress sometimes.</p>\n<p>Thanks to John Wickerson also for a clarification on the same subject.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294232429,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903168
    }
]