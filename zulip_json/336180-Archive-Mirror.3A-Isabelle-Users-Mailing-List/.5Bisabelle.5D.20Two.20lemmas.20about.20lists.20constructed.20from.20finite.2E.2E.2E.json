[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 22 May 2013, Christoph LANGE wrote:</p>\n<blockquote>\n<p>I should have said that I'm using the Isabelle2013 release version.</p>\n</blockquote>\n<p>You shouldn't.  On isabelle-users you always refer implicitly to the <br>\nlatest release without saying that explicitly.  Only if you use an older <br>\n(official) release you should say that.</p>\n<p>In contrast, if you are testing Isabelle repository versions, you should <br>\ndiscuss your observations on the isabelle-dev mailing list (including the <br>\nall-important Mercurial changeset id), not on isabelle-users.</p>\n<blockquote>\n<p>Is it right that as soon as I switch to Isabelle2014 or to the <br>\ndevelopment version I will be able to remove this code?</p>\n</blockquote>\n<p>Isabelle release cycles vary between 6-10 months, but the year has <br>\ninvariably 12 months.  So the next one is likely to be Isabelle2013-1 <br>\nbefore the end of 2013, not Isabelle2014.</p>\n<p>When working profesionally and productively with Isabelle you normally use <br>\nthe latest official release.  Only if you have a special situation, and <br>\nsome extra time to follow the ongoing development process quickly, you may <br>\nconsider testing repository versions instead (see above).</p>\n<p>Note that repository snapshots between the releases become outdated more <br>\nquickly than the stable stepping stones.  It is particularly bad to \"get <br>\nstuck\" on some old snapshot while the official releases have moved on 1 or <br>\n2 steps already.</p>\n<p>Makarius</p>",
        "id": 294240539,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906800
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nDear Isabelle community,</p>\n<p>I am currently working with lists constructed from finite sets, and I'm<br>\nmissing the following two lemmas that would really help me to get my<br>\nwork done.  At the moment my Isabelle experience is not sufficient for<br>\nproving them myself, plus I think it would make sense if they were part<br>\nof the library (List.thy).</p>\n<p>lemma sorted_list_of_set_not_empty [simp] :<br>\n  assumes \"finite S\" and \"S ≠ {}\"<br>\n  shows \"sorted_list_of_set S ≠ []\"<br>\nsorry</p>\n<p>lemma sorted_list_of_set_distinct [simp] :<br>\n  shows \"distinct (sorted_list_of_set S)\"<br>\nsorry</p>\n<p>Would any of the developers feel up to proving them, or alternatively<br>\nteaching me how to do it?</p>\n<p>BTW, for my work I actually don't need these lists-from-sets to be<br>\n_sorted_.  However sorted_list_of_set is the only result that</p>\n<p>find_consts \"'a set ⇒ 'a list\"</p>\n<p>gives me.  Efficient computation is not yet that crucial for my work,<br>\nbut would it be possible to provide a list-from-set constructor that<br>\ndoes not guarantee sorting?  I mean something that simply rearranges the<br>\ninternal data structure of a finite set (which is not guaranteed to be<br>\nsorted either) into a list.</p>\n<p>Finally, lists-from-sets are probably not even what I need to get my<br>\nactual work done.  I.e. if you think that there is no good reason for me<br>\nusing them, I'm willing to abandon them.  Originally I'm working with<br>\nfinite sets, but I defined a custom Max-like operation on them, which<br>\nrecursively folds the comparison of two elements over the whole<br>\nset/list.  As I'm not yet capable of understanding the internals behind</p>\n<p>definition (in linorder) Max :: \"'a set ⇒ 'a\" where<br>\n  \"Max = fold1 max\"</p>\n<p>in Big_Operators.thy (which seem to depend on certain idempotence laws<br>\nthat max satisfies), but wanted to prove some properties of my Max-like<br>\noperation and got stuck in my initial attempt to use finite_ne_induct, I<br>\nresorted to converting my finite sets to lists and using<br>\nlist_nonempty_induct – which did the job, except for the two missing<br>\nlemmas mentioned above.</p>\n<p>Cheers, and thanks in advance for your help,</p>\n<p>Christoph</p>",
        "id": 294242286,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907490
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nOn Wed, May 22, 2013 at 10:16 AM, Christoph LANGE<br>\n&lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Isabelle community,</p>\n<p>I am currently working with lists constructed from finite sets, and I'm<br>\nmissing the following two lemmas that would really help me to get my<br>\nwork done.  At the moment my Isabelle experience is not sufficient for<br>\nproving them myself, plus I think it would make sense if they were part<br>\nof the library (List.thy).</p>\n<p>lemma sorted_list_of_set_not_empty [simp] :<br>\n  assumes \"finite S\" and \"S ≠ {}\"<br>\n  shows \"sorted_list_of_set S ≠ []\"<br>\nusing assms by (metis sorted_list_of_set set.simps(1))</p>\n</blockquote>\n<p>A different formulation might make a more useful simp rule:</p>\n<p>lemma sorted_list_of_set_empty_iff:<br>\n  assumes \"finite S\"<br>\n  shows \"sorted_list_of_set S = [] ⟷ S = {}\"</p>\n<blockquote>\n<p>lemma sorted_list_of_set_distinct [simp] :<br>\n  shows \"distinct (sorted_list_of_set S)\"<br>\napply (cases \"finite S\")<br>\napply (induct set: finite)<br>\napply (simp_all add: distinct_insort)<br>\ndone</p>\n</blockquote>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294242294,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907495
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 22.05.2013 19:16, Christoph LANGE wrote:</p>\n<blockquote>\n<p>I am currently working with lists constructed from finite sets, and I'm<br>\nmissing the following two lemmas that would really help me to get my<br>\nwork done.  At the moment my Isabelle experience is not sufficient for<br>\nproving them myself, plus I think it would make sense if they were part<br>\nof the library (List.thy).</p>\n</blockquote>\n<p>I first wondered why you had problems with these proofs; then I <br>\ndiscovered that Florians rework of Big_Operators in the development <br>\nversion added some crucial lemmas ;)</p>\n<blockquote>\n<p>lemma sorted_list_of_set_not_empty [simp] :<br>\n   assumes \"finite S\" and \"S ≠ {}\"<br>\n   shows \"sorted_list_of_set S ≠ []\"</p>\n</blockquote>\n<p>Sledeghammer is able to find a proof after unfolding <br>\nsorted_list_of_set_def. A nicer proof however is to prove the following <br>\nfirst:</p>\n<hr>\n<p>lemma sorted_list_of_set_remove':<br>\n   assumes \"finite A\" \"x ∈ A\"<br>\n   shows<br>\n     \"sorted_list_of_set A = insort x (sorted_list_of_set (A - {x}))\"<br>\nproof -<br>\n   from assms have \"insert x (A - {x}) = A\" by blast<br>\n   then have \"sorted_list_of_set A = sorted_list_of_set (insert x (A - <br>\n{x}))\"<br>\n     by simp<br>\n   also have \"... = insort x (sorted_list_of_set (A - {x}))\"<br>\n     using assms by simp<br>\n   finally show ?thesis .<br>\nqed</p>\n<hr>\n<p>then your proof goes through with</p>\n<p>using assms by (auto simp: sorted_list_of_set_remove')</p>\n<p>BTW, a nicer lemma would be:</p>\n<p>lemma sorted_list_of_set_eq_Nil_iff:<br>\n   assumes \"finite S\"<br>\n   shows \"sorted_list_of_set S = [] &lt;-&gt; S = []\"<br>\n   using assms by (auto simp: sorted_list_of_set_remove')</p>\n<blockquote>\n<p>lemma sorted_list_of_set_distinct [simp] :<br>\n   shows \"distinct (sorted_list_of_set S)\"<br>\nsorry</p>\n</blockquote>\n<p>This property does not hold in Isabelle 2013, as Finite_Set.fold is only <br>\ndefined for finite sets (i.e., we cannot prove anything about infinite <br>\nsets). So you need to district your lemma to finite sets. Then the proof <br>\nis easy:</p>\n<p>lemma sorted_list_of_set_distinct [simp] :<br>\n   assumes \"finite S\" shows \"distinct (sorted_list_of_set S)\"<br>\n   using assms sorted_list_of_set by auto</p>\n<p>(In the next version of Isabelle, Finite_Set.fold will probably return <br>\nthe initial argument for infinite sets).</p>\n<blockquote>\n<p>Finally, lists-from-sets are probably not even what I need to get my<br>\nactual work done.  I.e. if you think that there is no good reason for me<br>\nusing them, I'm willing to abandon them.  Originally I'm working with<br>\nfinite sets, but I defined a custom Max-like operation on them, which<br>\nrecursively folds the comparison of two elements over the whole<br>\nset/list.  As I'm not yet capable of understanding the internals behind</p>\n<p>definition (in linorder) Max :: \"'a set ⇒ 'a\" where<br>\n   \"Max = fold1 max\"</p>\n<p>in Big_Operators.thy (which seem to depend on certain idempotence laws<br>\nthat max satisfies), but wanted to prove some properties of my Max-like<br>\noperation and got stuck in my initial attempt to use finite_ne_induct, I<br>\nresorted to converting my finite sets to lists and using<br>\nlist_nonempty_induct – which did the job, except for the two missing<br>\nlemmas mentioned above.</p>\n</blockquote>\n<p>As sets have no order, fold is only well-defined if the operation you <br>\ndefine is commutative.</p>\n<p>-- Lars</p>",
        "id": 294242312,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907506
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOnly in the development version.</p>",
        "id": 294242323,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907511
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nHi Lars, hi Brian,</p>\n<p>thanks for your quick help; let me answer all remaining points at once.</p>\n<p>2013-05-22 19:30 Lars Noschinski:</p>\n<blockquote>\n<p>I first wondered why you had problems with these proofs; then I<br>\ndiscovered that Florians rework of Big_Operators in the development<br>\nversion added some crucial lemmas ;)</p>\n</blockquote>\n<p>Oh, I see.  Sorry, I should have said that I'm using the Isabelle2013<br>\nrelease version.</p>\n<blockquote>\n<blockquote>\n<p>lemma sorted_list_of_set_not_empty [simp] :<br>\n   assumes \"finite S\" and \"S ≠ {}\"<br>\n   shows \"sorted_list_of_set S ≠ []\"</p>\n</blockquote>\n<p>Sledeghammer is able to find a proof after unfolding<br>\nsorted_list_of_set_def.</p>\n</blockquote>\n<p>That's indeed a good lesson for me as a, still, relative newbie.  So far<br>\nI had been doing this \"unfolding some_def sledgehammer\" step with<br>\ndefinitions of my own, whereas I had never thought of doing it with<br>\ndefinitions from the library.</p>\n<blockquote>\n<p>A nicer proof however is …<br>\nthen your proof goes through with …<br>\nBTW, a nicer lemma would be:</p>\n<p>lemma sorted_list_of_set_eq_Nil_iff:<br>\n  assumes \"finite S\"<br>\n  shows \"sorted_list_of_set S = [] &lt;-&gt; S = []\"<br>\n  using assms by (auto simp: sorted_list_of_set_remove')</p>\n</blockquote>\n<p>Thanks (to Brian, too)!</p>\n<p>For now I copied these into my formalisation.  Is it right that as soon<br>\nas I switch to Isabelle2014 or to the development version I will be able<br>\nto remove this code?</p>\n<blockquote>\n<blockquote>\n<p>lemma sorted_list_of_set_distinct [simp] :<br>\n   shows \"distinct (sorted_list_of_set S)\"<br>\nsorry</p>\n</blockquote>\n<p>This property does not hold in Isabelle 2013, as Finite_Set.fold is only<br>\ndefined for finite sets (i.e., we cannot prove anything about infinite<br>\nsets). So you need to district your lemma to finite sets. Then the proof<br>\nis easy:</p>\n<p>lemma sorted_list_of_set_distinct [simp] :<br>\n  assumes \"finite S\" shows \"distinct (sorted_list_of_set S)\"<br>\n  using assms sorted_list_of_set by auto</p>\n<p>(In the next version of Isabelle, Finite_Set.fold will probably return<br>\nthe initial argument for infinite sets).</p>\n</blockquote>\n<p>Thanks, and thanks for pointing out that I had forgotten to assume<br>\n\"finite S\".</p>\n<blockquote>\n<blockquote>\n<p>Finally, lists-from-sets are probably not even what I need to get my<br>\nactual work done.  I.e. if you think that there is no good reason for me<br>\nusing them, I'm willing to abandon them.  Originally I'm working with<br>\nfinite sets, but I defined a custom Max-like operation on them, which<br>\nrecursively folds the comparison of two elements over the whole<br>\nset/list.  As I'm not yet capable of understanding the internals behind</p>\n<p>definition (in linorder) Max :: \"'a set ⇒ 'a\" where<br>\n   \"Max = fold1 max\"</p>\n<p>in Big_Operators.thy (which seem to depend on certain idempotence laws<br>\nthat max satisfies), but wanted to prove some properties of my Max-like<br>\noperation and got stuck in my initial attempt to use finite_ne_induct, I<br>\nresorted to converting my finite sets to lists and using<br>\nlist_nonempty_induct – which did the job, except for the two missing<br>\nlemmas mentioned above.</p>\n</blockquote>\n<p>As sets have no order, fold is only well-defined if the operation you<br>\ndefine is commutative.</p>\n</blockquote>\n<p>Indeed.  Still I have no idea whether it will be _easy_ to use<br>\nfinite_ne_induct in my case.  Folding is actually not applicable to my<br>\nMax-like function, which is actually rather a variant of \"arg max\" in<br>\nthat it returns the index of the maximum component of a vector, where<br>\nthe index is an element of those finite \"nat set\"s that I'm using. –<br>\nAnyway, just some thoughts.  Your solutions work fine for me, and allow<br>\nme to focus on my actual problem (proving that a certain auction<br>\nformalisation determines a unique winner – soon to become public at<br>\n<a href=\"http://www.cs.bham.ac.uk/research/projects/formare/code/auction-theory/\">http://www.cs.bham.ac.uk/research/projects/formare/code/auction-theory/</a>).</p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294242331,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907517
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nMost of the time, converting from sets to lists is a cloogy workaround because<br>\nof problems defining some function directly on fnite sets. I recommend to<br>\nunderstand and use the appropriate fold combinator on lists instead.</p>\n<p>tobias</p>",
        "id": 294242404,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907530
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\n2013-05-22 22:43 Tobias Nipkow:</p>\n<blockquote>\n<p>Most of the time, converting from sets to lists is a cloogy workaround because<br>\nof problems defining some function directly on fnite sets.</p>\n</blockquote>\n<p>Good point – that's what I tried first, but I couldn't figure out how to<br>\nmake it work.</p>\n<blockquote>\n<p>I recommend to<br>\nunderstand and use the appropriate fold combinator on lists instead.</p>\n</blockquote>\n<p>You mean \"on sets\", right?</p>\n<p>Here is what I tried unsuccessfully.  I posted in on stackoverflow, as<br>\nit's a proper question.</p>\n<p><a href=\"http://stackoverflow.com/questions/16702866/defining-an-arg-max-like-function-over-finite-sets-and-proving-some-of-its-pr\">http://stackoverflow.com/questions/16702866/defining-an-arg-max-like-function-over-finite-sets-and-proving-some-of-its-pr</a></p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294242431,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907539
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 23/05/2013 01:14, schrieb Christoph LANGE:</p>\n<blockquote>\n<p>2013-05-22 22:43 Tobias Nipkow:</p>\n<blockquote>\n<p>Most of the time, converting from sets to lists is a cloogy workaround because<br>\nof problems defining some function directly on fnite sets.</p>\n</blockquote>\n<p>Good point – that's what I tried first, but I couldn't figure out how to<br>\nmake it work.</p>\n<blockquote>\n<p>I recommend to<br>\nunderstand and use the appropriate fold combinator on lists instead.</p>\n</blockquote>\n<p>You mean \"on sets\", right?</p>\n</blockquote>\n<p>yes</p>\n<blockquote>\n<p>Here is what I tried unsuccessfully.  I posted in on stackoverflow, as<br>\nit's a proper question.</p>\n<p><a href=\"http://stackoverflow.com/questions/16702866/defining-an-arg-max-like-function-over-finite-sets-and-proving-some-of-its-pr\">http://stackoverflow.com/questions/16702866/defining-an-arg-max-like-function-over-finite-sets-and-proving-some-of-its-pr</a></p>\n</blockquote>\n<p>if you are not desparate for executability, here is a two stage approach: first<br>\nget all the indices where the function has its maximum (which you can get via<br>\nMax), then select some element from it via SOME. although SOME can be a bit<br>\ntricky to reason about, this is a fairly abstract approach. something like</p>\n<p>let M = {x. v x = Max(v ` finite domain of v)}<br>\nin SOME x. x : M &amp; some tie breaker</p>\n<p>where the tie breaker could be something like ALL y : M. t x y</p>\n<p>tobias</p>\n<blockquote>\n<p>Cheers,</p>\n<p>Christoph<br>\n</p>\n</blockquote>",
        "id": 294242446,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907545
    }
]