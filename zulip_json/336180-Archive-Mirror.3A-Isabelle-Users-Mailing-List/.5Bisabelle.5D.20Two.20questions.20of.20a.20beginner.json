[
    {
        "content": "<p>From: Not Sure &lt;<a href=\"mailto:kuerzn@googlemail.com\">kuerzn@googlemail.com</a>&gt;<br>\nHi!</p>\n<p>I have two (plus one) questions:</p>\n<ol>\n<li>\n<p>blast, auto, ... are all GREAT!<br>\nBut is there a way (in ProofGeneral) to see the proofs found by these<br>\ntools more detail?</p>\n</li>\n<li>\n<p>If I have a non-atomic premise like:</p>\n<p>[|  A ==&gt; B ; ... |] ==&gt; C</p>\n</li>\n</ol>\n<p>how can I \"use\" it as a rule?</p>\n<p>I am looking for somethink like:</p>\n<p>apply (rule premise1)</p>\n<ol start=\"3\">\n<li>Where could I have found answers to these questions?</li>\n</ol>\n<p>Thanks!</p>\n<p>Johannes</p>",
        "id": 294232323,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903112
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou can see some aspects of proofs using proof objects, but it's about as illuminating as reading the assembly language code produced by a compiler.</p>\n<p>The answer to your second question is to use a structured proof. Non-atomic premises are all but useless in the apply style. In a structured proof, you can use such a thing exactly like an inference rule.</p>\n<p>You will find plenty of Isabelle documentation here: <a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a></p>\n<p>Larry Paulson</p>",
        "id": 294232350,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903131
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi,</p>\n<p>On Fr, 2013-01-18 at 12:19 +0000, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>The answer to your second question is to use a structured proof. Non-atomic premises are all but useless in the apply style. In a structured proof, you can use such a thing exactly like an inference rule.<br>\n</p>\n</blockquote>\n<p>Not an answer for a beginner: I'm frequently using the following code,<br>\nthat gives you a method rprems, that does exactly the requested thing<br>\n(see examples below the code).</p>\n<p>We already discussed several times whether we should integrate this<br>\nmethod into Isabelle (see separate post on devel-list)</p>\n<p>.. Peter</p>\n<hr>\n<p>ML {*<br>\n      (* Resolve with premises. Copied and adjusted from<br>\nGoal.assume_rule_tac. *)<br>\n    fun rprems_tac ctxt = Goal.norm_hhf_tac THEN' CSUBGOAL (fn (goal, i)<br>\n=&gt;<br>\n      let<br>\n        fun non_atomic (Const (\"==&gt;\", _) $ _ $ _) = true<br>\n          | non_atomic (Const (\"all\", _) $ _) = true<br>\n          | non_atomic _ = false;</p>\n<p>val ((_, goal'), ctxt') = Variable.focus_cterm goal ctxt;<br>\n        val goal'' = Drule.cterm_rule <br>\n          (singleton (Variable.export ctxt' ctxt)) goal';<br>\n        val Rs = filter (non_atomic o Thm.term_of) <br>\n          (Drule.strip_imp_prems goal'');</p>\n<p>val ethms = Rs |&gt; map (fn R =&gt;<br>\n          (Raw_Simplifier.norm_hhf (Thm.trivial R)));<br>\n      in eresolve_tac ethms i end<br>\n      );</p>\n<p>(* Resolve with premise. Copied and adjusted from<br>\nGoal.assume_rule_tac. *)<br>\n    fun rprem_tac n ctxt = Goal.norm_hhf_tac THEN' CSUBGOAL (fn (goal,<br>\ni) =&gt;<br>\n      let<br>\n        val ((_, goal'), ctxt') = Variable.focus_cterm goal ctxt;<br>\n        val goal'' = Drule.cterm_rule <br>\n          (singleton (Variable.export ctxt' ctxt)) goal';</p>\n<p>val R = nth (Drule.strip_imp_prems goal'') (n - 1)<br>\n        val rl = Raw_Simplifier.norm_hhf (Thm.trivial R)<br>\n      in<br>\n        etac rl i<br>\n      end<br>\n      );</p>\n<p>val setup =<br>\n      Method.setup @{binding rprems} <br>\n        (Scan.lift (Scan.option Parse.nat) &gt;&gt; (fn i =&gt; fn ctxt =&gt; <br>\n          SIMPLE_METHOD' (<br>\n            case i of<br>\n              NONE =&gt; rprems_tac ctxt<br>\n            | SOME i =&gt; rprem_tac i ctxt<br>\n          ))<br>\n        ) <br>\n        \"Resolve with premises\"</p>\n<p>*}</p>\n<p>setup \"setup\"</p>\n<p>(* EXAMPLES: *)</p>\n<p>lemma \"\\&lt;lbrakk&gt; A\\&lt;Longrightarrow&gt;B; B\\&lt;Longrightarrow&gt;C; A \\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; C\"<br>\n  apply (rprems 2) -- \"Explicitely specify number of premise\"<br>\n  apply (rprems 1)<br>\n  .</p>\n<p>lemma \"\\&lt;lbrakk&gt; A\\&lt;Longrightarrow&gt;B; B\\&lt;Longrightarrow&gt;C; A \\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; C\"<br>\n  apply (rprems) -- \"Resolve with any matching premise, <br>\n    first to last, backtracking\"<br>\n  apply (rprems)<br>\n  .</p>\n<hr>\n<blockquote>\n<p>You will find plenty of Isabelle documentation here: <a href=\"http://isabelle.in.tum.de/documentation.html\">http://isabelle.in.tum.de/documentation.html</a></p>\n<p>Larry Paulson</p>\n<p>On 18 Jan 2013, at 02:05, Not Sure &lt;<a href=\"mailto:kuerzn@googlemail.com\">kuerzn@googlemail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi!</p>\n<p>I have two (plus one) questions:</p>\n<ol>\n<li>\n<p>blast, auto, ... are all GREAT!<br>\nBut is there a way (in ProofGeneral) to see the proofs found by these<br>\ntools more detail?</p>\n</li>\n<li>\n<p>If I have a non-atomic premise like:</p>\n<p>[|  A ==&gt; B ; ... |] ==&gt; C</p>\n</li>\n</ol>\n<p>how can I \"use\" it as a rule?</p>\n<p>I am looking for somethink like:</p>\n<p>apply (rule premise1)</p>\n<ol start=\"3\">\n<li>Where could I have found answers to these questions?</li>\n</ol>\n<p>Thanks!</p>\n<p>Johannes</p>\n</blockquote>\n</blockquote>",
        "id": 294232373,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903137
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is what Larry means, when spelled out in Isar:</p>\n<p>notepad<br>\nbegin</p>\n<p>assume r:  \"A ==&gt; C\"<br>\n   have C<br>\n   proof (rule r)<br>\n     show A sorry<br>\n   qed</p>\n<p>end</p>\n<p>The notepad gives you a structured proof body without an outermost goal <br>\nstatement getting in the way, so it is usefule for experimentation and <br>\nunderstanding things.  If you intent to produce a result eventually, you <br>\ncan write it like this:</p>\n<p>lemma<br>\n   assumes r:  \"A ==&gt; C\"<br>\n   shows C<br>\nproof (rule r)<br>\n   show A sorry<br>\nqed</p>\n<p>If you follow Isar proof structuring the usual way, you should rarely run <br>\ninto a situation where you get a goal state with the intended rule being <br>\npushed in a goal state too early, and thus prevent its easy manipulation.</p>\n<p>(There are ways to do it nonetheless, notably the SUBPROOF and <br>\nSubgoal.FOCUS combinators in Isabelle/ML.  That is a completely different <br>\nstory, and not really on-topic for this thread.)</p>\n<p>Makarius</p>",
        "id": 294232569,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903210
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThese numbers within proofs scripts are not nice.  Many years ago, some <br>\npeople thinking about structured proofs devised ways to name subgoals and <br>\nsubgoals premises, instead of numbering them.  But I did not find this <br>\nvery convincing either.  It was one of the early achievements of Isar to <br>\nmanage without that -- and thus continuing the way Larry introduced <br>\nelim/dest resolution without physical addressing.</p>\n<p>So where are the applications?  This thread was started as beginner <br>\nquestions, to warm up how things are usually done.</p>\n<p>Makarius</p>",
        "id": 294232584,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903216
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nSide note: You should definitely try Isabelle/jEdit instead of Proof <br>\nGeneral.</p>\n<p>I've myself been substantially involved in making Isabelle Proof General <br>\nwork 13 years ago, but I don't see any reason left to use it today (only <br>\nhabits of Emacs users that have to be unlearned.)</p>\n<p>Makarius</p>",
        "id": 294232595,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903222
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAFAIK, jedit does not</p>\n<ul>\n<li>show you if the lemma you have just stated is already proved in the context</li>\n<li>show you a counterexample (auto quickcheck) to a lemma you stated</li>\n<li>forces you to wait until sledgehammer has returned before you can scroll<br>\naround - otherwise s/h is interrupted and restarts.</li>\n</ul>\n<p>The first two are particularly relevant for beginners.</p>\n<p>Tobias</p>",
        "id": 294232608,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903229
    }
]