[
    {
        "content": "<p>From: Christoph Feller &lt;<a href=\"mailto:c_feller@informatik.uni-kl.de\">c_feller@informatik.uni-kl.de</a>&gt;<br>\nHallo,</p>\n<p>a colleague and I came to the conclusion that it would be nice to have<br>\ninjectivity theorems for datatype constructors (example below).  These<br>\nare really easily proven - but I think they could help sledgehammer or<br>\ntactics like auto/blast.</p>\n<p>Our example:</p>\n<p>datatype ident = Ident string</p>\n<p>theorem infinite_idents:<br>\n \"\\&lt;not&gt; finite (UNIV :: ident set)\"<br>\napply clarify<br>\napply (drule_tac h=\"inv Ident\" in finite_imageI)<br>\nsledgehammer</p>\n<p>This gives me a \"metis line\" that doesn't work (I only use E and<br>\nSPASS). But if I insert</p>\n<p>lemma Ident_inj:<br>\n\"inj Ident\"<br>\nby (simp add:inj_on_def)</p>\n<p>before our theorem both E and SPASS can find a working solution really<br>\nquickly. So I think it would help to add theorems like \"inj<br>\n&lt;Constructor&gt;\" to the theorems generated for datatypes. I know about<br>\n&lt;type&gt;.inject which basically contains \"inj &lt;Constructor&gt;\" but<br>\nautomatic methods apparently don't find that connection.</p>\n<p>Additionally I think that a lemma \"inj f ==&gt; inj_on f A\" would be nice to have.</p>\n<p>Regards,<br>\nChristoph Feller</p>",
        "id": 294141940,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846134
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Christoph,</p>\n<blockquote>\n<p>a colleague and I came to the conclusion that it would be nice to have<br>\ninjectivity theorems for datatype constructors (example below).  These<br>\nare really easily proven - but I think they could help sledgehammer or<br>\ntactics like auto/blast.</p>\n</blockquote>\n<p>Adding more automatically generated stuff is not for free in terms of <br>\nperformance and scalability. So one would want some good empirical <br>\nevidence before doing something like that by default.</p>\n<blockquote>\n<p>Our example:</p>\n<p>datatype ident = Ident string</p>\n<p>theorem infinite_idents:<br>\n  \"\\&lt;not&gt;  finite (UNIV :: ident set)\"<br>\napply clarify<br>\napply (drule_tac h=\"inv Ident\" in finite_imageI)<br>\nsledgehammer</p>\n<p>This gives me a \"metis line\" that doesn't work (I only use E and<br>\nSPASS).</p>\n</blockquote>\n<p>Sledgehammer has seen quite a bit of improvement recently. The current <br>\ndevelopment version gives me a metis call that completes in 94ms.</p>\n<blockquote>\n<p>But if I insert</p>\n<p>lemma Ident_inj:<br>\n\"inj Ident\"<br>\nby (simp add:inj_on_def)</p>\n<p>before our theorem both E and SPASS can find a working solution really<br>\nquickly.</p>\n</blockquote>\n<p>In the development version I get the same metis call as above, so <br>\nnothing gained.</p>\n<blockquote>\n<p>So I think it would help to add theorems like \"inj<br>\n&lt;Constructor&gt;\" to the theorems generated for datatypes. I know about<br>\n&lt;type&gt;.inject which basically contains \"inj&lt;Constructor&gt;\" but<br>\nautomatic methods apparently don't find that connection.</p>\n</blockquote>\n<p>It is very hard to make such statements in general. Also, (in)finiteness <br>\nproofs are a bit special. They are often trivial for humans but <br>\nautomation is particularly weak there. Probably</p>\n<blockquote>\n<p>Additionally I think that a lemma \"inj f ==&gt;  inj_on f A\" would be nice to have.</p>\n</blockquote>\n<p>Well, this is just subset_inj_on[OF _ subset_UNIV]. A reason for having <br>\nit explicitly could be that people might search for it. Unfortunately, <br>\neven when it is present, a search for \"inv inv_on\" doesn't show it, <br>\nsince inv is just an abbreviation... Too bad.</p>\n<p>Alex</p>",
        "id": 294141949,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846138
    }
]