[
    {
        "content": "<p>From: Burkhart Wolff &lt;<a href=\"mailto:wolff@lri.fr\">wolff@lri.fr</a>&gt;<br>\nDear all,</p>\n<p>what is the recommended way in Isabelle17/18 to instantiate a polymorphic term,</p>\n<p>so, e.g.  Const (\"Option.option.None\", \"'a option”)     ( or alternatively:   Const (\"Option.option.None\", “?'a option”) )</p>\n<p>to</p>\n<p>Const (\"Option.option.None\", “int option”)</p>\n<p>???</p>\n<p>infer_type apparently does not do the trick.</p>\n<p>Many thanks for some advice.</p>\n<p>bu</p>",
        "id": 294740609,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191391
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nHi Burkhart,</p>\n<p>As Makarius would say, it all depends on your application. In general, a substitution is what would be called for. But if you built your term yourself, maybe you can use Sign.mk_const and pass the correct type arguments right away, e.g.</p>\n<p>Sign.mk_const thy (@{const_name None}, @{typ int})</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294740642,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191402
    },
    {
        "content": "<p>From: Burkhart Wolff &lt;<a href=\"mailto:wolff@lri.fr\">wolff@lri.fr</a>&gt;<br>\nThanks Jasmin.</p>\n<p>Meanwhile, I found out myself.</p>\n<p>Since it might be of wider interest for Isabelle users <br>\n(and since it is not totally obvious) I present the solution:</p>\n<p>First step: Type generalisation.<br>\nSince type unification and type matching work on schematic type<br>\nvariables, one has to generalise the free type variables.</p>\n<p>There are  more general and complex functions for this in structure<br>\nTerm_Subst, but for the purpose here the following suffices:</p>\n<p>ML‹<br>\nval generalize_typ = Term.map_type_tfree (fn (str,sort)=&gt; Term.TVar((str,0),sort));<br>\nval generalize_term = Term.map_types generalize_typ;<br>\n›</p>\n<p>(the index 0 is, as I said, sufficient for this special solution)</p>\n<p>Example: <br>\nML‹val t = generalize_term @{term \"[]”}›<br>\nyields now the system  output: “val t = Const (\"List.list.Nil\", \"?'a list\"): term”<br>\nindicating that the free type variable has been replaced by a schematic type variable.<br>\nIn slow motion: \"?'a list” is a system pretty printing for:</p>\n<p>ML‹ val t_schematic = Type(\"List.list\",[TVar((\"'a\",0),@{sort \"HOL.type\"})]); ›</p>\n<p>Note that type antiquotations do not permit to denotate types with schematic type variables directly,<br>\nfollowing an Isabelle development trend to hide schematic variables from the Isar interface.</p>\n<p>Second Step: Type Matching (or unification, but watch out for the indexes)<br>\nThe trick is most easily done by a high-level interface in structure Sign that covers more low-level<br>\noperations on the Term level.<br>\nMatching and unifications produce a type environment @{ML_type \"Type.tyenv”} which is basically <br>\na type synonym to Vartabs which is basically a synonym to Symtabs … So:</p>\n<p>ML‹<br>\nval tyenv = Sign.typ_match @{theory} (t_schematic, @{typ \"int list\"}) (Vartab.empty);            <br>\nval  [((\"'a\", 0), ([\"HOL.type\"], @{typ \"int\"}))] = Vartab.dest tyenv;<br>\n›</p>\n<p>Third step: Type instantiation.<br>\nApparently, a bizarre conversion between the old-style interface and <br>\nthe new-style @{ML \"tyenv\"} is necessary. See the following example.</p>\n<p>ML‹<br>\nval S = Vartab.dest tyenv;<br>\nval S' = (map (fn (s,(t,u)) =&gt; ((s,t),u)) S) : ((indexname * sort) * typ) list;<br>\n         (* it took me quite some time to find out that these two type representations,<br>\n            obscured by a number of type-synonyms, where actually identical. *)<br>\nval ty = t_schematic;<br>\nval ty' = Term_Subst.instantiateT S' t_schematic;</p>\n<p>val t = (generalize_term @{term \"[]\"});<br>\nval t' = Term_Subst.map_types_same (Term_Subst.instantiateT S') (t)<br>\n(* or alternatively : *)<br>\nval t'' = Term.map_types (Term_Subst.instantiateT S') (t)<br>\n›<br>\nThe system output for the latter is:<br>\nval ty = \"?'a list\": typ<br>\nval ty' = \"int list\": typ<br>\nval t = Const (\"List.list.Nil\", \"?'a list\"): term<br>\nval t' = Const (\"List.list.Nil\", \"int list\"): term</p>\n<p>Voila.</p>\n<p>Once upon a time, there was this the idea of an \"Isabelle programmers cookbook”,<br>\nwhere this kind of information on this level of abstraction could be gathered. <br>\nWas this project abandoned ?</p>\n<p>bu</p>",
        "id": 294740708,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661191427
    }
]