[
    {
        "content": "<p>From: Gabriele Pozzani &lt;<a href=\"mailto:gabriele.pozzani@gmail.com\">gabriele.pozzani@gmail.com</a>&gt;<br>\nHello,<br>\nI have a formula involving the \"mod\" operator and so on nat type, but when I<br>\neliminate the \"mod\" operator using the rule Divides.mod_eqD or<br>\nDivides.mod_eq_0D I want use the int type.</p>\n<p>In particular I have:<br>\n(k - (j - Suc 0)) mod n  = (0::nat)<br>\n eliminate the mod operator obtaining:<br>\nEXISTS q. (k - (j - Suc 0)) = n * q<br>\n but in natural if q is 0 then (k - (j - Suc 0)) --&gt; k &lt;= (j - Suc<br>\n0)                  not k = (j - Suc 0).</p>\n<p>There is a way to change automatically the type of a formula from nat to int<br>\nso using the integer theorems?</p>\n<p>I seen the int::nat =&gt; int but I must introduce it manually and if I use it<br>\nthere are many unification errors with others formula.</p>\n<p>Thanks<br>\nGabriele Pozzani</p>",
        "id": 294043013,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816127
    },
    {
        "content": "<p>From: Amine Chaieb &lt;<a href=\"mailto:chaieb@informatik.tu-muenchen.de\">chaieb@informatik.tu-muenchen.de</a>&gt;<br>\nThis is part of the arith tactic preprocessing and is due to Grosser <br>\nMeister. You can first rewrite with The following rules</p>\n<p>nat_number_of_def <br>\nzdvd_int <br>\nint_int_eq[symmetric] <br>\nzle_int[symmetric] <br>\nzless_int[symmetric] <br>\nzadd_int[symmetric] <br>\nzmult_int[symmetric] <br>\nand the split rule  zdiff_int_split</p>\n<p>These turn \"conventional\" formulae over nat in to formulae where the \"int\" <br>\nis in front of all terms.<br>\nAfter this you can rewrite with the following theorems</p>\n<p>nat_0_le <br>\nall_nat <br>\nex_nat <br>\nnumber_of1 <br>\nnumber_of2 <br>\nint_0 <br>\nint_1 </p>\n<p>and cong rules : conj_le_cong imp_le_cong</p>\n<p>These \"eliminate\" the \"int\" in favour of \"int (nat ..)\" which can be <br>\neliminated easily. Note that the \"nat\" variables have to be quantified!!!</p>\n<p>Please include the appropriate rules to cover the predicates and functions <br>\nyou use in the same scheme.</p>\n<p>Amine.</p>",
        "id": 294043026,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816134
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:tjark.weber@gmx.de\">tjark.weber@gmx.de</a>&gt;<br>\nGabriele,</p>\n<p>On Tuesday 24 October 2006 12:13, Gabriele Pozzani wrote:</p>\n<blockquote>\n<p>I have a formula involving the \"mod\" operator and so on nat type, but when<br>\nI eliminate the \"mod\" operator using the rule Divides.mod_eqD or<br>\nDivides.mod_eq_0D I want use the int type.</p>\n<p>In particular I have:<br>\n(k - (j - Suc 0)) mod n  = (0::nat)<br>\n eliminate the mod operator obtaining:<br>\nEXISTS q. (k - (j - Suc 0)) = n * q<br>\n but in natural if q is 0 then (k - (j - Suc 0)) --&gt; k &lt;= (j - Suc<br>\n0)                  not k = (j - Suc 0).</p>\n</blockquote>\n<p>in fact anything that would allow you to deduce \"k = j - Suc 0\" from your <br>\npremise would be unsound, because \"k &lt;= j - Suc 0\" is a sufficient condition <br>\nfor \"(k - (j - Suc 0)) mod n  = (0::nat)\".</p>\n<p>If subtraction on type \"nat\" is not accurately modelling what you want to <br>\nformalize, then maybe using type \"int\" in your formulas in the first place <br>\nmight solve your problem.</p>\n<blockquote>\n<p>There is a way to change automatically the type of a formula from nat to<br>\nint so using the integer theorems?</p>\n</blockquote>\n<p>No, because a theorem that holds for type \"nat\" may not hold for type \"int\", <br>\nand vice versa.  (One particular example is \"m &lt;= n ==&gt; m - n = 0\".)</p>\n<p>Best,<br>\nTjark</p>",
        "id": 294043039,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816142
    }
]