[
    {
        "content": "<p>From: Holden Lee &lt;<a href=\"mailto:hl422@cam.ac.uk\">hl422@cam.ac.uk</a>&gt;<br>\nIn Isabelle, (A) what can be done using locales that can't be done using<br>\ntypeclasses, and (B) what can be done using locales that would be<br>\ninconvenient with typeclasses?</p>\n<p>I've read about both of them, but am still trying to find a clear-cut<br>\nanswer, and hoping some discussion will clarify things. Here are some of my<br>\nthoughts, which might or might not be correct, so comment and add your own<br>\nthoughts.</p>\n<p>I'm mostly interested in constructions from abstract algebra. Here are some<br>\nexamples to draw on: (a) ring homomorphism, (b) the product of 2 arbitrary<br>\nrings, (c) the polynomial algebra R[X_1,...,X_n] over R, (d) the finite<br>\nfields F_p, (e) the localization S^{-1}R (a ring constructed from R and a<br>\nmultiplicative subset S of R, or any subset, if you prefer), combinations<br>\nand reinterpretations of these (ex. the vector space F_p[X_1,...,X_n] over<br>\nF_p)</p>\n<p>1. In general, locales are more powerful, but lack the automatic<br>\n   type-checking that types give.</p>\n<p>2. Anything involving types that depend on 2+ types cannot be expressed<br>\n   using typeclasses (ex. (a)-(b), a product of 2 arbitrary rings cannot be<br>\n   interpreted as a type of class ring, \"arbitrary\" meaning I haven't chosen a<br>\n   specific instance). Anything depending on 1 type can be expressed using<br>\n   typeclasses, if the representation has to be done using typeclasses every<br>\n   step of the way. Are there more theoretical restrictions?</p>\n<p>3. You can't use a parameter to construct a type (ex. finite field F_p).<br>\n   (i) Using locales, this isn't a problem because you can certainly construct<br>\n   a ring_scheme, etc. from a parameter, using an ordinary function. (ii)<br>\n   Using typeclasses, you would have to \"bake in\" a parameter, for instance<br>\n   have a function card_Fp::'a=&gt;nat discarding the input of type 'a and just<br>\n   giving the cardinality of the field (actually here you can sidestep this<br>\n   and just return the CARD of 'a, but you can't do this in general, like<br>\n   recovering S in (e)).</p>\n<p>4. However, there is no automated way to construct instances of<br>\n   typeclasses (creating classes is allowed only at top-level, so there is no<br>\n   dependence on parameters) or talk about their existence. Using a typeclass<br>\n   representing finite fields, you can't say \"for every prime p, there exists<br>\n   a field F_p with p elements,\" you can only say \"given a finite field with p<br>\n   elements...\" This is mathematically a bit odd because you hypothesize<br>\n   everything you need about the type you want (ex. finite fields) as<br>\n   assumptions in the class (including everything necessary to recover the<br>\n   original input data), whereas in the locale case you can construct it<br>\n   first, and then prove that it satisfies the assumptions you want.</p>\n<p>5. A result proven with locales can always be converted to the<br>\n   equivalent result with typeclasses by interpretation. However, a result<br>\n   proved with typeclasses cannot be converted to locales, because<br>\n   instantiation of a typeclass is not allowed inside a proof.</p>\n<p>-Holden</p>",
        "id": 294290819,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923386
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Holden,</p>\n<p>In your situation of abstract algebra, locales are better than type classes, as you want <br>\nto talk about carriers, sub-structures, and existence of structures. However, some of your <br>\ncomments need some refinement.</p>\n<blockquote>\n<p>2. Anything involving types that depend on 2+ types cannot be expressed<br>\n    using typeclasses (ex. (a)-(b), a product of 2 arbitrary rings cannot be<br>\n    interpreted as a type of class ring, \"arbitrary\" meaning I haven't chosen a<br>\n    specific instance).<br>\nThis is not correct. You can define a type ('a, 'b) prod_ring (e.g., via typedef) and do <br>\nan instance declaration for ring:</p>\n</blockquote>\n<p>instantiation prod_ring (ring, ring) ring begin<br>\n(* definition of ring operations on product *)<br>\ninstance (* proof *)<br>\nend</p>\n<p>This declaration is valid for any two types with the ring structure without saying which <br>\nring they are.</p>\n<blockquote>\n<p>4. However, there is no automated way to construct instances of<br>\n    typeclasses (creating classes is allowed only at top-level, so there is no<br>\n    dependence on parameters) or talk about their existence. Using a typeclass<br>\n    representing finite fields, you can't say \"for every prime p, there exists<br>\n    a field F_p with p elements,\" you can only say \"given a finite field with p<br>\n    elements...\"<br>\nYou can phrase a statement like \"for every prime p, there exists a field F_p with p <br>\nelements\" on the type level as follows. Define prime :: \"nat =&gt; nat\" as the distinct <br>\nenumeration of all the primes, e.g., prime n is the n-th prime. Then, define a type 'a F_p <br>\nas a type that contains prime CARD('a) elements. Then, you can do</p>\n</blockquote>\n<p>instantiation F_p (finite) field begin</p>\n<p>Since Isabelle has types with exactly n elements for any natural number n &gt; 0, you get <br>\nwhat you want. But I admit that this is a bit cumbersome.</p>\n<p>For completeness, there are a few cases where type classes are superior to locales.</p>\n<ol>\n<li>\n<p>Code generation within locales with assumptions essentially does not work. You can only <br>\ngenerate code for interpretations for which you have to manually redefine the constants <br>\nintroduced in the locale. With type classes, the code generator takes care of overloaded <br>\noperations.</p>\n</li>\n<li>\n<p>Overloading of polymorphic operations. If an overloaded operation (like addition in a <br>\nring) occurs with multiple different instances, the locale approach requires you to use a <br>\ndifferent constant for each instance. In that case, you normally have to introduce a <br>\nlocale that combines multiple instances, too. Here's an example with type classes:</p>\n</li>\n</ol>\n<p>lemma fixes f :: \"'a :: ring =&gt; 'b :: ring =&gt; 'c :: ring\"<br>\n   assumes \"!!a b c d. f (a + b) (c + d) = f a c + f b d\"<br>\n   shows \"...\"</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294290842,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923392
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nI don't know all the details about how to overload notation, but it <br>\nappears that overloading notation through type classes is generally <br>\nsuperior to doing it other ways, and notation can be of huge importance.</p>\n<p>If you use type classes, you obtain other magic by default, in <br>\nparticular with the code generator, which at a minimum comes into play <br>\nwith the \"value\" command. It's very useful to always be able to do some <br>\nexperimental computations with \"value\", and very annoying when \"value\" <br>\nwon't work for my functions, even though my logic is good.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294290901,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923416
    }
]