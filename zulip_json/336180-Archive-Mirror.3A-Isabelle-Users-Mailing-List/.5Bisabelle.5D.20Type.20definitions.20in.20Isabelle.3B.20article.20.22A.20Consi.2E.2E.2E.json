[
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nDear Ken,</p>\n<blockquote>\n<blockquote>\n<p>My suspicion is that declarations separated from definitions generally might cause inconsistency.</p>\n</blockquote>\n</blockquote>\n<p>Actually, this is precisely what we prove in our paper: that, under the described checks, delayed ad hoc overloaded definitions of constants (performed via declarations followed by definitions of instances at later times) and type definitions are jointly consistent under HOL deduction.</p>\n<blockquote>\n<blockquote>\n<p>In order to experiment, I would need some hint how declarations of<br>\nconstants (accompanied with a latter definition) work in Isabelle 2016, as asked for at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00093.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00093.html</a><br>\nas I couldn't find any information in the manuals about it.</p>\n</blockquote>\n</blockquote>\n<p>In Isabelle 2016, you have to be more explicit about overloading -- see section 11.3 (ad hoc overloading for constants) in the reference manual:    <a href=\"http://isabelle.in.tum.de/doc/isar-ref.pdf\">http://isabelle.in.tum.de/doc/isar-ref.pdf</a></p>\n<p>Your noncircular example should be written as follows:</p>\n<p>consts c :: 'a</p>\n<p>typedef T = \"{True}\" by blast</p>\n<p>overloading<br>\n  c_bool    ? \"c :: bool\"<br>\nbegin<br>\ndefinition c_bool :: bool where<br>\n  \"c_bool = (if (EX (x::T). ALL y. x = y) then False else True)\"<br>\nend</p>\n<p>By contrast, Ondra's circular example fails in Isabelle 2016:</p>\n<p>consts cc :: 'a</p>\n<p>typedef (overloaded) TT = \"{True,cc}\" by blast</p>\n<p>overloading<br>\n  cc_bool    ? \"cc :: bool\"<br>\nbegin<br>\ndefinition cc_bool :: bool where<br>\n  \"cc_bool = (if (EX (x::TT). ALL y. x = y) then False else True)\"<br>\nend</p>\n<p>The theory is also attached.</p>\n<p>Andrei<br>\n<a href=\"/user_uploads/14278/a4atdoNJjn2-y5bTdYiu0POY/Defs.thy\">Defs.thy</a></p>",
        "id": 294679942,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176346
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nFrom a logical point of view, there is no reason to go below the HOL standard,<br>\naccording to which (in proof mode) \"only consistency-preserving actions<br>\n(namely valid proof) can be performed\" [Gordon/Melham, 1993, p. 258 f.].</p>\n<p>Andrei Popescu found a quite adequate formulation saying that the (consistent) logic exists<br>\nindependent of a particular implementation. Hence, if Isabelle/HOL is supposed to be a<br>\nmanifestation of a consistent logic, it must be consistent, too. \"Nonsensical\" user data<br>\nshould be allowed only in the form of hypotheses, which can be refuted by the logic (and,<br>\nhence, dealt with in a reasonable way), as shown previously for R0.</p>\n<p>If we would allow weakening logical rigor by enabling (user) definitions to make the<br>\nlogical system inconsistent, we could directly step back to Cantor's naive set theory,<br>\nand accuse Russell of being the malicious \"who has studied the source code\" of set theory,<br>\nclaiming that Russell's paradox makes use of an \"overtly nonsensical\" definition.<br>\nOf course it is nonsensical (in formal logic and mathematics), but therefore it<br>\nshouldn't be expressible at all in the language of mathematics. This insight resulted,<br>\nas is well known, in type theory.</p>\n<p>My suspicion is that declarations separated from definitions generally might cause<br>\ninconsistency. In order to experiment, I would need some hint how declarations of <br>\nconstants (accompanied with a latter definition) work in Isabelle 2016, as asked for at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00093.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00093.html</a><br>\nas I couldn't find any information in the manuals about it.</p>\n<hr>\n<p>Ken Kubota<br>\ndoi: 10.4444/100<br>\n<a href=\"http://dx.doi.org/10.4444/100\">http://dx.doi.org/10.4444/100</a></p>",
        "id": 294679956,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176352
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI just want to point out explicitly that I am no longer paying attention<br>\nto this very strange thread.</p>\n<p>At the level of abstraction of the discussion, Isabelle is indeed<br>\n\"inconsistent\" and that is not going to change in the foreseeable future.</p>\n<p>Makarius</p>",
        "id": 294679968,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176358
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nMakarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>I just want to point out explicitly that I am no longer paying attention<br>\nto this very strange thread.<br>\nAt the level of abstraction of the discussion, Isabelle is indeed<br>\n\"inconsistent\" and that is not going to change in the foreseeable future.</p>\n</blockquote>\n</blockquote>\n<p>This is indeed a very strange thread -- and your backwards conclusion contributes to its strangeness. At the level of abstraction discussed here, that is, speaking of the logical system implemented in Isabelle/HOL, we are now (in 2016) talking about a logic proved to be <em>consistent</em>, not inconsistent. This level of abstraction assumes that we ignore what you call the back doors, and only focus on the purely logical mechanisms: type and constant definitions and HOL deduction.</p>\n<p>Btw, even though they also deal with a very complex implementation, the Coq people do not have a problem speaking at this level of abstraction -- and in particular acknowledging any logic inconsistency violations arising from their definitional mechanism (as happened recently). Needless to say, they also don't have a problem reporting when these violations have been addressed. And they do use words like 'inconsistency' and 'fix'.</p>\n<p>You show contempt for people's efforts to address such issues using proper and well-established logical concepts and terminology. And since you are speaking with the (deserved) authority of Isabelle's release manager, this is a big strategic mistake for Isabelle.</p>\n<p>Andrei</p>\n<p>Makarius</p>",
        "id": 294679992,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176364
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nDear Isabelle Developers,</p>\n<p>Concerning the type definitions in Isabelle and the article by Ondřej Kunčar and Andrei Popescu, I have some questions.</p>\n<ol>\n<li>\n<p>Which restriction was introduced in Isabelle (2016) in order to avoid the inconsistency of earlier versions revealed by Kunčar/Popescu? See<br>\n<a href=\"http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf\">http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf</a> (p. 3)<br>\nThe definition of the constant c contains a free variable y.<br>\nConstant definitions in Gordon's original HOL do not allow free variables, but only \"a closed term\" [Gordon/Melham, 1993, p. 220; or<br>\n<a href=\"http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf\">http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf</a> (p. 33)].</p>\n</li>\n<li>\n<p>Are all types still constructed via the \"typedef\" mechanism?<br>\nThe following formulation allows two interpretations: a mechanism on top of \"typedef\",<br>\nor a new mechanism at the same (basic) level as and in addition to \"typedef\":<br>\n\"In the post–Isabelle 2012 development version, we have converted the numeric types int, rat, and real to use Lifting and Transfer. (Previously they were constructed as quotients with typedef, in the style of Paulson [6].)\"<br>\n<a href=\"http://www21.in.tum.de/~kuncar/documents/huffman-kuncar-itp2012.pdf\">http://www21.in.tum.de/~kuncar/documents/huffman-kuncar-itp2012.pdf</a> (p. 17)</p>\n</li>\n<li>\n<p>The main questions is, whether in Isabelle still all new types are (besides being tested for non-emptiness)<br>\nintroduced with an axiom stating a mapping, like in Gordon's original HOL,<br>\nwhere for each new type an axiom is asserted saying that the new type is isomorphic to the defined (sub)set, cf.<br>\n<a href=\"http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf\">http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf</a> (p. 39).</p>\n</li>\n</ol>\n<p>Let me remark that the section \"8.5.2 Defining New Types\" in<br>\n<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/tutorial.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/tutorial.pdf</a> (pp. 173 ff.)<br>\nexplaining \"typedef\" is quite hidden.<br>\nIt would be desirable to have it in a separate logic manual like in the HOL4 logic part linked above.</p>\n<ol start=\"4\">\n<li>Why should \"dependent types\" be \"to a large extent incompatible with the HOL philosophy of keeping all types non-empty\" as claimed at<br>\n<a href=\"http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf\">http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf</a> (p. 4)?<br>\nMy R0 implementation is a dependent type theory, and there are no empty types in it.</li>\n</ol>\n<p>Kind regards,</p>\n<p>Ken Kubota</p>\n<hr>\n<p>Ken Kubota<br>\ndoi: 10.4444/100<br>\n<a href=\"http://dx.doi.org/10.4444/100\">http://dx.doi.org/10.4444/100</a></p>",
        "id": 294681327,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176818
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nDear Ken,</p>\n<p>Please see *** below.</p>\n<ol>\n<li>Which restriction was introduced in Isabelle (2016) in order to avoid the inconsistency of earlier versions revealed by Kunčar/Popescu? See<br>\n<a href=\"http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf\">http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf</a> (p. 3)</li>\n</ol>\n<p>*** As explained in the paper, now the definitional dependency is tracked through types as well.</p>\n<p>The definition of the constant c contains a free variable y.<br>\nConstant definitions in Gordon's original HOL do not allow free variables, but only \"a closed term\" [Gordon/Melham, 1993, p. 220; or<br>\n<a href=\"http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf\">http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf</a> (p. 33)].</p>\n<p>*** No: y is also bound there, by a forall quantifier.</p>\n<ol start=\"2\">\n<li>Are all types still constructed via the \"typedef\" mechanism?<br>\nThe following formulation allows two interpretations: a mechanism on top of \"typedef\",<br>\nor a new mechanism at the same (basic) level as and in addition to \"typedef\":<br>\n\"In the post-Isabelle 2012 development version, we have converted the numeric types int, rat, and real to use Lifting and Transfer. (Previously they were constructed as quotients with typedef, in the style of Paulson [6].)\"<br>\n<a href=\"http://www21.in.tum.de/~kuncar/documents/huffman-kuncar-itp2012.pdf\">http://www21.in.tum.de/~kuncar/documents/huffman-kuncar-itp2012.pdf</a> (p. 17)</li>\n</ol>\n<p>*** All these types, including int, rat and real, as well as all the (co)datatypes, are ultimately compiled into typedefs.</p>\n<ol start=\"3\">\n<li>The main questions is, whether in Isabelle still all new types are (besides being tested for non-emptiness)<br>\nintroduced with an axiom stating a mapping, like in Gordon's original HOL,<br>\nwhere for each new type an axiom is asserted saying that the new type is isomorphic to the defined (sub)set, cf.<br>\n<a href=\"http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf\">http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf</a> (p. 39).</li>\n</ol>\n<p>*** Yes: One can also <em>declare</em> types (which are assumed non-empty).  But all the <em>defined</em> types come with the two functions<br>\nrepresenting the back and forth isomorphisms with a subset of the host type.</p>\n<p>Let me remark that the section \"8.5.2 Defining New Types\" in<br>\n<a href=\"http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/tutorial.pdf\">http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2016/doc/tutorial.pdf</a> (pp. 173 ff.)<br>\nexplaining \"typedef\" is quite hidden.<br>\nIt would be desirable to have it in a separate logic manual like in the HOL4 logic part linked above.</p>\n<ol start=\"4\">\n<li>Why should \"dependent types\" be \"to a large extent incompatible with the HOL philosophy of keeping all types non-empty\" as claimed at<br>\n<a href=\"http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf\">http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf</a> (p. 4)?<br>\nMy R0 implementation is a dependent type theory, and there are no empty types in it.</li>\n</ol>\n<p>*** Having all types non-empty is incompatible with the mainstream dependent type approach, where one uses the Curry-Howard isomorphism<br>\nto model propositions as types, with their elements representing proofs -- then the existence of empty types simply means that not everything is provable.</p>\n<p>Best,<br>\n  Andrei</p>",
        "id": 294681350,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176826
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThis question is a perfect example why I dislike the use of the word “inconsistency\" in connection with the work of Kunčar and Popescu. Probably most people associate that word with some sort of incorrect logical reasoning. However, their work is concerned with Isabelle's automatic detection and rejection of circular definitions. Obvious ones such as x == x+1 and i==j, j==i+1 have been rejected for many years, but they found some cases where a very devious user could sneak a circular definition through. While it’s right that they have fixed this problem, nobody had actually exploited it, and the fix had no effect on the millions of lines of Isabelle proofs in existence. </p>\n<p>And it’s worth stressing again: even consistent definitions can be wrong.</p>\n<p>Larry Paulson</p>",
        "id": 294681372,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176830
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIndeed, this misleading tale told around the work by Kuncar / Popescu <br>\ngreatly subtracts from otherwise fine technical improvements.</p>\n<p>I have already pointed out many times that it was mainly a change of the <br>\ndocumented situation in Isabelle/HOL. Before there was a section in the <br>\nmanual saying clearly that typedefs are not fully checked. Afterwards, <br>\nthe officially supported typedefs were (1) extended to typedefs <br>\ndepending on overloaded consts (which was previously not covered) and <br>\n(2) the extended scheme checked by the system.</p>\n<p>Thus the isar-ref manual entry of HOL typedef could be changed <br>\naccordingly: the system has become more user-friendly, since the user is <br>\nno longer blamed implicitly for not having read the manual when <br>\nsomething goes wrong; instead the system complains explicitly. In <br>\npractice, such a situation was never seen, though, because the <br>\ncounter-example from the paper by Kuncar / Popescu was constructed <br>\nsynthetically to illustrate a theoretical point.</p>\n<p>Makarius</p>",
        "id": 294681408,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176841
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nThat's a typo, that type should be tau, the type that was defined on the <br>\nprevious line. I've already uploaded an updated version of the draft.</p>\n<p>Btw, we usually use alpha, beta, gamma for type variables, not sigma. <br>\nBut this is not mentioned until page 7.</p>\n<p>Ondrej</p>",
        "id": 294681429,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176847
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nOn 08/21/2016 12:21 PM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>This question is a perfect example why I dislike the use of the word<br>\n“inconsistency\" in connection with the work of Kunčar and Popescu.</p>\n</blockquote>\n<p>Which word would you use then? I'm open to suggestions.</p>\n<blockquote>\n<p>Probably most people associate that word with some sort of incorrect<br>\nlogical reasoning. However, their work is concerned with Isabelle's<br>\nautomatic detection and rejection of circular definitions.</p>\n</blockquote>\n<p>I see. I guess the whole discrepancy boils down to the question if <br>\ndefinitions are part of logical reasoning. For me, this is the case <br>\nsince you can view definitions as the following inference rule:</p>\n<p>T<br>\n----------- [side conditions]<br>\nT' |- c = t</p>\n<p>And if \"c = t\" allows you to prove False, then I call it an inconsistency.</p>\n<p>I don't find distinguishing between theorems stemming from axioms (and <br>\n\"pure\" logical reasoning) and between theorems stemming from definitions <br>\nparticularly enlightening.</p>\n<blockquote>\n<p>While it’s right that they have<br>\nfixed this problem, nobody had actually exploited it, and the fix had<br>\nno effect on the millions of lines of Isabelle proofs in existence.</p>\n</blockquote>\n<p>You are right. As far as I know, this was the case for any problems <br>\n(either implementation bugs or more substantial problems) that were <br>\nfound in other provers. But does this mean we should resign on <br>\ninspecting and improving our kernels/logics? I hope not.</p>\n<p>Bests,<br>\nOndrej</p>",
        "id": 294681438,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176850
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;</p>\n<blockquote>\n<p>As far as I know, this was the case for any problems (either implementation bugs or more substantial problems) that were found in other provers.</p>\n</blockquote>\n<p>I believe the soundness bug found in the Coq termination checker in December 2013 was hard to fix without breaking libraries -- I'm not sure what the exact resolution was and how much of an impact it had, but I believe it took them over one year to sort this out precisely because of the tension between soundness, expressiveness, and compatibility. Perhaps somebody with more knowledge about this should comment, but regardless it's dangerous to draw the conclusion that all soundness bugs can be fixed with no impact on real, legitimate applications.</p>\n<p>Jasmin</p>",
        "id": 294681464,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176861
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nA number of bugs in PVS had this effect too. As with your example, even the most careful user could not escape. And that’s precisely my point: soundness bugs often have consequences. </p>\n<p>Larry Paulson</p>",
        "id": 294681485,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176867
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou can see definitions that way, but then almost everything can be codified as an inference system. </p>\n<p>Of course I am not criticising your work, it's a positive contribution. Everything we can do to catch user errors is constructive. Note also how sledgehammer warns you if it can prove your theorem directly from an inconsistency in your assumptions. And we also have nitpick to catch user errors in theorem statements. But there is a difference between failing to catch a user error and performing incorrect deductions.</p>\n<p>Larry</p>",
        "id": 294681515,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176878
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 21.08.2016 21:41, Ondřej Kunčar wrote:</p>\n<blockquote>\n<p>I guess the whole discrepancy boils down to the question if <br>\ndefinitions are part of logical reasoning. For me, this is the case <br>\nsince you can view definitions as the following inference rule:</p>\n<p>T<br>\n----------- [side conditions]<br>\nT' |- c = t</p>\n<p>And if \"c = t\" allows you to prove False, then I call it an <br>\ninconsistency.</p>\n</blockquote>\n<p>This is an important observation. In classic Cambridge HOL systems, <br>\nadding definitions is an inference, but in Isabelle it is not: it is a <br>\ncertain extension of the theory with certain properties that might or <br>\nmight not be checked separately. That distinction of genuine inferences <br>\nvs. specifications is important, because explicit theory contexts are <br>\ncentral to Isabelle.</p>\n<blockquote>\n<p>I don't find distinguishing between theorems stemming from axioms (and <br>\n\"pure\" logical reasoning) and between theorems stemming from <br>\ndefinitions particularly enlightening.<br>\nMaybe, but this is how Isabelle works. Note that Isabelle follows <br>\nconventional logic text books in that respect. It was Cambridge HOL to <br>\nmake specifications an inference, probably due to technical reasons: <br>\nthere is only one big implicit theory in the ML environment that is <br>\naugmented by rules of inferences.</p>\n</blockquote>\n<p>It is always possible to discuss design decisions of existing systems, <br>\nbut it needs to be made clear in the text that this is done. Calling <br>\nsomething broken (or \"inconsistent\"), while actually talking about a <br>\ndifferent system is leading to endless confusion.</p>\n<blockquote>\n<blockquote>\n<p>While it’s right that they have<br>\nfixed this problem, nobody had actually exploited it, and the fix had<br>\nno effect on the millions of lines of Isabelle proofs in existence.<br>\nThis is because the lack of checks was known over many years as <br>\nsomething that is hardly relevant in practice. The feature addition of <br>\nthat additional check is theoretically nice, nonetheless.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>You are right. As far as I know, this was the case for any problems <br>\n(either implementation bugs or more substantial problems) that were <br>\nfound in other provers. But does this mean we should resign on <br>\ninspecting and improving our kernels/logics? I hope not.<br>\nNo, but here the situation was different: You started to look at the <br>\nimplementation for other reasons, found things that were surprising, and <br>\ncalled them a \"bug\". Then I pointed to the documentation, that this <br>\n\"bug\" was an official feature. That caused a lot of noise and confusion <br>\nthat still seems to be unsettled until today, even though \"typedef\" has <br>\nbeen officially upgraded from an axiomatic specification to a <br>\ndefinitional one in the implementation and documentation. (Both were <br>\nconsistent before and after that feature addition.)</p>\n</blockquote>\n<p>Makarius</p>",
        "id": 294681520,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176880
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nDear Andrei,</p>\n<p>Thank you for the quick answer, and also thanks to Larry Paulson and Makarius Wenzel.</p>\n<p>I had read the abbreviated notation with the forall quantifier too quickly, but still the third restriction specified at<br>\n<a href=\"http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf\">http://sourceforge.net/projects/hol/files/hol/kananaskis-10/kananaskis-10-logic.pdf</a> (p. 33) or at [Gordon/Melham, 1993, p. 220].<br>\nseems to be violated, as the type variable sigma occurs in the definiens, but not in (the type of) the definiendum.<br>\nYour example <br>\n    c:bool = ~(AL x:sigma AL y:sigma  .  x = y)<br>\nis very similar to the standard example on the next page of the logic manual with type variable alpha not occurring in type of the definiendum \"c:bool\":<br>\n    c:bool = EX f: alpha -&gt; alpha  .  One_One f /\\ ~(Onto f)<br>\nIt seems to me that a remedy simply would have been the restriction of Gordon's HOL (the third restriction).</p>\n<p>Larry Paulson's argument at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00075.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00075.html</a><br>\nseems to aim at a strict distinction between reasoning (inference) and circular definitions (language).<br>\nI doubt that this distinction can be made that strictly, since what restriction (iii) in Gordon's HOL tries to prevent,<br>\nin Andrews' logic is prevented by the restrictions on Rule R' [cf. Andrews, 2002, p. 214], where an inference from<br>\n    H  &gt;  A = B   and   H  &gt;  C<br>\nto<br>\n    H  &gt;  C [A/B]<br>\n('H' denotes a set of hypotheses, '&gt;' the turnstile) by substituting one occurrence of A in C by B is subject to a certain restriction<br>\nconcerning variables, i.e., if a variable x is free in a member of H and free in (A = B).<br>\nIf one steps from polymorphic to dependent type theory, type variables are also subject to binding (quantification),<br>\nsuch that type variable dependencies are preserved.<br>\nFor example, from<br>\n    {}  &gt;  ~(AL x:sigma AL y:sigma  .  x = y)<br>\none could infer by the derived Rule of Universal Generalization (5220) [cf. Andrews, 2002, p. 222]<br>\n    {}  &gt;  AL sigma:tau ~(AL x:sigma AL y:sigma  .  x = y)<br>\n(tau denotes the type of types) and then<br>\n    {}  &gt;  F<br>\nbecause some types are singletons.<br>\nIn other words, your c:bool would be F (false), because free (type) variables are implicitly universally quantified.<br>\nIn contrast, if there were a condition upon sigma, for example, being bool: H = { sigma = bool }, then from<br>\n    { sigma = bool }  &gt;  ~(AL x:sigma AL y:sigma  .  x = y)<br>\none couldn't use the derived Rule of Universal Generalization (5220) to infer<br>\n    { sigma = bool }  &gt;  AL sigma:tau ~(AL x:sigma AL y:sigma  .  x = y)<br>\nsince (type) variable sigma occurs free in the set of hypotheses H, which violates the condition of rule 5220,<br>\nwhich is a condition derived from Rule R', since 5220 (like all rules in Q0 except Rule R/R') is a derived rule.<br>\nHence, circular definitions are prevented by the inference rule (the reasoning) in Q0/R0 in a very simple manner.</p>\n<p>Best wishes,</p>\n<p>Ken Kubota</p>\n<hr>\n<p>Ken Kubota<br>\ndoi: 10.4444/100<br>\n<a href=\"http://dx.doi.org/10.4444/100\">http://dx.doi.org/10.4444/100</a></p>",
        "id": 294681540,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176887
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYes, such extreme measures would greatly simplify the story from a <br>\ntheoretical point of view, but we are talking here of implemented logic: <br>\nit needs to provide extra provisions to make it usable in practice.</p>\n<p>Abbreviations that are always expanded would render the system <br>\nimpractical due to huge terms in expanded internal form.</p>\n<p>Ruling out declarations that are separated from definitions greatly <br>\nsimplify things, but prevent important applications like type class <br>\ninstantiation.</p>\n<p>There is always a tradeoff in theoretical simplicity versus complexity <br>\nrequired for practical applications of logic.<br>\nWithout that tradeoff, making a usable theorem proving environment like <br>\nIsabelle would be a trivial exercise, and not an effort of 30 years.</p>\n<p>Makarius</p>",
        "id": 294681553,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176892
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nRegardless of whether we consider definitions as part of the inference kernel, the following is self-evident:</p>\n<p>A logical system, if it takes the trouble to guarantee anything, is supposed to guarantee that False cannot be inferred via the canonical 'safe' user interaction with the system -- which consists of performing definitions plus logical deduction.</p>\n<p>Since nobody does bare deduction without (building on top of) definitions, having the former consistent is pointless without having the latter consistent. So what are we talking about here?</p>\n<p>Of course, Makarius, you are right to remind us that Isabelle/HOL is a complex software system and its reliability has many facets. Of course, Larry, you are right to remind us that often user definitions can fail to be faithful to the intended concepts. But please let me remind you (again) that these are both different points.</p>\n<p>Andrei</p>",
        "id": 294681573,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176898
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI am talking about how Isabelle works. You are talking about a different <br>\nsystem. That is very dangerous, because people might pick up wrong ideas <br>\nabout the system, and then produce true non-sense.</p>\n<p>The whole \"typedef is axiomatic\" versus \"typedef is definitional in the <br>\nsense of HOL set theory\" affair from last year was about adding a <br>\nfeature in order to amend such social problems and misunderstandings. <br>\nThere was little practical relevance from a logical standpoint.</p>\n<p>In Isabelle we have yet more ways to produce a bad theory content and <br>\nthen derive results that look wrong.</p>\n<p>Makarius</p>",
        "id": 294681586,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176906
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nI find it very dangerous for the theoretical progress in our area to refuse to accept the existence of an Isabelle/HOL logical system -- namely, a system that</p>\n<p>can be described mathematically by:</p>\n<p>(A) a mechanism for constant and type definitions</p>\n<p>(B) a set of rules of deduction</p>\n<p>This system exists as a mathematical entity independently of the implementation. (All my contributions to Isabelle/HOL so far, admittedly modest, have</p>\n<p>been based on this view -- and they have led to additions to the real system.)</p>\n<p>As soon as you accept this view (regardless of how you choose to model (A) and (B) in a reasonable way), you will see the following:</p>\n<p>You have incorporated the additional check that we suggested in the paper not only for 'adding a feature in order to amend such social problems and misunderstandings', but also for transforming an inconsistent logical system into a consistent one -- or, if you take the view that type <em>definitions</em> used to come with no consistency guarantees, this was the transformation of a logical system that officially allowed inconsistency into one that does not. And I am very happy for this.</p>\n<p>A recurrent objection that you are bringing to the above view is that Isabelle/HOL is built on top of a logical framework, which, according to you,  makes the situation so complex that cannot be depicted by mortals. As I wrote  before, this is a matter that is settled separately, by an adequacy proof -- so that we can ignore the logical framework when making theoretical advancements.</p>\n<p>Finally, let me note that, as far as I see, Larry's point is a distinct one: He considers that the consistency of all definitions, be they constant or type definitions, are in principle entirely the user's responsibility -- although he admits that it would be nice if the system 'nitpicked' them here and there.</p>\n<p>On the way, he reveals something that had never crossed my mind: that what, in our paper, we naively call a consistency theorem is in fact an enhancement of Nitpick.  :-)  My last email was addressing Larry's point. And note that I was not talking about 'a different system', but about a logical system in general.</p>\n<p>Andrei</p>",
        "id": 294681608,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176913
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nBut then, looking at the revised version, the problem still seems to be caused by the language.<br>\nThe first line (\"consts\" …) seems to be a declaration, and the third line (\"defs\" …) a definition.<br>\nDeclarations like this allow the declared constant to practically behave like a variable, since the constant can be specified (defined) much later.</p>\n<p>In Q0/R0 there are no such declarations.<br>\nIf one would try to express the same in the language of R0, only one possibility would be left.<br>\nThe definition (\"defs\" …) could not be placed first, since it requires tau, which would be introduced by the latter type definition (\"typedef\" …) not available at the beginning.<br>\nHence first type tau has to be defined (being a mere abbreviation) on the basis of a variable \"c\" as:<br>\n    tau := [\\x:bool  .  x=T \\/ x=c:bool]<br>\nProving tau_T (i.e., T is element of tau; '_' denotes lambda application) then makes tau a type (being non-empty).<br>\nFinally,<br>\n    c = ~(AL x,y:tau  .  x=y)<br>\ncould be introduced as a hypothesis. Since it leads to a contradiction, it is shown to be false (hence, c != ~(AL x,y:tau  .  x=y) ), which is the desired result.<br>\nIn summary, the solution would be not allowing declarations in the mathematical language, but only definitions, like in Q0/R0.</p>\n<p>Concerning the question of definitions, they shouldn't be part of the kernel, since non-logical axioms should be avoided as discussed in section 3 at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00069.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00069.html</a><br>\nAlso, implementing definitions within the logical core contradicts to the LCF philosophy of a small trusted kernel.<br>\nFor this reason, definitions in R0 are mere abbreviations located outside of the logical kernel.<br>\nThey also can be removed at any time (and re-introduced again) without modifying the theorems already obtained.</p>\n<p>Ken Kubota</p>\n<hr>\n<p>Ken Kubota<br>\ndoi: 10.4444/100<br>\n<a href=\"http://dx.doi.org/10.4444/100\">http://dx.doi.org/10.4444/100</a></p>",
        "id": 294681622,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176917
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nWe are talking about the danger – almost certainly realised – of misleading people.</p>\n<p>The various issues involving Isabelle, Coq, PVS and other systems are all complicated in their details. Outside observes are probably not going to invest the time and effort necessary to investigate precisely what is going on in case case. They will regard these “inconsistencies” as roughly the same. So we are drawing a false equivalence between</p>\n<p>I. The prover incorrectly handles correct and meaningful definitions. Users, who have done nothing wrong, cannot complete their projects.</p>\n<p>II. Somebody who has studied the source code has devised a definition that is not meaningful and the prover fails to detect this. Nobody has ever used or wanted such a definition, because it is overtly nonsensical.</p>\n<p>It’s wrong and misleading to give the impression that I and II are the same.</p>\n<p>Larry</p>",
        "id": 294681695,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176929
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nUsing the current Isabelle 2016, it is not possible for me to reproduce the problem.</p>\n<p>If I understand Andrei Popescu and Makarius Wenzel correctly,<br>\ndeclarations of constants earlier than and separated from their definitions should be possible, <br>\nbut circular dependencies not anymore in the 2016 version of Isabelle.<br>\nNevertheless, the error message reports a problem with the definition of the constant,<br>\neven if circularity is avoided by removing 'c' from tau ('T').</p>\n<p>Could you please provide a working example (for the 2016 version of Isabelle)<br>\nby correcting my attempt (shown with the results below)?</p>\n<p>Please note that line \"consts c:α\" (\"consts c:alpha\") at<br>\n<a href=\"http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf\">http://www21.in.tum.de/~kuncar/kuncar-popescu-jar2016.pdf</a> (p. 3)<br>\nstill differs from line \"consts c :: bool\" in<br>\n<a href=\"http://www21.in.tum.de/~kuncar/documents/False.tar.gz\">http://www21.in.tum.de/~kuncar/documents/False.tar.gz</a><br>\navailable via<br>\n<a href=\"http://www21.in.tum.de/~kuncar/documents/patch.html\">http://www21.in.tum.de/~kuncar/documents/patch.html</a></p>\n<p>Ken Kubota</p>\n<p>(* using 'a, \"(overloaded)\", \"definition\", and c is removed from T  *)</p>\n<p>consts c :: 'a</p>\n<p>typedef (overloaded) T = \"{True}\" by blast</p>\n<p>definition c_bool_def: <br>\n  \"c::bool ≡ if (∀(x::T) y. x = y) then False else True\"<br>\n(<em>ERROR: Bad head of lhs: existing constant \"c\"</em>)</p>\n<p>(* using 'a, \"(overloaded)\" and \"definition\" *)</p>\n<p>consts c :: 'a</p>\n<p>typedef (overloaded) T = \"{True, c}\" by blast</p>\n<p>definition c_bool_def: <br>\n  \"c::bool ≡ if (∀(x::T) y. x = y) then False else True\"<br>\n(<em>ERROR: Bad head of lhs: existing constant \"c\"</em>)</p>\n<p>(* using \"(overloaded)\" and \"definition\" *)</p>\n<p>consts c :: bool</p>\n<p>typedef (overloaded) T = \"{True, c}\" by blast</p>\n<p>definition c_bool_def: <br>\n  \"c::bool ≡ if (∀(x::T) y. x = y) then False else True\"<br>\n(<em>ERROR: Bad head of lhs: existing constant \"c\"</em>)</p>\n<p>(* original version by Ondrej Kuncar, with \"defs\" *)</p>\n<p>consts c :: bool</p>\n<p>typedef T = \"{True, c}\" by blast</p>\n<p>defs c_bool_def: <br>\n  \"c::bool ≡ if (∀(x::T) y. x = y) then False else True\"<br>\n(* several errors in current Isabelle 2016 *)</p>\n<hr>\n<p>Ken Kubota<br>\ndoi: 10.4444/100<br>\n<a href=\"http://dx.doi.org/10.4444/100\">http://dx.doi.org/10.4444/100</a></p>",
        "id": 294681767,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176954
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nDear Larry,</p>\n<blockquote>\n<blockquote>\n<p>We are talking about the danger - almost certainly realised - of misleading people.</p>\n</blockquote>\n</blockquote>\n<p>I don't see how severely (and artificially) lowering the standard of what we want from a logical system can help against the potential confusion. Let me restate the obvious: We want consistency not only of bare deduction (from the HOL axioms), but of deduction from the definitional theories (including constant and type definitions). This is not a complicated statement, and most users of this systems and of similar systems will agree on it.</p>\n<p>We did not have that in Isabelle/HOL---and this was hinted to in the reference manual, but in not very clear terms and few people knew about it. Today we have achieved this goal and it is documented in quite clear terms in the same reference manual, and people should know about it. What does not help is refusing to accept what we have already accomplished, <em>even as a principial goal for a logical system</em>.</p>\n<p>It should also be stressed, of course, that the modifications needed to achieve this goal -- a harsher check at definitions -- did not affect in any way the previous Isabelle developments, which is great, and indeed different from similar problems in other systems.</p>\n<blockquote>\n<blockquote>\n<p>The various issues involving Isabelle, Coq, PVS and other systems are all complicated in their details. Outside observes are probably not going to invest the time and effort necessary to investigate precisely what is going on in case case. They will regard these \"inconsistencies\" as roughly the same. So we are drawing a false equivalence between</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I. The prover incorrectly handles correct and meaningful definitions. Users, who have done nothing wrong, cannot complete their projects.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>II. Somebody who has studied the source code has devised a definition that is not meaningful and the prover fails to detect this. Nobody has ever used or wanted such a definition, because it is overtly nonsensical.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>It's wrong and misleading to give the impression that I and II are the same.</p>\n</blockquote>\n</blockquote>\n<p>There is no a priori notion of 'meaningful' definition, apart from what the system accepts. So yes, from the point of view of the logical system these situations must be treated in the same way, in particular taken equally seriously. And this while ignoring the unnecessary reference to that malicious 'somebody who has studied the source code' -- who happens to be named Ondrej and happens to have been working on something else when he discovered that. But you know very well from day one the story behind this discovery and its ordeals.</p>\n<p>Andrei</p>",
        "id": 294681810,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176972
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:Jeremy.Dawson@anu.edu.au\">Jeremy.Dawson@anu.edu.au</a>&gt;<br>\nHow about III,<br>\na user devised a definition that is meaningful but mistakenly omits a <br>\nword (eg \"primrec\") somewhere, and could \"complete his project\" or so it <br>\nseems, by virtue of the fact that his definitions are nonsense, but not <br>\nobviously so</p>\n<p>Jeremy</p>",
        "id": 294681845,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176984
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nDear Andrei,</p>\n<p>Thank you very much for your kind support at<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00099.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-August/msg00099.html</a><br>\nwhich I really appreciate.</p>\n<p>I was wondering whether it would be possible to create declarations separated <br>\nfrom definitions without (!) overloading in the current Isabelle version <br>\n(2016). Such attempts were rejected by the current Isabelle version (see <br>\nattached theory CircularDefs). So it seems that overall your approach is <br>\nsuccessful in preventing the kind of inconsistency described in your article.</p>\n<p>Also, I tried to express your (Ondřej's) definitions in the R0 implementation <br>\nand obtained interesting results on the methods preventing such paradoxes. I <br>\nshall write more about it in a separate e-mail soon.</p>\n<p>Kind regards,</p>\n<p>Ken Kubota</p>\n<hr>\n<p>Ken Kubota<br>\ndoi: 10.4444/100<br>\n<a href=\"http://dx.doi.org/10.4444/100\">http://dx.doi.org/10.4444/100</a><br>\n<a href=\"/user_uploads/14278/yPkUrE-nuM6CM5kPXOSuyIg9/CircularDefs.thy\">CircularDefs.thy</a></p>",
        "id": 294681937,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661177021
    },
    {
        "content": "<p>From: Ken Kubota &lt;<a href=\"mailto:mail@kenkubota.de\">mail@kenkubota.de</a>&gt;<br>\nDear Andrei,</p>\n<p>Answering a private communication, I referred to your paper on Isabelle/HOL<br>\nas well as to Peter Homeier’s HOL-Omega TUTORIAL in a reply at<br>\n<a href=\"http://owlofminerva.net/kubota/r0-faq/\">http://owlofminerva.net/kubota/r0-faq/</a></p>\n<p>Regards,</p>\n<p>Ken</p>\n<hr>\n<p>Ken Kubota<br>\n<a href=\"http://doi.org/10.4444/100\">http://doi.org/10.4444/100</a></p>",
        "id": 294733962,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189120
    }
]