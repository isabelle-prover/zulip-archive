[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nConsider the following in HOL</p>\n<p>locale label = bounded_lattice +<br>\n  fixes lblRem :: \"'a \\&lt;Rightarrow&gt; 'b \\&lt;Rightarrow&gt;  'a\"<br>\n  and canElim :: \"'b \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\"<br>\nbegin</p>\n<p>First question: which type variable of the locale \"label\" ('a or 'b,<br>\nor neither) is understood to be the single type variable of<br>\n\"bounded_lattice\"?  I want 'a to be the lattice.  How can I say that?</p>\n<p>In the locale context I want to define a datatype</p>\n<p>datatype ('a,'b) expr = ...</p>\n<p>where 'a and 'b are the type variables of the locale, and 'a is the<br>\nlattice.  It seems that datatype definitions are not accepted in a<br>\nlocale context, so I defined ('a,'b) expr before the locale and tried<br>\nto instantiate it with 'a and 'b inside the locale.</p>\n<p>type_synonym exp = \"('a,'b) expr\"</p>\n<p>This fails: '*** Extra variables on rhs: \"'b\", \"'a\"'.  In my mind, the<br>\ntype variables 'a and 'b are somehow fixed in the locale context, so<br>\nare not extra variables on rhs.  That is, in any (concrete?) instance<br>\nof the locale 'a and 'b will be fixed, so I should be able to give<br>\nthem symbolic names and use them as if they were declared (say with<br>\ntypedecl) inside the locale context.</p>\n<p>I try something else:</p>\n<p>type_synonym ('a,'b) exp = \"('a,'b) expr\"</p>\n<p>This fails too: '*** Locally fixed type arguments \"'a\", \"'b\" in type<br>\ndeclaration \"exp\"'  So Isabelle also thinks 'a and 'b are fixed in the<br>\nlocale context.</p>\n<p>Now I'm stuck.  Can I do what I'm trying to do.? If not, is there a<br>\nlogical reason why not?</p>\n<p>Thanks,<br>\nRandy</p>",
        "id": 294138062,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845003
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 24 Jun 2011, Randy Pollack wrote:</p>\n<blockquote>\n<p>In the locale context I want to define a datatype</p>\n<p>datatype ('a,'b) expr = ...</p>\n<p>where 'a and 'b are the type variables of the locale, and 'a is the<br>\nlattice.  It seems that datatype definitions are not accepted in a<br>\nlocale context, so I defined ('a,'b) expr before the locale and tried<br>\nto instantiate it with 'a and 'b inside the locale.</p>\n<p>type_synonym exp = \"('a,'b) expr\"</p>\n<p>This fails: '*** Extra variables on rhs: \"'b\", \"'a\"'.  In my mind, the<br>\ntype variables 'a and 'b are somehow fixed in the locale context, so<br>\nare not extra variables on rhs.</p>\n</blockquote>\n<blockquote>\n<p>I try something else:</p>\n<p>type_synonym ('a,'b) exp = \"('a,'b) expr\"</p>\n<p>This fails too: '*** Locally fixed type arguments \"'a\", \"'b\" in type<br>\ndeclaration \"exp\"'  So Isabelle also thinks 'a and 'b are fixed in the<br>\nlocale context.</p>\n</blockquote>\n<p>Conceptually, the \"locality\" of type specifications is limited: it may not <br>\ndepend on the context parameters.  Its own parameters are considered fresh <br>\nabstractions, so an accidental clash with outer ones is an error.</p>\n<p>type_synonym, typedecl, typedef already work in that sense, but datatype <br>\nis still not \"localized\".  (It is on the agenda with high priority for <br>\nquite a few years already, although it is become some kind of running <br>\ngag in the meantime).</p>\n<blockquote>\n<p>That is, in any (concrete?) instance of the locale 'a and 'b will be <br>\nfixed, so I should be able to give them symbolic names and use them as <br>\nif they were declared (say with typedecl) inside the locale context.</p>\n</blockquote>\n<p>Local type parameters are fixed, outside the context they become <br>\narbitrary, and may thus get instantiated.</p>\n<blockquote>\n<p>Now I'm stuck.  Can I do what I'm trying to do.? If not, is there a <br>\nlogical reason why not?</p>\n</blockquote>\n<p>You can define the datatype globally and use it locally.  This means its <br>\nparameters will be always mentioned (again) in the local situation.</p>\n<p>Makarius</p>",
        "id": 294138138,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845022
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nQuoting Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;:</p>\n<blockquote>\n<p>Consider the following in HOL</p>\n<p>locale label = bounded_lattice +<br>\n fixes lblRem :: \"'a \\&lt;Rightarrow&gt; 'b \\&lt;Rightarrow&gt;  'a\"<br>\n and canElim :: \"'b \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\"<br>\nbegin</p>\n<p>First question: which type variable of the locale \"label\" ('a or 'b,<br>\nor neither) is understood to be the single type variable of<br>\n\"bounded_lattice\"?</p>\n</blockquote>\n<p>This is not specified.  Use print_locale to find out what happened  <br>\n(you may need to set show_types).</p>\n<blockquote>\n<p>I want 'a to be the lattice.  How can I say that?</p>\n</blockquote>\n<p>You need to mention the type variable in the imported expression.   <br>\nThis can be done like this:</p>\n<p>locale label = bounded_lattice x for x :: \"... 'a ...\" + ...</p>\n<blockquote>\n<p>In the locale context I want to define a datatype</p>\n<p>datatype ('a,'b) expr = ...</p>\n<p>where 'a and 'b are the type variables of the locale, and 'a is the<br>\nlattice.  It seems that datatype definitions are not accepted in a<br>\nlocale context, so I defined ('a,'b) expr before the locale and tried<br>\nto instantiate it with 'a and 'b inside the locale.</p>\n<p>[...]</p>\n<p>Now I'm stuck.  Can I do what I'm trying to do.? If not, is there a<br>\nlogical reason why not?</p>\n</blockquote>\n<p>As Makarius already said, use ('a, 'b) expr in your locale.</p>\n<p>Clemens</p>",
        "id": 294138166,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845032
    },
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nThanks Clemens and Makarius, but now I have a new problem with notation.</p>\n<p>Consider this</p>\n<p>context lattice begin<br>\nthm le_supI1             <strong> a theorem from the typeclass lattice </strong>)</p>\n<p>This prints out</p>\n<p>?x \\&lt;le&gt; ?a \\&lt;Longrightarrow&gt; ?x \\&lt;le&gt; sup ?a ?b</p>\n<p>So the typeclass \"lattice\" from Main supplies notation for less_eq,<br>\n(and less) but not for sup (or inf).  I don't understand why, but I<br>\nknow how to fix it: put</p>\n<p>notation  sup (infixl \"\\&lt;squnion&gt;\" 70)</p>\n<p>in the context.</p>\n<p>Now consider my locale</p>\n<p>locale label = lattice less_eq             (<strong> as Clemens suggested </strong>)<br>\n  for less_eq::\"'a::lattice \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\" +<br>\n  fixes oprn :: \"'a \\&lt;Rightarrow&gt; nat \\&lt;Rightarrow&gt; 'a\"<br>\nbegin<br>\nthm le_supI1</p>\n<p>This prints out</p>\n<p>less_eq ?x ?a \\&lt;Longrightarrow&gt; less_eq ?x (sup ?a ?b)</p>\n<p>So my \"for\" clause for less_eq has removed (or shadowed?) the notation<br>\n\\&lt;le&gt; from the typeclass lattice.</p>\n<p>I tried</p>\n<p>locale label2 = lattice less_eq less inf sup<br>\n  for less_eq::\"'a::bounded_lattice \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\" +<br>\n  fixes oprn :: \"'a \\&lt;Rightarrow&gt; nat \\&lt;Rightarrow&gt; 'a\"<br>\nbegin<br>\nnotation<br>\n  less_eq  (infix \"\\&lt;le&gt;\" 50) and<br>\n  less     (infix \"&lt;\"  50) and<br>\n  inf      (infixl \"\\&lt;sqinter&gt;\" 70) and<br>\n  sup      (infixl \"\\&lt;squnion&gt;\" 70)<br>\nthm le_supI1</p>\n<p>This prints out</p>\n<p>?x \\&lt;le&gt; ?a \\&lt;Longrightarrow&gt; ?x \\&lt;le&gt; ?a \\&lt;squnion&gt; ?b</p>\n<p>So it looks good.  But I try</p>\n<p>lemma \"x \\&lt;le&gt; a \\&lt;Longrightarrow&gt; x \\&lt;le&gt; a \\&lt;squnion&gt; b\"</p>\n<p>This gives</p>\n<p>*** Ambiguous input, 4 terms are type correct:<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (a \\&lt;squnion&gt; b)))<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (a \\&lt;squnion&gt; b)))<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (a \\&lt;squnion&gt; b)))<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (a \\&lt;squnion&gt; b)))</p>\n<p>I guess some mixup between \\&lt;squnion&gt; of lattice and \\&lt;squnion&gt; of label1</p>\n<p>What is the problem?  How can I fix it?</p>\n<p>Thanks for any help,<br>\nRandy</p>",
        "id": 294138176,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845034
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nThere's two issues here:</p>\n<p>locale label = lattice less_eq             (<strong> as Clemens suggested </strong>)<br>\n   for less_eq::\"'a::lattice \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\" +</p>\n<p>removes the syntax from the parameter.  It can either be declared with  <br>\na syntax annotation in the for clause or via the notation command.   <br>\nSo, what you did I would have expected to work.</p>\n<p>What happens in you case is that syntax from an imported class does  <br>\nnot arrive at the locale.</p>\n<p>class my_class =<br>\n   fixes operation :: \"'a =&gt; 'a =&gt; 'a\" (infixl \"++\" 60)<br>\nbegin<br>\n   term operation  (* prints op ++ *)<br>\nend</p>\n<p>locale my_locale = my_class<br>\nbegin<br>\n   term operation  (* prints operation, concrete syntax lost *)<br>\nend</p>\n<p>(If you make my_class a locale, the syntax arrives in the second  <br>\nlocale.)  I suspect this is either explained by the class package or  <br>\nperhaps local theories (Florian, Makarius?).  Class syntax is declared  <br>\nboth at the theory level and in the class context.  This likely causes  <br>\nthe syntax conflict you observe.</p>\n<p>Clemens</p>\n<p>Quoting Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;:</p>",
        "id": 294138251,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845059
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<blockquote>\n<p>Class syntax is declared<br>\nboth at the theory level and in the class context.</p>\n</blockquote>\n<p>Not exactly.  Class syntax is <em>only</em> declared at the theory level, but<br>\ninside the class context occurences of the global class operations on<br>\nthe type parameter 'a of the class are improved to their local<br>\ncounterparts.  This allows to use syntax uniformly (c.f. class tutorial,<br>\nÂ§3.6).</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/ey78csJJkuRa6hk3MkynANe7/signature.asc\">signature.asc</a></p>",
        "id": 294138349,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845091
    },
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nThanks, but I'm still stumped.  Let's go through a simplified example.<br>\n I'm using<br>\nIsabelle2011.</p>\n<p>theory testing imports Main begin   (<strong> nothing up my sleeve </strong>)<br>\nthm le_supI1                        (* some theorem from semilattice_sup *)</p>\n<p>Prints out</p>\n<p>(?x\\&lt;Colon&gt;?'a\\&lt;Colon&gt;semilattice_sup) \\&lt;le&gt;<br>\n(?a\\&lt;Colon&gt;?'a\\&lt;Colon&gt;semilattice_sup) \\&lt;Longrightarrow&gt;<br>\n?x \\&lt;le&gt; sup ?a (?b\\&lt;Colon&gt;?'a\\&lt;Colon&gt;semilattice_sup)</p>\n<p>Why?  The notation<br>\n\\&lt;le&gt;  (from class order) is preserved, but the notation \"\\&lt;squnion&gt;\"<br>\nfor sup (from<br>\nclass semilattice_sup is gone.</p>\n<p>I want to create a new locale, extending lattice with a new operator.  The new<br>\noperator may mention several type variables, one specific one of which<br>\nshould be the<br>\nsame as the lattice type.  This was my original question.</p>\n<p>I first tried this:</p>\n<p>locale label = lattice +<br>\n  fixes noperator :: \"'a::lattice \\&lt;Rightarrow&gt; 'b\"<br>\nbegin</p>\n<p>This doesn't seem to work:</p>\n<p>locale label =<br>\n  fixes less_eq :: \"'c\\&lt;Colon&gt;type \\&lt;Rightarrow&gt; 'c\\&lt;Colon&gt;type<br>\n\\&lt;Rightarrow&gt; bool\"<br>\n    and less :: \"'c\\&lt;Colon&gt;type \\&lt;Rightarrow&gt; 'c\\&lt;Colon&gt;type<br>\n\\&lt;Rightarrow&gt; bool\"<br>\n    and inf :: \"'c\\&lt;Colon&gt;type \\&lt;Rightarrow&gt; 'c\\&lt;Colon&gt;type<br>\n\\&lt;Rightarrow&gt; 'c\\&lt;Colon&gt;type\"<br>\n    and sup :: \"'c\\&lt;Colon&gt;type \\&lt;Rightarrow&gt; 'c\\&lt;Colon&gt;type<br>\n\\&lt;Rightarrow&gt; 'c\\&lt;Colon&gt;type\"<br>\n    and nopr :: \"'b\\&lt;Colon&gt;type \\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice\"</p>\n<p>\"noperator\" is not constrained to have type 'c, which seems to be the<br>\nlattice type here.<br>\nAnd why does 'c have sort \"type\" instead of sort \"lattice\"?</p>\n<p>So following Clemens' suggestion, I write:</p>\n<p>locale label = lattice less_eq<br>\n  for less_eq::\"'a::lattice \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\"<br>\n(infix \"\\&lt;le&gt;\" 50) +<br>\n  fixes noperator :: \"'a \\&lt;Rightarrow&gt; 'b\"<br>\nbegin</p>\n<p>locale label =<br>\n  fixes less :: \"'a\\&lt;Colon&gt;lattice \\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice<br>\n\\&lt;Rightarrow&gt; bool\"<br>\n    and inf :: \"'a\\&lt;Colon&gt;lattice \\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice<br>\n\\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice\"<br>\n    and sup :: \"'a\\&lt;Colon&gt;lattice \\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice<br>\n\\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice\"<br>\n    and less_eq :: \"'a\\&lt;Colon&gt;lattice \\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice<br>\n\\&lt;Rightarrow&gt; bool\"<br>\n    and noperator :: \"'a\\&lt;Colon&gt;lattice \\&lt;Rightarrow&gt; 'b\\&lt;Colon&gt;type\"</p>\n<p>That looks better, and printing \"le_supI1\" as above gives:</p>\n<p>(?x\\&lt;Colon&gt;'a\\&lt;Colon&gt;lattice) \\&lt;le&gt; (?a\\&lt;Colon&gt;'a\\&lt;Colon&gt;lattice)<br>\n\\&lt;Longrightarrow&gt;<br>\n?x \\&lt;le&gt; (sup\\&lt;Colon&gt;'a\\&lt;Colon&gt;lattice \\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice<br>\n\\&lt;Rightarrow&gt; 'a\\&lt;Colon&gt;lattice) ?a (?b\\&lt;Colon&gt;'a\\&lt;Colon&gt;lattice)</p>\n<p>But when I try to state this myself:</p>\n<p>lemma \"x \\&lt;le&gt; a \\&lt;Longrightarrow&gt; x \\&lt;le&gt; (sup a b)\"</p>\n<p>*** Ambiguous input, 4 terms are type correct:<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (sup a b)))<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (sup a b)))<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (sup a b)))<br>\n*** ((x \\&lt;le&gt; a) \\&lt;Longrightarrow&gt; (x \\&lt;le&gt; (sup a b)))</p>\n<p>What do you suggest?</p>\n<p>Thanks,<br>\nRandy</p>",
        "id": 294138366,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845097
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>I guess the source for the misunderstanding is that the lattice syntax<br>\nfor sup etc. is deleted in theory Lattices; to obtain it again, import<br>\ntheory Lattice_Syntax.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/euwJrsYZY5-rU82CFeR8gFZk/signature.asc\">signature.asc</a></p>",
        "id": 294138386,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845106
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Randy,</p>\n<p>you might want to try the following locale declaration:</p>\n<p>locale label = lattice less_eq less inf sup<br>\n   for less_eq :: \"'a =&gt; 'a =&gt; bool\" (infix \"\\&lt;le&gt;\" 50)<br>\n   and less :: \"'a =&gt; 'a =&gt; bool\" (infix \"&lt;\" 50)<br>\n   and inf :: \"'a =&gt; 'a =&gt; 'a\"<br>\n   and sup :: \"'a =&gt; 'a =&gt; 'a\"<br>\n   +<br>\n   fixes noperator :: \"'a =&gt; 'b\"<br>\nbegin</p>\n<p>lemma \"x \\&lt;le&gt; a \\&lt;Longrightarrow&gt; x \\&lt;le&gt; (sup a b)\"</p>\n<p>Mentioning all parameters of lattice in the for clause ensures that label keeps <br>\nthe same order of parameters as lattice does.</p>\n<p>Note that 'a no longer carries the sort constraint lattice. This is intentional <br>\nas the type variables in the context of a type class never carry the sort <br>\nconstraint of the lattice, because the assumptions of the type class are part of <br>\nthe locale assumption. Conversely, from within the type class context, you can <br>\nonly use lemmas that are proved in the type class context, but not with the type <br>\nconstraints.</p>\n<p>This also solves the issue with abiguous input: Since 'a is not of sort ord <br>\n(which defines the syntax for less_eq and less), the syntax for type classes is <br>\nnot applicable.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294138396,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845108
    }
]