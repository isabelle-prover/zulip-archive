[
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@googlemail.com\">munddr@googlemail.com</a>&gt;<br>\nThanks for that. I'm trying this at the moment:</p>\n<p>consts<br>\nA :: \"[nat,int] =&gt; int\"<br>\nB :: \"[nat,int] =&gt; int\"<br>\nC :: \"[nat,int] =&gt; int\"</p>\n<p>axioms<br>\nax: \"A p t = B p t + C p t\"</p>\n<p>lemma lem1: \"EX func x y.func x y = B x y + C x y\"<br>\nusing ax<br>\nby blast</p>\n<p>It can infer the types of all func, x and y and blast resolves it. However,<br>\nif I change the LHS to a free variable:</p>\n<p>lemma lem1: \"EX func x y.func x y = v\"<br>\nusing ax<br>\nby blast</p>\n<p>I wasn't so lucky. How come it can't unify v with B x y + C x y? What more<br>\ndo I need?</p>\n<p>Thanks again<br>\nJohn</p>",
        "id": 294082562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831169
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nJohn Munroe wrote:</p>\n<blockquote>\n<p>Thanks for that. I'm trying this at the moment:</p>\n<p>consts<br>\nA :: \"[nat,int] =&gt; int\"<br>\nB :: \"[nat,int] =&gt; int\"<br>\nC :: \"[nat,int] =&gt; int\"</p>\n<p>axioms<br>\nax: \"A p t = B p t + C p t\"</p>\n<p>lemma lem1: \"EX func x y.func x y = B x y + C x y\"<br>\nusing ax<br>\nby blast</p>\n<p>It can infer the types of all func, x and y and blast resolves it. However,<br>\nif I change the LHS to a free variable:</p>\n<p>lemma lem1: \"EX func x y.func x y = v\"<br>\nusing ax<br>\nby blast</p>\n<p>Have a look at the typing of your lemma (Switch on<br>\nSettings-&gt;Show-Types), it is: func::'a =&gt; 'b =&gt; 'c, x::'a, y::'b, v::'c.<br>\nAs there are no type constraints specified, Isabelle infers the most<br>\ngeneric type. However,<br>\nyour axiom ax only works for nat and int.</p>\n</blockquote>\n<p>To solve your problem, you have to explicitely constrain the type of,<br>\nsay, func:<br>\n  EX (func::nat=&gt;int=&gt;int) x y. ...</p>\n<p>However, your lemma means not what you seem to intend. The free variable<br>\n(v) will be implicitely universally quantified,<br>\ni.e. your lemma means that, for each v, there is a function func and<br>\narguments x and y such that func x y = v.<br>\nTo prove your lemma (even with the generic types), try e.g.</p>\n<p>lemma lem2: \"EX func x y. func x y = v\"<br>\n  apply (rule_tac x=\"%x y. v\" in exI)<br>\n  apply blast<br>\ndone</p>\n<p>This always works, because types in Isabelle are not empty, such there<br>\nis always some x and y that the function (%x y. v) can be applied to.</p>\n<p>Regards,<br>\n  Peter</p>\n<blockquote>\n<p>I wasn't so lucky. How come it can't unify v with B x y + C x y? What more<br>\ndo I need?</p>\n<p>Thanks again<br>\nJohn</p>\n<p>On Wed, Sep 2, 2009 at 10:03 AM, Peter Lammich &lt;<br>\n<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt; wrote:</p>\n<blockquote>\n<p>John Munroe wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I got a question about types for variables: can they have types? For<br>\nexample, if I want to prove if a binary function that takes in a Natural</p>\n<p>and</p>\n</blockquote>\n<blockquote>\n<p>an Integer can be instantiated:</p>\n<p>consts<br>\nF :: \"[nat,int] =&gt; int\"<br>\naxioms<br>\nax: \"F p t = G p t\"</p>\n<p>lemma lem1: \"EX f.f x y = G p t\"<br>\nusing ax</p>\n<p>Isabelle infers the type automatically to the most generic type in an<br>\nML-like fashion.<br>\nYou can constrain the type of any expression and variable by:<br>\n exp :: type, i.e.<br>\n EX f :: nat =&gt; int =&gt; int. f x y = G p t</p>\n</blockquote>\n<p>the types of x and y are then inferred automatically to nat and int.<br>\nUsually you will have to put parenthesis around the type constraint, i.e.<br>\n EX f. f (x::nat) (y::int) = G p t</p>\n<p>If you are unsure about the actual types, activate the option \"Show<br>\ntypes\" (In the Isabelle-&gt;Settings menu of PG)</p>\n<p>Hope this helps,<br>\n  Peter</p>\n<blockquote>\n<p>where f should be typed (perhaps x and y as well).</p>\n<p>Thanks very much<br>\nJohn</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294082707,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831204
    },
    {
        "content": "<p>From: Christian Doczkal &lt;<a href=\"mailto:c.doczkal@stud.uni-saarland.de\">c.doczkal@stud.uni-saarland.de</a>&gt;<br>\nHello</p>\n<p>The free variable is to become a free/schematic variable of the theorem.<br>\nHence its logically some arbitrary but fixed value which need not be<br>\nrelated to B and C.</p>\n<p>On the other hand the claim is trivially true since there is the<br>\nconstant v function (% is a lambda)</p>\n<p>lemma lem2: \"EX func x y. func x y = v\"<br>\napply (rule exI[where x=\"% x y . v\"])<br>\nby simp<br>\n<a href=\"/user_uploads/14278/dvmnHc9XwB2OKdGfgm_RbTlR/smime.p7s\">smime.p7s</a></p>",
        "id": 294082829,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831235
    },
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@googlemail.com\">munddr@googlemail.com</a>&gt;<br>\nHi,</p>\n<p>I got a question about types for variables: can they have types? For<br>\nexample, if I want to prove if a binary function that takes in a Natural and<br>\nan Integer can be instantiated:</p>\n<p>consts<br>\nF :: \"[nat,int] =&gt; int\"<br>\naxioms<br>\nax: \"F p t = G p t\"</p>\n<p>lemma lem1: \"EX f.f x y = G p t\"<br>\nusing ax</p>\n<p>where f should be typed (perhaps x and y as well).</p>\n<p>Thanks very much<br>\nJohn</p>",
        "id": 294084043,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831590
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nJohn Munroe wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I got a question about types for variables: can they have types? For<br>\nexample, if I want to prove if a binary function that takes in a Natural and<br>\nan Integer can be instantiated:</p>\n<p>consts<br>\nF :: \"[nat,int] =&gt; int\"<br>\naxioms<br>\nax: \"F p t = G p t\"</p>\n<p>lemma lem1: \"EX f.f x y = G p t\"<br>\nusing ax</p>\n<p>Isabelle infers the type automatically to the most generic type in an<br>\nML-like fashion.<br>\nYou can constrain the type of any expression and variable by:<br>\n  exp :: type, i.e.<br>\n  EX f :: nat =&gt; int =&gt; int. f x y = G p t</p>\n</blockquote>\n<p>the types of x and y are then inferred automatically to nat and int.<br>\nUsually you will have to put parenthesis around the type constraint, i.e.<br>\n  EX f. f (x::nat) (y::int) = G p t</p>\n<p>If you are unsure about the actual types, activate the option \"Show<br>\ntypes\" (In the Isabelle-&gt;Settings menu of PG)</p>\n<p>Hope this helps,<br>\n  Peter</p>\n<blockquote>\n<p>where f should be typed (perhaps x and y as well).</p>\n<p>Thanks very much<br>\nJohn<br>\n</p>\n</blockquote>",
        "id": 294084256,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831657
    }
]