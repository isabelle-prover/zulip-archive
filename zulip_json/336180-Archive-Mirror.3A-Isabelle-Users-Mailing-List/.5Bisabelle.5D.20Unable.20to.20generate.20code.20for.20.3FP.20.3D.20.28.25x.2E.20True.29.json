[
    {
        "content": "<p>From: Duraid Madina &lt;<a href=\"mailto:duraid@kinoko.c.u-tokyo.ac.jp\">duraid@kinoko.c.u-tokyo.ac.jp</a>&gt;<br>\nI was expecting a bool from the following, but instead got the error in the subject:</p>\n<div class=\"codehilite\" data-code-language=\"Isabelle\"><pre><span></span><code><span class=\"k\">theory</span> <span class=\"n\">odd</span> <span class=\"kp\">imports</span> <span class=\"n\">Primes</span> <span class=\"k\">begin</span>\n\n<span class=\"k\">definition</span>\n  <span class=\"n\">m_cond</span> <span class=\"o\">::</span> <span class=\"s\">\"nat =&gt; (nat =&gt; nat) =&gt; bool\"</span> <span class=\"kp\">where</span>\n  <span class=\"s\">\"m_cond n mf =</span>\n<span class=\"s\">    ((ALL i. i &lt;= n --&gt; 0 &lt; mf i) &amp;</span>\n<span class=\"s\">     (ALL i j. i &lt;= n &amp; j &lt;= n &amp; i ~= j</span>\n<span class=\"s\">   --&gt; gcd (mf i, mf j) = 1))\"</span>\n\n<span class=\"kt\">value</span> <span class=\"s\">\"m_cond 1 (%x. 3)\"</span>\n</code></pre></div>\n<p>Am I doing something evil here?</p>\n<p>Duraid</p>",
        "id": 294068202,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826211
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nUniversal quantifiers are not executable. The only exception are bounded<br>\nquantifiers of the form \"Q x : A\" where A is one of two kinds of sets:<br>\neither a set interval, eg {0..n::nat}, or a set coming from a list, eg<br>\n\"set xs\". Formulas \"ALL x. x &lt; n --&gt; ...\" are not recognized as<br>\nexecutable. You have to rewrite them into the set interval form:</p>\n<p>definition<br>\n  m_cond :: \"nat =&gt; (nat =&gt; nat) =&gt; bool\" where<br>\n  \"m_cond n mf =<br>\n    ((ALL i : {0..n}. 0 &lt; mf i) &amp;<br>\n     (ALL i : {0..n}. ALL j : {0..n}. i ~= j<br>\n   --&gt; gcd (mf i, mf j) = 1))\"</p>\n<p>Now</p>\n<p>value \"m_cond 1 (%x. 3)\"</p>\n<p>returns \"false\".</p>\n<p>Note: you must import the theory \"Executable_Set\" for this to work!</p>\n<p>Regards<br>\nTobias</p>\n<p>Duraid Madina wrote:</p>",
        "id": 294068365,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826278
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHere is how you would go about it if you wanted to make \"ALL i&lt;=n\"<br>\nexecutable directly. You define your own recursive function all_upto,<br>\nprove that it behaves the same as ALL, and make that a code lemma that<br>\nreplaces such bounded quantifiers by all_upto:</p>\n<p>primrec all_upto :: \"(nat  bool)  nat  bool\" where<br>\n\"all_upto P 0 = P 0\" |<br>\n\"all_upto P (Suc n) = (P(Suc n) &amp; all_upto P n)\"</p>\n<p>lemma all_Suc: \"(ALL i&lt;=Suc n. P i) = (P(Suc n) &amp; (ALL i&lt;=n. P i))\"<br>\nby (auto simp:le_Suc_eq)</p>\n<p>lemma [code unfold]: \"(ALL i&lt;=n. P i) = all_upto P n\"<br>\nby (induct n) (simp_all add:all_Suc)</p>\n<p>Now you don't need Executable_Set (and need to change m_cond only a little).</p>\n<p>Regards<br>\nTobias</p>\n<p>PS If you want to extract efficient code, import Efficient_Nat: it<br>\nimplements nat by int.</p>\n<p>Duraid Madina wrote:</p>",
        "id": 294068547,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826346
    },
    {
        "content": "<p>From: Duraid Madina &lt;<a href=\"mailto:duraid@kinoko.c.u-tokyo.ac.jp\">duraid@kinoko.c.u-tokyo.ac.jp</a>&gt;<br>\nMany thanks - this is very good to know. I got over some hurdles, but soon<br>\nran into existential quantifiers. My attempts to get these executable<br>\nfailed, so I'd like to ask:</p>\n<p>- What can be said in the case of making a 'SOME' executable?</p>\n<p>- Suppose one has a lemma which proves a unique integer exists satisfiying<br>\n    some properties, given some preconditions. How could one add an<br>\n    appropriate \"code lemma\"? (To get, say, the function which returns the<br>\n    unique integer when the preconditions are met and zero otherwise.)</p>\n<p>Thanks again,</p>\n<p>Duraid</p>",
        "id": 294068906,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826481
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Many thanks - this is very good to know. I got over some hurdles, but soon<br>\nran into existential quantifiers.</p>\n</blockquote>\n<p>EX is completely dual to ALL, also w.r.t. code generation.</p>\n<blockquote>\n<p>- What can be said in the case of making a 'SOME' executable?</p>\n</blockquote>\n<p>Tricky. Of course in general you cannot. But even if everything inside<br>\nthe SOME is executable, non-uniqueness (esp for \"SOME x. False\") almost<br>\nalways rule out replacing the some by a logically equivalent term. You<br>\nusually have to resort to extra-logical means. For example, in our Jinja<br>\nwork we implemented \"%S. SOME x. x : S\" by the ML function \"hd\" on lists:</p>\n<p>definition<br>\n  some_elem :: \"'a set =&gt; 'a\"<br>\n  \"some_elem == (%S. SOME x. x : S)\"</p>\n<p>consts_code<br>\n  \"some_elem\" (\"hd\")</p>\n<p>The const_code statement is outside the logic and it is your<br>\nresponsibility that hd is a correct implementation of some_elem!</p>\n<blockquote>\n<p>- Suppose one has a lemma which proves a unique integer exists satisfiying<br>\n    some properties, given some preconditions. How could one add an<br>\n    appropriate \"code lemma\"? (To get, say, the function which returns the<br>\n    unique integer when the preconditions are met and zero otherwise.)</p>\n</blockquote>\n<p>In that case I would avoid working with SOME in the first place. Use<br>\nTHE. And if you want to generate code: don't even use THE, define the<br>\nfunction explicitly. For example, if the element can be found by a<br>\nsearch over some interval:</p>\n<p>fun search where<br>\n\"search i j = (if i&lt;j then if p i then f i else search (i+1) j else 0)\"</p>\n<p>Then prove that search has the properties you want and use search where<br>\nyou would have used SOME.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Thanks again,</p>\n<p>Duraid</p>\n<p>On Tue, Nov 04, 2008 at 11:47:24AM +0100, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Universal quantifiers are not executable. The only exception are bounded<br>\nquantifiers of the form \"Q x : A\" where A is one of two kinds of sets:<br>\neither a set interval, eg {0..n::nat}, or a set coming from a list, eg<br>\n\"set xs\". Formulas \"ALL x. x &lt; n --&gt; ...\" are not recognized as<br>\nexecutable. You have to rewrite them into the set interval form:</p>\n<p>definition<br>\n  m_cond :: \"nat =&gt; (nat =&gt; nat) =&gt; bool\" where<br>\n  \"m_cond n mf =<br>\n    ((ALL i : {0..n}. 0 &lt; mf i) &amp;<br>\n     (ALL i : {0..n}. ALL j : {0..n}. i ~= j<br>\n   --&gt; gcd (mf i, mf j) = 1))\"</p>\n<p>Now</p>\n<p>value \"m_cond 1 (%x. 3)\"</p>\n<p>returns \"false\".</p>\n<p>Note: you must import the theory \"Executable_Set\" for this to work!</p>\n<p>Regards<br>\nTobias</p>\n<p>Duraid Madina wrote:</p>\n<blockquote>\n<p>I was expecting a bool from the following, but instead got the error in the subject:</p>\n<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>\ntheory odd imports Primes begin</p>\n<p>definition<br>\n  m_cond :: \"nat =&gt; (nat =&gt; nat) =&gt; bool\" where<br>\n  \"m_cond n mf =<br>\n    ((ALL i. i &lt;= n --&gt; 0 &lt; mf i) &amp;<br>\n     (ALL i j. i &lt;= n &amp; j &lt;= n &amp; i ~= j<br>\n   --&gt; gcd (mf i, mf j) = 1))\"</p>\n<p>value \"m_cond 1 (%x. 3)\"<br>\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>\n<p>Am I doing something evil here?</p>\n<p>Duraid<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294068950,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826499
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nTobias Nipkow wrote:<br>\nI forgot to add that this is inconsistent from a logical point of view:<br>\nit allows you to derive (via the ML level) that \"some_elem {1,2} ~=<br>\nsome_elem {2,1}\". So beware of what you are doing when implementing SOME<br>\nby hand.</p>\n<p>Tobias</p>",
        "id": 294068962,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826505
    }
]