[
    {
        "content": "<p>From: Wilmer RICCIOTTI &lt;<a href=\"mailto:Wilmer.Ricciotti@irit.fr\">Wilmer.Ricciotti@irit.fr</a>&gt;<br>\nHi all,</p>\n<p>as a beginner in the use of Isabelle/Isar, I have every day numerous clashes with the Isar way of proving theorems. The strangest one to date is related to proving an existentially quantified formula when you have the same formula with an explicit witness as a hypothesis. That is to say, something similar to this lemma:</p>\n<p>lemma fie : \"P a ⟶ (∃b.(P b))\"<br>\n  proof<br>\n    assume ha : \"P a\"<br>\n    thus \"∃b.(P b)\"..<br>\n  qed</p>\n<p>Unsurprisingly, this proof doesn't pose any challenge at all. However I can slightly complicate the formula by means of a definition, and this obvious proof technique won't work any more. Specifically, I define </p>\n<p>definition bijection :: \"('a ⇒ 'b) ⇒ bool\" where<br>\n    \"bijection f = (∀y::'b.∃!x::'a. y = f x)\"</p>\n<p>and then the same proof as before, with bijection in place of a generic P, fails:</p>\n<p>lemma foo : \"bijection (g::'a ⇒ 'b) ⟶ (∃ f.(bijection (f::'a ⇒ 'b)))\"<br>\n  proof<br>\n    assume hg : \"bijection (g::'a ⇒ 'b)\"<br>\n    thus \"∃f.(bijection f)\"..<br>\n  qed</p>\n<p>replacing the implicit \"..\" with an explicit \"proof (rule exI)\" fails similarly, leaving me quite puzzled.<br>\n(Un)Interestingly, since \"foo\" is an instance of \"fie\", we can easily prove it using \"by (rule fie)\" and nothing else. However this feels more like a trick to make things work than a solution.</p>\n<p>What am I doing wrong?</p>\n<p>Best,</p>",
        "id": 294245633,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908794
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>the behaviour of \"rule\" in the presence of premises is something that I<br>\nhave not and will probably never understand.</p>\n<p>You can replace the \"..\" with a \"by (rule_tac exI)\" or a \"by (intro<br>\nexI)\" and that works fine. Personally, I usually prefer the good old \"by<br>\nblast\" in these cases. Another thing that would work is \"from exI[OF<br>\nthis] show \"∃b.(P b)\" .\"</p>\n<p>As for the reason that rule fails here but rule_tac works, that is<br>\nsomething from the depths of the internals of Isabelle that are far<br>\noutside my area of expertise.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294245637,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908796
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Wilmer,</p>\n<p>I often run into the same problem ;) which is that things are too <br>\npolymorphic.</p>\n<blockquote>\n<p>lemma foo : \"bijection (g::'a ⇒ 'b) ⟶ (∃ f.(bijection (f::'a ⇒ 'b)))\"<br>\n proof<br>\n   assume hg : \"bijection (g::'a ⇒ 'b)\"<br>\n   thus \"∃f.(bijection f)\"..<br>\nIn this line, check the type of \"f\" (e.g., Ctrl+hover in jEdit) which <br>\noutputs:</p>\n</blockquote>\n<p>bound \"f\"<br>\n   bound variable<br>\n   :: 'c ⇒ 'd</p>\n<p>i.e., the types of \"f\" and \"g\" do not match. (Try to give f an explicit <br>\ntype in the binder.)</p>\n<p>hope this helps,</p>\n<p>chris</p>",
        "id": 294245653,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908802
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo Christian,</p>\n<p>Are you quite sure about this? On my system, all occurences of \"f\" and<br>\n\"g\" are displayed as having type \"'a ⇒ 'b\". I don't see how it could be<br>\nany other way, seeing as bijection is a free variable and the assertion<br>\nforces \"bijection\" to have the type \"('a ⇒ 'b) ⇒ bool\", which in turn<br>\nforces the bound f in the \"thus statement\" to be of type \"'a ⇒ 'b\" as well.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294245672,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908808
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Manuel,</p>\n<p>as far as I see \"bijjection\" is not a free variable, it was defined by <br>\nWilmer. But you are write that my suggestion does not solve to problem. <br>\nRather he would have to combine our two mails ;)</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294245695,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908822
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nOh my, I must have missed that. Yes, in these cases, it is best to<br>\nannotate variables in binders. If one does not know where the problem<br>\ncomes from in these cases, it can also be a good idea to enable the<br>\nunification trace, which shows exactly why a role could not be applied;<br>\nin this case, probably a clash between the free type variables.</p>\n<p>But be that as it may, even when one does annotate the bound variable,<br>\n\"..\" still does not work, which then brings us back to what I said in my<br>\nfirst reply. :)</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294245705,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908826
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nYes. That's what I wanted to say with \"combine our two mails\". -cheers chris</p>\n<p>For the record: I also find this behavior of \"..\"/\"rule\"/... vs. <br>\n\"rule_tac\"/\"blast\"/... strange.</p>",
        "id": 294245723,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908833
    },
    {
        "content": "<p>From: Stephan Merz &lt;<a href=\"mailto:Stephan.Merz@loria.fr\">Stephan.Merz@loria.fr</a>&gt;<br>\nIn order to answer Wilmer's original question explicitly: your second lemma can be proved using baby-steps as follows.</p>\n<p>lemma foo : \"bijection (g::'a ⇒ 'b) ⟶ (∃ f.(bijection (f::'a ⇒ 'b)))\"<br>\nproof<br>\n  assume hg : \"bijection (g::'a ⇒ 'b)\"<br>\n  thus \"∃(f::'a ⇒ 'b).(bijection f)\" <br>\n    apply (intro exI)<br>\n    apply assumption<br>\n    done<br>\nqed</p>\n<p>Observe that you also have to type-constrain the bound variable in \"thus\", and that (as noted by Christian and Manuel) \"..\" (or equivalently \"apply (rule exI)\"), which applies the rule in elim-resolution mode fail due to somewhat inscrutable issues of type resolution.</p>\n<p>Of course, you'd typically apply automatic proof methods such as auto or blast that do the job.</p>\n<p>Stephan</p>",
        "id": 294245736,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908839
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI looked through the relevant parts of the Isabelle source code just now<br>\nand all I could find was something called \"Pattern.trace_unify_fail\".<br>\nThis option seems to be exposed in Proof General through the menu, but<br>\nin jEdit, nothing like that seems to exist. There doesn't seem to be a<br>\nconfiguration attribute either, so that one could do something like<br>\n\"declare [[trace_unify]]\".</p>\n<p>However, as a workaround, you can do this in jEdit:</p>\n<p>ML {*  Pattern.trace_unify_fail := true *}</p>\n<p>If you then try an \"apply (rule exI)\", you get the following error message:</p>\n<p>The following types do not unify:<br>\n('a ⇒ 'b) ⇒ bool<br>\n('c ⇒ 'd) ⇒ bool</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294245789,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908845
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 18 Jul 2013, Wilmer RICCIOTTI wrote:</p>\n<blockquote>\n<p>as a beginner in the use of Isabelle/Isar, I have every day numerous <br>\nclashes with the Isar way of proving theorems. The strangest one to date <br>\nis related to proving an existentially quantified formula when you have <br>\nthe same formula with an explicit witness as a hypothesis. That is to <br>\nsay, something similar to this lemma:</p>\n<p>lemma fie : \"P a ⟶ (∃b.(P b))\"<br>\n proof<br>\n   assume ha : \"P a\"<br>\n   thus \"∃b.(P b)\"..<br>\n qed</p>\n</blockquote>\n<p>First this basic example in canonical form:</p>\n<p>lemma \"P a ⟶ (∃b. P b)\"<br>\n   proof<br>\n     assume \"P a\"<br>\n     then show \"∃b. P b\" ..<br>\n   qed</p>\n<p>Notes:</p>\n<p>* No need to invent funny names for things that are never refered by<br>\n     name.  The empty name is fine by default.  (If you do need names for<br>\n     intermediate facts, you can use <em>, <strong>, </strong></em>, or 1, 2, 3, until you get<br>\n     better ideas.  There is no need for Ha, Hb, Hc seen in other provers.</p>\n<p>* 'thus' is an an old-fahsioned abbreviation, for people who like typing<br>\n     more than necessary (paradoxically).  It is better to use explicit<br>\n     \"then show\" to make clear to yourself and the reader of the proof that<br>\n     something is happening here: forward chaining of facts towards a goal.<br>\n     Thus the subsequent \"rule\" step will first consume the facts, reducing<br>\n     the rule by applying it to a prefix of its premises, and then apply<br>\n     the remaining rule to the goal.</p>\n<p>* \".\" and \"..\" are full proofs in their own right, just like \"by<br>\n     method\".  So you should put a space there, and not imitate terminators<br>\n     seen in other provers.</p>\n<p>* Placing parentheses within the term language correctly requires a bit<br>\n     of experience with the syntax.  It is fine to put redundant<br>\n     parentheses there as a start, but I've made it precise in the example<br>\n     to avoid obscuring the situation for people who are versed in the<br>\n     syntax.</p>\n<blockquote>\n<p>Unsurprisingly, this proof doesn't pose any challenge at all. However I <br>\ncan slightly complicate the formula by means of a definition, and this <br>\nobvious proof technique won't work any more. Specifically, I define</p>\n<p>definition bijection :: \"('a ⇒ 'b) ⇒ bool\" where<br>\n   \"bijection f = (∀y::'b.∃!x::'a. y = f x)\"</p>\n<p>and then the same proof as before, with bijection in place of a generic P, fails:</p>\n<p>lemma foo : \"bijection (g::'a ⇒ 'b) ⟶ (∃ f.(bijection (f::'a ⇒ 'b)))\"<br>\n proof<br>\n   assume hg : \"bijection (g::'a ⇒ 'b)\"<br>\n   thus \"∃f.(bijection f)\"..<br>\n qed</p>\n</blockquote>\n<p>Here you try to make an existential introduction of a thing of function <br>\ntype.  Due to the way Larry implemented HO unification some decades ago, <br>\nthis does not work in the compositional manner required by Isar.  So here <br>\nis my slightly awkward proof (again in somewhat standard form):</p>\n<p>definition bijection :: \"('a ⇒ 'b) ⇒ bool\"<br>\n   where \"bijection f ⟷ (∀y. ∃!x. y = f x)\"</p>\n<p>lemma \"bijection (g::'a ⇒ 'b) ⟶ (∃f::'a ⇒ 'b. bijection f)\"<br>\nproof<br>\n   assume \"bijection g\"<br>\n   then show \"∃f::'a ⇒ 'b. bijection f\" by (rule exI [of _ g])<br>\nqed</p>\n<p>Note that there are two snags:</p>\n<p>* The inner \"show\" needs to be precise about the types, because there is<br>\n     no syntactic connection to the surrounding context: bound variable \"f\"<br>\n     and global constant \"bijection\" are not constrained in any way by what<br>\n     the proof text contains so far, so they would get a surprisingly<br>\n     general type due to Milner type-inference, if the constraint on f is<br>\n     omitted.</p>\n<p>As a rule of thumb, when something <em>should</em> unify but doesn't, types<br>\n     are too general.  Isabelle/jEdit makes it relatively easy these days<br>\n     to inspect the situation via the usual hovering.  (I still need to<br>\n     work out a color scheme to hilight such situations directly in the<br>\n     Prover IDE.)</p>\n<p>* Actual HO unification imcompleteness, which is a relevatively rare<br>\n     incident.  It is a tiny imperfection of Isabelle/Pure for the use of<br>\n     structured proof checking in Isabelle/Isar.  I've tried to convince<br>\n     Larry to address that in 1998 already, but it is unrealistic to touch<br>\n     this delicate part of Isabelle again.</p>\n<p>To keep this thread interesting, and about actual Isar, here is another <br>\nversion of the example to be considered:</p>\n<p>lemma<br>\n   fixes g :: \"'a ⇒ 'b\"<br>\n   assumes \"bijection g\"<br>\n   obtains f :: \"'a ⇒ 'b\" where \"bijection f\"<br>\n   using assms ..</p>\n<p>Makarius</p>",
        "id": 294245805,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908851
    },
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:rene.neumann@in.tum.de\">rene.neumann@in.tum.de</a>&gt;<br>\nAm 19.07.2013 18:48, schrieb Makarius:</p>\n<blockquote>\n<p>* 'thus' is an an old-fahsioned abbreviation,<br>\nWhen did this become 'old-fashioned'?</p>\n</blockquote>\n<blockquote>\n<p>for people who like typing more than necessary (paradoxically).</p>\n</blockquote>\n<p>|'th&lt;TAB&gt;&lt;space&gt;sh&lt;TAB&gt;'| = 7<br>\n|'thus'| = 4</p>\n<p>Not counting the time it takes to wait before autocompletion mechanisms<br>\ncan be used (ie small delay before each &lt;TAB&gt;)</p>\n<ul>\n<li>René<br>\n<a href=\"/user_uploads/14278/-YvhzDZJ_l2HIWV5dsFosHZY/smime.p7s\">smime.p7s</a></li>\n</ul>",
        "id": 294245815,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908858
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 19 Jul 2013, René Neumann wrote:</p>\n<blockquote>\n<p>Am 19.07.2013 18:48, schrieb Makarius:</p>\n<blockquote>\n<p>* 'thus' is an an old-fahsioned abbreviation,<br>\nWhen did this become 'old-fashioned'?</p>\n</blockquote>\n</blockquote>\n<p>Many years ago.  It goes back to an old draft of Isar, which was derived <br>\nfrom Mizar and the Mizar mode for HOL, before 'then' was introduced as a <br>\nstandalone Isar primitive.</p>\n<p>Did you ever wonder why there is no conflation of \"then obtain\"?</p>\n<blockquote>\n<blockquote>\n<p>for people who like typing more than necessary (paradoxically).</p>\n</blockquote>\n<p>|'th&lt;TAB&gt;&lt;space&gt;sh&lt;TAB&gt;'| = 7<br>\n|'thus'| = 4</p>\n<p>Not counting the time it takes to wait before autocompletion mechanisms<br>\ncan be used (ie small delay before each &lt;TAB&gt;)</p>\n</blockquote>\n<p>The extra typing happens when you change your structured goal <br>\nspecfications back and forth several times, e.g.</p>\n<p>then have<br>\n   from blah have<br>\n   with blah have</p>\n<p>The form with 'then' saves typing for experts and is more easy to <br>\nunderstand for readers of the text.  Isar is very compositional by design, <br>\nmore than Mizar in that respect.</p>\n<p>Makarius</p>",
        "id": 294245821,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908863
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDon't worry, it is alive and kicking.</p>\n<p>Tobias</p>",
        "id": 294245830,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908869
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nHi Wilmer,</p>\n<p>Makarius has precisely identified the problem: Unification has trouble<br>\nwhen proving the existence of something with a function type. I have<br>\ncome across this exact problem several times before; below is the<br>\nworkaround that I have used.</p>\n<p>lemma \"bijection (g::'a ⇒ 'b) ⟶ (∃f::'a ⇒ 'b. bijection f)\"<br>\nproof<br>\n   assume \"bijection g\"<br>\n   then show \"∃f::'a ⇒ 'b. bijection f\" by - (rule exI)<br>\nqed</p>\n<p>The \"-\" method serves to turn \"bijection g\" from a chained fact into<br>\nan ordinary assumption in the proof goal; this then affects how the<br>\n\"rule\" method does unification. (Writing \"by - rule\" will also work.)</p>\n<p>Grep the Isabelle sources for \"by - (rule exI)\" to see all the places<br>\nI've had to use this trick: Some examples involve proving countability<br>\nof types, showing goals of the form \"∃f::'a ⇒ nat. inj f\". Other<br>\nexamples occur in HOLCF when proving instances of class \"bifinite\",<br>\nwhich asserts the existence of a function with certain properties.</p>\n<p>The same trick used to be necessary for proving things of the form<br>\n\"∃A::'a set. P A\", during the period when \"'a set\" was an abbreviation<br>\nfor \"'a =&gt; bool\". This is no longer the case, but you can still find<br>\none or two leftover examples of \"by - (rule exI)\" in<br>\nMultivariate_Analysis.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294245836,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908876
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAccording to canonical jargon on this mailing list, \"old fashioned\" means <br>\nit is not even \"legacy\" yet.  It just means old-fashioned.</p>\n<p>Nonetheless, there is no reason to encumber new learners of Isar with old <br>\nhabits drawn from Mizar.  The latter cannot even use \"then obtain ...\" or <br>\n\"obtain ... then\".  I also want to do Mizar justice in avoiding confusion <br>\nof its \"hence\" and \"thus\" that have a quite different meaning there.</p>\n<p>Makarius</p>",
        "id": 294245862,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908887
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 19 Jul 2013, Brian Huffman wrote:</p>\n<blockquote>\n<blockquote>\n<p>lemma \"bijection (g::'a ⇒ 'b) ⟶ (∃f::'a ⇒ 'b. bijection f)\"<br>\nproof<br>\n  assume \"bijection g\"<br>\n  then show \"∃f::'a ⇒ 'b. bijection f\" by (rule exI [of _ g])<br>\nqed</p>\n</blockquote>\n<p>lemma \"bijection (g::'a ⇒ 'b) ⟶ (∃f::'a ⇒ 'b. bijection f)\"<br>\nproof<br>\n  assume \"bijection g\"<br>\n  then show \"∃f::'a ⇒ 'b. bijection f\" by - (rule exI)<br>\nqed</p>\n<p>The \"-\" method serves to turn \"bijection g\" from a chained fact into<br>\nan ordinary assumption in the proof goal; this then affects how the<br>\n\"rule\" method does unification. (Writing \"by - rule\" will also work.)</p>\n</blockquote>\n<p>For practical purposes, the \"by - rule\" form is indeed better.  My more <br>\nugly variant above stays formally within structured rule application of <br>\nIsar, but its need of instantiation is not nice.</p>\n<p>BTW, the 'by' command has these two slots: initial method and terminal <br>\nmethod.  There is a difference in handling of chained facts, so</p>\n<p>by method1 method2</p>\n<p>is conceptionally (and operationally) different from</p>\n<p>by (method1, method2)   -- improper</p>\n<p>Normally one should only show the good examples to imitate, but<br>\n\"by (cases, auto)\" is seen a bit too often in examples, where \"by cases auto\" <br>\nwas meant by the writer of the text.</p>\n<blockquote>\n<p>The same trick used to be necessary for proving things of the form<br>\n\"∃A::'a set. P A\", during the period when \"'a set\" was an abbreviation<br>\nfor \"'a =&gt; bool\".</p>\n</blockquote>\n<p>Gladly that episode is history.  It was known beforehand that such issues <br>\nwould follow from that experiment, because Larry or Tobias had introduced <br>\nthe explicit 'a set type exactly to prevent HO unification problems, <br>\nalthough it was before recorded history.</p>\n<p>Makarius</p>",
        "id": 294245874,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908894
    }
]