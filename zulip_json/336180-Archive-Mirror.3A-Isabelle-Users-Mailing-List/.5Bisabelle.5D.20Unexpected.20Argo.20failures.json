[
    {
        "content": "<p>From: Mikhail Mandrykin &lt;<a href=\"mailto:mandrykin@ispras.ru\">mandrykin@ispras.ru</a>&gt;<br>\nHello!</p>\n<p>A bit of context: We are currently experimenting with an approach to <br>\nmore reliable SMT proof replay in Isabelle/HOL with the aim to later <br>\napply it to low-level code verification, where there are typically many <br>\nsimilar and fairly uninteresting goals that can be easily discharged by <br>\nSMT. The approach is based on deterministic quantifier instantiation in <br>\nIsabelle/HOL itself, so that the solver is provided with a <br>\nquantifier-free problem, which is always decidable, making the proof <br>\nreplay very stable and even enabling partial model resonstruction of <br>\ncounterexamples (a preliminary description, if interesting:<br>\n<a href=\"https://forge.ispras.ru/attachments/download/7602/TSMT_Tutorial.pdf\">https://forge.ispras.ru/attachments/download/7602/TSMT_Tutorial.pdf</a><br>\nbut for now the reconstruction of deterministic one-liners from normal <br>\nSMT proofs is not yet properly implemented (requires manual efforts)). <br>\nSo, naturally, we explored the possibility to replay the proofs within <br>\nIsabelle/HOL itself using its internal solvers such as Metis and Argo <br>\n(for the fragment without linear integer arithmetic). While we had some <br>\nsuccess with Metis+our instantiation (although it's not consistently <br>\nfaster than SMT proof replay), we encountered unexpected failures in <br>\nArgo, particularly in its congruence closure propagation. I prepared a <br>\nsample theory<br>\n<a href=\"https://gist.github.com/schrodibear/fbe8c2224291e45c9e51c3b812746a46\">https://gist.github.com/schrodibear/fbe8c2224291e45c9e51c3b812746a46</a><br>\n(for some reason, the list rejected this inlined in the message) with <br>\ntwo goals, where Argo fails with an unexpected exception. The second <br>\ngoal is in fact valid and can be discharged with Metis. A more general <br>\nquestion is where is it appropriate to reports such problems and whether <br>\nArgo is maintained in the upstream or it would be reasonable to try <br>\ninvestigating this ourselves and possibly suggest a patch. The Isabelle <br>\nversion is Isabelle2020, current development version seems to not have <br>\nany changes in Argo since then</p>\n<p>Regards,<br>\nMikhail</p>",
        "id": 294830196,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246271
    },
    {
        "content": "<p>From: Jasmin Blanchette via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nDear Mikhail,</p>\n<blockquote>\n<p>A bit of context: We are currently experimenting with an approach to more reliable SMT proof replay in Isabelle/HOL with the aim to later apply it to low-level code verification, where there are typically many similar and fairly uninteresting goals that can be easily discharged by SMT. The approach is based on deterministic quantifier instantiation in Isabelle/HOL itself, so that the solver is provided with a quantifier-free problem, which is always decidable, making the proof replay very stable and even enabling partial model resonstruction of counterexamples (a preliminary description, if interesting:<br>\n<a href=\"https://forge.ispras.ru/attachments/download/7602/TSMT_Tutorial.pdf\">https://forge.ispras.ru/attachments/download/7602/TSMT_Tutorial.pdf</a></p>\n</blockquote>\n<p>This sounds very interesting. Most of the issues we have appear to be related to Z3's incomplete quantifier instantiation. CVC4 finds a proof using different (probably incomplete) heuristics and Z3 just seems not to find the same quantifiers. I was always afraid an approach based on instantiation would be too verbose (in the output), but now I've changed my mind: Most lemmas are probably used only with one instantiation anyway. It's worth trying anyway.</p>\n<blockquote>\n<p>The second goal is in fact valid and can be discharged with Metis.</p>\n</blockquote>\n<p>I'd expect Metis to, in principle, always terminate on such ground goals. I say \"in principle\" because it had some completeness bugs, but we're working right now on updating Metis in Isabelle to reflect the latest version.</p>\n<blockquote>\n<p>A more general question is where is it appropriate to reports such problems and whether Argo is maintained in the upstream or it would be reasonable to try investigating this ourselves and possibly suggest a patch. The Isabelle version is Isabelle2020, current development version seems to not have any changes in Argo since then</p>\n</blockquote>\n<p>Argo's developer and maintainer is Sascha B√∂hme (in CC:). He's in industry now and I don't know how responsive he will be. But do check with him first, and failing that, I would propose you investigate it yourself and send me a patch. (When Sascha left, I inherited some of his code, including \"smt\", but \"argo\" is a tool he developed afterwards as a hobby and I don't know it at all.)</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294830283,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246301
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 06/07/2020 08:37, Jasmin Blanchette via Cl-isabelle-users wrote:</p>\n<blockquote>\n<p>Dear Mikhail,</p>\n<blockquote>\n<p>A bit of context: We are currently experimenting with an approach to more reliable SMT proof replay in Isabelle/HOL with the aim to later apply it to low-level code verification, where there are typically many similar and fairly uninteresting goals that can be easily discharged by SMT. The approach is based on deterministic quantifier instantiation in Isabelle/HOL itself, so that the solver is provided with a quantifier-free problem, which is always decidable, making the proof replay very stable and even enabling partial model resonstruction of counterexamples (a preliminary description, if interesting:<br>\n<a href=\"https://forge.ispras.ru/attachments/download/7602/TSMT_Tutorial.pdf\">https://forge.ispras.ru/attachments/download/7602/TSMT_Tutorial.pdf</a></p>\n</blockquote>\n<p>This sounds very interesting. Most of the issues we have appear to be related to Z3's incomplete quantifier instantiation. CVC4 finds a proof using different (probably incomplete) heuristics and Z3 just seems not to find the same quantifiers. I was always afraid an approach based on instantiation would be too verbose (in the output), but now I've changed my mind: Most lemmas are probably used only with one instantiation anyway. It's worth trying anyway.</p>\n</blockquote>\n<p>A general suggestion for sledgehammer: whenever I try to understand a metis <br>\nproof found by s/h, I wish s/h would instantiate the lemmas (a little bit) <br>\nexplicitly because it makes it so much easier to figure out the proof as a <br>\nhuman. Maybe it could be an option and would work only in a proper context where <br>\nthe variable names have been fixed.</p>\n<p>Just one of these things it would be nice to have if the s/h developers had <br>\nunbounded time ;-)</p>\n<p>Tobias</p>\n<blockquote>\n<blockquote>\n<p>The second goal is in fact valid and can be discharged with Metis.</p>\n</blockquote>\n<p>I'd expect Metis to, in principle, always terminate on such ground goals. I say \"in principle\" because it had some completeness bugs, but we're working right now on updating Metis in Isabelle to reflect the latest version.</p>\n<blockquote>\n<p>A more general question is where is it appropriate to reports such problems and whether Argo is maintained in the upstream or it would be reasonable to try investigating this ourselves and possibly suggest a patch. The Isabelle version is Isabelle2020, current development version seems to not have any changes in Argo since then</p>\n</blockquote>\n<p>Argo's developer and maintainer is Sascha B√∂hme (in CC:). He's in industry now and I don't know how responsive he will be. But do check with him first, and failing that, I would propose you investigate it yourself and send me a patch. (When Sascha left, I inherited some of his code, including \"smt\", but \"argo\" is a tool he developed afterwards as a hobby and I don't know it at all.)</p>\n<p>Cheers,</p>\n<p>Jasmin</p>\n<p><a href=\"/user_uploads/14278/AIa3a-NclH7ozybH4dbRvDAG/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294830292,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246308
    },
    {
        "content": "<p>From: Mikhail Mandrykin &lt;<a href=\"mailto:mandrykin@ispras.ru\">mandrykin@ispras.ru</a>&gt;<br>\nDear  Jasmin,</p>\n<p>Jasmin Blanchette via Cl-isabelle-users –ø–∏—Å–∞–ª 2020-07-06 09:37:</p>\n<blockquote>\n<p>This sounds very interesting. Most of the issues we have appear to be<br>\nrelated to Z3's incomplete quantifier instantiation. CVC4 finds a<br>\nproof using different (probably incomplete) heuristics and Z3 just<br>\nseems not to find the same quantifiers. I was always afraid an<br>\napproach based on instantiation would be too verbose (in the output)<br>\nIn our approach we implemented a version of E-matching based on a static <br>\nand deterministic over- and under-approximations of the congruence <br>\nrelation inside our tactic, so the proofs lines do not have to <br>\nexplicitly provide all the instantiations, most of them can be <br>\nrediscovered by the algorithm. Just for curiosity, an example of proof <br>\nwith and without all explicit instantiations:</p>\n</blockquote>\n<p>define w‚á©s w‚á©e w‚á©I w‚á©I‚á©0 w‚á©i‚á©r w‚á©I‚á©1 w‚á©i‚á©r‚á©0 where<br>\n     \"w‚á©s ‚â° ùóê‚á©s S (Domain (apsnd Container <code> rel h_ent))\"\n     \"w‚á©e ‚â° ùóê‚á©e (S - (apsnd Container </code> rel h_ent) <code> S) {}\"\n     \"w‚á©I ‚â° ùóê‚á©I w‚á©s (apsnd Container ` rel s'.h_ent) S\"\n     \"w‚á©I‚á©0 ‚â° ùóê‚á©I w‚á©e (apsnd Container ` rel s'.h_ent) S\"\n     \"w‚á©i‚á©r ‚â° ùóê‚á©i‚á©r w‚á©I w‚á©s Container (rel s'.h_ent)\"\n     \"w‚á©I‚á©1 ‚â° ùóê‚á©I w‚á©I‚á©0 (apsnd Container ` rel s'.h_ent) S\"\n     \"w‚á©i‚á©r‚á©0 ‚â° ùóê‚á©i‚á©r w‚á©I‚á©1 w‚á©I‚á©0 Container (rel s'.h_ent)\"\n   thus \"S - (apsnd Container ` rel s'.h_ent) </code> S ‚â† {}\"<br>\n     by<br>\n       (tsmt<br>\n         set_eqIT[of \"S - (apsnd Container <code> rel h_ent) `` S\" \"{}\"] \nsubsetIT[of \"S\" \"Domain (apsnd Container </code> rel h_ent)\"]<br>\n         emptyT[of \"w‚á©e\"] emptyT[of \"w‚á©s\"] DiffT[of \"w‚á©e\" \"S\" \"(apsnd <br>\nContainer <code> rel s'.h_ent) `` S\"]\n         DiffT[of \"w‚á©e\" \"S\" \"(apsnd Container </code> rel h_ent) <code> S\"]\n         DiffT[of \"w‚á©s\" \"S\" \"(apsnd Container ` rel s'.h_ent) </code> S\"] <br>\nImageT[of \"w‚á©e\" \"apsnd Container <code> rel s'.h_ent\" \"S\"]\n         ImageT[of \"w‚á©s\" \"apsnd Container </code> rel s'.h_ent\" \"S\"]<br>\n         upd_Domain_apsnd_relT[of \"w‚á©s\" \"h_ent\" \"Object ob\" \"{(c, n)}\" ]<br>\n         upd_apsnd_relT[of \"w‚á©I‚á©0\" \"w‚á©e\" \"h_ent\" \"Object ob\" \"{(c, n)}\"]<br>\n         ImageIT[of \"apsnd Container <code> rel h_ent\" \"S\" \"w‚á©I‚á©0\" \"w‚á©e\"]\n         subsetT[of \"S\" \"Domain (apsnd Container </code> rel s'.h_ent)\" \"w‚á©s\"]<br>\n         DiffT[of \"w‚á©I‚á©0\" \"S\" \"(apsnd Container <code> rel s'.h_ent) `` S\"] \nemptyT[of \"w‚á©I‚á©0\"]\n         ImageT[of \"w‚á©I‚á©0\" \"apsnd Container </code> rel s'.h_ent\" \"S\"]<br>\n         image_apsndT[of \"w‚á©I‚á©1\" \"w‚á©I‚á©0\" \"Container\" \"rel s'.h_ent\"]<br>\n         image_apsndT[of \"w‚á©I\" \"w‚á©s\" \"Container\" \"rel s'.h_ent\"] <br>\ntag_ObjectT[of \"ob\"] tag_ContainerT[of \"w‚á©i‚á©r‚á©0\"]<br>\n         tag_ContainerT[of \"w‚á©i‚á©r\"])</p>\n<p>(explicit version automatically extracted by our proof method from the <br>\nfollowing short proof line without instances)</p>\n<p>vs.</p>\n<p>by (tsmt<br>\n           set_eqIT subsetIT emptyT DiffT ImageT upd_Domain_apsnd_relT <br>\nupd_apsnd_relT ImageIT subsetT DiffT<br>\n           sets(8, 14, 16) tags(3, 4))</p>\n<p>Another, arguably more important problem here, is that since we want our <br>\nmethod to be deterministic, we have to perform full instantiation <br>\naccording to the algorithm, but this is possible only if the <br>\ninstantiation terminates. However, in general it does not, so instead of <br>\napplying E-matching once until fixpoint, we separately provide syntax to <br>\napply it either until fixpoint or just once. Applying matching once for <br>\nevery lemma is the default. It makes instantiation fully deterministic, <br>\nbut makes the proof line discovery harder since we need not simply a set <br>\nof lemmas, but a list with proper ordering, because there are <br>\ndependencies between the instances. In particular, the list may contain <br>\nrepeated application of the same lemma as for DiffT in the example <br>\nabove. So what we are now planning to implement is a heuristical <br>\nordering (possibly with duplication) of facts extracted by sledgehammer <br>\nto maximize the set of resulting instances. If we get the proof replayed <br>\nwithin our method once, we can extract the instantiations and further <br>\noptimize the proof by removing some redundant instances (this <br>\noptimization is already implemented).</p>\n<blockquote>\n<p>I'd expect Metis to, in principle, always terminate on such ground<br>\ngoals.<br>\nWe have not encountered cases, where Metis does not terminate for sure <br>\n(a small formula, but, say &gt;90s of solving), but even for ground <br>\nformulas the time for proof replay grows significantly faster than with <br>\nSMT (Z3 with proof reconstruction), e.g. for a formula with 500 ground <br>\nassumptions (many redundant instances arising without explicit <br>\ninstantiation) Metis takes &gt;90s, while SMT takes 42ms for Z3 + 98ms for <br>\nproof replay. So we hoped that maybe Argo as an SMT solver can be faster <br>\non such formulas.</p>\n</blockquote>\n<p>Regards,<br>\nMikhail</p>",
        "id": 294830336,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246331
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nin fact, my main technique for eliminating calls to smt to work out (manually) these instantiations and then supply the ground instances to sledgehammer. The result is frequently a different proof using Metis, simp, etc.<br>\nLarry</p>",
        "id": 294830352,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246337
    },
    {
        "content": "<p>From: Jasmin Blanchette via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nHi Tobias,</p>\n<p>I know. :) You made the suggestion years ago, and back then I didn't prioritize it and failed to understand its potential (documentation, speed up reconstruction, and possibly make the difference between semidecidability and decidability). In retrospect, it's obvious, and just three days ago, I added the following item (#28!) to the Sledgehammer TODO list:</p>\n<p>G√©n√©ration de preuves Isar simples pour arithm√©tique et instantiation de quantifieurs</p>\n<p>Aujourd'hui, il y a plusieurs cas o√π la g√©n√©ration de preuve Isar prend trop de temps<br>\n    ou est trop compliqu√©e alors qu'une preuve du genre un have pour chaque lemme<br>\n    th√©orie (arithmetique) et un show √† la fin qui appelle typiquement metis.</p>\n<p>Similairement, CVC4 et peut-√™tre d'autres solveurs SMT peuvent g√©n√©rer les<br>\n    instances ground des axiomes utilis√©es. √áa pourrait √™tre utilis√© avec note, p.ex.,<br>\n    note f1 = some_lemma[of a b c], et ensuite un show √† la fin. Ou bien directement un<br>\n    seul gros appel laid √† metis etc.</p>\n<p>Thankfully it's a relatively easy change, not a full PhD, so it might get done first. Also because I have a bad conscience of not having done it back in 2012-2014.</p>\n<p>Jasmin</p>",
        "id": 294830364,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246344
    }
]