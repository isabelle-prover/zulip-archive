[
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@gmail.com\">munddr@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I see that the instantiations Unify.matchers finds may not necessarily<br>\nhave the simplest internal representation. For example:</p>\n<p>ML {*<br>\n  val trm = @{term \"(bar::nat set) = bar\"};<br>\n  val pat = @{cpat \"(?foo::(?'a =&gt; ?'b) =&gt; ?'c) (bar::(?'a =&gt; ?'b))\"}<br>\n|&gt; term_of;<br>\n  val mtchsq = Unify.matchers @{theory} [(pat,trm)];<br>\n  val mtchs = Seq.list_of mtchsq;<br>\n*}</p>\n<p>The first match gives this instantiation for ?foo:</p>\n<p>[?foo::(nat =&gt; bool) =&gt; ?'c := %a::nat =&gt; bool. a = a]</p>\n<p>Now, if we look at the internal representation of the term, it actually is:</p>\n<p>Abs (\"\", \"Nat.nat =&gt; HOL.bool\",<br>\n     Const (\"HOL.eq\", \"(Nat.nat =&gt; HOL.bool) =&gt; (Nat.nat =&gt; HOL.bool)<br>\n=&gt; HOL.bool\") $<br>\n       Abs (\"\", \"Nat.nat\", Bound 1 $ Bound 0) $ Abs (\"\", \"Nat.nat\",<br>\nBound 1 $ Bound 0))</p>\n<p>It is unnecessarily large. A simpler representation would be:</p>\n<p>Abs (\"\", \"Nat.nat  =&gt; HOL.bool\",<br>\n     Const (\"HOL.eq\", \"(Nat.nat =&gt; HOL.bool) =&gt; (Nat.nat =&gt; HOL.bool)<br>\n=&gt; HOL.bool\") $ Bound 0 $<br>\n       Bound 0)</p>\n<p>My question is: Is there a way to reduce the internal representation<br>\nof a term from one that contains \"reducible\" lambda expressions (like<br>\nin the first) to one that is leaner (like in the second) in general?<br>\nOr, is there a simple way to make the matcher algorithm spit out<br>\nleaner internal representations?</p>\n<p>Thank you for the help in advance.</p>\n<p>John</p>",
        "id": 294143370,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846653
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThe unification algorithm operates on eta-expanded terms. Is there any compelling reason why you need them to be eta-contracted?<br>\nLarry Paulson</p>",
        "id": 294143385,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846659
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nLarry is right that according to the natural order of things it is better <br>\nto leave things as they are produced, and work conceptually with arbitrary <br>\nrepresentatives of the alpha/beta/eta equivalence classes.</p>\n<p>In some boundary cases this might fails, because certain tools do not <br>\nobserve this equivalence.  Here you can contract or expand manually to <br>\nachieve a certain standard form, e.g. via Envir.eta_contract, <br>\nEnvir.beta_eta_contract, Patter.eta_long.  The Thm module also provides <br>\nsome variants for actual theorems.</p>\n<p>Makarius</p>",
        "id": 294143430,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846678
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Tue, Aug 30, 2011 at 5:12 AM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>Larry is right that according to the natural order of things it is better to<br>\nleave things as they are produced, and work conceptually with arbitrary<br>\nrepresentatives of the alpha/beta/eta equivalence classes.</p>\n<p>In some boundary cases this might fails, because certain tools do not<br>\nobserve this equivalence.</p>\n</blockquote>\n<p>I want to point out that the <em>simplifier</em> is one of those \"certain<br>\ntools\" whose behavior depends on whether or not terms are<br>\neta-expanded. (This includes not only the \"simp\" method, but also<br>\n\"unfold\", \"auto\", \"fastsimp\", etc.)</p>\n<p>Many simplification rules, such as \"id x = x\" or \"(f o g) x = f (g<br>\nx)\", are intended to unfold a definition of a constant <em>only</em> when it<br>\nis applied to an argument. Eta expansion can cause the simplifier to<br>\napply these rules in unexpected situations. (When users have the \"eta<br>\ncontract\" pretty printing option enabled, as is the default,<br>\nreplacements like \"f o g\" -&gt; \"%x. f (g x)\" can appear to happen at<br>\nrandom.)</p>\n<p>Eta-expansion can cause some confusion with congruence rules in the<br>\nsimplifier, since a congruence rule only applies when the given<br>\nconstant is applied to a sufficient number of arguments.</p>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-May/msg00032.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-May/msg00032.html</a><br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-May/msg00046.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2010-May/msg00046.html</a></p>\n<p>Eta expansion also interferes with the feature of the \"rule\" tactic<br>\nwhere it tries to preserve bound variable names:</p>\n<p><a href=\"https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2011-August/001803.html\">https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2011-August/001803.html</a></p>\n<p>With type \"'a set\" being an abbreviation for \"'a =&gt; bool\",<br>\neta-expansion can happen to set expressions, which causes other<br>\nproblems. For example, \"A \\&lt;inter&gt; B\" might get expanded to \"%a. (A<br>\n\\&lt;inter&gt; B) a\". Because of this, the otherwise-entirely-reasonable<br>\nsimp rule \"inf f g x = inf (f x) (g x)\" would cause  \"%a. (A \\&lt;inter&gt;<br>\nB) a\" (which pretty-prints as \"A \\&lt;inter&gt; B\") to simplify to \"%x. A x<br>\n&amp; B x\", violating the set/predicate discipline and messing up a lot of<br>\nproofs.</p>\n<p><a href=\"https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2011-August/001687.html\">https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2011-August/001687.html</a><br>\n<a href=\"https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2011-August/001733.html\">https://mailmanbroy.informatik.tu-muenchen.de/pipermail/isabelle-dev/2011-August/001733.html</a></p>\n<blockquote>\n<p>On Tue, 30 Aug 2011, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>The unification algorithm operates on eta-expanded terms. Is there any<br>\ncompelling reason why you need them to be eta-contracted?</p>\n</blockquote>\n</blockquote>\n<p>For reasons including (but not limited to) the ones listed above, I<br>\nwould greatly prefer to have a unification algorithm that preserves<br>\nterms as much as possible, performing NO unnecessary eta-expansions OR<br>\neta-contractions.</p>\n<p>(Implementation idea: When eta-expanding, mark all of the<br>\nnewly-introduced bound variables in some way; then do an<br>\neta-contraction at the end, contracting <em>only</em> newly-introduced<br>\nvariables.)</p>\n<p>A unification algorithm with this property would allow us to simplify<br>\nIsabelle's pretty printer quite a bit: The ridiculous \"eta contract\"<br>\npretty-printing option would no longer be needed, and we could also<br>\nget rid of a lot of ML code used for preventing or reversing<br>\neta-contraction with binders (e.g. the print translations for \"split\"<br>\nin Product_Type.thy).</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294143586,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846715
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nTobias (and maybe Stefan Berghofer) should be able to explain how the <br>\nsimplifier works concerning eta contraction.  (I have my own collection of <br>\nboundary cases and surprises, sometimes even with plain beta redexes.)</p>\n<p>Nonetheless, the situation has been rather \"stable\" in the past 10 years <br>\nor so, in the sense that there are now known soundness holes (there used <br>\nto be several in ancient times).  Any serious reforms deep down there, <br>\nwhich is below the inference kernel, has always been beyond my <br>\nimagination.  This does not mean someone could not do a convincing formal <br>\nmodel in HOL-Nominal, say, that explains convicingly how evertything could <br>\nfit together nicely (and still correctly).</p>\n<p>The \"unfold\" method and 'unfolding' command is a bit different, and in my <br>\narea of responsibility.  Historically I have merely imitated Larry's <br>\ntraditional rewrite_goals_tac suite, and was a bit too slow to turn it <br>\ninto something more close to the idea of actual unfolding of simple <br>\ndefinitions: \"c == %x y z. b\" instead of rewriting with \"c x y z == ...\".</p>\n<p>Last time I've tried this small reform (maybe around 2006), I ran into <br>\nvarious oddities in the library, theories depending on the odd behaviour <br>\nwrt. beta/eta conversion.  Later the situation became much worse, e.g. in <br>\nMultivariate_Analysis which often emulated tactical rewriting in the <br>\nmiddle of Isar proofs, using 'unfolding' for this.</p>\n<p>Since you have cleaned up a lot of Multivariate_Analysis recently, what <br>\nwas your impression?</p>\n<p>Makarius</p>",
        "id": 294143983,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846837
    }
]