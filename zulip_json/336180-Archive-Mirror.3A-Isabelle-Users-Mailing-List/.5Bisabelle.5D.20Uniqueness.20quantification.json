[
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@gmail.com\">munddr@gmail.com</a>&gt;<br>\nHi,</p>\n<p>I'm trying to prove a lemma containing a uniqueness quantification:</p>\n<p>axiomatization<br>\np1 :: \"nat =&gt; bool\" and<br>\np2 :: \"nat =&gt; bool\" and<br>\np3 :: \"nat =&gt; bool\"<br>\nwhere<br>\nax1: \"p1 x == ~p2 x &amp; ~p3 x\" and<br>\nax2: \"p2 x == ~p1 x &amp; ~p3 x\" and<br>\nax3: \"p3 x == ~p1 x &amp; ~p2 x\"</p>\n<p>lemma lem: \"EX! p:{p1,p2,p3}. p q\"<br>\nusing ax1 ax2 ax3<br>\napply auto</p>\n<p>but unfortunately no proof is found. Don't ax1, ax2 and ax3 together<br>\nimply that for all values, there's one and only one predicate that is<br>\ntrue?</p>\n<p>I must be missing something here...</p>\n<p>Thanks a lot for your time.</p>\n<p>John</p>",
        "id": 294217426,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895651
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nI can prove your lemma a bit like this:</p>\n<p>axiomatization<br>\np1 :: \"nat =&gt; bool\" and<br>\np2 :: \"nat =&gt; bool\" and<br>\np3 :: \"nat =&gt; bool\"<br>\nwhere<br>\nax1: \"p1 x == ~p2 x &amp; ~p3 x\" and<br>\nax2: \"p2 x == ~p1 x &amp; ~p3 x\" and<br>\nax3: \"p3 x == ~p1 x &amp; ~p2 x\"</p>\n<p>lemma lem: \"EX! p:{p1,p2,p3}. p q\"<br>\n   apply simp<br>\n   apply (simp add: conj_disj_distribR cong: conj_cong)<br>\n   apply (metis ax1 ax2 ax3)<br>\n   done</p>\n<p>Let me say a little about how I knew to do that.</p>\n<p>Firstly, introducing ax1 ax2 or ax3 as assumptions will loop the <br>\nsimplifier. It will take them as rewrite rules and apply them to each <br>\nother, and they're directed towards their complex ends. I could <br>\nintroduce them safely the other way around, e.g.</p>\n<p>lemma lem: \"EX! p:{p1,p2,p3}. p q\"<br>\n   using ax1[symmetric] ax2[symmetric] ax3[symmetric]<br>\n   apply simp<br>\n   apply (simp add: conj_disj_distribR cong: conj_cong)<br>\n   apply metis<br>\n   done</p>\n<p>The syntax \"EX! p: S. P p\" is an abbreviation for \"EX! p. p : S --&gt; P <br>\np\". The first simp statement reveals this by reducing \"p : {p1, p2, p3}\" <br>\nto \"p = p1 | p = p2 | p = p3\". If you are using an old enough version of <br>\nIsabelle, the syntax comes with a constant Bex1, which should be <br>\nunfolded in the first line with (simp add Bex1_def) to get to the same <br>\nstate.</p>\n<p>Secondly, I wanted to avoid the (very general) application \"p q\" in your <br>\nterm where \"p\" is a quantified variable (an intrinsically higher-order <br>\nexpression). If we move this statement together with the three different <br>\nequalities, and supply the \"conj_cong\" congruence rule (which allows the <br>\nleft-hand side of conjunctions to be used to rewrite their right hand <br>\nsides in the simplifier) then the applications are of the three specific <br>\npredicates p1 p2 and p3. The equalities are still higher-order, but for <br>\nsome reason metis can solve the problem already (mirabile dictu).</p>\n<p>The quantifiers can be removed more completely with \"apply (simp add: <br>\nconj_disj_distribR Ex1_def all_conj_distrib ex_disj_distrib)\", from <br>\nwhich point it is even more clear that metis should be able to solve the <br>\nproblem. Maybe.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294217503,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895695
    },
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@gmail.com\">munddr@gmail.com</a>&gt;<br>\nHi Thomas,</p>\n<p>Thanks so much for your detailed explanation.</p>\n<p>I've tried your suggestion and it works! However, I've tried extending<br>\nthe model to 5 predicates:</p>\n<p>axiomatization<br>\np1 :: \"nat =&gt; bool\" and<br>\np2 :: \"nat =&gt; bool\" and<br>\np3 :: \"nat =&gt; bool\" and<br>\np4 :: \"nat =&gt; bool\" and<br>\np5 :: \"nat =&gt; bool\"<br>\nwhere<br>\nax1: \"p1 x == ~p2 x &amp; ~p3 x &amp; ~p4 x &amp; ~p5 x\" and<br>\nax2: \"p2 x == ~p1 x &amp; ~p3 x &amp; ~p4 x &amp; ~p5 x\" and<br>\nax3: \"p3 x == ~p1 x &amp; ~p2 x &amp; ~p4 x &amp; ~p5 x\" and<br>\nax4: \"p4 x == ~p1 x &amp; ~p2 x &amp; ~p3 x &amp; ~p5 x\" and<br>\nax5: \"p5 x == ~p1 x &amp; ~p2 x &amp; ~p3 x &amp; ~p4 x\"</p>\n<p>and</p>\n<p>metis loops at:</p>\n<p>lemma lem: \"EX! p:{p1,p2,p3,p4,p5}. p q\"<br>\nusing ax1[symmetric] ax2[symmetric] ax3[symmetric] ax4[symmetric]<br>\nax5[symmetric]<br>\napply simp<br>\napply (simp add: conj_disj_distribR Ex1_def all_conj_distrib ex_disj_distrib)<br>\napply metis</p>\n<p>Do you know why it's fine for a smaller number of predicates, e.g., 3,<br>\nbut not when there are 5? Do you happen to know how to simplify the<br>\ngoal further?</p>\n<p>Thanks a lot for your time.</p>\n<p>John</p>",
        "id": 294217662,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895787
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nI fiddled around with it a bit, and discovered that applying clarsimp <br>\nbefore metis may solve the problem.</p>\n<p>I have no idea why this might be. I tried case decomposition but all I <br>\ndiscovered was that some combination of disjCI and conjE, which <br>\nclarsimp/clarify apply, was helping metis. It makes no sense to me that <br>\n(elim conjE, metis) can solve some problems which metis can't, but it <br>\nseems to be the case.</p>\n<p>I suppose I should ask the obvious: these equalities on predicates seem <br>\na bit strange. The \"p1 = p2\" possibilities all over the place are <br>\ncomplicating things. Do you want the property \"p q\" to hold for exactly <br>\none of the 5 <em>expressions</em> p1, p2, ... or for exactly one of the <br>\n<em>values</em>, of which there might be less than 5? Note that \"EX! p : {p1, <br>\np2, p3, p4, p5}. p q\" would be true if \"p1 q\" and \"p2 q\" but \"p1 = p2\" <br>\n(although that's impossible in this case).</p>\n<p>Here is a slightly stronger formulation which can be solved by auto:</p>\n<p>lemmas axs = ax1 ax2 ax3 ax4 ax5</p>\n<p>lemma lem: \"length (filter (%p. p q) [p1, p2, p3, p4, p5]) = 1\"<br>\n   using axs[symmetric]<br>\n   by auto</p>\n<p>This helper rule might also be helpful:</p>\n<p>lemma ex_unique_from_length:<br>\n   \"length (filter P xs) = 1 ==&gt; (EX! x : set xs. P x)\"<br>\n   apply (induct xs)<br>\n   apply (auto simp add: filter_empty_conv split: split_if_asm)<br>\n   done</p>\n<p>lemmas lem2 = ex_unique_from_length[OF lem, unfolded set.simps]</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294217803,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895867
    },
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@gmail.com\">munddr@gmail.com</a>&gt;<br>\nThanks again for your help.</p>\n<blockquote>\n<p>I suppose I should ask the obvious: these equalities on predicates seem a<br>\nbit strange. The \"p1 = p2\" possibilities all over the place are complicating<br>\nthings. Do you want the property \"p q\" to hold for exactly one of the 5<br>\n<em>expressions</em> p1, p2, ... or for exactly one of the <em>values</em>, of which there<br>\nmight be less than 5? Note that \"EX! p : {p1, p2, p3, p4, p5}. p q\" would be<br>\ntrue if \"p1 q\" and \"p2 q\" but \"p1 = p2\" (although that's impossible in this<br>\ncase).</p>\n</blockquote>\n<p>I indeed want \"p q\" to hold for exactly one of the 5 expressions, i.e.<br>\nonly one of the 5 predicates returns true for all arguments.</p>\n<p>Applying clarify/clarsimp seems to work indeed. However, if I change<br>\nthe type of the predicates from \"nat =&gt; bool\" to \"(nat*nat) =&gt; bool\",<br>\nthe proof breaks. Do you know why the input type of the predicates<br>\naffects the proof?</p>\n<blockquote>\n<p>Here is a slightly stronger formulation which can be solved by auto:</p>\n<p>lemmas axs = ax1 ax2 ax3 ax4 ax5</p>\n<p>lemma lem: \"length (filter (%p. p q) [p1, p2, p3, p4, p5]) = 1\"<br>\n  using axs[symmetric]<br>\n  by auto</p>\n<p>This helper rule might also be helpful:</p>\n<p>lemma ex_unique_from_length:<br>\n  \"length (filter P xs) = 1 ==&gt; (EX! x : set xs. P x)\"</p>\n</blockquote>\n<p>Right, but how come the reverse doesn't hold? If there's exactly one<br>\nof the predicates returning true, then isn't the length of the<br>\nfiltered list one?</p>\n<p>Thanks again.</p>\n<p>John</p>",
        "id": 294217927,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895928
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;</p>\n<blockquote>\n<p>I indeed want \"p q\" to hold for exactly one of the 5 expressions, i.e.<br>\nonly one of the 5 predicates returns true for all arguments.</p>\n<p>Applying clarify/clarsimp seems to work indeed. However, if I change<br>\nthe type of the predicates from \"nat =&gt;  bool\" to \"(nat*nat) =&gt;  bool\",<br>\nthe proof breaks. Do you know why the input type of the predicates<br>\naffects the proof?</p>\n</blockquote>\n<p>No particularly good ideas here, except that things are becoming more <br>\ncomplicated.</p>\n<blockquote>\n<p>Right, but how come the reverse doesn't hold? If there's exactly one<br>\nof the predicates returning true, then isn't the length of the<br>\nfiltered list one?</p>\n</blockquote>\n<p>No. To phrase what I said before in different language again, the <br>\ncardinality of the set you've been talking about \"{p1, p2, p3, p4, p5}\" <br>\nisn't necessarily 5. If \"p1 = p2\" then there are less than 5 unique <br>\nelements of the set \"{p1, p2, p3, p4, p5}\".</p>\n<p>To rephrase this once more: if you add a p6 to your axiomatization with <br>\nthe axiom ax6: \"p6 = p5\", then the equivalent lemma is still provable:</p>\n<p>lemma lem: \"EX! p:{p1,p2,p3,p4,p5, p6}. p q\"<br>\n   apply (simp add: conj_disj_distribR Ex1_def all_conj_distrib <br>\nex_disj_distrib)<br>\n   apply clarsimp<br>\n   apply (metis axs)<br>\n   done</p>\n<p>The reason this is provable is because \"{p1, p2, p3, p4, p5, p6} = {p1, <br>\np2, p3, p4, p5}\", so it's really just the same as the 5 example.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294217945,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895934
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nNo. Try</p>\n<p>lemma length_from_ex_unique:<br>\n    \"(EX! x : set xs. P x) ==&gt; length (filter P xs) = 1\"<br>\n  nitpick</p>\n<p>Best regards,<br>\nTjark</p>",
        "id": 294217952,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895940
    }
]