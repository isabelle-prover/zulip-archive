[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>this is a elaboration raised by the thread<br>\n<a href=\"https://groups.google.com/forum/#!topic/fa.isabelle/TmzVaYzDoGc\">https://groups.google.com/forum/#!topic/fa.isabelle/TmzVaYzDoGc</a>.</p>\n<p>In my understanding the deeper reason for this situation is that<br>\ncurrently, if you develop a specification using lift_definition, you are<br>\nactually forced to use lift_definition throughout, otherwise the<br>\ntransfer method becomes unusable.</p>\n<p>I acknowledge that this is a consequence of the actual way of how<br>\ntransfer is working. On the other hand, I see two points why this is<br>\nunsatisfactory.</p>\n<p>a) One of the strengths of Isabelle is that the initial definition is<br>\nnot that important. Indeed, as you prefer, you can establish different<br>\nspecificational views (primitive, equational, inductive) on operations<br>\nby providing appropriate theorems (and declare them to proof tools etc.<br>\naccordingly). See the attached example for different but equivalent<br>\ndefinitions of a distinctness predicate. This gives you the freedom to<br>\nswitch to the »representation« which suits best your proof application.<br>\nSimilarly, concerning a type, there can be operations which you want to<br>\nderive from more primitive ones (and use that definition in proofs<br>\nalso), but also be able to lift over it. Currently, you are forced to<br>\ndefine it using lift_definition, whether you consider this »natural« or not.</p>\n<p>b) In some situations, particularly when lifting type class instances<br>\nover types, you just have not the freedom of giving your own<br>\ndefinitions. E.g. for operation like of_nat you have to prove the class<br>\nassumption relative to of_nat without any possibility to use<br>\nlift_definition at all. If you are very experienced you can derive and<br>\ndeclare your own lifting rules (see e.g. src/HOL/Code_Numeral.thy), but<br>\nthis is really elementary.</p>\n<p>To overcome this shortcomings, just one thought. What about a statement</p>\n<p>lift_equation<br>\n      t1 is t2</p>\n<p>which is almost like lift_definition but does not introduce a new<br>\noperation and operates on an existing expression t1 instead. It would<br>\ngive the necessary proof obligations to the user and then register the<br>\nappropriate transfer rules.<br>\nThis would enable us to write things like</p>\n<p>lift_equation<br>\n      ‹of_nat :: nat =&gt; integer› is ‹of_nat :: nat =&gt; int›</p>\n<p>and establish transfer relations a posteriori.</p>\n<p>Opinions?</p>\n<p>Cheers,<br>\n        Florian<br>\n<a href=\"/user_uploads/14278/HnB0MNYdJ_o0XrkJOOnXvv5I/Foo.thy\">Foo.thy</a><br>\n<a href=\"/user_uploads/14278/KfdS1QUOyNf7Srw-zca7C6Ld/signature.asc\">signature.asc</a></p>",
        "id": 294306140,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924356
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>This sounds like a good idea. I have already got used to writing my own transfer rules for <br>\nthe functions that I do not want to (or cannot) define with lift_definition. An example of <br>\nthis can be found in the Coinductive entry in the AFP (theory TLList, lemmas TNil_transfer <br>\nto tllist_all2_transfer).</p>\n<p>However, one should be clear about which proof obligation should be presented to the user. <br>\nIf function f is defined in terms of g, for which there is already a transfer rule, then <br>\nthe transfer rule for f can often be proved by unfolding f's definition and invoking <br>\ntransfer_prover. Yet, transfer prover is very picky about the format of the goal <br>\nstatement. In particular, it does not like the ones set by lift_definition.</p>\n<p>Another great feature would be to get parametric transfer rules by specifying <br>\nparametricity theorems for either side of the transfer rule. Lift_definition currently <br>\ndoes some clever rewriting there that is not so easily done manually when proving custom <br>\ntransfer rules.</p>\n<p>Andreas</p>",
        "id": 294306237,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924387
    }
]