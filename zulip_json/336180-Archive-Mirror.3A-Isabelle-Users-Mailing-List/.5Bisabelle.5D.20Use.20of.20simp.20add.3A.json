[
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;<br>\nI would appreciate some kind of strategy to determine what to write <br>\nafter simp add: when proving a simple fact. This first came up for me <br>\nwhen I was trying to prove \"floor (9.5::real) = (9::int)\" and <br>\n\"ceiling (9.5::real) = (10::int)\". Here try0 was no help; it tried <br>\nsimp, auto, fast, fastforce, force, blast, metis, linarith, and <br>\npresburger, and then reported no proof found. Quite by accident, I <br>\nfound out how to do these; you type simp add: floor_unique or simp <br>\nadd: ceiling_unique . I'd like to know how to find rules like <br>\nfloor_unique and ceiling_unique in other cases. The one I'm concerned <br>\nabout now is \"(2::nat)*x ~= 3\", which arose for me as an unproved <br>\nsubgoal. Yes, I know I can prove this one by presburger, because try0 <br>\ntold me so, but that seems like using an elephant to crush a flea; <br>\npresburger took forever to find a proof. I've also tried <br>\nfind_theorems, but that said it found over 18,000 theorems and none <br>\nof the first few looked promising. I'm sure there's a much simpler <br>\nway of proving that \"(2::nat)*x ~= 3\", and I'm sure that many people <br>\non the mailing list know what it is, but what I'd really appreciate <br>\nis some hints on how to find something like this. -Douglas</p>",
        "id": 294291378,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923576
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 29/08/2014 05:22, W. Douglas Maurer wrote:</p>\n<blockquote>\n<p>I would appreciate some kind of strategy to determine what to write after simp<br>\nadd: when proving a simple fact. This first came up for me when I was trying to<br>\nprove \"floor (9.5::real) = (9::int)\" and \"ceiling (9.5::real) = (10::int)\".</p>\n</blockquote>\n<p>For a start, simp should prove this, but unfortunately it does not. We will have<br>\nto add the right lemmas to automate this, thanks.</p>\n<blockquote>\n<p>Here<br>\ntry0 was no help; it tried simp, auto, fast, fastforce, force, blast, metis,<br>\nlinarith, and presburger, and then reported no proof found. Quite by accident, I<br>\nfound out how to do these; you type simp add: floor_unique or simp add:<br>\nceiling_unique . I'd like to know how to find rules like floor_unique and<br>\nceiling_unique in other cases.</p>\n</blockquote>\n<p>The search button (<code>Find' or </code>Query'). In this case it is not so clear what to<br>\nsearch for. Certainly \"floor\", but that still gives you 75 lemmas, which you<br>\nwould have to go through and see if they might be helpful.</p>\n<blockquote>\n<p>The one I'm concerned about now is \"(2::nat)*x ~=<br>\n3\", which arose for me as an unproved subgoal. Yes, I know I can prove this one<br>\nby presburger, because try0 told me so, but that seems like using an elephant to<br>\ncrush a flea; presburger took forever to find a proof.</p>\n</blockquote>\n<p>Not for me: presburger is instantaneous, as is arith (which tries linear<br>\narithmetic first and only then presburger).</p>\n<blockquote>\n<p>I've also tried<br>\nfind_theorems, but that said it found over 18,000 theorems and none of the first<br>\nfew looked promising. I'm sure there's a much simpler way of proving that<br>\n\"(2::nat)*x ~= 3\", and I'm sure that many people on the mailing list know what<br>\nit is, but what I'd really appreciate is some hints on how to find something<br>\nlike this. -Douglas</p>\n</blockquote>\n<p>The 18,000 suggests you just typed find_theorems. Use the search facility<br>\n(<code>Find' or </code>Query') with appropriate selection criteria.</p>\n<p>Tobias</p>",
        "id": 294291420,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923588
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 29.08.2014 05:22, W. Douglas Maurer wrote:</p>\n<blockquote>\n<p>I would appreciate some kind of strategy to determine what to write<br>\nafter simp add: when proving a simple fact. This first came up for me<br>\nwhen I was trying to prove \"floor (9.5::real) = (9::int)\" and \"ceiling<br>\n(9.5::real) = (10::int)\". Here try0 was no help; it tried simp, auto,<br>\nfast, fastforce, force, blast, metis, linarith, and presburger, and<br>\nthen reported no proof found. Quite by accident, I found out how to do<br>\nthese; you type simp add: floor_unique or simp add: ceiling_unique .<br>\nI'd like to know how to find rules like floor_unique and<br>\nceiling_unique in other cases.<br>\nIn this case, my approach would have been to use find_theorems to look<br>\nfor \"floor _ = _\". If the property could also be computed (there are no<br>\nvariables in this goal), you can also try code_simp/normalization/eval<br>\n-- these methods use a different setup of rewrite rules aimed at<br>\ngeneration of executable code instead of proving.</p>\n</blockquote>\n<blockquote>\n<p>The one I'm concerned about now is \"(2::nat)*x ~= 3\", which arose for<br>\nme as an unproved subgoal. Yes, I know I can prove this one by<br>\npresburger, because try0 told me so, but that seems like using an<br>\nelephant to crush a flea; presburger took forever to find a proof.<br>\nIt shouldn't take long -- on my machine, presburger is almost<br>\ninstantaneous on this goal (additional premises may slow it down, though).<br>\nI've also tried find_theorems, but that said it found over 18,000<br>\ntheorems and none of the first few looked promising. I'm sure there's<br>\na much simpler way of proving that \"(2::nat)*x ~= 3\", and I'm sure<br>\nthat many people on the mailing list know what it is, but what I'd<br>\nreally appreciate is some hints on how to find something like this.<br>\nfind_theorems is often the right approach. However, if you need to give<br>\nit a query, otherwise it lists all theorems (which is not going to be<br>\nuseful). The simples queries consist of a number of term patterns (like<br>\n\"_ * _\"); another very useful query is \"intro\" which lists all<br>\napplicable introduction rules. The reference manual has a full list of<br>\noptions.</p>\n</blockquote>\n<p>Another way to discover lemmas is using sledgehammer and inspecting the<br>\nproofs (especially if you give it the isar_proofs option). For me, it<br>\ngives the proof</p>\n<p>by (metis Suc_numeral even_mult_two_ex monoid_mult_class.mult.right_neutral<br>\nodd_Suc_mult_two_ex semiring_norm(5))</p>\n<p>The interesting lemmas here are even_mult_two_ex and<br>\nodd_Suc_mult_two_ex. However, due to the existential, they are not<br>\nwell-suited for simp and auto.</p>\n<p>The goal \"2*x ~= 3\" is a bit tricky for automated tools: The reasoning<br>\nis that 2*x is even and 3 is odd. However, neither \"even\" nor \"odd\" is<br>\nmentioned in the goal. A rule like \"even x ==&gt; odd y ==&gt; x ~= y\" could<br>\nintroduce these constants. However, looking at the theorems for \"even\"<br>\nand \"odd\" [1], none of the existing theorems suggests itself.</p>\n<p>We can easily prove it ourselves, though:</p>\n<p>lemma even_odd_neq_nat: \"⋀x y :: nat. even x ⟹ odd y ⟹ x ≠ y\" by auto</p>\n<p>Giving this lemma to simp easily solves the goal.</p>\n<p>-- Lars</p>\n<p>[1] There is some oddity in find_theorems. Searching for \"odd\" will not<br>\nyield any lemmas, you will need to write \"odd _\". This is somehow<br>\nrelated to odd being an abbreviation for \"~ even\" and possibly warrants<br>\nsome closer investigation from the developers.</p>",
        "id": 294291439,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923594
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nThese rules are now in the Isabelle repository:<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/cfd3cff9387b\">http://isabelle.in.tum.de/repos/isabelle/rev/cfd3cff9387b</a></p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294291614,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660923644
    },
    {
        "content": "<p>From: \"W. Douglas Maurer\" &lt;<a href=\"mailto:maurer@gwu.edu\">maurer@gwu.edu</a>&gt;<br>\nIn response to my submission, Lars Noschinski wrote: 'The goal \"2*x <br>\n~= 3\" is a bit tricky for automated tools: The reasoning is that 2*x <br>\nis even and 3 is odd. However, neither \"even\" nor \"odd\" is mentioned <br>\nin the goal.' But a proof that \"2*x ~= 3\" by reference to even and <br>\nodd doesn't generalize in even simple ways, such as \"3*x ~= 5\".<br>\nThe real solution, it would appear to me, is that ax=b (for the free <br>\nvariable x, and constant natural numbers a and b) should simplify to <br>\nb mod a = 0. Since a and b are constants, this should be easy to <br>\ncheck. Similarly, ax ~= b should simplify to b mod a ~= 0. For \"2*x <br>\n~= 3\", this would simplify to 3 mod 2 ~= 0, or 1 ~= 0. -Douglas</p>",
        "id": 294307453,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924800
    }
]