[
    {
        "content": "<p>From: Simon Cooksey &lt;<a href=\"mailto:sjc205@kent.ac.uk\">sjc205@kent.ac.uk</a>&gt;<br>\nHello,</p>\n<p>I have a locale which provides me with a few data structures and has the<br>\nproof burden of invariants on them. I'd like to use an instantiation of<br>\na locale with concrete sets and relations and prove properties about it.</p>\n<p>Is there some documentation I can follow to do this? I've not found the<br>\nlocales and interpretations tutorial very helpful for the 2nd part.</p>\n<p>If I'm misunderstanding how locales are used corrections are also welcome!</p>\n<p>Thanks,<br>\nSimon<br>\n<a href=\"/user_uploads/14278/Z2GYLx-JutliEowd7RlQRypy/signature.asc\">signature.asc</a></p>",
        "id": 294711021,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182203
    },
    {
        "content": "<p>From: Simon Cooksey &lt;<a href=\"mailto:sjc205@kent.ac.uk\">sjc205@kent.ac.uk</a>&gt;<br>\nSome details:</p>\n<p>locale partial_order =<br>\n  fixes preceeds :: \"'a ‚áí 'a ‚áí bool\" (infixl \"‚âº\" 50)<br>\n    and events :: \"'a set\" (\"ùîà\" 1000)<br>\n  assumes refl [intro, simp]: \"x ‚âº x\"<br>\n    and anti_sym [intro]: \"‚ü¶ x ‚âº y; y ‚âº x ‚üß ‚üπ x = y\"<br>\n    and trans [trans]: \"‚ü¶ x ‚âº y; y ‚âº z ‚üß ‚üπ x ‚âº z\"</p>\n<p>locale primeES = partial_order +<br>\n  fixes conflict :: \"'a ‚áí 'a ‚áí bool\" (infixl \"#\" 50)<br>\n  assumes sym [intro]: \"‚ü¶ conflict x y ‚üß ‚üπ conflict y x\"<br>\n    and confOverPO [intro]: \"‚ü¶ conflict c d; d ‚âº e ‚üß ‚üπ conflict c e\"</p>\n<p>datatype mem_action = W | R | I<br>\ndatatype label = Label mem_action string int<br>\ntype_synonym 'a config = \"'a set\"</p>\n<p>locale labelledES = primeES +<br>\n  fixes config_domain :: \"'a config set\" (\"‚Ñ≠\" 1000)<br>\n    and label :: \"'a ‚áí label\"<br>\n  assumes conflict_free: \"‚ü¶C ‚àà config_domain; x ‚àà C; y ‚àà C ‚üß ‚üπ<br>\n¬¨(conflict x y)\"<br>\n    and down_closed: \"‚ü¶C ‚àà config_domain; y ‚àà C; x ‚âº y ‚üß ‚üπ x ‚àà C\"<br>\n    and config_subset: \"C ‚àà ‚Ñ≠ ‚üπ C ‚äÜ ùîà\"</p>\n<p>and the instantiation looks like this:</p>\n<p>interpretation emptyES: labelledES<br>\n  \"Œªx y . (x, y) ‚àà {(1,1)}‚áß*\"  -- Order<br>\n  \"{1}\" -- Events<br>\n  \"Œªx y . (x, y) ‚àà {}\" -- Conflict<br>\n  \"{{1}}\"<br>\n  \"Œªx . Label I '''' 0\" -- Labelling<br>\n  apply(unfold_locales)<br>\n         apply(auto)<br>\n   apply (metis Domain_empty Domain_insert Not_Domain_rtrancl singleton_iff)<br>\n  apply (meson converse_rtranclE prod.inject singletonD)<br>\n  done</p>\n<p>Which goes through cleanly.</p>\n<p>There's some definitions in the context of labelledES, such as<br>\nwell_justified and I'd like to prove something like \"well_justified<br>\nemptyES\" where emptyES is the instantiation of a labelledES as given above.</p>\n<p>Cheers again,</p>\n<p>Simon<br>\n<a href=\"/user_uploads/14278/QoEA6V_qY1Z_mQ4Mka8yBY-6/signature.asc\">signature.asc</a></p>",
        "id": 294711037,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182205
    },
    {
        "content": "<p>From: <a href=\"mailto:Matthew.Brecknell@data61.csiro.au\">Matthew.Brecknell@data61.csiro.au</a><br>\nYou could write a locale expression to specialise labelledES to your<br>\nparticular scenario:</p>\n<p>locale emptyES = labelledES<br>\n  \"Œªx y . (x, y) ‚àà {(1,1)}‚áß*\"¬†¬†-- Order<br>\n  \"{1}\" -- Events<br>\n  \"Œªx y . (x, y) ‚àà {}\" -- Conflict<br>\n  \"{{1}}\"<br>\n  \"Œªx . Label I '''' 0\" -- Labelling</p>\n<p>You can then prove lemmas in the context of emptyES:</p>\n<p>lemma (in emptyES) well_justified: \"well_justified\"<br>\n  sorry</p>\n<p>I think you should still be able to prove that this has a valid<br>\ninterpretation, without restating all the parameters. This will give<br>\nyou emptyES.well_justified in the interpretation context:</p>\n<p>interpretation emptyES: emptyES<br>\n  sorry (* as before *)</p>\n<p>If that produces conflicts, you might need to choose different names<br>\nfor the locale and interpretation.</p>\n<p>This seems a little fishy, though. I guess this is exploration, and you<br>\nare ultimately looking for some more general set of assumptions from<br>\nwhich well_justified always follows?</p>\n<p>BTW, if you really mean to permanently interpret something in the<br>\nglobal context, you should prefer <code>global_interpretation</code> instead of<br>\n<code>interpretation</code>. A <code>global_interpretation</code> will insist on being in the<br>\nglobal context, whereas <code>interpretation</code> will silently adopt a<br>\ndifferent behaviour if you later unintentionally wrap it in any kind of<br>\ncontext block.</p>",
        "id": 294711056,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182211
    }
]