[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 3 Feb 2016, Viorel Preoteasa wrote:</p>\n<blockquote>\n<p>If I define in ML</p>\n<p>val pair_a = @{term \"(term for p, term for f)\"};</p>\n<p>and I apply the procedure described above all works well,<br>\nhowever if instead I define the pair as the right hand<br>\nside of a definition that contains the same term for the<br>\npair, the simplification does not work. The \"if\" term stays<br>\nunsimplified</p>\n<p>val pair_b =  Thm.term_of (Thm.rhs_of ( @{thm Test_Pair_def}));</p>\n<p>The only difference between pair_a and pair_b seems to be the types. In <br>\npair_a there are simple type variables, while in pair_b there are <br>\nschematic type variables.</p>\n</blockquote>\n<p>Schematic type variables in goal states or terms that should be simplified <br>\nare notorious for surprises. The quickest way to avoid that in the given <br>\nexample is to use Logic.unvarify_global on pair_b, but note that \"global\" <br>\noperations don't work in local contexts, and locale contexts are the rule <br>\nand not the exception.</p>\n<blockquote>\n<p>Attached is the theory with the ML function implementing this <br>\nsimplification.</p>\n</blockquote>\n<p>Some more notes after reading through this for 10min:</p>\n<ul>\n<li>\n<p>always use formal antiquotation instead of literal string constants,<br>\n   e.g. @{const_name Trueprop}, @{type_name fun};</p>\n</li>\n<li>\n<p>observe maximum line length of 80-100 chars;</p>\n</li>\n<li>\n<p>never use hardwired Free variables like \"Aux_Var\", \"u\", \"v\", \"w\" in <br>\nproduction code;</p>\n</li>\n<li>\n<p>see \"implementation\" manual ch. 0 about Isabelle/ML usage;</p>\n</li>\n</ul>\n<p>The manual provides general background information and a few examples, <br>\nwith important functions mentioned in the text as entry points to the <br>\nsources.  E.g. Variable.import, Variable.export, <a href=\"http://Variable.trade\">Variable.trade</a> may help <br>\nto get a feeling how the context discipline with locally fixed and <br>\nexported schematic variables works.</p>\n<p>Makarius</p>",
        "id": 294666281,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661171880
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nI am trying to use asm_rewrite to simplify a term f(u,v,w) under some<br>\nassumptions p(u,v,w). p and f are given as a pair (p,f) and p and f have<br>\nthe same domain type. For this I construct in ML the term<br>\n\"p(u,v,w) ==&gt; Aux_Var = f(u,v,w)\".</p>\n<p>In my test f(u,v,w) = ((if u + v &lt; 10 then w else w + 1) + 2)<br>\nand p(u,v,w) = (u + v &lt; 10), and the goal is to simplify<br>\nf to f(u,v,w) = w + 2 under the assumption p(u,v,w).</p>\n<p>If I define in ML</p>\n<p>val pair_a = @{term \"(term for p, term for f)\"};</p>\n<p>and I apply the procedure described above all works well,<br>\nhowever if instead I define the pair as the right hand<br>\nside of a definition that contains the same term for the<br>\npair, the simplification does not work. The \"if\" term stays<br>\nunsimplified</p>\n<p>val pair_b =  Thm.term_of (Thm.rhs_of ( @{thm Test_Pair_def}));</p>\n<p>The only difference between pair_a and pair_b seems to be the<br>\ntypes. In pair_a there are simple type variables, while in pair_b<br>\nthere are schematic type variables.</p>\n<p>Attached is the theory with the ML function implementing this<br>\nsimplification. At the end it defines two variables simp_a_th<br>\nsimp_b_th holding the simplifications of the two terms<br>\npair_a and pair_b. In pair_a \"if\" is simplified, while in pair_b<br>\n\"if\" is not simplified. It works the same in Isabelle2015 and<br>\nalso Isabelle2016-RC3.</p>\n<p>Why is this difference? Is it possible to get the same simplification<br>\nresult also on the pair_b term?</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa<br>\n<a href=\"/user_uploads/14278/CT_vERnrSJYjhMh3FXpZugBA/TestAsmRewrite.thy\">TestAsmRewrite.thy</a></p>",
        "id": 294667903,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661172408
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThis may have something to do with the fact that hypotheses in theorems may not <br>\ncontain schematic variables. Or because the rewrit step would (or appears to) <br>\nrequire instantiation of a schematic variable in the term to be rewritten. If it <br>\ndoes not work it is safe to assume that it is an inherent limitation and you <br>\nhave to convert schematic to ordinary variables first.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/-c6h6Aw6UU2s9P-6yQFWj_6g/smime.p7s\">smime.p7s</a></p>",
        "id": 294668038,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661172457
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nHi Tobias,</p>\n<p>Thank you for the answer. I will do as you suggest. Anyway, my starting<br>\ntheorem does not have schematic variables. In the process it seems<br>\nthat I need some schematic variables, for example to combine theorems<br>\nwith OF, but I will make schematic just the variables that are needed.</p>\n<p>Viorel</p>",
        "id": 294668128,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661172485
    }
]