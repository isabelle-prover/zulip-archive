[
    {
        "content": "<p>From: Leo Freitas &lt;<a href=\"mailto:leo.freitas@newcastle.ac.uk\">leo.freitas@newcastle.ac.uk</a>&gt;<br>\nHi,</p>\n<p>I am encoding some VDM specifications using Isabelle and I am deciding on what to use to represent them.</p>\n<p>---- option 1: the type (~=&gt;) from Map.thy</p>\n<p>It works well up to the point where I needed to add expressions with map comprehension. In VDM map comprehension is given as </p>\n<p>{ x |-&gt; y | x &lt;- S, y &lt;- T, P(x, y) } , where x and y come from sets S and T and property P(x,y) hold.</p>\n<p>In Isabelle I used the following (convoluted?) construct, given a map f ∈ (Loc ⇀ nat) that is also finite f:</p>\n<p>map_of [ (x, the(f x)) . x ← sorted_list_of_set (dom f) , P x f ] </p>\n<p>This leads to complicated proofs I was hoping to avoid. Map.thy expects a list of pairs for building <br>\nmap comprehension through list comprehension, which needs to have its generated values through <br>\nlists instead of the sets of VDM, hence the use of sorted_list_of_set.</p>\n<p>---- option 2: maps as restricted set of pairs</p>\n<p>This doesn't have as much automation and has some extra lemmas about function application that<br>\nI inherited from an encoding of Event-B in Isabelle by Mathias Schimaltz.</p>\n<p>Here map comprehension is just through set comprehension but function application uses THE operator.</p>\n<p>Any thoughts / suggestions / rationale-of-choice on what would be best to use as an adequate representation? </p>\n<p>Many thanks</p>\n<p>Best,<br>\nLeo</p>",
        "id": 294239819,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906463
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Leo,</p>\n<blockquote>\n<p>In VDM map comprehension is given as</p>\n<p>{ x |-&gt; y | x &lt;- S, y &lt;- T, P(x, y) } , where x and y come from sets S and T and<br>\nproperty P(x,y) hold.<br>\nThis example is well-defined only if P(x, y) is single-valued on S and T. Otherwise, there <br>\nmight be multiple possible y's for some x, so which one should be taken? Option 2 avoids <br>\nthis issue by allowing arbitrary relations, and you have to prove single-valuedness <br>\nyourself when needed.</p>\n</blockquote>\n<p>In general, you should not convert sets to lists. As you have experienced, this <br>\ncomplicates proofs severely. But you can build map comprehensions from lambda <br>\nabstractions. The following encodes your example more easily:</p>\n<p>%x. if x : S &amp; (EX y. y : T &amp; P (x, y)) then Some (THE y. y : T &amp; P (x, y)) else None</p>\n<p>Note that you cannot avoid the THE operator if you don't have a function to obtain the y <br>\nfor any given x. If you already have a map f to specify S and T as dom f and ran f, this <br>\nsimplifies to:</p>\n<p>restrict_map f {x. P (x, the (f x))}</p>\n<p>If you only need finite maps, you can represent them directly as associative lists, e.g.,<br>\n[(1, 'a'), (2, 'b')] maps 1 to 'a' and 2 to 'b', but I would not recommend that. This way, <br>\nyou clutter your proofs with the representation details and you lose unique <br>\nrepresentations: [(2, 'b'), (1, 'a')] is the same map as above.</p>\n<p>If code generation is of interest, you might want to look at the type ('a, 'b) mapping <br>\nfrom HOL/Library, but this is just isomorphic to 'a ~=&gt; 'b.</p>\n<p>Hope this helps<br>\nAndreas</p>\n<p>On 15/04/13 17:47, Leo Freitas wrote:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I am encoding some VDM specifications using Isabelle and I am deciding on what to use to represent them.</p>\n<p>---- option 1: the type (~=&gt;) from Map.thy</p>\n<p>It works well up to the point where I needed to add expressions with map comprehension.<br>\nIn VDM map comprehension is given as</p>\n<p>{ x |-&gt; y | x &lt;- S, y &lt;- T, P(x, y) } , where x and y come from sets S and T and<br>\nproperty P(x,y) hold.</p>\n<p>In Isabelle I used the following (convoluted?) construct, given a map f ∈ (Loc ⇀ nat) that is also finite f:</p>\n<p>map_of [ (x, the(f x)) . x ← sorted_list_of_set (dom f) , P x f ]</p>\n<p>This leads to complicated proofs I was hoping to avoid. Map.thy expects a list of pairs for building<br>\nmap comprehension through list comprehension, which needs to have its generated values through<br>\nlists instead of the sets of VDM, hence the use of sorted_list_of_set.</p>\n<p>---- option 2: maps as restricted set of pairs</p>\n<p>This doesn't have as much automation and has some extra lemmas about function application that<br>\nI inherited from an encoding of Event-B in Isabelle by Mathias Schimaltz.</p>\n<p>Here map comprehension is just through set comprehension but function application uses THE operator.</p>\n<p>Any thoughts / suggestions / rationale-of-choice on what would be best to use as an adequate representation?</p>\n<p>Many thanks</p>\n<p>Best,<br>\nLeo<br>\n</p>\n</blockquote>",
        "id": 294239842,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906475
    }
]