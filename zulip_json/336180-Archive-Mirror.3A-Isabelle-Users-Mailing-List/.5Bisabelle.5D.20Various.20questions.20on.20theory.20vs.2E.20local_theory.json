[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nI am currently trying to automate some definitions and subsequent proofs and <br>\ndeclarations. However, I am currently unsure how to go about with a few points <br>\nand I'd appreciate any help to point me in the right direction. By the way, I am <br>\nusing the Isabelle repository version 29aa0c071875.</p>\n<p>Here's what I am doing: I have implemented a function as a transformer of <br>\nlocal_theory. Given some parameters,</p>\n<ol>\n<li>\n<p>it constructs an Isabelle term and uses this to define a new constant using <br>\nLocal_Theory.define. Call the resulting theory lthy1.</p>\n</li>\n<li>\n<p>From the definition, it proves some equations for simplification, adds them <br>\nto a dynamic theorem list, and declares them as [iff]. This is the first bit <br>\nwhich looks odd to me. Here are the details:</p>\n</li>\n</ol>\n<p>a) I use Goal.prove based on lthy1 to prove the simplification equations (say <br>\nsimp_thm) whose term representation whose I have constructed using the ML <br>\nprimitives.</p>\n<p>b) Then, I add the proven theorems to the dynamic theorem list via<br>\n   Local_Theory.declaration {syntax = false, pervasive=true} f<br>\nwhere f phi applies the morphism to the theorem to be stored (i.e. simp_thm) <br>\nbefore it updates the Generic_Data slot that manages the dynamic theorem list. <br>\nThis gives lthy2.</p>\n<p>c) Next, I declare thms as [iff] via</p>\n<p>val lthy3 = Local_Theory.declaration {syntax=false, pervasive=false}<br>\n     (fn phi =&gt; Thm.attribute_declaration (Clasimp.iff_add o Morphism.thm phi)<br>\n                   simp_thm) lthy2</p>\n<p>For now, let lthy3 be the result of the whole function.</p>\n<p>When I execute these steps inside a locale via local_setup, step c) outputs two <br>\nwarnings each about duplicate rewrite rules and duplicate safe elimination rules <br>\nfor the simp_thm. Is that normal? What should I do instead?</p>\n<ol start=\"3\">\n<li>Next, I would like to register the newly defined constant as another datatype <br>\nconstructor for the code generator via Code.add_datatype. Unfortunately, <br>\nCode.add_datatype is a theory morphism, not a local_theory transformer.</li>\n</ol>\n<p>Anyway, the problem is that Code.add_datatype expects a list of constructor <br>\nnames, i.e., the names that the constructors have in the background theory. How <br>\ncan I obtain the global name of the newly defined constant?</p>\n<ol start=\"4\">\n<li>Since the constructors for code generation have changed, I would also like to <br>\nadd the corresponding code equations for equal_class.equal, i.e., prove some <br>\ncode equations and declare them in the background theory as [code], i.e., using <br>\nCode.add_eqn, which again is a theory transformer.</li>\n</ol>\n<p>Am I right to assume that Local_Theory.background_theory converts that into a <br>\ntransformer on the local_theory?<br>\nAnd how do I correctly export the code equations that I have proved in lthy1 to <br>\nthe background theory?</p>\n<p>I hope that the above description provides sufficient information about what I <br>\nam doing to answer my problems. If not, I could also post the full code, but it <br>\nis currently in a messy state.</p>\n<p>Andreas</p>",
        "id": 294155614,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851088
    }
]