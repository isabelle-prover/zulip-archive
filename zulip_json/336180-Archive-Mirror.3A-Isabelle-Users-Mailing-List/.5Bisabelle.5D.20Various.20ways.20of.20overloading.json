[
    {
        "content": "<p>From: John Munroe &lt;<a href=\"mailto:munddr@gmail.com\">munddr@gmail.com</a>&gt;<br>\nHi all,</p>\n<p>I'm looking into overloading and it seems that consts/axioms already<br>\nallow overloading:</p>\n<p>typedecl A</p>\n<p>consts<br>\ng :: \"'a =&gt; bool\"<br>\na :: A</p>\n<p>axioms<br>\naxA: \"g (x::A) = True\"<br>\naxB: \"g (x::B) = False\"</p>\n<p>lemma \"g a\"<br>\nusing axA<br>\nby auto</p>\n<p>whereas, axiomatization doesn't:</p>\n<p>axiomatization<br>\ng :: \"'a =&gt; bool\"<br>\nwhere axA: \"g (x::A) = True\"</p>\n<p>which gives a type unification error:</p>\n<p>*** Type unification failed</p>\n<hr>\n<p>*** Type error in application: incompatible operand type</p>\n<hr>\n<p>*** Operator:  g::'a =&gt; bool :: 'a =&gt; bool<br>\n*** Operand:   x::A :: A</p>\n<p>Why is there such a discrepancy? Is it one of the reasons why<br>\nconsts/axioms are legacy features? The documentation seems to imply<br>\nthat overloading can only be achieved using type classes, but one<br>\ncould also do a similar thing in locales:</p>\n<p>consts<br>\ng :: \"'a =&gt; bool\"</p>\n<p>locale L =<br>\nassumes \"g (x::A) = True\" and<br>\n  \"g (y::B) = False\"</p>\n<p>Any advice on this will be much appreciated!</p>\n<p>Thanks</p>\n<p>John</p>",
        "id": 294143007,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846524
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;</p>\n<blockquote>\n<p>I'm looking into overloading and it seems that consts/axioms already<br>\nallow overloading:</p>\n<p>typedecl A</p>\n<p>consts<br>\ng :: \"'a =&gt; bool\"<br>\na :: A</p>\n<p>axioms<br>\naxA: \"g (x::A) = True\"<br>\naxB: \"g (x::B) = False\"</p>\n</blockquote>\n<p>Well, no wonder: axioms allow you to specify everything.</p>\n<p>Overloaded definitions are also part of the logical primitives, but type<br>\nclasses provide a neat integrated interface, which internally maps again<br>\non overloaded definitions.</p>\n<blockquote>\n<p>axiomatization<br>\ng :: \"'a =&gt; bool\"<br>\nwhere axA: \"g (x::A) = True\"</p>\n</blockquote>\n<p>By giving an explicit constant specification, you specify a <em>new</em><br>\nconstant to be declared, and its type signature (with type variables<br>\nlocally fixed) must match its occurences in axiom propositions.</p>\n<p>Without the constant specification, »axiomatization« will just state an<br>\naxiom.</p>\n<blockquote>\n<p>The documentation seems to imply<br>\nthat overloading can only be achieved using type classes</p>\n</blockquote>\n<p>The tutorial describes typical mechanisms for the end user.  The more<br>\nprimitive interfaces are covered in the Isar Reference Manual.</p>\n<blockquote>\n<p>but one<br>\ncould also do a similar thing in locales:</p>\n<p>consts<br>\ng :: \"'a =&gt; bool\"</p>\n<p>locale L =<br>\nassumes \"g (x::A) = True\" and<br>\n  \"g (y::B) = False\"</p>\n</blockquote>\n<p>In locale assumptions, you can state everything since it is only<br>\nhypothetical.  The question is whether you can give an interpretation<br>\nactually satisfying the assumptions.</p>\n<p>Regards,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/oJaCqJ_9QCNYN5dWVilcZBdc/signature.asc\">signature.asc</a></p>",
        "id": 294143035,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846537
    }
]