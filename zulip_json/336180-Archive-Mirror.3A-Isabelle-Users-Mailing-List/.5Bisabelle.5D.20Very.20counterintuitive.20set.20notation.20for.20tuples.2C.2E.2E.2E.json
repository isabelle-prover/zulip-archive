[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Cornelius,</p>\n<p>you see already in the output of, e.g.,</p>\n<p>term \"{(v, v). v : {''a'', ''b''}}\"</p>\n<p>that the non-linear pattern \"(v, v)\" is \"not accepted\" (or rather <br>\nimplicitly translated into a linear one).</p>\n<p>Currently, for set-comprehension, a syntax translation is specified (in <br>\nSet.thy), which is conceptually very simple and reuses the \"pttrn\" token <br>\ncategory. \"pttrn\" is initially equivalent to plain identifiers and only <br>\nlater extended, e.g., in Product_Type.thy to allow pairs.</p>\n<p>It might be possible to incorporate error messages in the setup in <br>\nProduct_Type.thy. But as you will see there, even the current \"simple\" <br>\nsetup is rather involved.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294237116,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905267
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Cornelius,</p>\n<p>You want \"{(v, v) | v. v : {''a'', ''b''}}\". The syntax for set <br>\ncomprehension is such that you should explicitly mention bound variables <br>\nbetween \"|\" and \".\", i.e., v in this case. In some simple cases, this <br>\ncan be avoided, and you ran into one of them:</p>\n<p>\"{(x, y). P}\" is pretty syntax for<br>\n\"Collect (prod_case (%x y. P))\", so in your case, you get<br>\n\"Collect (prod_case (%v v. v : {''a'', ''b''}))\"<br>\nSee how the second v in %v v. ... hides the former.</p>\n<p>There is no warning because it is perfectly normal to rebind a variable <br>\nname in a lambda abstraction.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294237143,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905279
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 22/03/2013 08:15, schrieb C. Diekmann:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I found a very counterintuitive problem with tuples in set notation.</p>\n<p>I want to define some sort of reflexive closure.<br>\nWhen I write {(v, v). v ∈ {''a'', ''b''}} I hope to get {(''a'',<br>\n''a''), (''b'', ''b'')}. However, I found that<br>\nlemma \"(''a'', ''b'') ∈ {(v, v). v ∈ {''a'', ''b''}}\" by(simp)<br>\nand even<br>\nlemma \"(''xyz'', ''b'') ∈ {(v, v). v ∈ {''a'', ''b''}}\" by(simp)</p>\n<p>With <code>declare[[show_types]]</code>, I traced the problem and found:<br>\nlemma \"{(v, v). v ∈ {''a'', ''b''}} = {(x, y). y∈{''a'', ''b''}}\" by simp<br>\nMy set is actually translated into {(va∷'a, v∷char list). v ∈ {''a'', ''b''}}</p>\n</blockquote>\n<p>As Christian already said, this is the explanation. Just like in functional<br>\nprogramming, patterns must be linear. Unlike in FP, Isabelle silently translates<br>\nyour non-linear pattern into a linear one (for set comprehensions only). It<br>\nshould of course be rejected but at the time I was too lazy to implement this<br>\n(it would have meant going to the ML level). Of course these days the philosophy<br>\nis still to accept it but use the right interface to warn the user that what he<br>\ntyped is not what he got and he better beware ;-)</p>\n<p>Tobias</p>\n<blockquote>\n<p>Why does this happen?<br>\nWhy wasn't there even some warning that a new variable <code>va</code> was introduced?</p>\n<p>Regards<br>\n  Cornelius<br>\n</p>\n</blockquote>",
        "id": 294237156,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905285
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI agree that it is perfectly normal, just like term \"λx x x. x\", and no <br>\nwarning or error is to be expected.</p>\n<p>In Scala there is occasionally an error with situations that look similar <br>\nto an HOL or ML person, but are actually more complex due to slightly <br>\ndifferent scoping rules for that JVM-derived language.  So it leads to <br>\nvery counterintuitive errors for me occasionally.</p>\n<p>Another counter-example is Isabelle/HOL list-comprehension, which has an <br>\nentry in the \"Confusing Isabelle error messages\" category here: <br>\n<a href=\"https://isabelle.in.tum.de/community/Error_Messages#Misleading_variable_naming_in_list_comprehension\">https://isabelle.in.tum.de/community/Error_Messages#Misleading_variable_naming_in_list_comprehension</a></p>\n<p>Every time I pass by there, I wonder if it is still up-to-date, and if <br>\nthere is a way to make the syntax more conformant to Isabelle lambda <br>\ncalculus scoping rules --- or if there are more fundamental problems <br>\nbehind that.  (IIRC, Christian Sternagel was the last one asking that some <br>\nmonths ago, but without any conclusion so far.)</p>\n<p>Makarius</p>",
        "id": 294237407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905377
    }
]