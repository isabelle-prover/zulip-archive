[
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nDear Isabelle power-users or developers,</p>\n<p>I have made a very strange observation about reasoning with transitive<br>\nchains.</p>\n<p>In<br>\n<a href=\"https://github.com/formare/auctions/tree/master/isabelle/Auction/Sandbox\">https://github.com/formare/auctions/tree/master/isabelle/Auction/Sandbox</a><br>\nyou can find some \"minimal\" examples in Chain_Bug_*.thy.  OK, I could<br>\nhave stripped them down to an even more minimal form, but instead I<br>\nchose to provide the Chain_Bug_*.diff files, which point out the minimal<br>\ndifferences between the different *.thy files.</p>\n<p>The problem is that I have a chain</p>\n<p>have \"X = Y\" sorry<br>\nalso have \"Y = Z\" sorry<br>\nfinally have \"X = Z\" .</p>\n<p>Y internally involves parameterised types – I'm not sure of the<br>\nterminology, but I mean something like \"'a set\".  If I choose not to<br>\nmake these types explicit I get a warning \"Introduced fixed type<br>\nvariable(s)\" (see Chain_Bug_3_warn.thy), but otherwise everything works<br>\nfine.  I don't have a type theory background but kind of<br>\nintuitively/superficially understand this warning.  But is it a bad<br>\nthing not to provide explicit type annotations in such a situation?</p>\n<p>When I add type annotations inside Y (to arrive at<br>\nChain_Bug_4_fails.thy), I somehow manage to break the transitive chain,<br>\nas pointed out by Chain_Bug_adding_type_annotation_breaks_it.diff.</p>\n<p>I can, however, use the same reasoning structure outside of a proof, in<br>\na notepad that seems to have the same context.  Chain_Bug_2_works.thy<br>\nshows such a notepad;<br>\nChain_Bug_putting_into_lemma_context_breaks_it.diff points out the<br>\ndifference from Chain_Bug_4_fails.thy.</p>\n<p>Whether I put the structure into a lemma, or use it to justify a proof<br>\nstep, makes, as expected, no difference.  Chain_Bug_1_fails shows the<br>\nsame thing in a proof step; Chain_Bug_using_for_proof_breaks_it.diff<br>\nshows the difference from Chain_Bug_2_works.thy, where the structure<br>\noccurs on top level.</p>\n<p>I will for now omit the type annotations and ignore the warning, but I<br>\nwould be happier if I understood what's wrong.</p>\n<p>Cheers, and thanks in advance,</p>\n<p>Christoph</p>",
        "id": 294249834,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910305
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nOn 09/07/2013 05:21 PM, Christoph LANGE wrote:</p>\n<blockquote>\n<p>Y internally involves parameterised types – I'm not sure of the<br>\nterminology, but I mean something like \"'a set\".</p>\n</blockquote>\n<p>This is called polymorphism, and it is indeed the cause of your problem<br>\nhere. Isabelle uses a somewhat restricted form of polymorphism based on<br>\nschematic types variables, if I remember correctly, and that can<br>\nsometimes lead to some headaches.</p>\n<p>My personal motto in matters such as these is: When in doubt, annotate<br>\neverything with type variables.</p>\n<p>To illustrate, you can switch on unification tracing. Unification is, in<br>\nthe context of types, the process of finding instantiations for type<br>\nvariables so that one type matches another and tracing it can give you<br>\nmore information about type errors such as this one. In your case, in<br>\nthe last step, where you do</p>\n<p>finally show \"{{} = injections {} Y\" .</p>\n<p>the unification trace says</p>\n<p>The following types do not unify:<br>\n('a × 'b) set set ⇒ ('a × 'b) set set ⇒ bool<br>\n('c × 'b) set set ⇒ ('c × 'b) set set ⇒ bool</p>\n<p>The first line is the type of your calculation. The second line is the<br>\ntype of your goal. If my interpretation of this output is correct,<br>\nIsabelle has introduced a new, fresh type variable 'c for the left-hand<br>\npart of your relation instead of the existing 'a. You need to force it<br>\nto use the existing 'a, by writing, for example:</p>\n<p>finally show \"{{} :: ('a×'b) set} = injections {} Y\" .</p>\n<p>…and it works.</p>\n<p>About this warning, the warning is of a similar kind, I think it is not<br>\nprudent to ignore it in most cases. It means that you have a variable<br>\nwith a polymorphic type that cannot be determined automatically, so<br>\nIsabelle will use some fresh type variable for the schematic type<br>\nvariables in it. This can lead to problems, especially when you have<br>\nseveral of these variables in the same context and they depend on one<br>\nanother in some fashion, for instance:</p>\n<p>notepad<br>\nbegin<br>\n  fix A and B assume \"A = {}\" and \"B = {}\"<br>\n  have \"A = B\"<br>\nend</p>\n<p>This leads to a type error, because A is assigned the type 'a set and B<br>\nis assigned the type 'b set, because Isabelle cannot, from the<br>\nassumptions, determine that A and B must have the same type – indeed,<br>\nthey don't have to – so it gives them two different types, which is more<br>\ngeneral. In this case, we would have to fix both A and B to the type 'a<br>\nset, and then everything would work. And this is precisely the reason<br>\nwhy we get the warning:</p>\n<h3>Introduced fixed type variable(s): 'a, 'b in \"A__\" or \"B__\"</h3>\n<p>Cheers,<br>\nManuel</p>\n<blockquote>\n<p>When I add type annotations inside Y (to arrive at<br>\nChain_Bug_4_fails.thy), I somehow manage to break the transitive chain,<br>\nas pointed out by Chain_Bug_adding_type_annotation_breaks_it.diff.</p>\n<p>I can, however, use the same reasoning structure outside of a proof, in<br>\na notepad that seems to have the same context.  Chain_Bug_2_works.thy<br>\nshows such a notepad;<br>\nChain_Bug_putting_into_lemma_context_breaks_it.diff points out the<br>\ndifference from Chain_Bug_4_fails.thy.</p>\n<p>Whether I put the structure into a lemma, or use it to justify a proof<br>\nstep, makes, as expected, no difference.  Chain_Bug_1_fails shows the<br>\nsame thing in a proof step; Chain_Bug_using_for_proof_breaks_it.diff<br>\nshows the difference from Chain_Bug_2_works.thy, where the structure<br>\noccurs on top level.</p>\n<p>I will for now omit the type annotations and ignore the warning, but I<br>\nwould be happier if I understood what's wrong.</p>\n<p>Cheers, and thanks in advance,</p>\n<p>Christoph<br>\n</p>\n</blockquote>",
        "id": 294249848,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910311
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nIf you get this warning, it does not mean per se that you are doing something wrong. It is just that introducing new toe variables often means that the proposition you are stating is not what you intended (it often occurs if you fix some variables and than five some statement about these variables, which don't constrain the type to one occurring already in your lemma).</p>\n<p>Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt; schrieb:</p>",
        "id": 294249867,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910317
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\n2013-09-07 18:04 Manuel Eberl:</p>\n<blockquote>\n<p>My personal motto in matters such as these is: When in doubt, annotate<br>\neverything with type variables.</p>\n</blockquote>\n<p>OK, thanks, I figured out a way of doing this.  I had to make a few mroe<br>\nexplicit annotations, at the top level of the proof of which I wanted to<br>\nprove one step by the transitive chain I mentioned.</p>\n<blockquote>\n<p>To illustrate, you can switch on unification tracing.</p>\n</blockquote>\n<p>I don't know how to do this in jEdit.  Does the conclusion of this<br>\nthread<br>\n(<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-June/thread.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-June/thread.html</a>)<br>\nstill hold, i.e. that it is not possible in jEdit?</p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294249893,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910330
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nYou can switch on unification traces via some ML command:</p>\n<p>ML {* trace_unify_fail:= true*}</p>\n<p>However, you need to be aware that this is a global setting, I.e. it affects the whole Isabelle session, not just the commands coming after it.  You need to switch it off explicitly by seeing the value to false again.</p>\n<p>Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt; schrieb:</p>",
        "id": 294249927,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910342
    }
]