[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nNo one cares I'm sure, but, for closure, I didn't put in the condition <br>\nthat the elements be in NNeg, where I guess I should have used P instead <br>\nof NNeg.</p>",
        "id": 294269747,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916777
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nI'm no expert on algebra, and the number of classes in Groups and Rings <br>\nis dizzying, but I guess I would try to put these typedef <br>\npositive/non-negative types lower down. I don't know any of the <br>\nramifications of these types, other than the operations need to be closed.</p>\n<p>typedef 'a ordered_ab_group_add_NN = \"{x::'a::ordered_ab_group_add. x &gt;= <br>\n0}\"<br>\n   by(auto)</p>\n<p>typedef 'a ordered_ring_NN = \"{x::'a::ordered_ring. x &gt;= 0}\"<br>\n   by(auto)</p>\n<p>typedef 'a linordered_idom_Pos = \"{x::'a::linordered_idom. x &gt; 0}\"<br>\n   proof-<br>\n   have \"1 : {x::'a. 0 &lt; x}\" by(auto) thus ?thesis by(blast) qed</p>\n<p>So I wanted to do a little test to see if <code>-(-1)</code> would be of these <br>\ntypes, because experimenting with that might tell me if this is a loser <br>\nidea. I couldn't do that without doing the required lifting.</p>\n<p>That's why I don't try to implement any this by myself right now. It's <br>\nbecause when I look at something like <code>fset</code>, I see that a lot of work <br>\nwent into making it work.</p>\n<p>Also, if I was proving theorems about <code>x::nat</code> when it gets coerced to <br>\n<code>int</code>, I don't know if that's the same thing as proving theorems about <br>\n<code>(x::int) &gt;= 0</code>. I would want to know if I was getting locked into <br>\nsomething.</p>\n<p>But, a type for the positive and non-negative members of a group or ring <br>\ncould also be used in datatypes.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294269766,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916783
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\n(*NOTE: The \"exception TYPE raised\" error shown below might be of <br>\ninterest to someone.)</p>\n<p>The value of trying to get fancy can be the tangents. The <br>\n<code>setup_lifting</code> command works if <code>typedef</code> uses type <code>rat</code>, but not if <br>\n<code>typedef</code> uses <code>'a::linordered_idom</code>. It has nothing specifically to do <br>\nwith <code>linordered_idom</code>. A test case I made using <code>'a::finite</code> does the <br>\nsame thing.</p>\n<p>So with a typedef based on <code>rat</code>, I can start down the lifting road:</p>\n<p>typedef ratN = \"{x::rat. x &gt;= 0}\"<br>\n   by(auto)<br>\ndeclare [[coercion Rep_ratN]]</p>\n<p>setup_lifting type_definition_ratN</p>\n<p>instantiation ratN :: zero<br>\nbegin<br>\nlift_definition zero_ratN :: ratN is \"0::rat\" ..<br>\ninstance ..<br>\nend</p>\n<p>theorem \"(0::ratN) +  x = (x::rat)\"<br>\n   by(transfer, simp)</p>\n<p>But, if I want to use <code>'a::linordered_idom</code>, I have to do it the <br>\nnon-lifting, definitional way, because of the \"exception TYPE raised\" <br>\nerror shown below:</p>\n<p>typedef 'a loidN = \"{x::('a::linordered_idom). x &gt;= 0}\"<br>\n   by(auto)<br>\ndeclare Abs_loidN_inverse [simp add]</p>\n<p>setup_lifting type_definition_loidN<br>\n(*<br>\nexception TYPE raised (line 246 of \"term.ML\"):<br>\n   dest_Type<br>\n   'f::linordered_idom<br>\n*)</p>\n<p>instantiation loidN :: (linordered_idom) zero<br>\nbegin<br>\ndefinition zero_loidN :: \"'a loidN\" where<br>\n   \"0  = Abs_loidN 0\"<br>\ndeclare zero_loidN_def [simp add]<br>\ninstance ..<br>\nend</p>\n<p>theorem \"Rep_loidN(0::'a loidN) + x = (x::'a::linordered_idom)\"<br>\n   by(simp)</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294269777,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916789
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nFor example me. Your type definition uses as a raw type a type variable. <br>\nThe new code in lifting that deals with parametricity assumes that the <br>\nraw type is always a type constructor. I'll take a look at it.</p>\n<p>Ondrej</p>",
        "id": 294269786,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916796
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nOndrej,</p>\n<p>Thanks. I use <code>'a::linordered_idom option</code> as a workaround, as shown below.</p>\n<p>NOTE for anyone: I can't get subtype coercion in the Rep direction, as <br>\nshow below. If someone can tell me whether I can or can't do that, I'd <br>\nappreciate it.</p>\n<p>typedef ('a::linordered_idom) loidOpt = \"{x::'a option. x ~= None &amp; the <br>\nx &gt;= 0}\"<br>\n   by(auto)</p>\n<p>(* The Rep declares don't return an error, but have no affect on <br>\ncoercions. *)<br>\n(*<br>\ndeclare [[coercion Rep_loidOpt]]<br>\ndeclare [[coercion \"Rep_loidOpt::rat loidOpt =&gt; rat option\"]]</p>\n<p>term \"(x::rat loidOpt) = Some (y::rat)\"<br>\n*)</p>\n<p>(<em>Going the Abs direction works, but it's not the subtyping I need.</em>)</p>\n<p>declare [[coercion Abs_loidOpt]]</p>\n<p>term \"(x::rat loidOpt) = Some (y::rat)\"<br>\nterm \"(x::'a::linordered_idom loidOpt) = Some (y::'a::linordered_idom)\"</p>\n<p>(<em>I tried messing with coercion_map, but it didn't help.</em>)</p>\n<p>fun MAPloidOpt :: \"('a::linordered_idom =&gt; 'b::linordered_idom) =&gt; 'a <br>\nloidOpt =&gt; 'b loidOpt\" where<br>\n   \"MAPloidOpt f q = Abs_loidOpt(Some(f (the(Rep_loidOpt q))))\"</p>\n<p>declare [[coercion_map MAPloidOpt]]</p>",
        "id": 294269876,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916826
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nAm 10.02.2014 14:38, schrieb Gottfried Barrow:</p>\n<blockquote>\n<p>On 2/9/2014 4:40 PM, Ondřej Kunčar wrote:</p>\n<blockquote>\n<p>On 02/09/2014 05:28 PM, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>(*NOTE: The \"exception TYPE raised\" error shown below might be of<br>\ninterest to someone.)</p>\n</blockquote>\n<p>For example me. Your type definition uses as a raw type a type <br>\nvariable. The new code in lifting that deals with parametricity <br>\nassumes that the raw type is always a type constructor. I'll take a <br>\nlook at it.</p>\n</blockquote>\n<p>Ondrej,</p>\n<p>Thanks. I use <code>'a::linordered_idom option</code> as a workaround, as shown <br>\nbelow.</p>\n<p>NOTE for anyone: I can't get subtype coercion in the Rep direction, as <br>\nshow below. If someone can tell me whether I can or can't do that, I'd <br>\nappreciate it.<br>\nHi Gottfried,</p>\n</blockquote>\n<p>there are two different algorithms in charge of inserting coercions:</p>\n<p>(1) A complete (=if a term can be coerced it will be coerced) for <br>\nstructural subtyping (a.k.a. global coercion insertion in error <br>\nmessages), where only coercions between base types (i.e., nullary type <br>\nconstructors such as nat, int, real) are allowed. Map functions are used <br>\nto lift those coercions between base types to more complex types (e.g, <br>\nnat list or int option). In this \"structural\" setting, there might be a <br>\ncoercion from \"nat list\" to \"int list\" (given a coercion from nat to int <br>\nand a map function for list),  but never a coercion from \"nat list\" to <br>\n\"int option\".</p>\n<p>(2) An incomplete (Coq-style) algorithm for non-structual coercions <br>\n(e.g. one from \"nat list\" to \"int option\"). This is called local <br>\ncoercion insertion in error messages.</p>\n<blockquote>\n<p>typedef ('a::linordered_idom) loidOpt = \"{x::'a option. x ~= None &amp; <br>\nthe x &gt;= 0}\"<br>\n  by(auto)</p>\n<p>(* The Rep declares don't return an error, but have no affect on <br>\ncoercions. *)<br>\n(*<br>\ndeclare [[coercion Rep_loidOpt]]<br>\ndeclare [[coercion \"Rep_loidOpt::rat loidOpt =&gt; rat option\"]]</p>\n<p>term \"(x::rat loidOpt) = Some (y::rat)\"<br>\n*)</p>\n</blockquote>\n<p>This is out of scope for (1). The incompleteness of (2) is visible on <br>\nyour example, which only will not insert coercions in the first argument <br>\nof equality (and of other polymorphic functions). It would have worked <br>\nif you had reversed the equation:</p>\n<p>term \" Some (y::rat) = (x::rat loidOpt)\"</p>\n<p>Dmitriy</p>",
        "id": 294269895,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916833
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nDmitriy</p>\n<p>Thanks. It's fortunate I didn't switch the order, or in the future it <br>\ncould have been, \"I thought I remember that this worked.\"</p>\n<p>If Ondrej accommodates, the problem I show next won't be an issue, but <br>\nbelow, I show how I can coerce to <code>rat</code>, but not to <code>'a::linordered_idom</code>.</p>\n<p>And thanks for the explanation. Guessing here, from what you said and <br>\nwhat Ondrej said, the error below is because the coercion needs a type <br>\nconstructor, and <code>'a::linordered_idom</code> is only a type variable.</p>\n<p>Are there such things as 0-ary type constructor variables, that I can <br>\nput in place of <code>'a</code>? With <code>show_sorts</code>, I never see the type/sort of <br>\n<code>nat</code> or <code>int</code>.</p>\n<p>(<em>source with error</em>)<br>\ntypedef ('a::linordered_idom) loidOpt = \"{x::'a option. x ~= None &amp; the <br>\nx &gt;= 0}\"<br>\n   by(auto)<br>\ndeclare [[coercion Rep_loidOpt]]</p>\n<p>definition the_Rep_loidOpt :: \"'a::linordered_idom loidOpt =&gt; 'a\" where<br>\n   \"the_Rep_loidOpt x = the(Rep_loidOpt x)\"</p>\n<p>declare [[coercion \"the_Rep_loidOpt::rat loidOpt =&gt; rat\"]]</p>\n<p>term \"(y::rat) = (x::rat loidOpt)\"</p>\n<p>declare [[coercion the_Rep_loidOpt]]<br>\n(*<br>\nBad type for a coercion:<br>\nthe_Rep_loidOpt :: ?'a::linordered_idom loidOpt =&gt; ?'a::linordered_idom<br>\n*)</p>\n<p>Thanks again,<br>\nGB</p>",
        "id": 294270105,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916912
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nAm 10.02.2014 17:27, schrieb Gottfried Barrow:</p>\n<blockquote>\n<p>On 2/10/2014 8:15 AM, Dmitriy Traytel wrote:</p>\n<blockquote>\n<p>This is out of scope for (1). The incompleteness of (2) is visible on <br>\nyour example, which only will not insert coercions in the first <br>\nargument of equality (and of other polymorphic functions). It would <br>\nhave worked if you had reversed the equation:</p>\n<p>term \" Some (y::rat) = (x::rat loidOpt)\"<br>\nDmitriy</p>\n</blockquote>\n<p>Thanks. It's fortunate I didn't switch the order, or in the future it <br>\ncould have been, \"I thought I remember that this worked.\"</p>\n<p>If Ondrej accommodates, the problem I show next won't be an issue, but <br>\nbelow, I show how I can coerce to <code>rat</code>, but not to <br>\n<code>'a::linordered_idom</code>.</p>\n<p>And thanks for the explanation. Guessing here, from what you said and <br>\nwhat Ondrej said, the error below is because the coercion needs a type <br>\nconstructor, and <code>'a::linordered_idom</code> is only a type variable.<br>\nExactly. In principle this could be supported in the incomplete <br>\nalgorithm (2), but it isn't yet (and I will not promise anything ;-) ).</p>\n</blockquote>\n<blockquote>\n<p>Are there such things as 0-ary type constructor variables, that I can <br>\nput in place of <code>'a</code>? With <code>show_sorts</code>, I never see the type/sort of <br>\n<code>nat</code> or <code>int</code>.<br>\nThere is no such thing.</p>\n</blockquote>\n<p>Dmitriy</p>",
        "id": 294270122,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916918
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nThe problem is addressed in 6ea67a791108.</p>\n<p>Just a side note: I am not sure if linordered_idom is the best choice <br>\nbecause I fear you cannot prove that your type 'a loidN is again in <br>\nlinordered_idom (usual problems with minus). Which I believe, you would <br>\nlike to do.</p>\n<p>Best,<br>\nOndrej</p>",
        "id": 294270305,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916992
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nOndrej,</p>\n<p>Thanks a lot. I'll have to wait for summertime. Fortunately, it took <br>\nyou, like, two days, instead of one. Otherwise, I might not have learned <br>\nabout Lifting_Option.thy, and using it as a template for the lifting <br>\nsetup I did.</p>\n<p>I can get confused by the complexities of type classes, coercion, and <br>\nthe many algebra type classes, but the context is a generalization of this:</p>\n<p>(1) one function,<br>\n(2) the type variable sort must have the properties of int <br>\n(linordered_idom),<br>\n(3) but the function must work with nat, even though nat does not have <br>\nthe required properties of linordered_idom.</p>\n<p>The short story, according to what I currently understand, is that <br>\ncoercion is the magic for there to be that one function, and auto <br>\ncoercion is the magic to make it notationally convenient.</p>\n<p>There's more I don't know than do know, but I worked up the example <br>\nbelow to show what I think I know, about what I think I want. Thanks <br>\nagain for the magic. --GB.</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* id_loid: It must work with nat and int, and generalizations of nat <br>\nand int.*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>definition id_loid :: \"'a::linordered_idom =&gt; 'a\" where<br>\n   \"id_loid x = x\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* Works with nat, int, and linordered_idom, but not with <br>\nlinordered_semidom.*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>value \"id_loid (x::int)\" (<em>x::int</em>)<br>\nvalue \"id_loid (x::nat)\" (<em>coerced to int</em>)<br>\nvalue \"id_loid (x::'a::linordered_idom)\" (<em>x::'a::linordered_idom</em>)<br>\nterm \"id_loid (x::'a::linordered_semidom)\"<br>\n(*<br>\nERROR: Type unification failed: Variable 'a::linordered_semidom not of sort<br>\nlinordered_idom<br>\n*)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***) </p>\n<p>(* As nat is to int, loidNNeg is to linordered_idom. Coercion is the <br>\nmagic.*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>typedef 'a loidNNeg = \"{x::'a::linordered_idom. x &gt;= 0}\"<br>\n   by(auto)</p>\n<p>term \"id_loid (Rep_loidNNeg(x::'a::linordered_idom loidNNeg))\"<br>\nvalue \"id_loid (Rep_loidNNeg(x::'a::linordered_idom loidNNeg))\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*My subtype is supposed to model the natural numbers, so I try to <br>\nnarrow down<br>\n  the  sort of the type class variable to linordered_semidom, and then <br>\nuse it<br>\n  in the function id_loid, but it doesn't work.*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>typedef 'a losdNNeg = \"{x::'a::linordered_semidom. x &gt;= 0}\"<br>\n   by(auto)</p>\n<p>term \"id_loid (Rep_losdNNeg(x::'a::linordered_semidom losdNNeg))\"<br>\n(*<br>\nERROR: Type unification failed: Variable 'a::linordered_semidom not of sort<br>\nlinordered_idom<br>\n*)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*It didn't work, so whatever I'm confused about, it's not that. I want <br>\nto check<br>\nthat linordered_semidom accomodates nat. I can't depend on a type error<br>\nto know when I've exceed the properties of nat, because it will get <br>\ncoerced to<br>\nint when I do. I have to look at the output panel to see if it got <br>\ncoerced with<br>\nvalue.</p>\n<p>It looks like linordered_semidom may be the maximum properties.*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>definition id_losr :: \"'a::linordered_semidom =&gt; 'a\" where<br>\n   \"id_losr x = x\"</p>\n<p>term \"id_losr (x::nat)\" (<em>x::nat</em>)<br>\nvalue \"id_losr (x::nat)\" (<em>x::nat</em>)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*Well, okay, I don't let the lack of knowledge keep me from blindly <br>\ntrying to<br>\ndo things, because the magic kicks in many times. Am I making things too<br>\ncomplex? I don't know. If I start with linordered_semidom, there has to <br>\nbe some<br>\nkind of coercion function, but I can't use the same x on both sides, as <br>\nbelow.*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>definition losd_to_loid :: \"'a::linordered_semidom =&gt; <br>\n'b::linordered_idom option\" where<br>\n   \"losd_to_loid x = Some x\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*<br>\nThe thing for me to pursue is whether I can define any of these typedefs <br>\nin the<br>\ncontext of the type class linordered_idom.</p>\n<p>Thanks to explanations by Andreas Lochbihler about locales, I was <br>\nsorting out<br>\nthe difference between global and locale polymorhpic functions, and how the<br>\ninference engine will interpret the sort of any type variable as broadly as<br>\npossible. That can result in a 'b variable appearing in a type class <br>\ncontext,<br>\nwhen a global function is used.</p>\n<p>Yes, there are many thing to confuse a Pure novice, and a HOL novice, <br>\ntoo. But<br>\nerror messages can be educational, such as that a type class variable name<br>\nmust be 'a, which is related to the fact that type classes can only have one<br>\ntype variable, and related to what I said in the last paragraph.</p>\n<p>class tester =<br>\n   fixes tester :: 'b<br>\nError: No type variable other than 'a allowed in class specification<br>\n*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*<br>\nNow, I try to define the typedef in a linordered_idom context.<br>\n*)<br>\ncontext linordered_idom<br>\nbegin<br>\ntypedef 'a loidNNeg = \"{x::'a::linordered_idom. x &gt;= 0}\"<br>\nend<br>\n(*<br>\nERROR: Sort constraint linordered_idom inconsistent with default type <br>\nfor type<br>\nvariable \"'a\". The error(s) above occurred in typedef \"loidNNeg\"<br>\n*)<br>\n(*<br>\nThe Wizard is talking to me. What is the Wizard saying? I suppose he's <br>\nsaying<br>\nsomething similar to what Andreas Lochbihler was trying to tell me <br>\nmonths ago.<br>\nThat the linordered_idom type variable sort has been specified broadly, as<br>\n'a::type, and here I am trying to put restrictions on it.</p>\n<p>There is value in being able to experiment with software, except when the<br>\nsoftware is running on the primary server of a large, worldwide <br>\ncorporation.<br>\n*)</p>",
        "id": 294270406,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917018
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nTo work with the repository, I was thinking I'd have to do something <br>\ncomplex, but then I just downloaded the 2 changeset files and built the <br>\nimage. Also, thanks for the heads up on <code>minus</code> causing problems. That <br>\nmay not be applicable here, but I'm sure it'll come up in the future.</p>\n<p>Dude expressions are applicable, and possibly Fabian Cancellera <br>\nanalogies, or maybe not, as I tend to confuse Czechoslovakia with the <br>\nSwiss domain .ch, but we can say that the power of the lifting package <br>\ncan be compared to the size of André Greipel's thighs. As to the speed <br>\nwith which I instantiated my type as <code>linordered_semidom</code>, we can say <br>\nthat is comparable to the speed of Marcel Kittel.</p>\n<p>There actually would have been a big snag, except for a recent tip by <br>\nAndreas Lochbihler, to not use ==&gt; in a structured proof, but to use <br>\n<code>assume</code>. A proof goal was going all crazy when I would prove the step <br>\nusing ==&gt;.</p>\n<p>The numeral type class is also important, by Florain Haftmann and Brian <br>\nHuffman. I haven't figured it out yet, but I know not to let my simp <br>\nrules interfere with letting it do its job.</p>\n<p>Having a set of constants for a number system is a big reason why one <br>\ntraditionally has to resort to using integers, rational numbers, and <br>\nreal numbers. It's rather radical to have a set of constants, the <br>\nnumerals, that are both abstract, due to polymorphism, but yet can be <br>\nused concretely. If I never have to use the real numbers or rational <br>\nnumbers, because I can figure out how to get by with the numerals, <br>\nthat'll be fine with me.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294270454,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917039
    }
]