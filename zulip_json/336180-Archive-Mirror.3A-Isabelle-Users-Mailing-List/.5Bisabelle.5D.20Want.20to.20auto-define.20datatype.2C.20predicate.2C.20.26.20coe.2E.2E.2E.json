[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I have a question for the Big Guns, and I posted it on Stackoverflow:</p>\n<p><a href=\"https://stackoverflow.com/questions/27865042/want-to-auto-define-with-ml-a-datatype-a-predicate-coercions-given-name\">https://stackoverflow.com/questions/27865042/want-to-auto-define-with-ml-a-datatype-a-predicate-coercions-given-name</a></p>\n<p>It's big enough to where I want to increase the chances that I'll either <br>\nget an answer in the negative, an answer that's complete enough for me <br>\nto finish it, or an answer that's a plain ole, complete working solution.</p>\n<p>There is the UGB, the universal set of Isabelle/HOL Big Guns, and a <br>\nsubset of UGB, the BGAOSO, the Big Guns Active on Stackoverflow. Members <br>\nof the BGAOSO have actually been very helpful, and I've gotten important <br>\nanswers on SO. For anything important, it seems like it was answered.</p>\n<p>I think SO is a better staging place for a more involved question, one <br>\nwhere there's a good chance it won't get answered, or won't get answered <br>\nwith enough detail for me to finish the job.</p>\n<p>If the answer is deceptively simple, that would not be bad. Within the <br>\nscope of that which is called bad, compared to that which is called <br>\ngood, it, a deceptively simple answer, would be of that quality which is <br>\ncommonly called good, or, simply, good.</p>\n<p>It's okay if it's answered here. If it's answered here and not there, <br>\nI'll probably delete the question there. I could include it all here, <br>\nnow, but the formatting is better there, so it seems I should leave it <br>\nall there, at this time.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294324463,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928057
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nI get impatient, so that question I was asking about is gone, or soon <br>\nwill be.</p>\n<p>I'll give you something of importance that I said there, which is the <br>\nLaw of df&amp;P:</p>\n<p>(The Law of df&amp;P): There is pattern matching with datatype and fun, let <br>\nit not escape your use.</p>\n<p>I like things black and white, so I need laws to work by. I now have a <br>\nnew one, which is the result of eliminating some complexity, and <br>\naccepting a compromise.</p>\n<p>(The Law of the Universe Plus One): There is 'a option, use it directly, <br>\nin it's simple brilliance.</p>\n<p>I was using it, but not in its simplicity, because I was trying to solve <br>\na problem that comes, at least partly, from the limitations of simple <br>\ntypes. Given a fundamental type, like nat, ideally, defining a new type, <br>\nsuch as that n = 1 or n = 7, should be a one-liner, but things end up <br>\ngetting complicated.</p>\n<p>I looked at the standard example of a dependent type to try and get a <br>\nbare minimum understanding. I don't know whether dependent types would <br>\neven solve the problem above, because, as far as I can tell, if I don't <br>\nrestrict the domain of a type with the use of type constructors, rather <br>\nthan with a predicate, it doesn't help. The end result can be that I <br>\njust introduce a lot of complexity, trying to achieve an idea, that my <br>\ndomain should be encoded in my type name.</p>\n<p>Why I don't switch to dependent types? I would. I'm a fair weather <br>\nfriend when it comes to proof assistants.</p>\n<p>What I do is try to do is get a glimpse of what I don't understand, and <br>\nmake decisions on my glimpse, because understanding takes times. My <br>\nglimpse tells me that complexity comes at a cost. Limitations force me <br>\nto seek simpler solutions, or to deal with details directly, and when I <br>\ndeal with details directly, I'm probably closer to what the hardware <br>\nreally does, and the details, again, make me seek simpler, more <br>\nstraightforward solutions. There are lots of things to consider, though.</p>\n<p>Here's a brilliant use of None:</p>\n<p>instantiation option :: (\"numeral\") numeral<br>\n   begin<br>\n     definition one_option :: \"'a option\" where<br>\n       \"one_option == Some 1\"</p>\n<p>definition plus_option :: \"'a option =&gt; 'a option =&gt; 'a option\" where<br>\n       \"x + y == if x = None | y = None then None else Some (the x + the y)\"<br>\n     declare plus_option_def [simp add]<br>\n   instance by(default, auto simp add: add.assoc)<br>\n   end<br>\n   declare [[coercion \"Some :: nat =&gt; nat option\"]]</p>\n<p>And someone says, \"Nothing new, guy, I've been using that for quite a <br>\nlong time.\" And I was hoping to hear that, because I need someone to <br>\nappreciate my brilliant use of None.</p>\n<p>Okay, because no one answered the question I requested help with, I want <br>\nto ask for help on something else.</p>\n<p>I need to know which of two phrases is grammatically correct. Should I <br>\nsay, \"None is brilliant\" or \"None are brilliant\"? Puns, yes, I would <br>\nlike to ask about those too, but I can ask about those later.</p>\n<p>I said I'm impatient, right? Yes, I did. People, if they don't help me, <br>\nI have to figure things out for myself, or look for another solution.</p>\n<p>\"None\". It's polymorphic, is it not? Okay, then it's \"are\".</p>\n<p>I think I've got a glimpse that the use of \"None\" has some good set <br>\ntheoretical zemantics. Sometimes it's the universe, and sometimes it's a <br>\nset complement.</p>\n<p>As to the sematics of zemantics, that's paying homage to the fact that <br>\nin all my formal education, I don't remember once hearing a <br>\nmathematician use the word \"semantics\".</p>\n<p>Is that a complaint? Not at all, because I don't need semantics and I <br>\ndon't understand formal semantics. It also doesn't end up being a <br>\nlimitation, because I don't design languages, I use languages that. Why <br>\nshould I use the word?</p>\n<p>I had truth tables, and now I have syntax. Semantics? No, I have no need <br>\nfor semantics, not when I have syntax and zemantics. One string of <br>\ncharacters goes in and another string of characters comes out. How do I <br>\nknow? Because, I can see it all, in the console, that's why I keep it <br>\nopen all the time.</p>\n<p>As to the zemantics of that little house in the console, and maybe even <br>\nits semantics, I'm not sure. Maybe it's saying, \"Hey, you, logical wimp, <br>\nwhy you using Sledgehammer so much? Maybe I'll kick your logical tail, <br>\nand send you home.\"</p>\n<p>That I don't use semantics, does that mean I don't need interpretation? <br>\nNo, of course I need interpretation, even with zemantics at my disposal.</p>\n<p>I look in the console. What do I see? An \"x\". Then, later on, not an <br>\n\"x\", but an \"x::'a\". Later on even, not an \"x::'a\", but an <br>\n\"x::'a::numeral\". This requires syntactic interpretation, that \"x\", I <br>\nneed to interpret it as \"x::'a\", and further, that \"x::'a\", it should be <br>\ninterpreted as \"x::'a::numeral\". I work it out again, to make sure I'm <br>\nright. One character went in. Fourteen characters came out. I interpret <br>\nit all again. Even a third time. Finally, I'm convinced that \"x\", yea, <br>\nit's exactly the same \"x\" as \"x::'a\", which is exactly the same \"x::'a\" <br>\nas \"x::'a::numeral\". Well, somehow not \"exactly the same\", but that's <br>\nthe benefit of zemantics over semantics. With zemantics, you don't sweat <br>\nthe small stuff.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294324488,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928068
    }
]