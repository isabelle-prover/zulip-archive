[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere are some more Q&amp;A threads on nat vs. int, and the natural <br>\nconstruction of int via quotients:</p>\n<p><a href=\"http://cstheory.stackexchange.com/questions/3772/why-naturals-instead-of-integers\">http://cstheory.stackexchange.com/questions/3772/why-naturals-instead-of-integers</a><br>\n<a href=\"http://mathoverflow.net/questions/29090/direct-construction-of-the-integers\">http://mathoverflow.net/questions/29090/direct-construction-of-the-integers</a></p>\n<p>Makarius</p>",
        "id": 294240618,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906813
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI agree with that, although the \"marketing\" of proof assistants in the <br>\nlast 10 years or so has moved in a different direction.  Today most people <br>\nthink of Coq as some dependently typed functional programming language, <br>\nand the Agda is emphasizing the programming aspect even more.</p>\n<p>My own terminology is mainly about \"formal languages\" and \"formalization\" <br>\nof any kind. For example, the formal proof language of Isar is used to <br>\nwrite formal proofs, not to \"program\" nor to \"implement\" proofs.</p>\n<p>Isabelle/ML and Isabelle/Scala happen to be programming languages just by <br>\naccident, so you can use them to program things.  The Isabelle document <br>\npreparation language (formal latex) also happens to be computationally <br>\ncomplete, but nobody would say to \"program\" / \"implement\" / \"code\" some <br>\ntext for a paper or book.</p>\n<p>Interestingly, the computational or non-computational aspect of languages <br>\noften causes additional confusion for licensing.  E.g. see the discussion <br>\nin the paper about \"Licensing the Mizar Mathematical Library\" <br>\n<a href=\"http://arxiv.org/abs/1107.3212\">http://arxiv.org/abs/1107.3212</a></p>\n<p>To my taste, the attempt to see Mizar articles as potentially <br>\ncomputational is even more artificial for that particular proof checker.</p>\n<p>Makarius</p>",
        "id": 294240636,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906819
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYou need to be specific what you mean by \"Isabelle\".  Maybe Isabelle/HOL?</p>\n<p>In some sense, generic \"Isabelle\" is a framework (or playground) for a <br>\nmultitude of formal languages of different use and purpose: Isabelle/ML, <br>\nIsabelle/Scala, Isabelle/Pure, Isabelle/HOL, Isabelle/Isar, Isabelle/XYZ.</p>\n<p>See also <br>\n<a href=\"https://sites.google.com/site/isabelleedinburgh2013/Slides_makarius.pdf?attredirects=0\">https://sites.google.com/site/isabelleedinburgh2013/Slides_makarius.pdf?attredirects=0</a> <br>\nnotably slide 4 about <em>some</em> languages of Isabelle.</p>\n<p>Makarius</p>",
        "id": 294240647,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906825
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIf people want to prove theorems, they had better turn to us :-)</p>\n<p>Larry</p>",
        "id": 294240727,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906861
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I want to recover the ordered pair part of an int. I actually have a <br>\nsimple solution like this:</p>\n<p>definition myI :: \"int =&gt; nat * nat\" where<br>\n   \"myI x = (nat x, nat (-x))\"</p>\n<p>In the process of getting to the above definition, I was trying to get <br>\nthe ordered pair using lower level methods. Even though I have a <br>\nsolution, I ask about these other methods in case there's something <br>\nuseful there for me to use.</p>\n<p>In Int.thy, on line 20, int is defined as a quotient_type:</p>\n<p>(020) quotient_type int = \"nat * nat\" / \"intrel\"<br>\n(021)   morphisms Rep_Integ Abs_Integ</p>\n<p>The type of Rep_Integ is (int =&gt; (nat * nat)), so I try to use it with <br>\nsomething like \"Rep_Integ 3\", but I can't ever get it to return an <br>\nordered pair like (3,0).</p>\n<p>QUESTION: Is there a way for me to get \"Rep_Integ 3\" to return (3,0)?</p>\n<p>I try to do some lifting, like on line 208:</p>\n<p>(208) lift_definition of_int :: \"int =&gt; 'a\" is \"%x(i,j). of_nat i - <br>\nof_nat j\"</p>\n<p>However, on line 1661, there's this:</p>\n<p>(1661) declare Quotient_int [quot_del]</p>\n<p>In isar-ref.pdf, it tells me that's to disable lifting for int, and so I <br>\ntry to enable it blindly like,</p>\n<p>setup_lifting Quotient_int,</p>\n<p>but I get a warning, and lifting doesn't work for me.</p>\n<p>QUESTION: Can I enable lifting for int?</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294241840,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907303
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThe simple answer is no. What your request is impossible. The integers are constructed as a quotient and therefore the representation of an integer is an equivalence class, in this case a set of pairs of natural numbers. The construction does not give you a map from integers to some distinguished element of this set. Of course, nothing stops you from writing your own function from integers to pairs of natural numbers.</p>\n<p>Some time ago I wrote a paper on such matters, which you may find useful:</p>\n<p><a href=\"http://www.cl.cam.ac.uk/~lp15/papers/Reports/equivclasses.pdf\">http://www.cl.cam.ac.uk/~lp15/papers/Reports/equivclasses.pdf</a></p>\n<p>Larry Paulson</p>",
        "id": 294241862,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907310
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nOn 05/21/2013 05:22 AM, Gottfried Barrow wrote:</p>\n<blockquote>\n<p>I try to do some lifting, like on line 208:</p>\n<p>(208) lift_definition of_int :: \"int =&gt; 'a\" is \"%x(i,j). of_nat i -<br>\nof_nat j\"</p>\n<p>However, on line 1661, there's this:</p>\n<p>(1661) declare Quotient_int [quot_del]</p>\n<p>In isar-ref.pdf, it tells me that's to disable lifting for int, and so I<br>\ntry to enable it blindly like,</p>\n<p>setup_lifting Quotient_int,</p>\n<p>but I get a warning, and lifting doesn't work for me.</p>\n</blockquote>\n<p>I guess \"lifting doesn't work for me\" means this:</p>\n<p>Lifting failed for the following term:<br>\nTerm:  λ(i∷nat, j∷nat). of_nat i - of_nat j<br>\nType:  nat × nat ⇒ ?'b∷{minus,semiring_1}</p>\n<p>Reason:  The type of the term cannot be instantiated to \"nat × nat ⇒ <br>\n'a∷type\".</p>\n<p>And this gives you a hint where the problem is:<br>\nyou cannot instantied 'a::type for ?'b::{minus, semiring_1}.</p>\n<p>The original definition of of_int in Int.thy is done in a context ring_1.</p>\n<p>Try this:</p>\n<p>lift_definition of_int :: \"int =&gt; 'a::ring_1\" is \"%(i,j). of_nat i - <br>\nof_nat j\"</p>\n<blockquote>\n<p>QUESTION: Can I enable lifting for int?</p>\n</blockquote>\n<p>Yes, by the command you used:<br>\nsetup_lifting Quotient_int<br>\nor even better together with the reflexivity theorem:<br>\nsetup_lifting Quotient_int int_equivp[THEN  equivp_reflp2]</p>\n<p>Ondrej</p>",
        "id": 294241943,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907340
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nLarry,</p>\n<p>Alright, your paper will be the explanatory comments to Int.thy that <br>\neveryone forgot to put in. Your slides will also be useful:</p>\n<p><a href=\"http://www.cl.cam.ac.uk/~lp15/papers/Reports/equivclasses-slides.pdf\">http://www.cl.cam.ac.uk/~lp15/papers/Reports/equivclasses-slides.pdf</a> <br>\n&lt;<a href=\"http://www.cl.cam.ac.uk/%7Elp15/papers/Reports/equivclasses-slides.pdf\">http://www.cl.cam.ac.uk/%7Elp15/papers/Reports/equivclasses-slides.pdf</a>&gt;</p>\n<p>I just need to match up a little of your notation in the paper with the <br>\nnewer Isar that's in Int.thy, and a lot of the naming is the same.</p>\n<p>It'd be interesting to know if it's common these days for other <br>\nlanguages to use the classic definition of the integers as equivalence <br>\nclasses like you did with Int.thy:</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Integer#Construction\">https://en.wikipedia.org/wiki/Integer#Construction</a></p>\n<p>It seems it's common for the natural numbers to be built using the <br>\nsuccessor function, but I'm guessing it's not so common for the integers <br>\nto be equivalence classes.</p>\n<p>I only need one representation of an integer, like (3,0) for 3, which I <br>\ncan use to tie into an equivalence class of my own, if that's the way I <br>\nshould do things, and it will work out.</p>\n<p>Thanks for the help,<br>\nGB</p>",
        "id": 294242035,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907377
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOndřej,</p>\n<p>One thing led to another, and I did a bunch of searches, and it turns <br>\nout you would be one of the two to ask for a tutorial on lifting, but <br>\nI'm sure you don't have time.</p>\n<p>I found this:</p>\n<p><a href=\"http://www4.in.tum.de/~kuncar/documents/huffman-kuncar-itp2012.pdf\">http://www4.in.tum.de/~kuncar/documents/huffman-kuncar-itp2012.pdf</a> <br>\n&lt;<a href=\"http://www4.in.tum.de/%7Ekuncar/documents/huffman-kuncar-itp2012.pdf\">http://www4.in.tum.de/%7Ekuncar/documents/huffman-kuncar-itp2012.pdf</a>&gt;</p>\n<p>And it turns out you have connections to Josef Urban.</p>\n<p>I got rid of my setup_lifting warning by importing Quotient_Product.thy, <br>\nfrom a tip of yours here:</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-January/msg00127.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-January/msg00127.html</a></p>\n<p>Now, I do setup_lifting, and the line of code you gave me works, so I'm <br>\nat an error for a simple thing I want to do, which will show you that I <br>\nhave a fundamental misunderstanding of how to use lifting:</p>\n<p>setup_lifting Quotient_int<br>\n    lift_definition of_int :: \"int =&gt; 'a::ring_1\" is \"%(i, j). of_nat i</p>\n<p>- of_nat j\"<br>\n       by(metis int.abs_eq_iff of_int.abs_eq)</p>\n<p>lift_definition foo45 :: \"int =&gt; nat * nat\" is \"%(x,y). (nat x, nat y)\"</p>\n<p>The last line gives this error:</p>\n<p>Lifting failed for the following types:<br>\n    Raw type:  int<br>\n    Abstract type:  nat<br>\n    Reason:  No quotient type \"Nat.nat\" found.</p>\n<p>But my \"foo45\" represents what I want, but you'll have to tell me <br>\nexactly what I have to do to get something like that.</p>\n<p>I've attached a screenshot which shows the four lines of code above, <br>\nwith the error.</p>\n<p>Thanks for the help,<br>\nGB<br>\n<a href=\"/user_uploads/14278/OJ01DXncNsr6OC5tAyy8EvFt/130521a__lifting_attempt.png\">130521a__lifting_attempt.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/OJ01DXncNsr6OC5tAyy8EvFt/130521a__lifting_attempt.png\" title=\"130521a__lifting_attempt.png\"><img src=\"/user_uploads/14278/OJ01DXncNsr6OC5tAyy8EvFt/130521a__lifting_attempt.png\"></a></div>",
        "id": 294242054,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907390
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nIn my experience it is quite the other way round. The first semesters<br>\nmathematics course I attended introduced the integers, the rational<br>\nnumbers and the real numbers as equivalence classes. Only the natural<br>\nnumbers and the complex numbers where introduced like a datatype.</p>\n<p>- Johannes</p>",
        "id": 294242064,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907396
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMy slides briefly hint at the reason why the integers and rationals are almost invariably defined using equivalence classes and not using particular representations such as signed natural numbers or reduced fractions. It is simply that equivalence classes make everything much easier.</p>\n<p>Imagine defining addition on signed natural numbers. You will need at least three cases: (1) the signs agree (2) left operand is greater (3) right operand is greater. To prove the associative law, you will have four occurrences of the addition operator and therefore 81 separate cases. With equivalence classes, there is only one case and it is shown in full on one of the slides.</p>\n<p>For fractions in reduced form, the situation is even worse, because you're constantly reasoning about greatest common divisors. With equivalent classes, there is no need for that.</p>\n<p>Larry Paulson</p>",
        "id": 294242137,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907410
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nThe term \"(nat x, nat y)\" has type \"int * int\" and you want to lift it <br>\nto a term of the type \"nat * nat\". That's not possible because there is <br>\nnot registered any such quotient (or subtype) (i.e., using integers to <br>\nrepresent natural numbers).</p>\n<p>What you probably meant (but I don't know I am just guessing your <br>\nintentions), is this definition:</p>\n<p>lift_definition foo45 :: \"int =&gt; nat * nat\" is \"%(x,y). (x, y)\"</p>\n<p>This is type correct but you can't prove the respectfulness theorem <br>\nsince this theorem implies that each equivalence class in a definition <br>\nof integers contains exactly one element. That's not true.</p>\n<p>You need some kind of a normalization function that picks up one element <br>\nfor each class. For example:</p>\n<p>lift_definition foo45 :: \"int =&gt; nat * nat\" is \"%(x,y). (x - y, 0)\" by auto</p>\n<p>This gives you for each positive integer x a pair (x, 0) and for each <br>\nnegative integer (0, 0).</p>\n<p>For deep understanding I recommend read the paper that Brian and I wrote <br>\nabout Lifting/Transfer and it is also good to know how typedef works. <br>\nYou can also read a paper by Kaliszyk, Urban <br>\n(<a href=\"http://www.inf.kcl.ac.uk/staff/urbanc/Publications/sac-11.pdf\">http://www.inf.kcl.ac.uk/staff/urbanc/Publications/sac-11.pdf</a>).</p>\n<p>Ondrej</p>",
        "id": 294242163,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907422
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nJohannes,</p>\n<p>Thanks for your comment. I was comparing the formal, textbook <br>\nconstruction of the integers, as in what you're listing, to concrete <br>\nimplementations of integers in programming languages, such as Coq, <br>\nIsabelle/HOL, Haskell, or any other language, old or new, but especially <br>\nnew.</p>\n<p>I'm speculating that this ability of Isabelle/HOL to define integers as <br>\nequivalence classes is special, and that it takes a special foundation <br>\nin a language to be able to do it, and that most languages don't have <br>\nthe foundation to be able to do it in a practical way.</p>\n<p>But I wouldn't know. This is the first time I've ever delved into the <br>\nlow-level internals of a programming language, but defining an integer <br>\nas a set, in particular as an equivalence class, seems like it requires <br>\nsome clever and sophisticated foundational code.</p>\n<p>First, a person would simply know how it could be done at all. But <br>\nthat's not enough; their code would have to perform reasonably fast.</p>\n<p>I wouldn't know where to begin, and I'm sure any initial discovery of <br>\nmine on how to do it would be so slow, it would be useless.</p>\n<p>All that to say, I'm guessing that Isabelle/HOL is pretty special in <br>\nthis ability to achieve a textbook definition of the integers. But I try <br>\nnot to become dogmatic about things I don't know about, and it could be <br>\nthat it's very common for programming languages to implement integers as <br>\nequivalence classes.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294242171,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907428
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nCoq and Isabelle/HOL are proof assistants, not programming languages. I can't imagine what gave you that idea. In Coq and Isabelle/HOL you write specifications, not code.</p>\n<p>Larry Paulson</p>",
        "id": 294242178,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907434
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\n2013-05-22 14:26 Lawrence Paulson:</p>\n<blockquote>\n<p>Coq and Isabelle/HOL are proof assistants, not programming languages. I can't imagine what gave you that idea. In Coq and Isabelle/HOL you write specifications, not code.</p>\n</blockquote>\n<p>Well, but there _is_ a notion of \"programming\" in Isabelle, given that<br>\nit is based on a functional programming language, isn't it?  I recall<br>\nthis earlier discussion on the title of the \"programming and proving\"<br>\ntutorial:<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-November/msg00148.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-November/msg00148.html</a></p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294242182,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907440
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 5/22/2013 8:26 AM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>Coq and Isabelle/HOL are proof assistants, not programming languages. I can't imagine what gave you that idea. In Coq and Isabelle/HOL you write specifications, not code.</p>\n<p>Larry Paulson</p>\n</blockquote>\n<p>Larry,</p>\n<p>My general rule is to never use emoticons, but rules have their exceptions.</p>\n<p>You gave me that idea :). As to acronyms such as \"lol\", even under these <br>\ncircumstances, they're still unacceptable.</p>\n<p>This is the specific email:</p>\n<p><a href=\"http://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-August/msg00034.html\">http://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-August/msg00034.html</a></p>\n<p>This will contain the thread:</p>\n<p><a href=\"http://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-August/thread.html\">http://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-August/thread.html</a> <br>\n&lt;<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-August/thread.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-August/thread.html</a>&gt;</p>\n<p>I was just starting to decide that under certain contexts, I could refer <br>\nto Isabelle/HOL as a programming language, because it's just a lot <br>\neasier to use that phrase sometimes, whereas, according to your specific <br>\nclarification in the email linked to above, Isabelle/Pure and <br>\nIsabelle/Isar are never to be called programming languages, so I try to <br>\nuse \"proof language\" or \"source language\" when referring to them, even <br>\nwhen I know others might not get my point.</p>\n<p>One of my other recent emails to the list spawned some private chatter <br>\nin which I referred to HOL as a programming language, which resulted in <br>\na similar response to yours,  which paraphrased would be, \"What is this <br>\nprogramming language you're talking about in reference to HOL?\"</p>\n<p>That's why I had easy access to the links above, because I thought I had <br>\nthe perfect, authoritative reference to explain that Isabelle/HOL is a <br>\nprogramming language, where Pure and Isar aren't.</p>\n<p>In an attempt to use safe, correct vocabulary, I've resorted to using <br>\n\"coding language\" when trying to refer to the whole Isabelle family of <br>\nlanguages. At some point, there's a need for phrases, like, \"I'm <br>\nprogramming with Isabelle/HOL\", or, \"I'm coding with Isabelle\". Like I <br>\nsay, \"coding\" has become my word of choice to replace \"programming\".</p>\n<p>Anyway, I'm happy to try and use the official vocabulary correctly. <br>\nThere are a ton of interwined languages with Isabelle, so I give up and <br>\nget lazy sometimes, and just say \"programming language\".</p>\n<p>As to Coq, it seems to me if I can call Isabelle/HOL a programming <br>\nlanguage, then I can call Coq a programming language. That's just an <br>\naside. I'd be happy to use any official Coq vocabulary to use to refer <br>\nto Coq.</p>\n<p>Regards,<br>\nGB</p>\n<blockquote>\n<p>On 22 May 2013, at 14:16, Gottfried Barrow&lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;  wrote:</p>\n<blockquote>\n<p>Thanks for your comment. I was comparing the formal, textbook construction of the integers, as in what you're listing, to concrete implementations of integers in programming languages, such as Coq, Isabelle/HOL, Haskell, or any other language, old or new, but especially new.<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294242192,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907447
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Wed, May 22, 2013 at 2:45 PM, Christoph LANGE &lt;<br>\n<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>2013-05-22 14:26 Lawrence Paulson:</p>\n<blockquote>\n<p>Coq and Isabelle/HOL are proof assistants, not programming languages. I<br>\ncan't imagine what gave you that idea. In Coq and Isabelle/HOL you write<br>\nspecifications, not code.</p>\n</blockquote>\n<p>Well, but there _is_ a notion of \"programming\" in Isabelle, given that<br>\nit is based on a functional programming language, isn't it?</p>\n</blockquote>\n<p>I would not put it that way.<br>\nBoth Isabelle/HOL and &lt;your favourite functional programming language&gt; are<br>\nbased on some flavour of lambda calculus. That's the connection.<br>\nHowever, there is no evaluation strategy specified for Isabelle/HOL terms,<br>\nand several constants don't have reducible definitions.<br>\nIt's possible (and even common) to write uncomputable specifications in HOL<br>\nwhereas you can't write anything uncomputable in a programming language.</p>\n<blockquote>\n<p>I recall<br>\nthis earlier discussion on the title of the \"programming and proving\"<br>\ntutorial:</p>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-November/msg00148.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-November/msg00148.html</a></p>\n<p>Cheers,</p>\n<p>Christoph</p>\n<p>--<br>\nChristoph Lange, School of Computer Science, University of Birmingham<br>\n<a href=\"http://cs.bham.ac.uk/~langec/\">http://cs.bham.ac.uk/~langec/</a>, Skype duke4701</p>\n<p>→ Intelligent Computer Mathematics, 8–12 July, Bath, UK.<br>\n  Work-in-progress deadline 7 June; <a href=\"http://cicm-conference.org/2013/\">http://cicm-conference.org/2013/</a><br>\n→ OpenMath Workshop, 10 July, Bath, UK.<br>\n  Submission deadline 7 June; <a href=\"http://cicm-conference.org/2013/openmath/\">http://cicm-conference.org/2013/openmath/</a></p>\n</blockquote>",
        "id": 294242217,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907459
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou can call anything anything, but you are only complicating things for yourself. To my mind, asking why Isabelle/HOL has equivalence classes when Haskell doesn't and they are both programming languages is a bit like asking why a Boeing can fly and a Ford cannot when they are both cars.</p>\n<p>Perhaps the term you are looking for is \"formal language\". Programming languages are formal, and higher-order logic is also a formal language. Just as Boeings and Fords are both vehicles.</p>\n<p>Larry Paulson</p>",
        "id": 294242249,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907471
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOndřej,</p>\n<blockquote>\n<p>What you probably meant (but I don't know I am just guessing your <br>\nintentions), is this definition:</p>\n<p>lift_definition foo45 :: \"int =&gt; nat * nat\" is \"%(x,y). (x, y)\"</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p>This is type correct but you can't prove the respectfulness theorem <br>\nsince this theorem implies that each equivalence class in a definition <br>\nof integers contains exactly one element. That's not true.</p>\n<p>You need some kind of a normalization function that picks up one <br>\nelement for each class. For example:</p>\n<p>lift_definition foo45 :: \"int =&gt; nat * nat\" is \"%(x,y). (x - y, 0)\" by <br>\nauto</p>\n</blockquote>\n<p>And so telling me that I need to prove \"respectfulness\" represents this <br>\nbig need of people like me to have some understanding of what's going on <br>\nunder the hood of the engine. Things like \"fun\" and lifting are great <br>\nbecause they take care of a lot of overhead, until I stray outside of <br>\nsome example/template I have.</p>\n<blockquote>\n<p>This gives you for each positive integer x a pair (x, 0) and for each <br>\nnegative integer (0, 0).</p>\n</blockquote>\n<p>This is one more time in which lifting appears to not be the best <br>\nsolution. I think it'll be hard to beat the simple definition that I <br>\ncame up with. But the value in these attempts to use lifting is in <br>\ngetting closer to knowing what lifting is.</p>\n<blockquote>\n<p>For deep understanding I recommend read the paper that Brian and I <br>\nwrote about Lifting/Transfer and it is also good to know how typedef <br>\nworks. You can also read a paper by Kaliszyk, Urban <br>\n(<a href=\"http://www.inf.kcl.ac.uk/staff/urbanc/Publications/sac-11.pdf\">http://www.inf.kcl.ac.uk/staff/urbanc/Publications/sac-11.pdf</a>).</p>\n</blockquote>\n<p>And so I have 3 papers to pull from now, yours, Peter's and this one you <br>\njust listed. All along it's been, \"Something's being lifted from <br>\nsomewhere, to some thing, but what's being lifted is not clear to me, <br>\nand neither are the restrictions on what the some thing can be.\"</p>\n<p>It looks like Urban and Kaliszyk's paper provides a good conceptual <br>\noverview. From section 5:/<br>\n/</p>\n<p>/The main benefit of a quotient package is to lift automatically<br>\n    theorems over raw types to theorems over quotient types. We will<br>\n    perform this lifting in three phases, called regularization,<br>\n    injection and cleaning according to procedures in Homeier’s ML-code./</p>\n<p>So I was asking myself, \"What's this Homeier's ML-code?\"</p>\n<p>And then I replied, \"Oh, that would be Peter Homeier, who sent me a link <br>\nto his paper on quotients earlier in the day, in response to my global <br>\nrequest for docs on quotients and lifting.\"</p>\n<p>With quotients and lifting, it appears that if you learn the one, you <br>\nlearn the other.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294242411,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907533
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nLarry,</p>\n<p>I was going to let your email be the end, a decision which actually <br>\nresulted in me culling out every point I thought about making, except <br>\nfor trying to make a point with your transportation analogy.</p>\n<p>To summarize the point to begin with, so you don't have to actually read <br>\nthe analogy, it's just a variation of my past \"Isabelle is awesome\" <br>\nstatements.</p>\n<p>So Isabelle/HOL is a Boeing airplane, though a special model that's <br>\nconfigurable, and Haskell is a Ford car.</p>\n<p>In regards to transportation, it appears not to make sense for a person <br>\nto make anything but the broadest of generalizations when comparing the two.</p>\n<p>That's because, Isabelle, being a Boeing airplane, is certainly a means <br>\nof transportation, but the maintenance and fuel costs are extraordinary, <br>\nand so on the surface, to point out that Haskell, a Ford car, hasn't <br>\nimplemented certain theoretical, engineering concepts when Isabelle has, <br>\ncan appear to be dumb, especially, because practically speaking, as far <br>\nas transportation the advanced features are of no use.</p>\n<p>However, the proper context is my use of the special, configurable <br>\nBoeing airplane. It happens to be that I have almost no interest in <br>\ntraveling, I only care to theorize about traveling, in particular, <br>\ntheorizing about air travel.</p>\n<p>At this time, I don't have the money to even have the Boeing started up, <br>\nbut then again, at this point, I only have a need to look at the Boeing, <br>\nand take a few measurements for certain parts that aren't completely <br>\ndocumented.</p>\n<p>Now, I would hope that in several years, I'm doing something more than <br>\nwhat has already been done in regards to theorizing about air travel, to <br>\nthe point to where I have a need to do more than just look at the <br>\nairplane, but in two years time, manufacturing costs being what they <br>\nare, there's some chance it will be affordable for me to pay some per <br>\nminute charge to reconfigure the special Boeing, where simply <br>\nreconfiguring it should answer some question I'll have.</p>\n<p>So forth and so on. As times passes, what was once not affordable <br>\nbecomes affordable, in regards to testing my theories. The upside is <br>\nthat I may never have to resort to buying a Ford car, which is <br>\naccessible to the masses, but still costs a lot of money, and is a waste <br>\nif I don't have to do it.</p>\n<p>And there's the possibility, if I can keep postponing the need for a <br>\nFord car, that at some point, the configurable Boeing has ceased to be <br>\nleading edge technology, for near exclusive use by academics and <br>\nresearchers, but the costs have dropped so much that it has become <br>\ncommodity technology, and things have evolved for me to the where I now <br>\nhave a need to travel, but not simply on the ground, like with the Ford <br>\ncar, but in the air.</p>\n<p>Do the designers intend for a person like me to use the Boeing in this <br>\nway? Probably not. Most likely, the configurable Boeing is meant as an <br>\nends to a mean for professionals who work in the aerospace industry.</p>\n<p>But instead of of using the configurable Boeing as an ends to a means, I <br>\nuse it as an ends in itself, and because it can be used like that, it's <br>\nawesome.</p>\n<p>Well, because I have no desire to ever work outside the realm of the <br>\nconfigurable Boeing, certain vocabulary doesn't fit my use of the Boeing <br>\nas good as it fits the designers use, but that idea is not to be pursued <br>\nhere.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294242475,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907557
    }
]