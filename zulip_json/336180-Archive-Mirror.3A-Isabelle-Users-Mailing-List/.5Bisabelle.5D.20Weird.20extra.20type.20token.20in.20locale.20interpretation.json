[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi all,</p>\n<p>I stumbled across the following problem with locales, see below for a <br>\nsmall example.</p>\n<p>Locale \"heap\" simply fixes the operations \"empty_heap\", \"new_obj\" and <br>\n\"typeof_addr\" and defines in terms of them two other functions <br>\n\"addr_of_sys_xcpt\" and \"preallocated\".</p>\n<p>The first depends only on the parameters empty_heap and new_obj.<br>\npreallocated is defined in terms of addr_of_sys_xcpt and thus depends on <br>\nall three parameters, although only on typeof_addr directly.</p>\n<p>Next, I interpret this locale (with prefix test), where new_obj gets <br>\ninstantiated to some function sc_new_obj that is partially applied to <br>\nsome list P, which the for clause declares. In its definition, <br>\nsc_new_obj is polymorphic in the list's element type.</p>\n<p>Since interpretation parameters declared in for clauses become <br>\nadditional parameters of the abbreviations that the interpretation <br>\nintroduces, I would have expected that \"test.preallocated\" abbreviates</p>\n<p>%P. heap.preallocated Map.empty (sc_new_obj P) id\"</p>\n<p>and has type \"'a list =&gt; (nat ~=&gt; ty) =&gt; bool\".</p>\n<p>However</p>\n<p>term test.preallocated</p>\n<p>produces</p>\n<p>\"%TYPE P. heap.preallocated Map.empty (sc_new_obj P) id\"<br>\n   :: \"'a itself =&gt; 'a list =&gt; (nat ~=&gt; ty) =&gt; bool\"</p>\n<p>test.preallocated expects an additional type token, which is <br>\nunnecessary, because the same type variable also occurs in the second <br>\nparameter! Why is that? And how can I get test.preallocated without the <br>\nextra type token?</p>\n<p>Here is the example for Isabelle2009-1:</p>\n<p>typedecl ty</p>\n<p>locale heap =<br>\n   fixes empty_heap :: \"'heap\"<br>\n   and new_obj :: \"'heap =&gt; string =&gt; ('heap * nat option)\"<br>\n   and typeof_addr :: \"'heap =&gt; nat =&gt; ty option\"<br>\nbegin</p>\n<p>definition addr_of_sys_xcpt :: \"string =&gt; nat\"<br>\nwhere<br>\n   \"addr_of_sys_xcpt C =<br>\n    (let (h0,  a0) = new_obj empty_heap ''foo''<br>\n     in if C = ''foo'' then the a0<br>\n        else undefined)\"</p>\n<p>definition preallocated :: \"'heap =&gt; bool\"<br>\nwhere<br>\n   \"preallocated h = (typeof_addr h (addr_of_sys_xcpt ''foo'') ~= None)\"</p>\n<p>end</p>\n<p>types sc_heap = \"nat =&gt; ty option\"</p>\n<p>definition sc_new_obj :: \"'a list =&gt; sc_heap =&gt; string =&gt; (sc_heap * nat <br>\noption)\"<br>\nwhere \"sc_new_obj P h C = (h, None)\"</p>\n<p>interpretation test!: heap Map.empty \"sc_new_obj P\" id for P<br>\n.</p>\n<p>term test.preallocated</p>\n<p>Regards,<br>\nAndreas</p>",
        "id": 294105488,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835061
    }
]