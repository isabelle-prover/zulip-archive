[
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHello all,</p>\n<p>The left-hand side of the following lemma is simply an eta-expanded<br>\nversion of the right-hand side. It could be solved immediately by<br>\n\"apply (rule refl)\". One might think that the simplifier could easily<br>\nhandle such a simple task.</p>\n<p>lemma \"(%n. nat_case 1 Suc n) = (nat_case 1 Suc)\"<br>\nby simp</p>\n<p>But... the proof fails! If you do \"apply simp\" instead, here's what is<br>\nleft over:</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>(%n. nat_case 1 Suc n) = nat_case (Suc 0) Suc</li>\n</ol>\n<p>The problem is that there is a congruence rule for nat_case:</p>\n<p>Nat.nat.weak_case_cong:<br>\n  M = M' ==&gt; nat_case f1 f2 M = nat_case f1 f2 M'</p>\n<p>On the eta-expanded left-hand side, the congruence rule applies and<br>\nprevents the \"1\" from being rewritten to \"Suc 0\". But the congruence<br>\nrule does not apply to the eta-contracted right-hand side.</p>\n<p>To prevent the simplifier from rewriting the first two arguments of<br>\nnat_case it seems like we really need a couple more congruence rules<br>\nfor the partially-applied cases:</p>\n<p>lemma nat_weak_case_cong2 [cong]: \"nat_case f1 f2 = nat_case f1 f2\"<br>\nlemma nat_weak_case_cong3 [cong]: \"nat_case f1 = nat_case f1\"</p>\n<p>... but the simplifier only allows one congruence per constant to be<br>\nactive at one time.</p>\n<p>This problem is actually important in practice: It makes some internal<br>\nproofs in the HOLCF fixrec package break for certain definitions. To<br>\navoid this issue, I am forced to have fixrec maintain its own private<br>\nsimpset that doesn't include any congruence rules.</p>\n<p>It seems like Isabelle tries to maintain the illusion that<br>\neta-equivalent terms are identical (especially when the \"Eta Contract\"<br>\noption is enabled in ProofGeneral). The behavior I have described<br>\nabove breaks this abstraction.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294107739,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835767
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nHello Brian &amp; Isabelle users.</p>\n<p>There's a tension here between Isabelle's resolution engine and its rewriting engine. The resolution engine makes eta-expansion irrelevant; the simplification engine does not. This is more often seen with simplification rules like o_apply - simple constants like \"op o\" seem to get unfolded inexplicably, the explanation being that the term they were in had been invisibly eta-expanded at some point. The advantage in this case is that it's usually easy to understand what's happened, even if it's difficult to explain why.</p>\n<p>The situation with congruence rules, however, is deeply unpleasant. The simpler way to fix your problem was to install the stronger form of the nat_case congruence rule, nat.case_cong. This one strengthens rather than degrades the simplifier, and eta contraction makes less difference.</p>\n<p>As I understand it, the weak case rules are installed to prevent the rewrite rules of complex recursive functions (e.g. \"f x = if x = 0 then 1 else x * f (x - 1)\") looping the simplifier. I agree that looping must be prevented, even at the cost of making the simplifier work less often. My experience from the L4.verified project, however, is that it is far preferable to remove the rewrite rules of such functions than to degrade the simplifier.</p>\n<p>There are four reasons for this:<br>\n  1) Novice Isabelle users just don't understand the current default setup, nor do they understand what congruence rules are. It shouldn't be this complicated to explain when (simp add: useful_rule_we_wrote) will work.<br>\n  2) The current situation won't stop looping anway, as split_if is in the default splitter set. The above function will loop the simplifier, as will many, If being more common than any case expression.<br>\n  3) It's easy to write a terminating function that doesn't depend on a case expression for termination. Consider this (contrived) code in the error+state monad:<br>\n\"f = do<br>\n  done &lt;- checkIfDone<br>\n  when done $ throwError ()<br>\n  takeOneStep<br>\n  f<br>\n\"<br>\n  This function might terminate (depending on the behaviour of checkIfDone and takeOneStep). Its expansion rule must be dropped from the simpset to prevent looping.<br>\n  4) Proofs about complex recursive functions of this type were usually complex and done by induction anyway. Having to manually unroll them with subst is not much additional effort.</p>\n<p>In short, I would prefer it if the stronger case congruence rules were in the default simpset and looping was prevented by other means.</p>\n<p>Yours,<br>\n    Thomas.</p>",
        "id": 294108008,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835859
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYou are right as to the motivation for the design. It seemed to better<br>\nchoice at the time. I still find it works well for me. But I would not<br>\nwant to argue with you if you say that you think the opposite choice<br>\nworks better for your L4.verified, and that may actually be more<br>\nrepresentative for the average user. It was a heuristic design. I<br>\nsuspect it would be a lot of work to reverse it.</p>\n<p>Tobias</p>\n<p>Thomas Sewell schrieb:</p>",
        "id": 294108028,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835866
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThe current design has the advantage of causing simplification to resemble execution: the arms of a conditional or case expression are left untouched until the relevant case has been identified. I would not express this as \"degrading the simplifier\". It certainly doesn't degrade its performance. However, I agree that there are situations where people are surprised that obvious simplifications do not take place in a case expression.</p>\n<p>Larry</p>\n<p>Thomas Sewell schrieb:</p>\n<blockquote>\n<p>As I understand it, the weak case rules are installed to prevent the rewrite rules of complex recursive functions (e.g. \"f x = if x = 0 then 1 else x * f (x - 1)\") looping the simplifier. I agree that looping must be prevented, even at the cost of making the simplifier work less often. My experience from the L4.verified project, however, is that it is far preferable to remove the rewrite rules of such functions than to degrade the simplifier.</p>\n</blockquote>",
        "id": 294108036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835871
    }
]