[
    {
        "content": "<p>From: Yuhui Lin &lt;<a href=\"mailto:Y.H.Lin-2@sms.ed.ac.uk\">Y.H.Lin-2@sms.ed.ac.uk</a>&gt;<br>\nHi all,</p>\n<p>With the change of representation for set, quickcheck can find counter examples for the type like \"nat set\" now. When I use quickcheck for the following example, </p>\n<p>definition <br>\n  forwardcomp :: \"('a * 'b) set ⇒ ('b * 'c) set ⇒ ('a * 'c) set\" (infixl \";\" 40)<br>\nwhere \"p ; q ≡ {(x,y). ∃ z. (x,z) ∈ p ∧ (z,y) ∈ q}\"</p>\n<p>locale myspec =<br>\nfixes<br>\nv1 v2 v3 :: \"(nat * nat) set\"</p>\n<p>lemma (in myspec) <br>\n\"((v1 Un v2) ; v3) = ((v1 ; v3) Un (v2 ; v3))\"<br>\nquickcheck<br>\noops</p>\n<p>it promote  the error message<br>\nWellsortedness error:<br>\nType nat not of sort {enum,equal}<br>\nNo type arity nat :: enum </p>\n<p>What do I miss here ? Many thanks.</p>\n<p>Best,<br>\nYuhui Lin</p>",
        "id": 294221187,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897569
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Yuhui,</p>\n<p>the problem is the existential quantifier in the definition of forwardcomp. <br>\nIsabelle provides an executable implementation for types of whose elements it is <br>\nhas a complete list (which is formalised in type class enum). Since lists are <br>\nfinite, nat is not and cannot be an instance. As quickcheck relies on executable <br>\nimplementations for all constants, this explains the error message.</p>\n<p>If you want to quickcheck lemmas that depend on forwardcomp, you need to provide <br>\nan executable implementation yourself. By default, Isabelle2012 implements sets <br>\nas the list of its elements (or by the list of the set's complement). Hence, you <br>\ncould prove the following code equation by \"pattern-matching\" on the <br>\n\"implementation constructor\" set.</p>\n<p>lemma forwardcomp_code [code]:<br>\n   \"(set ps; set qs) =<br>\n   set (concat (map (l(x, y). map (l(y', z'). (x, z')) (filter (l(y', z'). y = <br>\ny') qs)) ps))\"<br>\nby(fastforce simp add: forwardcomp_def)</p>\n<p>Then, you can quickcheck your lemma. Side remark: For a complete implementation, <br>\nyou would probably want to cover all \"implementation constructors\" for 'a set, <br>\nwhich are \"set\" and \"List.coset\". But it will be more difficult to find <br>\nappropriate equations for List.coset.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294221191,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897572
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nHi Yuhui,</p>\n<p>I had the same answer as Andreas in my pipeline.</p>\n<p>Alternatively, it should also be possible to give a lemma that describes <br>\nforwardcomp in terms of relcomp, and annotate it with the code attribute.</p>\n<p>Lukas</p>",
        "id": 294221204,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897578
    },
    {
        "content": "<p>From: Yuhui Lin &lt;<a href=\"mailto:Y.H.Lin-2@sms.ed.ac.uk\">Y.H.Lin-2@sms.ed.ac.uk</a>&gt;<br>\nHi,</p>\n<p>Now I've got a new problem to give a code attribute for the following function.<br>\n    \"funimage r x = (THE y. (x, y) ∈ r)\"</p>\n<p>I give a weaker version of code definition, i.e  <br>\n    (funimage (set ss) x) = snd (hd (filter (λ (x0, y0). x = x0) ss))</p>\n<p>but I don't know how to represent it equivalently in list, because it addresses that y is unique and x : r, which returns boolean type. </p>\n<p>I wonder if there is undefined value for list to represent the invalid case, e.g. return the invalid value when y is not unique. Also I'm trying to giving assumptions for the the code attribute, which is <br>\n\"x : Domain (set ss) ==&gt; functional (set ss) ==&gt; (funimage (set ss) x) = snd (hd (filter (λ (x0, y0). x = x0) ss))\"<br>\nThen I receive a warning \"Not a equation\". </p>\n<p>How can I deal with it ? Thanks for helps.</p>\n<p>best,<br>\nYuhui</p>",
        "id": 294222689,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898357
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Yuhui,</p>\n<blockquote>\n<p>Now I've got a new problem to give a code attribute for the following function.<br>\n  \"funimage r x = (THE y. (x, y) ∈ r)\"</p>\n<p>I give a weaker version of code definition, i.e<br>\n  (funimage (set ss) x) = snd (hd (filter (λ (x0, y0). x = x0) ss))<br>\nThis is neither weaker nor stronger. Moreover, your code definition is not a <br>\nproper specification at all - in fact it is unprovable. Otherwise, you would get <br>\nthe following inconsistency</p>\n</blockquote>\n<p>\"0 = funimage (set [(0, 0), (0, 1)]) 0 = funimage (set [(0, 1), (0, 0)]) 0 = 1\"</p>\n<p>because \"set [(0, 0), (0, 1)] = set [(0, 1), (0, 0)]\". In effect, you try to <br>\nexploit additional structure of the list when there is no such in the type of sets.</p>\n<blockquote>\n<p>I wonder if there is undefined value for list to represent the invalid case, e.g. return the invalid value when y is not unique. Also I'm trying to giving assumptions for the the code attribute, which is<br>\n\"x : Domain (set ss) ==&gt;  functional (set ss) ==&gt;  (funimage (set ss) x) = snd (hd (filter (λ (x0, y0). x = x0) ss))\"<br>\nThen I receive a warning \"Not a equation\".<br>\nCode equations must not make assumptions about the parameters. However, you can <br>\nmove the assumptions into a test:</p>\n</blockquote>\n<p>lemma [code]:<br>\n   \"funimage (set ss) x =<br>\n    (if x : Domain (set ss) &amp; functional (set ss)<br>\n     then snd (hd (filter (λ (x0, y0). x = x0) ss))<br>\n     else funimage (set ss) x)\"</p>\n<p>This should be provable and the code generator accepts it. If all your use <br>\ncontexts ensure the preconditions themselves, then this equation is perfectly <br>\nfine. However, if you plan to use quickcheck, you will probably get into <br>\nnon-termination very quickly.</p>\n<p>Therefore, it is better to have the else branch raise an exception than to risk <br>\nnon-termination. You can do so as follows:</p>\n<p>definition funimage_not_unique :: \"(unit =&gt; 'a) =&gt; 'a\"<br>\nwhere [simp]: \"funimage_not_unique f = f ()\"</p>\n<p>code_abort funimage_not_unique</p>\n<p>lemma [code]:<br>\n   \"funimage (set ss) x =<br>\n    (if x : Domain (set ss) &amp; functional (set ss)<br>\n     then snd (hd (filter (λ (x0, y0). x = x0) ss))<br>\n     else funimage_not_unique (%_. funimage (set ss) x))\"</p>\n<p>code_abort funimage_not_unique<br>\ntells the code generator to raise an exeption with message \"funimage_not_unique\" <br>\nwhenever the generated code executes funimage_not_unique.<br>\nThe constant funimage_not_unique itself is almost the identity, i.e., it does <br>\nnot change the else branch fundamentally. The unit closure ensures termination <br>\nin strict languages like ML, because it prohibits to evaluate the argument of <br>\nfunimage_not_unique, which would recurse endlessly.</p>\n<p>Some examples of this technique can be found in the HOL sources, e.g., in <br>\nPredicate.thy. In fact, Predicate already provides an executable definite <br>\ndescription operator (which has been described in [1]). Hence, the following <br>\nshould also work (not tested!):</p>\n<p>lemma<br>\n   \"funimage (set ss) x =<br>\n    Predicate.the (pred_of_set (set (filter (λ (x0, y0). x = x0) ss)))\"</p>\n<p>Hope this helps,<br>\n   Andreas</p>\n<p>[1] Andreas Lochbihler, Lukas Bulwahn, Animating the Formalised Semantics of a <br>\nJava-like Language, Marko van Eekelen and Herman Geuvers and Julien Schmalz and <br>\nFreek Wiedijk (Ed.), Interactive Theorem Proving, pp. 216--232, Springer, 2011.</p>",
        "id": 294222698,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898370
    },
    {
        "content": "<p>From: Yuhui Lin &lt;<a href=\"mailto:Y.H.Lin-2@sms.ed.ac.uk\">Y.H.Lin-2@sms.ed.ac.uk</a>&gt;<br>\nMany thanks for the solution. I can run quick check on these user-defined operations code attributes.  And I wonder for the following defitnion,</p>\n<p>\"Pow1 R = {S. S ≠ {} ∧ S ⊆ R}\"<br>\n\"domres R r = {(x, y) | x y. x ∈ R ∧ (x, y) ∈ r}\"</p>\n<p>there are no quantifiers, and the definitions look simple. I wonder why quick check can't execute them directly. More interestingly, if I unfolder the definition of Pow1, then quick check can work..</p>\n<p>lemma \"(S :: nat set) ~: Pow1 S\"<br>\nlemma \"(domres (s0::nat set) (v1:: (nat*nat set))) Un v2 = domres s0 (v1 Un v2)\"</p>\n<p>Best,<br>\nYuhui</p>",
        "id": 294223718,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898854
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Yuhui,</p>\n<p>Since sets are represented as the list of their elements, the \"Pow1 S\" in your <br>\nfirst lemma needs to be computed explicitly. Now, Pow1 is defined as a set <br>\ncomprehension, which is in general not executable. The default code setup <br>\ncomputes set comprehensions by taking the list of all elements of the type and <br>\nfiltering each by checking the predicate of the set comprehension. If you unfold <br>\nthe definition, your goal has the form \".. : {S. ...}\" and there is a <br>\npreprocessing step in the code generator that simplifies this to \"... ..\", i.e., <br>\nremoves the set comprehension and membership.</p>\n<p>For domres, there are quantifiers. \"{(x, y) | x y. ...}\" is a short-hand for <br>\n\"{u. \\exists x y. u = (x, y) &amp; ...}\". For tuples, you don't need to quantify <br>\nover x and y, so you could simplify the definition to</p>\n<p>\"domres R r = {(x, y). x ∈ R ∧ (x, y) ∈ r}\"</p>\n<p>Nevertheless, the trouble with set comprehensions remains, but you could prove <br>\nagain a custom code equation:</p>\n<p>lemma domres_code [code]:<br>\n   \"domres R (set rs) = set (filter (%(x, y). x : R) rs)\"<br>\nby(auto simp add: domres_def)</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294223847,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898922
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nDear Yuhui,</p>\n<p>On 09/03/2012 10:54 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Dear Yuhui,</p>\n<blockquote>\n<p>And I wonder for the following defitnion,</p>\n<p>\"Pow1 R = {S. S ≠ {} ∧ S ⊆ R}\"<br>\n\"domres R r = {(x, y) | x y. x ∈ R ∧ (x, y) ∈ r}\"</p>\n<p>there are no quantifiers, and the definitions look simple. I wonder <br>\nwhy quick check can't execute them directly. More interestingly, if I <br>\nunfolder the definition of Pow1, then quick check can work..</p>\n<p>lemma \"(S :: nat set) ~: Pow1 S\"<br>\nlemma \"(domres (s0::nat set) (v1:: (nat*nat set))) Un v2 = domres s0 <br>\n(v1 Un v2)\"</p>\n</blockquote>\n<p>Since sets are represented as the list of their elements, the \"Pow1 S\" <br>\nin your first lemma needs to be computed explicitly. Now, Pow1 is <br>\ndefined as a set comprehension, which is in general not executable. <br>\nThe default code setup computes set comprehensions by taking the list <br>\nof all elements of the type and filtering each by checking the <br>\npredicate of the set comprehension. If you unfold the definition, your <br>\ngoal has the form \".. : {S. ...}\" and there is a preprocessing step in <br>\nthe code generator that simplifies this to \"... ..\", i.e., removes the <br>\nset comprehension and membership.</p>\n<p>For domres, there are quantifiers. \"{(x, y) | x y. ...}\" is a <br>\nshort-hand for \"{u. \\exists x y. u = (x, y) &amp; ...}\". For tuples, you <br>\ndon't need to quantify over x and y, so you could simplify the <br>\ndefinition to</p>\n<p>\"domres R r = {(x, y). x ∈ R ∧ (x, y) ∈ r}\"</p>\n<p>Nevertheless, the trouble with set comprehensions remains, but you <br>\ncould prove again a custom code equation:</p>\n<p>lemma domres_code [code]:<br>\n  \"domres R (set rs) = set (filter (%(x, y). x : R) rs)\"<br>\nby(auto simp add: domres_def)</p>\n<p>Andreas is perfectly right with his explanations. It took me also a few <br>\nminutes to understand what Quickcheck is doing there and what not.</p>\n</blockquote>\n<p>You can inspect the code setup with this type of template:</p>\n<p>definition conjecture<br>\nwhere<br>\n   \"conjecture S = ((S :: nat set) ~: Pow1 S)\"</p>\n<p>code_thms conjecture</p>\n<p>In this case, you see that it requires the constant Collect which uses <br>\nenum_class.enum.<br>\nIn general, it somehow black magic (known to some wizards here and <br>\nthere) to understand why something is not executable.</p>\n<p>For the future, we are developing a rewriting procedure in the code <br>\ngenerator that should turn</p>\n<p>\"domres R r = {(x, y) | x y. x ∈ R ∧ (x, y) ∈ r}\" into \"(R \\times UNIV) <br>\n\\inter r\"  behind the scenes which can be executed with the code <br>\ngenerator (and therefore Quickcheck works).</p>\n<p>If you write \"Pow1 R = {S. S ≠ {} ∧ S ⊆ R}\" as \"Pow1 R = Pow R - {{}}\" <br>\nit should also be executable (and Quickcheck works).</p>\n<p>Lukas</p>\n<blockquote>\n<p>Best,<br>\nAndreas<br>\n</p>\n</blockquote>",
        "id": 294223942,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898989
    }
]