[
    {
        "content": "<p>From: <a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a><br>\nI'm looking at this sentence in prog-prove.pdf, page 3:</p>\n<p>Terms are formed as in functional programming by applying<br>\n     functions to arguments. If f is a function of type<br>\n     tau1 =&gt; tau2 and t is a term of type tau1, then f t<br>\n     is a term of type tau2.</p>\n<p>Also, the word \"contain\" in this sentence on page 4 makes me unsure of <br>\nwhat a term is:</p>\n<p>Terms may also contain lambda-abstractions.</p>\n<p>I've looked for other definitions of \"term\" in the Isabelle docs, but <br>\nI'm not sure how constants and variables are used as a part of the <br>\ndefinition of \"term\".</p>\n<p>Here are three questions I've asked myself, with my answers in <br>\nparentheses. You can correct them if you'd like:</p>\n<p>1) Does a term (of Isabelle/HOL) have a type?  (obviously yes)<br>\n2) Is a term (of Isabelle/HOL) a type? (no)<br>\n3) Is a type (of Isabelle/HOL) a term? (no)</p>\n<p>I'm guessing that one difference between a term and a type is related to <br>\nconstants.</p>\n<p>I briefly looked at \"3.2.5 Types and terms\" in isar-ref.pdf, but I can't <br>\nsort that out.</p>\n<p>In intro.pdf (Old Introduction to Isabelle), page 1, it says:</p>\n<p>The syntax for terms is summarised below...<br>\n     t :: tau       type constraint, on a term or bound variable<br>\n     %x . t         abstraction<br>\n     %x1...xn . t   curried abstraction, %x1...%xn . t<br>\n     t(u)           application<br>\n     t(u1,...,un)   curried application, t(u1) ... (un)</p>\n<p>This indicates that a lambda-abstraction can be a term.</p>\n<p>In Paulson's \"Logic and Computation - Interactive proof with Cambridge <br>\nLCF\", in \"Chapter 5 Syntactic Operations for PP-Lambda\", page 142, he says:</p>\n<p>Terms come in four syntactic classes: constants, variables,<br>\n     abstractions, and combinations (function applications).</p>\n<p>This is like a lambda-calculus term, so it looks as if Isabelle/HOL <br>\nterms may not be limited to function application, but I tend to take <br>\nthings literally, so when prog-prove.pdf says, \"Terms are formed as in <br>\nfunctional programming by applying functions to arguments\", that makes <br>\nme wonder whether a term is only function application.</p>\n<p>I'll ask two more questions, in case someone wants to answer them:</p>\n<p>1) Is a term (in Isabelle/HOL) function application only? (probably not)<br>\n2) To what extent do the concepts in \"Part II Cambridge LCF\" of <br>\nPaulson's \"Logic and Computation\" apply to Isabelle/HOL?</p>\n<p>Part I chapters 2, 3, and 4 of \"Logic and Computation\" look like <br>\nsomething I need to work through for foundational material on HOL.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294161964,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853462
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 4 Jun 2012, Ramana Kumar wrote:</p>\n<blockquote>\n<p>Base types, type constructors, and function types are all kinds of type<br>\nconstants, or can be viewed as such.<br>\nA base type might be \":bool\", the type of propositions, which may be<br>\nconsidered as the type constant \"bool\" applied to no arguments.<br>\n(Indeed, every type constant has a fixed number, its arity, of arguments it<br>\nought to take.)<br>\nA function type could be thought of a type constant for functions with<br>\narity 2 (taking the domain and range types as arguments).<br>\nI'm not sure what \"type constructors\" refers to, but probably it's just a<br>\nsynonym for type constants.<br>\nIf I'm getting some details of Isabelle wrong here, I'm sure the list will<br>\npoint it out. I'm speaking primarily from my knowledge of HOL.</p>\n</blockquote>\n<p>Yes, this is basically all the same for Isabelle, although the HOL-ish <br>\ncolon is not part of the name of types in Isabelle; instead double colon <br>\nis used as mere notation.</p>\n<p>I often use myself the terminology \"type constructor\" and \"type constant\" <br>\ninterchangeably, although it might confuse beginners -- who are already <br>\nconfused by the idea of term constant with functional types.</p>\n<blockquote>\n<p>I know Isabelle also has type classes, which complicates the story a bit,<br>\nbut you haven't mentioned them so I won't say anything further.</p>\n</blockquote>\n<p>A little, but not much.  Type classes are just predicates over types plus <br>\nsome sophisticated extra-logical infrastructure to make it all fit <br>\ntogether, including qualified type inference in the style of Haskell98 and <br>\ncode-generation.</p>\n<blockquote>\n<blockquote>\n<p>By all this it now seems clear to me that atomic types are distinct from<br>\natomic terms.</p>\n<p>Indeed all types, atomic or not, are distinct from all terms, atomic or<br>\nnot, in higher-order logic (or \"simple type theory\").</p>\n</blockquote>\n</blockquote>\n<p>Yes, the Isabelle/Pure framework clearly distinguishes 3 main categories <br>\nof types, terms, theorems --- so these are apples, pears, peaches.</p>\n<p>See also <br>\n<a href=\"http://isabelle.in.tum.de/dist/Isabelle2012/doc/implementation.pdf\">http://isabelle.in.tum.de/dist/Isabelle2012/doc/implementation.pdf</a> <br>\nespecially chapter 2, where all this is presented in a condensed manner, <br>\nwith references to the corresponding ML functions.  Section 2.3.2 is <br>\nparticularly funny: it shows some tricks to mix the different kinds of <br>\nformal fruit.</p>\n<p>Makarius</p>",
        "id": 294162142,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853536
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIsabelle's terms are lambda-terms with a type system similar to that of LCF, ML<br>\nor Haskell. The document Programming and Proving in Isabelle is an introduction<br>\nto Isabelle, not a definition. Just like most textbooks on functional<br>\nprogramming it does not start out with the lambda-calculus on page 1.</p>\n<p>To answer the question in your title: variables and constants.</p>\n<p>Tobias</p>",
        "id": 294162523,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853664
    },
    {
        "content": "<p>From: <a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a><br>\nTobias,</p>\n<p>Thanks. I'm trying to get the vocabulary down.</p>\n<p>Unless you tell me different, I'll conclude that term constants and term <br>\nvariables are different than type constants and type variables, though <br>\nthere might not be such a thing as a \"type constant\". I see (morely <br>\nclearly now) that you did precede the introduction of \"terms\" with <br>\nintroducing \"base types\", \"type constructors\", \"function types\", and <br>\n\"type variables\", though I see no \"type constant\".</p>\n<p>The standard lambda-term definition is straight forward enough, but the <br>\ntype definition is a little more slippery. Hindley's \"Basic Simple Type <br>\nTheory\" says:</p>\n<p>2A1 Definition (Types): An infinite sequence of type-variables is<br>\n      assumed to be given, distinct from term-variables. Types are...<br>\n      (i) each type-variable is a type (called an atom)</p>\n<p>Somehow, \"distinct from term-variables\" escaped my attention. Still, <br>\nthere's only mention of type variables. I should have also looked at <br>\nHindley's \"Lambda-Calculus and Combinators\":</p>\n<p>Definition 10.1 (Simple types): Assume we have a finite or infinite<br>\n      sequence of symbols called atomic types; then...<br>\n      (a) every atomic type is a type;</p>\n<p>\"Atomic type\" is sufficiently vague to allow for \"type constants\", and <br>\nall sorts of other atomic types.</p>\n<p>By all this it now seems clear to me that atomic types are distinct from <br>\natomic terms.</p>\n<p>Thanks,<br>\nGB</p>",
        "id": 294163329,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854020
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Mon, Jun 4, 2012 at 2:17 PM, &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Tobias,</p>\n<p>Thanks. I'm trying to get the vocabulary down.</p>\n<p>Unless you tell me different, I'll conclude that term constants and term<br>\nvariables are different than type constants and type variables,</p>\n</blockquote>\n<p>Correct.</p>\n<blockquote>\n<p>though there might not be such a thing as a \"type constant\".</p>\n</blockquote>\n<p>No, there are type constants. They are also known as \"type operators\".<br>\nEvery type is either a type variable or a type constant applied to a list<br>\nof argument types (the list may be empty).</p>\n<blockquote>\n<p>I see (morely clearly now) that you did precede the introduction of<br>\n\"terms\" with introducing \"base types\", \"type constructors\", \"function<br>\ntypes\", and \"type variables\", though I see no \"type constant\".<br>\n</p>\n</blockquote>\n<p>Base types, type constructors, and function types are all kinds of type<br>\nconstants, or can be viewed as such.<br>\nA base type might be \":bool\", the type of propositions, which may be<br>\nconsidered as the type constant \"bool\" applied to no arguments.<br>\n(Indeed, every type constant has a fixed number, its arity, of arguments it<br>\nought to take.)<br>\nA function type could be thought of a type constant for functions with<br>\narity 2 (taking the domain and range types as arguments).<br>\nI'm not sure what \"type constructors\" refers to, but probably it's just a<br>\nsynonym for type constants.<br>\nIf I'm getting some details of Isabelle wrong here, I'm sure the list will<br>\npoint it out. I'm speaking primarily from my knowledge of HOL.<br>\nI know Isabelle also has type classes, which complicates the story a bit,<br>\nbut you haven't mentioned them so I won't say anything further.</p>\n<blockquote>\n<p>The standard lambda-term definition is straight forward enough, but the<br>\ntype definition is a little more slippery. Hindley's \"Basic Simple Type<br>\nTheory\" says:</p>\n<p>2A1 Definition (Types): An infinite sequence of type-variables is<br>\n    assumed to be given, distinct from term-variables. Types are...<br>\n    (i) each type-variable is a type (called an atom)</p>\n<p>Somehow, \"distinct from term-variables\" escaped my attention. Still,<br>\nthere's only mention of type variables. I should have also looked at<br>\nHindley's \"Lambda-Calculus and Combinators\":</p>\n<p>Definition 10.1 (Simple types): Assume we have a finite or infinite<br>\n    sequence of symbols called atomic types; then...<br>\n    (a) every atomic type is a type;</p>\n<p>\"Atomic type\" is sufficiently vague to allow for \"type constants\", and all<br>\nsorts of other atomic types.</p>\n<p>By all this it now seems clear to me that atomic types are distinct from<br>\natomic terms.<br>\n</p>\n</blockquote>\n<p>Indeed all types, atomic or not, are distinct from all terms, atomic or<br>\nnot, in higher-order logic (or \"simple type theory\").<br>\nThere are other type theories where this is not true, but again you haven't<br>\nmentioned them so I'll shut up :)<br>\nBy my reckoning \"atomic types\" should just be type variables, and possibly<br>\nalso the type constants with arity 0.</p>\n<blockquote>\n<p>Thanks,<br>\nGB</p>\n<p>On 6/4/2012 12:43 AM, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Isabelle's terms are lambda-terms with a type system similar to that of<br>\nLCF, ML<br>\nor Haskell. The document Programming and Proving in Isabelle is an<br>\nintroduction<br>\nto Isabelle, not a definition. Just like most textbooks on functional<br>\nprogramming it does not start out with the lambda-calculus on page 1.</p>\n<p>To answer the question in your title: variables and constants.</p>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>Am 04/06/2012 05:26, schrieb <a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'm looking at this sentence in prog-prove.pdf, page 3:</p>\n<p>Terms are formed as in functional programming by applying<br>\n     functions to arguments. If f is a function of type<br>\n     tau1 =&gt;  tau2 and t is a term of type tau1, then f t<br>\n     is a term of type tau2.</p>\n<p>Also, the word \"contain\" in this sentence on page 4 makes me unsure of<br>\nwhat a<br>\nterm is:</p>\n<p>Terms may also contain lambda-abstractions.</p>\n<p>I've looked for other definitions of \"term\" in the Isabelle docs, but<br>\nI'm not<br>\nsure how constants and variables are used as a part of the definition<br>\nof \"term\".</p>\n<p>Here are three questions I've asked myself, with my answers in<br>\nparentheses. You<br>\ncan correct them if you'd like:</p>\n<p>1) Does a term (of Isabelle/HOL) have a type?  (obviously yes)<br>\n2) Is a term (of Isabelle/HOL) a type? (no)<br>\n3) Is a type (of Isabelle/HOL) a term? (no)</p>\n<p>I'm guessing that one difference between a term and a type is related<br>\nto constants.</p>\n<p>I briefly looked at \"3.2.5 Types and terms\" in isar-ref.pdf, but I<br>\ncan't sort<br>\nthat out.</p>\n<p>In intro.pdf (Old Introduction to Isabelle), page 1, it says:</p>\n<p>The syntax for terms is summarised below...<br>\n     t :: tau       type constraint, on a term or bound variable<br>\n     %x . t         abstraction<br>\n     %x1...xn . t   curried abstraction, %x1...%xn . t<br>\n     t(u)           application<br>\n     t(u1,...,un)   curried application, t(u1) ... (un)</p>\n<p>This indicates that a lambda-abstraction can be a term.</p>\n<p>In Paulson's \"Logic and Computation - Interactive proof with Cambridge<br>\nLCF\", in<br>\n\"Chapter 5 Syntactic Operations for PP-Lambda\", page 142, he says:</p>\n<p>Terms come in four syntactic classes: constants, variables,<br>\n     abstractions, and combinations (function applications).</p>\n<p>This is like a lambda-calculus term, so it looks as if Isabelle/HOL<br>\nterms may<br>\nnot be limited to function application, but I tend to take things<br>\nliterally, so<br>\nwhen prog-prove.pdf says, \"Terms are formed as in functional<br>\nprogramming by<br>\napplying functions to arguments\", that makes me wonder whether a term<br>\nis only<br>\nfunction application.</p>\n<p>I'll ask two more questions, in case someone wants to answer them:</p>\n<p>1) Is a term (in Isabelle/HOL) function application only? (probably not)<br>\n2) To what extent do the concepts in \"Part II Cambridge LCF\" of<br>\nPaulson's \"Logic<br>\nand Computation\" apply to Isabelle/HOL?</p>\n<p>Part I chapters 2, 3, and 4 of \"Logic and Computation\" look like<br>\nsomething I<br>\nneed to work through for foundational material on HOL.</p>\n<p>Thanks,<br>\nGB</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294163341,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854026
    },
    {
        "content": "<p>From: <a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a><br>\nRamana,</p>\n<p>Your HOL4-centric clarification of \"types\" and \"terms\" reminded me of <br>\nyour suggestion to Bill, in the thread \"rigorous axiomatic geometry...\", <br>\nthat he should look at the HOL4 document titled \"The HOL System Logic\".</p>\n<p><a href=\"http://hol.sourceforge.net/documentation.html\">http://hol.sourceforge.net/documentation.html</a></p>\n<p>I've had the main HOL4 manuals on my hard drive for months, but I forgot <br>\nabout using them as a general source of information on HOL.</p>\n<p>The three BNF grammars for \"types\" and \"terms\" on pages 10 and 15 also <br>\nfall under the \"Dude, this is awesome\" category, along with your <br>\nclarifications, and the detailed explanations in the manual, which I'll <br>\neventually study.</p>\n<p>Collectively, the Isabelle docs, HOL4 docs, and related textbooks are <br>\nawesome. A lot of theorem assistants don't have enough documentation to <br>\nget people over the barrier to entry.</p>\n<p>Still, because the books are spread around that give a foundational <br>\nunderstanding of what Isabelle/HOL is, it can make it hard to know where <br>\nto start. But that's other people's problem. I think I have a basic grip <br>\non what it is now, and how to learn about it. And in understanding <br>\nIsabelle/HOL, I should get an understanding of how to reinvent whatever <br>\nobject-language-wheel I want to on top of it.</p>\n<p>Two books I would add to my previous list are these:</p>\n<p>\"The HOL System LOGIC\", HOL4 Documentation<br>\n<a href=\"http://hol.sourceforge.net/documentation.html\">http://hol.sourceforge.net/documentation.html</a></p>\n<p>\"Logic and Computation: Interactive Proof with Cambridge LCF\",<br>\n     by Lawrence Paulson (Amazon)</p>\n<p>Thanks for the clarifications.</p>\n<p>--GB</p>",
        "id": 294163347,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854033
    },
    {
        "content": "<p>From: <a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a><br>\nOn 6/4/2012 10:54 AM, Ramana Kumar wrote:</p>\n<blockquote>\n<p>No, there are type constants. They are also known as \"type operators\".<br>\nEvery type is either a type variable or a type constant applied to a list<br>\nof argument types (the list may be empty).</p>\n<p>...</p>\n<p>Base types, type constructors, and function types are all kinds of type<br>\nconstants, or can be viewed as such.</p>\n<p>...<br>\nA function type could be thought of a type constant for functions with<br>\narity 2 (taking the domain and range types as arguments).</p>\n</blockquote>\n<p>Yea, you're right. Not surprising.  And TUM PhD theses are good for <br>\nclarifying the Isabelle terminology.</p>\n<p>Types tau are either type variables alpha or applications of type<br>\n     constructors k^n with fixed arity n...</p>\n<p>\"Proving Theorems of Higher-Order Logic with SMT Solvers\", page 4<br>\n<a href=\"http://www21.in.tum.de/~boehmes/phd_thesis.html\">http://www21.in.tum.de/~boehmes/phd_thesis.html</a></p>\n<p>So the atomic types are type variables and type constructors of arity 0. <br>\nI guess.</p>\n<p>The HOL4 terminology in the HOL4 logic manual is not the perfect goto <br>\ndocument for explaining the Isabelle termininology.</p>\n<blockquote>\n<p>I'm not sure what \"type constructors\" refers to, but probably it's just a<br>\nsynonym for type constants.</p>\n</blockquote>\n<p>It turns out that it's the opposite, that \"type constants\" is a synonym <br>\nfor \"type constructors\". Synonyms being what they are, that's not a <br>\nproblem.</p>\n<blockquote>\n<p>If I'm getting some details of Isabelle wrong here,I'm sure the list will<br>\npoint it out. I'm speaking primarily from my knowledge of HOL.</p>\n</blockquote>\n<p>The list doesn't appear to be overly concerned with enforcing correct <br>\nword usage. Lists are busy sometimes.</p>\n<p>--GB</p>",
        "id": 294163652,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854168
    }
]