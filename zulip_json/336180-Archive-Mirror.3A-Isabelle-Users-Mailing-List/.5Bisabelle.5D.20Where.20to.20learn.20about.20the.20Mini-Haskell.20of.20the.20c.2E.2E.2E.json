[
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nI had a check. Seems to me the first former is the most relevant.</p>\n<p>It appears code generation is really designed towards functional  <br>\nlanguages, which is not easily suitable for procedural and automata  <br>\nlanguages, even if those can of course be expressed in terms of lambda  <br>\ncalculus.</p>\n<p>For other targets which are not functional languages, this may be better  <br>\nto have a model of the target, as an Isabelle theory, then prove the  <br>\nproperties of a construct in that model (I don't know if “construct in  <br>\nthat model” is the proper wording, may be that should be “an instance of  <br>\nthat model”); then use a mapping from the modelled constructs to their  <br>\nserialization in the target language. That would rather looks like writing  <br>\nin the target language inside of Isabelle, and not be proper code  <br>\ngeneration from any kind of proof, but that's more safe I believe.</p>\n<p>Any comments welcome.</p>\n<p>P.S. I believe  <br>\n<a href=\"http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf\">http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf</a>  <br>\ncould be part of the standard documentations provided with the Isabelle  <br>\npackage. It's both useful and good enough for that.</p>",
        "id": 294232710,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903273
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Yannick,</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>(I don't know Haskell, just SML)<br>\nhere<br>\n<a href=\"http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf\">http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf</a></p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>a good entrance point indeed</p>\n<blockquote>\n<blockquote>\n<p>and probably here<br>\n<a href=\"http://www4.informatik.tu-muenchen.de/~haftmann/pdf/codegen_hol_haftmann_phd.pdf\">http://www4.informatik.tu-muenchen.de/~haftmann/pdf/codegen_hol_haftmann_phd.pdf</a></p>\n</blockquote>\n</blockquote>\n<p>for some technical details, e.g. syntactic restrictions (there is a<br>\nsmall guide how to approach this thesis on<br>\n<a href=\"http://isabelle.in.tum.de/~haftmann/\">http://isabelle.in.tum.de/~haftmann/</a>)</p>\n<blockquote>\n<p>It appears code generation is really designed towards functional<br>\nlanguages</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p>For other targets which are not functional languages, this may be better<br>\nto have a model of the target, as an Isabelle theory, then prove the<br>\nproperties of a construct in that model (I don't know if “construct in<br>\nthat model” is the proper wording, may be that should be “an instance of<br>\nthat model”); then use a mapping from the modelled constructs to their<br>\nserialization in the target language. That would rather looks like<br>\nwriting in the target language inside of Isabelle, and not be proper<br>\ncode generation from any kind of proof, but that's more safe I believe.</p>\n</blockquote>\n<p>Code generation »as it is« is indeed based on shallow embedding.  With<br>\nsome ambition this can be carried to parallel programming<br>\n(src/HOL/Library/Parallel) and imperative data structures<br>\n(src/HOL/Imperative-HOL).</p>\n<blockquote>\n<p>P.S. I believe<br>\n<a href=\"http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf\">http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf</a><br>\ncould be part of the standard documentations provided with the Isabelle<br>\npackage. It's both useful and good enough for that.</p>\n</blockquote>\n<p>There are many papers with explain conceptual background of Isabelle.<br>\nOnce there has been a list of them maintained by Larry Paulson, but I do<br>\nnot know if it is still publicly available.  But they are accessible<br>\nthrough references from the official Isabelle manuals, sometimes by<br>\ndirect delegation (cf. »If you consider imperative data structures as<br>\ninevitable for a specific application, you should consider […]<br>\n; the framework described there is available in session @{text<br>\nImperative_HOL}, together with a short primer document.« in the code<br>\ngenerator tutorial).</p>\n<p>Nevertheless such papers allows accumulate some dust over they years –<br>\nnot wrt. to the concepts, but to the actual surface appearance in<br>\nimplementation, naming, syntax etc.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/UpOTNW_jjPiQT4iRyq9JzPVY/signature.asc\">signature.asc</a></p>",
        "id": 294232956,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903408
    },
    {
        "content": "<p>From: \"Yannick Duchêne (Hibou57 )\" &lt;<a href=\"mailto:yannick_duchene@yahoo.fr\">yannick_duchene@yahoo.fr</a>&gt;<br>\nHi people,</p>\n<p>The codegen.pdf document, says a single translations occurs before  <br>\nserialization to a target language. This prior translation is said to have  <br>\na single target of its own: a kind of Mini-Haskell.</p>\n<p>Is this Mini-Haskell described in some official or unofficial documents?  <br>\n(I don't know Haskell, just SML)</p>\n<p>By the way, why a Mini-Haskell instead of a Mini-SML? What do Haskell  <br>\noffers here SML can't for this purpose? (not a criticism, that's just to  <br>\nlearn the rational behind it).</p>\n<p>Have an happy day</p>",
        "id": 294236435,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660904984
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nOn 02/07/2013 09:54 PM, Yannick Duchêne (Hibou57) wrote:</p>\n<blockquote>\n<p>Hi people,</p>\n<p>The codegen.pdf document, says a single translations occurs before<br>\nserialization to a target language. This prior translation is said to<br>\nhave a single target of its own: a kind of Mini-Haskell.</p>\n<p>Is this Mini-Haskell described in some official or unofficial documents?<br>\n(I don't know Haskell, just SML)<br>\nhere</p>\n</blockquote>\n<p><a href=\"http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf\">http://www4.informatik.tu-muenchen.de/~haftmann/pdf/code_generation_haftmann_nipkow.pdf</a></p>\n<p>and probably here</p>\n<p><a href=\"http://www4.informatik.tu-muenchen.de/~haftmann/pdf/codegen_hol_haftmann_phd.pdf\">http://www4.informatik.tu-muenchen.de/~haftmann/pdf/codegen_hol_haftmann_phd.pdf</a></p>\n<p>(I did not check, though)</p>\n<blockquote>\n<p>By the way, why a Mini-Haskell instead of a Mini-SML? What do Haskell<br>\noffers here SML can't for this purpose? (not a criticism, that's just to<br>\nlearn the rational behind it).<br>\nI think that would be typeclasses (and the syntax is maybe a bit more <br>\nlightweight, but that's just an opinion).</p>\n</blockquote>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294236533,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905009
    }
]