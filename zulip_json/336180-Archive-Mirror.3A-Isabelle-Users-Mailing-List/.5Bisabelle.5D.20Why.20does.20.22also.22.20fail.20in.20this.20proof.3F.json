[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 9 May 2006, Robin Green wrote:</p>\n<blockquote>\n<ol start=\"2\">\n<li>What's worse, I find myself in a Catch 22. Given the file I posted<br>\npreviously, I want to prove from </li>\n</ol>\n<p>lemma tt_simp [simp]: \"tt f g x == f x (g x)\"</p>\n<p>the following:</p>\n<p>lemma doh2 [simp]: \"tt f g == %x. f x (g x)\"</p>\n<ul>\n<li>something that should be completely trivial to prove</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>(in fact, I would expect the simp rule to do it).</p>\n</blockquote>\n<p>You are right.  The Simplifier setup does not anything like this for other<br>\nreasons (including historical ones).</p>\n<blockquote>\n<p>OK, let's try a compromise:</p>\n<p>lemma doh2 [simp]: \"tt f g == %x. f x (g x)\"<br>\nproof -<br>\n  have \"tt f g == %x. tt f g x\" .<br>\n  finally show \"tt f g == %x. f x (g x)\" by simp<br>\nqed</p>\n</blockquote>\n<p>Try this in the body:</p>\n<p>show \"%x. tt f g x == %x. f x (g x)\" by simp</p>\n<p>i.e. you make the Simplifier happy by stating an expanded form.  The<br>\nresult then fits into the pending problem due to alpha-beta-eta<br>\nconversion.  All single-step refinements work by higher-order unification,<br>\nwhich includes these lambda conversions.  Automated tools may have<br>\nslightly different ideas.</p>\n<blockquote>\n<p>Now, the weird thing is (and here I'm going back to my point 1),<br>\nIsabelle happily accepts this proof:</p>\n<p>lemma doh [simp]: \"const x == %y. x\"<br>\nproof -<br>\n  have \"const x == %y. const x y\" .<br>\n  also have \"... == %y. x\" by (unfold const_def)<br>\n  finally show \"const x == %y. x\" .<br>\nqed</p>\n<p>even though you claim, about lambda introductions like the one on the<br>\nfirst line:</p>\n<p>\"Such redundant cases are filtered out in<br>\n order to achieve more robust guessing of rule instances.\"</p>\n</blockquote>\n<p>The filtering is on calculational results, not the original facts.  Here<br>\nyou did make some progress, becase the final rhs is different from the<br>\nfirst lhs.  In the first example the latter were the same.</p>\n<blockquote>\n<p>OK, but I'm confused about the distinction between object-level equality<br>\nand meta-equality. What advantage would that give me for these types of<br>\nproofs? What disadvantages?</p>\n</blockquote>\n<p>Generally speaking, meta-level !! and ==&gt; connectives express natural<br>\ndeduction rules, which can be used directly.  Object-level formula need to<br>\nbe unpacked first, via usual intro/elim rules to reduce them to plain !!<br>\nand ==&gt;.</p>\n<p>Concerning equality, there is not much of a difference in HOL<br>\ntheoretically. Practically speaking = is more convenient, because most<br>\ntools work directly with this form.  For example, the calculational rules<br>\nfor = include various mixed forms (substitution etc.) while == is limited<br>\nto plain transitivity.</p>\n<blockquote>\n<p>Would currying be affected</p>\n</blockquote>\n<p>No.</p>\n<blockquote>\n<p>and would my theory file get more verbose?</p>\n</blockquote>\n<p>Yes, if you pack everything into ALL --&gt; etc. unnecessarily; proofs will<br>\nbecome more complicated.  But this is not what the present examples were<br>\nabout.</p>\n<p>Makarius</p>",
        "id": 293911060,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660747433
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 7 May 2006, Robin Green wrote:</p>\n<blockquote>\n<p>I'm using Isabelle 2005, and I've picked up how to do some calculational <br>\nproofs in a \"monkey-see, monkey-do\" kind of way - i.e. not really <br>\nunderstanding the connecting commands like \"also\" and \"have\" and \"show\".</p>\n</blockquote>\n<p>'also' merely composes the background calculation with the last fact. <br>\nSeveral rules are tried in turn, cf. print_trans_rules.</p>\n<blockquote>\n<p>Can someone explain why, in the attached theory file, I get this error<br>\non the last line:</p>\n</blockquote>\n<p>Because the calculational step does not make any progress -- your first <br>\nstep is reflexivity.  Such redundant cases are filtered out in order to <br>\nachieve more robust guessing of rule instances.  Try this to see what <br>\nhappens internally:</p>\n<p>thm  calculation  this  transitive [OF calculation this]</p>\n<p>Also note that equality reasoning is usually performed at the <br>\nobject-level, using \"=\" instead of \"==\".  (This is in contrast to the <br>\nother connectives !! and ==&gt;, which usually work better than ALL and --&gt;).</p>\n<p>Makarius</p>",
        "id": 293911062,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660747433
    },
    {
        "content": "<p>From: Robin Green &lt;<a href=\"mailto:greenrd@greenrd.org\">greenrd@greenrd.org</a>&gt;<br>\nOn Mon, 8 May 2006 14:13:48 +0200 (CEST)<br>\nMakarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<blockquote>\n<p>Can someone explain why, in the attached theory file, I get this<br>\nerror on the last line:</p>\n</blockquote>\n<p>Because the calculational step does not make any progress -- your<br>\nfirst step is reflexivity.</p>\n</blockquote>\n<p>OK, with this hint I managed to fix that proof - thanks.</p>\n<p>However, I would disagree that it does not make any progress. Two<br>\nstrange things about this explanation:</p>\n<ol>\n<li>\n<p>Sometimes Isabelle does not object to a step which essentially just<br>\nintroduces a lambda - but sometimes it does (assuming your explanation<br>\nabove is correct). I cannot discern any rhyme or reason to this - it<br>\nappears to me to be arbitrary.</p>\n</li>\n<li>\n<p>What's worse, I find myself in a Catch 22. Given the file I posted<br>\npreviously, I want to prove from </p>\n</li>\n</ol>\n<p>lemma tt_simp [simp]: \"tt f g x == f x (g x)\"</p>\n<p>the following:</p>\n<p>lemma doh2 [simp]: \"tt f g == %x. f x (g x)\"</p>\n<ul>\n<li>something that should be completely trivial to prove, because it<br>\nfollows directly from the fact that a function is defined to be a lambda<br>\nin the lambda calculus (in fact, I would expect the simp rule to do<br>\nit). So let's try a one-step proof:</li>\n</ul>\n<p>lemma doh2 [simp]: \"tt f g == %x. f x (g x)\" by simp</p>\n<p>No, that fails. OK, let's try a patient, but verbose approach:</p>\n<p>lemma doh2 [simp]: \"tt f g == %x. f x (g x)\"<br>\nproof -<br>\n  have \"tt f g == %x. tt f g x\" .<br>\n  also have \"... == %x. f x (g x)\" by simp<br>\n  finally show \"tt f g == %x. f x (g x)\"<br>\nqed</p>\n<p>This yields:</p>\n<p>*** empty result sequence -- proof command failed<br>\n*** At command \"finally\".</p>\n<p>OK, let's try a compromise:</p>\n<p>lemma doh2 [simp]: \"tt f g == %x. f x (g x)\"<br>\nproof -<br>\n  have \"tt f g == %x. tt f g x\" .<br>\n  finally show \"tt f g == %x. f x (g x)\" by simp<br>\nqed</p>\n<p>With this, Isabelle complains \"No calculation yet\".</p>\n<p>So the Catch 22 is: if I try to do it in 1 step, Isabelle can't seem<br>\nto simplify that much in one step. If I try to do it in 3 steps,<br>\nIsabelle effectively complains that I'm insulting its intelligence<br>\n(going by your explanation of what the problem is, anyway). If I try to<br>\ndo it in 2 steps, Isabelle doesn't recognise a 2-step calculation as a<br>\ncalculation (even though, it clearly is such, from a human POV). I<br>\ncan't win!</p>\n<p>Now, the weird thing is (and here I'm going back to my point 1),<br>\nIsabelle happily accepts this proof:</p>\n<p>lemma doh [simp]: \"const x == %y. x\"<br>\nproof -<br>\n  have \"const x == %y. const x y\" .<br>\n  also have \"... == %y. x\" by (unfold const_def)<br>\n  finally show \"const x == %y. x\" .<br>\nqed</p>\n<p>even though you claim, about lambda introductions like the one on the<br>\nfirst line:</p>\n<p>\"Such redundant cases are filtered out in<br>\n order to achieve more robust guessing of rule instances.\"</p>\n<p>So why is it that my proof of doh works, but my proofs of doh2<br>\ndon't? There must be something more to it that I'm not getting.</p>\n<blockquote>\n<p>Also note that equality reasoning is usually performed at the <br>\nobject-level, using \"=\" instead of \"==\".  (This is in contrast to the <br>\nother connectives !! and ==&gt;, which usually work better than ALL and<br>\n--&gt;).</p>\n</blockquote>\n<p>OK, but I'm confused about the distinction between object-level<br>\nequality and meta-equality. What advantage would that give me for these<br>\ntypes of proofs? What disadvantages? Would currying be affected -<br>\nand would my theory file get more verbose?</p>",
        "id": 293911067,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660747433
    },
    {
        "content": "<p>From: Robin Green &lt;<a href=\"mailto:greenrd@greenrd.org\">greenrd@greenrd.org</a>&gt;<br>\nI'm using Isabelle 2005, and I've picked up how to do some<br>\ncalculational proofs in a \"monkey-see, monkey-do\" kind of way - i.e.<br>\nnot really understanding the connecting commands like \"also\" and<br>\n\"have\" and \"show\".</p>\n<p>Can someone explain why, in the attached theory file, I get this error<br>\non the last line:</p>\n<p>*** empty result sequence -- proof command failed<br>\n*** At command \"also\".</p>\n<p>Previously when I hit this error, I found that I could delete the<br>\nprevious line in the proof and the error would go away. But in this<br>\ncase, if I delete the previous line, the combined step is too hard for<br>\nIsabelle to do in one step, as far as I can see.<br>\n<a href=\"/user_uploads/14278/8OyZpin7l-1pw5Fq0yll7spc/Functor.thy\">Functor.thy</a></p>",
        "id": 293911671,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660747588
    }
]