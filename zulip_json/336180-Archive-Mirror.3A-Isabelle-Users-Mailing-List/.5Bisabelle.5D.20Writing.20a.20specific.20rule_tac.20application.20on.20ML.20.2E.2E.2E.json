[
    {
        "content": "<p>From: Sylvia Gruener &lt;<a href=\"mailto:sylvia.gruener@googlemail.com\">sylvia.gruener@googlemail.com</a>&gt;<br>\nHello,</p>\n<p>I would like to write a tactic which applies a theorem to the goal<br>\n(where it depends on the structure of the goal which theorem is<br>\napplied). Moreover, the tactic gets as argument a term with which the<br>\nfree variable \"ur\" of the theorem should be instantiated before applying the theorem to the goal (each possible theorem contains a variable with this name). After deciding which theorem to apply, the tactic should behave exactly like applying rule_tac with the selected theorem and instantiating the variable \"ur\" with the given term. </p>\n<p>On the Isabelle level, the rule_tac application would look like this:<br>\n apply (rule_tac ur=\"some_term\" in some_theorem)</p>\n<p>My question is: How can I write this rule_tac application on the<br>\nML-Level?</p>\n<p>I tried to do this rule_tac application by executing</p>\n<p>(res_inst_tac ctxt [((\"ur\", 0), \"some_term\")] some_theorem 1)</p>\n<p>in the ML code of the tactic, but I had two problems with this call, to<br>\nwhich I do not find a solution: </p>\n<ol>\n<li>\n<p>The name of the variable has to be given as indexname (a pair of a<br>\n string and an integer). What exactly does the integer stand for? I<br>\n tried several values, none of them (also not 0) yielded exactly the<br>\n behavior of rule_tac (because some variables inside the term are not<br>\n instantiated the way rule_tac would do it). </p>\n</li>\n<li>\n<p>\"some_term\" is of type \"term\", but res_inst_tac needs of course a<br>\n parameter of type string. I defined my own syntax for my tactic using<br>\n the method_setup command, which parses the parameter as a term. <br>\n Is it possible to convert a term to a string of the format that<br>\n res_inst_tac is expecting? (The functions I tried only converted the<br>\n term structure to a string.)<br>\n Or is it possible to parse a string as argument instead of a term<br>\n when the tactic is applied on the Isabelle level?</p>\n</li>\n</ol>\n<p>Thank you very much,<br>\nSylvia</p>",
        "id": 294119328,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839299
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Sylvia,</p>\n<blockquote>\n<p>I would like to write a tactic which applies a theorem to the goal <br>\n(where it depends on the structure of the goal which theorem is <br>\napplied). Moreover, the tactic gets as argument a term with which the<br>\n free variable \"ur\" of the theorem should be instantiated before<br>\napplying the theorem to the goal (each possible theorem contains a<br>\nvariable with this name). After deciding which theorem to apply, the<br>\ntactic should behave exactly like applying rule_tac with the selected<br>\ntheorem and instantiating the variable \"ur\" with the given term.</p>\n<p>On the Isabelle level, the rule_tac application would look like this:<br>\n apply (rule_tac ur=\"some_term\" in some_theorem)</p>\n<p>My question is: How can I write this rule_tac application on the <br>\nML-Level?</p>\n<p>I tried to do this rule_tac application by executing</p>\n<p>(res_inst_tac ctxt [((\"ur\", 0), \"some_term\")] some_theorem 1)</p>\n</blockquote>\n<p>res_inst_tac is an old tactic designed for interactive use, which is why <br>\nit has \"parsing built in\". It is not really useful for writing other <br>\ntactics, due to the strings...</p>\n<p>Unfortunately, there is no direct ML counterpart of rule_tac.</p>\n<p>It is easy if your instantiation does not refer to goal parameters (that <br>\nis, variables that are !!-bound within the subgoal). Then you can first <br>\ninstantiate the theorem (using Thm.instantiate, or one of its relatives <br>\nDrule.instantiate' and Drule.cterm_instantiate) and then apply it using <br>\nresolve_tac. What you are doing then roughly corresponds to</p>\n<p>apply (rule some_theorem[where ur=\"some_term\"]) .</p>\n<p>If you do have to refer to goal parameters, then it is a bit more <br>\ndifficult. I know of two approaches that work reasonably well:</p>\n<ol>\n<li>\n<p>Use Subgoal.FOCUS_PARAMS to turn your subgoal into a new goal in a <br>\ncontext where the parameters are turned to fixed variables. Then you can <br>\ninstantiate and apply the rule as above. This roughly corresponds to</p>\n<p>(* goal: \"!!x y z. P x y z\" *)<br>\n proof -<br>\n   fix x y z<br>\n   show \"P x y z\" &lt;proof&gt;<br>\n qed</p>\n</li>\n</ol>\n<p>but the inner tactic (the rule application) does not have to solve the goal.</p>\n<ol start=\"2\">\n<li>Manually lift some_theorem into your \"goal context\" using <br>\nThm.lift_rule. Then, the schematic variables become parameterized over <br>\nthe goal parameters (i.e. they are now of function type). You can then <br>\ninstantiate them as you need. To apply the rule, you would then use<br>\nsome variant of compose_tac.</li>\n</ol>\n<blockquote>\n<p>in the ML code of the tactic, but I had two problems with this call,<br>\nto which I do not find a solution: 1. The name of the variable has to<br>\nbe given as indexname (a pair of a string and an integer). What<br>\nexactly does the integer stand for?</p>\n</blockquote>\n<p>Schematic variables have an indexname instead of just a name, which <br>\nallows for fast renaming. See Sect. 1.2.3 of the Implementation Manual.</p>\n<p>[...]</p>\n<blockquote>\n<p>Or is it possible to<br>\nparse a string as argument instead of a term when the tactic is<br>\napplied on the Isabelle level?</p>\n</blockquote>\n<p>In principle you could do this and delegate the parsing to res_inst_tac, <br>\nbut I would not recommend this as a general approach. In particular, you <br>\ncould no longer inspect the term structure of some_term.</p>\n<p>Hope this helps,<br>\nAlex</p>",
        "id": 294119413,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839335
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jlcaadawson@netspeed.com.au\">jlcaadawson@netspeed.com.au</a>&gt;<br>\nSylvia,</p>\n<p>Look at term_lift_inst_rule in tactic.ML, I've previously used it for (I <br>\nthink) something like what you're trying to do</p>\n<p>Jeremy</p>",
        "id": 294119434,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839343
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Look at term_lift_inst_rule in tactic.ML, I've previously used it for (I <br>\nthink) something like what you're trying to do</p>\n</blockquote>\n<p>that function no longer exists:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/07a8904f8fcd\">http://isabelle.in.tum.de/repos/isabelle/rev/07a8904f8fcd</a></p>\n<p>Alex</p>",
        "id": 294119454,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839350
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe question about term-based res_inst_tac is very old (maybe 15 years). <br>\nVarious people had come up with private solutions to that.  More recently, <br>\nwith the almost accidental advent of FOCUS, it became suddenly clear that <br>\nthe answer is there.</p>\n<p>So only thing you can't do with FOCUS is instantiate schematic variables <br>\nin the goal, but these are very rare in (robust) proofs under ML program <br>\ncontrol.</p>\n<p>Makarius</p>",
        "id": 294119767,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660839447
    }
]