[
    {
        "content": "<p>From: Liu Jian &lt;<a href=\"mailto:gjk.liu@gmail.com\">gjk.liu@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I am now interested in the work of the following paper<br>\nDavid Cock, Gerwin Klein and Thomas Sewell \"Secure Microkernels, State<br>\nMonads nad Scalable Refinement\"</p>\n<p>But a question about how to define a longer computation for \"bind\"<br>\noperator of State monad</p>\n<p>As the paper says \"bind\" can be defined as following:</p>\n<p>bind :: ('s, 'a) state-monad =&gt; ('a =&gt; ('s, 'b) state-mond) =&gt; ('s,<br>\n'b) state-monad<br>\n  bind f g == % s. let (v, s') = f s in g v s'</p>\n<p>And, \"The expression bind f g is abbreivated as f &gt;&gt;= g, To allow<br>\nconcise description for longer computations,<br>\nwe define a do syntax in sa similar fashion to Haskell\"</p>\n<p>do x &lt;- f; g x od == f &gt;&gt;= g</p>\n<p>But how to write the real isabelle statements for the above<br>\ndefinition? (Note there is parameter \"x\")</p>\n<p>Moreover,  from the above syntax, we can write the following monad code:<br>\n(in Kevin Elphinstoen, Gerwin Klein etc. \"Formalising a<br>\nHigh-Performance Microkernel\")</p>\n<p>activateThread ==<br>\n   do thread &lt;- getCurThread;<br>\n         state &lt;- getWaitState thread;<br>\n         case state of<br>\n         NotWaiting =&gt; return ()<br>\n   |     WaitingToSend eptr badge fault cap =&gt;<br>\n             if cap = None then<br>\n                  doIPCTransfer thread (waitingIPCPartner state)<br>\n            else arbitrary<br>\n   |     WaitinToRecieve eptr =&gt;<br>\n                  doIPCTransfer (waitingIPCPartner state) thread<br>\n   |     =&gt; arbitrary<br>\n  od</p>\n<p>Note that there are three monad binded in the above definition. But in<br>\nthe \"do ... od\" statement definition only contain two,<br>\nHow to deal with it? If possible could you give a example real<br>\nisabelle definition for above definition?</p>\n<p>cheers:)</p>\n<p>Liu Jian</p>",
        "id": 294068608,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826370
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nLiu Jian wrote:<br>\nIt's fairly standard syntax black magic and works roughly like the normal let <br>\nbindings in Isabelle (e.g. see HOL/HOL.thy).</p>\n<p>A more complex example directly with \"do\" syntax can be found in <br>\nHOL/Library/StateMonad.thy. It's slightly different from the one in our <br>\npapers, but the effect is the same.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294068638,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826390
    },
    {
        "content": "<p>From: Liu Jian &lt;<a href=\"mailto:gjk.liu@gmail.com\">gjk.liu@gmail.com</a>&gt;<br>\nThanks Gerwin! following your direction, I write the following statements</p>\n<p>types ('s, 'a)state_monad = \" 's =&gt; ('a , 's)\"</p>\n<p>constdefs bind :: \"('s, 'a)state_monad =&gt;('a =&gt; ('s, 'b)state_monad)<br>\n=&gt;('s, 'b)state_monad\" (infixr \"&gt;&gt;=\" 60)<br>\n\" f &gt;&gt;= g  == % s . let  (v, s') = f s in g v s'\"</p>\n<p>nonterminals<br>\ndobind</p>\n<p>syntax<br>\n  \"_bind\"       :: \"[pttrn, 'a] =&gt; dobind\"              (\"(2_ &lt;-/ _)\" 10)<br>\n  \"_do\"         :: \"[dobind, 'a] =&gt;  'b\"               (\"( do _ ;/ _\nod )\" [0,0] 10)</p>\n<p>translations<br>\n \" do x &lt;- f ; g od\" == \" f &gt;&gt;= (% x. g)\"</p>\n<p>Now, binding two monads is easy. But How to bind three or more monads<br>\nin a \"do ... od\"<br>\nstatement? Moreover, what is the association attribute of \"bind\"<br>\noperator? infixr or infixl.<br>\nIn the above definition I use the former. But I can not hold the<br>\ndifference between them.</p>\n<p>cheers:)</p>\n<p>Liu Jian</p>",
        "id": 294068746,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826420
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:gerwin.klein@nicta.com.au\">gerwin.klein@nicta.com.au</a>&gt;<br>\nHi Liu,</p>\n<p>you need to do the rest as well, see lines 125-192 in <br>\nHOL/Library/StateMonad.thy. The file is part of Isabelle2008 already, I <br>\nbelieve, if not, you can find it in the Isabelle development snapshot.</p>\n<p>Specifically, you will need _scomp (and _fcomp if you want to leave out the<br>\n\"_ &lt;-\" part) and for printing also the ML print translation. Florian Haftmann <br>\nwrote that specific theory, he'll be able to explain in more detail how it works.</p>\n<p>Cheers,<br>\nGerwin</p>\n<p>Liu Jian wrote:</p>",
        "id": 294068769,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826432
    },
    {
        "content": "<p>From: Liu Jian &lt;<a href=\"mailto:gjk.liu@gmail.com\">gjk.liu@gmail.com</a>&gt;<br>\nHi,</p>\n<p>I have tried a test like \"StateMonad.thy\" under your direction, But<br>\n   A error occur when deal with \"if ... then ... else...\" or \"case ...<br>\nof ...\" statement as following<br>\n activateThread ==<br>\n  do thread &lt;- getCurThread;<br>\n        state &lt;- getWaitState thread;<br>\n        case state of<br>\n        NotWaiting =&gt; return ()<br>\n  |     WaitingToSend eptr badge fault cap =&gt;<br>\n            if cap = None then<br>\n                 doIPCTransfer thread (waitingIPCPartner state)<br>\n           else arbitrary<br>\n  |     WaitinToReciev  Note idefinition<br>\n  |     WaitingToReceive eptr =&gt;<br>\n                 doIPCTransfer (waitingIPCPartner state) thread<br>\n  |     =&gt; arbitrary</p>\n<p>Note in the above definition, monads embeds in a case statement.</p>\n<p>As \"State_Monad.thy\" says there are some \"do...done\" examples in<br>\n\"HOL/ex/Random.thy\".<br>\nLines 101~107 (Random.thy) show me a example as following:</p>\n<p>range :: \"index =&gt; seed =&gt; index =&gt; seed\"<br>\nwhere<br>\n  \"range k = (do<br>\n     v &lt;- range_aux (log 2147483561 k) 1;<br>\n     return (v mod k)<br>\n   done)\"</p>\n<p>When you simply change it as following, a error occurs.</p>\n<p>range :: \"index =&gt; seed =&gt; index =&gt; seed\"<br>\nwhere<br>\n  \"range k = (do<br>\n     v &lt;- range_aux (log 2147483561 k) 1;<br>\n     if True return (v mod k) else return (v mod k)<br>\n   done)\"</p>\n<p>cheers,</p>\n<p>Liu Jian</p>\n<p>BTW:</p>\n<p>what's the meaning of following lines. Here, I can not understand the<br>\nmeaning of \"CONST\" and the difference between \"=&gt;\" and \"==\" in a<br>\ntranslation</p>\n<p>translations<br>\n  \"_do f\" =&gt; \"CONST run f\"</p>",
        "id": 294068836,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826456
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Liu Jian,</p>\n<blockquote>\n<p>When you simply change it as following, a error occurs.</p>\n<p>range :: \"index =&gt; seed =&gt; index =&gt; seed\"<br>\nwhere<br>\n  \"range k = (do<br>\n     v &lt;- range_aux (log 2147483561 k) 1;<br>\n     if True return (v mod k) else return (v mod k)<br>\n   done)\"</p>\n</blockquote>\n<p>The reason for this failure is the HOL if syntax: it demands a \"then\",<br>\nan in most cases has to be put in brackets:</p>\n<blockquote>\n<p>\"range k = (do<br>\n     v &lt;- range_aux (log 2147483561 k) 1;<br>\n     (if True then return (v mod k) else return (v mod k))<br>\n   done)\"</p>\n</blockquote>\n<blockquote>\n<p>what's the meaning of following lines. Here, I can not understand the<br>\nmeaning of \"CONST\" and the difference between \"=&gt;\" and \"==\" in a<br>\ntranslation</p>\n<p>translations<br>\n  \"_do f\" =&gt; \"CONST run f\"</p>\n</blockquote>\n<p>The \"CONST\" is a technical detail - for historical reasons, there are<br>\ntwo syntactic classes of constants: constants which are represented with<br>\ntheir proper qualified names in the syntax layer (\"authentic constants\")<br>\nand constants which are represented just by their base name<br>\n(\"non-authentic constants\").  New-style definition tools (definition,<br>\ninductive, function, primrec with new \"where\"-syntax ...) yield<br>\nauthentic constants, whereas older devices do not (consts, constdefs,<br>\n...).  The \"CONST\" marker states that \"run\" is an authentic constant.</p>\n<p>The difference between \"=&gt;\" and \"==\" in first approximation is that \"=&gt;\"<br>\nis only applied in input direction, whereas \"==\" is applied during input<br>\nand reversely during output.  For a detailed description on how the<br>\nsyntax layer work I have to redirect you to the old Isabelle Reference<br>\nManual <a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/ref.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/ref.pdf</a> which is<br>\noutdated in huge passages but the chapter on syntax still represents the<br>\ncurrent implementation fairly well.</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/zmjtjc0IkERaC4dKr37aomfB/signature.asc\">signature.asc</a></p>",
        "id": 294069194,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826580
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIn fact, the CONST marker will always do the right thing, both for <br>\nnew-style constants with \"authentic syntax\" and the old-style ones.  But <br>\nfor authentic consts you cannot do it otherwise, while old-style <br>\nnon-authentic ones could be given as unqualified (and unchecked) base <br>\nnames, although this is not recommended.</p>\n<p>In other words: always use explicit CONST if you refer to constants at the <br>\nlevel of syntax translations.</p>\n<p>Makarius</p>",
        "id": 294069904,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826781
    }
]