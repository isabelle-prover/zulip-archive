[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nHello,</p>\n<p>I have a theory which defines</p>\n<p>theory TestML imports Main<br>\nbegin<br>\nML<br>\n{*<br>\n    val Set_ex_bool_eq = @{thm Set.ex_bool_eq};<br>\n    val Set_all_bool_eq = @{thm Set.all_bool_eq};<br>\n*}<br>\nend</p>\n<p>How can I access these objects from the isabelle_process?</p>\n<p>I know that I can load the theory file using use_thy \"TestML\",<br>\nbut I could not figure out how to access these names.</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294637271,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160685
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAlmost everything in Isabelle lives within a formal theory context, <br>\nincluding the ML environment.  It is merely a historical accident of the <br>\nIsabelle/Pure bootstrap process that the ML content of Pure.thy is also <br>\ndumped onto the naked ML toplevel of isabelle_process or isabelle console.</p>\n<p>So the canonical approach is to evaluate Isabelle/ML snippets inside a <br>\nproper theory context like Main above. The remaining question is how to <br>\nachieve that for your application.  E.g. one could produce a temporary<br>\n.thy file on the spot and load that with use_thy.</p>\n<p>Makarius</p>",
        "id": 294637418,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160734
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nOn 4/28/2015 8:44 PM, Makarius wrote:</p>\n<blockquote>\n<p>On Tue, 28 Apr 2015, Viorel Preoteasa wrote:</p>\n<blockquote>\n<p>I have a theory which defines</p>\n<p>theory TestML imports Main<br>\nbegin<br>\nML<br>\n{*<br>\n   val Set_ex_bool_eq = @{thm Set.ex_bool_eq};<br>\n   val Set_all_bool_eq = @{thm Set.all_bool_eq};<br>\n*}<br>\nend</p>\n<p>How can I access these objects from the isabelle_process?</p>\n<p>I know that I can load the theory file using use_thy \"TestML\",<br>\nbut I could not figure out how to access these names.</p>\n</blockquote>\n<p>Almost everything in Isabelle lives within a formal theory context, <br>\nincluding the ML environment.  It is merely a historical accident of <br>\nthe Isabelle/Pure bootstrap process that the ML content of Pure.thy is <br>\nalso dumped onto the naked ML toplevel of isabelle_process or isabelle <br>\nconsole.<br>\nBut I guess, if I get this context, I can manipulate it from the ML top <br>\nlevel.</p>\n<p>So the canonical approach is to evaluate Isabelle/ML snippets inside a <br>\nproper theory context like Main above. The remaining question is how <br>\nto achieve that for your application.  E.g. one could produce a temporary<br>\n.thy file on the spot and load that with use_thy.</p>\n</blockquote>\n<p>Using Isabelle/ML snippets inside a proper theory context seems<br>\noriented towards a user interface. But I need to do this in batch mode.<br>\nIf I use this approach I have to create always a theory file,<br>\nand then load it using  use_thy. I would need to do this for every small <br>\ncall that I need.</p>\n<p>I have the following Isabelle/ML:</p>\n<p>ML<br>\n{*<br>\nval Set_ex_bool_eq = @{thm Set.ex_bool_eq};<br>\nval Set_all_bool_eq = @{thm Set.all_bool_eq};</p>\n<p>fun bool_ctxt ctxt =  Simplifier.add_simp Set_ex_bool_eq <br>\n(Simplifier.add_simp Set_all_bool_eq ctxt);</p>\n<p>fun term_to_string ctxt t =<br>\n   let<br>\n     val ctxt' = Config.put show_markup false ctxt;<br>\n     in Print_Mode.setmp [] (Syntax.string_of_term ctxt') t end;</p>\n<p>fun simplifya s ct th =<br>\n   let<br>\n     (<em>val _ = use_thy thy_name;</em>)<br>\n     val t = Syntax.read_term ct s;</p>\n<p>val simp_term_a = Simplifier.rewrite ct (cterm_of th t) |&gt; Thm.rhs_of;<br>\n     val simp_term_b = Simplifier.rewrite (bool_ctxt ct) simp_term_a |&gt; <br>\nThm.rhs_of;<br>\n     val simp_term_c = term_of simp_term_b;<br>\n     val result = term_to_string ct simp_term_c;<br>\n   in result end;</p>\n<p>fun simplify s thy_name =<br>\n   let<br>\n     (<em>val _ = use_thy thy_name;</em>)<br>\n     val thy = Thy_Info.get_theory thy_name;<br>\n     val ctxt = Proof_Context.init_global thy;<br>\n     in simplifya s ctxt thy end<br>\n*}</p>\n<p>I can define this code in a ml file, except:</p>\n<p>val Set_ex_bool_eq = @{thm Set.ex_bool_eq};<br>\nval Set_all_bool_eq = @{thm Set.all_bool_eq};</p>\n<p>probably there is a way to get these theorems at the toplevel of <br>\nisabelle_process<br>\nusing the context and the theory.</p>\n<p>I like the possibility of writhing my functions within a theory, but I <br>\nwould like<br>\nvery much to be able to use these functions at the toplevel of <br>\nisabelle_process<br>\nwithout generating a new file for every call that I need.</p>\n<p>Viorel</p>",
        "id": 294637450,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160745
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 28 Apr 2015, Viorel Preoteasa wrote:</p>\n<blockquote>\n<p>Using Isabelle/ML snippets inside a proper theory context seems oriented <br>\ntowards a user interface. But I need to do this in batch mode. If I use <br>\nthis approach I have to create always a theory file, and then load it <br>\nusing use_thy. I would need to do this for every small call that I need.</p>\n</blockquote>\n<p>I was talking about batch mode already. You could e.g. put all your tool <br>\nsetup in a static .thy (or .thy that loads a .ML via ML_file).  It could <br>\nrefer to some environment variables to get dynamic input from somewhere <br>\nelse, e.g. another tmp file.</p>\n<p>There are many more possibilities, e.g. using Isabelle/Scala for the <br>\nsystems programming.</p>\n<blockquote>\n<p>fun simplifya s ct th =</p>\n</blockquote>\n<p>The \"ct\" here seems to be a Proof.context, and the one and only one naming <br>\nconvention is \"ctxt\".  See also the \"implementation\" manual.</p>\n<blockquote>\n<p>I can define this code in a ml file, except:</p>\n<p>val Set_ex_bool_eq = @{thm Set.ex_bool_eq};<br>\nval Set_all_bool_eq = @{thm Set.all_bool_eq};</p>\n<p>probably there is a way to get these theorems at the toplevel of <br>\nisabelle_process<br>\nusing the context and the theory.</p>\n</blockquote>\n<p>Isabelle/ML files always refer to a proper theory context.  So we are back <br>\nto the start.</p>\n<p>Makarius</p>",
        "id": 294637455,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160747
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nIf I do this, and for example I define a value in a theory file:</p>\n<p>theory TestML imports Main<br>\nbegin<br>\nML{*<br>\nval newline = writeln \"\"<br>\n*}<br>\nend</p>\n<p>Now in isabelle_process I do:</p>\n<p>use_thy \"TestML\"</p>\n<p>The basic question is how do I access the value newline in the <br>\nisabelle_process?</p>\n<p>If I try just newline it is not recognized. Is this value available <br>\nunder some scope?</p>\n<p>Is it so that I am not supposed to access it from other place, except <br>\nthe theory?</p>\n<p>Viorel</p>",
        "id": 294637470,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160753
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe value is part of the theory context of TextML.  You can access it in a <br>\ntheory that imports it, for example.</p>\n<p>All of Isabelle/ML happens within some theory context.  The standard <br>\ncommands for that are 'ML' and 'ML_file' -- they are computationally <br>\ncomplete wrt. the ML language.  You can do whatever you want with it, <br>\nincluding arbitrary I/O with the outside world.</p>\n<p>Of course, you can define variants of the above 'ML' commands for your own <br>\npurposes.  With some more efforts it is also possible to define variants <br>\nof use_thy + embedded Isabelle/ML in the raw ML toplevel environment, to <br>\nbypass files altogether -- it depends on the application what is really <br>\nrequired.</p>\n<p>Here is an example to play with Isabelle/ML runtime-compilation-evaluation <br>\nin Isabelle2015-RC:</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>ML ‹fun ML ctxt source = ML_Context.eval_source_in (SOME ctxt) ML_Compiler.flags source›</p>\n<p>ML ‹ML @{context} ‹writeln @{const_name True}››</p>\n<p>end</p>\n<p>Here is the same for the raw ML toplevel of isabelle_process:</p>\n<p>fun ML ctxt source = ML_Context.eval_source_in (SOME ctxt) ML_Compiler.flags source;</p>\n<p>ML (Proof_Context.init_global (Thy_Info.get_theory \"Main\")) (Input.string \"writeln @{const_name True}\");</p>\n<p>This works to some extent, but not all aspects of the normal <br>\nIsabelle/Isar/ML environment is imitated here (like proper handling of <br>\ninterrrupts and exceptions).</p>\n<p>Makarius</p>",
        "id": 294637501,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160765
    }
]