[
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nLooking at</p>\n<p>val ctxt = Proof_Context.init_global @{theory Main};<br>\n    Syntax.read_term ctxt \"add_assoc\"<br>\n       (* = Free (\"add_assoc\", \"'a\"): term *)<br>\n    Syntax.read_term ctxt \"add.assoc\"<br>\n       (* ERROR: Undefined constant: \"add.assoc\"*)</p>\n<p>is my assumption right, that the latter is considered outer syntax only?<br>\nIn other words: The latter is NOT considered to become a valid term <br>\n(i.e. inner syntax) within some context ?</p>\n<p>If both questions are answered \"yes\", then this question comes up: How <br>\ncomes that the designers of Isabelle are sure, that theorem names never <br>\nshall occur in functions defined within Isabelle's function package <br>\n(where function definitions are terms, i.e. belong to inner syntax) ?</p>\n<p>And how does that design decision relate to the announcement of <br>\n\"Eisbach, a new sub-language for Isabelle which allows users to write <br>\nautomated reasoning techniques with high-level syntax, avoiding the <br>\nnecessity of descending into ML\"?</p>\n<p>Walther</p>",
        "id": 294635237,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159863
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThere /is/ a context in which the latter becomes a valid term.</p>\n<p>add_assoc and add.assoc are both valid inner syntax names. Both of them<br>\ncan denote constants; add_assoc can even be a free or bound variable.<br>\nNothing prevents you from declaring a function called \"add_assoc\", or<br>\ncalling variables in your lemmas \"add_assoc\".</p>\n<p>add.assoc is a bit different due to the qualifying dot in the name; that<br>\nis why add_assoc, in your example, is considered a free variable and<br>\nadd.assoc returns an error. \"add.assoc\" is not a valid name for a free<br>\nor bound variable. You can, however, easily define a locale \"add\" and a<br>\nfunction \"assoc\" in it, resulting in a constant called \"add.assoc\", and<br>\nthen your example does not return an error:</p>\n<p>locale add<br>\nbegin<br>\n  fun assoc where \"assoc x = x\"<br>\nend</p>\n<p>ML_val {* Syntax.read_term @{context} \"add.assoc\" *}<br>\nval it = Const (\"Scratch.add.assoc\", \"'a ⇒ 'a\"): term</p>\n<p>So I suppose the answer to your question is: theorem names /can/ occur<br>\nin inner syntax, but then they do not refer to theorems; they are just<br>\nnames like any other, because the inner syntax does not know anything<br>\nabout theorems or theorem names. The name \"add_assoc\" is a priori no<br>\ndifferent from the name \"x\", and \"add.assoc\" no different from<br>\n\"<a href=\"http://foo.bar\">foo.bar</a>\", even though the former are fact names.</p>\n<p>How that relates to Eisbach I cannot say, since I don't know the first<br>\nthing about Eisbach. I would, however, imagine that Eisbach also has the<br>\nstrict separation between outer level (lemmas, definitions, etc.) and<br>\ninner level (object logic terms) and therefore your question does not<br>\naffect Eisbach at all.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294635253,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159870
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nI can confirm that part. There’s nothing special about Eisbach in that respect.</p>\n<p>Cheers,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294635267,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159876
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIsabelle is not Coq or PVS.  There is not just one big lambda calculus to <br>\nassimilate everything, but we have arbitrarily nested languages and <br>\nsyntaxes.</p>\n<p>Name spaces are strictly separate for each \"kind\" of things.  The syntax <br>\nis usually done in a way that the distinction of kinds is clear from how <br>\nthe text is written.  E.g. fact expressions refer to attributes and <br>\ntheorems in a certain way, and cannot be mistaken as terms, for example.</p>\n<p>The main exception to the syntactic distinction of kinds is the inner term <br>\nlanguage: consts, frees, bounds can all look the same in the syntax, but <br>\nare later distinguished by their scope.</p>\n<p>The main meta-problem on this thread might be actually an expectation of <br>\nsomething complicated, but the situation is quite plain and simple.  And <br>\nafter decades of reforms of the system implementation it should all work <br>\nout smoothly, including arbitrary nesting of languages.</p>\n<p>If you want do implement something like that yourself, you can take the <br>\n\"rail\" language for syntax diagrams as an example (see <br>\n~~/src/Pure/Tools/rail.ML).  It has the advantage that it is rather small, <br>\nand has no connection to logic or lambda calculus to get confused.  There <br>\nis also a fair amount of IDE support just from the few canonical things <br>\ndone in that module; e.g. see uses of @{rail} in ~~/src/Doc/.</p>\n<p>Makarius</p>",
        "id": 294635278,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159882
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nThank you for the explanations</p>\n<blockquote>\n<p>Name spaces are strictly separate for each \"kind\" of things.  The <br>\nsyntax is usually done in a way that the distinction of kinds is clear <br>\nfrom how the text is written. E.g. fact expressions refer to <br>\nattributes and theorems in a certain way, and cannot be mistaken as <br>\nterms, for example.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>So I suppose the answer to your question is: theorem names /can/ occur <br>\nin inner syntax, but then they do not refer to theorems; </p>\n</blockquote>\n<p>while with respect to the following</p>\n<blockquote>\n<p>The main meta-problem on this thread might be actually an expectation <br>\nof something complicated, but the situation is quite plain and <br>\nsimple.  And after decades of reforms of the system implementation it <br>\nshould all work out smoothly, including arbitrary nesting of languages.</p>\n</blockquote>\n<p>some smoothness is lost in case one uses Isabelle not anticipated by <br>\ndesign, for instance Lucas-Interpretation [1]: Here programs [2] contain <br>\ntheorem names, which are turned into theorems by functions available in <br>\nIsabelle; this now requires additional conversion [3].</p>\n<p>So thanks a lot for all the replies -- they tell us about prospects on <br>\nEisbach.</p>\n<p>Walther</p>\n<p>[1] <a href=\"http://eptcs.web.cse.unsw.edu.au/paper.cgi?THedu11.5\">http://eptcs.web.cse.unsw.edu.au/paper.cgi?THedu11.5</a><br>\n[2] We plan to employ Isabelle's function package for that purpose.<br>\n[3] <a href=\"https://intra.ist.tugraz.at/hg/isa/rev/419308245588\">https://intra.ist.tugraz.at/hg/isa/rev/419308245588</a></p>",
        "id": 294635322,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661159891
    }
]