[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nDear Brian,</p>\n<p>I have been working some more with HOLCF (although my supervisers warned<br>\nme that I might run into difficulties or make life harder for me...),<br>\nand I have some suggestions and some questions. I hope you don’t mind me<br>\naccosting them to you, and remember that these really are only<br>\nsuggestions, not requests :-)</p>\n<p>First I noticed that I tend to have a lot of admissibility statements to<br>\nproof. With the lemmas provided in Adm.thy, this is usually not a big<br>\nproblem. I wonder if it would be sensible to take a similar approach<br>\nthan taken with cont2cont: I.e. have a ruleset adm2adm that I can amend,<br>\nso that I can just use \"apply (intros adm2adm)\" without listing all my<br>\ncuston adm rules, and be done in most cases. Or possibly \"apply (intros<br>\nadm2adm cont2cont)\", if some rules involve continuity claims, such as<br>\nthis one I wrote:</p>\n<hr>\n<p>lemma adm_single_valued:<br>\n assumes \"cont (λx. f x)\"<br>\n shows \"adm (λx. single_valued (f x))\"<br>\nusing assms<br>\nunfolding single_valued_def<br>\nby (intro adm_lemmas adm_not_mem cont2cont adm_subst[of f])</p>\n<hr>\n<p>My next question is about pattern matching in fixrec equations. At the<br>\nmoment, fixrec only supports very few constructors in patterns, and the<br>\nDiscr constructor is not supported. Therefore, I have only one equation<br>\nwith a large case expression then, which makes the .induct rule<br>\nrelatively unpleasant to work with (compared with, e.g., the function<br>\npackage). I’d be glad if I could use the Discr constructor in patterns,<br>\nand I’d be even more pleased if arbitrary patterns can be used inside<br>\nthe Discr constructor. </p>\n<p>And finaly, I’d like to have some advice. I tried to proof a statement<br>\n\"P f\" about the function f defined by fixrec, using f.induct. I noticed<br>\nthat it would be easier if I know \"Q f\", so I proved that (again using<br>\nf.induct). Turning back to the proof of \"P f\", I found out that the<br>\nlemma \"Q f\" is useless, as in the inductive proof of \"P f\" I am not<br>\nworking with f, but rather an approximation.</p>\n<p>I worked around it by proving P and Q simultaneously in one induction,<br>\nbut the proof is becoming illegibly convoluted.</p>\n<p>Is there maybe a cleaner and more idiomatic way of handing such a case?<br>\nI’m afraid that if I continue this way, in the end all statements of my<br>\nprojects will be proven in one huge induct rule. And Isabelle is already<br>\nmoving slowly inside the induct proof.</p>\n<p>Thanks for your support,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/1KZp_lHxgIHUpvWrHuy1AUTE/signature.asc\">signature.asc</a></p>",
        "id": 294116633,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838509
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Tue, Sep 7, 2010 at 1:11 PM, Joachim Breitner<br>\n&lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Brian,</p>\n<p>I have been working some more with HOLCF (although my supervisers warned<br>\nme that I might run into difficulties or make life harder for me...),<br>\nand I have some suggestions and some questions. I hope you don’t mind me<br>\naccosting them to you, and remember that these really are only<br>\nsuggestions, not requests :-)</p>\n<p>First I noticed that I tend to have a lot of admissibility statements to<br>\nproof. With the lemmas provided in Adm.thy, this is usually not a big<br>\nproblem. I wonder if it would be sensible to take a similar approach<br>\nthan taken with cont2cont: I.e. have a ruleset adm2adm that I can amend,<br>\nso that I can just use \"apply (intros adm2adm)\" without listing all my<br>\ncuston adm rules, and be done in most cases. Or possibly \"apply (intros<br>\nadm2adm cont2cont)\", if some rules involve continuity claims, such as<br>\nthis one I wrote:</p>\n<hr>\n<p>lemma adm_single_valued:<br>\n[...]</p>\n</blockquote>\n<p>Hi Joachim,</p>\n<p>You can easily create your own named rulesets using the Named_Thms ML<br>\nfunctor, like this:</p>\n<p>ML {*<br>\nstructure Adm2Adm = Named_Thms<br>\n(<br>\n  val name = \"adm2adm\"<br>\n  val description = \"admissibility intro rule\"<br>\n)<br>\n*}<br>\nsetup Adm2Adm.setup</p>\n<p>This defines a dynamic theorem list called \"adm2adm\", as well as an<br>\nattribute called \"adm2adm\" that will add a theorem to the list. You<br>\ncan then populate the ruleset with pre-existing rules from Adm.thy<br>\nusing a declare statement:</p>\n<p>declare &lt;names of adm rules&gt; [adm2adm]</p>\n<blockquote>\n<p>My next question is about pattern matching in fixrec equations. At the<br>\nmoment, fixrec only supports very few constructors in patterns, and the<br>\nDiscr constructor is not supported. Therefore, I have only one equation<br>\nwith a large case expression then, which makes the .induct rule<br>\nrelatively unpleasant to work with (compared with, e.g., the function<br>\npackage). I’d be glad if I could use the Discr constructor in patterns,<br>\nand I’d be even more pleased if arbitrary patterns can be used inside<br>\nthe Discr constructor.</p>\n</blockquote>\n<p>You can extend fixrec by associating match combinators with new<br>\nconstructors, using the Fixrec.add_matchers ML command. To see how to<br>\ndo this, look at my latest update to List_Cpo.thy, where I set up Nil<br>\nand Cons to work with fixrec:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/3989b2b44dba\">http://isabelle.in.tum.de/repos/isabelle/rev/3989b2b44dba</a></p>\n<p>Unfortunately this won't work for all constructors -- fixrec has some<br>\nhard-wired assumptions about the kinds of constructors it will work<br>\nwith. For one, it assumes that the arguments to the constructor will<br>\nall have types in class cpo. This means that the \"Discr\" and \"Def\"<br>\nconstructors won't work, because their argument types are generally<br>\nnot cpos.</p>\n<p>I'd like to relax this restriction, but doing so would require<br>\nrewriting fixrec's pattern-match compiler, which I don't really have<br>\ntime to do right now -- I need to finish my dissertation first!</p>\n<blockquote>\n<p>And finaly, I’d like to have some advice. I tried to proof a statement<br>\n\"P f\" about the function f defined by fixrec, using f.induct. I noticed<br>\nthat it would be easier if I know \"Q f\", so I proved that (again using<br>\nf.induct). Turning back to the proof of \"P f\", I found out that the<br>\nlemma \"Q f\" is useless, as in the inductive proof of \"P f\" I am not<br>\nworking with f, but rather an approximation.</p>\n<p>I worked around it by proving P and Q simultaneously in one induction,<br>\nbut the proof is becoming illegibly convoluted.</p>\n<p>Is there maybe a cleaner and more idiomatic way of handing such a case?<br>\nI’m afraid that if I continue this way, in the end all statements of my<br>\nprojects will be proven in one huge induct rule. And Isabelle is already<br>\nmoving slowly inside the induct proof.</p>\n</blockquote>\n<p>I'm afraid that with the foo.induct rules currently produced by<br>\nfixrec, you're probably stuck doing the simultaneous inductions.<br>\nFortunately it is possible to create a stronger induction rule, but<br>\nunfortunately fixrec does not generate such a rule for you. (It's on<br>\nmy long list of things to do after I finish my degree :)</p>\n<p>Here's how fixrec currently generates its induction rules: When you<br>\ndefine a recursive constant \"foo :: 'a\", fixrec builds a functional<br>\n\"foo_rec :: 'a =&gt; 'a\", and defines foo as its least fixed-point: \"foo<br>\n== fix$(LAM f. foo_rec f)\".</p>\n<p>Then fixrec uses the \"fix_ind\" lemma to generate an induction rule for foo:</p>\n<p>lemma fix_ind:<br>\n  assumes \"adm P\" and \"P \\&lt;bottom&gt;\" and \"!!x. P x ==&gt; P (F$x)\"<br>\n  shows \"P (fix$F)\"</p>\n<p>The problem is that fix_ind is weaker than it could be. Here is a<br>\nstronger form of induction for least fixed-points that could be used<br>\ninstead:</p>\n<p>lemma<br>\n  assumes \"adm P\" and \"!!n. P (iterate n$F$\\&lt;bottom&gt;)\"<br>\n  shows \"P (fix$F)\"</p>\n<p>So here's what I'd <em>like</em> fixrec to do: In addition to defining \"foo<br>\n== fix$(LAM f. foo_rec f)\", also define another nat-indexed sequence<br>\nof approximations to foo: \"foo_chain n == iterate n$(LAM f. foo_rec<br>\nf)$\\&lt;bottom&gt;\". Then it could generate an unfolding rule:</p>\n<p>\"foo_chain (Suc n) = foo_rec (foo_chain n)\"</p>\n<p>and a strong induction rule:</p>\n<p>\"adm P ==&gt; (!!n. P (foo_chain n)) ==&gt; P foo\"</p>\n<p>I think such a rule would allow you to prove separate lemmas about<br>\nfoo_chain, and re-use them inside later inductions. This way you could<br>\navoid having to do those big simultaneous inductions you complained<br>\nabout. Even without automation from fixrec, it might be worthwhile to<br>\ndefine the extra constant and prove the extra rules manually.</p>\n<blockquote>\n<p>Thanks for your support,<br>\nJoachim</p>\n</blockquote>\n<p>Thanks for your interest in HOLCF!</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294116650,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838515
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nDear Brian,</p>\n<p>I’d like to try that, but here, the symbol \"foo_rec\" is not known. And<br>\nlooking at src/HOLCF/Tools/fixrec.ML (without understanding much), I can<br>\nnot find a string ending in \"rec\" anywhere. The _def theorems generated<br>\nby fixrec seem to contain the equations of my functions directly. Are<br>\nyou sure that the _rec symbol is actually generated?</p>\n<p>Thanks,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/6IzNO9dHYsrzAmiYghwmkxP1/signature.asc\">signature.asc</a></p>",
        "id": 294116884,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838570
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nSorry, I guess what I said was a bit misleading. There is no \"foo_rec\"<br>\nconstant. I only meant \"foo_rec\" to stand for the functional (a<br>\npossibly large lambda term) of which \"foo\" is the least fixed-point.</p>\n<p>Maybe a more explicit example will my suggestion more clear.</p>\n<p>domain 'a llist = LNil | LCons (lazy 'a) (lazy \"'a llist\")</p>\n<p>fixrec repeat :: \"'a -&gt; 'a llist\" where \"repeat$a = LCons$a$(repeat$a)\"</p>\n<p>These lemmas are generated by fixrec:</p>\n<p>repeat_def: \"repeat == fix$(LAM r a. LCons$a$(r$a))\"<br>\nrepeat.unfold: \"repeat = (LAM a. LCons$a$(repeat$a))\"<br>\nrepeat.simps: \"repeat$a = LCons$a$(repeat$a)\"<br>\nrepeat.induct: \"adm P ==&gt; P \\&lt;bottom&gt; ==&gt; (!!x. P x ==&gt; P (LAM a.<br>\nLCons$a$(x$a))) ==&gt; P repeat\"</p>\n<p>And I would suggest that you also define</p>\n<p>repeat_chain :: \"nat =&gt; 'a -&gt; 'a llist\"<br>\n\"repeat_chain n == iterate n$(LAM r a. LCons$a$(r$a))$\\&lt;bottom&gt;\"</p>\n<p>and prove the lemmas</p>\n<p>\"repeat_chain (Suc n) = (LAM a. LCons$a$(repeat_chain n$a))\"<br>\n\"adm P ==&gt; (!!n. P (repeat_chain n)) ==&gt; P repeat\"</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294116996,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838601
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nHi Brian,</p>\n<p>ah, I see. Although it would be nice to have the foo_chain defined, in<br>\nmy case, it would be too ugly (the lambda-term I’d have to copy’n’paste<br>\nwould just be too ugly large :-). I’ll try to work with one big<br>\ninduction proof now.</p>\n<p>But thanks for the suggestion.</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/ZKUIfjt9j_8HA6lxKbGpefYc/signature.asc\">signature.asc</a></p>",
        "id": 294117026,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838607
    }
]