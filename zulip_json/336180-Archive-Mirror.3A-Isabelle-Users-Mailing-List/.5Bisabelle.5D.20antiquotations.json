[
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nI'm having some trouble using antiquotations.</p>\n<p>I find, for example that</p>\n<p>val ls_sp = @{simproc let_simp} ;</p>\n<p>works fine,  but</p>\n<p>val ncn_sp = @{simproc natless_cancel_numerals} ;</p>\n<p>doesn't work, message is<br>\n ***    ERROR \"Undefined simplification procedure: <br>\n\\\"natless_cancel_numerals\\\"\"</p>\n<p>(and many more that I've tried also don't work).</p>\n<p>How should I use these antiquotations?</p>\n<p>Another problem I've found with antiquotations is that commenting them <br>\nout doesn't work properly, thus</p>\n<p>val ls_sp = @{simproc let_simp} ;<br>\n(*<br>\nval ncn_sp = @{simproc natless_cancel_numerals} ;<br>\n*)</p>\n<p>produces the same error message about natless_cancel_numerals</p>\n<p>Jeremy</p>",
        "id": 294055488,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821396
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nDear Jeremy,</p>\n<blockquote>\n<p>I find, for example that</p>\n<p>val ls_sp = @{simproc let_simp} ;</p>\n<p>works fine,  but</p>\n<p>val ncn_sp = @{simproc natless_cancel_numerals} ;</p>\n<p>doesn't work, message is<br>\n***    ERROR \"Undefined simplification procedure: <br>\n\\\"natless_cancel_numerals\\\"\"</p>\n</blockquote>\n<p>Hmmm... It seems that the difference is that \"let_simp\" was declared <br>\nusing the \"simproc_setup\" command (in HOL.thy), and the declaration of <br>\n\"natless_cancel_numerals\" still happens using the (imperative) ML <br>\noperations. This might be the reason for the anomaly, though I am not sure.</p>\n<blockquote>\n<p>Another problem I've found with antiquotations is that commenting them <br>\nout doesn't work properly, thus</p>\n<p>val ls_sp = @{simproc let_simp} ;<br>\n(*<br>\nval ncn_sp = @{simproc natless_cancel_numerals} ;<br>\n*)</p>\n<p>produces the same error message about natless_cancel_numerals</p>\n</blockquote>\n<p>Yes, this is probably worth improving: At the stage where the <br>\nantiquotations are expended, comments are not taken into account.</p>\n<p>I am sure, Makarius can comment on these issues when he is back from <br>\nvacation.</p>\n<p>Alex</p>",
        "id": 294055505,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821409
    },
    {
        "content": "<p>From: Amine Chaieb &lt;<a href=\"mailto:chaieb@in.tum.de\">chaieb@in.tum.de</a>&gt;<br>\nAlexander Krauss wrote:<br>\nThe @{simproc } Antiquotation just asks the context for a simproc <br>\ndeclared under that name. If the simproc has not been \"registered\", it <br>\ncan not be found. The simproc_setup command does this consequently.</p>\n<p>The distribution is not yet cleaned up in this aspect, i.e. not all <br>\nsimprocs are declared \"officially\".</p>\n<p>Amine.</p>",
        "id": 294055518,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821415
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHaving studied the recent threads on the \"effect of use_thy\", <br>\n\"antiquotations\" etc. here is a summary in my own words, together with <br>\nsome additional hints on how to avoid problems with old ways of doing <br>\nthings, and moving on towards more powerful concepts.</p>\n<p>* ML code should be used within a proper theory only, with explicit <br>\n    \"uses\" declarations for the theory header specification for any \"use\"  <br>\n    command in the body.  Inline \"ML\" commands work without further ado.</p>\n<p>For historical reasons, the theory loader is a bit too liberal in <br>\n    skimping over ill-specified dependencies, which occasionally results <br>\n    in confusing situations, where the loader and the user disagree on the <br>\n    state of a theory being fully loaded.  This will improve eventually, <br>\n    as we remove more legacy features, especially the possibility of <br>\n    loading ML files ``after a theory'', which has caused endless trouble <br>\n    ever since it was introduced many years ago.  (Long ago this feature <br>\n    was really needed, because it was impossible to prove theorems within <br>\n    a theory body, which is hard to believe today.)</p>\n<p>* The raw interactive ML toplevel is mostly obsolete.  After many years <br>\n    of the two toplevels side-by-side, we have finally passed the turning <br>\n    point where everything is Isar, and ML is smoothly integrated into <br>\n    that.  Proper context-dependent antiquotations are just one benefit <br>\n    from this principle, and typing additional ML {* *} should be a small <br>\n    price to pay in current Proof General (adding a key binding to produce <br>\n    that wrapping should be trivial anyway).</p>\n<p>Further benefits of turning everything into Isar transactions will <br>\n    become more relevant in the future.  The point is that this uniform <br>\n    arrangement allows the Isar toplevel to ``manage'' isolated <br>\n    executions.  For example, it enables to schedule transactions <br>\n    concurrently (which is still limited to whole theory files in <br>\n    Isabelle2007).  Or just think of interrupting individual Isar commands <br>\n    instead of the whole Isabelle process with all its concurrent <br>\n    transactions being worked on at some point.</p>\n<p>If you really need the bare-metal feeling of the raw ML toplevel (e.g. <br>\n    for special debugging situations), here is an easy way to get it with <br>\n    proper Isar context, but without antiquotations:</p>\n<p>theory A imports B begin<br>\n      exit               (<em>leaving Isar for now</em>)<br>\n      ML&gt; ...            (<em>raw ML text here</em>)<br>\n      ML&gt; Isar.loop();   (<em>back to normal</em>)</p>\n<p>This also works within a proof or locale contexte etc.</p>\n<p>* ML functions that refer to the old-style (dynamic) context, such as <br>\n    \"the_context\" and \"thm\" are very hard to understand exactly and should <br>\n    be replaced more and more by proper antiquotations (which are <br>\n    statically scoped at compile-time).</p>\n<p>This means that pointing your finger at some bits of ML code, you <br>\n    already know its context (i.e. where your finger is within the <br>\n    Isabelle/Isar text), and any terms, thms etc. being referenced by <br>\n    antiquotation are fixed values wrt. to that context.  Moreover there <br>\n    is some degree of static checking of formal references.  For example, <br>\n    @{const_name wf} or @{thm wf_induct} will only compile if these <br>\n    entities are well-formed according to the compile-time context.</p>\n<p>Slightly more delicate issues arise when ML implementations are moved <br>\n    between contexts along with logical entities, by re-interpreting <br>\n    general ``declarations'' wrt. to a given morphism.  Some recent papers <br>\n    and talks by Chaieb/Wenzel explain these advanced concepts further.</p>\n<p>* The expander for antiquotations is ignorant of ML syntax.  In <br>\n    particular, Isar entities referenced inside ML comments are still <br>\n    statically checked, which might occasionally appear more rigid than <br>\n    expected.</p>\n<p>At some later stage, the expansion mechanism might learn bits of ML <br>\n    syntax (which is quite delicate), so this could be liberalized <br>\n    eventually.  A more interesting application of ML syntax interacting <br>\n    with Isar antiquotations is to produce different code in ML pattern <br>\n    positions (of fun/case/let) vs. plain ML expressions.</p>\n<p>* The @{theory} antiquotation requires special care, because it produces <br>\n    a static reference to the current theory value, which is still <br>\n    developed further in the present theory body.  If the ML environment <br>\n    somehow keeps this value persistently, it is likely to cause ``stale <br>\n    theory'' errors when accessed later.  As explained in the rudimentary <br>\n    \"Isabelle/Isar Implementation Manual\", theory certificates work like a <br>\n    linear type in ML, but a persistent @{theory} value violates the <br>\n    linearity restriction.</p>\n<p>In the worst case, one needs to keep a @{theory_ref} instead, which is <br>\n    a sliding theory reference that never becomes stale, but may evolve <br>\n    monotonically without further notice (just like the implicit theory <br>\n    reference present within any @{context}, @{thm}, or @{cterm} value).</p>\n<p>Luckily, raw theory values are rarely required these days, since <br>\n    Proof.context has taken over its role to represent ``the context'' <br>\n    most of the time. (In new-style local theory specifications, such as <br>\n    definitions within a locale, the context is disguised as local_theory, <br>\n    which is of the same ML type Proof.context, but holds additional <br>\n    target information to tell how results are processed).</p>\n<p>Makarius</p>",
        "id": 294055730,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821494
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 8 Feb 2008, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>Mostly my problems are something do to with theories.  I don't know if <br>\nthe problems I've faced today are because of theories or not, but I <br>\nthink it is quite likely.  But I waste an enormous amount of time trying <br>\nto cope with things that don't work as expected.</p>\n</blockquote>\n<p>The general advice is to let Isar take over control as much as possible, <br>\nwhile avoiding raw ML accesses (in particular operations with unclear <br>\ntheory/proof context).</p>\n<p>In particular:</p>\n<p>- Use ProofGeneral by default.<br>\n  - Always work within a theory body, if a theory is required.  Do not <br>\n    rely on accidental theory states from previous use_thy etc.</p>\n<p>- Use ML antiquotions as much as possible, because here the context is <br>\n    checked statically at compile time.</p>\n<blockquote>\n<p>The latest example is contained in the attached theory file. For some <br>\nreason the ML expression bool_axioms RL [fun_cong] produces an empty <br>\nlist of results when it appears in the theory file being loaded.</p>\n<p>After the theory file is modified in the way shown (ie not using <br>\nbool_axioms RL [fun_cong]) it loads OK.  Then, after that, the <br>\nexpression bool_axioms RL [fun_cong] returns exactly the results <br>\nexpected.  Why does the same ML expression behave differently at <br>\ndifferent points ?</p>\n</blockquote>\n<p>This is a good example why proper contexts matter.  The bool_axioms list <br>\nis bound at the ML toplevel in a situation <em>before</em> certain type class <br>\ninstantiations in your theory.  For the resolution to work out, these type <br>\narities need to be present in the theory.  Your ML code fails to produce <br>\nany result here, because it references bool_axioms in the raw ML <br>\nenvironment, without going through the Isar layer, which would have <br>\ntransferred the result as required.</p>\n<p>Using a proper ML antiquotation makes things work as expected:</p>\n<p>@{thms bool_axioms} RL [fun_cong]</p>\n<p>It is important to keep in mind that the ML environment is not the real <br>\nthing, just a low-level view on the implementation platform.</p>\n<p>Makarius</p>",
        "id": 294056050,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821617
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nMakarius wrote:</p>\n<blockquote>\n<p>On Fri, 8 Feb 2008, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>Mostly my problems are something do to with theories.  I don't know if <br>\nthe problems I've faced today are because of theories or not, but I <br>\nthink it is quite likely.  But I waste an enormous amount of time trying <br>\nto cope with things that don't work as expected.<br>\n</p>\n</blockquote>\n<p>The general advice is to let Isar take over control as much as possible, <br>\nwhile avoiding raw ML accesses (in particular operations with unclear <br>\ntheory/proof context).</p>\n<p>In particular:</p>\n<p>- Use ProofGeneral by default.<br>\n  - Always work within a theory body, if a theory is required.  Do not <br>\n    rely on accidental theory states from previous use_thy etc.<br>\n  - Use ML antiquotions as much as possible, because here the context is <br>\n    checked statically at compile time.</p>\n<blockquote>\n<p>The latest example is contained in the attached theory file. For some <br>\nreason the ML expression bool_axioms RL [fun_cong] produces an empty <br>\nlist of results when it appears in the theory file being loaded.</p>\n<p>After the theory file is modified in the way shown (ie not using <br>\nbool_axioms RL [fun_cong]) it loads OK.  Then, after that, the <br>\nexpression bool_axioms RL [fun_cong] returns exactly the results <br>\nexpected.  Why does the same ML expression behave differently at <br>\ndifferent points ?<br>\n</p>\n</blockquote>\n<p>This is a good example why proper contexts matter.  The bool_axioms list <br>\nis bound at the ML toplevel in a situation <em>before</em> certain type class <br>\ninstantiations in your theory.  For the resolution to work out, these type <br>\narities need to be present in the theory. <br>\nMakarius,</p>\n</blockquote>\n<p>Thanks for this - I think I understand this point.</p>\n<blockquote>\n<p>Your ML code fails to produce <br>\nany result here, because it references bool_axioms in the raw ML <br>\nenvironment, without going through the Isar layer, which would have <br>\ntransferred the result as required.</p>\n<p>However I don't understand this - as I said in my earlier email, exactly <br>\nthe same ML code _does_ produce the desired result later on.  So why <br>\ndoes the _same_ ML expression behave _differently_ at different points <br>\n?  Both the points where the ML expression bool_axioms RL [fun_cong] is <br>\nused occur _after_ the point where fun is shown to be in the<br>\naxclass boolean_class  (I understand that this is what the problem was).<br>\nUsing a proper ML antiquotation makes things work as expected:</p>\n<p>@{thms bool_axioms} RL [fun_cong]</p>\n<p>I gather your point is that</p>\n</blockquote>\n<p>@{thms bool_axioms}</p>\n<p>transfers bool_axioms to the current theory.  But this is exactly what I <br>\ndon't want!<br>\nMy complaint is that the _same_ ML expression bool_axioms RL [fun_cong] <br>\nbehaves differently between (a) where I put it in the theory file, where <br>\nit doesn't work, and (b) when I use it later, in trying to debug the <br>\nproblem.  I want the same expression to have the same meaning when I am <br>\ntrying to debug it as the meaning it has when it fails to work! </p>\n<p>Incidentally, some years ago I discovered that thms \"bool_axioms\" <br>\nretrieves the theorems<br>\nbool_axioms, after transferring them to the current theory.  I asked how <br>\nto retrieve named theorem(s) without transferring them to the current <br>\ntheory - no one then seemed to know.  Does anyone know how to do this?</p>\n<p>Further questions from my previous email, whose answers would, I hope, <br>\nhelp me to understand the complexities of theories in Isar:</p>\n<p>theory_of_thm (hd bool_axioms); produces a different result inside the <br>\nIsar file<br>\nfrom the result it gives afterwards.  Why is this?</p>\n<p>If I understand correctly the_context () returns the current theory as <br>\nat the point where it is executed.  Is that correct?  </p>\n<p>The difficulty in using Isar seems to be that the current theory keeps <br>\non changing, much more than with typical .ML proof files. Is this correct? </p>\n<p>So far as I understood the previous emails,<br>\nML {* XXX the_context  () <em>} and ML {</em> XXX@{theory} *} would only return <br>\na different result if the code represented by XXX actually changed the <br>\ncurrent theory.  Is that correct?</p>\n<p>A further question from a previous email (the answer given then was to <br>\nuse a different function) : bind_thm(s) seems to sometimes work (in the <br>\nsense of storing a theorem in the database so that it can be effectively <br>\nretrieved later).  Why is this?  What is the difference between bind_thm <br>\nand the function I was told to use (ie, PureThy.add_thmss)?</p>\n<p>Finally, is all this stuff documented anywhere?</p>\n<blockquote>\n<p>It is important to keep in mind that the ML environment is not the real <br>\nthing, just a low-level view on the implementation platform.</p>\n<p>I'm not sure what this means, but it is the language in which enormous <br>\namounts of Isabelle proofs are and have been written - and it is still <br>\nthe only language for doing lots of things (including some fairly <br>\nmundane things, as my theory file showed) in Isabelle.</p>\n</blockquote>\n<p>Jeremy</p>",
        "id": 294056089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821636
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere are some references that might help:</p>\n<ul>\n<li>\n<p>Makarius Wenzel and Burkhart Wolff. Building Formal Method Tools in the <br>\n   Isabelle/Isar Framework. In Theorem Proving in Higher Order Logics, <br>\n   TPHOLs 2007.<br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/isar-tool-framework.pdf\">http://www4.in.tum.de/~wenzelm/papers/isar-tool-framework.pdf</a></p>\n</li>\n<li>\n<p>Makarius Wenzel and Amine Chaieb. SML with antiquotations embedded into <br>\n   Isabelle/Isar. In J. Carette and F. Wiedijk, editors. Programming <br>\n   Languages for Mechanized Mathematics Workshop (CALCULEMUS 2007). <br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/Isar-SML.pdf\">http://www4.in.tum.de/~wenzelm/papers/Isar-SML.pdf</a></p>\n</li>\n<li>\n<p>Amine Chaieb and Makarius Wenzel. Context aware Calculation and <br>\n   Deduction --- Ring Equalities via Gröbner Bases in Isabelle. In M. <br>\n   Kauers, M. Kerber, R. Miner, and W. Windsteiger, editors. Towards <br>\n   Mechanized Mathematical Assistants (CALCULEMUS 2007 and MKM 2007).<br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/context-methods.pdf\">http://www4.in.tum.de/~wenzelm/papers/context-methods.pdf</a></p>\n</li>\n<li>\n<p>Makarius Wenzel.  The Isabelle/Isar Implementation Manual.  Distributed <br>\n   with Isabelle2007 (incomplete).<br>\n<a href=\"http://isabelle.in.tum.de/dist/Isabelle/doc/implementation.pdf\">http://isabelle.in.tum.de/dist/Isabelle/doc/implementation.pdf</a></p>\n</li>\n</ul>\n<p>These things did not appear overnight out of the blue, but emerged from <br>\nprinciples that have been present in Isabelle for many years already.</p>\n<p>The following talk provides an overview of the general state of affairs of <br>\nintegrating everything into some kind of ``logical operating system'':</p>\n<ul>\n<li>Makarius Wenzel.<br>\n   Aspects of locality in Isabelle --- local proofs, local theories, and <br>\n   local everything.<br>\n<a href=\"http://www.matf.bg.ac.yu/~janicic/locality.pdf\">http://www.matf.bg.ac.yu/~janicic/locality.pdf</a></li>\n</ul>\n<p>When using the system you do not have to understand all the details, but <br>\nmerely sit back comfortably and let the framework do most of the job. <br>\nComplications mostly arise from trying to challange things by interfering <br>\nwith the low-level implementation layer.</p>\n<p>Makarius</p>",
        "id": 294056098,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821642
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nDear Jeremy,</p>\n<p>In addition to the references, let me try to comment more specifically<br>\non some of your problems / complaints:</p>\n<blockquote>\n<p>My complaint is that the _same_ ML expression bool_axioms RL<br>\n[fun_cong] behaves differently between (a) where I put it in the<br>\ntheory file, where it doesn't work, and (b) when I use it later, in<br>\ntrying to debug the problem.</p>\n</blockquote>\n<p>If your radio doesn't work in the cellar, but does work in the living<br>\nroom, then you cannot debug the problem in the living room. You have to<br>\ngo to the cellar.</p>\n<blockquote>\n<p>I want the same expression to have the same meaning when I am trying<br>\nto debug it as the meaning it has when it fails to work!</p>\n</blockquote>\n<p>You should debug it in the same context: Open the offending theory in<br>\nPG, step to the point until it breaks, and debug it there. Then you<br>\nshould be able to see what the problem is.</p>\n<blockquote>\n<p>If I understand correctly the_context () returns the current theory<br>\nas at the point where it is executed.  Is that correct?<br>\n[...]<br>\nSo far as I understood the previous emails, ML {* XXX the_context  ()<br>\n<em>} and ML {</em> XXX@{theory} *} would only return a different result if<br>\nthe code represented by XXX actually changed the current theory.  Is<br>\nthat correct?</p>\n</blockquote>\n<p>No. Strictly speaking, the behaviour of the_context () is completely<br>\nunspecified: Since theories can be loaded in parallel, you could get<br>\nalmost anything, including a theory that is currently developing in a<br>\ndifferent thread. The \"current context\" is not defined in terms of the<br>\npoint in time when something is executed. It must be given statically,<br>\nby the location in the theory source. The @{theory} antiquotation does that.</p>\n<p>Let me repeat: If you use \"the_context ()\" in production code, it will<br>\nbreak with obscure errors sooner or later.</p>\n<blockquote>\n<p>A further question from a previous email (the answer given then was<br>\nto use a different function) : bind_thm(s) seems to sometimes work<br>\n(in the sense of storing a theorem in the database so that it can be<br>\neffectively retrieved later).  Why is this?  What is the difference<br>\nbetween bind_thm and the function I was told to use (ie,<br>\nPureThy.add_thmss)?</p>\n</blockquote>\n<p>You can read the answer from its type:</p>\n<p>bind_thms         : string * Thm.thm list -&gt; unit<br>\nPureThy.add_thmss : ((bstring * Thm.thm list) * Thm.attribute list) list<br>\n                 -&gt; Context.theory -&gt; Thm.thm list list * Context.theory</p>\n<p>Since bind_thms is impure, it can only update some global reference<br>\nhanging around. This is incompatible with paralellism. At the moment it<br>\nmay work sometimes, but it is guaranteed to break sooner or later.</p>\n<p>These changes are necessary, since the ability to process theories in<br>\nparalell decides whether you can use the 15 extra cores in your next CPU :-)</p>\n<p>You can usually tell these \"dont-use\" functions from the type: If you<br>\nfeel they should depend on or change the theory or context, and this is<br>\nnot explicit in the type, then this is calling for trouble.</p>\n<p>Since my comments above are a little non-constructive (\"don't do this\"),<br>\nI had another look at the theory you sent recently. You just need to<br>\nchange a few things to avoid all the trouble.</p>\n<ol>\n<li>Instead of the (evil, imperative) bind_thms, use a proper<br>\ndeclaration. On the theory level, the \"setup\" command will do what you<br>\nneed. It takes an ML snippet of type \"theory -&gt; theory\". In your example:</li>\n</ol>\n<p>setup {*<br>\n   let<br>\n     val boolexp = @{thm \"boolexp\"} ;</p>\n<p>val bool_axioms = Seq.list_of (EVERY'<br>\n       [REPEAT o dresolve_tac [conjunct1, conjunct2], REPEAT o etac allE,<br>\natac] 1<br>\n         (boolexp RS revcut_rl)) ;<br>\n   in<br>\n     snd o PureThy.add_thmss [((\"bool_axioms\", bool_axioms), [])]<br>\n   end<br>\n*}</p>\n<p>will do the right thing. If you find the syntax of PureThy.add_thmss too<br>\ncomplicated, just define yourself a shortcut:</p>\n<p>ML {*<br>\n   fun save_thms (name, thms) =<br>\n     snd o PureThy.add_thmss [((name, thms), [])]<br>\n*}</p>\n<ol start=\"2\">\n<li>Use antiquotations to refer to things from the context. Don't use the<br>\nimperative \"thm\" or \"thms\". They have no context, so they are bad :-).</li>\n</ol>\n<p>I recognise that it is hard to \"unlearn\" these things when they have<br>\nworked for you all the years. But it is really necessary to change them <br>\n(and thus break backwards compatibility) in order to bring Isabelle <br>\nforward.  But in the end, it should not be so difficult to solve your <br>\nconcrete problems.</p>\n<p>I hope this helps... Please don't hesitate to ask if you run into more <br>\nproblems, and include theory files whenever you can.</p>\n<p>All the best,<br>\nAlex</p>",
        "id": 294056114,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821648
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nJeremy Dawson wrote:<br>\nDear Jeremy,</p>\n<p>the reason for this effect is that each theorem contains an ML reference<br>\npointing to the theory it has been proved in (or been looked up in). The<br>\ntheorems contained in bool_axioms refer to some intermediate theory that<br>\ndoes not yet contain the information that fun is in boolean_class. However,<br>\nas soon as your theory has been completely processed, all theorems that<br>\nhave been proved in the preceeding intermediate theories are promoted to<br>\ntheorems that are also valid in the final theory. This is done by<br>\n(imperatively!) updating the theory references contained in the theorems,<br>\nwhich explains why the very same ML expression (denoting a data structure<br>\ncontaining a reference) suddenly behaves in a different way.</p>\n<p>This usage of references might indeed seem a bit strange at first sight,<br>\nbut it seems to be the only way to achieve that definitions and proofs<br>\nmay be intermixed within the same theory, which was impossible with the<br>\nimplementation of theories we had in Isabelle more than a decade ago.</p>\n<p>An effect similar to the one that you have noticed can be produced by<br>\nexecuting the ML command</p>\n<p>Type.of_sort (Sign.tsig_of (theory_of_thm (hd bool_axioms)))<br>\n     (Type (\"fun\", [TFree (\"'a\", HOLogic.typeS), TFree (\"'b\", [\"BI.boolean_class\"])]),<br>\n      [\"BI.boolean_class\"])</p>\n<p>for checking whether a function type is a member of boolean_class. This<br>\nexpression returns \"false\" when executed inside your theory, but \"true\"<br>\nwhen executed outside your theory, because the theory returned by<br>\n\"theory_of_thm ...\" is changed when closing the theory.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294056123,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821654
    },
    {
        "content": "<p>From: Lucas Dixon &lt;<a href=\"mailto:ldixon@inf.ed.ac.uk\">ldixon@inf.ed.ac.uk</a>&gt;<br>\n-----BEGIN PGP SIGNED MESSAGE-----<br>\nHash: SHA1</p>\n<p>Alexander Krauss wrote:<br>\nI'm curious about this: is it really the case that references are<br>\ninherently incompatible with parallelism? Is there some reason why it<br>\ncannot update a thread-local reference?</p>\n<p>I would expect that you can cut the Isar/ML cake both ways:<br>\nanti-quotations in Isar or quotations in ML. I feel there should be a<br>\nconfluence proof there somewhere :)</p>\n<p>So, is there some reason this is not possible? In particular, Isar is<br>\nexecuted in ML, so it seems rather strange to me that you cannot<br>\nreplicate it's effect in ML, for example by pasting the function calls<br>\nused by Isar into the ML.</p>\n<p>cheers,<br>\nlucas<br>\n-----BEGIN PGP SIGNATURE-----<br>\nVersion: GnuPG v1.4.6 (GNU/Linux)<br>\nComment: Using GnuPG with Mozilla - <a href=\"http://enigmail.mozdev.org\">http://enigmail.mozdev.org</a></p>\n<p>iD8DBQFHs4HXogMqU4edHsMRAjj/AJ0fAFJEtuZYSsziwW/nTSJqqHNJsQCdFCyS<br>\naOP6FBuIs/se0AyydGDCyqM=<br>\n=UlWW<br>\n-----END PGP SIGNATURE-----</p>",
        "id": 294056290,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821722
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nLucas Dixon wrote:<br>\nLucas / Alexander,</p>\n<p>Well, yes, one would think so.</p>\n<p>Perusing the source code, I see a function called<br>\neval_antiquotes (to be exact, I used !ML_Context.eval_antiquotes_fn)</p>\n<p>which gives results like this:</p>\n<p>val eval_antiquotes = !ML_Context.eval_antiquotes_fn ;<br>\neval_antiquotes \"val x = y ; val c = @{context} ; \\<br>\n  \\ val a = b ; val cs = @{claset} ; val t = @{theory}\" ;<br>\nval eval_antiquotes = fn : string -&gt; string * string</p>\n<blockquote>\n<h1>val it =</h1>\n<p>(\"structure Isabelle =\\nstruct\\nval context = <br>\nML_Context.the_local_context ();\\nval claset = Classical.local_claset_of <br>\n(ML_Context.the_local_context ());\\nval thy = ML_Context.the_context <br>\n();\\nend;\",<br>\n      \"val x = y ; val c = Isabelle.context ;  val a = b ; val cs = <br>\nIsabelle.claset ; val t = Isabelle.thy\")<br>\n: string * string</p>\n</blockquote>\n<p>Is this in fact used when the system encounters code such as</p>\n<p>ML {* val x = y ; val c = @{context} ; \\<br>\n  \\ val a = b ; val cs = @{claset} ; val t = @{theory} *} ?</p>\n<p>Or to be exact, is this translated code executed when the system <br>\nencounters the<br>\nML {* ... *} ?  If not, what exactly does happen ?</p>\n<p>If so, how does it work that in this case calls such as <br>\nML_Context.the_context () are safe to use ? (in general when are they <br>\nsafe and when not ?)</p>\n<p>In terms of threads in general:<br>\nWhen you're sitting at the terminal typing input into Isar, it gets <br>\nexecuted in the context of  a particular theory, doesn't it ?  Obviously <br>\nit manages to avoid any ambiguity (ie, it doesn't execute it in the <br>\ncontext of some other theory which is currently developing in a <br>\ndifferent thread. How does it identify which is the relevant theory ? </p>\n<p>Regards,</p>\n<p>Jeremy</p>",
        "id": 294056428,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821742
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 13 Feb 2008, Lucas Dixon wrote:</p>\n<blockquote>\n<p>Alexander Krauss wrote:</p>\n<blockquote>\n<p>Since bind_thms is impure, it can only update some global reference<br>\nhanging around. This is incompatible with paralellism. At the moment it<br>\nmay work sometimes, but it is guaranteed to break sooner or later.</p>\n</blockquote>\n<p>I'm curious about this: is it really the case that references are<br>\ninherently incompatible with parallelism? Is there some reason why it<br>\ncannot update a thread-local reference?</p>\n</blockquote>\n<p>In principle you can do this, but this requires extra bookeeping of some <br>\nkind of ``thread data environment''.  In post-Isabelle2007 we already have <br>\nthis for the \"print_mode\", which is now thread-safe without giving up the <br>\nslightly odd \"setmp\" idiom. Such contraptions should be the exeption, not <br>\nthe rule.</p>\n<p>Even Java programmers have started to envy powerful concepts of purely <br>\nfunctional programming, which partly explains the current excitement about <br>\nScala.</p>\n<blockquote>\n<p>I would expect that you can cut the Isar/ML cake both ways: <br>\nanti-quotations in Isar or quotations in ML. I feel there should be a <br>\nconfluence proof there somewhere :)</p>\n</blockquote>\n<p>In principle yes.  This is a bit like the Holo Deck in Startrek TNG, which <br>\nis sufficiently powerful to simulate another Enterprise with another fully <br>\nfunctional Holo Deck inside -- potentially ad infinitum.  In the end it is <br>\na matter of practical concern which level to take as primary one, which as <br>\nsecondary, and stop the nesting at some point.</p>\n<blockquote>\n<p>So, is there some reason this is not possible? In particular, Isar is <br>\nexecuted in ML, so it seems rather strange to me that you cannot <br>\nreplicate it's effect in ML, for example by pasting the function calls <br>\nused by Isar into the ML.</p>\n</blockquote>\n<p>Since the Isar toplevel is more powerful than the raw ML one, the choice <br>\nof preference is clear to me.  Also you don't want your ``operating <br>\nsystem'' code (i.e. the Isar infrastructure) pasted into your application <br>\ncode.  Moreover, we have recently started to repair some defects in <br>\nversions of SML/ML, by passing through our management of ML sources within <br>\nIsar.</p>\n<p>Makarius</p>",
        "id": 294056478,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821758
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 14 Feb 2008, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>Perusing the source code, I see a function called<br>\neval_antiquotes (to be exact, I used !ML_Context.eval_antiquotes_fn)</p>\n<p>which gives results like this:</p>\n<p>val eval_antiquotes = !ML_Context.eval_antiquotes_fn ;<br>\neval_antiquotes \"val x = y ; val c = @{context} ; \\<br>\n \\ val a = b ; val cs = @{claset} ; val t = @{theory}\" ;<br>\nval eval_antiquotes = fn : string -&gt; string * string</p>\n<blockquote>\n<h1>val it =</h1>\n<p>(\"structure Isabelle =\\nstruct\\nval context = ML_Context.the_local_context<br>\n();\\nval claset = Classical.local_claset_of (ML_Context.the_local_context<br>\n());\\nval thy = ML_Context.the_context ();\\nend;\",<br>\n     \"val x = y ; val c = Isabelle.context ;  val a = b ; val cs =<br>\nIsabelle.claset ; val t = Isabelle.thy\")<br>\n: string * string</p>\n</blockquote>\n<p>Is this in fact used when the system encounters code such as</p>\n<p>ML {* val x = y ; val c = @{context} ; \\<br>\n \\ val a = b ; val cs = @{claset} ; val t = @{theory} *} ?</p>\n<p>Or to be exact, is this translated code executed when the system encounters<br>\nthe<br>\nML {* ... *} ?</p>\n</blockquote>\n<p>Yes, here you see the compile time Isar context closure wrapped around ML <br>\ntext issued to the underlying platform.  Our previously mentioned paper <br>\nabout SML-antiquotations is explains this in a more abstract fashion.</p>\n<blockquote>\n<p>If so, how does it work that in this case calls such as <br>\nML_Context.the_context () are safe to use ? (in general when are they <br>\nsafe and when not ?)</p>\n</blockquote>\n<p>Here it is safe, because it runs in a critical section -- just for compile <br>\ntime.  Later at run-time, where the actual work happens, eveything is <br>\npurely functional and enables proper paralellism without further worries.</p>\n<blockquote>\n<p>In terms of threads in general: When you're sitting at the terminal <br>\ntyping input into Isar, it gets executed in the context of a particular <br>\ntheory, doesn't it ?  Obviously it manages to avoid any ambiguity (ie, <br>\nit doesn't execute it in the context of some other theory which is <br>\ncurrently developing in a different thread. How does it identify which <br>\nis the relevant theory ?</p>\n</blockquote>\n<p>It is determined from the context :-)</p>\n<p>Pointing your finger at a particular position in Isar source text, you <br>\ndetermine a certain context once and for all.  Any embedded ML code at <br>\nthat point will keep this as a first-class value (of type Proof.context) <br>\nfor later use at run-time; provided proper antiquotations are used.  So <br>\nthis is just the well-known static closure principle applied to <br>\nIsabelle/Isar + embedded ML.</p>\n<p>In contrast, low-level access to global references buys you dynamic <br>\nscoping in the best case, and erratic non-determinism in the worst case. <br>\nThis is why thm\"foo\", thms\"foo\", the_context() are all bad.</p>\n<p>Makarius</p>",
        "id": 294056498,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821764
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n^^^^^^</p>\n<p>This should read SML/NJ (we've managed to replace 5 integer types by just <br>\none true version).</p>\n<p>Makarius</p>",
        "id": 294056513,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821771
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nMakarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>If so, how does it work that in this case calls such as <br>\nML_Context.the_context () are safe to use ? (in general when are they <br>\nsafe and when not ?)<br>\n</p>\n</blockquote>\n<p>Here it is safe, because it runs in a critical section -- just for compile <br>\ntime.  Later at run-time, where the actual work happens, eveything is <br>\npurely functional and enables proper paralellism without further worries.</p>\n<p>Makarius,</p>\n</blockquote>\n<p>How do these critical sections work?  Is it to do with the function <br>\nCRITICAL which appears in the source code?</p>\n<blockquote>\n<blockquote>\n<p>In terms of threads in general: When you're sitting at the terminal <br>\ntyping input into Isar, it gets executed in the context of a particular <br>\ntheory, doesn't it ?  Obviously it manages to avoid any ambiguity (ie, <br>\nit doesn't execute it in the context of some other theory which is <br>\ncurrently developing in a different thread. How does it identify which <br>\nis the relevant theory ?<br>\n</p>\n</blockquote>\n<p>It is determined from the context :-)</p>\n<p>The question relates to what the system does.  That is to say, when I am <br>\nsitting at the terminal and type in ML {* val a = @{context} *} what is <br>\nthe ML code which the system evaluates ?  I want to know what ML code I <br>\nwould put there which would achieve exactly the same effect.<br>\nPointing your finger at a particular position in Isar source text, you <br>\ndetermine a certain context once and for all.  Any embedded ML code at <br>\nthat point will keep this as a first-class value (of type Proof.context) <br>\nfor later use at run-time; provided proper antiquotations are used.  So <br>\nthis is just the well-known static closure principle applied to <br>\nIsabelle/Isar + embedded ML.<br>\n</p>\n</blockquote>\n<blockquote>\n<p>In contrast, low-level access to global references buys you dynamic <br>\nscoping in the best case, and erratic non-determinism in the worst case. <br>\nThis is why thm\"foo\", thms\"foo\", the_context() are all bad.</p>\n<p>So what functions, _in ML_, are good, for these purposes? </p>\n</blockquote>\n<p>Jeremy</p>\n<blockquote>\n<p>Makarius</p>\n</blockquote>",
        "id": 294056565,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821800
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nMakarius wrote:</p>\n<blockquote>\n<blockquote>\n<p>So, is there some reason this is not possible? In particular, Isar is <br>\nexecuted in ML, so it seems rather strange to me that you cannot <br>\nreplicate it's effect in ML, for example by pasting the function calls <br>\nused by Isar into the ML.<br>\n</p>\n</blockquote>\n<p>Since the Isar toplevel is more powerful than the raw ML one, <br>\nI don't get this.  Is it in fact true that Isabelle (including Isar) is <br>\n(entirely) written in ML?<br>\nIf so, how can you do things in Isar that can't be done in ML?</p>\n</blockquote>\n<p>Jeremy</p>\n<blockquote>\n<p>Makarius</p>\n</blockquote>",
        "id": 294056579,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821806
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 15 Feb 2008, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>How do these critical sections work?  Is it to do with the function <br>\nCRITICAL which appears in the source code?</p>\n</blockquote>\n<p>See appendix A.2 of the fragmentary Isabelle/Isar implementation manual. <br>\nIt explains the programming model for multithreaded Isabelle; the short <br>\nand simple message is: do it purely functionally and in accord with the <br>\nofficial concepts of context (as a plain value).</p>\n<p>In rare situations, user code may also have to synchronize things <br>\nexplicitly, but well-behaved programs should only do this for tiny amounts <br>\nof time, i.e. refrain from any real computations / proof search inside a <br>\ncritical section.</p>\n<blockquote>\n<p>The question relates to what the system does.  That is to say, when I am <br>\nsitting at the terminal and type in ML {* val a = @{context} *} what is <br>\nthe ML code which the system evaluates ?  I want to know what ML code I <br>\nwould put there which would achieve exactly the same effect.</p>\n</blockquote>\n<p>You can look at the Isar implementation to find out the details, just for <br>\ncuriosity.  It is of course out of question to attempt to interfere with <br>\nthe existing infrastructure in user ML code.</p>\n<blockquote>\n<blockquote>\n<p>In contrast, low-level access to global references buys you dynamic <br>\nscoping in the best case, and erratic non-determinism in the worst <br>\ncase. This is why thm\"foo\", thms\"foo\", the_context() are all bad.</p>\n<p>So what functions, _in ML_, are good, for these purposes? </p>\n</blockquote>\n</blockquote>\n<p>Basically none.  You can refer to the compile time context using <br>\n@{context}, or get a runtime context as explicit functional argument from <br>\nsomewhere else.  For example, a proof method is essentially a function <br>\nProof.context -&gt; args -&gt; tactic, and your implementation will be something <br>\nlike (fn ctxt =&gt; fn args =&gt; ...), so you get the context ``by induction <br>\nhypothesis'' over the structure of your program.</p>\n<p>Concerning theorem lookup, ProofContext.get_thm: Proof.context -&gt; thmref<br>\n-&gt; thm enables to retrieve named facts from a given context, but it is<br>\nrarely useful within abstract code, because the name spacing rules behind <br>\nthis are quite delicate.  Better refer to proper theorem <em>values</em> <br>\ndirectly, either via @{thm ...} at compile time, or by using well-typed <br>\ninterfaces to derived context data, such as DatatypePackage.the_datatype <br>\nor similar operations of whatever tool you build yourself.</p>\n<p>The general idea of strongly-typed context data is explained in section <br>\n1.1 in the Isabelle/Isar implementation manual.</p>\n<p>Makarius</p>",
        "id": 294056610,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821819
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nMakarius et al,</p>\n<p>At present I have a function modify_ss (of type  : <br>\nMetaSimplifier.simpset -&gt; MetaSimplifier.simpset).</p>\n<p>It is used in a further function</p>\n<p>fun modified_ss () = modify_ss (simpset ()) ;</p>\n<p>Now I observe that</p>\n<p>val simpset = simpset_of o ML_Context.the_context;</p>\n<p>and given the previous remarks about using the_context () I assume that <br>\nyou wouldn't approve of using simpset (), either.  Is that correct?</p>\n<p>But if I understand the previous emails correctly, to write<br>\nfun modified_ss () = modify_ss (simpset_of @{theory}) ;<br>\nwould have the effect that the simpset used was invariably one <br>\nparticular simpset, namely that relevant when the text \"@{theory}\" was <br>\ninterpreted.</p>\n<p>But I want modified_ss () to take the simpset relevant at the time it is <br>\ncalled, and modify it.</p>\n<p>How do I define modified_ss in the approved way - using antiquotations <br>\nas and where appropriate ?</p>\n<p>Jeremy</p>",
        "id": 294056751,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821868
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 21 Feb 2008, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>At present I have a function modify_ss (of type  : MetaSimplifier.simpset -&gt;<br>\nMetaSimplifier.simpset).</p>\n<p>It is used in a further function</p>\n<p>fun modified_ss () = modify_ss (simpset ()) ;</p>\n<p>Now I observe that</p>\n<p>val simpset = simpset_of o ML_Context.the_context;</p>\n<p>and given the previous remarks about using the_context () I assume that you<br>\nwouldn't approve of using simpset (), either.  Is that correct?</p>\n</blockquote>\n<p>Yes, the simpset() form is indeed a legacy feature.  If it occurs in <br>\none-shot scripts, it can usually be replaced by the static version <br>\n@{simpset}; the same for @{claset} or @{clasimpset}.</p>\n<p>Your application sounds more like requiring a run-time context, though. So <br>\nassuming you have a proper value (ctxt: Proof.context) already, you may <br>\nget the simpset component like this:</p>\n<p>local_simpset_of ctxt</p>\n<p>and then add your stuff to the result.</p>\n<blockquote>\n<p>How do I define modified_ss in the approved way - using antiquotations <br>\nas and where appropriate ?</p>\n</blockquote>\n<p>Most likely, no antiquotations will get involved here, because you are <br>\nworking only with a runtime context.  You still need to get hold of that, <br>\ni.e. ``by induction over the structure of your code'' as explained <br>\nearlier.</p>\n<p>Makarius</p>",
        "id": 294056809,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821893
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nDear Jeremy,</p>\n<p>That depends on the application.</p>\n<p>You use \"setup\", when you want to apply the function to the current <br>\ntheory at that point in the source. This can be used e.g. to</p>\n<p>- install new commands, methods and attributes</p>\n<p>- Do something else (definitions, proofs or anything) at a<br>\n    specific point.</p>\n<p>On the other hand, if you are adding something like a method (=Isar <br>\nversion of a tactic), then you are usually given a theory (or a <br>\nProof.context) by the framework.</p>\n<p>Can you describe your application (i.e. what does \"addsm\" do and how <br>\nshould it be used on a theory), then I can be more concrete.</p>\n<p>Alex</p>",
        "id": 294056856,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821911
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nAlexander Krauss wrote:<br>\nDear Alexander,</p>\n<p>thanks - OK, now I've got a function of a type which hopefully doesn't <br>\nuse any impure features:</p>\n<h1>val addsm = fn : Context.theory -&gt; Context.theory</h1>\n<p>Now, what do I do with it? </p>\n<p>(Your email showed an example using setup {* ... : theory -&gt; theory *},<br>\n but I have this function, and want to use it, inside an ML file which <br>\nis to be \"used\" by a theory)</p>\n<p>regards,</p>\n<p>Jeremy Dawson</p>",
        "id": 294056868,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821917
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nMakarius wrote:</p>\n<blockquote>\n<p>Having studied the recent threads on the \"effect of use_thy\", <br>\n\"antiquotations\" etc. here is a summary in my own words, together with <br>\nsome additional hints on how to avoid problems with old ways of doing <br>\nthings, and moving on towards more powerful concepts.</p>\n<p>* The raw interactive ML toplevel is mostly obsolete.  After many years <br>\n    of the two toplevels side-by-side, we have finally passed the turning <br>\n    point where everything is Isar, and ML is smoothly integrated into <br>\n    that.  Proper context-dependent antiquotations are just one benefit <br>\n    from this principle, and typing additional ML {* *} should be a small <br>\n    price to pay in current Proof General (adding a key binding to produce <br>\n    that wrapping should be trivial anyway).</p>\n<p>Unfortunately the integration isn't \"smooth\".  In fact I'm working on a <br>\nproject now where it is demanded that everything is in Isar, so I have <br>\nto try to work in this way.  And it is incredibly frustrating, because <br>\nthings seem to sometimes work, and sometimes not, with no apparent <br>\nreason, seemingly randomly.</p>\n</blockquote>\n<p>Mostly my problems are something do to with theories.  I don't know if <br>\nthe problems I've faced today are because of theories or not, but I <br>\nthink it is quite likely.  But I waste an enormous amount of time trying <br>\nto cope with things that don't work as expected.  What is a simple job <br>\nwhen I'm doing proofs using \"the raw interactive ML toplevel\" becomes <br>\nslow and frustrating when I try to use Isar as much as possible, while <br>\nusing ML for the things not available in Isar.</p>\n<p>The latest example is contained in the attached theory file.<br>\nFor some reason the ML expression bool_axioms RL [fun_cong] produces an <br>\nempty list of results when it appears in the theory file being loaded.</p>\n<p>After the theory file is modified in the way shown (ie not using <br>\nbool_axioms RL [fun_cong]) it loads OK.  Then, after that, the <br>\nexpression bool_axioms RL [fun_cong]<br>\nreturns exactly the results expected.  Why does the same ML expression <br>\nbehave differently at different points ?</p>\n<p>Why is this?  I suspect it is to do with theories, and noted that<br>\ntheory_of_thm (hd bool_axioms); produces a different result inside the <br>\nIsar file<br>\nfrom the result it gives afterwards.  Why is this?</p>\n<p>I waste an enormous amount of time trying to cope with things that don't <br>\nwork as expected.  When a proof works fine at the terminal, but doesn't <br>\nwork when you put it into a theory file and load that theory file, <br>\ndebugging the situation is very difficult. (This is quite apart from the <br>\nfact that debugging Isar is naturally more difficult than debugging ML, <br>\nbecause when you load an ML proof file that fails, the theorems proved <br>\nprior to the failure are there for you to use).</p>\n<p>Something that is a simple job when I'm doing proofs solely in ML <br>\nbecomes slow and frustrating when I try to use Isar as much as possible <br>\n(and ML for the things not available in Isar.)  Often it seems to be <br>\nsomething to do with theories.  And although I've been using Isabelle <br>\nfor over 10 years now, it seems that these difficulties have only arisen <br>\nin the last few years, and mostly to do with trying to use Isar.  In <br>\nshort, using Isar is so much more difficult than using pure ML for <br>\nproofs. (Of course, learning two languages instead of one is no doubt <br>\npart of the reason also).</p>\n<blockquote>\n<p>* ML functions that refer to the old-style (dynamic) context, such as <br>\n    \"the_context\" and \"thm\" are very hard to understand exactly and should <br>\n    be replaced more and more by proper antiquotations (which are <br>\n    statically scoped at compile-time).</p>\n<p>If I understand correctly the_context () returns the current theory as <br>\nat the point where it is executed.  Is that correct?  If so, it doesn't <br>\nseem so hard to understand.  But - again I may be wrong here - the <br>\ndifficulty in using Isar seems to be that the current theory keeps on <br>\nchanging, much more than with typical .ML proof files.<br>\nSo far as I understood the previous emails,<br>\nML {* XXX the_context  () <em>} and ML {</em> XXX@{theory} *} would only return <br>\na different result if the code represented by XXX actually changed the <br>\ncurrent theory.  Is that correct?</p>\n</blockquote>\n<p>Anyway, attached is the theory file that has taken so much of my time.<br>\nIf the experts could tell me why bffcs0 is different from bffcs1-3, I'd <br>\nbe grateful.</p>\n<p>Regards,</p>\n<p>Jeremy Dawson</p>",
        "id": 294057220,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822083
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nJeremy Dawson wrote:<br>\nAfter spending so long composing an email, I forgot to attach the file, <br>\nhere it is.</p>\n<p>Thanks,</p>\n<p>Jeremy<br>\n<a href=\"/user_uploads/14278/GSJPSTmy_0AxCA8nf3TBD0ct/BI.thy\">BI.thy</a></p>",
        "id": 294057376,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822156
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nMakarius wrote:</p>\n<p>In relation to advocating the use of antiquotations, you said:<br>\n(this was in relation to advocating the use of antiquotations)</p>\n<p>But now I find that using @{theory} instead of the_context () produces <br>\nan error</p>\n<p>Exception-<br>\n   ERROR<br>\n      \"Stale theory encountered:\\n{ProtoPure, Pur (etc)</p>\n<p>When I change this back to the_context () the error goes away.</p>\n<p>What is a stale theory, and why does @{theory} produce a stale theory?</p>\n<p>Jeremy Dawson</p>",
        "id": 294057640,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822263
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAs explained in the Isar Implementation Manual, theory acts like a linear <br>\ntype.  The \"Stale theory\" error indicates that it has been used in <br>\nnon-linerar fashion.</p>\n<p>Note that @{theory} is rarely used in production code, only in one-liner <br>\ntests within a toplevel ML command etc.  If you really need to keep a live <br>\nreference to a (potentially evolving) theory, then use @{theory_ref}.</p>\n<p>Normally one would just pass through a Proof.context, instead of <br>\nmanipulating with low-level theory certificates.</p>\n<p>Makarius</p>",
        "id": 294057673,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822273
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe canonical documentation for Isabelle/ML is the \"implementation\"<br>\nmanual. You can look at the index for Isar.goal or use Isabelle/jEdit to<br>\nmake a hypersearch for it on all documentation sources:<br>\n$ISABELLE_HOME/src/Doc -- the latter gives a \"live\" view on that<br>\ndocument (including example snippets) in the Prover IDE.</p>\n<p>Anyway, I suspect that Jeremy wants to recreate the look-and-feel of<br>\ndifferent system called \"Isabelle98\" from 20 years ago. For that, the<br>\nproof method called \"tactic\" might help: it is documented in the<br>\n\"isar-ref\" manual, section \"7.3: Tactics -- improper proof methods\".<br>\nThis already indicates that we are looking at fringe topics of Isabelle2017.</p>\n<p>Makarius</p>",
        "id": 294733592,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661188970
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:Jeremy.Dawson@anu.edu.au\">Jeremy.Dawson@anu.edu.au</a>&gt;<br>\nHi Makarius,</p>\n<p>Thanks - what I really meant when I asked about documentation was, how <br>\ndo I find out how to get the goal as an ML value when I don't already <br>\nknow the answer to that question.  I agree that if I know the answer <br>\nthen it's easy to find it in the canonical documentation.</p>\n<p>In fact the preceding section in the Implementation manual is about the <br>\nProof structure, which also looks as though it contains useful stuff, <br>\nexcept that one needs to get hold of the current proof state.  How do <br>\nyou get the current proof state as an ML value?</p>\n<p>Thanks for the pointer about apply tactic ..., yes it's possible to <br>\nwrite a tactic which does nothing but print out the goal, and can use <br>\nthe goal as an ML value within the tactic, but when I tried to define a <br>\nreference value in which to save the goal value I found I couldn't.  Has <br>\nthe version of ML available to Isar users been jinxed, or something, so <br>\nthat reference variables don't work?</p>\n<p>For your information, I don't want to recreate the look-and-feel of<br>\n(what you now, I think correctly, admit is a) different system called <br>\n\"Isabelle98\".  I just want to get stuff done.  The sort of stuff (like <br>\nfinding out how to get hold of the current goal) that takes no time at <br>\nall in HOL4 or Isabelle2005 (which is actually what I use when I'm <br>\nbuilding on previous work) and takes hours in your Isabelle 2017</p>\n<p>Incidentally, on the subject of documentation - what about the Isabelle <br>\ncookbook - why isn't it included as part of the Isabelle documentation <br>\n(and kept up to date)?</p>\n<p>Cheers,</p>\n<p>Jeremy</p>",
        "id": 294733924,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189101
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 05/06/18 04:12, Jeremy Dawson wrote:</p>\n<blockquote>\n<p>In fact the preceding section in the Implementation manual is about the<br>\nProof structure, which also looks as though it contains useful stuff,<br>\nexcept that one needs to get hold of the current proof state.  How do<br>\nyou get the current proof state as an ML value?</p>\n</blockquote>\n<p>E.g. like this:</p>\n<p>lemma \"x = x\"<br>\n  ML_val ‹@{Isar.goal}›<br>\n  ML_val ‹Toplevel.proof_of @{Isar.state}›</p>\n<p>This has little practical relevance though. We are merely toying around<br>\nwith details of the implementation here.</p>\n<blockquote>\n<p>Thanks for the pointer about apply tactic ..., yes it's possible to<br>\nwrite a tactic which does nothing but print out the goal, and can use<br>\nthe goal as an ML value within the tactic, but when I tried to define a<br>\nreference value in which to save the goal value I found I couldn't.  Has<br>\nthe version of ML available to Isar users been jinxed, or something, so<br>\nthat reference variables don't work?</p>\n</blockquote>\n<p>Isabelle/ML is a very clean parallel programming environment, as<br>\nexplained in chapter 0 of the \"implementation\" manual. Section 0.7.9 is<br>\nabout Usynchronitzed.ref and Section 0.8 about \"Thread-safe programming\".</p>\n<blockquote>\n<p>For your information, I don't want to recreate the look-and-feel of<br>\n(what you now, I think correctly, admit is a) different system called<br>\n\"Isabelle98\".  I just want to get stuff done.  The sort of stuff (like<br>\nfinding out how to get hold of the current goal) that takes no time at<br>\nall in HOL4 or Isabelle2005 (which is actually what I use when I'm<br>\nbuilding on previous work) and takes hours in your Isabelle 2017</p>\n</blockquote>\n<p>In Isabelle you have the goal right there in the source, and the Prover<br>\nIDE manages proof documents that apply to it. Anything beyond that is<br>\nfor tool developers, and even that is quite easy if you think about the<br>\nsystem in the proper way, and look a bit through the documentation.</p>\n<p>Note that \"to get stuff done\" (doing proofs) usually requires no<br>\nIsabelle/ML at all.</p>\n<p>Makarius</p>",
        "id": 294734107,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189172
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:Jeremy.Dawson@anu.edu.au\">Jeremy.Dawson@anu.edu.au</a>&gt;<br>\nHi Makarius,</p>\n<p>not clear what you mean by this - sure, the goal has been entered in <br>\ntextual form by the user, and obviously the system turns this into the <br>\nML value - but I can't see how the ML value is \"there in the source\".</p>\n<p>What do you mean by this?</p>\n<p>Cheers,</p>\n<p>Jeremy</p>",
        "id": 294734680,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189373
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe true proof state is the partial proof text that you edit in the<br>\nProver IDE: as Isar source.</p>\n<p>You don't need the ML value to do the proof, it is part of the<br>\nimplementation.</p>\n<p>It might be fun to explore the implementation, but it can also take some<br>\nyears to get to the bottom of it.</p>\n<p>Makarius</p>",
        "id": 294734898,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189440
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:Jeremy.Dawson@anu.edu.au\">Jeremy.Dawson@anu.edu.au</a>&gt;<br>\nHi</p>\n<p>I don't seem to be able to use the goals or subgoals antiquotations <br>\ncorrectly</p>\n<p>lemma example: \"a = b --&gt; b = a\"<br>\nML_prf {* @{thm refl} *}</p>\n<p>ML_prf {* @{goals} <em>} (</em> fails *)<br>\nML_prf {* @{subgoals} <em>} (</em> fails *)<br>\nML_prf {* @{context} <em>} (</em> OK *)<br>\nML_prf {* @{theory} <em>} (</em> OK *)</p>\n<p>what am I doing wrong here?</p>\n<p>Thanks</p>\n<p>Jeremy</p>",
        "id": 294735447,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189635
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Jeremy,</p>\n<blockquote>\n<p>I don't seem to be able to use the goals or subgoals antiquotations<br>\ncorrectly</p>\n</blockquote>\n<p>as far as I understand, those are \"document antiquotations\", i.e. they<br>\nmay only appear in document text, but not in ML:</p>\n<p>text ‹@{goals}›</p>\n<p>If you want to take a look at the proof state from within the IDE, you<br>\nhave two choices:</p>\n<p>1) open the \"State\" panel<br>\n2) open the \"Output\" panel and check the \"Proof state\" box</p>\n<blockquote>\n<p>lemma example: \"a = b --&gt; b = a\"<br>\nML_prf {* @{thm refl} *}</p>\n</blockquote>\n<p>Note that this can be shorter expressed as \"thm refl\" directly. No need<br>\nto wrap that into ML.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294735683,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189703
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>you can use</p>\n<p>lemma example: \"a = b --&gt; b = a\"<br>\n  ML_val {* @{Isar.goal} *}</p>\n<p>to get the current goal. Note though, that this does not work with ML_prf.</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294735880,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189770
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:Jeremy.Dawson@anu.edu.au\">Jeremy.Dawson@anu.edu.au</a>&gt;<br>\nHi Dominique,</p>\n<p>Thanks - that's most helpful.  Do you know if this is documented anywhere?</p>\n<p>Cheers,</p>\n<p>Jeremy</p>",
        "id": 294736266,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189906
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nI don't know if it's documented. I found it via autocompletion in<br>\nIsabelle/jEdit. But it took some experimenting to figure out that it works<br>\nwith ML_val. (Because otherwise it just thrown UNDEF).</p>\n<p>Best wishes,<br>\nDominique.</p>",
        "id": 294736459,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661189973
    }
]