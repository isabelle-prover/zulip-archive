[
    {
        "content": "<p>From: Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt;<br>\nIsabelle is running for 30+ seconds when I try to apply (rule exI) in<br>\nthe middle of my structured proof, eating memory at about 20 MB/sec. I<br>\nran out of memory after that point. At first I thought it was<br>\nunification exploding but then I got rid of my function schematic<br>\nvariable. Could this be a bug? (I'm running from rev<br>\n29862:17d1e32ef867, BTW. I can try updating if needed.)</p>\n<p>The below theory ought to reproduce this.</p>\n<p>Chris Capel</p>\n<p>theory Lojban<br>\nimports Main<br>\nbegin</p>\n<p>datatype token =<br>\n    Start nat -- {* nat is phrase id *}<br>\n  | Trm nat bool -- {* phrase id, is elided *}</p>\n<p>-- {* Allowable phrase to phrase relations *}<br>\nconsts<br>\n  mapPhPh :: \"nat =&gt; nat set\"<br>\n  mapMem :: \"nat =&gt; nat =&gt; bool\" (infix \":*\" 50)<br>\n  mapNotMem :: \"nat =&gt; nat =&gt; bool\" (infix \"~:*\" 50)<br>\ntranslations<br>\n  \"a :* b\" == \"a : mapPhPh b\"<br>\n  \"a ~:* b\" == \"a ~: mapPhPh b\"</p>\n<p>-- {* ({({ } _) _} ) *}</p>\n<p>fun canAppend1 :: \"token list =&gt; nat =&gt; bool\" where<br>\n  \"canAppend1 ((Trm pid el)#xs) p = (~el | p ~:* pid &amp; canAppend1 xs p)\" |<br>\n  \"canAppend1 ((Start _ )#xs) p = True\"<br>\nfun canAppend :: \"token list =&gt; nat =&gt; nat =&gt; bool\" where<br>\n  \"canAppend xs p outID  = (p :* outID &amp; canAppend1 (rev xs) p)\"</p>\n<p>primrec insert_list :: \"'a list =&gt; nat =&gt; 'a list =&gt; 'a list\" where<br>\n  \"insert_list list 0 outer = list @ outer\" |<br>\n  \"insert_list list (Suc n) os = (hd os) # (insert_list list n (tl os))\"</p>\n<p>fun rmTrm where<br>\n  \"rmTrm lst = filter (% y. case y of Trm _ _ =&gt; False | _ =&gt; True) lst\"</p>\n<p>inductive_set P :: \"token list set\" where<br>\n  base:   \"[Start tid, Trm tid el] : P\" |<br>\n  beside: \"[| base : P; take 2 (drop pos base) = [Trm aID el1, Trm oID el2];<br>\n              canAppend ((take pos base) @ [Trm aID el1]) newID oID |]<br>\n           ==&gt; insert_list [Start newID, Trm newID elided]<br>\n                           (Suc pos) base<br>\n                 : P\" |</p>\n<p>inside: \"[| base : P; 0 &lt; pos;<br>\n              take 2 (drop (pos - 1) base) = [Start oldID, Trm oldID oldEl];<br>\n          rmTrm (drop pos base) = [];<br>\n              newID :* oldID |]<br>\n           ==&gt; insert_list [Start newID, Trm newID elided] pos base : P\"</p>\n<p>datatype 'tok prod =<br>\n    PTrm 'tok<br>\n  | Prod \"nat list list\"</p>\n<p>primrec powerlist :: \"'a list =&gt; 'a list list\" where<br>\n  \"powerlist [] = []\" |<br>\n  \"powerlist (x # xs) = (x # xs) # powerlist xs\"</p>\n<p>function<br>\n    parse_len :: \"'tok prod list =&gt; 'tok prod =&gt; 'tok list =&gt; int\" where</p>\n<p>\"parse_len gr (PTrm tok) toks = (if ((hd toks) = tok) then 1 else -1)\"<br>\n | \"parse_len gr (Prod pl) toks =<br>\n      last (sort (map (%p. foldl (% (len::int) (p, l).<br>\n                                    if len = -1 then -1<br>\n                                    else len + parse_len gr (gr!p) l)<br>\n                                 0 (zip p (powerlist toks)))<br>\n                  pl))\"</p>\n<p>by pat_completeness auto</p>\n<p>fun getPhMap :: \"(nat * nat) list =&gt; nat =&gt; nat set\" where<br>\n  \"getPhMap ls x = set (map snd (filter (%y. (fst y) = x) ls))\"</p>\n<p>fun rm_elided :: \"token list =&gt; token list\" where<br>\n  \"rm_elided st = filter (%s. case s of Start _ =&gt; True | Trm _ el =&gt; ~el) st\"</p>\n<p>lemma assumes \"st : P\" and \"mapt ~= []\" and \"mapPhPh = getPhMap mapt\"<br>\n  shows \"EX gr X Y. parse_len_dom (gr, gr!0, (rm_elided st)) --&gt;<br>\n             (nat (parse_len gr (gr!0) (rm_elided st)) = length (rm_elided st))<br>\n             &amp; size gr &lt; X * length (rm_elided st) * length mapt</p>\n<p>+ Y * length (rm_elided st)\"<br>\n  (is \"EX gr. ?LinGr gr\")<br>\nusing assms(1) proof (induct st rule: P.induct)<br>\n  fix gr tid el<br>\n  have \"?LinGr [Prod [[1, 2]], PTrm (Start tid), PTrm (Trm tid el)]\"<br>\n    sorry<br>\n  -- {* hence \"EX gr. ?LinGr gr\" ..*}<br>\n  thus \"EX gr X Y.<br>\n       parse_len_dom (gr, gr ! 0, rm_elided [Start tid, Trm tid el]) --&gt;<br>\n       nat (parse_len gr (gr ! 0) (rm_elided [Start tid, Trm tid el])) =<br>\n       length (rm_elided [Start tid, Trm tid el]) &amp;<br>\n       length gr<br>\n       &lt; X * length (rm_elided [Start tid, Trm tid el]) * length mapt +<br>\n         Y * length (rm_elided [Start tid, Trm tid el])\" apply (rule exI)<br>\nqed</p>",
        "id": 294072899,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827806
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThe inclusion of the previous result (by your use of \"thus\" rather  <br>\nthan \"show\") seems to be part of the problem, though I am not sure why.</p>\n<p>Another part of your problem is that the previous result does not  <br>\nappear to match up with the new result that you want to prove. Higher- <br>\norder unification can get out of control quite quickly when you have a  <br>\nbig search space but no solutions.</p>\n<p>I was able to make some progress with the following fragment:</p>\n<p>have l: \"?LinGr [Prod [[1, 2]], PTrm (Start tid), PTrm (Trm tid el)]\"<br>\n    sorry<br>\n  -- {* hence \"EX gr. ?LinGr gr\" ..*}<br>\nhave \"EX gr X Y.<br>\n       parse_len_dom (gr, gr ! 0, rm_elided st) --&gt;<br>\n       nat (parse_len gr (gr ! 0) (rm_elided st)) =<br>\n       length (rm_elided st) &amp;<br>\n       length gr<br>\n       &lt; X * length (rm_elided st) * length mapt +<br>\n         Y * length (rm_elided st)\"<br>\nby (rule exI, rule l)</p>\n<p>The previous result is now labelled l. We no longer include it in the  <br>\nnext proof (no \"from\"). I have corrected the statement to be proved so  <br>\nthat it matches. Now the proof is instantaneous. Alternatively, you  <br>\ncan include the previous result and prove the next one using blast  <br>\nwith no arguments.</p>\n<p>So the problem appears to be the interaction between the rule method  <br>\nand piped in facts.</p>\n<p>Larry Paulson</p>",
        "id": 294072928,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827818
    }
]