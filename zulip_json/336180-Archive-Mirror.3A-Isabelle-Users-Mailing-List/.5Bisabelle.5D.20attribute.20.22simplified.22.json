[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear all,</p>\n<p>This is just an observation about the \"simplified\" attribute. Maybe it <br>\nis well-known and its just me who wasn't aware of it.</p>\n<p>Suppose I have a lemma like</p>\n<p>consts foo :: \"'a list ⇒ 'b list ⇒ 'a list list\"</p>\n<p>lemma foo:<br>\n     \"i &lt; length ys ==&gt;<br>\n       foo xs ys ! i = take (ys ! i) (drop (listsum (take i ys)) xs)\"<br>\n   sorry</p>\n<p>and now I want a special version for when \"ys\" is actually \"map size <br>\nys\". So I do</p>\n<p>thm foo [of _ \"map size ys\" for ys, simplified]</p>\n<p>Now in the result the assumption \"?i &lt; length (map size ?ys2)\" is <br>\nsimplified to \"?i &lt; length ?ys2\". However, \"map size ?ys2 ! ?i\" is <em>not</em> <br>\nsimplified to \"size (?ys2 ! i)\" (which I expected in presence of \"?i &lt; <br>\nlength ?ys2\").</p>\n<p>Conclusion: The simplifier treats schematic variables in conditions <br>\ndifferently than free variables (which is no surprise). Is there a way <br>\nto obtain the result I expected without having to restate the whole lemma?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294324934,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928249
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHello Christian.</p>\n<p>You were half-correct about what was going on here. Both type-schematics<br>\nand term-schematics obstruct the simplifier. After a lot of fiddling I<br>\ndiscovered that you get the lemma you want like this:</p>\n<p>lemmas foo4 = foo [of i \"map size ys\", simplified] for i and ys :: \"('b<br>\n:: size) list\"</p>\n<p>OK, a little on how I got there. Turning on simplifier tracing causes<br>\nthe simplifier to trace this issue with the previous simplification attempt:</p>\n<p>\"[1]Cannot add premise as rewrite rule because it contains (type) unknowns:\"</p>\n<p>(I used \"declare [[simp_trace = true]]\" but I think there might also be<br>\na more modern way.)</p>\n<p>OK, so the simplifier can't assume something that contains either a<br>\nterm-unknown or a type-unknown. Turning on \"[[show_types = true]]\" also<br>\nhelps here.</p>\n<p>To start with, we instantiate all the term variables. I'm also using the<br>\n\"for\" form of \"lemmas\" rather than within the attribute, because this<br>\nleaves the variables fixed for the execution of the subsequent attributes.</p>\n<p>lemmas foo2 = foo [of i \"map size ys\" xs, simplified] for i ys xs</p>\n<p>OK, the simplifier still complains about the type-unknown that was<br>\nintroduced by typing \"map size ys\". This wouldn't happen, if, for<br>\ninstance, we used \"Suc\" instead of \"size\":</p>\n<p>lemmas foo3 = foo [of i \"map Suc ys\" xs, simplified] for i ys xs</p>\n<p>The simplification happens on foo3. This gave me hope, but for a while I<br>\ncouldn't figure out how to get the right lemma other than opening and<br>\nclosing a context to fix ys to an appropriate type. Finally I realised<br>\nthat the analogous syntax works with lemmas, giving me the form I<br>\nmentioned first.</p>\n<p>OK, hope that helps. Good luck,<br>\n     Thomas.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294325405,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928389
    }
]