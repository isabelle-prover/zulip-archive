[
    {
        "content": "<p>From: Gergely Buday &lt;<a href=\"mailto:gbuday@gmail.com\">gbuday@gmail.com</a>&gt;<br>\nHi,</p>\n<p>sledgehammer returns a number of lemmas that can be fed to metis to verify<br>\na lemma.</p>\n<p>auto is sometimes better finding the proof, but it does not return any<br>\ninformation on the lemmas used. Has anybody been thinking on the idea of<br>\nextending auto's implementation to return with the list of lemmas?<br>\nPossibly, the non-trivial lemmas.</p>\n<p>This would yield more readable scripts, but there might be a reason that<br>\nthis is not done.</p>\n<ul>\n<li>Gergely</li>\n</ul>",
        "id": 294273266,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917892
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThese two tools work in very different ways. The idea behind sledgehammer is to use a lot of very powerful tools to search for proof, but not to trust the result; instead, we merely extract the list of relevant lemmas to give to a weak but trustworthy internal prover. It is true that this list is very interesting in its own right, especially when it is shorter than one might expect.</p>\n<p>Auto uses Isabelleâ€™s internal reasoners. As you have guessed, they use an enormous number of basic lemmas in order to traverse formulas, and it might be interesting to identify the less trivial ones by somehow processing the proof object. This might be a good student project.</p>\n<p>Larry Paulson</p>",
        "id": 294273308,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917906
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nOn 14-03-26 03:31, Gergely Buday wrote:</p>\n<p>(Skip past the first 4 paragraphs to get an algorithm for how to <br>\nsometimes be able to narrow down what auto is doing, and for a list of <br>\ntraces to help you do that, and get trace info about other things.)</p>\n<p>I'm all for automated tools which give me good information, so, when <br>\nneeded, I can understand the logic for a proof step, or to make explicit <br>\nin a document what lemmas are being used for a proof step.</p>\n<p>If Larry Paulson is sympathetic with a request like this, that can't be <br>\na bad thing. I'll do my part and pull strings for grant money, with my <br>\npersonal friends at Intel, Google, Microsoft, Apple, IBM and all the big <br>\nUSA defense companies, that should have lots of money after 14 years of <br>\nwar, like Raytheon which I didn't get a job with, General Dynamics, <br>\nLockheed Martin, and Hughes which I didn't get a job with.</p>\n<p>And Motorola, which lost out to Intel, but which has been on my mind <br>\nlately, because of <code>num</code>. Is a <code>num</code> big endian or little endian? The <br>\norder of the <code>num</code> binary digits is reversed, so in my mind it's big <br>\nendian, because binary digits are permanently embedded in my mind as <br>\nbeing little endian, because of thinking about binary digits in relation <br>\nto Intel microprocessors, for a long time.</p>\n<p>However, Wiki relates endianess to how you read things from left to <br>\nright, and if Num.One is considered memory location 0, then maybe <code>num</code> <br>\nis little endian, because then, the reading of a <code>num</code> number is <br>\nreversed from how it's stored in memory. I'm looking around the room <br>\nright now for someone to engage with in thoughtful, intellectual <br>\ndiscourse about the endianness of <code>num</code>. There is no one in the room but <br>\nme. That's okay. There's the little kid next door, but he just wants me <br>\nto throw him the football, the football not being a soccer ball, the <br>\nfootball being related to chronic brain injury for those who bash their <br>\nheads against 280 pound men, pound not being a form of British currency <br>\nin this context, and bitcoin not being currency in the context of the <br>\nIRS, but merely property.</p>\n<blockquote>\n<p>auto is sometimes better finding the proof, but it does not return any<br>\ninformation on the lemmas used.</p>\n</blockquote>\n<p>The traces give you info about how auto proves a lemma. If it's doing a <br>\nlot for a proof step, it's not easy to tell what it did, but then that's <br>\nbecause it did a lot. If you want to narrow down how auto proves a proof <br>\nstep, you study the trace to the extent you want to, and then apply <br>\nother automatic methods directly, such as blast and arith, and from the <br>\nsimp rules you see in the trace experiment with simp, you do things like <br>\nthe following, while looking at the output panel trace:</p>\n<p>(1) apply(simp only:) and apply(auto simp only:), where if this prevents <br>\nauto from proving the lemma, you can start adding back rules you see in <br>\nthe simp trace with <code>only</code>, or start deleting simp rules using <code>del</code> to <br>\nsee if you can find simp rules it has to have, as shown next.</p>\n<p>(2) apply(simp only: foo bar) and apply(auto simp only: foo bar).</p>\n<p>(3)  apply(simp del: foo bar) and apply(auto simp del: foo bar).</p>\n<p>(4) apply(blast), (apply arith).</p>\n<p>If</p>\n<p>(1) <code>apply(auto simp only:)</code> or <code>apply(simp only:)</code> shuts it down,</p>\n<p>(2) <code>apply(auto simp only: foo1 foo2 foo3)</code> or <code>apply(simp only: foo1 \nfoo2 foo3)</code>proves it,</p>\n<p>(3) the blast trace shows it didn't call blast,</p>\n<p>(5) the linarith_trace shows it didn't use linear arithmetic,</p>\n<p>(6) in the trace it looks like all other rewrites are trivial <br>\nsimplifications,</p>\n<p>(7) or rewrites based on <code>unknown rewrite rule</code>s that come from your <br>\nlemma assumptions,</p>\n<p>then there's some chance logically, if there aren't other traces you <br>\nneed to enable, that (2) above is the non-trivial lemma info that you're <br>\nrequesting.</p>\n<p>Here are some traces I've accumulated over several years, that I either <br>\ninsert with a macro, or have in an imported helper file. You use <br>\n<code>declare</code> to enable them globally and <code>using</code> to declare them in a <br>\nproof. For auto, I'm interested in the simp, blast, and linarith traces <br>\nbecause that's the only ones I know about that will tell what auto is doing:</p>\n<p>declare[[blast_trace=false, blast_stats=false]]<br>\ndeclare[[simp_trace=false, simp_trace_depth_limit=100]]<br>\ndeclare[[linarith_trace=false]]<br>\ndeclare[[rule_trace=false]]<br>\ndeclare[[metis_trace=false]]<br>\ndeclare[[simp_debug=false]]<br>\ndeclare[[metis_verbose = false]]<br>\ndeclare[[unify_trace_simp=false]] (*controls tracing of the <br>\nsimplification phase of higher-order unification*)<br>\ndeclare[[unify_trace_types=false]]</p>\n<p>My standard insertion for traces is this:</p>\n<p>using[[simp_trace, simp_trace_depth_limit=100, linarith_trace, rule_trace]]<br>\nusing[[blast_trace, blast_stats]]</p>\n<p>To use the blast traces, you use the following, which was most helpfully <br>\nprovided by Makarius Wenzel:</p>\n<p>attribute_setup blast_trace = {*<br>\n   Scan.lift<br>\n    (Parse.$$$ \"=\" -- Args.$$$ \"true\" &gt;&gt; K true ||<br>\n     Parse.$$$ \"=\" -- Args.$$$ \"false\" &gt;&gt; K false ||<br>\n     Scan.succeed true) &gt;&gt;<br>\n   (fn b =&gt; Thm.declaration_attribute (K (Config.put_generic Blast.trace <br>\nb)))<br>\n*}</p>\n<p>attribute_setup blast_stats = {*<br>\n   Scan.lift<br>\n    (Parse.$$$ \"=\" -- Args.$$$ \"true\" &gt;&gt; K true ||<br>\n     Parse.$$$ \"=\" -- Args.$$$ \"false\" &gt;&gt; K false ||<br>\n     Scan.succeed true) &gt;&gt;<br>\n   (fn b =&gt; Thm.declaration_attribute (K (Config.put_generic Blast.stats <br>\nb)))<br>\n*}</p>\n<blockquote>\n<p>Has anybody been thinking on the idea of extending auto's implementation to return with the list of lemmas? Possibly, the non-trivial lemmas.</p>\n</blockquote>\n<p>Personally, I wish I could always shut down <code>simp</code> and <code>auto</code> with <br>\n<code>only</code>, other than trivial rewrites being done, like symmetry and <br>\nnegation of False rewrites, which are generally obnoxious things to have <br>\nto manually take care of.</p>\n<p>But, if there would be a huge performance hit, even when the traces <br>\naren't enabled, because it would slow down doing the thousands of <br>\nlow-level things it always has do, that would be bad.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294273329,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917913
    }
]