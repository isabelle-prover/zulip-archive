[
    {
        "content": "<p>From: Johannes Waldmann &lt;<a href=\"mailto:johannes.waldmann@htwk-leipzig.de\">johannes.waldmann@htwk-leipzig.de</a>&gt;<br>\nDear all,</p>\n<p>I wonder about the feasibility of the following.<br>\nPerhaps something similar has already been done.</p>\n<p>I want to automatically check solutions for homework assignments.<br>\nThe problem statement could be a text with some \"sorry\",<br>\nand the student has to replace these with actual proofs,<br>\nand is forbidden to change anything else.</p>\n<p>I am already doing this for Haskell homework -<br>\nstudents have to replace \"undefined\",<br>\nresulting code is type-checked and then small/quick-checked.<br>\nSee URL at end of this mail for implementation.</p>\n<ol>\n<li>\n<p>what is the best way to pattern-match<br>\nstudent's Isabelle code against problem statement?<br>\nFor Haskell, I actually compare abstract syntax trees.</p>\n</li>\n<li>\n<p>how safe is it to run Isabelle? - For Haskell,<br>\nanything dangerous would be in IO, which is prohibited<br>\nby putting type annotations in the problem statement<br>\n(which the student cannot change).<br>\nAnd \"unsafePerformIO\" is prohibited because it would need<br>\nsome \"import\" statement - which again would not survive<br>\nthe pattern matching. So, the worst that can happen<br>\nis that student's code runs forever,<br>\nand for that I just limit execution time (to a few seconds).<br>\nIs there any way to sneak an IO action into a proof?</p>\n</li>\n</ol>\n<p>3.1 How would I run Isabelle? Of course I don't want the GUI.<br>\n3.2 Can I avoid putting student's submission in a file,<br>\nand pipe it instead?<br>\n3.3 How would I detect that Isabelle actually verified the proof?<br>\nIdeally, just by checking the return code?</p>\n<p>Any input appreciated.</p>\n<ul>\n<li>Johannes.</li>\n</ul>\n<p><a href=\"https://gitlab.imn.htwk-leipzig.de/autotool/all/tree/master/collection/src/Haskell/Blueprint\">https://gitlab.imn.htwk-leipzig.de/autotool/all/tree/master/collection/src/Haskell/Blueprint</a></p>\n<p>NB: I once saw an (unrelated) project<br>\nthat used \"maxima\" to check elementary algebra homework,<br>\nand this had serious security holes -<br>\nyou could easily do IO because there is no static checking.</p>",
        "id": 294678656,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175886
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Johannes,</p>\n<blockquote>\n<ol>\n<li>what is the best way to pattern-match<br>\nstudent's Isabelle code against problem statement?<br>\nFor Haskell, I actually compare abstract syntax trees.</li>\n</ol>\n</blockquote>\n<p>is there any reason you require students to exactly fill out holes? For<br>\nour Haskell course we reckoned a \"matching interface\" is good enough.</p>\n<p>In Isabelle you could get something similar by using three theories:</p>\n<p>Interface.thy – definitions would go in there<br>\nStudent.thy – lemma statements + sorry would go there, student has to<br>\nfill them<br>\nChecker.thy – contains the exact same lemma statements, but using a<br>\nproof \"by rule\".</p>\n<p>Example:</p>\n<p>Interface.thy</p>\n<p>theory Interface imports Main begin</p>\n<p>definition prime ...</p>\n<p>Student.thy</p>\n<p>theory Student imports Interface begin</p>\n<p>lemma no_biggest_prime: obtains p where \"prime p\" \"p &gt; n\"<br>\n  sorry</p>\n<p>Checker.thy</p>\n<p>theory Checker imports Interface Student begin</p>\n<p>lemma check_no_biggest_prime:<br>\n    obtains p where \"<a href=\"http://Interface.prime\">Interface.prime</a> p\" \"p &gt; n\"<br>\n  by (rule Student.no_biggest_prime)</p>\n<p>Depending on where exactly a failure occurs (you can put those into<br>\nmultiple sessions) you know where the student did something wrong.</p>\n<blockquote>\n<ol start=\"2\">\n<li>how safe is it to run Isabelle? - For Haskell,<br>\nanything dangerous would be in IO, which is prohibited<br>\nby putting type annotations in the problem statement<br>\n(which the student cannot change).<br>\nAnd \"unsafePerformIO\" is prohibited because it would need<br>\nsome \"import\" statement - which again would not survive<br>\nthe pattern matching. So, the worst that can happen<br>\nis that student's code runs forever,<br>\nand for that I just limit execution time (to a few seconds).<br>\nIs there any way to sneak an IO action into a proof?</li>\n</ol>\n</blockquote>\n<p>Isabelle allows arbitrary code execution. There is currently a \"safe\"<br>\nflag but:</p>\n<ul>\n<li>with that many legitimate things don't work</li>\n<li>it will be gone in the next release.</li>\n</ul>\n<p>I strongly recommend containerizing Isabelle for running untrusted code.<br>\n(We use unprivileged containers without network access in a VM in our<br>\nAFP submission checker.)</p>\n<p>On the plus side, setting timeouts is possible and robust.</p>\n<blockquote>\n<p>3.1 How would I run Isabelle? Of course I don't want the GUI.</p>\n</blockquote>\n<p>You have to prepare a ROOT file and put all the files into appropriate<br>\nfolders. Then you can run</p>\n<p>$ bin/isabelle build ...</p>\n<p>See also §2 in the Isabelle system manual:<br>\n&lt;<a href=\"https://isabelle.in.tum.de/dist/Isabelle2016/doc/system.pdf\">https://isabelle.in.tum.de/dist/Isabelle2016/doc/system.pdf</a>&gt;</p>\n<blockquote>\n<p>3.2 Can I avoid putting student's submission in a file,<br>\nand pipe it instead?</p>\n</blockquote>\n<p>You could, but that would involve you writing some nontrivial amount of<br>\ncustom Scala code to drive the build process. I wouldn't recommend it.</p>\n<blockquote>\n<p>3.3 How would I detect that Isabelle actually verified the proof?<br>\nIdeally, just by checking the return code?</p>\n</blockquote>\n<p>Yes, you get that for free from \"isabelle build\". Exit code 0 means<br>\nsession built successfully, other exit codes mean timeout/failure/...</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294678682,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175898
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi Johannes,</p>\n<p>also see this thread, where I asked similar questions (but without much<br>\nmore answers :-)<br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-April/msg00087.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-April/msg00087.html</a></p>\n<p>as Lars says, there is a safe mode, and we use in (in addition to<br>\ncontainerization using Docker) Karlsruhe where we automatically process<br>\nIsabelle submissions using the “Praktomat” checker. We currently do not<br>\ncheck what the students actually proved, for that we still manually<br>\ncheck their submission, but this way any sorries or other problems are<br>\ndetected.</p>\n<p>Maybe<br>\n<a href=\"https://github.com/KITPraktomatTeam/Praktomat/blob/master/src/checker/checker/IsabelleChecker.py\">https://github.com/KITPraktomatTeam/Praktomat/blob/master/src/checker/checker/IsabelleChecker.py</a><br>\nprovides some inspiration.<br>\n<a href=\"/user_uploads/14278/9GYHCCULyNLDnWETfctOobAx/signature.asc\">signature.asc</a></p>",
        "id": 294678781,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175905
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nThe point I was trying to make is: there is a \"safe\" mode, but don't<br>\never use it! :-)</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294678801,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175910
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>besides adding security (which is better handled by containerization),<br>\nthe safe mode also prevents the student from adding ML code that allows<br>\nthem to implement a bad oracle, i.e. their own \"sorry\", right? Will<br>\nthere be another way of avoiding that, once the safe mode is gone?</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/WoNpH7I6CmhUENkxbUkIJkBH/signature.asc\">signature.asc</a></p>",
        "id": 294678832,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175923
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Joachim,</p>\n<blockquote>\n<p>besides adding security (which is better handled by containerization),</p>\n</blockquote>\n<p>... a dubious amount at best. Using \"code_printing\" and \"export_code\"<br>\nyou can already write arbitrary things to the file system, e.g.<br>\n\".bashrc\" or the checker theory (if those are writeable). Also let me<br>\nreiterate that the \"secure\" mode is gone after Isabelle2016.</p>\n<blockquote>\n<p>the safe mode also prevents the student from adding ML code that allows<br>\nthem to implement a bad oracle, i.e. their own \"sorry\", right? Will<br>\nthere be another way of avoiding that, once the safe mode is gone?</p>\n</blockquote>\n<p>There are more ways to cheat than that, e.g. with \"axiomatization\" or<br>\nintroducing custom or changing existing input/output syntax. However, ML<br>\noracles can be easily detected using \"Thm.peek_status\" (the \"oracle\"<br>\nfield is set to \"true\").</p>\n<p>Given that the whole system is so complex there is no bullet-proof way<br>\nyou can reasonably assign grades without reserving the right to deduct<br>\npoints if cheating is detected by a human. (Human review of Isabelle<br>\nsources is a necessity.)</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294678868,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175947
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nThis is not reliable either. You can hide usage of an oracle in the <br>\ninstance proof when you instantiate a type class. For example, create a <br>\ntype class that assumes False and use sorry in the instance proof.</p>\n<p>Probably the most reliable way that we can amend this is to remove the <br>\naxiomatic type classes from the kernel.</p>\n<p>Bests,<br>\nOndrej</p>",
        "id": 294678873,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175953
    },
    {
        "content": "<p>From: Johannes Waldmann &lt;<a href=\"mailto:johannes.waldmann@htwk-leipzig.de\">johannes.waldmann@htwk-leipzig.de</a>&gt;<br>\nWell, you can always give a name to a \"hole\" inside an expression.<br>\nThen student has to add a top-level definition for that name.</p>\n<p>But then, being top-level (module-level)<br>\nmeans that it cannot refer to local names<br>\nfrom the scope that the hole was in,<br>\nbut sometimes that's the point of an exercise,<br>\nif it's about \"local\" programming techniques.</p>\n<p>Also, there are other kinds of holes (than expressions),<br>\nI want to use this also for patterns and types.<br>\nAgain, these could be named, but then I lose the scope information,<br>\nor have to make it explicit (by adding arguments).</p>\n<p>I imagine the same could be useful for Isabelle homework:<br>\n\"fill the gap(s) in this proof (but don't touch the non-gaps)\"<br>\nthe point being that the student has to respect the (local) structure.</p>\n<ul>\n<li>Johannes.</li>\n</ul>",
        "id": 294679258,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176094
    }
]