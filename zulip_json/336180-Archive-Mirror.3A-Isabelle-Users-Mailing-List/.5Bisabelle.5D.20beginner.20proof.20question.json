[
    {
        "content": "<p>From: Dorka Tronix &lt;<a href=\"mailto:dorkatronix@gmail.com\">dorkatronix@gmail.com</a>&gt;<br>\nHi,<br>\nI'm a beginner with proof assistants. Apologies if this is the wrong mailing<br>\nlist; I wasn't sure where to ask beginner questions.  I'm trying to learn<br>\nIsabelle with some small examples of my own.   I'm having problems with what<br>\nI thought would be a simple proof, and think I must be missing something<br>\nobvious.</p>\n<p>I have a very simple recursive data type:<br>\ndatatype \"S\" = Assert bool<br>\n | Assign bool<br>\n | Ite bool \"S list\" \"S list\" (* if then else statement *)</p>\n<p>and a simple function:</p>\n<p>fun \"fse\" :: \"S list \\&lt;Rightarrow&gt; bool \\&lt;Rightarrow&gt; bool\" where<br>\n   \"fse [] b = b\" |<br>\n    \"fse (x#xs) b = (case x of<br>\n             (Assert e) \\&lt;Rightarrow&gt; fse xs (b \\&lt;and&gt; e )<br>\n            | (Assign e) \\&lt;Rightarrow&gt; fse xs (b \\&lt;and&gt; e)<br>\n            | (Ite e s1 s2) \\&lt;Rightarrow&gt; (fse xs (fse (s1) (b \\&lt;and&gt; e)))<br>\n\\&lt;or&gt; (fse  xs (fse (s2) (b \\&lt;and&gt; (\\&lt;not&gt; e)))))\"</p>\n<p>This function should be doing something like forward symbolic execution of a<br>\nprogram.  I'd like to prove the law of excluded miracle:<br>\n  lemma law_of_excluded_miracle [simp] : \"\\&lt;forall&gt; s. \\&lt;not&gt; (fse s False)\"</p>\n<p>My handwritten proof is via induction on the structure of an S list.  The<br>\nempty list, Assert e, and Assign e cases are trivial. In my handwritten<br>\nproof I'm also applying the IH to ITE.    Ite is causing the problem in<br>\nIsabelle.  This case is recursively calling fse on the first branch s1 to<br>\nget a predicate, and then processing the rest of the list. Similar with the<br>\nsecond branch.</p>\n<p>I can't seem to get past the ITE case. At first I thought I just needed a<br>\nsize function so that isabelle knew that the list sizes were decreasing so<br>\nthe IH would apply. That didn't work.</p>\n<p>My ultimate goal is to prove:<br>\nlemma swap : \"\\&lt;forall&gt; s. \\&lt;forall&gt; p. \\&lt;forall&gt; q. (fse s p) \\&lt;and&gt; q =<br>\n(fse s q) \\&lt;and&gt; p\"</p>\n<p>This fails as well (I'm hoping that the law_of_excluded_miracle proof will<br>\ngive insight into the swap proof).</p>\n<p>I've attached the .thy file. Any help would be appreciated....I've spent<br>\nseveral days on both.</p>\n<p>thanks!<br>\n<a href=\"/user_uploads/14278/ftEmZH_P855ZuwjLp6qMVnyy/simple-fse-lst-question.thy\">simple-fse-lst-question.thy</a></p>",
        "id": 294137522,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844838
    },
    {
        "content": "<p>From: Simon Winwood &lt;<a href=\"mailto:sjw@cse.unsw.edu.au\">sjw@cse.unsw.edu.au</a>&gt;<br>\nHi, it looks like you are using the wrong induction rule for your <br>\nproof --- you are using List.induct, rather than fse.induct.  I had a go<br>\nat the proof, attached, and found it a bit annoying.  Given a slightly<br>\nmore compact version of fse (my fse2) it goes away by induct, auto.</p>\n<p>Simon<br>\n<a href=\"/user_uploads/14278/h3IbDdVmll7TuzqQJiKYxVnc/Test.thy\">Test.thy</a></p>",
        "id": 294137543,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844845
    }
]