[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHello all,</p>\n<p>I have been revisiting the HOL-Word theories, and a central question<br>\nwhich has come to my mind is how bits are to be represented.  Some<br>\ntheories are just using bool, but some use a dedicated but also<br>\ntwo-valued type bit.  This mixture is awkward.  Further, it seems to me<br>\nthat the use of the bit type (in connection with the pseudo infix<br>\nconstructor _ BIT _, which is the seed of almost all further usages of<br>\ntype bit) goes back to the ancient numeral representation as signed bit<br>\nstrings, which is now gone.</p>\n<p>So, I would call for feedback from users of the HOL-Word theories:</p>\n<ul>\n<li>\n<p>Is there a reason to prefer bit over bool or the other way round, and<br>\nif yes, in which situations?  Or does that just appear as accident?</p>\n</li>\n<li>\n<p>If bool would be the preferred type, is it feasible (wrt. to existing<br>\napplications »outside there«) to replace bit by bool entirely? This<br>\ncould also include input syntax 0 and 1 for False and True respectively,<br>\na conversion of_bool :: bool =&gt; 'a::zero_neq_one etc.</p>\n</li>\n</ul>\n<p>Suggestions welcome,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/kj0333437g2i6R280_wgYFyp/signature.asc\">signature.asc</a></p>",
        "id": 294246704,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909195
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nI created Library/Bit.thy in February 2009 as a theory of the field of<br>\nintegers mod 2. One motivation was to be able to have polynomials with<br>\nintegers mod 2 as coefficients, which have applications in<br>\ncryptography. (I had also been working on Library/Polynomial.thy<br>\naround the same time.) As a field, it is possible to use type \"bit\"<br>\nwith polynomial operations like div, mod, and gcd.</p>\n<p>The connections between Bit.thy and the ancient numeral representation<br>\nusing _ BIT _ are accidental (see rev. 8e33b9d04a82); it is just a<br>\ncoincidence that the new type is also named \"bit\". The other uses of<br>\nBit.thy in HOL-Word are also likely due to my choice of the name of<br>\nthe type \"bit\" more than anything else. Perhaps \"Z2\" or \"z2\" would<br>\nhave been a better name for the new type; I just thought that an<br>\nEnglish word would fit better with Isabelle's naming conventions.</p>\n<p>In summary: I never meant for Library/Bit.thy to have any connection<br>\nwhatsoever to HOL-Word; I'd be in favor of converting HOL-Word to use<br>\ntype bool instead. Also, I'm open to renaming Library/Bit.thy to more<br>\naccurately describe its contents and intended use.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294246769,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909207
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nI'll try to give you my understanding of the situation.</p>\n<p>As users, we mostly use these n-bit machine word representations:</p>\n<p>- as lists of booleans of length n (to_bl/of_bl)<br>\n   - as functions from a domain of cardinality n to bool (test_bit)<br>\n   - as naturals modulo 2^n (unat/of_nat)<br>\n   - as nonnegative integers modulo 2 ^ n (uint/word_of_int)<br>\n   - as a integers - 2 ^ (n - 1) &lt;= x &lt; 2 ^ (n - 1) (sint/word_of_int)</p>\n<p>The word type could also have been defined as any of these <br>\nrepresentations, and the strength of the library is that the user <br>\ndoesn't need to care much what the underlying type definition is.</p>\n<p>I think that HOL-Word has a lot of history in it. It was created around <br>\nthe time of an earlier change in the numeral representation, which <br>\nannoyed its author somewhat and resulted in some compatibility layers. <br>\nAs a user, seeing these layers, types and definitions is a strong <br>\nindication that you've dug too deep. The same goes for the \"_ BIT _\" <br>\nrepresentation. I suspect that these representations only get used in <br>\nuser proofs in evaluating concrete n-bit arithmetic (that is, the <br>\nsimpset introduces them then removes them again).</p>\n<p>So, in short, go ahead and reconcile. I don't think users will have too <br>\nmuch work to do if the key representations and theorems about them are <br>\npreserved.</p>\n<p>Final comment, the word_bitwise representation Sascha and I worked on in <br>\n2010 uses the boolean list representation (to_bl/of_bl) or, more <br>\nprecisely, its reverse (rev o to_bl/of_bl o rev). In hindsight, the HOL4 <br>\ngroup's approach based on the function-to-bool representation (test-bit <br>\nin Isabelle) is probably smarter, since it caches better, though it <br>\ninvolves lots of natural inequalities which require simprocs to resolve <br>\nin Isabelle and are a bit of a nuisance. I'm not sure if that is even <br>\nslightly relevant.</p>\n<p>Sincerely,<br>\n     Thomas.</p>",
        "id": 294246783,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909214
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nHi Brian,</p>\n<p>could you describe in a bit more detail which aspects of finite fields<br>\nyou have formalized? In particular, have you formalized the concept of<br>\nan irreducible polynomial, together with specific irreducibility criteria?<br>\nWhen I started a formalization of AES a while ago, I used a brute-force<br>\napproach to prove that the polynomial in the AES specification is actually<br>\nirreducible. More precisely, to prove that p is irreducible I proved that<br>\nno polynomial q with degree q \\in {1..degree p div 2} divides p, but I was<br>\nwondering whether there are more clever ways of doing this.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294246857,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909244
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nOn Wed, Aug 21, 2013 at 8:57 AM, Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Brian,</p>\n<p>could you describe in a bit more detail which aspects of finite fields<br>\nyou have formalized? In particular, have you formalized the concept of<br>\nan irreducible polynomial, together with specific irreducibility criteria?</p>\n</blockquote>\n<p>I haven't formalized very much: Polynomial.thy defines div, mod, and<br>\ngcd on univariate polynomials over a field, but I haven't formalized<br>\nirreducibility or proved any related theorems.</p>\n<blockquote>\n<p>When I started a formalization of AES a while ago, I used a brute-force<br>\napproach to prove that the polynomial in the AES specification is actually<br>\nirreducible. More precisely, to prove that p is irreducible I proved that<br>\nno polynomial q with degree q \\in {1..degree p div 2} divides p, but I was<br>\nwondering whether there are more clever ways of doing this.</p>\n</blockquote>\n<p>I guess there are ([1] suggests a few methods), but I don't know of<br>\nany formalizations of such methods in Isabelle.</p>\n<p>[1] <a href=\"http://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields\">http://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields</a></p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294246869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909251
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<p>thanks for the replies.  I will give a short summary and give some clues<br>\nwhat I am actually aiming for.  Note that this is just a roadmap for<br>\nfuture work, not anything I see for the near future (~ 3 months).</p>\n<ul>\n<li>\n<p>Concerning Bit.thy – this is something separate, a formalisation of<br>\nthe Z2 field actually.  It stand aparat, and references of the Word<br>\ntheories to bit should be replaced by bool.</p>\n</li>\n<li>\n<p>Concerning bit operations – these should use bool uniformly.  Both<br>\nexplicit list conversions and implicit structural operation like<br>\ntest_bit and set_bit are relevant for user space. _ BIT _ is a historic<br>\naccident.  The idea is to clearly separate the bit operations into<br>\nseparate HOL-Library theories, to make them properly available for<br>\napplications which do not need words but bits.</p>\n</li>\n</ul>\n<p>This suggests a few refinements, which then lead to naming questions,<br>\ne.g. for bin_nth :: int =&gt; nat =&gt; bool the name does not really make<br>\nsense ;-).  Maybe its best to have the bit operations in a theory named<br>\nBit, to have qualified names like Bit.test :: 'a =&gt; nat =&gt; bool or<br>\n<a href=\"http://Bit.map\">Bit.map</a> :: nat =&gt; (bool =&gt; bool) =&gt; ('a =&gt; 'a) and such.  Then the<br>\nexisting Z2 theory should maybe really be named Z2.  (Just rough<br>\nthoughts at the moment, not clear suggestions).</p>\n<p>It is uncertain when I will come back to that issue, but the basic<br>\nlandmarks are now far clearer than before.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/SPSZtJYPdx6SRtf3TOqjoZFQ/signature.asc\">signature.asc</a></p>",
        "id": 294247374,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909436
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nSee now</p>\n<p><a href=\"http://isabelle.in.tum.de/~haftmann/cgi-bin/repos/bit_bool/\">http://isabelle.in.tum.de/~haftmann/cgi-bin/repos/bit_bool/</a><br>\n<a href=\"http://isabelle.in.tum.de/~haftmann/cgi-bin/repos/bit_bool_afp/\">http://isabelle.in.tum.de/~haftmann/cgi-bin/repos/bit_bool_afp/</a></p>\n<p>where bool replaces bit as digit type throughout.</p>\n<p>I invite users with heavy applications of the Word library to check this<br>\nfirst before bringing it upstream.</p>\n<p>Happy proving,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/oOCG9Yk2QunOIO5VL2jAFv9s/signature.asc\">signature.asc</a></p>",
        "id": 294254931,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912220
    }
]