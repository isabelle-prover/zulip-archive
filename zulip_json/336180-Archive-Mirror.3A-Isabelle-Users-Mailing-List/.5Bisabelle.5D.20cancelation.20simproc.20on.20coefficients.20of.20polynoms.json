[
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nDear Tobias,</p>\n<blockquote>\n<p>On 4. Feb 2019, at 10:45, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<p>Dear Mathias,</p>\n<p>It took me some time to remember the key point: linarith uses Fourier-Motzkin elimnation which is complere for rationals and reals but incomplete for integers. For the latter we have Presburger, but it is too slow for the example.</p>\n<p>The idea of eliminating common factors first is interesting. I have no idea if this is always beneficial. </p>\n</blockquote>\n<p>I asked our local expert of linear arithmetics, Martin Bromberger:</p>\n<blockquote>\n<p>tl;dr: Eliminating common factors helps much more than it hurts, especially for linear integer arithmetic; but there are cases, although rare, where it might be harmful.<br>\n</p>\n</blockquote>\n<blockquote>\n<p>Detailed explanation:<br>\n</p>\n</blockquote>\n<blockquote>\n<p>Fourier-Motzkin transformation over the reals/rationals: is just a projection. And the projection does not change if we eliminate common factors because this elimination is equivalence preserving. (There is one exception... Your projection may change because your Fourier-Motzkin implementation might change the variable elimination order. Yay heuristics...) What changes, however, is the run time needed to compute the projection. Whether you are faster or worse depends on the overhead of eliminating common factors vs. the speed-up you gain by having smaller coefficients. Personally, I think you would gain a speed-up.<br>\n</p>\n</blockquote>\n<blockquote>\n<p>Fourier-Motzkin transformation over the integers: eliminating       common factors alone should not change whether a problem is solvable or unsolvable. Because the projection stays the same :-) Unless, (i) you combine it with rounding (\"2 * x:int + 4 * y:int &lt;= 1\" simplifies to \"x:int + 2 * y:int &lt;= 0 = \\floor(1/2)\") or (ii) if you simplify strict inequalities over integer variables (\"a:int &lt; 1\" simplifies to \"a:int &lt;= 0\", but \"2 * a:int &lt; 2\" simplifies to \"2 * a:int &lt;= 1\"). I assume (ii) is what happened in your example (because (i) is a form of eliminating common factors) and thanks to eliminating common factors you removed some rational/real solutions and made the problem solvable. And because this is possible (i) and (ii) are also normally done for arithmetic inequalities. (Still, you might very rarely get worse results because your Fourier-Motzkin implementation changes the variable elimination order due to heuristic shenanigans…)<br>\n</p>\n</blockquote>\n<blockquote>\n<p>PS: Eliminating common factors and (i) and (ii) are not just preprocessing steps but inprocessing steps. You should apply them after every intermediate step of Fourier-Motzkin transformation…<br>\n</p>\n</blockquote>\n<blockquote>\n<p>Since the existing code is quite delicate, I also don't want to mess with it.</p>\n</blockquote>\n<p>I was more thinking of a preprocessing step, than a change to linarith itself. Which I expect to be a much bigger task.</p>\n<blockquote>\n<p>Is there a simproc for eliminating common factors? I suspect not in full generality, because the simplifier leaves \"10 * (i::int) ≤ 25 * j\" alone. There is one by Larry for the simple case \"m * t &lt;= n * u\" where m and n have a common factor. I have no idea how much work it would be to generalize it.</p>\n</blockquote>\n<p>Thanks for the pointer.</p>\n<p>Best regards,<br>\nMathias</p>\n<blockquote>\n<p>Best regards<br>\nTobias</p>\n<p>On 01/02/2019 18:38, Mathias Fleury wrote:</p>\n<blockquote>\n<p>Hi list,<br>\nafter trying to reconstruct more veriT proofs, I found out the following lemma cannot be discharged by linarith:<br>\nlemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 10 * int (size lr) &lt; 4 + 14 * int (size rr) ∨<br>\n         10 * int (size lr) ≤ 15 + 25 * int (size l') ∨<br>\n         ¬ 10 * int (size lr) + 10 * int (size rr) ≤ 30 + 25 * int (size l') \"<br>\n  apply linarith (* fails *)<br>\n  oops<br>\nHowever, if I simplify the coefficients by dividing by 5, then linearity is able to prove the goal:<br>\nlemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 5 * int (size lr) &lt; 2 + 7 * int (size rr) ∨<br>\n         2 * int (size lr) ≤ 3 + 5 * int (size l') ∨<br>\n         ¬ 2 * int (size lr) + 2 * int (size rr) ≤ 6 + 5 * int (size l') \"<br>\n  apply linarith<br>\n  done<br>\nIs there any simproc able to do this simplification automatically? If there is one, is there any reason why linarith does not use it by default?<br>\nThanks,<br>\nMathias<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294749703,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194943
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nMathias,</p>\n<p>Actually, a simproc to cancel all common factors is easy: Givem t1 &lt;= t2, where <br>\nt1 and t2 are sums, compute the common factor m of t1 and t2 and the remainders <br>\nt1' and t2'. Prove by rewriting with distributivity that (t1 &lt;= t2) = (m*t1' &lt;= <br>\nm<em>t2'). Prove by simproc that (m</em>t1' &lt;= m*t2') = (t1' &lt;= t2') - see <br>\nTools/numeral_simprocs.ML.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/TahsHp2D3zwr2TFvbq_-s4y6/smime.p7s\">smime.p7s</a></p>",
        "id": 294749870,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195011
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi all,</p>\n<blockquote>\n<p>On 4. Feb 2019, at 17:20, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<p>Mathias,</p>\n<p>Actually, a simproc to cancel all common factors is easy: Givem t1 &lt;= t2, where t1 and t2 are sums, compute the common factor m of t1 and t2 and the remainders t1' and t2'. Prove by rewriting with distributivity that (t1 &lt;= t2) = (m<em>t1' &lt;= m</em>t2'). Prove by simproc that (m<em>t1' &lt;= m</em>t2') = (t1' &lt;= t2') - see Tools/numeral_simprocs.ML.<br>\n</p>\n</blockquote>\n<p>I implemented that. I followed what was already in Tools/numeral_simprocs.ML. Then I activated the <br>\nprocedure as simproc on nat and 'a :: linordered_ring_strict (which includes int and reals) and run it on the (non-slow part of) AFP.</p>\n<p>When trying it out on the AFP, some proofs broke because of the reordering meaning. So if we want to activate such simproc, we would have to adapt some proofs:<br>\n  by (clarsimp simp add: cos_one_2pi) (metis mult_minus_right of_int_of_nat)<br>\n~&gt;<br>\n  by (clarsimp simp add: cos_one_2pi) (metis mult_minus_left of_int_of_nat)</p>\n<p>Nevertheless, it turns out things are a bit more complicated than I expected. They are already two different simprocs that can cancel terms, but do different things:</p>\n<p>* eq_cancel_numeral_factor: it cancels term, but on the way, it reorders terms. <br>\n     (2::int) * a * b = 2 * b' * a' ~&gt; a * b = a' * b'</p>\n<p>* eq_cancel_factor: it cancels a terms, but without reordering terms:<br>\n     (2::int) * a * b = 2 * b' * a' ~&gt; 2 = 0 ∨ a * b = b' * a'<br>\n[2 = 0 can be simplified to false later, yielding a * b = b' * a']</p>\n<p>I have a few questions:</p>\n<p>* Does anyone know why some cancelation simprocs sort terms?<br>\n  * Are simprocs supposed to be confluent, i.e., reach the same conclusion independently of the order they are applied?</p>\n<p>Best,<br>\nMathias</p>\n<blockquote>\n<p>Tobias</p>\n<p>On 04/02/2019 15:29, Mathias Fleury wrote:</p>\n<blockquote>\n<p>Dear Tobias,</p>\n<blockquote>\n<p>On 4. Feb 2019, at 10:45, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a> &lt;mailto:<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;&gt; wrote:</p>\n<p>Dear Mathias,</p>\n<p>It took me some time to remember the key point: linarith uses Fourier-Motzkin elimnation which is complere for rationals and reals but incomplete for integers. For the latter we have Presburger, but it is too slow for the example.</p>\n<p>The idea of eliminating common factors first is interesting. I have no idea if this is always beneficial.<br>\nI asked our local expert of linear arithmetics, Martin Bromberger:<br>\n   tl;dr: Eliminating common factors helps much more than it hurts,<br>\n   especially for linear integer arithmetic; but there are cases, although<br>\n   rare, where it might be harmful.</p>\n<p>Detailed explanation:</p>\n<p>Fourier-Motzkin transformation over the reals/rationals: is just a<br>\n   projection. And the projection does not change if we eliminate common<br>\n   factors because this elimination is equivalence preserving. (There is one<br>\n   exception... Your projection may change because your Fourier-Motzkin<br>\n   implementation might change the variable elimination order. Yay<br>\n   heuristics...) What changes, however, is the run time needed to compute<br>\n   the projection. Whether you are faster or worse depends on the overhead of<br>\n   eliminating common factors vs. the speed-up you gain by having smaller<br>\n   coefficients. Personally, I think you would gain a speed-up.</p>\n<p>Fourier-Motzkin transformation over the integers: eliminating       common<br>\n   factors alone should not change whether a problem is solvable or<br>\n   unsolvable. Because the projection stays the same :-) Unless, (i) you<br>\n   combine it with rounding (\"2 * x:int + 4 * y:int &lt;= 1\" simplifies to<br>\n   \"x:int + 2 * y:int &lt;= 0 = \\floor(1/2)\") or (ii) if you simplify strict<br>\n   inequalities over integer variables (\"a:int &lt; 1\" simplifies to \"a:int &lt;=<br>\n   0\", but \"2 * a:int &lt; 2\" simplifies to \"2 * a:int &lt;= 1\"). I assume (ii) is<br>\n   what happened in your example (because (i) is a form of eliminating common<br>\n   factors) and thanks to eliminating common factors you removed some<br>\n   rational/real solutions and made the problem solvable. And because this is<br>\n   possible (i) and (ii) are also normally done for arithmetic inequalities.<br>\n   (Still, you might very rarely get worse results because your<br>\n   Fourier-Motzkin implementation changes the variable elimination order due<br>\n   to heuristic shenanigans…)</p>\n<p>PS: Eliminating common factors and (i) and (ii) are not just preprocessing<br>\n   steps but inprocessing steps. You should apply them after every<br>\n   intermediate step of Fourier-Motzkin transformation…</p>\n<p>Since the existing code is quite delicate, I also don't want to mess with it.<br>\nI was more thinking of a preprocessing step, than a change to linarith itself. Which I expect to be a much bigger task.<br>\nIs there a simproc for eliminating common factors? I suspect not in full generality, because the simplifier leaves \"10 * (i::int) ≤ 25 * j\" alone. There is one by Larry for the simple case \"m * t &lt;= n * u\" where m and n have a common factor. I have no idea how much work it would be to generalize it.<br>\nThanks for the pointer.<br>\nBest regards,<br>\nMathias<br>\nBest regards<br>\nTobias<br>\n</p>\n</blockquote>\n<p>On 01/02/2019 18:38, Mathias Fleury wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi list,<br>\nafter trying to reconstruct more veriT proofs, I found out the following lemma cannot be discharged by linarith:<br>\nlemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 10 * int (size lr) &lt; 4 + 14 * int (size rr) ∨<br>\n         10 * int (size lr) ≤ 15 + 25 * int (size l') ∨<br>\n         ¬ 10 * int (size lr) + 10 * int (size rr) ≤ 30 + 25 * int (size l') \"<br>\n  apply linarith (* fails *)<br>\n  oops<br>\nHowever, if I simplify the coefficients by dividing by 5, then linearity is able to prove the goal:<br>\nlemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 5 * int (size lr) &lt; 2 + 7 * int (size rr) ∨<br>\n         2 * int (size lr) ≤ 3 + 5 * int (size l') ∨<br>\n         ¬ 2 * int (size lr) + 2 * int (size rr) ≤ 6 + 5 * int (size l') \"<br>\n  apply linarith<br>\n  done<br>\nIs there any simproc able to do this simplification automatically? If there is one, is there any reason why linarith does not use it by default?<br>\nThanks,<br>\nMathias</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294750202,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195148
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI don't believe we have a master plan for arithmetic simprocs. Or only for some <br>\nof them. It is all grown historically, with sometimes odd interactions.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/vznuZLhzozlSen520mCAy_oW/smime.p7s\">smime.p7s</a></p>",
        "id": 294750293,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195171
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI've been mentioning this issue occasionally over the last few years.<br>\nConsidering how well computer algebra systems can handle equations and<br>\ninequalities, there /must/ be room for improvement in Isabelle/HOL.</p>\n<p>Unfortunately, I've had little luck finding out what exactly it is that<br>\nthese systems do, and in any case it is probably a lot of work. To make<br>\nmatters worse, it might well break a lot of existing proofs if we switch<br>\nit on by default, and no one will use it if we don't.</p>\n<p>Manuel</p>",
        "id": 294750321,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195183
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI just realised that I should have read more than the first sentence of<br>\nyour email; I interpreted \"Master plan for arithmetic simprocs\" as \"plan<br>\nfor the future development of arithmetic simprocs\". Now I see that's not<br>\nwhat you meant.</p>\n<p>Still, if anyone has some opinions on what I wrote or feels inclined to<br>\nimplement this, do come forward.</p>\n<p>Manuel</p>",
        "id": 294750334,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195189
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI would love to see the following paper implemented:</p>\n<p><a href=\"https://tel.archives-ouvertes.fr/IMAG/hal-01505598v1\">https://tel.archives-ouvertes.fr/IMAG/hal-01505598v1</a></p>\n<p>It discovers equalities and is therefore useful even when it can’t prove the goal outright. I guess it would be a medium-sized project.</p>\n<p>Larry</p>",
        "id": 294750345,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195195
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI've seen that paper but I'm not sure how useful it would be in an<br>\nIsabelle context, at least in an Isar proof. There, the typical workflow<br>\nis that you have a fixed goal to prove and you chain in all the facts<br>\nthat are needed to prove it and then you call a method that can either<br>\nsolve it or it fails.</p>\n<p>The only workflow I could possibly imagine is in apply-style<br>\nexploration: You run \"apply linarith2\" on your goal and if it can't<br>\nsolve it, it prints a list of learned inequalities, and then you<br>\nmanually go through that to see if there are any interesting ones among<br>\nthem and then copypaste them back into your Isar proof before that.</p>\n<p>Since this use of the method is purely diagnostic, there would be no<br>\nneed to formalise the \"learning new equalities\" part at all.</p>\n<p>I'm not saying that it wouldn't be interesting to formalise this method<br>\njust for the sake of formalising it; it's certainly interesting from a<br>\ntheoretical viewpoint in any case. I'm just not sure that it would be<br>\n/that/ useful as an Isabelle tool.</p>\n<p>By the way, since we're talking about simprocs, I'm currently offering a<br>\nstudent project at TUM to implement some extremely specialised simprocs<br>\nto tackle things like \"ln(12) = 2*ln(2) + ln(3)\", \"of_nat n + 1 / 2 ∉ ℤ<br>\n= False\", and \"totient 1234 = 616\" etc. Let's see if someone bites.</p>\n<p>Manuel</p>",
        "id": 294750358,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195200
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi list,</p>\n<p>after trying to reconstruct more veriT proofs, I found out the following lemma cannot be discharged by linarith:</p>\n<p>lemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 10 * int (size lr) &lt; 4 + 14 * int (size rr) ∨<br>\n         10 * int (size lr) ≤ 15 + 25 * int (size l') ∨<br>\n         ¬ 10 * int (size lr) + 10 * int (size rr) ≤ 30 + 25 * int (size l') \"<br>\n  apply linarith (* fails *)<br>\n  oops</p>\n<p>However, if I simplify the coefficients by dividing by 5, then linearity is able to prove the goal:</p>\n<p>lemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 5 * int (size lr) &lt; 2 + 7 * int (size rr) ∨<br>\n         2 * int (size lr) ≤ 3 + 5 * int (size l') ∨<br>\n         ¬ 2 * int (size lr) + 2 * int (size rr) ≤ 6 + 5 * int (size l') \"<br>\n  apply linarith<br>\n  done</p>\n<p>Is there any simproc able to do this simplification automatically? If there is one, is there any reason why linarith does not use it by default?</p>\n<p>Thanks,<br>\nMathias</p>",
        "id": 294750382,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195209
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThere should be no need to divide by 5, linarith should not need it. Alas, ...</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/AqpK0dfk3QbW8lmYlm8sJxiA/smime.p7s\">smime.p7s</a></p>",
        "id": 294750562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195275
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi all,</p>\n<p>I had a look at the trace. The problems seems to be \"¬ 10 * t2 ≤ 15 + 25 * t1\". </p>\n<ul>\n<li>\n<p>If not simplified, it is transformed to \"16 &lt;= 10 * t2 + ~25 * t1\" (in the tracing: \"16 &lt;= 10, 0, ~25\")</p>\n</li>\n<li>\n<p>After simplification, it becomes \"¬ 2 * t2 ≤ 3 + 5 * t1\", which is transformed to \"4 &lt;= 2 * t2 + ~5 * t1\" (in the tracing: \"4 &lt;= 2, 0, ~5\")</p>\n</li>\n</ul>\n<p>The latter yields an equivalent (but slightly stronger at a first glance) equality: \"20 &lt;= 10 * t2 + ~25 * t1\". This equality is equivalent to \"16 &lt;= 10 * t2 + ~25 * t1\", but linarith does not notice.</p>\n<p>If I replace \"10 * t2 ≤ 15 + 25 * t1\" by \"10 * t2 ≤ 19 + 25 * t1\", then the refutation works (and this two expressions are equivalent).</p>\n<blockquote>\n<p>On 1. Feb 2019, at 19:49, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:<br>\nThere should be no need to divide by 5, linarith should not need it. Alas, …</p>\n</blockquote>\n<p>Or is linarith suppose to preprocess  the (in)equalities?</p>\n<p>Mathias</p>\n<p>The same example without the constants:<br>\nconsts t1 :: int <br>\nconsts t2 :: int<br>\nconsts t3 :: int</p>\n<p>definition \"eq1 ≡ ¬ 0 ≤ t1 ∨ ¬ 10 * t2 &lt; 4 + 14 * t3 ∨<br>\n         10 * t2 ≤ 15 + 25 * t1 ∨  ¬ 10 * t2 + 10 * t3 ≤ 30 + 25 * t1\"</p>\n<p>definition \"eq3 ≡ ¬ 0 ≤ t1 ∨ ¬ 10 * t2 &lt; 4 + 14 * t3 ∨<br>\n         2 * t2 ≤ 3 + 5 * t1 ∨ ¬ 2 * t2 + 2 * t3 ≤ 6 + 5 * t1\"</p>\n<p>lemma \"eq1 \"<br>\n  unfolding eq1_def<br>\n  supply [[linarith_trace]]<br>\n  apply linarith<br>\n  oops</p>\n<p>(*<br>\nTrying to refute subgoal 1<br>\n¬ 0 ≤ t1 ∨<br>\n¬ 10 * t2 &lt; 4 + 14 * t3 ∨<br>\n10 * t2 ≤ 15 + 25 * t1 ∨ ¬ 10 * t2 + 10 * t3 ≤ 30 + 25 * t1 <br>\nprove: <br>\nPreprocessing yields 1 subgoal(s) total. <br>\nSplitting of inequalities yields 1 subgoal(s) total. <br>\nRefutation failed. <br>\nTrying to refute subgoal 1<br>\n0 ≤ t1 ⟹<br>\n10 * t2 &lt; 4 + 14 * t3 ⟹<br>\n¬ 10 * t2 ≤ 15 + 25 * t1 ⟹<br>\n10 * t2 + 10 * t3 ≤ 30 + 25 * t1 ⟹ False <br>\nprove: <br>\nPreprocessing yields 1 subgoal(s) total. <br>\nSplitting of inequalities yields 1 subgoal(s) total. </p>\n<p>0 &lt;= 0, 0, 1<br>\n~3 &lt;= ~10, 14, 0<br>\n16 &lt;= 10, 0, ~25<br>\n~30 &lt;= ~10, ~10, 25 </p>\n<p>0 &lt;= 0, 0, 1<br>\n16 &lt;= 10, 0, ~25<br>\n~225 &lt;= ~120, 0, 175 </p>\n<p>0 &lt;= 0, 0, 1<br>\n~33 &lt;= 0, 0, ~125 </p>\n<p>~33 &lt;= 0, 0, 0 <br>\nRefutation failed. <br>\n*)</p>\n<p>lemma \"eq3 \"<br>\n  unfolding eq3_def<br>\n  supply [[linarith_trace]]<br>\n  apply linarith<br>\n  done<br>\n(*<br>\nTrying to refute subgoal 1<br>\n¬ 0 ≤ t1 ∨<br>\n¬ 10 * t2 &lt; 4 + 14 * t3 ∨<br>\n2 * t2 ≤ 3 + 5 * t1 ∨ ¬ 2 * t2 + 2 * t3 ≤ 6 + 5 * t1 <br>\nprove: <br>\nPreprocessing yields 1 subgoal(s) total. <br>\nSplitting of inequalities yields 1 subgoal(s) total. <br>\nRefutation failed. <br>\nTrying to refute subgoal 1<br>\n0 ≤ t1 ⟹<br>\n10 * t2 &lt; 4 + 14 * t3 ⟹<br>\n¬ 2 * t2 ≤ 3 + 5 * t1 ⟹ 2 * t2 + 2 * t3 ≤ 6 + 5 * t1 ⟹ False <br>\nprove: <br>\nPreprocessing yields 1 subgoal(s) total. <br>\nSplitting of inequalities yields 1 subgoal(s) total. </p>\n<p>0 &lt;= 0, 0, 1<br>\n~3 &lt;= ~10, 14, 0<br>\n4 &lt;= 2, 0, ~5<br>\n~6 &lt;= ~2, ~2, 5 </p>\n<p>0 &lt;= 0, 0, 1<br>\n4 &lt;= 2, 0, ~5<br>\n~45 &lt;= ~24, 0, 35 </p>\n<p>0 &lt;= 0, 0, 1<br>\n3 &lt;= 0, 0, ~25 </p>\n<p>3 &lt;= 0, 0, 0 <br>\nContradiction! (1) <br>\n*)</p>\n<blockquote>\n<p>On 1. Feb 2019, at 19:49, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<p>There should be no need to divide by 5, linarith should not need it. Alas, ...</p>\n<p>Tobias</p>\n<p>On 01/02/2019 18:38, Mathias Fleury wrote:</p>\n<blockquote>\n<p>Hi list,<br>\nafter trying to reconstruct more veriT proofs, I found out the following lemma cannot be discharged by linarith:<br>\nlemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 10 * int (size lr) &lt; 4 + 14 * int (size rr) ∨<br>\n         10 * int (size lr) ≤ 15 + 25 * int (size l') ∨<br>\n         ¬ 10 * int (size lr) + 10 * int (size rr) ≤ 30 + 25 * int (size l') \"<br>\n  apply linarith (* fails *)<br>\n  oops<br>\nHowever, if I simplify the coefficients by dividing by 5, then linearity is able to prove the goal:<br>\nlemma \"¬ 0 ≤ int (size l') ∨<br>\n         ¬ 5 * int (size lr) &lt; 2 + 7 * int (size rr) ∨<br>\n         2 * int (size lr) ≤ 3 + 5 * int (size l') ∨<br>\n         ¬ 2 * int (size lr) + 2 * int (size rr) ≤ 6 + 5 * int (size l') \"<br>\n  apply linarith<br>\n  done<br>\nIs there any simproc able to do this simplification automatically? If there is one, is there any reason why linarith does not use it by default?<br>\nThanks,<br>\nMathias<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294750729,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195346
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIn principle a proof tool can propose to add more Isar text as <br>\n\"sendback\" source snippets, e.g. see recent versions of the \"induct\" <br>\nfamily of methods. The main problem is probably technical, to place <br>\nfurther facts in the right spot before the goal statement: that would <br>\nrequire new sendback properties such that the Prover IDE knows what is <br>\nintended (Isabelle/Scala understands more Isar structure and syntax than <br>\nIsabelle/ML).</p>\n<p>Makarius</p>",
        "id": 294751131,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195508
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Mathias,</p>\n<p>It took me some time to remember the key point: linarith uses Fourier-Motzkin <br>\nelimnation which is complere for rationals and reals but incomplete for <br>\nintegers. For the latter we have Presburger, but it is too slow for the example.</p>\n<p>The idea of eliminating common factors first is interesting. I have no idea if <br>\nthis is always beneficial. Since the existing code is quite delicate, I also <br>\ndon't want to mess with it.</p>\n<p>Is there a simproc for eliminating common factors? I suspect not in full <br>\ngenerality, because the simplifier leaves \"10 * (i::int) ≤ 25 * j\" alone. There <br>\nis one by Larry for the simple case \"m * t &lt;= n * u\" where m and n have a common <br>\nfactor. I have no idea how much work it would be to generalize it.</p>\n<p>Best regards<br>\nTobias<br>\n<a href=\"/user_uploads/14278/pWkjFTl7hpTM_BEH3AHxPues/smime.p7s\">smime.p7s</a></p>",
        "id": 294751243,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195546
    }
]