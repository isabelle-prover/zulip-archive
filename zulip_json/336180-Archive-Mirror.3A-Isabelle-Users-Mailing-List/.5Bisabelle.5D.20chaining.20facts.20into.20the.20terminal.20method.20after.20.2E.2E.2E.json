[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n\"Fudge\" seems to be a recent slang word that I do quite understand, or is <br>\nthis North American?</p>\n<p>Concerning the meaning of the above, the concept of Isar facts vs. goal <br>\nrefinements are explained to some extent in section 6.2 of the <br>\nimplementation manual.  Roughly you have something like this:</p>\n<p>&lt;using facts&gt;<br>\n   &lt;goal&gt;<br>\n   proof &lt;initial method&gt;<br>\n     &lt;body&gt;<br>\n   qed &lt;terminal method&gt;</p>\n<p>The initial step (with the \"using\" part) is usually fully \"structured\" in <br>\nthe sense explained in section 6.2: methods like \"rule\" or \"induct\" take <br>\nfacts very seriously in what they do.  Moving further towards the tail <br>\nposition, some structure is given up: the terminal method merely finishes <br>\nwhat is left, usually using \"simple methods\" in the sense of 6.2, where <br>\nfacts are only inserted as \"insert\" does.  (BTW, it is bad style to make a <br>\nweakly structured initial method application -- simp, auto etc. -- and <br>\nthen try to proceed in a structured way towards the end.)</p>\n<p>So the above use of qed \"insert\" is in accordance with the usual Isar <br>\nstyle, even though complex method expressions at qed time tend to become <br>\nslightly ugly.</p>\n<p>For the special situation of induction, the general plan of action is to <br>\nprovide reasonably mechanisms for proof composition into the Prover IDE at <br>\nsome point.  E.g. the cases would be spelt out explictly by the IDE, and <br>\nthe user gets a chance to expand the non-trivial ones or tweak the trivial <br>\nones, even if most of them happen to be almost the same.  Once we are <br>\ngetting closer to this, one can revisit the old questions about effective <br>\ncomposition and maintanence of big induction proofs, wrt. changes of the <br>\ninductive specifications etc.</p>\n<p>Here is a historically interesting example, which has defined the received <br>\nIsar proof style to a large extent.  At that point <br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2002/src/HOL/Unix/Unix.thy#l425\">http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2002/src/HOL/Unix/Unix.thy#l425</a> <br>\nall cases are expanded uniformaly -- and automatically benefit from <br>\nindependent failure reports and parallel evaluation (around 2008/2009). <br>\nAt some later stage one subproof was changed independently so we now see<br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2011-1/src/HOL/Unix/Unix.thy#l425\">http://isabelle.in.tum.de/repos/isabelle/file/Isabelle2011-1/src/HOL/Unix/Unix.thy#l425</a></p>\n<p>This definitely shows some redundancy in the text, but postulating a <br>\ndecent Prover IDE it might actually work out in everyday hard work as <br>\nwell, without having to make tight \"proof scripts\" again.</p>\n<p>Makarius</p>",
        "id": 294149819,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848874
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nMakarius,</p>\n<p>On 06/01/2012, at 11:08 PM, Makarius wrote:</p>\n<blockquote>\n<p>\"Fudge\" seems to be a recent slang word that I do quite understand, or is this North American?</p>\n</blockquote>\n<p>It might be. I don't think it's recent.</p>\n<blockquote>\n<p>Concerning the meaning of the above, the concept of Isar facts vs. goal refinements are explained to some extent in section 6.2 of the implementation manual.  Roughly you have something like this:</p>\n<p>&lt;using facts&gt;<br>\n &lt;goal&gt;<br>\n proof &lt;initial method&gt;<br>\n   &lt;body&gt;<br>\n qed &lt;terminal method&gt;</p>\n<p>The initial step (with the \"using\" part) is usually fully \"structured\" in the sense explained in section 6.2: methods like \"rule\" or \"induct\" take facts very seriously in what they do.  Moving further towards the tail position, some structure is given up: the terminal method merely finishes what is left, usually using \"simple methods\" in the sense of 6.2, where facts are only inserted as \"insert\" does.  (BTW, it is bad style to make a weakly structured initial method application -- simp, auto etc. -- and then try to proceed in a structured way towards the end.)</p>\n<p>So the above use of qed \"insert\" is in accordance with the usual Isar style, even though complex method expressions at qed time tend to become slightly ugly.</p>\n</blockquote>\n<p>I understand, but my point is that Isar allows me to name a fact but does not let me use it in a context where I need to - forcing me to employ the otherwise useless \"insert\" tactic. (In other contexts one can say \"using ...\", or appeal to the more powerful cut_tac if necessary.) This makes me think some outer syntax is missing.</p>\n<p>I was vaguely proposing that:</p>\n<p>...<br>\nqed &lt;terminal method&gt;</p>\n<p>be generalised to something like:</p>\n<p>qed (using fact+)? &lt;terminal method&gt;</p>\n<ul>\n<li>that the use of insert in this way be blessed with some outer syntax.</li>\n</ul>\n<p>Best of luck with the IDE issues. :-)</p>\n<p>cheers<br>\npeter</p>",
        "id": 294149855,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848886
    },
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nHi,</p>\n<p>I have an induction of this form:</p>\n<p>datatype D = a | b | c | d</p>\n<p>lemma<br>\n  assumes A: \"A\"<br>\n  assumes B: \"B (x :: D)\"<br>\n  shows \"C x\"<br>\nusing B<br>\nproof(induct x)<br>\n  case a with A show ?case sorry (* non trivial *)<br>\nnext<br>\n  case b with A show ?case sorry (* trivial *)<br>\nnext<br>\n  case c with A show ?case sorry (* trivial *)<br>\nnext<br>\n  case d with A show ?case sorry (* trivial *)<br>\nqed</p>\n<p>I would like to write this instead:</p>\n<p>lemma<br>\n  assumes A: \"A\"<br>\n  assumes B: \"B (x :: D)\"<br>\n  shows \"C x\"<br>\nusing B<br>\nproof(induct x)<br>\n  case a with A show ?case sorry (* non trivial *)<br>\nqed using A by ...</p>\n<p>I have fudged this in the past by using the \"insert\" method:</p>\n<p>...<br>\nqed (insert A, ...)</p>\n<p>Would it be possible to generalise what's allowed after \"qed\"?</p>\n<p>Logically I could chain A into the induction too, but this obfuscates the induction hypothesis.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294150005,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848960
    }
]