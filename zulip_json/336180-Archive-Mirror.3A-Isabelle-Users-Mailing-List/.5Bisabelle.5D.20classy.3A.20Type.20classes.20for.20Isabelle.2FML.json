[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear list,</p>\n<p>I've created some (very rough) tooling for type classes and automatic<br>\ninstance resolution for Isabelle/ML. You can find the sources on GitHub:</p>\n<p>&lt;<a href=\"https://github.com/larsrh/classy\">https://github.com/larsrh/classy</a>&gt;</p>\n<p>This was prompted by my unwillingness to write code like this:</p>\n<p>val codec =<br>\n    Codec.tuple<br>\n      (Codec.list<br>\n        (Codec.tuple<br>\n          Term_Codec.term<br>\n          Term_Codec.term))<br>\n      (Codec.tuple<br>\n        Term_Codec.typ<br>\n        Term_Codec.typ)</p>\n<p>This can now be simply written as</p>\n<p>val codec =<br>\n    @{ML.resolve ‹(term * term) list * (typ * typ)› :: codec}</p>\n<p>You can have a look at the files \"Classy.thy\" and \"Examples.thy\" to get<br>\nan idea of how it can be used.</p>\n<p>A word of warning: The resolution algorithm is utterly stupid; it just<br>\nperforms a naive search of all possible instances. Notably, it is not<br>\neven guaranteed to terminate. When declaring instances, there are no<br>\nchecks whether an instance is wellformed (e.g. according to Haskell98's<br>\nor Isabelle's notion of wellformedness). All of this is purely<br>\nsyntactic, that is, it gets confused when type aliases are involved.</p>\n<p>However, the code does support local instances (as long as they don't<br>\noverride other ones) and observes the usual Isabelle conventions wrt to<br>\nlocal theories.</p>\n<p>Parts of the code are lifted from Spec_Check, especially those dealing<br>\nwith parsing ML types. \"classy\" is in some sense even more general than<br>\nthe mechanisms in Spec_Check, because it isn't specialized to random<br>\nvalue generators.</p>\n<p>Feedback most welcome.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294651167,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661166144
    }
]