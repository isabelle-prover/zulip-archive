[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear all,</p>\n<p>I stumbled over the following problem with code_datatype and theory merges. It <br>\ninvolves 4 theories with diamond inheritance:</p>\n<ol>\n<li>The first theory defines a type and a refined representation for code generation.</li>\n</ol>\n<p>theory Scratch1 imports Main begin</p>\n<p>typedef type = \"UNIV :: int set\"<br>\n   morphisms rep_Foo Foo<br>\nby blast</p>\n<p>definition Bar where [code del]: \"Bar n = Foo (n + 1)\"<br>\ncode_datatype Bar</p>\n<p>lemma Foo_code [code]: \"Foo n = Bar (n - 1)\"<br>\nby(simp add: Bar_def)</p>\n<p>end</p>\n<ol start=\"2\">\n<li>The next theory Scratch2 changes the refinement such that Foo is the new <br>\nconstructor in the generated code and Bar is implemented in terms of Foo.</li>\n</ol>\n<p>theory Scratch2 imports Scratch1 begin<br>\ndeclare Foo_code [code del]<br>\ncode_datatype Foo<br>\ndeclare Bar_def [code]<br>\nend</p>\n<ol start=\"3\">\n<li>Scratch3 does nothing but introduce an empty theory.</li>\n</ol>\n<p>theory Scratch3 imports Scratch1 begin end</p>\n<ol start=\"4\">\n<li>Scratch4 merges Scratch2 and Scratch3, the order is irrelevant for the following.</li>\n</ol>\n<p>theory Scratch4 imports Scratch3 Scratch2 begin</p>\n<p>(* This is where the trouble begins: The theory merge imports the code equation <br>\nBar_def declared in Scratch2 <em>and</em> Foo_code from Scratch, which is visible via <br>\nScratch3. *)</p>\n<p>code_thms Bar</p>\n<p>produces the following error:</p>\n<p>*** Constructor as head in equation:<br>\n*** Foo ?n ==<br>\n*** Bar (minus_int_inst.minus_int ?n<br>\n***       (number_int_inst.number_of_int (Int.Bit1 Int.Pls)))<br>\n*** At command \"code_thms\"</p>\n<p>Deleting the offending theorem Foo_code is not straight forward:</p>\n<p>declare Foo_code [code del]<br>\ncode_thms Bar</p>\n<p>still gives the same error. To me, this looks like a bug in the code generator.<br>\nI found a way to get rid of the offending equation in Scratch4, but I don't <br>\nconsider this a reasonable solution:</p>\n<p>code_datatype Bar<br>\ndeclare Foo_code [code del]<br>\ncode_datatype Foo</p>\n<p>Although the example is constructed, such weird hiearchies and code_datatype <br>\nredeclarations do occur in practice. An example: Restore the code generator <br>\nsetup from HOL/Libray/Cset for Cset.set after loading HOL/Library/Dlist. By the <br>\nway, this has been the reason for Lukas proposing to split the data structure <br>\ntheories in HOL/Library.</p>\n<p>I'd be glad if anyone of the developers looked into this issue.</p>\n<p>Andreas</p>",
        "id": 294135585,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844221
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nOn 04/21/2011 02:43 PM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>I stumbled over the following problem with code_datatype and theory <br>\nmerges. It involves 4 theories with diamond inheritance:</p>\n<ol>\n<li>The first theory defines a type and a refined representation for <br>\ncode generation.</li>\n</ol>\n<p>theory Scratch1 imports Main begin</p>\n<p>typedef type = \"UNIV :: int set\"<br>\n  morphisms rep_Foo Foo<br>\nby blast</p>\n<p>definition Bar where [code del]: \"Bar n = Foo (n + 1)\"<br>\ncode_datatype Bar</p>\n<p>lemma Foo_code [code]: \"Foo n = Bar (n - 1)\"<br>\nby(simp add: Bar_def)</p>\n<p>end</p>\n<ol start=\"2\">\n<li>The next theory Scratch2 changes the refinement such that Foo is <br>\nthe new constructor in the generated code and Bar is implemented in <br>\nterms of Foo.</li>\n</ol>\n<p>theory Scratch2 imports Scratch1 begin<br>\ndeclare Foo_code [code del]<br>\ncode_datatype Foo<br>\ndeclare Bar_def [code]<br>\nend</p>\n<ol start=\"3\">\n<li>Scratch3 does nothing but introduce an empty theory.</li>\n</ol>\n<p>theory Scratch3 imports Scratch1 begin end</p>\n<ol start=\"4\">\n<li>Scratch4 merges Scratch2 and Scratch3, the order is irrelevant for <br>\nthe following.</li>\n</ol>\n<p>theory Scratch4 imports Scratch3 Scratch2 begin</p>\n<p>(* This is where the trouble begins: The theory merge imports the code <br>\nequation Bar_def declared in Scratch2 <em>and</em> Foo_code from Scratch, <br>\nwhich is visible via Scratch3. *)</p>\n<p>code_thms Bar</p>\n<p>produces the following error:</p>\n<p>*** Constructor as head in equation:<br>\n*** Foo ?n ==<br>\n*** Bar (minus_int_inst.minus_int ?n<br>\n***       (number_int_inst.number_of_int (Int.Bit1 Int.Pls)))<br>\n*** At command \"code_thms\"</p>\n<p>Deleting the offending theorem Foo_code is not straight forward:</p>\n<p>declare Foo_code [code del]<br>\ncode_thms Bar</p>\n<p>still gives the same error. To me, this looks like a bug in the code <br>\ngenerator.<br>\nI found a way to get rid of the offending equation in Scratch4, but I <br>\ndon't consider this a reasonable solution:</p>\n<p>code_datatype Bar<br>\ndeclare Foo_code [code del]<br>\ncode_datatype Foo</p>\n<p>Although the example is constructed, such weird hiearchies and <br>\ncode_datatype redeclarations do occur in practice. An example: Restore <br>\nthe code generator setup from HOL/Libray/Cset for Cset.set after <br>\nloading HOL/Library/Dlist. By the way, this has been the reason for <br>\nLukas proposing to split the data structure theories in HOL/Library.</p>\n<p>I'd be glad if anyone of the developers looked into this issue.<br>\n</p>\n</blockquote>\n<p>This issue has been resolved by 42d607a9ae65 in the development version.</p>\n<p>Lukas</p>\n<blockquote>\n<p>Andreas<br>\n</p>\n</blockquote>",
        "id": 294136232,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844409
    }
]