[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>I have a coinductive predicate P and I want to show that \"P s\" holds, <br>\nwhere \"s\" is a corecursively-defined stream whose definition uses a <br>\nfriendly function, i.e. something like \"s = 0 ## g s\" where g is <br>\nfriendly. (see also attached theory)</p>\n<p>The problem is that P.coinduct then only allows me to use \"P s\" in the <br>\ncoinduction proof, but I need \"P (g s)\". I suppose what I really need <br>\nhere is something like \"coinduction up to friends for coinductive <br>\npredicates\"; from what I read, something like this is already available <br>\nfor \"normal\" coinduction w.r.t. equality.</p>\n<p>How do I do something like this? (my actual coinductive predicate is, of <br>\ncourse, much more complicated than this, so working with \"normal\" <br>\ncoinduction w.r.t. equality is not an option)</p>\n<p>Cheers,</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/y-xsPeDO2jcuj6l9ewjZqjfq/Test.thy\">Test.thy</a></p>",
        "id": 294700009,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178867
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Manuel,</p>\n<p>You have to manually derive a coinduction up-to rule for your coinductive predicates. <br>\nBNF_Corec only proves coinduction up-to rules for equality. User-defined predicates are <br>\nnot supported and probably will not be in the foreseeable future, because one would need a <br>\nlot of properties of the predicate. I've sketched the derivation of such an coinduction <br>\nup-to rule for your unary predicate P and the friend g below. It roughly corresponds to <br>\nwhat the BNF_Corec package does internally. Basically, you first define a closure operator <br>\nfor the set of friends that you are interested in and then prove the upto rule by <br>\ncoinduction with a nested induction on the closure.</p>\n<p>inductive g_closure :: \"(int stream ⇒ bool) ⇒ int stream ⇒ bool\" for P where<br>\n     embed: \"P xs ⟹ g_closure P xs\"<br>\n   | step: \"g_closure P xs ⟹ g_closure P (g xs)\"</p>\n<p>lemma P_coinduct_upto_g:<br>\n   assumes *: \"X xs\"<br>\n   and step: \"⋀xs. X xs ⟹ ∃x xs'. xs = x ## xs' ∧ g_closure X xs' ∧ 0 ≤ x\"<br>\n   shows \"P xs\"<br>\nproof -<br>\n   from * have \"g_closure X xs\" by(rule g_closure.intros)<br>\n   then show ?thesis<br>\n   proof(coinduction arbitrary: xs)<br>\n     case (P xs)<br>\n     then have \"∃x xs'. xs = x ## xs' ∧ g_closure X xs' ∧ 0 ≤ x\"<br>\n     proof induction<br>\n       case (embed xs)<br>\n       from step[OF embed] show ?case by(auto)<br>\n     next<br>\n       case (step xs)<br>\n       then show ?case<br>\n         by(subst g.code)(auto intro: g_closure.step)<br>\n     qed<br>\n     then show ?case by blast<br>\n   qed<br>\nqed</p>\n<p>A few more comments:</p>\n<ol>\n<li>\n<p>This rule is somewhat weaker than P.coinduct, because I've omitted the case \"\\/ P xs'\", <br>\nwhich coinductive automatically adds. You can re-add it if you replace</p>\n<p>from * have \"g_closure X xs\" by(rule g_closure.intros)</p>\n</li>\n</ol>\n<p>with</p>\n<p>from * have \"g_closure (%xs. X xs \\/ P xs) xs\" by(rule g_closure.intros)</p>\n<p>and adjust the proof accordingly.</p>\n<ol start=\"2\">\n<li>\n<p>You may want to include SCons as another intro rule for g_closure such that SCons is <br>\ntreated as a friend. The problem there is that SCons does not in general preserve the <br>\ncoinductive predicate P, but only if the new head is non-negative. That means that you <br>\nneed a separate closure predicate for every coinductive predicate. This is also one of the <br>\nreasons why there's no support for user-defined coinductive predicates yet.</p>\n</li>\n<li>\n<p>If you use friends in the context of the constructor guard for your corecursive <br>\ndefinitions, then you want to have an even stronger coinduction rule, namely</p>\n</li>\n</ol>\n<p>lemma P_coinduct_upto_g:<br>\n   assumes *: \"X xs\"<br>\n   and step: \"⋀xs. X xs ⟹<br>\n    g_closure (%xs. ∃x xs'. xs = x ## xs' ∧ g_closure X xs' ∧ 0 ≤ x) xs\"<br>\n   shows \"P xs\"</p>\n<p>You can derive that one from mine above by another induction.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294700020,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178873
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi guys,</p>\n<p>Nice uniform description, Andreas!  We should have this for friends and other \"up-to\" operators at some point.</p>\n<p>(Coq has a tool for \"up-to\" coinduction called Paco -- they are ahead of us on coinduction but behind us corecursion.)</p>\n<p>Btw, here is my more ad hoc solution, which also illustrates the currently available friend structural corecursion -- theory also attached. Please pardon my unpolished scripts. Essentially, I follow \"s\" wherever it unfolds, which suggests a generalization.</p>\n<p>corec s_gen :: \"int ⇒ int stream\" where<br>\n  \"s_gen i = i ## g (s_gen i)\"</p>\n<p>inductive gs :: \"int stream  ⇒ bool\" where<br>\n  s_gen: \"i ≥ 0 ⟹ gs (s_gen i)\"<br>\n |g: \"gs xs ⟹ gs (g xs)\"</p>\n<p>(* Can use the existing structural friend corecursion here: *)<br>\nlemma s_gen_s: \"s = s_gen 0\"<br>\nproof-<br>\n  {fix xs ys assume \"xs = s ∧ ys = s_gen 0\" hence \"xs = ys\"<br>\n   apply (coinduct rule: s_gen.corec.coinduct)<br>\n   using s.unique s_gen.code s_gen.cong_refl by force<br>\n   }<br>\n  thus ?thesis by auto<br>\nqed</p>\n<p>lemma gs_shd:<br>\nassumes \"gs xs\" shows \"shd xs ≥ 0\"<br>\nusing assms apply (induct) by (subst s_gen.code) auto</p>\n<p>lemma gs_stl:<br>\nassumes \"gs xs\" shows \"gs (stl xs)\"<br>\nusing assms apply (induct)<br>\nby (subst s_gen.code) (auto intro: gs.intros)</p>\n<p>lemma P_gs: assumes \"gs xs\" shows \"P xs\"<br>\nusing assms proof (coinduct rule: P.coinduct)<br>\n  case (P xs)<br>\n  thus ?case proof cases<br>\n    case (s_gen i) thus ?thesis apply(intro exI[of _ \"g (s_gen i)\"] exI[of _ i])<br>\n    apply simp apply (subst s_gen.code) by (auto intro: gs.intros)<br>\n  next<br>\n    case (g xss) thus ?thesis<br>\n    apply(intro exI[of _ \"g (stl xss)\"] exI[of _ \"shd xss + 1\"])<br>\n    apply simp apply (subst g.code)<br>\n    by (auto intro: gs.intros  gs_stl simp: gs_shd)<br>\n  qed<br>\nqed</p>\n<p>lemma P_s: \"P s\"<br>\nby (simp add: s_gen s_gen_s  P_gs)</p>\n<p>Best,</p>\n<p>Andrei<br>\n<a href=\"/user_uploads/14278/uDM-DXI-0VdFzq1nrTrSPwof/Test.thy\">Test.thy</a></p>",
        "id": 294700065,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178896
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>thanks for the explanation. I think I now managed to define the closure <br>\nthat I need and prove the corresponding coinduct_upto rule.</p>\n<p>I noticed that during the proof of this rule, I essentially needed to <br>\nprove that all the friendly functions in the closure preserve the <br>\ninductive predicate, i.e. in terms of the example theory from earlier, I <br>\nneeded to prove some generalised version of \"P s ==&gt; P (g s)\".</p>\n<p>I then thought that once I have proven the coinduct_upto rule, I should <br>\nbe able to easily derive the fact \"P s ==&gt; P (g s)\" from that, but I <br>\ncannot see how. If I want to prove \"P s ==&gt; P (g s)\", do I really have <br>\nto do all the proof work again?</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294700087,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178904
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Manuel,</p>\n<p>You can use Andreas's rule to prove that fact for any xs:</p>\n<p>lemma P_s: assumes \"P xs\" shows \"P( g xs)\"<br>\nusing assms apply(coinduction arbitrary: xs rule: P_coinduct_upto_g)<br>\nby (smt P.cases embed g.code stream.sel(1) stream.sel(2))</p>\n<p>(and, of course, you can also use it to immediately prove P(s), your original motivation)</p>\n<p>Andrei</p>",
        "id": 294700155,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178920
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo Andrei,</p>\n<p>yes, but the new coinduction rule doesn't help with that; I can do the <br>\nsame proof using the old one:</p>\n<p>lemma P_s: assumes \"P xs\" shows \"P( g xs)\"<br>\nusing assms apply(coinduction arbitrary: xs)<br>\nby (smt P.cases embed g.code stream.sel(1) stream.sel(2))</p>\n<p>It is a bit difficult to illustrate my problem because my actual <br>\npredicate is quite complicated, but the above minimal example is so <br>\ntrivial that it is difficult to see what my point is.</p>\n<p>Anyway, I attached my theory. The relevant coinductive predicate is <br>\n\"is_expansion_aux\". The corresponding closure predicate is \"ms_closure\". <br>\nThe coinduct_upto theorem is \"is_expansion_aux_coinduct_upto\".</p>\n<p>Note that the coinduct_upto theorem contains a lengthy proof for the <br>\nms_closure_add case involving the friendly ms_plus_aux function. Later, <br>\nwhen I want to prove \"is_expansion_aux_add\", I have to do pretty much <br>\nthe same proof again. I wonder if there is some way to get rid of that <br>\nduplication.</p>\n<p>Cheers,</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/4H1EKuyeCV0zRyE0m8znDCSD/Bar.thy\">Bar.thy</a></p>",
        "id": 294700164,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178923
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nOK, let me see if I understand what you have here. I will speak in terms of sets since it will be nicer for the concepts involved here (but it works the same for predicates).</p>\n<p>Essentially, you have a set of operations on a type T. (In your case, T is 'a llist * (real-&gt;real) * scale.)</p>\n<p>For any set X on that type, let Cl(X) be the closure of X under the operations. (This is essentially your ms_closure).</p>\n<p>You also have a predicate (is_expansion_aux) defined coinductively,  i.e., as gfp F, where</p>\n<p>F : T set -&gt; T set is a monotonic operator.</p>\n<p>Your up-to coinduction rule says:</p>\n<p>(1) For all X, X &lt;= F (Cl X) implies X &lt;= gfp F.</p>\n<p>On the other hand, you prove that \"gfp F\" is closed under each of the operations, i.e.:</p>\n<p>(2) for each n-ary operation f and all x, if x is in (gfp F)^n then \"f x\" is in \"gfp F\".</p>\n<p>And the question is whether you can use aspects of (1) to prove (2), as opposed to replicating proofs -- is this correct?</p>\n<p>I don't think (2) follows from (1). However, for proving (1) you typically need something stronger, namely (something at least as strong as)</p>\n<p>the following \"distributive law\":</p>\n<p>(3) For all X, Cl (F X /\\ X) &lt;= F (Cl X)   (where /\\ is intersection)</p>\n<p>So if from (1) you can extract (3) as a lemma, you can reuse (3) for proving (2):</p>\n<p>(2) is immediately implied by Cl (gfp F) &lt;= gfp F, which in turn follows from (1) and (3): To prove</p>\n<p>Cl (gfp F) &lt;= gfp F, by (1) it suffices that Cl (gfp F) &lt;= F (Cl (Cl (gfp F))), i.e., Cl (gfp F) &lt;= F (Cl (gfp F)).</p>\n<p>The last is true by (3): Cl (gfp F) = Cl (F(gfp F) /\\ gfp F) &lt;= F(Cl (gfp F)).</p>\n<p>I preferred to use an algebraic language since I find it clearest. Of course, for your concrete problem</p>\n<p>you will not have to invoke F explicitly, but inline everything inside (co)induction.</p>\n<p>Andrei</p>",
        "id": 294700186,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178928
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI think this probably answers my question.</p>\n<p>I have decided not to look into this any further at the moment, seeing <br>\nas 1. it gives me a headache, 2. I have working proofs for now and 3. <br>\nI'm quite eager to continue my formalisation elsewhere.</p>\n<p>Thanks a lot for your help (also to Andreas). I still have no idea what <br>\nI actually did with these closures, but the proofs went relatively <br>\nsmoothly and everything works out.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294700252,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178953
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Manuel,</p>\n<p>I am sorry for the headache. But since you've come this far, I suggest giving the proof reuse idea another chance (at some point).  :-)</p>\n<p>Here is what my previously stated facts (1)-(3) become for your simple example (theory also attached). The only considered operation here is g, but the closure can potentially have any set of operations (including the constant s). Notice how (3) is the mother of all interesting facts -- and how everything else is absolute routine. Looking into what most people call \"the low level\", e.g., the operators behind (co)inductive definitions, can be rewarding for reducing proof complexity.</p>\n<p>theory Test<br>\nimports<br>\n  Main<br>\n  \"~~/src/HOL/Library/BNF_Corec\"<br>\n  \"~~/src/HOL/Library/Stream\"<br>\nbegin</p>\n<p>coinductive P :: \"int stream ? bool\" where<br>\n  \"P xs ? x ? 0 ? P (x ## xs)\"</p>\n<p>definition F :: \"(int stream ? bool) ? int stream ? bool\" where<br>\n\"F X xs ? ?xs' x. xs = x ## xs' ? X xs' ? x ? 0\"</p>\n<p>lemma F_mono: \"mono F\"<br>\nunfolding mono_def F_def by blast</p>\n<p>(* Note: *) lemma P: \"P = gfp F\"<br>\nunfolding HOL.nitpick_unfold F_def ..</p>\n<p>corec (friend) g :: \"int stream ? int stream\" where<br>\n  \"g x = (shd x + 1) ## g (stl x)\"</p>\n<p>inductive g_closure ::<br>\n\"(int stream ? bool) ? int stream ? bool\" for X where<br>\n embed: \"X xs ? g_closure X xs\"<br>\n|step: \"g_closure X xs ? g_closure X (g xs)\"</p>\n<p>(* The following three facts are all trivial: *)<br>\nlemma g_closure_mono:<br>\nassumes \"X ? Y\"<br>\nshows \"g_closure X ? g_closure Y\"<br>\nproof<br>\n  fix xs assume \"g_closure X xs\"<br>\n  thus \"g_closure Y xs\"<br>\n  using assms by (induct) (auto intro: g_closure.intros)<br>\nqed</p>\n<p>lemma g_closure_ext: \"X ? g_closure X\"<br>\n  by (auto intro: embed)</p>\n<p>lemma g_closure_idem: \"g_closure (g_closure X) = g_closure X\"<br>\nproof-<br>\n  {fix xs assume \"g_closure (g_closure X) xs\"<br>\n   hence \"g_closure X xs\"<br>\n     by (induction) (auto intro: g_closure.intros)<br>\n  }<br>\n  thus ?thesis<br>\n  by (simp add: antisym g_closure_ext predicate1I)<br>\nqed</p>\n<p>(* The <em>only</em> non-routine fact: *)<br>\nlemma 3: \"g_closure (F X) ? F (g_closure X)\"<br>\nproof clarify<br>\n  fix xs<br>\n  assume \"g_closure (F X) xs\"<br>\n  thus \"F (g_closure X) xs\"<br>\n  apply induct<br>\n  using F_def embed apply auto[1]<br>\n  by (smt F_def g.code g_closure.step stream.sel)<br>\nqed</p>\n<p>lemma 1: (* Follows routinely from 3 *)<br>\nassumes \"X ? F (g_closure X)\"<br>\nshows \"X ? gfp F\"<br>\nproof-<br>\n  note g_closure_mono[OF assms]<br>\n  also have \"g_closure (F (g_closure X)) ? F (g_closure (g_closure X))\"<br>\n  using 3 by simp<br>\n  also have \"... = F (g_closure X)\" unfolding g_closure_idem ..<br>\n  finally have \"g_closure X ? F (g_closure X)\" .<br>\n  with gfp_upperbound have \"g_closure X ? gfp F\" by auto<br>\n  thus ?thesis by(auto intro: g_closure.intros)<br>\nqed</p>\n<p>lemma P_coinduct_upto_g: (* is just the concrete version on 1 *)<br>\nassumes *: \"X xs\"<br>\nand step: \"?xs. X xs ? ?xs' x. xs = x ## xs' ? g_closure X xs' ? x ? 0\"<br>\nshows \"P xs\"<br>\n  using 1 assms unfolding P F_def using predicate1I by blast</p>\n<p>(* Follows routinely from 1 and 3: *)<br>\nlemma g_closure_P: \"g_closure P ? P\"<br>\nunfolding P apply(rule 1) unfolding g_closure_idem<br>\napply(subst gfp_unfold[OF F_mono]) using 3 .</p>\n<p>(* An immediate consequence of g_closure_P *)<br>\nlemma 2: \"P xs ? P (g xs)\"<br>\nusing g_closure_P by (auto intro: g_closure.intros)</p>\n<p>end</p>\n<p>Andrei<br>\n<a href=\"/user_uploads/14278/NJzXjAI57XqDkhSBHQd_RVzL/Test.thy\">Test.thy</a></p>",
        "id": 294700379,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661178983
    }
]