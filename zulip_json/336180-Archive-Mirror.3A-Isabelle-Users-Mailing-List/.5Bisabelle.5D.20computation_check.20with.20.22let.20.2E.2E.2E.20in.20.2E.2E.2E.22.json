[
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear code generation experts,</p>\n<p>I was wondering how can we computation_check a term with the form “let … in …”. Here is a small example: given a proposition that can be proved by evalutaion (i.e., by eval or by by code_simp),</p>\n<p>lemma \"let x ::int poly= [:2,3:] in [:1,2:] * x = [:2, 7, 6:]”</p>\n<p>I want to solve it using the computation_check mechanic. If I unfold the “let” constant first, the proposition can be proved like the following:</p>\n<p>ML ‹<br>\n  val holds = @{computation_check terms:<br>\n      Trueprop<br>\n      \"times::int poly ⇒ _\"<br>\n      \"HOL.equal ::int poly ⇒ _\"<br>\n      \"0 :: int poly\"<br>\n      \"pCons :: int ⇒ _\"<br>\n      \"0 :: int\" \"1 :: int\"<br>\n      Code_Target_Int.positive datatypes:num<br>\n  };<br>\n›</p>\n<p>lemma \"let x::int poly= [:2,3:] in [:1,2:] * x = [:2, 7, 6:]\"<br>\n  unfolding Let_def<br>\n  apply (tactic ‹<br>\n    CONVERSION (holds @{context}) 1<br>\n  ›)<br>\n  by (rule TrueI)</p>\n<p>However, without the unfolding (i.e., remove “unfolding Let_def”), \"apply (tactic ‹CONVERSION (holds@{context}) 1›)” will get stuck. I am not sure if there is any other constant I should add to “@{computation_check terms:<br>\n      ...<br>\n  };\"<br>\nto make the CONVERSION work.</p>\n<p>Thanks in advance,<br>\nWenda<br>\n<a href=\"/user_uploads/14278/yiFA8aff7eOQa8nMANAq2Lmn/signature.asc\">signature.asc</a></p>",
        "id": 294728029,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187032
    },
    {
        "content": "<p>From: \"Thiemann, Rene\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear Wenda,</p>\n<p>one might be tempted to just add “Let\" to the list of constants. However,<br>\nthis still won’t work since your input term contains an abstraction: </p>\n<p>Let [:2,3:] (% x. [:1,2:] * x = [:2, 7, 6:])</p>\n<p>And according to the code-generator manual (codegen.pdf), abstractions are not supported:</p>\n<p>From the documentation:<br>\n6.5 Pitfalls concerning input terms</p>\n<p>No abstractions. Only constants and applications are admissible as input; abstractions are not   possible. In theory, the compilation schema could be extended to cover abstractions also, but this would increase the trusted code base. If abstractions are required, they can always be eliminated by a dedicated preprocessing step, e.g. using combinatorial logic.</p>\n<p>So your unfolding of the “Let” constant is precisely such a required preprocessing step to get rid of the abstraction in this example.</p>\n<p>With best regards,<br>\nRené</p>",
        "id": 294728043,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187039
    },
    {
        "content": "<p>From: Wenda Li &lt;<a href=\"mailto:wl302@cam.ac.uk\">wl302@cam.ac.uk</a>&gt;<br>\nDear René,</p>\n<p>Thanks for your prompt reply and detailed explanation, which did clarify some of my confusions.</p>\n<p>Eliminating occurrences of “let … in …” when pre-prossessing is of course a viable way, but my main motivation for this “let … in …” expression is possible gain in performance: suppose we want to prove the following proposition</p>\n<p>lemma \"let x::int poly= smult 2 [:1,2:] in [:2,3:] * x * x  = [:8, 44, 80, 48:]”</p>\n<p>through evaluation. If we can directly evaluate \"let x::int poly= smult 2 [:1,2:] in [:2,3:] * x * x  = [:8, 44, 80, 48:]” in SML, we probably need to do the “smult” operation only once. However, with the “let” expression unfolded, what we need to evaluate is instead</p>\n<p>[:2, 3:] * smult 2 [:1, 2:] * smult 2 [:1, 2:] = [:8, 44, 80, 48:]</p>\n<p>, with which I guess the “smult” operation will be carried out twice.</p>\n<p>To sum up, my main purpose of “let … in …” is to eliminate repeated computations, and I hope to achieve this in the computation_check setups.</p>\n<p>Many thanks,<br>\nWenda<br>\n<a href=\"/user_uploads/14278/C74t_Ae12U1coDxQ3aYEQzCK/signature.asc\">signature.asc</a></p>",
        "id": 294728113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187063
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Wenda,</p>\n<p>a generic solution to the abstraction issue would be a preprocessor<br>\ntransforming abstractions into expressions in combinatorial logic.</p>\n<p>There is an implementation of this in meson:</p>\n<p>ML ‹<br>\n  Meson_Clausify.introduce_combinators_in_cterm @{context}<br>\n    @{cterm \"let (k::int) = 42 * 7 in k + k * 1705 - k ^ 2\"}<br>\n›</p>\n<p>Unfortunately, following the comments in the code, the implementation<br>\nseems suboptimal.</p>\n<p>I would appreciate if someone would use this as a base to provide a<br>\ngeneric preprocessor in Pure; this could then be an official part of<br>\ncomputations.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/o1ddohbOmyayAfGEsxO8tb_N/signature.asc\">signature.asc</a></p>",
        "id": 294728165,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661187088
    }
]