[
    {
        "content": "<p>From: Carsten Varming &lt;<a href=\"mailto:varming@cmu.edu\">varming@cmu.edu</a>&gt;<br>\nHi,</p>\n<p>Working with Isabelle data types I have come across some odd behavior.</p>\n<p>In the 21_Jun_2007 edition I get the following when stepping through the<br>\ncode below. Some of the behavior, but not all, is the same in the 2005<br>\nedition.</p>\n<p>The  data type declaration results in:</p>\n<h3>Theorem database already contains a copy of \"test.D.arity_size_*\"</h3>\n<p>The primitive recursive function definition results in:</p>\n<h3>No function definition for datatype \"List.list\"</h3>\n<h3>No function definition for datatype \"*\"</h3>\n<h3>No function definition for datatype \"*\"</h3>\n<p>And the case NE results in:<br>\n*** Illegal schematic variable(s) in case \"NE\"<br>\n*** At command \"case\".</p>\n<p>What am I experiencing here? Is this how it is suppose to be?</p>\n<p>theory test imports Main<br>\nbegin</p>\n<p>types 'a EE = \"nat  'a  nat\"</p>\n<p>datatype D =<br>\n      B<br>\n   |  Elem \"D EE\"<br>\n   |  NE \"(D list)\"</p>\n<p>consts E :: \"D  nat\"<br>\nprimrec<br>\n\"E B = 1\"<br>\n\"E (Elem e) = 2\"<br>\n\"E (NE e) = 3\"</p>\n<p>lemma \"E d &gt; 0\"<br>\nproof (induct d)<br>\ncase B thus ?case by auto next<br>\ncase NE</p>\n<p>Carsten</p>",
        "id": 294049832,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818962
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sat, 23 Jun 2007, Carsten Varming wrote:</p>\n<blockquote>\n<p>Working with Isabelle data types I have come across some odd behavior.</p>\n<p>In the 21_Jun_2007 edition I get the following when stepping through the<br>\ncode below.</p>\n</blockquote>\n<blockquote>\n<p>types 'a EE = \"nat ? 'a ? nat\"</p>\n<p>datatype D =<br>\n     B<br>\n  |  Elem \"D EE\"<br>\n  |  NE \"(D list)\"</p>\n<p>consts E :: \"D ? nat\"<br>\nprimrec<br>\n\"E B = 1\"<br>\n\"E (Elem e) = 2\"<br>\n\"E (NE e) = 3\"</p>\n<p>lemma \"E d &gt; 0\"<br>\nproof (induct d)<br>\ncase B thus ?case by auto next<br>\ncase NE</p>\n</blockquote>\n<blockquote>\n<p>And the case NE results in:<br>\n*** Illegal schematic variable(s) in case \"NE\"<br>\n*** At command \"case\".</p>\n<p>What am I experiencing here? Is this how it is suppose to be?</p>\n</blockquote>\n<p>Since D is a nested datatype, the induction principle works via several <br>\npredicates simultaneaously.  Just inspect the theorem list D.inducts to <br>\nsee how this looks internally.  An induction proof needs to follow that <br>\nstructure, by stating multiple goals and invoking theses rules properly <br>\n(which can be a bit tricky).  E.g. see the simple example in <br>\nHOL/Induct/Term.thy</p>\n<p>As your primrec function is not recursive anyhow, but uses plain case <br>\nanalyis only, you may finish the proof like this:</p>\n<p>lemma \"E d &gt; 0\"<br>\n  proof (cases d)<br>\n    case B then show ?thesis by simp<br>\n  next <br>\n    case Elem then show ?thesis by simp<br>\n  next<br>\n    case NE then show ?thesis by simp<br>\n  qed</p>\n<p>or even like this:</p>\n<p>lemma \"E d &gt; 0\"<br>\n    by (cases d) simp_all</p>\n<blockquote>\n<p>Some of the behavior, but not all, is the same in the 2005 edition.</p>\n</blockquote>\n<p>There have been some changes here concerning the \"induct\" method and <br>\ncorresponding rules produced by nested/mutual datatypes etc.  The NEWS <br>\nfile provides some further clues.</p>\n<p>Makarius</p>",
        "id": 294049877,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660818967
    }
]