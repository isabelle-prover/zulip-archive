[
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nHi!<br>\nI want to define a declaration attribute which works with the given <br>\ntheorem. I've already implemented this operation in the function foo :: <br>\nthm -&gt; local_theory -&gt; local_theory. Now I want to define a attribute by <br>\nthe function Thm.declaration_attribute :: (thm -&gt; Context.generic -&gt; <br>\nContext.generic) -&gt; Thm.attribute. Although I invested a non-trivial <br>\ntime to try to figure out how to go from Context.generic to local_theory <br>\nand back, I wasn't successful. Can anybody please help me and tell me <br>\nhow to implement the \"boilerplate\" function bar in <br>\n\"Thm.declaration_attribute bar\" such that bar is implemented in terms of <br>\nthe function foo?</p>\n<p>Thanks.</p>\n<p>Ondrej</p>",
        "id": 294153948,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850405
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nThe function Context.mapping is probably what you want.</p>\n<p>Lukas</p>",
        "id": 294153963,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850411
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nWhat is your local_theory -&gt; local_theory operation actually doing?  If it <br>\ndoes genuine specifications (like Local_Theory.define) than it cannot be a <br>\n\"declaration\" at the same time.</p>\n<p>A declaration is some kind of generic data update on a generic context. <br>\nIt needs to work in many situations, like the original local_theory <br>\ncontext of the user, its background theory, any other application context <br>\nafter interpretation, and more.</p>\n<p>This is also the reason, why such declarations need to fail gracefully, if <br>\nthey don't like their argument, and not prevent other declarations from <br>\nsucceeding that happened to be pulled-in by the same locale <br>\ninterpretation, for example.</p>\n<p>Makarius</p>",
        "id": 294153965,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850413
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nOn 03/21/2012 09:55 AM, Makarius wrote:</p>\n<blockquote>\n<p>On Tue, 20 Mar 2012, Ondřej Kunčar wrote:</p>\n<blockquote>\n<p>I want to define a declaration attribute which works with the given<br>\ntheorem. I've already implemented this operation in the function foo<br>\n:: thm -&gt; local_theory -&gt; local_theory. Now I want to define a<br>\nattribute by the function Thm.declaration_attribute :: (thm -&gt;<br>\nContext.generic -&gt; Context.generic) -&gt; Thm.attribute.</p>\n</blockquote>\n<p>What is your local_theory -&gt; local_theory operation actually doing? If<br>\nit does genuine specifications (like Local_Theory.define) than it cannot<br>\nbe a \"declaration\" at the same time.</p>\n</blockquote>\n<p>It changes theory data by Local_Theory.declaration and adds an attribute <br>\nby Local_Theory.note.</p>\n<blockquote>\n<p>A declaration is some kind of generic data update on a generic context.<br>\nIt needs to work in many situations, like the original local_theory<br>\ncontext of the user, its background theory, any other application<br>\ncontext after interpretation, and more.</p>\n<p>This is also the reason, why such declarations need to fail gracefully,<br>\nif they don't like their argument, and not prevent other declarations<br>\nfrom succeeding that happened to be pulled-in by the same locale<br>\ninterpretation, for example.</p>\n</blockquote>\n<p>OK, I got from your explanation that it's not possible. So now I defined <br>\na command instead of an attribute and it works. But to be honest, I <br>\ndon't understand why it is not possible. Your explanation seems to be <br>\ntoo much abstract (or dense) to me. Could you please explain it in a <br>\nmore detailed way or maybe use some concrete examples? I am not too much <br>\nfamiliar with this abstract infrastructure of Isabelle.</p>\n<p>Thanks.</p>\n<p>Ondrej</p>",
        "id": 294154012,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850438
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 21 Mar 2012, Ondřej Kunčar wrote:</p>\n<blockquote>\n<p>On 03/21/2012 09:55 AM, Makarius wrote:</p>\n<p>On Tue, 20 Mar 2012, Ondřej Kunčar wrote:</p>\n<blockquote>\n<blockquote>\n<p>I want to define a declaration attribute which works with the given<br>\ntheorem. I've already implemented this operation in the function foo<br>\n:: thm -&gt; local_theory -&gt; local_theory. Now I want to define a<br>\nattribute by the function Thm.declaration_attribute :: (thm -&gt;<br>\nContext.generic -&gt; Context.generic) -&gt; Thm.attribute.</p>\n</blockquote>\n<p>What is your local_theory -&gt; local_theory operation actually doing? If<br>\nit does genuine specifications (like Local_Theory.define) than it cannot<br>\nbe a \"declaration\" at the same time.</p>\n</blockquote>\n<p>It changes theory data by Local_Theory.declaration and adds an attribute by <br>\nLocal_Theory.note.</p>\n</blockquote>\n<p>This sounds like you are doing plain declarations of context data, but it <br>\nhappens to be wrapped up as local_theory specification elements.  By using <br>\nthe declaration functions directly, you should be able to present the <br>\ncomposition as attribute.  Normally, the Isabelle components in question <br>\nshould export declarations functions along with the attributes, if not one <br>\ncan always recover the declaration part of an attribute by a bit of <br>\ntrickery.</p>\n<p>It depends on the application how things are best presented to the user: <br>\nAttributes are more flexible, because they can be used in many situations <br>\n(specifications, proofs, locales, classes atc.), but sometimes it is more <br>\nappropriate to wrap things up as standalone definitional package (like <br>\n'function' or 'inductive').</p>\n<blockquote>\n<blockquote>\n<p>A declaration is some kind of generic data update on a generic context.<br>\nIt needs to work in many situations, like the original local_theory<br>\ncontext of the user, its background theory, any other application<br>\ncontext after interpretation, and more.</p>\n<p>This is also the reason, why such declarations need to fail gracefully,<br>\nif they don't like their argument, and not prevent other declarations<br>\nfrom succeeding that happened to be pulled-in by the same locale<br>\ninterpretation, for example.</p>\n</blockquote>\n<p>OK, I got from your explanation that it's not possible. So now I defined <br>\na command instead of an attribute and it works. But to be honest, I <br>\ndon't understand why it is not possible.</p>\n</blockquote>\n<p>I see a tendency of \"negation by failure\" reasoning here.  A certain <br>\nattempt did not work, but many more possiblities were not even considered <br>\nyet.  Usually the art is to find the one \"canonical way\" in a jungle of <br>\ndead ends.  How much energy is invested on that depends on the <br>\napplication, i.e. if it is just some experiment or something exposed to <br>\nmany users eventually.</p>\n<blockquote>\n<p>Your explanation seems to be too much abstract (or dense) to me. Could <br>\nyou please explain it in a more detailed way or maybe use some concrete <br>\nexamples?</p>\n</blockquote>\n<p>If you show your concrete sources, I can comment on the approach <br>\nconcretely.</p>\n<p>Further general explanations are in the Isabelle/Isar Implementation <br>\nmanual.  Every time I revisit it to continue working on the text, I am <br>\nsurprised how much is mentioned there already, although it is definitely <br>\ndense.</p>\n<p>Makarius</p>",
        "id": 294154070,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850462
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nMakarius may need several rounds of refinement to answer this question <br>\nin a concrete way. Let me try to speed up the process.</p>\n<p>I think that what is confusing you is that Context.generic provides a <br>\nsecond layer of generic operation over theories, locales and structured <br>\nproofs, when it looks that can already be done with local_theory.</p>\n<p>Things are more complex than they seem. If one is inside a structured <br>\nproof inside a locale inside a theory, all three context objects exist <br>\nat once, in an arrangement that has been described as the Haftmann/Wenzel<br>\nsandwich. Some operations are run on the topmost layer and then filter <br>\ndown as the proof/locale closes and merges. Some operations, such as <br>\nattributes, get run simultaneously on multiple layers. Attributes may <br>\nalso be run when locales are interpreted and when they are reopened, <br>\nthough I think the details of this have changed recently. This was <br>\ndiscussed in the past on this list <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2012-March/msg00028.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2012-March/msg00028.html</a></p>\n<p>This is what Makarius is getting at when he says attributes should try <br>\nto run as generally as possible: they may need to run in all kinds of <br>\ncircumstances and failure may derail later operations.</p>\n<p>As for local_theory, it looks like you can define all your functionality <br>\nas a local_theory transformer, and run it on theories by using <br>\nTheory_Target.init and Local_Theory.exit_global. If I understand <br>\ncorrectly, this should not be expected to work for all kinds of changes, <br>\nthough it seems to work for adding notes (theorem names) and constants.</p>\n<p>In conclusion: the obvious thing to do in an attribute is adjust data <br>\nwith the put/map operation of any data store derived from Generic_Data. <br>\nThis may in fact be what you want to do. You can also transform the <br>\ntheorem locally. Anything else requires a pretty deep understanding of <br>\nwhat is going on.</p>\n<p>This is just my understanding, I haven't attempted to read much of the <br>\ndocumentation. I look forward to people correcting what I got wrong.</p>\n<p>Yours,<br>\n     Thomas.</p>",
        "id": 294154089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850470
    }
]