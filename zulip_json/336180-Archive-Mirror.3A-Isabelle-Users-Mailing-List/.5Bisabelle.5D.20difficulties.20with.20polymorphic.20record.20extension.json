[
    {
        "content": "<p>From: \"Elsa L. Gunter\" &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nDear Isabelle community,</p>\n<p>I am having difficulty building records they way I want.  I may well<br>\nhave forgotten something, but the behavior I am see with extending<br>\npolymorphic records is surprising to me.  First I define:</p>\n<p>record ('instr,'dir) generalized_control_flow_graph_context =<br>\n   Instructions :: \"'instr set\"<br>\n   Directions :: \"'dir set\"<br>\n   edgeTyping :: \"'instr ⇒ ('dir ⇒ nat)set\"</p>\n<p>If I then enter</p>\n<p>declare [[show_types = true]]<br>\nterm \"⦇Instructions =a,<br>\n   Directions = b,<br>\n   edgeTyping =c⦈\"</p>\n<p>I get</p>\n<p>\"⦇Instructions = a::'a set, Directions = b::'b set,<br>\n     edgeTyping = c::'a ⇒ ('b ⇒ nat) set⦈\"<br>\n   :: \"('a, 'b) generalized_control_flow_graph_context\"</p>\n<p>as output, which is what I would expect.  Now I wish to extend this<br>\nrecord to a new record with additional fields, introducing some new<br>\ntype variables, but also sharing the type variables already used in<br>\ngeneralized_control_flow_graph_context.  So I enter the following:</p>\n<p>record ('instr,'dir,'node) generalized_control_flow_graph =<br>\n        \"('instr,'dir) generalized_control_flow_graph_context\" +<br>\n   Nodes :: \"'node set\"<br>\n   Edges :: \"'node ⇒ ('dir × 'node)set\"<br>\n   labeling :: \"'node ⇒ 'instr\"</p>\n<p>The intent is that the types of 'dir and 'instr are shared between<br>\nInstructions, Directions, edgeTyping, Edges and labeling.  When I<br>\ncreate at element of this extended record type as follows I get the<br>\ngiven results:</p>\n<p>term \"⦇Instructions =a,<br>\n   Directions = b,<br>\n   edgeTyping =c,<br>\n    Nodes = d,<br>\n   Edges = e,<br>\n   labeling = f⦈\"</p>\n<p>\"⦇Instructions = a::'a set, Directions = b::'b set,<br>\n     edgeTyping = c::'a ⇒ ('b ⇒ nat) set, Nodes = d::'e set,<br>\n     Edges = e::'e ⇒ ('d × 'e) set, labeling = f::'e ⇒ 'c⦈\"<br>\n   :: \"⦇Instructions :: 'a set, Directions :: 'b set,<br>\n          edgeTyping :: 'a ⇒ ('b ⇒ nat) set, Nodes :: 'e set,<br>\n          Edges :: 'e ⇒ ('d × 'e) set, labeling :: 'e ⇒ 'c⦈\"</p>\n<p>Note that the types of Nodes, Edges, labeling are completely<br>\nindependent of those for Instructions, Directions and edgeTyping,<br>\ndespite the same types being used in both parts of the<br>\ngeneralized_control_flow_graph record definition.  I know each type<br>\ngets separately parsed separately, but it seems plausible that the<br>\nwhole record extension package could infer that the types used in one<br>\npart of the definition where to be the same as those of the same name<br>\nin other parts.  These extra degrees of freedom present problems where<br>\ntype variables can end up buried on the right-hand side of a definition<br>\nwithout being captured by the left hand side, where they would if the<br>\ndesired type constraints had been enforced.  I have found a number of<br>\ncrufty ways around the difficulty, but I would appreciate help with<br>\nlearning how to do this record extension definition correctly. I've<br>\nnot been able to find it in the documentation.</p>\n<p>---Elsa</p>",
        "id": 294678130,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175698
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Elsa,</p>\n<p>The excessive polymorphism is due to the way record extensions are constructed. Input <br>\nsyntax like (|Instructions = a, Directions = b, edgeTyping = c|) are translated into the <br>\nrecord construction functions XXX_ext, i.e., \"generalized_control_flow_graph_context_ext\" <br>\nand \"generalized_control_flow_graph_ext\". Each of these takes as the last argument what is <br>\nto be put into the extension slot. Hence,</p>\n<p>⦇Instructions =a,<br>\n    Directions = b,<br>\n    edgeTyping =c,<br>\n    Nodes = d,<br>\n    Edges = e,<br>\n    labeling = f⦈</p>\n<p>is translated to</p>\n<p>generalized_control_flow_graph_context_ext a b c<br>\n     (generalized_control_flow_graph_ext d e f ())</p>\n<p>and it is this term on which type inference works. After the translation, the connection <br>\nbetween the type variables in generalized_control_flow_graph_context_ext and <br>\ngeneralized_control_flow_graph_ext is lost. So there is no way for the type inference <br>\nalgorithm to see that you want the type variables to be instantiated to the same. As the <br>\ntranslation happens before type inference, it is not (easily) possible to add sensible <br>\ntype annotations, either. In summary, you need some sort of external enforcement that will <br>\nshow up in your input syntax.</p>\n<p>I do not know what you came up with, but the simplest thing that comes to my mind is to <br>\nuse a cast operator as an abbreviation. Here is a small example:</p>\n<p>record 'a foo = foo :: 'a<br>\n   record 'a bar = \"'a foo\" + bar :: 'a<br>\n   abbreviation (input) BAR :: \"'a bar ⇒ 'a bar\" where \"BAR x ≡ x\"<br>\n   term \"BAR ⦇foo = 0, bar = 0⦈\"</p>\n<p>As BAR is an input abbreviation, it really only shows up in the formulas you write, but it <br>\nnever shows up in any theorem, so it does not affect your reasoning.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294678146,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175702
    },
    {
        "content": "<p>From: \"Elsa L. Gunter\" &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nThank you Andreas, both for reminding me of what I should have known <br>\n(and probably once did) about record extension, and for the suggested fix.</p>\n<p>---Elsa</p>",
        "id": 294680724,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661176629
    }
]