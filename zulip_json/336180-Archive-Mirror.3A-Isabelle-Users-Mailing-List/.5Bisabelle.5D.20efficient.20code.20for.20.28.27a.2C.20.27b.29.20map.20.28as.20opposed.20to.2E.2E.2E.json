[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear all (especially Andreas ;)),</p>\n<p>is it possible to automatically get efficient code when code generating <br>\na function involving the \"('a, 'b) map\" type (i.e., \"'a =&gt; 'b option\").</p>\n<p>If I import AFP/Containers I can have this for \"('a, 'b) mapping\" (which <br>\nis a type-copy of \"('a, 'b) map\").</p>\n<p>But in the actual formalization \"('a, 'b) map\" is more convenient to use <br>\nsince we have nice syntax like \"m x\" for lookup and \"m (x |-&gt; t)\" for <br>\nupdate.</p>\n<p>Since according to the user guide the above is possible w.r.t. \"'a set\", <br>\nI was wondering what the obstacle is for \"('a, 'b) map\" (or maybe I just <br>\nmisunderstood something).</p>\n<p>More concretely, what is your advice for a function like</p>\n<p>match_list ::<br>\n     (('f, 'v) term * ('f, 'v) term) list =&gt;<br>\n       ('v =&gt; ('f, 'v) term option) =&gt; ('f, 'v) subst</p>\n<p>where \"match_list E Map.empty\" gives a matcher for all equations in \"E\". <br>\nWould you change this to use \"('v, ('f, 'v) term) mapping\" instead, or <br>\nis there a way to get efficient code as it is? Thanks in advance!</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294251983,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911103
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHi Christian.</p>\n<p>The problem is, that ('a,'b) map is just syntactic sugar for the type <br>\n'a =&gt; 'b option. The code-generator replacement of types by efficient<br>\nimplementations only works for types represented by a single<br>\ntype-constant (like ('a,'b) mapping or 'a set).</p>\n<p>Moreover, note that, in general, you do not want to translate all<br>\noccurences of \"'a -&gt; 'b option\" by a map implementation, as there are<br>\nalso functions that return option-values, which are intended to be<br>\ntranslated as functions.</p>\n<p>The automatic refinement framework [1] tries to tackle this problem,<br>\nhowever, it has to be employed manually before code generation, and<br>\nusually requires some setup overhead.</p>\n<p>In order to use Containers, I believe that you should transform your<br>\nfunctions to use mapping. Maybe the transfer+lifting package of Brian<br>\nand Ondra may help you to automate this task.</p>\n<p>Best,<br>\n  Peter</p>\n<p>[1]: Peter Lammich, Automatic Data Refinement, Proc. of ITP 2013</p>",
        "id": 294251997,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911109
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nAh, right. I somehow repressed that \"'a set\" is no longer a type <br>\nsynonym, which was the only reason why I was wondering about \"('a, 'b) <br>\nmap\". Now everything is clear (including that my question was stupid ;)).</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294252013,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911115
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Christian,</p>\n<p>The difference between 'a set and ('a, 'b) map is that set is a single type constructor of <br>\nits own, whereas map is just a type synonym for a compount type expression. Unfortunately, <br>\nthe code generator supports only data refinement for single type constructors, on which <br>\nContainers relies. So there is no way to get this to work directly.</p>\n<p>Therefore, you have to switch to some other type. There are two options:</p>\n<ol>\n<li>\n<p>Use ('a, 'b) mapping. I recommend that you only use it for code generation, the mapping <br>\ntype in its current state is not suitable for proving lots of stuff. In my AFP entry <br>\nNative Word (in AFP-devel: <a href=\"http://afp.sourceforge.net/devel-entries/Native_Word.shtml\">http://afp.sourceforge.net/devel-entries/Native_Word.shtml</a>), <br>\nthe userguide describes how one can easily deal with such type copies thanks to <br>\ntransfer/lifting. I will see whether I can make it work for mapping, too.</p>\n</li>\n<li>\n<p>Peter Lammics's Autoref tool (also in AFP-devel: <br>\n<a href=\"http://afp.sourceforge.net/devel-entries/Automatic_Refinement.shtml\">http://afp.sourceforge.net/devel-entries/Automatic_Refinement.shtml</a>) also provides some <br>\nautomation to specialise maps to efficient data structures. Internally, it produces copies <br>\nof your functions that directly operate on the implementation type (like a RBT).</p>\n</li>\n</ol>\n<p>Best,<br>\nAndreas</p>",
        "id": 294252061,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911122
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nHi Christian,<br>\nPeter has already explained the situation in general. I just want to add <br>\nthat Lifting/Transfer can indeed help you a bit in moving your <br>\nspecification from 'a =&gt; 'b option to ('a, 'b) mapping. Please see <br>\nChapter 4 in our ITP 2013 paper: Data Refinement in Isabelle/HOL.</p>\n<p>Best,<br>\nOndrej</p>",
        "id": 294252083,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911128
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear all,</p>\n<p>Thanks for the useful answers. For my concrete case: does <br>\n\"lift_definition\" also work for recursive functions (whith \"match_list\" <br>\nis). With my first attempt using \"lift_definition\" I just got a <br>\n\"wrapper\" around the recursive function that changed the type, which <br>\ndoesn't solve the efficiency problem.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294252145,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911152
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Christian,</p>\n<p>yes, it can. I wrote some pre- and postprocessing to make the Transfer.transferred work <br>\nbetter with maps (theory attached, works with 2013-1-RC3 and Containers in AFP/devel). <br>\nThere's a small example. Can you check whether that works for you in general? If so, it <br>\nmight be a good idea to add this to Containers or even HOL/Library.</p>\n<p>Best,<br>\nAndreas<br>\n<a href=\"/user_uploads/14278/Yfc3dFV-1ToGsjkw7EF3YBk-/Map_To_Mapping.thy\">Map_To_Mapping.thy</a></p>",
        "id": 294252166,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911159
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nlift_definition gives you a logical definition of the new function. But <br>\nyou have to still provide a code equation for this new function (as it <br>\nis described in the paper I've already referred to).<br>\nThen you have two options:<br>\nA) state the new code equation by yourself and prove it by transfer <br>\n(Isabelle 2013).<br>\nB) Since Isabelle 2013-1, there is a limited support for transferring <br>\n\"in the other direction\" by the attribute Transfer.transferred. The <br>\nproblem in this solution is that the raw terms for map operations are <br>\nvery general terms like term application (for map lookup) and so on. <br>\nAndreas showed us in his file a trick that actually Peter Lammich does <br>\nin his autoref framework, namely rewriting these term applications to an <br>\nad-hoc constants by simplifier and then using Transfer.transferred. The <br>\nquestion is, of course how, much this solution scale. I am curious to <br>\nhear some report about that from you.</p>\n<p>Ondrej</p>",
        "id": 294252180,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911164
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Andreas and Ondřej,</p>\n<p>here is my \"report\" ;) (I did however not systematically investigate my <br>\noptions, but stopped immediately after having the first working solution).</p>\n<p>For ease of reference please consult the attached theory file <br>\n(Matching_Test) which is (together with Andreas' Map_To_Mapping) <br>\nself-contained but is only concerned with code generation; thus a <br>\n\"sorry\" and no soundness or completeness statements for matching (but <br>\nthis all exists of course on my local machine as part of IsaFoR).</p>\n<p>A short explanation of the used functions and what I intended to do with <br>\nthem:</p>\n<p>- match_term_list: matching on lists of term pairs, but with an <br>\naccumulator that builds the result; thus depending on the initial value <br>\nof this accumulator this might not really compute a matcher</p>\n<p>- match_list: the above where the accumulator is initialized to the <br>\nempty map (thus it really is matching on the given list of term pairs)</p>\n<p>- for code generation only \"match_list\" is important (since <br>\n\"match_term_list\" is just an auxiliary function that is not used <br>\ndirectly); hence my goal was to get efficient code for \"match_list\"</p>\n<p>- first get an efficient variant of \"match_term_list\" (called <br>\n\"match_term_list'\" and then prove a code equation which replaces <br>\n\"match_term_list\" inside the definition of \"match_list\" by <br>\n\"match_term_list'\" (together with necessary glue); what I wanted to <br>\navoid at all cost, was to have to create a duplicate of \"match_list\" for <br>\ncode generation (since than I would also have to \"transfer\" all existing <br>\nproofs to this constant)</p>\n<p>Since I'm a newbie w.r.t. to lifting/transfer (well, I've read about it, <br>\nbut never used it myself) I can only give some comments (which might be <br>\ntrivial):</p>\n<p>Andreas' \"transferred_mapping\" attribute worked \"as advertised\" in order <br>\nto get code equations for \"match_term_list'\"!</p>\n<p>Afterwards I manually proved that</p>\n<p>match_term_list E σ =<br>\n<a href=\"http://Option.map\">Option.map</a> Mapping.lookup (match_term_list' E (Mapping σ))</p>\n<p>(maybe this could also be done automatically?) and finally the code <br>\nequation for \"match_list\"</p>\n<p>match_list E =<br>\n<a href=\"http://Option.map\">Option.map</a> (subst_of_map undefined ∘ Mapping.lookup)<br>\n       (match_term_list' E Mapping.empty)</p>\n<p>I could have stopped after the first equation, but in the generated code <br>\n\"Mapping sigma\" was used to initialize \"match_term_list\" which I <br>\nunderstood to mean that the generated code would actually <em>not</em> use an <br>\nefficient version of maps, since maps are represented by an AST</p>\n<p>data Mapping a b = Assoc_List_Mapping (DAList.Alist a b)<br>\n   | RBT_Mapping (RBT_Mapping2.Mapping_rbt a b) | Mapping (a -&gt; Maybe b);</p>\n<p>cheers</p>\n<p>chris<br>\n<a href=\"/user_uploads/14278/0aCtt7eogO9Kaw89FgNuHSlW/Matching_Test.thy\">Matching_Test.thy</a></p>",
        "id": 294252198,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911173
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<p>once there has been the rough idea to reformulate Map.thy using a<br>\ndedicated type like in Mapping.thy.  The user-visible difference would<br>\nbe that element lookups need a dedicated function</p>\n<p>lookup :: ('a, 'b) mapping =&gt; 'a =&gt; 'b option</p>\n<p>But this could be inserted implicitly by coercions also whenever a ('a,<br>\n'b) mapping it used in place of a function.</p>\n<p>I did not pursue this further, since my impression was that (unlike<br>\nsets) the syntax in Map.thy is not so pervasively common, so<br>\nspecification requiring executable data structures can just be based on<br>\nMapping.thy.  Considering your statement about »easy going« of proofs in<br>\nMapping.thy, maybe we have to rethink about it.  Or is it just that<br>\nlemmas / automation are missing?</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/KTannoENRzyjHvVqPwTu9Ojb/signature.asc\">signature.asc</a></p>",
        "id": 294252293,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911220
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>I haven't investigated in detail what exactly is missing. Whenever I used mapping, I had <br>\ncode generation in mind, so my thinking might be a bit biased. What I particularly like <br>\nabout 'a =&gt; 'b option is no clutter: I can build new maps just from lambda abstraction and <br>\nthe other usual HOL constants (if/case/Some/Option.map/Option.bind/...), there's no need <br>\nfor coercing between ('a, 'b) mapping and 'a =&gt; 'b option. Therefore, I don't have to <br>\nworry where coercions are automatically inserted. Nor do I care about what the simplifer <br>\ndoes to these coercions when. (By the way, if I enable automatic coercions, the error <br>\nmessages for ill-typed terms sometimes do not help to identify what's wrong at all, in <br>\nparticular if I got the number of parameters of a function wrong.) Of course, these maps <br>\nare not (efficiently) executable, but I usually don't care in such situations: I just use <br>\nthem inside proofs, e.g., as a witness to an existential quantifier. In proofs, I use such <br>\nmaps as arguments to functions for which I later generate code -- although not for these <br>\nparameters.</p>\n<p>There are certainly functions, lemmas and automation missing. When I last looked at <br>\nMapping (which is already quite some time ago), I had the impression that everything is <br>\nstill centered around code generation, but inside a proof, I usually don't care about code <br>\ngeneration, I just want to quickly get the proof done. Although I must say that I know one <br>\ncase where automation for ('a, 'b) mapping can in principle be better than for 'a =&gt; 'b <br>\noption: Element lookup is just function application and the simplifier does not do well <br>\nfor equation of the form \"g (f x) = ...\" where f is a free variable. With mapping, this <br>\ncorresponding equation \"g (lookup f x) = ...\" works much better.</p>\n<p>Andreas</p>",
        "id": 294252425,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911263
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Christian,</p>\n<p>Thanks for testing. I have a few suggestions for your example. You find attached the <br>\nupdated theory file.</p>\n<ol>\n<li>\n<p>Mapping_match_term_list:<br>\nYou can prove this lemma without induction: by transfer simp suffices if the simplifier <br>\nalready knows option_map_id.</p>\n</li>\n<li>\n<p>You can also use [transferred_mapping] to replace constants with lifted constants in <br>\ncode equations of other constants, not just to transfer the code equations of lifted <br>\nconstants. Concretely, if you also lift subst_of_map, then you get all your code equations <br>\nautomatically.</p>\n</li>\n</ol>\n<p>However, [transferred_mapping] requires that all type variables in key/value positions <br>\nhave sort type. Your definition theorem of subst_of_map does not adhere to that because <br>\nyou have not specified the type of subst_of_map. Therefore, I have added the type signature.</p>\n<blockquote>\n<p>I could have stopped after the first equation, but in the generated code \"Mapping sigma\"<br>\nwas used to initialize \"match_term_list\" which I understood to mean that the generated<br>\ncode would actually <em>not</em> use an efficient version of maps, since maps are represented by<br>\nan AST</p>\n<p>data Mapping a b = Assoc_List_Mapping (DAList.Alist a b)<br>\n   | RBT_Mapping (RBT_Mapping2.Mapping_rbt a b) | Mapping (a -&gt; Maybe b);<br>\nYes, that's right. If you use the constant Mapping (from theory Mapping) in code equations <br>\nexplicitly, then you specify that this map should be implemented with closures, i.e., you <br>\noverride the mechanism that automatically selects a suitable implementation.</p>\n</blockquote>\n<p>Best,<br>\nAndreas<br>\n<a href=\"/user_uploads/14278/dpvjVlVmtDGtXTJuMbZaNtGs/Matching_Test.thy\">Matching_Test.thy</a></p>",
        "id": 294252447,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911269
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nConcerning Mapping.mapping xor Mapping.lookup as coercion: this lies <br>\noutside of the fragment for which we guarantee completenes (=if a term <br>\ncan be coerced it will be coerced). In such cases a very simple <br>\nincomplete coercion insertion algorithm is used. E.g. in the following <br>\nexample only one of the two terms will be coerced.</p>\n<p>declare [[coercion_enabled]]<br>\ndeclare [[coercion Mapping.Mapping]]<br>\nterm \"f = Mapping.lookup f\"<br>\nterm \"Mapping.lookup f = f\"</p>\n<p>So even more care is required than in the complete fragment.</p>\n<p>Concerning the error messages: at least you should always get strictly <br>\nmore information than without coercion inference (i.e. the error message <br>\nof the standard type-inference will always come first, only then <br>\ncoercion inference will give additional hints). Of course, the <br>\nadditional information can be distracting---maybe it should be hidden in <br>\na popup or so). The problem of helpful type inference error messages is <br>\nnot trivial, and coercions don't make it easier.</p>\n<p>Dmitriy</p>",
        "id": 294252464,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911275
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nConcerning the \"popup or so\" you could experiment with Pretty.text_fold <br>\n(although the fold will be always open by default in currently published <br>\nIsabelle versions).</p>\n<p>The Isabelle Pretty module started out as implementation of Oppen-style <br>\npretty-printing by Larry Paulson, but it has acquired more and more <br>\nlogical markup facilities over the years (e.g. Pretty.markup, <br>\nPretty.paragraph, Pretty.item).</p>\n<p>The full potential of this is still unused.  (Display of advanced markup <br>\nrequires a proper PIDE front-end.)</p>\n<p>Makarius</p>",
        "id": 294256339,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912741
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nThanks for the hint. There result of my experiments are in the <br>\ndevelopment repository (2bbcbf8cf47e).</p>\n<p>It would be nice if the default status (folded or not) could be <br>\nindicated by a parameter to Pretty.text_fold (and respected by the <br>\nfront-end).</p>\n<p>Dmitriy</p>",
        "id": 294256697,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912851
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI will take a look soon, and continue this thread on isabelle-dev.</p>\n<p>Makarius</p>",
        "id": 294256720,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912857
    }
]