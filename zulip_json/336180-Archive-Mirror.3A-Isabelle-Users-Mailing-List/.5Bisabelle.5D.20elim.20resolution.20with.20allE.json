[
    {
        "content": "<p>From: Fritz Lehmann &lt;<a href=\"mailto:fritz.random.lehmann@googlemail.com\">fritz.random.lehmann@googlemail.com</a>&gt;<br>\nHi,</p>\n<p>in the following proof I try to understand the elim resolution with allE:<br>\n--<br>\nGoal \"EX y. ALL x. (P(y) --&gt; P(x))\";<br>\nbr exCI 1;<br>\nbr allI 1;</p>\n<blockquote>\n<p>br impI 1;<br>\nLevel 3 (1 subgoal)<br>\nEX y. ALL x. P(y) --&gt; P(x)</p>\n</blockquote>\n<ol>\n<li>\n<p>!!x. [| ALL y. ~ (ALL x. P(y) --&gt; P(x)); P(?a) |] ==&gt; P(x)<br>\nval it = () : unit</p>\n<blockquote>\n<p>be allE 1;<br>\nLevel 4 (1 subgoal)<br>\nEX y. ALL x. P(y) --&gt; P(x)</p>\n</blockquote>\n</li>\n<li>\n<p>!!x. [| P(?a); ~ (ALL xa. P(?y3(x)) --&gt; P(xa)) |] ==&gt; P(x)<br>\nval it = () : unit</p>\n</li>\n</ol>\n<p>be (allI RSN (2,swap)) 1;<br>\nbr impI 1;<br>\nbe notE 1;<br>\nba 1;<br>\n--</p>\n<p>but I'm not sure about the several steps.</p>\n<p>allE: [| ALL x. ?P(x); ?P(?x) ==&gt; ?R |] ==&gt; ?R</p>\n<p>Don't care about name clashes:<br>\n[| ALL z. ?P1(z); ?P1(?z) ==&gt; ?R1 |] ==&gt; ?R1</p>\n<p>Lifting over parameters:<br>\n[| !!x. ALL z. ?P2(x,z); !!x. ?P2(x,?z1(x)) ==&gt; ?R2(x) |] ==&gt; !!x. ?R2(x)</p>\n<p>Lifting over assumptions:<br>\n[| !!x. ?K ==&gt; ALL z. ?P2(x,z); !!x. ?K ==&gt; (?P2(x,?z1(x)) ==&gt; ?R2(x))<br>\n|] ==&gt; !!x. ?K ==&gt; ?R2(x)</p>\n<p>(Elim-)Resolution with !!x. [| ALL y. ~ (ALL x. P(y) --&gt; P(x)); P(?a)<br>\n|] ==&gt; P(x):<br>\n?K  := [| ALL y. ~ (ALL x. P(y) --&gt; P(x)); P(?a) |]<br>\n?R2 := %x. P(x)</p>\n<ol>\n<li>!!x. [| ALL y. ~ (ALL x. P(y) --&gt; P(x)); P(?a) |] ==&gt; ALL z. ?P2(x,z)</li>\n<li>!!x. [| ALL y. ~ (ALL x. P(y) --&gt; P(x)); P(?a); ?P2(x,?z1(x)) |] ==&gt; P(x)</li>\n</ol>\n<p>By assumption 1 (because of elim):<br>\nz := y<br>\n?P2 := %x z. ~(ALL x. P(z) --&gt; P(x))</p>\n<p>Remove 1., remove \"ALL y. ~ (ALL x. P(y) --&gt; P(x));\" from 2.:</p>\n<ol>\n<li>!!x. [| P(?a); ~ (ALL x. P(?z1(x)) --&gt; P(x)) |] ==&gt; P(x)</li>\n</ol>\n<p>Looks similar to:</p>\n<ol>\n<li>!!x. [| P(?a); ~ (ALL xa. P(?y3(x)) --&gt; P(xa)) |] ==&gt; P(x)</li>\n</ol>\n<p>but where comes the xa from (lifting over parameters?) and could you<br>\nfind other errors in the step by step calculation?</p>\n<p>Kind regards,</p>\n<p>Fritz.</p>",
        "id": 294058536,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822582
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nApplying ?P2 to the local x and ?z1(x) results in beta reduction, i.e. <br>\ncapture-avoiding substitution: the proper result is ~ (ALL xa. P(?y3(x)) <br>\n--&gt; P(xa)).  In the first version ~ (ALL x. P(?z1(x)) --&gt; P(x)) the x in<br>\n?z1(x) got captured by the inner ALL x quantifier.</p>\n<p>BTW, your script uses rather ancient ML interfaces of Isabelle, which are <br>\nessentially obsolete (it seems you have studied the old Introduction to <br>\nIsabelle Manual).  Here is a version using contempory Isabelle/Isar <br>\nsyntax, also in HOL which is more convenient to write, with less <br>\nparentheses:</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>lemma all_elim: \"ALL z. B z ==&gt; (B b ==&gt; C) ==&gt; C\" by blast</p>\n<p>lemma \"EX y. ALL x. P y --&gt; P x\"<br>\n  apply (rule exCI)<br>\n  apply (rule allI)<br>\n  apply (rule impI)<br>\n  ML {* bind_thm (\"r\", Thm.lift_rule (Thm.cprem_of (#2 (Isar.goal ())) 1) @{thm all_elim}) *}<br>\n  thm r<br>\n  apply (erule allE)<br>\n  apply (erule allI [THEN [2] swap])<br>\n  apply (rule impI)<br>\n  apply (erule notE)<br>\n  apply assumption<br>\n  done</p>\n<p>end</p>\n<p>By using distinctive variables from the very beginning, there is less <br>\nconfusion with implicit renaming in the example.  Moreover, I've asked the <br>\nsystem to do the lifting directly, cf. rule r.</p>\n<p>Also note that your ?K in lifting over assumptions needs to mention the <br>\nlocal x in general, but your goal premises were independent of that by <br>\naccident.</p>\n<p>If you really want to see how lifting works, here is the ML implementation <br>\nfrom Isabelle/src/Pure/logic.ML:</p>\n<p>fun lift_all inc =<br>\n  let<br>\n    fun lift Ts ((c as Const (\"==&gt;\", _)) $ A $ B) t = c $ A $ lift Ts B t<br>\n      | lift Ts ((c as Const (\"all\", _)) $ Abs (a, T, B)) t = c $ Abs (a, T, lift (T :: Ts) B t)<br>\n      | lift Ts _ t = incr_indexes (rev Ts, inc) t;<br>\n  in lift [] end;</p>\n<p>This means the ==&gt; and !! structure of the first term (from the subgoal) <br>\nis imposed on the second one (from the rule). The incr_indexes function is <br>\ndefined in the same file.  In Isabelle/src/Pure/thm.ML all of this will be <br>\nwrapped into the Thm.lift_rule inference.</p>\n<p>Makarius</p>",
        "id": 294058541,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822586
    }
]