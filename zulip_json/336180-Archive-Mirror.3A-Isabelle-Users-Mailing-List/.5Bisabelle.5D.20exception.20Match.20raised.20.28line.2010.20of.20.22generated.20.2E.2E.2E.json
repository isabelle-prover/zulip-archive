[
    {
        "content": "<p>From: Jose Manuel Rodriguez Caballero &lt;<a href=\"mailto:jose.manuel.rodriguez.caballero@ut.ee\">jose.manuel.rodriguez.caballero@ut.ee</a>&gt;<br>\nDear Isabelle users,<br>\n  In \"HOL-Algebra.Exponent\" we find the following function:</p>\n<p>definition multiplicity :: \"'a ⇒ 'a ⇒ nat\" where<br>\n  \"multiplicity p x = (if finite {n. p ^ n dvd x} then Max {n. p ^ n dvd x} else 0)\"</p>\n<p>I would like to do computations in Isabelle of this function, e.g.,</p>\n<p>value ‹multiplicity 2 12›</p>\n<p>My strategy was to redefine this function in a recursive way</p>\n<p>lemma multipl'_rec:<br>\n  fixes n::nat and p::nat<br>\n  assumes ‹n ≠ 0›<br>\n  shows ‹(((n+1) div (p+2)))-1 &lt; n›<br>\n  by (smt add.commute add_diff_inverse_nat add_less_same_cancel2 assms div_less_dividend less_one linorder_neqE_nat nat_add_left_cancel_less not_add_less2 one_less_numeral_iff semiring_norm(76) zero_less_diff)</p>\n<p>function multipl' :: \"nat ⇒ nat ⇒ nat\"<br>\n  where<br>\n    \"multipl' p 0 = 0\"<br>\n  | \"p+2 dvd n+1 ⟹ multipl' p n = Suc (multipl' p (((n+1) div (p+2)))-1)\"<br>\n  | \"¬ (p+2 dvd n+1) ⟹  multipl' p n = 0\"<br>\n        apply simp+<br>\n        apply (metis old.prod.exhaust)<br>\n       apply metis<br>\n      apply (metis Suc_1 Suc_eq_plus1 Suc_le_mono Suc_n_not_le_n add_Suc_right divides_aux_eq dvd_1_left<br>\n      dvd_antisym le0)<br>\n     apply metis<br>\n    apply (metis old.prod.inject)<br>\n   apply (metis prod.inject)<br>\n  by metis<br>\ntermination<br>\n  apply auto<br>\n  proof<br>\n  show \"multipl'_dom y\"<br>\n    if \"multipl'_rel y (a, b)\"<br>\n    for a :: nat<br>\n      and b :: nat<br>\n      and y :: \"nat × nat\"<br>\n    using that sorry<br>\nqed</p>\n<p>fun multipl :: \"nat ⇒ nat ⇒ nat\" where<br>\n‹multipl p n = multipl' (p-2) (n-1)›</p>\n<p>and to prove that the new definition is equivalent to the old definition, i.e.,</p>\n<p>lemma multipl_multiplicity:<br>\n  fixes p::nat and n::nat<br>\n  assumes ‹prime p› and ‹n ≠ 0›<br>\n  shows ‹multipl p n = multiplicity p n›<br>\nsorry</p>\n<p>Nevertheless, when I write</p>\n<p>value ‹multipl 2 12›</p>\n<p>I receive the following error message: \"exception Match raised (line 10 of \"generated code\")\"</p>\n<p>Any suggestions in order to fix this problem? Thank you in advance.</p>\n<p>Kind regards,<br>\nJosé M.</p>",
        "id": 294822115,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661242652
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nThe problem is that the code generator cannot handle conditional<br>\nequations in a function definition. You will have to prove a code<br>\nequation that does explicit \"if\" instead.</p>\n<p>By the way, I found the following code in an AFP entry<br>\n(Probabilistic_Prime_Tests/Fermat_Witness). I think I wrote this a while<br>\nago. I should probably put this in the library, but until then, feel<br>\nfree to use it.</p>\n<p>definition divide_out :: \"'a :: factorial_semiring \\&lt;Rightarrow&gt; 'a<br>\n\\&lt;Rightarrow&gt; 'a \\&lt;times&gt; nat\" where<br>\n  \"divide_out p x = (x div p ^ multiplicity p x, multiplicity p x)\"</p>\n<p>lemma fst_divide_out [simp]: \"fst (divide_out p x) = x div p ^<br>\nmultiplicity p x\"<br>\n  and snd_divide_out [simp]: \"snd (divide_out p x) = multiplicity p x\"<br>\n  by (simp_all add: divide_out_def)</p>\n<p>function divide_out_aux :: \"'a :: factorial_semiring \\&lt;Rightarrow&gt; 'a<br>\n\\&lt;times&gt; nat \\&lt;Rightarrow&gt; 'a \\&lt;times&gt; nat\" where<br>\n  \"divide_out_aux p (x, acc) =<br>\n     (if x = 0 \\&lt;or&gt; is_unit p \\&lt;or&gt; \\&lt;not&gt;p dvd x then (x, acc) else<br>\ndivide_out_aux p (x div p, acc + 1))\"<br>\n  by auto<br>\ntermination proof (relation \"measure (\\&lt;lambda&gt;(p, x, _). multiplicity p<br>\nx)\")<br>\n  fix p x :: 'a and acc :: nat<br>\n  assume \"\\&lt;not&gt;(x = 0 \\&lt;or&gt; is_unit p \\&lt;or&gt; \\&lt;not&gt;p dvd x)\"<br>\n  thus \"((p, x div p, acc + 1), p, x, acc) \\&lt;in&gt; measure (\\&lt;lambda&gt;(p,<br>\nx, _). multiplicity p x)\"<br>\n    by (auto elim!: dvdE simp: multiplicity_times_same)<br>\nqed auto</p>\n<p>lemmas [simp del] = divide_out_aux.simps</p>\n<p>lemma divide_out_aux_correct:<br>\n  \"divide_out_aux p z = (fst z div p ^ multiplicity p (fst z), snd z +<br>\nmultiplicity p (fst z))\"<br>\nproof (induction p z rule: divide_out_aux.induct)<br>\n  case (1 p x acc)<br>\n  show ?case<br>\n  proof (cases \"x = 0 \\&lt;or&gt; is_unit p \\&lt;or&gt; \\&lt;not&gt;p dvd x\")<br>\n    case False<br>\n    have \"x div p div p ^ multiplicity p (x div p) = x div p ^<br>\nmultiplicity p x\"<br>\n      using False<br>\n      by (subst dvd_div_mult2_eq [symmetric])<br>\n         (auto elim!: dvdE simp: multiplicity_dvd multiplicity_times_same)<br>\n    with False show ?thesis using 1<br>\n      by (subst divide_out_aux.simps)<br>\n         (auto elim: dvdE simp: multiplicity_times_same<br>\nmultiplicity_unit_left<br>\n                                not_dvd_imp_multiplicity_0)<br>\n  qed (auto simp: divide_out_aux.simps multiplicity_unit_left<br>\nnot_dvd_imp_multiplicity_0)<br>\nqed</p>\n<p>lemma divide_out_code [code]: \"divide_out p x = divide_out_aux p (x, 0)\"<br>\n  by (simp add: divide_out_aux_correct divide_out_def)</p>\n<p>lemma multiplicity_code [code]: \"multiplicity p x = snd (divide_out_aux<br>\np (x, 0))\"<br>\n  by (simp add: divide_out_aux_correct)</p>\n<p>Manuel</p>",
        "id": 294822734,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661242940
    }
]