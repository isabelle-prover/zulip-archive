[
    {
        "content": "<p>From: Daniel Stüwe &lt;<a href=\"mailto:stuewe@in.tum.de\">stuewe@in.tum.de</a>&gt;<br>\nHi all,</p>\n<p>in my bachelor's thesis I was working with functions calling themselves <br>\nin a set comprehension.<br>\nBut while using induction and Isar with the induction rules for these <br>\nfunctions I got an unexpected exception in the case of the induction <br>\nstep. I guess some unnecessary fixed variables in the rule are causing <br>\nthis.</p>\n<p>I created a minimal example showing the exception at last:</p>\n<p>theory Super<br>\nimports Main<br>\nbegin</p>\n<p>fun super where<br>\n\"super 0 = {}\" |<br>\n\"super (Suc n) = { x | x . x ∈ super n}\"</p>\n<p>lemma \"x ∈ super n ⟹ P x\"<br>\nby (induction n rule: super.induct) auto</p>\n<p>lemma \"x ∈ super n ⟹ P x\"<br>\nproof (induction n)<br>\ncase 0<br>\n   thus ?case by simp<br>\nnext<br>\n   case (Suc n)<br>\n   thus ?case by auto<br>\nqed</p>\n<p>thm super.induct nat.induct<br>\n(*<br>\n   ⟦?P 0; ⋀n. (⋀x xa. ?P n) ⟹ ?P (Suc n)⟧ ⟹ ?P ?a0.0<br>\n   ⟦?P 0; ⋀nat. ?P nat ⟹ ?P (Suc nat)⟧ ⟹ ?P ?nat<br>\n*)</p>\n<p>lemma \"x ∈ super n ⟹ P x\"<br>\nproof (induction n rule: super.induct)<br>\nprint_cases<br>\n   case 1<br>\n   thus ?case by simp<br>\nnext<br>\n   case 2<br>\n   (* exception THM 0 raised (line 661 of \"thm.ML\") - Isabelle 2015 *)<br>\n   (* exception THM 0 raised (line 737 of \"thm.ML\") - Isabelle 2016 *)<br>\noops</p>\n<p>end</p>\n<p>Greetings,<br>\nDaniel</p>",
        "id": 294669233,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661172886
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nOK, here are some bits of information, none of which are a satisfactory<br>\nanswer.</p>\n<p>1) It's clear the problem comes from the extra meta-quantified \"x\" and<br>\n\"xa\" in super.induct.</p>\n<p>2) You can use super.induct[simplified] as an induction rule. That gets<br>\nrid of the pointless quantification and essentially gives you<br>\nnat.induct. Then the cases can be proven.</p>\n<p>3) If you turn ML's debugging trace on, you get this explanation:</p>\n<p>Here's the full trace:<br>\nException trace - exception THM 0 raised (line 737 of \"thm.ML\"): assume:<br>\nvariables<br>\nAssumption.assume_hyps(2)<br>\nBasics.fold_map(3)()<br>\nAssumption.add_assms(3)<br>\nProof.gen_assume(8)(1)<br>\nProof.gen_assume(8)<br>\nProof.gen_case(5)<br>\nLibrary.oo(1)(1)(1)<br>\nToplevel.gen_proofs'(2)(1)(1)(1)<br>\nexception THM 0 raised (line 737 of \"thm.ML\"): assume: variables</p>\n<p>So, the problem is, the \"case\" mechanism is trying to depend on an<br>\nassumption involving more variables. I'm guessing those variables were<br>\ninvented by the \"fun\" package to handle the <em>two</em> binders of \"x\" created<br>\nby the syntax \"{x | x . x : super n}\". I think the package is then<br>\ngetting confused, because these variables don't actually get involved in<br>\nthe induction principle.</p>\n<p>I would suspect that for more involved recursive functions, the<br>\nvariables involved will be connected to the induction principle for it<br>\nto be useful. But you might have to fiddle a bit to get that to be true.</p>\n<p>Cheers,<br>\n     Thomas.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294669276,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661172899
    }
]