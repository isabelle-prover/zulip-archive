[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear list,</p>\n<p>as far as I can tell \"mult\" from \"~~/src/HOL/Library/Multiset\" does not<br>\nsupport code generation at the moment.</p>\n<p>So maybe the attached theory (which I extracted from recent work on<br>\nIsaFoR) is of general interest.</p>\n<p>Summary: The main (but not new, and maybe obvious) observation is that<br>\nwe may always drop the common part of two multisets that should be<br>\ncompared (I got the idea to use the converse of a finite well-founded<br>\nrelation in the main induction proof by Vincent van Oostrom). Now, when<br>\nchecking whether \"(N, M) : mult r\", instead of guessing an arbitrary<br>\ndecomposition \"M = I + A\" and \"N = I + B\" such that \"ALL b :# B. EX a :#<br>\nA. (b, a) : r\" (which currently does not support code generation and<br>\nwould lead to a worst-case exponential implementation), we may always<br>\nchoose \"A = M - M #Int N\" and \"B = N - M #Int N\" (which supports code<br>\ngeneration and yields a worst-case quadratic implementation).</p>\n<p>However, since the equivalence between my implementation and \"mult r\"<br>\nbasically requires \"r\" to be irreflexive and transitive, we only obtain<br>\nexecutable code for specific \"r\" (or rather its predicate variant; see<br>\nthe attached file) satisfying these requirements.</p>\n<p>cheers</p>\n<p>chris<br>\n<a href=\"/user_uploads/14278/Qhax6WFQW_F28xrJpzRK5uS0/Executable_Multiset_Extension.thy\">Executable_Multiset_Extension.thy</a></p>",
        "id": 294673870,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174262
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<p>I will take care for this.</p>\n<p>Just one question: since the equation is guarded by preconditions, how<br>\ndo you apply it for code generation?  By instantiating it to a specific<br>\nrelation and generation code for that instance only?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/6R8PN2H62yex6i__iG7BK17s/signature.asc\">signature.asc</a></p>",
        "id": 294673898,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174273
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Florian,</p>\n<p>right, that's what I apparently failed to convey ;)</p>\n<p>But maybe you, or others know tricks to make code generation work<br>\nautomagically for each suitable instance?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294673914,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174278
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Christian,</p>\n<blockquote>\n<p>But maybe you, or others know tricks to make code generation work<br>\nautomagically for each suitable instance?</p>\n</blockquote>\n<p>there are different approaches to make it work.</p>\n<p>a) Provide a locale (»functorial style«)</p>\n<p>locale executable_mult =<br>\n  fixes r :: \"'a =&gt; 'a =&gt; bool\"<br>\n  assumes irrefl: \"irrefl r\" and trans: \"trans r\"<br>\nbegin</p>\n<p>lemma [code]<br>\n  \"mult r = …\"<br>\n  using irrefl trans …</p>\n<p>end</p>\n<p>interpretation executable_mult foo …</p>\n<p>b) Provide an abstract type (»dictionary passing style«)</p>\n<p>typedef 'a irrefl_trans = \"{r. irrefl r &amp; trans r}\" …</p>\n<p>setup_lifting …</p>\n<p>definition \"R = Abs_irrefl_trans r\"</p>\n<p>lemma [code abstract]:<br>\n  \"Rep_irrefl_trans R = r\" …</p>\n<p>definition \"mult_exec R = mult (Rep_irrefl_trans R)\"</p>\n<p>Depends on the particular application which one is preferrable.</p>\n<p>Cheers,<br>\n    Florian</p>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<p>On Thu, May 5, 2016, 10:36 Florian Haftmann<br>\n&lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a><br>\n&lt;mailto:<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;&gt; wrote:</p>\n<p>Hi Christian,</p>\n<p>I will take care for this.</p>\n<p>Just one question: since the equation is guarded by preconditions, how<br>\n    do you apply it for code generation?  By instantiating it to a specific<br>\n    relation and generation code for that instance only?</p>\n<p>Cheers,<br>\n            Florian</p>\n<p>Am 04.05.2016 um 15:24 schrieb Christian Sternagel:<br>\n    &gt; Dear list,<br>\n    &gt;<br>\n    &gt; as far as I can tell \"mult\" from \"~~/src/HOL/Library/Multiset\"<br>\n    does not<br>\n    &gt; support code generation at the moment.<br>\n    &gt;<br>\n    &gt; So maybe the attached theory (which I extracted from recent work on<br>\n    &gt; IsaFoR) is of general interest.<br>\n    &gt;<br>\n    &gt; Summary: The main (but not new, and maybe obvious) observation is that<br>\n    &gt; we may always drop the common part of two multisets that should be<br>\n    &gt; compared (I got the idea to use the converse of a finite well-founded<br>\n    &gt; relation in the main induction proof by Vincent van Oostrom). Now,<br>\n    when<br>\n    &gt; checking whether \"(N, M) : mult r\", instead of guessing an arbitrary<br>\n    &gt; decomposition \"M = I + A\" and \"N = I + B\" such that \"ALL b :# B.<br>\n    EX a :#<br>\n    &gt; A. (b, a) : r\" (which currently does not support code generation and<br>\n    &gt; would lead to a worst-case exponential implementation), we may always<br>\n    &gt; choose \"A = M - M #Int N\" and \"B = N - M #Int N\" (which supports code<br>\n    &gt; generation and yields a worst-case quadratic implementation).<br>\n    &gt;<br>\n    &gt; However, since the equivalence between my implementation and \"mult r\"<br>\n    &gt; basically requires \"r\" to be irreflexive and transitive, we only<br>\n    obtain<br>\n    &gt; executable code for specific \"r\" (or rather its predicate variant; see<br>\n    &gt; the attached file) satisfying these requirements.<br>\n    &gt;<br>\n    &gt; cheers<br>\n    &gt;<br>\n    &gt; chris<br>\n    &gt;</p>\n<p>--</p>\n<p>PGP available:<br>\n<a href=\"http://isabelle.in.tum.de/~haftmann/pgp/florian_haftmann_at_informatik_tu_muenchen_de\">http://isabelle.in.tum.de/~haftmann/pgp/florian_haftmann_at_informatik_tu_muenchen_de</a></p>\n<p><a href=\"/user_uploads/14278/et3gYiz7KDoqQ3Q3EEmKlJgs/signature.asc\">signature.asc</a></p>\n</blockquote>",
        "id": 294673970,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174285
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nSee now</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/f2177f5d2aed\">http://isabelle.in.tum.de/repos/isabelle/rev/f2177f5d2aed</a><br>\n<a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/40134ddec3bf\">http://isabelle.in.tum.de/repos/isabelle/rev/40134ddec3bf</a></p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/sBwE_URJz84lZoIIYgTgqk5a/signature.asc\">signature.asc</a></p>",
        "id": 294674569,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661174488
    }
]