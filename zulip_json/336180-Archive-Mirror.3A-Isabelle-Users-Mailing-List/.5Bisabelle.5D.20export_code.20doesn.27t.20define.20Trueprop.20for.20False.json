[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>This is the result of my making comparisons between Scala and Haskell. <br>\nI'd like to generate a little code for whatever I'm doing, and messing <br>\naround with the meta-logic is something I eventually want to do. It <br>\ncould be I'm doing things which aren't intended to be done.</p>\n<p>I start with a hybrid version of \"not\" named \"Hnot\", (PROP P ==&gt; False), <br>\nand I export it.</p>\n<p>definition MFalse :: \"prop\" (\"MFalse\") where \"MFalse == (!!P. PROP P)\"<br>\n    definition Hnot :: \"prop =&gt; prop\" where \"Hnot P == (PROP P ==&gt; False)\"<br>\n    value \"Hnot(Trueprop False)\"<br>\n    export_code Hnot in Scala file \"i131123a.scala\"<br>\n    export_code Hnot in Haskell file \".\"</p>\n<p>I actually wanted to use \"(PROP P ==&gt; MFalse)\", but MFalse uses \"!!\", so <br>\nI get the export_code error message \"No code equations for all\".</p>\n<p>QUESTION: Are there some magic code equations for \"all\", or is this a <br>\nfundamental limitation?</p>\n<p>Starting here, I make some comments about the Haskell code, since it's <br>\nalmost like reading the Isar.</p>\n<p>From the generated code, HOL \"prop\" is converted to a data type \"Prop\", <br>\nwhich has only one value, \"Holds\".</p>\n<p>data Prop = Holds;</p>\n<p>I guess it makes sense that \"Prop\" can only be true, but consequently, <br>\nit makes the use of variables in \"follows\", the meta-implication, rather <br>\nmeaningless:</p>\n<p>follows :: Prop -&gt; Prop -&gt; Prop;<br>\n    follows p Holds = Holds;<br>\n    follows Holds p = p;</p>\n<p>I set that aside because the use of HOL is the main objective for most <br>\npeople. This brings us to \"trueprop\", which is the code for \"Trueprop\".</p>\n<p>trueprop :: Bool -&gt; Prop;<br>\n    trueprop True = Holds;</p>\n<p>This shows that \"trueprop\" is only defined for \"true\". I set that aside, <br>\nas a solitary issue, and talk about \"hnot\", which seems like it should <br>\nbe a valid function:</p>\n<p>hnot :: HOL.Prop -&gt; HOL.Prop;<br>\n    hnot p = HOL.follows p (HOL.trueprop False);</p>\n<p>Here, I've reached the limits of knowing what the limits of code <br>\ngeneration is supposed to be, when it comes to the meta-logic.</p>\n<p>In Isabelle I can do this, and I get a value of True:</p>\n<p>value \"Hnot(Trueprop False)\"</p>\n<p>I'm actually using the Scala code to test the functions in simple ways, <br>\nand I can't do that. The function \"trueprop\" is not defined for \"false\", <br>\nso both \"trueprop\" and \"hnot\" throw an exception.</p>\n<p>This is kind of contrary to the following four statements in HOL.thy, <br>\nwhere, by necessity, Trueprop is defined for both True and False:</p>\n<p>typedecl bool<br>\n    Trueprop  :: \"bool =&gt; prop\"<br>\n    consts<br>\n       True :: bool<br>\n       False :: bool</p>\n<p>As I said, it could be that none of this was intended to be used like this.</p>\n<p>Thanks,<br>\nGB</p>\n<p>theory i131123a<br>\nimports Complex_Main<br>\nbegin</p>\n<p>definition MFalse :: \"prop\" (\"MFalse\") where<br>\n   \"MFalse == (!!P. PROP P)\"</p>\n<p>definition Hnot_try :: \"prop =&gt; prop\" where<br>\n   \"Hnot_try P == (PROP P ==&gt; MFalse)\"<br>\nexport_code Hnot_try in Scala file \"i131123a.scala\"<br>\n(<em>ERROR: No code equations for all</em>)</p>\n<p>definition Hnot :: \"prop =&gt; prop\" where<br>\n   \"Hnot P == (PROP P ==&gt; False)\"</p>\n<p>value \"Hnot(Trueprop False)\"</p>\n<p>export_code Hnot in Scala file \"i131123a.scala\"<br>\nexport_code Hnot in Haskell file \".\"</p>\n<p>end<br>\n<a href=\"/user_uploads/14278/IjdDPrgRbGvL6lhZORGn1JvS/i131123a.thy\">i131123a.thy</a></p>",
        "id": 294256155,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912679
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nCode generation has been an excellent tutor. Seeing \"data prop Holds\" by <br>\nthe code generator has drove home a simple idea, that I can never make a <br>\nfalse statement at the prop level of logic. Sounds simple, but until <br>\nnow, I've always consider true and false to both be available to me.</p>\n<p>However, my \"hnot(false)\" doesn't attempt to make a false statement. It <br>\nmakes the statement \"False ==&gt; False\", which is true, and so it <br>\nshouldn't throw an exception.</p>\n<p>I don't know if this is good enough for the future, but for the moment, <br>\nI made \"trueprop\" part of the \"prop\" data type, and defined \"follows\" so <br>\nthat an exception is thrown there when a false meta-implication is <br>\nattempted.</p>\n<p>The Scala objects below, \"HOL2\" and \"HOL\" are a combination of the Scala <br>\nobjects that were exported for the source in my last email. \"HOL2\" is my <br>\nmodification.</p>\n<p>If one says, \"Is not an exception thrown semantically equivalent to a <br>\nmeta-logic false?\" I reply, \"I know nothing about semantics or <br>\npredicates. Those computer scientists, that is what they talk about, but <br>\nme, I know nothing about semantics or predicates.\"</p>\n<p>Regards,<br>\nGB</p>\n<p>// FIXED FOR NOW, MAYBE.<br>\nobject HOL2 {<br>\n   sealed abstract class prop<br>\n   final case class      Holds() extends prop<br>\n   final case class      trueprop(x0: Boolean) extends prop</p>\n<p>// ECLIPSE WARNING: match may not be exhaustive. It would fail on the<br>\n   // following input:<br>\n   //   (trueprop(true), trueprop(false))<br>\n   // Dude, exactly, it's impossible to make a false statement at the prop<br>\n   // level of logic. Exceptions are acceptable, but meta-logic false is<br>\n   // semantically offensive to those in the know.<br>\n   def follows(p: prop, pa: prop): prop = (p, pa) match {<br>\n     case (p, Holds()) =&gt; Holds()<br>\n     case (Holds(), trueprop(true)) =&gt; Holds()<br>\n     case (trueprop(false), trueprop(true)) =&gt; Holds()<br>\n     case (trueprop(true), trueprop(true)) =&gt; Holds()<br>\n     case (trueprop(false), trueprop(false)) =&gt; Holds()<br>\n   }</p>\n<p>def hnot(p: prop): prop = follows(p, trueprop(false))</p>\n<p>// Return value of Holds(). It's legit, is it not?<br>\n   val x = hnot(trueprop(false))</p>\n<p>// No error. Simple assignment. I'm not making any logical claim.<br>\n   val y = trueprop(false)</p>\n<p>// Throws exception. Not because or \"trueprop\", but because of <br>\n\"follows\".<br>\n   // That's what I want for now. Concerning the future, maybe not.<br>\n   val z = hnot(trueprop(true))<br>\n}</p>\n<p>// ORIGINAL: THROWS EXCEPTION FOR A LEGIT STATEMENT.<br>\nobject HOL {<br>\n     sealed abstract class prop<br>\n     final case class      Holds extends prop</p>\n<p>def trueprop(x0: Boolean): prop = x0 match {<br>\n     case true =&gt; Holds()<br>\n   }</p>\n<p>def follows(p: prop, pa: prop): prop = (p, pa) match {<br>\n     case (p, Holds()) =&gt; Holds()<br>\n     case (Holds(), p) =&gt; p<br>\n   }</p>\n<p>def hnot(p: prop): prop = follows(p, trueprop(false))</p>\n<p>// Throws exception. This is not where it should throw the exception, <br>\nbecause<br>\n   // hnot(false) should be an acceptable statement.<br>\n   val x = trueprop(false)<br>\n}<br>\n<a href=\"/user_uploads/14278/DUNHxarz9KZr9vqVhrvsP1fY/i131123a__mod_to_throw_exception_at_follows.scala\">i131123a__mod_to_throw_exception_at_follows.scala</a></p>",
        "id": 294256412,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912766
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nThis is my last email on this, unless someone wants to straighten me out <br>\non anything, but in about 2 to 3 months from now, I'm going to start <br>\ntrying to use the concept that I outlined in last email, where I made an <br>\nattempt to fix the exception problem, unless someone wants to explain <br>\nwhy I'm off track.</p>\n<p>Its taken me a while to get to the code generator, where I specifically <br>\nlearned about \"export_code\" from a tip given to me here several weeks <br>\nago by Florian. It pays to ask questions, and get a tip here and there <br>\nfor some of them.</p>\n<p>There are \"huge\" parts of Isabelle, and I'll now put the code generator <br>\nin with those huge parts, like Isar as a high-level language, the <br>\nmeta-logic of Pure, the object logic of HOL, Sledgehammer, the PIDE <br>\ninterface, and other auto tools.</p>\n<p>Complements from a mere user are now out of the way.</p>\n<p>Here, I'm thinking about whether \"prop\" and \"==&gt;\" are supposed to get <br>\ntheir meaning from their use with \"value\" or from their use with <br>\n\"theorem\". I guess I'm stating the obvious in saying that Isabelle/Pure <br>\ncan't be exported as about 10 lines of Scala or Haskell code, and so <br>\nsomething has to be lost.</p>\n<p>Essentially, \"value\", which I understand is related to the code <br>\ngenerator, doesn't return a \"prop\" value of \"so-called-meta-true\" or <br>\n\"so-called-meta-false\", as shown by these examples:</p>\n<p>value \"True ==&gt; False\" (* returns (Trueprop False)::prop *)<br>\nvalue \"False ==&gt; True\" (* returns (Trueprop True)::prop *)<br>\nvalue \"!!P. PROP P\"    (* returns (!!u::prop. PROP u)::prop *)</p>\n<p>The short story is that the Haskell line of code \"data prop Holds\" is my <br>\nguiding principle, and that the meaning of \"prop\" and \"==&gt;\" should come <br>\nfrom \"theorem\" and not \"value\", otherwise, the meta-logic, when <br>\nexported, will be no different from the object logic (which may be <br>\ninescapable). That's the way it appears to me.</p>\n<p>I look to the software to teach me logic. I look to it to give me, as an <br>\nenforcer, the years of knowledge the programmers have, who have written <br>\nthe software.</p>\n<p>When the software doesn't give me strict guidance, I'm willing to get <br>\ncreative, but I'd rather waste less of of my time than more of it by <br>\ngoing off track.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294256869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912910
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Gottfried,</p>\n<p>the trick of the definition \"holds == Trueprop True\" and the related<br>\nstuff is just used to allow the code generator (code_runtime.ML) to<br>\nevaluate expressions of the form (P) \"Trueprop _\" and check whether they<br>\nresult in \"Trueprop True\" aka \"holds\" and then certify the result as<br>\ntheorem (P).  It has no further significance.</p>\n<p>Maybe this answers you abundant questions.</p>\n<p>Cheers,<br>\n    Florian</p>",
        "id": 294257406,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913060
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nExposure to tricks can still result in light-bulb moments. It's more <br>\nclear to me now that an expression like<code>value \"!!P. PROP P\"</code> and <code>value \n\"Trueprop False\"</code> never get simplified to some meta-logic false <br>\nconstant. I take that as meaning there is no meta-logic false that's <br>\nbeen defined. If there is, maybe someone will tell me where it is.</p>\n<p>I guess no one but me cares about exporting functions of type \"prop =&gt; <br>\nprop\" and \"prop =&gt; prop =&gt; prop\".</p>\n<p>I decided that Scala \"val\" should mimic Isar \"value\" with functions <br>\nbased on type prop.</p>\n<p>It should produce something that looks like these:</p>\n<p>value \"True\"           (* True::bool *)<br>\nvalue \"False\"          (* False::bool *)<br>\nvalue \"Trueprop True\"  (* (Trueprop True)::prop *)<br>\nvalue \"Trueprop False\" (* (Trueprop False)::prop *)<br>\nvalue \"hNot(True)\"     (* (Trueprop False)::prop *)<br>\nvalue \"hNot(False)\"    (* (Trueprop True)::prop *)</p>\n<p>In the exported code, I changed \"trueprop\" from a function to a datatype <br>\nand got rid of \"Holds\". Until the day I can figure out how to export <br>\n\"!!P. PROP P\", or \"(op ==&gt;) == (op &amp;&amp;&amp;)\", I don't see a need for it, but <br>\nI could be wrong.</p>\n<p>Based on my limited knowledge, I think the modified \"trueprop\" and <br>\n\"follows\" should work as a drop-in replacement for any exported <br>\nfunctions of type \"prop =&gt; prop =&gt; prop\".</p>\n<p>Thanks,<br>\nGB</p>\n<p>// Modification to get Scala \"val\" to work like Isar \"value\"<br>\nobject I_131123b_mod {</p>\n<p>abstract sealed class prop<br>\nfinal case class trueprop(b: Boolean) extends prop</p>\n<p>def follows(p: prop, pa: prop): prop = (p, pa) match {<br>\n   case (p, trueprop(true)) =&gt; trueprop(true)<br>\n   case (trueprop(false), trueprop(false)) =&gt; trueprop(true)<br>\n   case (trueprop(true), trueprop(false)) =&gt; trueprop(false)<br>\n}</p>\n<p>def hNot(p: prop): prop = follows(p, trueprop(false))</p>\n<p>val x1 = true            // x1: Boolean = true<br>\nval x2 = false           // x2: Boolean = false<br>\nval x3 = trueprop(true)  // x3: trueprop = trueprop(true)<br>\nval x4 = trueprop(false) // x4: trueprop = trueprop(false)<br>\nval x5 = hNot(trueprop(true))  // x5: prop = trueprop(false)<br>\nval x6 = hNot(trueprop(false)) // x6: prop = trueprop(true)</p>\n<p>// HOL functions (bool =&gt; bool) are just Scala (Boolean =&gt; Boolean).<br>\ndef bNot(b: Boolean): Boolean = !b</p>\n<p>} /* object I_131123b */</p>\n<p>theory i131123b__scala_val_should_match_isa_value<br>\nimports Complex_Main<br>\nbegin</p>\n<p>definition hNot :: \"prop =&gt; prop\" where<br>\n   \"hNot P == (PROP P ==&gt; False)\"<br>\nnotation hNot (\"hNot _\" [5] 5)</p>\n<p>value \"True\"           (* True::bool *)<br>\nvalue \"False\"          (* False::bool *)<br>\nvalue \"Trueprop True\"  (* (Trueprop True)::prop *)<br>\nvalue \"Trueprop False\" (* (Trueprop False)::prop *)<br>\nvalue \"hNot(True)\"     (* (Trueprop False)::prop *)<br>\nvalue \"hNot(False)\"    (* (Trueprop True)::prop *)</p>\n<p>theorem \"hNot(False)\"<br>\nby(unfold hNot_def, simp)</p>\n<p>definition bNot :: \"bool =&gt; bool\" where<br>\n   \"bNot b = (~b)\"</p>\n<p>no_notation hNot (\"hNot _\" [5] 5)<br>\nexport_code hNot bNot Not in Scala module_name \"I_131123b\" file <br>\n\"i131123b.scala\"</p>\n<p>end</p>\n<p>// ORIGINAL EXPORT<br>\nobject I_131123b {</p>\n<p>abstract sealed class prop<br>\nfinal case class Holds() extends prop</p>\n<p>def trueprop(x0: Boolean): prop = x0 match {<br>\n   case true =&gt; Holds()<br>\n}</p>\n<p>def follows(p: prop, pa: prop): prop = (p, pa) match {<br>\n   case (p, Holds()) =&gt; Holds()<br>\n   case (Holds(), p) =&gt; p<br>\n}</p>\n<p>def bNot(b: Boolean): Boolean = ! b</p>\n<p>def hNot(p: prop): prop = follows(p, trueprop(false))</p>\n<p>} /* object I_131123b */</p>",
        "id": 294261730,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914630
    }
]