[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nHi,</p>\n<p>Could I make a feature request regarding the \"definition\" package?</p>\n<p>Current status</p>\n<hr>\n<p>Statements like { definition \"foo (a,b) == blah /\\ bleh\" } are not accepted, since the definition package does not support tupled arguments. </p>\n<p>Proposal</p>\n<hr>\n<p>That the definition package allows tupled arguments. Slightly more generally, since (a,b) is just shorthand for the constructed term \"Pair a b\", I propose that the definition package should support pattern-matching of arguments whenever the types of those arguments have exactly <em>one</em> constructor. For instance, I could then write { datatype proc = Procedure string command } and { definition \"exec (Procedure s c) == ...\" }.</p>\n<p>Current workarounds</p>\n<hr>\n<ol>\n<li>\n<p>Write { definition \"foo == %(a,b). blah /\\ bleh\" }. But this changes the foo_def theorem, and doesn't look so visually nice.</p>\n</li>\n<li>\n<p>Write { fun foo where \"foo (a,b) = (blah /\\ bleh)\" }. But this changes the foo_def theorem, and I have to remember to use foo.simps instead. And I have to put extra parentheses around the definiens, because \"=\" has different precedence to \"==\". And I have to remove foo.simps from the simplifier if I don't want foo expanding all the time. And I prefer to reserve \"fun\" for proper recursive functions, which foo isn't.</p>\n</li>\n<li>\n<p>Write { definition \"foo a b == blah /\\ bleh\" }. But there are times when it's more idiomatic to tuple than to curry.</p>\n</li>\n</ol>\n<p>cheers,<br>\nJohn</p>",
        "id": 294257432,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913084
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThat would indeed be convenient and I have frequently felt like adding it to<br>\nIsabelle/HOL. HOL Light supports this, and maybe HOL4 too.</p>\n<p>Tobias</p>",
        "id": 294257479,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913102
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFor me this is a genuine \"feature\", i.e. could be done or could be done <br>\ndifferently.  I've myself considered it around 1996, and rejected the idea <br>\nas too much extra complication (after discussion with Konrad Slind and <br>\nJohn Harrison).</p>\n<p>We need to strive to <em>remove</em> more features that are not strictly <br>\nnecessary.  All this is a heavy weight, and some day the system will just <br>\ncollapse due to the laws of gravity.</p>\n<p>Makarius</p>",
        "id": 294257504,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913108
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI feel uneasy about this idea, because “definition” is the low-level definitional mechanism of Isabelle, which doesn’t presume the existence of such things as ordered pairs. Your suggestion makes sense for Isabelle/HOL, but not in the wider context of generic theories, where ordered pairs may not exist. One of the specific purposes of “fun” is to support pattern matching.</p>\n<p>Larry Paulson</p>",
        "id": 294257553,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913127
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nHi Larry,</p>\n<p>I see, yes, that sounds sensible. What about my slight generalisation, of pattern-matching an argument whenever its type has just one constructor? Ordered pairs don't always exist, but do datatypes always exist?</p>\n<p>John</p>",
        "id": 294257562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913133
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nHOL4 does support this for its new_definition \"primitive\". Later theories can interpose pre and post transformations on the input term and the output theorem so that definitions appearing to be on tuples get turned into \"real\" definitions of the form <code>var = rhs</code>, and then turned back into the characterising theorem that the user expects.  (Even handling <code>f x = x + 1</code> uses this machinery.)</p>\n<p>Michael</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294257581,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913141
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 28/11/2013 21:35, schrieb Michael Norrish:</p>\n<blockquote>\n<p>HOL4 does support this for its new_definition \"primitive\". Later theories can interpose pre and post transformations on the input term and the output theorem so that definitions appearing to be on tuples get turned into \"real\" definitions of the form <code>var = rhs</code>, and then turned back into the characterising theorem that the user expects.  (Even handling <code>f x = x + 1</code> uses this machinery.)</p>\n</blockquote>\n<p>Thanks, I thought so. Awesome how you manage to support all this complexity!</p>\n<p>Tobias</p>\n<blockquote>\n<p>Michael</p>\n<p>On 29 Nov 2013, at 2:20, \"Tobias Nipkow\" &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>That would indeed be convenient and I have frequently felt like adding it to<br>\nIsabelle/HOL. HOL Light supports this, and maybe HOL4 too.</p>\n<p>Tobias<br>\n</p>\n</blockquote>\n<p>Am 28/11/2013 15:55, schrieb John Wickerson:</p>\n<blockquote>\n<blockquote>\n<p>Hi,</p>\n<p>Could I make a feature request regarding the \"definition\" package?</p>\n<p>Current status</p>\n<hr>\n<p>Statements like { definition \"foo (a,b) == blah /\\ bleh\" } are not accepted, since the definition package does not support tupled arguments.</p>\n<p>Proposal</p>\n<hr>\n<p>That the definition package allows tupled arguments. Slightly more generally, since (a,b) is just shorthand for the constructed term \"Pair a b\", I propose that the definition package should support pattern-matching of arguments whenever the types of those arguments have exactly <em>one</em> constructor. For instance, I could then write { datatype proc = Procedure string command } and { definition \"exec (Procedure s c) == ...\" }.</p>\n<p>Current workarounds</p>\n<hr>\n<ol>\n<li>\n<p>Write { definition \"foo == %(a,b). blah /\\ bleh\" }. But this changes the foo_def theorem, and doesn't look so visually nice.</p>\n</li>\n<li>\n<p>Write { fun foo where \"foo (a,b) = (blah /\\ bleh)\" }. But this changes the foo_def theorem, and I have to remember to use foo.simps instead. And I have to put extra parentheses around the definiens, because \"=\" has different precedence to \"==\". And I have to remove foo.simps from the simplifier if I don't want foo expanding all the time. And I prefer to reserve \"fun\" for proper recursive functions, which foo isn't.</p>\n</li>\n<li>\n<p>Write { definition \"foo a b == blah /\\ bleh\" }. But there are times when it's more idiomatic to tuple than to curry.</p>\n</li>\n</ol>\n<p>cheers,<br>\nJohn<br>\n</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.<br>\n</p>\n</blockquote>",
        "id": 294257590,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913145
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nWell, no, in general nothing exists. </p>\n<p>Of course I see that “fun” might be cumbersome in such a simple case.</p>\n<p>Larry Paulson</p>",
        "id": 294257599,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913152
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nvs. 'fun' / 'function' is not fully clear.</p>\n<p>The 'definition' package is for \"simple definitions\".  It wraps up the <br>\nbasic Local_Theory.define concept, which in turn goes releatively straight <br>\nto primitive definitions of the logical core (which are not accessible to <br>\nusers these days).  It presents itself in an object-logic friendly manner, <br>\nto allow writing \"f x y = rhs\" (with HOL equality).  The Pure form \"f x y <br>\n== rhs\" or even \"f == %x y. rhs\" is mostly historic -- it is only required <br>\nfor object-logics like ZF that cannot internalize all forms of definition. <br>\nThe conversion of the user specification is represented as higher-order <br>\nrewrite system via 'defn' rules -- whatever works here works, what doesn't <br>\nwork doesn't.</p>\n<p>The 'function' package is somehow dual: it incorporates as many features <br>\nas possible, just before gravitational collapse.  Pattern matching <br>\nprobably even outweighs the recursion / termination aspect. <br>\n(Interestingly, Scala is a higher-order functional language, where <br>\nrecursion and pattern matching are separate.  Odersky then uses his <br>\nremaining complexity budget elsewhere to make it more sophisticated than <br>\nML or Haskell.)</p>\n<p>The practical situation can be improved in a simple manner like this:</p>\n<p>* Refrain from using == in definitions.  Uniform = simplifies theories<br>\n     and allows to move specifications between different tools and packages<br>\n     more easily: 'theorem', 'definition', 'primrec', 'fun', 'function' etc.</p>\n<p>* The function package could refrain from exposing its internal<br>\n     construction of f as f_def.  This was technically not possible when<br>\n     first implemented, but is now just a matter how Local_Theory.define is<br>\n     invoked.  This also avoids well-known confusion due to unintended<br>\n     \"unfold f_def\" seen routinely with fresh users.</p>\n<p>Then the difference is just implicit simplification or not, and you write <br>\nsomething like:</p>\n<p>fun f where [simp del]: \"f (x, y, z) ((a, b), (u, v, w)) = rhs\"</p>\n<p>and make patterns as complex as the function package allows. Later you <br>\nsimplify with f.simps as usual.</p>\n<p>A side-alley of this thread is the old question, what the \"unfold\" proof <br>\nmethod or 'unfolding' command should really do.  There are various <br>\nwell-known anomalies in its wording and technical snags of \"unfolding <br>\nf_def\" where the equation does not always apply (because patterns don't <br>\nmatch).</p>\n<p>So far I always considered a puristic approach more desirable (at least in <br>\ntheory): reconstruct a precise equation \"f == %x y z. rhs\" from the <br>\nuser-space equation f x y z = rhs.  Really <em>unfold</em> that, and don't <br>\nrewrite with arbitray rules. Any such change and clarification is apt to <br>\nbreak existing applications, as usual.</p>\n<p>An alternative speculation is this: \"unfold f\" takes a term f and looks up <br>\nits equational \"Spec_Rules\", which is a new concept from some years ago. <br>\nIt then just rewrites with them by simplification, like the present f_def <br>\nor f.simps would do.  This unifies 'definition' and 'fun' in that respect, <br>\nand makes the system appear more like Coq, where terms have canonical <br>\n\"computation rules\".</p>\n<p>Makarius</p>",
        "id": 294261673,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914605
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nThanks Makarius, particularly for the \"where [simp del]\" tip. That's much nicer than having to issue a separate \"declare\" instruction. </p>\n<p>John</p>",
        "id": 294261686,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914612
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nConcerning the fundamental laws of General Relativity in Software <br>\nConstruction, I've recently found this interesting information about the <br>\nforthcoming JDK 8:</p>\n<p>* <a href=\"http://openjdk.java.net/projects/jdk8/features#122\">http://openjdk.java.net/projects/jdk8/features#122</a></p>\n<p>122 Remove the Permanent Generation<br>\n   Remove the permanent generation from the Hotspot JVM and thus the need<br>\n   to tune the size of the permanent generation.</p>\n<p>* <a href=\"http://openjdk.java.net/projects/jdk8/features#173\">http://openjdk.java.net/projects/jdk8/features#173</a></p>\n<p>173 Retire Some Rarely-Used GC Combinations<br>\n   Remove three rarely-used combinations of garbage collectors in order to<br>\n   reduce ongoing development, maintenance, and testing costs.</p>\n<p>This is a major revolution -- I can imagine the screeming of some existing <br>\nusers of the platform.</p>\n<p>Sun never retired old things: there are tons of deprecated APIs from Java <br>\n1.0 until today.  Oracle seems to recover some common sense now, seeing <br>\nthat it cannot handle arbitrary weight, although Oracle is a much larger <br>\ncompany than Sun ever was.</p>\n<p>Lets hope that JDK 8, when it is released next spring, will make a big <br>\nstep forward (like JDK 7 did over JDK 6).  Isabelle/Scala and its various <br>\nfront-ends depend on it.  (It is the weakest point in the PIDE equation.)</p>\n<p>Makarius</p>",
        "id": 294261706,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914620
    },
    {
        "content": "<p>From: Konrad Slind &lt;<a href=\"mailto:konrad.slind@gmail.com\">konrad.slind@gmail.com</a>&gt;<br>\nHandling tuples in the input to the HOL4 definition mechanism<br>\nwas definitely annoying. (Bear in mind that tuples would also<br>\nhave to be handled for the derived induction theorem.) I think the<br>\nHOL4 implementation tries to handle arbitrarily nested tuple arguments,<br>\nbut that is probably overkill.</p>\n<p>Konrad.</p>",
        "id": 294262611,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914930
    }
]