[
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear All,</p>\n<p>could anyone explain how search in find\\_theorems works from the inside?<br>\nDo you have any literature to recommend?</p>\n<p>Many thanks in advance,</p>\n<p>Best wishes,<br>\nAngeliki</p>",
        "id": 294765984,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661201983
    },
    {
        "content": "<p>From: \"Klein, Gerwin (Data61, Kensington NSW)\" &lt;<a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a>&gt;<br>\nThere’s no literature on its internals, it was too small a tool to publish about. The user interface is documented in the Isar reference manual.</p>\n<p>What aspect are you interested in?</p>\n<p>It’s basically filtering a list of theorems extracted from the current context by search predicates. The main predicates are pattern matching on the term, string matching on the theorem name, and a few more such as “conclusion matches current goal”, etc.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294766000,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661201994
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear Gerwin, CC:Yiannos<br>\nthanks a lot for your reply!<br>\nThe reason I'm asking is that<br>\nmy colleague Yiannos Stathopoulos at Cambridge<br>\nand I have been working on designing a new, different search engine for <br>\nthe Isabelle<br>\nlibrary and we'd like to compare its efficiency with find\\_theorems. <br>\nWhile comparing them, looking into how find\\_theorems works internally <br>\n<em>might</em> give us some insights about what it is that makes search work <br>\nbetter and why.</p>\n<p>Thanks again,<br>\nBest,<br>\nAngeliki</p>",
        "id": 294766005,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661201996
    },
    {
        "content": "<p>From: \"Klein, Gerwin (Data61, Kensington NSW)\" &lt;<a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a>&gt;<br>\nInteresting. Is efficiency an issue with the current find_theorems? </p>\n<p>Not saying that it can’t be improved. The main feature that people keep asking for is to be able to search outside the current context and session.</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294766068,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202006
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear Gerwin,</p>\n<p>On 2019-11-21 00:39, Klein, Gerwin (Data61, Kensington NSW) wrote:</p>\n<blockquote>\n<blockquote>\n<p>On 21 Nov 2019, at 11:30, Dr A. Koutsoukou-Argyraki &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt; <br>\nwrote:</p>\n<p>Dear Gerwin, CC:Yiannos<br>\nthanks a lot for your reply!<br>\nThe reason I'm asking is that<br>\nmy colleague Yiannos Stathopoulos at Cambridge<br>\nand I have been working on designing a new, different search engine <br>\nfor the Isabelle<br>\nlibrary and we'd like to compare its efficiency with find\\_theorems. <br>\nWhile comparing them, looking into how find\\_theorems works internally <br>\n<em>might</em> give us some insights about what it is that makes search work <br>\nbetter and why.</p>\n</blockquote>\n<p>Interesting. Is efficiency an issue with the current find_theorems?</p>\n</blockquote>\n<p>most of the time it works well, but there are some cases where it <br>\ndoesn't give any results where there are plenty of related lemmas.</p>\n<p>Of course this is a very tricky problem for many different reasons.</p>\n<p>(e.g. Here are some examples of search words that within the entire <br>\nAnalysis don't give results :</p>\n<p><code>Borel'', </code>Zorn'', <code>Gauss'', </code>product'', <code>operator'', </code>Hilbert'',  <br>\n<code>Lebesgue'', </code>derivative'', <code>Euclidean'', </code>rational'',  <br>\n<code>polynomial'',  </code>series'' , <code>Weierstrass'', </code>Noether'', <br>\n<code>summation'',\n</code>fraction'',  <code>supremum'', </code>infimum'', <code>pythagorean'',  \n</code>multiplication'', <code>converge'', </code>convergence'', ``mapping'')</p>\n<p>Also it's case-sensitive, i.e.<code>borel''gives about 509 results while \n</code>Borel''gives nothing.</p>\n<blockquote>\n<p>Not saying that it can’t be improved. The main feature that people<br>\nkeep asking for is to be able to search outside the current context<br>\nand session.</p>\n<p>We also hope to get this to work, and in general the hope is to manage <br>\nto get more results (of high relevance) for search queries.<br>\nWe can keep you updated about our progress if you are interested.</p>\n</blockquote>\n<p>Best,<br>\nAngeliki</p>",
        "id": 294766080,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202011
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nWhen I use the Query panel with \"Find Theorems\" and type \"name: product\" it says <br>\n\"found 179 theorem(s)\" and displays 40.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/fii8gtgELGkvprYxIrMCTx8s/smime.p7s\">smime.p7s</a></p>",
        "id": 294766093,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202015
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThe point is that you have to know what to search for. For example, “prod”, “mult” and “times” all yield different results because these tokens are used arbitrarily in the names of theorems. The objective here is to involve mathematical knowledge in search.</p>\n<p>Larry</p>",
        "id": 294766104,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202020
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I hope it is not inappropriate to provide an idea/feature request for the<br>\nnew find_theorems infrastructure.</p>\n<p>I believe that it would be impossible to cover all possible use cases by<br>\npredefining filters for a command such as find_theorems. Thence, it would<br>\nbe useful to provide a generic Isabelle/ML API, which would allow users to<br>\nwrite their own filters (e.g. values of the type \"thm -&gt; bool\", \"thm list<br>\n-&gt; bool\" or anything similar) and combine them using predefined logical<br>\nconnectives, such as \\/, /\\, etc.</p>\n<p>For example (the code below is a very rough sketch of the idea),</p>\n<p>(* Generic find theorems *)</p>\n<p>ML‹</p>\n<p>infix 1 \\/ /\\;</p>\n<p>signature FIND_THEOREMS_GENERIC =<br>\nsig</p>\n<p>val /\\ : (string * thm -&gt; bool) * (string * thm -&gt; bool) -&gt; string * thm -&gt;<br>\nbool<br>\nval \\/ : (string * thm -&gt; bool) * (string * thm -&gt; bool) -&gt; string * thm -&gt;<br>\nbool<br>\nval find_theorems : theory -&gt; (string * thm -&gt; bool) -&gt; (string * thm) list</p>\n<p>end</p>\n<p>structure Find_Theorems_Generic : FIND_THEOREMS_GENERIC =<br>\nstruct</p>\n<p>fun f1 /\\ f2 = fn thm =&gt; f1 thm andalso f2 thm;<br>\nfun f1 \\/ f2 = fn thm =&gt; f1 thm orelse f2 thm;</p>\n<p>fun find_theorems thy f =<br>\n  let val facts = Global_Theory.all_thms_of thy false |&gt; filter f<br>\n  in facts end;</p>\n<p>end;</p>\n<p>open Find_Theorems_Generic;</p>\n<p>›</p>\n<p>(* Use case example: custom filters *)</p>\n<p>ML‹</p>\n<p>(* Definition of custom filters *)</p>\n<p>(* Type constraint *)<br>\nfun has_type_constraintt has_type_constraintT (Const (_, T)) =<br>\n      has_type_constraintT T<br>\n  | has_type_constraintt has_type_constraintT (Free (_, T)) =<br>\n      has_type_constraintT T<br>\n  | has_type_constraintt has_type_constraintT (Var (_, T)) =<br>\n      has_type_constraintT T<br>\n  | has_type_constraintt has_type_constraintT (Abs (_, T, t)) =<br>\n      if has_type_constraintT T<br>\n      then true<br>\n      else has_type_constraintt has_type_constraintT t<br>\n  | has_type_constraintt has_type_constraintT (t $ u) =<br>\n      if has_type_constraintt has_type_constraintT t<br>\n      then true<br>\n      else has_type_constraintt has_type_constraintT u<br>\n  | has_type_constraintt _ _ = false</p>\n<p>fun has_type_constraint_thm has_type_constraintT thm = thm<br>\n  |&gt; Thm.full_prop_of<br>\n  |&gt; has_type_constraintt has_type_constraintT</p>\n<p>fun has_classT _ _ (Type (_, [])) = false<br>\n  | has_classT sort_rel sort (Type (c, T::Ts)) =<br>\n      if has_classT sort_rel sort T<br>\n      then true<br>\n      else has_classT sort_rel sort (Type (c, Ts))<br>\n  | has_classT sort_rel sort (TFree (_, sort')) = sort_rel (sort', sort)<br>\n  | has_classT sort_rel sort (TVar (_, sort')) = sort_rel (sort', sort)</p>\n<p>fun has_type_constructorT c (Type (c', [])) = (c = c')<br>\n  | has_type_constructorT c (Type (c', T::Ts)) =<br>\n      if has_type_constructorT c T<br>\n      then true<br>\n      else has_type_constructorT c (Type (c', Ts))<br>\n  | has_type_constructorT _ _ = false</p>\n<p>(* Presence of a given class *)<br>\nfun has_class_thm S nthm = nthm<br>\n  |&gt; snd<br>\n  |&gt; (S |&gt; has_classT (subset op= o swap) |&gt; has_type_constraint_thm)</p>\n<p>(* Presence of a given type constructor *)<br>\nfun has_type_constructor_thm c nthm = nthm<br>\n  |&gt; snd<br>\n  |&gt; (has_type_constructorT c |&gt; has_type_constraint_thm )</p>\n<p>fun sort_and_tc_filter c S = has_class_thm S /\\ has_type_constructor_thm c</p>\n<p>fun sort_or_tc_filter c S = has_class_thm S \\/ has_type_constructor_thm c</p>\n<p>›</p>\n<p>(* Use case example: all theorems that contain the sort constraint<br>\ntopological_space or the type constructor filter *)</p>\n<p>ML‹</p>\n<p>val thms = find_theorems<br>\n  @{theory}<br>\n  (sort_or_tc_filter \\&lt;^type_name&gt;‹filter› \\&lt;^sort&gt;‹topological_space›)</p>\n<p>val _ = thms |&gt; length |&gt; Int.toString |&gt; writeln;<br>\nval _ = thms |&gt; map fst |&gt; map writeln;</p>\n<p>›</p>\n<p>(* Use case example: all theorems that contain the sort constraint<br>\ntopological_space and the type constructor filter *)</p>\n<p>ML‹</p>\n<p>val thms = find_theorems<br>\n  @{theory}<br>\n  (sort_and_tc_filter \\&lt;^type_name&gt;‹filter› \\&lt;^sort&gt;‹topological_space›)</p>\n<p>val _ = thms |&gt; length |&gt; Int.toString |&gt; writeln;<br>\nval _ = thms |&gt; map fst |&gt; map writeln;</p>\n<p>›</p>\n<p>Thank you</p>",
        "id": 294766122,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202033
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 21/11/2019 12:24, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>The point is that you have to know what to search for. For example, “prod”, “mult” and “times” all yield different results because these tokens are used arbitrarily in the names of theorems. The objective here is to involve mathematical knowledge in search.</p>\n</blockquote>\n<p>Her point was that the search for a long list of example words yielded 0 <br>\nresults. I am merely pointing out that find_theorems works fine on these words <br>\nif you use \"name:\".</p>\n<p>Your point is of course important.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Larry</p>\n<p>On 21 Nov 2019, at 06:14, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>When I use the Query panel with \"Find Theorems\" and type \"name: product\" it says \"found 179 theorem(s)\" and displays 40.</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/zIQ5PN8ibj5VTTh3Zo7Jt-3O/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294766161,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202045
    },
    {
        "content": "<p>From: mailing-list anonymous &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I noticed a mistake in my previous post: (once again) I was trying to write<br>\nan email within a fixed and very limited timeframe. Of course, I did not<br>\nmean to use the term \"logical connective\" in the context of a function that<br>\ncombines two filters together. I believe that the term \"combinator\" would<br>\nbe more suitable.</p>\n<p>Thank you</p>",
        "id": 294766185,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202058
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nIndeed, for several  of them using \"name:\" works, thank you for noticing <br>\n, Tobias.</p>\n<p>But when I search via the Query search box I still don't get any results <br>\nfor any of the words mentioned, including \"product\".</p>\n<p>Using \"name:\" does give me results for some of them.</p>\n<p>I still don't get any results using \"name:\"  for<br>\n\"Gauss\", \"Noether\", \"summation\", \"supremum\", \"infimum\", \"pythagorean\", <br>\n\"multiplication\".</p>\n<p>In general it would be good if performance could get a bit improved.</p>\n<p>Best wishes,<br>\nAngeliki</p>",
        "id": 294766206,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202068
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 21/11/2019 21:11, Dr A. Koutsoukou-Argyraki wrote:</p>\n<blockquote>\n<p>Indeed, for several  of them using \"name:\" works, thank you for noticing , Tobias.</p>\n<p>But when I search via the Query search box I still don't get any results for any <br>\nof the words mentioned, including \"product\".</p>\n</blockquote>\n<p>Strange, because it does work for me. I just tried it again.</p>\n<blockquote>\n<p>Using \"name:\" does give me results for some of them.</p>\n<p>I still don't get any results using \"name:\"  for<br>\n\"Gauss\", \"Noether\", \"summation\", \"supremum\", \"infimum\", \"pythagorean\", <br>\n\"multiplication\".</p>\n</blockquote>\n<p>I can confirm that for \"Gauss\" but the reason is simple: there is no theorem <br>\nwhose name contains \"Gauss\" in the Isabelle/HOL distribution. I suspect it is <br>\nthe same for your other words.</p>\n<p>Tobias</p>\n<blockquote>\n<p>In general it would be good if performance could get a bit improved.</p>\n<p>Best wishes,<br>\nAngeliki</p>\n<blockquote>\n<p>Her point was that the search for a long list of example words yielded<br>\n0 results. I am merely pointing out that find_theorems works fine on<br>\nthese words if you use \"name:\".</p>\n<p>Your point is of course important.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Larry</p>\n<p>On 21 Nov 2019, at 06:14, Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>When I use the Query panel with \"Find Theorems\" and type \"name: product\" it <br>\nsays \"found 179 theorem(s)\" and displays 40.<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p><a href=\"/user_uploads/14278/M_gL8nKnOaSMofu0NWgM6Cht/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294766213,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202070
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>But when I search via the Query search box I still don't get any<br>\nresults for any of the words mentioned, including \"product\".</p>\n</blockquote>\n<p>Strange, because it does work for me. I just tried it again.</p>\n</blockquote>\n<p>Note that, of course, it also depends what context you are in (e.g. what<br>\ntheories you have loaded).</p>\n<blockquote>\n<p>I can confirm that for \"Gauss\" but the reason is simple: there is no<br>\ntheorem whose name contains \"Gauss\" in the Isabelle/HOL distribution.<br>\nI suspect it is the same for your other words.</p>\n</blockquote>\n<p>That is not entirely true. There is something in HOL-Number_Theory, and<br>\nif you count \"gauss\" as well there are some in HOL-Probability and even<br>\nHOL itself.</p>\n<p>The underlying problem, I suppose, is that the only way to attach any<br>\nkind of meta-information to a theorem in a way that the current search<br>\ncan pick up is through its name. And the other problem is that it only<br>\nworks for things that you have loaded.</p>\n<p>Manuel</p>",
        "id": 294766224,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202076
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nwell, when searching for \"Gauss\" within the Computational Algebra <br>\nlibrary I would hope to get some facts related to the fundamental <br>\ntheorem of algebra,<br>\nsimilarly  when searching for \"Noether\" within  the algebra<br>\nlibrary I would hope to get some facts related to rings etc. even if <br>\nnoetherian rings are not there.</p>\n<p>What I'm trying to say is that it would be useful to get associated <br>\nresults with the search words, not just results that have the name  <br>\nitself included.<br>\nAlso, e.g. \"multiplication\" ideally would give different kinds of <br>\nmultiplication, \"infimum\"/\"supremum\"/ ideally would give related facts <br>\netc.</p>\n<p>So, what we are hoping to achieve in what we're developing with Yiannos <br>\nis \"associated\" concepts<br>\nin the search results for queries.</p>\n<p>Best wishes,<br>\nAngeliki</p>",
        "id": 294766236,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202086
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;</p>\n<blockquote>\n<p>The underlying problem, I suppose, is that the only way to attach any<br>\nkind of meta-information to a theorem in a way that the current search<br>\ncan pick up is through its name.</p>\n</blockquote>\n<p>exactly! that is why I write in my other email that we are hoping for <br>\nmore associations even if the name is not explicit.</p>\n<blockquote>\n<p>And the other problem is that it only<br>\nworks for things that you have loaded.</p>\n<p>yes, I'm aware of this, but luckily the user can control this (e.g.  by <br>\nloading the whole library)<br>\nOf course ideally the search would work even for unloaded things</p>\n</blockquote>\n<p>Best wishes,<br>\nAngeliki</p>",
        "id": 294766239,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202088
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYes, a theory called Gauss, but not a theorem.</p>\n<p>I am merely pointing out that find_theorems meets its specification.</p>\n<p>\"What I'm trying to say is that it would be useful to get associated results <br>\nwith the search words, not just results that have the name  itself included.\"</p>\n<p>I completely agree.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/tqywokHge0Z_TSNae7whFuU1/smime.p7s\">smime.p7s</a></p>",
        "id": 294766251,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202094
    },
    {
        "content": "<p>From: \"Klein, Gerwin (Data61, Kensington NSW)\" &lt;<a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a>&gt;</p>\n<blockquote>\n<p>On 22 Nov 2019, at 08:16, Dr A. Koutsoukou-Argyraki &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>The underlying problem, I suppose, is that the only way to attach any<br>\nkind of meta-information to a theorem in a way that the current search<br>\ncan pick up is through its name.</p>\n</blockquote>\n<p>exactly! that is why I write in my other email that we are hoping for more associations even if the name is not explicit.</p>\n</blockquote>\n<p>Thanks for the explanations, I think I understand now what the goal is.</p>\n<p>Having lived through the early days of web search before Google, I have some opinions on this. Compared to Google, the initial search engines were pretty much useless, mostly because they were based on string search only and returned too many results for the results you actually wanted to appear anywhere near the top. Many of them tried to fix the problem of returning irrelevant results by trying to match <em>more</em> things, i.e. make the search more fuzzy. That made it worse. Google mainly figured out how to rank search results such that popular pages (after their search rank measure) come first on the assumption that those will be the things you want. That worked spectacularly well. </p>\n<p>For Isabelle, I also usually get too many results, not too few. That is not true in the case you describe, although the use cases so far seems to describe finding definition concepts, not theorems. There is a separate command for that (find_consts). Maybe they should be merged so the user doesn’t have to distinguish between them, but I think there is a lot more room for improvement for finding constants, possibly with the same basic ideas you have described. I.e. it’s worth looking into the concept separately.</p>\n<p>It was an explicit design goal for find_theorems not to match fuzzily, because you can use pattern matching for that, and you want to be able to reduce the matches to what is interesting.</p>\n<p>Maybe that was the wrong idea. Google in a sense has ruined structured search, because Google is so good at unstructured search that nobody is used to the idea any more, even where we have the structure and information that we don’t have on the web. I.e. the usual search interaction is to type in a few words, like you described, not terms or patterns. So maybe we should support that. If we find a good way of ranking results instead, it doesn’t matter so much if we return more results, as long as we return the one the user actually needs in the first 5 or 10.</p>\n<p>So, the real problem to solve is ranking results. The other part (matching more from a search) is comparatively easy.</p>\n<blockquote>\n<blockquote>\n<p>And the other problem is that it only<br>\nworks for things that you have loaded.<br>\nyes, I'm aware of this, but luckily the user can control this (e.g.  by loading the whole library)<br>\nOf course ideally the search would work even for unloaded things</p>\n</blockquote>\n</blockquote>\n<p>I’d be keen on that feature :)</p>\n<p>Cheers,<br>\nGerwin</p>",
        "id": 294766257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202101
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear Gerwin,</p>\n<p>many thanks for your comments!<br>\nOn 2019-11-21 22:20, Klein, Gerwin (Data61, Kensington NSW) wrote:</p>\n<blockquote>\n<p>So, the real problem to solve is ranking results. The other part<br>\n(matching more from a search) is comparatively easy.</p>\n<p>yes, this is an excellent point of course, and we do not know how to <br>\nsolve the ranking problem. Combining a number of search words sometimes <br>\nhelps a lot, but it is not always enough.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>And the other problem is that it only<br>\nworks for things that you have loaded.<br>\nyes, I'm aware of this, but luckily the user can control this (e.g.  <br>\nby loading the whole library)<br>\nOf course ideally the search would work even for unloaded things</p>\n</blockquote>\n</blockquote>\n<p>I’d be keen on that feature :)</p>\n</blockquote>\n<p>This will be possible with what Yiannos and I are trying<br>\nout, as the search will be done offline on the entire library. This <br>\nagain may have the consequence of too many results, which brings back <br>\nthe ranking problem, so we have to see how to treat this.</p>\n<p>Best,<br>\nAngeliki</p>",
        "id": 294766350,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202130
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nProof objects reference theorems (or concepts), so you have a graph on <br>\nwhich page rank could be applied ... on theorems, not web pages, though.</p>\n<p>Clemens</p>",
        "id": 294766351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202131
    },
    {
        "content": "<p>From: \"mailing.list.anonymous\" &lt;<a href=\"mailto:mailing.list.anonymous@gmail.com\">mailing.list.anonymous@gmail.com</a>&gt;<br>\nDear All,</p>\n<p>I hope that my previous comment <br>\n(<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00068.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00068.html</a>) <br>\nwas not too out of place. I wrote and submitted it before the following <br>\nposts (providing more background information with regard to the further <br>\ndevelopment plans for the 'find_theorems' infrastructure) were submitted <br>\nto the list: <br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00076.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00076.html</a>, <br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00081.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00081.html</a>. <br>\nPlease accept my apologies for my haste.</p>\n<p>I have to admit that I also found the existing 'find_theorems' <br>\ninfrastructure slightly limiting and, most certainly, I am not the only <br>\none (e.g. see <br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00036.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2019-November/msg00036.html</a>). <br>\nAt some point when I was working on the extension of Types-To-Sets, I <br>\ndid think quite seriously about introducing something similar to <br>\nIsabelle/ML-based query language (most likely, building on the ideas <br>\ndrawn from the general query languages and the language of patterns for <br>\nsubterm selection) for searching the databases of theorems and constants <br>\nas an independent user-level package . At the time, it was meant to be <br>\nembedded in Isabelle/ML only (but designed in a way such that, <br>\npotentially, it could be translated to Isar). Nevertheless, it seemed <br>\ntoo much of a tangent at the time and I opted for a much simpler <br>\napplication-specific solution. Nevertheless, I was never entirely happy <br>\nabout the outcome and the thought of a possibility of introducing <br>\nsomething better/more general (at least, for my own application) keeps <br>\nnagging me.</p>\n<p>I am very glad that there is an ongoing project towards the improvement <br>\nof the infrastructure for searching for theorems/constants. Of course, <br>\nhaving any capacity for doing unstructured search would be very useful <br>\nfor the end users of Isar. However, I am curious if, as part of this <br>\ndevelopment, you are also considering providing anything akin to a <br>\ngeneric and application specific query language with pattern matching (I <br>\nguess, this would have to be aimed, primarily, at the structured <br>\nsearch). The reason why I am asking this question is that this is still <br>\nsomething that I am considering doing at some point in the future. Of <br>\ncourse, I would only be happier if someone else developed something that <br>\nprovides the functionality that I seek. Otherwise, this will remain on <br>\nmy “To Do List”.</p>\n<p>In summary, I would highly appreciate if you could let me know whether <br>\nthe plan for the work on the improvement of the functionality for <br>\nsearching for theorems/constants does include the development of a query <br>\nlanguage for structured search of theorems and constants with some form <br>\nof pattern matching that goes beyond the capabilities of the existing <br>\nimplementation of find_theorems.</p>\n<p>Thank you</p>",
        "id": 294766372,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661202143
    }
]