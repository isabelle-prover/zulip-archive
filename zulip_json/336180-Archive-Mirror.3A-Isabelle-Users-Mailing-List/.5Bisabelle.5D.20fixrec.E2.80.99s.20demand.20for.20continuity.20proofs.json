[
    {
        "content": "<p>From: Peter Gammie &lt;<a href=\"mailto:peteg42@gmail.com\">peteg42@gmail.com</a>&gt;<br>\nJoachim,</p>\n<p>Just a quick response, as it is late here. I'd suggest you read more background material before trying to prove anything. In particular, the original HOLCF paper is great, and there are some theories in the AFP that illustrate how to use HOLCF - Brian Huffman's stream fusion one is very well presented, and I hacked some things together in my worker/wrapper entry. There you will find a theory for the natural numbers that handles some of these issues.</p>\n<p>I'd be very wary about mixing the continuous (HOLCF) and total (HOL) function spaces. It does work if you obey the design principles spelt out in the original paper.</p>\n<p>Start with easy stuff - reasoning about lists defined using 'domain', e.g. The naturals, unless defined as a domain, are already fiddly. Sets are a long way from obvious, probably leading you to power domains if you have a non-trivial recursive definition.</p>\n<p>Take a look at the examples in the HOLCF directory of the Isabelle distribution too.</p>\n<p>It might help to switch on \"Show sorts\" in proof general and remember that if a type isn't annotated with pcpo (etc) then HOLCF doesn't know much about it.</p>\n<p>cheers<br>\npeter</p>",
        "id": 294115351,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838123
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nDear Brian,</p>\n<p>thanks for your detailed response, I’m having a much clearer picture now<br>\nand also managed to define my function using HOLCF.</p>\n<p>I had some problems with the cont2cont_Let' rule in the cont2cont rule<br>\nset. Here is a minimal example:</p>\n<hr>\n<p>lemma \"cont (λx. x⋅(Discr True))\"<br>\nby (intro cont2cont)</p>\n<hr>\n<p>works as expected. But</p>\n<hr>\n<p>lemma \"cont (λx. let y = True in x⋅(Discr y))\"<br>\nby (intro cont2cont)</p>\n<hr>\n<p>does not. The goal that it is stuck on is<br>\n\"cont (λp. Discr (snd p))\".</p>\n<p>It works after I added this lemma to the cont2cont set, which works for<br>\nlet expressions where the variable x does not appear in the bound<br>\nexpression:</p>\n<hr>\n<p>lemma cont2cont_Let_simple[simp,cont2cont]:<br>\n  assumes \"cont (λx. g x t)\"<br>\n  shows \"cont (λx. let y = t in g x y)\"<br>\nunfolding Let_def using assms .</p>\n<hr>\n<p>I’m not sure if this is a general solution and or it would somehow<br>\nconflict with cont2cont_Let'. If it is a general solution, feel free to<br>\nadd it to HOLCF.</p>\n<p>Furthermore, I had to add these lemmas:</p>\n<hr>\n<p>lemma cont2cont_list_case [simp, cont2cont]:<br>\n  assumes \"⋀y. cont (λx. f1 x)\"<br>\n     and  \"⋀y z. cont (λx. f2 x y z)\"<br>\n  shows \"cont (λx. list_case (f1 x) (f2 x) l)\"<br>\nusing assms<br>\nby (cases l) auto</p>\n<p>lemma cont2cont_prod_case [simp, cont2cont]:<br>\n  assumes \"⋀y z. cont (λx. f x y z)\"<br>\n  shows \"cont (λx. prod_case (f x) p)\"<br>\nusing assms<br>\nby (cases p) auto</p>\n<hr>\n<p>plus similar ones for each algebraic data types that I am using. The<br>\nform of these lemmas is very static – do you think this can be<br>\ngeneralized somehow? I did not yet write any ML scripts in Isabelle, but<br>\nI’m eager to learn if there is a worthwhile goal.</p>\n<p>Thanks,<br>\nJoachim</p>\n<p>PS: I wrote a \"list :: cpo(cpo)\" instance, relating lists of equal<br>\nlength piecewise and not relating lists of different lengths, at<br>\n<a href=\"http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/HOLCFList.thy;hb=HEAD\">http://git.nomeata.de/?p=funcCF.git;a=blob;f=CFGraph/HOLCFList.thy;hb=HEAD</a><br>\nIf you think this is generally useful and know where to put it I’d<br>\nhappily share it (after make the proofs prettier).<br>\n<a href=\"/user_uploads/14278/vdp7qN5PTVYd7jeV__rgIz42/signature.asc\">signature.asc</a></p>",
        "id": 294116522,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838479
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nHi Brian,</p>\n<p>Am Freitag, den 03.09.2010, 14:25 -0700 schrieb Brian Huffman:</p>\n<blockquote>\n<blockquote>\n<p>It works after I added this lemma to the cont2cont set, which works for<br>\nlet expressions where the variable x does not appear in the bound<br>\nexpression:</p>\n<hr>\n<p>lemma cont2cont_Let_simple[simp,cont2cont]:<br>\n assumes \"cont (λx. g x t)\"<br>\n shows \"cont (λx. let y = t in g x y)\"<br>\nunfolding Let_def using assms .</p>\n<hr>\n<p>I’m not sure if this is a general solution and or it would somehow<br>\nconflict with cont2cont_Let'. If it is a general solution, feel free to<br>\nadd it to HOLCF.</p>\n</blockquote>\n<p>It would be good to add this new rule to HOLCF, but I would make a<br>\nsmall change to the \"assumes\" part:</p>\n<p>lemma cont2cont_Let_simple[simp,cont2cont]:<br>\n assumes \"!!y. cont (λx. g x y)\"<br>\n shows \"cont (λx. let y = t in g x y)\"<br>\nunfolding Let_def using assms .</p>\n<p>In case \"t\" is a large term, and/or \"y\" occurs many times in the body<br>\nof g, this might avoid a blow-up in term size.</p>\n</blockquote>\n<p>it probably would not affect me at the moment, but are there no cases<br>\nwhere this would be too weak? What if \"cont (λx. g x y)\" does not hold<br>\nfor all y, but only for y=t? But maybe such cases are only pathological<br>\nand do not occur in practice.</p>\n<p>I guess the premise \"let y = t in cont (λx. g x y)\" would not allow the<br>\nother cont2cont rules to proceed.</p>\n<blockquote>\n<blockquote>\n<p>Furthermore, I had to add these lemmas:</p>\n<hr>\n<p>lemma cont2cont_list_case [simp, cont2cont]:<br>\n assumes \"⋀y. cont (λx. f1 x)\"<br>\n    and  \"⋀y z. cont (λx. f2 x y z)\"<br>\n shows \"cont (λx. list_case (f1 x) (f2 x) l)\"<br>\nusing assms<br>\nby (cases l) auto</p>\n<p>lemma cont2cont_prod_case [simp, cont2cont]:<br>\n assumes \"⋀y z. cont (λx. f x y z)\"<br>\n shows \"cont (λx. prod_case (f x) p)\"<br>\nusing assms<br>\nby (cases p) auto</p>\n<hr>\n<p>plus similar ones for each algebraic data types that I am using. The<br>\nform of these lemmas is very static – do you think this can be<br>\ngeneralized somehow? I did not yet write any ML scripts in Isabelle, but<br>\nI’m eager to learn if there is a worthwhile goal.</p>\n</blockquote>\n<p>I see that these lemmas assume that the variable \"x\" doesn't occur in<br>\nthe scrutinee of the case expression; in practice it might be<br>\nnecessary to create both versions of cont2cont rules for each case<br>\ncombinator.</p>\n</blockquote>\n<p>I used cont2cont_if as the template for these, and did not see a<br>\ncont2cont rule for if where x occurs in the condition. After all, it is<br>\neasy to create non-continuous functions then:<br>\n    cont (λx. if x then False else True)<br>\nusing the bool:pcpo instance should be false (because it is not<br>\nmonotonous), even though \"cont (λx. x)\", \"cont (λx. False)\" and \"cont<br>\n(λx. True)\" hold. What form would a cont2cont rule about if have, if x<br>\nappears in the condition?</p>\n<p>Thanks,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/yymR-03jH7RbizwcmZqQ7gEK/signature.asc\">signature.asc</a></p>",
        "id": 294116556,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838491
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nHi again,</p>\n<p>I have more questions about HOL/CF, especially about the fixrec package:</p>\n<p>Consider again the function from my last example:<br>\n        f b = {b} ∪ f b</p>\n<p>I have this working definition:</p>\n<hr>\n<p>fixrec f :: \"int discr → (int ⇒ one)\" where<br>\n  \"f⋅b = (f⋅b) (undiscr b := ONE)\"</p>\n<hr>\n<p>but I do not like how I have to use undiscr here (especially as in my<br>\nreal example, the argument is more complex).</p>\n<p>Shouldn’t fixrec be able to define the function having the type \"int ⇒<br>\n(int ⇒ one)\"? Based on my understanding, this type is also a pcpo and<br>\ntherefore the operator based on the recursive definition with type<br>\n\"(int ⇒ (int ⇒ one)) → (int ⇒ (int ⇒ one))\" can be used to define f.<br>\nUnfortunately, this does not work:</p>\n<hr>\n<p>fixrec f :: \"int ⇒ int ⇒ one\" where<br>\n  \"f b = (f b) (b := ONE)\"</p>\n<hr>\n<p>gives me <br>\n*** fixrec definition error:<br>\n*** unknown term<br>\n*** At command \"fixrec\".<br>\nwhile</p>\n<hr>\n<p>fixrec f :: \"int ⇒ int ⇒ one\" where<br>\n  \"f = (λb. (f b) (b := ONE))\"</p>\n<hr>\n<p>gives<br>\n*** Continuity proof failed; please check that cont2cont rules<br>\n*** or simp rules are configured for all non-HOLCF constants.<br>\n*** The error occurred for the goal statement:<br>\n*** cont (λf b. (f b)(b := ONE))<br>\n*** At command \"fixrec\".</p>\n<p>I’m also wondering why this works</p>\n<hr>\n<p>fixrec g :: \"(int×int) discr → ((int×int) ⇒ one)\" where<br>\n  \"g⋅b = (case undiscr b of t ⇒ (g⋅(Discr t)) (t := ONE))\"</p>\n<hr>\n<p>but this does not:</p>\n<hr>\n<p>fixrec g :: \"(int×int) discr → ((int×int) ⇒ one)\" where<br>\n  \"g⋅b = (case undiscr b of (a,c) ⇒ (g⋅(Discr (a,c))) ((a,c) := ONE))\"</p>\n<hr>\n<p>*** Continuity proof failed; please check that cont2cont rules<br>\n*** or simp rules are configured for all non-HOLCF constants.<br>\n*** The error occurred for the goal statement:<br>\n*** cont (λg. Λ a. case undiscr a of (a, c) ⇒ (g⋅(Discr (a, c)))((a, c) := ONE))<br>\n*** At command \"fixrec\".</p>\n<p>Is all this a limitation of fixrec, or a limitation in my understanding<br>\nit? :-)</p>\n<p>Thank in advance for your help,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/OV7x4tNNaALu4NjHr3CnUmBw/signature.asc\">signature.asc</a></p>",
        "id": 294117963,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838865
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nHi,</p>\n<p>I think I can answer one of the questions myself:</p>\n<p>It works if I first show this lemma:</p>\n<hr>\n<p>lemma cont_prod_case [simp, cont2cont]:<br>\n  \"[|⋀ a b. cont (f a b)|] ==&gt; cont (λx. prod_case (λa b. f a b x) p)\"<br>\nunfolding prod_case_unfold<br>\nby (induct p) simp_all</p>\n<hr>\n<p>Does this mean that I have to show such a lemma for every function (or<br>\ncase expression) that contains a recursive call to the function I’m<br>\ndefining with fixrec? Or is there some automatism that I’m missing at<br>\nthe moment?</p>\n<p>Thanks again,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/z8J70UF8zkeHKdKP4sY0BOQO/signature.asc\">signature.asc</a></p>",
        "id": 294118207,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838933
    }
]