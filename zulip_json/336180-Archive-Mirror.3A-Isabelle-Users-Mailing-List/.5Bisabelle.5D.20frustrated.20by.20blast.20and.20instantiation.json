[
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:michael.norrish@nicta.com.au\">michael.norrish@nicta.com.au</a>&gt;<br>\nI am currently trying to prove what feels like a trivial lemma and<br>\nbecoming frustrated by meta-level quantifiers and blast, and no doubt<br>\nany number of sophisticated considerations that I'm not aware of.</p>\n<p>Here is a miniature theory that illustrates a stripped down version of<br>\nmy problem.</p>\n<hr>\n<p>theory foo<br>\n   imports Main</p>\n<p>begin</p>\n<p>consts c :: \"nat\"<br>\nconsts f :: \"nat =&gt; 'a\"</p>\n<p>lemma foo1: \"ALL i. EX! n. n &lt; c &amp; f n = i\"<br>\nsorry</p>\n<p>lemma foo2: \"(ALL k. P k) = (ALL i. i &lt; c --&gt; P (f i))\"<br>\napply rule<br>\n   apply simp<br>\napply rule+<br>\napply (insert foo1[where 'a = 'a])<br>\napply (drule_tac x = k in spec)<br>\napply blast<br>\ndone</p>\n<p>end</p>\n<hr>\n<p>(The theorem foo1 actually has a proof in the real setting.)</p>\n<p>This proof succeeds, but there are two things I dislike about it.</p>\n<ol>\n<li>\n<p>It seems as if I am doing the wrong thing in not converting foo1<br>\n     to be in \"rule_format\" (or proving it that way in the first<br>\n     place).  All the documentation I have suggests that rule_format is<br>\n     the right way to store lemmas.  But, I seem to have to keep the<br>\n     object level universal if I'm to be able to import/insert the<br>\n     result into the proof foo2.  If I have it in rule_format and<br>\n     insert it un-modified, then I get a meta-level implication in my<br>\n     premises, and I don't know how to do anything with that.  If I try<br>\n     to use \"of\" or \"where\" to instantiate a rule_format version of<br>\n     foo1, then the meta-level quantifier on the goal shifts its<br>\n     quantification over the goal's k to dodge my implication.</p>\n</li>\n<li>\n<p>I have to instantiate foo1 by hand, both to get its type variable<br>\n     correct, and then to instantiate i.  Why doesn't</p>\n<p>apply (blast intro: foo1)</p>\n<p>just solve this goal at the outset?  If I set the corresponding<br>\n   situation up in HOL4, my proof of foo2 looks like</p>\n<p>val foo2 = store_thm(<br>\n      \"foo2\",<br>\n<code>(!k. P k) = (!i. i &lt; c ==&gt; P (f i))</code>,<br>\n      PROVE_TAC [foo1])</p>\n<p>[ Perhaps I'm giving blast the wrong modifier.  But then, why<br>\n     doesn't blast let me just use add: and then figure out for<br>\n     itself how to use the given theorem?  I can believe that<br>\n     theorems being permanently added to the underlying reasoners<br>\n     should be carefully categorised as intro, dest or elim<br>\n     (particularly as there so many of them), but for a one-off<br>\n     tactic, having to apply thought is just a hindrance to getting<br>\n     through the proof. ]</p>\n</li>\n</ol>\n<p>So, what is the 'right' way to state foo1, and the right way to prove<br>\nfoo2?</p>\n<p>Michael.</p>",
        "id": 294045185,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817024
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI don't think this has anything to do with which quantifier you use - <br>\nblast just seems unable to prove the goal. This may be due to the <br>\npresence of \"=\". Larry may be able to comment.</p>\n<p>Concerning the quantifiers: certainly simp, but I believe also blast <br>\ndon't care what quantifiers a premise carries.</p>\n<p>Meta-level quantifiers in premises can be dealt with like object-level <br>\nones with the rules meta_spec and meta_allE.</p>\n<p>Tobias</p>\n<p>Michael Norrish schrieb:</p>",
        "id": 294045199,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817034
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMichael,</p>\n<p>You are right that the meta-level form of a theorem (using !! and  <br>\n==&gt;) is generally best, but it depends on various factors. You really  <br>\nneed to use an Isar structured proof to take advantage of this  <br>\nformat. Here is a nice version of your proof:</p>\n<p>lemma foo3: \"!!i. EX! n. n &lt; c &amp; f n = i\"<br>\nsorry</p>\n<p>lemma foo4: \"(ALL k. P k) = (ALL i. i &lt; c --&gt; P (f i))\"<br>\nproof auto<br>\n   fix k<br>\n   assume \"ALL i&lt;c. P (f i)\"<br>\n   with foo3 [of k]<br>\n   show \"P k\" by blast<br>\nqed</p>\n<p>The problem with the straight-line version is that k is a bound  <br>\nvariable, and instantiation by of/where (which is really intended for  <br>\nstructured proofs only) inserts a free variable. With the structured  <br>\nproof above, k becomes a free variable.</p>\n<p>Larry</p>",
        "id": 294045354,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817072
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:michael.norrish@nicta.com.au\">michael.norrish@nicta.com.au</a>&gt;<br>\nLawrence Paulson wrote:</p>\n<blockquote>\n<p>You really need to use an Isar structured proof to take advantage of<br>\nthis format. Here is a nice version of your proof:</p>\n</blockquote>\n<blockquote>\n<p>lemma foo3: \"!!i. EX! n. n &lt; c &amp; f n = i\"<br>\nsorry</p>\n</blockquote>\n<blockquote>\n<p>lemma foo4: \"(ALL k. P k) = (ALL i. i &lt; c --&gt; P (f i))\"<br>\nproof auto<br>\n  fix k<br>\n  assume \"ALL i&lt;c. P (f i)\"<br>\n  with foo3 [of k]<br>\n  show \"P k\" by blast<br>\nqed</p>\n</blockquote>\n<blockquote>\n<p>The problem with the straight-line version is that k is a bound<br>\nvariable, and instantiation by of/where (which is really intended<br>\nfor structured proofs only) inserts a free variable. With the<br>\nstructured proof above, k becomes a free variable.</p>\n</blockquote>\n<p>Thanks.  I think I appreciate the distinction between the different<br>\nsorts of variables a bit better now.  I was misled by or misunderstood<br>\nthe Tutorial's description of \"insert\", which uses of in an<br>\napply-style proof, and doesn't seem to run into any issues with<br>\nits quantifiers.</p>\n<p>Until I figure out Isar's declarative language, I'll use meta_allE for<br>\nthe moment (thanks, Tobias).</p>\n<p>Regards,<br>\nMichael.</p>",
        "id": 294045372,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817079
    }
]