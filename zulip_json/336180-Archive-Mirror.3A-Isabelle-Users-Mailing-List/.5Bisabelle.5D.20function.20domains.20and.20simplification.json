[
    {
        "content": "<p>From: Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt;<br>\ntheory test<br>\nimports Main<br>\nbegin</p>\n<p>(* This function returns some nat based on a list of nats.<br>\nIf there is a zero in the list, it will sometimes not terminate. *)<br>\nfunction testfun where<br>\n  \"testfun list =<br>\n    (if (list!0) &lt; length list<br>\n    then testfun (drop (list ! 0) list)<br>\n    else length list)\"<br>\nby pat_completeness auto</p>\n<p>lemma simp_loop: \"testfun_dom ([0]) ==&gt; testfun [0] = 1\"<br>\n(* apply (simp) loops *)<br>\nsorry</p>\n<p>lemma easy: \"testfun_dom ([2]) ==&gt; testfun [2] = 1\"<br>\napply simp<br>\ndone</p>\n<p>lemma weird: \"testfun_dom ([1, 2]) ==&gt; testfun [1, 2] = 1\"<br>\napply (simp)</p>\n<p>Here the simplifier behaves quite strangely, in my opinion. It<br>\nsimplifies testfun through one recursive iteration, leaving<br>\n\"testfun_dom [1, 2] ==&gt; testfun [2] = 1\". Why doesn't it simplify the<br>\nentire call?</p>\n<p>Not surprisingly, adding \"testfun_dom ([2])\" to the assumptions allows<br>\nit to complete. But it doesn't seem like that should be necessary,<br>\nsince \"testfun_dom ([1, 2]) ==&gt; testfun_dom ([2])\" due directly to the<br>\ndefinition of testfun. Generally speaking, if arg is the argument to<br>\nfun x, for each recursive call x' in x, arg' is in the domain if arg<br>\nis. But Isabelle doesn't seem aware of this. Should it be, ideally?</p>\n<p>This makes reasoning about potentially non-terminating recursive<br>\nfunctions nearly impossible, in my quite limited experience. Is this<br>\nthe experience of others?</p>\n<p>Chris Capel</p>",
        "id": 294078211,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829725
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Chris,</p>\n<blockquote>\n<p>function testfun where<br>\n  \"testfun list =<br>\n    (if (list!0) &lt; length list<br>\n    then testfun (drop (list ! 0) list)<br>\n    else length list)\"</p>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p>lemma weird: \"testfun_dom ([1, 2]) ==&gt; testfun [1, 2] = 1\"<br>\napply (simp)</p>\n<p>Here the simplifier behaves quite strangely, in my opinion. It<br>\nsimplifies testfun through one recursive iteration, leaving<br>\n\"testfun_dom [1, 2] ==&gt; testfun [2] = 1\". Why doesn't it simplify the<br>\nentire call?</p>\n<p>Not surprisingly, adding \"testfun_dom ([2])\" to the assumptions allows<br>\nit to complete. But it doesn't seem like that should be necessary,<br>\nsince \"testfun_dom ([1, 2]) ==&gt; testfun_dom ([2])\" due directly to the<br>\ndefinition of testfun. Generally speaking, if arg is the argument to<br>\nfun x, for each recursive call x' in x, arg' is in the domain if arg<br>\nis. But Isabelle doesn't seem aware of this. Should it be, ideally?</p>\n</blockquote>\n<p>Ideally, yes. But it is not trivial to make the simplifier do this in <br>\ngeneral, I think...</p>\n<blockquote>\n<p>This makes reasoning about potentially non-terminating recursive<br>\nfunctions nearly impossible, in my quite limited experience. Is this<br>\nthe experience of others?</p>\n</blockquote>\n<p>In the proofs I did with partial functions, I never had to evaluate a <br>\nconcrete function more than one or two steps, usually as part of an <br>\ninduction proof.</p>\n<p>If you want to use the simplifier to evaluate a partial function on some <br>\nconcrete input an arbitrary number of steps automatically, then I guess <br>\nyou need a special simproc, which automates the domain reasoning along <br>\nthe way... This hasn't been done yet, and I'd be interested in seeing a <br>\nmotivating example...</p>\n<p>Alex</p>",
        "id": 294078219,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829731
    }
]