[
    {
        "content": "<p>From: barzan stefania &lt;<a href=\"mailto:stefania_barzan@yahoo.com\">stefania_barzan@yahoo.com</a>&gt;<br>\nDear all,</p>\n<p>In Isabelle i always deal with simple algebra properties.  <br>\nI<br>\nproved that having g,h,y,t in (G,times), (a, b, a1, b1, c, c1 :: int) and this two equations:  <br>\n                                  (g (^) a) times (h (^) b)= t times (y<br>\n(^) c) <br>\n                              and (g (^) a1) times (h (^) b1)= t times (y (^) c1) <br>\n                              ==&gt;(g (^) (a-a1)) times (h (^) (b-b1))= y (^) (c-c1) is true.</p>\n<p>How can<br>\ni generalize this for finitely many base elements? <br>\n(for example to prove that<br>\nhaving (g1 (^) a1) times (g2 (^) a2) times... times (g87 (^) (a87))= t<br>\ntimes (y (^) c) <br>\n                              and (g1 (^) a1') times (g2 (^) a2') times... times (g87<br>\n(^) (a87'))= t times (y (^) c1) <br>\n         to get true (g1 (^) (a1-a1')) times (g2<br>\n(^) (a2-a2')) times... times (g87 (^) (a87-a87')))=  y (^) (c-c1)). <br>\nIs<br>\nthere a way at all? Is is not right the way i look at the problem?  </p>\n<p>Thank you very much!<br>\nStefania Barzan</p>",
        "id": 294076789,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829208
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nbarzan stefania wrote:</p>\n<blockquote>\n<p>Dear all,</p>\n<p>In Isabelle i always deal with simple algebra properties.  <br>\nI<br>\nproved that having g,h,y,t in (G,times), (a, b, a1, b1, c, c1 :: int) and this two equations:  <br>\n                                  (g (^) a) times (h (^) b)= t times (y<br>\n(^) c) <br>\n                              and (g (^) a1) times (h (^) b1)= t times (y (^) c1) <br>\n                              ==&gt;(g (^) (a-a1)) times (h (^) (b-b1))= y (^) (c-c1) is true.</p>\n<p>How can<br>\ni generalize this for finitely many base elements? <br>\n(for example to prove that<br>\nhaving (g1 (^) a1) times (g2 (^) a2) times... times (g87 (^) (a87))= t<br>\ntimes (y (^) c) <br>\n                              and (g1 (^) a1') times (g2 (^) a2') times... times (g87<br>\n(^) (a87'))= t times (y (^) c1) <br>\n         to get true (g1 (^) (a1-a1')) times (g2<br>\n(^) (a2-a2')) times... times (g87 (^) (a87-a87')))=  y (^) (c-c1)). <br>\nIs<br>\nthere a way at all? Is is not right the way i look at the problem?  </p>\n<p>Thank you very much!<br>\nStefania Barzan</p>\n<p>Barzan,</p>\n</blockquote>\n<p>To express something like</p>\n<p>(g1 (^) a1') times (g2 (^) a2') times... times (g87(^) (a87'))</p>\n<p>in a general way, you want to use foldl or foldr,</p>\n<blockquote>\n<p>read \"foldl\";<br>\nval it = Const (\"List.foldl\", \"('a =&gt; 'b =&gt; 'a) =&gt; 'a =&gt; 'b List.list =&gt; <br>\n'a\")<br>\n: Term.term<br>\nread \"foldr\";<br>\nval it = Const (\"List.foldr\", \"('a =&gt; 'b =&gt; 'b) =&gt; 'a List.list =&gt; 'b =&gt; <br>\n'b\")<br>\n: Term.term</p>\n</blockquote>\n<p>Jeremy</p>\n<p>&gt;       <br>\n&gt;</p>",
        "id": 294076813,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829217
    },
    {
        "content": "<p>From: Amine Chaieb &lt;<a href=\"mailto:ac638@cam.ac.uk\">ac638@cam.ac.uk</a>&gt;<br>\nHi,</p>\n<p>It seems like you need a version of setprod that works in set-based <br>\nlocales and not just on classes. This kind of problems starts showing up <br>\nmore often.</p>\n<p>If you had classes (i.e. no carrier set G --- I hope I am interpreting <br>\nyour formalization right) then</p>\n<p>you could write e.g. \"setprod (%i. g i (^) a i) {1..n}</p>\n<p>for (g1 (^) an) times (gn (^) an) times... times (gn (^) (an))</p>\n<p>where times is also denoted by *.</p>\n<p>Within a set-based locale, you might need to use the fold or fold_image <br>\niterator to \"re\"define setprod. Have a look at HOL/FiniteSet.thy to see <br>\nhow setprod is defined in terms of fold_image.</p>\n<p>A \"hack\" here is also to use foldl or foldr (proofs with foldr are <br>\neasier in general) over lists --- the length of the list will give you <br>\nthe n above, but you have to \"artificially\" enforce that you have the <br>\nsame number of g's and a's either by enforcing the two list to have the <br>\nsame length or by just using a list of pairs (gi,ai).</p>\n<p>Hope I am understanding your message right and that this helps,<br>\nAmine.</p>\n<p>barzan stefania wrote:</p>",
        "id": 294076826,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829222
    }
]