[
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>Wondering about the following :</p>\n<p>given a specific large number, is there a way to show what the set of <br>\nits proper divisors is?</p>\n<p>E.g. define:</p>\n<p>definition proper_divisor :: \"nat ⇒nat ⇒ bool \"  (infixr \"properdiv\" 80)<br>\n   where \" n properdiv m ≡(( n ≥ 1) ∧( n&lt; m) ∧ ( n dvd m) ) \"</p>\n<p>definition properdiv_set:  \"properdiv_set m ={n.  n properdiv m  }\"</p>\n<p>I want to show that :</p>\n<p>\"properdiv_set 819 = { 1, 3, 7, 9, 13, 21, 39, 63, 91, 117, 273 }\".</p>\n<p>Now, for a small number, e.g. for 9, the following works:</p>\n<p>\"properdiv_set (Suc(Suc(Suc(Suc (Suc (Suc (Suc (Suc (Suc 0))))))))) = <br>\n{1,3}\"<br>\n     by (auto simp: properdiv_set proper_divisor_def less_Suc_eq dvd_def; <br>\npresburger)</p>\n<p>but I need to have a way of showing what the set of proper divisors for <br>\nmuch larger numbers is.</p>\n<p>Any ideas would be much appreciated.</p>\n<p>Thank you,<br>\nAngeliki</p>",
        "id": 294830622,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246449
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIf you formulate it more computationally (and more consistenly spaced), you can <br>\nuse evaluation in ML:</p>\n<p>definition proper_divisor :: \"int ⇒int ⇒ bool \"  (infixr \"properdiv\" 80)<br>\n   where \"n properdiv m = (n ≥ 1 ∧ n&lt; m ∧ n dvd m)\"</p>\n<p>definition properdiv_set:  \"properdivs m = filter (λn. n properdiv m) [1..m]\"</p>\n<p>lemma \"properdivs 819 = [1, 3, 7, 9, 13, 21, 39, 63, 91, 117, 273]\"<br>\nby eval</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/6rSBOd4KaxaWET2CCmgPAUzm/smime.p7s\">smime.p7s</a></p>",
        "id": 294830643,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246461
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nAs far as I know, the fastest known algorithm for large numbers is to<br>\ncompute a prime factorisation and then just read off the set of<br>\ndivisors. Let's define the set of (not necessarily proper) divisors.</p>\n<p>definition divisors :: \"'a :: normalization_semidom ⇒ 'a set\" where<br>\n  \"divisors x = {y. normalize y = y ∧ y dvd x}\"</p>\n<p>I use a more general type so that it also works for int, poly, etc. but<br>\nI require that the divisors be normalized to make things nicer. For nat,<br>\nit doesn't make a difference.</p>\n<p>Then we can prove various nice lemmas like</p>\n<p>lemma divisors_prime_power:<br>\n  fixes p :: \"'a :: factorial_semiring\"<br>\n  assumes \"prime p\"<br>\n  shows   \"divisors (p ^ n) = (λi. normalize (p ^ i)) ` {..n}\"</p>\n<p>lemma divisors_mult_coprime:<br>\n  fixes a b :: \"'a :: semiring_gcd\"<br>\n  assumes \"coprime a b\"<br>\n  shows   \"divisors (a * b) = normalize ` (divisors a * divisors b)\"</p>\n<p>and finally</p>\n<p>lemma divisors_conv_prime_factorization':<br>\n  fixes x :: \"'a :: factorial_semiring_gcd\"<br>\n  assumes \"prime_factorization x = P\"<br>\n  assumes \"x ≠ 0\"<br>\n  shows   \"divisors x = normalize <code> (∏p∈set_mset P. (λi. p ^ i) </code><br>\n{..count P p})\"</p>\n<p>With this, you can easily compute the set of divisors as long as you<br>\nfactorize beforehand:</p>\n<p>lemma \"divisors (80389990399 :: nat) =<br>\n          {1, 101, 199, 10201, 20099, 39601, 2029999, 3999701, 7880599,<br>\n403969801,<br>\n           795940499, 80389990399}\"<br>\nproof -<br>\n  have \"prime (101 :: nat)\" and \"prime (199 :: nat)\"<br>\n    by simp_all<br>\n  hence *: \"prime_factorization 80389990399 = {#101, 101, 199, 199,<br>\n199::nat#}\"<br>\n    by (intro prime_factorization_eqI_strong) (auto simp del:<br>\nprime_nat_numeral_eq)<br>\n  show ?thesis<br>\n    by (subst divisors_conv_prime_factorization'[OF *])<br>\n       (simp_all add: set_times_image atMost_Suc insert_commute)<br>\nqed</p>\n<p>If you want the proper divisors, just kick out 1 and the number itself<br>\nand you're done! Of course, if you have a number with lots of prime<br>\ndivisors, it will be slow since there are lots of divisors. The builtin<br>\nprocedure to prove primality is also very slow, but other methods are<br>\navailable, as you know.</p>\n<p>By the way, a student of mine and I developed a simproc to do such<br>\nthings completely automatically, but I haven't had the time to put it in<br>\nthe distribution yet. Then, with some simple setup, you could just<br>\nevaluate \"divisors\" by an invocation of \"simp\" without having to<br>\nfactorise yourself.</p>\n<p>If you use the stuff I attached for anything that will go in the AFP,<br>\nplease put a \"TODO\" tag there because I should probably put this stuff<br>\nin the distribution at some point and then we can eliminate this<br>\nduplication.</p>\n<p>Manuel<br>\n<a href=\"/user_uploads/14278/hWaM4udRczwn866mrteKHeNn/Divisors.thy\">Divisors.thy</a></p>",
        "id": 294830677,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246480
    },
    {
        "content": "<p>From: \"Thiemann, René\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>computing the divisors for integers and natural numbers via<br>\nprime factorization is also readily available in the AFP:</p>\n<p>in thys/Polynomial_Factorization/Prime_Factorization.thy there<br>\nare divisors_nat and divisors_int functions.</p>\n<p>Best,<br>\nRené<br>\n<a href=\"/user_uploads/14278/Vj4f1PsA1czWO06aeKxWgWg-/signature.asc\">signature.asc</a></p>",
        "id": 294830730,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246511
    },
    {
        "content": "<p>From: \"Dr A. Koutsoukou-Argyraki\" &lt;<a href=\"mailto:ak2110@cam.ac.uk\">ak2110@cam.ac.uk</a>&gt;<br>\nDear all,</p>\n<p>Many thanks to Manuel, Tobias and René for their great alternative <br>\nsuggestions.</p>\n<p>I think I will opt for making use of René's AFP entry</p>\n<p>(as it is the one that is straightforward to use with my development, <br>\nwhich is already quite long-- using the other definitions would require <br>\na complete re-work of all my proofs)</p>\n<p>I noticed that computations of divisors of specific numbers using the <br>\nabove AFP entry are also easily done using \"by eval\"</p>\n<p>Thank you again,<br>\nBest,<br>\nAngeliki</p>",
        "id": 294830810,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661246529
    }
]