[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nHello all,</p>\n<p>I want to formalise a little bit of graph theory in Isabelle. (Specifically, I'm interested in directed labelled multigraphs.) In particular, I need a (disjoint) union operation on graphs. Here is a typical definition of this operation, which I've copied from a random textbook on graph theory:</p>\n<blockquote>\n<p>Let G and H be two given graphs. The disjoint union of G and H, denoted by G \\union H, is defined to be the graph with vertex set V(G) \\union V(H), where V(G) and V(H) are made disjoint by renaming if necessary, and edge set E(G) \\union E(H).</p>\n</blockquote>\n<p>A couple of questions:</p>\n<ol>\n<li>\n<p>Is there already a theory of graphs in Isabelle? (A previous message [1] on this mailing list referred to a \"HOL/Library/Graphs.thy\" theory, but I couldn't find a theory at that location -- perhaps it's not there any more?)</p>\n</li>\n<li>\n<p>If there isn't a pre-existing theory, and I roll my own instead, does anybody have any tips on how best to go about it? The phrase \"made disjoint by renaming if necessary\" smells a lot like Barendregt's variable convention for the lambda-calculus. So I'm wondering if I need Nominal Isabelle to formalise graph theory -- is that the case?</p>\n</li>\n</ol>\n<p>Thanks very much,<br>\nJohn</p>",
        "id": 294150884,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849266
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nA set-theoretic disjoint union of V(G) and V(H) might work, e.g. the graph<br>\nunion has nodes (True, g) where g is in G and (False, h) where h is in H,<br>\nrather than explicit renaming.</p>\n<p>I wouldn't think Nominal Isabelle is an obvious candidate because there's<br>\nno notion of variable binding in graphs (node names aren't variables,<br>\nthey're not either free or bound, etc.). (Right?)</p>\n<p>To make the disjoint union above work, I imagine your graphs would be a<br>\npolymorphic record where an \"'a graph\" has a record field that is its node<br>\n(multi)set, and nodes are elements of type \"'a\".</p>\n<p>If you found a way to make renaming work instead, then the node multiset<br>\ncould be non-polymorphic (e.g. a multiset of strings). For example you<br>\ncould add characters to the end of all the node names in one graph as<br>\nnecessary when you take a union... This could make it harder to recover the<br>\ncomponents of a union, or prove properties about unions.</p>",
        "id": 294150911,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849272
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nHi Ramana, thanks for this. I like your suggestion of tagging nodes with True or False.</p>\n<blockquote>\n<p>I wouldn't think Nominal Isabelle is an obvious candidate because there's no notion of variable binding in graphs (node names aren't variables, they're not either free or bound, etc.). (Right?)</p>\n</blockquote>\n<p>Hm, well I think one could argue that, in fact, there is some sort of binding going on here, though it's rather simpler than in the lambda calculus, and is implicit. I pick names for each node in the graph, then use those names to define the graph's connectivity and assign labels to nodes or edges. But once the graph is drawn, I don't care about the names any more. So I think there's a tacit name-binding operation happening here.</p>\n<p>John</p>",
        "id": 294150931,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849278
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nI see... you would want to identify graphs of the same shape just as we<br>\nidentify alpha-equivalent lambda terms.<br>\n(And be allowed to define a function on graphs (that doesn't depend on the<br>\nnames) by defining it on concrete (named) graphs, and having the system<br>\nlift it to up-to-isomorphism graphs.)<br>\nNominal Isabelle does help with this in the case of lambda terms, but you<br>\nbuild the terms as an inductive data type with the binders at certain nodes.<br>\nThe analogue for graphs would be to build graphs as an inductive datatype<br>\n(e.g. a constructor for a graph with n unconnected nodes, a constructor for<br>\nconnecting two subgraphs at their nth and mth nodes).<br>\nThen you either leave the names out altogether, or have a binder at each<br>\nnode.<br>\nThe problem is that, unlike lambda terms, graphs may have more than one<br>\nlargest proper subgraph, so you'd also want to quotient over different ways<br>\nof constructing the same graph.</p>\n<p>Alternatively, you build graphs a more natural way (set of nodes + mset of<br>\nedges).<br>\nI don't know if Nominal Isabelle would deal with such a datatype correctly.<br>\n(The analogue of lambda terms in this style might be (set of (variable,<br>\nposition) pairs, where a position is the number of left brackets before the<br>\nvariable if you bracketed every subterm).)<br>\nBut if it doesn't, you can always take the quotient type manually (and<br>\nthereby identify graphs of the same shape) with the quotient package.<br>\nIt's more work than you might want, but you can at least express what you<br>\nmean.</p>",
        "id": 294150949,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849285
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nI am currently developing some a theory of graphs, which can handle <br>\ndirected labelled multigraphs (graphs are as a \"'a set\" of vertexes, a <br>\n\"'b set\" of edges and two projections mapping edges to their start and <br>\nend nodes).</p>\n<p>It is not yet part of the Isabelle distribution. For the time being, you <br>\ncan find it at (look at the master branch):</p>\n<p><a href=\"http://www21.in.tum.de/~noschinl/git/?p=graph-formalization.git\">http://www21.in.tum.de/~noschinl/git/?p=graph-formalization.git</a></p>\n<p>However, I don't provide an operation for disjoint union of graphs.</p>\n<p>-- Lars</p>",
        "id": 294151010,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849310
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:Thomas.Sewell@nicta.com.au\">Thomas.Sewell@nicta.com.au</a>&gt;<br>\nMy two cents worth: it might make more sense to use the quotient package than the nominal package. Your intuition is that graph equality should be naming-independent.</p>\n<p>Define graphs as sets of pairs in some big-enough naming alphabet (naturals, strings, unspecified type 'a ...) and quotient by the equivalence relation of bijective renaming.</p>\n<p>That should give you a new type whose notion of equality matches your intuition. You may then have a bit of work to do to define the syntax and operations you need within the new type. I've never used the quotient package and don't know how much it will help you here. I think you could, for instance, define your disjoint union operator on the pairwise representation (easy) then lift it to an operator in the graph type by showing it respects the equivalence relation (tool support desirable).</p>\n<p>This is quite a different approach to Lars' so the relative merits should be thought about.</p>\n<p>Yours,<br>\n    Thomas.</p>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294151128,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849334
    }
]