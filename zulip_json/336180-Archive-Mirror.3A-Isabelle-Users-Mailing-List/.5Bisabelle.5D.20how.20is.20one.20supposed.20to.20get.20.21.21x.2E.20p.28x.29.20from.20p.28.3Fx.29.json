[
    {
        "content": "<p>From: Andrei Borac &lt;<a href=\"mailto:zerosum42@gmail.com\">zerosum42@gmail.com</a>&gt;<br>\nOk, so I have a kind of \"two-dimensional\" induction that I'm trying to<br>\ndo. Here is a stripped-down example that illustrates the difficulty:</p>\n<p>consts p :: \"nat =&gt; nat =&gt; bool\"</p>\n<p>lemma base: \"(p 0 y)\"<br>\nsorry (* lemma base: p 0 ?y *)</p>\n<p>lemma meta: \"(p row col) ==&gt; (p (row + 1) any_col)\"<br>\nsorry (* lemma meta: p ?row ?col ==&gt; p (?row + 1) ?any_col *)</p>\n<p>lemma half: \"(!!col. (p row col)) ==&gt; (p (row + 1) any_col)\"<br>\nsorry (* lemma half: (!!col. p ?row col) ==&gt; p (?row + 1) ?any_col *)</p>\n<p>lemma desired: \"(p row col)\"</p>\n<p>The base cases and inductive steps are simply \"provided\" using \"sorry\"<br>\nto keep the example simple. meta and half are basically the same thing<br>\nexcept in meta \"col\" is a meta-whatsitcalled or maybe<br>\nschematic-whatsitcalled. Now, after 3 hours of trial and error, I have<br>\nsucceeded in providing the desired lemma:</p>\n<p>lemma helper: \"!!row. (!!col. p row col) ==&gt; p (Suc row) col\"<br>\napply(drule half[where any_col=col])<br>\napply(simp)<br>\ndone (* lemma helper: (!!col. p ?row col) ==&gt; p (Suc ?row) ?col *)</p>\n<p>lemma desired: \"(p row col)\"<br>\napply(induct row arbitrary: col)<br>\napply(simp add: base)<br>\napply(simp add: helper)<br>\ndone (* lemma desired: p ?row ?col *)</p>\n<p>So, how is this kind of thing -supposed- to be done? Is there a way to<br>\napply something in the main proof to get this done without a helper<br>\nlemma? I was thinking the obvious thing is change it to subgoal_tac,<br>\nbut so far all my attempts have been unsuccessful. Plus, it seems like<br>\nthere should be an even better way.</p>\n<p>Thanks,<br>\n-Andrei</p>",
        "id": 294107822,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835797
    },
    {
        "content": "<p>From: Andrei Borac &lt;<a href=\"mailto:zerosum42@gmail.com\">zerosum42@gmail.com</a>&gt;<br>\nOk, second attempt; I have found a more accurate way to represent the<br>\nproblem. Sorry that the title is incorrect (it's p(some x) from !!x.<br>\np(x)). Anyways, here is what is actually not working:</p>\n<p>consts f :: \"nat list =&gt; nat =&gt; nat option\"<br>\nconsts g :: \"nat list =&gt; nat =&gt; nat option\"</p>\n<p>lemma False<br>\napply(subgoal_tac \"<br>\n!!context param value.<br>\n  [| !!param_any.<br>\n         f context param_any = Some value<br>\n             ==&gt; (case (g context param_any) of None =&gt; 0<br>\n                  | Some value_some =&gt; value_some) = value;<br>\n     g context param = None;<br>\n     f context param = Some value |]<br>\n  ==&gt; value = 0\")<br>\ndefer</p>\n<p>Resulting in the first subgoal:</p>\n<p>!!context param value.<br>\n       [| !!param_any.<br>\n             f context param_any = Some value<br>\n             ==&gt; (case g context param_any of None =&gt; 0 | Some<br>\nvalue_some =&gt; value_some) = value;<br>\n          g context param = None; f context param = Some value |]<br>\n       ==&gt; value = 0</p>\n<p>where all variables are green. Now it seems like setting \"param_any\"<br>\nto \"param\" should work. We know that \"f\" produced something and that<br>\nthe case of \"g\" is None, so we should get value = 0, as required.<br>\nHowever, clarsimp will not do it (and I can't seem to be able to split<br>\nthe option in my apply-style proof). What will work (or why can't it<br>\nwork ...)?</p>\n<p>-Andrei</p>",
        "id": 294107931,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835834
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThis is how you ca instantiate a !! hypothesis in apply style:</p>\n<p>apply(erule_tac x = \"&lt;term&gt;\" in meta_allE)</p>\n<p>Not pretty and not very stable under changes, but it works. I recommend<br>\nto use it only for finding a proof but rewrite it at the end (into a<br>\nstructured proof).</p>\n<p>In your case there are alternatives: auto/fastsimp/force solve your goal<br>\nautomatically; clarsimp is just too weak.</p>\n<p>Tobias</p>\n<p>Andrei Borac schrieb:</p>",
        "id": 294107993,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835852
    }
]