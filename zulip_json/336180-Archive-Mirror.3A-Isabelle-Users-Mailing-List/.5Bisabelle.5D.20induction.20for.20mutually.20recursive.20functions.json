[
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Viorel,</p>\n<p>The two versions are actually equivalent, so one should be provable when <br>\nthe other is. Unfortunately, the equation \"na = n\" seems to be oriented <br>\nin an unfortunate way, such that the simplifier does not help you here...</p>\n<p>Note that here you are relying on a feature of the induct method to do <br>\ninduction over non-variable terms, which introduces equations on the fly <br>\n(which you already see in the simplified form; if you add (no_simp) <br>\nafter \"induct\", you see where they come from).</p>\n<p>You can avoid this situation altogether by using currying instead of <br>\ntuple arguments in your function definition, which is generally recommended:</p>\n<p>function<br>\n   init_fun :: \"nat =&gt; nat * nat * nat\"<br>\n   and loop_fun :: \"nat =&gt; nat =&gt; nat =&gt; nat * nat * nat\"<br>\n   and final_fun :: \"nat =&gt; nat =&gt; nat =&gt; nat * nat * nat\"<br>\n   where<br>\n     \"init_fun n = loop_fun n 0 0\" |<br>\n     \"loop_fun n k s = (if k &lt; n then loop_fun n (k + 1) (s + k + 1)<br>\n                              else if k = n then final_fun n k s<br>\n                              else (n, k, s))\"|</p>\n<p>\"final_fun n k s = (n, k, s)\"</p>\n<p>by pat_completeness auto<br>\ntermination<br>\n   apply (relation \"measure (% x. case x of Inl n =&gt; n + 3 | Inr (Inl <br>\n(n, k, s)) =&gt; n - k + 2 | Inr (Inr (n, k, s)) =&gt; n - k + 1)\")<br>\n   by auto</p>\n<p>theorem TestInduction:<br>\n   \"Testa n ==&gt;  Test (init_fun n)\"<br>\n   \"Testb n k s ==&gt; Test (loop_fun n k s)\"<br>\n   \"Testc n k s ==&gt; Test (final_fun n k s)\"<br>\napply (induct n and n k s and n k s rule: <br>\ninit_fun_loop_fun_final_fun.induct)</p>\n<p>Hope this helps...</p>\n<p>Alex</p>",
        "id": 294143810,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846791
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHi Alex,</p>\n<p>That you for your message. Changing the function definition to<br>\nthe curried version helped. After this change I got<br>\nthe proof obligations that I expected.</p>\n<p>I managed already to prove the theorem by instantiating the<br>\ninduction theorems manually, but it was very cumbersome,<br>\nand I needed to prove the same facts 3 times.</p>\n<p>Regarding my initial definition, it still does not seem provable.<br>\nThe conditions na = n; 0 = k; 0 = s cannot be discharged.<br>\nIf you look at the second subgoal, the situation is even worse<br>\nbecause one would need to prove k = k+1. Maybe there is an error<br>\nin applying the induction when the functions have tuples<br>\nas parameters.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294143822,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846794
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello,</p>\n<p>I have the following mutually recursive function definition</p>\n<p>function<br>\n   init_fun :: \"nat =&gt; nat * nat * nat\"<br>\n   and loop_fun :: \"nat * nat * nat =&gt; nat * nat * nat\"<br>\n   and final_fun :: \"nat * nat * nat =&gt; nat * nat * nat\"<br>\n   where<br>\n     \"init_fun n = loop_fun (n, 0, 0)\" |<br>\n     \"loop_fun (n, k, s) = (if k &lt; n then loop_fun (n, k + 1, s + k + 1)<br>\n                              else if k = n then final_fun (n, k, s)<br>\n                              else (n, k, s))\"|</p>\n<p>\"final_fun (n, k, s) = (n, k, s)\"</p>\n<p>by pat_completeness auto<br>\ntermination<br>\n   apply (relation \"measure (% x. case x of Inl n =&gt; n + 3 | Inr (Inl <br>\n(n, k, s)) =&gt; n - k + 2 | Inr (Inr (n, k, s)) =&gt; n - k + 1)\")<br>\n   by auto</p>\n<p>Asumming that Testa, Testb, Testc, and Test are defined I want to prove by<br>\n(mutual) induction:</p>\n<p>theorem TestInduction:<br>\n   \"Testa n ==&gt;  Test (init_fun n)\"<br>\n   \"Testb n k s ==&gt; Test (loop_fun (n, k, s))\"<br>\n   \"Testc n k s ==&gt; Test (final_fun (n, k, s))\"</p>\n<p>If I try</p>\n<p>apply (induct n and \"(n, k, s)\" and \"(n, k, s)\" rule: <br>\ninit_fun_loop_fun_final_fun.induct)</p>\n<p>I get something that is unprovable:</p>\n<ol>\n<li>\n<p>[| [| na = n; 0 = k; 0 = s; Testb n k s|] ==&gt; Test (loop_fun (n, k, <br>\ns)); Testa na |] ==&gt; Test (init_fun na)</p>\n</li>\n<li>\n<p>...</p>\n</li>\n<li>...</li>\n</ol>\n<p>I would expect something like:</p>\n<ol>\n<li>\n<p>[| [| Testb na 0 0|] ==&gt; Test (loop_fun (na, 0, 0)); Testa na |] ==&gt; <br>\nTest (init_fun na)</p>\n</li>\n<li>\n<p>...</p>\n</li>\n<li>...</li>\n</ol>\n<p>that I can prove using the definition of the Test predicates.</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294145217,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847242
    }
]