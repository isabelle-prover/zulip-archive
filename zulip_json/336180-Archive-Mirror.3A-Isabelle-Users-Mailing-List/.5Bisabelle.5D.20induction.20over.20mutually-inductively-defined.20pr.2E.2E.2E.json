[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nHello,</p>\n<p>I have a whole bunch of mutually-inductively-defined datatypes, functions and predicates in my theory, and I'm having difficulty doing structural and rule induction over them.</p>\n<p>At the end of this email is my (slightly condensed) theory file. Apologies for not creating a minimal example exhibiting my problem -- I thought it better to leave the theory file mostly as-is, to ensure that your solutions apply to my real script and not just to some minimal example.</p>\n<p>The problem is the last line ... </p>\n<blockquote>\n<p>proof(induct rule: prov_dia_prov_col.induct)</p>\n</blockquote>\n<p>... which gives an error (\"Proof command failed\"), despite my goal being of the required form \"?P ?a \\&lt;and&gt; ?Q ?A\". My question is: How can I give Isabelle hints to help it work out how to apply the given induction rule? </p>\n<p>Many thanks,<br>\nJohn</p>\n<p>------------8&lt;-------------</p>\n<p>theory Ribbons imports Main</p>\n<p>begin</p>\n<p>typedecl bool_exp<br>\nconsts Not :: \"bool_exp \\&lt;Rightarrow&gt; bool_exp\"<br>\nconsts rd_be :: \"bool_exp \\&lt;Rightarrow&gt; string set\"</p>\n<p>typedecl assertion<br>\nconsts Emp :: \"assertion\"<br>\nconsts Pure :: \"bool_exp \\&lt;Rightarrow&gt; assertion\"</p>\n<p>axiomatization<br>\n  Star :: \"assertion \\&lt;Rightarrow&gt; assertion \\&lt;Rightarrow&gt; assertion\"<br>\nwhere star_comm: \"Star p q = Star q p\"<br>\n  and star_assoc: \"Star (Star p q) r = Star p (Star q r)\"<br>\n  and star_emp: \"Star p Emp = p\"<br>\n  and emp_star: \"Star Emp p = p\"</p>\n<p>consts Exists :: \"string \\&lt;Rightarrow&gt; assertion \\&lt;Rightarrow&gt; assertion\"</p>\n<p>axiomatization <br>\n  rd_ass :: \"assertion \\&lt;Rightarrow&gt; string set\"<br>\nwhere rd_emp: \"rd_ass Emp = {}\"<br>\n  and rd_star: \"rd_ass (Star p q) = rd_ass p \\&lt;union&gt; rd_ass q\"<br>\n  and rd_exists: \"rd_ass (Exists x p) = rd_ass p\"</p>\n<p>typedecl atomic<br>\nconsts rd_atm :: \"atomic \\&lt;Rightarrow&gt; string set\"<br>\nconsts wr_atm :: \"atomic \\&lt;Rightarrow&gt; string set\"</p>\n<p>datatype command =<br>\n  Atomic \"atomic\"<br>\n| If \"bool_exp\" \"command list\" \"command list\"<br>\n| While \"bool_exp\" \"command list\"</p>\n<p>fun<br>\n  interleave_coms :: \"(command list \\&lt;times&gt; command list) \\&lt;Rightarrow&gt; command list set\"<br>\nwhere<br>\n  \"interleave_coms ([], C2) = {C2}\"<br>\n| \"interleave_coms (C1, []) = {C1}\"<br>\n| \"interleave_coms (c1#C1, c2#C2)<br>\n  = {c1#C | C. C \\&lt;in&gt; interleave_coms(C1, c2#C2)}<br>\n  \\&lt;union&gt; {c2#C | C. C \\&lt;in&gt; interleave_coms(c1#C1, C2)}\"</p>\n<p>inductive<br>\n  prov_com :: \"assertion \\&lt;times&gt; command \\&lt;times&gt; assertion \\&lt;Rightarrow&gt; bool\"<br>\nand<br>\n  prov_comlist :: \"assertion \\&lt;times&gt; command list \\&lt;times&gt; assertion \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n  exists: <br>\n  \"prov_com (p, c, q) <br>\n  \\&lt;Longrightarrow&gt; prov_com (Exists x p, c, Exists x q)\"<br>\n| ifcom: <br>\n  \"\\&lt;lbrakk&gt;prov_comlist (Star (Pure b) p, C1, q); <br>\n  prov_comlist (Star (Pure (Not b)) p, C2, q)\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; prov_com (p, If b C1 C2, q)\"<br>\n| while: <br>\n  \"prov_comlist (Star (Pure b) p, C, p) <br>\n  \\&lt;Longrightarrow&gt; prov_com (p, While b C, Star (Pure (Not b)) p)\" <br>\n| frame: <br>\n  \"\\&lt;lbrakk&gt;prov_com (p, c, q); wr_com(c) \\&lt;inter&gt; rd_ass(r) = {}\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; prov_com (Star p r, c, Star q r)\"<br>\n| skip: <br>\n  \"prov_comlist(p, [], p)\"<br>\n| seq: <br>\n  \"\\&lt;lbrakk&gt;prov_com (p, c, q); prov_comlist (q, C, r)\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; prov_comlist (p, c#C, r)\"</p>\n<p>datatype face =<br>\n  Ribbon \"assertion\"<br>\n| Exists_int \"string\" \"face list\"</p>\n<p>type_synonym interface = \"face list\"</p>\n<p>fun<br>\n  ass_face :: \"face \\&lt;Rightarrow&gt; assertion\"<br>\nand<br>\n  ass :: \"interface \\&lt;Rightarrow&gt; assertion\"<br>\nwhere<br>\n  \"ass_face (Ribbon p) = p\"<br>\n| \"ass_face (Exists_int x P) = Exists x (ass P)\"<br>\n| \"ass [] = Emp\"<br>\n| \"ass (f#P) = Star (ass_face f) (ass P)\"</p>\n<p>datatype column =<br>\n  Blank \"interface\"<br>\n| Basic \"interface\" \"command\" \"interface\"<br>\n| VComp_dia \"column list\" \"column list\"<br>\n| Exists_dia \"string\" \"column list\"<br>\n| If_dia \"interface\" \"bool_exp\" \"column list\" \"column list\" \"interface\"<br>\n| While_dia \"interface\" \"bool_exp\" \"column list\" \"interface\"</p>\n<p>type_synonym diagram = \"column list\"</p>\n<p>fun<br>\n  top :: \"diagram \\&lt;Rightarrow&gt; interface\"<br>\nand<br>\n  top_col :: \"column \\&lt;Rightarrow&gt; interface\"<br>\nwhere<br>\n  \"top_col (Blank P) = P\"<br>\n| \"top_col (Basic P c Q) = P\"<br>\n| \"top_col (VComp_dia A B) = top A\"<br>\n| \"top_col (Exists_dia x A) = [Exists_int x (top A)]\"<br>\n| \"top_col (If_dia P b A B Q) = P\"<br>\n| \"top_col (While_dia P b A Q) = P\"<br>\n| \"top [] = []\"<br>\n| \"top (a # A) = (top_col a) @ (top A)\"</p>\n<p>fun<br>\n  bot :: \"diagram \\&lt;Rightarrow&gt; interface\"<br>\nand<br>\n  bot_col :: \"column \\&lt;Rightarrow&gt; interface\"<br>\nwhere<br>\n  \"bot_col (Blank P) = P\"<br>\n| \"bot_col (Basic P c Q) = Q\"<br>\n| \"bot_col (VComp_dia A B) = bot B\"<br>\n| \"bot_col (Exists_dia x A) = [Exists_int x (bot A)]\"<br>\n| \"bot_col (If_dia P b A B Q) = Q\"<br>\n| \"bot_col (While_dia P b A Q) = Q\"<br>\n| \"bot [] = []\"<br>\n| \"bot (a # A) = (bot_col a) @ (bot A)\"</p>\n<p>fun<br>\n  coms :: \"diagram \\&lt;Rightarrow&gt; command list set\"<br>\nand<br>\n  coms_col :: \"column \\&lt;Rightarrow&gt; command list set\"<br>\nwhere<br>\n  \"coms_col (Blank P) = {}\"<br>\n| \"coms_col (Basic P c Q) = {[c]}\"<br>\n| \"coms_col (VComp_dia A B) <br>\n  = {C @ C' | C C'. C \\&lt;in&gt; coms A \\&lt;and&gt; C' \\&lt;in&gt; coms B}\"<br>\n| \"coms_col (Exists_dia x A) = coms A\"<br>\n| \"coms_col (If_dia P b A B Q) <br>\n  = { [If b C C'] | C C'. C \\&lt;in&gt; coms A \\&lt;and&gt; C' \\&lt;in&gt; coms B}\"<br>\n| \"coms_col (While_dia P b A Q) = { [While b C] | C. C \\&lt;in&gt; coms A}\"<br>\n| \"coms [] = {}\"<br>\n| \"coms (a # A) <br>\n  = \\&lt;Union&gt;{interleave_coms (C, C') | C C'. C \\&lt;in&gt; coms_col a \\&lt;and&gt; C' \\&lt;in&gt; coms A}\"</p>\n<p>consts <br>\n  disj_col_dia :: \"column \\&lt;Rightarrow&gt; diagram \\&lt;Rightarrow&gt; bool\"</p>\n<p>inductive<br>\n  prov_dia :: \"diagram \\&lt;Rightarrow&gt; bool\"<br>\nand<br>\n  prov_col :: \"column \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n  Blank: <br>\n  \"prov_col (Blank P)\"<br>\n| Basic: <br>\n  \"prov_com (ass P, c, ass Q) \\&lt;Longrightarrow&gt; prov_col (Basic P c Q)\"<br>\n| Exists: <br>\n  \"prov_dia A \\&lt;Longrightarrow&gt; prov_col (Exists_dia x A)\"<br>\n| VComp: <br>\n  \"\\&lt;lbrakk&gt;prov_dia A; prov_dia B; bot A = top B\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; prov_col (VComp_dia A B)\"<br>\n| If: <br>\n  \"\\&lt;lbrakk&gt;prov_dia A; prov_dia B; top A = (Ribbon (Pure b)) # P; <br>\n  top B = (Ribbon (Pure (Not b))) # P; bot A = Q; bot B = Q\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; prov_col (If_dia P b A B Q)\"<br>\n| While: <br>\n  \"\\&lt;lbrakk&gt;prov_dia A; top A = (Ribbon(Pure b)) # P; <br>\n  bot A = P; Q = (Ribbon(Pure (Not b))) # P\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; prov_col (While_dia P b A Q)\"<br>\n| Nil: <br>\n  \"prov_dia []\"<br>\n| Cons:<br>\n  \"\\&lt;lbrakk&gt;prov_col a; prov_dia A; disj_col_dia a A\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; prov_dia (a # A)\"</p>\n<p>datatype chain = <br>\n  cNil \"assertion\"<br>\n| cCons \"assertion\" \"command\" \"chain\"</p>\n<p>fun <br>\n  seq_chains :: \"chain \\&lt;times&gt; chain \\&lt;Rightarrow&gt; chain\"<br>\nwhere<br>\n  \"seq_chains (cNil _, G') = G'\"<br>\n| \"seq_chains (cCons p c G, G') = cCons p c (seq_chains (G, G'))\"</p>\n<p>fun<br>\n  pre :: \"chain \\&lt;Rightarrow&gt; assertion\"<br>\nwhere<br>\n  \"pre(cNil p) = p\"<br>\n| \"pre(cCons p c G) = p\"</p>\n<p>fun <br>\n  post :: \"chain \\&lt;Rightarrow&gt; assertion\"<br>\nwhere<br>\n  \"post(cNil p) = p\"<br>\n| \"post(cCons p c G) = post G\"</p>\n<p>fun<br>\n  comlist :: \"chain \\&lt;Rightarrow&gt; command list\"<br>\nwhere<br>\n  \"comlist(cNil p) = []\"<br>\n| \"comlist(cCons p c G) = c # (comlist G)\"</p>\n<p>fun<br>\n  ass_map :: \"(assertion \\&lt;Rightarrow&gt; assertion) \\&lt;Rightarrow&gt; chain \\&lt;Rightarrow&gt; chain\"<br>\nwhere<br>\n  \"ass_map f (cNil p) = cNil (f p)\"<br>\n| \"ass_map f (cCons p c G) = cCons (f p) c (ass_map f G)\"</p>\n<p>function<br>\n  interleave_chains :: \"(chain \\&lt;times&gt; chain) \\&lt;Rightarrow&gt; chain set\"<br>\nwhere<br>\n  \"interleave_chains (cNil p, G) = {ass_map (\\&lt;lambda&gt;q. Star p q) G}\"<br>\n| \"interleave_chains (G, cNil p) = {ass_map (\\&lt;lambda&gt;q. Star q p) G}\"<br>\n| \"interleave_chains (cCons p1 c1 G1, cCons p2 c2 G2)<br>\n  = {cCons (Star p1 p2) c1 G | G. <br>\n      G \\&lt;in&gt; interleave_chains(G1, cCons p2 c2 G2)}<br>\n  \\&lt;union&gt; {cCons (Star p1 p2) c2 G | G. <br>\n      G \\&lt;in&gt; interleave_chains(cCons p1 c1 G1, G2)}\"<br>\nby pat_completeness auto<br>\ntermination by lexicographic_order</p>\n<p>lemma chainpair_induction [case_names Nil_Cons Cons_Nil Cons_Cons]:<br>\n  assumes \"\\&lt;And&gt;p1 G2. \\&lt;Phi&gt; (cNil p1) G2\"<br>\n  assumes \"\\&lt;And&gt;p2 G1. \\&lt;Phi&gt; G1 (cNil p2)\"<br>\n  assumes \"\\&lt;And&gt;p1 p2 c1 c2 G1 G2.<br>\n  \\&lt;lbrakk&gt;\\&lt;Phi&gt; G1 (cCons p2 c2 G2); \\&lt;Phi&gt; (cCons p1 c1 G1) G2\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; \\&lt;Phi&gt; (cCons p1 c1 G1) (cCons p2 c2 G2)\"<br>\n  shows \"\\&lt;Phi&gt; G1 G2\"<br>\nusing assms<br>\nby induction_schema (pat_completeness, lexicographic_order)</p>\n<p>consts disj_chain :: \"chain \\&lt;Rightarrow&gt; chain \\&lt;Rightarrow&gt; bool\"</p>\n<p>inductive<br>\n  prov_chain :: \"chain \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n  skip: \"prov_chain(cNil p)\"<br>\n| seq: \"\\&lt;lbrakk&gt;prov_com(p, c, pre G); prov_chain G\\&lt;rbrakk&gt; <br>\n  \\&lt;Longrightarrow&gt; prov_chain(cCons p c G)\" </p>\n<p>fun<br>\n  chains :: \"diagram \\&lt;Rightarrow&gt; chain set\"<br>\nand<br>\n  chains_col :: \"column \\&lt;Rightarrow&gt; chain set\"<br>\nwhere<br>\n  \"chains_col (Blank P) = {cNil (ass P)}\"<br>\n| \"chains_col (Basic P c Q) = {cCons (ass P) c (cNil (ass Q))}\"<br>\n| \"chains_col (VComp_dia A B) = {seq_chains (G1, G2) <br>\n  | G1 G2. G1 \\&lt;in&gt; chains A \\&lt;and&gt; G2 \\&lt;in&gt; chains B \\&lt;and&gt; post G1 = pre G2}\"<br>\n| \"chains_col (Exists_dia x A) = {ass_map (Exists x) G <br>\n  | G. G \\&lt;in&gt; chains A}\"<br>\n| \"chains_col (If_dia P b A B Q) = <br>\n  {cCons (ass P) (If b (comlist G1) (comlist G2)) (cNil (ass Q)) <br>\n  | G1 G2. G1 \\&lt;in&gt; chains A \\&lt;and&gt; G2 \\&lt;in&gt; chains B <br>\n    \\&lt;and&gt; pre G1 = Star (Pure b) (ass P) <br>\n    \\&lt;and&gt; pre G2 = Star (Pure (Not b)) (ass P) <br>\n    \\&lt;and&gt; post G1 = ass Q \\&lt;and&gt; post G2 = ass Q }\"<br>\n| \"chains_col (While_dia P b A Q) = <br>\n  { cCons (ass P) (While b (comlist G)) (cNil (ass Q)) <br>\n  | G. G \\&lt;in&gt; chains A \\&lt;and&gt; post G = ass P<br>\n    \\&lt;and&gt; pre G = Star (Pure b) (ass P) <br>\n    \\&lt;and&gt; ass Q = Star (Pure (Not b)) (ass P) }\"<br>\n| \"chains [] = {}\"<br>\n| \"chains (a # A) = \\&lt;Union&gt; {interleave_chains (G1, G2) <br>\n  | G1 G2. G1 \\&lt;in&gt; chains_col a \\&lt;and&gt; G2 \\&lt;in&gt; chains A \\&lt;and&gt; disj_chain G1 G2}\"</p>\n<p>lemma soundness_part_one:<br>\n  fixes a and A<br>\n  shows \"(prov_col a \\&lt;longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains_col a. prov_chain G)) \\&lt;and&gt; (prov_dia A \\&lt;longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains A. prov_chain G))\"<br>\nproof(induct rule: prov_dia_prov_col.induct)</p>",
        "id": 294147473,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848035
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYou have given the two conjuncts in the wrong order. Swap them and it works.</p>\n<p>Tobias</p>",
        "id": 294147516,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848050
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nThanks Christian. With a little more fiddling, I have found the following to be roughly equivalent. One can either use the *.induct rule, like so (I previously had the conjuncts the wrong way round):</p>\n<p>lemma soundness_part_one:<br>\n  shows \"(prov_dia A \\&lt;longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains A. prov_chain G)) \\&lt;and&gt; (prov_col a \\&lt;longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains_col a. prov_chain G))\" <br>\nproof(induct rule: prov_dia_prov_col.induct)</p>\n<p>or the *.inducts rule, like so:</p>\n<p>lemma soundness_part_one:<br>\n  shows \"(prov_dia A \\&lt;Longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains A. prov_chain G))\" <br>\n  and \"(prov_col a \\&lt;Longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains_col a. prov_chain G))\" <br>\nproof(induct rule: prov_dia_prov_col.inducts)</p>\n<p>Thanks for your help!</p>\n<p>john</p>",
        "id": 294147524,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848052
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\n$ISABELLE_HOME/src/HOL/Induct/Common_Patterns.thy, I guess.</p>\n<p>-- Lars</p>",
        "id": 294147541,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848058
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nYes, exactly! Christian</p>\n<p>Lars Noschinski writes:</p>\n<blockquote>\n<p>On 08.11.2011 17:45, Christian Urban wrote:</p>\n<blockquote>\n<p>There used to be an example theory in the Isabelle<br>\ndistribution which explains all bells and whistles of the<br>\ninduct-method, but I cannot find it at the moment. Maybe others<br>\ncan point to it.</p>\n</blockquote>\n<p>$ISABELLE_HOME/src/HOL/Induct/Common_Patterns.thy, I guess.</p>\n<p>-- Lars</p>\n</blockquote>",
        "id": 294147559,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848064
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nHi John,</p>\n<p>Just one minor point. The second version with *.inducts<br>\nhas the slight advantage to be already \"rule format\" <br>\nready to be used by other automated tools. The one<br>\nwith induct is still in \"object format\" and would need<br>\nsome further processing to be usable with for example, simp<br>\nor auto. Generally the rule of thumb should be to state<br>\nlemmas in terms of \\&lt;And&gt; and ==&gt;, instead of \\&lt;and&gt; <br>\nand --&gt;. This allows for more automation by Isabelle <br>\nand for cleaner proofs in Isar.</p>\n<p>Best wishes,<br>\nChristian</p>\n<p>John Wickerson writes:</p>\n<blockquote>\n<p>Thanks Christian. With a little more fiddling, I have found the following to be roughly equivalent. One can either use the *.induct rule, like so (I previously had the conjuncts the wrong way round):</p>\n<p>lemma soundness_part_one:<br>\n  shows \"(prov_dia A \\&lt;longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains A. prov_chain G)) \\&lt;and&gt; (prov_col a \\&lt;longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains_col a. prov_chain G))\" <br>\nproof(induct rule: prov_dia_prov_col.induct)</p>\n<p>or the *.inducts rule, like so:</p>\n<p>lemma soundness_part_one:<br>\n  shows \"(prov_dia A \\&lt;Longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains A. prov_chain G))\" <br>\n  and \"(prov_col a \\&lt;Longrightarrow&gt; (\\&lt;forall&gt;G \\&lt;in&gt; chains_col a. prov_chain G))\" <br>\nproof(induct rule: prov_dia_prov_col.inducts)</p>\n<p>Thanks for your help!</p>\n<p>john<br>\n</p>\n</blockquote>\n<blockquote>\n<p>On 8 Nov 2011, at 16:45, Christian Urban wrote:</p>\n<blockquote>\n<p>Hi John,</p>\n<p>Mutual inductions can be a bit fiddly. Therefore inductive, <br>\ndatatype and other tools provide an \"*.inducts\" rule. This<br>\nrule is essentially the projection of the \"*.induct\" rule.<br>\n(So no need to state the rule using conjunctions.)  With this <br>\nthe induct method can more easily figure out which induction <br>\nto perform. There used to be an example theory in the Isabelle <br>\ndistribution which explains all bells and whistles of the <br>\ninduct-method, but I cannot find it at the moment. Maybe others <br>\ncan point to it. Below is a theory that should work in your example.</p>\n<p>Hope this helps,<br>\nChristian</p>\n<p>&lt;Ribbons.thy&gt;</p>\n<p>John Wickerson writes:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have a whole bunch of mutually-inductively-defined datatypes, functions and predicates in my theory, and I'm having difficulty doing structural and rule induction over them.</p>\n<p>At the end of this email is my (slightly condensed) theory file. Apologies for not creating a minimal example exhibiting my problem -- I thought it better to leave the theory file mostly as-is, to ensure that your solutions apply to my real script and not just to some minimal example.</p>\n<p>The problem is the last line ... </p>\n<blockquote>\n<p>proof(induct rule: prov_dia_prov_col.induct)</p>\n</blockquote>\n<p>... which gives an error (\"Proof command failed\"), despite my goal being of the required form \"?P ?a \\&lt;and&gt; ?Q ?A\". My question is: How can I give Isabelle hints to help it work out how to apply the given induction rule? </p>\n<p>Many thanks,<br>\nJohn</p>\n<p>------------8&lt;-------------</p>\n<p>theory Ribbons imports Main</p>\n<p>begin</p>\n<p>typedecl bool_exp<br>\nconsts Not :: \"bool_exp \\&lt;Rightarrow&gt; bool_exp\"<br>\nconsts rd_be :: \"bool_exp \\&lt;Rightarrow&gt; string set\"</p>\n<p>typedecl assertion<br>\nconsts Emp :: \"assertion\"<br>\nconsts Pure :: \"bool_exp \\&lt;Rightarrow&gt; assertion\"</p>\n<p>axiomatization<br>\n Star :: \"assertion \\&lt;Rightarrow&gt; assertion \\&lt;Rightarrow&gt; assertion\"<br>\nwhere star_comm: \"Star p q = Star q p\"<br>\n and star_assoc: \"Star (Star p q) r = Star p (Star q r)\"<br>\n and star_emp: \"Star p Emp = p\"<br>\n and emp_star: \"Star Emp p = p\"</p>\n<p>consts Exists :: \"string \\&lt;Rightarrow&gt; assertion \\&lt;Rightarrow&gt; assertion\"</p>\n<p>axiomatization <br>\n rd_ass :: \"assertion \\&lt;Rightarrow&gt; string set\"<br>\nwhere rd_emp: \"rd_ass Emp = {}\"<br>\n and rd_star: \"rd_ass (Star p q) = rd_ass p \\&lt;union&gt; rd_ass q\"<br>\n and rd_exists: \"rd_ass (Exists x p) = rd_ass p\"</p>\n<p>typedecl atomic<br>\nconsts rd_atm :: \"atomic \\&lt;Rightarrow&gt; string set\"<br>\nconsts wr_atm :: \"atomic \\&lt;Rightarrow&gt; string set\"</p>\n<p>datatype command =<br>\n Atomic \"atomic\"<br>\n| If \"bool_exp\" \"command list\" \"command list\"<br>\n| While \"bool_exp\" \"command list\"</p>\n<p>fun<br>\n interleave_coms :: \"(command list \\&lt;times&gt; command list) \\&lt;Rightarrow&gt; command list set\"<br>\nwhere<br>\n \"interleave_coms ([], C2) = {C2}\"<br>\n| \"interleave_coms (C1, []) = {C1}\"<br>\n| \"interleave_coms (c1#C1, c2#C2)<br>\n = {c1#C | C. C \\&lt;in&gt; interleave_coms(C1, c2#C2)}<br>\n \\&lt;union&gt; {c2#C | C. C \\&lt;in&gt; interleave_coms(c1#C1, C2)}\"</p>\n<p>inductive<br>\n prov_com :: \"assertion \\&lt;times&gt; command \\&lt;times&gt; assertion \\&lt;Rightarrow&gt; bool\"<br>\nand<br>\n prov_comlist :: \"assertion \\&lt;times&gt; command list \\&lt;times&gt; assertion \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n exists: <br>\n \"prov_com (p, c, q) <br>\n \\&lt;Longrightarrow&gt; prov_com (Exists x p, c, Exists x q)\"<br>\n| ifcom: <br>\n \"\\&lt;lbrakk&gt;prov_comlist (Star (Pure b) p, C1, q); <br>\n prov_comlist (Star (Pure (Not b)) p, C2, q)\\&lt;rbrakk&gt; <br>\n \\&lt;Longrightarrow&gt; prov_com (p, If b C1 C2, q)\"<br>\n| while: <br>\n \"prov_comlist (Star (Pure b) p, C, p) <br>\n \\&lt;Longrightarrow&gt; prov_com (p, While b C, Star (Pure (Not b)) p)\" <br>\n| frame: <br>\n \"\\&lt;lbrakk&gt;prov_com (p, c, q); wr_com(c) \\&lt;inter&gt; rd_ass(r) = {}\\&lt;rbrakk&gt; <br>\n \\&lt;Longrightarrow&gt; prov_com (Star p r, c, Star q r)\"<br>\n| skip: <br>\n \"prov_comlist(p, [], p)\"<br>\n| seq: <br>\n \"\\&lt;lbrakk&gt;prov_com (p, c, q); prov_comlist (q, C, r)\\&lt;rbrakk&gt; <br>\n \\&lt;Longrightarrow&gt; prov_comlist (p, c#C, r)\"</p>\n<p>datatype face =<br>\n Ribbon \"assertion\"<br>\n| Exists_int \"string\" \"face list\"</p>\n<p>type_synonym interface = \"face list\"</p>\n<p>fun<br>\n ass_face :: \"face \\&lt;Rightarrow&gt; assertion\"<br>\nand<br>\n ass :: \"interface \\&lt;Rightarrow&gt; assertion\"<br>\nwhere<br>\n \"ass_face (Ribbon p) = p\"<br>\n| \"ass_face (Exists_int x P) = Exists x (ass P)\"<br>\n| \"ass [] = Emp\"<br>\n| \"ass (f#P) = Star (ass_face f) (ass P)\"</p>\n<p>datatype column =<br>\n Blank \"interface\"<br>\n| Basic \"interface\" \"command\" \"interface\"<br>\n| VComp_dia \"column list\" \"column list\"<br>\n| Exists_dia \"string\" \"column list\"<br>\n| If_dia \"interface\" \"bool_exp\" \"column list\" \"column list\" \"interface\"<br>\n| While_dia \"interface\" \"bool_exp\" \"column list\" \"interface\"</p>\n<p>type_synonym diagram = \"column list\"</p>\n<p>fun<br>\n top :: \"diagram \\&lt;Rightarrow&gt; interface\"<br>\nand<br>\n top_col :: \"column \\&lt;Rightarrow&gt; interface\"<br>\nwhere<br>\n \"top_col (Blank P) = P\"<br>\n| \"top_col (Basic P c Q) = P\"<br>\n| \"top_col (VComp_dia A B) = top A\"<br>\n| \"top_col (Exists_dia x A) = [Exists_int x (top A)]\"<br>\n| \"top_col (If_dia P b A B Q) = P\"<br>\n| \"top_col (While_dia P b A Q) = P\"<br>\n| \"top [] = []\"<br>\n| \"top (a # A) = (top_col a) @ (top A)\"</p>\n<p>fun<br>\n bot :: \"diagram \\&lt;Rightarrow&gt; interface\"<br>\nand<br>\n bot_col :: \"column \\&lt;Rightarrow&gt; interface\"<br>\nwhere<br>\n \"bot_col (Blank P) = P\"<br>\n| \"bot_col (Basic P c Q) = Q\"<br>\n| \"bot_col (VComp_dia A B) = bot B\"<br>\n| \"bot_col (Exists_dia x A) = [Exists_int x (bot A)]\"<br>\n| \"bot_col (If_dia P b A B Q) = Q\"<br>\n| \"bot_col (While_dia P b A Q) = Q\"<br>\n| \"bot [] = []\"<br>\n| \"bot (a # A) = (bot_col a) @ (bot A)\"</p>\n<p>fun<br>\n coms :: \"diagram \\&lt;Rightarrow&gt; command list set\"<br>\nand<br>\n coms_col :: \"column \\&lt;Rightarrow&gt; command list set\"<br>\nwhere<br>\n \"coms_col (Blank P) = {}\"<br>\n| \"coms_col (Basic P c Q) = {[c]}\"<br>\n| \"coms_col (VComp_dia A B) <br>\n = {C @ C' | C C'. C \\&lt;in&gt; coms A \\&lt;and&gt; C' \\&lt;in&gt; coms B}\"<br>\n| \"coms_col (Exists_dia x A) = coms A\"<br>\n| \"coms_col (If_dia P b A B Q) <br>\n = { [If b C C'] | C C'. C \\&lt;in&gt; coms A \\&lt;and&gt; C' \\&lt;in&gt; coms B}\"<br>\n| \"coms_col (While_dia P b A Q) = { [While b C] | C. C \\&lt;in&gt; coms A}\"<br>\n| \"coms [] = {}\"<br>\n| \"coms (a # A) <br>\n = \\&lt;Union&gt;{interleave_coms (C, C') | C C'. C \\&lt;in&gt; coms_col a \\&lt;and&gt; C' \\&lt;in&gt; coms A}\"</p>\n<p>consts <br>\n disj_col_dia :: \"column \\&lt;Rightarrow&gt; diagram \\&lt;Rightarrow&gt; bool\"</p>\n<p>inductive<br>\n prov_dia :: \"diagram \\&lt;Rightarrow&gt; bool\"<br>\nand<br>\n prov_col :: \"column \\&lt;Rightarrow&gt; bool\"<br>\nwhere<br>\n Blank: <br>\n \"prov_col (Blank P)\"<br>\n| Basic: <br>\n \"prov_com (ass P, c, ass Q) \\&lt;Longrightarrow&gt; prov_col (Basic P c Q)\"<br>\n| Exists: <br>\n \"prov_dia A \\&lt;Longrightarrow&gt; prov_col (Exists_dia x A)\"<br>\n| VComp: <br>\n \"\\&lt;lbrakk&gt;prov_dia A; prov_dia B; bot A = top B\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; prov_col (VComp_dia A B)\"<br>\n| If: <br>\n \"\\&lt;lbrakk&gt;prov_dia A; prov_dia B; top A = (Ribbon (Pure b)) # P; <br>\n top B = (Ribbon (Pure (Not b))) # P; bot A = Q; bot B = Q\\&lt;rbrakk&gt; <br>\n \\&lt;Longrightarrow&gt; prov_col (If_dia P b A B Q)\"<br>\n| While: <br>\n \"\\&lt;lbrakk&gt;prov_dia A; top A = (Ribbon(Pure b)) # P; <br>\n bot A = P; Q = (Ribbon(Pure (Not b))) # P\\&lt;rbrakk&gt; <br>\n \\&lt;Longrightarrow&gt; prov_col (While_dia P b A Q)\"<br>\n| Nil: <br>\n \"prov_dia []\"<br>\n| Cons:<br>\n \"\\&lt;lbrakk&gt;prov_col a; prov_dia A; disj_col_dia a A\\&lt;rbrakk&gt; <br>\n \\&lt;Longrightarrow&gt; prov_dia (a # A)\"</p>\n<p>datatype chain = <br>\n cNil \"assertion\"<br>\n| cCons \"assertion\" \"command\" \"chain\"</p>\n<p>fun <br>\n seq_chains :: \"chain \\&lt;times&gt; chain \\&lt;Rightarrow&gt; chain\"<br>\nwhere<br>\n \"seq_chains (cNil _, G') = G'\"<br>\n| \"seq_chains (cCons p c G, G') = cCons p c (seq_chains (G, G'))\"</p>\n<p>fun<br>\n pre :: \"chain \\&lt;Rightarrow&gt; assertion\"<br>\nwhere<br>\n \"pre(cNil p) = p\"<br>\n| \"pre(cCons p c G) = p\"</p>\n<p>fun <br>\n post :: \"chain \\&lt;Rightarrow&gt; assertion\"<br>\nwhere<br>\n \"post(cNil p) = p\"<br>\n| \"post(cCons p c G) = post G\"</p>\n<p>fun<br>\n comlist :: \"chain \\&lt;Rightarrow&gt; command list\"<br>\nwhere<br>\n \"comlist(cNil p) = []\"<br>\n| \"comlist(cCons p c G) =<br>\n[message truncated]</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294147580,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848070
    }
]