[
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nHi,</p>\n<p>after investigating a little, I learned that inductive_set builds on<br>\ninductive.</p>\n<p>The same question applies to inductive: For an inductive predicate X,<br>\ncan I somehow get an induction schema like<br>\n  \"[| ... |] ==&gt; P X\"<br>\nas opposed to<br>\n  \"[| X x; ... |] ==&gt; P x\"<br>\n?</p>\n<p>If there is no way to get this automatically, is there maybe a way to<br>\naccess the monotonicity rule of an inductive predicate, so that I can<br>\napply lfp_ordinal_induct?</p>\n<p>Christoph</p>",
        "id": 294656074,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168061
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHopefully one can get access to the monotonicity theorem proved internally in <br>\nthe cause of an inductive definition. But I don't know how. It is not called <br>\nX_mono or X.mono. In the worst case it is hidden...</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/hzrwwlRaXA3E3oLJi2p3tL53/smime.p7s\">smime.p7s</a></p>",
        "id": 294656079,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168064
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nIndeed, inductive does not bind the monotonicity theorem to a theorem name and so the <br>\nmonotonicity theorem is not accessible from user space. Moreover, the monotonicity prover <br>\nis not exported in the ML interface either, so you cannot even state the monotonicity <br>\ntheorem yourself and have the monotonicity prover solve the goal once more.</p>\n<p>Andreas</p>",
        "id": 294656100,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168072
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nBummer! Is there any reason not to make the monotonicity theorem availble in <br>\nuser space? If not...</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/tw0pTwXXgPezr27yJmr3U_In/smime.p7s\">smime.p7s</a></p>",
        "id": 294656117,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168076
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nNo, I'd be glad if it was made available. Probably nobody ever invested the time to adapt <br>\nthe code base.</p>\n<p>Andreas</p>",
        "id": 294656134,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168082
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nHi all,</p>\n<p>monotonicity and similar theorems are not made available to the user because this would expose<br>\nthe inner workings of the inductive definition package, which can change without prior notice.<br>\nFor a more detailed discussion of this problem, see e.g. this thread:</p>\n<p><a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-May/msg00079.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-May/msg00079.html</a><br>\n<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-June/msg00013.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2008-June/msg00013.html</a></p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294656167,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168100
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Stefan,</p>\n<p>You are right in that the rules generated by the inductive package suffice for proving. <br>\nHowever, sometimes it is easier to prove some statement using a higher-level reasoning <br>\nprinciple than with the point-wise rules for inductive predicates. Thus, there may be <br>\ncases where it is easier to derive a property from the internal construction than from <br>\nwhat is exposed. Most of the other Isabelle packages I know follow the same principle: the <br>\ninternal constructions are accessible, but normally not used. If anyone uses the internal <br>\nconstructions, it is obvious that the proofs will break if the implementation is changed.</p>\n<p>For comparison, partial_function also exposes the internal definition and the monotonicity <br>\ntheorem and I actually use this frequently to derive better induction rules for my <br>\nfunctions. In principle, such rules could be derived from the induction rule provided, but <br>\nI would have to do the derivation for each function. By using the internal derivation, I <br>\ncan do the derivation once and just instantiate the appropriate lemma.  Of course, I know <br>\nthat I have to change my proofs when partial_function changes, but as I am using the <br>\ninternal definition only in a principled way, the required adaptations should also be <br>\ncanonical.</p>\n<p>Something similar can also be useful for the inductive package, as this request shows.</p>\n<p>From what I saw in the Isabelle repository, this distinction between official and <br>\ninternal theorems might be more explicit in the next release. The internal theorems are <br>\nonly made available if a specific attribute is set at definition time. Something similar <br>\ncould also be done for inductive.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294656219,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168116
    },
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nI don't see how ordinal induction (like lfp_ordinal_induct)<br>\n  \"[| ... |] ==&gt; P X\"<br>\nis derivable from the pointwise induction rule<br>\n  \"[| X x; ... |] ==&gt; P x\"<br>\nprovided by the inductive package.</p>\n<p>Or is it derivable?</p>\n<p>Best,<br>\nChristoph</p>",
        "id": 294656225,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168118
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Christoph,</p>\n<p>The general answer first:<br>\nThe rules generated by the inductive package suffice to prove that the predicate equals <br>\nthe internal construction. Thus, you can prove the same as you can prove with access the <br>\ninternal construction. However, this proof of equivalence can be quite tedious (which is <br>\nwhy I support making the internal construction accessible).</p>\n<p>In the specific case of lfp_ordinal_induct, you just have to look at its proof. It uses <br>\nthree properties of lfp and f:</p>\n<ol>\n<li>Monotonicity of f: You have to prove this yourself manually, but this is doable.</li>\n<li>lfp_unfold: This corresponds to X.simps[abs_def]</li>\n<li>lfp_lowerbound: This corresponds to X.induct</li>\n</ol>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294656255,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168131
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nDear Christoph,</p>\n<p>the prove using lfp_ordinal_induct is quite different, the inductive<br>\npackage does not produce it for you.</p>\n<p>As Andreas points out, you can directly use the definition of the<br>\npredicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>\nThen you can apply lfp_ordinal_induct. </p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294656286,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168149
    },
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nDear Johannes,</p>\n<p>thank you, and also Andreas for your answers.</p>\n<p>&lt;inductive_pred&gt;_def is \"&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;\".<br>\nCan I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>\nto copy&amp;paste it?</p>\n<p>I tried pattern matching like<br>\n  note X_def (is \"_ == lfp ?f\")<br>\nbut this doesn't work (the isar manual agrees).</p>\n<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>\ninductive package?  If not, maybe my approach of redefining the<br>\ninductive predicate explicitly via lfp and proving equality could be<br>\nmore robust against changes in the inductive package?</p>\n<p>Best,<br>\nChristoph</p>",
        "id": 294656374,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168179
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAs far as I understood Stefan, the _def theorems are actually internal.</p>\n<p>I think you should be on the save side with your last suggestion, i.e.<br>\ndefining the functional F_def and then prove:</p>\n<p>inductive X ...</p>\n<p>definition F where<br>\n  \"F = ...\"</p>\n<p>lemma \"X = lfp F\"<br>\n  unfolding X_def F_def by simp</p>\n<p>Then you should be on the save side if we change the internals of the<br>\ninductive package.</p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294656404,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168192
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 27/10/2015 16:16, Johannes Hölzl wrote:</p>\n<blockquote>\n<p>As far as I understood Stefan, the _def theorems are actually internal.</p>\n</blockquote>\n<p>But it is exported, and hasn't changed over many years and I don't see any <br>\nimpending change there either.</p>\n<p>Tobias</p>\n<blockquote>\n<p>I think you should be on the save side with your last suggestion, i.e.<br>\ndefining the functional F_def and then prove:</p>\n<p>inductive X ...</p>\n<p>definition F where<br>\n   \"F = ...\"</p>\n<p>lemma \"X = lfp F\"<br>\n   unfolding X_def F_def by simp</p>\n<p>Then you should be on the save side if we change the internals of the<br>\ninductive package.</p>\n<p>- Johannes</p>\n<p>Am Dienstag, den 27.10.2015, 15:22 +0100 schrieb Christoph Dittmann:</p>\n<blockquote>\n<p>Dear Johannes,</p>\n<p>thank you, and also Andreas for your answers.<br>\n</p>\n</blockquote>\n<p>On 10/27/2015 02:26 PM, Johannes Hölzl wrote:</p>\n<blockquote>\n<blockquote>\n<p>As Andreas points out, you can directly use the definition of the<br>\npredicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>\nThen you can apply lfp_ordinal_induct.</p>\n</blockquote>\n<p>&lt;inductive_pred&gt;_def is \"&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;\".<br>\nCan I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>\nto copy&amp;paste it?</p>\n<p>I tried pattern matching like<br>\n   note X_def (is \"_ == lfp ?f\")<br>\nbut this doesn't work (the isar manual agrees).</p>\n<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>\ninductive package?  If not, maybe my approach of redefining the<br>\ninductive predicate explicitly via lfp and proving equality could be<br>\nmore robust against changes in the inductive package?</p>\n<p>Best,<br>\nChristoph<br>\n</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/UhQ6XHkQRfmGKkJ_J7qJx3-U/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294656425,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168199
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 27/10/2015 16:16, Johannes Hölzl wrote:</p>\n<blockquote>\n<p>As far as I understood Stefan, the _def theorems are actually internal.</p>\n<p>I think you should be on the save side with your last suggestion, i.e.<br>\ndefining the functional F_def and then prove:</p>\n<p>inductive X ...</p>\n<p>definition F where<br>\n   \"F = ...\"</p>\n<p>lemma \"X = lfp F\"<br>\n   unfolding X_def F_def by simp</p>\n<p>Then you should be on the save side if we change the internals of the<br>\ninductive package.</p>\n</blockquote>\n<p>No, you are not: the simp proof may well fail if X_def changes, and if it <br>\ndisappears altogether the unfolding breaks.</p>\n<p>Tobias</p>\n<blockquote>\n<p>- Johannes</p>\n<p>Am Dienstag, den 27.10.2015, 15:22 +0100 schrieb Christoph Dittmann:</p>\n<blockquote>\n<p>Dear Johannes,</p>\n<p>thank you, and also Andreas for your answers.<br>\n</p>\n</blockquote>\n<p>On 10/27/2015 02:26 PM, Johannes Hölzl wrote:</p>\n<blockquote>\n<blockquote>\n<p>As Andreas points out, you can directly use the definition of the<br>\npredicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>\nThen you can apply lfp_ordinal_induct.</p>\n</blockquote>\n<p>&lt;inductive_pred&gt;_def is \"&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;\".<br>\nCan I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>\nto copy&amp;paste it?</p>\n<p>I tried pattern matching like<br>\n   note X_def (is \"_ == lfp ?f\")<br>\nbut this doesn't work (the isar manual agrees).</p>\n<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>\ninductive package?  If not, maybe my approach of redefining the<br>\ninductive predicate explicitly via lfp and proving equality could be<br>\nmore robust against changes in the inductive package?</p>\n<p>Best,<br>\nChristoph<br>\n</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/24Gm8TNHSgV0LXLezdT6F-ns/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294656434,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168205
    },
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nI was thinking more of something like the proof of X_lfp_equiv I posted<br>\nin my original posting, without using X_def.</p>\n<p>The only drawback is that I need to state the monotone function twice in<br>\nslightly different form, once for the inductive predicate and once again<br>\nto redefine it with lfp.</p>\n<p>Best,<br>\nChristoph</p>",
        "id": 294656442,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168210
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Dienstag, den 27.10.2015, 16:33 +0100 schrieb Tobias Nipkow:</p>\n<blockquote>\n<blockquote>\n<p>lemma \"X = lfp F\"<br>\n   unfolding X_def F_def by simp</p>\n<p>Then you should be on the save side if we change the internals of the<br>\ninductive package.</p>\n</blockquote>\n<p>No, you are not: the simp proof may well fail if X_def changes, and if it <br>\ndisappears altogether the unfolding breaks.</p>\n</blockquote>\n<p>Okay, I should be more specific with safe side: You only need to perform<br>\nlocal changes. You need to adapt your proof only locally, only this<br>\nproof.</p>\n<p>If you would sprinkle X_def all over the place and inductive changes it,<br>\nyou can _not_ overwrite X_def like</p>\n<p>lemma X_def: \"X = lfp ...\"</p>\n<p>as Isabelle does not allow the same theorem name in one theory.</p>\n<blockquote>\n<p>Am Dienstag, den 27.10.2015, 15:22 +0100 schrieb Christoph Dittmann:</p>\n<blockquote>\n<blockquote>\n<p>Dear Johannes,</p>\n<p>thank you, and also Andreas for your answers.<br>\n</p>\n</blockquote>\n<p>On 10/27/2015 02:26 PM, Johannes Hölzl wrote:</p>\n<blockquote>\n<blockquote>\n<p>As Andreas points out, you can directly use the definition of the<br>\npredicate (&lt;inductive pred&gt;_def) and then manually prove monotonicity.<br>\nThen you can apply lfp_ordinal_induct.</p>\n</blockquote>\n<p>&lt;inductive_pred&gt;_def is \"&lt;inductive_pred&gt; == lfp &lt;something_very_long&gt;\".<br>\nCan I somehow bind &lt;something_very_long&gt; to a name so that I do not need<br>\nto copy&amp;paste it?</p>\n<p>I tried pattern matching like<br>\n   note X_def (is \"_ == lfp ?f\")<br>\nbut this doesn't work (the isar manual agrees).</p>\n<p>Is &lt;inductive_pred&gt;_def considered part of the stable interface to the<br>\ninductive package?  If not, maybe my approach of redefining the<br>\ninductive predicate explicitly via lfp and proving equality could be<br>\nmore robust against changes in the inductive package?</p>\n<p>Best,<br>\nChristoph<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294656492,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168235
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nYes, it should be considered fixed, and I support Andreas' idea of<br>\nexporting the monotonicity theorem. </p>\n<ul>\n<li>Johannes</li>\n</ul>",
        "id": 294656515,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168247
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nStefan, you could call it something like mono_internal, thus expressing that it <br>\nmay change.</p>\n<p>Tobias<br>\n<a href=\"/user_uploads/14278/jSr-LWCsEzTxVvPzdHkgyT-J/smime.p7s\">smime.p7s</a></p>",
        "id": 294656679,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168315
    },
    {
        "content": "<p>From: Christoph Dittmann &lt;<a href=\"mailto:f-isabellelist@yozora.eu\">f-isabellelist@yozora.eu</a>&gt;<br>\nHi,</p>\n<p>I would like to use lfp_ordinal_induct_set with inductive_set.</p>\n<p>When I define:</p>\n<p>inductive_set X where \"⟦ ⋀b. f a b ⟹ b ∈ X ⟧ ⟹ a ∈ X\"</p>\n<p>I get an induction theorem X.induct for free.  However, X.induct talks<br>\nabout elements, not sets.  The following induction schema based on least<br>\nfixed points also works:</p>\n<p>lemma X_lfp_induct:<br>\n  assumes step: \"⋀S. P S ⟹ P (S ∪ {a. ∀b. f a b ⟶ b ∈ S})\"<br>\n    and union: \"⋀M. ∀S ∈ M. P S ⟹ P (⋃M)\"<br>\n  shows \"P X\"<br>\noops</p>\n<p>I managed to prove X_lfp_induct (see attachment) by redefining X<br>\nmanually via the lfp function and then showing that this definition is<br>\nequivalent to the inductive_set.  Then X_lfp_induct follows from<br>\nlfp_ordinal_induct_set from ~~/src/HOL/Inductive.thy.</p>\n<p>For this I needed to prove things like monotonicity, which I assume<br>\ninductive_set already proves internally.  So my approach seems a little<br>\nredundant and I think there could be a better way.</p>\n<p>Is there an easier way to get a least fixed point induction schema like<br>\nthis for inductive_sets in general, maybe even fully automatic?</p>\n<p>Thanks,<br>\nChristoph<br>\n<a href=\"/user_uploads/14278/Y6AB5bQgq46omnmL4RNHpXBT/lfp.thy\">lfp.thy</a></p>",
        "id": 294657720,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168738
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nA few notes on these questions about internal construction vs. external <br>\nresults (or \"interface\") of derived definitional packages.</p>\n<ul>\n<li>\n<p>Historically, constant definitions were always visible in the fact<br>\n   namespace.  A bit later, we introduced the \"concealed\" flag, as formal<br>\n   means to say that the accidental presence of such facts is better<br>\n   ignored (especially by tools like find_theorems of sledgehammer).  Only<br>\n   recently (i.e. some years ago) the namespaces for definitional axioms<br>\n   and facts (stored theorems) were clearly separated.  Thus it became<br>\n   possible to make formal definitions relatively hard to access by<br>\n   user-space tools.  (The 'private' modifier from Isabelle2015 has a<br>\n   similar effect.)</p>\n</li>\n<li>\n<p>Some weeks ago, I tried to make a few definitional packages more serious<br>\n   in this respect, by using an empty binding for the facts of the internal<br>\n   definitions.  Thus a few cases were exposed, where applications were<br>\n   actually using this, despite the original intentions.  So I added<br>\n   another configuration option to re-enable the lost definitional fact.</p>\n</li>\n<li>\n<p>I have now done the same for 'inductive', 'coinductive' etc. treating<br>\n   the \"mono\" rule like the internal definition.  This exposed surprisingly<br>\n   many cases where the definition was used in applications.  So the<br>\n   question, whether the \"mono\" rule is morally public or not is futile.</p>\n</li>\n</ul>\n<p>In conclusion, this is the relevant NEWS entry from Isabelle/ca53150406c9, <br>\nwhich is meant for the coming release:</p>\n<p>* Inductive definitions ('inductive', 'coinductive', etc.) expose<br>\n   low-level facts of the internal construction only if the option<br>\n   \"inductive_defs\" is enabled. This refers to the internal predicate<br>\n   definition and its monotonicity result. Rare INCOMPATIBILITY.</p>\n<p>* Recursive function definitions ('fun', 'function', 'partial_function')<br>\n   expose low-level facts of the internal construction only if the option<br>\n   \"function_defs\" is enabled. Rare INCOMPATIBILITY.</p>\n<p>This means the new situation is both more restrictive and more permissive.</p>\n<p>There was also a discussion about the \"stability of interfaces\" in <br>\nIsabelle.  It does not really exist.  Everything may change at some point. <br>\nOf course, we don't change things at will, according to current weather <br>\nconditions.  But we are still moving conceptually forward to a hopefully <br>\nbetter system.</p>\n<p>A recent example for that is the upheaval of the 'datatype' package after <br>\nmany years.</p>\n<p>Makarius</p>",
        "id": 294659037,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169235
    }
]