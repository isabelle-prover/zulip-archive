[
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:michael.norrish@nicta.com.au\">michael.norrish@nicta.com.au</a>&gt;<br>\nIt seems that I cannot do the following</p>\n<p>instance tyop :: (class1, class2) myclass<br>\n    &lt;some proof&gt;</p>\n<p>instance tyop :: (class3, class4) myclass<br>\n    &lt;some other proof&gt;</p>\n<p>where there is no connection between the various class&lt;n&gt;.  This is<br>\ndespite the fact that the proofs themselves do work.</p>\n<p>My reading of the \"Order-Sorted Unification\" paper suggests to me that<br>\nI'm bumping my head against the \"unnecessarily strong\" co-regularity<br>\ncondition.  Is there any prospect of this being weakened?</p>\n<p>Failing that, how might I achieve the desired effect?  The myclass<br>\naxclass has as one of its axioms that the \"size\" of its types not be<br>\ngreater than a particular limit.  In the binary type operator (array),<br>\nthe \"size\" of the type is the product of the \"size\" of the first<br>\nargument to array, and the \"number\" of the second.</p>\n<p>At the moment, in order to get something like</p>\n<p>(word32, \"10\") array</p>\n<p>accepted as an instance of myclass, I first have to invent a class<br>\ninto which I can put word32 (I call it sz4), and then a class for the<br>\ntype \"10\", which I call count10.  I can then use the definition of the<br>\n\"size\" calculation and the axioms for sz4 and count10 to prove that<br>\nthe \"size\" of</p>\n<p>('a::sz4, 'b::count10) array</p>\n<p>is 40, which is less than the limit in myclass.</p>\n<p>But if I'm interested in also showing</p>\n<p>(some_user_type, \"13\") array</p>\n<p>is in myclass, I'm now stuck.</p>\n<p>Thanks,<br>\nMichael.</p>",
        "id": 294051078,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819502
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nMichael Norrish schrieb:<br>\nDid I write \"unnecessarily strong\"? Because I don't think it is. If <br>\n(during type inference) you unify a type of class myclass with a type <br>\n\"('a,'b) tyop\", in your example it is not clear what the classes of the <br>\nsubtypes 'a and 'b should be. You have lost the principal types property.</p>\n<p>Best<br>\nTobias</p>",
        "id": 294051099,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819507
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Michael,</p>\n<p>Instead of using the type class mechanism here, you could accomplish what you <br>\nwant using predicates on types. I'll explain what I mean by this using an <br>\nexample:</p>\n<p>definition<br>\n  sizelimit :: \"nat =&gt; 'a itself =&gt; bool\" where<br>\n  \"sizelimit n (t::'a itself) == ALL x::'a. size x &lt;= n\"</p>\n<p>Now you can use this predicate to represent sort constraints. For example, <br>\ninstead of proving \"instance word32 :: sz4\" you would prove a theorem that <br>\nsays \"sizelimit 4 TYPE(word32)\". This is basically what Isabelle's axclass <br>\nsystem does internally (except that it doesn't allow you to parametrize a <br>\nclass by a natural number, of course).</p>\n<p>You could also prove an inference rule like this for tyop:</p>\n<p>[| sizelimit m TYPE('a); sizelimit n TYPE('b); m * n &lt;= k|]<br>\n    ==&gt; sizelimit k TYPE(('a,'b)tyop)</p>\n<p>This is much more flexible than any instance declaration in Isabelle could be. <br>\nBut the drawback is that you lose automation: Instead of sort annotations you <br>\nwill need to add explicit sizelimit assumptions to your theorems, which you <br>\nwill then have to discharge manually using inference rules like the one <br>\nabove.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294051113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819514
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nBrian Huffman wrote:</p>\n<blockquote>\n<p>Instead of using the type class mechanism here, you could accomplish<br>\nwhat you want using predicates on types. ...</p>\n</blockquote>\n<blockquote>\n<p>This is much more flexible than any instance declaration in Isabelle<br>\ncould be.  But the drawback is that you lose automation: Instead of<br>\nsort annotations you will need to add explicit sizelimit assumptions<br>\nto your theorems, which you will then have to discharge manually<br>\nusing inference rules like the one above.</p>\n</blockquote>\n<p>Yes, this would definitely suffice.  But I'm afraid it's not really an<br>\noption given what we're doing and where we're up to at the moment.  We<br>\nare making pretty heavy use of our \"memtype\" class, which encodes \"is<br>\nrepresentable in memory\", and it would be a pain to lose that<br>\nautomation.  We also don't have the time to go back and re-engineer<br>\neverything.</p>\n<p>We will get round the problem by showing</p>\n<p>instance array :: (oneMB_orless, lt_four_thousand) mem_type</p>\n<p>once and for all, and then showing that the examples we're working<br>\nwith satisfy those constraints.  (Declaring an array of 5000 ints<br>\nwon't be allowed, but we're working with a pretty restricted codebase,<br>\nso we can be confident that we're happy with this restriction.)</p>\n<p>Michael.</p>",
        "id": 294051135,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819521
    }
]