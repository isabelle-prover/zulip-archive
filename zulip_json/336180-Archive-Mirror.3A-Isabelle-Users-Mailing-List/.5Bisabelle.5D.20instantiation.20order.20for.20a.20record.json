[
    {
        "content": "<p>From: Sven Schneider &lt;<a href=\"mailto:Sven.Schneider@TU-Berlin.DE\">Sven.Schneider@TU-Berlin.DE</a>&gt;<br>\nDear Isabelle community,</p>\n<p>I am having trouble instantiation the typeclass order for one of my records.<br>\nActually, the problem exists whenever the typeclass has parameters, to<br>\nbe defined.</p>\n<p>The error message is not particularly helpful to me.<br>\n*** Bad head of lhs: existing constant \"op \\&lt;le&gt;\"<br>\n*** The error(s) above occurred in definition:<br>\n*** \"A \\&lt;le&gt; B \\&lt;equiv&gt; lesseqTESTRECORD A B\"</p>\n<p>The online manual did not help me much in this case either; I tried<br>\nunsuccessfully to translate the examples from the manual to my case.</p>\n<p>Hopefully somebody can give me a hint on what to change to get to the<br>\npoint where the proving can start.</p>\n<p>Cheers,<br>\nSven</p>\n<p>==============================<br>\nTESTRECORD.thy BEGIN<br>\n==============================<br>\ntheory TESTRECORD<br>\nimports<br>\n  Main</p>\n<p>begin</p>\n<p>record 'a TESTRECORD =<br>\n  prefix_elem :: \"'a set\"</p>\n<p>definition lesseqTESTRECORD :: \"'a TESTRECORD \\&lt;Rightarrow&gt; 'a<br>\nTESTRECORD \\&lt;Rightarrow&gt; bool\" where<br>\n  \"lesseqTESTRECORD D1 D2 \\&lt;equiv&gt; (prefix_elem D1 \\&lt;subseteq&gt;<br>\nprefix_elem D2)\"</p>\n<p>definition lessTESTRECORD :: \"'a TESTRECORD \\&lt;Rightarrow&gt; 'a TESTRECORD<br>\n\\&lt;Rightarrow&gt; bool\" where<br>\n  \"lessTESTRECORD D1 D2 \\&lt;equiv&gt; lesseqTESTRECORD D1 D2 \\&lt;and&gt; D1\\&lt;noteq&gt;D2\"</p>\n<p>instantiation \"TESTRECORD_ext\" :: (type,type) order<br>\nbegin</p>\n<p>print_context</p>\n<p>definition<br>\n  less_eq_TESTRECORD_ext_def: \"less_eq A B = lesseqTESTRECORD A B\"</p>\n<p>definition<br>\n  less_TESTRECORD_ext_def: \"less A B = lessTESTRECORD A B\"</p>\n<p>instance proof<br>\n==============================<br>\nTESTRECORD.thy END<br>\n==============================</p>",
        "id": 294252624,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911361
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Sven,</p>\n<p>When you define the parameters of a type class in an instantiation, you must make sure <br>\nthat type inference infers exactly the expected type for the constant to be defined. If <br>\nthe type is not right, Isabelle does not recognize this as the definition of the <br>\nparameter. In your example with record, you instantiate the type class for TESTRECORD_ext.<br>\nHence, your definition of less_eq should have the type<br>\n   ('a, 'b) TESTRECORD_ext =&gt; ('a, 'b) TESTRECORD_ext =&gt; bool<br>\nHowever, type inference computes the type<br>\n   'a TESTRECORD =&gt; 'a TESTRECORD =&gt; bool<br>\nwhere 'a TESTRECORD abbreviates ('a, unit) TESTRECORD_ext, i.e, the type is too specialised.</p>\n<p>Therefore, you have to generalise your definition of lesseqTESTRECORD and lessTESTRECORD <br>\nto the raw type ('a, 'b) TESTRECORD_ext of the extensible record. In fact, if you just <br>\ndelete the type annotation for your definition of these two constants, the definitions <br>\nwill work, but you will not be able to show the order class axioms, because your <br>\ncomparison functions ignore any possible extensions of the record and therefore <br>\nantisymmetry does not hold.</p>\n<p>Instead, the comparison operations should work for any extension of the record. The <br>\nfollowing should work. There are three differences:</p>\n<ol>\n<li>\n<p>The types are generalised to TESTRECORD_ext with the extension type parameter 'b being <br>\nof sort ord</p>\n</li>\n<li>\n<p>The comparison is extended point-wise to the extension of the record (more D1 &lt;= more D2)</p>\n</li>\n<li>\n<p>The instantiation requires the sort order for the extension type parameter, as you will <br>\notherwise not be able to complete the proof.</p>\n</li>\n</ol>\n<p>definition lesseqTESTRECORD :: \"('a, 'b :: ord) TESTRECORD_ext \\&lt;Rightarrow&gt; ('a, 'b)<br>\nTESTRECORD_ext \\&lt;Rightarrow&gt; bool\" where<br>\n   \"lesseqTESTRECORD D1 D2 \\&lt;equiv&gt; (prefix_elem D1 \\&lt;subseteq&gt;<br>\nprefix_elem D2) &amp; more D1 &lt;= more D2\"</p>\n<p>definition lessTESTRECORD :: \"('a, 'b :: ord) TESTRECORD_ext \\&lt;Rightarrow&gt; ('a, 'b) <br>\nTESTRECORD_ext<br>\n\\&lt;Rightarrow&gt; bool\" where<br>\n   \"lessTESTRECORD D1 D2 \\&lt;equiv&gt; lesseqTESTRECORD D1 D2 \\&lt;and&gt; D1\\&lt;noteq&gt;D2\"</p>\n<p>instantiation \"TESTRECORD_ext\" :: (type,order) order<br>\nbegin</p>\n<p>There is just one remaining problem: In Isabelle2013, the unit type is not an instance of <br>\norder, and neither in the coming release (but probably in Isabelle2014). So, you have to <br>\nprovide an instantiation for unit yourself. You can import, e.g., the theory from the <br>\nArchive of Formal Proofs at<br>\n<a href=\"http://afp.sourceforge.net/browser_info/devel/AFP/Containers/Unit_Instantiations.html\">http://afp.sourceforge.net/browser_info/devel/AFP/Containers/Unit_Instantiations.html</a></p>\n<p>One further remark: It is generally better to avoid intermediate constants like <br>\nlesseqTESTRECORD and instead to define the order operation directly inside the <br>\ninstantiation context, unless you have particular reasons.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294252682,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911369
    },
    {
        "content": "<p>From: Sven Schneider &lt;<a href=\"mailto:Sven.Schneider@TU-Berlin.DE\">Sven.Schneider@TU-Berlin.DE</a>&gt;<br>\nDear Andreas,</p>\n<p>thank you very much.<br>\nWith your help I could solve my actual problem/.</p>\n<p>/Best regards,<br>\nSven</p>",
        "id": 294252693,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911373
    }
]