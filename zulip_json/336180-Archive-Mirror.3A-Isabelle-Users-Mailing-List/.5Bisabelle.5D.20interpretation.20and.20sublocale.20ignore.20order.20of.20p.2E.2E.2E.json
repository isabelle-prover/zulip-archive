[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear locale experts,</p>\n<p>The commands for interpreting a locale (interpret/interpretation/sublocale) accept <br>\nparameters declared with a for clause. The generated abbreviations for the constants <br>\ndefined in the locale then take the declared parameters as additional arguments. However, <br>\nthe order of these additional arguments is IMHO all but intutive and a night-mare for <br>\nmaintainability. The two examples below illustrate this.</p>\n<ol>\n<li>\n<p>Suppose we have a locale which fixes a parameter and defines a function f using the <br>\nparameter x. For the interpretation, let's define an abbreviation foo with two arguments <br>\nand interpret the locale for foo with both parameters declared in a for clause.</p>\n<p>locale l = fixes x :: int begin<br>\n definition f where \"f y = x + y\"<br>\n end</p>\n<p>abbreviation foo :: \"nat ⇒ int ⇒ int\" where \"foo x y == y - 2 * int x\"<br>\n interpretation sl!: l \"foo x y\" for x :: nat and y :: int .<br>\n term sl.f  (* λy x. l.f (foo x y) *)</p>\n</li>\n</ol>\n<p>As can be seen by inspecting the generated abbreviation sl.f, the order of the parameters <br>\nin the for clause (first x, then y) has been ignored, as sl.f takes first the y and then <br>\nthe x.</p>\n<p>Now, if I later change foo from an abbreviation to a definition, the order of parameters <br>\nchanges. Now, sl'.f takes the x first and then the y.</p>\n<p>definition foo' :: \"nat ⇒ int ⇒ int\" where \"foo' x y == y - 2 * int x\"<br>\n   interpretation sl'!: l \"foo' x y\" for x :: nat and y :: int .<br>\n   term sl'.f  (* λx y. l.f (foo' x y) *)</p>\n<p>Apparently, not the order of the parameters in the for clause matters, but the order of <br>\nthe parameters as they occur in the term which is used to instantiate the parameter. So, <br>\nwhen I going from an abbreviation to a definition, I have to reorder the first two <br>\nparameters of all occurrences of sl.f in my theories.</p>\n<ol start=\"2\">\n<li>\n<p>If we have a locale with several parameters (say 2), things get even worse. The order <br>\nof the parameter is not consistent over several constant declarations. In this example, <br>\nthere are two parameters and two definitions each of which depends on only one of the <br>\nparameters.</p>\n<p>locale l2 = fixes x :: int and z :: int begin<br>\n definition f where \"f y = x + y\"<br>\n definition g where \"g y = z + y\"<br>\n end</p>\n<p>interpretation sl2!: l2 \"y - 2 * int x\" \"int x - 2 * y\" for x :: nat and y :: int .<br>\n term \"sl2.f :: int ⇒ nat ⇒ int ⇒ int\"<br>\n term \"sl2.g :: nat ⇒ int ⇒ int ⇒ int\"</p>\n</li>\n</ol>\n<p>Now we see that sl2.f first takes the y and then the x, whereas sl2.g first takes the x <br>\nand then the y.</p>\n<p>I find this particularly annoying, because for every function defined in my locale I have <br>\nto remember separately the order of the parameters. I'd prefer much more if interpretation <br>\nand friends used the order of the parameters as given in the for clause consistently for <br>\nall constants. Can this behaviour be somehow changed?</p>\n<p>I tried to use unnamed context blocks to fix the order of parameters, but interpretations <br>\nare gone at the end of the block and sublocale and permanent_interpretation do not work <br>\ninside such blocks.</p>\n<p>Andreas</p>",
        "id": 294646777,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164432
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<p>if I conclude correctly you suggest that exporting a term out of an<br>\neigencontext (»for«) should honour the order in which variables have<br>\nbeen specified.</p>\n<p>This sounds reasonable.  What appears strange to me is that the<br>\nbehaviour of eigencontexts differs from unnamed context blocks in that<br>\nrespect, because as far as I know and can glimpse from the<br>\nimplementation the internal treatment should be the same… can anybody<br>\nshed further light on this?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/hYqnnMqdK9EZI_-_nGjKuKyT/signature.asc\">signature.asc</a></p>",
        "id": 294650701,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661165984
    }
]