[
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi David,</p>\n<p>In such cases extensionality is the way to go: thm ext.  Attached I have<br>\ntwo ways to employ it: either directly as (rule ext), which I recommend<br>\nin cases which require an Isar proof, or by means thm expand_fun_eq<br>\nwhich is handy for proofs which can be done automatically by simp (or<br>\nauto or clarsimp or ...).</p>\n<p>Hope this helps<br>\n    Florian</p>\n<p>--</p>\n<p>theory Hold<br>\nimports Main<br>\nbegin</p>\n<p>locale D_po =<br>\n  fixes le :: \"'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\"<br>\n  fixes D :: \"'a set\"<br>\nbegin</p>\n<p>abbreviation lle :: \"'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\" (infixl<br>\n\"\\&lt;sqsubseteq&gt;\" 100) where<br>\n  \"x \\&lt;sqsubseteq&gt; y \\&lt;equiv&gt; le x y\"</p>\n<p>definition downclosed where<br>\n  \"downclosed I \\&lt;longleftrightarrow&gt; I \\&lt;subseteq&gt; D \\&lt;and&gt; (\\&lt;forall&gt;x<br>\ny . (x \\&lt;in&gt; I \\&lt;and&gt; y \\&lt;in&gt; D \\&lt;and&gt; y \\&lt;sqsubseteq&gt; x)<br>\n\\&lt;longrightarrow&gt; y \\&lt;in&gt; I)\"</p>\n<p>definition ub where<br>\n  \"ub S a \\&lt;longleftrightarrow&gt;  a \\&lt;in&gt; D \\&lt;and&gt; (\\&lt;forall&gt;x\\&lt;in&gt;S. x<br>\n\\&lt;sqsubseteq&gt; a)\"</p>\n<p>definition lub where<br>\n  \"lub S d \\&lt;longleftrightarrow&gt; ub S d \\&lt;and&gt; (\\&lt;forall&gt;a. ub S a<br>\n\\&lt;longrightarrow&gt; d \\&lt;sqsubseteq&gt; a)\"</p>\n<p>definition Directed where<br>\n  \"Directed S \\&lt;longleftrightarrow&gt; S \\&lt;noteq&gt; {} \\&lt;and&gt; S \\&lt;subseteq&gt; D<br>\n\\&lt;and&gt; (\\&lt;forall&gt;f g. (f \\&lt;in&gt; S \\&lt;and&gt; g \\&lt;in&gt; S) \\&lt;longrightarrow&gt;<br>\n(\\&lt;exists&gt;l. ub {f, g} l \\&lt;and&gt; l \\&lt;in&gt; S))\"</p>\n<p>definition ideal where<br>\n  \"ideal I \\&lt;longleftrightarrow&gt; Directed I \\&lt;and&gt; downclosed I\"</p>\n<p>end</p>\n<p>locale D_bpo  = D_po +<br>\n  fixes idall :: \"('a \\&lt;Rightarrow&gt; bool) \\&lt;Rightarrow&gt; bool\"<br>\n  and my_subset:: \"('a \\&lt;Rightarrow&gt; bool) \\&lt;Rightarrow&gt; ('a<br>\n\\&lt;Rightarrow&gt; bool) \\&lt;Rightarrow&gt; bool\"<br>\n  defines Ideals: \"idall \\&lt;equiv&gt; {I:: ('a \\&lt;Rightarrow&gt; bool) .<br>\n(D_po.ideal le D I)}\"<br>\n  defines relative: \"my_subset x y \\&lt;equiv&gt; x \\&lt;subseteq&gt; y \\&lt;and&gt; x<br>\n\\&lt;in&gt; idall \\&lt;and&gt; y \\&lt;in&gt; idall\"</p>\n<p>locale D_cpo = D_bpo +<br>\n  assumes compass: \"\\&lt;forall&gt;S. D_po.Directed le D S \\&lt;longrightarrow&gt;<br>\n(\\&lt;exists&gt; l. D_po.lub le D S l)\"</p>\n<p>locale bpo_ideal = D_bpo le D idall my_subset + D_cpo my_subset idall<br>\nidid ididsub</p>\n<p>interpretation bpo_ideal \\&lt;subseteq&gt; D_bpo .</p>\n<p>interpretation D_bpo \\&lt;subseteq&gt; bpo_ideal<br>\nproof -<br>\n  show bopi: \"bpo_ideal op \\&lt;sqsubseteq&gt; D\"<br>\n  proof<br>\n    show \"\\&lt;forall&gt;S. D_po.Directed (\\&lt;lambda&gt;x y. x \\&lt;subseteq&gt; y<br>\n\\&lt;and&gt; x \\&lt;in&gt; {I. D_po.ideal op \\&lt;sqsubseteq&gt; D I} \\&lt;and&gt; y \\&lt;in&gt; {I.<br>\nD_po.ideal op \\&lt;sqsubseteq&gt; D I})<br>\n         {I. D_po.ideal op \\&lt;sqsubseteq&gt; D I} S \\&lt;longrightarrow&gt;<br>\n        (\\&lt;exists&gt;l. D_po.lub (\\&lt;lambda&gt;x y. x \\&lt;subseteq&gt; y \\&lt;and&gt; x<br>\n\\&lt;in&gt; {I. D_po.ideal op \\&lt;sqsubseteq&gt; D I} \\&lt;and&gt; y \\&lt;in&gt; {I. D_po.ideal<br>\nop \\&lt;sqsubseteq&gt; D I})<br>\n              {I. D_po.ideal op \\&lt;sqsubseteq&gt; D I} S l)\" sorry<br>\n  qed</p>\n<p>-- {* Alt. 1: rule ext *}<br>\n  have \"my_subset = (\\&lt;lambda&gt;x y. x \\&lt;subseteq&gt; y \\&lt;and&gt; x \\&lt;in&gt; idall<br>\n\\&lt;and&gt; y \\&lt;in&gt; idall)\"<br>\n  proof (rule ext)+<br>\n    fix x y<br>\n    show \"my_subset x y \\&lt;longleftrightarrow&gt; x \\&lt;subseteq&gt; y \\&lt;and&gt; x<br>\n\\&lt;in&gt; idall \\&lt;and&gt; y \\&lt;in&gt; idall\"<br>\n      by (simp add: relative)<br>\n  qed</p>\n<p>-- {* Alt. 2: expand_fun_eq *}<br>\n  have \"my_subset = (\\&lt;lambda&gt;x y. x \\&lt;subseteq&gt; y \\&lt;and&gt; x \\&lt;in&gt; idall<br>\n\\&lt;and&gt; y \\&lt;in&gt; idall)\"<br>\n    by (simp add: expand_fun_eq relative)</p>\n<p>qed</p>\n<p>-- </p>\n<p>Home:<br>\n<a href=\"http://wwwbroy.in.tum.de/~haftmann\">http://wwwbroy.in.tum.de/~haftmann</a></p>\n<p>PGP available:<br>\n<a href=\"http://home.informatik.tu-muenchen.de/haftmann/pgp/florian_haftmann_at_informatik_tu_muenchen_de\">http://home.informatik.tu-muenchen.de/haftmann/pgp/florian_haftmann_at_informatik_tu_muenchen_de</a><br>\n<a href=\"/user_uploads/14278/Wb2zzWeZ8pzHGOVctrxEWOMb/signature.asc\">signature.asc</a></p>",
        "id": 294068735,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826414
    }
]