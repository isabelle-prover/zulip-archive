[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nDear Isabelle,</p>\n<p>When I type...</p>\n<blockquote>\n<p>lemma assumes \"A ∧ B\" shows \"A\" \"B\"<br>\nusing assms<br>\napply rule</p>\n</blockquote>\n<p>...I obtain the following proof state...</p>\n<blockquote>\n<p>goal (2 subgoals):<br>\n 1. A ⟹ B ⟹ A<br>\n 2. B </p>\n</blockquote>\n<p>... which is insoluble. I think the \"apply rule\" step is using the conjE rule. Which rule should I apply in order to obtain the preferred proof state below? I briefly tried conjunctionI but that doesn't seem quite to fit.</p>\n<blockquote>\n<p>goal (2 subgoals):<br>\n 1. A ⟹ B ⟹ A<br>\n 2. A ⟹ B ⟹ B </p>\n</blockquote>\n<p>By the way, I know I can solve this lemma via auto; my question is pedagogical rather than practical.</p>\n<p>cheers,<br>\njohn</p>",
        "id": 294229407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901665
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>I was told, but don’t understand the reasons, that this works as an<br>\nintro rule for &amp;&amp;&amp;:</p>\n<p>lemma assumes \"A ∧ B\" shows \"A\" \"B\"<br>\nusing assms<br>\napply -</p>\n<p>goal (2 subgoals):</p>\n<ol>\n<li>A ∧ B ⟹ A</li>\n<li>A ∧ B ⟹ B </li>\n</ol>\n<p>But I’m also looking forward for pedagogical enlightenment. </p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/ioMLggzG-B_xV6oF5krI5rKg/signature.asc\">signature.asc</a></p>",
        "id": 294229450,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901695
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nAutomated tools are indeed obstructing the understanding how formal proof <br>\nreally works.  Here is my version of the above example:</p>\n<p>notepad<br>\nbegin</p>\n<p>assume ab: \"A &amp; B\"<br>\n   from ab have A and A<br>\n     apply rule<br>\n      apply assumption<br>\n     using ab<br>\n     apply rule<br>\n     apply assumption<br>\n     done</p>\n<p>from ab obtain A and B ..</p>\n<p>end</p>\n<p>General notes on it:</p>\n<p>* 'notepad' is better for experimentation than old-fashioned 'lemma',<br>\n     because it gives you the full proof language.  In top-level theorem<br>\n     statements your possibilities to indicate proof structure are more<br>\n     limited and one has to simulate things, and obscure the main points<br>\n     more than necessary.  There is also the initial goal hanging around,<br>\n     but proof is not primarily about goals.</p>\n<p>* The fact \"ab\" (or your assms) need to be eliminated twice to work on<br>\n     the two goals \"A\" and \"B\".  The \"rule\" method implicitly refers to<br>\n     conjE, but it works on the head goal only.  Note that in old-fashioned<br>\n     tactical reasoning, you would simulate a local fact like \"ab\" via some<br>\n     goal premise \"A &amp; B ==&gt; ...\", and \"apply (erule conjE)\" would consume<br>\n     that, and the result would indeed become insoluble as you've said.<br>\n     In proper Isar, the context grows monotonically, and things can be<br>\n     used again as required.</p>\n<p>* My second proof above via 'obtain' does the elimination of fact \"ab\"<br>\n     in a single step, saying that it is possible to assume A and B<br>\n     simultaneously thanks to the (implicit) conjE rule.  Recall that \"..\"<br>\n     abbreviates \"by rule\" (actually \"by default\", which is a bit more).</p>\n<p>Formally, there is only one goal behind 'obtain', so it works in a<br>\n     single rule application step, not two.  It would be more awkward to<br>\n     prove:</p>\n<p>from ab have A and B sorry</p>\n<p>which are two goals again.</p>\n<p>Since the context of assumptions is commutative, you may swap the<br>\n     obtain result in-place like this:</p>\n<p>from ab obtain B and A ..</p>\n<p>Putting it all together, here is my canonical starter proof for Isar:</p>\n<p>assume \"A &amp; B\"<br>\n   then obtain B and A ..<br>\n   then have \"B &amp; A\" ..</p>\n<p>You can also make implicit rules explicit like this:</p>\n<p>assume \"A &amp; B\"<br>\n   then obtain B and A by (rule conjE)<br>\n   then have \"B &amp; A\" by (rule conjI)</p>\n<p>Using the projections conjD1/conjD2 instead, it becomes a bit more awkward <br>\nand artificial:</p>\n<p>assume ab: \"A &amp; B\"<br>\n   from ab have a: A by (rule conjD1)<br>\n   from ab have b: B by (rule conjD2)<br>\n   from b and a have \"B &amp; A\" by (rule conjI)</p>\n<p>To be more fair, here is another variant that minimizes the spaghetti of <br>\nfact references:</p>\n<p>assume \"A &amp; B\"<br>\n   then have B ..<br>\n   from <code>A &amp; B</code> have A ..<br>\n   with <code>B</code> have \"B &amp; A\" ..</p>\n<p>I usually prefer the first-class support of eliminations in Isar via <br>\n'obtain' to reduce the formal noise and expose the reasoning more <br>\ndirectly.</p>\n<p>Makarius</p>",
        "id": 294229543,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901750
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n&amp;&amp;&amp; is merely funny Pure notation to say that there are several <br>\nsimultaneous goals to be proven.</p>\n<p>The system needs to retain this structure for advanced methods like <br>\n\"induct\", so it cannot be split into several goals by default.  The <br>\nsplitting happends implicitly for any other proof method like \"rule\", <br>\nwhich then acts on the first resulting subgoal only.  There are other <br>\nproof methods like \"auto\" that operate on all available subgoals, and <br>\nconsequently insert used facts into all of them at the start, so the above <br>\nexample will work here.</p>\n<p>You can see the difference again in \"simp\" vs. \"simp_all\", which is the <br>\nsame tool acting either on the head goal or all goals: \"apply simp_all\" <br>\nwill solve the above, but not \"apply simp\".</p>\n<p>Further fine points:</p>\n<p>assume \"A &amp; B\"<br>\n   then have A and B by (simp, simp)  -- works</p>\n<p>assume \"A &amp; B\"<br>\n   then have A and B by simp simp  -- fails</p>\n<p>assume \"A &amp; B\"<br>\n   then have A and B apply simp apply simp done  -- fails</p>\n<p>assume \"A &amp; B\"<br>\n   then have A and B<br>\n     apply simp<br>\n     using <code>A &amp; B</code><br>\n     apply simp<br>\n     done  -- works</p>\n<p>The first one works, because the method expression with sequential <br>\ncomposition \",\" uses the same facts each time: both simp steps will insert <br>\nthe given facts into the respective head subgoal before doing <br>\nsimplification.</p>\n<p>The second version puts one simp in the \"initial\" slot of 'by', and the <br>\nother in the \"terminal\" slot.  Only the initial method expressions sees <br>\nthe used facts, they are reset afterwards.</p>\n<p>The third version imitates the same operationally, using two separate <br>\n'apply' steps.  The 'apply' command essentially \"consumes\" the used facts, <br>\nso the second simp won't see them and fail.</p>\n<p>The fourth version refreshes the consumed facts by explicit 'using' in the <br>\napply script, so it works again.</p>\n<p>This illustrates that \"by method1 method2\" is structurally different from <br>\n\"by (method1, method2).  I always emphasize the importance to do canonical <br>\n\"by induct auto\" or \"by cases auto\" steps that way, and not \"optimize\" <br>\nspecial cases where old-fashioned sequential composition via \",\" happens <br>\nto work.  The latter is merely an odd imitation of tactical proof style in <br>\nIsar, and should have disappeared already 10 years ago.</p>\n<p>Makarius</p>",
        "id": 294229555,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901756
    }
]