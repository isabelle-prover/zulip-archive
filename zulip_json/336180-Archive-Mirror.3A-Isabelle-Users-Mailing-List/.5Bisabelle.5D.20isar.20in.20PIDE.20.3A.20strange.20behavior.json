[
    {
        "content": "<p>From: Michel via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nTo understand Isar, I try to write proofs without automation.<br>\nI have understood that after the word \"proof\", PIDE try to apply the implicit rule of the formula to prove and with \"r\", such a rule does not exists.<br>\nBut with show \"r\" using 1, it's worst.</p>\n<p>Intuitively, the proof of \"r\" is simple.<br>\n4: \"q --&gt; r\" by mp (modus ponens) on 1, 3<br>\n\"r\" by mp on 4, 2<br>\nWhy it's impossible to write this in Isar ?<br>\nHow to avoid the implicit use of rules?</p>\n<p>lemma trivial3isar : \"(p ⟶ (q ⟶ r)) ⟶ (q ⟶ (p ⟶ r))\"<br>\n  proof<br>\n    assume 1: \"p ⟶ (q ⟶ r)\"<br>\n    show \"q ⟶ (p ⟶ r)\"<br>\n    proof<br>\n      assume 2: \"q\"<br>\n      show \"p ⟶ r\"<br>\n      proof<br>\n        assume  3: \"p\"<br>\n        show \"r\"<br>\n          using 1<br>\n        proof</p>\n<p>With show \"r\" using 1,  the last proof gives two unsolvable goals<br>\n1 (q --&gt; r)==&gt; r<br>\n2 p --&gt; (q --&gt; r) ==&gt; p</p>",
        "id": 294707338,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181027
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nJust note that this highly nested proof structure is very unusual in<br>\npractice. </p>\n<p>The parenthesis structure of your goal is a bit misleading. Try </p>\n<p>term \"(p ⟶ (q ⟶ r)) ⟶ (q ⟶ (p ⟶ r))\"  </p>\n<p>to see how it looks with only necessary parenthesis:<br>\n  \"(p ⟶ q ⟶ r) ⟶ q ⟶ p ⟶ r\"</p>\n<p>Chains of implications are a very common thing in HOL, and usually you<br>\nhandle them all at once by repeated implication introduction ... there<br>\nis no need to open a new nesting level for every single impI:<br>\n<br>\n  lemma \"(p ⟶ (q ⟶ r)) ⟶ (q ⟶ (p ⟶ r))\"  <br>\n  proof (intro impI)</p>\n<p>having done this, the proof is almost as easy as you would write it<br>\ndown on paper. You have several stylistic possibilities here. You could<br>\nnumber your assumptions:</p>\n<p>assume 1: \"p ⟶ (q ⟶ r)\" and 2: \"q\" and 3: \"p\"<br>\n    from 1 have \"q⟶r\" using 3 by (rule mp)<br>\n    then show \"r\" using 2 by (rule mp)<br>\n  qed      <br>\n<br>\nor you could refer to the short assumptions explicitly by fact<br>\nantiquotations (note that you have to assume them anyway):</p>\n<p>lemma \"(p ⟶ (q ⟶ r)) ⟶ (q ⟶ (p ⟶ r))\"  <br>\n  proof (intro impI)<br>\n    assume \"q\" \"p\"<br>\n    assume \"p ⟶ (q ⟶ r)\" <br>\n    then have \"q⟶r\" using ‹p› by (rule mp)<br>\n    then show \"r\" using ‹q› by (rule mp)<br>\n  qed      </p>\n<p>I posted this email because I feel that this thread has the potential<br>\nto scare new Isabelle users and leave them with the impression they<br>\nneed deeply nested lengthy proofs to handle simple chains of<br>\nimplications ...</p>\n<p>Note to more advanced beginners:<br>\nUsually, you never state top-level implications on the HOL level, but<br>\nyou use the meta-level directly, e.g., you would write:</p>\n<p>lemma \"(p ⟶ (q ⟶ r)) ⟹ q ⟹ p ⟹ r\" or, equivalently:<br>\n  lemma \"⟦(p ⟶ (q ⟶ r)); q; p⟧ ⟹ r\" <br>\n  proof -<br>\n    assume \"q\" \"p\"<br>\n    assume \"p ⟶ (q ⟶ r)\" <br>\n    then have \"q⟶r\" using ‹p› by (rule mp)<br>\n    then show \"r\" using ‹q› by (rule mp)<br>\n  qed      </p>\n<p>(whether to use brackets or chains of implications is a matter of<br>\ntaste, and actually, brackets are just syntactic sugar for chains of<br>\nimplication. I, personally, find brackets easier to read.)</p>\n<p>Even more likely, you would use the long-goal format, which saves you<br>\nfrom re-stating the assumptions in the proof:</p>\n<p>lemma <br>\n    assumes 1: \"(p ⟶ (q ⟶ r))\" and \"q\" \"p\" <br>\n    shows \"r\"  <br>\n  proof -<br>\n    from 1 have \"q⟶r\" using ‹p› by (rule mp)<br>\n    then show \"r\" using ‹q› by (rule mp)<br>\n  qed</p>",
        "id": 294707364,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181032
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere are more examples that you can try: De Morgan laws.</p>\n<p>The predicate logic versions are actually simpler than the propositional<br>\nones, but you need to know how to introduce and eliminate quantifiers<br>\n(especially the 'obtain' element of Isar).</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/MuT4QsZCbMGlSAH-ldS5k884/De_Morgan.thy\">De_Morgan.thy</a></p>",
        "id": 294707401,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181045
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nAbsolutely right.</p>\n<p>To learn a natural proof style, it’s crucial to use automation. Most proofs involve a string of steps stated using “have” and concluding with “show”. The steps may be connected using “then” or using “moreover/ultimately”. And each justification should involve just a couple of steps involving simp/auto/blast or generated using sledgehammer. </p>\n<p>Nesting only arises when one of the intermediate steps is too difficult to prove directly by automation, but even then, the structure of the inner proof would be as described above.</p>\n<p>A nesting deeper than three is unusual except in long and complicated proofs.</p>\n<p>Try to find an example that goes outside pure logic.</p>\n<p>Larry Paulson</p>",
        "id": 294707427,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181054
    },
    {
        "content": "<p>From: Michel via Cl-isabelle-users &lt;<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nThank you really much for your examples.  I try to write basic proofs if <br>\nit possible without automation and with your suggestion it was possible. <br>\nI have written a software &lt;<a href=\"http://teachinglogic.liglab.fr/DN/\">http://teachinglogic.liglab.fr/DN/</a>&gt; (a long <br>\ntime ago) to produce proof in natural deduction.</p>\n<p>This software was originally written in Prolog by Robert Stärk, who was <br>\nassistant at ETH Zürich. I try to see if the proofs given by this <br>\nsoftware can be translated in Isar. That is the origin of my questions <br>\non Isar.</p>\n<p>Lawrence Paulson has said : It’s essential to understand that “proof” by <br>\nitself will attempt to use the default proof method. But this default <br>\nproof method can lead to an unprovable goal.</p>\n<p>If you have to show a not propositional formula, as in the examples <br>\ntriv1 and triv2 below, you have to give a \"by method\" or suggest an <br>\nhypothesis to eliminate.<br>\nIn the example triv1 below, the default proof method leads to an <br>\nunprovable goal, and there is no hypothesis to eliminate, so you are <br>\nobliged to give a \"by method\". In the example triv2, the default method <br>\nleads to an unprovable goal, but we can indicates an hypothesis to <br>\neliminate.</p>\n<p>lemma triv1 : \"p ⟹ q ∨ p\"<br>\n   (* proof : after the word proof, the new goal produced automatically<br>\n      by the intro rule disjI1 would be p ⟹ q<br>\n      which is unprovable. You have to give a method<br>\n      because you don't have an hypothesis to eliminate<br>\n   *)<br>\n     by (rule disjI2)</p>\n<p>lemma triv2 : assumes 1: \"p ∨ q\" shows \"q ∨ p\"<br>\n   (* proof : after the word proof, the new goal, produced by<br>\n      the implicit intro rule disjI1 would be<br>\n      p ∨ q ⟹ q which is unprovable<br>\n      so either you give a method (by method) to prove the lemma<br>\n      or you must indicate, with using, the assumption that can be <br>\neliminated<br>\n       *)<br>\n   using 1<br>\n   proof<br>\n     assume \"p\"<br>\n     then show \"q ∨ p\" by (rule disjI2)<br>\n     next<br>\n     assume \"q\"<br>\n     then show   \"q ∨ p\" by (rule disjI1)<br>\n   qed</p>\n<p>In the proof triv3, the thesis is a proposition, so you must use an <br>\nhypothesis (or a direct by method).</p>\n<p>lemma triv3 : assumes 1: \"p ∧ q\" shows \"p\"<br>\n   using 1<br>\nproof<br>\n   (* you must use the hypothesis 1 because no rule<br>\n   can be applied to the thesis \"p\".<br>\n   The new goal, thanks to the elimination of 1, is the trivial p ⟹ q ⟹ p<br>\n   *)<br>\n   show ?thesis by assumption<br>\nqed</p>\n<p>I think the indication above on how to prove a thesis must be written in <br>\nthe tutorial prog-prove or an another short tutorial on<br>\nthe manner to write proofs in Isar.</p>\n<p>Sincerely yours.</p>",
        "id": 294707473,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181069
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn 03/03/17 15:26, Michel via Cl-isabelle-users wrote:</p>\n<blockquote>\n<p>Thank you really much for your examples.  I try to write basic proofs if<br>\nit possible without automation and with your suggestion it was possible.<br>\nI have written a software &lt;<a href=\"http://teachinglogic.liglab.fr/DN/\">http://teachinglogic.liglab.fr/DN/</a>&gt; (a long<br>\ntime ago) to produce proof in natural deduction.</p>\n<p>This software was originally written in Prolog by Robert Stärk, who was<br>\nassistant at ETH Zürich. I try to see if the proofs given by this<br>\nsoftware can be translated in Isar. That is the origin of my questions<br>\non Isar.</p>\n<p>Lawrence Paulson has said : It’s essential to understand that “proof” by<br>\nitself will attempt to use the default proof method. But this default<br>\nproof method can lead to an unprovable goal.</p>\n</blockquote>\n<p>The main Isar proof scheme is as follows:</p>\n<p>from facts1 have goal<br>\n    using facts2<br>\n  proof method1<br>\n    ...<br>\n  qed method2</p>\n<p>The body \"...\" then consists recursively of sub-proofs, each with a<br>\nlocal context:</p>\n<p>fix parameters<br>\n  assume premises<br>\n  show conclusion<br>\n    &lt;proof&gt;</p>\n<p>These usually address each sub-goal in turn, but the order is arbitrary.<br>\nThe \"next\" command may be used to proceed with a fresh local context;<br>\nalternatively it is always possible to use { ... } to indicate context<br>\nblock structure.</p>\n<p>The initial refinement of \"proof method1\" uses facts = facts1 facts2<br>\n(appended in that order) and passes that to the proof method. It is<br>\n\"standard\" by default; \"standard\" is a bit more than just \"rule\", but<br>\nusually it is sufficient to think of \"rule\" as the standard step.</p>\n<p>The terminal method2 has a chance to finish-off remaining sub-goals (it<br>\nmay be omitted). Afterwards there is always an implicit stage to finish<br>\neverything implicitly by-assumption.</p>\n<p>Some important abbreviations:</p>\n<p>proof method1 qed method2  == by method1 method2<br>\n  ..  == by standard<br>\n  .   == by this</p>\n<p>Proof method \"standard\" applies a standard rule: the facts are put into<br>\nits premises (in that order), the remaining rule is applied to the goal.</p>\n<p>Proof method \"this\" applies all \"used\" facts directly, without putting a<br>\nrule in between.</p>\n<p>To apply these Isar principles in practice, I recommend to take all the<br>\nNatural Deduction rules for predicate logic as examples, and turn them<br>\ninto canonical Isar proof outlines, e.g. like this for conjunction:</p>\n<p>have \"A ∧ B\"<br>\n  proof<br>\n    show A sorry<br>\n    show B sorry<br>\n  qed</p>\n<p>next</p>\n<p>assume *: \"A ∧ B\"<br>\n  then have A ..<br>\n  from * have B ..</p>\n<p>The double projection is a bit awkward. Better eliminate conjunction<br>\nsimultaneously:</p>\n<p>assume \"A ∧ B\"<br>\n  then obtain A B ..</p>\n<p>Etc. ... Here is<br>\n<a href=\"http://teachinglogic.liglab.fr/DN/index.php?formula=p+%26+q+%3D%3E+q+%26+p&amp;action=Prove+Formula\">http://teachinglogic.liglab.fr/DN/index.php?formula=p+%26+q+%3D%3E+q+%26+p&amp;action=Prove+Formula</a><br>\nin Isar:</p>\n<p>have \"A ∧ B ⟶ B ∧ A\"<br>\n  proof<br>\n    assume \"A ∧ B\"<br>\n    then obtain B A ..<br>\n    then show \"B ∧ A\" ..<br>\n  qed</p>\n<p>You can enclose the above snippets into \"notepad begin ... end\", to<br>\navoid having toplevel theorem statements (which have separate syntax).</p>\n<p>I also recommend to start Isar without ever writing Pure rule statements<br>\nin the text: these somehow belong to the \"implementation\" of logic and<br>\nare rarely needed in proof texts.</p>\n<blockquote>\n<p>I think the indication above on how to prove a thesis must be written in<br>\nthe tutorial prog-prove or an another short tutorial on<br>\nthe manner to write proofs in Isar.</p>\n</blockquote>\n<p>After more than 30 years, the situation of Isabelle manuals is very<br>\ncomplex. Everything can be found somewhere, but it might take time to<br>\nfind it. Moreover, some old materials needs to be ignored, especially<br>\nwhen getting started.</p>\n<p>Makarius</p>",
        "id": 294707543,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181097
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is more exercise material based on the above website. It uses<br>\nIsabelle/Pure directly, without the huge Isabelle/HOL library.  Thus it<br>\nis really confined to single-step structure proofs in Isar. Moreover,<br>\nclassical logic is not assumed globally, but confined to a separate<br>\nlocale context (in contrast, most Isabelle/HOL tools use classical logic<br>\nimplicitly).</p>\n<p>As Peter has already pointed out before, these proofs are a bit atypical<br>\nfor practical Isar: there is a fine art to write rule statements in open<br>\nform, without too many auxiliary logical connectives getting in between.<br>\nThis is occasionally called \"logic-free reasoning\".</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/bUGCOIV4GgJ0RMFKxTCIO9mi/Pure_Logic.thy\">Pure_Logic.thy</a><br>\n<a href=\"/user_uploads/14278/OZ9_1kWygPojkD0Eh5Mfx76e/Ex.thy\">Ex.thy</a></p>",
        "id": 294707550,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661181100
    }
]