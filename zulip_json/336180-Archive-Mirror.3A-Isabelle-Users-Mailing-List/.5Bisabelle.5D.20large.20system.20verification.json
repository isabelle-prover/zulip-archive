[
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:a.popescu@mdx.ac.uk\">a.popescu@mdx.ac.uk</a>&gt;<br>\nDear (large) system verification experts,</p>\n<p>I am surveying the literature on this topic and I identified two approaches to verifying software systems in a proof assistant with acquiring solid adequacy guarantees:</p>\n<p>(1) Develop (the core of) the system in the proof assistant and extract code to a programming language.</p>\n<p>(2) Develop the system in the programming language directly and extract a model to be verified in the proof assistant.  </p>\n<p>My 5 cents here are that, while (1) can be convenient for getting things done reliably, (2) is more realistic regarding the prospect of collaborating with developers without verification expertise, and ultimately with the industry. Or can we hope that in the near future \"the industry\" will embrace the initial development of systems in a proof assistant? </p>\n<p>Of course, there are nuances here, e.g., is one aiming at verifying a large monolithic system or an open-ended class of systems (the latter being closer to the goal of a program verification framework)?<br>\nI know there have been successful projects in both categories and I would be interested to hear opinions and examples concerning these two approaches. </p>\n<p>(This question is related to the thread \"proof engineering for program verification\", but has a slightly different scope.)  </p>\n<p>Many thanks in advance,   <br>\n  Andrei</p>\n<hr>\n<p>Please note that Middlesex University's preferred way of receiving all correspondence is via email in line with our Environmental Policy. All incoming post to Middlesex University is opened and scanned by our digital document handler, CDS, and then emailed to the recipient.</p>\n<p>If you do not want your correspondence to Middlesex University processed in this way please email the recipient directly. Parcels, couriered items and recorded delivery items will not be opened or scanned by CDS.  There are items which are \"exceptions\" which will be opened by CDS but will not be scanned a full list of these can be obtained by contacting the University.</p>",
        "id": 294645794,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164003
    },
    {
        "content": "<p>From: Magnus Myreen &lt;<a href=\"mailto:mom22@cam.ac.uk\">mom22@cam.ac.uk</a>&gt;<br>\nDear Andrei,</p>",
        "id": 294645815,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164012
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nI completely agree with Magnus.</p>\n<p>There are also examples of larger systems being developed in Dafny, which is more towards (1), although in this case Dafny <em>is</em> the programming language, so itâ€™s really more a mix of the two.</p>\n<p>Ultimately I think a mix will give you the highest productivity at the moment, but (1) will only work with non-verification-experts if the language you are using in the proof assistant is a full programming language by itself.</p>\n<p>Cheers,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294645823,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661164016
    }
]