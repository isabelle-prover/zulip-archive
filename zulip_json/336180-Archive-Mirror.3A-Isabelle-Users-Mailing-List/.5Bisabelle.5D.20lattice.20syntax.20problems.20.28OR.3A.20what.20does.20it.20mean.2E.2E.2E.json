[
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHello all,</p>\n<p>I have recently noticed some weird/undesirable behavior with regards<br>\nto lattice syntax. Exploring this issue brings up some fundamental<br>\nquestions about what it really means for Isabelle to merge two<br>\ntheories.</p>\n<p>As many of you may know, HOL/Lattices.thy defines infix syntax for<br>\nvarious lattice operations, including binary \"inf\" and \"sup\"; but then<br>\nit uses \"no_notation\" to erase this syntax at the end of the file, to<br>\navoid using up so many precious symbols. Users who want to use the<br>\nsyntax can import it from HOL/Library/Lattice_Syntax, like this:</p>\n<p>theory Scratch imports \"~~/src/HOL/Library/Lattice_Syntax\" begin<br>\nterm \"x \\&lt;sqinter&gt; y\" (* parses as \"inf x y\" *)</p>\n<p>When I wrote my Free Boolean Algebra AFP entry (which makes heavy use<br>\nof the lattice syntax) I followed what seemed to be the best practice,<br>\nand used \"no_notation\" to delete the syntax again.</p>\n<p>I expected that users of my Free_Boolean_Algebra library would be able<br>\nto use the lattice syntax (if they chose to do so) by importing<br>\nLibrary/Lattice_Syntax again. Unfortunately this does not work!</p>\n<p>theory Scratch<br>\nimports<br>\n  \"~~/src/HOL/Library/Lattice_Syntax\"<br>\n  \"~/hg/afp/thys/Free-Boolean-Algebra/Free_Boolean_Algebra\"<br>\nbegin</p>\n<p>term \"x \\&lt;sqinter&gt; y\"</p>\n<p>*** Inner lexical error at: \\&lt;sqinter&gt; y (line 7 of<br>\n\"/home/brianh/Documents/Isabelle/Scratch.thy\")<br>\n*** Failed to parse term<br>\n*** At command \"term\" (line 7 of \"/home/brianh/Documents/Isabelle/Scratch.thy\")</p>\n<p>I thought that when you say \"theory C imports A B begin\", Isabelle<br>\nshould actually merge theories A and B. In particular, any input<br>\nsyntax that exists in either theory A or theory B should be available<br>\nin theory C. But that is not the case here! The syntax in<br>\nLattice_Syntax is completely ignored.</p>\n<p>Evidently, Isabelle assumes that merging Lattice_Syntax +<br>\nFree_Boolean_Algebra will be equal to the Free_Boolean_Algebra theory<br>\nby itself (because Lattice_Syntax is an ancestor theory of<br>\nFree_Boolean_Algebra) and optimizes away the actual theory merge. But<br>\nthis is an invalid assumption.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294139960,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845512
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nOn 07/28/2011 05:28 PM, Brian Huffman wrote:</p>\n<blockquote>\n<p>Hello all,</p>\n<p>I have recently noticed some weird/undesirable behavior with regards<br>\nto lattice syntax. Exploring this issue brings up some fundamental<br>\nquestions about what it really means for Isabelle to merge two<br>\ntheories.</p>\n<p>As many of you may know, HOL/Lattices.thy defines infix syntax for<br>\nvarious lattice operations, including binary \"inf\" and \"sup\"; but then<br>\nit uses \"no_notation\" to erase this syntax at the end of the file, to<br>\navoid using up so many precious symbols. Users who want to use the<br>\nsyntax can import it from HOL/Library/Lattice_Syntax, like this:</p>\n<p>theory Scratch imports \"~~/src/HOL/Library/Lattice_Syntax\" begin<br>\nterm \"x \\&lt;sqinter&gt;  y\" (* parses as \"inf x y\" *)</p>\n<p>When I wrote my Free Boolean Algebra AFP entry (which makes heavy use<br>\nof the lattice syntax) I followed what seemed to be the best practice,<br>\nand used \"no_notation\" to delete the syntax again.</p>\n<p>I expected that users of my Free_Boolean_Algebra library would be able<br>\nto use the lattice syntax (if they chose to do so) by importing<br>\nLibrary/Lattice_Syntax again. Unfortunately this does not work!</p>\n<p>theory Scratch<br>\nimports<br>\n   \"~~/src/HOL/Library/Lattice_Syntax\"<br>\n   \"~/hg/afp/thys/Free-Boolean-Algebra/Free_Boolean_Algebra\"<br>\nbegin</p>\n<p>term \"x \\&lt;sqinter&gt;  y\"</p>\n<p>*** Inner lexical error at: \\&lt;sqinter&gt;  y (line 7 of<br>\n\"/home/brianh/Documents/Isabelle/Scratch.thy\")<br>\n*** Failed to parse term<br>\n*** At command \"term\" (line 7 of \"/home/brianh/Documents/Isabelle/Scratch.thy\")</p>\n<p>I thought that when you say \"theory C imports A B begin\", Isabelle<br>\nshould actually merge theories A and B. In particular, any input<br>\nsyntax that exists in either theory A or theory B should be available<br>\nin theory C. But that is not the case here! The syntax in<br>\nLattice_Syntax is completely ignored.</p>\n<p>Evidently, Isabelle assumes that merging Lattice_Syntax +<br>\nFree_Boolean_Algebra will be equal to the Free_Boolean_Algebra theory<br>\nby itself (because Lattice_Syntax is an ancestor theory of<br>\nFree_Boolean_Algebra) and optimizes away the actual theory merge. But<br>\nthis is an invalid assumption.</p>\n<p>Obviously, you cannot load a theory twice in Isabelle.<br>\nSo, it is not only an optimization but an necessity not to load and <br>\nmerge the theory twice in your situation.</p>\n</blockquote>\n<p>I guess the pragmatic solution is to ask your users to use a clone of <br>\nLattice_Syntax with a different name. The correct technical solution in <br>\nIsabelle is a local context-aware infrastructure for syntax, which is <br>\njust a little bit out of reach right now, but other people can probably <br>\ndescribe the situation more in-depth than I can right now.</p>\n<p>Lukas</p>\n<blockquote>\n<ul>\n<li>Brian<br>\n</li>\n</ul>\n</blockquote>",
        "id": 294139980,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845519
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Thu, Jul 28, 2011 at 9:26 AM, Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Obviously, you cannot load a theory twice in Isabelle.<br>\nSo, it is not only an optimization but an necessity not to load and merge<br>\nthe theory twice in your situation.</p>\n</blockquote>\n<p>Loading and merging are separate things. I am not asking Isabelle to<br>\n<em>load</em> the same theory twice. I am merely asking Isabelle to <em>merge</em> a<br>\ntheory with one of its ancestors.</p>\n<blockquote>\n<p>I guess the pragmatic solution is to ask your users to use a clone of<br>\nLattice_Syntax with a different name.</p>\n</blockquote>\n<p>I am well aware of a workaround. All I have to do is create a dummy<br>\nempty theory file called \"Lattice_Syntax_Copy\" that imports<br>\nLattice_Syntax.</p>\n<p>theory Lattice_Syntax_Copy imports Lattice_Syntax begin<br>\nend</p>\n<p>Now, since Lattice_Syntax_Copy is not actually an ancestor of<br>\nFree_Boolean_Algebra, then Isabelle can be persuaded to do actually<br>\nmerge them together.</p>\n<p>theory Scratch imports Lattice_Syntax_Copy Free_Boolean_Algebra begin<br>\nterm \"x \\&lt;sqinter&gt; y\" (* this works *)</p>\n<blockquote>\n<p>The correct technical solution in<br>\nIsabelle is a local context-aware infrastructure for syntax, which is just a<br>\nlittle bit out of reach right now, but other people can probably describe<br>\nthe situation more in-depth than I can right now.</p>\n</blockquote>\n<p>Yes, a much nicer long-term solution would be something that would<br>\nmake the whole no_notation/Lattice_Syntax.thy hack unnecessary.</p>\n<p>But in the short term, it would be nice for theory imports to behave<br>\nin the way I expect (i.e. actually merge every theory in the import<br>\nlist, without throwing any away). I tracked the problem to the<br>\nfunction Context.begin_thy in Pure/context.ML. The function<br>\nmaximal_thys implents the ignore-ancestors-in-imports bug/feature:</p>\n<p>fun maximal_thys thys =<br>\n  thys |&gt; filter_out (fn thy =&gt; exists (fn thy' =&gt; proper_subthy (thy,<br>\nthy')) thys);</p>\n<p>fun begin_thy pp name imports =<br>\n  if name = \"\" orelse name = draftN then error (\"Bad theory name: \" ^<br>\nquote name)<br>\n  else<br>\n    let<br>\n      val parents = maximal_thys (distinct eq_thy imports);<br>\n      ...</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294140022,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845531
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nAt the current state of the art, I see two approaches to deal with that<br>\nissues:</p>\n<ul>\n<li>Import Lattice_Syntax, and do not modify/remove it later on</li>\n<li>add the infamous notation / no_notation prelude and postlude</li>\n</ul>\n<p>In the long run the vision is to have syntax managed by locales and this<br>\nacitvate it on demand.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/O9_Aai_LhH7mUHHtBVNdx8c-/signature.asc\">signature.asc</a></p>",
        "id": 294140045,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845537
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nOne cannot change the semantics of theory merges \"in the short term\", <br>\njust because \"no_notation\" happens to be conceptually broken. We must <br>\nget rid of it, instead of going further in the same direction.</p>\n<p>Alex</p>",
        "id": 294140166,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845581
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nI am not suggesting that we change the merge behavior \"just because<br>\nno_notation is broken\". Rather, I am suggesting that we change the<br>\nmerge behavior because the merge behavior itself is broken. The<br>\nno_notation command just happens to be the thing that caused me to see<br>\nthe problem; the basic problem with theory merging is really much more<br>\ngeneral.</p>\n<p>The current ignore-everything-but-maximal-theories merge behavior was<br>\nintroduced in 2005:</p>\n<p><a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/f1152f75f6fc\">http://isabelle.in.tum.de/repos/isabelle/rev/f1152f75f6fc</a></p>\n<p>This implementation assumes that when a user imports theories A and B,<br>\nwhere A is an ancestor to B, then merging A and B will always yield a<br>\ntheory that is identical to B. So, as an optimization, it doesn't<br>\nbother to merge A at all.</p>\n<p>The implicit assumption here, upon which the correctness of this<br>\noptimization rests, is that descendant theories only extend the theory<br>\ncontext in a monotonic fashion. The problem is that this simply is not<br>\ntrue.</p>\n<p>The \"no_notation\" command is one example of something that modifies<br>\nthe theory context in a non-monotonic way, deleting something from the<br>\ncontext, instead of adding to it. You say that we may eventually get<br>\nrid of the \"no_notation\" command, but what about all the other<br>\ncommands that delete things from the theory context? Will \"declare foo<br>\n[simp del]\" be phased out as well?</p>\n<p>I propose that we go back to the pre-2005 theory merge semantics, by<br>\nreverting the relevant portion of changeset f1152f75f6fc. If at some<br>\npoint in the future we manage to completely eradicate all<br>\nnon-monotonic theory-updating commands, at that time it might be safe<br>\nto reinstate the maximal-theories-only optimization.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294140237,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845599
    }
]