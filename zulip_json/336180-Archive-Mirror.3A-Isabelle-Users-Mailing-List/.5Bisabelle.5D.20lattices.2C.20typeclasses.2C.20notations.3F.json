[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nHi,</p>\n<p>I'm a newbie on Isabelle typeclasses.  Doing an information flow<br>\nexample, I have:</p>\n<p>datatype policy = ...</p>\n<p>I want make a lattice out of policies, and I have definitions</p>\n<p>function policyMeet :: \"policy \\&lt;Rightarrow&gt; policy \\&lt;Rightarrow&gt;<br>\npolicy\" (infixl \"|\\&lt;and&gt;\" 100)<br>\nwhere ...<br>\nfunction policyJoin :: \"policy \\&lt;Rightarrow&gt; policy \\&lt;Rightarrow&gt;<br>\npolicy\" (infixl \"|\\&lt;or&gt;\" 100)<br>\nwhere ...</p>\n<p>I define the order and prove it is a partial order:</p>\n<p>define policyOrder :: \"policy \\&lt;Rightarrow&gt; policy \\&lt;Rightarrow&gt; bool\"<br>\n  ( \"_ \\&lt;sqsubseteq&gt; _\" )<br>\nwhere \"(P1 \\&lt;sqsubseteq&gt; P2) = ((P1 |\\&lt;and&gt; P2) = P1)\"</p>\n<p>lemma policyOrderRfl[simp]:<br>\n  fixes P::policy<br>\n  shows \"P \\&lt;sqsubseteq&gt; P\"<br>\n...</p>\n<p>Now to make \"policy\" into a partial order.  As a locale interpretation<br>\nthis works fine:</p>\n<p>interpretation policy: partial_order \"policyOrder :: policy<br>\n\\&lt;Rightarrow&gt; policy \\&lt;Rightarrow&gt; bool\"<br>\nproof (unfold_locales, rule policyOrderRfl)<br>\n  fix x y z :: policy assume j1:\"x \\&lt;sqsubseteq&gt; y\" and j2:\"y \\&lt;sqsubseteq&gt; z\"<br>\n  show \"x \\&lt;sqsubseteq&gt; z\" using policyOrderTrn[OF j1 j2] .<br>\nnext ...</p>\n<p>However as a typeclass instantiation I get stuck:</p>\n<p>instantiation policy::partial_order<br>\nbegin<br>\ndefinition \"leq = policyOrder\"<br>\ninstance<br>\nproof (intro_classes)</p>\n<p>The first goal is</p>\n<p>\\&lt;And&gt;x. x \\&lt;sqsubseteq&gt; x</p>\n<p>So I try</p>\n<p>fix x::policy show \"x \\&lt;sqsubseteq&gt; x\"</p>\n<p>Already this is not accepted.  Perhaps there is an ambiguity between<br>\nthe \\&lt;sqsubseteq&gt; of policyOrder and the \\&lt;sqsubseteq&gt; of the<br>\npartial_order class (in spite of the explicit annotation (x::policy\").</p>\n<p>So I try</p>\n<p>fix x::policy show \"leq x x\" using policyOrderRfl  .</p>\n<p>Here the \"show\" is accepted, but the last step \".\" still fails.</p>\n<p>What is my problem?  Thanks for any info.</p>\n<p>Randy</p>",
        "id": 294137189,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844727
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Randy,</p>\n<p>[...]</p>\n<blockquote>\n<p>However as a typeclass instantiation I get stuck:</p>\n<p>instantiation policy::partial_order</p>\n</blockquote>\n<p>First of all, you seem to be using the partial_order class from <br>\nHOL/Lattice session. There is nothing wrong with this, but note that <br>\nthere is also a similar class \"order\" in HOL/Orderings.thy and \"lattice\" <br>\nin HOL/Lattices.thy. These are already part of the HOL image, and I <br>\nthink they are better integrated in terms of reasoning infrastructure, <br>\nbut I am not sure. These classes use the symbol \\&lt;le&gt; rather than <br>\n\\&lt;sqsubseteq&gt; and also include a strict variant.</p>\n<blockquote>\n<p>begin<br>\ndefinition \"leq = policyOrder\"<br>\ninstance<br>\nproof (intro_classes)</p>\n<p>The first goal is</p>\n<p>\\&lt;And&gt;x. x \\&lt;sqsubseteq&gt;  x</p>\n<p>So I try</p>\n<p>fix x::policy show \"x \\&lt;sqsubseteq&gt;  x\"</p>\n<p>Already this is not accepted.  Perhaps there is an ambiguity between<br>\nthe \\&lt;sqsubseteq&gt;  of policyOrder and the \\&lt;sqsubseteq&gt;  of the<br>\npartial_order class (in spite of the explicit annotation (x::policy\").</p>\n<p>So I try</p>\n<p>fix x::policy show \"leq x x\" using policyOrderRfl  .</p>\n<p>Here the \"show\" is accepted, but the last step \".\" still fails.</p>\n<p>What is my problem?  Thanks for any info.</p>\n</blockquote>\n<p>You are confusing the two constants, \"leq\" and \"policyOrder\". They are <br>\ndefined to be equal, but the definition must be used explicitly. Since <br>\nyou have ambiguous notation, \\&lt;sqsubseteq&gt; refers to policyOrder, which <br>\nis why the first attempt fails. In the second attempt, your goal is OK, <br>\nbut the proof is not, because policyOrderRfl uses a different constant. <br>\nYou should unfold the definition (I think in this context it will be <br>\ncalled something like leq_policy_def) explicitly.</p>\n<p>It may also be a good idea to get rid of the syntax for policyOrder. It <br>\nmakes your grammar ambiguous (which produces tons of warnings), and once <br>\nyou have the instance, you can use it anyway, since it is defined for <br>\nthe type class.</p>\n<p>Hope this helps,<br>\nAlex</p>",
        "id": 294137208,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844734
    },
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nThanks Alex.  I'm using \"order\" in HOL/Orderings.thy and \"lattice\" in<br>\nHOL/Lattices.thy as Alex suggested.  My typeclass instantiation works.</p>\n<p>Now I want to work with the dual of a given lattice.  In HOL/Lattices.thy I see</p>\n<p>lemma dual_lattice:<br>\n  \"class.lattice (op \\&lt;ge&gt;) (op &gt;) sup inf\"<br>\n  by [...]</p>\n<p>What does that mean?  How can I use this lemma?  Please point me to<br>\nexamples;.  This lemma is not even used to prove lemma<br>\ndual_bounded_lattice in the same file.</p>\n<p>Looking at the HOL/Lattice session I found the following kind of example</p>\n<p>datatype 'a dual = dual 'a<br>\nprimrec undual :: \"'a dual \\&lt;Rightarrow&gt; 'a\" where<br>\n  undual_dual: \"undual (dual x) = x\"</p>\n<p>instantiation dual:: (lattice) lattice<br>\nbegin<br>\ndefinition \"inf_dual x y = dual (sup (undual x) (undual y))\"<br>\n[...]<br>\ninstance<br>\nproof</p>\n<p>Now I get 12 subgoals (which I can probably prove) but I haven't taken advantage<br>\nof lemma dual_lattice.</p>\n<p>Please explain how this is intended to be done.</p>\n<p>Thanks,<br>\nRandy</p>\n<hr>",
        "id": 294137343,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844770
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Randy,</p>\n<blockquote>\n<p>Now I want to work with the dual of a given lattice.  In HOL/Lattices.thy I see</p>\n<p>lemma dual_lattice:<br>\n  \"class.lattice (op \\&lt;ge&gt;) (op &gt;) sup inf\"<br>\n  by [...]</p>\n<p>What does that mean?<br>\nThis lemma is proven in the context lattice, i.e. it holds for all instances of <br>\nthe lattice type class. Thus, this means that the assumptions of the type class <br>\nlattice (expressed by the predicate class.lattice) hold for the operations &gt;=, <br>\n, sup, inf for all instances of the lattice type class. Less formally: <br>\nWhenever &lt;=, &lt;, inf, sup form a lattice, so do &gt;=, &gt;, sup, inf.</p>\n</blockquote>\n<blockquote>\n<p>How can I use this lemma?  Please point me to<br>\nexamples;.<br>\nThere is just one example in HOL/Lattices for dual_lattice (in the proof of <br>\ndual_distrib_lattice). But there are more examples for dual_semilattice, which <br>\nis essentially the same concept. Lemmas less_supI1 and less_supI2 show how it is <br>\nmeant to use this lemma.</p>\n</blockquote>\n<blockquote>\n<p>Looking at the HOL/Lattice session I found the following kind of example</p>\n<p>datatype 'a dual = dual 'a<br>\nprimrec undual :: \"'a dual \\&lt;Rightarrow&gt; 'a\" where<br>\n  undual_dual: \"undual (dual x) = x\"</p>\n<p>instantiation dual:: (lattice) lattice<br>\nbegin<br>\ndefinition \"inf_dual x y = dual (sup (undual x) (undual y))\"<br>\n[...]<br>\ninstance<br>\nproof</p>\n<p>Now I get 12 subgoals (which I can probably prove) but I haven't taken advantage<br>\nof lemma dual_lattice.</p>\n<p>Please explain how this is intended to be done.<br>\nThe HOL/Lattice development and Lattices.thy are not compatible connected to <br>\neach other. This is just another way of dealing with dual lattices (or symmetric <br>\ninstances of type classes, in general).</p>\n</blockquote>\n<p>Let me briefly compare the two approaches:<br>\nOn the one hand, Lattices.thy assumes that you mainly work with the normal type <br>\nclass instantiation. In case you need the dual, the recommended scheme is as in <br>\nlemmas less_supI1 and less_supI2, i.e. interpret the local context that is <br>\nassociated with the type class with the operations instantiated for the dual <br>\nlattice. Then, use these theorems to prove your goal. This works nicely in terms <br>\nof tool support, but you have to do the local interpretation for every lemma <br>\nthat needs the dual. Moreover, you do not get a dual instance for type class <br>\ninstances.</p>\n<p>On the other hand, the dual type in HOL/Lattice provides a type wrapper for dual <br>\nlattices. In Isabelle, every type may instantiate a type class only once. Hence, <br>\nyou cannot have instantiations of a lattice and its dual for the same type. <br>\nInstead, the type dual instantiates the lattice type classes for the dual <br>\nlattice operations. Suppose you are working on a concrete type my_type which <br>\ninstantiates the lattice type class. Then, if you need the operations from the <br>\nlattice, work in type my_type. If you need to work in the dual lattice, transfer <br>\nyour statement to type \"my_type dual\". An example how this can be used, is in <br>\nHOL/Lattice/Lattices.thy in lemmas join_assoc and join_commute.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294137375,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844783
    }
]