[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nHi,</p>\n<p>I have a relation \"↝\" representing the reductions of a small-step operational semantics. By construction, every configuration can only reduce to finitely-many next configurations.</p>\n<p>Given an initial configuration C, I would like to prove that if every execution starting from C gets stuck after a finite number of steps, then there are only finitely-many executions of C0.</p>\n<p>I'm having quite a bit of difficulty getting my head round how to prove this. I can do it if I assume that the entire \"↝\" relation is well-founded, but that's too strong an assumption, since I need it to be possible for <em>some</em> executions to diverge, just not those that start from C.</p>\n<p>I have a sense that my lemma, if it is indeed true, will have been proven before, perhaps in the context of graph theory, or computability theory.</p>\n<p>I'd really appreciate any hints the Isabelle community might have for how I might prove this, or where/whether it has already been proven.</p>\n<p>Thanks!<br>\nJohn</p>\n<p>ps. In case more precision is appropriate...</p>\n<p>I'm defining executions like this:</p>\n<blockquote>\n<p>definition executions :: \"config ⇒ (nat ⇒ config option) set\"<br>\nwhere<br>\n \"executions C ≡ {π.  π 0 = Some C ∧ (∀i. <br>\n case π i of None ⇒ π (i+1) = None | Some C ⇒ <br>\n if reduce C=[] then π (i+1) = None <br>\n                else π (i+1) ∈ Some ` set (reduce C))}\"</p>\n</blockquote>\n<p>and my lemma is:</p>\n<blockquote>\n<p>lemma <br>\n assumes \"∀π ∈ executions C. ∃i &gt; 0. finite_seq i π\" <br>\n shows \"finite (executions C)\"</p>\n</blockquote>\n<p>and I define finite_seq like so:</p>\n<blockquote>\n<p>fun finite_seq where<br>\n \"finite_seq 0 π = (∀i. π i = None)\"<br>\n| \"finite_seq (Suc i) π = (π 0 ≠ None ∧ finite_seq i (λi. π (Suc i)))\"</p>\n</blockquote>",
        "id": 294281279,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920450
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi John,</p>\n<p>On 16/06/14 14:00, John Wickerson wrote:</p>\n<blockquote>\n<p>I have a relation \"↝\" representing the reductions of a small-step operational semantics. By construction, every configuration can only reduce to finitely-many next configurations.</p>\n<p>Given an initial configuration C, I would like to prove that if every execution starting from C gets stuck after a finite number of steps, then there are only finitely-many executions of C0.</p>\n<p>I'm having quite a bit of difficulty getting my head round how to prove this. I can do it if I assume that the entire \"↝\" relation is well-founded, but that's too strong an assumption,<br>\nYour assumption is that all executions starting in C eventually get stuck. You can prove <br>\nthat this is equivalent to the well-foundedness of ↝ restricted to the states reachable <br>\nfrom C. Then, you can use well-founded induction to show finiteness, probably similar to <br>\nwhat you already have.</p>\n</blockquote>\n<p>To show well-foundedness, you can take the length of the longest execution starting in a <br>\nstate as measure function.</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>since I need it to be possible for <em>some</em> executions to diverge, just not those that <br>\nstart from C.</p>\n<blockquote>\n<p>I have a sense that my lemma, if it is indeed true, will have been proven before, perhaps in the context of graph theory, or computability theory.</p>\n<p>I'd really appreciate any hints the Isabelle community might have for how I might prove this, or where/whether it has already been proven.</p>\n<p>Thanks!<br>\nJohn</p>\n<p>ps. In case more precision is appropriate...</p>\n<p>I'm defining executions like this:</p>\n<blockquote>\n<p>definition executions :: \"config ⇒ (nat ⇒ config option) set\"<br>\nwhere<br>\n  \"executions C ≡ {π.  π 0 = Some C ∧ (∀i.<br>\n  case π i of None ⇒ π (i+1) = None | Some C ⇒<br>\n  if reduce C=[] then π (i+1) = None<br>\n                 else π (i+1) ∈ Some ` set (reduce C))}\"</p>\n</blockquote>\n<p>and my lemma is:</p>\n<blockquote>\n<p>lemma<br>\n  assumes \"∀π ∈ executions C. ∃i &gt; 0. finite_seq i π\"<br>\n  shows \"finite (executions C)\"</p>\n</blockquote>\n<p>and I define finite_seq like so:</p>\n<blockquote>\n<p>fun finite_seq where<br>\n  \"finite_seq 0 π = (∀i. π i = None)\"<br>\n| \"finite_seq (Suc i) π = (π 0 ≠ None ∧ finite_seq i (λi. π (Suc i)))\"<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294281290,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920452
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nThanks very much for your reply Andreas.</p>\n<p>I had actually tried the idea of using \"well-foundedness of ↝ restricted to the states reachable from C\", but couldn't make it work. I've just tried it again, encouraged by your suggestion, but I'm still struggling. </p>\n<p>Specifically, I'm phrasing my lemma like this (↝* is an abbreviation I defined for the reflexive transitive closure of ↝):</p>\n<blockquote>\n<p>lemma<br>\n  assumes \"wf {(C2,C1). C ↝* C1 ∧ C1 ↝ C2}\"<br>\n  shows \"finite (traces C)\"</p>\n</blockquote>\n<p>I use wf_induct:</p>\n<blockquote>\n<p>proof (rule wf_induct[OF assms])</p>\n</blockquote>\n<p>That reduces the problem to the following (I've made the assumption slightly more readable):</p>\n<blockquote>\n<p>fix C1<br>\n  assume 1: \"∀C2. C ↝* C1 ∧ C1 ↝ C2 ⟶ finite (traces C2)\"<br>\n  show \"finite (traces C1)\"</p>\n</blockquote>\n<p>My specific problem is that before I can exploit fact \"1\", I need to show that C1 is indeed reachable from C. I simply don't have that fact anywhere!</p>\n<p>Do you have any further tips that might help me? Many many thanks!</p>\n<p>John</p>\n<p>On 16 Jun 2014, at 13:57, Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi John,</p>\n<p>On 16/06/14 14:00, John Wickerson wrote:</p>\n<blockquote>\n<p>I have a relation \"↝\" representing the reductions of a small-step operational semantics. By construction, every configuration can only reduce to finitely-many next configurations.</p>\n<p>Given an initial configuration C, I would like to prove that if every execution starting from C gets stuck after a finite number of steps, then there are only finitely-many executions of C0.</p>\n<p>I'm having quite a bit of difficulty getting my head round how to prove this. I can do it if I assume that the entire \"↝\" relation is well-founded, but that's too strong an assumption,<br>\nYour assumption is that all executions starting in C eventually get stuck. You can prove that this is equivalent to the well-foundedness of ↝ restricted to the states reachable from C. Then, you can use well-founded induction to show finiteness, probably similar to what you already have.</p>\n</blockquote>\n<p>To show well-foundedness, you can take the length of the longest execution starting in a state as measure function.</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>since I need it to be possible for <em>some</em> executions to diverge, just not those that start from C.</p>\n<blockquote>\n<p>I have a sense that my lemma, if it is indeed true, will have been proven before, perhaps in the context of graph theory, or computability theory.</p>\n<p>I'd really appreciate any hints the Isabelle community might have for how I might prove this, or where/whether it has already been proven.</p>\n<p>Thanks!<br>\nJohn</p>\n<p>ps. In case more precision is appropriate...</p>\n<p>I'm defining executions like this:</p>\n<blockquote>\n<p>definition executions :: \"config ⇒ (nat ⇒ config option) set\"<br>\nwhere<br>\n \"executions C ≡ {π.  π 0 = Some C ∧ (∀i.<br>\n case π i of None ⇒ π (i+1) = None | Some C ⇒<br>\n if reduce C=[] then π (i+1) = None<br>\n                else π (i+1) ∈ Some ` set (reduce C))}\"</p>\n</blockquote>\n<p>and my lemma is:</p>\n<blockquote>\n<p>lemma<br>\n assumes \"∀π ∈ executions C. ∃i &gt; 0. finite_seq i π\"<br>\n shows \"finite (executions C)\"</p>\n</blockquote>\n<p>and I define finite_seq like so:</p>\n<blockquote>\n<p>fun finite_seq where<br>\n \"finite_seq 0 π = (∀i. π i = None)\"<br>\n| \"finite_seq (Suc i) π = (π 0 ≠ None ∧ finite_seq i (λi. π (Suc i)))\"</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294281373,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920477
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi John,</p>\n<p>On 16/06/14 16:48, John Wickerson wrote:</p>\n<blockquote>\n<p>Thanks very much for your reply Andreas.</p>\n<p>I had actually tried the idea of using \"well-foundedness of ↝ restricted to the states reachable from C\", but couldn't make it work. I've just tried it again, encouraged by your suggestion, but I'm still struggling.</p>\n<p>Specifically, I'm phrasing my lemma like this (↝* is an abbreviation I defined for the reflexive transitive closure of ↝):</p>\n<blockquote>\n<p>lemma<br>\n   assumes \"wf {(C2,C1). C ↝* C1 ∧ C1 ↝ C2}\"<br>\n   shows \"finite (traces C)\"</p>\n</blockquote>\n<p>I use wf_induct:</p>\n<blockquote>\n<p>proof (rule wf_induct[OF assms])</p>\n</blockquote>\n<p>That reduces the problem to the following (I've made the assumption slightly more readable):</p>\n<blockquote>\n<p>fix C1<br>\n   assume 1: \"∀C2. C ↝* C1 ∧ C1 ↝ C2 ⟶ finite (traces C2)\"<br>\n   show \"finite (traces C1)\"</p>\n</blockquote>\n<p>My specific problem is that before I can exploit fact \"1\", I need to show that C1 is indeed reachable from C. I simply don't have that fact anywhere!<br>\nAt the moment, your induction predicate is \"%C. finite (traces C)\". You have to generalise <br>\nit to arbitrary states reachable from C, i.e.,</p>\n</blockquote>\n<p>lemma<br>\n   assumes \"wf {(C2,C1). C ↝* C1 ∧ C1 ↝ C2}\"<br>\n   and \"C ↝* C1\"<br>\n   shows \"finite (traces C1)\"<br>\nusing assms<br>\nproof(induction C1 rule: wf_induct_rule)</p>\n<blockquote>\n<p>Do you have any further tips that might help me? Many many thanks!<br>\nDo not use any of the basic proof rules for wf to establish the well-foundedness <br>\nassumption. The resulting proof oblications are usually too complicated. Rather show that <br>\nthe relation \"{(C2,C1). C ↝* C1 ∧ C1 ↝ C2}\" is a subset of \"measure f\" for some measure <br>\nfunction f on states (like the longest execution starting in the state as I suggested in <br>\nmy previous mail). Then, you get well-foundedness from the rules wf_subset and wf_measure.</p>\n</blockquote>\n<p>Andreas</p>\n<blockquote>\n<p>On 16 Jun 2014, at 13:57, Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi John,<br>\n</p>\n</blockquote>\n<p>On 16/06/14 14:00, John Wickerson wrote:</p>\n<blockquote>\n<blockquote>\n<p>I have a relation \"↝\" representing the reductions of a small-step operational semantics. By construction, every configuration can only reduce to finitely-many next configurations.</p>\n<p>Given an initial configuration C, I would like to prove that if every execution starting from C gets stuck after a finite number of steps, then there are only finitely-many executions of C0.</p>\n<p>I'm having quite a bit of difficulty getting my head round how to prove this. I can do it if I assume that the entire \"↝\" relation is well-founded, but that's too strong an assumption,<br>\nYour assumption is that all executions starting in C eventually get stuck. You can prove that this is equivalent to the well-foundedness of ↝ restricted to the states reachable from C. Then, you can use well-founded induction to show finiteness, probably similar to what you already have.</p>\n</blockquote>\n<p>To show well-foundedness, you can take the length of the longest execution starting in a state as measure function.</p>\n<p>Hope this helps,<br>\nAndreas</p>\n<p>since I need it to be possible for <em>some</em> executions to diverge, just not those that start from C.</p>\n<blockquote>\n<p>I have a sense that my lemma, if it is indeed true, will have been proven before, perhaps in the context of graph theory, or computability theory.</p>\n<p>I'd really appreciate any hints the Isabelle community might have for how I might prove this, or where/whether it has already been proven.</p>\n<p>Thanks!<br>\nJohn</p>\n<p>ps. In case more precision is appropriate...</p>\n<p>I'm defining executions like this:</p>\n<blockquote>\n<p>definition executions :: \"config ⇒ (nat ⇒ config option) set\"<br>\nwhere<br>\n  \"executions C ≡ {π.  π 0 = Some C ∧ (∀i.<br>\n  case π i of None ⇒ π (i+1) = None | Some C ⇒<br>\n  if reduce C=[] then π (i+1) = None<br>\n                 else π (i+1) ∈ Some ` set (reduce C))}\"</p>\n</blockquote>\n<p>and my lemma is:</p>\n<blockquote>\n<p>lemma<br>\n  assumes \"∀π ∈ executions C. ∃i &gt; 0. finite_seq i π\"<br>\n  shows \"finite (executions C)\"</p>\n</blockquote>\n<p>and I define finite_seq like so:</p>\n<blockquote>\n<p>fun finite_seq where<br>\n  \"finite_seq 0 π = (∀i. π i = None)\"<br>\n| \"finite_seq (Suc i) π = (π 0 ≠ None ∧ finite_seq i (λi. π (Suc i)))\"<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294281429,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920483
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nHa, it works! Thanks so much Andreas. I knew I had to generalise the induction hypothesis somehow, but just hadn't massaged the statement into <em>quite</em> the right form.</p>\n<p>John</p>",
        "id": 294281462,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920495
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi John,</p>\n<p>I had the same concern, but I think that you could avoid the circularity by defining the <br>\nlongest execution recursively. However, I meanwhile realised that you can show <br>\nwell-foundedness more easily with the lemma finite_acyclic_wf (without going over the <br>\nlongest execution). Acyclicity of the reachable graph should be easy to show because <br>\notherwise, you have a loop and you could construct an infinite execution by looping. For <br>\nfiniteness, you will need something like a Koenig's lemma to go from traces to states (If <br>\nevery node in a connected graph has finitely many successors and there are infinitely many <br>\nnodes, then there is an infinite path). You can find an example of such a lemma (for an <br>\nundirected graph) in my AFP entry Coinductive (theory Koenigslemma).</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294281547,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920532
    }
]