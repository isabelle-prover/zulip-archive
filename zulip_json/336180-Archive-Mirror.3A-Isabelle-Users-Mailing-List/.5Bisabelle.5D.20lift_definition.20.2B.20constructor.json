[
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nIn Isabelle2013-1 in HOL/Library/Polynomial there is</p>\n<p>lift_definition pCons :: \"'a::zero =&gt; 'a poly =&gt; 'a poly\"<br>\nis \"λa p. nat_case a (coeff p)\"<br>\nusing coeff_almost_everywhere_zero by (rule<br>\nalmost_everywhere_zero_nat_case)</p>\n<p>Is there a way to have a constructor \"pCons\" instead of function <br>\n\"pCons\"? I.e. a constructor like</p>\n<p>datatype 'a pcons = Zero | pCons 'a \"'a pcons\"</p>\n<p>could be somehow associated with lift_definition ? Or is this possible <br>\nwith datatype_new ?</p>\n<p>Walther</p>\n<p>PS: For those who find the question strange: If there is a \"yes\" then we <br>\ncould have a mCons for distributive representation of polynomials.</p>",
        "id": 294255625,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912495
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman.brian.c@gmail.com\">huffman.brian.c@gmail.com</a>&gt;<br>\nOn Tue, Nov 19, 2013 at 9:57 AM, Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt; wrote:</p>\n<blockquote>\n<p>In Isabelle2013-1 in HOL/Library/Polynomial there is</p>\n<p>lift_definition pCons :: \"'a::zero =&gt; 'a poly =&gt; 'a poly\"<br>\nis \"λa p. nat_case a (coeff p)\"<br>\n...<br>\nIs there a way to have a constructor \"pCons\" instead of function \"pCons\"?<br>\nI.e. a constructor like</p>\n<p>datatype 'a pcons = Zero | pCons 'a \"'a pcons\"</p>\n<p>could be somehow associated with lift_definition ? Or is this possible with<br>\ndatatype_new ?</p>\n</blockquote>\n<p>What exactly do you mean by \"constructor\"? HOL doesn't have any<br>\nbuilt-in logical distinction between constructors and other functions.</p>\n<p>The datatype package maintains its own internal database of<br>\n\"constructor\" functions, which is used for various kinds of proof<br>\nautomation. Independently defined constructors can be registered after<br>\nthe fact with \"rep_datatype\". However, Zero and pCons do not meet the<br>\ndatatype package's requirement for distinctness, as pCons 0 Zero =<br>\nZero.</p>\n<p>Perhaps you hope to gain access to some form of automation for pCons<br>\nthat would normally be provided by the datatype package? (E.g.<br>\ncases/induct proofs, case expressions, code generation, function<br>\ndefinitions by pattern matching, etc.) If so, then it is likely that<br>\nthere is another way to get what you want with a little more work.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294255654,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912508
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nBrian,</p>\n<p>thanks for your hints !<br>\nIn the course of general considerations [1] we come back to this <br>\nspecific question:</p>\n<p>On 11/19/2013 08:24 PM, Brian Huffman wrote:</p>\n<blockquote>\n<p>On Tue, Nov 19, 2013 at 9:57 AM, Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt; wrote:</p>\n<blockquote>\n<p>In Isabelle2013-1 in HOL/Library/Polynomial there is</p>\n<p>lift_definition pCons :: \"'a::zero =&gt; 'a poly =&gt; 'a poly\"<br>\nis \"λa p. nat_case a (coeff p)\"</p>\n</blockquote>\n</blockquote>\n<p>Other kinds of representations, for instance sparse distributive <br>\npolynomial representation like [2], could be lifted as well <br>\n(establishing respective morphisms) by something like</p>\n<p>lift_definition dCons :: \"...\"<br>\n    is \"...\"</p>\n<p>and then there is the question, how to distinguish between \"pCons\" and <br>\n\"dCons\": pattern matching, for instance by ...</p>\n<p>case p of<br>\n      pCons _ =&gt; ...<br>\n    | dCons _ =&gt; ...</p>\n<p>... on constructors \"pCons\" and \"dCons\" was an idea ...</p>\n<blockquote>\n<blockquote>\n<p>Is there a way to have a constructor \"pCons\" instead of function \"pCons\"?<br>\nI.e. a constructor like</p>\n<p>datatype 'a pcons = Zero | pCons 'a \"'a pcons\"</p>\n<p>could be somehow associated with lift_definition ? Or is this possible with<br>\ndatatype_new ?<br>\nWhat exactly do you mean by \"constructor\"? HOL doesn't have any<br>\nbuilt-in logical distinction between constructors and other functions.</p>\n</blockquote>\n</blockquote>\n<p>The signatures of pCons, dCons, etc are under question, also the <br>\nlocation with respect to the lift_definition --- do you find anything <br>\nrealisable about this idea ?</p>\n<p>Walther</p>\n<p>[1] <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00262.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00262.html</a><br>\n[2] <a href=\"http://afp.sourceforge.net/entries/Polynomials.shtml\">http://afp.sourceforge.net/entries/Polynomials.shtml</a></p>",
        "id": 294259914,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913998
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nWalther,</p>\n<p>Let me comment a bit, even though I am not an expert on polynomials in Isabelle. The <br>\ndefinition in HOL/Library/Polynomials gives you a logically unique representation for <br>\npolynomials, i.e., if two polynomials evaluate to the same at all points, then they are <br>\nequal (in the sense of op =). Your construction with the datatype does not give you this <br>\nidentity, i.e., you get a different type with different properties. Of course, you can do <br>\nso on your own, but in my experience redundancy in a type usually makes proving harder. <br>\nAlthough you can interpret a polynomial in one representation or in the other, the logic <br>\ndoes not distinguish them and neither can you in your proofs.</p>\n<p>However, if you need pattern-matching only for code generation (e.g., to pick an efficient <br>\nimplementation), then that's still possible (to some extent) even if polynomials are not <br>\ndefined as a datatype. You haven't mentioned code generation, but if you are interested, <br>\nI'd be happy to explain the details.</p>\n<p>Andreas</p>",
        "id": 294260393,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914158
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nAndreas,</p>\n<p>thanks for your kind offer ...</p>\n<blockquote>\n<p>[...] You haven't mentioned code generation, but if you are <br>\ninterested, I'd be happy to explain the details.</p>\n</blockquote>\n<p>... because code generation is in our focus: we want to generate <br>\nalgorithms from theories in algebraic geometry, while different <br>\nalgorithms require different representations of polynomials for <br>\nefficiency reasons. So we are happy to hear ...</p>\n<blockquote>\n<p>if you need pattern-matching only for code generation (e.g., to pick <br>\nan efficient implementation), then that's still possible (to some <br>\nextent) even if polynomials are not defined as a datatype.</p>\n</blockquote>\n<p>... and in your paper [1] to find a quick guide to the following code <br>\nsnippets derived from [3]:</p>\n<p>datatype ('a, 'b) phantom = phantom 'b</p>\n<p>datatype poly_impl = Poly_IMPL<br>\n   definition poly_Recursive :: poly_impl where \"poly_Recursive = Poly_IMPL\"<br>\n   definition poly_Distrib_Sparse :: poly_impl where <br>\n\"poly_Distrib_Sparse = Poly_IMPL\"<br>\n   definition poly_Distrib_Sense :: poly_impl where \"poly_Distrib_Sense <br>\n= Poly_IMPL\"</p>\n<p>class poly_impl =<br>\n     fixes poly_impl :: \"('a, poly_impl) phantom\"</p>\n<p>code_datatype poly_Recursive poly_Distrib_Sparse poly_Distrib_Sense</p>\n<p>From now on we probably have to go another way: we need to choose <br>\ndifferent representations not specific with respect to types, but <br>\nspecific with respect to algorithms.</p>\n<p>We are looking forward with great interest, how we can ...</p>\n<ul>\n<li>\n<p>flexibly switch between representations of polynomials (probably even <br>\nwithin one single, but complex algorithm)</p>\n</li>\n<li>\n<p>derive properties for algorithms uniformly from a \"logically unique <br>\nrepresentation for polynomials\" like [2]</p>\n</li>\n</ul>\n<p>... and are going to study your approach in detail. Any hints are <br>\nappreciated.</p>\n<p>Walther</p>\n<p>[1] <br>\n<a href=\"http://www.infsec.ethz.ch/research/publications/pub2013/lochbihler13itp.pdf\">http://www.infsec.ethz.ch/research/publications/pub2013/lochbihler13itp.pdf</a><br>\n[2] <a href=\"http://isabelle.in.tum.de/dist/library/HOL/HOL-Library/Polynomial.html\">http://isabelle.in.tum.de/dist/library/HOL/HOL-Library/Polynomial.html</a><br>\n[3] <a href=\"http://afp.sourceforge.net/entries/Collections.shtml\">http://afp.sourceforge.net/entries/Collections.shtml</a></p>\n<p>On 12/16/2013 08:46 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Walther,</p>\n<p>Let me comment a bit, even though I am not an expert on polynomials in <br>\nIsabelle. The definition in HOL/Library/Polynomials gives you a <br>\nlogically unique representation for polynomials, i.e., if two <br>\npolynomials evaluate to the same at all points, then they are equal <br>\n(in the sense of op =). Your construction with the datatype does not <br>\ngive you this identity, i.e., you get a different type with different <br>\nproperties. Of course, you can do so on your own, but in my experience <br>\nredundancy in a type usually makes proving harder. Although you can <br>\ninterpret a polynomial in one representation or in the other, the <br>\nlogic does not distinguish them and neither can you in your proofs.</p>\n<p>However, if you need pattern-matching only for code generation (e.g., <br>\nto pick an efficient implementation), then that's still possible (to <br>\nsome extent) even if polynomials are not defined as a datatype.<br>\nAndreas<br>\nOn 13/12/13 15:17, Walther Neuper wrote:</p>\n<blockquote>\n<p>Brian,</p>\n<p>thanks for your hints !<br>\nIn the course of general considerations [1] we come back to this <br>\nspecific question:<br>\n</p>\n</blockquote>\n<p>On 11/19/2013 08:24 PM, Brian Huffman wrote:</p>\n<blockquote>\n<blockquote>\n<p>On Tue, Nov 19, 2013 at 9:57 AM, Walther Neuper <br>\n&lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt; wrote:</p>\n<blockquote>\n<p>In Isabelle2013-1 in HOL/Library/Polynomial there is</p>\n<p>lift_definition pCons :: \"'a::zero =&gt; 'a poly =&gt; 'a poly\"<br>\nis \"λa p. nat_case a (coeff p)\"</p>\n</blockquote>\n</blockquote>\n<p>Other kinds of representations, for instance sparse distributive <br>\npolynomial representation<br>\nlike [2], could be lifted as well (establishing respective morphisms) <br>\nby something like</p>\n<p>lift_definition dCons :: \"...\"<br>\n    is \"...\"</p>\n<p>and then there is the question, how to distinguish between \"pCons\" <br>\nand \"dCons\": pattern<br>\nmatching, for instance by ...</p>\n<p>case p of<br>\n      pCons _ =&gt; ...<br>\n    | dCons _ =&gt; ...</p>\n<p>... on constructors \"pCons\" and \"dCons\" was an idea ...</p>\n<blockquote>\n<blockquote>\n<p>Is there a way to have a constructor \"pCons\" instead of function <br>\n\"pCons\"?<br>\nI.e. a constructor like</p>\n<p>datatype 'a pcons = Zero | pCons 'a \"'a pcons\"</p>\n<p>could be somehow associated with lift_definition ? Or is this <br>\npossible with<br>\ndatatype_new ?<br>\nWhat exactly do you mean by \"constructor\"? HOL doesn't have any<br>\nbuilt-in logical distinction between constructors and other functions.</p>\n</blockquote>\n</blockquote>\n<p>The signatures of pCons, dCons, etc are under question, also the <br>\nlocation with respect to<br>\nthe lift_definition --- do you find anything realisable about this <br>\nidea ?</p>\n<p>Walther</p>\n<p>[1] <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00262.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-November/msg00262.html</a><br>\n[2] <a href=\"http://afp.sourceforge.net/entries/Polynomials.shtml\">http://afp.sourceforge.net/entries/Polynomials.shtml</a></p>\n</blockquote>\n</blockquote>",
        "id": 294260527,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660914206
    }
]