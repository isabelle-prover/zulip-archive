[
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHello list,</p>\n<p>I would like to prepare code exportation within a locale, in such a way that I only have to instantiate the locale to generate code later. However, my functions do not unconditionally terminate and I need an invariant (called inv in the following email) to prove termination and correctness. Therefore, I wanted to define a typedef within the locale. </p>\n<p>But as there cannot be a typedef inside a locale, I axiomatised it (via the theorem that typedef generates) with the idea that I could instantiate it later, while still using the theorems and lift definitions:</p>\n<p>locale type_definition_locale =<br>\n  fixes Abs :: \"'a ⇒ 'inv\" and Rep :: \"'inv ⇒ 'a\" and inv :: \"'a ⇒ bool\"<br>\n  assumes<br>\n    Rep_inverse: \"Abs (Rep x) = x\" and<br>\n    Rep: \"Rep x ∈ {a. inv a}\" and<br>\n    Rep_inject: \"Rep x = Rep y ⟷ x = y\" and<br>\n    Abs_inverse: \"z ∈ {a. inv a} ⟹ Rep (Abs z) = z\" and<br>\n    Abs_induct: \"(⋀y. y ∈ {a. inv a} ⟹ P (Abs y)) ⟹ P y\" and<br>\n    Rep_induct: \"z ∈ {a. inv a} ⟹ (⋀z. P' (Rep z)) ⟹ P' z\" and<br>\n    Abs_cases: \"(⋀y. x = Abs y ⟹ y ∈ {a. inv a} ⟹ Q) ⟹ Q\" and<br>\n    Rep_cases: \"z ∈ {a. inv a} ⟹ (⋀y. z = Rep y ⟹ Q) ⟹ Q\" and<br>\n    Abs_inject: \"z ∈ {a. inv a} ⟹ z' ∈ {a. inv a} ⟹ Abs z = Abs z' ⟷ z = z'\"</p>\n<p>Now my question is the following: is there a way to use lift_definition within the previous locale? For now, an error is produced:</p>\n<p>context type_definition_locale<br>\nbegin</p>\n<p>definition raw_K :: \"'a ⇒ 'a ⇒ 'a\" where<br>\n\"raw_K a _ = a\"</p>\n<p>lift_definition refined_K :: \"'inv ⇒ 'inv ⇒ 'inv\" is raw_K</p>\n<p>(* Fails with:<br>\n       Lifting failed for the following term:<br>\n       Term:  raw_K<br>\n       Type:  'a ⇒ 'a ⇒ 'a</p>\n<p>Reason:<br>\n         The type of the term cannot be instantiated to<br>\n         \"'inv ⇒ 'inv ⇒ ‘inv”.<br>\n  *)<br>\nend</p>\n<p>I tried using setup_lifting, but this does not work either. The error message was not very precise (\"The abstract type must be a type constructor.”), but I think that the error comes from:</p>\n<p>fun is_Type (Type _) = true<br>\n  | is_Type _ = false</p>\n<p>Types passed as parameters in locales use the constructor TFree instead of Type.</p>\n<p>Is there a way to avoid doing the lifting by hand? Would it be safe to extend the function is_Type to accept TFree?</p>\n<p>Thanks in advance,<br>\nMathias</p>",
        "id": 294677271,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175383
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Mathias,</p>\n<p>The Lifting package manages the registered quotients in a map with the name of the type <br>\nconstructor as a key. So even if you could trick setup_lifting into accepting a theorem of <br>\nthe form</p>\n<p>type_definition Rep Abs {x. inv x}</p>\n<p>the lift_definition command would not be able to find the setup, because it constructs the <br>\nlifting relation based on the type constructors that appear in the types of the raw term <br>\nand the lifted constant. One would have to extend the implementation of <br>\nLifting_Term.prove_schematic_quot_thm accordingly to also support TFree.</p>\n<p>Moreover, you'd have to make sure that the quotient theorem setup does not leak into any <br>\ninterpretation, in which the type variables get instantiated or generalised. Otherwise, <br>\nthe internal data structures of the Lifting package would be messed up.</p>\n<p>Finally, I am not sure that your approach will actually work for code generation. The <br>\nsteps of lift_definition for a subtype copy are fairly limited except when it comes to <br>\ncode generation for compound return types. For example, if your function returns something <br>\nlike 'inv list (rather than a plain 'inv), then lift_definition internally generates a <br>\nnumber of types and auxiliary constants and lifts the invariant to those types such that <br>\nthe code generator can handle them. I cannot see how this construction would work for an <br>\nunspecified 'inv (otherwise, we could have done the construction once and for all for such <br>\nan arbitrary 'inv and then just reused everything).</p>\n<p>Andreas</p>",
        "id": 294677307,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175395
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Mathias,</p>\n<p>quoting NEWS for Isabelle2099-2:<br>\n<a href=\"/user_uploads/14278/cuxmbmLnKi0N2qtD4T_9buiu/signature.asc\">signature.asc</a></p>",
        "id": 294677327,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175405
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nHi Mathias,</p>\n<p>independently of lift_definition and code generation: a side remark on your locale.</p>\n<p>A type definition locale already exists. It is called type_definition (the term type_definition is actually a locale predicate; the locale is used by typedef). It assumes only three facts (Rep, Rep_inverse, and Abs_inverse) and derives the rest. </p>\n<p>There is no need to duplicate those things.</p>\n<p>Dmitriy</p>",
        "id": 294677341,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175413
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nDear Andreas and Florian,</p>\n<p>Thanks for your comments.</p>\n<blockquote>\n<p>I do not know whether your typedef specification satisfy the<br>\nprecondition that no dependencies on parameters or assumptions are<br>\nintroduced, but you may want to try this and see how far you can get.</p>\n</blockquote>\n<p>I am not in that case: I wanted to abstract the concrete representation of two watched literals scheme (allowing to instantiate the locale with arrays or red-black trees).</p>\n<blockquote>\n<p>Finally, I am not sure that your approach will actually work for code generation. The steps of lift_definition for a subtype copy are fairly limited except when it comes to code generation for compound return types. </p>\n</blockquote>\n<p>I am mostly interested in the steps of lift_definition for a subtype. I wanted to avoid writing the theorems by hand each time, but it does not matter so much. That seems also easier than changing the Lifting package.</p>\n<p>Thanks for your help,<br>\nMathias</p>\n<blockquote>\n<p>On 16 Jun 2016, at 08:51, Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<p>Dear Mathias,</p>\n<p>The Lifting package manages the registered quotients in a map with the name of the type constructor as a key. So even if you could trick setup_lifting into accepting a theorem of the form</p>\n<p>type_definition Rep Abs {x. inv x}</p>\n<p>the lift_definition command would not be able to find the setup, because it constructs the lifting relation based on the type constructors that appear in the types of the raw term and the lifted constant. One would have to extend the implementation of Lifting_Term.prove_schematic_quot_thm accordingly to also support TFree.</p>\n<p>Moreover, you'd have to make sure that the quotient theorem setup does not leak into any interpretation, in which the type variables get instantiated or generalised. Otherwise, the internal data structures of the Lifting package would be messed up.</p>\n<p>Finally, I am not sure that your approach will actually work for code generation. The steps of lift_definition for a subtype copy are fairly limited except when it comes to code generation for compound return types. For example, if your function returns something like 'inv list (rather than a plain 'inv), then lift_definition internally generates a number of types and auxiliary constants and lifts the invariant to those types such that the code generator can handle them. I cannot see how this construction would work for an unspecified 'inv (otherwise, we could have done the construction once and for all for such an arbitrary 'inv and then just reused everything).</p>\n<p>Andreas</p>\n<p>On 15/06/16 20:44, Mathias Fleury wrote:</p>\n<blockquote>\n<p>Hello list,</p>\n<p>I would like to prepare code exportation within a locale, in such a way that I only have to instantiate the locale to generate code later. However, my functions do not unconditionally terminate and I need an invariant (called inv in the following email) to prove termination and correctness. Therefore, I wanted to define a typedef within the locale.</p>\n<p>But as there cannot be a typedef inside a locale, I axiomatised it (via the theorem that typedef generates) with the idea that I could instantiate it later, while still using the theorems and lift definitions:</p>\n<p>locale type_definition_locale =<br>\n  fixes Abs :: \"'a ⇒ 'inv\" and Rep :: \"'inv ⇒ 'a\" and inv :: \"'a ⇒ bool\"<br>\n  assumes<br>\n    Rep_inverse: \"Abs (Rep x) = x\" and<br>\n    Rep: \"Rep x ∈ {a. inv a}\" and<br>\n    Rep_inject: \"Rep x = Rep y ⟷ x = y\" and<br>\n    Abs_inverse: \"z ∈ {a. inv a} ⟹ Rep (Abs z) = z\" and<br>\n    Abs_induct: \"(⋀y. y ∈ {a. inv a} ⟹ P (Abs y)) ⟹ P y\" and<br>\n    Rep_induct: \"z ∈ {a. inv a} ⟹ (⋀z. P' (Rep z)) ⟹ P' z\" and<br>\n    Abs_cases: \"(⋀y. x = Abs y ⟹ y ∈ {a. inv a} ⟹ Q) ⟹ Q\" and<br>\n    Rep_cases: \"z ∈ {a. inv a} ⟹ (⋀y. z = Rep y ⟹ Q) ⟹ Q\" and<br>\n    Abs_inject: \"z ∈ {a. inv a} ⟹ z' ∈ {a. inv a} ⟹ Abs z = Abs z' ⟷ z = z'\"</p>\n<p>Now my question is the following: is there a way to use lift_definition within the previous locale? For now, an error is produced:</p>\n<p>context type_definition_locale<br>\nbegin</p>\n<p>definition raw_K :: \"'a ⇒ 'a ⇒ 'a\" where<br>\n\"raw_K a _ = a\"</p>\n<p>lift_definition refined_K :: \"'inv ⇒ 'inv ⇒ 'inv\" is raw_K</p>\n<p>(* Fails with:<br>\n       Lifting failed for the following term:<br>\n       Term:  raw_K<br>\n       Type:  'a ⇒ 'a ⇒ 'a</p>\n<p>Reason:<br>\n         The type of the term cannot be instantiated to<br>\n         \"'inv ⇒ 'inv ⇒ ‘inv”.<br>\n  *)<br>\nend</p>\n<p>I tried using setup_lifting, but this does not work either. The error message was not very precise (\"The abstract type must be a type constructor.”), but I think that the error comes from:</p>\n<p>fun is_Type (Type _) = true<br>\n  | is_Type _ = false</p>\n<p>Types passed as parameters in locales use the constructor TFree instead of Type.</p>\n<p>Is there a way to avoid doing the lifting by hand? Would it be safe to extend the function is_Type to accept TFree?</p>\n<p>Thanks in advance,<br>\nMathias<br>\n</p>\n</blockquote>\n</blockquote>",
        "id": 294677489,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661175463
    }
]