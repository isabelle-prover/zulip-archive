[
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi list,</p>\n<p>while investigating why the proof reconstruction (smt) of some veriT proof failed, I found that the tactic linarith fails on the following example:</p>\n<p>lemma ‹¬ (p_241 :: int) &lt; 1 + (p_244 * p_244 + 2 * p_244) ⟹<br>\np_241 &lt; p_253 * p_253 ⟹<br>\n(1 + p_244) * (1 + p_244) = 1 + p_244 + p_244 * (1 + p_244) ⟹<br>\n (1 + p_244) * p_244 = p_244 + p_244 * p_244 ⟹<br>\n p_244 * (1 + p_244) = (1 + p_244) * p_244 ⟹<br>\n p_253 * p_253 = (1 + p_244) * (1 + p_244) ⟹ False <br>\n›<br>\n  apply linarith</p>\n<p>It fails with the following error message:<br>\n  exception Fail raised (line 416 of \"~~/src/Provers/Arith/fast_lin_arith.ML\"): Linear arithmetic: failed to add thms<br>\n(the same exception is raised in the repository version).</p>\n<p>I am aware that the goal can be solved by presburger but I would prefer to understand why it fails and whether I can do anything during proof reconstruction to avoid the problem. Does anyone know why linarith fails on this example?</p>\n<p>Cheers,<br>\nMathias</p>",
        "id": 294749090,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194704
    },
    {
        "content": "<p>From: Sascha Böhme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt;<br>\nHi Mathias,</p>\n<p>linarith is some intricate proof method. You can gain some insight by using the option [[linarith_trace]]. In your particular case, it seems that linarith’s internal application of the simplifier is too ambitious and simplifies an equation to True. A subsequent step that tries to conclude a+c=b+d from the equations a=b and c=d fails when given True as one of the two equations. One can certainly transform any True into, for instance, the equation 0=0, but I suspect that this might not be as as easy as it seems.</p>\n<p>A simpler solution is to transform your problem by applying the law of distributivity:</p>\n<p>lemma ‹¬ (p_241 :: int) &lt; 1 + (p_244 * p_244 + 2 * p_244) ⟹<br>\np_241 &lt; p_253 * p_253 ⟹<br>\n(1 + p_244) * (1 + p_244) = 1 + p_244 + p_244 * (1 + p_244) ⟹<br>\n (1 + p_244) * p_244 = p_244 + p_244 * p_244 ⟹<br>\n p_244 * (1 + p_244) = (1 + p_244) * p_244 ⟹<br>\n p_253 * p_253 = (1 + p_244) * (1 + p_244) ⟹ False <br>\n›<br>\n  by (unfold int_distrib) linarith</p>\n<p>I’m unsure if that helps in your particular case.</p>\n<p>Regards,<br>\nSascha</p>",
        "id": 294749256,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194790
    },
    {
        "content": "<p>From: Sascha Böhme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt;<br>\nHi Dominique,</p>\n<p>linarith is an intricate proof method. You can gain some insight by using the option [[linarith_trace]]. In your case, the simplifier that is applied internally in linarith is too ambitious and reduces an equation to True. Then, a subsequent step that tries to produce a+c=b+d from the two equations a=b and c=d fails when given True as one the equations. One can certainly transform every True into, for instance, the equation 0=0, but I suspect that this would not be as easy as it seems.</p>\n<p>There is fortunately some way to circumvent these intricacies. You can preprocess the lemma by applying the law of distributivity. This results in a goal that is „more“ like a linear problem. Then linarith succeeds.</p>\n<p>lemma ‹¬ (p_241 :: int) &lt; 1 + (p_244 * p_244 + 2 * p_244) ⟹<br>\np_241 &lt; p_253 * p_253 ⟹<br>\n(1 + p_244) * (1 + p_244) = 1 + p_244 + p_244 * (1 + p_244) ⟹<br>\n (1 + p_244) * p_244 = p_244 + p_244 * p_244 ⟹<br>\n p_244 * (1 + p_244) = (1 + p_244) * p_244 ⟹<br>\n p_253 * p_253 = (1 + p_244) * (1 + p_244) ⟹ False <br>\n›<br>\n  by (unfold int_distrib) linarith</p>\n<p>I’m unsure if that helps in your particular case.</p>\n<p>Regards,<br>\nSascha</p>",
        "id": 294749269,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194796
    },
    {
        "content": "<p>From: Mathias Fleury &lt;<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nHi Sacha,</p>\n<blockquote>\n<p>On 28. Jan 2019, at 21:58, Sascha Böhme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt; wrote:</p>\n<p>Hi Dominique,</p>\n<p>linarith is an intricate proof method. You can gain some insight by using the option [[linarith_trace]]. In your case, the simplifier that is applied internally in linarith is too ambitious and reduces an equation to True. Then, a subsequent step that tries to produce a+c=b+d from the two equations a=b and c=d fails when given True as one the equations.</p>\n</blockquote>\n<p>Thanks for the analysis.</p>\n<blockquote>\n<p>One can certainly transform every True into, for instance, the equation 0=0, but I suspect that this would not be as easy as it seems.</p>\n<p>There is fortunately some way to circumvent these intricacies. You can preprocess the lemma by applying the law of distributivity. This results in a goal that is „more“ like a linear problem. Then linarith succeeds.</p>\n<p>lemma ‹¬ (p_241 :: int) &lt; 1 + (p_244 * p_244 + 2 * p_244) ⟹<br>\np_241 &lt; p_253 * p_253 ⟹<br>\n(1 + p_244) * (1 + p_244) = 1 + p_244 + p_244 * (1 + p_244) ⟹<br>\n(1 + p_244) * p_244 = p_244 + p_244 * p_244 ⟹<br>\np_244 * (1 + p_244) = (1 + p_244) * p_244 ⟹<br>\np_253 * p_253 = (1 + p_244) * (1 + p_244) ⟹ False <br>\n›<br>\n  by (unfold int_distrib) linarith</p>\n<p>I’m unsure if that helps in your particular case.</p>\n</blockquote>\n<p>Well, I can preprocess the goal before calling Z3_Replay_Methods.arith_th_lemma (<a href=\"https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88\">https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88</a> &lt;<a href=\"https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88\">https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88</a>&gt;). </p>\n<p>Given that I was reconstructing veriT proofs, do you think that this kind of preprocessing also makes sense to replay arithmetic steps Z3 proof?</p>\n<p>Thanks,<br>\nMathias</p>\n<blockquote>\n<p>Regards,<br>\nSascha</p>\n<p>Von: Mathias Fleury &lt;mailto:<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nGesendet: Donnerstag, 24. Januar 2019 10:23<br>\nAn: Isabelle User &lt;mailto:<a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a>&gt;<br>\nBetreff: [isabelle] linarith error</p>\n<p>Hi list,</p>\n<p>while investigating why the proof reconstruction (smt) of some veriT proof failed, I found that the tactic linarith fails on the following example:</p>\n<p>lemma ‹¬ (p_241 :: int) &lt; 1 + (p_244 * p_244 + 2 * p_244) ⟹<br>\np_241 &lt; p_253 * p_253 ⟹<br>\n(1 + p_244) * (1 + p_244) = 1 + p_244 + p_244 * (1 + p_244) ⟹<br>\n(1 + p_244) * p_244 = p_244 + p_244 * p_244 ⟹<br>\np_244 * (1 + p_244) = (1 + p_244) * p_244 ⟹<br>\np_253 * p_253 = (1 + p_244) * (1 + p_244) ⟹ False <br>\n›<br>\n  apply linarith</p>\n<p>It fails with the following error message:<br>\n  exception Fail raised (line 416 of \"~~/src/Provers/Arith/fast_lin_arith.ML\"): Linear arithmetic: failed to add thms<br>\n(the same exception is raised in the repository version).</p>\n<p>I am aware that the goal can be solved by presburger but I would prefer to understand why it fails and whether I can do anything during proof reconstruction to avoid the problem. Does anyone know why linarith fails on this example?</p>\n<p>Cheers,<br>\nMathias</p>\n</blockquote>",
        "id": 294749320,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194806
    },
    {
        "content": "<p>From: Sascha Böhme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt;<br>\nHi Mathias,</p>\n<p>Your suggestion might be beneficial, but I'm not aware of any concrete Z3 example in which this preprocessing would help. Just go ahead and try if nothing breaks. I’ve seen that some definition unfolding is already applied in the Z3 replay code. Maybe you can just add the distributivity rules there?</p>\n<p>Regards,<br>\nSascha</p>\n<p>Von: Mathias Fleury<br>\nGesendet: Montag, 28. Januar 2019 22:17<br>\nAn: Sascha Böhme<br>\nCc: Isabelle User<br>\nBetreff: Re: [isabelle] linarith error</p>\n<p>Hi Sacha,</p>\n<blockquote>\n<p>On 28. Jan 2019, at 21:58, Sascha Böhme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt; wrote:</p>\n<p>Hi Dominique,</p>\n<p>linarith is an intricate proof method. You can gain some insight by using the option [[linarith_trace]]. In your case, the simplifier that is applied internally in linarith is too ambitious and reduces an equation to True. Then, a subsequent step that tries to produce a+c=b+d from the two equations a=b and c=d fails when given True as one the equations.</p>\n</blockquote>\n<p>Thanks for the analysis.</p>\n<blockquote>\n<p>One can certainly transform every True into, for instance, the equation 0=0, but I suspect that this would not be as easy as it seems.</p>\n<p>There is fortunately some way to circumvent these intricacies. You can preprocess the lemma by applying the law of distributivity. This results in a goal that is „more“ like a linear problem. Then linarith succeeds.</p>\n<p>lemma ‹¬ (p_241 :: int) &lt; 1 + (p_244 * p_244 + 2 * p_244) ⟹<br>\np_241 &lt; p_253 * p_253 ⟹<br>\n(1 + p_244) * (1 + p_244) = 1 + p_244 + p_244 * (1 + p_244) ⟹<br>\n(1 + p_244) * p_244 = p_244 + p_244 * p_244 ⟹<br>\np_244 * (1 + p_244) = (1 + p_244) * p_244 ⟹<br>\np_253 * p_253 = (1 + p_244) * (1 + p_244) ⟹ False <br>\n›<br>\n  by (unfold int_distrib) linarith</p>\n<p>I’m unsure if that helps in your particular case.</p>\n</blockquote>\n<p>Well, I can preprocess the goal before calling Z3_Replay_Methods.arith_th_lemma (<a href=\"https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88\">https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88</a> &lt;<a href=\"https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88\">https://isabelle.in.tum.de/repos/isabelle/file/2755c387f1e6/src/HOL/Tools/SMT/z3_replay_methods.ML#l88</a>&gt;). </p>\n<p>Given that I was reconstructing veriT proofs, do you think that this kind of preprocessing also makes sense to replay arithmetic steps Z3 proof?</p>\n<p>Thanks,<br>\nMathias</p>\n<blockquote>\n<p>Regards,<br>\nSascha</p>\n<p>Von: Mathias Fleury &lt;mailto:<a href=\"mailto:mathias.fleury12@gmail.com\">mathias.fleury12@gmail.com</a>&gt;<br>\nGesendet: Donnerstag, 24. Januar 2019 10:23<br>\nAn: Isabelle User &lt;mailto:<a href=\"mailto:isabelle-users@cl.cam.ac.uk\">isabelle-users@cl.cam.ac.uk</a>&gt;<br>\nBetreff: [isabelle] linarith error</p>\n<p>Hi list,</p>\n<p>while investigating why the proof reconstruction (smt) of some veriT proof failed, I found that the tactic linarith fails on the following example:</p>\n<p>lemma ‹¬ (p_241 :: int) &lt; 1 + (p_244 * p_244 + 2 * p_244) ⟹<br>\np_241 &lt; p_253 * p_253 ⟹<br>\n(1 + p_244) * (1 + p_244) = 1 + p_244 + p_244 * (1 + p_244) ⟹<br>\n(1 + p_244) * p_244 = p_244 + p_244 * p_244 ⟹<br>\np_244 * (1 + p_244) = (1 + p_244) * p_244 ⟹<br>\np_253 * p_253 = (1 + p_244) * (1 + p_244) ⟹ False <br>\n›<br>\n  apply linarith</p>\n<p>It fails with the following error message:<br>\n  exception Fail raised (line 416 of \"~~/src/Provers/Arith/fast_lin_arith.ML\"): Linear arithmetic: failed to add thms<br>\n(the same exception is raised in the repository version).</p>\n<p>I am aware that the goal can be solved by presburger but I would prefer to understand why it fails and whether I can do anything during proof reconstruction to avoid the problem. Does anyone know why linarith fails on this example?</p>\n<p>Cheers,<br>\nMathias</p>\n</blockquote>",
        "id": 294749443,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661194857
    }
]