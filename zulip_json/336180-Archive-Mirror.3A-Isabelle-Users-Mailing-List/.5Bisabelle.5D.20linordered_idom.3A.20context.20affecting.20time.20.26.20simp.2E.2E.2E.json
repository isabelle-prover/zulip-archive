[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Gottfried,</p>\n<blockquote>\n<p>1) In the linordered_idom class context, the function foo_f takes 0.7 seconds to<br>\nprocess, where an identical function, foo_f2, in the global context takes<br>\nonly about 0.1 second. Is there any advantage to defining foo_f in the<br>\nlinordered_idom class context, other than it will localize its name?<br>\nAs the definition of foo_f does not depend on any parameter of the linordered_idom type <br>\nclass, I don't see a point in defining foo_f inside the type class context.</p>\n</blockquote>\n<blockquote>\n<p>2) Inside the class context, the simp method will not use foo_f.simps, even<br>\nthough the output message shows that foo_f.simps are available as rewrite<br>\nrules. Inside, linordered_idom_class.foo_f.simps must be added as a simp rule.<br>\nIs there something I can do to get it to use foo_f.simps, without having to<br>\nadd the qualified name linordered_idom_class.foo_f.simps as a simp rule?<br>\nYou are confused by Isabelle's type inference. Inside a type class context, the type <br>\nvariable 'a is fixed, i.e., inside linorderd_idom, foo_f.simps only works for instances of <br>\nfoo_f with type \"'a foo_d\". In your theorem, you try to instantiate 'a to int. This makes <br>\nIsabelle think that you want to refer to the exported version of foo_f, so you have to add <br>\nthe exported foo_f.simps rules as well.</p>\n</blockquote>\n<blockquote>\n<p>3) The value method prints linordered_idom numerals as sums of 1, even though<br>\nI import Code_Target_Numeral.thy. The simp method prints numerals in the nice<br>\nform. Is there something I can do to get the value method to print<br>\nlinordered_idom numerals as single numbers rather than sums of 1?*)</p>\n</blockquote>\n<p>value uses a different set of different equations for normalising terms, namely those <br>\ndeclared as [code], whereas the simp method uses [simp]. You can, of course, try to change <br>\nthe setup of code generator, but that requires considerable effort.</p>\n<p>Andreas</p>",
        "id": 294254202,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911962
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 11/4/2013 4:37 AM, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>You are confused by Isabelle's type inference. Inside a type class <br>\ncontext, the type variable 'a is fixed, i.e., inside linorderd_idom, <br>\nfoo_f.simps only works for instances of foo_f with type \"'a foo_d\". In <br>\nyour theorem, you try to instantiate 'a to int. This makes Isabelle <br>\nthink that you want to refer to the exported version of foo_f, so you <br>\nhave to add the exported foo_f.simps rules as well.</p>\n</blockquote>\n<p>Andreas,</p>\n<p>Thanks for the help. It helps to get help to understand the subtleties. <br>\nWhat I was doing in those other emails helped me here to experiment with <br>\nthe type variables in the class context:</p>\n<p>datatype 'a foo_d = Foo_d 'a</p>\n<p>context linordered_idom<br>\nbegin<br>\nfun foo_f :: \"'b::linordered_idom foo_d =&gt; real\" where<br>\n   \"foo_f (Foo_d x) = real x\"</p>\n<p>theorem \"foo_f (Foo_d (1::int)) = (1::real)\"<br>\nprint_statement foo_f.simps<br>\nprint_statement linordered_idom_class.foo_f.simps<br>\nby(simp)<br>\nend</p>\n<p>As you talk about, the type variable 'a is special in the class context. <br>\nIf I try <code>fun foo_f :: \"'a::linordered_idom foo_d =&gt; real\"</code>, I get the <br>\nerror <code>Sort constraint linordered_idom inconsistent with default type \nfor type variable \"'a\"</code>. Using 'b works, and the two print statements <br>\nshow I get what I want.</p>\n<blockquote>\n<p>value uses a different set of different equations for normalising <br>\nterms, namely those declared as [code], whereas the simp method uses <br>\n[simp]. You can, of course, try to change the setup of code generator, <br>\nbut that requires considerable effort.</p>\n</blockquote>\n<p>The printing of numerals is bigger than me, but getting \"value\" to work <br>\nby using [code] is something I want to start doing.</p>\n<p>Related to those other emails, I've created these commands:</p>\n<p>consts nat_of :: \"'a =&gt; nat\"<br>\nabbreviation (input) nat_of_int :: \"int =&gt; nat\" where \"nat_of_int == nat\"<br>\ndefs (overloaded) nat_of_int_def [simp,code_unfold]: \"nat_of == nat_of_int\"</p>\n<p>These are based on the \"real::'a =&gt; real\" function in Real.thy.</p>\n<p>The problem is that <code>value \"nat_of(1::int)\"</code> gets rewritten as \"Suc 0\", <br>\nbut a slightly more complicated use of \"nat_of\" doesn't get simplified <br>\nwith \"value\".</p>\n<p>I don't know the relationship of \"simp\" to \"code\", but with <br>\n\"declare[[simp_trace]]\", when I use \"value\", the output panel shows the <br>\nrewriting that's being done.</p>\n<p>Below, I give the simple example I just mentioned, along with the output <br>\nof the two \"value\"s, and some of the simp trace. I attach the THY, which <br>\njust duplicates the source I've put in this email.</p>\n<p>Thanks for the help,<br>\nGB</p>\n<p>consts nat_of :: \"'a =&gt; nat\"</p>\n<p>abbreviation (input) nat_of_int :: \"int =&gt; nat\" where<br>\n   \"nat_of_int == nat\"</p>\n<p>defs (overloaded)<br>\n   nat_of_int_def [simp,code_unfold]: \"nat_of == nat_of_int\"</p>\n<p>datatype 'a foo_d2 = Foo_d2 'a</p>\n<p>fun foo_g :: \"'a foo_d2 =&gt; nat\" where<br>\n   \"foo_g (Foo_d2 x) = nat_of(x)\"</p>\n<p>value \"nat_of(1::int)\"<br>\n   (* Output: \"(Suc (0::nat))\" :: \"nat\" *)<br>\n   (* With simp_trace, this is the first rewrite:<br>\n     [1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\n     (term_of_class.term_of (nat_of (1::int)))<br>\n     [1]Applying instance of rewrite rule \"??.unknown\":<br>\n     (nat_of == nat)<br>\n     [1]Rewriting:<br>\n     (nat_of == nat) *)</p>\n<p>value \"foo_g(Foo_d2(1::int))\"<br>\n   (* Output: \"(nat_of (1::int))\" :: \"nat\" *)<br>\n   (* With simp_trace, this is the last rewrite:<br>\n     [1]Rewriting:<br>\n     (Numeral1 == (1::int))<br>\n     \"(nat_of (1::int))\" :: \"nat\" *)<br>\n<a href=\"/user_uploads/14278/Rd7-e9mtvk3GTQO9lwaSROHy/i131031a__q1b_context_slower__needs_qualified_simp__numeral_print.thy\">i131031a__q1b_context_slower__needs_qualified_simp__numeral_print.thy</a></p>",
        "id": 294254381,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912030
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Gottfried,</p>\n<blockquote>\n<p>consts nat_of :: \"'a =&gt; nat\"</p>\n<p>abbreviation (input) nat_of_int :: \"int =&gt; nat\" where<br>\n  \"nat_of_int == nat\"</p>\n<p>defs (overloaded)<br>\n  nat_of_int_def [simp,code_unfold]: \"nat_of == nat_of_int\"</p>\n</blockquote>\n<p>without having had a closer look, I guess your problem is due to that<br>\nad-hoc overloading; the code generator only supports Haskell-style<br>\noverloading with type classes.</p>\n<blockquote>\n<p>value \"foo_g(Foo_d2(1::int))\"</p>\n</blockquote>\n<p>If the output of »value t« surprises you, the first step is something like</p>\n<p>definition<br>\n  \"blubb = t\"</p>\n<p>export_code blubb in SML file …</p>\n<p>and inspecting the resulting code.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/M6Lqe3_C-Pvr4Y0REl1HkOxn/signature.asc\">signature.asc</a></p>",
        "id": 294254732,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912164
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 11/4/2013 2:08 PM, Florian Haftmann wrote:</p>\n<blockquote>\n<p>without having had a closer look, I guess your problem is due to that<br>\nad-hoc overloading; the code generator only supports Haskell-style<br>\noverloading with type classes.</p>\n</blockquote>\n<p>Florian,</p>\n<p>The magic of the code generator kicks in with type classes in place. I <br>\ndon't even have to declare anything for the code generator.</p>\n<p>I don't know if I would want to be adding type classes like I'm doing <br>\nwith the simple example I show here, but having learned how to do it has <br>\nbeen important.</p>\n<p>(I said that before I used the \"export_code\" command. Up until then, I <br>\nwas only associating \"code generator\" with the computation of values in <br>\nIsabelle. If there's nothing to export when type classes aren't being <br>\nused, then I definitely want to do whatever I need to do to be using <br>\ntype classes, when computations are the potential end result.)</p>\n<blockquote>\n<p>If the output of »value t« surprises you, the first step is something like</p>\n<p>definition<br>\n   \"blubb = t\"</p>\n<p>export_code blubb in SML file …</p>\n<p>and inspecting the resulting code.<br>\nI had no interest in exporting code to bring a bunch of work onto myself <br>\ntrying to track down a problem, and for the function \"real\" that I based <br>\neverything on, \"export_code\" tells me there's no code equations for <br>\n\"real\". Now that I have some type classes that get the code generator <br>\nworking for me, I'm more interested in exporting.</p>\n</blockquote>\n<p>I exported, but for Scala. Scala: it's a functional programming <br>\nlanguage, an object oriented one, a scripting language, it's distributed <br>\nwith Isabelle, and it's one of the four languages that the code <br>\ngenerator will export for. It's a good deal.</p>\n<p>I couldn't have done it without your help.</p>\n<p>The magic of the code generator is shown at the comment marked \"(<em>__</em>__)\".</p>\n<p>Regards,<br>\nGB</p>\n<p>theory i131031a__q1c_using_type_classes_to_satisfy_the_code_generator<br>\nimports Complex_Main (<em>\"../../../iHelp/i\"</em>)<br>\nbegin</p>\n<p>(*I based my original \"nat_of\" on the function \"real::'a =&gt; real\", where <br>\nI used<br>\nthe \"defs (overloaded)\" command. It turns out, \"real\" can't be used <br>\neither by<br>\nthe code generator.*)</p>\n<p>definition foo_def :: \"'a =&gt; real\" where<br>\n\"foo_def x = real(x)\"<br>\nvalue \"real(1::int)\" (* OUTPUT: \"1\" :: \"real\"*)<br>\nvalue \"foo_def(1::int)\" (* OUTPUT: \"(real 1)\" :: \"real\" *)</p>\n<p>(*export_code foo_def in Scala file \"i131031a__q1c_foo_def.scala\"<br>\nERROR:<br>\nNo code equations for real*)</p>\n<p>(*Now I use the tip by Florian Haftmann that ad-hoc overloading is the <br>\nproblem,<br>\nand that the code generator only supports Haskell-style overloading with <br>\ntype<br>\nclasses.*)</p>\n<p>class lord_idom_nir = linordered_idom +<br>\nfixes nat_of :: \"'a =&gt; nat\"<br>\nfixes int_of :: \"'a =&gt; int\"<br>\nfixes rat_of :: \"'a =&gt; rat\"</p>\n<p>instantiation int :: lord_idom_nir<br>\nbegin<br>\ndefinition \"nat_of = nat\"<br>\ndefinition \"int_of = (λx. x)\"<br>\ndefinition \"rat_of = rat_of_int\"<br>\ninstance proof qed<br>\nend</p>\n<p>value \"rat_of(int_of(int(nat_of(1::int))))\" (* OUTPUT: 1::rat *)</p>\n<p>class lord_ab_group_add_nir = linordered_ab_group_add +<br>\nfixes gnat_of :: \"'a =&gt; nat\"<br>\nfixes gint_of :: \"'a =&gt; int\"<br>\nfixes grat_of :: \"'a =&gt; rat\"</p>\n<p>instantiation int :: lord_ab_group_add_nir<br>\nbegin<br>\ndefinition \"gnat_of = nat\"<br>\ndefinition \"gint_of = (λx. x)\"<br>\ndefinition \"grat_of = rat_of_int\"<br>\ninstance proof qed<br>\nend</p>\n<p>datatype ('a,'b) oI =<br>\noIf \"'a * 'b\"<br>\n|oIF \"('a,'b) oI list\"</p>\n<p>fun oICq :: \"('a::lord_idom_nir,'b::lord_ab_group_add_nir) oI =&gt; rat\" where<br>\n\"oICq (oIf p) = (if (snd p) &lt; 0<br>\nthen 1/rat_of(fst p ^ gnat_of(- snd p))<br>\nelse rat_of(fst p ^ gnat_of(snd p)))\"<br>\n|\"oICq (oIF[]) = 1\"<br>\n|\"oICq (oIF (x#xs)) = oICq x * oICq (oIF xs)\"</p>\n<p>(<em>export_code oICq in Scala file \"i131031a__q1c_oICq.scala\"</em>)</p>\n<p>(<em>__</em>__) It works by magic now. The output is (1::rat).*)</p>\n<p>value \"oICq(oIf(1::int,1::int))\"<br>\n(*OUTPUT: (1::rat). Using the conversions that are based on ad-hoc <br>\noverloading,<br>\nthe expression is never simplified. It is this:</p>\n<p>\"(rat_of (power.power 1 (λ(u ua). (u * ua)) 1 (nat_of 1)))\" :: \"rat\" *)</p>\n<p>(* (int * int) *)<br>\ntheorem \"oICq(oIf(a::int,b::int)) = rat_of(a ^ nat(b)) ∨<br>\noICq(oIf(a::int,b::int)) = (1/rat_of(a ^ nat(-b)))\"<br>\nby(simp add: gnat_of_int_def)</p>\n<p>(* (nat * int) *)<br>\ntheorem \"oICq(oIf(a::nat,b::int)) = rat_of(a ^ nat(b)) ∨<br>\noICq(oIf(a::nat,b::int)) = (1/rat_of(a ^ nat(-b)))\"<br>\nby(simp add: zpower_int gnat_of_int_def)</p>\n<p>(* (int * nat) *)<br>\ntheorem \"oICq(oIf(a::int,b::nat)) = rat_of(a ^ b)\"<br>\nby(simp add: gnat_of_int_def)</p>\n<p>(* (nat * nat) *)<br>\ntheorem \"oICq(oIf(a::nat,b::nat)) = rat_of(a ^ b)\"<br>\nby(simp add: zpower_int gnat_of_int_def)</p>\n<p>(* Export test of a simple definition using nat_of.*)</p>\n<p>definition def_export_test :: \"int =&gt; nat\" where<br>\n\"def_export_test x = nat_of x\"</p>\n<p>(*export_code def_export_test in Scala file <br>\n\"i131031a__q1c_def_export_test.scala\"*)<br>\n<a href=\"/user_uploads/14278/1EMTLQhrol9eUA2j7Au-jUZ4/i131031a__q1c_using_type_classes_to_satisfy_the_code_generator.thy\">i131031a__q1c_using_type_classes_to_satisfy_the_code_generator.thy</a></p>",
        "id": 294254954,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660912232
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>This is the first of two emails with some questions about my use of the <br>\nlinordered_idom class. In this email, I ask three fairly simple questions.</p>\n<p>The questions are in the attached THY, at the top of the file, and I <br>\ninclude the contents of the THY below.</p>\n<p>Thanks,<br>\nGB</p>\n<p>(*I have three questions related to the 6 comments in the source below, <br>\nand which<br>\nare marked 1a, 1b, 2a, 2b, 3a, and 3b, though the comments aren't in <br>\nthat order.</p>\n<p>1) In the linordered_idom class context, the function foo_f takes 0.7 <br>\nseconds to<br>\nprocess, where an identical function, foo_f2, in the global context takes<br>\nonly about 0.1 second. Is there any advantage to defining foo_f in the<br>\nlinordered_idom class context, other than it will localize its name?</p>\n<p>2) Inside the class context, the simp method will not use foo_f.simps, even<br>\nthough the output message shows that foo_f.simps are available as rewrite<br>\nrules. Inside, linordered_idom_class.foo_f.simps must be added as a simp <br>\nrule.<br>\nIs there something I can do to get it to use foo_f.simps, without having to<br>\nadd the qualified name linordered_idom_class.foo_f.simps as a simp rule?</p>\n<p>3) The value method prints linordered_idom numerals as sums of 1, even <br>\nthough<br>\nI import Code_Target_Numeral.thy. The simp method prints numerals in the <br>\nnice<br>\nform. Is there something I can do to get the value method to print<br>\nlinordered_idom numerals as single numbers rather than sums of 1?*)</p>\n<p>datatype 'a foo_d = Foo_d 'a</p>\n<p>context linordered_idom<br>\nbegin<br>\n(<em>___1a__ It takes about 0.7 second to process foo_f in this context.</em>)</p>\n<p>fun foo_f :: \"'a foo_d =&gt; real\" where<br>\n\"foo_f (Foo_d x) = real x\"</p>\n<p>(*___2a__ Inside, foo_f.simps must be used with the fully qualified <br>\nname, even<br>\nthough the output message shows it's present as a rewrite rule.*)</p>\n<p>theorem \"foo_f (Foo_d (1::int)) = (1::real)\"<br>\napply(simp add: foo_f.simps)<br>\n(*OUTPUT: Ignoring duplicate rewrite rule... Failed to apply proof <br>\nmethod...*)<br>\napply(simp add: linordered_idom_class.foo_f.simps)<br>\ndone<br>\nend</p>\n<p>(<em>___2b__ Outside, foo_f.simps works without the fully qualified name.</em>)</p>\n<p>theorem \"foo_f (Foo_d (1::int)) = (1::real)\"<br>\nby(simp)</p>\n<p>(*___1b__ It takes about 0.1 second to process foo_f2 in the global <br>\ncontext.*)</p>\n<p>fun foo_f2 :: \"'a::linordered_idom foo_d =&gt; real\" where<br>\n\"foo_f2 (Foo_d x) = real x\"</p>\n<p>(*___3a__ Value prints numerals as sums of 1. Importing <br>\nCode_Target_Numeral.thy<br>\ndoesn't help.*)<br>\ndeclare[[show_sorts=true]]<br>\nvalue \"foo_f(Foo_d(2 * 2))\"<br>\n(*OUTPUT:<br>\n\"real (((1::'a::linordered_idom) + (1::'a::linordered_idom)) *\n((1::'a::linordered_idom) + (1::'a::linordered_idom)))\"<br>\n:: \"real\"*)</p>\n<p>(<em>___3b__ But simp prints numerals in the nice form.</em>)<br>\ntheorem \"foo_f(Foo_d(2 * 2)) = (4::real)\"<br>\napply(simp)<br>\n(*OUTPUT:<br>\ngoal (1 subgoal):</p>\n<ol>\n<li>real (4∷'a) = (4∷real)*)<br>\noops<br>\n<a href=\"/user_uploads/14278/F188Wf50DlQNuq0iFqoNRBz8/i131031a__context_slower__needs_qualified_simp__numeral_print.thy\">i131031a__context_slower__needs_qualified_simp__numeral_print.thy</a></li>\n</ol>",
        "id": 294258238,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660913397
    }
]