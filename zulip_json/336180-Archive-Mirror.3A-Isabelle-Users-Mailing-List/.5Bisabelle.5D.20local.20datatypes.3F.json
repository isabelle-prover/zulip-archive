[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nHello,</p>\n<p>Is it possible to introduce a new datatype that scoped only for the duration of a single proof? My datatype doesn't technically <em>depend</em> on local definitions inside the proof -- I just want to make it clear to the reader that these datatype only needs to be understood in the context of this proof.</p>\n<p>That is, I want to write something like this:</p>\n<p>theorem soundness: <br>\n\"\\&lt;forall&gt; a :: A. prov a --&gt; sem a\"<br>\nproof</p>\n<p>datatype myNewType = Foo int | Bar nat</p>\n<p>fun f :: \"A =&gt; myNewType =&gt; bool\"<br>\n  where (* ... *)</p>\n<p>lemma soundness_first_step:<br>\n    \"\\&lt;forall&gt; a. prov a --&gt; (\\&lt;exists&gt; m. f a m)\"<br>\n  proof (* ... *) qed</p>\n<p>lemma soundness_second_step:<br>\n    \"\\&lt;forall&gt; a. (\\&lt;exists&gt; m. f a m) --&gt; sem a\"<br>\n  proof (* ... *) qed</p>\n<p>show ?thesis <br>\n    using soundness_first_step<br>\n      and soundness_second_step by auto</p>\n<p>qed</p>\n<p>Thanks very much,<br>\njohn</p>",
        "id": 294146780,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847794
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 28 Oct 2011, John Wickerson wrote:</p>\n<blockquote>\n<p>Is it possible to introduce a new datatype that scoped only for the <br>\nduration of a single proof? My datatype doesn't technically <em>depend</em> on <br>\nlocal definitions inside the proof -- I just want to make it clear to <br>\nthe reader that these datatype only needs to be understood in the <br>\ncontext of this proof.</p>\n</blockquote>\n<p>There are technical reasons why such extreme for of locality is not <br>\nsupported, and practical ones.</p>\n<p>If you take locales for example, the \"local\" specifications are always <br>\naccessible from outside via qualified names.  Picking lemmas from other <br>\npeoples private developments is common practice, and seems to cause little <br>\nproblems in reality.  (Less than in regular programming.)</p>\n<blockquote>\n<p>That is, I want to write something like this:</p>\n<p>theorem soundness:<br>\n\"\\&lt;forall&gt; a :: A. prov a --&gt; sem a\"<br>\nproof</p>\n<p>datatype myNewType = Foo int | Bar nat</p>\n<p>fun f :: \"A =&gt; myNewType =&gt; bool\"<br>\n where (* ... *)</p>\n<p>lemma soundness_first_step:<br>\n   \"\\&lt;forall&gt; a. prov a --&gt; (\\&lt;exists&gt; m. f a m)\"<br>\n proof (* ... *) qed</p>\n</blockquote>\n<p>The standard way to do it is to put the 'theorem' last, without any <br>\nspecial nesting.  Its classification as \"theorem\" already indicates it <br>\nbeing a main result.  There is also 'corollary'.</p>\n<p>BTW, type names in HOL are almost always plain identifiers like foo_bar, <br>\nwithout caps or camels.</p>\n<p>BTW2, closed statements with HOL \\&lt;forall&gt; --&gt; are rare.  You normally <br>\nstate open inference rules, using !! ==&gt; or better fixes/assumes/shows in <br>\nIsar notation.  E.g. like this:</p>\n<p>lemma soundness_first_step:<br>\n     fixes a<br>\n     assumes \"prov a\"<br>\n     shows \"\\&lt;exists&gt; m. f a m\"</p>\n<p>You can also split up the \\&lt;exists&gt; via Isar 'obtains', if you are <br>\nmore ambitious.</p>\n<p>Makarius</p>",
        "id": 294146809,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847806
    }
]