[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nConsider the following (HOL/Main, Isabelle 2011)</p>\n<p>locale preordX2 = le: preorder le lt + le': preorder le' lt'<br>\n  for le::\"'a =&gt; 'a =&gt; bool\" and lt::\"'a =&gt; 'a =&gt; bool\"<br>\n  and le'::\"'b =&gt; 'b =&gt; bool\" and lt'::\"'b =&gt; 'b =&gt; bool\"<br>\n  +<br>\n  fixes preordX2_opn:: \"'a =&gt; 'b =&gt;  'a\"<br>\nbegin</p>\n<p>This locale is abstracted over two preorders.  I have an operation<br>\n\"preordX2_opn\" on objects of both preorders, so I need explicit type<br>\nvariables 'a, 'b, for the constituent preorders in order to correctly<br>\nspecify this operation.</p>\n<p>Now consider the trivial lemma:</p>\n<p>lemma<br>\n  fixes a::'a<br>\n  shows \"~ (lt a a)\"<br>\n  using less_irrefl .       --\"less_irrefl from typeclass preorder\"</p>\n<p>This proof FAILS:<br>\n  *** Failed to finish proof<br>\n  *** At command \".\"</p>\n<p>I suppose the failure is due to typing:</p>\n<p>thm less_irrefl<br>\n\\&lt;not&gt; (lt'\\&lt;Colon&gt;'b \\&lt;Rightarrow&gt; 'b \\&lt;Rightarrow&gt; bool) (?x\\&lt;Colon&gt;'b) ?x</p>\n<p>It seems that type variable 'b is incorrect here;  less_irrefl should<br>\nhave a generalized type.</p>\n<p>Indeed, the following proof succeeds:</p>\n<p>lemma<br>\n  fixes b::'b<br>\n  shows \"~ (lt' b b)\"<br>\n  using less_irrefl .</p>\n<p>Randy</p>",
        "id": 294142721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846426
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Tue, Aug 23, 2011 at 12:41 PM, Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Consider the following (HOL/Main, Isabelle 2011)</p>\n<p>locale preordX2 = le: preorder le lt + le': preorder le' lt'<br>\n for le::\"'a =&gt; 'a =&gt; bool\" and lt::\"'a =&gt; 'a =&gt; bool\"<br>\n and le'::\"'b =&gt; 'b =&gt; bool\" and lt'::\"'b =&gt; 'b =&gt; bool\"<br>\n +<br>\n fixes preordX2_opn:: \"'a =&gt; 'b =&gt;  'a\"<br>\nbegin</p>\n</blockquote>\n<p>Within this locale, you have these two lemmas in scope:</p>\n<p>le.less_irrefl: \"~ lt x x\"<br>\nle'.less_irrefl: \"~ lt' x x\"</p>\n<blockquote>\n<p>Now consider the trivial lemma:</p>\n<p>lemma<br>\n fixes a::'a<br>\n shows \"~ (lt a a)\"<br>\n using less_irrefl .       --\"less_irrefl from typeclass preorder\"</p>\n</blockquote>\n<p>The unqualified lemma name \"less_irrefl\" is ambiguous here. Isabelle<br>\nresolves the ambiguity by picking the most-recently-introduced name<br>\nthat matches, which happens to be \"le'.less_irrefl\". If you explicitly<br>\nsay \"using le.less_irrefl\" the proof will work.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294142738,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846433
    }
]