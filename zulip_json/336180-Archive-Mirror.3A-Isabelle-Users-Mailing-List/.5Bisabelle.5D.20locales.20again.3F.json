[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nThis is ok:</p>\n<p>lemma <br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   defines \"P == (F = Suc)\"<br>\n   assumes h:\"... P ...\"<br>\n   shows \"... P ...\"</p>\n<p>where I might want to use P several times in the assumes and shows.</p>\n<p>What is the intended way to make a definition for local use in the<br>\nassumes of a locale?  This is rejected:</p>\n<p>locale PF =          (***)<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   defines \"P == (F = Suc)\"<br>\n   assumes PFa:\"P\"</p>\n<p>*** Bad head of lhs: bound variable \"P\"</p>\n<p>This is accepted</p>\n<p>locale PF2 =<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   and P :: bool<br>\n   defines \"P == (F = Suc)\"<br>\n   assumes PFa:\"P\"</p>\n<p>but doesn't seem to mean what I wanted to express in (***).</p>\n<p>A different, but related question.  Consider the (partial)<br>\ninterpretation:</p>\n<p>interpretation PF2I: PF2 Suc</p>\n<p>gives goal</p>\n<p>PF2 Suc &amp;&amp;&amp; P == Suc = Suc<br>\n              ^ this P is blue</p>\n<p>I guess the blue P is generalized, so this can never be proved, which<br>\nis probably intended for partial interpretation.</p>\n<p>but consider this:</p>\n<p>abbreviation P :: \"(nat \\&lt;Rightarrow&gt; nat) \\&lt;Rightarrow&gt; bool\"<br>\n   where \"P F == \\&lt;forall&gt;(n::nat). \\&lt;exists&gt;(z::nat). F n = z + 1\"</p>\n<p>locale PF =<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   assumes PFa[rule_format]:\"P F\"</p>\n<p>locale PFm = PF + fixes m :: nat<br>\n begin<br>\n definition F0 :: \"nat \\&lt;Rightarrow&gt; nat\" where \"F0 x = (F x) + m\"</p>\n<p>lemma Flem: shows \"P F0\"<br>\n sorry</p>\n<p>end</p>\n<p>Now the partial interpretation</p>\n<p>interpretation PFmSuc: PFm Suc<br>\n   by (unfold_locales, auto)</p>\n<p>is accepted.</p>\n<p>thm PFmSuc.Flem</p>\n<p>shows</p>\n<p>P (PFm.F0 Suc m)<br>\n                ^ thus is black on a yellow background</p>\n<p>What does that mean?</p>\n<p>Randy</p>",
        "id": 294081484,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830835
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nQuoting Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;:</p>\n<blockquote>\n<p>This is ok:</p>\n<p>lemma<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   defines \"P == (F = Suc)\"<br>\n   assumes h:\"... P ...\"<br>\n   shows \"... P ...\"</p>\n<p>where I might want to use P several times in the assumes and shows.</p>\n<p>What is the intended way to make a definition for local use in the<br>\nassumes of a locale?  This is rejected:</p>\n<p>locale PF =          (***)<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   defines \"P == (F = Suc)\"<br>\n   assumes PFa:\"P\"</p>\n<p>*** Bad head of lhs: bound variable \"P\"</p>\n<p>This is accepted</p>\n<p>locale PF2 =<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   and P :: bool<br>\n   defines \"P == (F = Suc)\"<br>\n   assumes PFa:\"P\"</p>\n<p>but doesn't seem to mean what I wanted to express in (***).</p>\n</blockquote>\n<p>The treatment of \"free\" variables is different in \"lemma\" and<br>\n\"locale\".  In \"lemma\" they are automatically fixed (and generalised  <br>\nwhen the statement is turned into a theorem), in \"locale\" they are  <br>\nuniversally quantified for the term they occur in.  The distinction  <br>\nmight seem a bit arbitrary but I guess one wanted \"x * y = y * x\" to  <br>\nmean \"!x y. x * y = y * x\" in a locale assumption.</p>\n<blockquote>\n<p>A different, but related question.  Consider the (partial)<br>\ninterpretation:</p>\n<p>interpretation PF2I: PF2 Suc</p>\n<p>gives goal</p>\n<p>PF2 Suc &amp;&amp;&amp; P == Suc = Suc<br>\n              ^ this P is blue</p>\n<p>I guess the blue P is generalized, so this can never be proved, which<br>\nis probably intended for partial interpretation.</p>\n</blockquote>\n<p>Indeed, in a top-level interpretation there is no context where \"P\"<br>\ncould be bound and it is thus generalised.  If you did</p>\n<p>interpretation FP2I: PF2 Suc x</p>\n<p>you would get a blue x instead.  (In contrary to what I said in my  <br>\nprevious e-mail, I think the implementation accepts such an unbound  <br>\nvariable also on the right hand side of sublocale, but it may then get  <br>\nlost as what to do with it when applying the interpretation.)</p>\n<blockquote>\n<p>but consider this:</p>\n<p>abbreviation P :: \"(nat \\&lt;Rightarrow&gt; nat) \\&lt;Rightarrow&gt; bool\"<br>\n   where \"P F == \\&lt;forall&gt;(n::nat). \\&lt;exists&gt;(z::nat). F n = z + 1\"</p>\n<p>locale PF =<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   assumes PFa[rule_format]:\"P F\"</p>\n<p>locale PFm = PF + fixes m :: nat<br>\n begin<br>\n definition F0 :: \"nat \\&lt;Rightarrow&gt; nat\" where \"F0 x = (F x) + m\"</p>\n</blockquote>\n<p>This creates a constant \"PFm.F0\" with two arguments and in the locale  <br>\n\"PFm.F0 F m\" is abbreviated by \"F0\".</p>\n<blockquote>\n<p>lemma Flem: shows \"P F0\"<br>\n sorry</p>\n<p>end</p>\n<p>Now the partial interpretation</p>\n<p>interpretation PFmSuc: PFm Suc<br>\n   by (unfold_locales, auto)</p>\n<p>is accepted.</p>\n</blockquote>\n<p>It should be equivalent to</p>\n<p>interpretation PFmSuc: PFm Suc m</p>\n<blockquote>\n<p>thm PFmSuc.Flem</p>\n<p>shows</p>\n<p>P (PFm.F0 Suc m)<br>\n                ^ thus is black on a yellow background</p>\n</blockquote>\n<p>I'm not sure what black on yellow means.  I believe it is a warning  <br>\nthat you might have done something unintended.  However, I expect the  <br>\nresult to be the same if you make an interpretation with full arguments.</p>\n<p>Clemens</p>",
        "id": 294081569,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830854
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@ipd.info.uni-karlsruhe.de\">lochbihl@ipd.info.uni-karlsruhe.de</a>&gt;<br>\nClemens Ballarin wrote:</p>\n<blockquote>\n<p>Quoting Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;:</p>\n<blockquote>\n<p>What is the intended way to make a definition for local use in the<br>\nassumes of a locale?<br>\nIn Isabelle 2008 and earlier, \"defines\" allowed you to make a definition <br>\nthat gets unfolded automatically in interpretations and need not be <br>\nspecified, although you still had to explicitly fix the defined <br>\nparameter. In particular, at interpretations, you did not have to <br>\ninstantiate the parameter. Since Isabelle 2009, you can still fix the <br>\nparameter, but at all interpretations, you must specify the defined <br>\nparameter as well.</p>\n</blockquote>\n</blockquote>\n<p>In your example, this would be:</p>\n<blockquote>\n<blockquote>\n<p>locale PF2 =<br>\n   fixes F::\"nat \\&lt;Rightarrow&gt; nat\"<br>\n   and P :: bool<br>\n   defines \"P == (F = Suc)\"<br>\n   assumes PFa:\"P\"</p>\n</blockquote>\n</blockquote>\n<p>interpretation PF2I: PF2 Suc \"Suc = Suc\"</p>\n<p>or</p>\n<p>interpretation PF2I: PF2 Suc True</p>\n<p>Unfortunately, unfold_locales does not work well with defines, so you <br>\ntypically have to get rid of the goals due to defines first.</p>\n<blockquote>\n<blockquote>\n<p>Now the partial interpretation</p>\n<p>interpretation PFmSuc: PFm Suc<br>\n   by (unfold_locales, auto)</p>\n<p>is accepted.<br>\n  thm PFmSuc.Flem</p>\n<p>shows</p>\n<p>P (PFm.F0 Suc m)<br>\n                ^ thus is black on a yellow background</p>\n</blockquote>\n<p>I'm not sure what black on yellow means.  I believe it is a warning that <br>\nyou might have done something unintended.  However, I expect the result <br>\nto be the same if you make an interpretation with full arguments.<br>\nIt does have the same result. In this example, m is not bound by the <br>\ncontext, i.e. a new parameter that should be declared as such. However, <br>\ninterpretation has an unusual behaviour regarding undeclared new <br>\nparameters. As far as I have been able to track it down, it does the <br>\nfollowing for undeclared parameters:</p>\n</blockquote>\n<ol>\n<li>\n<p>If the undeclared parameter in the expression is the same as one in <br>\nthe locale that is not instantiated, then it is not generalised.</p>\n</li>\n<li>\n<p>If is a new undeclared parameter (e.g. some argument to a function), <br>\nthen it is generalised iff there are assumptions to be shown at the <br>\ninterpretation.<br>\nAnyway, the correct way to do the above interpretation is:</p>\n</li>\n</ol>\n<p>interpretation PFmSuc: PFm Suc m for m</p>\n<p>You can also omit the m parameter:</p>\n<p>interpretation PFmSuc: PFm Suc for m</p>\n<p>The black on yellow background tells you that there is a variable that <br>\nis not bound by the context, but neither generalised. You can turn it <br>\ninto a free (generalised) variable by applying the attribute standard to <br>\nthe theorem, but this can also do much more to it.</p>\n<p>Andreas</p>",
        "id": 294081645,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830878
    }
]