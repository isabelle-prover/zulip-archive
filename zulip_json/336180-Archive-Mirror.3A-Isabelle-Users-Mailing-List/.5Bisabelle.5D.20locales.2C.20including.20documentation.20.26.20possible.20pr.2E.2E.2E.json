[
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Fri, May 4, 2012 at 6:01 AM, Bill Richter<br>\n&lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt; wrote:</p>\n<blockquote>\n<p>My axiomatic geometry quest is now entirely about locales, and I have<br>\na documentation bug.  The syntax looks incorrect in both locales.pdf<br>\nand p 40 of the Isabelle/Isar Reference Manual, which has a nice group<br>\ntheory example, from which I learned something about proofs.</p>\n<p>So I created the file Group1.thy below and had a lot of fun playing<br>\nwith it in jedit.  First notice all the \"s and 's I inserted.  There<br>\nare none of p 40, or in locales.pdf, and wouldn't that be great if we<br>\ndidn't need them.  I figured that out the <code>\"'s &amp; </code>''s easily by trial<br>\nand error, but It took me a long time to realize I had to put the<br>\nfinal period after the `\"'.</p>\n</blockquote>\n<p>I agree that the omission of quotation marks in our pdf documentation<br>\nis misleading and confusing, especially for new users who naturally<br>\nwant to copy examples manually from the pdf into their theory files.</p>\n<p>As a workaround, it may be useful to locate the source theories for<br>\nthe pdfs, and copy the definitions directly. (Look inside the doc-src<br>\ndirectory in the distribution.)</p>\n<p>I can happily report that the new \"Programming and Proving in<br>\nIsabelle/HOL\" tutorial in the upcoming Isabelle2012 release does show<br>\nquotation marks in the examples.</p>\n<blockquote>\n<p>I didn't know how to make the -1 exponent<br>\nin jedit, so I changed x^{-1} to sqrt x.  Can someone tell me how?</p>\n</blockquote>\n<p>See appendix B of the Isabelle/Isar Reference Manual for a list of<br>\npredefined symbols.</p>\n<blockquote>\n<p>And here's another newbie question: If you have a 4-ary relation C,<br>\nhow do you tell Isabelle you want to write it as a b &lt;\\equiv&gt; c d?<br>\nThat's what Tim does, but where is that explained?</p>\n</blockquote>\n<p>To introduce syntax like this, you will need to use the \"notation\"<br>\ncommand with a mixfix declaration. (Search for \"mixfix\" in the<br>\nIsabelle tutorial and old reference manual.)</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294160595,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853002
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 4 May 2012, Brian Huffman wrote:</p>\n<blockquote>\n<p>I agree that the omission of quotation marks in our pdf documentation is <br>\nmisleading and confusing, especially for new users who naturally want to <br>\ncopy examples manually from the pdf into their theory files.</p>\n</blockquote>\n<p>This is an old problem, but showing the quotes alone does not help. Most <br>\nnew users try to copy-paste mechanically, not manually, and then get <br>\ndisappointed by the approximative result.  Quotes, underscores, special <br>\nsymbols etc. may all appear differently depending on the underlying LaTeX <br>\nstyles of the documents in question.</p>\n<blockquote>\n<p>I can happily report that the new \"Programming and Proving in <br>\nIsabelle/HOL\" tutorial in the upcoming Isabelle2012 release does show <br>\nquotation marks in the examples.</p>\n</blockquote>\n<p>Copy paste fails here, as anticipated.  E.g. page 8, middle:</p>\n<p>fun app :: \"′a list ⇒ ′a list ⇒ ′a list\" where \"app Nil ys = ys\" |<br>\n     \"app (Cons x xs) ys = Cons x (app xs ys)\"</p>\n<p>The single quotes are not the ASCII ones, so Isabelle will choke on that <br>\ninput.  Such things can be tweaking in the LaTeX setup, but it is a <br>\nnever-ending story.</p>\n<p>I've once tried a systematic approach where the original Isabelle source <br>\nis associated with the visual typesetting (whatever that is), and it <br>\nalmost worked.  Unfortunately some PDF browsers had problems with this <br>\naddition to the PDF format from a few years ago, especially Mac OS Preview <br>\nand Windows Acrobat Reader.  Evince/Poppler on Linux was the only platform <br>\nthat worked reliably when I did the experiment 1-2 years ago.</p>\n<p>Makarius</p>",
        "id": 294160622,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853014
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nBrian, I read ref.pdf p 30--32 on misfixes, but I could not figure out<br>\nhow to write (in my code below) <br>\nC a b c d as a b \\&lt;equiv&gt; c d.  <br>\nI seem to have a priority problem.  I'm using the priority stuff <br>\nps = [99,99,99,99] and p = 70, and I've tried lots of others.</p>\n<p>My \"\\&lt;forall&gt; a b . a b \\&lt;equiv&gt; b a\" gets me the error, a<br>\ndo-not-enter on locale, and when I click on locale, I see in the<br>\noutput window<br>\nAmbiguous input.  2 types are correct:<br>\n(\\&lt;forall&gt; (a b) . (a b \\&lt;equiv&gt; b a))<br>\n((\\&lt;forall&gt; (a b) . (a b)) \\&lt;equiv&gt; (b a))<br>\nIf I change that to \"a b \\&lt;equiv&gt; b a\", and then I get no error, but<br>\nthe output window reads<br>\nAmbiguous input produces 2 parse trees: [which seem to be]<br>\n(C a b b a)<br>\n(C a b) (C b a)<br>\nFortunately, only one is correct, <br>\nbut you may still want to disambiguate your grammar or input.<br>\nThere's more of the same for every \\&lt;equiv&gt; expression in my axioms.</p>\n<p>II tried to write a simple proof following p 40--42 of isar-ref.pdf,<br>\nbut it didn't work. I get do-not-enter signs on every line of the<br>\nproof.  The following commented proof is no better.</p>\n<p>----- Tarski2.thy Tarski2</p>\n<p>theory Tarski2<br>\nimports Complex_Main <br>\nbegin<br>\nlocale tarskifirst7 =<br>\n fixes C :: \"'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\" (\"_ _  \\&lt;equiv&gt; _ _\" [99,99,99,99] 70)<br>\n fixes B :: \"'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; 'a \\&lt;Rightarrow&gt; bool\"<br>\n(*<br>\n  assumes A1: \"\\&lt;forall&gt; a b . a b \\&lt;equiv&gt; b a\"<br>\n*)<br>\n  assumes A1: \"a b \\&lt;equiv&gt; b a\"<br>\n   and A2: \"a b \\&lt;equiv&gt; p q \\&lt;and&gt; a b \\&lt;equiv&gt; r s --&gt; p q \\&lt;equiv&gt; r s\"<br>\n   and A3: \"a b \\&lt;equiv&gt; c c ==&gt; a = b\"<br>\n   and A4: \"\\&lt;exists&gt; x. B q a x \\&lt;and&gt; a x \\&lt;equiv&gt; b c\"<br>\n   and A5: \"a \\&lt;noteq&gt; b \\&lt;and&gt; B a b x \\&lt;and&gt; B a' b' x' \\&lt;and&gt; b x \\&lt;equiv&gt; b' x' \\&lt;and&gt; <br>\n              a b \\&lt;equiv&gt; a' b' \\&lt;and&gt; a c \\&lt;equiv&gt; a' c' \\&lt;and&gt; b c \\&lt;equiv&gt; b' c' --&gt; c x \\&lt;equiv&gt; c' x'\"<br>\n   and A6: \"B a b a ==&gt; a = b\"<br>\n   and A7: \"B a p c \\&lt;and&gt; B b q c ==&gt; (\\&lt;exists&gt; x. B p x b \\&lt;and&gt; B q x a)\"</p>\n<p>context tarskifirst7<br>\nbegin</p>\n<p>theorem EquivReflexive: \"a b \\&lt;equiv&gt; a b\"</p>\n<p>proof -<br>\n     have \"b a \\&lt;equiv&gt; a b\" by (rule A1)<br>\n     have \"b a \\&lt;equiv&gt; a b\" by (rule A1)<br>\n     thus \"a b \\&lt;equiv&gt; a b\" by (rule A2)<br>\n     qed<br>\n   end</p>\n<p>(*<br>\n   proof -<br>\n     have \"b a \\&lt;equiv&gt; a b\" by (rule A1 [symmetric])<br>\n     have \"b a \\&lt;equiv&gt; a b\" by (rule A1 [symmetric])<br>\n     also have \"a b \\&lt;equiv&gt; a b\" by (rule A2 [symmetric])<br>\n     finally show \"a b \\&lt;equiv&gt; a b\"<br>\n     qed<br>\n   end<br>\n*)</p>\n<p>(* end *)<br>\n(*<br>\n lemma A1: \"C a b b a\"<br>\n  by (simp add: A1)</p>\n<p>lemma A2: \"C a b p q \\&lt;and&gt; C a b r s ==&gt; C p q r s\"<br>\n  by (simp add: A2)</p>\n<p>lemma A3 : a b \\&lt;equiv&gt; c c =\\&lt;Rightarrow&gt; a = b<br>\n  by (simp add: A3)</p>\n<p>theorem th2-1: a b \\&lt;equiv&gt; a b<br>\nproof −<br>\n  from A2 [of b a a b a b] and A1 [of b a] show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-2: a b \\&lt;equiv&gt; c d =\\&lt;Rightarrow&gt; c d \\&lt;equiv&gt; a b<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with A2 [of a b c d a b] and th2-1 [of a b] show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-3: [[a b \\&lt;equiv&gt; c d; c d \\&lt;equiv&gt; e f ]] =\\&lt;Rightarrow&gt; a b \\&lt;equiv&gt; e f<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with th2-2 [of a b c d] have c d \\&lt;equiv&gt; a b by simp<br>\n  assume c d \\&lt;equiv&gt; e f<br>\n  with A2 [of c d a b e f ] and c d \\&lt;equiv&gt; a b show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-4: a b \\&lt;equiv&gt; c d =\\&lt;Rightarrow&gt; b a \\&lt;equiv&gt; c d<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with th2-3 [of b a a b c d] and A1 [of b a] show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-5: a b \\&lt;equiv&gt; c d =\\&lt;Rightarrow&gt; a b \\&lt;equiv&gt; d c<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with th2-3 [of a b c d d c] and A1 [of c d] show ?thesis by simp<br>\nqed</p>\n<p>definition is-segment :: 'p set \\&lt;Rightarrow&gt; bool where<br>\nis-segment X \\&lt;exists&gt; x y. X = {x, y}<br>\ndefinition segments :: p set set where<br>\nsegments = {X. is-segment X}<br>\ndefinition SC :: p set \\&lt;Rightarrow&gt; p set \\&lt;Rightarrow&gt; bool where<br>\nSC X Y \\&lt;exists&gt; w x y z. X = {w, x} \\&lt;and&gt; Y = {y, z} \\&lt;and&gt; w x \\&lt;equiv&gt; y z</p>\n<p>*)</p>",
        "id": 294160804,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853076
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Sun, May 6, 2012 at 1:01 AM, Bill Richter<br>\n&lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt; wrote:</p>\n<blockquote>\n<p>Brian, I read ref.pdf p 30--32 on misfixes, but I could not figure out<br>\nhow to write (in my code below)<br>\nC a b c d as a b \\&lt;equiv&gt; c d.<br>\nI seem to have a priority problem.  I'm using the priority stuff<br>\nps = [99,99,99,99] and p = 70, and I've tried lots of others.</p>\n<p>My \"\\&lt;forall&gt; a b . a b \\&lt;equiv&gt; b a\" gets me the error, a<br>\ndo-not-enter on locale, and when I click on locale, I see in the<br>\noutput window<br>\nAmbiguous input.  2 types are correct:<br>\n(\\&lt;forall&gt; (a b) . (a b \\&lt;equiv&gt; b a))<br>\n((\\&lt;forall&gt; (a b) . (a b)) \\&lt;equiv&gt; (b a))</p>\n</blockquote>\n<p>Your syntax is ambiguous because \\&lt;equiv&gt; is also used to write<br>\nmeta-equality (i.e. definitional equality) in Isabelle. \"a b \\&lt;equiv&gt;<br>\nc d\" looks like an equality between two function applications.</p>\n<p>You will have a much easier time avoiding ambiguous parse<br>\nwarnings/errors if you simply use a different symbol, such as \\&lt;cong&gt;.</p>\n<p>fixes C :: \"'a =&gt; 'a =&gt; 'a =&gt; 'a =&gt; bool\" (\"_ _ \\&lt;cong&gt; _ _\" [99,99,99,99] 70)</p>\n<p>The other potential source of ambiguous parsing here is when one of<br>\nthe arguments to C is a function application:</p>\n<p>term \"(f x) b \\&lt;cong&gt; c d\"</p>\n<p>This parses fine, but it prints out as \"f x b \\&lt;cong&gt; c d\". If you try<br>\nto parse it again without the parentheses, you get an ambiguity.</p>\n<p>To fix this, I would bump up the argument precedences to the maximum<br>\n(1000), which is higher than function application. This makes it so<br>\nevery argument to C must be either a variable or a parenthesized<br>\nexpression (which will also be the case for the pretty-printer's<br>\noutput).</p>\n<p>fixes C :: \"'a =&gt; 'a =&gt; 'a =&gt; 'a =&gt; bool\" (\"_ _ \\&lt;cong&gt; _ _\"<br>\n[1000,1000,1000,1000] 70)</p>\n<blockquote>\n<p>II tried to write a simple proof following p 40--42 of isar-ref.pdf,<br>\nbut it didn't work. I get do-not-enter signs on every line of the<br>\nproof.  The following commented proof is no better.<br>\n[...]<br>\n assumes A1: \"a b \\&lt;equiv&gt; b a\"<br>\n  and A2: \"a b \\&lt;equiv&gt; p q \\&lt;and&gt; a b \\&lt;equiv&gt; r s --&gt; p q \\&lt;equiv&gt; r s\"</p>\n</blockquote>\n<p>Rules stated in terms of object logic connectives, like \"P \\&lt;and&gt; Q<br>\n--&gt; R\", aren't very useful with the \"rule\" method. You had better<br>\nstate rules using \"==&gt;\", like<br>\n\"P ==&gt; Q ==&gt; R\" instead.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294160822,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853082
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nThanks, Brian, that's very helpful!  I was really confused by the<br>\n\\equiv biz.  Can you explain two more things:</p>\n<p>what do the 1000 priorities here even mean: [1000,1000,1000,1000] 70?<br>\nIf we right a b \\cong c d, I want a &amp; b to be bound really tightly<br>\ntogether, so 1000 sounds like a good number, and I want the whole<br>\nexpression to be bound tighter than say and or implies, so 70 is a<br>\ngood number.  But then I'd write it as [1000, 70, 1000].  </p>\n<p>Rules stated in terms of object logic connectives, like \"P \\&lt;and&gt; Q<br>\n   --&gt; R\", aren't very useful with the \"rule\" method. You had better<br>\n   state rules using \"==&gt;\", like<br>\n   \"P ==&gt; Q ==&gt; R\" instead.</p>\n<p>I've been puzzled for some time by the preference (especially in<br>\nJulien's Tarski geometry Coq code) by folks writing</p>\n<p>P ==&gt; Q ==&gt; R ==&gt; S ==&gt; T ==&gt; U <br>\ninstead of the more sensible <br>\nP &amp; Q &amp; R &amp; S &amp; T ==&gt; U .</p>\n<p>And you're saying there's a good reason for this!  Great!  Can you<br>\nexplain why the first approach works better with rules?</p>",
        "id": 294160840,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853088
    }
]