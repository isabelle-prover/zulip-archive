[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nI'm reasoning about a properties of a fixed hypothetical function.  I<br>\nwant to say \"if F has some specified properties then some given<br>\nvariant, F0 of F, has the same properties\".</p>\n<p>First, \"F has property HE\":</p>\n<p>locale fixF = fixes F :: sometype<br>\n  begin<br>\n  abbreviation HE :: \"bool\" where \"HE == ...<br>\n  ...<br>\n  end<br>\n  locale HE = fixF + assumes HE[rule_format]: HE</p>\n<p>If some F has property HE then some variant, F0, of F depending on an<br>\narbitrary constant, v0, also has that property.  I can say:</p>\n<p>locale HEv0 = HE + fixes v0 :: sometype =<br>\n  definition F0 :: Ftyp where \"F0 X = (if ... then v0 else F X)\"<br>\n  lemma shows \"fixF.HE F0\"<br>\n    proof (... using HE ...) qed</p>\n<p>If we interpret locale HEv0 with some actual FF and vv, we get a<br>\ncontext where F is interpreted by FF, v is interpreted by vv, and</p>\n<p>\"fixF.HE (%X. if ... then vv else FF X)\"</p>\n<p>is a theorem.  This is as expected.  But we have proved that given FF<br>\n(with property HE) and vv then (%X. if ... then vv else FF X)<br>\nis a good interpretation of locale HE.</p>\n<p>Is there a locale expression (?) that when interpreted with with FF<br>\nand vv, gives the context of HE interpreted with <br>\n(%X. if ... then vv else FF X)?  (Maybe using a \"where\" clause?)</p>\n<p>Thanks,<br>\nRandy</p>",
        "id": 294081439,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830817
    },
    {
        "content": "<p>From: Clemens Ballarin &lt;<a href=\"mailto:ballarin@in.tum.de\">ballarin@in.tum.de</a>&gt;<br>\nQuoting Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;:</p>\n<blockquote>\n<p>I'm reasoning about a properties of a fixed hypothetical function.  I<br>\nwant to say \"if F has some specified properties then some given<br>\nvariant, F0 of F, has the same properties\".</p>\n<p>First, \"F has property HE\":</p>\n<p>locale fixF = fixes F :: sometype<br>\n  begin<br>\n  abbreviation HE :: \"bool\" where \"HE == ...<br>\n  ...<br>\n  end<br>\n  locale HE = fixF + assumes HE[rule_format]: HE</p>\n<p>If some F has property HE then some variant, F0, of F depending on an<br>\narbitrary constant, v0, also has that property.</p>\n</blockquote>\n<p>As Andreas has already indicated, this statement can be expressed in  <br>\nthe locales language using the sublocale command.  Larry has once  <br>\ncalled this \"conditional interpretation\" and I quote from the e-mail  <br>\nexchange:</p>\n<p>Larry's question:</p>\n<blockquote>\n<p>Is there such a thing as a conditional interpretation? I used locales<br>\nto describe a certain transformation on continued fractions that is<br>\nonly valid subject to certain conditions. If I want to apply this setup<br>\nin a completely concrete situation, then we have full information and<br>\nall necessary conditions can be proved. but can I use locales to<br>\ndescribe a special case of the transformation that is still subject to<br>\nvarious conditions? It seems illegal to insert a \"assumes\" clause in an<br>\ninterpretation or to nest an interpretation within a locale.</p>\n</blockquote>\n<p>My reply:</p>\n<blockquote>\n<p>the way to deal with such a situation is to declare a locale for the<br>\ncondition, say</p>\n<p>locale cond = ...</p>\n<p>and then use the sublocale command to make an interpretation relative to<br>\ncond</p>\n<p>sublocale cond &lt; expr</p>\n<p>where expr is the locale expression you want to have interpreted.</p>\n<p>The effect of this is that whenever the context cond is entered, the<br>\ninterpretation expr is added automatically.  The same applies if cond<br>\nis interpreted or used in the rhs of another sublocale command.</p>\n</blockquote>\n<p>\"Conditional interpretation\" seems to be an important usage scenario  <br>\nfor the sublocale command.  I will add it to the next revision of the  <br>\ntutorial.  The module hierarchy point of view taken there doesn't seem  <br>\nhelpful for many users.</p>\n<p>Clemens</p>",
        "id": 294081551,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830848
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:lochbihl@ipd.info.uni-karlsruhe.de\">lochbihl@ipd.info.uni-karlsruhe.de</a>&gt;<br>\nHi Randy,</p>\n<blockquote>\n<p>Is there a locale expression (?) that when interpreted with with FF<br>\nand vv, gives the context of HE interpreted with<br>\n(%X. if ... then vv else FF X)?  (Maybe using a \"where\" clause?)<br>\nIf I understand you correctly, you want to have an interpretation of HE <br>\nfor F0 (with the F0's definition unfolded) whenever you interpret HEv0. <br>\nYou can do this by making HEv0 a sublocale of HE with F instantiated to F0:</p>\n</blockquote>\n<p>sublocale HEv0 &lt; F0HE : HE \"%X. if ... then v0 else F X\"<br>\nunfolding F0_def[symmetric]<br>\nby(unfold_locales)(rule HEF0)</p>\n<p>where HEF0 refers to your lemma that shows \"fixF.HE F0\".</p>\n<p>Now, whenever you interpret HEv0, this also interprets HE with F0 <br>\nunfolded. The constants and lemmas generated by this process are <br>\nprefixed by F0HE to distinguish them from those that obtained directly <br>\nfrom HE. Also, already inside the HEv0 locale, you can access the HE <br>\ncontext for F0.</p>\n<p>Is that what you wanted?</p>\n<p>Regards,<br>\nAndreas</p>\n<p>Randy Pollack schrieb:</p>\n<blockquote>\n<p>I'm reasoning about a properties of a fixed hypothetical function.  I<br>\nwant to say \"if F has some specified properties then some given<br>\nvariant, F0 of F, has the same properties\".</p>\n<p>First, \"F has property HE\":</p>\n<p>locale fixF = fixes F :: sometype<br>\n  begin<br>\n  abbreviation HE :: \"bool\" where \"HE == ...<br>\n  ...<br>\n  end<br>\n  locale HE = fixF + assumes HE[rule_format]: HE</p>\n<p>If some F has property HE then some variant, F0, of F depending on an<br>\narbitrary constant, v0, also has that property.  I can say:</p>\n<p>locale HEv0 = HE + fixes v0 :: sometype =<br>\n  definition F0 :: Ftyp where \"F0 X = (if ... then v0 else F X)\"<br>\n  lemma shows \"fixF.HE F0\"<br>\n    proof (... using HE ...) qed</p>\n<p>If we interpret locale HEv0 with some actual FF and vv, we get a<br>\ncontext where F is interpreted by FF, v is interpreted by vv, and</p>\n<p>\"fixF.HE (%X. if ... then vv else FF X)\"</p>\n<p>is a theorem.  This is as expected.  But we have proved that given FF<br>\n(with property HE) and vv then (%X. if ... then vv else FF X)<br>\nis a good interpretation of locale HE.</p>\n<p>Is there a locale expression (?) that when interpreted with with FF<br>\nand vv, gives the context of HE interpreted with (%X. if ... then vv <br>\nelse FF X)?  (Maybe using a \"where\" clause?)</p>\n<p>Thanks,<br>\nRandy<br>\n</p>\n</blockquote>",
        "id": 294081590,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830860
    },
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nHi,</p>\n<p>I want to use the locale \"preorder\" from HOL Main.  First I try<br>\nto see the locale predicate for \"preorder\", as described in the<br>\nlocales tutorial:</p>\n<p>thm preorder_def<br>\n   (*** Unknown fact \"preorder_def\" (line 3 of ...</p>\n<p>What is my misunderstanding?</p>\n<p>Next, I define a locale:</p>\n<p>locale funny =<br>\n    p1: preorder where<br>\n    less_eq = p1le and less = p1lt<br>\n    for p1le::\"'a =&gt; 'a =&gt; bool\"<br>\n    and p1lt::\"'a =&gt; 'a =&gt; bool\"<br>\n   +<br>\n    fixes p2le:: \"nat =&gt; 'a =&gt; 'a\"<br>\n    and p2lt:: \"nat =&gt; 'a =&gt; 'a\"<br>\n    assumes p2leAx: \"\\forall n. preorder p2le p2lt\"</p>\n<p>Note the use of the (first class) locale predicate in assumption<br>\np2leAx.  My intension is that this locale has one carrier ('a), a<br>\npreorder on that carrier (p1) and a family of preorders indexed<br>\nby naturals (p2le), also on the same carrier.  Since I don't know<br>\nhow to include a family of locales in a locale definition, I use<br>\nthe first class locale predicate.  Is there a better way to<br>\nconstruct this structure?</p>\n<p>When isabelle checks this locale \"funny\" it says:</p>\n<p>### Additional type variable(s) in locale specification \"funny\": 'b</p>\n<p>What does that mean?  It seems to come from the use of<br>\nthe \"preorder\" locale predicate in assumption \"p2leAx\", but I've<br>\nbeen explicit about the instantiation of \"preorder\"?</p>\n<p>Finally, the context \"preorder\" contains some definitions and<br>\nlemmas outside the original locale definition of \"preorder\".<br>\n(E.g. in the context preorder I define the symmetric closure of<br>\nless_eq, and prove that is an equivalence.)  Can I access those<br>\ndefinitions and lemmas for the preorder \"p2le\" in my example?</p>\n<p>Thanks for any help,<br>\nRandy</p>",
        "id": 294163386,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854059
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Randy,</p>\n<blockquote>\n<p>I want to use the locale \"preorder\" from HOL Main.<br>\npreorder is primarily a type class. Every type class has an associated locale, <br>\nfor which the naming conventions differ a bit: Some names need to be prefixed <br>\nwith \"class.\".</p>\n</blockquote>\n<blockquote>\n<p>thm preorder_def<br>\n    (*** Unknown fact \"preorder_def\" (line 3 of ...<br>\nthm class.preorder_def is what you want.</p>\n</blockquote>\n<blockquote>\n<p>Next, I define a locale:</p>\n<p>locale funny =<br>\n     p1: preorder where<br>\n     less_eq = p1le and less = p1lt<br>\n     for p1le::\"'a =&gt;  'a =&gt;  bool\"<br>\n     and p1lt::\"'a =&gt;  'a =&gt;  bool\"<br>\n    +<br>\n     fixes p2le:: \"nat =&gt;  'a =&gt;  'a\"<br>\n     and p2lt:: \"nat =&gt;  'a =&gt;  'a\"<br>\n     assumes p2leAx: \"\\forall n. preorder p2le p2lt\"<br>\nThe declaration has 3 flaws:</p>\n</blockquote>\n<ol>\n<li>\n<p>As preorder is a type class, the corresponding predicate from the locale <br>\nassumptions is \"class.preorder\", not preorder. In the above form, preorder in <br>\np2leAx is a free variable that is quantified over. Although the locale itself is <br>\ncalled preorder without prefix!</p>\n</li>\n<li>\n<p>When you replace \"preorder\" with \"class.preorder\" in p2leAx, Isabelle now <br>\ngenerates a type error, which guides you to the second issue: The quantifier <br>\nover n is vacuous because n does not appear inside the quantifier. Hence, type <br>\ninference computes a type 'b for n, which does not occur among the parameters. <br>\nHence, the warning about additional type variables.</p>\n</li>\n<li>\n<p>The type for p2le and p2lt are wrong, they should be \"nat =&gt; 'a =&gt; 'a =&gt; bool\"</p>\n</li>\n</ol>\n<p>Here's the declaration you want:</p>\n<p>locale funny =<br>\n   p1: preorder where<br>\n     less_eq = p1le and less = p1lt<br>\n   for p1le::\"'a =&gt; 'a =&gt; bool\"<br>\n   and p1lt::\"'a =&gt; 'a =&gt; bool\"<br>\n   +<br>\n   fixes p2le:: \"nat =&gt; 'a =&gt; 'a =&gt; bool\"<br>\n   and p2lt:: \"nat =&gt; 'a =&gt; 'a =&gt; bool\"<br>\n   assumes p2leAx: \"class.preorder (p2le n) (p2lt n)\"</p>\n<p>Note that you can drop the quantifier on n, because locale declarations <br>\nimplicitly quantify universally over all free variables in the assumptions.</p>\n<blockquote>\n<p>Is there a better way to construct this structure?<br>\nNo, this is the canonical way, see also this thread:<br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-March/msg00005.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-March/msg00005.html</a></p>\n</blockquote>\n<blockquote>\n<p>Finally, the context \"preorder\" contains some definitions and<br>\nlemmas outside the original locale definition of \"preorder\".<br>\n(E.g. in the context preorder I define the symmetric closure of<br>\nless_eq, and prove that is an equivalence.)  Can I access those<br>\ndefinitions and lemmas for the preorder \"p2le\" in my example?<br>\nYou first have to make funny a sublocale of preorder as follows:</p>\n</blockquote>\n<p>sublocale funny &lt; p2!: preorder \"p2le n\" \"p2lt n\" for n by(rule p2leAx)</p>\n<p>The \"p2!\" determines the prefix to be used. For example:</p>\n<p>context funny begin<br>\nthm p2.less_asym</p>\n<p>Andreas</p>",
        "id": 294163421,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854070
    }
]