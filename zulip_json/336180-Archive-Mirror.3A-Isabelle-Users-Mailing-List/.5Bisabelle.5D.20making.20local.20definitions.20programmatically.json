[
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<p>I must confess the qualification conventions appear to me also a<br>\nlittle bit obscure.  Generally, most times it is preferable to store<br>\nthe logical entities stemming from definitions etc. in separate<br>\ntables for later usage.</p>\n</blockquote>\n<p>Dear Florian,</p>\n<p>Thanks for your help with this; my code now works.</p>\n<p>As for this last point, I thought that I would do as you suggest (keep<br>\ntrack of what is returned by LocalTheory.define), but if you check<br>\nwhat it does, you don't actually get a Const back.  Instead, the term<br>\nreturned is a Free, with an unqualified name.</p>\n<p>So this doesn't seem to be so helpful.  (Perhaps I could take the <br>\ndefining theorem apart....)</p>\n<p>Michael.</p>",
        "id": 294058840,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822721
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Michael,</p>\n<blockquote>\n<p>As for this last point, I thought that I would do as you suggest (keep<br>\ntrack of what is returned by LocalTheory.define), but if you check<br>\nwhat it does, you don't actually get a Const back.  Instead, the term<br>\nreturned is a Free, with an unqualified name.</p>\n</blockquote>\n<p>Concerning this, recall the following:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>locale L =<br>\n  fixes c0 :: \"'a \\&lt;Rightarrow&gt; 'a\"<br>\nbegin</p>\n<p>ML {*<br>\nfun def lthy =<br>\n  let<br>\n    val ((t, _), lthy') = LocalTheory.define Thm.definitionK<br>\n      ((\"c1\", NoSyn), ((\"\", []), @{term \"\\&lt;lambda&gt;x. c0 (c0 x)\"})) lthy;<br>\n    val lthy'' = LocalTheory.restore lthy';<br>\n    val t' = Morphism.term (ProofContext.export_morphism lthy' lthy'') t;<br>\n  in (t', lthy'') end;<br>\n*}</p>\n<p>ML {*<br>\nContext.&gt;&gt;&gt; (Context.map_proof_result def)<br>\n*}</p>\n</blockquote>\n</blockquote>\n<p>Definitions in local theories accumulate a hypothetical proof context.<br>\nIf you want to return to the plain local theory, you can leave the<br>\nhypothetical proof context using LocalTheory.restore and export logical<br>\nentities (theorems, terms, types, ...) using an appropriate export<br>\nmorphism which calcuates the difference between the hypothetical proof<br>\ncontext lthy' and the restored plain local theory lthy''.</p>\n</blockquote>\n<p>This approach refrains from assuming anything about a particular naming<br>\npolicy.</p>\n<p>Hope this helps,</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/0PPqlQraBypBhsiZcfMadSpf/florian.haftmann.vcf\">florian.haftmann.vcf</a><br>\n<a href=\"/user_uploads/14278/4V2G3VQorFpv21FAOHvjY6Aq/signature.asc\">signature.asc</a></p>",
        "id": 294058854,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822730
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<p>Concerning this, recall the following:</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>locale L =<br>\n  fixes c0 :: \"'a \\&lt;Rightarrow&gt; 'a\"<br>\nbegin</p>\n<p>ML {*<br>\nfun def lthy =<br>\n  let<br>\n    val ((t, _), lthy') = LocalTheory.define Thm.definitionK<br>\n      ((\"c1\", NoSyn), ((\"\", []), @{term \"\\&lt;lambda&gt;x. c0 (c0 x)\"})) <br>\nlthy;<br>\n    val lthy'' = LocalTheory.restore lthy';<br>\n    val t' = Morphism.term (ProofContext.export_morphism lthy' <br>\nlthy'') t;<br>\n  in (t', lthy'') end;<br>\n*}</p>\n<p>ML {*<br>\nContext.&gt;&gt;&gt; (Context.map_proof_result def)<br>\n*}</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>This approach refrains from assuming anything about a particular<br>\nnaming policy.</p>\n</blockquote>\n<p>Ah yes.  If I call LocalTheory.restore, I guess I still have to later<br>\ncall LocalTheory.exit.  Is that right?</p>\n<p>And another thing: a while back Makarius said that we should avoid all<br>\nfunctions that implicitly manipulate references because these are<br>\nunsafe in the presence of threads.  Yet it is clear that Context.&gt;&gt;&gt;<br>\nmust be doing this.  Is this function an exception to the general rule?</p>\n<p>Thanks,<br>\nMichael.</p>",
        "id": 294058864,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822733
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Michael,</p>\n<p>It is helpful to recall the local theory sandwich:</p>\n<p>hypothetical proof context (ctxt)<br>\n    ---------------------------------<br>\n        local theory               (lthy)<br>\n        ---------------------------------<br>\n        background theory          (thy)</p>\n<p>An lthy is \"put on top\" of a thy e.g. by means of LocalTheory.init.<br>\nLocalTheory.define etc. than accumulate hypothetical entities, resulting<br>\nin the hypothetical context ctxt.  If necessary, you can \"switch back\"<br>\nto lthy by LocalTheory.restore.  Since LocalTheory.define etc. extend<br>\nthy, linearity has to be ensured - Local.Theory.exit re-exposed the<br>\n\"backbone\" theory thy.</p>\n<p>So much to say about this part of the story.</p>\n<p>Now concerning Context.&gt;&gt;(&gt;).  These are the <em>only</em> remaining facilities<br>\nwhich update a context destructively;  in a certain fashion they are the<br>\nsinbin where the (rare) cases when a destructive update is unaviodable<br>\nare focused.  The runtime framework asserts that concurrent threads do<br>\nnot interfere here.  Of course the best thing is to adhere to explicit<br>\npure updates, but for bootstrap, legacy or explorative issues this<br>\nfacility is helpful.</p>\n<p>Hope this helps</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/wpxFunMf75bwezt7Pbx1zvnj/florian.haftmann.vcf\">florian.haftmann.vcf</a><br>\n<a href=\"/user_uploads/14278/q97DWOVpwAxT_AzhKeRXaiI5/signature.asc\">signature.asc</a></p>",
        "id": 294058876,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660822740
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nI have a locale L with some number of fixes, f1, f2 and f3, say.</p>\n<p>Using LocalTheory.define, I have defined a number of constants in that<br>\nlocale with eqns</p>\n<p>C1 == rhs1<br>\n   C2 == rhs2</p>\n<p>some, none or all of the rhs-es may refer to the fixes.  Say each of<br>\nC1 and C2 is of type nat.</p>\n<p>Subsequently, in the same locale, I want to define a function of the<br>\nform</p>\n<p>select b == if b then C1 else C2</p>\n<p>I want to build the right-hand side for this definition in ML.</p>\n<p>What do I put into the conditional term in the place of C1 and C2?</p>\n<p>It would be nice if I could just write</p>\n<p>Const(\"C1\", nat)</p>\n<p>and</p>\n<p>Const(\"C2\", nat)</p>\n<p>But I guess this won't work, because C1 probably really has a type<br>\nthat depends on the fixes that appear in rhs1, and likewise C2.<br>\nI.e., at the top level, if I do the Isar command</p>\n<p>term \"L.C1\"</p>\n<p>I may see that it really has type \"fixtype1 =&gt; nat\", and L.C2 may have<br>\ntype \"fixtype1 =&gt; fixtype2 =&gt; nat\".</p>\n<p>So, what do I do?</p>\n<p>Michael.</p>",
        "id": 294059848,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823150
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Michael,</p>\n<p>the best thing is to use the \"check\" interface which does the job for you:</p>\n<p>Syntax.check_term @{context} (Const (\"local.C1\", dummyT))</p>\n<p>yield a completely inferred and expanded term representing the local<br>\nconstant C1.  This saves you from educated guesses what the expanded<br>\nfoundation term of a local constant actually is.  Note that \"check\" is a<br>\npart of the canonical interface for reading terms:</p>\n<p>a) \"parse\" transforms a string to an abstract term representation<br>\n(without further steps like type inference, expanding local constants etc)<br>\nb) \"check\" does the rest</p>\n<p>This allows to aggregate \"skeleton terms\" with dummy types and check<br>\nthem to get complete internal terms.</p>\n<p>Example:</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>locale L =<br>\n  fixes c0 :: \"'a \\&lt;Rightarrow&gt; 'a\"<br>\nbegin</p>\n<p>definition<br>\n  \"c1 x = c0 (c0 x)\"</p>\n<p>definition<br>\n  \"c2 x = c1 (c1 x)\"</p>\n<p>ML {* Syntax.parse_term @{context} \"c1\" *}<br>\nML {* Syntax.check_term @{context} (Const (\"local.c1\", dummyT)) *}</p>\n<p>end</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/zXvbbPR6x2ARWWl-ZDupNDPo/signature.asc\">signature.asc</a></p>",
        "id": 294059868,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823161
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<p>the best thing is to use the \"check\" interface which does the job<br>\nfor you:</p>\n</blockquote>\n<blockquote>\n<p>Syntax.check_term @{context} (Const (\"local.C1\", dummyT))</p>\n</blockquote>\n<blockquote>\n<p>yield a completely inferred and expanded term representing the local<br>\nconstant C1.  This saves you from educated guesses what the expanded<br>\nfoundation term of a local constant actually is.  Note that \"check\"<br>\nis a part of the canonical interface for reading terms [...]</p>\n</blockquote>\n<blockquote>\n<p>This allows to aggregate \"skeleton terms\" with dummy types and check<br>\nthem to get complete internal terms.</p>\n</blockquote>\n<blockquote>\n<p>Example:</p>\n</blockquote>\n<blockquote>\n<p>locale L =<br>\n  fixes c0 :: \"'a \\&lt;Rightarrow&gt; 'a\"<br>\nbegin</p>\n<p>definition<br>\n  \"c1 x = c0 (c0 x)\"</p>\n<p>definition<br>\n  \"c2 x = c1 (c1 x)\"</p>\n<p>ML {* Syntax.parse_term @{context} \"c1\" *}<br>\nML {* Syntax.check_term @{context} (Const (\"local.c1\", dummyT)) *}</p>\n</blockquote>\n<blockquote>\n<p>end</p>\n</blockquote>\n<p>But can I then pass an expanded term, one which mentions the implicit<br>\nlocale parameters explicitly, to LocalTheory.define?  My experiments<br>\nsuggest I can't.</p>\n<p>If I put this into the locale</p>\n<p>ML {* val t = Syntax.check_term @{context} (Const(\"local.c1\", dummyT))<br>\n       val ctxt' = LocalTheory.define Thm.definitionK<br>\n                                      ((\"c3\", NoSyn), ((\"\", []), t))<br>\n                                      @{context}<br>\n*}</p>\n<p>then I get an error \"Illegal application of command \"consts\" in local<br>\ntheory mode\".  What should t be to make this definition work?  Or<br>\nshould I be using some other definitional principle?</p>\n<p>And is prepending \"local.\" the canonical way to get an acceptable name<br>\nfor the locale's constants?</p>\n<p>Michael.</p>",
        "id": 294060017,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823218
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Michael,</p>\n<p>Which Isabelle version are you using?  The following works fine with<br>\nIsabelle2007:</p>\n<p>locale L =<br>\n  fixes c0 :: \"'a ï¿½ 'a\"<br>\nbegin</p>\n<p>definition<br>\n  \"c1 x = c0 (c0 x)\"</p>\n<p>definition<br>\n  \"c2 x = c1 (c1 x)\"</p>\n<p>ML {*<br>\nval t = Syntax.check_term @{context} (Const (\"local.c1\", dummyT))<br>\n*}</p>\n<p>ML {* val (_, ctxt') = LocalTheory.define Thm.definitionK ((\"c3\",<br>\nNoSyn), ((\"\", []), t)) @{context} *}</p>\n<p>Recently it is now also possible to transform a local context (a local<br>\ntheory) with ML, using the Context.&gt;&gt; and Context.&gt;&gt;&gt; combinators within<br>\nML sections:</p>\n<p>locale L =<br>\n  fixes c0 :: \"'a \\&lt;Rightarrow&gt; 'a\"<br>\nbegin</p>\n<p>definition<br>\n  \"c1 x = c0 (c0 x)\"</p>\n<p>definition<br>\n  \"c2 x = c1 (c1 x)\"</p>\n<p>ML_val {*<br>\nval t = Syntax.check_term @{context} (Const (\"local.c1\", dummyT))<br>\n*}</p>\n<p>ML {*<br>\nContext.&gt;&gt;&gt; (Context.map_proof_result (<br>\n  LocalTheory.define Thm.definitionK ((\"c3\", NoSyn), ((\"\", []), t))<br>\n  ##&gt; LocalTheory.restore<br>\n))<br>\n*}</p>\n<p>ML {* @{term c3} *}<br>\nthm c3_def</p>\n<p>end</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/AkVhY7XvZKXBL9DRupjG0Ubp/florian.haftmann.vcf\">florian.haftmann.vcf</a><br>\n<a href=\"/user_uploads/14278/LcQQgF_Qkh0WCQhAu060XYWj/signature.asc\">signature.asc</a></p>",
        "id": 294060028,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823224
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>ML {* val t = Syntax.check_term @{context} (Const(\"local.c1\", dummyT))<br>\n      val ctxt' = LocalTheory.define Thm.definitionK<br>\n                                     ((\"c3\", NoSyn), ((\"\", []), t))<br>\n                                     @{context}<br>\n*}</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Which Isabelle version are you using?  The following works fine with<br>\nIsabelle2007 [...]</p>\n</blockquote>\n<p>I just tried it again; and now it works.  This is very strange, but<br>\nI'll assume I messed up my previous experiment.  Thanks for your help!</p>\n<p>Michael.</p>",
        "id": 294060045,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823236
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nA further hint I want to add:  LocalTheory.define etc. return the<br>\ndefined entity as a term.  Normally it is the best to use these directly<br>\nto build up other definitions, lemmas etc.  This saves you from<br>\nreferring to suspected names of constants altogether.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/ZAhU4DOyYaFrHgkaOZjC7kIp/florian.haftmann.vcf\">florian.haftmann.vcf</a><br>\n<a href=\"/user_uploads/14278/6gKGCm7R05RcK2H8KEtqmNyn/signature.asc\">signature.asc</a></p>",
        "id": 294060055,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823243
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<p>A further hint I want to add: LocalTheory.define etc. return the<br>\ndefined entity as a term.  Normally it is the best to use these<br>\ndirectly to build up other definitions, lemmas etc.  This saves you<br>\nfrom referring to suspected names of constants altogether.</p>\n</blockquote>\n<p>It seems I have have apply Context.map_proof_result for this to be<br>\nuseful.  If I omit this (as below), then the result includes a term<br>\nthat is a Free (not a Const), with no parameters.</p>\n<hr>\n<p>locale L =<br>\n   fixes c0 :: \"'a =&gt; 'a\"<br>\nbegin</p>\n<p>definition<br>\n   \"c1 x = c0 (c0 x)\"</p>\n<p>definition<br>\n   \"c2 x = c1 (c1 x)\"</p>\n<p>ML {*<br>\nval t = Syntax.check_term @{context} (Const (\"local.c1\", dummyT))<br>\n*}</p>\n<p>ML {* val (result, ctxt') = LocalTheory.define Thm.definitionK ((\"c3\",<br>\nNoSyn), ((\"\", []), t)) @{context} *}</p>\n<p>end</p>\n<hr>\n<p>Michael.</p>",
        "id": 294060196,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823305
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nMichael Norrish wrote:</p>\n<blockquote>\n<p>Florian Haftmann wrote:</p>\n<blockquote>\n<p>A further hint I want to add: LocalTheory.define etc. return the<br>\ndefined entity as a term.  Normally it is the best to use these<br>\ndirectly to build up other definitions, lemmas etc.  This saves you<br>\nfrom referring to suspected names of constants altogether.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>It seems I have have apply Context.map_proof_result for this to be<br>\nuseful.  If I omit this (as below), then the result includes a term<br>\nthat is a Free (not a Const), with no parameters.</p>\n</blockquote>\n<p>It seems I was confused.  Context.map_proof_result is no use.<br>\nWhatever I do, LocalTheory.define doesn't return anything other than<br>\nan unadorned Free.</p>\n<p>It seems that if I want to refer to other local constants, I should<br>\nconstruct a</p>\n<p>Const(\"local.\" ^ myconstname, dummyT)</p>\n<p>and then Syntax.check it.</p>\n<p>Is this best practice?</p>\n<p>Michael.</p>",
        "id": 294060204,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823310
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Michael,</p>\n<p>Definitions in local theories accumulate a hypothetical proof context.<br>\nIf you want to return to the plain local theory, you can leave the<br>\nhypothetical proof context using LocalTheory.restore and export logical<br>\nentities (theorems, terms, types, ...) using an appropriate export<br>\nmorphism which calcuates the difference between the hypothetical proof<br>\ncontext lthy' and the restored plain local theory lthy''.</p>\n<p>Anyway, it is also possible (and most times more convenient) to<br>\n<em>continue</em> within the hypothetical context with defines, notes etc.<br>\nThese are exported into the local theory context implicitly without<br>\nfurther ado.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/NRmGhAPRqS2kUF-E1nxCeLVY/signature.asc\">signature.asc</a></p>",
        "id": 294060216,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823317
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<p>Definitions in local theories accumulate a hypothetical proof<br>\ncontext.  If you want to return to the plain local theory, you can<br>\nleave the hypothetical proof context using LocalTheory.restore and<br>\nexport logical entities (theorems, terms, types, ...) using an<br>\nappropriate export morphism which calcuates the difference between<br>\nthe hypothetical proof context lthy' and the restored plain local<br>\ntheory lthy''.</p>\n</blockquote>\n<p>I need to make definitions inside a locale that I have set up<br>\nprogrammatically.  Within that program, I can't do nice things like<br>\n@{term \"...localeconst....\"}  (as in your example), because the<br>\ncode doing this is not itself in a locale.</p>\n<p>Here's a specific question about check_term.</p>\n<p>If I have a theory fragment of the following form:</p>\n<hr>\n<p>theory Scratch<br>\n   imports Main<br>\nbegin</p>\n<p>locale L =<br>\n   fixes x :: nat<br>\nbegin<br>\n   definition \"y = x + 3\"<br>\nend</p>\n<p>term L.y<br>\nthm L.y_def</p>\n<p>ML {*<br>\n   val lthy = TheoryTarget.init (SOME \"Scratch.L\")<br>\n                                (Context.deref @{theory_ref})<br>\n   val t = Syntax.check_term lthy (Const(&lt;string&gt;, dummyT))<br>\n*}</p>\n<hr>\n<p>The only way I can avoid an \"unknown const\" error is to have</p>\n<p>&lt;string&gt; = \"Scratch.L.y\"</p>\n<p>I thought the point of check_term was that I could have \"local.y\"<br>\nthere, and have it work.  Have I set up my lthy local_theory value<br>\nincorrectly?</p>\n<p>(In my simple example, I recognise that I could also write</p>\n<p>&lt;string&gt; = @{const_name \"L.y\"}</p>\n<p>This is <em>no</em> use in my real circumstances, where the locale L has been<br>\nset up in code, so there is no fixed string \"L.y\" I could provide to<br>\n@{const_name}.  Indeed, both the \"L\" and the \"y\" are constructed<br>\nstrings in my code.)</p>\n<p>Michael.</p>",
        "id": 294060228,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823328
    },
    {
        "content": "<p>From: Simon Winwood &lt;<a href=\"mailto:sjw@cse.unsw.edu.au\">sjw@cse.unsw.edu.au</a>&gt;<br>\nThis works for me:</p>\n<p>ML {*<br>\n   val lthy = TheoryTarget.init (SOME \"Scratch.L\") (Context.deref @{theory_ref})  <br>\n   val t = Syntax.check_term lthy (Const(LocalTheory.full_name lthy \"y\", dummyT))<br>\n*}</p>\n<p>I guess that check_term doesn't expand the name it is given.  <br>\nThat first line is ugly, better (IMHO) is:</p>\n<p>val lthy = TheoryTarget.context \"L\" @{theory}</p>\n<p>Simon</p>\n<p>At Tue, 29 Apr 2008 16:39:39 +1000,<br>\nMichael Norrish wrote:</p>\n<blockquote>\n<p>Florian Haftmann wrote:<br>\n[...]</p>\n<p>I need to make definitions inside a locale that I have set up<br>\nprogrammatically.  Within that program, I can't do nice things like<br>\n@{term \"...localeconst....\"}  (as in your example), because the<br>\ncode doing this is not itself in a locale.</p>\n<p>Here's a specific question about check_term.</p>\n<p>If I have a theory fragment of the following form:</p>\n<hr>\n<p>theory Scratch<br>\n   imports Main<br>\nbegin</p>\n<p>locale L =<br>\n   fixes x :: nat<br>\nbegin<br>\n   definition \"y = x + 3\"<br>\nend</p>\n<p>term L.y<br>\nthm L.y_def</p>\n<p>ML {*<br>\n   val lthy = TheoryTarget.init (SOME \"Scratch.L\")<br>\n                                (Context.deref @{theory_ref})<br>\n   val t = Syntax.check_term lthy (Const(&lt;string&gt;, dummyT))<br>\n*}</p>\n<hr>\n<p>The only way I can avoid an \"unknown const\" error is to have</p>\n<p>&lt;string&gt; = \"Scratch.L.y\"</p>\n<p>I thought the point of check_term was that I could have \"local.y\"<br>\nthere, and have it work.  Have I set up my lthy local_theory value<br>\nincorrectly?</p>\n<p>(In my simple example, I recognise that I could also write</p>\n<p>&lt;string&gt; = @{const_name \"L.y\"}</p>\n<p>This is <em>no</em> use in my real circumstances, where the locale L has been<br>\nset up in code, so there is no fixed string \"L.y\" I could provide to<br>\n@{const_name}.  Indeed, both the \"L\" and the \"y\" are constructed<br>\nstrings in my code.)</p>\n<p>Michael.<br>\n</p>\n</blockquote>",
        "id": 294060256,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823347
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Michael,</p>\n<p>a possibility to get the internal (fully qualified) identifier of a<br>\nconstant is to lookup the constant table explicitly, as done here in<br>\nline \"val c = ...\":</p>\n<p>theory Scratch<br>\nimports Main<br>\nbegin</p>\n<p>locale L =<br>\n  fixes n :: nat<br>\nbegin</p>\n<p>definition \"m = n + 3\"</p>\n<p>end</p>\n<p>ML {*<br>\nval lthy = TheoryTarget.init (SOME \"Scratch.L\") @{theory};<br>\nval c = Consts.intern (ProofContext.consts_of lthy) \"m\";<br>\nval t = Syntax.check_term lthy (Const (c, dummyT));<br>\n*}</p>\n<p>The subsequent check_term internalizes the abbreviation etc.</p>\n<p>I must confess the qualification conventions appear to me also a little<br>\nbit obscure.  Generally, most times it is preferable to store the<br>\nlogical entities stemming from definitions etc. in separate tables for<br>\nlater usage.</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/G-qs-TmsDxIW6YlLddm9p2kr/florian.haftmann.vcf\">florian.haftmann.vcf</a><br>\n<a href=\"/user_uploads/14278/SdlbHPQ7D_d2APUpp74PM-14/signature.asc\">signature.asc</a></p>",
        "id": 294060270,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823353
    }
]