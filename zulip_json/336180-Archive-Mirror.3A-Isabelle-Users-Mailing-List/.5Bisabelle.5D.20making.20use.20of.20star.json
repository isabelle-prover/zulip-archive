[
    {
        "content": "<p>From: James Smith &lt;<a href=\"mailto:jecs@imperial.ac.uk\">jecs@imperial.ac.uk</a>&gt;<br>\nGood afternoon,</p>\n<p>this is the first of several neophyte questions I suspect...</p>\n<p>I've defined reflexive transitive closure...</p>\n<p>theory rtc</p>\n<p>imports Main</p>\n<p>begin</p>\n<p>inductive star :: \"('a =&gt; 'a =&gt; bool) =&gt; ('a =&gt; 'a =&gt; bool)\" for r where</p>\n<p>base: \"star r x x\" |</p>\n<p>step: \"r x y ==&gt; ( star r y z ==&gt; star r x z )\"</p>\n<p>end</p>\n<p>...and now want to apply this to a successor function I have on states...</p>\n<p>definition succ :: \"State =&gt; State =&gt; bool\" </p>\n<p>where \"( succ x y ) \\&lt;equiv&gt; ( index x = Suc(index y) )\"</p>\n<p>...where states are just records with an index field and other non<br>\ninterfering fields:</p>\n<p>record State = </p>\n<p>index :: nat</p>\n<p>...</p>\n<p>My successor function works fine. If I instantiate a few states with the<br>\nobvious indeces I get, for example...</p>\n<p>value \"succ state_1 state_0\"</p>\n<p>...returning true, whereas</p>\n<p>value \"succ state_2 state_0\"</p>\n<p>returns false.</p>\n<p>I (somewhat naively, it turns out) expected that...</p>\n<p>value \"star succ state_2 state_0\"</p>\n<p>..would return true, but it returns:</p>\n<p>\"star (\\&lt;lambda&gt; u ua. Index = Suc( index ua)) (| index = Suc( Suc 0), ...\\)<br>\n(| index = 0, ...|)\"</p>\n<p>My Coq colleagues in the room aren't suprised and tell me that my definition<br>\nof star is just that, and doesn't provide a way to actually compute the<br>\ntransitive closure. Also, I note that if I do...</p>\n<p>value \"succ\"</p>\n<p>...I get \"_\", which I take to mean \"some value\", whereas if I do...</p>\n<p>value \"star\"</p>\n<p>...I just get \"star\", which I suspect has something to do with it.</p>\n<p>Can anyone tell me what is going wrong and how to fix it?</p>\n<p>Many thanks,</p>\n<p>James</p>",
        "id": 294161738,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853386
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 21/06/2012 14:31, schrieb James Smith:</p>\n<blockquote>\n<p>Good afternoon,</p>\n<p>this is the first of several neophyte questions I suspect...<br>\nI've defined reflexive transitive closure...</p>\n<p>theory rtc<br>\nimports Main<br>\nbegin</p>\n<p>inductive star :: \"('a =&gt; 'a =&gt; bool) =&gt; ('a =&gt; 'a =&gt; bool)\" for r where<br>\nbase: \"star r x x\" |<br>\nstep: \"r x y ==&gt; ( star r y z ==&gt; star r x z )\"</p>\n<p>end</p>\n<p>...and now want to apply this to a successor function I have on states...</p>\n<p>definition succ :: \"State =&gt; State =&gt; bool\" </p>\n<p>where \"( succ x y ) \\&lt;equiv&gt; ( index x = Suc(index y) )\"</p>\n<p>...where states are just records with an index field and other non<br>\ninterfering fields:</p>\n<p>record State = <br>\n  index :: nat</p>\n<p>I (somewhat naively, it turns out) expected that...</p>\n<p>value \"star succ state_2 state_0\"</p>\n<p>..would return true, but it returns:</p>\n<p>\"star (\\&lt;lambda&gt; u ua. Index = Suc( index ua)) (| index = Suc( Suc 0), ...\\)<br>\n(| index = 0, ...|)\" </p>\n<p>My Coq colleagues in the room aren't suprised and tell me that my definition<br>\nof star is just that, and doesn't provide a way to actually compute the<br>\ntransitive closure.</p>\n</blockquote>\n<p>They are wrong. Isabelle (in contrast to Coq) can often execute inductive<br>\ndefinitions. Hence your expectation makes sense. However, there are several<br>\ndifficulties with the way you have phrased your definitions:</p>\n<ol>\n<li>You need to say</li>\n</ol>\n<p>code_pred start .</p>\n<p>in order to generate code for star (or any inductive predicate).</p>\n<ol start=\"2\">\n<li>\n<p>star is higher order. This complicates code generation to the point that it<br>\ndoes not work for the situation where all arguments of \"star r\" are inputs. If<br>\nyou fix r in the defn of star, it works better. But let's assume we stick with<br>\nyour star.</p>\n</li>\n<li>\n<p>What your defn of star will still allow us to do is to translate it into a<br>\nProlog-like enumeration of all y such that \"star r x y\" for some given r and x.<br>\nThis means not a single value but a set of values will be computed. The syntax is</p>\n</li>\n</ol>\n<p>values \"{y. star succ state_0 y}\"</p>\n<ol start=\"4\">\n<li>This does still not quite work because \"succ\" is not defined in a manner that<br>\nthe second argument can be computed from the first. It needs to be an inductive<br>\ndefinition</li>\n</ol>\n<p>inductive succ :: \"State =&gt; State =&gt; bool\"<br>\nwhere \"y = x(|index := Suc(index x)|) ==&gt; succ x y\"</p>\n<p>code_pred succ .</p>\n<ol start=\"5\">\n<li>Now the above values command does not terminate because there are infinitely<br>\nmany successor states. You can look at the first 3 states like this:</li>\n</ol>\n<p>values 3 \"{y. star succ state_0 y}\"</p>\n<p>Happy?</p>\n<ol start=\"6\">\n<li>The way you have written star makes it unsuitable for computing predecessors<br>\nfrom successors: values 3 \"{x. star succ x state_2}\" will not terminate because<br>\nstar will call itself recursively forever without getting to a call of succ.</li>\n</ol>\n<p>For an impressive example of what code generation for inductive predicates can<br>\ndo see  A. Lochbihler, L. Bulwahn : Animating the Formalised Semantics of a<br>\nJava-like Language. ITP 2011<br>\n<a href=\"http://pp.info.uni-karlsruhe.de/personhp/andreas_lochbihler.php\">http://pp.info.uni-karlsruhe.de/personhp/andreas_lochbihler.php</a></p>\n<blockquote>\n<p>Also, I note that if I do...</p>\n<p>value \"succ\"</p>\n<p>...I get \"_\", which I take to mean \"some value\", whereas if I do...</p>\n<p>value \"star\"</p>\n<p>...I just get \"star\", which I suspect has something to do with it.<br>\n</p>\n</blockquote>\n<p>This is the result of the fact that \"normal\" definitions and inductive ones are<br>\nexecuted by different mechanisms.</p>\n<p>Tobias</p>\n<p>PS I have take the liberty to remove most of the blank lines from your email.</p>\n<blockquote>\n<p>Many thanks,</p>\n<p>James</p>\n</blockquote>",
        "id": 294161903,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853438
    },
    {
        "content": "<p>From: James Smith &lt;<a href=\"mailto:jecs@imperial.ac.uk\">jecs@imperial.ac.uk</a>&gt;<br>\nTobias, hi,</p>\n<p>many thanks for your reply. I understand now that you don't need to execute<br>\ndefinitions in order to prove things about them. So, for example, the proof<br>\nthat <code>star' is indeed transitive doesn't require </code>code_pred star', but<br>\ncomputing with it does. I find it fascinating that you can compute with<br>\nIsabelle in this way nonetheless.</p>\n<p>More fundamentally, I do not want to create executable code, although I am<br>\ngiving the impression that I do. I am just adjusting to the use of a theorem<br>\nprover after using a model checker. I should be proving things about the<br>\ntypes that I think up, rather than instantiating them. Creating instances of<br>\n<code>State' to confirm that </code>succ star' appears to be transitive is stupid when<br>\nI already have a proof that `star' is transitive without needing to execute<br>\nor indeed instantiate anything.</p>\n<p>As an interesting aside, working with Isabelle in a room full of Coq users<br>\nseems to be working out fine. Those around me get an introduction to basic<br>\nIsabelle syntax amongst other things and I get valuable conversations about<br>\ntheorem proving and types in general.</p>\n<p>Kind regards,</p>\n<p>James</p>",
        "id": 294161928,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853446
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOf course, if you have a proof, there is no need to run test cases to check the<br>\nproperty. But with larger definitions, proofs become expensive enough that a bit<br>\nof rapid prototyping to weed out the most glaring bugs can be quite beneficial.</p>\n<p>Tobias</p>",
        "id": 294161938,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853450
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nExchange of Isabelle and Coq users can indeed be quite interesting to <br>\nlearn more about the specifc strengths and weaknesses of either system, <br>\nalthough there is a substantial overlap.</p>\n<p>BTW, when a Coq user says \"type\" he means \"proposition\" in a more common <br>\nsense, which is also the way Isabelle uses term.  So</p>\n<p>theorem a: A &lt;proof&gt;</p>\n<p>is just a theorem called \"a\" with proposition \"A\", which is proven by the <br>\nincluded proof.  A Coq user would call \"a\" constant and \"A\" type here.</p>\n<p>Anyway, Isabelle also has some terminology that first needs some <br>\ninterpretation to be understandable to other people out there.</p>\n<p>Makarius</p>",
        "id": 294162108,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853523
    },
    {
        "content": "<p>From: James Smith &lt;<a href=\"mailto:jecs@imperial.ac.uk\">jecs@imperial.ac.uk</a>&gt;<br>\nTobias, hi,</p>\n<p>back with Isabelle today...</p>\n<p>Hmm, I've just looked at this again. I think I haven't explained myself well<br>\nand so have been misunderstood. I have my definition of State:</p>\n<hr>\n<p>record State =<br>\n    index :: nat<br>\n    cookies :: \"Cookie set\"</p>\n<hr>\n<p>A cookie is just a string for the time being, and I instantiate one:</p>\n<hr>\n<p>type_synonym Cookie = string<br>\ndefinition c :: Cookie where \"counter=[CHR ''c'']\"</p>\n<hr>\n<p>I also instantiate a few states:</p>\n<hr>\n<p>definition state_0 :: State where \"state_0\\&lt;equiv&gt;(|index=0,cookies={}|)\"<br>\ndefinition state_1 :: State where \"state_1\\&lt;equiv&gt;(|index=1,cookies={c}|)\"<br>\ndefinition state_2 :: State where \"state_2\\&lt;equiv&gt;(|index=2,cookies={c}|)\"</p>\n<hr>\n<p>Now with the succ predicate defined about the following...</p>\n<hr>\n<p>value \"succ state_0 state_1\"</p>\n<hr>\n<p>...returns false and it took me a while to work out why. If I delete the<br>\ncookie from state_1, or, alternatively, add a cookie to state_0, it works.<br>\nThis is because the inductive predicate, as you rightly point out,<br>\ncalculates the second argument from the first, taking x and changing its<br>\nindex to get y. Therefore y is only the successor to x if y agrees in all<br>\nits other fields. But this isn't the required behaviour, y should be the<br>\nsuccessor if its index is one greater, that's all.</p>\n<p>I understand inductive definitions a little better now so I have, for<br>\nexample:</p>\n<hr>\n<p>Inductive succ :: \"nat =&gt; nat =&gt; bool\" where<br>\n\"succ 1 0\" |<br>\n\"succ n m ==&gt; succ (Suc n) (Suc m)</p>\n<hr>\n<p>But how can I get this with states? I have a signature...</p>\n<hr>\n<p>Inductive succ :: \"nat =&gt; nat =&gt; bool\" where<br>\n...</p>\n<hr>\n<p>...but it's not obvious to me how I create a base step without instantiating<br>\nstates, which I don't want to do except for ``testing''. I mean with nat you<br>\nalready have an inductive set to work with, to do induction over, so<br>\ndefining succ n m is easy from there. But with my states I don't have a<br>\nstructure already in place so I can't do induction over it.</p>\n<p>It seems to me I should just use \"State list\", in which case, if I take the<br>\ntime to understand the functionality available with lists, I won't need to<br>\ndefine succ at all.</p>\n<p>Regards,</p>\n<p>James</p>",
        "id": 294163105,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853891
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHi James,</p>\n<p>the relation you want is truly relational, you cannot compute one argument from<br>\nthe other. Prolog can deal with such relations with the help of logical<br>\nvariables and backtracking. Isabelle's execution mechanism does not support<br>\nlogical variables but only backtracking. Thus you would need to enumerate all<br>\nthe possible values of all the other fields, which is infeasible in general.</p>\n<p>Tobias</p>",
        "id": 294163139,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853904
    },
    {
        "content": "<p>From: James Smith &lt;<a href=\"mailto:jecs@imperial.ac.uk\">jecs@imperial.ac.uk</a>&gt;<br>\nHi,</p>\n<p>exactly. My point was that my bad explanation in the first place probably<br>\nled to a belief that computing states was what was required. </p>\n<p>I realised this morning that I'd have to provide my own ``universe'' of all<br>\ninstances of states in order for such calculations to work. </p>\n<p>With type nat you get all the natural numbers to work with. With my type<br>\nState you get the type definition and nothing else.</p>\n<p>Many thanks for all the help. I'll move on to lists now, thankfully!</p>\n<p>Kind regards,</p>\n<p>James</p>",
        "id": 294163145,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853910
    }
]