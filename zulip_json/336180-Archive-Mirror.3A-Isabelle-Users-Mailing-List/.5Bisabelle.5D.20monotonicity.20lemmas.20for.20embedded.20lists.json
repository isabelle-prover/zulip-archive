[
    {
        "content": "<p>From: Peter Sewell &lt;<a href=\"mailto:Peter.Sewell@cl.cam.ac.uk\">Peter.Sewell@cl.cam.ac.uk</a>&gt;<br>\nDear Isabelle developers,</p>\n<p>we have a lot of datatypes with embedded lists, as in the example<br>\nbelow (this is a small example cut down from large (and automatically<br>\ngenerated) examples).  Defining inductive relations over these needs<br>\nsome additional monotonicity lemmas, here \"tmp\" and \"tmp2\".  In<br>\ngeneral we need many analogues to tmp2, all of a similar form, e.g.<br>\n(from a different example):</p>\n<p>lemma tmp7: \"        A &lt;= B   ==&gt; ALL x. (%(l_, p_, T_, D_). (p_, T_, D_) : (%y. Inr (Inr (Inr y))) -` A) x </p>\n<ul>\n<li>--&gt;   (%(l_, p_, T_, D_). (p_, T_, D_) : (%y. Inr (Inr (Inr y))) -` B) x\" by blast</li>\n</ul>\n<p>with different Inr/Inl sequences depending on the structure of the<br>\ndefinitions.  Lemma tmp is key but has a uniform shape, whereas tmp2 and<br>\nits analogues have varying shapes but are solved with blast.</p>\n<p>This suggests to the naive user that if the monotonicity prover just<br>\ntried blast before giving up, we would only need the general lemma<br>\ntmp, making life much simpler.  Is it possible to turn that on?<br>\nAlternatively, is there some smart way to express tmp2 and analogues<br>\nin a uniform way (i.e. as a single lemma) that would be acceptable to<br>\nthe inductive package?  Or we can rephrase the usages of List.list_all<br>\netc if that would help?</p>\n<p>many thanks,<br>\nPeter</p>\n<p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</p>\n<p>theory out imports Main begin</p>\n<p>(** syntax *)<br>\ntypes index = \"nat\"<br>\ndatatype <br>\na = <br>\n   a_unit  <br>\n | a_tuple \"a list\"  <br>\n | a_proj \"a\" \"index\"  </p>\n<p>datatype <br>\nt = <br>\n   t_unit  <br>\n | t_tuple \"t list\"  </p>\n<p>(** definitions *)<br>\n(*defns Jtype *)<br>\nconsts<br>\n  at :: \"(a*t) set\"</p>\n<p>lemma tmp:\"<br>\n        ! x. f x --&gt; g x ==&gt; list_all (%b. b) (map f l_T_list)--&gt;<br>\n                   list_all (%b. b) (map g l_T_list) \"<br>\n  apply(induct_tac l_T_list, auto) done</p>\n<p>lemma tmp2: \"A &lt;= B ==&gt; ALL x. (%(a_, t_). (a_, t_) : A) x --&gt; (%(a_, t_). (a_, <br>\nt_) : B) x\" by blast</p>\n<p>inductive at<br>\nintros</p>\n<p>(* defn at *)</p>\n<p>at_1I: \" ( a_unit , t_unit ) : at\"</p>\n<p>at_2I: \"[|(List.list_all (% b . b) ((<a href=\"http://List.map\">List.map</a> (%(a_,t_). ( a_ , t_ ) : at) a_t_list)))|] ==&gt;<br>\n  ( (a_tuple ((<a href=\"http://List.map\">List.map</a> (%(a_,t_).a_) a_t_list))) , (t_tuple ((<a href=\"http://List.map\">List.map</a> (%(a_,t_) .t_) a_t_list))) ) : at\"</p>\n<p>at_3I: \"[| ( a , (t_tuple (t_list)) ) : at|] ==&gt; <br>\n ( (a_proj a i) , ((%t_ . t_) (List.nth t_list (i))) ) : at\"</p>\n<p>monos tmp tmp2</p>\n<p>end</p>\n<p>------- End of Forwarded Message</p>",
        "id": 294042768,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816036
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nPeter Sewell wrote:</p>\n<blockquote>\n<p>Dear Isabelle developers,</p>\n<p>we have a lot of datatypes with embedded lists, as in the example<br>\nbelow (this is a small example cut down from large (and automatically<br>\ngenerated) examples).  Defining inductive relations over these needs<br>\nsome additional monotonicity lemmas, here \"tmp\" and \"tmp2\".  In<br>\ngeneral we need many analogues to tmp2, all of a similar form, e.g.<br>\n(from a different example):</p>\n<p>lemma tmp7: \"        A &lt;= B   ==&gt; ALL x. (%(l_, p_, T_, D_). (p_, T_, D_) : (%y. Inr (Inr (Inr y))) -<code> A) x \n- --&gt;   (%(l_, p_, T_, D_). (p_, T_, D_) : (%y. Inr (Inr (Inr y))) -</code> B) x\" by blast</p>\n</blockquote>\n<p>Dear Peter,</p>\n<p>one way to tell the monotonicity prover how to deal with abstractions<br>\nover tuples (also known as \"split\") is to add the following equation<br>\nas a monotonicity rule:</p>\n<p>lemma [mono]: \"split f p = f (fst p) (snd p)\" by (simp add: split_def)</p>\n<p>This will just unfold the definition of split during the proof of<br>\nmonotonicity, i.e. the prover should be able to deal with any abstraction<br>\nover n-tuples. As far as the inverse image operator -` is concerned,<br>\nthere already is a monotonicity rule of the form</p>\n<p>A &lt;= B ==&gt; f -<code> A &lt;= f -</code> B</p>\n<p>in the default set of rules used by the monotonicity prover.<br>\nHowever, rather than using the inverse image operator, it seems<br>\neasier to define several inductive sets simultaneously.</p>\n<blockquote>\n<p>lemma tmp:\"<br>\n        ! x. f x --&gt; g x ==&gt; list_all (%b. b) (map f l_T_list)--&gt;<br>\n                   list_all (%b. b) (map g l_T_list) \"</p>\n</blockquote>\n<p>Note that a meta-level quantifier is required in the premise, i.e.<br>\nrule tmp should actually read</p>\n<p>(!! x. f x --&gt; g x) ==&gt; list_all (%b. b) (map f l_T_list)--&gt;<br>\n     list_all (%b. b) (map g l_T_list)</p>\n<p>See section 2.8.3 \"Monotonicity theorems\" in the Isabelle/HOL manual<br>\nfor a description of the different forms of monotonicity rules accepted<br>\nby the inductive definition package.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294042923,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816085
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nSomething related: one should always try to use \"ALL x : set xs. P x\" <br>\nrather than \"list_all P xs\".</p>\n<p>Tobias</p>\n<p>Stefan Berghofer schrieb:</p>",
        "id": 294042933,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816090
    }
]