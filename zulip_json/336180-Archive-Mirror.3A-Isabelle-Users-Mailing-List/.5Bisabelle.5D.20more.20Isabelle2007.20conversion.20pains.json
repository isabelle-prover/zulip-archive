[
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nStefan Berghofer wrote:<br>\nStefan,</p>\n<p>thanks.  But I now find a similar problem: the theorems x.mono, x.unfold <br>\nand x.defs<br>\nseem to have disappeared.  Actually it seems the theorems x.mono, <br>\nx.unfold already don't appear in Isabelle2005 for new-style theory <br>\nfiles, but you could use an old-style theory file, or (sometimes) derive <br>\nx.unfold from x.defs.</p>\n<p>But in Isabelle2007 you can't use an old-style theory file and even <br>\nx.defs doesn't seem to exist.  Where have all these theorems gone?</p>\n<p>Regards,</p>\n<p>Jeremy</p>",
        "id": 294061309,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823794
    },
    {
        "content": "<p>From: <a href=\"mailto:stefan.berghofer@in.tum.de\">stefan.berghofer@in.tum.de</a><br>\nQuoting Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;:</p>\n<p>Dear Jeremy,</p>\n<p>the problem with these rules is that they expose the internal representation<br>\nof inductive sets or predicates, which violates the principle of information<br>\nhiding. Since the internal representation has been changed recently, proofs<br>\nusing these rules would not have worked any longer anyway, so I decided to<br>\nremove them. The 'official' way of proving something about an inductive<br>\ndefinition is to use the introduction, induction and case analysis rules,<br>\nand indeed all proofs using the x.unfold or x.defs rules can easily be<br>\nrewritten to use these 'official' rules.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 294061451,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823843
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\n<a href=\"mailto:berghofe@mailbroy.informatik.tu-muenchen.de\">berghofe@mailbroy.informatik.tu-muenchen.de</a> wrote:<br>\nDear Stefan,</p>\n<p>Thanks for your reply.</p>\n<p>I don't understand what you say about \"violates the principle of <br>\ninformation<br>\nhiding\".  If anything provable using x.unfold or x.defs can be proved <br>\nusing the 'official' rules, then surely the 'official' rules contain (at <br>\nleast) the same information as  x.unfold or x.defs.</p>\n<p>If I can prove x.unfold or x.defs using the 'official' rules, then whay <br>\ncan't they be included in the inductive set package as previously?</p>\n<p>More importantly, may I suggest that it would be good policy on the part <br>\nof the developers to ensure that new developments are made to be <br>\nbackward compatible where possible? </p>\n<p>For about 3 years recently I worked on a particular project where they <br>\ngenerally would use the latest development version of Isabelle.  It <br>\nseems to me that during that time, about half my time on the project was <br>\nspent doing useful work and about half was spent changing my work in <br>\nresponse to changes in Isabelle. </p>\n<p>Now I'm doing different work, with a mass of Isabelle theories which <br>\nwork for Isabelle2005.  If I don't adapt them to Isabelle 2007 (and I <br>\nobviously have a strong incentive not to do so) it means that any <br>\nfurther work I do is in Isabelle2005; this means that if someone else <br>\ndoes similar things in Isabelle2007, neither of us can use each other's <br>\nwork.  This is not a good idea, but it is a natural consequence of the <br>\nsignificant incompatibilities which have often been a consequence of <br>\nrecent developments in Isabelle.</p>\n<p>Regards,</p>\n<p>Jeremy Dawson</p>",
        "id": 294061502,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823862
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nJeremy Dawson wrote:</p>\n<blockquote>\n<p>I don't understand what you say about \"violates the principle of information<br>\nhiding\".  If anything provable using x.unfold or x.defs can be proved <br>\nusing the 'official' rules, then surely the 'official' rules contain (at <br>\nleast) the same information as  x.unfold or x.defs.</p>\n</blockquote>\n<p>Dear Jeremy,</p>\n<p>on Wikipedia (<a href=\"http://en.wikipedia.org/wiki/Information_hiding\">http://en.wikipedia.org/wiki/Information_hiding</a>), I found the<br>\nfollowing definition of \"information hiding\":</p>\n<p>The principle of information hiding is the hiding of design decisions<br>\n   in a computer program that are most likely to change, thus protecting<br>\n   other parts of the program from change if the design decision is changed.<br>\n   The protection involves providing a stable interface which shields the<br>\n   remainder of the program from the implementation (the details that are<br>\n   most likely to change).</p>\n<p>In the context of the inductive definition package, the \"design decision\"<br>\nis the way how inductive sets (or predicates) are defined, and the \"other<br>\nparts of the program\" that should be protected from change are the proofs<br>\nabout inductively defined sets. Moreover, the \"stable interface\" that we<br>\nprovide is the introduction, induction and case analysis rules.<br>\nThis also means that proofs relying on an inductive set being defined<br>\n(or \"implemented\") in a particular way (such as proofs involving x.defs)<br>\nwill no longer work once the definition has changed.</p>\n<p>In the old inductive definition package, an inductive set was defined by<br>\nforming the least fixpoint of a function on the complete lattice of sets<br>\nof n-tuples, whereas the new inductive command defines inductive predicates<br>\nas a least fixpoint of a function on the complete lattice of n-ary predicates,<br>\nand the inductive_set command is just a wrapper for the inductive command.<br>\nFor example, the definition of rtrancl in Isabelle2005 is</p>\n<p>r^* == lfp (%S. {x. (EX a. x = (a, a)) |<br>\n                       (EX a b c. x = (a, c) &amp; (a, b) : S &amp; (b, c) : r)})</p>\n<p>whereas in Isabelle2007, it is</p>\n<p>r^** == lfp (%p x1 x2. (EX a. x1 = a &amp; x2 = a) |<br>\n                          (EX a b c. x1 = a &amp; x2 = c &amp; p a b &amp; r b c))<br>\n   r^* == {(xa, x). (%x xa. (x, xa) : r)^** xa x}</p>\n<blockquote>\n<p>If I can prove x.unfold or x.defs using the 'official' rules, then whay <br>\ncan't they be included in the inductive set package as previously?</p>\n<p>More importantly, may I suggest that it would be good policy on the part <br>\nof the developers to ensure that new developments are made to be <br>\nbackward compatible where possible?</p>\n</blockquote>\n<p>We really tried very hard to ensure backward compatibility when introducing<br>\nthe new inductive definition package. In particular, we put a lot of work<br>\nin the implementation of the inductive_set wrapper that allows most of the<br>\nproofs using inductive sets to be ported to Isabelle2007 with a minimal<br>\namount of changes. However, the x.defs and x.unfold rules are really a bit<br>\nobscure in my opinion, which is why they were not mentioned in the tutorial<br>\neither. It therefore made no sense to me to write additional code for proving<br>\nthese obscure rules from the \"official\" ones, in particular because the few<br>\nproofs in the Isabelle distributions that were using these rules could easily<br>\nbe adapted.<br>\nFor example, the proof of exec_mono in HOL/Induct/Com.thy in Isabelle2005<br>\nlooked as follows:</p>\n<p>lemma exec_mono: \"A&lt;=B ==&gt; exec(A) &lt;= exec(B)\"<br>\n   apply (unfold exec.defs )<br>\n   apply (rule lfp_mono)<br>\n   apply (assumption | rule basic_monos)+<br>\n   done</p>\n<p>In contrast, the Isabelle2007 version is</p>\n<p>lemma exec_mono: \"A&lt;=B ==&gt; exec(A) &lt;= exec(B)\"<br>\n   apply (rule subsetI)<br>\n   apply (simp add: split_paired_all)<br>\n   apply (erule exec.induct)<br>\n   apply blast+<br>\n   done</p>\n<blockquote>\n<p>For about 3 years recently I worked on a particular project where they <br>\ngenerally would use the latest development version of Isabelle.  It <br>\nseems to me that during that time, about half my time on the project was <br>\nspent doing useful work and about half was spent changing my work in <br>\nresponse to changes in Isabelle.</p>\n</blockquote>\n<p>I can understand your frustration, but with thousands of Isabelle theories<br>\nout there, it is almost impossible to achieve that none of the changes we<br>\nmake affects any of these theories.<br>\nA good way of ensuring that your theories will still work with newer versions<br>\nof Isabelle is to submit them to the AFP. Once your theories are in the AFP,<br>\nevery developer who makes a change that breaks any of the theories in the AFP<br>\n(or the Isabelle distribution) is responsible for fixing it, which is usually<br>\nnot too difficult, since the developer knows what kind of changes he has made.</p>\n<p>Finally, let me assure you that I am happy to assist in porting any of your<br>\nproofs about inductive definitions to Isabelle2007.</p>\n<p>Regards,<br>\nStefan</p>",
        "id": 294061606,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660823893
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nStefan Berghofer wrote:</p>\n<blockquote>\n<p>Jeremy Dawson wrote:</p>\n<blockquote>\n<p>I don't understand what you say about \"violates the principle of <br>\ninformation<br>\nhiding\".  If anything provable using x.unfold or x.defs can be proved <br>\nusing the 'official' rules, then surely the 'official' rules contain <br>\n(at least) the same information as  x.unfold or x.defs.</p>\n</blockquote>\n<p>Dear Jeremy,</p>\n<p>on Wikipedia (<a href=\"http://en.wikipedia.org/wiki/Information_hiding\">http://en.wikipedia.org/wiki/Information_hiding</a>), I <br>\nfound the<br>\nfollowing definition of \"information hiding\":</p>\n<p>The principle of information hiding is the hiding of design decisions<br>\n  in a computer program that are most likely to change, thus protecting<br>\n  other parts of the program from change if the design decision is <br>\nchanged.<br>\n  The protection involves providing a stable interface which shields the<br>\n  remainder of the program from the implementation (the details that are<br>\n  most likely to change).</p>\n<p>In the context of the inductive definition package, the \"design decision\"<br>\nis the way how inductive sets (or predicates) are defined, and the \"other<br>\nparts of the program\" that should be protected from change are the proofs<br>\nabout inductively defined sets. Moreover, the \"stable interface\" that we<br>\nprovide is the introduction, induction and case analysis rules.<br>\nThis also means that proofs relying on an inductive set being defined<br>\n(or \"implemented\") in a particular way (such as proofs involving x.defs)<br>\nwill no longer work once the definition has changed.</p>\n<p>In the old inductive definition package, an inductive set was defined by<br>\nforming the least fixpoint of a function on the complete lattice of sets<br>\nof n-tuples, whereas the new inductive command defines inductive <br>\npredicates<br>\nas a least fixpoint of a function on the complete lattice of n-ary <br>\npredicates,<br>\nand the inductive_set command is just a wrapper for the inductive <br>\ncommand.<br>\nFor example, the definition of rtrancl in Isabelle2005 is</p>\n<p>r^* == lfp (%S. {x. (EX a. x = (a, a)) |<br>\n                      (EX a b c. x = (a, c) &amp; (a, b) : S &amp; (b, c) : r)})</p>\n<p>Dear Stefan,</p>\n</blockquote>\n<p>I think there is some misunderstanding here.  I don't care how the <br>\ninductive set is defined, logically, internally.  The point is, if I'm <br>\nnot mistaken, that the above equality is still true in Isabelle2007.  <br>\nThat is, the truth of this equality does not depend on the \"design <br>\ndecision\" of the way how inductive sets (or predicates) are defined.  <br>\nYou would provide a \"stable interface\" by continuing to make it available. </p>\n<blockquote>\n<p>whereas in Isabelle2007, it is</p>\n<p>r^** == lfp (%p x1 x2. (EX a. x1 = a &amp; x2 = a) |<br>\n                         (EX a b c. x1 = a &amp; x2 = c &amp; p a b &amp; r b c))<br>\n  r^* == {(xa, x). (%x xa. (x, xa) : r)^** xa x}</p>\n<blockquote>\n<p>If I can prove x.unfold or x.defs using the 'official' rules, then <br>\nwhay can't they be included in the inductive set package as previously?</p>\n<p>More importantly, may I suggest that it would be good policy on the <br>\npart of the developers to ensure that new developments are made to be <br>\nbackward compatible where possible?</p>\n</blockquote>\n<p>We really tried very hard to ensure backward compatibility when <br>\nintroducing<br>\nthe new inductive definition package. In particular, we put a lot of work<br>\nin the implementation of the inductive_set wrapper that allows most of <br>\nthe<br>\nproofs using inductive sets to be ported to Isabelle2007 with a minimal<br>\namount of changes. However, the x.defs and x.unfold rules are really a <br>\nbit<br>\nobscure in my opinion, which is why they were not mentioned in the <br>\ntutorial<br>\neither.<br>\nWell, they are mentioned in the HOL Logic document (including the <br>\nversion of 22 November 2007 (that is, I think, the one distributed with <br>\nIsabelle 2007)</p>\n<blockquote>\n<p>For about 3 years recently I worked on a particular project where <br>\nthey generally would use the latest development version of Isabelle.  <br>\nIt seems to me that during that time, about half my time on the <br>\nproject was spent doing useful work and about half was spent changing <br>\nmy work in response to changes in Isabelle.<br>\nI can understand your frustration, but with thousands of Isabelle <br>\ntheories<br>\nout there, it is almost impossible to achieve that none of the changes we<br>\nmake affects any of these theories.<br>\nA good way of ensuring that your theories will still work with newer <br>\nversions<br>\nof Isabelle is to submit them to the AFP. <br>\nWell, I have a rather vague recollection of hearing that the AFP is only <br>\ninterested in proofs written in Isar.  Is that correct? <br>\nOnce your theories are in the AFP,<br>\nevery developer who makes a change that breaks any of the theories in <br>\nthe AFP<br>\n(or the Isabelle distribution) is responsible for fixing it, which is <br>\nusually<br>\nnot too difficult, since the developer knows what kind of changes he <br>\nhas made.</p>\n</blockquote>\n<p>Finally, let me assure you that I am happy to assist in porting any of <br>\nyour<br>\nproofs about inductive definitions to Isabelle2007.</p>\n<p>Well, thanks - there is also the question of whether it is worthwhile <br>\nfor anyone to bother with doing this, since I'm managing fine with <br>\nIsabelle2005.  Maybe I'll email you separately on this.</p>\n</blockquote>\n<p>regards,</p>\n<p>Jeremy Dawson</p>\n<blockquote>\n<p>Regards,<br>\nStefan<br>\n</p>\n</blockquote>",
        "id": 294061936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824027
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Well, I have a rather vague recollection of hearing that the AFP is only <br>\ninterested in proofs written in Isar.  Is that correct?</p>\n</blockquote>\n<p>It does not say so anywhere. And some contributions are not in Isar. <br>\nAlthough we do have a preference for Isar and may ask for revisions of <br>\nparticularly brittle theories before adding them.</p>\n<p>Tobias</p>",
        "id": 294061950,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824034
    }
]