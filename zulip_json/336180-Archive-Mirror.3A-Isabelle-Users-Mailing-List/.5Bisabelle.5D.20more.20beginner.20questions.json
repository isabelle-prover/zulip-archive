[
    {
        "content": "<p>From: Tim Newsham &lt;<a href=\"mailto:newsham@lava.net\">newsham@lava.net</a>&gt;<br>\n1) Is there a datatype for characters in isabelle?  I would like<br>\n    to prove stuff about a real world grammar for a language of<br>\n    characters.</p>\n<p>2) This is really basic but giving me a headache.  How can I make<br>\n    an optional tuple?  I tried \"('a, 'a) option\"  but that didnt seem<br>\n    to work properly.</p>\n<p>3) Do any isabelle users hang out on some real-time chat network where<br>\n    a beginner like me could pester them?  For example <a href=\"http://irc.freenode.net\">irc.freenode.net</a><br>\n    #isabelle would be nice.  <em>hint</em> <em>hint</em><br>\n    I'm there, but I'm afraid I'm in no position to answer questions :)</p>\n<p>thanks in advance.</p>\n<p>Tim Newsham<br>\n<a href=\"http://www.thenewsh.com/~newsham/\">http://www.thenewsh.com/~newsham/</a></p>",
        "id": 294051856,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819821
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>1) Is there a datatype for characters in isabelle?  I would like<br>\n   to prove stuff about a real world grammar for a language of<br>\n   characters.</p>\n</blockquote>\n<p>Yes, char, in List.</p>\n<blockquote>\n<p>2) This is really basic but giving me a headache.  How can I make<br>\n   an optional tuple?  I tried \"('a, 'a) option\"  but that didnt seem<br>\n   to work properly.</p>\n</blockquote>\n<p>You are using Haskell syntax. Try \"('a * 'a) option\".</p>\n<p>Tobias</p>",
        "id": 294051873,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819826
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nOn Mon, Sep 24, 2007 at 05:33:51PM -1000, Tim Newsham wrote:</p>\n<blockquote>\n<p>1) Is there a datatype for characters in isabelle?  I would like<br>\n   to prove stuff about a real world grammar for a language of<br>\n   characters.<br>\nYes there is (it is called char). To use them you<br>\nhave to include letters in double single quotes.<br>\nE.g., the character A would be written as ''A''</p>\n<p>2) This is really basic but giving me a headache.  How can I make<br>\n   an optional tuple?  I tried \"('a, 'a) option\"  but that didnt seem<br>\n   to work properly.<br>\nThe syntax would be</p>\n</blockquote>\n<p>datatype 'a option = None | Some 'a</p>\n<p>But this type is already predefined... so just use the construcotrs<br>\nNone and Some (taking one argument).</p>\n<blockquote>\n<p>3) Do any isabelle users hang out on some real-time chat network where<br>\n   a beginner like me could pester them?  For example <a href=\"http://irc.freenode.net\">irc.freenode.net</a><br>\n   #isabelle would be nice.  <em>hint</em> <em>hint</em><br>\n   I'm there, but I'm afraid I'm in no position to answer questions :)<br>\nI do not know about that.</p>\n<p>thanks in advance.</p>\n<p>Tim Newsham<br>\n<a href=\"http://www.thenewsh.com/~newsham/\">http://www.thenewsh.com/~newsham/</a></p>\n<p>cheers</p>\n</blockquote>\n<p>christian</p>",
        "id": 294051908,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819841
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nOn Tuesday 25 September 2007 05:33, Tim Newsham wrote:</p>\n<blockquote>\n<p>1) Is there a datatype for characters in isabelle?  I would like<br>\n    to prove stuff about a real world grammar for a language of<br>\n    characters.</p>\n<p>Yes.  I'm not sure how you enter a single character, but you have<br>\n\"''A'' :: char list\" for example, and also <br>\n \"''ABC'' :: char list\" (ie two single forward quotes before and after).<br>\nDefined in src/HOL/List.thy</p>\n</blockquote>\n<blockquote>\n<p>2) This is really basic but giving me a headache.  How can I make<br>\n    an optional tuple?  I tried \"('a, 'a) option\"  but that didnt seem<br>\n    to work properly.</p>\n</blockquote>\n<p>Your  \"('a, 'a)\" is Haskell-style for expressing a tuple type.<br>\nIsabelle-style (and ML style) is ('a * 'a)<br>\nThus eg <br>\n \"Some (1, a) :: (nat * 'a) option\"<br>\nNote the lower cases in Some and None.<br>\nDefined in src/HOL/Datatype.thy</p>\n<blockquote>\n<p>Jeremy</p>\n</blockquote>\n<blockquote>\n<p>thanks in advance.</p>\n<p>Tim Newsham<br>\n<a href=\"http://www.thenewsh.com/~newsham/\">http://www.thenewsh.com/~newsham/</a></p>\n</blockquote>",
        "id": 294051922,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819847
    },
    {
        "content": "<p>From: Paul Graunke &lt;<a href=\"mailto:paul.graunke@galois.com\">paul.graunke@galois.com</a>&gt;<br>\nOn Sep 24, 2007, at 8:33 PM, Tim Newsham wrote:</p>\n<blockquote>\n<p>1) Is there a datatype for characters in isabelle?  I would like<br>\n   to prove stuff about a real world grammar for a language of<br>\n   characters.<br>\nI think it is called \"char\".  At one point the fully qualified name  <br>\nwas \"List.char\".</p>\n</blockquote>\n<blockquote>\n<p>2) This is really basic but giving me a headache.  How can I make<br>\n   an optional tuple?  I tried \"('a, 'a) option\"  but that didnt seem<br>\n   to work properly.</p>\n</blockquote>\n<p>Try \"('a * 'a) option\" or \"('a \\&lt;times&gt; 'a) option\".</p>\n<p>Regards,</p>\n<p>Paul</p>",
        "id": 294051944,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819857
    },
    {
        "content": "<p>From: Tim Newsham &lt;<a href=\"mailto:newsham@lava.net\">newsham@lava.net</a>&gt;<br>\nThanks for the many answers.  I wasn't properly using (a * b) for<br>\ntuple types, and I overlooked the \"char\" definition in List.</p>\n<p>I've made a bit more progress and am again stuck.  I made<br>\na definition for a character parser and a property for when<br>\na parser accepts a string and I want to prove that the character<br>\nparser only accepts strings that are made up of that one<br>\nparticular character (excuse the extra parens, I'm playing it<br>\nsafe until I'm more comfortable with Isabelle):</p>\n<p>lemma \"(accepts (pcar ch) s) =&gt; (s = (ch # []))\"<br>\napply(case_tac s)<br>\napply(simp add:pchar_def)<br>\napply(simp add:pchar_def)</p>\n<p>at this point I feel like I want to use split_if, but<br>\napply(split split_if) fails.  I'm not sure if my definition for<br>\nonlyCh is acceptable, but I was able to dispatch part of the<br>\nproof so perhaps it is.  Is my problem due to any of my definitions<br>\nbeing unsuitable or is there a simple way to continue the current<br>\nproof?   The last goal was:</p>\n<p>!! a list .<br>\n     [| case if a = ch then Some (list, a) else None of None =&gt; False<br>\n         | Some (resid, result) =&gt; null resid;<br>\n         s = a # list |]<br>\n     ==&gt; a = ch /\\ list = []</p>\n<p>The full body of my thy file is:<br>\n------- gram.thy -----<br>\ntheory Gram<br>\nimports Main<br>\nbegin</p>\n<p>(* monadic parser (a la parsec) for character strings *)<br>\ndatatype 'a parser = Parser \"char list \\&lt;Rightarrow&gt; (char list * 'a) <br>\noption\"</p>\n<p>(*<br>\n    An input string is fully consumed and accepted by a parser.<br>\n    Only if it parses successfully and it consumes the full input.<br>\n*)<br>\nconsts accepts :: \"'a parser \\&lt;Rightarrow&gt; char list \\&lt;Rightarrow&gt; bool\"<br>\nprimrec \"accepts (Parser p) cs = (case p cs of<br>\n    None \\&lt;Rightarrow&gt; False<br>\n    | Some (resid, result) \\&lt;Rightarrow&gt; null resid)\"</p>\n<p>(* a parser for an arbitrary character *)<br>\nconsts onlyCh :: \"char \\&lt;Rightarrow&gt; char list \\&lt;Rightarrow&gt; (char list * <br>\nchar) option\"<br>\nprimrec \"onlyCh ch [] = None\"<br>\n         \"onlyCh ch (x # xs) = (if (x = ch) then (Some (xs, x))<br>\n                                             else None)\"<br>\nconstdefs<br>\n   pchar :: \"char \\&lt;Rightarrow&gt; char parser\"<br>\n   \"pchar == %ch . (Parser (onlyCh ch))\"</p>\n<p>(* character parser only accepts the single character *)<br>\nlemma \"(accepts (pchar ch) s) \\&lt;Longrightarrow&gt; (s = (ch # []))\"<br>\napply(case_tac s)<br>\napply(simp add:pchar_def)<br>\napply(simp add:pchar_def)<br>\napply(split split_if)<br>\n---- end gram.thy ----</p>\n<p>Tim Newsham<br>\n<a href=\"http://www.thenewsh.com/~newsham/\">http://www.thenewsh.com/~newsham/</a></p>",
        "id": 294051958,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819863
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nIf-then-else and other case-combinators each have two separate split rules: <br>\nOne is for use in the conclusion of a subgoal, and the other is for use with <br>\nthe assumptions. For if-then-else, the two split rules are called \"split_if\" <br>\nand \"split_if_asm\".</p>\n<p>Since your subgoal has an if-then-else in the assumptions, you should use:<br>\napply (split split_if_asm)</p>\n<p>The split rules for case expressions have a standard naming scheme based on <br>\nthe name of the datatype: For type nat they are \"nat.split\" <br>\nand \"nat.split_asm\"; \"nat.splits\" refers to both. Rules for other datatypes <br>\nare similarly named.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294051970,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819873
    }
]