[
    {
        "content": "<p>From: Lucas Cavalcante &lt;<a href=\"mailto:thesupervisar@gmail.com\">thesupervisar@gmail.com</a>&gt;<br>\nI thank you in advance for any clarification concerning my following doubts!</p>\n<hr>\n<p>1.</p>\n<p>Suppose I want to define a new datatype in terms of other fresh<br>\ndatatypes, and then define a function over this new datatype, as for<br>\ninstance in:</p>\n<p>datatype<br>\n mytype = typ0 | typ1<br>\nand<br>\n typ0 = Zero<br>\nand<br>\n typ1 = One</p>\n<p>consts And :: \"[mytype, mytype] =&gt; mytype\"<br>\nprimrec<br>\n\"And Zero One  = Zero\"<br>\n\"And Zero Zero = Zero\"<br>\n\"And One  Zero = Zero\"<br>\n\"And One  One  = One\"</p>\n<p>Why does Isabelle complain that the constructors Zero and One do not<br>\nhave type \"mytype\", as I explicitly declared typ0 and typ1 as<br>\nparticular cases of mytype?</p>\n<p>I also tried to define, more simply:</p>\n<p>consts AND :: \"[mytype, mytype] =&gt; mytype\"<br>\nprimrec<br>\n\"AND Zero x  = Zero\"<br>\n\"AND x y = y\"</p>\n<p>bu that went even worse for Isabelle...  I found the error messages<br>\nsomewhat unexpected, as a completely similar definition works fine in<br>\nML.</p>\n<p>Of course, this is just a simple example of the problem I'm having.<br>\nWhat I am really interested in is in defining functions involving<br>\nmutually recursive datatypes, but first I have to understand what<br>\nhappens in simpler cases such as the above one!</p>\n<hr>\n<p>2.</p>\n<p>Can I not use the same constructor name for different datatypes? In<br>\nthe following example the second step of primrec is not correct<br>\nbecause Two is not from 'a n1 datatype anymore, but 'a n2.</p>\n<p>datatype 'a n1 = One 'a | Two 'a | LotOf 'a<br>\ndatatype 'a n2 = Two 'a | OddPrime 'a</p>\n<p>consts ct :: \"'a n1 =&gt; 'a n1\"</p>\n<p>primrec<br>\n \"ct (One x) = One x\"<br>\n \"ct (Two x::'a n1) = (One x::'a n1)\"</p>\n<hr>\n<p>3.</p>\n<p>When using the same syntax sugar for different constructors of<br>\ndifferent datatypes, Isabelle finds it ambiguous to correctly parse<br>\nthe terms.  Can I not use the same connective symbol for these<br>\nconstructions?  Details follow in the example below:</p>\n<p>datatype 'a t1 = At1 'a<br>\n               | Not1 \"'a t1\" (\"not_\" [50])<br>\n               | Imp1 \"'a t1\" \"'a t1\" (\"_imp_\" [45])</p>\n<p>datatype<br>\n         'a t2 = \"'a t3\"<br>\n               | Not \"'a t3\"  (\"not_\" [50])<br>\n  and<br>\n         'a t3 = At 'a<br>\n               | Imp \"'a t2\" \"'a t2\" (\"_imp_\" [45])</p>\n<p>consts</p>\n<p>valid_t1 :: \"'a t1 =&gt; prop\" (\"(_)\" 5)<br>\n  valid_t2 :: \"'a t2 =&gt; prop\" (\"(_)\" 5)<br>\n  valid_t3 :: \"'a t3 =&gt; prop\" (\"(_)\" 5)</p>\n<p>axioms</p>\n<p>impIa:         \"(P ==&gt; Q) ==&gt; P imp Q\"</p>\n<hr>\n<p>Lucas</p>",
        "id": 294052172,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819955
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\ndoes not do what you think it does, neither in Isabelle nor in ML.<br>\nThe above declares mytype to be a type with two nullary constructors <br>\ntyp0 and typ1. (The name space for types and functions is disjoint.) <br>\nThere are no untagged union types in the ML family of languages, incl HOL.</p>\n<p>Tobias</p>",
        "id": 294052183,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819961
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nYou can indeed use the same constructor name for different datatypes, as you <br>\nhave done in your example. But the unqualified name \"Two\" will always refer <br>\nto the most recently defined one, regardless of any type annotation you put <br>\non it. To distinguish between them, you should use the qualified <br>\nnames \"n1.Two\" and \"n2.Two\".</p>\n<p>Note that Isabelle's pretty printer uses qualified names exactly when needed <br>\nfor disambiguation, so if you type the command \"term Two\" after the above <br>\ndatatype declarations, Isabelle responds with:</p>\n<p>\"n2.Two\"<br>\n  :: \"'a  =&gt; 'a n2\"</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294052197,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819967
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nIsabelle finds the axiom \"impla\" ambiguous because it <em>is</em> ambiguous. This <br>\naxiom produces 128 parse trees (one 2-way ambiguity between Imp1/Imp, and <br>\nthree 4-way ambiguities between valid_t1/valid_t2/valid_t3/Trueprop, which <br>\nmakes 2 * 4 * 4 * 4 = 128), of which 2 are type-correct:</p>\n<p>\"(PROP valid_t1 P ==&gt; PROP valid_t1 Q) ==&gt; PROP valid_t1 (Imp1 P Q)\"<br>\n\"(PROP valid_t2 P ==&gt; PROP valid_t2 Q) ==&gt; PROP valid_t3 (Imp P Q)\"</p>\n<p>You could specify which one of these you mean by using type annotations, e.g.<br>\naxioms impIa: \"((P::'a t1) ==&gt; Q) ==&gt; P imp Q\"</p>\n<p>Isabelle will still give a warning about the multiple parse trees, but it will <br>\naccept the declaration since now only one parse tree is type correct.</p>\n<p>In general I think it is a bad idea to reuse the same syntactic sugar for <br>\ndifferent constants, since it can slow down the parser a lot (In the example <br>\nabove, Isabelle must attempt to type-check all 128 parse trees to find the <br>\none that works). Instead, I would recommend using type classes and <br>\noverloading; you can associate the syntactic sugar with the overloaded <br>\nconstant without causing any ambiguity in parsing.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294052209,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819973
    }
]