[
    {
        "content": "<p>From: Peter Sewell &lt;<a href=\"mailto:Peter.Sewell@cl.cam.ac.uk\">Peter.Sewell@cl.cam.ac.uk</a>&gt;<br>\nAnother naive question: I'd like to define several mutually recursive<br>\nfunctions, eg (roughly) as is_val and is_exp in the example below.<br>\nLooking in the tutorial I only see single examples - how would this be<br>\nmost nicely done?  (Presumably I could make a new disjoint sum type<br>\nand work over that, but that seems ugly - though some plumbing of size<br>\nfunctions is going to be needed somewhere.)</p>\n<p>ta,<br>\nPeter</p>\n<p>theory Out = Main:<br>\ntypes ident = \"string\"<br>\ndatatype <br>\nexp = <br>\n   Exp_ident \"ident\"<br>\n | Exp_unit<br>\n | Exp_pair \"exp*exp\"<br>\n | Exp_fun \"ident*exp\"<br>\n | Exp_app \"exp*exp\"<br>\n | Exp_foo \"exp\"<br>\nand C = <br>\n   Ctx_pairL \"exp\"<br>\n | Ctx_pairR \"exp\"<br>\n | Ctx_appL \"exp\"<br>\n | Ctx_appR \"exp\"<br>\nand Jop = <br>\n   JO_red \"exp*exp\"<br>\nand judgement = <br>\n   judgement_Jop \"Jop\"</p>\n<p>consts is_val :: \"exp =&gt; bool\"<br>\nis_C :: \"C =&gt; bool\"<br>\nis_Jop :: \"Jop =&gt; bool\"<br>\nis_exp :: \"exp =&gt; bool\"<br>\nrecdef is_val \"measure (% x . size x)\"<br>\n\"is_val (Exp_ident ( x ) ) = (True)\"<br>\n\"is_val (Exp_unit) = (True)\"<br>\n\"is_val (Exp_pair ( exp , exp' ) ) = (((is_val exp) &amp; (is_val exp')))\"<br>\n\"is_val (Exp_fun ( x , exp ) ) = (((is_exp exp)))\"<br>\n\"is_val (Exp_app ( exp , exp' ) ) = False\"<br>\n\"is_val (Exp_foo ( val ) ) = False\"<br>\nrecdef is_C \"measure (% x . size x)\"<br>\n\"is_C (Ctx_pairL ( exp ) ) = (((is_exp exp)))\"<br>\n\"is_C (Ctx_pairR ( val ) ) = (((is_val val)))\"<br>\n\"is_C (Ctx_appL ( exp ) ) = (((is_exp exp)))\"<br>\n\"is_C (Ctx_appR ( val ) ) = (((is_val val)))\"<br>\nrecdef is_Jop \"measure (% x . size x)\"<br>\n\"is_Jop (JO_red ( e , e' ) ) = (((is_exp e) &amp; (is_exp e')))\"<br>\nrecdef is_exp \"measure (% x . size x)\"<br>\n\"is_exp (Exp_ident ( x ) ) = (True)\"<br>\n\"is_exp (Exp_unit) = (True)\"<br>\n\"is_exp (Exp_pair ( exp , exp' ) ) = (((is_exp exp) &amp; (is_exp exp')))\"<br>\n\"is_exp (Exp_fun ( x , exp ) ) = (((is_exp exp)))\"<br>\n\"is_exp (Exp_app ( exp , exp' ) ) = (((is_exp exp) &amp; (is_exp exp')))\"<br>\n\"is_exp (Exp_foo ( val ) ) = (((is_val val)))\"</p>",
        "id": 293904904,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745670
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@csee.ogi.edu\">brianh@csee.ogi.edu</a>&gt;<br>\nYou could actually define these functions together using primrec: Since <br>\nrecursive calls are only made on subterms, you don't really need the full <br>\npower of recdef.</p>\n<p>However, using primrec is complicated by the fact that you have used product <br>\ntypes as arguments to your constructors. This is actually an instance of <br>\nindirect recursion, which means you would be required to additionally define <br>\nseveral extra constants which take the product types as arguments. If you <br>\nchange your datatype definitions so that the constructors have two separate <br>\narguments instead of a pair, then primrec should work just fine.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 293904919,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745673
    },
    {
        "content": "<p>From: Peter Sewell &lt;<a href=\"mailto:Peter.Sewell@cl.cam.ac.uk\">Peter.Sewell@cl.cam.ac.uk</a>&gt;<br>\nBrian Huffman writes:</p>\n<blockquote>\n<p>You could actually define these functions together using primrec: Since <br>\nrecursive calls are only made on subterms, you don't really need the full <br>\npower of recdef.</p>\n</blockquote>\n<p>that's true in this case, indeed.</p>\n<blockquote>\n<p>However, using primrec is complicated by the fact that you have used product <br>\ntypes as arguments to your constructors. This is actually an instance of <br>\nindirect recursion, which means you would be required to additionally define <br>\nseveral extra constants which take the product types as arguments. If you <br>\nchange your datatype definitions so that the constructors have two separate <br>\narguments instead of a pair, then primrec should work just fine.</p>\n</blockquote>\n<p>But that seems not to be.  As far as I can tell it's impossible to <br>\ndefine multiple mutually-recursive functions over the same types, eg the</p>\n<p>is_val :: \"exp =&gt; bool\"<br>\n  is_exp :: \"exp =&gt; bool\"</p>\n<p>in the example below, using either primrec or recdef.  Is that really the case?<br>\nClearly I could encode, with something like</p>\n<p>is_val_is_exp :: \"exp =&gt; (bool * bool) \"</p>\n<p>and Tom Ridge points out that I can then prove lemmas characterising<br>\nthe projections of that that look like my original definition.  <br>\nBut I don't want to do that encoding unless I have to...</p>\n<p>thanks,<br>\nPeter</p>\n<p>(* here is_val and is_exp define two sub-grammars of the free exp *)<br>\ntheory Out = Main:<br>\ntypes ident = \"string\"<br>\ndatatype <br>\nexp = <br>\n   Exp_ident \"ident\"<br>\n | Exp_unit <br>\n | Exp_pair \"exp\" \"exp\"<br>\n | Exp_fun \"ident\" \"exp\"<br>\n | Exp_app \"exp\" \"exp\"<br>\n | Exp_foo \"exp\"</p>\n<p>consts<br>\nis_val :: \"exp =&gt; bool\"<br>\nis_exp :: \"exp =&gt; bool\"</p>\n<p>primrec<br>\n\"is_val ((Exp_ident x)) = (True)\"<br>\n\"is_val (Exp_unit) = (True)\"<br>\n\"is_val ((Exp_pair exp exp')) = (((is_val exp) &amp; (is_val exp')))\"<br>\n\"is_val ((Exp_fun x exp)) = (((is_exp exp)))\"<br>\n\"is_val ((Exp_app exp exp')) = False\"<br>\n\"is_val ((Exp_foo val)) = False\"</p>\n<p>\"is_exp ((Exp_ident x)) = (True)\"<br>\n\"is_exp (Exp_unit) = (True)\"<br>\n\"is_exp ((Exp_pair exp exp')) = (((is_exp exp) &amp; (is_exp exp')))\"<br>\n\"is_exp ((Exp_fun x exp)) = (((is_exp exp)))\"<br>\n\"is_exp ((Exp_app exp exp')) = (((is_exp exp) &amp; (is_exp exp')))\"<br>\n\"is_exp ((Exp_foo val)) = (((is_val val)))\"</p>",
        "id": 293905025,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745698
    },
    {
        "content": "<p>From: <a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a><br>\nI think the only mutual recursion we currently support is for mutually<br>\nrecursive datatypes. Mutual recursion in general is in the pipeline...</p>\n<p>Below you find a higher-order encoding of mutual recursion. It avoids having<br>\nto mess around with pairs but requires its own tricks. I had never tried this<br>\nbefore and it was a valuable exercise.</p>\n<p>Tobias</p>\n<p>types ident = \"string\"<br>\ndatatype<br>\nexp =<br>\n   Exp_ident \"ident\"<br>\n | Exp_unit<br>\n | Exp_pair \"exp\" \"exp\"<br>\n | Exp_fun \"ident\" \"exp\"<br>\n | Exp_app \"exp\" \"exp\"<br>\n | Exp_foo \"exp\"</p>\n<p>consts<br>\nis_val2 :: \"(exp =&gt; bool) =&gt; exp =&gt; bool\"<br>\nis_exp :: \"exp =&gt; bool\"</p>\n<p>primrec<br>\n\"is_val2 ise (Exp_ident x) = True\"<br>\n\"is_val2 ise (Exp_unit) = True\"<br>\n\"is_val2 ise (Exp_pair exp exp') = (is_val2 ise exp &amp; is_val2 ise exp')\"<br>\n\"is_val2 ise (Exp_fun x exp) = ise exp\"<br>\n\"is_val2 ise (Exp_app exp exp') = False\"<br>\n\"is_val2 ise (Exp_foo val) = False\"</p>\n<p>recdef is_exp \"measure size\"<br>\n\"is_exp (Exp_ident x) = True\"<br>\n\"is_exp (Exp_unit) = True\"<br>\n\"is_exp (Exp_pair exp exp') = (is_exp exp &amp; is_exp exp')\"<br>\n\"is_exp (Exp_fun x exp) = is_exp exp\"<br>\n\"is_exp (Exp_app exp exp') = (is_exp exp &amp; is_exp exp')\"<br>\n\"is_exp (Exp_foo val) = is_val2 is_exp val\"</p>\n<p>(* The real thing: *)<br>\nconstdefs is_val :: \"exp =&gt; bool\"<br>\n \"is_val == is_val2 is_exp\"</p>\n<p>(* Deriving the real eqns: *)<br>\nlemma [simp]:<br>\n \"is_val (Exp_ident x) = True\"<br>\n \"is_val (Exp_unit) = True\"<br>\n \"is_val (Exp_pair exp exp') = (is_val exp &amp; is_val exp')\"<br>\n \"is_val (Exp_fun x exp) = is_exp exp\"<br>\n \"is_val (Exp_app exp exp') = False\"<br>\n \"is_val (Exp_foo val) = False\"<br>\nby(simp_all add:is_val_def)</p>\n<p>(* A complication: the final is_exp rule is more complicated than one<br>\nmay naively expect. *)<br>\nthm is_exp.simps(6)</p>\n<p>lemma is_val2_cong:<br>\n \"(!!e'. size e' &lt; size e ==&gt; f e' = g e') ==&gt; is_val2 f e = is_val2 g e\"<br>\nby (induct e) simp_all</p>\n<p>lemma is_exp_foo[simp]: \"is_exp (Exp_foo e) = is_val e\"<br>\nby(simp add:is_val_def measure_def inv_image_def is_val2_cong)</p>\n<p>declare is_exp.simps(6)[simp del]</p>",
        "id": 293905030,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745699
    },
    {
        "content": "<p>From: <a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a><br>\nI think the only mutual recursion we currently support is for mutually<br>\nrecursive datatypes. Mutual recursion in general is in the pipeline...</p>\n<p>Below you find a higher-order encoding of mutual recursion. It avoids having<br>\nto mess around with pairs but requires its own tricks. I had never tried this<br>\nbefore and it was a valuable exercise.</p>\n<p>Tobias</p>\n<p>types ident = \"string\"<br>\ndatatype<br>\nexp =<br>\n   Exp_ident \"ident\"<br>\n | Exp_unit<br>\n | Exp_pair \"exp\" \"exp\"<br>\n | Exp_fun \"ident\" \"exp\"<br>\n | Exp_app \"exp\" \"exp\"<br>\n | Exp_foo \"exp\"</p>\n<p>consts<br>\nis_val2 :: \"(exp =&gt; bool) =&gt; exp =&gt; bool\"<br>\nis_exp :: \"exp =&gt; bool\"</p>\n<p>primrec<br>\n\"is_val2 ise (Exp_ident x) = True\"<br>\n\"is_val2 ise (Exp_unit) = True\"<br>\n\"is_val2 ise (Exp_pair exp exp') = (is_val2 ise exp &amp; is_val2 ise exp')\"<br>\n\"is_val2 ise (Exp_fun x exp) = ise exp\"<br>\n\"is_val2 ise (Exp_app exp exp') = False\"<br>\n\"is_val2 ise (Exp_foo val) = False\"</p>\n<p>recdef is_exp \"measure size\"<br>\n\"is_exp (Exp_ident x) = True\"<br>\n\"is_exp (Exp_unit) = True\"<br>\n\"is_exp (Exp_pair exp exp') = (is_exp exp &amp; is_exp exp')\"<br>\n\"is_exp (Exp_fun x exp) = is_exp exp\"<br>\n\"is_exp (Exp_app exp exp') = (is_exp exp &amp; is_exp exp')\"<br>\n\"is_exp (Exp_foo val) = is_val2 is_exp val\"</p>\n<p>(* The real thing: *)<br>\nconstdefs is_val :: \"exp =&gt; bool\"<br>\n \"is_val == is_val2 is_exp\"</p>\n<p>(* Deriving the real eqns: *)<br>\nlemma [simp]:<br>\n \"is_val (Exp_ident x) = True\"<br>\n \"is_val (Exp_unit) = True\"<br>\n \"is_val (Exp_pair exp exp') = (is_val exp &amp; is_val exp')\"<br>\n \"is_val (Exp_fun x exp) = is_exp exp\"<br>\n \"is_val (Exp_app exp exp') = False\"<br>\n \"is_val (Exp_foo val) = False\"<br>\nby(simp_all add:is_val_def)</p>\n<p>(* A complication: the final is_exp rule is more complicated than one<br>\nmay naively expect. *)<br>\nthm is_exp.simps(6)</p>\n<p>lemma is_val2_cong:<br>\n \"(!!e'. size e' &lt; size e ==&gt; f e' = g e') ==&gt; is_val2 f e = is_val2 g e\"<br>\nby (induct e) simp_all</p>\n<p>lemma is_exp_foo[simp]: \"is_exp (Exp_foo e) = is_val e\"<br>\nby(simp add:is_val_def measure_def inv_image_def is_val2_cong)</p>\n<p>declare is_exp.simps(6)[simp del]</p>",
        "id": 293905033,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660745700
    }
]