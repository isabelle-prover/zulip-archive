[
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nDear Isabelle,</p>\n<p>When building an Isabelle script, I often have to come up with names for facts if I am not using them immediately. Coming up with meaningful names all the time is an intellectual burden I could live without when I'm concentrating on a proof. More importantly, even if I did come up with meaningful names all the time, I reckon they would soon get out-of-sync as I modified my script. I briefly tried <em>numbering</em> my steps, but again, the numbers quickly get out-of-order as my script evolves, and I have always to bear in mind which number I used last.</p>\n<p>So, my current solution is to have an emacs macro that generates a sequence of 5 random letters when I press \"C-c d\", which I use to name my facts. I find this works rather well; I've not had a clash yet, and I don't have to engage my brain at all. Here's a little snippet from my current theory, to illustrate:</p>\n<p>How do other users approach this issue?</p>\n<p>John</p>\n<p>ps. One final thought: does there exist a tool that processes an Isabelle script to make it more readable, renaming steps with (say) ascending natural numbers, and removing unused names? I think that would be rather nice.</p>",
        "id": 294158777,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852333
    },
    {
        "content": "<p>From: Johannes HÃ¶lzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Dienstag, den 22.05.2012, 10:33 +0100 schrieb John Wickerson:</p>\n<blockquote>\n<p>Dear Isabelle,</p>\n<p>When building an Isabelle script, I often have to come up with names<br>\nfor facts if I am not using them immediately. Coming up with<br>\nmeaningful names all the time is an intellectual burden I could live<br>\nwithout when I'm concentrating on a proof. More importantly, even if I<br>\ndid come up with meaningful names all the time, I reckon they would<br>\nsoon get out-of-sync as I modified my script. I briefly tried<br>\n<em>numbering</em> my steps, but again, the numbers quickly get out-of-order<br>\nas my script evolves, and I have always to bear in mind which number I<br>\nused last.</p>\n<p>So, my current solution is to have an emacs macro that generates a<br>\nsequence of 5 random letters when I press \"C-c d\", which I use to name<br>\nmy facts. I find this works rather well; I've not had a clash yet, and<br>\nI don't have to engage my brain at all. Here's a little snippet from<br>\nmy current theory, to illustrate:</p>\n<blockquote>\n<p>with iecss and \"0.prems\"(2) have <br>\n  dakuy: \"set S = set (initials (Graph V \\&lt;Lambda&gt; E))\" and<br>\n  iuqxi: \"set (initials (Graph V \\&lt;Lambda&gt; E)) = set V\" by auto<br>\nfrom pqshe have wsegy: \"set E = {}\" by auto  <br>\nhence hkimj: \"E = []\" by auto</p>\n</blockquote>\n</blockquote>\n<p>Uhh, why are 5 random letters better than a slightly out of sync name?</p>\n<ul>\n<li>\n<p>For short theorems like \"E = []\" or \"set E = {}\" you can reference it<br>\n   by <code>E = []</code> or <code>set E = {}</code>.  You can even use patterns if they are<br>\n   unique:</p>\n<p><code>set S = _</code><br>\n<code>_ = set V</code></p>\n</li>\n<li>\n<p>Use the structuring mechanisms of Isar:</p>\n<p>have \"\" ...<br>\n   moreover have \"\" ...<br>\n   moreover have \"\" ...<br>\n   ultimately have \"\" ...</p>\n<p>have \"x = y\"<br>\n   also have \"... &lt; c\"<br>\n   finally have \"x &lt; c\" </p>\n<p>have \"\"<br>\n   then have \"\"<br>\n   then have \"\"<br>\n   then show \"\"</p>\n<p>This avoids names, but also guides the reader through your proof.</p>\n</li>\n<li>\n<p>I prefer to name collections of assumptions when they specify a<br>\n   variable:</p>\n<p>fix x assume x: \"0 &lt; x\" \"x &lt; 1\" ...</p>\n</li>\n<li>\n<p>Otherwise I think a good idea is to name the theorem after the<br>\n   constants appearing:</p>\n<p>S_eq_initials: \"set S = set (initials (Graph V \\&lt;Lambda&gt; E))\"<br>\n   initials_eq_V: \"set (initials (Graph V \\&lt;Lambda&gt; E)) = set V\"</p>\n<p>This avoids mostly the burden to find good names.</p>\n</li>\n<li>\n<p>Only sometimes I use <em>, <strong>, or </strong></em> for theorems I immediately reuse,<br>\n   like:</p>\n<p>have *: \"a b c = 1\"<br>\n   show ?thesis<br>\n     unfolding *</p>\n</li>\n</ul>\n<p>So please delete your 5 random letters script and use one of these<br>\ntechniques ;-)</p>\n<ul>\n<li>Johannes</li>\n</ul>\n<blockquote>\n<p>How do other users approach this issue?</p>\n<p>John</p>\n<p>ps. One final thought: does there exist a tool that processes an<br>\nIsabelle script to make it more readable, renaming steps with (say)<br>\nascending natural numbers, and removing unused names? I think that<br>\nwould be rather nice.</p>\n</blockquote>",
        "id": 294158795,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852339
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHere is the hardliner view: if you need to number your intermediate statements<br>\nwith more than 0-9, you are doing something wrong. [Unless you want to do<br>\nsomething exotic like recast refutations found by a SAT solver as Isar proofs ;-) ].</p>\n<p>Why? Look at a math book, they don't need many labels either. Of course, it<br>\ntakes a bit of practice and it is a question of style, but Isar has a number of<br>\nfeatures that help to avoid names. I find the following most useful:</p>\n<ul>\n<li>\n<p>In your example, drop wsegy: and hkimj: and refer to them as <code>set E = {}</code> and<br>\n<code>E = []</code></p>\n</li>\n<li>\n<p>use this, then, hence, assms, ?thesis etc</p>\n</li>\n<li>Introduce abbreviations: let ?t = \"big term\"</li>\n</ul>\n<p>Tobias</p>",
        "id": 294158805,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852346
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nA funny thing that I've seen recently on some non-prover tool is this: use <br>\nSHA1 digest on the content and restrict it to a unique prefix according to <br>\nthe totality of such hashes in a certain context.  This gives you 1-3 <br>\nstrange letters in most situations.</p>\n<p>Lamport has his own naming scheme, with full paths according to proof <br>\nstructure, and compressed versions thereof.</p>\n<p>In Isabelle/Isar the basic attitude is that explicit names are relatively <br>\nrare, so complete naming is avoided by default.  You also have implicit <br>\n\"this\" and \"calculation\" to work with.</p>\n<p>Makarius</p>",
        "id": 294158813,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852351
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHere is another analogy that I like: try to write proofs as much like Unix pipes<br>\nas possible and avoid long-distace cross references.</p>\n<p>Tobias</p>",
        "id": 294158823,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852358
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI assume that you are aware of the various chaining facilities that exist, including moreover/ultimately. And the ability to refer to facts using backquotes, as in <code>k&gt;0</code>.</p>\n<p>With those, I find that I don't need many labels, so that usually the name of the variable involved is sufficient, for example,</p>\n<p>assumes k: \"k&gt;0\"</p>\n<p>Larry Paulson</p>",
        "id": 294158834,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852364
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt;<br>\nThanks Larry. Yes, I am aware of the chaining features (though not all of the features Johannes helpfully pointed out), and do try not to use my \"random-name\" trick <em>too</em> often. Regarding your suggestion of conflating variable-names and fact-names, I'm rather uneasy about this practice: doesn't it make the proof rather confusing if, for instance, \"[OF k]\" and \"[of k]\" are actually referring to different k's?</p>\n<p>John</p>",
        "id": 294158854,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852370
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI suppose it might confuse some people. You can always call it kgt0 if you prefer. Random strings of letters strike me as being the worst option, because they convey no information whatever.</p>\n<p>Larry Paulson</p>",
        "id": 294158871,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852376
    },
    {
        "content": "<p>From: \"\\\"Mark\\\"\" &lt;<a href=\"mailto:mark@proof-technologies.com\">mark@proof-technologies.com</a>&gt;<br>\nYou are not alone, John.  Tom Hales uses a script to generate a random<br>\nsequence of 7 letters for the names of the lemmas in his Flyspeck project.<br>\nAlthough this is for HOL Light.</p>\n<p>Mark.</p>\n<p>on 22/5/12 11:51 AM, John Wickerson &lt;<a href=\"mailto:jpw48@cam.ac.uk\">jpw48@cam.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Thanks Larry. Yes, I am aware of the chaining features (though not all of<br>\nthe features Johannes helpfully pointed out), and do try not to use my<br>\n\"random-name\" trick <em>too</em> often. Regarding your suggestion of conflating<br>\nvariable-names and fact-names, I'm rather uneasy about this practice:<br>\ndoesn't it make the proof rather confusing if, for instance, \"[OF k]\" and<br>\n\"[of k]\" are actually referring to different k's?</p>\n<p>John</p>\n<p>On 22 May 2012, at 11:33, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>I assume that you are aware of the various chaining facilities that<br>\nexist,<br>\nincluding moreover/ultimately. And the ability to refer to facts using<br>\nbackquotes, as in <code>k&gt;0</code>.</p>\n<p>With those, I find that I don't need many labels, so that usually the<br>\nname<br>\nof the variable involved is sufficient, for example,</p>\n<p>assumes k: \"k&gt;0\"</p>\n<p>Larry Paulson</p>\n</blockquote>\n<p>On 22 May 2012, at 10:33, John Wickerson wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear Isabelle,</p>\n<p>When building an Isabelle script, I often have to come up with names for<br>\nfacts if I am not using them immediately. Coming up with meaningful names<br>\nall the time is an intellectual burden I could live without when I'm<br>\nconcentrating on a proof. More importantly, even if I did come up with<br>\nmeaningful names all the time, I reckon they would soon get out-of-sync as<br>\nI<br>\nmodified my script. I briefly tried <em>numbering</em> my steps, but again, the<br>\nnumbers quickly get out-of-order as my script evolves, and I have always<br>\nto<br>\nbear in mind which number I used last.</p>\n<p>So, my current solution is to have an emacs macro that generates a<br>\nsequence of 5 random letters when I press \"C-c d\", which I use to name my<br>\nfacts. I find this works rather well; I've not had a clash yet, and I<br>\ndon't<br>\nhave to engage my brain at all. Here's a little snippet from my current<br>\ntheory, to illustrate:</p>\n<blockquote>\n<p>with iecss and \"0.prems\"(2) have<br>\ndakuy: \"set S = set (initials (Graph V \\&lt;Lambda&gt; E))\" and<br>\niuqxi: \"set (initials (Graph V \\&lt;Lambda&gt; E)) = set V\" by auto<br>\nfrom pqshe have wsegy: \"set E = {}\" by auto<br>\nhence hkimj: \"E = []\" by auto</p>\n</blockquote>\n<p>How do other users approach this issue?</p>\n<p>John</p>\n<p>ps. One final thought: does there exist a tool that processes an<br>\nIsabelle<br>\nscript to make it more readable, renaming steps with (say) ascending<br>\nnatural<br>\nnumbers, and removing unused names? I think that would be rather nice.<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294158922,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852392
    }
]