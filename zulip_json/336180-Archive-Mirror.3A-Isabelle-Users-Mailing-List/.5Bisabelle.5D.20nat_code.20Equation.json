[
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nDear all,</p>\n<p>I recently had to check some very large proof using the code that was generated by Isabelle.<br>\nUnfortunately we have not been able to parse the proof within reasonable time. <br>\nTherefore, we started to profile our parser (which is written as an Isabelle function) <br>\nand we stumbled upon a strange hotspot: nat!</p>\n<p>In Code_Integer we have the following code-equation:</p>\n<p>lemma nat_code [code]:<br>\n  \"nat k = (if k ≤ 0 then 0 else<br>\n     let<br>\n       (l, j) = divmod_int k 2;<br>\n       n = nat l;<br>\n       l' = n + n<br>\n     in if j = 0 then l' else Suc l')\"<br>\nproof -<br>\n  have \"2 = nat 2\" by simp<br>\n  show ?thesis<br>\n    apply (subst mult_2 [symmetric])<br>\n    apply (auto simp add: Let_def divmod_int_mod_div not_le<br>\n     nat_div_distrib nat_mult_distrib mult_div_cancel mod_2_not_eq_zero_eq_one_int)<br>\n    apply (unfold <code>2 = nat 2</code>)<br>\n    apply (subst nat_mod_distrib [symmetric])<br>\n    apply simp_all<br>\n  done<br>\nqed</p>\n<p>Is there any reason why this is so complex? I would imagine a much simpler equation where<br>\nthe proof is also simple.</p>\n<p>lemma [code]: \"nat k = (if k ≤ 0 then 0 else Suc (nat (k - 1)))\"<br>\nproof (cases k)<br>\n  case (nonneg n)<br>\n  show ?thesis unfolding nonneg<br>\n    by (induct n, auto)<br>\nqed simp</p>\n<p>Best regards,<br>\nRené</p>",
        "id": 294227146,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900530
    },
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:rene.neumann@in.tum.de\">rene.neumann@in.tum.de</a>&gt;<br>\nWhy not something tail-recursive, which, under the assumption that the<br>\ncompiler cannot optimize the above into something tail-recursive, should<br>\nperform even better (probably except for Haskell):</p>\n<p>fun nat' :: \"int ⇒ nat ⇒ nat\" where<br>\n  \"nat' k accu = (if k ≤ 0 then accu else nat' (k - 1) (Suc accu))\"</p>\n<p>lemma nat'_correct:<br>\n  \"nat' k l = nat k + l\"<br>\nproof (cases k)<br>\n  case (nonneg n)<br>\n  show ?thesis unfolding nonneg<br>\n    by (induct n arbitrary: l) simp_all<br>\nqed simp</p>\n<p>lemma [code]: \"nat k = nat' k 0\"<br>\nunfolding nat'_correct by simp</p>\n<ul>\n<li>René<br>\n<a href=\"/user_uploads/14278/GyIQWjzThcXXW5ermUonNOym/smime.p7s\">smime.p7s</a></li>\n</ul>",
        "id": 294227154,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900536
    },
    {
        "content": "<p>From: René Neumann &lt;<a href=\"mailto:rene.neumann@in.tum.de\">rene.neumann@in.tum.de</a>&gt;<br>\nJust for the fun, a simple test:</p>\n<p>fun nat' :: \"int ⇒ nat ⇒ nat\" where<br>\n  \"nat' k accu = (if k ≤ 0 then accu else nat' (k - 1) (Suc accu))\"</p>\n<p>fun nat_th :: \"int ⇒ nat\" where<br>\n  \"nat_th k = (if k ≤ 0 then 0 else Suc (nat_th (k - 1)))\"</p>\n<p>ML {*<br>\n  val y : <a href=\"http://IntInf.int\">IntInf.int</a> = 70000000;</p>\n<p>(* Tail-recursive approach *)<br>\n  val t = <a href=\"http://Time.now\">Time.now</a> ();<br>\n  val _ = @{code nat'} y (@{code nat} 0);<br>\n  val nat_tail = Time.- (<a href=\"http://Time.now\">Time.now</a> (), t);</p>\n<p>(* René Thiemann's approach *)<br>\n  val t = <a href=\"http://Time.now\">Time.now</a> ();<br>\n  val _ = @{code nat_th} y;<br>\n  val nat_th = Time.- (Time.now() , t);</p>\n<p>(* approach from Code_Integer *)<br>\n  val t = <a href=\"http://Time.now\">Time.now</a> ();<br>\n  val _ = @{code nat} y;<br>\n  val nat = Time.- (Time.now(), t);<br>\n*}<br>\nResults:</p>\n<p>val nat_tail = 9.403: Time.time<br>\nval nat_th = 28.333: Time.time<br>\nval nat = 9.594: Time.time</p>\n<p>Here the difference between nat_tail and nat is neglegible. When running<br>\nthe above multiple times, sometimes 'nat_tail' is a little better, other<br>\ntimes 'nat' is.</p>\n<ul>\n<li>René<br>\n<a href=\"/user_uploads/14278/PTb9oY48fNmraFM9q2vCRbeW/smime.p7s\">smime.p7s</a></li>\n</ul>",
        "id": 294227159,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900542
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nNote that if you import HOL/Library/Code_Nat.thy, which declares a<br>\nbinary code representation for type nat, then the implementation of<br>\nfunction nat from Code_Integer is <em>much</em> faster than either nat' or<br>\nnat_th.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294227177,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900555
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nSince my use-case is a more complex program in Haskell, I prefer my version,<br>\nbut indeed for eager languages the tail-recursive variant is more plausible.</p>\n<p>with nat (from library)<br>\n3.32 seconds</p>\n<p>with my version of nat:<br>\n2.61 seconds</p>\n<p>with your tail-rec. version of nat:<br>\n2.76 seconds</p>\n<p>Best regards,<br>\nRené</p>",
        "id": 294227245,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900576
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nPerhaps, then one can load this more complex nat-function only in \"HOL/Library/Code_Nat.thy\"?</p>\n<ul>\n<li>René</li>\n</ul>",
        "id": 294227248,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900579
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nHi Brian,</p>\n<p>Unfortunately, HOL/Library/Code_Nat.thy does not fully work in my case. </p>\n<p>The following short example shows the problem:</p>\n<p>theory Test<br>\n imports \"~~/src/HOL/Library/Code_Nat\"<br>\nbegin</p>\n<p>fun foo where <br>\n  \"foo xs 0 = True\"<br>\n| \"foo [] (Suc _) = False\"<br>\n| \"foo (x # xs) (Suc n) = foo xs n\"</p>\n<p>export_code foo in Haskell file -</p>\n<p>complains about</p>\n<p>\"Nat.Suc\" is not a constructor, on left hand side of equation, in theorem:<br>\nfoo [] (Suc ?uu) ≡ False</p>\n<p>Of course, I can drop the pattern matching on Suc, but I do not want to do that<br>\nmanually for all my functions.</p>\n<p>Cheers,<br>\nRené</p>\n<p>PS: The problem also occurs in the development version of Isabelle where<br>\n  I imported Code_Binary_Nat instead of Code_Nat (changeset ad52ddd35c3a)</p>",
        "id": 294228364,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901136
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nHi René,</p>\n<p>The ML setup in Code_Nat.thy is intended to automatically translate<br>\naway patterns involving Suc, so that you don't have to do it yourself.<br>\nUnfortunately the translation is kind of picky; it only works if for<br>\neach rule with a \"Suc n\" pattern, there is a matching rule with a \"0\"<br>\npattern in its place. E.g. the following modification works with<br>\nCode_Nat.thy in Isabelle2012:</p>\n<p>fun foo where<br>\n  \"foo [] 0 = True\"<br>\n| \"foo (x # xs) 0 = True\"<br>\n| \"foo [] (Suc _) = False\"<br>\n| \"foo (x # xs) (Suc n) = foo xs n\"</p>\n<p>But instead of changing your code, please try out the attached version<br>\nof Code_Nat.thy, where I have modified the code preprocessor.</p>\n<p>Florian: Perhaps you could look at my code and see whether it would be<br>\nsuitable to check in to the development repo. It might still contain<br>\nsome bugs; I haven't tested it on nested patterns like \"Suc (Suc n)\"<br>\nfor example.</p>\n<ul>\n<li>Brian<br>\n<a href=\"/user_uploads/14278/oJ2yUN5cCskUsCZIxKfbjYCe/Code_Nat.thy\">Code_Nat.thy</a></li>\n</ul>",
        "id": 294228478,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901194
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Brian,</p>\n<p>I will put this in my queue which at the moment is near denial of<br>\nservice :-(.  But note that the code originally is from Stefan.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/aLt_imzzahu66t7hdqERlMMO/signature.asc\">signature.asc</a></p>",
        "id": 294228483,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901202
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>fun foo where<br>\n \"foo xs 0 = True\"<br>\n| \"foo [] (Suc _) = False\"<br>\n| \"foo (x # xs) (Suc n) = foo xs n\"</p>\n<p>export_code foo in Haskell file -</p>\n<p>complains about</p>\n<p>\"Nat.Suc\" is not a constructor, on left hand side of equation, in theorem:<br>\nfoo [] (Suc ?uu) ≡ False</p>\n</blockquote>\n<p>The ML setup in Code_Nat.thy is intended to automatically translate<br>\naway patterns involving Suc, so that you don't have to do it yourself.<br>\nUnfortunately the translation is kind of picky; it only works if for<br>\neach rule with a \"Suc n\" pattern, there is a matching rule with a \"0\"<br>\npattern in its place.</p>\n</blockquote>\n<p>I understand.</p>\n<blockquote>\n<p>E.g. the following modification works with<br>\nCode_Nat.thy in Isabelle2012:</p>\n<p>fun foo where<br>\n \"foo [] 0 = True\"<br>\n| \"foo (x # xs) 0 = True\"<br>\n| \"foo [] (Suc _) = False\"<br>\n| \"foo (x # xs) (Suc n) = foo xs n\"</p>\n<p>But instead of changing your code, please try out the attached version<br>\nof Code_Nat.thy, where I have modified the code preprocessor.</p>\n</blockquote>\n<p>Thanks Brian, for the new version of Code_Nat. Unfortunately, it works for foo, <br>\nbut not for other functions. A minimized example that fails is as follows:</p>\n<p>fun double :: \"nat ⇒ nat\" where<br>\n  \"double 0 = 0\"<br>\n| \"double n = n + n\"</p>\n<p>export_code double in Haskell file -</p>\n<p>Constructor as head in equation:<br>\nnat_of_num ?n ≡ plus_nat_inst.plus_nat (pred_numeral ?n) (nat_of_num num.One) </p>\n<p>René</p>",
        "id": 294228505,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901216
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nThis took me a minute to figure out! In this example double.simps<br>\nactually contains the rule \"double (Suc n) = Suc n + Suc n\". Since the<br>\nRHS mentions \"Suc\" we must also generate code for \"Suc\" as well, which<br>\nis where the problem starts.</p>\n<p>In the code equation for Suc, \"Suc n = n + 1\", my code preprocessor<br>\nincorrectly translates away the Suc on the LHS. I attach an updated<br>\nversion that fixes this.</p>\n<p>However, after some more thought I don't think that my general<br>\napproach will work at all for patterns like \"Suc (Suc n)\"; in the long<br>\nrun we'll probably have to stay with a code preprocessor like the<br>\ncurrent one, which can combine multiple equations into single ones<br>\nthat use if-then-else or case.</p>\n<ul>\n<li>Brian<br>\n<a href=\"/user_uploads/14278/eLAQ63V5Cn7ztvrdIcdx2Zpu/Code_Nat.thy\">Code_Nat.thy</a></li>\n</ul>",
        "id": 294228563,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901247
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi René,</p>\n<p>the observation made by Brian has indeed been the primary motiviation<br>\nfor this »representation-ignorant binary digit scanning« equation.<br>\nThere is a high chance that this could be changed in a similar way you<br>\nsuggest.  However, there is a reform of all that code generation<br>\narithmetic stuff ongoing, and this particular issue cannot be dealt in<br>\nisolation with within the distribution.  So, I would recommend to<br>\ndeclare this code equation in your particular application until this<br>\nreform shows up in a release (it is very likely that this will not be<br>\nthe upcoming release).</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/ctiEDi90JoBhi_VJIHH3HUlY/signature.asc\">signature.asc</a></p>",
        "id": 294228698,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901304
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust some side-remarks about the Isabelle/ML that is quoted above:</p>\n<p>* Type int is always the normal mathematical one, i.e. IntInf and Int<br>\n     coincide.  (There are some special tricks to make the different SML<br>\n     implementations underlying Isabelle/ML agree on this.)</p>\n<p>* Structure Timing provides some tools for timing, notably the classic<br>\n     timeit and timeap combinators.  Since timing on multicore hardware<br>\n     is difficult to get right, it currently prints elapsed / CPU / GC time<br>\n     to give some starting points for further guessing.  (In any case it is<br>\n     the standard library entry for that, so when better timing mechanisms<br>\n     become available they will be integrated here.)</p>\n<p>Makarius</p>",
        "id": 294228741,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901333
    },
    {
        "content": "<p>From: René Thiemann &lt;<a href=\"mailto:rene.thiemann@uibk.ac.at\">rene.thiemann@uibk.ac.at</a>&gt;<br>\nHi Florian,</p>\n<p>This is perfectly fine for me. I can easily install my code-equation<br>\nand will also wait on other changes in arithmetic. Anyway, my main <br>\nmotivation for posting my observation was that if one does not know <br>\nabout Code_Nat one obtains strange-looking code for \"nat\".</p>\n<p>Cheers,<br>\nRené</p>",
        "id": 294228806,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901369
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi all,</p>\n<blockquote>\n<blockquote>\n<p>Thanks Brian, for the new version of Code_Nat.</p>\n</blockquote>\n</blockquote>\n<p>see now <a href=\"http://isabelle.in.tum.de/repos/isabelle/rev/0a2371e7ced3\">http://isabelle.in.tum.de/repos/isabelle/rev/0a2371e7ced3</a></p>\n<p>It is now possible, in theory Code_Binary_Nat, to drop the dependency on<br>\nthe venerable preprocessor by Stefan Berghofer (theory<br>\nCode_Abstract_Nat) and install this specific preprocessor instead.</p>\n<blockquote>\n<p>However, after some more thought I don't think that my general<br>\napproach will work at all for patterns like \"Suc (Suc n)\"; in the long<br>\nrun we'll probably have to stay with a code preprocessor like the<br>\ncurrent one, which can combine multiple equations into single ones<br>\nthat use if-then-else or case.</p>\n</blockquote>\n<p>Also the preprocessor from Code_Abstract_Nat cannot compile away all<br>\npatterns: it always needs 0/Suc twins to proceed.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/_PMuNXpRH9dPPItcbIzpVd5I/signature.asc\">signature.asc</a></p>",
        "id": 294234156,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903992
    }
]