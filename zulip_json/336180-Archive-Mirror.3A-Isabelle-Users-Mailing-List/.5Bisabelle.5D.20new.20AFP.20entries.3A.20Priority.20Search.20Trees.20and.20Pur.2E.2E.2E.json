[
    {
        "content": "<p>From: \"Klein, Gerwin (Data61, Kensington NSW)\" &lt;<a href=\"mailto:Gerwin.Klein@data61.csiro.au\">Gerwin.Klein@data61.csiro.au</a>&gt;<br>\nTwo new AFP entries, both by Peter Lammich and Tobias Nipkow:</p>\n<p>Priority Search Trees<br>\n<a href=\"https://www.isa-afp.org/entries/Priority_Search_Trees.html\">https://www.isa-afp.org/entries/Priority_Search_Trees.html</a></p>\n<p>We present a new, purely functional, simple and efficient data structure combining a search tree and a priority queue, which we call a priority search tree. The salient feature of priority search trees is that they offer a decrease-key operation, something that is missing from other simple, purely functional priority queue implementations. Priority search trees can be implemented on top of any search tree. This entry does the implementation for red-black trees. This entry formalizes the first part of our ITP-2019 proof pearl Purely Functional, Simple and Efficient Priority Search Trees and Applications to Prim and Dijkstra.</p>\n<p>Purely Functional, Simple, and Efficient Implementation of Prim and Dijkstra<br>\n<a href=\"https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html\">https://www.isa-afp.org/entries/Prim_Dijkstra_Simple.html</a></p>\n<p>We verify purely functional, simple and efficient implementations of Prim's and Dijkstra's algorithms. This constitutes the first verification of an executable and even efficient version of Prim's algorithm. This entry formalizes the second part of our ITP-2019 proof pearl Purely Functional, Simple and Efficient Priority Search Trees and Applications to Prim and Dijkstra.</p>\n<p>Enjoy!<br>\nGerwin</p>",
        "id": 294757713,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661198241
    }
]