[
    {
        "content": "<p>From: Felix Breuer &lt;<a href=\"mailto:felix@fbreuer.de\">felix@fbreuer.de</a>&gt;<br>\nHello Isabelle Community!</p>\n<p>On Sunday I took my first steps with Isabelle at the very nice and useful Isabelle Tutorial at the Vienna Summer of Logic. Having finished the exercises I am now working on porting a toy proof that I did some time ago using Freek Wiedijk’s miz3 (based on HOL Light) to Isabelle/Isar. In this context, two questions came up:</p>\n<p>1) Does Isabelle have a theory for finite sums of numbers?</p>\n<p>What is the best way to represent in Isabelle/HOL the sum of all integers from 1 to n or the sum of all integers in a given list? Are there theorems for working with sums available? For example, is the rewrite rule (in mathematical/TeX notation):</p>\n<p>\\sum_{i=0}^n a_i = a_0 + \\sum_{i=1}^n</p>\n<p>proved somewhere in Isabelle’s library? A naive search of the library did not turn up anything.</p>\n<p>2) In Isar proofs, is there a way to omit the “by” clause at the end of each statement?</p>\n<p>I find that many steps in Isar proofs can be justified by one of the usual suspects (simp, auto, blast, force,…). Is there a way to omit the “by” clause and have Isabelle implicitly try the most common proof methods in some order? miz3 has this feature and it unclutters miz3 proofs considerably.</p>\n<p>Thanks,<br>\nFelix</p>",
        "id": 294282530,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920833
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nIsabelle supports sums and products over index sets very generally, via axiomatic type classes (allowing just about all kinds of numbers). Index sets can be anything, but there is particular support for intervals of various kinds (over naturals, integers and other ordered types).</p>\n<p>For some proofs over summations, see Convex.thy and Formal_Power_Series.thy in HOL/Library/.</p>\n<p>Larry Paulson</p>",
        "id": 294282548,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920839
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHello Felix,</p>\n<blockquote>\n<p>1) Does Isabelle have a theory for finite sums of numbers?</p>\n</blockquote>\n<p>indeed it does:</p>\n<p>term \"∑i ∈ {0..n}. f i\"</p>\n<blockquote>\n<p>What is the best way to represent in Isabelle/HOL the sum of all<br>\nintegers from 1 to n or the sum of all integers in a given list?</p>\n</blockquote>\n<p>The sum of all integers from 1 to n can be written like this:</p>\n<p>term \"∑i ∈ {1..n}. i\"</p>\n<p>(although here, the types of \"1\", \"n\" and \"i\" are polymorphic; so they<br>\ncan be \"int\" or \"nat\" or ...)</p>\n<p>You can write the above even shorter:</p>\n<p>term \"∑{1..n}\"</p>\n<p>The underlying constant for sums of sets is called \"setsum\", and by<br>\nanalogy, there's also \"listsum\" to compute the sum of the elements in a<br>\nlist.</p>\n<blockquote>\n<p>Are there theorems for working with sums available? For example, is the<br>\nrewrite rule (in mathematical/TeX notation):</p>\n<p>\\sum_{i=0}^n a_i = a_0 + \\sum_{i=1}^n</p>\n</blockquote>\n<p>Let's state this more generally:</p>\n<p>lemma \"k ≤ n ⟹ (∑i ∈ {k..n}. f i) = f k + (∑i ∈ {Suc k..n}. f i)\"</p>\n<p>Isabelle/jEdit tells us:</p>\n<p>Auto solve_direct: The current goal can be solved directly with<br>\n    Set_Interval.setsum_head_Suc:<br>\n    ?m ≤ ?n ⟹ setsum ?f {?m..?n} = ?f ?m + setsum ?f {Suc ?m..?n}</p>\n<p>Your original rule can be proved like this:</p>\n<p>lemma \"0 &lt; (n::nat) ⟹ (∑i ∈ {0..n}. f i) = f 0 + (∑i ∈ {1..n}. f i)\"<br>\n  by (auto simp: setsum_head_Suc)</p>\n<p>For these kinds of things, you might want to try the \"find_theorems\"<br>\ncommand. For example, the query</p>\n<p>find_theorems \"setsum ?f _ = ?f _ + setsum ?f _\"</p>\n<p>finds the relevant theorem and some more.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294282607,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660920845
    },
    {
        "content": "<p>From: Felix Breuer &lt;<a href=\"mailto:felix@fbreuer.de\">felix@fbreuer.de</a>&gt;<br>\nHi Lars and Larry,</p>\n<p>thank you for your help! Just knowing that the right name to search for was “setsum” helped a lot. Just searching for theorems containing “sum” (in the JEdit Query Panel) - as I had done before - finds nothing.</p>\n<p>After some more work, I am now thoroughly stuck again, though: I want to prove:</p>\n<p>lemma \"( ∑ k∈{0..m}. ((f (Suc k)) * (recip f (n - (Suc k)))) ) = ( ∑ k∈{(Suc 0)..(Suc m)}. ((f k) * (recip f (n - k))) )\" </p>\n<p>Whatever f and recip are, this should follow simply from setsum_shift_bounds_cl_Suc_ivl, which reads:</p>\n<p>corollary setsum_shift_bounds_cl_Suc_ivl:<br>\n    \"setsum f {Suc m..Suc n} = setsum (%i. f(Suc i)){m..n}”</p>\n<p>However, I cannot figure out how to get Isabelle to instantiate the corollary in the right way. When I try to prove the lemma using</p>\n<p>by (simp add: setsum_shift_bounds_cl_Suc_ivl)</p>\n<p>I get</p>\n<p>Failed to finish proof⌂:<br>\ngoal (1 subgoal):</p>\n<ol>\n<li>(∑k = 0..m. f (Suc k) * recip f (n - Suc k)) = (∑k = Suc 0..m. f k * recip f (n - k)) + f (Suc m) * recip f (n - Suc m)</li>\n</ol>\n<p>So simp applies a wrong rewrite rule and then gets stuck. Using Sledgehammer to get some hints on how to do it right, only resulted in time outs. So what am I missing?</p>\n<p>Thanks again,<br>\nFelix</p>",
        "id": 294283192,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921035
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 18.07.2014 20:54, Felix Breuer wrote:</p>\n<blockquote>\n<p>Hi Lars and Larry,</p>\n<p>thank you for your help! Just knowing that the right name to search for was “setsum” helped a lot. Just searching for theorems containing “sum” (in the JEdit Query Panel) - as I had done before - finds nothing.<br>\nIn such cases, it might help searching for theorems with a certain name,<br>\ne.g. \"name: set\". Also, you can search for constants of a certain type.<br>\nAfter some more work, I am now thoroughly stuck again, though: I want to prove:</p>\n<p>lemma \"( ∑ k∈{0..m}. ((f (Suc k)) * (recip f (n - (Suc k)))) ) = ( ∑ k∈{(Suc 0)..(Suc m)}. ((f k) * (recip f (n - k))) )\" </p>\n<p>Whatever f and recip are, this should follow simply from setsum_shift_bounds_cl_Suc_ivl, which reads:</p>\n<p>corollary setsum_shift_bounds_cl_Suc_ivl:<br>\n    \"setsum f {Suc m..Suc n} = setsum (%i. f(Suc i)){m..n}”</p>\n<p>However, I cannot figure out how to get Isabelle to instantiate the corollary in the right way. When I try to prove the lemma using</p>\n<p>by (simp add: setsum_shift_bounds_cl_Suc_ivl)<br>\nThere is \"subst\" which applies only a single rule at a single position.<br>\nYou can also instruct simp to use only the given set of rules.</p>\n</blockquote>\n<p>by (subst setsum_shift_bounds_cl_Suc_ivl) ..<br>\n     (* where \"..\" equals \"rule\" for most purposes *)</p>\n<p>or</p>\n<p>by (simp only: setsum_shift_bounds_cl_Suc_ivl)</p>\n<p>Last but not least, you can also identify the wrong rule by using the<br>\nsimplifier trace:</p>\n<p>using [[simp_trace]]<br>\n    apply simp<br>\n    (* Look in the tracing output to identify the wrong rule, then<br>\nreplace apply simp by: *)<br>\n    by (simp del: foo)</p>\n<p>Best regards,<br>\n  Lars</p>",
        "id": 294283231,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660921047
    }
]