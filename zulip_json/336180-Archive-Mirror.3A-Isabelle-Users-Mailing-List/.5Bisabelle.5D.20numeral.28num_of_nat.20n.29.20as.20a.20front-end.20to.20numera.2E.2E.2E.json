[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nThere are:</p>\n<p>(1) the \"num\" datatype,</p>\n<p>(2) the \"numeral\" type class,</p>\n<p>(3) the \"numeral :: num =&gt; 'a\" function in the numeral type class,</p>\n<p>(4) and the \"num_of_nat :: nat =&gt; num\" function.</p>\n<p>So, I make this goal:</p>\n<p>GOAL: Never use the numeral type class directly. Only access numerals, <br>\nwhich are polymorphic, through nat.</p>\n<p>To explain that, I list some \"huge facts\":</p>\n<p>(1) The use of numbers in a number system needs to be consistent, <br>\npractical, and unified, in particular, the use of number system constants.</p>\n<p>(2) The need for pattern matching with numbers is huge!</p>\n<p>(3) The need for recursive functions with numbers is huge!</p>\n<p>(4) Facilitating the magic of \"fun\" for pattern matching and recursion, <br>\nespecially with \"nat\", is huge, huge, huge!</p>\n<p>Types and the need for type coercion complicate things. As I show in the <br>\nsource, the usual subset hierarchy from nat, int, rat, to real is not <br>\nseamless. Even if it was seamless, there are more needs that just to <br>\nhave that hierarchy be seamless.</p>\n<p>What are rational numbers? Abstract rationals are functions which take <br>\nnatural number arguments. I can think of 6 types of rational numbers, 5 <br>\nof which I list using 5 functions that I've defined:</p>\n<p>(1) natN, the natural numbers.</p>\n<p>(2) natZ, the integers.</p>\n<p>(3) natQ, fractions.</p>\n<p>(4) natQm, mixed numbers.</p>\n<p>(5) natQd, terminating decimal numbers.</p>\n<p>(6) Non-terminating decimal numbers, which would be a notationally messy <br>\nform of natQd involving an infinite sum [Wiki].</p>\n<p>If I have functions which give me the rational numbers, which are <br>\nfunctions that take natural numbers, then the irrational numbers are <br>\nspecial constants, or functions which take those constants and/or <br>\nrational numbers (which are functions which take natural numbers).</p>\n<p>Beyond that, it's just a matter of setting up all the notation for those <br>\nfunctions. Unless it's not like that at all.</p>\n<p>I include and attach the source.</p>\n<p>Regards,<br>\nGB</p>\n<p>[Wiki] <a href=\"http://en.wikipedia.org/wiki/Decimal#Other_rational_numbers\">http://en.wikipedia.org/wiki/Decimal#Other_rational_numbers</a></p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\ntheory z140323a__numeral_nat_of_num_front_for_numerals<br>\nimports Complex_Main<br>\nbegin</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* AUTO COERCIONS: NAT &amp; INT DON'T COERCE TO RAT, RAT DOESN'T TO REAL *)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>(<em>yes</em>) term \"(3::nat)::int\"</p>\n<p>(<em>no</em>)(<em>term \"(3::nat)::rat\"</em>)<br>\n(<em>no</em>)(<em>term \"(3::int)::rat\"</em>)</p>\n<p>(<em>yes</em>) term \"(3::nat)::real\"<br>\n(<em>no</em>)(<em>term \"(3::rat)::real\"</em>)<br>\n(<em>yes</em>) term \"(3::int)::real\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* NUMBER OF DIGITS IN A NAT *)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\nfun dec_digits :: \"nat =&gt; nat\" where<br>\n\"dec_digits n = (if (n div 10 = 0) then 1 else 1 + dec_digits(n div 10))\"</p>\n<p>fun bin_digits :: \"nat =&gt; nat\" where<br>\n\"bin_digits n = (if (n div 0b10 = 0) then 1 else 1 + bin_digits(n div <br>\n0b10))\"</p>\n<p>fun hex_digits :: \"nat =&gt; nat\" where<br>\n\"hex_digits n = (if (n div 0x10 = 0) then 1 else 1 + hex_digits(n div <br>\n0x10))\"</p>\n<p>value \"dec_digits 5555 = 4\" (<em>True</em>)<br>\nvalue \"bin_digits 0b1111111111 = 10\" (<em>True</em>)<br>\nvalue \"hex_digits 0xfff = 3\" (<em>True</em>)<br>\nvalue \"hex_digits 2048 = 3\" (<em>True</em>)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* natN, natZ: ABSTRACT NAT AND INTEGER *)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*NOTES:<br>\n(1) Rather than curry natZ, I use (nat * nat). This will allow me to be <br>\nable to<br>\nwork with sets of (nat * nat). Similarly, I use <code>((nat*nat) * (nat*nat))</code><br>\nas a rational.</p>\n<p>(2) \"One = num_of_nat 0\" and \"One = num_of_nat 1\", which means I need class<br>\nzero.<br>\n(a) It's not as simple as \"numeral(num_of_nat n) - numeral(num_of_nat m)\".<br>\n(b) <code>class numeral = one + semigroup_add</code>, so numeral doesn't have zero.<br>\n(c) <code>class neg_numeral = numeral + group_add</code>, so neg_numeral has zero.<br>\n*)<br>\nfun natN :: \"nat =&gt; 'a::{zero,numeral}\" where<br>\n\"natN 0 = 0\"<br>\n|\"natN n = numeral(num_of_nat n)\"</p>\n<p>value \"(natN 0::nat) = 0\"<br>\nvalue \"(numeral(num_of_nat 0)::nat) = 1\"</p>\n<p>fun natZ :: \"(nat * nat) =&gt; 'a::neg_numeral\" where<br>\n\"natZ (0,0) = 0\"<br>\n|\"natZ (n,0) = numeral(num_of_nat n)\"<br>\n|\"natZ (0,n) = -numeral(num_of_nat n)\"<br>\n|\"natZ (n,m) = numeral(num_of_nat n) - numeral(num_of_nat m)\"</p>\n<p>term \"natZ\"</p>\n<p>value \"(natZ (0,0)::int) = 0\"<br>\nvalue \"(natZ (3,0)::int) = 3\"<br>\nvalue \"(natZ (0,3)::int) = -3\"<br>\nvalue \"(natZ (5,3)::int) = 2\"<br>\nvalue \"(natZ (3,5)::int) = -2\"<br>\nvalue \"(natZ (0,0)::'a::neg_numeral) = 0\"<br>\nvalue \"(natZ (3,0)::'a::neg_numeral) = 3\"<br>\nvalue \"(natZ (0,3)::'a::neg_numeral) = -3\"<br>\nvalue \"(natZ (5,3)::'a::neg_numeral) = 2\"<br>\nvalue \"(natZ (3,5)::'a::neg_numeral) = -2\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* natQ FRACTION *)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>fun natQ :: \"((nat * nat) * (nat * nat)) =&gt; 'a::{neg_numeral,inverse}\" <br>\nwhere<br>\n\"natQ (n,d) = natZ n / natZ d\"</p>\n<p>value \"natQ ((5,2),(2,4))::rat\" (* -3/2 *)<br>\nvalue \"natQ ((5,2),(2,4))::'a::{neg_numeral,inverse}\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* natQm MIXED NUMBER *)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)</p>\n<p>abbreviation (input) natQm<br>\n:: \"(nat * nat) =&gt; ((nat * nat) * (nat * nat)) =&gt; <br>\n'a::{neg_numeral,inverse}\"<br>\nwhere \"natQm i q == natZ i + natQ q\"</p>\n<p>term \"natQm (3,0) ((5,2),(2,4))\" (* 3 3/-2 *)<br>\nvalue \"natQm (3,0) ((5,2),(2,4))::rat\" (* 3/2 *)<br>\nvalue \"natQm (3,0) ((3,0),(0,2))::'a::{neg_numeral,inverse}\"<br>\nvalue \"natQm (3,0) ((5,2),(2,4))::'a::{neg_numeral,inverse}\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* natQd TERMINATING DECIMAL NUMBER *)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*NOTE: The <code>digits</code> argument allows for functions that more efficiently<br>\ncalculate the number of digits in <code>frac</code>.*)</p>\n<p>abbreviation (input) natQd<br>\n:: \"(nat =&gt; nat) =&gt; (nat * nat) =&gt; nat =&gt; 'a::{neg_numeral,inverse}\"<br>\nwhere \"natQd digits i frac == natQm i ((frac,0),(10 ^ (digits frac),0))\"</p>\n<p>term \"(natQd dec_digits (3,0) 123)\" (* 3.123 *)<br>\nvalue \"(natQd dec_digits (3,0) 123)::rat\" (* 3123/1000*)<br>\nvalue \"(natQd dec_digits (3,0) 123)::'a::{neg_numeral,inverse}\"</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(* natZA: ABS_INTEG VERSION *)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n(*<br>\n(1) Here I use Abs_Integ to try to be more efficient, but <code>value</code> doesn't<br>\nsimplify Abs_Integ.</p>\n<p>(2) Above, the 4th case, <code>natZ n m</code>, is inefficient for quotient_type <br>\nintegers.<br>\n(a) For ints, subtraction is \"%(x, y) (u, v). (x + v, y + u)\", so<br>\n<code>2 - 3 = natZ 2 3</code> is \"%(2,0) (3,0). (2 + 0, 0 + 3)\", which will get<br>\nexpanded to <code>(1 + 1 + (0 + 0 + 0), 0 + 0 + (1 + 1 + 1))</code>.<br>\n(b) This might not be important. I don't think I would use that case much.<br>\n*)<br>\nfun natZA :: \"(nat * nat) =&gt; int\" where<br>\n\"natZA (0,0) = 0\"<br>\n|\"natZA (n,0) = numeral(num_of_nat n)\"<br>\n|\"natZA (0,n) = -numeral(num_of_nat n)\"<br>\n|\"natZA (n,m) = Abs_Integ(numeral(num_of_nat n), numeral(num_of_nat m))\"</p>\n<p>value \"natZA (0,0)::int\"<br>\nvalue \"natZA (3,0)::int\"<br>\nvalue \"natZA (0,3)::int\"<br>\nvalue \"natZA (3,5)::int\"<br>\nvalue \"natZA (5,3)::int\"<br>\nvalue \"natZA (1,2)::int\" (<em>Abs_Integ (Suc (0∷nat), Suc (Suc (0∷nat)))</em>)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\nend<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\n<a href=\"/user_uploads/14278/B33N35r7z5lpTPA3Owl1dYo6/z140323a__numeral_nat_of_num_front_for_numerals.thy\">z140323a__numeral_nat_of_num_front_for_numerals.thy</a></p>",
        "id": 294273127,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917843
    }
]