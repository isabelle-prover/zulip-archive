[
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Andres,</p>\n<p>It is what it is mostly for historical reasons, but I also seem to recall that<br>\n=simp=&gt; lead to nontermination in same cases (unsurprisingly) and that therefore<br>\nwe restricted its usage. You could try to replace map_cong by your map_cong' and<br>\nsee if anything breaks. If not, that would be a strong indication that the<br>\nmap-congruence rules generated by datatype should always use =simp=&gt;.</p>\n<p>Tobias</p>",
        "id": 294287942,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922477
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Tobias,</p>\n<p>Thanks for the background infos. I pushed the replacement of ==&gt; with =simp=&gt; to testboard <br>\n(see <a href=\"http://isabelle.in.tum.de/testboard/Isabelle/rev/1cbcd78f8d3c\">http://isabelle.in.tum.de/testboard/Isabelle/rev/1cbcd78f8d3c</a>). I expect a few proofs <br>\nin the AFP to break, because they use apply(rule map_cong), but let's see.</p>\n<p>Even if that is the only problem, I doubt that this will be a strong indication either <br>\nway. A grep over the sources revealed just a few places where map_cong is used (map_cong <br>\nis not a default congruence rule); probably because the [simp] rule map_eq_conv takes <br>\nalready care of map equalities.</p>\n<p>Andreas</p>",
        "id": 294288136,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922526
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Tobias,</p>\n<p>Here is the summary of =simp=&gt; vs. ==&gt; in the congruence rule for map. I replaced map_cong <br>\nby map_cong' in List.thy and ran all of the Isabelle distribution (isabelle makeall) and <br>\nthe AFP, thereby fixing what was broken.</p>\n<ol>\n<li>\n<p>Whenenver map_cong was used as a congruence rule, map_cong' also works, without looping.</p>\n</li>\n<li>\n<p>I found three occurrences where map_cong was not used as [cong] that fail with map_cong'.</p>\n</li>\n</ol>\n<p>a) In HOL/Word/Word.thy, it is used with rule. Using it as a congruence rule causes the <br>\nsimplifier to loop, but this is independent of whether ==&gt; or =simp=&gt; is used.</p>\n<p>b) In the AFP entry Affine_Arithmetic is used with subst followed by auto.<br>\n   (simp cong: map_cong') does not solve the goal, either.</p>\n<p>c) In the AFP entry Matrix, there is an instance of the pattern<br>\n   by(rule map_cong)(auto ...)<br>\nBoth (simp cong: map_cong) and (simp cong: map_cong') solve the goal, too.</p>\n<p>In conclusion, =simp=&gt; does not break anything in the tested theories when map_cong is <br>\nused as a congruence rule. Since [fundef_cong] does not handle =simp=&gt; and map_cong seems <br>\nto be useful in some cases (2a,b), we should keep the version with ==&gt;. Possibly, BNF <br>\ncould also generate the congruence rule list.strong_map_cong with =simp=&gt;. The name follow <br>\nthe existing naming convention for ball, bex, SUP, INF, ... (Although I would prefer <br>\nmap_cong_strong because the main operator does not hide somewhere in the middle of the <br>\ntheorem name.)</p>\n<p>Andreas</p>",
        "id": 294288359,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922606
    },
    {
        "content": "<p>From: Jasmin Christian Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<p>Thanks for your thorough investigation.</p>\n<blockquote>\n<p>In conclusion, =simp=&gt; does not break anything in the tested theories when map_cong is used as a congruence rule. Since [fundef_cong] does not handle =simp=&gt; and map_cong seems to be useful in some cases (2a,b), we should keep the version with ==&gt;. Possibly, BNF could also generate the congruence rule list.strong_map_cong with =simp=&gt;. The name follow the existing naming convention for ball, bex, SUP, INF, ... (Although I would prefer map_cong_strong because the main operator does not hide somewhere in the middle of the theorem name.)</p>\n</blockquote>\n<p>Good idea. I would also prefer \"_strong\" as a suffix, for consistency with other \"_strong\"ly-suffixed properties in BNF. We'll add it to our list. If nobody objects, I could also rename \"strong_ball_cong\" etc. to \"ball_cong_strong\" etc. (once Isabelle2014 is out).</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294288384,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922614
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nHi Andreas,</p>\n<p>Thanks for that. For me it sounds pretty conclusive that we should follow your<br>\nrecommendation: let BNF generate both map_cong and map_cong_strong.</p>\n<p>Thanks!<br>\nTobias</p>",
        "id": 294288397,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922618
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIt would improve uniformity.</p>\n<p>Tobias</p>",
        "id": 294288414,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922624
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nI would even argue that there is nothing \"strong\" about those rules <br>\n(since op =simp=&gt; = op ==&gt;). So if renaming anyway, maybe ball_cong_simp <br>\nor even ball_cong_simp_implies is a better name?</p>\n<p>Dmitriy</p>",
        "id": 294288432,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922631
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nI have no strong opinion about the naming schema itself, but it should<br>\nbe uniform afterwards.</p>\n<p>Also note that the situation with sum and prod and sets is a little<br>\ndelicate and demands a suffix pattern due to interpretation, e.g.<br>\nfoo.strong_cong.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/d_OdIplOejXU1MSdYSJJLgzj/signature.asc\">signature.asc</a></p>",
        "id": 294288564,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660922668
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nI wondered why the congruence rule for map does not enable the simplifier to solve <br>\nstatements such as the following. Such statements occur naturally with the induction rules <br>\nfrom the new datatype package when recursion goes through a list.</p>\n<p>lemma \"(⋀x. x ∈ set xs ⟹ f x = g x) ⟹ h (map f (rev xs)) = h (map g (rev xs))\"<br>\n   apply(simp cong: list.map_cong)</p>\n<p>Then, I found he following comment on op =simp=&gt; in HOL.thy:</p>\n<p>text {*<br>\n     The following copy of the implication operator is useful for<br>\n     fine-tuning congruence rules.  It instructs the simplifier to simplify<br>\n     its premise.<br>\n   *}</p>\n<p>definition simp_implies :: \"[prop, prop] =&gt; prop\"  (infixr \"=simp=&gt;\" 1) where<br>\n     \"simp_implies ≡ op ==&gt;\"</p>\n<p>A look at the usages of op =simp=&gt; showed that it is only used in congruence rules for the <br>\nbig operators and bounded quantification. In particular, all of them use it in the form</p>\n<p>!!x. x : ?B =simp=&gt; ?f x = ?g x</p>\n<p>and the same form shows up in list.map_cong. And indeed, if list.map_cong were</p>\n<p>lemma map_cong': \"⟦xs = ys; ⋀x. x ∈ set ys =simp=&gt; f x = g x⟧ ⟹ map f xs = map g ys\"<br>\n   unfolding simp_implies_def by(rule list.map_cong)</p>\n<p>then simp would be able to solve the above goal:</p>\n<p>by(simp cong: map_cong')</p>\n<p>My question now is: What is the advantage of op ==&gt; over op =simp=&gt; in congruence rules, <br>\ni.e., list.map_cong over map_cong'? Since the BNF package generates congruence rules with <br>\nthe structure</p>\n<p>!!x. x : set_type ?A ==&gt; f x = g x</p>\n<p>would it be sensible to use =simp=&gt; there?</p>\n<p>By the way, I noticed that [fundef_cong] cannot deal with =simp=&gt;. But that should not be <br>\nthe only reason for having the weaker cong rule.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294294036,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924007
    }
]