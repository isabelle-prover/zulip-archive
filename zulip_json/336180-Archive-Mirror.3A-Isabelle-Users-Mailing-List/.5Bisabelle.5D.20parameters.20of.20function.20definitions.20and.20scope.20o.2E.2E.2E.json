[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nThnx for the answers to my previous questions. I have 2 more :)</p>\n<p>1) When defining a function using the `fun' keyword, it is not possible <br>\nto use the name of an existing constant as parameter. E.g.,</p>\n<p>definition foo :: \"bool\" where \"foo = True\"</p>\n<p>fun bar :: \"nat =&gt; nat\" where \"bar foo = Suc(foo)\"</p>\n<p>doesn't work. It produces:</p>\n<p>*** Type unification failed: Clash of types \"bool\" and \"nat\"<br>\n*** Type error in application: Incompatible operand type</p>\n<hr>\n<p>*** Operator:  bar :: nat =&gt; nat<br>\n*** Operand:   foo :: bool</p>\n<hr>\n<p>*** At command \"fun\".</p>\n<p>Is that the intended behavior?</p>\n<p>2) Is it possible to <code>hide' previously defined constants that have only \nbe used in some lemmas and aren't needed later on, in order to be able \nto reuse the name? Or put differently, can I use </code>fun' and/or <br>\n`definition' in a local scope (let's say, within a proof)?</p>\n<p>cheers</p>\n<p>christian</p>",
        "id": 294071420,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827315
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nChristian Sternagel wrote:</p>\n<blockquote>\n<p>Thnx for the answers to my previous questions. I have 2 more :)</p>\n<p>1) When defining a function using the `fun' keyword, it is not possible <br>\nto use the name of an existing constant as parameter. E.g.,</p>\n<p>definition foo :: \"bool\" where \"foo = True\"</p>\n<p>fun bar :: \"nat =&gt; nat\" where \"bar foo = Suc(foo)\"</p>\n<p>doesn't work.</p>\n</blockquote>\n<p>You can out an explicit quantifier:</p>\n<p>fun bar :: ... where \"!!foo. bar foo = Suc foo\"</p>\n<p>the specification parser normally puts quantifiers around free variables <br>\nin the spec, but you can also put them explicitly. With this trick you <br>\ncan also influence the order in which variables are quantified in the <br>\ninduction rule.</p>\n<blockquote>\n<p>2) Is it possible to `hide' previously defined constants that have only <br>\nbe used in some lemmas and aren't needed later on, in order to be able <br>\nto reuse the name?</p>\n</blockquote>\n<p>hide const my_const</p>\n<blockquote>\n<p>Or put differently, can I use <code>fun' and/or \n</code>definition' in a local scope (let's say, within a proof)?</p>\n</blockquote>\n<p>Not really... Locales are local scopes in a way, but thats probably <br>\noverkill.</p>\n<p>Alex</p>",
        "id": 294071481,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827340
    }
]