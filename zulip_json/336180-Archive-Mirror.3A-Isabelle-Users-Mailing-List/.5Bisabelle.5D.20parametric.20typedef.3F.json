[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nConsider the following (very simplified) example:</p>\n<p>datatype myDatatype = A | B</p>\n<p>locale fix_n = fixes n :: nat<br>\n  begin</p>\n<p>inductive myProperty :: \"myDatatype =&gt; bool\"<br>\n    where<br>\n    mPA : \"myProperty A\"<br>\n  | mPB : \"even n \\&lt;Longrightarrow&gt; myProperty B\"</p>\n<p>Now I want to define a new type</p>\n<p>typedef myType = \"{X::myDatatype . myProperty X}\"</p>\n<p>This is not accepted:</p>\n<p>*** Illegal application of command \"typedef\" (...) in local theory mode</p>\n<p>Is there a way to do such a thing, or a reason why it cannot be done?</p>\n<p>Notice that leaving locale fix_n, the following is accepted:</p>\n<p>end (<strong> fix_n </strong>)</p>\n<p>consts N :: nat</p>\n<p>interpretation FN:fix_n \"N :: nat\"<br>\n  done</p>\n<p>typedef myType = \"{X::myDatatype . FN.myProperty X}\"<br>\n    by (rule exI[of _ \"A\"], simp add: FN.mPA)</p>\n<p>So Isabelle accepts that parametric definition and reasoning about<br>\nmyType is sound.  But with this approach I will never be able to<br>\ninstantiate the constant N.</p>\n<p>Randy</p>",
        "id": 294091129,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831878
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 12 Oct 2009, Randy Pollack wrote:</p>\n<blockquote>\n<p>Consider the following (very simplified) example:</p>\n<p>datatype myDatatype = A | B</p>\n<p>locale fix_n = fixes n :: nat<br>\n begin</p>\n<p>inductive myProperty :: \"myDatatype =&gt; bool\"<br>\n   where<br>\n   mPA : \"myProperty A\"<br>\n | mPB : \"even n \\&lt;Longrightarrow&gt; myProperty B\"</p>\n<p>Now I want to define a new type</p>\n<p>typedef myType = \"{X::myDatatype . myProperty X}\"</p>\n<p>This is not accepted:</p>\n<p>*** Illegal application of command \"typedef\" (...) in local theory mode</p>\n<p>Is there a way to do such a thing, or a reason why it cannot be done?</p>\n</blockquote>\n<p>HOL typedef can (and will) be \"localized\", but the rhs must not depend on <br>\nterm parameters of the local context, otherwise HOL would magically <br>\nacquire a form of dependent types.  (Dependency on assumptions is no <br>\nproblem.)</p>\n<blockquote>\n<p>Notice that leaving locale fix_n, the following is accepted:</p>\n<p>end (<strong> fix_n </strong>)</p>\n<p>consts N :: nat</p>\n<p>interpretation FN:fix_n \"N :: nat\"<br>\n done</p>\n<p>typedef myType = \"{X::myDatatype . FN.myProperty X}\"<br>\n   by (rule exI[of _ \"A\"], simp add: FN.mPA)</p>\n<p>So Isabelle accepts that parametric definition and reasoning about <br>\nmyType is sound.  But with this approach I will never be able to <br>\ninstantiate the constant N.</p>\n</blockquote>\n<p>In principle such underspecified global constants can instantiated later <br>\nby theory interpretation, in the style of the AWE tool from Bremen.</p>\n<p>Makarius</p>",
        "id": 294091199,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660831916
    }
]