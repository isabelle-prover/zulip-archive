[
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nHi Chris,</p>\n<blockquote>\n<p>In general, my current idea is to have something, where I could do the <br>\nfollowing:</p>\n<p>monad option: \"option\" begin<br>\n  definition \"return x == Some x\"<br>\n  definition \"bind m f == case m of Some x =&gt; f x | e =&gt; e\"<br>\n  (* maybe 'fail' for pattern-match errors? *)<br>\n  definition \"fail = None\"</p>\n<p>monad_laws by (...)<br>\nend</p>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p>which then provides the usual &gt;&gt;= and &gt;&gt; combinators as well as <br>\ndo-notation for the option type and the sum type (I'm not yet sure if it <br>\nis a good idea / necessary to proof the monad laws for every instance).</p>\n</blockquote>\n<p>What would the tool do with the proofs of the monad laws?<br>\nIf they are just thrown away or stored under some name, then there is <br>\nlittle value to it. One could also imagine the tool defining derived <br>\noperations like mapM and prove laws about them, but this may be going <br>\ntoo far.</p>\n<blockquote>\n<p>This looks very much like type classes. Hence an obvious question would <br>\nbe: will there ever be higher-kinded type classes in Isabelle? Is this <br>\neven possible? Of course, it would be futile to make a special \"monad\" <br>\nversion if there is a more general solution.</p>\n</blockquote>\n<p>Constructor classes is not something that one can easily mount on top of <br>\nan existing logic, so I am quite sure that this can only happen if one <br>\nfinds a way of moving all this into user-space... But this is a <br>\ndifferent story.</p>\n<p>I think the main advantage of a \"monad package\" as you describe it is<br>\nthat it streamlines the syntax translations. Making a few extra <br>\ndefinitions and proving some laws is something that a user easily does <br>\nhimself, but the translations are always painful and hard to get right.</p>\n<blockquote>\n<p>Another question: would this be useful/used for/by users/you? :D</p>\n</blockquote>\n<p>If it is simple and does it's job well, I am sure that there are as many <br>\nuses for it as there are monads out there.</p>\n<p>One further point: The begin-end syntax you have in mind is something <br>\nthat can only be implemented by a \"target\". Targets are the most complex <br>\npart of the local theory infrastructure, and you probably don't want to <br>\nimplement one \"at home\" unless you have a very very good reason.</p>\n<p>A simpler interface would do just as well, such as</p>\n<p>monad option<br>\n   where return = \"Some\"<br>\n   and bind = \"option_bind\"</p>\n<p>Maybe one should not make new constant definitions here but simply <br>\nassume that they are already constants with the appropriate definition <br>\n(So one can use inductive/primrec/function to define them). Then the <br>\nmonad command would basically be equivalent to the translation <br>\nfunctions, except that it would work out of the box.</p>\n<p>Alex</p>",
        "id": 294108401,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835976
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHi all,</p>\n<p>@makarius:<br>\n1) Sorry for mixing up notions. I do fully agree that it is very <br>\nimportant to be concise in order to avoid misunderstandings :)</p>\n<p>2) Syntax.add_term_check sounds interesting and I will give it a try.</p>\n<p>@alex:<br>\n1) My interest in the do-notation was actually caused by <br>\nHOL/Library/State_Monad.thy when browsing Isabelle's library. I will <br>\nalso have a look at the heap monad.</p>\n<p>2) I would very much like to unify all this :D, however, I'm not sure if <br>\nI can manage. Nevertheless, I'll give it a try and consider it as a <br>\ntraining session in Isabelle ML programming.</p>\n<p>In general, my current idea is to have something, where I could do the <br>\nfollowing:</p>\n<p>monad option: \"option\" begin<br>\n   definition \"return x == Some x\"<br>\n   definition \"bind m f == case m of Some x =&gt; f x | e =&gt; e\"<br>\n   (* maybe 'fail' for pattern-match errors? *)<br>\n   definition \"fail = None\"</p>\n<p>monad_laws by (...)<br>\nend</p>\n<p>monad error: \"+\" begin<br>\n   definition \"return x == Inr x\"<br>\n   definition \"bind m f == case m of Inl x =&gt; f x | e =&gt; e\"<br>\n   (* maybe 'fail' for pattern-match errors? *)<br>\n   definition \"fail = Inl undefined\"</p>\n<p>monad_laws by (...)<br>\nend</p>\n<p>which then provides the usual &gt;&gt;= and &gt;&gt; combinators as well as <br>\ndo-notation for the option type and the sum type (I'm not yet sure if it <br>\nis a good idea / necessary to proof the monad laws for every instance).</p>\n<p>This looks very much like type classes. Hence an obvious question would <br>\nbe: will there ever be higher-kinded type classes in Isabelle? Is this <br>\neven possible? Of course, it would be futile to make a special \"monad\" <br>\nversion if there is a more general solution.</p>\n<p>Another question: would this be useful/used for/by users/you? :D</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294108422,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835981
    }
]