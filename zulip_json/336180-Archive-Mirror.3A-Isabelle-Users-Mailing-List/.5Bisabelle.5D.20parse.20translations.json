[
    {
        "content": "<p>From: Matthias Schmalz &lt;<a href=\"mailto:Matthias.Schmalz@inf.ethz.ch\">Matthias.Schmalz@inf.ethz.ch</a>&gt;<br>\n-----BEGIN PGP SIGNED MESSAGE-----<br>\nHash: SHA1</p>\n<blockquote>\n<p>Is this some standard notion of Event-B explained in the literature<br>\nsomewhere?</p>\n</blockquote>\n<p>Yes and no. It is some standard Event-B notation (set comprehension) but<br>\nI am not aware of an explanation in the literature. I have thus written<br>\nmy own specification documentation:<br>\nftp://ftp.inf.ethz.ch/pub/publications/tech-reports/6xx/698.pdf</p>\n<p>Avoiding auxiliary notation, the Event-B set comprehension<br>\n\"{x y. phi x y .| t x y}\"<br>\nstands for<br>\n\"(if<br>\n  \\&lt;forall&gt; phi x y.<br>\n    phi x y \\&lt;noteq&gt; None \\&lt;and&gt; (the (phi x y) --&gt; t x y \\&lt;noteq&gt; None)<br>\nthen Some {the (t x y) | x y. the (phi x y)}<br>\nelse None)\"</p>\n<blockquote>\n<p>You then provide ML 'parse_translation' and 'print_translation' in the<br>\nknown manner.  Moreover, the inner check/uncheck phase is configured<br>\nlike this:</p>\n<p>declaration {* K (Syntax.add_term_check 0 \"my_check\" my_check) *}</p>\n<p>Here my_check is your function to operate on simultatenously on a given<br>\ninput or output situation (consiting of terms).  It returns either SOME<br>\nchanged result, or NONE for identity.  See also e.g. see<br>\nsrc/Pure/Isar/proof_context.ML how expand_abbrevs and contract_abbrevs<br>\nare done.  This is really a user-space mechanism.</p>\n</blockquote>\n<p>I think this is the missing piece of the puzzle. I have been unaware<br>\nthat I can install transformations after type checking.</p>\n<p>Thanks,<br>\nMatthias<br>\n-----BEGIN PGP SIGNATURE-----<br>\nVersion: GnuPG v1.4.6 (GNU/Linux)<br>\nComment: Using GnuPG with Mozilla - <a href=\"http://enigmail.mozdev.org\">http://enigmail.mozdev.org</a></p>\n<p>iD8DBQFNQFuwczhznXSdWggRAhRmAJ9XkaiVKy2RkFHSm7eYLGrzFCmyOACfWgbC<br>\nETux71Xyh2E/whWf0IQgd48=<br>\n=KMHG<br>\n-----END PGP SIGNATURE-----</p>",
        "id": 294126568,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660841481
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nNot really, at least not at the raw parse tree level. Duplication of <br>\nsubtrees as above (and likewise comparison of subtrees for printing) looks <br>\nsuspicious.</p>\n<p>Nonetheless, it should work by separating the concrete from the abstract <br>\nsyntax.  I.e. \"foo\" is like a regular binder, and there is an abbreviation <br>\nfor the rest. Abbreviations work by higher-order rewriting on fully-typed <br>\nlambda terms.</p>\n<p>Makarius</p>",
        "id": 294127625,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660841783
    },
    {
        "content": "<p>From: Matthias Schmalz &lt;<a href=\"mailto:Matthias.Schmalz@inf.ethz.ch\">Matthias.Schmalz@inf.ethz.ch</a>&gt;<br>\n-----BEGIN PGP SIGNED MESSAGE-----<br>\nHash: SHA1</p>\n<p>Makarius schrieb:</p>\n<blockquote>\n<p>On Fri, 14 Jan 2011, Matthias Schmalz wrote:</p>\n<blockquote>\n<ol>\n<li>Consider the following contrieved parse translation translating<br>\n\"foo x. t\" to \"(\\&lt;forall&gt; x. t) \\&lt;and&gt; (\\&lt;forall&gt; x. t)\":</li>\n</ol>\n<p>term \"foo x. True\"<br>\n(with show_types activated) I get<br>\n\"(\\&lt;forall&gt; x::'a. True) \\&lt;and&gt; (\\&lt;forall&gt; x::'b. True)\".<br>\n(The two occurrences of x have different types.)</p>\n<p>Is it possible to change the parse translation so that<br>\nterm \"foo x. True\"<br>\nyields \"(\\&lt;forall&gt; x::'a. True) \\&lt;and&gt; (\\&lt;forall&gt; x::'a. True)\".<br>\n(The two occurrences of x have the same type.)</p>\n</blockquote>\n<p>Not really, at least not at the raw parse tree level. Duplication of<br>\nsubtrees as above (and likewise comparison of subtrees for printing)<br>\nlooks suspicious.</p>\n</blockquote>\n<p>That is good to know. So I will stop trying.</p>\n<blockquote>\n<p>Nonetheless, it should work by separating the concrete from the abstract<br>\nsyntax.  I.e. \"foo\" is like a regular binder, and there is an<br>\nabbreviation for the rest. Abbreviations work by higher-order rewriting<br>\non fully-typed lambda terms.</p>\n</blockquote>\n<p>The binder(s) I actually want to define has the following characteristics:</p>\n<ol>\n<li>binds several variables (like \\&lt;forall&gt;, \\&lt;exists&gt;, set comprehension)</li>\n<li>\n<p>no simple recursive definition (like set comprehension, unlike<br>\n\\&lt;forall&gt;, as \\&lt;forall&gt; x xs. p == \\&lt;forall&gt; x. \\&lt;forall&gt; xs. p)</p>\n</li>\n<li>\n<p>the right-hand side of the definition has an extra bound variable<br>\n(like set comprehension:<br>\n{t | xs. p} == {y. \\&lt;exists&gt; xs. y = t \\&lt;and&gt; p})</p>\n</li>\n<li>\n<p>the right-hand side binds the bound variables of the left-hand side<br>\nseveral times such as in:<br>\nfoo xs. p == (\\&lt;forall&gt; xs. p) \\&lt;and&gt; (\\&lt;exists&gt; xs. p)</p>\n</li>\n</ol>\n<p>The multiple bound variables make it hard to work with abbreviations.<br>\nI will try to cook something up with overloading (to cope with the<br>\narbitrary number of bound variables). If that does not work out, I will<br>\ndefine (on demand) several constants foo1, foo2, ..., one for each<br>\nnumber of bound variables.</p>\n<p>Maybe somebody on the list can point to a running example of a binder<br>\nwith the above properties? That would be helpful.</p>\n<p>Anyway, thanks for the explanations,<br>\nMatthias</p>\n<p>-----BEGIN PGP SIGNATURE-----<br>\nVersion: GnuPG v1.4.6 (GNU/Linux)<br>\nComment: Using GnuPG with Mozilla - <a href=\"http://enigmail.mozdev.org\">http://enigmail.mozdev.org</a></p>\n<p>iD8DBQFNMyPfczhznXSdWggRAlcOAJ99BjR5aGRtjitF4CoPNY4bvIv5eQCeLZoe<br>\n/D5T7dSFzOeQlzXAEuswYxc=<br>\n=2xd+<br>\n-----END PGP SIGNATURE-----</p>",
        "id": 294127716,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660841813
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIs this some standard notion of Event-B explained in the literature <br>\nsomewhere?</p>\n<p>Anyway, the aforementioned idea of separating the concrete syntax (with <br>\nthe binding) from the abstract syntax (with the duplication of subterms) <br>\nworks along these lines:</p>\n<p>abbreviation Foo :: \"('a =&gt; bool) =&gt; bool\" (binder \"FOO \" 10)<br>\n     where \"Foo b == (ALL x. b x) &amp; (EX x. b x)\"</p>\n<p>There are two syntax layers involved here: the \"binder\" annotation <br>\nproduces some standard parse/print translation for iterated binders; the <br>\nrewrite rule operates on fully type-checked lambda terms -- when the <br>\nregular type-inference is already finished.</p>\n<p>At both layers you can install your own ML function to operate on parse <br>\nterms and typed lambda terms, respectively.  You merely declare an <br>\nuninterpreted constant like this:</p>\n<p>axiomatization Foo :: \"('a =&gt; bool) =&gt; bool\"</p>\n<p>or any other type scheme that fits for your application.  Note that <br>\n'axiomatization' instead of 'consts' ensures that the user cannot <br>\naccidentally define Foo later on.</p>\n<p>You then provide ML 'parse_translation' and 'print_translation' in the <br>\nknown manner.  Moreover, the inner check/uncheck phase is configured like <br>\nthis:</p>\n<p>declaration {* K (Syntax.add_term_check 0 \"my_check\" my_check) *}</p>\n<p>Here my_check is your function to operate on simultatenously on a given <br>\ninput or output situation (consiting of terms).  It returns either SOME <br>\nchanged result, or NONE for identity.  See also e.g. see <br>\nsrc/Pure/Isar/proof_context.ML how expand_abbrevs and contract_abbrevs are <br>\ndone.  This is really a user-space mechanism.</p>\n<p>Makarius</p>",
        "id": 294128729,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660842096
    }
]