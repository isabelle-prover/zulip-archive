[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nI would like to define some set-valued functions whose recursive definition does not <br>\nterminate. I know that such functions can in principle be defined with inductive_set, but <br>\ninductive_set does not allow parameters of the function to change in recursive calls (see <br>\n<a href=\"http://stackoverflow.com/questions/16603886/inductive-set-with-non-fixed-parameters\">http://stackoverflow.com/questions/16603886/inductive-set-with-non-fixed-parameters</a>). So I <br>\nthought I should give partial_function a try, as sets form a ccpo with the standard subset <br>\nordering. Setting up partial_function for sets is straightforward, but I am have trouble <br>\nwith the induction rule:</p>\n<p>lemma fixp_induct_set:<br>\n   fixes F :: \"'c =&gt; 'c\"<br>\n   and U :: \"'c =&gt; 'b =&gt; 'a set\"<br>\n   and C :: \"('b =&gt; 'a set) =&gt; 'c\"<br>\n   and P :: \"'b =&gt; 'a =&gt; bool\"<br>\n   assumes mono: \"!!x. monotone (fun_ord op &lt;=) op &lt;= (%f. U (F (C f)) x)\"<br>\n   and eq: \"f == C (ccpo.fixp (fun_lub Sup) (fun_ord op &lt;=) (%f. U (F (C f))))\"<br>\n   and inverse2: \"!!f. U (C f) = f\"<br>\n   and step: \"!!f x y. [| y : U (F f) x; !!x y. y : U f x ==&gt; P x y |] ==&gt; P x y\"<br>\n   and enforce_variable_ordering: \"x = x\"<br>\n   and elem: \"y : U f x\"<br>\n   shows \"P x y\"</p>\n<p>Note the bogus assumption enforce_variable_ordering. Without it, the variable y occurs <br>\nbefore x in the order of variables of the theorem. partial_function then tries to <br>\ninstantiate them in the wrong way and I get a type error. For example:</p>\n<p>partial_function (set) test :: \"nat =&gt; int set\"<br>\nwhere \"test n = {}\"</p>\n<p>*** exception THM 0 raised (line 1155 of \"thm.ML\"):<br>\n*** instantiate: type conflict<br>\n***   ?y :: int<br>\n***   n :: nat<br>\n*** [| !!x. monotone (fun_ord op &lt;=) op &lt;= (%f. ?F f x);<br>\n***  ?f == ccpo.fixp (fun_lub Union) (fun_ord op &lt;=) ?F;<br>\n***  !!f x y. [|y : ?F f x; !!x y. y : f x ==&gt; ?P x y|] ==&gt; ?P x y; ?y : ?f ?x|]<br>\n*** ==&gt; ?P ?x ?y<br>\n*** At command \"partial_function\"</p>\n<p>With the superflous assumption enforce_variable_ordering, partial_function accepts the <br>\nspecification. Is this a known limitation of partial_function? Is there some other way to <br>\nenforce the variable ordering of a theorem or to tell partial_function to instantiate <br>\nvariables in the reversed order?</p>\n<p>Cheers,<br>\nAndreas</p>\n<p>PS: If other people find partial_function for sets useful, I could add the setup to the <br>\nrepository.</p>",
        "id": 294243689,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908054
    }
]