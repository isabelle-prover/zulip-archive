[
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nUsing the function package I cannot prove pattern compatibility with <br>\nunary occurrence of \"*_sumC\" in the proof obligation, which I see happen <br>\nquite often, e.g.[1].</p>\n<p>Interestingly, the example on p.2 of the \"Tutorial on Function <br>\nDefinition\" is solved automatically by \"fun\", but \"function\" creates <br>\nthat kind of obligation, which is NOT provable \"by auto\":</p>\n<p>function sep :: \"'a ? 'a list ? 'a list\" where<br>\n      \"sep a (x # y # xs) = x # a # sep a (y # xs)\"<br>\n    | \"sep a xs = xs\"<br>\n    apply pat_completeness<br>\n    apply simp<br>\n    defer<br>\n    apply simp<br>\n    ------------------------------------------<br>\n    proof (prove): step 4</p>\n<p>goal (1 subgoal):<br>\n     1. ?a x y xs aa xsa.<br>\n           (a, x # y # xs) = (aa, xsa) ?<br>\n           x # a # sep_sumC (a, y # xs) = xsa</p>\n<p>For learning how to prove this kind of obligations it seems very helpful <br>\nto have the above example proved explicitly --- is there some of the <br>\nexperts, who could spend a few minutes on that, please ?</p>\n<p>Walther</p>\n<p>PS: I scanned the documentation without findings: did I overlook something?<br>\nAnd I scanned  the mailing list with some findings [2/3, 4/5], but <br>\nwithout coming to a clue.</p>\n<p>[1] the rhs of the conclusion contains dvd_up_sumC, the lhs does not; so <br>\none needs some properties of dvd_up_sumC for proving equality, e.g <br>\n\"dvd_up_sumC (ds, rest) = ds mod rest\" (which easily can be proved under <br>\nthe assumptions given):</p>\n<p>3. ?d p ds ps.<br>\n        ([d], [p]) = (ds, ps) ?<br>\n        (p mod d = 0) =<br>\n        (let ds = drop_lc0 ds; ps = drop_lc0 ps; d000 = replicate <br>\n(length ps - length ds) 0 @ ds;<br>\n             quot = GCD_Poly_FP.lcoeff ps div2 GCD_Poly_FP.lcoeff d000;<br>\n             rest = drop_lc0 (ps minus_up (d000 mult_ups quot))<br>\n         in if rest = [] then True<br>\n            else if quot ? 0 ? length ds ? length rest then dvd_up_sumC <br>\n(ds, rest) else False)</p>\n<p>[2] <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-March/msg00023.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-March/msg00023.html</a><br>\n[3] <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-March/msg00026.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2011-March/msg00026.html</a><br>\n[4] <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-February/msg00001.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-February/msg00001.html</a><br>\n[5] <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-February/msg00002.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2010-February/msg00002.html</a></p>",
        "id": 294239503,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906326
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Walter,</p>\n<p>function (sequential) ...</p>\n<p>instead of just</p>\n<p>function ...</p>\n<p>does the trick (together with pat_completeness and auto). Without the <br>\nsequential option the defining equations must be disjoint and complete. <br>\nSee also \"isabelle doc functions\".</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294239510,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906328
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nChristian,</p>\n<p>thanks for reply !</p>\n<p>Your suggestion ...</p>\n<blockquote>\n<p>function (sequential) ...</p>\n<p>instead of just</p>\n<p>function ...</p>\n<p>does the trick (together with pat_completeness and auto). </p>\n</blockquote>\n<p>helped me to pin down my problem: \"function (sequential) sep ... \" <br>\ncreates these obligations for pattern compatibility:</p>\n<p>goal (6 subgoals):</p>\n<p>1. ?a x y xs aa xa ya xsa.<br>\n            (a, x # y # xs) = (aa, xa # ya # xsa) ?<br>\n            x # a # sep_sumC (a, y # xs) = xa # aa # sep_sumC (aa, ya # xsa)</p>\n<p>2. ?a x y xs aa. (a, x # y # xs) = (aa, []) ? x # a # sep_sumC (a, <br>\ny # xs) = []</p>\n<p>3. ?a x y xs aa v. (a, x # y # xs) = (aa, [v]) ? x # a # sep_sumC <br>\n(a, y # xs) = [v]</p>\n<p>4. ?a aa. (a, []) = (aa, []) ? [] = []<br>\n      5. ?a aa v. (a, []) = (aa, [v]) ? [] = [v]<br>\n      6. ?a v aa va. (a, [v]) = (aa, [va]) ? [v] = [va]</p>\n<p>My interest was for 'mixed' obligations like 3./4. above, where \"_sumC\" <br>\noccurs only once: I wanted to prove the equalities (which is impossible <br>\nwithout knowledge about \"_sumC\") under the assumptions.</p>\n<p>Now I see (thanks to your help!), that these obligations are proved <br>\nusing the fact that the <em>assumptions</em>, \"(a, x # y # xs) = (aa, [])\" and <br>\n\"(a, x # y # xs) = (aa, [v])\", <em>are not satisfiable</em> ('ex falso <br>\nqodlibet'). The simplifier knows theorems like \"List.inject\", <br>\n\"List.distinct_2\" etc good enough to end up with</p>\n<p>a # sep_sumC (a, y # xs) = [] ? False</p>\n<p>In the case of the function I am trying to define [1], I get 15 <br>\nobligations: the 11 'non-mixed' obligations are solved \"by simp\" (which <br>\neach takes a few seconds for each).<br>\nHowever, the 4 'mixed' obligations cannot be proved \"by simp\" (which <br>\nloop somewhere I can not yet identify in the trace), although they all <br>\nhave non-satisfiable assumptions...</p>\n<p>1. ?d p v vb vc ps. ([d], [p]) = (v # vb # vc, ps) ? ...<br>\n     2. ?d p ds v vb vc. ([d], [p]) = (ds, v # vb # vc) ? ...<br>\n     3. ?ps v vb vc psa. ([], ps) = (v # vb # vc, psa) ? ...<br>\n     4. ?ds dsa v vb vc. (ds, []) = (dsa, v # vb # vc) ? ...</p>\n<p>So, instead of tweaking the simplifier, it seems to suffice to show the <br>\nassumptions not satisfiable ;-))) ... thanks a lot !!!</p>\n<p>Walther</p>\n<p>[1] I am stuck with dvd for univariate polynomials:<br>\n     function (sequential) dvd_unipoly :: \"unipoly ? unipoly ? bool\" <br>\n(infixl \"dvd'_unipoly\" 70) where<br>\n       \"[d] dvd_unipoly [p] = ((¦d¦ ? ¦p¦) &amp; (p mod d = 0))\"<br>\n     | \"ds dvd_unipoly ps =<br>\n         (let<br>\n           ds = drop_lc0 ds; ps = drop_lc0 ps;<br>\n           d000 = (List.replicate (List.length ps - List.length ds) 0) @ ds;<br>\n           quot = (lcoeff ps) div2 (lcoeff d000);<br>\n           rest = drop_lc0 (ps minus_up (d000 mult_ups quot))<br>\n         in<br>\n           if rest = [] then True else<br>\n             if quot ? 0 &amp; List.length ds ? List.length rest then ds <br>\ndvd_unipoly rest else False)\"</p>\n<blockquote>\n<p>On 04/13/2013 05:52 PM, Walther Neuper wrote:</p>\n<blockquote>\n<p>Using the function package I cannot prove pattern compatibility with<br>\nunary occurrence of \"*_sumC\" in the proof obligation, which I see happen<br>\nquite often, e.g.[1].</p>\n<p>Interestingly, the example on p.2 of the \"Tutorial on Function<br>\nDefinition\" is solved automatically by \"fun\", but \"function\" creates<br>\nthat kind of obligation, which is NOT provable \"by auto\":</p>\n<p>function sep :: \"'a ? 'a list ? 'a list\" where<br>\n       \"sep a (x # y # xs) = x # a # sep a (y # xs)\"<br>\n     | \"sep a xs = xs\"<br>\n     apply pat_completeness<br>\n     apply simp<br>\n     defer<br>\n     apply simp<br>\n     ------------------------------------------<br>\n     proof (prove): step 4</p>\n<p>goal (1 subgoal):<br>\n      1. ?a x y xs aa xsa.<br>\n            (a, x # y # xs) = (aa, xsa) ?<br>\n            x # a # sep_sumC (a, y # xs) = xsa</p>\n<p>For learning how to prove this kind of obligations it seems very helpful<br>\nto have the above example proved explicitly --- is there some of the<br>\nexperts, who could spend a few minutes on that, please ?</p>\n<p>Walther</p>\n<p>PS: I scanned the documentation without findings: did I overlook <br>\nsomething?<br>\nAnd I scanned  the mailing list with some findings [2/3, 4/5], but<br>\nwithout coming to a clue.</p>\n<p>[1] the rhs of the conclusion contains dvd_up_sumC, the lhs does not; so<br>\none needs some properties of dvd_up_sumC for proving equality, e.g<br>\n\"dvd_up_sumC (ds, rest) = ds mod rest\" (which easily can be proved under<br>\nthe assumptions given):<br>\n  3. /\\ d p ds ps.<br>\n        ([d], [p]) = (ds, ps) ==&gt;<br>\n        (p mod d = 0) =<br>\n        (let ds = drop_lc0 ds; ps = drop_lc0 ps; d000 = replicate<br>\n(length ps - length ds) 0 @ ds;<br>\n             quot = GCD_Poly_FP.lcoeff ps div2 GCD_Poly_FP.lcoeff d000;<br>\n             rest = drop_lc0 (ps minus_up (d000 mult_ups quot))<br>\n         in if rest = [] then True<br>\n            else if quot ? 0 ? length ds ? length rest then <br>\ndvd_up_sumC (ds, rest) else False)</p>\n</blockquote>\n</blockquote>",
        "id": 294239527,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660906334
    }
]