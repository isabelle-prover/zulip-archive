[
    {
        "content": "<p>From: Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt;<br>\nI'm trying to define an inductive set of type \"token list set\", where<br>\n\"token\" is just some datatype. Initially I had definitions along the<br>\nlines of this:</p>\n<p>datatype token = C1 nat | C2 nat</p>\n<p>inductive_set P where<br>\nbase: \"[C1 1, C2 2] : P\" |<br>\nother: \"ws @ [C1 x, C2 y] @ zs : P ==&gt; ws @ [C1 x, C1 m, C2 n, C2 y] @ zs : P\"</p>\n<p>This is a clear, correct way of defining it. However, it's not at<br>\n<em>all</em> easy to work with when proving membership, whether forwards or<br>\nbackwards, because of the need to break of the list one is unifying<br>\nwith before applying the rule. So I tried changing it to this:</p>\n<p>inductive_set P where<br>\nbase: \"[C1 1, C2 2] : P\" |<br>\nother: \"[| base : P; take 2 (drop n base) = [C1 x, C2 y] |] ==&gt;<br>\ninsert_list [C1 m, C2 n] base (n + 1) : P\"</p>\n<p>(\"insert_list x y n\" puts x into y at n.) This definition, besides<br>\nbeing less clear, doesn't actually work, as \"= [x, y]\" doesn't perform<br>\npattern matching. Instead, the equality asserts that (take a b) = [x,<br>\ny] for any x and y, which is obviously not true.</p>\n<p>Is there a better way to do this? Is there maybe a way to get the<br>\nsecond example to work?</p>\n<p>Chris Capel</p>",
        "id": 294072023,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827524
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYour second definition looks correct to me. But it is probably not much<br>\neasier to use than the first. I would stick to the first definition and<br>\nwrite structured proofs where you rearrange the list into the required<br>\nform (one simp step will do that) before apply the rule.</p>\n<p>Tobias</p>\n<p>Chris Capel schrieb:</p>",
        "id": 294072051,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827532
    },
    {
        "content": "<p>From: Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt;<br>\nChris Capel wrote:</p>\n<blockquote>\n<p>I'm trying to define an inductive set of type \"token list set\", where<br>\n\"token\" is just some datatype. Initially I had definitions along the<br>\nlines of this:</p>\n<p>datatype token = C1 nat | C2 nat</p>\n<p>inductive_set P where<br>\nbase: \"[C1 1, C2 2] : P\" |<br>\nother: \"ws @ [C1 x, C2 y] @ zs : P ==&gt; ws @ [C1 x, C1 m, C2 n, C2 y] @ zs : P\"</p>\n<p>This is a clear, correct way of defining it. However, it's not at<br>\n<em>all</em> easy to work with when proving membership, whether forwards or<br>\nbackwards, because of the need to break of the list one is unifying<br>\nwith before applying the rule. So I tried changing it to this:</p>\n<p>inductive_set P where<br>\nbase: \"[C1 1, C2 2] : P\" |<br>\nother: \"[| base : P; take 2 (drop n base) = [C1 x, C2 y] |] ==&gt;<br>\ninsert_list [C1 m, C2 n] base (n + 1) : P\"</p>\n<p>(\"insert_list x y n\" puts x into y at n.) This definition, besides<br>\nbeing less clear, doesn't actually work, as \"= [x, y]\" doesn't perform<br>\npattern matching. Instead, the equality asserts that (take a b) = [x,<br>\ny] for any x and y, which is obviously not true.</p>\n<p>??? Aren't x and y implicitly universally quantified over the _whole_ rule ?<br>\nThat is (since they don't appear after the ==&gt;, they are implicitly <br>\n_existentially_ quantified where they appear).</p>\n</blockquote>\n<p>BTW, you seem to be overloading 'n'.</p>\n<blockquote>\n<p>Is there a better way to do this? Is there maybe a way to get the<br>\nsecond example to work?</p>\n<p>What exactly happens when you try the second way?</p>\n</blockquote>\n<p>Jeremy</p>\n<blockquote>\n<p>Chris Capel<br>\n</p>\n</blockquote>",
        "id": 294072063,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827536
    },
    {
        "content": "<p>From: Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt;<br>\nOn Sun, Feb 8, 2009 at 15:13, Jeremy Dawson &lt;<a href=\"mailto:jeremy@rsise.anu.edu.au\">jeremy@rsise.anu.edu.au</a>&gt; wrote:</p>\n<blockquote>\n<p>Chris Capel wrote:</p>\n<blockquote>\n<p>inductive_set P where<br>\nbase: \"[C1 1, C2 2] : P\" |<br>\nother: \"[| base : P; take 2 (drop n base) = [C1 x, C2 y] |] ==&gt;<br>\ninsert_list [C1 m, C2 n] base (n + 1) : P\"</p>\n<p>(\"insert_list x y n\" puts x into y at n.) This definition, besides<br>\nbeing less clear, doesn't actually work, as \"= [x, y]\" doesn't perform<br>\npattern matching. Instead, the equality asserts that (take a b) = [x,<br>\ny] for any x and y, which is obviously not true.</p>\n</blockquote>\n<p>??? Aren't x and y implicitly universally quantified over the _whole_ rule ?<br>\nThat is (since they don't appear after the ==&gt;, they are implicitly<br>\n_existentially_ quantified where they appear).</p>\n</blockquote>\n<p>I <em>believe</em> so, but I'm not sure. I didn't mean to imply otherwise. My<br>\npoint was that unification doesn't instantiate them.</p>\n<blockquote>\n<p>BTW, you seem to be overloading 'n'.</p>\n</blockquote>\n<p>Oops. My actual theory does not do this. :)</p>\n<blockquote>\n<blockquote>\n<p>Is there a better way to do this? Is there maybe a way to get the<br>\nsecond example to work?</p>\n</blockquote>\n<p>What exactly happens when you try the second way?</p>\n</blockquote>\n<p>Well, with some more testing I've seen that this will work (i.e. it's<br>\ncorrect), but the problem is I have to manually instantiate x and y,<br>\nwhereas ideally they would be instantiated by unification. That was<br>\nthe same problem with the first formulation--manual instantiation of<br>\nstuff that you would wish wasn't necessary. However, maybe, as per<br>\nTobias, I need to learn to do structured proofs.</p>\n<p>Chris Capel</p>",
        "id": 294072082,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660827542
    }
]