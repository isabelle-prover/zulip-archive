[
    {
        "content": "<p>From: Nguyen Van Tang &lt;<a href=\"mailto:tang_nguyen@jaist.ac.jp\">tang_nguyen@jaist.ac.jp</a>&gt;<br>\nHi all,</p>\n<p>I am studying Isabelle/HOL. I would like to have one question. Can we use<br>\nIsabelle to formalize \"finite paths\" of a transition system (or formalize<br>\nfinite run of a finite automaton) ?</p>\n<p>Please help me if you have a solution on this problem?</p>\n<p>Thank you in advance,</p>\n<p>Bests,</p>\n<p>Tang.</p>",
        "id": 294051287,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819582
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nNguyen Van Tang wrote:<br>\nThis is, how I handle labeled transition systems of all kinds, maybe it<br>\nhelps</p>\n<p>I think on AFP (archive of formal proofs, <a href=\"http://afp.sf.net\">afp.sf.net</a>) there is also<br>\nanother example how to formalize FSMs:</p>\n<p>theory LTS<br>\nimports Main<br>\nbegin</p>\n<p>section {* Labeled transition systems *}<br>\ntext {*<br>\n  Labeled transition systems (LTS) provide a model of a state transition<br>\nsystem with named transitions.<br>\n*}</p>\n<p>subsection {* Definitions *}<br>\ntext {*  A LTS is modelled as a relation, that relates triples of start<br>\nconfiguration, transition label and end configuration *}<br>\ntypes ('c,'a) LTS = \"('c \\&lt;times&gt; 'a \\&lt;times&gt; 'c) set\"</p>\n<p>text {* Transitive closure of LTS *}<br>\nconsts trcl :: \"('c,'a) LTS \\&lt;Rightarrow&gt; ('c,'a list) LTS\"</p>\n<p>inductive \"trcl t\"<br>\nintros<br>\n  empty[simp]: \"(c,[],c) \\&lt;in&gt; trcl t\"<br>\n  cons[simp, trans]: \"\\&lt;lbrakk&gt; (c,a,c') \\&lt;in&gt; t; (c',w,c'') \\&lt;in&gt; trcl<br>\nt \\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; (c,a#w,c'') \\&lt;in&gt; trcl t\"</p>\n<p>subsection {* Basic properties of transitive closure *}<br>\nlemma trcl_empty_cons: \"(c,[],c')\\&lt;in&gt;trcl t \\&lt;Longrightarrow&gt; (c=c')\"<br>\nby (auto elim: trcl.cases)<br>\nlemma trcl_empty_simp[simp]: \"(c,[],c')\\&lt;in&gt;trcl t = (c=c')\" by (auto<br>\nelim: trcl.cases intro: trcl.intros)</p>\n<p>lemma trcl_single[simp]: \"((c,[a],c') \\&lt;in&gt; trcl t) = ((c,a,c') \\&lt;in&gt;<br>\nt)\" by (auto elim: trcl.cases)<br>\nlemma trcl_uncons: \"(c,a#w,c')\\&lt;in&gt;trcl t \\&lt;Longrightarrow&gt; \\&lt;exists&gt;ch<br>\n. (c,a,ch)\\&lt;in&gt;t \\&lt;and&gt; (ch,w,c') \\&lt;in&gt; trcl t\" by (auto elim: trcl.cases)<br>\nlemma trcl_one_elem: \"(c,e,c')\\&lt;in&gt;t \\&lt;Longrightarrow&gt;<br>\n(c,[e],c')\\&lt;in&gt;trcl t\" by auto</p>\n<p>lemma trcl_concat[trans]: \"!! c . \\&lt;lbrakk&gt; (c,w1,c')\\&lt;in&gt;trcl t;<br>\n(c',w2,c'')\\&lt;in&gt;trcl t \\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt;<br>\n(c,w1@w2,c'')\\&lt;in&gt;trcl t\"<br>\nproof (induct w1)<br>\n  case Nil thus ?case by (subgoal_tac \"c=c'\") auto<br>\nnext<br>\n  case (Cons a w) thus ?case by (auto dest: trcl_uncons)<br>\nqed   </p>\n<p>lemma trcl_unconcat: \"!! c . (c,w1@w2,c')\\&lt;in&gt;trcl t \\&lt;Longrightarrow&gt;<br>\n\\&lt;exists&gt;ch . (c,w1,ch)\\&lt;in&gt;trcl t \\&lt;and&gt; (ch,w2,c')\\&lt;in&gt;trcl t\" proof<br>\n(induct w1)<br>\n  case Nil hence \"(c,[],c)\\&lt;in&gt;trcl t \\&lt;and&gt; (c,w2,c')\\&lt;in&gt;trcl t\" by auto<br>\n  thus ?case by fast<br>\nnext<br>\n  case (Cons a w1) note IHP = this<br>\n  hence \"(c,a#(w1@w2),c')\\&lt;in&gt;trcl t\" by simp (* Auto/fast/blast do not<br>\nget the point _#(_@_) = (_#_)@_ in next step, so making it explicit *)<br>\n  with trcl_uncons obtain chh where \"(c,a,chh)\\&lt;in&gt;t \\&lt;and&gt;<br>\n(chh,w1@w2,c')\\&lt;in&gt;trcl t\" by fast<br>\n  moreover with IHP obtain ch where \"(chh,w1,ch)\\&lt;in&gt;trcl t \\&lt;and&gt;<br>\n(ch,w2,c')\\&lt;in&gt;trcl t\" by fast<br>\n  ultimately have \"(c,a#w1,ch)\\&lt;in&gt;trcl t \\&lt;and&gt; (ch,w2,c')\\&lt;in&gt;trcl t\"<br>\nby auto<br>\n  thus ?case by fast<br>\nqed</p>\n<p>lemma trcl_rev_cons[trans]: \"\\&lt;lbrakk&gt; (c,w,ch)\\&lt;in&gt;trcl T;<br>\n(ch,e,c')\\&lt;in&gt;T \\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; (c,w@[e],c')\\&lt;in&gt;trcl T\" by<br>\n(auto dest: trcl_concat iff add: trcl_single)<br>\nlemma trcl_rev_uncons: \"(c,w@[e],c')\\&lt;in&gt;trcl T \\&lt;Longrightarrow&gt;<br>\n\\&lt;exists&gt;ch. (c,w,ch)\\&lt;in&gt;trcl T \\&lt;and&gt; (ch,e,c')\\&lt;in&gt;T\" by (force dest:<br>\ntrcl_unconcat)</p>\n<p>lemma trcl_cons2[trans]: \"\\&lt;lbrakk&gt; (c,e,ch)\\&lt;in&gt;T; (ch,f,c')\\&lt;in&gt;T<br>\n\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; (c,[e,f],c')\\&lt;in&gt;trcl T\" by auto</p>\n<p>lemma trcl_mono[mono]: \"A \\&lt;subseteq&gt; B \\&lt;Longrightarrow&gt; trcl A<br>\n\\&lt;subseteq&gt; trcl B\"<br>\n  apply (clarsimp)<br>\n  apply (erule trcl.induct)<br>\n  apply auto<br>\ndone </p>\n<p>(* TODO: What's this good for ?*)<br>\nlemma trcl_pair_simple_induct:<br>\n  assumes NIL: \"!!s c. P s c [] s c\"<br>\n  assumes STEP: \"!!s c sh ch e w s' c'.<br>\n\\&lt;lbrakk&gt;((s,c),e,(sh,ch))\\&lt;in&gt;T; P sh ch w s' c'\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; P s c (e#w) s' c'\"<br>\n  shows \"!!s c. ((s,c),w,(s',c'))\\&lt;in&gt;trcl T \\&lt;Longrightarrow&gt; P s c w<br>\ns' c'\"<br>\nproof (induct w)<br>\n  case Nil thus ?case using NIL by (auto dest: trcl_empty_cons)<br>\nnext<br>\n  case (Cons e w) note IHP=this<br>\n  then obtain sh ch where SPLIT1: \"((s,c),e,(sh,ch))\\&lt;in&gt;T\" and SPLIT2:<br>\n\"((sh,ch),w,(s',c'))\\&lt;in&gt;trcl T\" by (fast dest: trcl_uncons)<br>\n  with IHP show ?case using STEP by (auto)<br>\nqed</p>\n<p>lemma trcl_inter_mono: \"x\\&lt;in&gt;trcl (S\\&lt;inter&gt;R) \\&lt;Longrightarrow&gt;<br>\nx\\&lt;in&gt;trcl S\" \"x\\&lt;in&gt;trcl (S\\&lt;inter&gt;R) \\&lt;Longrightarrow&gt; x\\&lt;in&gt;trcl R\"<br>\nproof -<br>\n  assume \"x\\&lt;in&gt;trcl (S\\&lt;inter&gt;R)\"<br>\n  with trcl_mono[of \"S\\&lt;inter&gt;R\" S] show \"x\\&lt;in&gt;trcl S\" by auto<br>\nnext<br>\n  assume \"x\\&lt;in&gt;trcl (S\\&lt;inter&gt;R)\"<br>\n  with trcl_mono[of \"S\\&lt;inter&gt;R\" R] show \"x\\&lt;in&gt;trcl R\" by auto<br>\nqed</p>\n<p>lemma trcl_rev_cases: \"!!c c'. \\&lt;lbrakk&gt; (c,w,c')\\&lt;in&gt;trcl S;<br>\n\\&lt;lbrakk&gt;w=[]; c=c'\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt;P; !!ch e wh. \\&lt;lbrakk&gt;<br>\nw=wh@[e]; (c,wh,ch)\\&lt;in&gt;trcl S; (ch,e,c')\\&lt;in&gt;S<br>\n\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt;P \\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; P\"<br>\n  by (induct w rule: rev_induct) (simp, blast dest: trcl_rev_uncons)</p>\n<p>lemma trcl_prop_trans: \"\\&lt;lbrakk&gt;(c,w,c')\\&lt;in&gt;trcl S; \\&lt;lbrakk&gt;c=c';<br>\nw=[]\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; P;  \\&lt;lbrakk&gt;c\\&lt;in&gt;Domain S;<br>\nc'\\&lt;in&gt;Range (Range S)\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt;P \\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; P\"<br>\n  apply (erule_tac trcl_rev_cases)<br>\n  apply auto<br>\n  apply (erule trcl.cases)<br>\n  apply auto<br>\n  done</p>\n<p>lemma trcl_mono_e: \"x\\&lt;in&gt;trcl (T\\&lt;inter&gt;M) \\&lt;Longrightarrow&gt; x\\&lt;in&gt;trcl<br>\nT\" using trcl_mono[of \"T\\&lt;inter&gt;M\" T] by auto</p>\n<p>end</p>\n<p>Finite automata can be done (for example) like this:<br>\n(*  Title:       Finite state machines<br>\n    ID:<br>\n    Author:      Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\n    Maintainer:  Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\n*)</p>\n<p>header {* Finite state machines *}<br>\ntheory FSM<br>\nimports Main LTS<br>\nbegin</p>\n<p>text {*<br>\n  This theory models nondeterministic finite state machines with<br>\nexplicit set of states and alphabet. @{text \\&lt;epsilon&gt;}-transitions are<br>\nnot supported.<br>\n*}</p>\n<p>subsection {* Definitions *}</p>\n<p>record ('s,'a) FSM_rec =<br>\n  Q :: \"'s set\" -- \"The set of states\"<br>\n  \\&lt;Sigma&gt; :: \"'a set\" -- \"The alphabet\"<br>\n  \\&lt;delta&gt; :: \"('s, 'a) LTS\" -- \"The transition relation\"<br>\n  s0 :: \"'s\" -- \"The initial state\"<br>\n  F :: \"'s set\" -- \"The set of final states\"</p>\n<p>locale FSM = struct A +<br>\n  assumes delta_cons: \"(q,l,q')\\&lt;in&gt;\\&lt;delta&gt; A \\&lt;Longrightarrow&gt; q\\&lt;in&gt;Q<br>\nA \\&lt;and&gt; l\\&lt;in&gt;\\&lt;Sigma&gt; A \\&lt;and&gt; q'\\&lt;in&gt;Q A\" -- \"The transition relation<br>\nis consistent with the set of states and the alphabet\"<br>\n  assumes s0_cons: \"s0 A \\&lt;in&gt; Q A\" -- \"The initial state is a state\"<br>\n  assumes F_cons: \"F A \\&lt;subseteq&gt; Q A\" -- \"The final states are states\"<br>\n  assumes finite_states: \"finite (Q A)\" -- \"The set of states is finite\"<br>\n  assumes finite_alphabet: \"finite (\\&lt;Sigma&gt; A)\" -- \"The alphabet is finite\"</p>\n<p>subsection {* Basic properties *}<br>\nlemma (in FSM) finite_delta_dom: \"finite (Q A \\&lt;times&gt; \\&lt;Sigma&gt; A<br>\n\\&lt;times&gt; Q A)\" proof -<br>\n  from finite_states finite_alphabet finite_cartesian_product[of<br>\n\"\\&lt;Sigma&gt; A\" \"Q A\"] have \"finite (\\&lt;Sigma&gt; A \\&lt;times&gt; Q A)\" by fast<br>\n  with finite_states finite_cartesian_product[of \"Q A\" \"\\&lt;Sigma&gt; A<br>\n\\&lt;times&gt; Q A\"] show \"finite (Q A \\&lt;times&gt; \\&lt;Sigma&gt; A \\&lt;times&gt; Q A)\" by fast<br>\nqed</p>\n<p>lemma (in FSM) finite_delta: \"finite (\\&lt;delta&gt; A)\" proof -<br>\n  have \"\\&lt;delta&gt; A \\&lt;subseteq&gt; Q A \\&lt;times&gt; \\&lt;Sigma&gt; A \\&lt;times&gt; Q A\" by<br>\n(auto simp add: delta_cons)<br>\n  with finite_delta_dom show ?thesis by (simp add: finite_subset)<br>\nqed</p>\n<p>subsection {* Reflexive, transitive closure of transition relation *}</p>\n<p>text {* Reflexive transitive closure on restricted domain *}</p>\n<p>consts trclAD :: \"('s,'a,'c) FSM_rec_scheme \\&lt;Rightarrow&gt; ('s,'a) LTS<br>\n\\&lt;Rightarrow&gt; ('s,'a list) LTS\"<br>\ninductive \"trclAD A D\"<br>\nintros<br>\n  empty[simp]: \"s\\&lt;in&gt;Q A \\&lt;Longrightarrow&gt; (s,[],s)\\&lt;in&gt;trclAD A D\"<br>\n  cons[simp]: \"\\&lt;lbrakk&gt;(s,e,s')\\&lt;in&gt;D; s\\&lt;in&gt;Q A; e\\&lt;in&gt;\\&lt;Sigma&gt; A;<br>\n(s',w,s'')\\&lt;in&gt;trclAD A D\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt;<br>\n(s,e#w,s'')\\&lt;in&gt;trclAD A D\"</p>\n<p>syntax trclA :: \"('s,'a,'c) FSM_rec_scheme \\&lt;Rightarrow&gt; ('s,'a list) LTS\"<br>\ntranslations \"trclA A\" =&gt; \"trclAD A (\\&lt;delta&gt; A)\"</p>\n<p>lemma trclAD_empty_cons[simp]: \"(c,[],c')\\&lt;in&gt;trclAD A D<br>\n\\&lt;Longrightarrow&gt; c=c'\" by (auto elim: trclAD.cases)<br>\nlemma trclAD_single: \"(c,[a],c') \\&lt;in&gt; trclAD A D \\&lt;Longrightarrow&gt;<br>\n(c,a,c') \\&lt;in&gt; D\" by (auto elim: trclAD.cases)<br>\nlemma trclAD_elems: \"(c,w,c')\\&lt;in&gt;trclAD A D \\&lt;Longrightarrow&gt; c\\&lt;in&gt;Q A<br>\n\\&lt;and&gt; w\\&lt;in&gt;lists (\\&lt;Sigma&gt; A) \\&lt;and&gt; c'\\&lt;in&gt;Q A\" by (erule<br>\ntrclAD.induct, auto)<br>\nlemma trclAD_one_elem: \"\\&lt;lbrakk&gt;c\\&lt;in&gt;Q A; e\\&lt;in&gt;\\&lt;Sigma&gt; A; c'\\&lt;in&gt;Q<br>\nA; (c,e,c')\\&lt;in&gt;D\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; (c,[e],c')\\&lt;in&gt;trclAD A D\"<br>\nby auto</p>\n<p>lemma trclAD_uncons: \"(c,a#w,c')\\&lt;in&gt;trclAD A D \\&lt;Longrightarrow&gt;<br>\n\\&lt;exists&gt;ch . (c,a,ch)\\&lt;in&gt;D \\&lt;and&gt; (ch,w,c') \\&lt;in&gt; trclAD A D \\&lt;and&gt;<br>\nc\\&lt;in&gt;Q A \\&lt;and&gt; a\\&lt;in&gt;\\&lt;Sigma&gt; A\"<br>\n  by (auto elim: trclAD.elims)</p>\n<p>lemma trclAD_concat: \"!! c . \\&lt;lbrakk&gt; (c,w1,c')\\&lt;in&gt;trclAD A D;<br>\n(c',w2,c'')\\&lt;in&gt;trclAD A D \\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt;<br>\n(c,w1@w2,c'')\\&lt;in&gt;trclAD A D\"<br>\nproof (induct w1)<br>\n  case Nil thus ?case by (subgoal_tac \"c=c'\") auto<br>\nnext<br>\n  case (Cons a w) thus ?case by (auto dest: trclAD_uncons)<br>\nqed   </p>\n<p>lemma trclAD_unconcat: \"!! c . (c,w1@w2,c')\\&lt;in&gt;trclAD A D<br>\n\\&lt;Longrightarrow&gt; \\&lt;exists&gt;ch . (c,w1,ch)\\&lt;in&gt;trclAD A D \\&lt;and&gt;<br>\n(ch,w2,c')\\&lt;in&gt;trclAD A D\" proof (induct w1)<br>\n  case Nil hence \"(c,[],c)\\&lt;in&gt;trclAD A D \\&lt;and&gt; (c,w2,c')\\&lt;in&gt;trclAD A<br>\nD\" by (auto dest: trclAD_elems)<br>\n  thus ?case by fast<br>\nnext<br>\n  case (Cons a w1) note IHP = this<br>\n  hence \"(c,a#(w1@w2),c')\\&lt;in&gt;trclAD A D\" by simp (* Auto/fast/blast do<br>\nnot get the point _#(_@_) = (_#_)@_ in next step, so making it explicit *)<br>\n  with trclAD_uncons obtain chh where \"(c,a,chh)\\&lt;in&gt;D \\&lt;and&gt;<br>\n(chh,w1@w2,c')\\&lt;in&gt;trclAD A D \\&lt;and&gt; c\\&lt;in&gt;Q A \\&lt;and&gt; a\\&lt;in&gt;\\&lt;Sigma&gt; A\"<br>\nby fast<br>\n  moreover with IHP obtain ch where \"(chh,w1,ch)\\&lt;in&gt;trclAD A D \\&lt;and&gt;<br>\n(ch,w2,c')\\&lt;in&gt;trclAD A D\" by fast<br>\n  ultimately have \"(c,a#w1,ch)\\&lt;in&gt;trclAD A D \\&lt;and&gt;<br>\n(ch,w2,c')\\&lt;in&gt;trclAD A D\" by auto<br>\n  thus ?case by fast<br>\nqed</p>\n<p>lemma trclAD_eq: \"\\&lt;lbrakk&gt;Q A = Q A'; \\&lt;Sigma&gt; A = \\&lt;Sigma&gt; A'\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; trclAD A D = trclAD A' D\" by (unfold trclAD.defs) simp</p>\n<p>lemma trclAD_mono[mono]: \"D\\&lt;subseteq&gt;D' \\&lt;Longrightarrow&gt; trclAD A D<br>\n\\&lt;subseteq&gt; trclAD A D'\"<br>\n  apply (clarsimp)<br>\n  apply (erule trclAD.induct)<br>\n  apply auto<br>\n  done</p>\n<p>lemma trclAD_mono_adv: \"\\&lt;lbrakk&gt;D\\&lt;subseteq&gt;D'; Q A = Q A'; \\&lt;Sigma&gt; A<br>\n= \\&lt;Sigma&gt; A'\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; trclAD A D \\&lt;subseteq&gt; trclAD<br>\nA' D'\" by (subgoal_tac \"trclAD A D = trclAD A' D\") (auto dest: trclAD_eq<br>\ntrclAD_mono)</p>\n<p>subsubsection {* Relation of @{term trclAD} and @{term LTS.trcl} *}<br>\nlemma trclAD_by_trcl1: \"trclAD A D \\&lt;subseteq&gt; (trcl (D \\&lt;inter&gt; (Q A<br>\n\\&lt;times&gt; \\&lt;Sigma&gt; A \\&lt;times&gt; <br>\n[message truncated]</p>",
        "id": 294051296,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819588
    },
    {
        "content": "<p>From: Cristiano Longo &lt;<a href=\"mailto:cristiano.longo@tvblob.com\">cristiano.longo@tvblob.com</a>&gt;<br>\nHi, I used the definition of Non Deterministic Finite State Automaton to build <br>\na \"model\" for Automaton with a not finite state set. Such automaton can be <br>\ndefined by </p>\n<p>(1) a data type for states <br>\n(2) a data type for symbols + a special simbol Epsilon<br>\n(3) a transition function (state, symbol Un Epsilon) =&gt; state set </p>\n<p>The run function in  NonDeterministicAutomata.thy compute the final state set <br>\nof a such defined machine given the initial state, transition function and a <br>\nlist of symbols.</p>\n<p>Note the use of option datatype to extends the symbol set with epsilon(None).</p>\n<p>ExampleNA.thy implements the automata shown in <br>\n<a href=\"http://en.wikipedia.org/wiki/Nondeterministic_finite_state_machine\">http://en.wikipedia.org/wiki/Nondeterministic_finite_state_machine</a>.</p>\n<p>The transition function is defined as an inductive set. Using this technique <br>\nis simpler and clearer that using primrec. But probably is not correct, <br>\nbecause it is not an inductive set.  </p>\n<p>I have done some experiment. I am not able to understand if a string is <br>\nrecognized by this automata using quicksearch, and blast loops on some tryng <br>\nto chek some string, for example 001010.</p>\n<p>I would be happy to receive suggestions about transition function definitions.</p>\n<p>Please my english,<br>\nCristiano Longo </p>\n<p>Alle 07:25, venerd√¨ 24 agosto 2007, Nguyen Van Tang ha scritto:<br>\n<a href=\"/user_uploads/14278/8er-FcztlE6z5Fwsv2W2DOJz/NonDeterministicAutomata.thy\">NonDeterministicAutomata.thy</a><br>\n<a href=\"/user_uploads/14278/RqrdJk8HkyEqtRZGAM1XNQKL/ExampleNA.thy\">ExampleNA.thy</a></p>",
        "id": 294051317,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819594
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nNow that we have got on to the subject of (finite) automata, the <br>\nfollowing theories from the Archive of Formal Proofs may be of interest:<br>\n<a href=\"http://afp.sourceforge.net/entries/Functional-Automata.shtml\">http://afp.sourceforge.net/entries/Functional-Automata.shtml</a></p>\n<p>Tobias</p>\n<p>Cristiano Longo schrieb:</p>",
        "id": 294051325,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819599
    }
]