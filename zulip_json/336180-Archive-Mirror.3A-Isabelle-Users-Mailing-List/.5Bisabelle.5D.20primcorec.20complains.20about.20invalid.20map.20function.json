[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear BNF experts,</p>\n<p>I am trying to convert my manual definitions of primitively corecursive functions to use <br>\nprimcorec. Unfortunately, I am having trouble as soon as my codatatype uses nested <br>\nrecursion. Here's a minimal example. It runs with Isabelle2013-2, but the problem is the <br>\nsame with a recent development version such as e872d196a73b. I want to define map_bar' <br>\nwith primcorec, but primcorec rejects my attempt below with \"Invalid map function in <br>\n\"map_foo'\". So, how should I write my definition of map_bar'?</p>\n<p>datatype_new ('a, 'c, 'e) foo = A 'a | B \"'c =&gt; 'e\"</p>\n<p>primrec_new map_foo' ::<br>\n   \"('a =&gt; 'b) =&gt; ('d =&gt; 'c) =&gt; ('e =&gt; 'f)<br>\n   =&gt; ('a, 'c, 'e) foo =&gt; ('b, 'd, 'f) foo\"<br>\nwhere<br>\n   \"map_foo' f h k (A x) = A (f x)\"<br>\n| \"map_foo' f h k (B c) = B (map_fun h k c)\"</p>\n<p>codatatype ('a, 'c) bar = Bar \"('a, 'c, ('a, 'c) bar) foo\"</p>\n<p>definition map_bar' :: \"('a =&gt; 'b) =&gt; ('d =&gt; 'c) =&gt; ('a, 'c) bar =&gt; ('b, 'd) bar\"<br>\nwhere \"map_bar' f h = bar_unfold (map_foo' f h id o un_Bar)\" (* works *)</p>\n<p>primcorec map_bar' :: \"('a =&gt; 'b) =&gt; ('d =&gt; 'c) =&gt; ('a, 'c) bar =&gt; ('b, 'd) bar\"<br>\nwhere \"un_Bar (map_bar' f h r) = map_foo' f h (map_bar' f h) (un_Bar r)\"<br>\n(* invalid map function map_foo' *)</p>\n<p>Here's some background info on what I am trying to achieve. The type variable 'c in foo is <br>\ndead, so map_foo as generated by datatype_new does not take a parameter for 'c. The <br>\nquotient and lifting packages, however, expect a map function that take one parameters for <br>\neach type variable. That's why I want to define map_foo' and map_bar'.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294269131,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916612
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>So, how should I write my definition of map_bar'?</p>\n</blockquote>\n<p>Try</p>\n<p>primcorec map_bar' :: \"('a =&gt; 'b) =&gt; ('d =&gt; 'c) =&gt; ('a, 'c) bar =&gt; ('b, 'd) bar\" where<br>\n    \"un_Bar (map_bar' f h r) = map_foo id (map_bar' f h) ((map_foo' f h id \\&lt;circ&gt; un_Bar) r)\"</p>\n<p>I arrived at it by looking at the characteristic theorem</p>\n<p>thm bar.unfold[of \"map_foo' f h id o un_Bar\" for f h, folded map_bar'_def]</p>\n<p>associated with your definition</p>\n<p>definition map_bar' :: \"('a =&gt; 'b) =&gt; ('d =&gt; 'c) =&gt; ('a, 'c) bar =&gt; ('b, 'd) bar\"<br>\n    where \"map_bar' f h = bar_unfold (map_foo' f h id o un_Bar)\" (* works *)</p>\n<p>I'm sorry if this is a bit tedious each time. If this is a major hurdle for you, we might look into ways to make \"primcorec\" work more smoothly for such cases. Do you think it would make sense if the BNF package always defined the \"map\" function in the way you suggest?</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294269156,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916622
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nThe corecursive call to map_bar' is only allowed to be applied either <br>\ndirectly of through the map function of foo (the one generated by the <br>\npackage, not your custom map_foo'). The solution is to modify the <br>\n\"abstract state\" (here \"un_Bar r\") before applying the corecursive call. <br>\nTo obtain your original equations you will need a few helper lemmas <br>\n(relating map_foo and map_foo').</p>\n<p>primcorec map_bar' :: \"('a =&gt; 'b) =&gt; ('d =&gt; 'c) =&gt; ('a, 'c) bar =&gt; ('b, <br>\n'd) bar\"<br>\nwhere \"un_Bar (map_bar' f h r) = map_foo f (map_bar' f h) (map_foo' id h <br>\nid (un_Bar r))\"</p>\n<p>lemma map_foo_map_foo': \"map_foo f k foo = map_foo' f id k foo\"<br>\n   by (induct foo) auto</p>\n<p>lemma map_foo'_comp[simp]:<br>\n   \"map_foo' f h k (map_foo' f' h' k' foo) = map_foo' (f o f') (h' o h) <br>\n(k o k') foo\"<br>\n   by (induct foo) (auto simp: map_fun.compositionality o_def)</p>\n<p>lemma map_bar': \"un_Bar (map_bar' f h r) = map_foo' f h (map_bar' f h) <br>\n(un_Bar r)\"<br>\n   by (auto simp: map_foo_map_foo')</p>\n<p>Dmitriy</p>",
        "id": 294269170,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916625
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jasmin and Dmitriy,</p>\n<p>Thanks for the quick replies. Jasmin's description of how he found the decomposition into <br>\nmap functions and state transformation helped me to solve the next few definitions.</p>\n<blockquote>\n<p>Do you think it would make sense if the BNF package always defined the \"map\" function<br>\nin the way you suggest?<br>\nIt would certainly have saved me some work it the BNF package did not omit the dead <br>\nvariables in the map function (I have also generalised the relator, so that would be the <br>\nnext thing). But I need them only for the lifting package, I have not yet used them in <br>\nother cases. So, if there will be some integration of BNF and lifting, then that's <br>\ndefinitely worth thinking about; otherwise, I suggest that we need more evidence of this <br>\nbeing useful before someone starts to implement special cases for dead type variables.</p>\n</blockquote>\n<blockquote>\n<p>I'm sorry if this is a bit tedious each time. If this is a major hurdle for you, we<br>\nmight look into ways to make \"primcorec\" work more smoothly for such cases.</p>\n</blockquote>\n<p>It is (not yet) obvious to me how I have to decompose the transformations such that <br>\nprimcorec accepts them. In fact, I am already stuck again.</p>\n<p>codatatype 'a foobar = AA 'a | BB \"bool =&gt; 'a foobar\"</p>\n<p>primcorec fbind :: \"'a foobar =&gt; ('a =&gt; 'b foobar) =&gt; 'b foobar\"<br>\nwhere \"fbind f g = (if is_AA f then g (un_AA f) else BB (%b. fbind (un_BB f b) g))\"</p>\n<p>datatype_new ('a, 'c, 'e) foo = A 'a | B \"'c =&gt; 'e\"</p>\n<p>codatatype ('a, 'c) bar = Bar \"('a, 'c, ('a, 'c) bar) foo foobar\"</p>\n<p>definition bbind  :: \"('a, 'c) bar =&gt; ('a =&gt; ('b, 'c) bar) =&gt; ('b, 'c) bar\"<br>\nwhere<br>\n   \"bbind r f =<br>\n   corec_bar (%r. fbind (un_Bar r) (%foo. case foo of A x =&gt;<br>\n      map_foobar (map_foo id Inl) (un_Bar (f x))<br>\n    | B c =&gt; AA (B (%input. Inr (c input))))) r\"</p>\n<p>The functions fbind and bbind are monadic bind operations for the two codatatypes. <br>\nFollowing your suggestions, I thought that I transform the foobar first into<br>\n\"bar + (bar * ('a =&gt; bar)) foo foobar\" and then in the map functions, the Inl part stops <br>\nthe corecursion and the right continues. The following attempt raises an exception that <br>\nsays something about Inr () (but there are no unit types anywhere in my spec ???).</p>\n<p>*** exception TERM raised (line 366 of \"~~/src/HOL/Tools/hologic.ML\"):<br>\n*** mk_split: bad body type<br>\n*** Inr ()<br>\n*** At command \"primcorec\"</p>\n<p>primcorec bbind :: \"('a, 'c) bar =&gt; ('a =&gt; ('b, 'c) bar) =&gt; ('b, 'c) bar\"<br>\nwhere<br>\n   \"un_Bar (bbind r f) =<br>\n    map_foobar (map_foo id (case_sum id (split bbind)))<br>\n      (fbind (un_Bar r)<br>\n       (case_foo<br>\n         (map_foobar (map_foo id Inl) o un_Bar o f)<br>\n         (%c. AA (B (%i. Inr (c i, f))))))\"</p>\n<p>Next, I tried to eta-expand split as follows, but in vain. This time, I am puzzled about <br>\nthe \"Inr (r, f)\" in the prod_case. Where does that come from?</p>\n<p>primcorec bbind :: \"('a, 'c) bar =&gt; ('a =&gt; ('b, 'c) bar) =&gt; ('b, 'c) bar\"<br>\nwhere<br>\n   \"un_Bar (bbind r f) =<br>\n    map_foobar (map_foo id (%z. case z of Inl r =&gt; r | Inr (r, f) =&gt; bbind r f))<br>\n      (fbind (un_Bar r)<br>\n       (case_foo<br>\n         (map_foobar (map_foo id Inl) o un_Bar o f)<br>\n         (%c. AA (B (%i. Inr (c i, f))))))\"</p>\n<p>*** primcorec error:<br>\n***   Type unification failed: Clash of types \"_ + _\" and \"(_, _) bar\"</p>\n<hr>\n<p>*** Type error in application: incompatible operand type</p>\n<hr>\n<p>*** Operator:  sum_case (%r. r) ::<br>\n***   (('a, 'c) bar * ('a =&gt; ('b, 'c) bar) =&gt; ('b, 'c) bar)<br>\n***   =&gt; ('b, 'c) bar + ('a, 'c) bar * ('a =&gt; ('b, 'c) bar) =&gt; ('b, 'c) bar<br>\n*** Operand:   %a. case a of (r, f) =&gt; Inr (r, f) ::<br>\n***   ('a, 'c) bar * ('a =&gt; ('b, 'c) bar)<br>\n***   =&gt; ('b, 'c) bar + ('a, 'c) bar * ('a =&gt; ('b, 'c) bar)</p>\n<hr>\n<p>*** At command \"primcorec\"</p>\n<p>Could you please help me once more?</p>\n<p>Andreas</p>",
        "id": 294269183,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916630
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>It would certainly have saved me some work it the BNF package did not omit the dead variables in the map function (I have also generalised the relator, so that would be the next thing). But I need them only for the lifting package, I have not yet used them in other cases. So, if there will be some integration of BNF and lifting, then that's definitely worth thinking about; otherwise, I suggest that we need more evidence of this being useful before someone starts to implement special cases for dead type variables.</p>\n</blockquote>\n<p>It occurred to me that it might be cleaner if you define a map function that affects only the deads and then use function composition with the BNF-generated \"map\" to obtain the map function you need for Lifting. (Whether this actually improves things or makes your life more miserable is an open question, admittedly.)</p>\n<p>Now to your actual problem:</p>\n<blockquote>\n<p>codatatype 'a foobar = AA 'a | BB \"bool =&gt; 'a foobar\"</p>\n<p>primcorec fbind :: \"'a foobar =&gt; ('a =&gt; 'b foobar) =&gt; 'b foobar\"<br>\nwhere \"fbind f g = (if is_AA f then g (un_AA f) else BB (%b. fbind (un_BB f b) g))\"</p>\n<p>datatype_new ('a, 'c, 'e) foo = A 'a | B \"'c =&gt; 'e\"</p>\n<p>codatatype ('a, 'c) bar = Bar \"('a, 'c, ('a, 'c) bar) foo foobar\"</p>\n<p>[...] The following attempt raises an exception that says something about Inr () (but there are no unit types anywhere in my spec ???).</p>\n<p>*** exception TERM raised (line 366 of \"~~/src/HOL/Tools/hologic.ML\"):<br>\n*** mk_split: bad body type<br>\n*** Inr ()<br>\n*** At command \"primcorec\"</p>\n<p>primcorec bbind :: \"('a, 'c) bar =&gt; ('a =&gt; ('b, 'c) bar) =&gt; ('b, 'c) bar\"<br>\nwhere<br>\n \"un_Bar (bbind r f) =<br>\n  map_foobar (map_foo id (case_sum id (split bbind)))<br>\n    (fbind (un_Bar r)<br>\n     (case_foo<br>\n       (map_foobar (map_foo id Inl) o un_Bar o f)<br>\n       (%c. AA (B (%i. Inr (c i, f))))))\"</p>\n</blockquote>\n<p>This is currently not supported, because \"sum\" is an old-style datatype and \"primrec\" can only deal with new-style \"case\"s. (It wouldn't be hard to hard-code something for sums and products on our side, though.)</p>\n<p>With the repository version: If you make sure that changes 1401434a7e83, f09037306f25, 3d2c97392e25, and 5ebf832b58a1 are applied, and you define your own sum \"datatype_new\" (or \"codatatype\" if you are so inclined), both the above example and the example below will work. (In fact, the naming \"case_sum\" in your example suggests that you are using a new-style datatype, if it's not a typo.)</p>\n<p>Considering that we have 340 working instances of \"primcorec\" in Isabelle, the AFP, and a semi-private repository [<em>], I'm amazed that you managed to produce an example that triggered so many bugs at once. The combination of \"split\" not followed by a lambda + a case inside a map function argument was simply toxic. I hope you feel slightly guilty for shaming us [</em>*] publicly like that. ;)</p>\n<p>All right: Thanks for your patience and for taking the time to file in the bug report!</p>\n<p>Cheers,</p>\n<p>Jasmin</p>\n<p>[*] <a href=\"https://bitbucket.org/traytel/co-rec\">https://bitbucket.org/traytel/co-rec</a><br>\n[**] or rather: me. I can't even blame Lorenz or Dmitriy; all the bugs were clearly mine.</p>",
        "id": 294269329,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916673
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Jasmin,</p>\n<blockquote>\n<p>This is currently not supported, because \"sum\" is an old-style datatype and \"primrec\" can only deal with new-style \"case\"s. (It wouldn't be hard to hard-code something for sums and products on our side, though.)<br>\nIt would be nice if such basic type constructors like sum and product work with <br>\nprim(co)rec. I tried to register sum with wrap_free_constructors, but that did not work.<br>\nI now have a local sum type as a temporary workaround.</p>\n</blockquote>\n<p>locale sum_datatype_new begin<br>\ndatatype_new ('a, 'b) sum = Inl 'a | Inr 'b<br>\nend<br>\ncontext begin<br>\ninterpretation sum_datatype_new .<br>\nprimcorec bbind ...<br>\nend</p>\n<blockquote>\n<p>(In fact, the naming \"case_sum\" in your example suggests that you are using a new-style <br>\ndatatype, if it's not a typo.)<br>\nTrue, I am hooked on the repository version again. But as I had the same problems in <br>\nIsabelle2013-2, I thought that I post this on isabelle-users for documentation.</p>\n</blockquote>\n<blockquote>\n<p>I hope you feel slightly guilty for shaming us [**] publicly like that. ;)</p>\n<p>All right: Thanks for your patience and for taking the time to file in the bug report!<br>\nI did not consider this a bug report. I was simply desperate because nothing worked and I <br>\nthought that I had still not understood how nested corecursion works map functions.</p>\n</blockquote>\n<p>Thanks for fixing all this.</p>\n<p>Andreas</p>",
        "id": 294269355,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916685
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<p>Am 06.02.2014 um 09:44 schrieb Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;:</p>\n<blockquote>\n<p>It would be nice if such basic type constructors like sum and product work with prim(co)rec. I tried to register sum with wrap_free_constructors, but that did not work.</p>\n</blockquote>\n<p>Did you specify selectors? Currently (and unfortunately), the tactics behind \"primcorec\" require types with \"sel_split\" theorems, which are generated only for types with selectors and discriminators.</p>\n<blockquote>\n<p>I now have a local sum type as a temporary workaround.</p>\n</blockquote>\n<p>I'll see what I can do. In fact, there's a lot that can and will be done at some point or another, including having us enrich the structure of \"list\", \"option\", \"sum\", and \"prod\". Today these are BNFs and free constructor types without selectors and discriminators. The next steps are (1) free constructor types with selectors and discriminators; (2) new-style datatypes (either using \"datatype_new\" or a forthcoming \"wrap_datatype_new\" command, depending on the type). The latter would allow things like nested-to-mutual recursion through lists.</p>\n<blockquote>\n<blockquote>\n<p>All right: Thanks for your patience and for taking the time to file in the bug report!<br>\nI did not consider this a bug report. I was simply desperate because nothing worked and I thought that I had still not understood how nested corecursion works map functions.</p>\n</blockquote>\n</blockquote>\n<p>To me, any report of one of my tools spitting out an exception is a bug report. Even though we know that \"primcorec\" messaging is not finished; see e.g.</p>\n<p><a href=\"https://bitbucket.org/traytel/co-rec/src/2959b88c3f52790b1ab7ada19654a2527bfa1d67/Examples/Primcorec_Messages.thy?at=default\">https://bitbucket.org/traytel/co-rec/src/2959b88c3f52790b1ab7ada19654a2527bfa1d67/Examples/Primcorec_Messages.thy?at=default</a></p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294269370,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916691
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jasmin,</p>\n<p>I tried the following in Isabelle/8a53ee72e595.</p>\n<p>wrap_free_constructors<br>\n   [Inl, Inr]<br>\n   case_sum<br>\n   [is_Inl, is_Inr]<br>\n   [[projl], [projr]]<br>\nsorry</p>\n<p>primcorec bbind :: \"('a, 'c) bar =&gt; ('a =&gt; ('b, 'c) bar) =&gt; ('b, 'c) bar\"<br>\nwhere<br>\n   \"un_Bar (bbind r f) =<br>\n    map_foobar (map_foo id (case_sum id (split bbind)))<br>\n      (fbind (un_Bar r)<br>\n       (case_foo<br>\n         (map_foobar (map_foo id Inl) o un_Bar o f)<br>\n         (%c. AA (B (%i. Inr (c i, f))))))\"</p>\n<p>It results in the following exception:</p>\n<p>*** exception TERM raised (line 366 of \"~~/src/HOL/Tools/hologic.ML\"):<br>\n*** mk_split: bad body type<br>\n*** Inr ()<br>\n*** At command \"primcorec\"</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294269384,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916698
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<p>Ah, that one was easy to fix (a87e49f4336d). Incidentally, looking at 062aa11e98e1 in conjunction with a87e49f4336d suggests that some Isabelle developers are like monkeys in front of typewriters.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294269481,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916713
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jasmin,</p>\n<p>Thanks, my example now also works with wrap_free_constructors. Maybe the <br>\nwrap_free_constructors declaration could be moved to Sum_Type?</p>\n<blockquote>\n<p>Incidentally, looking at 062aa11e98e1 in conjunction with a87e49f4336d suggests that <br>\nsome Isabelle developers are like monkeys in front of typewriters.<br>\nUnfortunately, the DUP exception is back in Isabelle/b5b64d9d1002 as the following example <br>\nshows (AFP/3daf6a41c65b).</p>\n</blockquote>\n<p>theory Scratch imports<br>\n   \"$AFP/Coinductive/Coinductive_Nat\"<br>\n   \"~~/src/HOL/Probability/Probability\"<br>\nbegin</p>\n<p>*** exception DUP \"Extended_Nat.enat\" raised (line 374 of \"General/table.ML\")<br>\n*** At command \"theory\"</p>\n<p>Happy debugging,<br>\nAndreas</p>",
        "id": 294269521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916722
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>Thanks, my example now also works with wrap_free_constructors. Maybe the wrap_free_constructors declaration could be moved to Sum_Type?</p>\n</blockquote>\n<p>Yesterday I gave it a try and failed (having \"rep_datatype\" and \"wrap_free_constructors\" in the same theory file introduces its own set of problems), but now I realized that if I put \"wrap_free_constructors\" before \"rep_datatype\" and use the \"rep_compat\" option, things work smoothly. Then the problem is that the entry gets overwritten, but more on this below...</p>\n<blockquote>\n<blockquote>\n<p>Incidentally, looking at 062aa11e98e1 in conjunction with a87e49f4336d suggests that some Isabelle developers are like monkeys in front of typewriters.<br>\nUnfortunately, the DUP exception is back in Isabelle/b5b64d9d1002 as the following example shows (AFP/3daf6a41c65b).</p>\n</blockquote>\n<p>theory Scratch imports<br>\n \"$AFP/Coinductive/Coinductive_Nat\"<br>\n \"~~/src/HOL/Probability/Probability\"<br>\nbegin</p>\n<p>*** exception DUP \"Extended_Nat.enat\" raised (line 374 of \"General/table.ML\")<br>\n*** At command \"theory\"</p>\n<p>Happy debugging,</p>\n</blockquote>\n<p>Ah, I can already see what's going on: \"Coinductive_Nat\" redefines the \"Ctr_Sugar\" entry for \"nat\", whereas \"Probability\" doesn't. Merge then has to choose between two different entries and can't make up its mind.</p>\n<p>So there are two problems:</p>\n<ol>\n<li>\n<p>Overwriting an entry is not harmless -- cf. the discussion above, but also after \"Coinductive_Nat\" all the tools that are based on the \"Ctr_Sugar\" entry for \"nat\" (and that includes \"function\" and some simprocs) won't know about the inductive view.</p>\n</li>\n<li>\n<p>The \"DUP\" exception.</p>\n</li>\n</ol>\n<p>I'll start by simply reverting yesterday's change that causes the \"DUP\". Then I'll see how easy it is to generalize the data structure (and modify its clients) so that it can store multiple entries for a given key.</p>\n<p>As usual, thanks for your report and patience with us mere mortals (or monkeys),</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294269545,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916728
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHm, in this particular case the fix is to move most parts of<br>\nCoinductive_Nat to HOL/Library/Extended_Nat. I think we should even<br>\nchange the definition of enat to use codatatype enat = eZero | eSuc<br>\n(epred: enat)</p>\n<ul>\n<li>Johannes</li>\n</ul>\n<p>PS: This could be another nice (in the sky) feature for (co)datatype:</p>\n<p>codatatype enat = (0::zero) | eSuc (epred: enat)</p>\n<p>and automatically have all your rules etc about 0 instead of Zero :-)<br>\nOf course this would only work for syntactic typeclasses.</p>",
        "id": 294269564,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916734
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nSure, you guys do what you want. ;)</p>\n<p>But the \"DUP\" is a general issue, and we had to address it.</p>\n<p>For the record: A \"DUP\" exception might still arise in odd cases where two theories independently register ctr sugar for the same type in a different way and then merge. Perhaps we should simply do like others do, namely \"Symtab.merge (K true)\", in which case the \"canonical\" order of imports decides who wins.</p>\n<p>This is one reason why I'm slightly attacted to the possibility of having several ctr sugar records. On the other hand, some applications might not be able to cope with this gracefully and will have to pick a winner anyway...</p>\n<p>Jasmin</p>",
        "id": 294269583,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660916741
    }
]