[
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>I’m doing my first steps with coinductive data type, and I’m struggling<br>\nwith primcorec (probably due to a lack of understanding of the syntactic<br>\nrequirements and the usual ways to work around them).</p>\n<p>I created a data type for possibly infinite labeled trees:</p>\n<p>codatatype (lset: 'a) ltree = Node (lnext : \"'a ⇒ 'a ltree option\")</p>\n<p>With help of Andreas¹ I managed to define an „or“ operation: A path in<br>\nthe resulting tree is a path in either one or the other:</p>\n<p>primcorec lor :: \"'a ltree ⇒ 'a ltree ⇒ 'a ltree\"<br>\n  where \"lnext (lor t1 t2) = (λ x.<br>\n           case (lnext t1 x) of Some t1' ⇒ (case lnext t2 x of Some t2' ⇒ Some (lor t1' t2') | None ⇒ Some t1')<br>\n                              | None     ⇒ lnext t2 x)\"</p>\n<p>Now I try to define an \"and\" operation: A path in the resulting tree is<br>\nan interleaving of paths in one or the other tree. I tried it like this:</p>\n<p>primcorec land :: \"'a ltree ⇒ 'a ltree ⇒ 'a ltree\"<br>\n   where \"lnext (land t1 t2) = (λ x.<br>\n      case (lnext t1 x) of Some t1' ⇒ (case lnext t2 x of Some t2' ⇒ Some (lor (land t1' t2) (land t1 t2')) | None ⇒ Some (land t1' t2))<br>\n                         | None     ⇒ (case lnext t2 x of Some t2' ⇒ Some (land t1 t2')                     | None ⇒ None))\"</p>\n<p>but it does not like the recursion via lor and gives this error message:</p>\n<p>primcorec error:<br>\n  Type unification failed: Clash of types \"_ + _\" and \"_ ltree\"</p>\n<p>Type error in application: incompatible operand type</p>\n<p>Operator:  lor :: 'a ltree ⇒ 'a ltree ⇒ 'a ltree<br>\nOperand:   Inr (t1', t2) :: 'a ltree + 'a ltree × 'a ltree</p>\n<p>It seems that primcorec likes definitions of the form</p>\n<p>primcorec land :: \"'a ltree ⇒ 'a ltree ⇒ 'a ltree\"<br>\n   where \"lnext (land t1 t2) = map_option (λ (x,y). land x y) o (λ x. ...)</p>\n<p>better, but I couldn’t figure out how to use that here, where in once<br>\ncase I need to invoke land twice and pass the result to lor.</p>\n<p>Can I rewrite the definition in a way that primcorec likes it?</p>\n<p>Greetings,<br>\nJoachim</p>\n<p>¹ <a href=\"http://stackoverflow.com/questions/26883229/invalid-map-function-when-defining-a-corecursive-tree\">http://stackoverflow.com/questions/26883229/invalid-map-function-when-defining-a-corecursive-tree</a><br>\n<a href=\"/user_uploads/14278/vQ3jo-U2IPTuFEZ6aNt0_yga/signature.asc\">signature.asc</a></p>",
        "id": 294321768,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927128
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@in.tum.de\">traytel@in.tum.de</a>&gt;<br>\nDear Joachim,</p>\n<p>your land is not primitively corecursive. Primitive means that the <br>\ncorecursive call appears directly or via a map function as an argument <br>\nthe constructor, but without any other function in between. In your case <br>\nthere is a function in between: lor.</p>\n<p>In my Coinductive_Languages AFP entry I show how to circumvent the <br>\nsyntactic criterion in an ad-hoc fashion. The Times-function from there <br>\nhas exactly the flavour of your land. A more systematic approach is <br>\ndescribed in an unpublished draft [1] (however no package is yet <br>\navailable for this). If you decide to go the systematic route, we could <br>\nstill provide some guidance through the material that is formalized in <br>\nthe context of [1], and you might become a first tester of the <br>\nforthcoming package.</p>\n<p>Hope that helps,<br>\nDmitriy</p>\n<p>[1] <a href=\"http://www21.in.tum.de/~traytel/papers/fouco/fouco.pdf\">http://www21.in.tum.de/~traytel/papers/fouco/fouco.pdf</a></p>",
        "id": 294321787,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927134
    }
]