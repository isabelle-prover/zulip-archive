[
    {
        "content": "<p>From: \"Siek, Jeremy\" &lt;<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;<br>\nI’d like to write recursive functions over the following datatype:</p>\n<p>datatype val = VNat nat | VRel \"(val × val) fset\"</p>\n<p>As a simple example,</p>\n<p>primrec count :: \"val ⇒ nat\" where<br>\n  \"count (VNat n) = 1\" |<br>\n  \"count (VRel t) = (ffold (λ (v1,v2). λ r. count v1 + count v2 + r) 0 t)\"</p>\n<p>But this get’s rejected with the “Invalid map function” error.</p>\n<p>What’s the correct way to do this?</p>\n<p>Cheers,<br>\nJeremy</p>\n<hr>\n<p>Jeremy G. Siek    &lt;jsiek@indiana.edu&lt;mailto:<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;&gt;<br>\nAssociate Professor<br>\nSchool of Informatics and Computing<br>\nIndiana University Bloomington<br>\n<a href=\"http://homes.soic.indiana.edu/jsiek/\">http://homes.soic.indiana.edu/jsiek/</a></p>",
        "id": 294713413,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182959
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Jeremy,</p>\n<blockquote>\n<p>I’d like to write recursive functions over the following datatype:</p>\n<p>datatype val = VNat nat | VRel \"(val × val) fset\"</p>\n<p>As a simple example,</p>\n<p>primrec count :: \"val ⇒ nat\" where<br>\n  \"count (VNat n) = 1\" |<br>\n  \"count (VRel t) = (ffold (λ (v1,v2). λ r. count v1 + count v2 + r) 0<br>\nt)\"</p>\n<p>But this get’s rejected with the “Invalid map function” error.</p>\n</blockquote>\n<p>this is a restriction of \"primrec\". What you're writing is not in fact a<br>\nprimitive recursive specification. There are two ways around that:</p>\n<p>1) Rewrite it as primitive recursive<br>\n2) Use the \"fun\"/\"function\" command</p>\n<p>Here is option 1:</p>\n<p>primrec count :: \"val ⇒ nat\" where<br>\n\"count (VNat n) = 1\" |<br>\n\"count (VRel t) = (ffold (λ (v1,v2). λ r. v1 + v2 + r) 0 (map_prod count<br>\ncount |`| t))\"</p>\n<p>Observe that the recursive calls of \"count\" must only occur within<br>\nsuitable \"map functions\" of the involved type constructors. In your case,<br>\nthe recursion of \"val\" is nested through a pair and an \"fset\". Hence, the<br>\nuse of \"|`|\" (map for \"fset\") and \"map_prod\" (map for \"prod\").</p>\n<p>Option 2:</p>\n<p>fun count :: \"val ⇒ nat\" where<br>\n\"count (VNat n) = 1\" |<br>\n\"count (VRel t) = (ffold (λ (v1,v2). λ r. count v1 + count v2 + r) 0 t)\"</p>\n<p>The problem here is showing termination. The function package tries to<br>\nautomatically derive a termination relation, which fails here.</p>\n<p>It can be specified manually as follows:</p>\n<p>function (sequential) count :: \"val ⇒ nat\" where<br>\n\"count (VNat n) = 1\" |<br>\n\"count (VRel t) = (ffold (λ (v1,v2). λ r. count v1 + count v2 + r) 0 t)\"<br>\n  by pat_completeness auto</p>\n<p>termination<br>\n  apply (relation \"measure size\")<br>\n  &lt;proof&gt;</p>\n<p>But as far as I can tell, the resulting goal is not actually provable. The<br>\nreason is that the function package has no idea how recursive calls nested<br>\nin \"ffold\" work. There are ways to explain to the function package how this<br>\nworks, but I'm not sure if it's possible in this concrete case. One would<br>\nneed a lemma like this:</p>\n<p>lemma ffold_cong[fundef_cong]:<br>\n  assumes \"⋀x y. x |∈| S ⟹ f x y = g x y\" \"x = y\" \"S = T\"<br>\n  shows \"ffold f x S = ffold g y T\"<br>\nsorry</p>\n<p>Using this lemma, we can successfully prove termination, but I'm not sure<br>\nwhether it actually holds.</p>\n<p>In summary, I think you're left with either rewriting your function to be<br>\nprimitive recursive, or avoid \"non-deterministic\" functions like \"ffold\".</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294713428,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182965
    },
    {
        "content": "<p>From: \"Siek, Jeremy\" &lt;<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;<br>\nDear Lars,</p>\n<p>Thank you for your very thorough answer! It looks like option 1 will suite my needs.</p>\n<p>Thank you!<br>\nJeremy</p>",
        "id": 294713450,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182971
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Thank you for your very thorough answer! It looks like option 1 will<br>\nsuite<br>\nmy needs.</p>\n</blockquote>\n<p>On second thought, I realised that your use of \"ffold\" is merely to<br>\ncompute the sum of some things in a set. Luckily, we can make \"function\"<br>\ncope with that. See attachment for a possible solution (also a version with<br>\n\"primrec\" that doesn't use \"ffold\").</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/yax_AY03iDOVL4gi_levVLqI/Scratch.thy\">Scratch.thy</a></p>",
        "id": 294713474,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182977
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nThese days, users should regard \"primrec\" as an internal feature necessary for bootstrapping the system but for implementers only.</p>\n<p>Larry Paulson</p>",
        "id": 294713496,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182984
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Jeremy and Lars,</p>\n<p>Special care is needed when recursing through permutative structures like sets and multisets. For example, the primrec version discussed here is _not_ equal to the 'fun' version of 'count', since it recursively collapses the numbers coming from subtrees that happen to have the same count. The 'fun' version is the correct one.</p>\n<p>All the best,</p>\n<p>Andrei</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; on behalf of Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nSent: 09 July 2017 11:28<br>\nTo: Siek, Jeremy<br>\nCc: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nSubject: Re: [isabelle] primrec of datatype containing fset</p>\n<blockquote>\n<p>Thank you for your very thorough answer! It looks like option 1 will<br>\nsuite<br>\nmy needs.</p>\n</blockquote>\n<p>On second thought, I realised that your use of \"ffold\" is merely to<br>\ncompute the sum of some things in a set. Luckily, we can make \"function\"<br>\ncope with that. See attachment for a possible solution (also a version with<br>\n\"primrec\" that doesn't use \"ffold\").</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294713514,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182989
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Andrei,</p>\n<blockquote>\n<p>Special care is needed when recursing through permutative structures like sets and multisets. For example, the primrec version discussed here is _not_ equal to the 'fun' version of 'count', since it recursively collapses the numbers coming from subtrees that happen to have the same count. The 'fun' version is the correct one.</p>\n</blockquote>\n<p>ah of course, you're right. Sorry for the mistake, Jeremy!</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294713534,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661182995
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nI don't fully agree.</p>\n<p>There are some cases, like infinitely-branching datatypes, where<br>\n\"primrec\" works without problems, but \"function\" requires considerable<br>\nadditional work (because there is no usable \"size\" function).</p>\n<p>Also, for datatypes with many constructors, I think \"function\" can be<br>\nquite slow due to the huge number of things it does and theorems that it<br>\nproves. \"primrec\" is a good light-weight alternative then.</p>\n<p>Personally, I tend to use primrec rather than fun whenever it is<br>\npossible to do so without significant effort.</p>\n<p>Manuel</p>",
        "id": 294713568,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183008
    },
    {
        "content": "<p>From: \"Siek, Jeremy\" &lt;<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;<br>\nHi Andrei,</p>\n<p>Good catch!</p>\n<p>But now I’m a bit unsatisfied… the function version of count required a fair bit of work and<br>\nlooks like it’s rather specific, so I may have to repeat this amount of work for every<br>\nother recursive function on datatype val.</p>\n<p>I wonder if the termination argument involving fsum could be adapted to ffold?</p>\n<p>Cheers,<br>\nJeremy</p>\n<p>On Jul 9, 2017, at 7:19 AM, Andrei Popescu &lt;A.Popescu@mdx.ac.uk&lt;mailto:<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;&gt; wrote:</p>\n<p>Hi Jeremy and Lars,</p>\n<p>Special care is needed when recursing through permutative structures like sets and multisets. For example, the primrec version discussed here is _not_ equal to the 'fun' version of 'count', since it recursively collapses the numbers coming from subtrees that happen to have the same count. The 'fun' version is the correct one.</p>\n<p>All the best,</p>\n<p>Andrei</p>\n<hr>\n<p>From: cl-isabelle-users-bounces@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; &lt;cl-isabelle-users-bounces@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt;&gt; on behalf of Lars Hupel &lt;hupel@in.tum.de&lt;mailto:<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;&gt;<br>\nSent: 09 July 2017 11:28<br>\nTo: Siek, Jeremy<br>\nCc: cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: Re: [isabelle] primrec of datatype containing fset</p>\n<blockquote>\n<p>Thank you for your very thorough answer! It looks like option 1 will<br>\nsuite<br>\nmy needs.</p>\n</blockquote>\n<p>On second thought, I realised that your use of \"ffold\" is merely to<br>\ncompute the sum of some things in a set. Luckily, we can make \"function\"<br>\ncope with that. See attachment for a possible solution (also a version with<br>\n\"primrec\" that doesn't use \"ffold\").</p>\n<p>Cheers<br>\nLars</p>\n<hr>\n<p>Jeremy G. Siek    &lt;jsiek@indiana.edu&lt;mailto:<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;&gt;<br>\nAssociate Professor<br>\nSchool of Informatics and Computing<br>\nIndiana University Bloomington<br>\n<a href=\"http://homes.soic.indiana.edu/jsiek/\">http://homes.soic.indiana.edu/jsiek/</a></p>",
        "id": 294713585,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183014
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nPersonally, I would suggest something like this:</p>\n<p>lemma single_le_sumI:<br>\n  assumes \"∃b∈A. a ≤ (f b :: nat)\" \"finite A\"<br>\n  shows   \"a ≤ (∑b∈A. f b)\"<br>\nproof -<br>\n  from assms obtain b where \"b ∈ A\" \"a ≤ f b\" by blast<br>\n  note this(2)<br>\n  also from ‹b ∈ A› and ‹finite A›<br>\n    have \"f b ≤ (∑b∈A. f b)\" by (intro member_le_sum) auto<br>\n  finally show ?thesis .<br>\nqed</p>\n<p>function count :: \"val ⇒ nat\" where<br>\n  \"count (VNat n) = 1\" |<br>\n  \"count (VRel A) = (∑(x,y)∈fset A. count x + count y)\"<br>\n  by pat_completeness auto<br>\ntermination by (relation \"measure size\") (force simp: less_Suc_eq_le<br>\nintro: single_le_sumI)+</p>\n<p>This reuses the summation function for sets, and I think that will be<br>\nmuch nicer to work with than a fold. The termination proof is still a<br>\nbit messy, unfortunately, and I don't know what can be done about it in<br>\ngeneral, but at least similar cases should also work with this \"one-liner\".</p>\n<p>Manuel</p>",
        "id": 294713595,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183020
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nDear Larry,</p>\n<blockquote>\n<blockquote>\n<p>These days, users should regard \"primrec\" as an internal feature necessary for bootstrapping the system but for implementers only.</p>\n</blockquote>\n</blockquote>\n<p>While this is true in most cases, in complex situations involving nested recursion \"primrec\" can provide the most elegant solution. For example, compare the \"function\"-based definition with the following correct primrec definition:</p>\n<p>primrec count' :: \"val ⇒ nat\" where<br>\n\"count' (VNat n) = 1\" |<br>\n\"count' (VRel t) = fsum (λ((_,v), (_,u)). v + u) (fimage (map_prod (λ v. (v,count' v)) (λ v. (v,count' v))) t)\"</p>\n<p>(This is now correct since all subtrees are counted as separate entities, taking advantage of full primitive recursion as opposed to mere iteration.)</p>\n<p>With a proper setting for congruences and such, this can be handled by \"function\" as well, but this is tricky and quite laborious -- as the current thread shows.</p>\n<p>Best,</p>\n<p>Andrei</p>\n<p>Larry Paulson</p>\n<blockquote>\n<p>On 9 Jul 2017, at 11:15, Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt; wrote:</p>\n<p>this is a restriction of \"primrec\". What you're writing is not in fact a<br>\nprimitive recursive specification. There are two ways around that:</p>\n<p>1) Rewrite it as primitive recursive<br>\n2) Use the \"fun\"/\"function\" command</p>\n</blockquote>",
        "id": 294713617,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183027
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Jeremy,</p>\n<hr>\n<blockquote>\n<blockquote>\n<p>Hi Andrei,<br>\nGood catch!<br>\nBut now I’m a bit unsatisfied… the function version of count required a fair bit of work and<br>\nlooks like it’s rather specific, so I may have to repeat this amount of work for every<br>\nother recursive function on datatype val.<br>\nI wonder if the termination argument involving fsum could be adapted to ffold?</p>\n</blockquote>\n</blockquote>\n<p>It can, with some tricks.</p>\n<p>But for this particular function, primrec works:</p>\n<p>primrec count :: \"val ⇒ nat\" where<br>\n\"count (VNat n) = 1\" |<br>\n\"count (VRel t) = fsum (λ((_,n), (_,m)). n + m) (fimage (map_prod (λ v. (v,count v)) (λ v. (v,count v))) t)\"</p>\n<p>If you have a genuinely primitive recursion function and primrec seems to cause you trouble, you can always use the primtive recursive combinator</p>\n<p>rec_val :: (nat ⇒ 'a) ⇒ (((val × 'a) × val × 'a) fset ⇒ 'a) ⇒ val ⇒ 'a</p>\n<p>explicitly, and then infer the high-level equations, e.g.:</p>\n<p>definition count where \"count = rec_val (λn. 1) (fsum (λ((_,n), (_,m)). n + m))\"<br>\nlemma count_simps[simp]:<br>\n\"count (VNat n) = 1\"<br>\nand<br>\n\"count (VRel t) = fsum (λ((_,n), (_,m)). n + m) (fimage (map_prod (λ v. (v,count v)) (λ v. (v,count v))) t)\"<br>\nunfolding count_def by auto</p>\n<p>This is essentially what the primrec package does for you automatically, but sometimes, esp. for nested recursion, the combinator version is easier to get right.</p>\n<p>I would be curious to know what other functions you would like to define on val. These examples would help us devise the right support for ffold and friends in the finite set library.</p>\n<p>Best,</p>\n<p>Andrei</p>\n<p>On Jul 9, 2017, at 7:19 AM, Andrei Popescu &lt;A.Popescu@mdx.ac.uk&lt;mailto:<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;&gt; wrote:</p>\n<p>Hi Jeremy and Lars,</p>\n<p>Special care is needed when recursing through permutative structures like sets and multisets. For example, the primrec version discussed here is _not_ equal to the 'fun' version of 'count', since it recursively collapses the numbers coming from subtrees that happen to have the same count. The 'fun' version is the correct one.</p>\n<p>All the best,</p>\n<p>Andrei</p>\n<hr>\n<p>From: cl-isabelle-users-bounces@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; &lt;cl-isabelle-users-bounces@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt;&gt; on behalf of Lars Hupel &lt;hupel@in.tum.de&lt;mailto:<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;&gt;<br>\nSent: 09 July 2017 11:28<br>\nTo: Siek, Jeremy<br>\nCc: cl-isabelle-users@lists.cam.ac.uk&lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt;<br>\nSubject: Re: [isabelle] primrec of datatype containing fset</p>\n<blockquote>\n<p>Thank you for your very thorough answer! It looks like option 1 will<br>\nsuite<br>\nmy needs.</p>\n</blockquote>\n<p>On second thought, I realised that your use of \"ffold\" is merely to<br>\ncompute the sum of some things in a set. Luckily, we can make \"function\"<br>\ncope with that. See attachment for a possible solution (also a version with<br>\n\"primrec\" that doesn't use \"ffold\").</p>\n<p>Cheers<br>\nLars</p>\n<hr>\n<p>Jeremy G. Siek    &lt;jsiek@indiana.edu&lt;mailto:<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;&gt;<br>\nAssociate Professor<br>\nSchool of Informatics and Computing<br>\nIndiana University Bloomington<br>\n<a href=\"http://homes.soic.indiana.edu/jsiek/\">http://homes.soic.indiana.edu/jsiek/</a></p>",
        "id": 294713656,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183039
    },
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;<br>\nHi Manuel,</p>\n<p>Sorry, I had missed your message. I fully agree with your disagreement.  :-)</p>\n<p>Best,</p>\n<p>Andrei</p>",
        "id": 294713708,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183044
    },
    {
        "content": "<p>From: \"Siek, Jeremy\" &lt;<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;<br>\nThanks Andrei!</p>\n<p>Cheers,<br>\nJeremy</p>\n<p>On Jul 9, 2017, at 8:16 AM, Andrei Popescu &lt;A.Popescu@mdx.ac.uk&lt;mailto:<a href=\"mailto:A.Popescu@mdx.ac.uk\">A.Popescu@mdx.ac.uk</a>&gt;&gt; wrote:</p>\n<p>Dear Larry,</p>\n<blockquote>\n<blockquote>\n<p>These days, users should regard \"primrec\" as an internal feature necessary for bootstrapping the system but for implementers only.</p>\n</blockquote>\n</blockquote>\n<p>While this is true in most cases, in complex situations involving nested recursion \"primrec\" can provide the most elegant solution. For example, compare the \"function\"-based definition with the following correct primrec definition:</p>\n<p>primrec count' :: \"val ⇒ nat\" where<br>\n\"count' (VNat n) = 1\" |<br>\n\"count' (VRel t) = fsum (λ((_,v), (_,u)). v + u) (fimage (map_prod (λ v. (v,count' v)) (λ v. (v,count' v))) t)\"</p>\n<p>(This is now correct since all subtrees are counted as separate entities, taking advantage of full primitive recursion as opposed to mere iteration.)</p>\n<p>With a proper setting for congruences and such, this can be handled by \"function\" as well, but this is tricky and quite laborious -- as the current thread shows.</p>\n<p>Best,</p>\n<p>Andrei</p>\n<p>Larry Paulson</p>\n<blockquote>\n<p>On 9 Jul 2017, at 11:15, Lars Hupel &lt;hupel@in.tum.de&lt;mailto:<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;&gt; wrote:</p>\n<p>this is a restriction of \"primrec\". What you're writing is not in fact a<br>\nprimitive recursive specification. There are two ways around that:</p>\n<p>1) Rewrite it as primitive recursive<br>\n2) Use the \"fun\"/\"function\" command</p>\n</blockquote>\n<hr>\n<p>Jeremy G. Siek    &lt;jsiek@indiana.edu&lt;mailto:<a href=\"mailto:jsiek@indiana.edu\">jsiek@indiana.edu</a>&gt;&gt;<br>\nAssociate Professor<br>\nSchool of Informatics and Computing<br>\nIndiana University Bloomington<br>\n<a href=\"http://homes.soic.indiana.edu/jsiek/\">http://homes.soic.indiana.edu/jsiek/</a></p>",
        "id": 294713735,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183051
    },
    {
        "content": "<p>From: Dmitriy Traytel &lt;<a href=\"mailto:traytel@inf.ethz.ch\">traytel@inf.ethz.ch</a>&gt;<br>\nAnd I agree with Andrei’s agreement to Manuel’s disagreement. :)</p>\n<p>The question of using primrec or fun shows up every now and then on this mailing list, e.g., here <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00037.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00037.html</a> &lt;<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00037.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00037.html</a>&gt;.</p>\n<p>Next to the reasons brought up by Manuel before, I also particularly agree with Florian’s advice to use the least powerful command as a means of documentation: <a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00044.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00044.html</a> &lt;<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00044.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2016-May/msg00044.html</a>&gt;</p>\n<p>Dmitriy</p>",
        "id": 294713754,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183057
    }
]