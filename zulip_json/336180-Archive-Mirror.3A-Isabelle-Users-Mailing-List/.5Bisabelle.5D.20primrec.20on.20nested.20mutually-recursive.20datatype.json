[
    {
        "content": "<p>From: Greg Bronevetsky &lt;<a href=\"mailto:greg@bronevetsky.com\">greg@bronevetsky.com</a>&gt;<br>\nI'm trying to do use primrec to define a function that is applied to a <br>\nnested mutually-recursive datatype. The relevant portion of the datatype <br>\ndefinition is below:<br>\ndatatype<br>\n  AppSrcStmt =<br>\n    skip |<br>\n    while PvtAddr \"AppSrcOp list\"<br>\nand<br>\n  AppSrcOp = opTriple \"FuncMark * TypeMark * AppSrcStmt\"</p>\n<p>The primrec in question is a measure function on this datatype, defined <br>\nas follows:<br>\nconsts AppSrcStmtSize :: \"AppSrcStmt =&gt; nat\"<br>\n       AppSrcOpSize :: \"AppSrcOp =&gt; nat\"<br>\n       AppSrcOpListSize :: \"(AppSrcOp list) =&gt; nat\"</p>\n<p>primrec<br>\n  \"AppSrcOpSize (opTriple asOp) = (AppSrcStmtSize (snd (snd asOp)))\"</p>\n<p>\"AppSrcOpListSize [] = 0\"<br>\n  \"AppSrcOpListSize (asOp # opList) = (AppSrcOpSize asOp)\"</p>\n<p>\"AppSrcStmtSize skip = 1\"<br>\n  \"AppSrcStmtSize (while pv aW) = 1 + (AppSrcOpListSize aW)\"</p>\n<p>Unfortunately, I get the following error:<br>\n*** Constant to be defined occurs on rhs<br>\n*** The error(s) above occurred in definition <br>\n\"AppSrcStmtSize_AppSrcStmt_def\":<br>\n***   \"AppSrcStmtSize ==<br>\n***    AppSrcStmt_AppSrcOp_rec_1 (1::nat) (%(pv::nat) aW::AppSrcOp list. <br>\nop + (1::nat))<br>\n***     (%(asOp::nat * nat * AppSrcStmt) asOpa::unit. AppSrcStmtSize <br>\n(snd (snd asOp))) (0::nat)<br>\n***     (%(asOp::AppSrcOp) (opList::AppSrcOp list) (asOpa::nat) <br>\nopLista::nat. asOpa) arbitrary arbitrary\"<br>\n*** At command \"primrec\".</p>\n<p>I think I'm following the directions from section 3.4 of the tutorial <br>\nbut I apparenly I'm missing something. Any thoughts on what the problem <br>\nmight be?</p>",
        "id": 293899581,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660743938
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nGreg Bronevetsky wrote:<br>\nDear Greg,</p>\n<p>the problem is that not only the list datatype, but also the triple type<br>\nis unfolded (into two pair types). As a consequence, you need two more<br>\nsize functions, one on type \"FuncMark * TypeMark * AppSrcStmt\" and one<br>\non type \"FuncMark * TypeMark * AppSrcStmt\". The following definition should<br>\nwork:</p>\n<p>consts<br>\n   AppSrcStmtSize :: \"AppSrcStmt =&gt; nat\"<br>\n   AppSrcOpSize :: \"AppSrcOp =&gt; nat\"<br>\n   AppSrcOpListSize :: \"(AppSrcOp list) =&gt; nat\"<br>\n   AppSrcOpTripleSize :: \"FuncMark * TypeMark * AppSrcStmt =&gt; nat\"<br>\n   AppSrcOpPairSize :: \"TypeMark * AppSrcStmt =&gt; nat\"</p>\n<p>primrec<br>\n  \"AppSrcOpSize (opTriple asOp) = AppSrcOpTripleSize asOp\"</p>\n<p>\"AppSrcOpTripleSize (x, y) = AppSrcOpPairSize y\"</p>\n<p>\"AppSrcOpPairSize (x, y) = AppSrcStmtSize y\"</p>\n<p>\"AppSrcOpListSize [] = 0\"<br>\n  \"AppSrcOpListSize (asOp # opList) = (AppSrcOpSize asOp)\"</p>\n<p>\"AppSrcStmtSize skip = 1\"<br>\n  \"AppSrcStmtSize (while pv aW) = 1 + (AppSrcOpListSize aW)\"</p>\n<p>See also the theorems AppSrcStmt_AppSrcOp.size provided by the datatype<br>\npackage, which follow a similar scheme.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 293899606,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660743945
    },
    {
        "content": "<p>From: Greg Bronevetsky &lt;<a href=\"mailto:greg@bronevetsky.com\">greg@bronevetsky.com</a>&gt;<br>\nThank you. What you suggests works. However, when I apply it to my full <br>\nexample I'm still getting errors. The problem is that my language has if <br>\nstatements as well as while statements. Adding them to my type <br>\ndefinition, produces the following:<br>\n AppSrcStmt =<br>\n   skip |<br>\n   ifStmt PvtAddr \"AppSrcOp list\" \"AppSrcOp list\"<br>\n   while PvtAddr \"AppSrcOp list\"<br>\nand<br>\n AppSrcOp = opTriple \"FuncMark * TypeMark * AppSrcStmt\"</p>\n<p>I then use the following definition of the size funciton (directly <br>\nderived from your email):<br>\nconsts<br>\n  AppSrcStmtSize :: \"AppSrcStmt =&gt; nat\"<br>\n  AppSrcOpSize :: \"AppSrcOp =&gt; nat\"<br>\n  AppSrcOpListSize :: \"(AppSrcOp list) =&gt; nat\"<br>\n  AppSrcOpTripleSize :: \"FuncMark * TypeMark * AppSrcStmt =&gt; nat\"<br>\n  AppSrcOpPairSize :: \"TypeMark * AppSrcStmt =&gt; nat\"</p>\n<p>primrec<br>\n \"AppSrcOpSize (opTriple asOp) = AppSrcOpTripleSize asOp\"</p>\n<p>\"AppSrcOpTripleSize (x, y) = AppSrcOpPairSize y\"</p>\n<p>\"AppSrcOpPairSize (x, y) = AppSrcStmtSize y\"</p>\n<p>\"AppSrcOpListSize [] = 0\"<br>\n \"AppSrcOpListSize (asOp # opList) = (AppSrcOpSize asOp) + <br>\n(AppSrcOpListSize opList)\"</p>\n<p>\"AppSrcStmtSize skip = 1\"<br>\n \"AppSrcStmtSize (ifStmt pv aTrue aFalse) = 1 + (AppSrcOpListSize aTrue) </p>\n<ul>\n<li>(AppSrcOpListSize aFalse)\"<br>\n \"AppSrcStmtSize (while pv aW) = 1 + (AppSrcOpListSize aW)\"</li>\n</ul>\n<p>When I do this, I get the following error:<br>\n*** Primrec definition error:<br>\n*** inconsistent functions for datatype \"List.list\"<br>\n*** in<br>\n*** \"AppSrcStmtSize (ifStmt pv aTrue aFalse) = 1 + AppSrcOpListSize aTrue\"<br>\n*** At command \"primrec\".</p>\n<p>After playing around with it, I see that the problem comes from the fact <br>\nthat AppSrcOpListSize appears on the right hand side of AppSrcStmtSize <br>\nin three spots. If I comment out any two of the references to <br>\nAppSrcOpListSize then the definition goes through without a problem. <br>\nHowever, if there is more than one such reference, I get the above <br>\nerror. Any ideas?</p>",
        "id": 293899616,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660743948
    },
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nGreg Bronevetsky wrote:<br>\nThe problem is that each occurrence of \"AppSrcOp list\" is unfolded.<br>\nConsequently, you have to give a separate size function for each of<br>\nthese occurrences, even though they happen to behave in the same way.<br>\nThe following definition should work:</p>\n<p>consts<br>\n  AppSrcStmtSize :: \"AppSrcStmt =&gt; nat\"<br>\n  AppSrcOpSize :: \"AppSrcOp =&gt; nat\"<br>\n  AppSrcOpListSize1 :: \"(AppSrcOp list) =&gt; nat\"<br>\n  AppSrcOpListSize2 :: \"(AppSrcOp list) =&gt; nat\"<br>\n  AppSrcOpListSize3 :: \"(AppSrcOp list) =&gt; nat\"<br>\n  AppSrcOpTripleSize :: \"FuncMark * TypeMark * AppSrcStmt =&gt; nat\"<br>\n  AppSrcOpPairSize :: \"TypeMark * AppSrcStmt =&gt; nat\"</p>\n<p>primrec<br>\n\"AppSrcOpSize (opTriple asOp) = AppSrcOpTripleSize asOp\"</p>\n<p>\"AppSrcOpTripleSize (x, y) = AppSrcOpPairSize y\"</p>\n<p>\"AppSrcOpPairSize (x, y) = AppSrcStmtSize y\"</p>\n<p>\"AppSrcOpListSize1 [] = 0\"<br>\n\"AppSrcOpListSize1 (asOp # opList) = (AppSrcOpSize asOp) + (AppSrcOpListSize1 opList)\"</p>\n<p>\"AppSrcOpListSize2 [] = 0\"<br>\n\"AppSrcOpListSize2 (asOp # opList) = (AppSrcOpSize asOp) + (AppSrcOpListSize2 opList)\"</p>\n<p>\"AppSrcOpListSize3 [] = 0\"<br>\n\"AppSrcOpListSize3 (asOp # opList) = (AppSrcOpSize asOp) + (AppSrcOpListSize3 opList)\"</p>\n<p>\"AppSrcStmtSize skip = 1\"<br>\n\"AppSrcStmtSize (ifStmt pv aTrue aFalse) = 1 + (AppSrcOpListSize1 aTrue) + (AppSrcOpListSize2 aFalse)\"<br>\n\"AppSrcStmtSize (while pv aW) = 1 + (AppSrcOpListSize3 aW)\"</p>\n<p>Again, a quick look at the theorems AppSrcStmt_AppSrcOp.size reveals<br>\nhow the scheme works.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 293899630,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660743952
    },
    {
        "content": "<p>From: Greg Bronevetsky &lt;<a href=\"mailto:greg@bronevetsky.com\">greg@bronevetsky.com</a>&gt;<br>\nAh, that worked! One final question then. You suggested that I look at <br>\nthe theorem AppSrcStmt_AppSrcOp.size. How do I do that?</p>",
        "id": 293899631,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660743953
    }
]