[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Gottfried,</p>\n<p>This looks like a primrec_new bug in Isabelle2013-2 (it works with \"the\" development <br>\nversion, e.g., 761e40ce91bc). As a workaround, you can wrap x in some function such as id.</p>\n<p>primrec_new get_hS_FAILS :: \"hD =&gt; hD fset\" where<br>\n   \"get_hS_FAILS hEM    = {||}\"<br>\n  |\"get_hS_FAILS (hS x) = id x\"</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294263258,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660915163
    },
    {
        "content": "<p>From: G B &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;</p>\n<blockquote>\n<blockquote>\n<p>[by Andreas]...As a workaround, you can wrap x in some function such as id.</p>\n</blockquote>\n</blockquote>\n<p>Andreas, thanks again.</p>\n<blockquote>\n<p>Incidentally, I'm wondering whether you really need the \"hEM\" constructor in</p>\n<p>datatype_new hD = hEM | hS \"hD fset\"</p>\n<p>The canonical definition of hereditarily finite sets reads</p>\n<p>datatype_new hD = hS \"hD fset\"</p>\n</blockquote>\n<p>Jasmin,</p>\n<p>No, I don't, but I would have wasted a lot of time to find out that I <br>\ndon't, if you wouldn't have told me, so I'm grateful for you taking the <br>\ntime to tell me, and for other things also.</p>\n<p>I am a foreigner, living among wizards, where I've known mainly only <br>\nabout the canonical Canon_List_Rule, in which there is <code>Nil</code> and <code>Cons x \nxs</code>. Because the Canon_List_Rule demands the existence of <code>Nil</code>, I <br>\nconcluded that I must claim the existence of a <code>hEM</code>.</p>\n<p>True mathematical elegance is a statement that is so simple, it's hard <br>\nfor a novice to understand what information the statement contains.</p>\n<p>Now, I understand the magic of the polymorphic empty set, <code>{||}</code>, along <br>\nwith the fact that it happens to be type correct for the constructor <br>\n<code>hs</code>. The understanding about <code>{||}</code> being type correct didn't come <br>\nuntil I started to try and simplify another <code>datatype</code>, based on your <br>\nquestion/suggestion.</p>\n<p>This demonstrates the value of occasionally interacting with actual <br>\nhumanoids, rather than only indirectly interacting through software. <br>\nError messages and failed proof attempts are valuable in that they tell <br>\nme, \"Novice, we wizards want to teach you something. It is enough that <br>\nwe have told you that you are wrong.\"</p>\n<p>But when I don't get an error message and my proofs succeed, and I'm <br>\nbeing logically clumsy, the software alone can't teach me a better way.</p>\n<p>It appears that use of <code>datatype_new</code> to define hereditarily finite sets <br>\nis not something that is easily hidden.</p>\n<p>I actually only defined 'hD` because I figure if wizards are talking <br>\nabout hereditarily finite sets, then it's something I'm supposed to care <br>\nabout.</p>\n<p>The <code>hS</code> ends up being one of 4 variations of sets I'm trying to work on <br>\nthat are variations of ZFC sets. I have two more powerful versions that <br>\nhopefully will pan out. For a year and a half, I've worked on an axiom <br>\nbased set that gives me things I can be used with little or no modification.</p>\n<p>The appearance of <code>datatype_new</code> has turned me into a closet <br>\nconstructivist, where I use <code>THE</code> and <code>SOME</code> only to hypocritically <br>\nrebel against the constructivists, but never use if <code>THE</code> and <code>SOME</code> <br>\nwill prevent me from producing what could otherwise be used for computation.</p>\n<p>On August 8, 2013, I was getting some foggy ideas on how I thought I <br>\nneeded to recursively define a certain object using nested sets. On that <br>\nday, there came the list email \"Re: [isabelle] nested datatypes\" [1], <br>\nwhich told of the a new datatype package coming down the pipe, and I saw <br>\nthat I merely needed to wait for that, because traditional ZFC sets are <br>\nlike the Hotel California, you can check elements in, but it's a hell in <br>\nthere, because it's hard to check them out. At least, that's my impression.</p>\n<p>A large part of the value of Nitpick and Sledgehammer is the help they <br>\ngive me in prototyping. In one day, Nitpick showed me I needed to <br>\nabandon two different definitions I was trying to implement. Then, after <br>\ncoming up with a partially good definition, Nitpick and Sledgehammer <br>\nhelped me get enough other definitions going, and theorems proved, to <br>\nknow I was on the right track.</p>\n<p>I could start hitting these four variations hard, but I have a bad <br>\nco-dependent relation with Sledgehammer. It's a high when it gives me an <br>\neasy proof, but when it doesn't immediately provide a proof, I have to <br>\nget manipulative. I don't care that I'm being manipulative. I only care <br>\nthat it takes too much time, and that I don't have a bigger toolbox to <br>\nbe able to optimize the metis proofs it gives me.</p>\n<p>So, I have to take a huge, time-consuming tangent on logic.</p>\n<p>I am a prophet who makes easy, fail-safe prophecies. In the game of <br>\nlogic, Isabelle will be a huge gamer-changer with the masses, and <br>\ndatatype_new will be a big game-changer in the game of Isabelle/HOL.</p>\n<p>Regards,<br>\nGB</p>\n<p>[1] <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-August/msg00017.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-August/msg00017.html</a></p>",
        "id": 294263280,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660915176
    }
]