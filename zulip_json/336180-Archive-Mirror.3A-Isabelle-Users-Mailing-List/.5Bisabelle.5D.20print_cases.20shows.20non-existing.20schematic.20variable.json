[
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nI have an introduction rule which has a lot of premises. These premises<br>\nalso have some assumptions. It is very tedious to fix all the variables<br>\nand assume all the assumptions over and over again, so I decided to<br>\ninvestigate whether I can leverage Isar's 'case' notation for proofs<br>\nusing this rule.</p>\n<p>My first attempt was to start my proof like this:</p>\n<p>lemmas irule_cases = irulesI[case_names a b c d e]</p>\n<p>proof (cases rule: irule_cases)</p>\n<p>This works out almost as I expected. I can write down</p>\n<p>case a<br>\n    show ...<br>\n      ...<br>\n  next<br>\n    case b<br>\n    show ...</p>\n<p>However, the schematic variable '?case' does not exist. In other<br>\nsituations, I can just use 'show ?thesis', but this is not applicable here.</p>\n<p>Strangely enough, this is what 'print_cases' prints:</p>\n<p>cases:<br>\n    a:<br>\n      let \"?case\" = \"is_fmap ?rs\"</p>\n<p>But the variable is just not there, which can be confirmed via<br>\n'Query/Print Context'.</p>\n<p>I've browsed through the Isar reference and found the attribute<br>\n'case_conclusion':</p>\n<p>lemmas irule_cases =<br>\n    irulesI[case_names a b c d e,<br>\n            case_conclusion a foo, ...]</p>\n<p>Now, 'print_cases' claims that '?foo' exists, but it doesn't.</p>\n<p>Now, if I change the initial proof step to use 'induct' instead of<br>\n'cases', I get the '?case' variable. However, I would argue, that using<br>\n'induct' for this situation feels even more unnatural than using 'cases'.</p>\n<p>In ยง6.6.1 of the Isar reference, it is stated about the 'case' command<br>\nthat \"Term bindings may be covered as well, notably ?case for the main<br>\nconclusion.\" I haven't found anything about when exactly '?case' is<br>\npresent or absent.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294635619,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160011
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Lars,</p>\n<p>I don't know the design choices for cases, as I have not implemented them, but here are my <br>\ncomments: cases assumes that you give it a conventional case analysis rules. These rules <br>\ndo not change the conclusion, so cases has some point in not providing any term <br>\nabbreviations for the conclusions. Anyway, you are trying to use sophisticated proof <br>\nmethods just to benefit from a certain side effect. I used to do that regularly, too (and <br>\nsometimes still do, but much less).</p>\n<p>I guess that it should be fairly easy to implement your own method that does nothing but <br>\napplying a rule and setting up the cases. The infrastructure should be all there.</p>\n<p>Andreas</p>",
        "id": 294635656,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160023
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nAfter looking at the code a bit I was wondering, how the cases method<br>\nmanages to not declare the term bindings -- the term bindings are<br>\npresent in the cases and I could not find an obvious flag or similar<br>\nwhich would hide the term bindings.</p>\n<p>Does anybody know how this is achieved?</p>\n<p>-- Lars</p>",
        "id": 294635666,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160029
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nIndeed.  Proof methods can always produce cases as they see fit, cf. <br>\nexisting uses of METHOD_CASES and type cases_tactic.  These things have <br>\nbeen slightly tuned and cleaned up for Isabelle2015, as part of the <br>\nintegration of Eisbach.</p>\n<p>Nonetheless, proof method definitions with cases are rare in practice. <br>\nIt requires some care and sometimes technical tricks to get material from <br>\nthe internal goal state into the proof text, without breaking down normal <br>\nIsar principles of proof composition.</p>\n<p>One example that is not from the \"cases\" and \"induct\" family is <br>\n\"eventually_elim\" in ~~/src/HOL/Filter.thy (in Isabelle2015-RC1).  It uses <br>\nsome basic tools to compose cases from module Rule_Cases, which is also <br>\nthe basis for the other cases methods.</p>\n<p>Makarius</p>",
        "id": 294635699,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160041
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThings really happen in ~~/src/Pure/Isar/proof_context.ML at his point:</p>\n<p>fun case_result c ctxt =<br>\n   let<br>\n     val Rule_Cases.Case {fixes, ...} = c;<br>\n     val (ts, ctxt') = ctxt |&gt; fold_map fix fixes;<br>\n     val Rule_Cases.Case {assumes, binds, cases, ...} = Rule_Cases.apply ts c;<br>\n   in<br>\n     ctxt'<br>\n     |&gt; bind_terms (map drop_schematic binds)<br>\n     |&gt; update_cases true (map (apsnd SOME) cases)<br>\n     |&gt; pair (assumes, (binds, cases))<br>\n   end;</p>\n<p>val apply_case = apfst fst oo case_result;</p>\n<p>Later on in proof.ML, apply_case is turned into Proof.invoke_case, which <br>\nis the Isabelle/ML definition of the Isar command 'case'.</p>\n<p>The drop_schematic above drops term bindings that happen to contain <br>\nleft-over schematic variables, i.e. have not been properly determined by <br>\nother means (further instantiation by the proof method etc.).</p>\n<p>It is a classic Isar principle that proof text (and cases are part of <br>\nthat) cannot be schematic.  When implementing these things about 15 years <br>\nago, I kept it rather simple by leaving schematic parts for informative <br>\npurposes until the last moment.  Something similar happens for schematic <br>\ntype variables, e.g. due to hidden polymorphism.</p>\n<p>So instead of halting and catching fire due to schematic variables <br>\nsomewhere, things only fail late for situations where the user insists to <br>\nmake use of uninstantiated proof context elements.  Note that the user may <br>\nalso choose to ignore the debatable case definitions, and proceed by other <br>\nmeans.</p>\n<p>Today, we have higher ambitions in comfort (also IDE support).  I am <br>\ntrying to revisit all this for some years already, but again did not <br>\nmanage for Isabelle2015.</p>\n<p>Makarius</p>",
        "id": 294635712,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160047
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 22.04.2015 14:54, Makarius wrote:</p>\n<blockquote>\n<p>On Wed, 22 Apr 2015, Lars Noschinski wrote:</p>\n<blockquote>\n<p>After looking at the code a bit I was wondering, how the cases method<br>\nmanages to not declare the term bindings -- the term bindings are<br>\npresent in the cases and I could not find an obvious flag or similar<br>\nwhich would hide the term bindings.</p>\n</blockquote>\n<p>Things really happen in ~~/src/Pure/Isar/proof_context.ML at his point:</p>\n<p>fun case_result c ctxt =<br>\n  let<br>\n    val Rule_Cases.Case {fixes, ...} = c;<br>\n    val (ts, ctxt') = ctxt |&gt; fold_map fix fixes;<br>\n    val Rule_Cases.Case {assumes, binds, cases, ...} =<br>\nRule_Cases.apply ts c;<br>\n  in<br>\n    ctxt'<br>\n    |&gt; bind_terms (map drop_schematic binds)<br>\n    |&gt; update_cases true (map (apsnd SOME) cases)<br>\n    |&gt; pair (assumes, (binds, cases))<br>\n  end;</p>\n<p>val apply_case = apfst fst oo case_result;<br>\n[...]<br>\nThe drop_schematic above drops term bindings that happen to contain<br>\nleft-over schematic variables, i.e. have not been properly determined<br>\nby other means (further instantiation by the proof method etc.).<br>\nOh, so that's indeed done by this mechanism. Thanks for the explanation.<br>\n(I was sure I had constructed a situation where \"cases\" produced<br>\nnon-schematic bindings before, but was apparently not careful enough).</p>\n</blockquote>\n<p>-- Lars</p>",
        "id": 294635748,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160060
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nThe problem is that the 'cases' method doesn't instantiate the rule<br>\nbefore setting up the cases, as opposed to what 'induct' does. If I write</p>\n<p>proof (cases rule: foo[where ...])</p>\n<p>I get the '?case' bindings.</p>\n<p>I completely understand why Isar text can't be schematic, which is why<br>\nI'm wondering whether the 'cases' method can be changed to perform<br>\nmatching before setting up the cases.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294635762,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661160066
    }
]