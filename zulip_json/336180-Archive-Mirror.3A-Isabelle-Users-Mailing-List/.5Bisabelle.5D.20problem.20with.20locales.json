[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nI have the following two locales:</p>\n<p>locale node =<br>\n   fixes nil :: \"'node\"<br>\n   assumes infinite: \"Â¬ finite (UNIV::'node set)\"<br>\nbegin<br>\n   definition \"domain f = {x :: 'node .  - (f x = (nil::'node))}\"<br>\nend</p>\n<p>locale list = node +<br>\n   fixes \"next\" :: \"'node =&gt; 'node\"<br>\n   fixes val :: \"'node =&gt; 'node\"<br>\n   assumes \"next (nil::'node) = nil\"</p>\n<p>These locales generate error \"Type unification failed\". If I drop the<br>\ndefinition from the first locale then I do not get this message.</p>\n<p>More generally. Is there a standard mechanism to enforce<br>\nthe type 'node from the first locale to be the same as the<br>\ntype node from the second locale?</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294147273,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847973
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nDear Viorel,</p>\n<p>when locales inherit from other locales, Isabelle always renames type variables <br>\nof the inherited locales to 'a, 'b, 'c, etc. There are two ways to undo the <br>\nrenaming:</p>\n<p>a) Do not use the locale feature of implicitly adding unmentioned parameters of <br>\nimported locales to the for clause, but state them explicitly:</p>\n<p>locale list = node nil for nil :: \"'node\" + ...</p>\n<p>The drawback is that you have to redeclare mixfix syntax if your imported locale <br>\ndeclares such for the parameter. If you do not plan to use syntax annotations <br>\nanyway, this is the preferred way.</p>\n<p>b) Constrain the parameter types using \"constrains\":</p>\n<p>locale list = node +<br>\n   constrains nil :: \"'node\"<br>\n   fixes \"next\" :: \"'node =&gt; node\"<br>\n...</p>\n<p>The advantage is that constrains does not delete mixfix syntax. However, Clemens <br>\nhas threatened to remove this rarely known feature in some futute release. <br>\nMoreover, this often still gives you type error messages. I found that it works <br>\nreliably if</p>\n<ol>\n<li>the locale inherits from exactly one other locale,</li>\n<li>you constrain all inherited parameters consistently, and</li>\n<li>in the locale assumptions, you do not refer to constants defined in the <br>\ninherited locale (or any of its anchestors).</li>\n</ol>\n<p>Both solutions are not ideal and I would be glad if the locale mechanism did not <br>\nrename type variable apparently randomly. However, I haven't yet been able to <br>\nconvince the Isabelle developpers solve this problem.</p>\n<p>Best regards,<br>\nAndreas</p>",
        "id": 294147281,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847978
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 7 Nov 2011, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>Dear Viorel,</p>\n<p>when locales inherit from other locales, Isabelle always renames type <br>\nvariables of the inherited locales to 'a, 'b, 'c, etc. There are two <br>\nways to undo the renaming:</p>\n</blockquote>\n<p>That's an old topic about locales.  What you are asking for is a mechanism <br>\nfor \"locale inheritance\" in the first place, which simply does not exist <br>\nat the moment.  The one you have called as such above is \"polymorphic <br>\nlocale import\", which explains the most general canonical type assignment <br>\nin the result.  (When you refer to a polymorphic constant into a term the <br>\nsame happens without much surprise.)</p>\n<blockquote>\n<p>Both solutions are not ideal and I would be glad if the locale mechanism <br>\ndid not rename type variable apparently randomly. However, I haven't yet <br>\nbeen able to convince the Isabelle developpers solve this problem.</p>\n</blockquote>\n<p>Concerning \"the Isabelle developpers\" the situation of locales is <br>\nespecially difficult.  I am glad that Clemens Ballarin left things in a <br>\nquite reasonably state in 2009, after the chaotic phase of 2005-2008, when <br>\ntoo many people where trying too many things at the same time (including <br>\nmyself).  More recently, Florian Haftmann has done some more cleanup, and <br>\nI have also recommenced myself to address long-standing known problems <br>\n(like the dynamic evaluation of attributes inherited from distant past).</p>\n<p>Locales are a very delicate area of the system, and it requires extreme <br>\ncare to make some actual progress, without causing collateral damage to <br>\nexisting infrastructure.</p>\n<p>Makarius</p>",
        "id": 294147295,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847984
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nDear Andreas,</p>\n<p>Using constrains solved my problem. Using this constrains declaration<br>\nseem like a nice solution to this problem. I don't see the reason to<br>\nremove it, but on the contrary to document it well.</p>\n<p>I had earlier this problem and the way I solved it was by imposing<br>\nadditional dummy assumptions on the imported constants.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294147320,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660847990
    }
]