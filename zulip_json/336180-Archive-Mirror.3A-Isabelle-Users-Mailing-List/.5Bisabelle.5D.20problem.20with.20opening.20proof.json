[
    {
        "content": "<p>From: Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt;<br>\nOK, I gave Isar another try and I'm making some progress with it. Anyway.</p>\n<p>I have some statements like</p>\n<p>fix ...<br>\nassume ... and ...<br>\nthus \"EX x y. ...\"<br>\nproof</p>\n<p>The \"proof\" line fails, with \"empty result sequence\", unless I change<br>\nit to \"proof -\" or change \"thus\" to \"show\", hence taking the<br>\nassumptions out of \"this\". Why are my assumptions getting in the way<br>\nof what should be a simple application of exI? This makes no sense to<br>\nme, as exI only cares about the conclusion. Let me know if I need to<br>\nsend an example.</p>\n<p>On a completely different note, it would be cool if abbreviations<br>\ncould be made that are local to proofs. Often I have expressions<br>\nrepeated several times throughout a goal that make it quite large,<br>\nwhen it would be manageable with some abbreviations. Let statements<br>\nare nice, but they're expanded in the goal display. Such a command<br>\nmight not semantically differ from the let command.</p>\n<p>Chris Capel</p>",
        "id": 294077739,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829535
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Chris,</p>\n<blockquote>\n<p>fix ...<br>\nassume ... and ...<br>\nthus \"EX x y. ...\"<br>\nproof</p>\n</blockquote>\n<p>\"proof\" is short for \"proof default\", where the \"default\" method performs:</p>\n<ol>\n<li>\n<p>introduction using a suitable predeclared rule if no facts are<br>\nchained in.</p>\n</li>\n<li>\n<p>elimination using a suitable predeclared rule if any facts are<br>\nchained in.</p>\n</li>\n</ol>\n<p>So in your case it fails because there are no suitable elimination rules<br>\nfor your assumptions.</p>\n<p>What you can try instead:</p>\n<blockquote>\n<p>fix ...<br>\nassume P: ... and Q: ...<br>\nshow \"EX x y. ...\"<br>\nproof<br>\n  from P Q ...</p>\n</blockquote>\n<p>or perhaps</p>\n<blockquote>\n<p>fix ...<br>\nassume ... and ...<br>\nshow \"EX x y. ...\"<br>\nproof (intro exI)</p>\n</blockquote>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/07MJYg4zOrvGy5XrmxNqyTDh/signature.asc\">signature.asc</a></p>",
        "id": 294077758,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829549
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nHi Chris,</p>\n<p>I have often used local definitions to help manage the size of large<br>\nsubgoals. There are two ways to use them. First, you can use \"defines\"<br>\nin the theorem statement:</p>\n<p>lemma foo:<br>\n  fixes x and y ...<br>\n  assumes ...<br>\n  defines wibble_def: \"wibble == ... x ... y ...\"<br>\n  shows \"... wibble ...\"</p>\n<p>Note that if the rhs of the definition mentions any free variables,<br>\nthey must be previously declared using \"fixes\". Once you finish the<br>\nproof, the local definitions are unfolded, and the locally-defined<br>\nconstants do not appear in the resulting theorem.</p>\n<p>The other method is to use the \"def\" command. Note the unusual<br>\nplacement of the quote marks---only the rhs is quoted.</p>\n<p>lemma foo: ...<br>\nproof -<br>\n  fix x and y<br>\n  def wibble == \"... x .. y ...\"<br>\n  show ...</p>\n<p>Local definitions are not abbreviations; you will still need to<br>\nfold/unfold the definitions manually within the proofs. But if your<br>\nsubgoal terms are really big, this is an advantage: Not only do your<br>\ngoals look smaller, they really are smaller---which makes<br>\nsimplification and other proof tactics run faster.</p>\n<p>On the other hand, it would be nice to have both local definitions and<br>\nlocal abbreviations. I'm sure that it would be possible to implement<br>\nan \"abbrev\" command that works much like \"def\", but I'm just not sure<br>\nhow to do it.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294077775,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829557
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Chris,</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>fix ...<br>\nassume ... and ...<br>\nthus \"EX x y. ...\"<br>\nproof<br>\n\"proof\" is short for \"proof default\", where the \"default\" method performs:</p>\n</blockquote>\n</blockquote>\n<p>In the Isar documentation it says \"Unless given explicitly by the<br>\nuser, the default initial method is “rule”\". Is this inaccurate?</p>\n</blockquote>\n<p>Indeed, \"default\" is almost \"rule\", except if the proposition to prove<br>\ninvolves class or locale predicates;  this we can ignore here.</p>\n<blockquote>\n<p>But why does it also fail for \"proof (rule exI)\"? What's the<br>\ndifference between rule and intro that allows the latter to succeed?</p>\n</blockquote>\n<p>\"rule\" performs introduction if no facts are chained in, and elimination<br>\nif some facts are chained in.  \"intro\" only performs introduction.</p>\n<p>Hope this helps<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/pmquyzJ9_IL3VqUg0Gn04Imr/signature.asc\">signature.asc</a></p>",
        "id": 294077798,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829573
    },
    {
        "content": "<p>From: Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt;<br>\nOn Fri, May 22, 2009 at 02:23, Florian Haftmann<br>\n&lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Chris,</p>\n<blockquote>\n<p>fix ...<br>\nassume ... and ...<br>\nthus \"EX x y. ...\"<br>\nproof</p>\n</blockquote>\n<p>\"proof\" is short for \"proof default\", where the \"default\" method performs:</p>\n</blockquote>\n<p>In the Isar documentation it says \"Unless given explicitly by the<br>\nuser, the default initial method is “rule”\". Is this inaccurate? I<br>\nsuppose if the mode is not proof(chain) then default is the same as<br>\nrule? And otherwise it's the same as erule? In fact, the \"default\"<br>\nmethod isn't in the documentation's index at all.</p>\n<blockquote>\n<ol>\n<li>\n<p>introduction using a suitable predeclared rule if no facts are<br>\nchained in.</p>\n</li>\n<li>\n<p>elimination using a suitable predeclared rule if any facts are<br>\nchained in.</p>\n</li>\n</ol>\n</blockquote>\n<p>Thanks, I totally didn't know that at all. It does explain things,<br>\nthough, except...</p>\n<blockquote>\n<p>So in your case it fails because there are no suitable elimination rules<br>\nfor your assumptions.</p>\n</blockquote>\n<p>But why does it also fail for \"proof (rule exI)\"? What's the<br>\ndifference between rule and intro that allows the latter to succeed?</p>\n<p>Chris Capel</p>",
        "id": 294077830,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829585
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 22 May 2009, Chris Capel wrote:</p>\n<blockquote>\n<blockquote>\n<p>\"proof\" is short for \"proof default\", where the \"default\" method performs:</p>\n</blockquote>\n<p>In the Isar documentation it says \"Unless given explicitly by the<br>\nuser, the default initial method is “rule”\". Is this inaccurate?</p>\n</blockquote>\n<p>The manual is indeed less accurate than the true source text. <br>\nConceptually, 'proof' without argument performs a \"default\" step, but the <br>\nmethod of that name is essentially dynamically rebound by some later <br>\nstages (2 times in Isabelle/HOL).</p>\n<p>The main idea of a default step is represented by the Pure \"rule\" method; <br>\nthe later additions for type classes and classical reasoning can be <br>\nignored for now.</p>\n<blockquote>\n<p>I suppose if the mode is not proof(chain) then default is the same as <br>\nrule? And otherwise it's the same as erule?</p>\n</blockquote>\n<p>No, method \"rule\" is always just that.  Any proper Isar method is <br>\nsensitive to the facts being chained.  Thus chaining + rule acts like an <br>\nelimination, and no chaining + rule like a plain introduction.</p>\n<p>The variants \"erule\" etc. are from a slightly different (tactical) layer, <br>\nwhich are never required in properly structured Isar proofs.</p>\n<blockquote>\n<p>But why does it also fail for \"proof (rule exI)\"? What's the difference <br>\nbetween rule and intro that allows the latter to succeed?</p>\n</blockquote>\n<p>The \"intro\" method repeatedly unfolds introduction rules.  As a weakly <br>\nstructured tool, it merely inserts facts into the goal initially, without <br>\ntaking them a seriously as \"rule\".  This is analogous to \"simp\", \"auto\" <br>\netc.</p>\n<p>You should be able to ignore the \"intro\" and \"elim\" methods most of the <br>\ntime -- they stem from a very early stage of Isar when structured proofs <br>\nwere not fully understood yet.</p>\n<p>Makarius</p>",
        "id": 294077845,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829590
    },
    {
        "content": "<p>From: \"Dr. Brendan Patrick Mahony\" &lt;<a href=\"mailto:brendan.mahony@dsto.defence.gov.au\">brendan.mahony@dsto.defence.gov.au</a>&gt;<br>\nIs there any source I can access that describes this full  <br>\nunderstanding of structured proofs?</p>\n<p>Generally, I see the structured proof game as coaxing the proof engine  <br>\ninto returning the particular proof state that I feel best explains  <br>\nthe truth of my proposition to the human reader. To this end, I find  <br>\nintro and elim necessary quite often, when the default reasoning set  <br>\nreturns a proof state that is incomprehensible to a human reader.  <br>\nSince it is very hard to massage the default set into a manageable  <br>\nshape it is easiest to use a number of intro, elim and simp methods to  <br>\nget the desired proof state. Obviously, it is suboptimal to have long  <br>\nconvoluted chains of methods that result in the \"obvious\" goal state,  <br>\nsince this will tend to make the reader uneasy about the \"formal  <br>\nnonsense\" that is meant to be reassuring them about the quality of the  <br>\nproof being offered. However, it is certainly better than having a  <br>\nshort chain of methods that result it an unintuitive or  <br>\nincomprehensible or even unexpectedly non-existent proof state.</p>\n<p>I still must say, that I can't follow the reasoning behind the way  <br>\ndefault/rule is implemented. My confusion is well described by the  <br>\nfollowing examples, the first of which is a valid proof</p>\n<p>lemma<br>\n   assumes<br>\n     a1: \"A\" and<br>\n     a2: \"B\"<br>\n   shows<br>\n     \"A &amp; B\"<br>\n   using a1 a2 ..</p>\n<p>lemma<br>\n   assumes<br>\n     a1: \"A\" and<br>\n     a2: \"B\"<br>\n   shows<br>\n     \"A &amp; B\"<br>\n   using a2 a1 ..</p>\n<p>and the second of which is not.</p>\n<p>This can be seriously annoying when trying to chain facts</p>\n<p>assume b1: \"B\"<br>\nhave b2: \"A\"<br>\n   -- proof<br>\nwith b1 show \"A &amp; B\" ..</p>\n<p>IMPORTANT: This email remains the property of the Australian Defence Organisation and is subject to the jurisdiction of section 70 of the CRIMES ACT 1914.  If you have received this email in error, you are requested to contact the sender and delete the email.</p>",
        "id": 294077867,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829603
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 25 May 2009, Dr. Brendan Patrick Mahony wrote:</p>\n<blockquote>\n<p>On 23/05/2009, at 7:13 PM, Makarius wrote:</p>\n<blockquote>\n<p>You should be able to ignore the \"intro\" and \"elim\" methods most of the <br>\ntime -- they stem from a very early stage of Isar when structured <br>\nproofs were not fully understood yet.</p>\n</blockquote>\n<p>Is there any source I can access that describes this full understanding <br>\nof structured proofs?</p>\n</blockquote>\n<p>Let's say, the understanding has greatly improved since then, but is not <br>\nreally a \"full\" one.</p>\n<p>An up-to-date exposition of general Isar concepts and machinery is now in <br>\nsection 2 of the isar-ref manual.  This spot has been empty for ten years <br>\nand has been filled only a few months ago.</p>\n<p>Nonetheless, there are many things that are not written anywhere, notably <br>\nabout the deeper reasons for various design details.  I am already glad <br>\nenough to have occasional readers of the more basic stuff, and did not see <br>\na market yet for the really arcane lore.</p>\n<blockquote>\n<p>Generally, I see the structured proof game as coaxing the proof engine <br>\ninto returning the particular proof state that I feel best explains the <br>\ntruth of my proposition to the human reader.</p>\n</blockquote>\n<p>This basic principle has been there in Isar from the very beginning, but <br>\nits focus has shifted more and more away from goals, towards more direct <br>\ncomposition of facts (with nice derived concepts like 'also' and 'obtain', <br>\nfree-form blocks { ... } etc.).</p>\n<blockquote>\n<p>To this end, I find intro and elim necessary quite often, when the <br>\ndefault reasoning set returns a proof state that is incomprehensible to <br>\na human reader.</p>\n</blockquote>\n<p>The \"intro\" and \"elim\" methods are probably best understood as logical <br>\ncounterparts to \"unfold\".  This category of methods can be used at the <br>\nstart of an Isar proof, but the demand for this has greatly diminished <br>\nover the years.</p>\n<p>For example, in 1999 (when doing the HahnBanach case-study) we found <br>\nourselves using \"elim\" a lot to simulate what 'obtain' would become a bit <br>\nlater.  Moreover, free-form blocks with moreover/ultimately + auto/blast <br>\nare often more convenient for arbitrary composition of intermediate <br>\nstepping stones than fiddling on goals with \"intro\" etc.</p>\n<p>Nonetheless, intro/elim/unfold are in no way blacklisted as initial proof <br>\nstep (in contrast to bad things like \"proof auto\" which is really just a <br>\nleftover from a very ancient attempt of mine at structure reasoning in<br>\n1997).</p>\n<blockquote>\n<p>Obviously, it is suboptimal to have long convoluted chains of methods <br>\nthat result in the \"obvious\" goal state, since this will tend to make <br>\nthe reader uneasy about the \"formal nonsense\" that is meant to be <br>\nreassuring them about the quality of the proof being offered.</p>\n</blockquote>\n<p>Maybe this paper <a href=\"http://www4.in.tum.de/~wenzelm/papers/isar-reasoning.pdf\">http://www4.in.tum.de/~wenzelm/papers/isar-reasoning.pdf</a> <br>\nhelps to reduce formal nonsense a bit.  (After the presentation at the <br>\nconference some Coq expert told me that they have essentially always done <br>\nthe same, although with quite different means and ends.)</p>\n<blockquote>\n<p>I still must say, that I can't follow the reasoning behind the way<br>\ndefault/rule is implemented. My confusion is well described by the<br>\nfollowing examples, the first of which is a valid proof</p>\n<p>lemma<br>\n  assumes<br>\n    a1: \"A\" and<br>\n    a2: \"B\"<br>\n  shows<br>\n    \"A &amp; B\"<br>\n  using a1 a2 ..</p>\n<p>lemma<br>\n  assumes<br>\n    a1: \"A\" and<br>\n    a2: \"B\"<br>\n  shows<br>\n    \"A &amp; B\"<br>\n  using a2 a1 ..</p>\n<p>and the second of which is not.</p>\n<p>This can be seriously annoying when trying to chain facts</p>\n<p>assume b1: \"B\"<br>\nhave b2: \"A\"<br>\n  -- proof<br>\nwith b1 show \"A &amp; B\" ..</p>\n</blockquote>\n<p>Here the \"rule\" method (of the '..' step) asks you to present facts in <br>\nproper order, i.e. \"from this and by\".</p>\n<p>In 1998, I did have a version of \"rule\" that was much more liberal, but <br>\nnever worked out so well.  The critical question is how much variance <br>\n(degrees of freedom) is acceptable in Isar proof checking, before either <br>\nthe system or the reader can no longer work things out with reasonable <br>\nefforts.</p>\n<p>If \"rule\" would admit arbitrary permutations of facts, for example, there <br>\nwould be a much larger search space for seamingly trivial steps.  Even <br>\nworse, it would stop working in most \"open\" situations via plain \"proof <br>\n... qed', because the first choice needs to be the right one.  It is <br>\nbetter to leave free rearrangement of facts and goals to automated tools, <br>\nand use something like \"from a b c show D by blast\" instead.</p>\n<p>In contrast, there is no problem to allow the user write the required <br>\nsub-proofs (fix/assume/show) in any order, because explicit text is given, <br>\nand both the system and the user usually manage to fit things together <br>\nquickly.  (Actually, there used to be a performance bottle-neck here until <br>\nrecently; it has been sorted out for Isabelle2009.)</p>\n<p>Makarius</p>",
        "id": 294078048,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829664
    }
]