[
    {
        "content": "<p>From: 游珍 &lt;<a href=\"mailto:yucy0405@163.com\">yucy0405@163.com</a>&gt;<br>\nDear friends,</p>\n<p>I'm an Isabelle newbie trying to verify a statement:</p>\n<p>Min(a[0],a[1],…,a[n])+ Min(b[0],b[1],…,b[m])</p>\n<p>=Min(a[0]+b[0],a[0]+b[1],…a[0]+b[m], a[1]+a[0],…,a[1]+b[m],....a[n]+b[m])</p>\n<p>I have some prombles, the following are my proof;</p>\n<p>theory test1</p>\n<p>importsMain</p>\n<p>begin</p>\n<p>(<em>------------Min_list ----------------</em>)</p>\n<p>fun Min_list :: \"int list \\&lt;Rightarrow&gt; nat \\&lt;Rightarrow&gt; int\"</p>\n<p>where</p>\n<p>\"Min_list a 0 = (a !0)\" |</p>\n<p>\"Min_list a (Suc m) = (if ((a !(Suc m))&lt;(Min_list a m)) then (a !(Suc m)) else (Min_list a m)) \"</p>\n<p>(<em>------------Is any problem with the definition of fun di_sum? ----------------</em>)</p>\n<p>fun di_sum :: \"int list \\&lt;Rightarrow&gt; nat \\&lt;Rightarrow&gt; int list \\&lt;Rightarrow&gt; nat \\&lt;Rightarrow&gt; int list\"</p>\n<p>where</p>\n<p>\"di_sum a 0 b 0 = [(a !0)+(b !0)]\" |</p>\n<p>\"di_sum a 0 b (Suc m) = (di_sum a 0 b m) @ [(a !0)+(b !(Suc m))]\" |</p>\n<p>\"di_sum a (Suc n) b m = (di_sum a n b m) @ (di_sum [a !(Suc n)] 0 b m)\"</p>\n<p>lemma \"(Min_list (a::int list) (n::nat)) + (Min_list (b::int list) (m::nat)) = (Min_list (di_sum a n b m) ((n+(Suc 0))*(m+(Suc 0))-(Suc 0)))\"</p>\n<p>apply (induct n)</p>\n<p>apply (unfold Min_list.simps)</p>\n<p>apply (induct m)</p>\n<p>apply simp</p>\n<p>apply (unfold di_sum.simps)</p>\n<p>apply ?????</p>\n<p>Which method or rule I can choose? How to use these methods and rules?  </p>\n<p>Need help!</p>\n<p>Thanks in advance!</p>\n<p>yucy</p>",
        "id": 294138417,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845117
    },
    {
        "content": "<p>From: bnord &lt;<a href=\"mailto:bnord01@googlemail.com\">bnord01@googlemail.com</a>&gt;<br>\nHi yucy,</p>\n<p>I think first of all you need to restrain your lemma to the case where n <br>\n&lt; length a and m &lt; length b. Then maybe your definitions are a bit <br>\ncomplex. Maybe show some lemmas characterizing your functions first. I <br>\nwould define Min_list and di_list using fold and map as there are many <br>\nlemmas helping you to deal with them. Something like:</p>\n<p>definition minList :: \"int list \\&lt;Rightarrow&gt; int\" where<br>\n\"minList a = foldl min (a!0) a\"</p>\n<p>definition flatten :: \"'a list list \\&lt;Rightarrow&gt; 'a list\" where<br>\n\"flatten x = foldl (op @) [] x\"</p>\n<p>definition sumList :: \"int list \\&lt;Rightarrow&gt; int list \\&lt;Rightarrow&gt; int <br>\nlist\" where<br>\n\"sumList a b = flatten (map (%x. map (%y. x + y) b) a)\"</p>\n<p>But beware the case of the empty list! You would first want to prove <br>\nsome lemma about what elements are contained in sumList and maybe some <br>\ncharacterizing minList in terms of it picks the minimal element. Then <br>\nyour lemma should follow easily.</p>\n<p>Sorry I can't recommend any specific methods or rules you could use in <br>\nyour proof it looks kind of messy at that step, of course you can fight <br>\nyour way trough it but I wouldn't want to do that.</p>\n<p>Regards<br>\nBenedikt</p>",
        "id": 294138427,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845120
    }
]