[
    {
        "content": "<p>From: 游珍 &lt;<a href=\"mailto:yucy0405@163.com\">yucy0405@163.com</a>&gt;<br>\nHi,<br>\n   There is \"Min_Un theorm\"  in isabelle. The concrete description is given as follow:<br>\n   Finite_Set.linorder_class.Min_Un: \\&lt;lbrakk&gt;finite ?A; ?A \\&lt;noteq&gt; {}; finite ?B; ?B \\&lt;noteq&gt; {}\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; Min (?A \\&lt;union&gt; ?B) = min (Min ?A) (Min ?B)</p>\n<p>When I proof a lemma, i think i need use \"Min_Un theorem\", but i don't succes ,though i try it for many times. the following are my  theory: </p>\n<p>theory minsum<br>\nimports Main <br>\nbegin</p>\n<p>fun sum :: \"nat \\&lt;Rightarrow&gt; nat  \\&lt;Rightarrow&gt; nat list \\&lt;Rightarrow&gt; nat\"<br>\nwhere<br>\n\"sum i j xs = (if j\\&lt;ge&gt;size xs then 0 else (if i&gt;j then 0 else (\\&lt;Sum&gt;k\\&lt;in&gt;{i..&lt;Suc j}. (xs !k))))\"</p>\n<p>(<em>------------(sum k j xs)  i\\&lt;le&gt;k\\&lt;le&gt;j----------------</em>)<br>\nfunction list_sum :: \"nat \\&lt;Rightarrow&gt; nat \\&lt;Rightarrow&gt; nat list \\&lt;Rightarrow&gt; nat list\"<br>\nwhere<br>\n  \"list_sum i j xs =(if j\\&lt;ge&gt;size xs then [] else ( if i&gt;j then [] else (sum i j xs)#(list_sum (Suc i) j xs) ))\"<br>\n  by pat_completeness auto<br>\n  termination<br>\n  by (relation \"measure (\\&lt;lambda&gt;(i,j,_). j + 1 - i)\") auto </p>\n<p>(<em>-------------- min of list_sum-----------------</em>)<br>\nfun ms :: \"nat \\&lt;Rightarrow&gt; nat list \\&lt;Rightarrow&gt; nat\"<br>\nwhere <br>\n  \"ms j xs = Min (set (list_sum 0 j xs))\"</p>\n<p>(<em>--------------(sum i j xs) 0\\&lt;le&gt;i\\&lt;le&gt;j\\&lt;le&gt;n-------------</em>)<br>\nfunction set_sum ::  \"nat \\&lt;Rightarrow&gt; nat list \\&lt;Rightarrow&gt; nat set\"<br>\nwhere<br>\n   \"set_sum n xs = ( case n of 0  \\&lt;Rightarrow&gt; {} | Suc(m)  \\&lt;Rightarrow&gt; (set_sum m xs)\\&lt;union&gt;(set (list_sum 0 (Suc m) xs) ) )\"<br>\n  by pat_completeness auto<br>\n  termination<br>\n  by (relation \"measure (\\&lt;lambda&gt;(n,_). n )\") auto<br>\n(<em>--------------min of set_sum-------------------</em>)</p>\n<p>fun minsum :: \"nat \\&lt;Rightarrow&gt; nat list \\&lt;Rightarrow&gt; nat\"<br>\nwhere <br>\n  \"minsum n xs = Min (set_sum n xs)\"</p>\n<p>lemma  finite_list_sum [simp] :  \"finite (set (list_sum i j xs))\"<br>\n   apply (induct i)<br>\n   apply simp<br>\n   apply simp<br>\n   done<br>\nlemma  finite_set_sum [simp] :  \"finite (set_sum n xs)\"<br>\n   apply (induct n)<br>\n   apply simp<br>\n   apply simp<br>\n   done<br>\nlemma list_sum_not_null [simp]: \"i&gt;0\\&lt;and&gt;(size xs)&gt;i \\&lt;Longrightarrow&gt;  (set (list_sum 0 i xs)) \\&lt;noteq&gt; {}\"<br>\n   apply auto<br>\n   done<br>\nlemma set_sum_not_null [simp]: \"i&gt;0\\&lt;and&gt;(size xs)&gt;i \\&lt;Longrightarrow&gt;  (set_sum i xs) \\&lt;noteq&gt; {}\"<br>\n   apply (induct i)<br>\n   apply auto<br>\n   done</p>\n<p>lemma recur1 : \"i&gt;0\\&lt;and&gt;(size xs)&gt;i \\&lt;Longrightarrow&gt; (min (minsum i xs) (ms (Suc i) xs)) = (minsum (Suc i) xs)\"<br>\n  apply (unfold minsum.simps )<br>\n  apply (unfold ms.simps)<br>\n  apply ( ???????? Min_Un)</p>\n<p>After I excute the command \"apply (unfold ms.simps)\", I got a goal as follows:<br>\ngoal  (1 subgoal):</p>\n<ol>\n<li>\n<p>0 &lt; i \\&lt;and&gt; i &lt; length xs \\&lt;Longrightarrow&gt; <br>\n    min (Min (set_sum i xs)) (Min (set (list_sum 0 (Suc i) xs))) = Min (set_sum (Suc i) xs)</p>\n<p>In order to get the result:<br>\n  \"0 &lt; i \\&lt;and&gt; i &lt; length xs \\&lt;Longrightarrow&gt; <br>\n  Min  (set_sum i xs)\\&lt;union&gt; (set (list_sum 0 (Suc i) xs))= Min (set_sum (Suc i) xs)\"<br>\n  I try to use a theorem \"Min_Un\" providede for isabelle. Before using \"Min_Un\",I proof four lemmas, which are \"finite_list_sum\", \"finite_set_sum\", \"list_sum_not_null\" and \"set_sum_not_null\". </p>\n<p>However, i still don not success by using \"apply (rule  Min_Un)\",\"apply (simp add:Min_Un)\" or \"apply (subst Min_Un)\", I don't know how to use it. Maybe the theorem \"Min_Un\" is not suitable to apply in my proof, Need help !</p>\n<p>Thanks for your attention!<br>\n                                        yucy<br>\n<a href=\"/user_uploads/14278/ckzgvhpPTPRlQjjjnFvxNTAi/prombleletter2.thy\">prombleletter2.thy</a></p>\n</li>\n</ol>",
        "id": 294067816,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826064
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nwrote:</p>\n<blockquote>\n<p>Hi,<br>\n   There is \"Min_Un theorm\"  in isabelle. The concrete description is given as follow:<br>\n   Finite_Set.linorder_class.Min_Un: \\&lt;lbrakk&gt;finite ?A; ?A \\&lt;noteq&gt; {}; finite ?B; ?B \\&lt;noteq&gt; {}\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; Min (?A \\&lt;union&gt; ?B) = min (Min ?A) (Min ?B)</p>\n<p>When I proof a lemma, i think i need use \"Min_Un theorem\", but i don't succes ,though i try it for many times. the following are my  theory: </p>\n<p>The first problem in your theory is, that your function declarations <br>\nintroduce simplification loops.<br>\nYou should explicitely erase the looping rules from the simpset, and <br>\nreplace them by safer ones.<br>\n(See the isabelle tutorial on function definition for details).</p>\n</blockquote>\n<blockquote>\n<p>(<em>--------------(sum i j xs) 0\\&lt;le&gt;i\\&lt;le&gt;j\\&lt;le&gt;n-------------</em>)<br>\nfunction set_sum ::  \"nat \\&lt;Rightarrow&gt; nat list \\&lt;Rightarrow&gt; nat set\"<br>\nwhere<br>\n   \"set_sum n xs = ( case n of 0  \\&lt;Rightarrow&gt; {} | Suc(m)  \\&lt;Rightarrow&gt; (set_sum m xs)\\&lt;union&gt;(set (list_sum 0 (Suc m) xs) ) )\"<br>\n  by pat_completeness auto<br>\n  termination<br>\n  by (relation \"measure (\\&lt;lambda&gt;(n,_). n )\") auto<br>\n(<em>--------------min of set_sum-------------------</em>)</p>\n<p>Try this (equivalent) definition instead, it makes the case-distinction <br>\nexplicit using pattern matching. And thus introduces safe simplification <br>\nrules.</p>\n</blockquote>\n<p>(<em>--------------(sum i j xs) 0\\&lt;le&gt;i\\&lt;le&gt;j\\&lt;le&gt;n-------------</em>)<br>\nfun set_sum :: \"nat \\&lt;Rightarrow&gt; nat list \\&lt;Rightarrow&gt; nat set\"<br>\nwhere<br>\n\"set_sum 0 xs = {}\" |<br>\n\"set_sum (Suc m) xs = (set_sum m xs)\\&lt;union&gt;(set (list_sum 0 (Suc m) xs))\"</p>\n<blockquote>\n<p>lemma recur1 : \"i&gt;0\\&lt;and&gt;(size xs)&gt;i \\&lt;Longrightarrow&gt; (min (minsum i xs) (ms (Suc i) xs)) = (minsum (Suc i) xs)\"</p>\n<p>Now you could go with:</p>\n</blockquote>\n<p>apply (unfold minsum.simps )<br>\napply (unfold ms.simps)<br>\napply (simp del: sum.simps list_sum.simps) -- (Or do a declare <br>\nsum.simps[simp_del] and declare list_sum.simps[simp del] after the def. <br>\nof those functions.)<br>\napply (rule Min_Un[symmetric])<br>\napply simp_all</p>\n<p>However, this leaves one subgoal, resulting from your <br>\nlist_sum_not_null-lemma not to be appropriate for the generated subgoal <br>\n(There's a (Suc i) in the generated subgoal, where your lemma has only <br>\nan (i)).</p>\n<p>Hope this helps,<br>\nPeter</p>",
        "id": 294067837,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660826071
    }
]