[
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:uuomul@yahoo.com\">uuomul@yahoo.com</a>&gt;<br>\nFYI</p>\n<p>Andrei </p>\n<p>Message: 1</p>",
        "id": 294272019,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917520
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nDid I hear my name tangentially called? That is so unnecessary.</p>\n<p>Without a doubt, a function, in which the domain is a set, must <br>\nfoundationally be a set of ordered pairs. Here it is:</p>\n<p>definition funS ::\"('a =&gt; 'b) =&gt; 'a set =&gt; 'b set =&gt; ('a * 'b) set\" where<br>\n   \"funS f D C == {(x,y). (!x. x : D --&gt; f x : C) &amp; x : D &amp; y = f x}\"</p>\n<p>But HOL functions, as rules, are so much easier to work with, so here <br>\nare the rules:</p>\n<p>definition funR :: \"('a =&gt; 'b) =&gt; 'a set =&gt; 'b set =&gt; 'a =&gt; 'b\" where<br>\n   \"funR f D C == (%x. if (!x. x : D --&gt; f x : C) &amp; x : D then f x else <br>\nuDf)\"</p>\n<p>definition funR_img :: \"('a =&gt; 'b) =&gt; 'a set =&gt; 'a =&gt; 'b\" where<br>\n   \"funR_img f D = (%x. if x : D then f x else uDf)\"</p>\n<p>The work comes from the fact that the image of the domain of a funR can <br>\ncontain exactly one more element, uDf, than the range of funS. However, <br>\nwhen the codomain is the image of the domain, the image of funR and the <br>\nrange of funS are equal.</p>\n<p>The solutions in dealing with complexity lie in notation as much as in <br>\nlogic, and notation happens to be one of Isar's strengths.</p>\n<p>Do I hear a refrain? \"Give me nested sets, give me nested sets...\"</p>\n<p>Was it not myself who posted a use of datatype_new for nested sets , <br>\neven before datatype_new was released as part of Isabelle2013-1? Yes. <br>\nThat was me. I remember. Not even vaguely.</p>\n<p>Here is countably infinite nestable sets of reals, built from atoms, <br>\nwhere the UNIV of reals is, of course, uncountable:</p>\n<p>datatype_new rD = rA real | rS \"real cset\"</p>\n<p>Will it work out? That is not important.</p>\n<p>What is a set? It is an abstract thought. The infrastructure for the <br>\nbulk of working with functions as sets, and working with nested sets, is <br>\nalready in Fun.thy, Set.thy, and Finite_Set.thy.</p>\n<p>It is the blurring of traditional thought. The convergence of ideas.</p>\n<p>There is nothing left to do, other than several years of tedious work.</p>\n<p>Please marvel at my innovative use of Isar notation in the attached <br>\nscreen shot. I am a true artiste, as is possible for anyone who uses the <br>\nnotational abilities of Isar.</p>\n<p>Regards,<br>\nGB<br>\n<a href=\"/user_uploads/14278/c-RHiKklSla86Iz0ZQhnv6iE/funS_funR.png\">funS_funR.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/14278/c-RHiKklSla86Iz0ZQhnv6iE/funS_funR.png\" title=\"funS_funR.png\"><img src=\"/user_uploads/14278/c-RHiKklSla86Iz0ZQhnv6iE/funS_funR.png\"></a></div>",
        "id": 294272044,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917528
    }
]