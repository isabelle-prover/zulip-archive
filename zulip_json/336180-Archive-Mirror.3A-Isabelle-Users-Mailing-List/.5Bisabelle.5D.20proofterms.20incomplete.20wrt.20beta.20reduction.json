[
    {
        "content": "<p>From: Stefan Berghofer &lt;<a href=\"mailto:berghofe@in.tum.de\">berghofe@in.tum.de</a>&gt;<br>\nSean McLaughlin wrote:</p>\n<blockquote>\n<p>It is thus difficult, when translating these proof terms,<br>\n to know with precision when to apply beta reduction and when not to.<br>\nI realize there is no beta axiom, as in HOL Light.  Is there a  general way<br>\nto tell when beta reduction should be applied?  Currently I apply it</p>\n</blockquote>\n<p>One of the reasons why beta-conversion is not recorded in the proof object is<br>\nthat Isabelle's central inference rule - higher-order resolution - works modulo<br>\nbeta-conversion, too.<br>\nInterestingly, the Coq theorem prover goes even further and not only leaves<br>\nbeta-conversion, but also iota-conversion (i.e. unfolding of recursive<br>\ndefinitions) implicit in proof terms. The ability to elide such<br>\ncomputations in proof terms turns out to be essential for applications<br>\nsuch as proof-carrying code, where the size of the transmitted proofs<br>\nneeds to be kept as small as possible. One of my colleagues, who built<br>\na proof-carrying code system based on Isabelle, noticed that even proof<br>\nterms for relatively simple safety properties of programs can reach an<br>\nenormous size just because of the numerous calls to Isabelle's simplifier<br>\nthat are recorded in the proof term.</p>\n<blockquote>\n<p>wildly everywhere I can and it seems to work most of the time, but  I'd <br>\nlike to be precise about it.</p>\n</blockquote>\n<p>This is exactly what the proof replaying function in Pure/Proof/proofchecker.ML<br>\ndoes as well. It uses only very primitive inference rules such as Thm.implies_elim,<br>\nwhich are <em>not</em> modulo beta-conversion (unlike higher-order resolution). Note<br>\nthat eta-conversion needs to be done as well.</p>\n<p>Greetings,<br>\nStefan</p>",
        "id": 293899554,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660743933
    }
]