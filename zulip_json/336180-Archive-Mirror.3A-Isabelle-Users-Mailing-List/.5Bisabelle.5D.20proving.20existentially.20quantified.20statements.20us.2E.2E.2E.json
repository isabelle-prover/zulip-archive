[
    {
        "content": "<p>From: Julian Brunner &lt;<a href=\"mailto:julianbrunner@gmail.com\">julianbrunner@gmail.com</a>&gt;<br>\nHello,</p>\n<p>While using Isabelle, I keep running into the problem of not being able to<br>\nprove existentially quantified statements using a witness with the show<br>\nstatement telling me that the \"Local statement will fail to refine any<br>\npending goal\".</p>\n<p>For instance:</p>\n<p>theorem \"EX x. x = (0 :: nat)\"<br>\nproof<br>\n  obtain x where x_def: \"x = (0 :: nat)\" by simp<br>\n  show \"x = 0\" using x_def by simp<br>\nqed</p>\n<p>This example results in \"Local statement will fail to refine any pending<br>\ngoal\" in line 4 of the proof. Furthermore, replacing line 3 with</p>\n<p>def x == \"0 :: nat\"</p>\n<p>makes everything work just fine. This is a minimal example built from a<br>\nbigger proof where the witness used for proving the existential statement<br>\nwas an expression containing variables that originated in an obtain<br>\nstatement. From what I've observed so far, it appears that whenever<br>\nvariables from an obtain statement are part of the witness, the show<br>\nstatement fails. I've used [[show_types]] to confirm that the types aren't<br>\npart of the issue, both x and 0 are of type nat. Also, the output doesn't<br>\ngive me the usual \"Failed attempt to solve goal by exported rule\" line<br>\nstating why the show statement failed, as is the case with assume<br>\nstatements that don't match any assumption in the goal.</p>\n<p>Of course I can work around this by invoking proof with the '-' method and<br>\nusing automation to prove the existentially quantified statement using the<br>\nwitness, but it'd be nicer if it'd work like this, I feel like this is just<br>\na minor technical issue, but I couldn't figure out what's going on.</p>\n<p>I think I've also run into a similar problem that didn't involve obtain<br>\nstatements but I can't find the theory where that happened right now, maybe<br>\nI'll post again if I run into that issue once more. For now, I'd be happy<br>\nwith figuring this one out.</p>\n<p>Cheers,<br>\n Julian</p>",
        "id": 294227627,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900787
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 12.11.2012 20:21, Julian Brunner wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>While using Isabelle, I keep running into the problem of not being able to<br>\nprove existentially quantified statements using a witness with the show<br>\nstatement telling me that the \"Local statement will fail to refine any<br>\npending goal\".</p>\n</blockquote>\n<p>This error message is not very helpful (and I seem to remember there <br>\nonce was a more useful one, mentioning obtained variables?). There is a <br>\nmore useful error message when the last theorem of a {-}-block contains <br>\nan obtained variable</p>\n<p>{ obtain x where \"x = Suc 0\" by auto<br>\n     then have \"x &gt; 0\" by auto }</p>\n<p>results in:</p>\n<p>Result contains obtained parameters: x</p>\n<p>This is due to the same reason. When you use \"fix\" or \"def\" to define a <br>\nvariable, they either get just generalized (i.e. turned into schematics) <br>\n(fix) or replaced by their right hand side (definitions)<br>\nwhen a block is closed / a show is performed.</p>\n<p>This cannot be done for obtained variables.</p>\n<blockquote>\n<p>Of course I can work around this by invoking proof with the '-' method and<br>\nusing automation to prove the existentially quantified statement using the<br>\nwitness, but it'd be nicer if it'd work like this, I feel like this is just<br>\na minor technical issue, but I couldn't figure out what's going on.</p>\n</blockquote>\n<p>A good scheme for proving such things is</p>\n<p>lemma \"EX x. P x\"<br>\nproof -<br>\n   obtain x where &lt;...&gt;<br>\n   &lt;...&gt;<br>\n   have \"P x\" &lt;...&gt;<br>\n   show ?thesis ..<br>\nqed</p>\n<p>where .. is a shorthand for \"by rule\".</p>\n<p>-- Lars</p>",
        "id": 294227643,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900799
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nThe reason for this failure is consistency: when proving P(?x), you delay the<br>\npoint at which you give the actual witness t for ?x. But that is just an<br>\noperational rearrangement of the proof. Logically it must be possible to<br>\nconstruct that t right away. Hence t must not depend on anything that only came<br>\ninto existence while proving P(?x). Otherwise you could prove EX x. ALL y. x=y:</p>\n<p>apply(rule exI)</p>\n<ol>\n<li>ALL y. ?x = y</li>\n</ol>\n<p>apply(rule allI)</p>\n<ol>\n<li>!!y. ?x = y</li>\n</ol>\n<p>apply(rule refl)</p>\n<p>fails because you would need to instantiate ?x with the local y, which Isabelle<br>\nprevents. (Contrast this with a proof of ALL x. EX y. x=y)</p>\n<p>Your failed proof attempt was morally correct, but you need to convince the<br>\nsystem that the witness could have been constructed up front, usually by<br>\nrearranging your proof text, eg as Lars suggested.</p>\n<p>Best<br>\nTobias</p>",
        "id": 294227684,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900805
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Julian,</p>\n<p>a further comment:</p>\n<blockquote>\n<p>theorem \"EX x. x = (0 :: nat)\"<br>\nproof</p>\n</blockquote>\n<p>the statement to prove here contains a schematic variable ?x or such.<br>\nThis is something better to be avoided except for good reason.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/L2lQYwMEAEdhw__KvBfO6bca/signature.asc\">signature.asc</a></p>",
        "id": 294227809,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660900873
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Tue, 13 Nov 2012, Lars Noschinski wrote:</p>\n<blockquote>\n<p>On 12.11.2012 20:21, Julian Brunner wrote:</p>\n<blockquote>\n<p>While using Isabelle, I keep running into the problem of not being able <br>\nto prove existentially quantified statements using a witness with the <br>\nshow statement telling me that the \"Local statement will fail to refine <br>\nany pending goal\".</p>\n</blockquote>\n<p>This error message is not very helpful (and I seem to remember there <br>\nonce was a more useful one, mentioning obtained variables?).</p>\n</blockquote>\n<p>It seems that I've destroyed that error messahe by accident in Jan-2009, <br>\nbut it is likely to work again in the coming release.</p>\n<blockquote>\n<p>For instance:</p>\n<p>theorem \"EX x. x = (0 :: nat)\"<br>\nproof<br>\n obtain x where x_def: \"x = (0 :: nat)\" by simp<br>\n show \"x = 0\" using x_def by simp<br>\nqed</p>\n</blockquote>\n<p>BTW, a more compact way to write that wrong proof is this:</p>\n<p>theorem \"EX x. x = (0 :: nat)\"<br>\nproof<br>\n   obtain x where \"x = (0 :: nat)\" by simp<br>\n   then show ?this .<br>\nqed</p>\n<p>But that does not work for logical reasons, as has been pointed out <br>\nbefore.  You cannot apply an obtained result with parameters to the <br>\nenclosing goal.  This is also the deeper reason why there is 'have' for <br>\nlocal results, and 'show' for local results that get exported into the <br>\nenclosing goal context, but only 'obtain' and not 'obtain_show'.</p>\n<p>(And you don't need to obtain local definitions in the first place, has <br>\nhas been said already.)</p>\n<p>Makarius</p>",
        "id": 294228458,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901179
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nJust for fun some further vacuous 'obtain' proofs:</p>\n<p>notepad<br>\nbegin<br>\n   obtain x where \"x = (0 :: nat)\" by (rule that) (rule refl)<br>\nnext<br>\n   obtain x where \"x == (0 :: nat)\" by (rule that) (rule reflexive)<br>\nnext<br>\n   obtain x where \"x == (0 :: nat)\" ..<br>\nend</p>\n<p>The last form works, because \"that\" is declared as Pure.intro, and Pure <br>\n\"reflexive\" implicit (like assumption).</p>\n<p>The better form is this:</p>\n<p>def x == \"0 :: nat\"</p>\n<p>Here the system does the reflexicity step for you, and it bypasses the <br>\nfull \"may-assume-that-holds\" mechanism of 'obtain', that involves the <br>\nrestriction on variable occurrences (as seen in the exE rule).</p>\n<p>Makarius</p>",
        "id": 294228464,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660901185
    }
]