[
    {
        "content": "<p>From: Ewaryst Schulz &lt;<a href=\"mailto:ewaryst.schulz@dfki.de\">ewaryst.schulz@dfki.de</a>&gt;<br>\nHi,<br>\nI have a question regarding let environments in formulas. I'd like to <br>\npush them to the top of the formula and ideally declare them by <br>\ndef-statements in the isar-proof.<br>\nConsider e.g. a context with variables x1, ..., xn:<br>\nMy goal is of the form Psi(s1(X), ... , sm(X)), where X = x1, ..., xn, and<br>\ns1(X) of the form</p>\n<p>let y1 = t1(X);<br>\n     y2 = t2(X,y1);<br>\n     ...<br>\n     yk = tk(X,Y)<br>\nin Phi(X,Y,yk)</p>\n<p>Now I'd like to move the let-environment to the outside (theoretically <br>\nthis is possible, if no variable capturing occurs, by some beta/eta <br>\nreduction and expansion):</p>\n<p>Psi(s1(X), ... , sm(X))<br>\n---&gt;<br>\nlet y1 = t1(X);<br>\n     y2 = t2(X,y1);<br>\n     ...<br>\n     yk = tk(X,Y)<br>\nin Psi(Phi(X,Y,yk), s2(X), ... , sm(X))</p>\n<p>And then put the let-env to the isar context by def:</p>\n<p>---&gt;<br>\ndef y1 == t1(X)<br>\ndef y2 == t2(X,y1)<br>\n...<br>\ndef yk == tk(X,Y)</p>\n<p>goal:<br>\nPsi(Phi(X,Y,yk), s2(X), ... , sm(X))</p>\n<p>I'm not a really advanced user so I'd prefer to use an existing <br>\nprocedure to do that automatically. Is there a tactic which does exactly <br>\nthis job?<br>\nOf course then I won't have the defs visible in my isar proof, and I'd <br>\nneed a labeling convention for this knowledge (to access the equalities <br>\nyi == t1(...)).<br>\nThe method should also fail if the Y,yk and X intersect in the variable <br>\nnames (variable capturing).<br>\nI don't think there is already something which does that exactly, but <br>\nperhaps there is a better way to deal with let environments deep inside <br>\nformulas<br>\n(I don't want to expand/unfold the let environment!) ?</p>\n<p>Thanks for your help in advance,</p>\n<p>cheers,<br>\nEwaryst</p>",
        "id": 294076904,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829250
    },
    {
        "content": "<p>From: Konrad Slind &lt;<a href=\"mailto:slind@cs.utah.edu\">slind@cs.utah.edu</a>&gt;<br>\nHi,</p>\n<p>Michael Norrish and I tackled exactly this sort of thing in</p>\n<p><a href=\"http://www.cs.utah.edu/~slind/papers/tphols05.pearl.pdf\">http://www.cs.utah.edu/~slind/papers/tphols05.pearl.pdf</a></p>\n<p>The ideas in the paper are worked out in HOL4, and may<br>\nneed to be modified a bit for Isabelle/HOL.</p>\n<p>Cheers,<br>\nKonrad.</p>",
        "id": 294076945,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829269
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nI just tried out the rules from the paper in Isabelle/HOL. Indeed, the<br>\nunmodified rules don't work quite the same in Isabelle. Here's what I tried:</p>\n<p>definition flip_def [simp]: \"flip f x y = f y x\"<br>\ndefinition compose_def [simp]: \"compose f g x = f (g x)\"</p>\n<p>lemma Let_simps:<br>\n  \"!!f m g. f (Let m g) = Let m (compose f g)\"<br>\n  \"!!m f n. (Let m f) n = Let m (flip f n)\"<br>\n  \"!!f g. compose f (%x. g x) = (%x. f (g x))\"<br>\n  \"!!f y. flip (%x. f x) y = (%x. f x y)\"<br>\n  \"!!f g. compose f (split g) = split (compose (compose f) g)\"<br>\n  \"!!f x. flip (split f) x = split (flip (compose flip f) x)\"<br>\nunfolding Let_def expand_fun_eq by simp_all</p>\n<p>Next I applied these as rewrites to the example term from the paper:</p>\n<p>lemma \"perm (h # t)<br>\n  (let (l1, l2) = part (%y. ord y h) t in qsort ord l1 @ [h] @ qsort ord<br>\nl2)\"<br>\napply (simp only: Let_simps)</p>\n<p>Here's the resulting term I hoped to get:</p>\n<p>let (l1, l2) = part (%y. ord y h) t<br>\n    in perm (h # t) (qsort ord l1 @ [h] @ qsort ord l2)\"</p>\n<p>But here's what I got:</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>let x = part (%y. ord y h) t<br>\n    in perm (h # t) ((%(l1, l2). qsort ord l1 @ [h] @ qsort ord l2) x)</li>\n</ol>\n<p>It sort of worked. At least the let binding was lifted to the outside of the<br>\nterm. But the tuple binding was replaced with a single variable binding.<br>\nAlso, the simplifier invented a new bound variable name, while the rules in<br>\nthe paper are specifically designed to preserve bound variable names.</p>\n<p>It appears that the Isabelle's simplifier behaves differently than HOL4. In<br>\nHOL4, the LHS patterns of the following two rules are non-overlapping:</p>\n<p>\"compose f (%x. g x) = (%x. f (g x))\"<br>\n  \"compose f (split g) = split (compose (compose f) g)\"</p>\n<p>In Isabelle, I think the simplifier treats the first rule as equivalent to<br>\nthe eta-contracted form:<br>\n  \"compose f g = (%x. f (g x))\"<br>\nSo it matches more often than the same rule in HOL4.</p>\n<p>As a workaround, you could call the simplifier twice, using the<br>\nsplit-specific rules first, and the more general rules afterward:</p>\n<p>lemma \"perm (h # t)<br>\n  (let (l1, l2) = part (%y. ord y h) t in qsort ord l1 @ [h] @ qsort ord<br>\nl2)\"<br>\napply (simp only: Let_simps(1,2,5,6), simp only: Let_simps(3,4))</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>let (xa, x) = part (%y. ord y h) t<br>\n    in perm (h # t) (qsort ord xa @ [h] @ qsort ord x)</li>\n</ol>\n<p>This at least gets the tuple binding in the right place, but the variable<br>\nnames are still wrong. It just seems that the preservation of bound variable<br>\nnames is a feature of the HOL4 simplifier that was never implemented in<br>\nIsabelle. Instead, Isabelle's simplifier replaces the old bound variable<br>\nname for whatever name was used on the RHS of the original rewrite rule. For<br>\nexample:</p>\n<p>lemma foo: \"!!f g. compose f (%a. (g a, h a)) = (%a. f (g a, h a))\"<br>\nunfolding expand_fun_eq by simp</p>\n<p>lemma \"P (compose f (%y. (y, y)))\"<br>\napply (simp only: foo)</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>P (%a. f (a, a))</li>\n</ol>\n<p>Anyway, I guess my conclusion is that to lift let-bindings in Isabelle, we<br>\nwill need more than just a set of rewrite rules. A special proof tactic that<br>\npreserves variable names probably wouldn't be too hard to implement though.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294076950,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829272
    }
]