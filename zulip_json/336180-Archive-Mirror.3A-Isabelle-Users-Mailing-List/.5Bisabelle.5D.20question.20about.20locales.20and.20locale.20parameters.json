[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello,</p>\n<p>I have the following locale definition:</p>\n<p>locale test =<br>\n   fixes none :: \"'index\"<br>\n   begin;</p>\n<p>primrec<br>\n     label:: \"('a =&gt; 'index) =&gt; ('a list) =&gt; ('a =&gt; 'index)\" where<br>\n     \"label lbl []       = lbl\" |<br>\n     \"label lbl (y # S)  = label (lbl(y := none)) S\";</p>\n<p>lemma first: \"f x = none ==&gt; f = label (f(x := i)) [x]\";<br>\n     by auto;</p>\n<p>lemma second: \"none = f x ==&gt; f = label (f(x := i)) [x]\";<br>\n     apply auto;</p>\n<p>The first lemma is proved by auto as one would expect, however the second<br>\nlemma is transformed into</p>\n<p>f = test.label (f x) (f(x := i)) [x]</p>\n<p>where  test.label :: 'index =&gt; ('a =&gt; 'index) =&gt; 'a list =&gt; 'a =&gt; 'index</p>\n<p>At first I had big problems understanding why label would have the<br>\nfirst parameter of type 'index, then I figured out that this extra <br>\nparameter<br>\nis the parameter none fixed by the locale. This fact can also be deduced<br>\nfrom how second lemma was transformed by auto.</p>\n<ol>\n<li>\n<p>Within a locale I would expect  the fixed parameters to behave as<br>\nconstants.</p>\n</li>\n<li>\n<p>Even if they are treated as variable in second lemma I would expect<br>\nthat the definition label can still be applied to test.label (f x) (f(x <br>\n:= i)) [x]<br>\nwith (f x) instead on none. If that would be the case, then second lemma<br>\nshould be discharged automatically.</p>\n</li>\n<li>\n<p>Trying to apply the definition of label manually (unfold ...) (rule ...)<br>\nor (simp add: ...) does not change the goal</p>\n</li>\n<li>\n<p>How do I prove  f = test.label (f x) (f(x := i)) [x] ? I can prove<br>\nsecond lemma using   by (case_tac \"f x = none\", auto) but the statement<br>\n\" f = test.label (f x) (f(x := i)) [x]\" occurs in a much more involved<br>\nresult, and I cannot control how the simplifications are done before<br>\ngetting this \"unprovable\" goal.</p>\n</li>\n</ol>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294105615,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835104
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Viorel,</p>\n<p>the matter is: internally, \"label\" (in test) is represented as<br>\n\"test.label none\".  Therefore the assumption \"none = f x\" rewrites this<br>\nto \"test.label (f x)\" (c.f. also<br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/local-theory.pdf\">http://www4.in.tum.de/~wenzelm/papers/local-theory.pdf</a>).  You could call<br>\nthis a misbehaviour of the simplifier.</p>\n<p>Once \"test.label none\" has been unfolded to \"test.label (f x)\", the<br>\nlocal theorems (in test) are not applicable any more.  The global<br>\nfoundational theorems test.label.simps etc. could be used;  however I do<br>\nrecommend to avoid that unfolding from the very beginning.</p>\n<p>Hope this helps,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/mXeL280H4Z-qXDqLhvUfHa3S/signature.asc\">signature.asc</a></p>",
        "id": 294105679,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835130
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Wed, Apr 14, 2010 at 5:37 AM, Florian Haftmann<br>\n&lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Viorel,</p>\n<blockquote>\n<p>locale test =<br>\n  fixes none :: \"'index\"<br>\n  begin;</p>\n<p>primrec<br>\n    label:: \"('a =&gt; 'index) =&gt; ('a list) =&gt; ('a =&gt; 'index)\" where<br>\n...<br>\n  lemma second: \"none = f x ==&gt; f = label (f(x := i)) [x]\";<br>\n    apply auto;</p>\n</blockquote>\n<p>the matter is: internally, \"label\" (in test) is represented as<br>\n\"test.label none\".  Therefore the assumption \"none = f x\" rewrites this<br>\nto \"test.label (f x)\" (c.f. also<br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/local-theory.pdf\">http://www4.in.tum.de/~wenzelm/papers/local-theory.pdf</a>).  You could call<br>\nthis a misbehaviour of the simplifier.</p>\n</blockquote>\n<p>It seems that inside the locale, \"label == test.label none\" is<br>\nregistered as a local <em>abbreviation</em>. As such, its argument (\"none\")<br>\nis still visible to the simplifier.</p>\n<p>Is there any reason why \"label == test.label none\" could not be<br>\nimplemented instead as a local <em>definition</em>? I'm thinking of how the<br>\n\"def\" command works within a proof script: This adds a definition that<br>\nis unfolded when the lemma is exported, but within the proof, the<br>\nsimplifier just sees an opaque constant.</p>\n<p>If locally-defined constants were treated this way in locales, I think<br>\nthe behavior would cause many fewer surprises for users.</p>\n<p>This same issue has been brought up on this list before, nearly two years ago:</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2008-June/msg00089.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2008-June/msg00089.html</a></p>\n<p>At the time, I recommended using a congruence rule as a quick<br>\nworkaround to prevent the simplifier from tampering with hidden<br>\nparameters of locally-defined constants. But I think a \"def\"-like<br>\nmechanism is a better solution.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294105711,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835142
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nBrian Huffman wrote:<br>\nThis unfortunately does not work in general, since \"def\" in proofs <br>\ncannot support polymorphism.</p>\n<p>Alex</p>",
        "id": 294105734,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835149
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHello Viorel,</p>\n<p>the definition of label in your locale test produces only one global <br>\nconstant called test.label that takes all locale parameters on which the <br>\ndefinition depends (in your case \"none\") as extra parameters.</p>\n<p>When you are inside the context of the locale, you merely see <br>\nabbreviations of the global constants with the parameters instantiated <br>\nto the fixed locale parameters, i.e. there is no local version of the <br>\nlabel constant.</p>\n<blockquote>\n<p>lemma second: \"none = f x ==&gt; f = label (f(x := i)) [x]\";<br>\n    apply auto;</p>\n<p>[...]</p>\n<p>f = test.label (f x) (f(x := i)) [x]<br>\nHere, the simplifier rewrites \"none\" to \"f x\", so the local abbreviation <br>\n\"label == test.label none\" no longer applies.<br>\nThis is why you see the global constant. Unfortunately, auto also <br>\nremoves the equation \"none = f x\" from the assumptions because it thinks <br>\nthat it would not be needed any more.</p>\n</blockquote>\n<blockquote>\n<ol start=\"2\">\n<li>Even if they are treated as variable in second lemma I would expect<br>\nthat the definition label can still be applied to test.label (f x) (f(x <br>\n:= i)) [x]<br>\nwith (f x) instead on none. If that would be the case, then second lemma<br>\nshould be discharged automatically.<br>\nJust like with the constants, there are local and global versions of the <br>\ntheorem. For label, label.simps refers to the local version where none <br>\nis fixed as parameter. Since your goal involves the global version of <br>\nlabel after auto has been applied, you must also use the global version <br>\ntest.label.simps for reasoning.</li>\n</ol>\n</blockquote>\n<p>Fortunately, your locale does not assume anything. Hence, the global <br>\nversion of the defining theorem are not guarded by any locale predicate <br>\nand you can use them freely for reasoning.</p>\n<blockquote>\n<ol start=\"4\">\n<li>How do I prove  f = test.label (f x) (f(x := i)) [x] ? I can prove<br>\nsecond lemma using   by (case_tac \"f x = none\", auto) but the statement<br>\n\" f = test.label (f x) (f(x := i)) [x]\" occurs in a much more involved<br>\nresult, and I cannot control how the simplifications are done before<br>\ngetting this \"unprovable\" goal.<br>\nInstead of using auto, you could first tell the simplifier not to use <br>\nthe assumptions, which leaves the local version intact.</li>\n</ol>\n</blockquote>\n<p>apply(simp (no_asm_use))</p>\n<p>In a second step, use again the simplifier to solve the remaining goal.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294105776,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835159
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello,</p>\n<p>Thank you all for answering my question. It seems that this is a <br>\ndelicate issue.<br>\nApplying a rule (auto) in local context which takes you out from the <br>\nlocal context,<br>\nalthough well motivated by the implementation, seem strange to the new user<br>\nwhich may not be aware of the internals. On the other hand if auto changes<br>\nthe goal into a global goal, why the global simplification rules are not<br>\nused here. If auto would use these simplification rules (test.label.simps),<br>\nthen this goal will be solved automatically. Moreover, I suppose<br>\n(test.label.simps) are always applicable when (label.simps) are<br>\napplicable, and using (test.label.simps) in auto would always<br>\nyield better results. If the final result contains \"test.label none\"<br>\nthen the abbreviation would replace it back by label.</p>\n<p>Another way I would imagine is that you would not allow results<br>\nwhich take you out of the local theory. Whenever you get out<br>\nof the locale you stop the proof and search for alternatives.<br>\nAfter all that is what you want with a locale.</p>\n<p>I have figured out that avoiding unfolding \"test.label none\" to <br>\n\"test.label (f x)\", would let me<br>\nprogress with the prof. However, as I already mentioned, this is not a good<br>\noption in my case because this problem occurs in a context where the <br>\ngoal has many<br>\ncomponents, and auto solves all except the one from this example. It <br>\nwould be much<br>\neasier for me to use the global rule instead of splitting the goal <br>\nlittle by little and make<br>\nsure the unfolding \"test.label none\" to \"test.label (f x)\" does not occur.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294105861,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835172
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nThe workaround using congruence rules that I mentioned before will do<br>\njust that: It will prevent simp or auto from rewriting \"test.label<br>\nnone\" to \"test.label (f x)\".</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2008-June/msg00089.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2008-June/msg00089.html</a></p>\n<p>Here's the rule you would want to use in your case (note that there is<br>\nno assumption corresponding to subterm \"n\"):</p>\n<p>lemma label_cong [cong]: \"f = g ==&gt; xs = ys ==&gt; test.label n f xs =<br>\ntest.label n g ys\"<br>\nby simp</p>\n<p>By placing this lemma (with its [cong] attribute) before your other<br>\nproofs, \"test.label none\" should never have its argument rewritten by<br>\nthe simplifier.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294105982,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835218
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Mon, Apr 19, 2010 at 1:40 AM, Viorel Preoteasa<br>\n&lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt; wrote:</p>\n<blockquote>\n<p>Hello Brian,</p>\n<p>The trick seems to work for the test theory, but it does not work<br>\nfor my real theory. Also using the global simplification rule does not<br>\nwork for me either because I have assumptions in the locale. I have<br>\nsucceeded to strip down the example for which the cong approach<br>\ndoes not work. In the third and forth lemmas the definition label<br>\nis expanded to test.label and the proofs fail.<br>\n...<br>\nlemma third:<br>\n \"tl a = [] ==&gt;  f (hd a) = none<br>\n     ==&gt; f = label (f(hd a := i)) a\";<br>\n apply auto;<br>\n sorry;</p>\n<p>lemma forth:<br>\n \"? y ys . a = y # ys ==&gt; f (hd a) = none<br>\n     ==&gt; f = label (f(hd a := i)) a\";<br>\n apply auto;<br>\n sorry;</p>\n</blockquote>\n<p>I see what is going on here. The congruence rule successfully prevents<br>\nthe <em>simplifier</em> from rewriting \"label\" to \"test.label\", but with<br>\nlemmas \"third\" and \"forth\" it is not the simplifier that is causing<br>\nthe problem. Try replacing \"apply auto\" with either \"apply safe\" or<br>\n\"apply clarify\", and you will get the same result.</p>\n<p>This unhelpful behavior of \"safe\" (which is included as part of what<br>\n\"auto\" does) in the context of locales has been noted before on the<br>\nmailing list:</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2007-February/msg00075.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2007-February/msg00075.html</a><br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2007-February/msg00076.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2007-February/msg00076.html</a></p>\n<p>Unfortunately, while it has been acknowledged as a problem, it seems<br>\nthat nothing has been done about it.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294106068,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835246
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nYes, try the following:</p>\n<p>apply (auto) [1]</p>\n<p>In general, \"apply (&lt;tactic&gt;) [n]\" restricts the tactic to act only on<br>\nthe first n subgoals.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294106082,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835251
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere I really need to insist that the Isar category of \"method\" is not <br>\ncalled \"tactic\".  One of the very characteristics of Isar proof methods is <br>\nthe stylized access to the underlying goal structure, without the <br>\ntraditional goal addressing of tactics.</p>\n<p>The method combinator [...] above works quite differently from tactial <br>\ngoal addressing: it singles out a section of the goal state, applies the <br>\nproof method, and retrofits the result.</p>\n<p>Makarius</p>",
        "id": 294106122,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835264
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Brian,</p>\n<p>The trick seems to work for the test theory, but it does not work<br>\nfor my real theory. Also using the global simplification rule does not<br>\nwork for me either because I have assumptions in the locale. I have<br>\nsucceeded to strip down the example for which the cong approach<br>\ndoes not work. In the third and forth lemmas the definition label<br>\nis expanded to test.label and the proofs fail.</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<p>locale test =<br>\n  fixes none :: \"'index\"<br>\nbegin;</p>\n<p>primrec<br>\n  label:: \"('a =&gt; 'index) =&gt; ('a list) =&gt; ('a =&gt; 'index)\" where<br>\n  \"label lbl []       = lbl\" |<br>\n  \"label lbl (y # l)  = label (lbl(y := none)) l\";</p>\n<p>lemma first: \"f x = none ==&gt; f = label (f(x := i)) [x]\";<br>\n  by auto;</p>\n<p>lemma label_cong [cong]: \"f = g ==&gt; xs = ys ==&gt; test.label n f xs = <br>\ntest.label n g ys\"<br>\nby simp</p>\n<p>lemma second: \"none = f x ==&gt; f = label (f(x := i)) [x]\";<br>\n  by auto;</p>\n<p>lemma third:<br>\n  \"tl a = [] ==&gt;  f (hd a) = none<br>\n       ==&gt; f = label (f(hd a := i)) a\";<br>\n  apply auto;<br>\n  sorry;</p>\n<p>lemma forth:<br>\n  \"? y ys . a = y # ys ==&gt; f (hd a) = none<br>\n       ==&gt; f = label (f(hd a := i)) a\";<br>\n  apply auto;<br>\n  sorry;</p>\n<p>end;</p>\n<p>Brian Huffman wrote:</p>",
        "id": 294106147,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835270
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello Brian,</p>\n<p>Thank you for your answer. I have succeeded with one theorem, but<br>\nI am struggling with the next one now.  It is quite difficult to get it<br>\nto work. I have many parameters in the theories, and many definitions<br>\ndepending on one or more parameters. As you already said, and also<br>\ndiscovered by myself while trying to prove the results, even safe<br>\nand clarify expand the definitions in the undesired way. What is<br>\neven worse is that these apply to all sub-goals, not only to the first one.<br>\nIs there  a way of applying a rule (auto, safe, clarify, unfold) only<br>\nto the first goal (the same way as simp works)?</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294106257,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835289
    }
]