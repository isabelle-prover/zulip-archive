[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nHi there,</p>\n<p>today I stumbled over some (for me) unexpected behavior of the <br>\n\"notation\" command.</p>\n<p>I'm using the following notation:</p>\n<p>notation set (\"\\&lt;^raw:\\listset{&gt;_\\&lt;^raw:}&gt;\")</p>\n<p>where</p>\n<p>\\newcommand\\listset[1]{#1}</p>\n<p>As soon as I have introduced the notation, however, all \"set\" types also <br>\nuse it. E.g., @{typ \"('a * 'b) set\"} is transformed into</p>\n<p>\\isa{\\listset{{\\isacharprime}a\\ {\\isasymtimes}\\ {\\isacharprime}b}}</p>\n<p>The same behavior occurs when I'm defining notation for the constant <br>\n\"List.set\" instead (and I do not see any connection between that <br>\nconstant and the type constructor \"set\").</p>\n<p>My goal was to make the conversion from lists into sets 'implicit' in my <br>\nresulting PDF. Any suggestions, how to achieve this?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294105315,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835018
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 11 Apr 2010, Christian Sternagel wrote:</p>\n<blockquote>\n<p>today I stumbled over some (for me) unexpected behavior of the <br>\n\"notation\" command.</p>\n<p>I'm using the following notation:</p>\n<p>notation set (\"\\&lt;^raw:\\listset{&gt;_\\&lt;^raw:}&gt;\")</p>\n<p>where</p>\n<p>\\newcommand\\listset[1]{#1}</p>\n<p>As soon as I have introduced the notation, however, all \"set\" types also use <br>\nit. E.g., @{typ \"('a * 'b) set\"} is transformed into</p>\n<p>\\isa{\\listset{{\\isacharprime}a\\ {\\isasymtimes}\\ {\\isacharprime}b}}</p>\n<p>The same behavior occurs when I'm defining notation for the constant <br>\n\"List.set\" instead (and I do not see any connection between that <br>\nconstant and the type constructor \"set\").</p>\n</blockquote>\n<p>The connection is the base name, which is \"set\" in both cases.  Since the <br>\nList.set constant uses non-authentic syntax for historical reasons, it is <br>\npassed through the syntax layer via its base name only, causing confusion <br>\nwith the type constructor (all type constructors have non-authentic <br>\nsyntax).</p>\n<p>This behaviour has been there in the syntax layer from the very beginning, <br>\nand it is indeed unexpected.  Only recently, I have finally managed to <br>\nmake syntax fully authentic: consts, types, classes as separate <br>\ncategories.  So in the next official release the above should work as <br>\nexpected, at the cost of substantial incompatibility for most syntax <br>\ntranslation functions by users out there.</p>\n<blockquote>\n<p>My goal was to make the conversion from lists into sets 'implicit' in my <br>\nresulting PDF. Any suggestions, how to achieve this?</p>\n</blockquote>\n<p>You can try to exploit some further details in the syntax tree, using <br>\ntyped_print_translation for example: the const version should carry some <br>\ntype information, while the type version does not.</p>\n<p>Makarius</p>",
        "id": 294105368,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660835036
    }
]