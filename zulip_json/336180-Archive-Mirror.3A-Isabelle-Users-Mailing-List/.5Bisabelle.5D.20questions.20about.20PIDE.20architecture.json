[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 19 Feb 2015, Walther Neuper wrote:</p>\n<blockquote>\n<p>But may I ask for \"notes on PIDE architecture\" ?</p>\n<p>In PIDE communication between Java (i.e. Isabelle/jEdit) and Isabelle/Scala <br>\nseems straight forward, because both run in the same JRE.<br>\nBut how is communication between Isabelle/Scala and Isabelle/ML possible?</p>\n</blockquote>\n<p>This question might sound trivial to some people, but I have struggled <br>\nwith the problem over many years, to make it really really work -- <br>\nrobustly, efficiently, portably.</p>\n<p>There is a brief sketch on \"PIDE Protocol Layers\" in my ITP-2014 paper:</p>\n<p>Makarius Wenzel. Asynchronous User Interaction and Tool Integration in<br>\n   Isabelle/PIDE. In G. Klein and R. Gamboa, editors, Interactive Theorem<br>\n   Proving (ITP 2014). 2014. Springer, LNCS 8558.</p>\n<p><a href=\"http://www4.in.tum.de/~wenzelm/papers/itp-pide.pdf\">http://www4.in.tum.de/~wenzelm/papers/itp-pide.pdf</a></p>\n<p>The relevant text is cited here for convenience:</p>\n<p>\\para{PIDE Protocol Layers.}  Conceptually, the two processes are<br>\n   connected by two independent streams of \\emph{protocol functions}.<br>\n   These streams are essentially symmetric, but input from the editor<br>\n   to the prover is called \\emph{protocol command}, and output from the<br>\n   prover to the editor is called \\emph{protocol message}.<br>\n   Syntactically, a protocol function consists of a name and argument<br>\n   list (arbitrary strings).  Semantically, the stream of protocol<br>\n   functions is applied consecutively to a private \\emph{protocol<br>\n   state} on each side; there are extensible tables in Isabelle/Scala<br>\n   and Isabelle/ML to define the meaning for protocol functions.</p>\n<p>The arguments of protocol functions usually consist of algebraic<br>\n   datatypes (tuples and recursive variants). This well-known ML<br>\n   concept is represented in Scala by case classes<br>\n   \\cite[\\S7.2]{Scala:2004}.  The PIDE implementation starts out with<br>\n   raw byte streams between the processes, then uses YXML transfer<br>\n   syntax for untyped XML trees \\cite[\\S2.3]{Wenzel:2011:CICM}, and<br>\n   finally adds structured XML/ML data representation via some<br>\n   combinator library.  Further details are explained in<br>\n   \\cite{Wenzel:2013:CoqPIDE}, including a full implementation on a few<br>\n   pages of OCaml; the Standard ML version is part of Isabelle/PIDE.<br>\n   This elementary PIDE protocol stack is easily ported to other<br>\n   functional languages to connect different back-ends, but actual<br>\n   document-oriented interaction requires further reforms of the<br>\n   prover.</p>\n<p>See also the included fragment of some slides that explain that (and a bit <br>\nmore).</p>\n<p>The citation Wenzel:2013:CoqPIDE is here: <a href=\"http://arxiv.org/abs/1304.6626\">http://arxiv.org/abs/1304.6626</a> <br>\n-- it explains more things in a prover-agnostic fashion.</p>\n<blockquote>\n<p>Over the years watching the advent of *.scala in ~~/src/Pure/ I imagined some <br>\nmagic about the parallelism between the *.scala files and the *.ML files. But <br>\nin</p>\n<p><a href=\"https://github.com/larsrh/libisabelle/tree/master/pide-core/src/main/scala\">https://github.com/larsrh/libisabelle/tree/master/pide-core/src/main/scala</a></p>\n<p>there are some directories from ~~/src/Pure/, and all of the copied <br>\ndirectories contain exact copies of all the *.scala files and while dropping <br>\nall *.ML files.</p>\n<p>So, where comes communication between Isabelle/Scala and Isabelle/ML from?</p>\n</blockquote>\n<p>As long as these are exact copies of the Isabelle/Pure Scala files, and <br>\nused in a suitable environment of properties and/or process variables, <br>\nthey will magically work with an Isabelle/ML process that expects exactly <br>\nthat communication scheme.</p>\n<p>In Isabelle/Eclipse, Andrius Velykis has made his own clone of basic PIDE <br>\nfunctionality, although with some actual changes managed in a systematic <br>\nway.</p>\n<p>In the longer run, we need to draw further conclusions from practical <br>\nexperience with such derivatice projects.  Somehow the idea of modularity <br>\nseems to be very weak in the JVM world, and Isabelle/Java/Scala does not <br>\nmake this easier for mainstream project and package management tools out <br>\nthere.  (It only makes it very easy for an Isabelle-only environment, as <br>\nexplained for \"isabelle scalac\" in the \"system\" manual.)</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/viw-aMjDJ3FmsfnePLJplLrI/pide-protocol.pdf\">pide-protocol.pdf</a></p>",
        "id": 294326251,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928626
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>As long as these are exact copies of the Isabelle/Pure Scala files, and<br>\nused in a suitable environment of properties and/or process variables,<br>\nthey will magically work with an Isabelle/ML process that expects<br>\nexactly that communication scheme.</p>\n</blockquote>\n<p>Those files are indeed exact copies.</p>\n<blockquote>\n<p>In the longer run, we need to draw further conclusions from practical<br>\nexperience with such derivatice projects.  Somehow the idea of<br>\nmodularity seems to be very weak in the JVM world, and<br>\nIsabelle/Java/Scala does not make this easier for mainstream project and<br>\npackage management tools out there.  (It only makes it very easy for an<br>\nIsabelle-only environment, as explained for \"isabelle scalac\" in the<br>\n\"system\" manual.)</p>\n</blockquote>\n<p>I don't think modularity in the Java ecosystem is significantly weaker<br>\nthan anywhere else. The problem with system integration in Isabelle is<br>\nthat Isabelle has \"high gravity\", i.e. it usually assumes that<br>\napplications are centered around Isabelle. From that point of view, it<br>\nalso makes sense that Isabelle/Scala observes ML coding conventions wrt<br>\nnaming and architecture. With the rise of the document model, new<br>\napplications become possible, some of which can't (or don't want to)<br>\nadhere to that world view.</p>\n<p>So far, I know of two major applications where significant development<br>\neffort has been spent to integrate Isabelle into existing software:</p>\n<ul>\n<li>Isabelle/Eclipse with Eclipse being the \"center of the universe\"</li>\n<li>Clide [0] with a Play! web application</li>\n</ul>\n<p>(There's also Leon+Isabelle, but that was more of a \"proof of concept\".)</p>\n<p>The Isabelle integration in Clide works almost exactly in the same way<br>\nas libisabelle: They copied the Isabelle/Pure JAR into some suitable<br>\n'lib' directory. (Taking a JAR instead of the full sources has the<br>\ndisadvantage that cross-compiling against different versions of Scala is<br>\nruled out, and that the Scala version for Clide must be the same as the<br>\nScala version for Isabelle.)</p>\n<p>I think it is fair to say that we already have practical experience. It<br>\nmight be worth getting feedback from Clide's authors (not sure if they<br>\nread this mailing list) [1].</p>\n<p>But all this brings me back to my original point: Modularity. It would<br>\nbe entirely possible to ship an \"official\" JAR file with some metadata<br>\n(in Java lingo: \"artifact\") to a repository. Integrating Isabelle into a<br>\nScala application then becomes a matter of one line in the build definition:</p>\n<p>libraryDependencies += \"de.tum.in.isabelle\" %% \"pide\" % \"2014\"</p>\n<p>Of course, the PIDE sources would need to be enriched with functionality<br>\nto fetch an Isabelle distribution, unpack it, and build the required<br>\ncomponents in a way that doesn't require shell scripts or Perl. (I have<br>\nthat on my agenda.)</p>\n<p>Cheers<br>\nLars</p>\n<p>[0] &lt;<a href=\"http://clide.flatmap.net/login\">http://clide.flatmap.net/login</a>&gt;<br>\n[1] their paper at ITP'14 is also quite interesting: Christoph LÃ¼th,<br>\nMartin Ring: \"Collaborative Interactive Theorem Proving with Clide\"</p>",
        "id": 294326273,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660928637
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nI see, you have found a way to replace IDEs' \"run configurations\", and I <br>\nhad the opportunity so see that used on your laptop efficiently such <br>\nthat I never could follow what is going on ;-))</p>\n<p>But may I ask for \"notes on PIDE architecture\" ?</p>\n<p>In PIDE communication between Java (i.e. Isabelle/jEdit) and <br>\nIsabelle/Scala seems straight forward, because both run in the same JRE.<br>\nBut how is communication between Isabelle/Scala and Isabelle/ML possible?</p>\n<p>Over the years watching the advent of *.scala in ~~/src/Pure/ I imagined <br>\nsome magic about the parallelism between the *.scala files and the *.ML <br>\nfiles. But in</p>\n<p><a href=\"https://github.com/larsrh/libisabelle/tree/master/pide-core/src/main/scala\">https://github.com/larsrh/libisabelle/tree/master/pide-core/src/main/scala</a></p>\n<p>there are some directories from ~~/src/Pure/, and all of the copied <br>\ndirectories contain exact copies of all the *.scala files and while <br>\ndropping all *.ML files.</p>\n<p>So, where comes communication between Isabelle/Scala and Isabelle/ML from?</p>\n<p>Walther</p>",
        "id": 294328508,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929435
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>In PIDE communication between Java (i.e. Isabelle/jEdit) and <br>\nIsabelle/Scala seems straight forward, because both run in the same <br>\nJRE. But how is communication between Isabelle/Scala and Isabelle/ML <br>\npossible?</p>\n</blockquote>\n<p>I don't understand all low-level details myself, but a useful intuition<br>\nis that the JVM spawns a prover process and then exchanges XML trees<br>\nwith it. This mechanism is extensible: Both processes speak a common<br>\nprotocol for process management (e.g. jEdit can tell the prover \"here's<br>\nan updated document\", to which the prover replies \"annotate this piece<br>\nof text with a warning message\"), but users can extend the communication<br>\nwith custom messages. These XML messages are transmitted via the<br>\nintermediate \"YXML\" format which is a space-efficient representation of<br>\nmost of XML. A reasonable summary of this is \"a custom IPC protocol\".</p>\n<p>The low-level implementation can be found in the files<br>\n'System/system_channel.scala' and 'System/system_channel.ML'. In<br>\nIsabelle2014, this is done with FIFOs or sockets (depending on the OS),<br>\nbut the current development version uses sockets exclusively.</p>\n<blockquote>\n<p>Over the years watching the advent of *.scala in ~~/src/Pure/ I <br>\nimagined some magic about the parallelism between the *.scala files <br>\nand the *.ML files.</p>\n</blockquote>\n<p>Conceptually, the Scala files are not required for running the prover<br>\nprocess. They merely provide one way to interact with it. On the other<br>\nside, the JVM process doesn't need the ML file to do whatever it's<br>\ndoing. Files of both languages could be separated without any problems<br>\n(it wouldn't even complicate the build of Isabelle).</p>\n<p>The reason why both sources are being kept together is because there's<br>\nsome symmetry which can be exploited. Some modules (e.g. XML processing,<br>\ngraph algorithms) are actually the same in both languages so that it<br>\nmakes sense to keep them together.</p>\n<blockquote>\n<p>But in</p>\n<p><a href=\"https://github.com/larsrh/libisabelle/tree/master/pide-core/src/main/scala\">https://github.com/larsrh/libisabelle/tree/master/pide-core/src/main/scala</a></p>\n<p>there are some directories from ~~/src/Pure/, and all of the copied <br>\ndirectories contain exact copies of all the *.scala files and while <br>\ndropping all *.ML files.</p>\n</blockquote>\n<p>I could've just taken the 'Pure.jar' file unmodified from Isabelle and<br>\nused that. There are two reasons against this:<br>\n1) I wouldn't be able to cross-compile 'libisabelle' against different<br>\nScala versions, since 'Pure.jar' would be fixed to whatever Scala<br>\nversion is currently used in Isabelle.<br>\n2) I would include some extra dependencies (e.g. Scala Swing) which are<br>\nnot needed for a non-GUI library.</p>\n<p>I did that for my work on Isabelle integration with Leon, but figured<br>\nthat there ought to be a better way. Copying source files is also what<br>\nAndrius Velykis did for isabelle-eclipse.</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/NwgCMsnELZa1-otJX8mAHsfw/smime.p7s\">smime.p7s</a></p>",
        "id": 294328543,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660929447
    }
]