[
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nHello all,</p>\n<p>I tried to test the higher-order lifting capabilities of the<br>\nIsabelle2011-1 quotient package recently. Here is my example theory:</p>\n<p>theory Scratch<br>\nimports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\nbegin</p>\n<p>lemma \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\napply descending</p>\n<p>*** Type unification failed: Clash of types \"_ list\" and \"_ fset\"</p>\n<hr>\n<p>*** Type error in application: incompatible operand type</p>\n<hr>\n<p>*** Operator:  map :: ('b fset \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'b<br>\nfset list \\&lt;Rightarrow&gt; 'a fset list<br>\n*** Operand:   map f :: 'b list \\&lt;Rightarrow&gt; 'a list</p>\n<p>A recent development version (4ecf63349466) yields exactly the same<br>\nerror message.</p>\n<p>To test whether the multiple occurrences of map_fset at different<br>\ntypes were causing the problem, I tried a simpler example:</p>\n<p>lemma \"concat_fset (map_fset (\\&lt;lambda&gt;x. {|x|}) xs) = xs\"<br>\napply descending</p>\n<p>*** Type unification failed: Clash of types \"_ list\" and \"_ fset\"</p>\n<hr>\n<p>*** Type error in application: incompatible operand type</p>\n<hr>\n<p>*** Operator:  map :: ('a \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'a list<br>\n\\&lt;Rightarrow&gt; 'a fset list<br>\n*** Operand:   \\&lt;lambda&gt;x. [x] :: 'a \\&lt;Rightarrow&gt; 'a list</p>\n<p>Is there some additional configuration/setup I need to do to enable<br>\nlifting of higher-order theorems, or does this error indicate a bug in<br>\nthe quotient package?</p>\n<p>Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>\nwhich the descending method actually works? I can't seem to find one.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294148896,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848561
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nHello all,</p>\n<p>I tried to test the higher-order lifting capabilities of the<br>\nIsabelle2011-1 quotient package recently. Here is my example theory:</p>\n<p>theory Scratch<br>\nimports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\nbegin</p>\n<p>lemma \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\napply descending</p>\n<p>*** Type unification failed: Clash of types \"_ list\" and \"_ fset\"</p>\n<hr>\n<p>*** Type error in application: incompatible operand type</p>\n<hr>\n<p>*** Operator:  map :: ('b fset \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'b<br>\nfset list \\&lt;Rightarrow&gt; 'a fset list<br>\n*** Operand:   map f :: 'b list \\&lt;Rightarrow&gt; 'a list</p>\n<p>A recent development version (4ecf63349466) yields exactly the same<br>\nerror message.</p>\n<p>To test whether the multiple occurrences of map_fset at different<br>\ntypes were causing the problem, I tried a simpler example:</p>\n<p>lemma \"concat_fset (map_fset (\\&lt;lambda&gt;x. {|x|}) xs) = xs\"<br>\napply descending</p>\n<p>*** Type unification failed: Clash of types \"_ list\" and \"_ fset\"</p>\n<hr>\n<p>*** Type error in application: incompatible operand type</p>\n<hr>\n<p>*** Operator:  map :: ('a \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'a list<br>\n\\&lt;Rightarrow&gt; 'a fset list<br>\n*** Operand:   \\&lt;lambda&gt;x. [x] :: 'a \\&lt;Rightarrow&gt; 'a list</p>\n<p>Is there some additional configuration/setup I need to do to enable<br>\nlifting of higher-order theorems, or does this error indicate a bug in<br>\nthe quotient package?</p>\n<p>Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>\nwhich the descending method actually works? I can't seem to find one.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294148907,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848567
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\nOn Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Brian,</p>\n<p>I am not sure whether this will help to establish your<br>\ntheorem, but here is something to get you started. \"Descending\"<br>\ncan only guess what the theorem should look like on<br>\nthe raw type. From what I have seen it might guess wrong<br>\nin case of higher-order theorems (or in case where you are<br>\ntrying to lift constants of type ('a list) list to<br>\n('a fset) fset).</p>\n<p>One way to get around this is to already provide the<br>\nlemma from which you want to lift. Like so</p>\n<p>theory Scratch<br>\nimports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\nbegin</p>\n<p>lemma map_concat_rev:<br>\n \"concat (map (map f) xss) = map f (concat xss)\"<br>\nby (rule map_concat[symmetric])</p>\n<p>lemma<br>\n \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\napply(lifting map_concat_rev)</p>\n</blockquote>\n<p>Yes, I also tried this. I understand that the \"lifting\" method<br>\ntypically should discharge the current goal, but in this case it<br>\nleaves me with two new subgoals:</p>\n<p>goal (2 subgoals):</p>\n<ol>\n<li>\n<p>⋀fa x y.<br>\n       ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>\n       ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>\n           list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>\n           map map</p>\n</li>\n<li>\n<p>(∀f xss.<br>\n        concat_fset<br>\n         (((abs_fset ---&gt; rep_fset) ---&gt;<br>\n           (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>\n           map (map_fset f) xss) =<br>\n        map_fset f (concat_fset xss)) =<br>\n    (∀f xss.<br>\n        concat_fset (map_fset (map_fset f) xss) =<br>\n        map_fset f (concat_fset xss))</p>\n</li>\n</ol>\n<p>I'm not sure what I should do at this point. Is there some additional<br>\nsetup I can do that will allow \"lifting\" to discharge these<br>\nautomatically, or are users expected to try to discharge these<br>\nmanually?</p>\n<ul>\n<li>Brian</li>\n</ul>\n<blockquote>\n<p>Brian Huffman writes:<br>\n &gt; Hello all,<br>\n &gt;<br>\n &gt; I tried to test the higher-order lifting capabilities of the<br>\n &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>\n &gt;<br>\n &gt; theory Scratch<br>\n &gt; imports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\n &gt; begin<br>\n &gt;<br>\n &gt; lemma \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\n &gt; apply descending<br>\n &gt;<br>\n &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; ***<br>\n &gt; *** Type error in application: incompatible operand type<br>\n &gt; ***<br>\n &gt; *** Operator:  map :: ('b fset \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'b<br>\n &gt; fset list \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; *** Operand:   map f :: 'b list \\&lt;Rightarrow&gt; 'a list<br>\n &gt;<br>\n &gt; A recent development version (4ecf63349466) yields exactly the same<br>\n &gt; error message.<br>\n &gt;<br>\n &gt; To test whether the multiple occurrences of map_fset at different<br>\n &gt; types were causing the problem, I tried a simpler example:<br>\n &gt;<br>\n &gt; lemma \"concat_fset (map_fset (\\&lt;lambda&gt;x. {|x|}) xs) = xs\"<br>\n &gt; apply descending<br>\n &gt;<br>\n &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; ***<br>\n &gt; *** Type error in application: incompatible operand type<br>\n &gt; ***<br>\n &gt; *** Operator:  map :: ('a \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'a list<br>\n &gt; \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; *** Operand:   \\&lt;lambda&gt;x. [x] :: 'a \\&lt;Rightarrow&gt; 'a list<br>\n &gt;<br>\n &gt; Is there some additional configuration/setup I need to do to enable<br>\n &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>\n &gt; the quotient package?<br>\n &gt;<br>\n &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>\n &gt; which the descending method actually works? I can't seem to find one.<br>\n &gt;<br>\n &gt;<br>\n &gt; - Brian</p>\n<p>--</p>\n</blockquote>",
        "id": 294148936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848579
    },
    {
        "content": "<p>From: Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt;<br>\nHi Brian,</p>\n<p>Lifting (and descending) cannot always be done completely<br>\nautomatically. This is already a feature of the original<br>\nwork of Homeier. This means the tactic just return what<br>\nthey cannot solve automatically.</p>\n<p>If I remember correctly, Cezary and I encountered similar <br>\nproblems with lifting properties about concat such as</p>\n<p>\"concat [] = []\"<br>\n   \"concat (x # xs) = x @ concat xs\"</p>\n<p>This required us to do some contortions like proving the <br>\nproperty concat_rsp in FSet.thy.</p>\n<p>Best wishes,<br>\nChristian</p>\n<p>Brian Huffman writes:</p>\n<blockquote>\n<p>On Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Brian,</p>\n<p>I am not sure whether this will help to establish your<br>\ntheorem, but here is something to get you started. \"Descending\"<br>\ncan only guess what the theorem should look like on<br>\nthe raw type. From what I have seen it might guess wrong<br>\nin case of higher-order theorems (or in case where you are<br>\ntrying to lift constants of type ('a list) list to<br>\n('a fset) fset).</p>\n<p>One way to get around this is to already provide the<br>\nlemma from which you want to lift. Like so</p>\n<p>theory Scratch<br>\nimports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\nbegin</p>\n<p>lemma map_concat_rev:<br>\n \"concat (map (map f) xss) = map f (concat xss)\"<br>\nby (rule map_concat[symmetric])</p>\n<p>lemma<br>\n \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\napply(lifting map_concat_rev)</p>\n</blockquote>\n<p>Yes, I also tried this. I understand that the \"lifting\" method<br>\ntypically should discharge the current goal, but in this case it<br>\nleaves me with two new subgoals:</p>\n<p>goal (2 subgoals):<br>\n 1. ⋀fa x y.<br>\n       ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>\n       ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>\n           list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>\n           map map<br>\n 2. (∀f xss.<br>\n        concat_fset<br>\n         (((abs_fset ---&gt; rep_fset) ---&gt;<br>\n           (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>\n           map (map_fset f) xss) =<br>\n        map_fset f (concat_fset xss)) =<br>\n    (∀f xss.<br>\n        concat_fset (map_fset (map_fset f) xss) =<br>\n        map_fset f (concat_fset xss))</p>\n<p>I'm not sure what I should do at this point. Is there some additional<br>\nsetup I can do that will allow \"lifting\" to discharge these<br>\nautomatically, or are users expected to try to discharge these<br>\nmanually?</p>\n<ul>\n<li>Brian</li>\n</ul>\n<blockquote>\n<p>Brian Huffman writes:<br>\n &gt; Hello all,<br>\n &gt;<br>\n &gt; I tried to test the higher-order lifting capabilities of the<br>\n &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>\n &gt;<br>\n &gt; theory Scratch<br>\n &gt; imports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\n &gt; begin<br>\n &gt;<br>\n &gt; lemma \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\n &gt; apply descending<br>\n &gt;<br>\n &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; ***<br>\n &gt; *** Type error in application: incompatible operand type<br>\n &gt; ***<br>\n &gt; *** Operator:  map :: ('b fset \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'b<br>\n &gt; fset list \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; *** Operand:   map f :: 'b list \\&lt;Rightarrow&gt; 'a list<br>\n &gt;<br>\n &gt; A recent development version (4ecf63349466) yields exactly the same<br>\n &gt; error message.<br>\n &gt;<br>\n &gt; To test whether the multiple occurrences of map_fset at different<br>\n &gt; types were causing the problem, I tried a simpler example:<br>\n &gt;<br>\n &gt; lemma \"concat_fset (map_fset (\\&lt;lambda&gt;x. {|x|}) xs) = xs\"<br>\n &gt; apply descending<br>\n &gt;<br>\n &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; ***<br>\n &gt; *** Type error in application: incompatible operand type<br>\n &gt; ***<br>\n &gt; *** Operator:  map :: ('a \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'a list<br>\n &gt; \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; *** Operand:   \\&lt;lambda&gt;x. [x] :: 'a \\&lt;Rightarrow&gt; 'a list<br>\n &gt;<br>\n &gt; Is there some additional configuration/setup I need to do to enable<br>\n &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>\n &gt; the quotient package?<br>\n &gt;<br>\n &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>\n &gt; which the descending method actually works? I can't seem to find one.<br>\n &gt;<br>\n &gt;<br>\n &gt; - Brian</p>\n<p>--</p>\n</blockquote>\n</blockquote>",
        "id": 294148948,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660848585
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:huffman@in.tum.de\">huffman@in.tum.de</a>&gt;<br>\n[Note to isabelle-users members: This a continuation of an old thread<br>\nfrom Dec. 18.]</p>\n<p>On Fri, Feb 3, 2012 at 4:35 PM, Cezary Kaliszyk<br>\n&lt;<a href=\"mailto:cezarykaliszyk@gmail.com\">cezarykaliszyk@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Brian,</p>\n<p>It is very late to answer your email, but I added the compositional<br>\nrespectfulness and preservation theorems for 'map', which means<br>\nthat the theorem you mentioned (map_concat) now lifts automatically.</p>\n</blockquote>\n<p>Hi Cezary,</p>\n<p>Thanks for adding the new respectfulness and preservation theorems for<br>\nmap. Unfortunately the descending method still produces the same error<br>\nmessage, but the proof does indeed work with the lifting method now:</p>\n<p>theory Scratch imports \"~~/src/HOL/Quotient_Examples/FSet\" begin</p>\n<p>lemma \"map_fset f (concat_fset xss) = concat_fset (map_fset (map_fset f) xss)\"<br>\nby (lifting map_concat)</p>\n<p>I also tried my other example again:</p>\n<p>lemma concat_map_single: \"concat (map (\\&lt;lambda&gt;x. [x]) xs) = xs\"<br>\nby (induct xs, simp_all)</p>\n<p>lemma \"concat_fset (map_fset (\\&lt;lambda&gt;x. {|x|}) xs) = xs\"<br>\napply (lifting concat_map_single)</p>\n<p>Here the lifting method leaves a couple of subgoals, but by following<br>\nyour example I was able to state and prove the necessary<br>\nrespectfulness and preservation theorems:</p>\n<p>lemma map_rsp3 [quot_respect]:<br>\n  \"((op = ===&gt; list_eq) ===&gt; list_eq ===&gt; list_all2 list_eq OOO<br>\nlist_eq) map map\"</p>\n<p>lemma map_prs3 [quot_preserve]:<br>\n  \"((id ---&gt; rep_fset) ---&gt; rep_fset ---&gt; (abs_fset o map abs_fset))<br>\nmap = map_fset\"</p>\n<p>So it seems that the quotient package needs a separate respectfulness<br>\ntheorem for each of these type instances of map:</p>\n<p>map_rsp, for map :: ('a =&gt; 'b) =&gt; 'a list =&gt; 'b list<br>\nmap_rsp2, for map :: ('a list =&gt; 'b list) =&gt; 'a list list =&gt; 'b list list<br>\nmap_rsp3, for map :: ('a =&gt; 'b list) =&gt; 'a list =&gt; 'b list list</p>\n<p>I suppose I would need another theorem map_rsp4 in order to use map at<br>\ntype ('a list =&gt; 'b) =&gt; 'a list list =&gt; 'b list, for example.</p>\n<p>Moving on, I also tried lifting another monad law, which gave me a<br>\ncompletely new error message.</p>\n<p>lemma concat_map_concat: \"concat (map concat xsss) = concat (concat xsss)\"<br>\nby (induct xsss, simp_all)</p>\n<p>lemma \"concat_fset (map_fset concat_fset xsss) = concat_fset (concat_fset xsss)\"<br>\napply (lifting concat_map_concat)</p>\n<p>*** Solve_quotient_assm failed. Possibly a quotient theorem is missing.</p>\n<p>Perhaps you could help me determine what quotient theorem I need here?<br>\nI suspect that this error has something to do the variable xsss :: 'a<br>\nlist list list, with the 3-deep nesting of the list type.</p>\n<ul>\n<li>Brian</li>\n</ul>\n<blockquote>\n<p>On Sun, Dec 18, 2011 at 11:46 AM, Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Hi Brian,</p>\n<p>Lifting (and descending) cannot always be done completely<br>\nautomatically. This is already a feature of the original<br>\nwork of Homeier. This means the tactic just return what<br>\nthey cannot solve automatically.</p>\n<p>If I remember correctly, Cezary and I encountered similar<br>\nproblems with lifting properties about concat such as</p>\n<p>\"concat [] = []\"<br>\n  \"concat (x # xs) = x @ concat xs\"</p>\n<p>This required us to do some contortions like proving the<br>\nproperty concat_rsp in FSet.thy.</p>\n<p>Best wishes,<br>\nChristian</p>\n<p>Brian Huffman writes:</p>\n<p>On Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt; wrote:<br>\n &gt; &gt;<br>\n &gt; &gt; Hi Brian,<br>\n &gt; &gt;<br>\n &gt; &gt; I am not sure whether this will help to establish your<br>\n &gt; &gt; theorem, but here is something to get you started. \"Descending\"<br>\n &gt; &gt; can only guess what the theorem should look like on<br>\n &gt; &gt; the raw type. From what I have seen it might guess wrong<br>\n &gt; &gt; in case of higher-order theorems (or in case where you are<br>\n &gt; &gt; trying to lift constants of type ('a list) list to<br>\n &gt; &gt; ('a fset) fset).<br>\n &gt; &gt;<br>\n &gt; &gt; One way to get around this is to already provide the<br>\n &gt; &gt; lemma from which you want to lift. Like so<br>\n &gt; &gt;<br>\n &gt; &gt; theory Scratch<br>\n &gt; &gt; imports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\n &gt; &gt; begin<br>\n &gt; &gt;<br>\n &gt; &gt; lemma map_concat_rev:<br>\n &gt; &gt;  \"concat (map (map f) xss) = map f (concat xss)\"<br>\n &gt; &gt; by (rule map_concat[symmetric])<br>\n &gt; &gt;<br>\n &gt; &gt; lemma<br>\n &gt; &gt;  \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\n &gt; &gt; apply(lifting map_concat_rev)<br>\n &gt;<br>\n &gt; Yes, I also tried this. I understand that the \"lifting\" method<br>\n &gt; typically should discharge the current goal, but in this case it<br>\n &gt; leaves me with two new subgoals:<br>\n &gt;<br>\n &gt; goal (2 subgoals):<br>\n &gt;  1. ⋀fa x y.<br>\n &gt;        ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>\n &gt;        ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>\n &gt;            list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>\n &gt;            map map<br>\n &gt;  2. (∀f xss.<br>\n &gt;         concat_fset<br>\n &gt;          (((abs_fset ---&gt; rep_fset) ---&gt;<br>\n &gt;            (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>\n &gt;            map (map_fset f) xss) =<br>\n &gt;         map_fset f (concat_fset xss)) =<br>\n &gt;     (∀f xss.<br>\n &gt;         concat_fset (map_fset (map_fset f) xss) =<br>\n &gt;         map_fset f (concat_fset xss))<br>\n &gt;<br>\n &gt; I'm not sure what I should do at this point. Is there some additional<br>\n &gt; setup I can do that will allow \"lifting\" to discharge these<br>\n &gt; automatically, or are users expected to try to discharge these<br>\n &gt; manually?<br>\n &gt;<br>\n &gt; - Brian<br>\n &gt;<br>\n &gt; &gt; Brian Huffman writes:<br>\n &gt; &gt;  &gt; Hello all,<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; I tried to test the higher-order lifting capabilities of the<br>\n &gt; &gt;  &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; theory Scratch<br>\n &gt; &gt;  &gt; imports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\n &gt; &gt;  &gt; begin<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; lemma \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\n &gt; &gt;  &gt; apply descending<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Operator:  map :: ('b fset \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'b<br>\n &gt; &gt;  &gt; fset list \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; &gt;  &gt; *** Operand:   map f :: 'b list \\&lt;Rightarrow&gt; 'a list<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; A recent development version (4ecf63349466) yields exactly the same<br>\n &gt; &gt;  &gt; error message.<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; To test whether the multiple occurrences of map_fset at different<br>\n &gt; &gt;  &gt; types were causing the problem, I tried a simpler example:<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; lemma \"concat_fset (map_fset (\\&lt;lambda&gt;x. {|x|}) xs) = xs\"<br>\n &gt; &gt;  &gt; apply descending<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Operator:  map :: ('a \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'a list<br>\n &gt; &gt;  &gt; \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; &gt;  &gt; *** Operand:   \\&lt;lambda&gt;x. [x] :: 'a \\&lt;Rightarrow&gt; 'a list<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; Is there some additional configuration/setup I need to do to enable<br>\n &gt; &gt;  &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>\n &gt; &gt;  &gt; the quotient package?<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>\n &gt; &gt;  &gt; which the descending method actually works? I can't seem to find one.<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; - Brian<br>\n &gt; &gt;<br>\n &gt; &gt; --</p>\n<p>--<br>\n</p>\n</blockquote>\n<p>--<br>\nCezary Kaliszyk, University of Innsbruck,<br>\n<a href=\"http://cl-informatik.uibk.ac.at/~cek/\">http://cl-informatik.uibk.ac.at/~cek/</a></p>\n</blockquote>",
        "id": 294152329,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849770
    },
    {
        "content": "<p>From: Cezary Kaliszyk &lt;<a href=\"mailto:cezarykaliszyk@gmail.com\">cezarykaliszyk@gmail.com</a>&gt;<br>\nHi Brian,</p>\n<p>On Sat, Feb 04, 2012 at 10:05:00AM +0100, Brian Huffman wrote:</p>\n<blockquote>\n<blockquote>\n<p>It is very late to answer your email, but I added the compositional<br>\nrespectfulness and preservation theorems for 'map', which means<br>\nthat the theorem you mentioned (map_concat) now lifts automatically.<br>\nThanks for adding the new respectfulness and preservation theorems for<br>\nmap. Unfortunately the descending method still produces the same error<br>\nmessage [...]</p>\n</blockquote>\n</blockquote>\n<p>Should be fixed now. As mentioned before in this thread the procedure<br>\nfor guessing which theorem one wants to lift (and the procedure for<br>\nguessing the lifted theorem) is a heuristic. The idea for the<br>\nheuristic is to be greedy as this is what the user wants in most<br>\ncases, however the implementation was not greedy enough.</p>\n<blockquote>\n<p>Moving on, I also tried lifting another monad law, which gave me a<br>\ncompletely new error message.</p>\n<p>lemma concat_map_concat: \"concat (map concat xsss) = concat (concat xsss)\"<br>\nby (induct xsss, simp_all)</p>\n<p>lemma \"concat_fset (map_fset concat_fset xsss) = concat_fset (concat_fset xsss)\"<br>\napply (lifting concat_map_concat)</p>\n<p>*** Solve_quotient_assm failed. Possibly a quotient theorem is missing.</p>\n<p>Perhaps you could help me determine what quotient theorem I need here?<br>\nI suspect that this error has something to do the variable xsss :: 'a<br>\nlist list list, with the 3-deep nesting of the list type.</p>\n</blockquote>\n<p>If instead of lifting you use lifting_setup and manually apply<br>\nregularize and injection, you can see the missing quotient theorem,<br>\nnamely:</p>\n<p>Quotient (list_all2 (list_all2 op \\&lt;approx&gt; OOO op \\&lt;approx&gt;) OOO op \\&lt;approx&gt;)<br>\n     (abs_fset \\&lt;circ&gt; map (abs_fset \\&lt;circ&gt; map abs_fset))<br>\n     (map (map rep_fset \\&lt;circ&gt; rep_fset) \\&lt;circ&gt; rep_fset)</p>\n<p>Since this involves a composition of 3 relations I imagine it to be<br>\nvery tedious to prove; but if you declare it with the [quot_thm]<br>\nattribute, the lifting will only leave the usual respectfulness and<br>\npreservation obligations.</p>\n<p>Regards,</p>\n<p>Cezary</p>\n<blockquote>\n<p>On Sun, Dec 18, 2011 at 11:46 AM, Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt; wrote:</p>\n<blockquote>\n<blockquote>\n<p>Hi Brian,</p>\n<p>Lifting (and descending) cannot always be done completely<br>\nautomatically. This is already a feature of the original<br>\nwork of Homeier. This means the tactic just return what<br>\nthey cannot solve automatically.</p>\n<p>If I remember correctly, Cezary and I encountered similar<br>\nproblems with lifting properties about concat such as</p>\n<p>\"concat [] = []\"<br>\n  \"concat (x # xs) = x @ concat xs\"</p>\n<p>This required us to do some contortions like proving the<br>\nproperty concat_rsp in FSet.thy.</p>\n<p>Best wishes,<br>\nChristian</p>\n<p>Brian Huffman writes:</p>\n<p>On Sun, Dec 18, 2011 at 10:41 AM, Christian Urban &lt;<a href=\"mailto:urbanc@in.tum.de\">urbanc@in.tum.de</a>&gt; wrote:<br>\n &gt; &gt;<br>\n &gt; &gt; Hi Brian,<br>\n &gt; &gt;<br>\n &gt; &gt; I am not sure whether this will help to establish your<br>\n &gt; &gt; theorem, but here is something to get you started. \"Descending\"<br>\n &gt; &gt; can only guess what the theorem should look like on<br>\n &gt; &gt; the raw type. From what I have seen it might guess wrong<br>\n &gt; &gt; in case of higher-order theorems (or in case where you are<br>\n &gt; &gt; trying to lift constants of type ('a list) list to<br>\n &gt; &gt; ('a fset) fset).<br>\n &gt; &gt;<br>\n &gt; &gt; One way to get around this is to already provide the<br>\n &gt; &gt; lemma from which you want to lift. Like so<br>\n &gt; &gt;<br>\n &gt; &gt; theory Scratch<br>\n &gt; &gt; imports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\n &gt; &gt; begin<br>\n &gt; &gt;<br>\n &gt; &gt; lemma map_concat_rev:<br>\n &gt; &gt;  \"concat (map (map f) xss) = map f (concat xss)\"<br>\n &gt; &gt; by (rule map_concat[symmetric])<br>\n &gt; &gt;<br>\n &gt; &gt; lemma<br>\n &gt; &gt;  \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\n &gt; &gt; apply(lifting map_concat_rev)<br>\n &gt;<br>\n &gt; Yes, I also tried this. I understand that the \"lifting\" method<br>\n &gt; typically should discharge the current goal, but in this case it<br>\n &gt; leaves me with two new subgoals:<br>\n &gt;<br>\n &gt; goal (2 subgoals):<br>\n &gt;  1. ⋀fa x y.<br>\n &gt;        ⟦Quot_True map_fset; (list_all2 list_eq OOO list_eq) x y⟧<br>\n &gt;        ⟹ ((list_eq ===&gt; list_eq) ===&gt;<br>\n &gt;            list_all2 list_eq OOO list_eq ===&gt; list_all2 list_eq OOO list_eq)<br>\n &gt;            map map<br>\n &gt;  2. (∀f xss.<br>\n &gt;         concat_fset<br>\n &gt;          (((abs_fset ---&gt; rep_fset) ---&gt;<br>\n &gt;            (map rep_fset ∘ rep_fset) ---&gt; abs_fset ∘ map abs_fset)<br>\n &gt;            map (map_fset f) xss) =<br>\n &gt;         map_fset f (concat_fset xss)) =<br>\n &gt;     (∀f xss.<br>\n &gt;         concat_fset (map_fset (map_fset f) xss) =<br>\n &gt;         map_fset f (concat_fset xss))<br>\n &gt;<br>\n &gt; I'm not sure what I should do at this point. Is there some additional<br>\n &gt; setup I can do that will allow \"lifting\" to discharge these<br>\n &gt; automatically, or are users expected to try to discharge these<br>\n &gt; manually?<br>\n &gt;<br>\n &gt; - Brian<br>\n &gt;<br>\n &gt; &gt; Brian Huffman writes:<br>\n &gt; &gt;  &gt; Hello all,<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; I tried to test the higher-order lifting capabilities of the<br>\n &gt; &gt;  &gt; Isabelle2011-1 quotient package recently. Here is my example theory:<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; theory Scratch<br>\n &gt; &gt;  &gt; imports \"~~/src/HOL/Quotient_Examples/FSet\"<br>\n &gt; &gt;  &gt; begin<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; lemma \"concat_fset (map_fset (map_fset f) xss) = map_fset f (concat_fset xss)\"<br>\n &gt; &gt;  &gt; apply descending<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Operator:  map :: ('b fset \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'b<br>\n &gt; &gt;  &gt; fset list \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; &gt;  &gt; *** Operand:   map f :: 'b list \\&lt;Rightarrow&gt; 'a list<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; A recent development version (4ecf63349466) yields exactly the same<br>\n &gt; &gt;  &gt; error message.<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; To test whether the multiple occurrences of map_fset at different<br>\n &gt; &gt;  &gt; types were causing the problem, I tried a simpler example:<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; lemma \"concat_fset (map_fset (\\&lt;lambda&gt;x. {|x|}) xs) = xs\"<br>\n &gt; &gt;  &gt; apply descending<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; *** Type unification failed: Clash of types \"_ list\" and \"_ fset\"<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Type error in application: incompatible operand type<br>\n &gt; &gt;  &gt; ***<br>\n &gt; &gt;  &gt; *** Operator:  map :: ('a \\&lt;Rightarrow&gt; 'a fset) \\&lt;Rightarrow&gt; 'a list<br>\n &gt; &gt;  &gt; \\&lt;Rightarrow&gt; 'a fset list<br>\n &gt; &gt;  &gt; *** Operand:   \\&lt;lambda&gt;x. [x] :: 'a \\&lt;Rightarrow&gt; 'a list<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; Is there some additional configuration/setup I need to do to enable<br>\n &gt; &gt;  &gt; lifting of higher-order theorems, or does this error indicate a bug in<br>\n &gt; &gt;  &gt; the quotient package?<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; Also, can anyone suggest <em>any</em> examples of higher-order theorems upon<br>\n &gt; &gt;  &gt; which the descending method actually works? I can't seem to find one.<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt;<br>\n &gt; &gt;  &gt; - Brian<br>\n &gt; &gt;<br>\n &gt; &gt; --</p>\n<p>--<br>\n</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294152698,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849904
    }
]