[
    {
        "content": "<p>From: Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt;<br>\nIs there supposed to be any sort of guarantee of consistency between a<br>\nterm A and the term B that results from printing A and then reading<br>\nthe result, when the \"show types\" option is off? I have found a case<br>\nwhere the types in B are more general, in a way that caused problems<br>\ntrying to do a lemma. I can give more details if desired.</p>\n<p>Chris Capel</p>",
        "id": 294077147,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829328
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nSimilar situations can also arise even when \"show types\" is on. This happens<br>\noften if you use functions like \"of_nat :: nat =&gt; 'a::semiring_1\" or \"of_int<br>\n:: int =&gt; 'a::ring_1\" that are polymorphic in the return type. For example,<br>\nif you type \"thm of_int_less_iff\", you get:</p>\n<p>\"(of_int (?w::int) &lt; of_int (?z::int)) = (?w &lt; ?z)\"</p>\n<p>Even with \"show sorts\" enabled, you get no indication that this lemma<br>\napplies only to class \"ordered_idom\".</p>\n<p>I would say that the \"show types\" and \"show sorts\" options were designed<br>\nsolely for making terms easier for humans to parse; I don't think any<br>\nguarantees about re-parsing by Isabelle were intended.</p>\n<p>With the prevalence of Isar-style proofs nowadays, users are doing a lot<br>\nmore cut-and-paste from the goals buffer back into their proof scripts than<br>\nthey used to. Maybe it is time to add a new option, \"show exactly enough<br>\ntype annotations for Isabelle to be able to re-parse terms\". Maybe the other<br>\ndevelopers could comment on the feasibility of this?</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294077193,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829347
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>I would say that the \"show types\" and \"show sorts\" options were designed<br>\nsolely for making terms easier for humans to parse; I don't think any<br>\nguarantees about re-parsing by Isabelle were intended.</p>\n</blockquote>\n<p>'Fraid you are right, Brian. Although these options do help ;-)</p>\n<p>Tobias</p>\n<blockquote>\n<p>On Mon, May 11, 2009 at 6:14 PM, Chris Capel &lt;<a href=\"mailto:pdf23ds@gmail.com\">pdf23ds@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>Is there supposed to be any sort of guarantee of consistency between a<br>\nterm A and the term B that results from printing A and then reading<br>\nthe result, when the \"show types\" option is off? I have found a case<br>\nwhere the types in B are more general, in a way that caused problems<br>\ntrying to do a lemma. I can give more details if desired.</p>\n<p>Chris Capel<br>\n--<br>\n\"What is it like to be a bat? What is it like to bat a bee? What is it<br>\nlike to be a bee being batted? What is it like to be a batted bee?\"<br>\n-- The Mind's I (Hofstadter, Dennet)</p>\n</blockquote>\n</blockquote>",
        "id": 294077202,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829352
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nBrian Huffman wrote:<br>\nI thought a bit about this recently when fiddling with HOL4's<br>\npretty-printer.  In the absence of user code getting in the way, I<br>\nbelieve you can do a reasonable job with the following algorithm:</p>\n<p>* all variables get type annotations<br>\n   * terms with constants at their head, and where the constant \"might<br>\n     be polymorphic\" (see below) get their types printed as well if the<br>\n     constant is applied to n arguments and there are type variables<br>\n     that occur after the nth argument that don't appear in the first<br>\n     n.</p>\n<p>For example, K is a constant with type : 'a -&gt; 'b -&gt; 'a.  If the<br>\n     term is</p>\n<p>K x</p>\n<p>Then the term K x will get a type annotation because the 'b of the<br>\n     term's type doesn't occur among the arguments that are present<br>\n     (the x).  K itself will not get an annotation.</p>\n<p>Nil, the empty list constant, would always get a type annotation<br>\n     in this scheme.  In Isabelle, so too would constants like zero.<br>\n     This is because they are never applied to any arguments, so their<br>\n     polymorphism would always be left dangling.</p>\n<p>The \"might be polymorphic\" test has to do with HOL4's overloading<br>\nsystem.  Terms that are known to print with a form that can in turn<br>\nparse back to multiple possible terms are considered polymorphic, even<br>\nthough they are not in fact polymorphic at all.</p>\n<p>With user code about (users can dynamically update the parser/printer<br>\nsystems with their own code in both Isabelle and HOL4), all bets are<br>\noff of course.</p>\n<p>Michael.</p>",
        "id": 294077521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829437
    }
]