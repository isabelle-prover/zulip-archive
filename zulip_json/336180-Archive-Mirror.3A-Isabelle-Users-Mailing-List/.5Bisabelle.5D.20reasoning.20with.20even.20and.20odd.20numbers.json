[
    {
        "content": "<p>From: Amarin Phaosawasdi &lt;<a href=\"mailto:phaosaw2@illinois.edu\">phaosaw2@illinois.edu</a>&gt;<br>\nHello,</p>\n<p>I have a series of short, related questions regarding reasoning with <br>\neven and odd numbers.</p>\n<p>There are a lot of examples on the inductive definitions of even <br>\nnumbers, such as the following from the book Concrete Semantics.</p>\n<p>inductive ev :: \"nat ⇒ bool\" where<br>\nev0: \"ev 0\" |<br>\nevSS: \"ev n ⟹ ev (n + 2)\"</p>\n<p>Proving that 4 is even can be done like this.</p>\n<p>lemmas four_is_even = evSS[OF evSS[OF ev0]]</p>\n<p>lemma \"ev (Suc(Suc(Suc(Suc 0))))\"<br>\nby (rule four_is_even[simplified])</p>\n<p>Q1: Is there anyway to simplify \"evSS[OF evSS[OF ev0]]\" on the fly such <br>\nthat I don't need the lemma \"four_is_even\"?</p>\n<p>Q2: I am not able to prove \"ev 4\". The closest that I got is this.</p>\n<p>lemma \"ev 4\"<br>\napply (subgoal_tac \"ev (0 + 2 + 2)\")<br>\nsorry</p>\n<p>Simplification just yields \"ev (Suc(Suc(Suc(Suc 0))))\", not \"ev 4\".</p>\n<p>How can I prove \"ev 4\"?</p>\n<p>Q3: I also wanted to prove that \"¬ev 1\", so I tried modifying the <br>\ninductive definition as follows.</p>\n<p>inductive ev :: \"nat ⇒ bool\" where<br>\nev0: \"ev 0\" |<br>\nevS: \"¬ev n ⟹ ev (n + 1)\" |<br>\nevSS: \"ev n ⟹ ev (n + 2)\"</p>\n<p>Isabelle told me that proof failed for the goal.<br>\nmono (λp x. x = 0 ∨ (∃n. x = n + 1 ∧ ¬ p n) ∨ (∃n. x = n + 2 ∧ p n))</p>\n<p>What's going on? If I can't define ev this way, what's the best way to <br>\nprove \"¬ev 1\"</p>\n<p>Maybe the questions weren't that short, sorry about that.</p>\n<p>Any help on any of the questions are much appreciated.</p>\n<p>Thank you,<br>\nAmarin</p>",
        "id": 294317562,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925913
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 15/10/2014 05:37, Amarin Phaosawasdi wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have a series of short, related questions regarding reasoning with even and<br>\nodd numbers.</p>\n<p>There are a lot of examples on the inductive definitions of even numbers, such<br>\nas the following from the book Concrete Semantics.</p>\n<p>inductive ev :: \"nat ⇒ bool\" where<br>\nev0: \"ev 0\" |<br>\nevSS: \"ev n ⟹ ev (n + 2)\"</p>\n</blockquote>\n<p>For a start, note that a bit further down, in the section \"In Isabelle\", the <br>\n\"+2\" is replaced by \"Suc(Suc\". The \"+2\" version was just an intuitive starter.</p>\n<blockquote>\n<p>Proving that 4 is even can be done like this.</p>\n<p>lemmas four_is_even = evSS[OF evSS[OF ev0]]</p>\n<p>lemma \"ev (Suc(Suc(Suc(Suc 0))))\"<br>\nby (rule four_is_even[simplified])</p>\n<p>Q1: Is there anyway to simplify \"evSS[OF evSS[OF ev0]]\" on the fly such that I<br>\ndon't need the lemma \"four_is_even\"?</p>\n</blockquote>\n<p>Yes, you can combine attributes with \",\":<br>\nevSS[OF evSS[OF ev0], simplified]</p>\n<blockquote>\n<p>Q2: I am not able to prove \"ev 4\". The closest that I got is this.</p>\n</blockquote>\n<p>Numerals are distinct from Suc terms.</p>\n<blockquote>\n<p>lemma \"ev 4\"<br>\napply (subgoal_tac \"ev (0 + 2 + 2)\")<br>\nsorry</p>\n<p>Simplification just yields \"ev (Suc(Suc(Suc(Suc 0))))\", not \"ev 4\".</p>\n<p>How can I prove \"ev 4\"?</p>\n</blockquote>\n<p>One possibility:</p>\n<p>lemma \"ev 4\"<br>\nusing evSS[OF evSS[OF ev0]]<br>\nby(simp add: numeral_eq_Suc)</p>\n<p>where numeral_eq_Suc expands numerals to Sc terms. There may also exist a set of <br>\nrules that performs the opposite conversion.</p>\n<blockquote>\n<p>Q3: I also wanted to prove that \"¬ev 1\", so I tried modifying the inductive<br>\ndefinition as follows.</p>\n<p>inductive ev :: \"nat ⇒ bool\" where<br>\nev0: \"ev 0\" |<br>\nevS: \"¬ev n ⟹ ev (n + 1)\" |<br>\nevSS: \"ev n ⟹ ev (n + 2)\"</p>\n</blockquote>\n<p>Rule evS violates the format for inductive definitions (see 4.5.3).</p>\n<blockquote>\n<p>Isabelle told me that proof failed for the goal.<br>\nmono (λp x. x = 0 ∨ (∃n. x = n + 1 ∧ ¬ p n) ∨ (∃n. x = n + 2 ∧ p n))</p>\n<p>What's going on? If I can't define ev this way, what's the best way to prove<br>\n\"¬ev 1\"</p>\n</blockquote>\n<p>You have to rephrase it such that you can apply induction, eg</p>\n<p>ev n ==&gt; n ~= 1</p>\n<p>Tobias</p>\n<blockquote>\n<p>Maybe the questions weren't that short, sorry about that.</p>\n<p>Any help on any of the questions are much appreciated.</p>\n<p>Thank you,<br>\nAmarin</p>\n<p><a href=\"/user_uploads/14278/Z7ZlRgktS2I4c2wHEbQmV4JO/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294317598,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925926
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>On 15/10/14 05:37, Amarin Phaosawasdi wrote:</p>\n<blockquote>\n<p>Q1: Is there anyway to simplify \"evSS[OF evSS[OF ev0]]\" on the fly<br>\nsuch that I don't need the lemma \"four_is_even\"?<br>\nBy ‘simplify’, you probably mean ‘derive automatically’. evSS[OF evSS[OF<br>\nev0]] is basically a ‘hand-crafted proof’ where you put together the<br>\nexisting lemmas by hand to derive a new lemma. Isabelle proof methods<br>\nlike simp and auto basically do the same thing automatically in the<br>\nbackground.</p>\n</blockquote>\n<p>You have correctly deduced that the problem here is that in order to<br>\napply the introduction rules for ev (ev0 and evSS), the goal must be in<br>\nthe shape ‘ev 0’ or ‘ev (n + 2)’. This is what your subgoal_tac achieves.</p>\n<p>When the goal /is/ in that shape, you can simply apply the introduction<br>\nrules for ev to solve it:</p>\n<blockquote>\n<p>apply (rule evSS)<br>\napply (rule evSS)<br>\napply (rule ev0)</p>\n</blockquote>\n<p>Or shorter:</p>\n<blockquote>\n<p>apply (rule evSS ev0)+</p>\n</blockquote>\n<p>Or even shorter:</p>\n<blockquote>\n<p>apply (intro evSS ev0)</p>\n</blockquote>\n<p>Or this:</p>\n<blockquote>\n<p>apply (intro ev.intros)</p>\n</blockquote>\n<p>The entire proof:</p>\n<blockquote>\n<p>lemma \"ev 4\"<br>\nproof-<br>\n  have \"(4::nat) = 0 + 2 + 2\" by simp<br>\n  also have \"ev (0 + 2 + 2)\" by (intro ev.intros)<br>\n  finally show ?thesis .<br>\nqed</p>\n</blockquote>\n<p>Now, as for the matter of getting from ‘4’ to ‘Suc (Suc (Suc (Suc 0)))’:<br>\nthe representation of numeral constants (such as 4) in Isabelle is a bit<br>\ntricky for technical reasons. There is a collection of rewrite rules to<br>\nconvert something like ‘4’ into its ‘Suc’ notation. It is called<br>\neval_nat_numeral. If you write</p>\n<blockquote>\n<p>lemma \"ev 4\"<br>\napply (simp only: eval_nat_numeral)<br>\nyou get the new goal \"ev (Suc (Suc (Suc (Suc 0))))\". You can usually<br>\nalso use ‘simp add: eval_nat_numeral’, the ‘only’ just means that /only/<br>\nthe given rules will be applied, which can be useful sometimes.</p>\n</blockquote>\n<p>The problem is that evSS cannot be applied then, because they want the<br>\nform ‘ev (n + 2)’. Therefore, I would recommend to define the inductive<br>\ndifferently:</p>\n<blockquote>\n<p>inductive ev :: \"nat ⇒ bool\" where<br>\nev0: \"ev 0\" |<br>\nevSS: \"ev n ⟹ ev (Suc (Suc n))\"</p>\n</blockquote>\n<p>Then you can simply prove even ‘ev 1000’ easily:</p>\n<blockquote>\n<p>lemma \"ev 1000\"<br>\n  by (auto simp: eval_nat_numeral intro!: ev.intros)</p>\n</blockquote>\n<p>Alternatively, if you don't want to define the inductive differently,<br>\nyou could just prove a derived introduction rule:</p>\n<blockquote>\n<p>lemma evSS': \"ev n ⟹ ev (Suc (Suc n))\"<br>\n  using evSS by simp<br>\nAnd then you can prove your lemmas with that.</p>\n</blockquote>\n<p>On 15/10/14 05:37, Amarin Phaosawasdi wrote:</p>\n<blockquote>\n<p>Isabelle told me that proof failed for the goal.<br>\nmono (λp x. x = 0 ∨ (∃n. x = n + 1 ∧ ¬ p n) ∨ (∃n. x = n + 2 ∧ p n))<br>\nAs far as I know: inductive definitions require the properties to be<br>\nmonotonic, i.e. among other things you can't have something like ‘¬ev n’<br>\nanywhere in it. This is not an inductive property anymore, you could<br>\notherwise define something silly like ‘¬ev n ⟹ ev n’.</p>\n</blockquote>\n<p>Regardless, you don't need this rule anyway. First of all, it is already<br>\nsubsumed by the other rules and secondly, it does not help you at all in<br>\nproving ‘¬ev 1’. For that, ‘¬ev _’ would have to be on the right-hand<br>\nside of the implication.</p>\n<p>The way to prove ‘¬ev 1’ is by case distinction: if ‘ev 1’ were to hold,<br>\nthen either 1 = 0, which is obviously false, or 1 = Suc (Suc n), which<br>\nis also obviously false. The idea here is that ev is the ‘smallest’<br>\npredicate that fulfils the introduction rules given in its definition,<br>\nso if ‘ev n’ cannot be derived by ev0 and evSS, it is false.</p>\n<p>A simple way to do this case distinction is by using the simplification<br>\nrules for ev, ev.simps:</p>\n<blockquote>\n<p>lemma \"¬ev 1\"<br>\n  by (subst ev.simps) auto<br>\nUsing ev.simps with the ‘simp’ method is not a good idea because it will<br>\nprobably cause the simplifier to loop.</p>\n</blockquote>\n<p>For more complicated examples, you can prove the following (intuitively<br>\nobvious) lemma:</p>\n<blockquote>\n<p>lemma ev_imp_not_ev_Suc: \"ev n ⟹ ¬ev (Suc n)\"<br>\nI will not give you the proof – it can be proven by induction over the<br>\ninductive definition of ‘ev’ and I think it makes a nice exercise. You<br>\nmay also want to look up the ev.cases rule and the ‘inductive_cases’<br>\ncommand.</p>\n</blockquote>\n<p>With that lemma, if you want to prove that something is not even, you<br>\ncan just rewrite it to ‘Suc’ notation with ‘eval_nat_numeral’, apply<br>\nev_imp_not_ev_Suc, and thus reduce the problem to proving that the<br>\npredecessor of the number is even – which you have already done.</p>\n<p>As a side note: with the command ‘code_pred ev .’, you can generate<br>\nexecutable code for the predicate ‘ev’. Then you can check evenness with<br>\n‘value \"ev 3\"’ and even prove or disprove it by using the ‘eval’ method.</p>\n<blockquote>\n<p>lemma \"ev 4\" by eval<br>\nlemma \"¬ev 3\" by eval<br>\nNote that, for technical reasons, a proof involving ‘eval’ is arguably<br>\nnot as nice as a ‘normal’ proof.</p>\n</blockquote>\n<p>Cheers,<br>\nManuel</p>\n<blockquote>\n<p>Q2: I am not able to prove \"ev 4\". The closest that I got is this.</p>\n<p>lemma \"ev 4\"<br>\napply (subgoal_tac \"ev (0 + 2 + 2)\")<br>\nsorry</p>\n<p>Simplification just yields \"ev (Suc(Suc(Suc(Suc 0))))\", not \"ev 4\".</p>\n<p>How can I prove \"ev 4\"?</p>\n<p>Q3: I also wanted to prove that \"¬ev 1\", so I tried modifying the<br>\ninductive definition as follows.</p>\n<p>inductive ev :: \"nat ⇒ bool\" where<br>\nev0: \"ev 0\" |<br>\nevS: \"¬ev n ⟹ ev (n + 1)\" |<br>\nevSS: \"ev n ⟹ ev (n + 2)\"</p>\n<p>Isabelle told me that proof failed for the goal.<br>\nmono (λp x. x = 0 ∨ (∃n. x = n + 1 ∧ ¬ p n) ∨ (∃n. x = n + 2 ∧ p n))</p>\n<p>What's going on? If I can't define ev this way, what's the best way to<br>\nprove \"¬ev 1\"</p>\n<p>Maybe the questions weren't that short, sorry about that.</p>\n<p>Any help on any of the questions are much appreciated.</p>\n<p>Thank you,<br>\nAmarin<br>\n</p>\n</blockquote>",
        "id": 294317605,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925932
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nOther people have answered your questions in detail, but I just wanted to stress one point about inductive definitions. They give you rules for building up the elements of a set (equivalently, for constructing elements were a predicate is true), but the negative cases are implicit. Therefore, once you have defined the notion of even, you have also defined the notion of odd. And inductive references in the rules can only be positive. You should regard the rules as stating “0 is even”; “if N is even then so is N 2”; \"there are no other even numbers”. A statement such as “if N is odd then N+1 is even” should be provable.</p>\n<p>Larry Paulson</p>",
        "id": 294317626,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660925937
    },
    {
        "content": "<p>From: Amarin Phaosawasdi &lt;<a href=\"mailto:phaosaw2@illinois.edu\">phaosaw2@illinois.edu</a>&gt;<br>\nThank you.</p>\n<p>Is there a difference between using a proof vs adding it to simp like this?</p>\n<p>lemma \"ev 4\"<br>\nby (simp add: numeral_eq_Suc evSS[OF evSS[OF ev0]])</p>\n<p>Amarin</p>",
        "id": 294317925,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926023
    },
    {
        "content": "<p>From: Amarin Phaosawasdi &lt;<a href=\"mailto:phaosaw2@illinois.edu\">phaosaw2@illinois.edu</a>&gt;<br>\nAh, this makes things clearer, thank you.</p>\n<p>Amarin</p>",
        "id": 294317944,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926030
    },
    {
        "content": "<p>From: Amarin Phaosawasdi &lt;<a href=\"mailto:phaosaw2@illinois.edu\">phaosaw2@illinois.edu</a>&gt;<br>\nI definitely learned a lot here. Thanks.<br>\nHere's one way I did it.</p>\n<p>lemma suc0:\"¬ev (Suc 0)\"<br>\nby (subst ev.simps, simp)</p>\n<p>lemma sucSS:\"⋀n. ev n ⟹ ¬ ev (Suc n) ⟹ ¬ ev (Suc (Suc (Suc n)))\"<br>\nby (erule ev.cases) (subst ev.simps, simp)+</p>\n<p>lemma \"ev n ⟹ ¬ev (Suc n)\"<br>\nby (induction rule: ev.induct) (simp add: suc0 sucSS)+</p>\n<p>The other way, as you hinted, was adding the elimination rules so that <br>\nauto can use them.</p>\n<p>inductive_cases evE[elim!]: \"ev n\"<br>\nlemma \"ev n ⟹ ¬ev (Suc n)\"<br>\nby (induction rule: ev.induct) auto</p>\n<p>I'm a little curious though.</p>\n<p>How did evE[elim!] help me with, for example, \"¬ev (Suc 0)\"?</p>\n<p>As you can see above, without evE, I would prove it as follows.</p>\n<p>lemma \"¬ev (Suc 0)\"<br>\nby (subst ev.simps, simp)</p>\n<p>But with it, I can simply do.</p>\n<p>lemma \"¬ev (Suc 0)\"<br>\nby auto</p>\n<p>How would I prove \"¬ev (Suc 0)\" using evE (or ev.cases) explicitly the <br>\nway that auto is presumably using behind the scenes?</p>\n<p>Amarin</p>",
        "id": 294317952,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926036
    },
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>The typical way of proving negations is by assuming the statement holds<br>\nand deriving False. You can do<br>\nthis with the rule notI:</p>\n<p>lemma \"¬ev (Suc 0)\"<br>\n    apply (rule notI)</p>\n<p>This leaves you with</p>\n<p>goal (1 subgoal):</p>\n<p>1. ev (Suc 0) ⟹ False</p>\n<p>Now you can use evE to perform a case distinction on ‘ev (Suc 0)’: if<br>\n‘ev (Suc 0)’ holds, it was either derived by ev0 (in which case ‘Suc 0’<br>\nwould have to be ‘0’) or it was derived by evSS (in which case ‘Suc 0’<br>\nwould have to be ‘Suc (Suc n)’ for some n). Both are trivially false and<br>\ncan be discharged by ‘simp_all’.</p>\n<p>lemma \"¬ev (Suc 0)\"<br>\n    apply (rule notI)<br>\n    apply (erule evE)<br>\n    apply simp_all<br>\n    done</p>\n<p>It should be mentioned that your evE is the same as the<br>\nautomatically-proved ev.cases. inductive_cases is for deriving more<br>\nspecialised elimination rules, i.e. ones where you don't have ‘ev n’,<br>\nbut something more restricted, such as ‘ev 0’ or ‘ev (Suc n)’ or ‘ev<br>\n(Suc (Suc n))’. inductive_cases simply uses the ev.cases rule and<br>\nperforms some simplification on it. In your case, you could do the<br>\nfollowing:</p>\n<p>inductive_cases evS: \"ev (Suc n)\"</p>\n<p>Then, in the above proof of ‘¬ev (Suc 0)’, you applying the elimination<br>\nrule would leave you with the goal ‘Suc 0 = 0’. In this case, it doesn't<br>\nmake much difference though – you might as well just use ev.cases.</p>\n<p>Also, I would like to say that declaring rules as elimination rules<br>\n([elim]), especially safe ones ([elim!]) should be done with care. The<br>\nevE rule you defined is probably not a good choice for an automatic<br>\nelimination rule, since it doesn't always make the goal ‘simpler’ and<br>\ncan be applied infinitely often, blowing the goal up indefinitely. In<br>\nthese examples, it all works out, but in more complicated ones, auto<br>\n(and force, blast, etc.) might loop because of it, applying the rule<br>\ninfinitely often.</p>\n<p>Cheers,<br>\nManuel</p>",
        "id": 294317970,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926043
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nOn 19/10/2014 19:52, Amarin Phaosawasdi wrote:</p>\n<blockquote>\n<blockquote>\n<p>One possibility:</p>\n<p>lemma \"ev 4\"<br>\nusing evSS[OF evSS[OF ev0]]<br>\nby(simp add: numeral_eq_Suc)</p>\n<p>Thank you.</p>\n</blockquote>\n<p>Is there a difference between using a proof vs adding it to simp like this?</p>\n</blockquote>\n<p>Yes, with \"using\" the fact becomes part of the proof state and is simplified itself.</p>\n<p>Tobias</p>\n<blockquote>\n<p>lemma \"ev 4\"<br>\nby (simp add: numeral_eq_Suc evSS[OF evSS[OF ev0]])</p>\n<p>Amarin</p>\n<p><a href=\"/user_uploads/14278/DgpRuucGECuYfHBJPkEwyB94/smime.p7s\">smime.p7s</a></p>\n</blockquote>",
        "id": 294318030,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926067
    }
]