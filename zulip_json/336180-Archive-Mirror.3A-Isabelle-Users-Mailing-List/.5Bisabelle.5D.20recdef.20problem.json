[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:christian.sternagel@uibk.ac.at\">christian.sternagel@uibk.ac.at</a>&gt;<br>\nIn <code>Isabelle/HOL - A Proof Assistant for Higher-Order Logic' ([1] in the following) </code>recdef' is used to define functions for the datatype</p>\n<p>datatype ('v,'f)\"term\" =<br>\n    Var 'v<br>\n  | Fun 'f \"('v,'f)term list\"</p>\n<p>For me it gets interesting as soon as higher-order functions can be used to define functions with `recdef'. In [1] there is following example:</p>\n<p>consts trev :: \"('v,'f)term =&gt; ('v,'f)term\"<br>\n recdef trev \"measure size\"<br>\n  \"trev (Var x) = Var x\"<br>\n  \"trev (Fun f ts) = Fun f (rev (map trev ts))\"</p>\n<p>which could be proved terminating after the hint </p>\n<p>t : set ts --&gt; size t &lt; Suc (term_list_size ts)</p>\n<p>I wanted to define following function (which gives the set of positions of a term---where a position is a possibly empty list of natural numbers):</p>\n<p>consts pos :: \"('v,'f)term =&gt; nat list set\"<br>\n  recdef pos \"measure (% t. size t)\"<br>\n   \"pos (Var v) = {[]}\"<br>\n   \"pos (Fun f ts) = <br>\n    {[]} Un {(i#p) | i p. i : {0..&lt;length ts} &amp; p : pos (ts!i)}\"</p>\n<p>which is not possible automatically because of the unsolved goal:</p>\n<p>\\&lt;forall&gt; :001 ts. size (ts ! :001) &lt; Suc (term_list_size ts)</p>\n<p>now my questions:<br>\n1) what does :001 mean (I just assumed its the index variable i from my definition).<br>\n2) why is the information i : {0..&lt;length ts} lost, which would make the unsolved goal equivalent to: </p>\n<p>t : set ts --&gt; size t &lt; Suc (term_list_size ts)</p>\n<p>3) is it possible to do a termination proof for a recdef definition fully by hand in order to make sure, that i : {0..&lt;length ts} is used?</p>\n<p>Thanks in advance.</p>\n<p>cheers</p>\n<p>christian sternagel</p>",
        "id": 294046842,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817635
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nChristian,</p>\n<blockquote>\n<p>I wanted to define following function (which gives the set of   <br>\npositions of a term---where a position is a possibly empty list of   <br>\nnatural numbers):</p>\n<p>consts pos :: \"('v,'f)term =&gt; nat list set\"<br>\n  recdef pos \"measure (% t. size t)\"<br>\n   \"pos (Var v) = {[]}\"<br>\n   \"pos (Fun f ts) =<br>\n    {[]} Un {(i#p) | i p. i : {0..&lt;length ts} &amp; p : pos (ts!i)}\"</p>\n<p>which is not possible automatically because of the unsolved goal:</p>\n<p>\\&lt;forall&gt; :001 ts. size (ts ! :001) &lt; Suc (term_list_size ts)</p>\n<p>now my questions:<br>\n1) what does :001 mean (I just assumed its the index variable i from  <br>\n my definition).</p>\n</blockquote>\n<p>It's an internal variable produced by the simplifier. I am not sure why<br>\nyou get to see this strange name, but reading it as \"i\" is probably just<br>\nright.</p>\n<blockquote>\n<p>2) why is the information i : {0..&lt;length ts} lost, which would make  <br>\n the unsolved goal equivalent to:</p>\n</blockquote>\n<p>You are missing a congruence rule here. Congruence rules are needed for recdef<br>\nto know at which values the recursive call actually occurs. In your  <br>\nexample, the<br>\nfollowing congruence rule for conjunction helps:</p>\n<p>lemma conj_cong[recdef_cong]:<br>\n   \"[| A = A'; A' ==&gt; B = B' |] ==&gt; A &amp; B = A' &amp; B' \"<br>\nby blast</p>\n<p>In the second premise, you see the hypothesis A'. This gives you the  <br>\nextra hypothesis for the termination proof.</p>\n<p>You can see congruence rules as if they express something about evaluation<br>\norder, which is not otherwise defined, since we're just doing logic. By giving<br>\nthis congruence rule to recdef you state (and have proved) that the  <br>\nsecond part of the conjunction only relevant if the first part is  <br>\nsatisfied. In the tutorial<br>\n(end of 9.2.2) this is only mentioned briefly, but the example given  <br>\nthere works<br>\nout-of-the-box, because the map_cong rule is there already (and  <br>\nconj_cong should<br>\nprobably also be). In general you need a suitable congruence rule for every<br>\nhigher-order combinator you use in the definition.</p>\n<p>You can see the preconfigured congruence rules by issuing</p>\n<p>ML \"RecdefPackage.print_recdefs (the_context ())\"</p>\n<p>By looking at some of them you will quickly learn how to make your own ones if<br>\nyou need them.</p>\n<blockquote>\n<p>3) is it possible to do a termination proof for a recdef definition   <br>\nfully by hand in order to make sure, that i : {0..&lt;length ts} is used?</p>\n</blockquote>\n<p>Yes you can, by a largely unkown feature:</p>\n<p>Issue your recdef definition using the \"permissive\" keyword:</p>\n<p>recdef (permissive) pos ....</p>\n<p>Then the defintion goes through, but the unproven termination  <br>\nconditions end up as premises of the pos.simps rules:</p>\n<p>thm pos.simps</p>\n<p>Then you can set up a manual proof by</p>\n<p>recdef_tc abc: pos</p>\n<p>and when you have finished the proof, the lemmas will be stored as \"abc\". You<br>\nwill still have to remove the premises manually from pos.simps though.</p>\n<p>The above information is for Isabelle 2005. In the developer snapshot  <br>\nyou would<br>\ninstead use the new \"function\" package. There, handling termination proofs is<br>\neasier and can be done manually, but the issue with congruence rules remains.</p>\n<p>Hope this helps...</p>\n<p>Alex</p>",
        "id": 294046952,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660817680
    }
]