[
    {
        "content": "<p>From: Anh Le &lt;<a href=\"mailto:anhlevn@cims.nyu.edu\">anhlevn@cims.nyu.edu</a>&gt;<br>\nHi everyone,<br>\nI am reading some Isabelle code (proving type safety of Featherweight Java).</p>\n<p>A primitive recursion is defined below, where the function subst_list is<br>\ndefined twice, exactly the same, with two different names: subst_list1 and<br>\nsubst_list2.<br>\nI though it was redundant and removes one of them, and renamed the other to<br>\nsubst_list. But then Isabelle showed an error, which is inconsistent<br>\nfunction error.<br>\nSo my question is why isabelle requires those duplicated equations? is there<br>\nany way that we can just define only one function subst_list?</p>\n<p>Thank you very much<br>\nAnh</p>\n<p>primrec<br>\n  substs :: \"(varName \\&lt;rightharpoonup&gt; exp) \\&lt;Rightarrow&gt; exp \\&lt;Rightarrow&gt;<br>\nexp\"<br>\n  and subst_list1 :: \"(varName \\&lt;rightharpoonup&gt; exp) \\&lt;Rightarrow&gt; exp list<br>\n\\&lt;Rightarrow&gt; exp list\"<br>\n  and subst_list2 :: \"(varName \\&lt;rightharpoonup&gt; exp) \\&lt;Rightarrow&gt; exp list<br>\n\\&lt;Rightarrow&gt; exp list\"</p>\n<p>where<br>\n  \"substs sub (Var x) = (case (sub(x)) of None \\&lt;Rightarrow&gt; (Var x) | Some<br>\np \\&lt;Rightarrow&gt; p)\" |<br>\n  \"substs sub (FieldProj e f) = FieldProj(substs sub e) f\" |<br>\n  \"substs sub (MethodInvk e m es) = MethodInvk (substs sub e) m<br>\n                                               (subst_list1 sub es)\" |<br>\n  \"substs sub (New C es) = New C (subst_list2 sub es)\" |<br>\n  \"substs sub (Cast C e) = Cast C (substs sub e)\" |</p>\n<p>\"subst_list1 sub [] = []\" |<br>\n  \"subst_list2 sub (h # t) = (substs sub h) # (subst_list sub t)\" |</p>\n<p>\"subst_list2 sub [] = []\" |<br>\n  \"subst_list2 sub (h # t) = (substs sub h) # (subst_list2 sub t)\"</p>",
        "id": 294136305,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844431
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Anh,</p>\n<p>restrictions of the primrec and datatype package is the reason for two versions <br>\nof subst_list. As I gather from the function definition of substs, the exp <br>\ndatatype looks something like this:</p>\n<p>datatype exp<br>\n   = Var vname<br>\n   | FieldProj exp fname<br>\n   | MethodInvk exp mname \"exp list\"<br>\n   | New cname \"exp list\"<br>\n   | Cast cname exp</p>\n<p>The problem here is that the two constructors MethodInvk and New both take a <br>\n<em>list</em> of expressions. The datatype package unfolds nested recursion in datatype <br>\ndeclarations into primitive recursion by mutual recursion, see Section 3.4.2 of <br>\nthe Isabelle/HOL tutorial. Since nested recursion occurs twice, the datatype <br>\npackage inlines the list datatype twice. This can also be seen in the induction <br>\nrule foo.induct and the recursion combinators foo_rec_1, foo_rec_2 and foo_rec3.</p>\n<p>primrec expects the function definition to strictly follow the induction rule <br>\nand the recursion combinators. Hence, there must be two definitions of subst_list.</p>\n<p>The fun command allows more general recursion. By replacing primrec with fun, <br>\nyou may get rid of the duplicated subst_list functions. fun also proves an <br>\ninduction rule for proofs about substs.</p>\n<p>Andreas</p>\n<p>Anh Le schrieb:</p>",
        "id": 294136308,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844433
    }
]