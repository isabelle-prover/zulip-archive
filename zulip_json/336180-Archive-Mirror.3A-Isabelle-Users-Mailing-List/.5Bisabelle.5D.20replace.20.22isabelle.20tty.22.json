[
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nHi Lars,</p>\n<p>with great interest I studied your code [1] (cited below), followed the <br>\nfunction calls into <del>/src/Pure/System, </del>/src/Pure/PIDE etc and tried <br>\nto understand.</p>\n<p>So far I understood, that<br>\n(1) Session.protocol_handler starts a persistent session<br>\n(2) Isabelle_Process.protocol_command takes a string list, interpretes <br>\nthe strings, accordingly executes a predefined collection of ML <br>\nfunctions and returns results as strings.</p>\n<p>However, I could not yet find out, how to use isabelle_process or the <br>\nisabelle wrapper (or what else?) to feed the strings such that they <br>\ndrive (1) and (2).</p>\n<p>Could you, please, help once more?</p>\n<p>Walther</p>",
        "id": 294319015,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926337
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHello,</p>\n<blockquote>\n<p>So far I understood, that<br>\n(1) Session.protocol_handler starts a persistent session</p>\n</blockquote>\n<p>it works in the opposite direction. The JVM process spins up a prover<br>\nprocess. Then, the protocol is initialized and both sides \"register\"<br>\nsome handler for bidirectional communication. That is,<br>\n\"Session.protocol_handler\" tells the JVM that the specified class should<br>\nreceive messages from the prover.</p>\n<blockquote>\n<p>(2) Isabelle_Process.protocol_command takes a string list, interpretes<br>\nthe strings, accordingly executes a predefined collection of ML<br>\nfunctions and returns results as strings.</p>\n</blockquote>\n<p>\"protocol_command\" is in some sense \"dual\" to \"protocol_handler\": it<br>\ntells the prover that the specified function should receive messages<br>\nfrom the JVM. You're correct in that the function is called with some<br>\nstrings and can then do whatever is necessary. However, it does not<br>\nactually return anything.</p>\n<p>Bi-directional communication in the PIDE model is message-driven. That<br>\nmeans that sending data has a \"fire and forget\" semantics: It<br>\nimmediately returns and there's no waiting for a reply or anything. Both<br>\nJVM and prover can send messages to each other at any point in time.</p>\n<p>In the sources, you can see that the \"exec\" function actually always<br>\nsends a reply, but does so via \"protocol_message\", which generates a new<br>\nmessage which is completely independent from the one the handler<br>\nreceived earlier.</p>\n<blockquote>\n<p>However, I could not yet find out, how to use isabelle_process or the<br>\nisabelle wrapper (or what else?) to feed the strings such that they<br>\ndrive (1) and (2).</p>\n</blockquote>\n<p>As written above, your JVM application drives the whole process. You<br>\ninvoke the appropriate functions for starting up the prover, load the<br>\n\"Isac\" section where your handler is waiting for input. Then you can<br>\nsend messages to your handler.</p>\n<p>I hope that sheds some light onto the somewhat delicate procedure. We<br>\ncould definitely do with more documentation on the system integration<br>\naspect of Isabelle/Scala (which would presumably go into system.pdf,<br>\nwhose chapter on that topic is very sparse). I reckon that with the<br>\nremoval of \"isabelle tty\", more applications of Isabelle/Scala will emerge.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294319062,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926349
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 21 Nov 2014, Lars Hupel wrote:</p>\n<blockquote>\n<p>I hope that sheds some light onto the somewhat delicate procedure. We<br>\ncould definitely do with more documentation on the system integration<br>\naspect of Isabelle/Scala (which would presumably go into system.pdf,<br>\nwhose chapter on that topic is very sparse).</p>\n</blockquote>\n<p>Isabelle/Scala is indeed the main system programming language for <br>\nIsabelle, so the manual should say more about it.  The reason why so <br>\nlittle Isabelle/Scala is in the manuals is that code snippets cannot be <br>\nformally checked, as is done for Isabelle/ML. Without formal checking, it <br>\nis pointless to make examples, because they will stop working in no time,<br>\nafter the next round of refinements of the system implementation.</p>\n<blockquote>\n<p>I reckon that with the removal of \"isabelle tty\", more applications of <br>\nIsabelle/Scala will emerge.</p>\n</blockquote>\n<p>Probably yes, and for two reasons:</p>\n<p>(1) Without the TTY baggage it becomes more feasible to introduce formal<br>\n       Isabelle/Scala checking in the documentation, in the sense above.</p>\n<p>(2) Removal of obsolete things makes people active, who are still using<br>\n       very old archeological layers of the system.  Actual use of new<br>\n       programming interfaces always helps to make them more smooth and<br>\n       easier to use.</p>\n<p>The Isabelle process protocol concepts covered here are in fact already <br>\nquite well-established and polished for some years. So now is the right <br>\ntime to convert old applications, and to forget that there was ever a TTY <br>\nloop in Isabelle.</p>\n<p>Makarius</p>\n<hr>\n<p><a href=\"http://stop-ttip.org\">http://stop-ttip.org</a>  925,281 people so far</p>\n<hr>",
        "id": 294319097,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926356
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nIndeed.</p>\n<p>What could be done is writing a minimal PIDE application demonstrating<br>\nbi-directional communication, possibly in the style of literate<br>\nprogramming. This could then be executed and tested as part of a regular<br>\n(nightly?) build against the repository version.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294319264,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926385
    },
    {
        "content": "<p>From: Cezary Kaliszyk &lt;<a href=\"mailto:cezarykaliszyk@gmail.com\">cezarykaliszyk@gmail.com</a>&gt;<br>\nDear Walther,</p>\n<p>There is also a different approach to simulating the TTY/ProofGeneral<br>\ninteraction with Isabelle.</p>\n<p>I have written a small 20-line script that lets me imitate<br>\nminimal Isar-interaction via isabelle-console. It only allows<br>\nsending single lines to Isabelle, there is no \"back\" or error<br>\nhandling, but this is enough for simple sending of commands to<br>\nIsabelle and analysing their outputs.</p>\n<p>The reason why I use this script, is because I use Isabelle<br>\non a headless server. It has enough memory to do bigger<br>\nexperiments, but I cannot run graphical applications there,<br>\nin particular I cannot run PIDE. As ProofGeneral and TTY<br>\nsupport have been removed, I needed to implement some minimal<br>\ninteraction, and the minimum, following the indispensable<br>\nhelp from Makarius is:</p>\n<p>The script runs:<br>\n  \"isabelle console\",<br>\nThen sends it:<br>\n  \"val s = Toplevel.toplevel;\"<br>\nAnd for every line of user input sends:<br>\n  \"val s = fold (Toplevel.command_exception true) (Outer_Syntax.parse<br>\nPosition.start \\\"%s\\\") s;\"</p>\n<p>I suppose this could be extended to support a \"go-back\" or even<br>\nsome more complicated protocol like the one from ProofGeneral<br>\nwhich I presume you are currently using.</p>\n<p>Attached, sorry for yet another programming language, but the<br>\nabove should explain it.</p>\n<p>Regards,</p>\n<p>Cezary<br>\n<a href=\"/user_uploads/14278/mSSFu86sf6e6iXweP65vq2OX/isatty.ml\">isatty.ml</a></p>",
        "id": 294319350,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926406
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nDear Cezary,</p>\n<p>thank you for the surprising mini-solution ...</p>\n<p>... we have an even simpler protocol than ProofGeneral, so your solution <br>\nwould be quite appropriate for a quick shortcut.</p>\n<p>Such a shortcut would be necessary, if the efforts required for a <br>\nsolution via Isabelle/Scala would be beyond our present resources.</p>\n<p>So, probably we come back to your solution after some trials.</p>\n<p>Regards,<br>\nWalther</p>",
        "id": 294319357,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926410
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nLars,</p>\n<p>thank you for the helpful explanations.</p>\n<p>Now I studied [2] and see, that this scala colde establishes the other <br>\nside for communication with Session.protocol_handler and <br>\nIsabelle_Process.protocol_command from [1].<br>\nSo I prepare to adapt both [1]+[2] for Isac and come back to your <br>\ndiscussion with Makarius:</p>\n<blockquote>\n<blockquote>\n<p>My impression in<br>\nthe past 7 years was that these things do change between major releases<br>\nof Scala, and direct Java access is not properly supported.</p>\n</blockquote>\n<p>Indeed. The only guarantee is calling Java from Scala, and even that<br>\nbreaks from time to time because of mismatches between their type systems.<br>\n;-(( we need to call Scala from Java</p>\n<blockquote>\n<p>The Isabelle/Scala attitude towards that problem is to ask users to<br>\nwrite their own little Scala module to access the PIDE infrastructure,<br>\nand expose it to an existing Java program, if they really have to.</p>\n</blockquote>\n<p>Exactly. If there are only a handful of different commands which need to<br>\nbe supported, such a wrapper seems to be the best idea. But even then,<br>\none needs to think about whether the interaction is supposed to be<br>\nasynchronous, because Java is lacking in that regard.</p>\n</blockquote>\n<p>In order to start with a minimal solution, I'd like to bypass <br>\nasynchronous interaction (which is no restriction on Isac's present <br>\nsolution).</p>\n<p>First question: what is your experience with NetBeans versus Eclipse in <br>\nprojects combining Java and Scala?</p>\n<p>Walther</p>\n<p>[1]<br>\n&lt;<a href=\"https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/isabelle/Isabelle_Leon/Protocol.thy#L248-L264\">https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/isabelle/Isabelle_Leon/Protocol.thy#L248-L264</a>&gt;</p>\n<p>[2]<br>\n&lt;<a href=\"https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/scala/leon/solvers/isa/System.scala\">https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/scala/leon/solvers/isa/System.scala</a>&gt;</p>\n<p>On 14-11-21 09:51 AM, Lars Hupel wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<blockquote>\n<p>So far I understood, that<br>\n(1) Session.protocol_handler starts a persistent session<br>\nit works in the opposite direction. The JVM process spins up a prover<br>\nprocess. Then, the protocol is initialized and both sides \"register\"<br>\nsome handler for bidirectional communication. That is,<br>\n\"Session.protocol_handler\" tells the JVM that the specified class should<br>\nreceive messages from the prover.</p>\n</blockquote>\n<blockquote>\n<p>(2) Isabelle_Process.protocol_command takes a string list, interpretes<br>\nthe strings, accordingly executes a predefined collection of ML<br>\nfunctions and returns results as strings.<br>\n\"protocol_command\" is in some sense \"dual\" to \"protocol_handler\": it<br>\ntells the prover that the specified function should receive messages<br>\nfrom the JVM. You're correct in that the function is called with some<br>\nstrings and can then do whatever is necessary. However, it does not<br>\nactually return anything.</p>\n</blockquote>\n<p>Bi-directional communication in the PIDE model is message-driven. That<br>\nmeans that sending data has a \"fire and forget\" semantics: It<br>\nimmediately returns and there's no waiting for a reply or anything. Both<br>\nJVM and prover can send messages to each other at any point in time.</p>\n<p>In the sources, you can see that the \"exec\" function actually always<br>\nsends a reply, but does so via \"protocol_message\", which generates a new<br>\nmessage which is completely independent from the one the handler<br>\nreceived earlier.</p>\n<blockquote>\n<p>However, I could not yet find out, how to use isabelle_process or the<br>\nisabelle wrapper (or what else?) to feed the strings such that they<br>\ndrive (1) and (2).<br>\nAs written above, your JVM application drives the whole process. You<br>\ninvoke the appropriate functions for starting up the prover, load the<br>\n\"Isac\" section where your handler is waiting for input. Then you can<br>\nsend messages to your handler.</p>\n</blockquote>\n<p>I hope that sheds some light onto the somewhat delicate procedure. We<br>\ncould definitely do with more documentation on the system integration<br>\naspect of Isabelle/Scala (which would presumably go into system.pdf,<br>\nwhose chapter on that topic is very sparse). I reckon that with the<br>\nremoval of \"isabelle tty\", more applications of Isabelle/Scala will emerge.</p>\n<p>Cheers<br>\nLars</p>\n</blockquote>",
        "id": 294319386,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926416
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe problem posed here is technically trivial, i.e. a non-problem.  It is <br>\njust a matter to overcome old ways of thinking about it.</p>\n<p>Isabelle/Scala is well-established as the main system programming <br>\ninterface for several years.  When you want to connect to some Isabelle <br>\nprover process, the Scala APIs are the way to do it.</p>\n<p>Pretty soon, it will be no longer possible to use the Isabelle process at <br>\nall, without the Scala process around it.  The remaining TTY loop was <br>\nhindering important reforms long enough.  After Isabelle2014 it is no <br>\nlonger there, without any traces of it left.</p>\n<p>Then it becomes possible to assume that things like Invoke_Scala.method <br>\nwork in Isabelle/ML all the time, and many problems from the past can be <br>\nresolved in the proper way.  (E.g. a brushed-up version of document <br>\npreparation.)</p>\n<p>Makarius</p>\n<hr>\n<p><a href=\"http://stop-ttip.org\">http://stop-ttip.org</a>  927,487 people so far</p>\n<hr>",
        "id": 294319697,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926484
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 21 Nov 2014, Walther Neuper wrote:</p>\n<blockquote>\n<p>In order to start with a minimal solution, I'd like to bypass <br>\nasynchronous interaction (which is no restriction on Isac's present <br>\nsolution).</p>\n</blockquote>\n<p>Asynchronous interaction is already the minimal solution.  It is simpler <br>\nthan synchronous interaction in many ways.</p>\n<p>Just give up the notion that you are mutating an implicit \"current state\". <br>\nYou can easily pass around explicit handles to immutable values that are <br>\nbounced back and forth between the ML and Scala process in an asynchronous <br>\nmanner.</p>\n<p>The application by Lars demonstrates that nicely.</p>\n<blockquote>\n<p>First question: what is your experience with NetBeans versus Eclipse in <br>\nprojects combining Java and Scala?</p>\n</blockquote>\n<p>The current high-end IDE is probably IntelliJ IDEA, but I am using myself <br>\njust jEdit as plain text editor for Scala.</p>\n<p>Makarius</p>\n<hr>\n<p><a href=\"http://stop-ttip.org\">http://stop-ttip.org</a>  927,491 people so far</p>\n<hr>",
        "id": 294319714,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926489
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>First question: what is your experience with NetBeans versus Eclipse in<br>\nprojects combining Java and Scala?</p>\n</blockquote>\n<p>Last time I used NetBeans with Scala was in 2010. It was quite unstable,<br>\nand when I revisited it a couple of months ago, the situation has not<br>\nimproved significantly.</p>\n<p>IntelliJ is good, but implements its own type checker for Scala which<br>\nmay or may not agree with the official Scala compiler. I found its \"type<br>\naware\" highlighting annoying to use because of spurious error markers.</p>\n<p>The recommended IDE to use with Scala/Java is Eclipse. It is<br>\ncommercially supported from Typesafe and should be stable enough. I<br>\ndon't have practical experience with it, though.</p>",
        "id": 294319826,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926526
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nConcerning the general topic of the relation Isabelle/Scala/PIDE vs. the <br>\nnow removed TTY / Proof General interaction mode, see also this blog entry <br>\nof mine: <a href=\"http://sketis.net/2014/discontinuation-of-isabelle-proof-general\">http://sketis.net/2014/discontinuation-of-isabelle-proof-general</a></p>\n<p>Makarius</p>\n<hr>\n<p><a href=\"http://stop-ttip.org\">http://stop-ttip.org</a>  935,236 people so far</p>\n<hr>",
        "id": 294319880,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660926539
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nWe did not engage for \"Remaining uses of Proof General\" because we hope <br>\nfor easy ways to replace \"isabelle tty\" in our prototype, and because we <br>\nlook forward to replace our self-made front-end by Isabelle/jEdit as <br>\nsoon as Isabelle goes collaboration and includes session management.</p>\n<p>Until Isabelle2013-2, our prototype had the communication between its <br>\nfront-end (client) in Java and its mathematics-engine (server) in <br>\nIsabelle/ML via stdin/stdout of the server process:</p>\n<p>(a) Java started the server by<br>\n      \"isabelle tty -l Isac\"<br>\n(b) the first text line written to stdin was<br>\n      \"theory TTY_Communication imports Build_Isac begin\"<br>\n(c) the client requests were ML functions   f : a1 -&gt; .. -&gt; an -&gt; unit<br>\n      written to stdin as text \"ML {* f a1 .. an *}\"<br>\n(d) the functions f wrote data in XML-format, which was read from stdout<br>\n      by a Java XML parser.</p>\n<p>We want to invest into replacement of this outdated communication the <br>\nmore, the closer Isabelle comes to a session management. So presently <br>\nour questions are</p>\n<p>(1) Is the code around the removed \"isabelle tty\" already stable enough <br>\nto start replacement of \"isabelle tty\" in our project now ?<br>\n(2) If \"yes\", what are the options to replace the above (a..d) \"isabelle <br>\ntty\" communication in our prototype ? Where should we start to look to <br>\nin the Isabelle code ?</p>\n<p>We are aware, that the above questions are at the borderline of this <br>\nmailing list's scope --- so we are really grateful for any help!</p>\n<p>Walther</p>\n<p>[1] <a href=\"http://www.ist.tugraz.at/isac\">http://www.ist.tugraz.at/isac</a></p>",
        "id": 294322197,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927269
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHello,</p>\n<blockquote>\n<p>(d) the functions f wrote data in XML-format, which was read from<br>\nstdout by a Java XML parser.</p>\n</blockquote>\n<p>firstly, I'm going to assume that your front end is running on the JVM.</p>\n<p>I did something highly relevant in August, when I was visiting Viktor<br>\nKuncak's group at EPFL. There, I integrated Isabelle into their existing<br>\nsystem which was written in Scala.</p>\n<p>This was really easy, because the protocol with which the prover and<br>\nIsabelle/jEdit communicate is exposed as a somewhat stable API. By<br>\nputting a specific JAR file (\"Pure.jar\" somewhere in $ISABELLE_HOME) in<br>\nyour client's classpath, you have access to all the necessary<br>\nfunctionality (i.e. spawning up a prover, sending protocol messages etc.).</p>\n<blockquote>\n<p>(a) Java started the server by<br>\n     \"isabelle tty -l Isac\"<br>\n(b) the first text line written to stdin was<br>\n     \"theory TTY_Communication imports Build_Isac begin\"</p>\n</blockquote>\n<p>This can be trivially done with the above mechanism. You can even<br>\ntrigger the build of the \"Isac\" session first.</p>\n<blockquote>\n<p>(c) the client requests were ML functions   f : a1 -&gt; .. -&gt; an -&gt; unit<br>\n     written to stdin as text \"ML {* f a1 .. an *}\"</p>\n</blockquote>\n<p>This is more interesting. Is the scope of what these functions do<br>\nlimited, or can the user somehow specify arbitrary functions?</p>\n<p>If the scope is limited, then you can do something like [1] and treat<br>\nthe prover process as some sort of \"REPL\" which only understands a fixed<br>\nset of commands and acts accordingly. Notably, the support of multiple<br>\nclients in a single Isabelle session is almost trivial.</p>\n<p>If not, there should be a way to make it work (after all, an ML block is<br>\na regular command), but I can't offer any concrete advice there, except<br>\nmaybe studying the implementation of the ML and ML_val commands in Isar.</p>\n<blockquote>\n<p>(1) Is the code around the removed \"isabelle tty\" already stable enough<br>\nto start replacement of \"isabelle tty\" in our project now ?</p>\n</blockquote>\n<p>I would say yes, even though a canonical discipline on how to write an<br>\napplication using only a minimal subset of the features of PIDE has not<br>\nemerged yet.</p>\n<blockquote>\n<p>(2) If \"yes\", what are the options to replace the above (a..d) \"isabelle<br>\ntty\" communication in our prototype ? Where should we start to look to<br>\nin the Isabelle code ?</p>\n</blockquote>\n<p>The other relevant bit in the code I wrote at EPFL is [2], although it<br>\nis cluttered with rather ad hoc session management required by the<br>\nsystem I was integrating with. If you're inclined, I can put together a<br>\nsmaller example which should be sufficient to demonstrate the general<br>\npatterns.</p>\n<p>There's one caveat left: All of the above presumes that using Scala is<br>\nnot a problem. It's certainly possible to do all of the above with Java,<br>\nalthough I guess it's going to be rather verbose syntactically.</p>\n<p>Cheers<br>\nLars</p>\n<p>[1]<br>\n&lt;<a href=\"https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/isabelle/Isabelle_Leon/Protocol.thy#L248-L264\">https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/isabelle/Isabelle_Leon/Protocol.thy#L248-L264</a>&gt;</p>\n<p>[2]<br>\n&lt;<a href=\"https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/scala/leon/solvers/isa/System.scala\">https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/scala/leon/solvers/isa/System.scala</a>&gt;</p>",
        "id": 294322210,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927275
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThat is the old question of accessing a Scala library from Java.</p>\n<p>You probably understand yourself more about the Scala compiler and its <br>\nrepresentation of Scala things on the JVM than I do.  My impression in the <br>\npast 7 years was that these things do change between major releases of <br>\nScala, and direct Java access is not properly supported.</p>\n<p>The Isabelle/Scala attitude towards that problem is to ask users to write <br>\ntheir own little Scala module to access the PIDE infrastructure, and <br>\nexpose it to an existing Java program, if they really have to.  In some <br>\nsense, Isabelle/jEdit does the same, because jEdit is just another Java <br>\nprogram.</p>\n<p>Big commercial frameworks like Akka advertize dual Java and Scala APIs, <br>\nbut that is not for free -- it was implemented like that from the start <br>\n(with the intention to make money in the Java market).</p>\n<p>Makarius</p>\n<hr>\n<p><a href=\"http://stop-ttip.org\">http://stop-ttip.org</a>  909,835 people so far</p>\n<hr>",
        "id": 294322232,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927287
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>You probably understand yourself more about the Scala compiler and its<br>\nrepresentation of Scala things on the JVM than I do.  My impression in<br>\nthe past 7 years was that these things do change between major releases<br>\nof Scala, and direct Java access is not properly supported.</p>\n</blockquote>\n<p>Indeed. The only guarantee is calling Java from Scala, and even that<br>\nbreaks from time to time because of mismatches between their type systems.</p>\n<blockquote>\n<p>The Isabelle/Scala attitude towards that problem is to ask users to<br>\nwrite their own little Scala module to access the PIDE infrastructure,<br>\nand expose it to an existing Java program, if they really have to.  In<br>\nsome sense, Isabelle/jEdit does the same, because jEdit is just another<br>\nJava program.</p>\n</blockquote>\n<p>Exactly. If there are only a handful of different commands which need to<br>\nbe supported, such a wrapper seems to be the best idea. But even then,<br>\none needs to think about whether the interaction is supposed to be<br>\nasynchronous, because Java is lacking in that regard.</p>\n<p>Lars</p>",
        "id": 294322247,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927293
    },
    {
        "content": "<p>From: Walther Neuper &lt;<a href=\"mailto:wneuper@ist.tugraz.at\">wneuper@ist.tugraz.at</a>&gt;<br>\nthanks a lot for the quick replies!</p>\n<blockquote>\n<blockquote>\n<p>(1) Is the code around the removed \"isabelle tty\" already stable enough<br>\nto start replacement of \"isabelle tty\" in our project now ?<br>\nI would say yes, even though a canonical discipline on how to write an<br>\napplication using only a minimal subset of the features of PIDE has not<br>\nemerged yet.<br>\nVery good. so let's start.<br>\n(d) the functions f wrote data in XML-format, which was read from<br>\nstdout by a Java XML parser.<br>\nfirstly, I'm going to assume that your front end is running on the JVM.<br>\nRight.<br>\nOur protocol is very primitive, it is NOT asynchronous:<br>\n(c) the client requests were ML functions   f : a1 -&gt; .. -&gt; an -&gt; unit<br>\n      written to stdin as text \"ML {* f a1 .. an *}\"<br>\nThis is more interesting. Is the scope of what these functions do<br>\nlimited, or can the user somehow specify arbitrary functions?<br>\nThe set of functions f is fixed and cannot be expanded by the user, <br>\n<a href=\"https://intra.ist.tugraz.at/hg/isa/file/c06c18fe06e0/src/Tools/isac/Frontend/interface.sml#l10\">https://intra.ist.tugraz.at/hg/isa/file/c06c18fe06e0/src/Tools/isac/Frontend/interface.sml#l10</a>.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>If the scope is limited, then you can do something like [1] and treat<br>\nthe prover process as some sort of \"REPL\" which only understands a fixed<br>\nset of commands and acts accordingly. Notably, the support of multiple<br>\nclients in a single Isabelle session is almost trivial.<br>\nThe other relevant bit in the code I wrote at EPFL is [2], although it<br>\nis cluttered with rather ad hoc session management required by the<br>\nsystem I was integrating with. If you're inclined, I can put together a<br>\nsmaller example which should be sufficient to demonstrate the general<br>\npatterns.<br>\nSo I'll go to study [1,2].<br>\nMy hope is still, to stay within Java, because you say<br>\nThe only guarantee is calling Java from Scala, and even that<br>\nbreaks from time to time because of mismatches between their type systems.</p>\n</blockquote>\n<p>Thanks a lot,<br>\nWalther</p>\n<blockquote>\n<p>[1]<br>\n&lt;<a href=\"https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/isabelle/Isabelle_Leon/Protocol.thy#L248-L264\">https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/isabelle/Isabelle_Leon/Protocol.thy#L248-L264</a>&gt;<br>\n[2]<br>\n&lt;<a href=\"https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/scala/leon/solvers/isa/System.scala\">https://github.com/larsrh/leon/blob/8a01cfea513376821c02a2390b3a7ed3266d336c/src/main/scala/leon/solvers/isa/System.scala</a>&gt;</p>\n</blockquote>",
        "id": 294322267,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660927300
    }
]