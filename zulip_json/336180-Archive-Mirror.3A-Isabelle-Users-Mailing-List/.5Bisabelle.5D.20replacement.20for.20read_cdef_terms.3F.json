[
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nIn the previous version of Isabelle, I used the function <br>\nread_cdef_terms, which has now disappeared.  Is there an exact <br>\nre-implementation using the new Isabelle2007 facilities?  (That would <br>\nmake my life simplest, naturally.)</p>\n<p>Failing that, I need to be able to parse a list of strings into terms, <br>\nwith variables being assigned types consistently across that list, and <br>\nalso being able to provide variant names and types for certains of the <br>\nstrings corresponding to variable names.</p>\n<p>My previous call to read_cdef_terms looked like</p>\n<p>read_cdef_terms (thy, f state, K NONE) [] true stringlist</p>\n<p>where f state was of type</p>\n<p>(string * 'a) -&gt; (string * typ) option</p>\n<p>Thanks,<br>\nMichael.</p>",
        "id": 294054906,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821132
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nDear Michael,</p>\n<blockquote>\n<p>In the previous version of Isabelle, I used the function<br>\nread_cdef_terms, which has now disappeared.  Is there an exact<br>\nre-implementation using the new Isabelle2007 facilities?  (That would<br>\nmake my life simplest, naturally.)</p>\n</blockquote>\n<p>There are still some apparently similar functions, e. g.<br>\nThm.read_def_cterms or Sign.read_def_terms which might serve as a subsitute.</p>\n<blockquote>\n<p>Failing that, I need to be able to parse a list of strings into terms,<br>\nwith variables being assigned types consistently across that list, and<br>\nalso being able to provide variant names and types for certains of the<br>\nstrings corresponding to variable names.</p>\n<p>My previous call to read_cdef_terms looked like</p>\n<p>read_cdef_terms (thy, f state, K NONE) [] true stringlist</p>\n<p>where f state was of type</p>\n<p>(string * 'a) -&gt; (string * typ) option</p>\n</blockquote>\n<p>Indeed tinkering with raw variable names has been highly discouraged<br>\nsince Isabelle2005 - proof contexts allow to track declared and fixed<br>\nvariables and avoid name clashes implicitly.  Chapter 4 of the emerging<br>\nIsabelle Implementation Manual gives some hints.</p>\n<p>Anyway, an adaption to that style usually requires a re-working of the<br>\nwhole code since everything has to be lifted from theories to local<br>\ntheories.  Perhaps the easiest quick-fix to your problem is to copy &amp;<br>\npaste from Isabelle 2005 sources which are available from CVS, -r<br>\nIsabelle2005.  Just mail me if this is not straight-forward.</p>\n<p>Hope this helps<br>\nFlorian<br>\n<a href=\"/user_uploads/14278/F9aj51PiO5fITwII-gbF4SAS/florian.haftmann.vcf\">florian.haftmann.vcf</a><br>\n<a href=\"/user_uploads/14278/D1wz3pdJ4xELVZXlqUAaJNUh/signature.asc\">signature.asc</a></p>",
        "id": 294054914,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821139
    },
    {
        "content": "<p>From: Michael Norrish &lt;<a href=\"mailto:Michael.Norrish@nicta.com.au\">Michael.Norrish@nicta.com.au</a>&gt;<br>\nFlorian Haftmann wrote:</p>\n<blockquote>\n<blockquote>\n<p>In the previous version of Isabelle, I used the function<br>\nread_cdef_terms, which has now disappeared.  Is there an exact<br>\nre-implementation using the new Isabelle2007 facilities?  (That would<br>\nmake my life simplest, naturally.)</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>There are still some apparently similar functions, e. g.<br>\nThm.read_def_cterms or Sign.read_def_terms which might serve as a<br>\nsubsitute.</p>\n</blockquote>\n<p>I couldn't see the former; but I think the latter is just what I need.</p>\n<blockquote>\n<blockquote>\n<p>Failing that, I need to be able to parse a list of strings into terms,<br>\nwith variables being assigned types consistently across that list, and<br>\nalso being able to provide variant names and types for certains of the<br>\nstrings corresponding to variable names.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Indeed tinkering with raw variable names has been highly discouraged<br>\nsince Isabelle2005 - proof contexts allow to track declared and<br>\nfixed variables and avoid name clashes implicitly.  Chapter 4 of the<br>\nemerging Isabelle Implementation Manual gives some hints.</p>\n</blockquote>\n<p>I was incorrect; I'm not modifying the names, just ascribing types to<br>\nfree names.  This sort of parsing in a context of known names is<br>\ncritical to our application.  It's not happening as part of a proof,<br>\nbut rather at the top \"definitional\" level, so I'm not sure that there<br>\nis a proof context to hand.  In any case, I think I'm happy with<br>\nSign.read_def_terms.</p>\n<p>Thanks,<br>\nMichael.</p>",
        "id": 294055000,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821175
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nThe former is in source file Pure/more_thm.ML which extends the Thm<br>\nstructure.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/7k7P-sGg-xtV3ldC7fjw4ORl/florian.haftmann.vcf\">florian.haftmann.vcf</a><br>\n<a href=\"/user_uploads/14278/r5r7u-uPd3YR8IgUMY1vxFel/signature.asc\">signature.asc</a></p>",
        "id": 294055043,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821194
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe short answer is to use Syntax.read_terms with the proper context that <br>\nshould have been passed to you in the particular situation (e.g. the proof <br>\ncontext of a method, or the local_theory context of a specification <br>\nelement).  Additional type information may be added to the context by <br>\ndeclaring previous terms properly, using Variable.declare_term.</p>\n<p>The long answer is that with Isabelle2007 we have made some serious moves <br>\ntowards a much simpler and more powerful way of processing input of formal <br>\nentities (types and terms).  Instead of the traditional rather weakly <br>\ndefined all-in-one operations of the read_def_cterm kind of thing we have <br>\nnow separate layers for parsing and type-checking.  In particular:</p>\n<p>(1) Syntax.parse_term (or similar operations for sort, typ, prop)<br>\n    turns a concrete string representation into a formal entity where all <br>\n    names are properly internalised (name space lookups for consts, <br>\n    potential internalization of ``brown'' variables, de-Bruijn <br>\n    representation of bound variables etc.).</p>\n<p>Here type information is still incomplete, more or less exactly as <br>\n    given in the original input. This format could be called a pre-term, <br>\n    but uses the existing datatype term with dummyT etc. as usual in <br>\n    Isabelle.</p>\n<p>Parsing works independently on individual terms; if you have a list of <br>\n    strings just map Syntax.parse_term over them.  This also facilitates <br>\n    mixed situations, where some terms are already alvailable in internal <br>\n    form, and further ones are parsed from user input.</p>\n<p>(2) Syntax.check_terms (and friends) turn a list of pre-terms into fully<br>\n    checked terms, by simulatenous type-inference, or any other term <br>\n    checking facility installed in the present context.  (The latter <br>\n    concept is new, and part of what is occasionally called ``user-space <br>\n    type system'' in internal Isabelle jargon.)</p>\n<p>(3) Any additional information (type constraints etc.) is specified <br>\n    implicitly via the provided context.  Recall that <br>\n    Variable.declare_term will add additional information from previously <br>\n    checked terms.</p>\n<p>In very rare situations, you can conjure up a context via <br>\n    ProofContext.init applied to the global background theory, but usually <br>\n    this holds too little information for proper parsing/checking.  E.g. <br>\n    it lacks the local declarations of a locale or class context, or even <br>\n    just the syntactic constraints of a goal context.</p>\n<p>When experimenting with any of this, the ML antiquotation @{context} will <br>\ngive you the (compile-time) context; in production code you usually need a <br>\nruntime context passed from somewhere else.  Here is an example to read a <br>\nterm the fully explicit way within an Isar proof:</p>\n<p>lemma<br>\n    fixes m n :: nat<br>\n    shows \"m + n = n + m\"</p>\n<p>ML {* val pre_t = Syntax.parse_term @{context} \"m + n\" *}<br>\n  ML {* val [t] = Syntax.check_terms @{context} [pre_t] *}</p>\n<p>This results in</p>\n<p>val pre_t =<br>\n    Const (\"<a href=\"http://HOL.plus_class.plus\">HOL.plus_class.plus</a>\", \"_\") $ Free (\"m\", \"_\") $ Free (\"n\", \"_\")<br>\n  val t =<br>\n    Const (\"<a href=\"http://HOL.plus_class.plus\">HOL.plus_class.plus</a>\", \"nat =&gt; nat =&gt; nat\") $ Free (\"m\", \"nat\") $<br>\n      Free (\"n\", \"nat\")</p>\n<p>There are also some common compositions of parse/check operations, such as <br>\nSyntax.read_term for the above Syntax.parse_term followed by singleton <br>\nSyntax.check_terms.</p>\n<p>Many internal Isabelle components have already been converted to the new <br>\nsystem, but some obsolete read operations still lure in the code.  As a <br>\nrule of thumb, anything that just takes a theory instead of a proper <br>\nProof.context will disappear soon, e.g. the obsolete Thm.read_def_cterm(s) <br>\nin src/Pure/more_thm.ML (the comments in the sources already say so).</p>\n<p>Makarius</p>",
        "id": 294055670,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821482
    }
]