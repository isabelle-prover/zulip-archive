[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nSorry for just sending an incomplete message.</p>\n<p>In the following example (taken from<br>\n~~/src/HOL/Induct/Common_Patterns.thy) there is apparently unnecessary<br>\nduplication.</p>\n<p>lemma<br>\n fixes n :: nat<br>\n shows \"P n\" and \"Q n\"<br>\nproof (induct n)<br>\n case 0 case 1<br>\n show \"P 0\" sorry<br>\nnext<br>\n case 0 case 2<br>\n show \"Q 0\" sorry<br>\nnext<br>\n case (Suc n) case 1<br>\n note hyps = <code>P n</code> <code>Q n</code>              (<strong>** this line ... </strong>**)<br>\n show \"P (Suc n)\" sorry<br>\nnext<br>\n case (Suc n) case 2<br>\n note hyps = <code>P n</code> <code>Q n</code>              (<strong>** ... duplicated </strong>*)<br>\n show \"Q (Suc n)\" sorry<br>\nqed</p>\n<p>I want to know how to avoid this duplication.  I have the common example</p>\n<p>lemma<br>\nassumes h:\"inductiveR x\" and j:\"P x\"<br>\nshows \"Q1 x\" and \"Q2 x\"<br>\nusing h proof (induct)<br>\n  (case ...) case 1 have \"P x0\" by fact show \"Q1 x0\" ...<br>\n                case 2 have \"P x0\" by fact show \"Q2 x0\" ...</p>\n<p>I want to eliminate the duplication in the last two lines.</p>\n<p>In fact, playing with examples shows that</p>\n<p>lemma<br>\nassumes h:\"inductiveR x\" and j:\"P x\"<br>\nshows \"Q1 x\" and \"Q2 x\"<br>\nusing h proof (induct)<br>\n  (case ...x0...)                  (<strong> the fact \"P x0\" is not known here </strong>)<br>\n         case 1 have j:\"P x0\" by fact<br>\n                    show \"Q1 x0\" proof (... j ...)<br>\n         case 2 show \"Q2 x0\" proof (... j ...)  (<strong> why is j in scope here? </strong>)</p>\n<p>works.  I don't understand the scoping of facts in this example.</p>\n<p>Thanks,<br>\nRandy</p>",
        "id": 294136559,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844519
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Sun, May 15, 2011 at 3:25 PM, Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>lemma<br>\nassumes h:\"inductiveR x\" and j:\"P x\"<br>\nshows \"Q1 x\" and \"Q2 x\"<br>\nusing h proof (induct)<br>\n (case ...) case 1 have \"P x0\" by fact show \"Q1 x0\" ...<br>\n               case 2 have \"P x0\" by fact show \"Q2 x0\" ...</p>\n<p>I want to eliminate the duplication in the last two lines.</p>\n</blockquote>\n<p>I think I understand your problem now. Did you mean to say, \"using h j<br>\nproof (induct)\" above?</p>\n<p>Here is another example adapted from HOL/Induct/Common_Patterns.thy;<br>\nI've added the extra assumption \"C n\" which is added to the inductive<br>\nhypothesis. At the point of \"case (Suc n)\", you might like to be able<br>\nto use the assumption \"C (Suc n)\" to derive some other facts, and use<br>\nthose in both subcases 1 and 2. The problem is that the \"case\" command<br>\ndoes not assume \"C (Suc n)\" for you until you get all the way down to<br>\nthe subcases.</p>\n<p>lemma<br>\n  fixes n :: nat<br>\n  assumes \"C n\"<br>\n  shows \"A n ==&gt; P n\"<br>\n    and \"B n ==&gt; Q n\"<br>\nusing <code>C n</code> proof (induct n)<br>\n  case 0<br>\n  {<br>\n    case 1 note <code>A 0</code> show \"P 0\" sorry<br>\n  next<br>\n    case 2 note <code>B 0</code> show \"Q 0\" sorry<br>\n  }<br>\nnext<br>\n  case (Suc n)<br>\n  note <code>A n ==&gt; C n ==&gt; P n</code><br>\n    and <code>B n ==&gt; C n ==&gt; Q n</code><br>\n  (<strong>* <code>C (Suc n)</code> has not been assumed yet at this point </strong>*)<br>\n  {<br>\n    case 1<br>\n    note <code>A (Suc n)</code> and <code>C (Suc n)</code><br>\n    show \"P (Suc n)\" sorry<br>\n  next<br>\n    case 2<br>\n    note <code>B (Suc n)</code> and <code>C (Suc n)</code><br>\n    show \"Q (Suc n)\" sorry<br>\n  }<br>\nqed</p>\n<p>I can think of two solutions, one of which you already discovered:</p>\n<blockquote>\n<p>In fact, playing with examples shows that</p>\n<p>lemma<br>\nassumes h:\"inductiveR x\" and j:\"P x\"<br>\nshows \"Q1 x\" and \"Q2 x\"<br>\nusing h proof (induct)<br>\n (case ...x0...)                  (<strong> the fact \"P x0\" is not known here </strong>)<br>\n        case 1 have j:\"P x0\" by fact<br>\n                   show \"Q1 x0\" proof (... j ...)<br>\n        case 2 show \"Q2 x0\" proof (... j ...)  (<strong> why is j in scope here? </strong>)</p>\n<p>works.  I don't understand the scoping of facts in this example.</p>\n</blockquote>\n<p>By omitting the \"next\" between subcases 1 and 2, Isabelle doesn't<br>\nreset the proof context, so \"j\" is still in scope. This technique<br>\nwouldn't work for my example above though, since when you use two<br>\n\"case\" commands without using \"next\" in between, you get a proof<br>\ncontext that is essentially the union of the two cases. Here the<br>\nsecond subcase fails because too many assumptions are in scope.</p>\n<p>lemma<br>\n  fixes n :: nat<br>\n  assumes \"C n\"<br>\n  shows \"A n ==&gt; P n\"<br>\n    and \"B n ==&gt; Q n\"<br>\nusing <code>C n</code><br>\nproof (induct n)<br>\n  case (Suc n)<br>\n  case 1<br>\n    note <code>A (Suc n)</code> and <code>C (Suc n)</code><br>\n    show \"P (Suc n)\" sorry<br>\n  case 2<br>\n    note <code>C (Suc n)</code> and <code>C (Suc n)</code><br>\n    show \"Q (Suc n)\" (*** error because assumption <code>A (Suc n)</code> is<br>\nstill in scope ***)</p>\n<p>Solution 2: If the \"case\" command doesn't make the necessary<br>\nassumptions early enough for you, you can always \"assume\" them<br>\nyourself, like this:</p>\n<p>lemma<br>\n  fixes n :: nat<br>\n  assumes \"C n\"<br>\n  shows \"A n ==&gt; P n\"<br>\n    and \"B n ==&gt; Q n\"<br>\nusing <code>C n</code> proof (induct n)<br>\n  case 0<br>\n  {<br>\n    case 1 note <code>A 0</code> show \"P 0\" sorry<br>\n  next<br>\n    case 2 note <code>B 0</code> show \"Q 0\" sorry<br>\n  }<br>\nnext<br>\n  case (Suc n)<br>\n  assume foo: \"C (Suc n)\"<br>\n  from foo have bar: ...<br>\n  {<br>\n    case 1<br>\n    note <code>A (Suc n)</code><br>\n    show \"P (Suc n)\" using bar sorry<br>\n  next<br>\n    case 2<br>\n    note <code>B (Suc n)</code><br>\n    show \"Q (Suc n)\" using bar sorry<br>\n  }<br>\nqed</p>\n<p>The validity of this might make a bit more sense if you remember that<br>\nthe \"case\" command is essentially syntactic sugar for a bunch of \"fix\"<br>\nand \"assume\" commands. Whenever you do a \"show\" command, Isar only<br>\nrequires that the assumptions in scope are a subset of the ones in the<br>\ngoal you are trying to solve.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294136618,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844525
    },
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nThanks Brian,</p>\n<p>You understood the question as I meant it.  I consider it a weakness<br>\nthat the fact <code>C (Suc n)</code> is not in scope where it logically should<br>\nbe.  Of the two solutions you suggest, the one I first discovered is<br>\nillogical, and the second one you point out is less comfortable for<br>\nthe user because the assumption isn't checked by Isabelle at the point<br>\nit is introduced.  Due to the profusion of renamed variables under the<br>\n\"case\" it is easy to misstate such assumptions.</p>\n<p>Best,<br>\nRandy</p>",
        "id": 294136635,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844531
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 15 May 2011, Randy Pollack wrote:</p>\n<blockquote>\n<p>In the following example (taken from<br>\n~~/src/HOL/Induct/Common_Patterns.thy) there is apparently unnecessary<br>\nduplication.</p>\n<p>lemma<br>\nfixes n :: nat<br>\nshows \"P n\" and \"Q n\"<br>\nproof (induct n)<br>\ncase 0 case 1<br>\nshow \"P 0\" sorry<br>\nnext<br>\ncase 0 case 2<br>\nshow \"Q 0\" sorry<br>\nnext<br>\ncase (Suc n) case 1<br>\nnote hyps = <code>P n</code> <code>Q n</code>              (<strong>** this line ... </strong>**)<br>\nshow \"P (Suc n)\" sorry<br>\nnext<br>\ncase (Suc n) case 2<br>\nnote hyps = <code>P n</code> <code>Q n</code>              (<strong>** ... duplicated </strong>*)<br>\nshow \"Q (Suc n)\" sorry<br>\nqed</p>\n<p>I want to know how to avoid this duplication.</p>\n</blockquote>\n<p>First of all, the boundaries of nested cases are determined by the <br>\n\"induct\" method.  Further refinement of this behaviour is on the TODO list <br>\nfor several years, but that method has accumulated so many features <br>\nalready, that it takes a long time to clear it out again.</p>\n<p>Given the current behaviour there are still many ways how to express the <br>\nproof.  The \"Common_Patterns\" are just some examples to explain the main <br>\nideas.  E.g. the above duplication of \"P n\" and \"Q n\" as propositions can <br>\nbe avoided by using the fact names produced by each case, i.e. \"Suc\", <br>\n\"Suc.hyps\", \"Suc.prems\".  You can also project from there using syntax <br>\nsuch as \"Suc(2)\" although such numbers make proofs a bit hard to read and <br>\nmaintain.</p>\n<blockquote>\n<p>In fact, playing with examples shows that</p>\n<p>lemma<br>\nassumes h:\"inductiveR x\" and j:\"P x\"<br>\nshows \"Q1 x\" and \"Q2 x\"<br>\nusing h proof (induct)<br>\n (case ...x0...)                  (<strong> the fact \"P x0\" is not known here </strong>)<br>\n        case 1 have j:\"P x0\" by fact<br>\n                   show \"Q1 x0\" proof (... j ...)<br>\n        case 2 show \"Q2 x0\" proof (... j ...)  (<strong> why is j in scope here? </strong>)</p>\n<p>works.  I don't understand the scoping of facts in this example.</p>\n</blockquote>\n<p>This is another example why it is a bad idea to invent new Isar <br>\nindentation rules on the spot.  The indentation that is hard-wired into <br>\nProof General is quite precise approximation of important semantic aspects <br>\nof the language.  In particular, the 'case' command merely augments the <br>\ncontext monotonically, without introducing any block structure on its own. <br>\nSo no change of indentation here.</p>\n<p>I've also made a mistake many years ago in calling it 'case' in the first <br>\nplace, which sounds too much like a rigid structure in corellation with <br>\nthe goal state, which it isn't.</p>\n<p>To understand Isar block structure in general, you can always use { ... } <br>\nexplicitly, but in practice it is usually suppressed due to the following <br>\nimplicit principles -- using ( ... ) for the true internal parantheses <br>\nthat do not have concrete syntax:</p>\n<p>(1) a proof body opens an extra pair of spare parentheses like this:</p>\n<p>(<br>\n        have A<br>\n        (<br>\n          proof method<br>\n            body<br>\n          qed method<br>\n        )<br>\n        )</p>\n<p>(2) concrete user commands are defined as follows:</p>\n<p>{    == ((<br>\n         }    == ))<br>\n         next == )(</p>\n<p>More precisely</p>\n<p>next == ) note nothing (</p>\n<p>which explains why you cannot push results over that boundary.</p>\n<p>Makarius</p>",
        "id": 294136771,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844574
    }
]