[
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nHi, I'm a mathematician writing a rigorous axiomatic geometry paper<br>\n<a href=\"http://www.math.northwestern.edu/~richter/hilbert.pdf\">http://www.math.northwestern.edu/~richter/hilbert.pdf</a> <br>\nusing Hilbert's axioms.  I want to cite geometry proofs nicely coded<br>\nand checked by proof-checker like Isabelle.  I've written Mizar code<br>\n<a href=\"http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar\">http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar</a> <br>\nand I want to port it to Isabelle, which Freek Wiedijk seems to<br>\nsuggest is an improvement.  Makarius has been helping me, and he said<br>\nI should ask here about formalizations of geometry.  My feeling, which<br>\ncould be mistaken, is that Coq and HOL Light are primarily<br>\ntheorem-provers (procedural) and require considerable tweaking to<br>\nallow folks to type in readable axiomatic geometry (declarative)<br>\nproofs, but that Isabelle is both procedural and declarative.  </p>\n<p>My Mizar code is a largely a port of Julien Narboux's Coq pseudo-code<br>\n<a href=\"http://dpt-info.u-strasbg.fr/~narboux/tarski.html\">http://dpt-info.u-strasbg.fr/~narboux/tarski.html</a>.  I partially prove<br>\nthe theorem of the 1983 book Metamathematische Methoden in der<br>\nGeometrie by Schwabhäuser, Szmielew, and Tarski, that Tarski's<br>\n(extremely weak!) plane geometry axioms imply Hilbert's axioms.  I get<br>\nabout as far as Narboux, with Gupta's amazing proof which implies<br>\nHilbert's axiom I1 that two points determine a line.  I don't think my<br>\nMizar code is that great, but it's a lot more readable than Julien's<br>\nCoq pseudo-code.  No doubt some Mizar experts could improve my code,<br>\nbut I'm putting them off as a last resort, because Mizar seems<br>\nunsuitable as a language to use in a high school math class.</p>\n<p>So I'd appreciate your Isabelle help, including the easiest way run<br>\nIsabelle programs.  Do I really need Proof General?  I'll also accept<br>\ngeometry help!  I haven't seen Schwabhäuser's book, and I can't see<br>\nhow to go any farther with Tarski's axioms.  I'm basically missing<br>\nHilbert's Pasch Betweenness axiom (Tarski's axiom is about 1/3 of it)<br>\nand Hilbert's angle construction axiom.</p>",
        "id": 294154711,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850746
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nNo, I believe the modern way to run Isabelle is with the jEdit interface<br>\nthat comes with the Isabelle distribution.</p>",
        "id": 294154779,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850764
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nI appreciate your work [...] Maybe we could join our efforts.</p>\n<p>Julien, I'd be thrilled to work with you and Gabriel Braun, especially<br>\nas you &amp; Makarius are on a committee studying Theorem Proving<br>\nComponents for Educational Software.  So you &amp; Makarius are people I<br>\nwant to talk to about teaching geometry, and not only vital<br>\nprogramming resources.  This is very interesting:</p>\n<p>I appreciate your work, your proofs seem to be really more readable<br>\n   than Coq proofs. Of course my LCF style proofs are not meant to be<br>\n   readable. In fact, I believe that these proofs about Tarski's<br>\n   axioms are really low level and it is hard to have intuition about<br>\n   the proofs because there are basic facts which are hard to prove<br>\n   (for instance existence of the midpoint arrives only at chapter 7<br>\n   !) and therefore it is not really the kind of proof one wants to<br>\n   show in high-school, that is why I did not try to produce readable<br>\n   proofs.</p>\n<p>Surely no one should teach Tarski's axioms in high school, as the<br>\nproofs are way too hard since his axioms are so weak.  But the Tarski<br>\nproofs are still worth understanding, for the same reason that high<br>\nschool kids (arguably) ought to learn Hilbert's axioms and not use the<br>\nstronger axioms of Moise &amp; Venema, based on Birkhoff's real line for<br>\ndistances and angles, and taking the plane separation axiom instead of<br>\nHilbert's weaker Pasch axiom.  </p>\n<p>Moise proofs are a lot easier than Hilbert proofs.  But only using<br>\nMoise raises the question in the student's mind: am I smart enough to<br>\nunderstand the supposedly harder Hilbert axioms?  And if I'm not smart<br>\nenough, maybe I shouldn't even be using the simpler Moise axioms!<br>\nThe only way to reassure the students is to write up nice Hilbert proofs,<br>\nand I think I succeeded, or at least made a start, in <br>\n<a href=\"http://www.math.northwestern.edu/~richter/hilbert.pdf\">http://www.math.northwestern.edu/~richter/hilbert.pdf</a><br>\nThe same remarks go for Tarksi, at least for me (the teacher).  I know I<br>\ncouldn't figure out the Tarski proofs myself, I needed your Coq code,<br>\nbut am I even smart enough to understand the proofs?  </p>\n<p>I think there is definitely is Tarski geometry intuition, although<br>\nit's hard to come by.  Gupta's amazing proof is definitely based on<br>\nintuition, and you can see the intuition in the pictures you and the<br>\nwikiproofs folks draw.  Gupta's theorem<br>\na ≠ b ∧ Babc ∧ Babd → Bacd ∨ Badc<br>\nwould be easy if we could find two points p &amp; q that are equidistant<br>\nfrom a, b &amp; c.  We could easily do that if we had Hilbert's angle<br>\nconstruction axiom, but we don't.  So Gupta (as you explained to me in<br>\nyour Coq code) first finds a rhombus (which turns out to be flat), and then<br>\nshows the diagonals of the rhombus bisect each other (that's generally<br>\ntrue, and in our flat case it follows easily from the Inner Pasch<br>\naxiom), and then we can do enough angle construction using this<br>\nbisected rhombus to find the points p &amp; q, which turn out to be on the<br>\nsame line after all.  Isn't that an amazing proof?  </p>\n<p>Your email from last week reactivated my interest in these proofs<br>\n   and I worked on the proof of Hilbert's Pasch axiom. </p>\n<p>Excellent!  I noticed that your proof of the full Pasch axiom in your <br>\n(in progress) <a href=\"http://dpt-info.u-strasbg.fr/~narboux/Tarski/Hilbert.html\">http://dpt-info.u-strasbg.fr/~narboux/Tarski/Hilbert.html</a><br>\nseems to be still  in progress.<br>\nAlso, you didn't quite prove the midpoint theorem, but only<br>\nLemma l7_25 : forall A B C, Cong C A C B -&gt; exists X, is_midpoint X A B.<br>\nYour C should exist, by constructing an isosceles triangle, but I<br>\ncan't even do that.</p>\n<p>I don't know why my address from hol-info bounced, as I've gotten mail<br>\nfrom other hol-info users.  Can you check what my bad address was?  </p>\n<p>About your questions about Isabelle, I think you could use the<br>\n   latest use interface based on Jedit.</p>\n<p>Thanks.  Makarius told me this after I posted.  I still don't know how<br>\nto use Isabelle.  Makarius stressed that I ought to try Coq.</p>",
        "id": 294154820,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850788
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nthey have built a large Coq library about high school geometry.<br>\n   [...] But this [ Coq declarative proof] language is not used much<br>\n   by the Coq community so you may encounter bugs.</p>\n<p>Julien, I think that you and your coauthors in<br>\n<a href=\"http://hal.inria.fr/docs/00/58/49/18/PDF/iccsaConf.pdf\">http://hal.inria.fr/docs/00/58/49/18/PDF/iccsaConf.pdf</a> are using Coq<br>\nto figure out how to teach the course, and not asking the students to<br>\nwrite Coq code proofs.  This sentence in your paper concerns me:</p>\n<p>The work closest to ours is the one by<br>\n   P. Scott and J. Fleuriot [17].<br>\n<a href=\"http://www.springerlink.com/content/b715100716u1t347/?MUD=MP\">http://www.springerlink.com/content/b715100716u1t347/?MUD=MP</a></p>\n<p>I know I just got here, and I'm not trying to fight with anyone, but I<br>\nthink this paper shows I have some value to the group already.  </p>\n<p>Scott and Fleuriot took on a challenging and interesting HOL Light<br>\nproject, to fill in the gaps of Hilbert's book FoG.  That will show<br>\nthe power of HOL Light and their programming skill.</p>\n<p>But their paper doesn't seem helpful in teaching a rigorous Hilbert<br>\ngeometry course.  Reading Greenberg's &amp; Hartshorne's books (or my<br>\npaper <a href=\"http://www.math.northwestern.edu/~richter/hilbert.pdf\">http://www.math.northwestern.edu/~richter/hilbert.pdf</a>) would<br>\nmuch more helpful.  The authors don't seem to understand the gaps in<br>\nEuclid's work which were fixed by Hilbert's axioms.  Euclid messed up<br>\nevery single result that involved angle addition, including the<br>\ntriangle sum theorem (sum 3 angles = 180).  That's a result kids<br>\ntaking a Hilbert geometry course need to know!  The authors study<br>\ninstead possible deficiencies of Hilbert's book FoG, and there may be<br>\nplenty, but you can't teach a geometry course out of FoG, as there<br>\nisn't enough interesting material.  Euclid's errors are much more<br>\ninteresting, as Euclid was often used as a textbook (for centuries?).<br>\nScott and Fleuriot say something misleading in their intro:</p>\n<p>Indeed, it is sufficient to note that Hilbert followed Euclid in<br>\n   one pervasive omission: they both give proofs on an ambient plane<br>\n   when the axioms characterise solid geometry [8].</p>\n<p>First, they're citing Heath (a valuable Euclid resource), who mentions<br>\nHilbert quite often but shows absolutely no understanding of how<br>\nHilbert's work fixes Euclid's pervasive angle-addition errors.</p>\n<p>Second, is there even an error, as Scott and Fleuriot quote Heath as<br>\nsaying?  I don't see any plane/solid-geometry error in Hilbert's<br>\naxioms listed <a href=\"http://en.wikipedia.org/wiki/Hilbert%27s_axioms\">http://en.wikipedia.org/wiki/Hilbert%27s_axioms</a></p>\n<p>In my paper I explain (following Moise's rigorous book) how to handle<br>\nthis solid geometry biz.  Basically, for all the 2-dim stuff you have<br>\nto say \"in a plane\" and in the 3-dim part you then use the planar<br>\nstuff plus extra incidence axioms.  Euclid's book XI is a fantastic<br>\ntreatment of solid geometry, which Moise simplifies.</p>",
        "id": 294154834,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850795
    },
    {
        "content": "<p>From: Josef Urban &lt;<a href=\"mailto:josef.urban@gmail.com\">josef.urban@gmail.com</a>&gt;<br>\nHi Bill,</p>\n<p>transforming the raw Mizar texts is often painful. Depending on<br>\nthe application, it is often better to transform the XML layer or<br>\neven the Prolog (MPTP) layer. A simple XSL stylesheet that<br>\nimplements your mizar-&gt;isar function is now at<br>\n<a href=\"https://raw.github.com/JUrban/xsl4mizar/master/ISA/isa_main.xsl\">https://raw.github.com/JUrban/xsl4mizar/master/ISA/isa_main.xsl</a> .</p>\n<p>Use it as follows:</p>\n<p>git clone git://github.com/JUrban/xsl4mizar.git</p>\n<p>mizf joe.miz<br>\nxsltproc xsl4mizar/addabsrefs.xsl joe.xml &gt; joe.xml1<br>\nxsltproc --param display_thesis \\'0\\' xsl4mizar/ISA/isa_main.xsl<br>\njoe.xml1 | html2text</p>\n<p>You can extend it by overloading in isa_main.xsltxt the other<br>\nprinting functions from MHTML/. The API description is at<br>\n<a href=\"http://mizar.org/version/current/doc/xml/Mizar.html\">http://mizar.org/version/current/doc/xml/Mizar.html</a> . I can<br>\nprobably help with some harder parts if this leads somewhere.</p>\n<p>This can only get you so far. For the general issues with<br>\ntransforming the Mizar dependent type system to HOL-like systems,<br>\nsee Ondrej Kuncar's paper:<br>\n<a href=\"http://ktiml.mff.cuni.cz/~kuncar/kuncar-wds10.pdf\">http://ktiml.mff.cuni.cz/~kuncar/kuncar-wds10.pdf</a> .</p>\n<p>It might also be easier for you to first transform your code to<br>\nHOL Light's Mizar mode, because it does not have the keyword<br>\nincompatibilities that Isar introduced, and it has quite faithful<br>\nimplementation of the Mizar \"by\" inference. In Isabelle, you<br>\ncould later try to replace such calls with \"metis\" calls. If you are<br>\ninterested in Coq, it also has a declarative Mizar-like mode, but it<br>\nis much less used than Isar.</p>\n<p>And one more translation alternative: You could also ask the OMDoc<br>\npeople (Florian Rabe I guess) about OMDoc-&gt;Isabelle export. They<br>\ndo have quite fresh import of Mizar (using the XML layer).</p>\n<p>Best,<br>\nJosef</p>",
        "id": 294154856,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850800
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nAt the end of February, I submitted my Master's thesis, which was about<br>\nan Isabelle formalization of the independence of the parallels<br>\npostulate.  Specifically, I chose Tarski's axioms, and showed that his<br>\nEuclidean axiom (Axiom 10 in Metamathematische Methoden in der<br>\nGeometrie) is independent of the others, by proving that the<br>\nKlein--Beltrami model of the hyperbolic plane satisfies the rest of<br>\nTarski's axioms, but not the Euclidean axiom.</p>\n<p>As you will have gathered, my work was primarily about models of<br>\nTarski's axioms, rather than consequences of them, but if you're<br>\ninterested, ask me off-list, and I can send you a copy of my thesis, or<br>\nmy Isabelle files, or whatever interests you.  Please understand,<br>\nthough, that I haven't heard back from the examiners yet, and I think<br>\nthey're entitled to ask me to make changes to my thesis, so what I send<br>\nyou shouldn't be considered to be the final version of my thesis.</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/A7fYujT1gFjhAE3GI3fdKL7P/signature.asc\">signature.asc</a></p>",
        "id": 294154920,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850829
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nJosef, as you're a real Mizar expert, I'll be grateful if you look at<br>\n<a href=\"http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar\">http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar</a> <br>\nI'll endure pain to manually transform my 1467 lines of Mizar Tarski<br>\ngeometry proofs to Isabelle (or Coq or HOL Light even).  I'm grateful<br>\nto the Mizar folks for writing a language I could learn and code up my<br>\nTarski proofs, not least because I now believe my proofs.  But I think<br>\nMizar is too clunky a language to recommend high school students to<br>\ncode in.  That brings up HOL Light's Mizar mode, as you mentioned, or<br>\nFreek's miz3, but I couldn't get any of them to run on HOL Light 3.09,<br>\nnor could I compile the latest version of HOL Light, and Freek<br>\nsuggests often that Isabelle is an improvement over Mizar.</p>\n<p>Could you just get me started on Isabelle?  I finally ran the<br>\nexecutable ./Isabelle, and up popped jedit.  I'm reading various<br>\nIsabelle dox, and it's all great, but I haven't found what I want:</p>\n<p>How do we code up first order logic (FOL) proofs that follow from some<br>\nFOL axioms?  I really think the Isabelle dox ought to explain this.</p>\n<p>You can't exactly do that in Mizar, I believe, and maybe you can't do<br>\nit in any of the proof assistants.  Mizar is all about set theory<br>\n(using I think Tarski's FOL set theory axioms), so we have to talk<br>\ninstead about a model of my FOL axioms.  That's fine.  </p>\n<p>So we have to define some ``class'' of mathematical objects, which is<br>\nthe sets, functions &amp; relations that define a model.  In my case,<br>\nthat's a set S with a 3-ary and 4-ary relation equiv and between<br>\nsatisfying various properties (Tarski's axioms).  Now we have to code<br>\nup proofs about this class i.e. prove theorems about models of<br>\nTarski's axioms, which amounts to the FOL proofs we want.  This must<br>\nbe explained somewhere in the Isabelle dox.</p>",
        "id": 294154926,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850831
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nTim, that sounds great!  Please send me anything you like privately.<br>\nI'd love to look at your code.  But if you know the answer to the<br>\nquestion I just posted, please post the answer on the list.  How in<br>\nIsabelle do we define models of some FOL axioms and then prove<br>\ntheorems about the models?  And feel free to post an answer to my<br>\ngeometry questions too!  How in Tarski's axioms do you prove Hilbert's<br>\nfull Pasch axiom and angle construction axiom from Tarksi's?</p>",
        "id": 294154945,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850837
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThese are not \"keyword incompatibilities\", but fundamental differences in <br>\nthe approach to structured proofs, and the meaning of the language <br>\nelements.  It all follows Isabelle/Pure and its higher-order natural <br>\ndeduction environment.  Similarities with Mizar and other \"declaritive <br>\nproof\" modes are quite superficial.  I never use the \"declarative\" <br>\nterminolgy for Isar, it does not quite fit what it actually is.</p>\n<p>In particular, their is no built-in automation in Isar.  Users can draw on <br>\nan existing repertoire of proof methods taken from the library, such as <br>\n\"metis\" in Isabelle/HOL, but they don't have to.</p>\n<p>Makarius</p>",
        "id": 294155007,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850867
    },
    {
        "content": "<p>From: Josef Urban &lt;<a href=\"mailto:josef.urban@gmail.com\">josef.urban@gmail.com</a>&gt;<br>\nHi Bill,</p>\n<p>On Mon, Apr 30, 2012 at 5:55 AM, Bill Richter<br>\n&lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt; wrote:</p>\n<blockquote>\n<p>Josef, as you're a real Mizar expert, I'll be grateful if you look at<br>\n<a href=\"http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar\">http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar</a></p>\n</blockquote>\n<p>Superficially it looked OK. But there are better experts than me, and<br>\nyou can get reviews and suggestions if you submit the article to MML.</p>\n<blockquote>\n<p>I'll endure pain to manually transform my 1467 lines of Mizar Tarski<br>\ngeometry proofs to Isabelle (or Coq or HOL Light even).  I'm grateful<br>\nto the Mizar folks for writing a language I could learn and code up my<br>\nTarski proofs, not least because I now believe my proofs.  But I think<br>\nMizar is too clunky a language to recommend high school students to<br>\ncode in.  That brings up HOL Light's Mizar mode, as you mentioned, or<br>\nFreek's miz3, but I couldn't get any of them to run on HOL Light 3.09,<br>\nnor could I compile the latest version of HOL Light, and Freek<br>\nsuggests often that Isabelle is an improvement over Mizar.</p>\n</blockquote>\n<p>I just saw the extensive discussion on the hol list, and I don't think<br>\nI can add much. Particularly John knows really a lot. One recent<br>\ncomparison talk by Freek is at <a href=\"http://www.cs.ru.nl/~freek/talks/lsfa.pdf\">www.cs.ru.nl/~freek/talks/lsfa.pdf</a> .</p>\n<blockquote>\n<p>Could you just get me started on Isabelle?</p>\n</blockquote>\n<p>Why me? :-)  There are so many Isabelle experts here.</p>\n<p>Best,<br>\nJosef</p>\n<blockquote>\n<p>I finally ran the<br>\nexecutable ./Isabelle, and up popped jedit.  I'm reading various<br>\nIsabelle dox, and it's all great, but I haven't found what I want:</p>\n<p>How do we code up first order logic (FOL) proofs that follow from some<br>\nFOL axioms?  I really think the Isabelle dox ought to explain this.</p>\n<p>You can't exactly do that in Mizar, I believe, and maybe you can't do<br>\nit in any of the proof assistants.  Mizar is all about set theory<br>\n(using I think Tarski's FOL set theory axioms), so we have to talk<br>\ninstead about a model of my FOL axioms.  That's fine.</p>\n<p>So we have to define some ``class'' of mathematical objects, which is<br>\nthe sets, functions &amp; relations that define a model.  In my case,<br>\nthat's a set S with a 3-ary and 4-ary relation equiv and between<br>\nsatisfying various properties (Tarski's axioms).  Now we have to code<br>\nup proofs about this class i.e. prove theorems about models of<br>\nTarski's axioms, which amounts to the FOL proofs we want.  This must<br>\nbe explained somewhere in the Isabelle dox.</p>\n<p>--<br>\nBest,<br>\nBill</p>\n</blockquote>",
        "id": 294155022,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850874
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nI don't think they're saying that there's a problem with the axioms;<br>\nthey're saying that there's a problem with some of Hilbert's proofs.<br>\nSee, for example,<br>\nMeikle, L. I., and Fleuriot, J. D.  Formalizing Hilbert’s Grundlagen in<br>\nIsabelle/Isar.  In Theorem Proving in Higher Order Logics, D. Basin and<br>\nB. Wolff, Eds., vol. 2758 of Lecture Notes in Computer Science.<br>\nSpringer Berlin / Heidelberg, 2003, pp. 319–334.<br>\nIn particular, on page 327, they say \"The Grundlagen proof then applied<br>\nAxiom(II,4).  This was not possible in the mechanical proof until all<br>\nnine assumptions of the axiom were present. ...<br>\nHilberts_missing_assumptions was a lemma used to achieve this.  Its<br>\nproof was difficult, especially having to show that EG lay on the plane<br>\nAFC.  Hilbert failed to mention these difficulties.\"</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/DiwzWIV0Yf-mEACdHo1ckBCI/signature.asc\">signature.asc</a></p>",
        "id": 294156730,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851498
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nJeremy, I'll look at your paper, but don't want to discuss Euclid with<br>\nyou or anyone else here unless they understand Hilbert's formal (not<br>\ninformal) first order axiomatization of plane geometry as explained in<br>\nHartshorne's book: 3 incidence axioms, 4 betweenness axioms, 6<br>\ncongruence axioms, the parallel postulate and the circle-circle axiom.</p>\n<p>With these axioms, you can prove every plane geometry result Euclid<br>\nstated, and you ought to be able to code the proofs up nicely in<br>\nIsabelle, and maybe even teach a high school or college course where<br>\nthe students code up their own rigorous axiomatic Hilbert proofs.  You<br>\ncan't code up proofs of Euclid's propositions using Euclid's axioms.</p>\n<p>Your paper is relevant to this group if you can code up your<br>\nenhanced-Euclid proofs in Isabelle.  I couldn't tell from my brief<br>\nglance at your paper if this is possible.  What do you think?</p>",
        "id": 294157869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660851972
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nTim and Makarius, I can't follow the Isabelle dox, and I need<br>\nsomething like ``Isabelle for Dummies.''  I just want to know how to<br>\nwrite my FOL proofs in Isabelle, how to compile them, with examples.</p>\n<p>Now I feel strongly that Isabelle (like Mizar) ought to be able to<br>\ncheck FOL proofs without specifying any proof strategies like Tim's<br>\n<code>simp add' or </code>blast'.  Mizar makes lots of proof shortcuts that I<br>\nwouldn't have expected, and I'd be happier if Isabelle did few proof<br>\nshortcuts.  I want the students to have to write up most of the proof.<br>\nI think in strict FOL, you have to insert so many needless steps that<br>\nthe proofs become unreadable.  I guess we need a good compromise.</p>\n<p>I untarred Isabelle2011-1_bundle_x86-linux.tar.gz and went to the<br>\ndirectory Isabelle2011-1.</p>\n<p>I ran the executable ./Isabelle and up popped jedit.  I pasted in<br>\nIsabelle code from Tim's master's thesis into Scratch.thy.  There's<br>\nextensive jedit help on the Help menu, but I couldn't figure out how<br>\nto compile my buffer.    So then I tried </p>\n<p>bin/isabelle emacs po.thy &amp;</p>\n<p>and up popped a Proof General Emacs frame displaying my short file<br>\npo.thy based on the first example in the<br>\nIsabelle2011-1/doc/locales.pdf.</p>\n<p>------ po.thy ----<br>\ntheory PO<br>\nimports Main <br>\nbegin</p>\n<p>locale partial_order =<br>\n  fixes le :: \" 'a ⇒ 'a ⇒ bool \" (infixl \"\\&lt;sqsubseteq&gt;\" 50)<br>\n  assumes refl [intro, simp]: \"x \\&lt;sqsubseteq&gt; x\"<br>\n    and anti_sym [intro]: \"[[ x  \\&lt;sqsubseteq&gt;  y; y \\&lt;sqsubseteq&gt; x ]] =⇒ x = y\"<br>\n    and trans [trans]: \"[[ x \\&lt;sqsubseteq&gt; y; y \\&lt;sqsubseteq&gt; z ]] =⇒  x \\&lt;sqsubseteq&gt; z\"<br>\n------ end po.thy ----</p>\n<p>Now I can see how to compile my file!  I click on menu item<br>\nIsabelle -&gt; Start Isabelle <br>\nI think that's the much the same thing as clicking the down-arrow<br>\nbutton which says ``process whole buffer''.  I get an error message:</p>\n<ul>\n<li>Inner lexical error at: ⇒ 'a ⇒ bool  (line 6 of \"/home/richter/Isabelle/Isabelle2011-1/po.thy\")<br>\n*** Failed to parse type<br>\n*** At command \"locale\" (line 5 of \"/home/richter/Isabelle/Isabelle2011-1/po.thy\")</li>\n</ul>\n<p>I have no idea what this means.  Posibly I'm using the wrong quote.<br>\nI'm writing 'a, but locales.pdf actually shows ’a.  So I changed to<br>\nthis quote, and I got a new error message:</p>\n<p>*** Inner lexical error at: ’a ⇒ ’a ⇒ bool (line 6 of \"/home/richter/Isabelle/Isabelle2011-1/po.thy\")<br>\n*** Failed to parse type<br>\n*** At command \"locale\" (line 5 of \"/home/richter/Isabelle/Isabelle2011-1/po.thy\")</p>\n<p>Maybe that's progress, because Proof General is now noticing my first<br>\nquote a, and not just the second one.  </p>\n<p>I'm actually trying to understand Tim's Tarski geometry axiom code.<br>\nSo I tried compiling a simple version of it below.   Proof General<br>\ngives me an error message similar to the above one:</p>\n<p>*** Outer syntax error (line 5 of \"/home/richter/Isabelle/Isabelle2011-1/Scratch.thy\"): command expected,<br>\n*** but symbolic identifier - (line 5 of \"/home/richter/Isabelle/Isabelle2011-1/Scratch.thy\") was found</p>\n<p>But it's the code I'm more interested in now.  Tim's axioms make<br>\nperfect sense, except for the (- - ≡ - - [99,99,99,99] 50) on the line<br>\ndefining C.  I'm concerned about lemma A1, which just restates the<br>\naxiom A1.  I do something like that in my Mizar code, and I was really<br>\nhoping it wouldn't be necessary in Isabelle.  Maybe I don't know what<br>\nlemma A1 is for.  But there's plenty of stuff I don't understand in<br>\nTim's proof, like<br>\nby (simp add: A1)<br>\nwith A2 show ?thesis by blast</p>\n<p>On p 123 of isar-ref.pdf, this is somewhat explained:</p>\n<p>Typically, the soundness proof is relatively straight-forward,<br>\n   often just by canonical automated tools such as “by simp ” or “by<br>\n   blast ”.</p>\n<p>I'm guessing that simp and blast are like what HOL Light calls<br>\ntactics, search strategies for Isabelle to concoct a proof.  One of<br>\nthe nice things about Mizar is that you don't ever have to specify any<br>\nproof strategies, although clearly Mizar is using a strategy.</p>\n<p>Tim's ?thesis I bet can understand, from p 6:</p>\n<p>?thesis — the main conclusion of the innermost pending claim</p>\n<p>Tim's show ?thesis seems to be explained on p 126:</p>\n<p>Typical idioms for concluding calculational proofs are “finally show ?thesis .”</p>\n<p>---- simple version of Tim's Tarski code ----<br>\ntheory Tarski<br>\nimports Main <br>\nbegin</p>\n<p>locale tarski-first7 =<br>\n fixes C :: \"'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; bool \"  (- - ≡ - - [99,99,99,99] 50)<br>\nfixes B :: 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; bool<br>\n assumes A1: \\&lt;forall&gt; a b. a b \\&lt;equiv&gt; b a<br>\n and A2: \\&lt;forall&gt; a b p q r s. a b \\&lt;equiv&gt; p q \\&lt;and&gt; a b \\&lt;equiv&gt; r s −\\&lt;rightarrow&gt; p q \\&lt;equiv&gt; r s<br>\n and A3: \\&lt;forall&gt; a b c. a b \\&lt;equiv&gt; c c −\\&lt;rightarrow&gt; a = b<br>\n and A4: \\&lt;forall&gt; q a b c. \\&lt;exists&gt; x. B q a x \\&lt;and&gt; a x \\&lt;equiv&gt; b c<br>\n and A5: \\&lt;forall&gt; a b c d a b c d . a = b \\&lt;and&gt; B a b c \\&lt;and&gt; B a b c<br>\n                              \\&lt;and&gt;ab \\&lt;equiv&gt; a b \\&lt;and&gt;bc \\&lt;equiv&gt; b c \\&lt;and&gt;ad \\&lt;equiv&gt; a d \\&lt;and&gt; bd \\&lt;equiv&gt; b d<br>\n                        −\\&lt;rightarrow&gt; c d \\&lt;equiv&gt; c d<br>\n and A6: \\&lt;forall&gt; a b. B a b a −\\&lt;rightarrow&gt; a = b<br>\n and A7: \\&lt;forall&gt; a b c p q. B a p c \\&lt;and&gt; B b q c −\\&lt;rightarrow&gt; (\\&lt;exists&gt; x. B p x b \\&lt;and&gt; B q x a)</p>\n<p>context tarski-first7<br>\nbegin<br>\n lemma A1 : a b \\&lt;equiv&gt; b a<br>\n  by (simp add: A1)</p>\n<p>lemma A2 : [[a b \\&lt;equiv&gt; p q; a b \\&lt;equiv&gt; r s]] =\\&lt;Rightarrow&gt; p q \\&lt;equiv&gt; r s<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; p q and a b \\&lt;equiv&gt; r s<br>\n  with A2 show ?thesis by blast<br>\nqed</p>\n<p>lemma A3 : a b \\&lt;equiv&gt; c c =\\&lt;Rightarrow&gt; a = b<br>\n  by (simp add: A3)</p>\n<p>theorem th2-1: a b \\&lt;equiv&gt; a b<br>\nproof −<br>\n  from A2 [of b a a b a b] and A1 [of b a] show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-2: a b \\&lt;equiv&gt; c d =\\&lt;Rightarrow&gt; c d \\&lt;equiv&gt; a b<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with A2 [of a b c d a b] and th2-1 [of a b] show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-3: [[a b \\&lt;equiv&gt; c d; c d \\&lt;equiv&gt; e f ]] =\\&lt;Rightarrow&gt; a b \\&lt;equiv&gt; e f<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with th2-2 [of a b c d] have c d \\&lt;equiv&gt; a b by simp<br>\n  assume c d \\&lt;equiv&gt; e f<br>\n  with A2 [of c d a b e f ] and c d \\&lt;equiv&gt; a b show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-4: a b \\&lt;equiv&gt; c d =\\&lt;Rightarrow&gt; b a \\&lt;equiv&gt; c d<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with th2-3 [of b a a b c d] and A1 [of b a] show ?thesis by simp<br>\nqed</p>\n<p>theorem th2-5: a b \\&lt;equiv&gt; c d =\\&lt;Rightarrow&gt; a b \\&lt;equiv&gt; d c<br>\nproof −<br>\n  assume a b \\&lt;equiv&gt; c d<br>\n  with th2-3 [of a b c d d c] and A1 [of c d] show ?thesis by simp<br>\nqed</p>",
        "id": 294157998,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852039
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Bill,</p>\n<p>As soon as you open a theory file (extension \".thy\") with jEdit, it is <br>\nconstantly \"checked\" (even in parallel, for lemmas that are not <br>\ndependent in a linear fashion). (There is a thin column next to the main <br>\ntext buffer, where the total progress or errors are indicated. <br>\nFurthermore, errors are marked by red wavy lines inside the text buffer.)</p>\n<p>On a more general note. In principle I would strongly suggest to start <br>\nwith trivial proofs in order to get acquainted with the mechanisms of <br>\nIsabelle. And only afterwards try to formalize something serious.</p>\n<p>Concerning some of the points you mentioned:</p>\n<ul>\n<li>\n<p>PDFs or HTML sites that are generated from Isabelle theory files often <br>\nuse slightly different symbols/notation than is actually used as input. <br>\nA good way to get \"the real thing\" is having a look (e.g., with jEdit) <br>\nat the example theory files that are located in &lt;Isabelle <br>\ndirectory&gt;/src/HOL/ex/.</p>\n</li>\n<li>\n<p>In parallel to referring to reference manuals (like isar-ref) it is a <br>\ngood idea to read more tutorial-like texts, e.g., tutorial.pdf and <br>\nisar-overview.pdf, that are part of the documentation of Isabelle.</p>\n</li>\n<li>\n<p>It is mostly your own decision how big the steps of a proof are. You <br>\ncan do single steps (using the \"rule\" method) which results in huge <br>\nundigestable proofs. Or you can use methods like \"simp\" (equational <br>\nreasoning), \"blast\" (logical reasoning which should succeed on many <br>\nfirst-order proofs), \"auto\" (somewhat a combination of the previous <br>\ntwo), \"induction\" (for ... well, induction), \"cases\" (for case <br>\nanalysis). (In courses it is often done that students are only allowed <br>\nto use certain rules in order to proof a statement, since the automatic <br>\ntools would outright solve many typical examples.)</p>\n</li>\n</ul>\n<p>hope this helps,</p>\n<p>chris</p>",
        "id": 294158185,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852106
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nI've posted a number of times without getting the help I wanted.<br>\nIncluded below is 1000 lines of HOL-Light/miz3 code that works great.<br>\nI couldn't have written it without the help of John Harrison, who got<br>\nme started in 3 separate ways, and also Freek Wiedijk.  Someone can<br>\nprobably tell me how to port this code to Isabelle.  The Isabelle dox<br>\nfor proofs look great, but to me they are impenetrable.  I think I<br>\ncoded in the axioms correctly, in the file light below (Tarski) but I<br>\ncan't figure out how to write any Isabelle proofs.</p>\n<p>theory Tarski<br>\nimports Main <br>\nbegin</p>\n<p>locale tarski-first7 =<br>\nfixes C :: \"'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; bool\" (- - \\&lt;equiv&gt; - - [99,99,99,99] 50)<br>\nfixes B :: 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; 'p \\&lt;Rightarrow&gt; bool<br>\nassumes A1: \"\\&lt;forall&gt; a b. a b \\&lt;equiv&gt; b a\"<br>\n and A2: \"\\&lt;forall&gt; a b p q r s. a b \\&lt;equiv&gt; p q \\&lt;and&gt; a b \\&lt;equiv&gt; r s =\\&lt;Rightarrow&gt; p q \\&lt;equiv&gt; r s\"<br>\n and A3: \"\\&lt;forall&gt; a b c. a b \\&lt;equiv&gt; c c =\\&lt;Rightarrow&gt; a = b\"<br>\n and A4: \"\\&lt;forall&gt; q a b c. \\&lt;exists&gt; x. B q a x \\&lt;and&gt; a x \\&lt;equiv&gt; b c\"<br>\n and A5: \"\\&lt;forall&gt; a b c d a' b' c' d' . not(a = b) \\&lt;and&gt; B a b c \\&lt;and&gt; B a' b' c'<br>\n              \\&lt;and&gt; a b \\&lt;equiv&gt; a' b' \\&lt;and&gt; b c \\&lt;equiv&gt; b' c' \\&lt;and&gt; a d \\&lt;equiv&gt; a' d' \\&lt;and&gt; b d \\&lt;equiv&gt; b' d'<br>\n                        =\\&lt;Rightarrow&gt; c d \\&lt;equiv&gt; c' d'\"<br>\n and A6: \"\\&lt;forall&gt; a b. B a b a =\\&lt;Rightarrow&gt; a = b\"<br>\n and A7: \"\\&lt;forall&gt; a b c p q. B a p c \\&lt;and&gt; B b q c =\\&lt;Rightarrow&gt; \\&lt;exists&gt; x. B p x b \\&lt;and&gt; B q x a\"</p>\n<p>end</p>",
        "id": 294158276,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852144
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nI think what you might be looking for is Isabelle's locales.  In my<br>\nthesis, I used a locale (actually, several incremental locales) to<br>\ncharacterize Tarski's axioms.  Then, I could prove consequences of the<br>\naxioms inside the locales, and I could define models of the axioms<br>\noutside the locales that I later proved were instances of the locales.</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/yxumQJUZRBduDk2ipCnteIbx/signature.asc\">signature.asc</a></p>",
        "id": 294158334,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852174
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nJeremy, if you or anyone else wants to talk about Euclid off-line, I'd<br>\nbe happy to talk.  As I try to explain in my paper, I love the Elements<br>\n<a href=\"http://www.math.northwestern.edu/~richter/hilbert.pdf\">http://www.math.northwestern.edu/~richter/hilbert.pdf</a><br>\nIt's very creative and forms the basis of non-Euclidean geometry.</p>\n<p>Thanks, Chris, that's very helpful.  I'll look for the red wavy error<br>\nlines in jedit.  I'll look at /src/HOL/ex/.  I've looked at<br>\ntutorial.pdf, but I'll look again, and isar-overview.pdf sounds good.<br>\nThanks for explaining simp, blast etc, although I don't really know<br>\nwhat you mean.  Is there somewhere an FOL example, with a long<br>\n(perhaps indigestible) single step \"rule\" method proof, which is<br>\nshortened with simp, and then shortened even more with blast &amp; auto?</p>\n<p>(In courses it is often done that students are only allowed to use<br>\n   certain rules in order to proof a statement, since the automatic<br>\n   tools would outright solve many typical examples.)</p>\n<p>Wow!  Can you point me to any of these courses?  That sounds like what<br>\nI need to know.  As I posted earlier, I'm mostly trying to cite some<br>\ngood code for my geometry paper above (which I'll then submit).  I<br>\ndon't have to write the code myself, although I did<br>\n<a href=\"http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar\">http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar</a><br>\nExamples of real classroom situations where students hand in Isabelle<br>\nproofs would be fantastic!  Dunno about Europe, but US public schools<br>\nare really gungho about computer applications.</p>",
        "id": 294158895,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852382
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Bill,</p>\n<p>On 05/02/2012 01:09 PM, Bill Richter wrote:</p>\n<blockquote>\n<p>Thanks, Chris, that's very helpful.  I'll look for the red wavy error<br>\nlines in jedit.  I'll look at /src/HOL/ex/.  I've looked at<br>\ntutorial.pdf, but I'll look again, and isar-overview.pdf sounds good.<br>\nThanks for explaining simp, blast etc, although I don't really know<br>\nwhat you mean.  Is there somewhere an FOL example, with a long<br>\n(perhaps indigestible) single step \"rule\" method proof, which is<br>\nshortened with simp, and then shortened even more with blast&amp;  auto?<br>\nWell, not really indigestible, but consider the following Isabelle/HOL <br>\nproof of Pierce's Law:</p>\n</blockquote>\n<p>lemma Pierce1: \"((P --&gt; Q) --&gt; P) --&gt; P\"<br>\nproof (rule impI)<br>\n   assume 1: \"(P --&gt; Q) --&gt; P\"<br>\n   have \"(~ P) | P\" by (rule excluded_middle)<br>\n   thus P<br>\n   proof (rule disjE)<br>\n     assume \"P\" thus \"P\" by assumption<br>\n   next<br>\n     assume 2: \"~ P\"<br>\n     have \"P --&gt; Q\"<br>\n     proof (rule impI)<br>\n       assume \"P\"<br>\n       with 2 show \"Q\" by (rule notE)<br>\n     qed<br>\n     with 1 show \"P\" by (rule mp)<br>\n   qed<br>\nqed</p>\n<p>Which just uses the existing lemmas</p>\n<p>impI: (?P ==&gt; ?Q) ==&gt; ?P --&gt; ?Q<br>\nexcluded_middle: ~ ?P | ?P<br>\ndisjE: ?P | ?Q ==&gt; (?P ==&gt; ?R) ==&gt; (?Q ==&gt; ?R) ==&gt; ?R<br>\nnotE: ~ ?P ==&gt; ?P ==&gt; ?R<br>\nmp: ?P --&gt; ?Q ==&gt; ?P ==&gt; ?Q</p>\n<p>where the question marks indicate that variables can be instantiated <br>\narbitrarily (i.e., they are so called \"schematic variables\"). In this <br>\nproof every step (w.r.t. some given set of rules) is done explicitly. If <br>\nwe use \"blast\" (or \"auto\" for that matter) it reduces to.</p>\n<p>lemma Pierce2: \"((P --&gt; Q) --&gt; P) --&gt; P\" by blast</p>\n<p>But note that both proofs are equally rigorous, since blast just applies <br>\nexisting lemmas that are setup as introduction and elimination rules for <br>\nlogical symbols (besides others). (The whole idea of proof assistants <br>\nlike Isabelle, is that internally everything is reducible to the initial <br>\naxioms, whether this is done by hand or left to the system is to some <br>\nextend the users choice [sometimes the automatic methods are just not <br>\npowerful enough to solve a goal and the user has to divide it in smaller <br>\npieces manually].)</p>\n<blockquote>\n<p>(In courses it is often done that students are only allowed to use<br>\n    certain rules in order to proof a statement, since the automatic<br>\n    tools would outright solve many typical examples.)</p>\n<p>Wow!  Can you point me to any of these courses?  That sounds like what<br>\nI need to know.  As I posted earlier, I'm mostly trying to cite some<br>\ngood code for my geometry paper above (which I'll then submit).  I<br>\ndon't have to write the code myself, although I did<br>\n<a href=\"http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar\">http://www.math.northwestern.edu/~richter/RichterTarskiMizar.tar</a><br>\nExamples of real classroom situations where students hand in Isabelle<br>\nproofs would be fantastic!  Dunno about Europe, but US public schools<br>\nare really gungho about computer applications.<br>\nThere is the Isabelle Community Wiki</p>\n</blockquote>\n<p><a href=\"https://isabelle.in.tum.de/community\">https://isabelle.in.tum.de/community</a></p>\n<p>(which has not yet really come to life). It contains pointers to some <br>\ncourses that use or are about Isabelle</p>\n<p><a href=\"https://isabelle.in.tum.de/community/Course_Material\">https://isabelle.in.tum.de/community/Course_Material</a></p>\n<p>This could be interesting for you.</p>\n<p>hope this helps</p>\n<p>chris</p>",
        "id": 294159083,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852450
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nMakarius ported to Isabelle 100+ lines (below) of my HOL-Light/miz3<br>\ncode I posted here on May 20, which is more or less a port of Julien<br>\nNarboux's Coq pseudo-code.  I'm thrilled the Isabelle maintainers took<br>\nsuch an interest in Tarski axiomatic geometry:</p>\n<p>M&gt; I've spent maybe 1 or 2 hours on the various versions of the Tarski<br>\nM&gt; axiomatization by Bill, Julien Narboux, John Harrison, and<br>\nM&gt; Wikipedia.  Bill had a slight divergence in some details in his 2<br>\nM&gt; or 3 versions that I did not follow to the bottom.</p>\n<p>Makarius's port proved a theorem that's false, the last theorem below,<br>\nC1.  The problem seems to be Makarius's axiom</p>\n<p>A5: \"a ≠ b ⟹ Bet a b c ⟹ Bet a' b' c' ⟹ a b c ≐≐ a' b' c' ⟹<br>\n      b d ≐ b' d' ⟹ c d ≐ c' d'\"</p>\n<p>I think this is my error, from my Isabelle file 6Tarski.thy, which I<br>\nthink I posted here.  My deepest apologies!  I should have written</p>\n<p>and A5: \"∀ a b c d a' b' c' d' . not(a = b) ∧ B a b d ∧ B a' b' d'<br>\n              ∧ a b ≡ a' b' ∧ b c ≡ b' c' ∧ a d ≡ a' d' ∧ b d ≡ b' d'<br>\n                        =⇒ c d ≡ c' d'\"</p>\n<p>which is basically Tarksi's version of the SAS axiom (which Tarski<br>\ncleverly defined without having angles!), which I got right in miz3</p>\n<p>let A5 = new_axiom<br>\n<code>!a b c d a' b' c' d'.\n        ~(a = b) /\\ a,b,c cong a',b',c' /\\\n        Between(a,b,d) /\\ Between(a',b',d') /\\ b,d === b',d'\n        ==&gt; c,d === c',d'</code>;;</p>\n<p>Makarius, I think you needed <br>\nBet a b d ⟹ Bet a' b' d',<br>\nbut you sure did a whole better than I did!  I couldn't even get the<br>\naxiom locale to work, or prove anything.  I made the change, and now<br>\njedit gives an error, with do-not-enters on the last 4 lines:</p>\n<p>with neq Bet Bet have \"y x ≐ y y\" using <code>b x ≐ b y</code> by (rule A5)<br>\n  then show ?thesis by (rule A3)<br>\nqed</p>\n<p>end</p>\n<p>So I uncommented the assumption<br>\n    and \"Bet a b x\"<br>\nbut I still get these 4 do-not-enters.  Uh, would you try try again? </p>\n<p>A few things confuse me about your code, e.g.</p>\n<p>defines \"a b c ≐≐ x y z ≡ a b ≐ x y ∧ a c ≐ x z ∧ b c ≐ y z\"</p>\n<p>So ≡ means \"if and only if\", which in HOL-Light is &lt;=&gt;? </p>\n<p>Two of Tarski's first 7 axioms are constructive (some point x exists),<br>\nA4 and A7, and you proved rules for them, using what I thought was a<br>\nvery powerful automation tool blast:</p>\n<p>lemma A4_rule: obtains x where \"Bet q a x\" and \"a x ≐ b c\"<br>\n  using A4 by blast</p>\n<p>and then used A4 by e.g. writing </p>\n<p>obtain x where x: \"Bet q a x\" \"a x ≐ a a\" by (rule A4_rule)</p>\n<p>Hmm, you don't have to do that in Mizar or Freek's miz3.</p>\n<p>Now I ran your code in the spanking new Isabelle:</p>\n<p>(poisson)Isabelle2012&gt; ./Isabelle ../Tarski.thy &amp;</p>\n<p>I'm a newbie, but it sure looks to me that jedit thinks your code is<br>\nperfect.  Let me explain why your last result shouldn't be true:</p>\n<p>lemma C1:<br>\n  assumes neq: \"a ≠ b\"<br>\n    and Bet: \"Bet a b y\"<br>\n(*  and \"Bet a b x\"    -- \"FIXME unused\"  *)<br>\n    and \"b x ≐ b y\"<br>\n  shows \"y = x\"<br>\nproof -<br>\n  have 1: \"a b ≐ a b\" ..<br>\n  have 2: \"b y ≐ b y\" ..<br>\n  have \"a b y ≐≐ a b y\" ..<br>\n  with neq Bet Bet have \"y x ≐ y y\" using <code>b x ≐ b y</code> by (rule A5)<br>\n  then show ?thesis by (rule A3)<br>\nqed</p>\n<p>Tarski's axioms hold in the plane R^2, in which the result means this.</p>\n<p>Let <code>l' be the line containing two distinct points </code>a' and <code>b'.  Take\n</code>y' to be a point on `l' so that b is between a and y.  (That means<br>\nthat y can equal b.)   Now take a point x in the plane so that <br>\nlength bx = length by.<br>\nThen x = y.</p>\n<p>Of course that's false (unless y = b).  There's a whole circle of such<br>\npoints x, with center b and radius length by.</p>",
        "id": 294159343,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852561
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 25 May 2012, Bill Richter wrote:</p>\n<blockquote>\n<p>Makarius's port proved a theorem that's false, the last theorem below,<br>\nC1.  The problem seems to be Makarius's axiom</p>\n<p>A5: \"a ≠ b ⟹ Bet a b c ⟹ Bet a' b' c' ⟹ a b c ≐≐ a' b' c' ⟹<br>\n     b d ≐ b' d' ⟹ c d ≐ c' d'\"</p>\n<p>I think this is my error, from my Isabelle file 6Tarski.thy, which I<br>\nthink I posted here.  My deepest apologies!  I should have written</p>\n<p>and A5: \"∀ a b c d a' b' c' d' . not(a = b) ∧ B a b d ∧ B a' b' d'<br>\n             ∧ a b ≡ a' b' ∧ b c ≡ b' c' ∧ a d ≡ a' d' ∧ b d ≡ b' d'<br>\n                       =⇒ c d ≡ c' d'\"</p>\n<p>which is basically Tarksi's version of the SAS axiom (which Tarski<br>\ncleverly defined without having angles!), which I got right in miz3</p>\n</blockquote>\n<p>Of course the theorem was true under the given assumptions.  It happens <br>\nroutinely in formalizations that something else is formalized than <br>\nexpected.  This is why unguarded axiomatizations are so dangerous.  Here <br>\nwe made a locale definition instead, and in the worst case the <br>\ncorresponding predicate tarski_first7 could turn out to be always False, <br>\nnot more no less.</p>\n<blockquote>\n<p>I made the change, and now jedit gives an error, with do-not-enters on <br>\nthe last 4 lines:</p>\n<p>with neq Bet Bet have \"y x ≐ y y\" using <code>b x ≐ b y</code> by (rule A5)<br>\n then show ?thesis by (rule A3)<br>\nqed</p>\n<p>end</p>\n<p>So I uncommented the assumption<br>\n   and \"Bet a b x\"<br>\nbut I still get these 4 do-not-enters.  Uh, would you try try again?</p>\n</blockquote>\n<p>Here is my proof with the amended locale definition:</p>\n<p>lemma C1:<br>\n   assumes neq: \"a ≠ b\"<br>\n     and Bet1: \"Bet a b y\"<br>\n     and Bet2: \"Bet a b x\"<br>\n     and b: \"b x ≐ b y\"<br>\n   shows \"y = x\"<br>\nproof -<br>\n   have \"y x ≐ y y\"<br>\n   using neq Bet2 Bet1 _ b<br>\n   proof (rule A5)<br>\n     show \"a b y ≐≐ a b y\" ..<br>\n   qed<br>\n   then show ?thesis by (rule A3)<br>\nqed</p>\n<p>We are doing precise single step reasoning here, which means all the slots <br>\nfor the rules need to be filled in the correct order.  This is not Mizar <br>\nor any of the Mizar modes for HOL, which are centered around classic <br>\npredicate logic with some builtin proof automation to bridge larger gaps.</p>\n<p>Note that the precise natural deduction of the Pure Isar proof has <br>\nexhibited the mistake in the A5 specification, in the first place.</p>\n<blockquote>\n<p>A few things confuse me about your code, e.g.</p>\n<p>defines \"a b c ≐≐ x y z ≡ a b ≐ x y ∧ a c ≐ x z ∧ b c ≐ y z\"</p>\n<p>So ≡ means \"if and only if\", which in HOL-Light is &lt;=&gt;?</p>\n</blockquote>\n<p>No it is Pure equality.  Unlike 'definition', the 'defines' element cannot <br>\nwork with object-level =.</p>\n<blockquote>\n<p>Two of Tarski's first 7 axioms are constructive (some point x exists),<br>\nA4 and A7, and you proved rules for them, using what I thought was a<br>\nvery powerful automation tool blast:</p>\n<p>lemma A4_rule: obtains x where \"Bet q a x\" and \"a x ≐ b c\"<br>\n using A4 by blast</p>\n<p>and then used A4 by e.g. writing</p>\n<p>obtain x where x: \"Bet q a x\" \"a x ≐ a a\" by (rule A4_rule)</p>\n<p>Hmm, you don't have to do that in Mizar or Freek's miz3.</p>\n</blockquote>\n<p>The locale definition only allows closed Pure rule statements, not the <br>\nopen Isar form with fixes/assumes--shows/obtains, so I proved them as <br>\nlemmas later on in the context.  By doing that, the heavy-duty classical <br>\nreasoning of blast was clearly isolated in some derived rules. In Mizar or <br>\nmiz3, it would have intruded the proof, and the mistake in your A5 would <br>\nnot have been discovered.  (You did not have it in the miz3 version that <br>\nyou sent me, but in the Isabelle attempt.)</p>\n<blockquote>\n<p>Let me explain why your last result shouldn't be true:</p>\n<p>lemma C1:<br>\n assumes neq: \"a ≠ b\"<br>\n   and Bet: \"Bet a b y\"<br>\n(*  and \"Bet a b x\"    -- \"FIXME unused\"  *)<br>\n   and \"b x ≐ b y\"<br>\n shows \"y = x\"<br>\nproof -<br>\n have 1: \"a b ≐ a b\" ..<br>\n have 2: \"b y ≐ b y\" ..<br>\n have \"a b y ≐≐ a b y\" ..<br>\n with neq Bet Bet have \"y x ≐ y y\" using <code>b x ≐ b y</code> by (rule A5)<br>\n then show ?thesis by (rule A3)<br>\nqed</p>\n<p>Tarski's axioms hold in the plane R^2, in which the result means this.</p>\n<p>Let <code>l' be the line containing two distinct points </code>a' and <code>b'.  Take\n</code>y' to be a point on `l' so that b is between a and y.  (That means<br>\nthat y can equal b.)   Now take a point x in the plane so that<br>\nlength bx = length by.<br>\nThen x = y.</p>\n<p>Of course that's false (unless y = b).  There's a whole circle of such <br>\npoints x, with center b and radius length by.</p>\n</blockquote>\n<p>That is an informal argument.  It merely motivates why something in the <br>\nformalization had to be amended.</p>\n<p>Makarius</p>",
        "id": 294159455,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852591
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nThanks, Makarius, I'll run your code and study it.  Is this explained<br>\nsomewhere in the Isabelle dox, or could you explain it better:</p>\n<p>We are doing precise single step reasoning here, which means all<br>\n   the slots for the rules need to be filled in the correct order.<br>\n   This is not Mizar or any of the Mizar modes for HOL, which are<br>\n   centered around classic predicate logic with some builtin proof<br>\n   automation to bridge larger gaps.</p>\n<p>I would have said FOL instead of predicate logic, does that mean the<br>\nsame?  I'm not an expert in FOL, but I think FOL proofs tend to be<br>\nvery tedious, and the builtin Mizar proof automation turns these FOL<br>\nproofs into something that is a real pleasure to code up.  Is that<br>\nright?  And Isabelle (Isar?) is doing something different from that?</p>\n<blockquote>\n<p>Of course that's false (unless y = b).  There's a whole circle of<br>\nsuch points x, with center b and radius length by.</p>\n</blockquote>\n<p>That is an informal argument.  It merely motivates why something in<br>\n   the formalization had to be amended.</p>\n<p>Absolutely!  </p>\n<p>In Mizar or miz3, it would have intruded the proof, and the mistake<br>\n   in your A5 would not have been discovered.  </p>\n<p>I bet it would have been discovered!  I wrote 1500 lines of Mizar<br>\nproofs (slimmed down to 1000 miz3 lines), that's bound to shake out<br>\nbugs in the axioms.</p>\n<p>(You did not have it in the miz3 version that you sent me, but in<br>\n   the Isabelle attempt.)</p>\n<p>Let me apologize again for sending you the busted A5 Isabelle code.</p>\n<p>This is why unguarded axiomatizations are so dangerous.  Here we<br>\n   made a locale definition instead, and in the worst case the<br>\n   corresponding predicate tarski_first7 could turn out to be always<br>\n   False, not more no less.</p>\n<p>Yes, and thus locales are definitely a real advantage of Isabelle over<br>\nHOL Light right now.  Still, I wonder why one can't just define all<br>\nthe sets you'd want in HOL Light (only very lightly typed) to get<br>\nsomething like a locale.  That is, I think of your locale as something<br>\nclose to FOL Tarski axiomatic geometry proofs.  But instead we could<br>\nlook at all models of Tarski's axioms, a model being some sets and<br>\nfunctions with some properties.  Can you do this in Isabelle too?</p>",
        "id": 294159608,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852640
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nOops, of course I meant \"Peirce\" (but after three occurrences I can <br>\nhardly claim this as a typo ;)).</p>",
        "id": 294159645,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852655
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 27 May 2012, Bill Richter wrote:</p>\n<blockquote>\n<p>Thanks, Makarius, I'll run your code and study it.  Is this explained<br>\nsomewhere in the Isabelle dox, or could you explain it better:</p>\n<p>We are doing precise single step reasoning here, which means all<br>\n  the slots for the rules need to be filled in the correct order.<br>\n  This is not Mizar or any of the Mizar modes for HOL, which are<br>\n  centered around classic predicate logic with some builtin proof<br>\n  automation to bridge larger gaps.</p>\n<p>I would have said FOL instead of predicate logic, does that mean the<br>\nsame?  I'm not an expert in FOL, but I think FOL proofs tend to be<br>\nvery tedious, and the builtin Mizar proof automation turns these FOL<br>\nproofs into something that is a real pleasure to code up.  Is that<br>\nright?  And Isabelle (Isar?) is doing something different from that?</p>\n</blockquote>\n<p>The Isabelle/Pure framework is centered around higher-order natural <br>\ndeduction, and Isabelle/Isar as a proof language continues these ideas. To <br>\nunderstand these things properly, you should first blot out \"FOL\", then <br>\nget used to Pure + Isar, then add HOL as object-logic, and then rediscover <br>\nwhat predicate logic (including FOL) will do for you here via some add-on <br>\ntools.</p>\n<blockquote>\n<p>Yes, and thus locales are definitely a real advantage of Isabelle over<br>\nHOL Light right now.  Still, I wonder why one can't just define all<br>\nthe sets you'd want in HOL Light (only very lightly typed) to get<br>\nsomething like a locale.</p>\n</blockquote>\n<p>In principle any of the HOL systems could provide their own locale <br>\nmechanism, or something similar.  It is not possible to \"just\" do it, <br>\nthough.  Isabelle has required 10+ years to get this all done right. It is <br>\nalso a matter of culture.  John Harrison would certainly not add such <br>\ncomplexity to his system.  You have to use Isabelle or Coq for such <br>\nsophisticated module concepts, or maybe Mizar.</p>\n<blockquote>\n<p>That is, I think of your locale as something close to FOL Tarski <br>\naxiomatic geometry proofs.  But instead we could look at all models of <br>\nTarski's axioms, a model being some sets and functions with some <br>\nproperties.  Can you do this in Isabelle too?</p>\n</blockquote>\n<p>If this means you want to study the meta-theory of Tarski axioms, then any <br>\nof the HOL systems -- Isabelle/HOL included -- can do this for you, if you <br>\ndefine the syntax and inference system more concretely (via datatypes and <br>\ninductive relations).</p>\n<p>Makarius</p>",
        "id": 294159872,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852732
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nThanks, Makarius, and I really like your posts on hol info.  I'd be<br>\nhappy for you to post there about miz3 ocaml dirty code cache issues.</p>\n<p>The Isabelle/Pure framework is centered around higher-order natural<br>\n   deduction, and Isabelle/Isar as a proof language continues these<br>\n   ideas. To understand these things properly, you should first blot<br>\n   out \"FOL\", then get used to Pure + Isar, then add HOL as<br>\n   object-logic, and then rediscover what predicate logic (including<br>\n   FOL) will do for you here via some add-on tools.</p>\n<p>I'm not opposed to learning Pure + Isar, but it would be a whole lot<br>\neasier for me to learn if I knew in advance how it related to FOL,<br>\nwhich as a mathematician I have a rudimentary (but not practical)<br>\nunderstanding of.  Let me make a rudimentary FOL point:</p>\n<p>I think writing down strict axiomatic FOL proofs would really be<br>\ntedious because e.g. you have manually substitute variables every time<br>\nyou want to use an axiom.  I don't have a full list of the tedium<br>\nstrict FOL can cause.  But I'm only willing to write up FOL-type<br>\nproofs if the proof assistant will automate that tedium.  Do similar<br>\nissues arise with Pure + Isar?</p>\n<p>Also, as you may have observed on hol info, I know next to nothing<br>\nabout HOL.  Basically I understand the 20 pages of set theory John<br>\nexplains in his reference manual.  Isn't Isabelle HOL much the same as<br>\nHOL as in HOL Light HOL?  Where is a good place to learn about HOL?</p>\n<blockquote>\n<p>Yes, and thus locales are definitely a real advantage of Isabelle<br>\nover HOL Light right now.  Still, I wonder why one can't just<br>\ndefine all the sets you'd want in HOL Light (only very lightly<br>\ntyped) to get something like a locale.</p>\n</blockquote>\n<p>In principle any of the HOL systems could provide their own locale<br>\n   mechanism, or something similar.  It is not possible to \"just\" do<br>\n   it, though.  Isabelle has required 10+ years to get this all done<br>\n   right. It is also a matter of culture.  John Harrison would<br>\n   certainly not add such complexity to his system.  You have to use<br>\n   Isabelle or Coq for such sophisticated module concepts, or maybe<br>\n   Mizar.</p>\n<p>Sure, but I really dislike the Mizar type system, and I want to<br>\nlightly typed sets to avoid any hard typing.  More below: </p>\n<blockquote>\n<p>But instead we could look at all models of Tarski's axioms, a<br>\nmodel being some sets and functions with some properties.  Can<br>\nyou do this in Isabelle too?</p>\n</blockquote>\n<p>If this means you want to study the meta-theory of Tarski axioms,<br>\n   then any of the HOL systems -- Isabelle/HOL included -- can do this<br>\n   for you, if you define the syntax and inference system more<br>\n   concretely (via datatypes and inductive relations).</p>\n<p>Great, but I don't know what meta-theory means.  A model of Tarski's<br>\ngeometry axioms is be a set S (of points), a 3-ary relation Between on<br>\nS and a 4-ary relation Equiv on S satisfying Tarski's axioms (so far I<br>\nonly use his first 7 axioms, and you coded them up in Isabelle).  So<br>\nthere might be a predicate TarskiModel(S, Between, Equiv), and<br>\ntheorems in a Tarski model would begin</p>\n<p>assume TarskiModel(S, Between, Equiv)...</p>\n<p>I don't understand HOL well enough to actually pull this off, but John<br>\nexplained how to get started.  My point is that I don't think any<br>\ntyping is involved here, beyond maybe something rudimentary like</p>\n<p>new_type(\"point\",0);;<br>\nnew_type_abbrev(\"TarskiPlane\",<code>:point-&gt;bool</code>);;</p>",
        "id": 294160117,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852806
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 30 May 2012, Bill Richter wrote:</p>\n<blockquote>\n<p>I'd be happy for you to post there about miz3 ocaml dirty code cache <br>\nissues.</p>\n</blockquote>\n<p>Better not.  I did not really follow that detail of this highly complex <br>\nthread.  It is part of the miz3 philosophy to do things in a certain way, <br>\nand Freek has a right to take his preferred way.</p>\n<blockquote>\n<p>The Isabelle/Pure framework is centered around higher-order natural<br>\n  deduction, and Isabelle/Isar as a proof language continues these<br>\n  ideas. To understand these things properly, you should first blot<br>\n  out \"FOL\", then get used to Pure + Isar, then add HOL as<br>\n  object-logic, and then rediscover what predicate logic (including<br>\n  FOL) will do for you here via some add-on tools.</p>\n<p>I'm not opposed to learning Pure + Isar, but it would be a whole lot<br>\neasier for me to learn if I knew in advance how it related to FOL,<br>\nwhich as a mathematician I have a rudimentary (but not practical)<br>\nunderstanding of.</p>\n</blockquote>\n<p>In my rough \"education plan\" above, the relation to FOL was the last step, <br>\nnot the first one.  It is easier to get started with a clear mind.</p>\n<blockquote>\n<p>Let me make a rudimentary FOL point:</p>\n<p>I think writing down strict axiomatic FOL proofs would really be<br>\ntedious because e.g. you have manually substitute variables every time<br>\nyou want to use an axiom.  I don't have a full list of the tedium<br>\nstrict FOL can cause.  But I'm only willing to write up FOL-type<br>\nproofs if the proof assistant will automate that tedium.  Do similar<br>\nissues arise with Pure + Isar?</p>\n</blockquote>\n<p>I can only guess what you mean by \"strict axiomatic FOL proof\".  There are <br>\nmany ways to define what a logical inference system is, and how proofs are <br>\ndone.</p>\n<p>In Isabelle Pure it is done over lambda-calculus as syntax, and via <br>\nbackchaining of natural deduction rules with implicit unification to solve <br>\nthe instantiation problems arising here.  BTW, Isar means \"Intelligible <br>\nsemi-automated reasoning\", because the only proof automation built into <br>\nthe proof language is unification, which is typically used together with <br>\nimplicit selection of rules from the context (library etc.) as determined <br>\nfrom the structure of the text.  That's the whole secret of it.</p>\n<p>Any other proof automation is quoted explicitly in the Isar text, via <br>\n\"proof methods\": blast, simp, auto, metis, smt, ... ad infinitum. You go <br>\nto the store and order the kind of washing machine you prefer, or do <br>\nthings purely by hand ...</p>\n<blockquote>\n<p>Also, as you may have observed on hol info, I know next to nothing<br>\nabout HOL.  Basically I understand the 20 pages of set theory John<br>\nexplains in his reference manual.  Isn't Isabelle HOL much the same as<br>\nHOL as in HOL Light HOL?  Where is a good place to learn about HOL?</p>\n</blockquote>\n<p>You should not spend to much time with that.  If you take HOL as a <br>\nsimplified version of set-theory with explicit syntactic types it is OK as <br>\na start.  Foundationally, HOL is not so interesting than it was in 1940 or <br>\n1950.</p>\n<blockquote>\n<p>In principle any of the HOL systems could provide their own locale<br>\n  mechanism, or something similar.  It is not possible to \"just\" do<br>\n  it, though.  Isabelle has required 10+ years to get this all done<br>\n  right. It is also a matter of culture.  John Harrison would<br>\n  certainly not add such complexity to his system.  You have to use<br>\n  Isabelle or Coq for such sophisticated module concepts, or maybe<br>\n  Mizar.</p>\n<p>Sure, but I really dislike the Mizar type system, and I want to<br>\nlightly typed sets to avoid any hard typing.</p>\n</blockquote>\n<p>Note that HOL typing is particularly hard.  Every type is its own isolated <br>\nuniverse, although a rather small one.  You need explicit morphisms to <br>\ntravel between such distinct worlds.</p>\n<blockquote>\n<blockquote>\n<p>But instead we could look at all models of Tarski's axioms, a<br>\nmodel being some sets and functions with some properties.  Can<br>\nyou do this in Isabelle too?</p>\n</blockquote>\n<p>If this means you want to study the meta-theory of Tarski axioms,<br>\n  then any of the HOL systems -- Isabelle/HOL included -- can do this<br>\n  for you, if you define the syntax and inference system more<br>\n  concretely (via datatypes and inductive relations).</p>\n<p>Great, but I don't know what meta-theory means.  A model of Tarski's<br>\ngeometry axioms is be a set S (of points), a 3-ary relation Between on<br>\nS and a 4-ary relation Equiv on S satisfying Tarski's axioms (so far I<br>\nonly use his first 7 axioms, and you coded them up in Isabelle).  So<br>\nthere might be a predicate TarskiModel(S, Between, Equiv), and<br>\ntheorems in a Tarski model would begin</p>\n</blockquote>\n<p>You get such a predicate already from the locale tarski_first7 that I've <br>\nproduced for you.  It is called \"tarski_first7\" and can be used within the <br>\nlogical language:</p>\n<p>term \"tarski_first7\"</p>\n<p>The system will check that and print the most general type for it:<br>\n\"('a ⇒ 'a ⇒ 'a ⇒ 'a ⇒ bool) ⇒ ('a ⇒ 'a ⇒ 'a ⇒ bool) ⇒ bool\". You <br>\ncan also hover over the formal term to get it explained.</p>\n<p>Note that the type is naturally curried as everything by default in <br>\nIsabelle Pure -- just like in good HOL families.</p>\n<p>Moreover your carrier set S is actually modeled as a type here, in the <br>\nusual manner in HOL.  You can relativize it to a set over the base type, <br>\nbut that is a different story of the larger HOL family.</p>\n<blockquote>\n<p>assume TarskiModel(S, Between, Equiv)...</p>\n</blockquote>\n<p>This is what the locale context \"begin\" does for you implicitly, and then <br>\nyou start to define derived things and state theorems and do proofs from <br>\nit.  This means you are developing a concrete \"theory\", but this is not <br>\nmeta-theory.</p>\n<p>Meta theory means you speak about things, by stepping aside or outside <br>\nfrom it.  Here is an arbitrary example from AFP, which I have happened to <br>\nhave browsed two weeks ago with a student: <br>\n<a href=\"http://afp.sourceforge.net/entries/Completeness.shtml\">http://afp.sourceforge.net/entries/Completeness.shtml</a></p>\n<p>The example develops the logical inference system and semantics of a <br>\nversion of first-order logic in the usual way, almost literally from the <br>\nbook (I don't know which one).  There are just the usual formalization <br>\ntweaks to represent it as concrete formal things inside HOL (and a slight <br>\ntendency of redundant copies of basic mathematical HOL concepts used in <br>\nthe development).</p>\n<blockquote>\n<p>I don't understand HOL well enough to actually pull this off, but John<br>\nexplained how to get started.  My point is that I don't think any<br>\ntyping is involved here, beyond maybe something rudimentary like</p>\n<p>new_type(\"point\",0);;<br>\nnew_type_abbrev(\"TarskiPlane\",<code>:point-&gt;bool</code>);;</p>\n</blockquote>\n<p>That is a global axiomatic theory.  In Isabelle/HOL is would look like <br>\nthis:</p>\n<p>axiomatization<br>\n   Cong :: \"point ⇒ point ⇒ point ⇒ point ⇒ bool\"  (\"_ _ ≐ _ _\" [1000, <br>\n1000, 1000, 1000] 50) and<br>\n   Cong3  (\"_ _ _ ≐≐ _ _ _\" [1000, 1000, 1000, 1000, 1000, 1000] 50) and<br>\n   Bet :: \"point ⇒ point ⇒ point ⇒ bool\"<br>\nwhere<br>\n   Cong3_def: \"a b c ≐≐ x y z ≡ a b ≐ x y ∧ a c ≐ x z ∧ b c ≐ y z\"<br>\n     and A1: \"a b ≐ b a\"<br>\n     and A2: \"a b ≐ p q ⟹ a b ≐ r s ⟹ p q ≐ r s\"<br>\n     and A3: \"a b ≐ c c ⟹ a = b\"<br>\n     and A4: \"∃x. Bet q a x ∧ a x ≐ b c\"<br>\n     and A5: \"a ≠ b ⟹ Bet a b d ⟹ Bet a' b' d' ⟹ a b c ≐≐ a' b' c' ⟹<br>\n       b d ≐ b' d' ⟹ c d ≐ c' d'\"<br>\n     and A6: \"Bet a b a ⟹ a = b\"<br>\n     and A7: \"Bet a p c ⟹ Bet b q c ⟹ ∃x. Bet p x b ∧ Bet q x a\"</p>\n<p>Showing that publicly on isabelle-users, most people should frown upun it <br>\n-- shudder.  There are all these sophisticated ways to make things local <br>\nin Isabelle ...</p>\n<p>Makarius</p>",
        "id": 294160201,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852837
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nThanks, Tim!  I'll look carefully at your code, and study locales.</p>\n<p>I should read Scott and Fleuriot's HOL Light article carefully, and<br>\nalso Meikle and Fleuriot's Isabelle paper you cited<br>\n<a href=\"http://www.springerlink.com/content/6ngakhj9k7qj71th/fulltext.pdf\">http://www.springerlink.com/content/6ngakhj9k7qj71th/fulltext.pdf</a>.<br>\nI'm annoyed Hilbert wrote such an unreadable book FoG, and I wonder he<br>\ndidn't take too much credit from Pasch.  So I can learn from Scott,<br>\nFleuriot &amp; Meikle.  But they need to learn how Euclid's errors were<br>\ncorrected using Hilbert's axioms.  I explain this nicely in<br>\n<a href=\"http://www.math.northwestern.edu/~richter/hilbert.pdf\">http://www.math.northwestern.edu/~richter/hilbert.pdf</a> <br>\nAlmost no working mathematicians understand the Euclid and<br>\nHilbert's-axiom story, and I only learned it this year, to help my son<br>\nwith Geometry, as his textbook was incredibly unrigorous.  He read my<br>\npaper and my Mizar code quite carefully, and that's why I'm here.</p>\n<p>What Meikle and Fleuriot write here is misleading:</p>\n<p>It is generally accepted that Hilbert’s work managed to eradicate<br>\n   the need for INTUITION in deriving results.</p>\n<p>That's OK if we replace INTUITION by `drawing pictures instead of<br>\nusing axioms'.  What is generally accepted is that Hilbert’s work<br>\nmanaged to eradicate Euclid's pervasive angle-addition errors.</p>\n<p>Back to Scott and Fleuriot, you may be correct that they found an<br>\nerror involving solid geometry vs plane geometry.  I'll look into it.<br>\nBut Scott and Fleuriot's full quote is very misleading:</p>\n<p>in their attempt to formalise the axiomatics and its elementary<br>\n   theorems, Meikle and Fleuriot found many missing lemmas<br>\n   [11]. Indeed, IT IS SUFFICIENT to note that Hilbert followed Euclid<br>\n   in one pervasive omission: they both give proofs on an ambient<br>\n   plane when the axioms characterise solid geometry [8].</p>\n<p>It is not sufficient.  We must note that textbooks by Greenberg &amp;<br>\nHartshorne gave acceptably rigorous treatments using Hilbert's axioms,<br>\nand nobody has ever given rigorous proofs using Euclid's axioms.</p>\n<p>Tim, you really ought to understand the Euclid and Hilbert-axiom<br>\nstory, being a Tarski geometry guy.  Can you find</p>\n<p>M. Greenberg, Euclidean and non-Euclidean geometries, W. H. Freeman<br>\nand Co., 1974. </p>\n<p>R. Hartshorne, Geometry, Euclid and Beyond, Undergraduate Texts in<br>\nMath., Springer, 2000.</p>\n<p>Greenberg's recent survey is quite readable and has interesting<br>\nmathematical logic relating Tarski's axioms to Hilbert's.</p>\n<p>Old and new results in the foundations of elementary plane Euclidean<br>\nand non-Euclidean geometries, Amer. Math. Monthly 117 (2010),<br>\n198--219.</p>",
        "id": 294160222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852849
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nOur paper aims to provide a formal system, E, that mirrors the<br>\n   structure of Euclid's proof. We show how such a system can be<br>\n   interpreted in terms of more conventional proof systems (like<br>\n   Hilbert's), </p>\n<p>Jeremy, this is very interesting, and explained on p 69 of your paper:</p>\n<p>ADM&gt; Below, however, we will show that with a modicum of tinkering,<br>\nADM&gt; Tarski’s axioms can be expressed in a restricted form, namely, as<br>\nADM&gt; a system of geometric rules. We will then invoke a cut<br>\nADM&gt; elimination theorem, due to Sara Negri, that shows that if a<br>\nADM&gt; sequent of suitably restricted complexity is provable in the<br>\nADM&gt; system, there is a proof in which every intermediate sequent is<br>\nADM&gt; also of restricted complexity. This will allow us to translate<br>\nADM&gt; proofs in Tarski’s system to proofs in E.</p>\n<p>I don't see where you went the other way, translating your proofs into<br>\nTarski axiomatic proofs.  You are saying that rigorous Hilbert/Tarski<br>\naxiomatic proofs are simpler than proofs in your framework, right?</p>\n<p>Probably you understand the advantage of Tarski's axioms over<br>\nHilbert's, but I'll say it anyway: Mostly the advantage is that Tarski<br>\nin a first order axiom basically said that every line is the real<br>\nline, so that the model is R x R.  Hilbert got that earlier with a<br>\nsecond order logic axiom, a Dedekind cuts axiom.  Tarski actually only<br>\ngot F x F, for a real closed field F, but that's good enough, as he<br>\nshowed that the theory of real closed fields is decidable.  But do you<br>\nneed decidability?  I see you mention it often.  Ziegler's result that<br>\nyou cite is used by Greenberg (Amer. Math. Monthly 2010) to show that<br>\nHilbert's first order geometry is undecidable.</p>\n<p>but getting Isabelle to verify proofs in E as such would require<br>\n   extending Isabelle with some automation to bridge the gap.</p>\n<p>But the Isabelle folks are looking for that kinda work (so I copied<br>\nthe list)!  I think that's why Scott, Fleuriot &amp; Meikle are coding up<br>\nHilbert's book FoG, to give HOL Light and Isabelle a workout.</p>",
        "id": 294160471,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852941
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nThanks for the example, Chris!  I'll have to study it.  Your links<br>\n<a href=\"https://isabelle.in.tum.de/community/Course_Material\">https://isabelle.in.tum.de/community/Course_Material</a> seemed more about<br>\nlearning Isabelle (and so relevant to me) than teaching undergraduate<br>\nmath courses.  But I know Julien Narboux and others are thinking that<br>\nway.  I took your advice to read the tutorial, and have a bug report:</p>\n<p>I learned interesting Isabelle from Proof General, but not jedit.  I<br>\nlearned the main thing that I wanted to know: we you can use fancy<br>\nsymbols Mizar disallows, like ⇒, in isabelle proofs.  I pasted in the<br>\ntutorial.pdf file Toylist.thy below of sec 2.3, with the last `done'<br>\ncommented out. I opened it in jedit:<br>\n(localhost)Isabelle2011-1&gt; bin/isabelle jedit Toylist.thy &amp; <br>\nand get only the error message</p>\n<p>Bad filename \"Toylist.thy\" for theory ToyList.</p>\n<p>So I can't do any of the sec 2.3 tests in jedit!  I think I got some<br>\nred wiggly lines of yours, and definitely a red-and-white do not enter<br>\nsign on the left of the first line theory ToyList.  So instead I<br>\nopened it in Proof Generaland everything works. <br>\n(localhost)Isabelle2011-1&gt; bin/isabelle emacs Toylist.thy &amp; </p>\n<p>I get the message<br>\n       proof (prove): step 2<br>\n       goal:<br>\n       No subgoals!</p>\n<p>By commenting things out and looking at the Proof General output, I<br>\ncan understand the proof, which I'll explain.  It's about Scheme-type<br>\nlists, built with cons (although no car &amp; cdr), and the two simple<br>\nlist functions append (@) and reverse.  They inductively prove</p>\n<p>xs @ [] = xs<br>\n(xs @ ys) @ zs = xs @ (ys @ zs)<br>\nrev(xs @ ys) = (rev ys) @ (rev xs)<br>\nrev(rev xs) = xs</p>\n<p>with each proof using the previous results.  We prove each statements<br>\nis true for xs = [], and then we prove that the statement for xs<br>\nimplies the statement for x # xs.  Let's just do the last one:</p>\n<p>The base case is easy: <br>\nrev(rev []) = rev([]) = []<br>\nNow note that <br>\nrev([x]) = rev(x # []) = rev([]) @ (x # []) = [] @ (x # []) = x # []</p>\n<p>Now assume theorem rev_rev is true xs.  Then using lemma rev_app, the<br>\ninduction assumption and the above, we prove the induction equation:</p>\n<p>rev(rev (x # xs)) = rev(rev(xs) @ [x]) = rev([x]) @ rev(rev(xs)) <br>\n= (x # []) @ xs = x # ([] @ xs) = x # xs</p>\n<p>That's a nice proof.  I don't know why we have to use strategy auto as<br>\nwell as induct_tac, because it sure looks like just induction to me. </p>\n<p>But if we comment out just the apply(auto) in the proof of theorem<br>\nrev_rev, we get the output</p>\n<p>proof (prove): step 1</p>\n<p>goal (2 subgoals):</p>\n<ol>\n<li>rev (rev []) = []</li>\n<li>\\&lt;And&gt;a list. rev (rev list) = list \\&lt;Longrightarrow&gt; rev (rev (a # list)) = a # list</li>\n</ol>\n<p>Well, isabelle did nothing put state the inductive case.  It didn't<br>\neven prove the base case.  Page 12 of tutorial.pdf says </p>\n<p>apply(induct_tac xs)<br>\n    This tells Isabelle to perform induction on variable xs. </p>\n<p>Apparently that's not true: to perform induction we need also auto.</p>\n<p>If we instead comment out  app_assoc and rev_app, we get message<br>\ngoal (1 subgoal): </p>\n<ol>\n<li>\\&lt;And&gt;a list. rev (rev list) = list \\&lt;Longrightarrow&gt; rev (rev list @ a # []) = a # list *)</li>\n</ol>\n<p>------------------------------  Toylist.thy  ------------------------------<br>\ntheory ToyList<br>\nimports Datatype<br>\nbegin<br>\ndatatype 'a list = Nil                         (\"[]\")</p>\n<p>| Cons 'a \"'a list\"           (infixr \"#\" 65)<br>\n(* This is the append function: *)<br>\nprimrec app :: \"'a list \\&lt;Rightarrow&gt; 'a list \\&lt;Rightarrow&gt; 'a list\" (infixr \"@\" 65)<br>\nwhere<br>\n\"[] @ ys       = ys\" |<br>\n\"(x # xs) @ ys = x # (xs @ ys)\"<br>\nprimrec rev :: \"'a list \\&lt;Rightarrow&gt; 'a list\" where<br>\n\"rev []        = []\" |<br>\n\"rev (x # xs) = (rev xs) @ (x # [])\"</p>\n<p>lemma app_Nil2 [simp]: \"xs @ [] = xs\"<br>\napply(induct_tac xs)<br>\napply(auto)<br>\ndone</p>\n<p>lemma app_assoc [simp]: \"(xs @ ys) @ zs = xs @ (ys @ zs)\"<br>\napply(induct_tac xs)<br>\napply(auto)<br>\ndone</p>\n<p>lemma rev_app [simp]: \"rev(xs @ ys) = (rev ys) @ (rev xs)\"<br>\napply(induct_tac xs)<br>\napply(auto)<br>\ndone</p>\n<p>theorem rev_rev [simp]: \"rev(rev xs) = xs\"<br>\napply(induct_tac xs)<br>\napply(auto)<br>\n(* done *)</p>",
        "id": 294160480,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852947
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Bill,</p>\n<p>On 05/03/2012 12:38 PM, Bill Richter wrote:</p>\n<blockquote>\n<p>I learned interesting Isabelle from Proof General, but not jedit.  I<br>\nlearned the main thing that I wanted to know: we you can use fancy<br>\nsymbols Mizar disallows, like ⇒, in isabelle proofs.  I pasted in the<br>\ntutorial.pdf file Toylist.thy below of sec 2.3, with the last `done'<br>\ncommented out. I opened it in jedit:<br>\n(localhost)Isabelle2011-1&gt;  bin/isabelle jedit Toylist.thy&amp;<br>\nand get only the error message</p>\n<p>Bad filename \"Toylist.thy\" for theory ToyList.<br>\nWell this error message is actually very informative. The file name and <br>\nthe name of the theory differ (in case) and that is against conventions, <br>\nit's rather a bug of ProofGeneral to accept your file.</p>\n</blockquote>\n<blockquote>\n<p>Now assume theorem rev_rev is true xs.  Then using lemma rev_app, the<br>\ninduction assumption and the above, we prove the induction equation:</p>\n<p>rev(rev (x # xs)) = rev(rev(xs) @ [x]) = rev([x]) @ rev(rev(xs))<br>\n= (x # []) @ xs = x # ([] @ xs) = x # xs</p>\n<p>That's a nice proof.  I don't know why we have to use strategy auto as<br>\nwell as induct_tac, because it sure looks like just induction to me.<br>\nThe induct/induction/induct_tac methods just set up an induction proof <br>\n(i.e., base cases + inductive cases) according to the variable you want <br>\nto induct over. It's the same with pen'n'paper actually. What you do to <br>\nsolve the base case and inductive case is not induction, but mostly <br>\ndifferent techniques like equational reasoning etc.</p>\n<p>But if we comment out just the apply(auto) in the proof of theorem<br>\nrev_rev, we get the output</p>\n<p>proof (prove): step 1</p>\n<p>goal (2 subgoals):<br>\n  1. rev (rev []) = []<br>\n  2. \\&lt;And&gt;a list. rev (rev list) = list \\&lt;Longrightarrow&gt;  rev (rev (a # list)) = a # list</p>\n<p>Well, isabelle did nothing put state the inductive case.  It didn't<br>\neven prove the base case.  Page 12 of tutorial.pdf says</p>\n<p>apply(induct_tac xs)<br>\n     This tells Isabelle to perform induction on variable xs.</p>\n<p>Apparently that's not true: to perform induction we need also auto.</p>\n<p>If we instead comment out  app_assoc and rev_app, we get message<br>\ngoal (1 subgoal):<br>\n1. \\&lt;And&gt;a list. rev (rev list) = list \\&lt;Longrightarrow&gt;  rev (rev list @ a # []) = a # list *)</p>\n</blockquote>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294160488,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852953
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;</p>\n<blockquote>\n<p>Bad filename \"Toylist.thy\" for theory ToyList.<br>\n   Well this error message is actually very informative. The file name and <br>\n   the name of the theory differ (in case) and that is against conventions, <br>\n   it's rather a bug of ProofGeneral to accept your file.</p>\n</blockquote>\n<p>You're a good teacher, Chris!  You made me think: I was supposed to<br>\nwrite <code>theory toylist', and not </code>theory ToyList' in my Isabelle file.</p>\n<p>The induct/induction/induct_tac methods just set up an induction<br>\n   proof (i.e., base cases + inductive cases) according to the<br>\n   variable you want to induct over. It's the same with pen'n'paper<br>\n   actually. What you do to solve the base case and inductive case is<br>\n   not induction, but mostly different techniques like equational<br>\n   reasoning etc.</p>\n<p>I need to understand what you mean in order to understand how to write<br>\nIsabelle or HOL Light proofs, but what I did is certainly what<br>\nmathematicians call an inductive proof.  I showed the results were<br>\ntrue for lists of length 0 (just []), and then assumed the results<br>\nwere true for all lists of length n, and used that to prove the<br>\nresults were true for all lists length n+1.  I've heard Schemers call<br>\nthat tree induction.</p>",
        "id": 294160504,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852959
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nSorry, Chris, I messed it up again.  Noch einmals: my filename is<br>\nToylist.thy, so I should have typed theory Toylist.  I'm looking<br>\nforward to doing more exercises in jedit.  Proof General is a pain.</p>",
        "id": 294160517,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852965
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThere are two steps in an inductive proof: In a first step the original <br>\ngoal (\"property holds for all lists\") is transformed with an induction <br>\nrule in a number of new goals (\"property holds for lists of length 0\" <br>\nand \"assuming property holds for all lists of length n, it holds for all <br>\nlists of length n + 1\"). In a second step these new goals have to be proven.</p>\n<p>Isabelle's \"induct\" and \"induct_tac\" methods only perform the first <br>\nstep. This transformation is done purely schematic -- even if e.g. the <br>\nbase case is trivial, it will not be solved automatically. The second <br>\nstep needs to be performed explicitly (here \"auto\").</p>\n<p>-- Lars</p>",
        "id": 294160524,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852971
    },
    {
        "content": "<p>From: Jeremy Avigad &lt;<a href=\"mailto:avigad@cmu.edu\">avigad@cmu.edu</a>&gt;<br>\nDear Bill,</p>\n<p>I agree that it would be nice to see Elements-style proofs verified in <br>\nIsabelle. I have talked about E with friends in the Isabelle community, <br>\nso they know about the work.</p>\n<p>I'll respond to the rest of the message off-list, though, since the <br>\ndetails are not related to Isabelle.</p>\n<p>Best wishes,</p>\n<p>Jeremy</p>",
        "id": 294160541,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660852978
    },
    {
        "content": "<p>From: Jeremy Avigad &lt;<a href=\"mailto:avigad@cmu.edu\">avigad@cmu.edu</a>&gt;<br>\nDear all,</p>\n<p>At the risk of taking the discussion too far from Isabelle, I'd like to <br>\nmention that Ed Dean, John Mumma, and I have carried out a detailed <br>\nanalysis of the style of reasoning one finds in Euclid:</p>\n<p>A formal system for Euclid's Elements<br>\n   Review of Symbolic Logic, 2:700-768, 2009<br>\n<a href=\"http://journals.cambridge.org/repo_A674ohNM\">http://journals.cambridge.org/repo_A674ohNM</a><br>\n   (additional links and errata are on my web page)</p>\n<p>We argue that Euclid is more rigorous than is commonly acknowledged, in <br>\nthat there are clearly discernible norms to diagrammatic reasoning <br>\n(though they are different from the norms of axiom-based proof). We also <br>\nnote that Euclidean theorems have a very restricted logical form, and <br>\nshow that his methods are complete (for that class of sentences) with <br>\nrespect to the modern semantics of ruler-and-compass constructions.</p>\n<p>Best wishes,</p>\n<p>Jeremy</p>",
        "id": 294161160,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853187
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nThank you very much Makarius, for a long interesting lecture.  I<br>\ndidn't know any of that stuff.  This in particular:</p>\n<p>If you take HOL as a simplified version of set-theory with explicit<br>\n   syntactic types it is OK as a start.</p>\n<p>But I think we'd communicate a lot better if you understood math<br>\nlogic, from say Enderton's book Mathematical Logic.  Until then you<br>\nwon't know why I'm floundering.  I apologize if I misunderstand you.</p>\n<p>I can only guess what you mean by \"strict axiomatic FOL proof\".</p>\n<p>I mean what Enderton means (same for `models'), and I'd like you to<br>\nknow too.  Look, you're really good at what you do, and you<br>\ncommunicate really well, and you go to the trouble to speak<br>\nintelligibly to newbies like me... but don't you want to know the<br>\nproof of the Goedel incompleteness theorem?</p>\n<p>Anyway, eventually I'll take all of your suggestions.  I'll go through<br>\nthe Isar manuals and learn Pure + Isar and see how close that is to<br>\nEnderton's FOL.  I want to learn!  Isabelle is the only proof<br>\nassistant with nice fonts and serious documentation.</p>",
        "id": 294161572,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853321
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nDear Bill,</p>\n<p>I haven't been following this thread in detail, so I am not sure what<br>\nyou've been told already. Surely you realize that FOL is just one logic<br>\n(albeit an important one). There are many other logics, and interactive<br>\nproof assistants are usually <em>not</em> built on FOL.</p>\n<p>There are very good reasons for this design choice, but it also has its<br>\ndrawbacks. For instance, it tends to puzzle mathematicians with an<br>\ninterest in foundations who have been taught that everything rests on<br>\nFOL and ZFC.</p>\n<p>If you are specifically looking for systems that perform (automated)<br>\nfirst-order reasoning, take a look at<br>\n<a href=\"http://en.wikipedia.org/wiki/Automated_theorem_proving\">http://en.wikipedia.org/wiki/Automated_theorem_proving</a></p>\n<p>Best regards,<br>\nTjark</p>",
        "id": 294161583,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853327
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nThanks, Tjark and Konrad!  I'll read the HOL paper, which looks pretty<br>\nold, and so is maybe something that everyone just assumes nowadays.  I<br>\ndon't know about those other first-order reasoning<br>\nAutomated_theorem_provers, or why folks don't use them.  My interest<br>\nin proof assistants (HOL Light, Isabelle, Coq) is that Tom Hales is<br>\nusing them to formalize his Kepler conjecture proof.  </p>\n<p>it tends to puzzle mathematicians with an interest in foundations<br>\n   who have been taught that everything rests on FOL and ZFC.</p>\n<p>Tjark, you understand my confusion!  Is something written about this?<br>\nI do contend that it's true what mathematicians are taught, but it may<br>\nnot appear to be true at the technical level that proof assistants<br>\noperate on.  That's of course fine, but I need to see the underlying<br>\nFOL and ZFC, even if the proof assistants aren't coded that way.</p>",
        "id": 294162126,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853530
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Mon, Jun 4, 2012 at 5:44 AM, Bill Richter<br>\n&lt;richter@math.northwestern.edu&gt;wrote:</p>\n<blockquote>\n<p>Thanks, Tjark and Konrad!  I'll read the HOL paper, which looks pretty<br>\nold, and so is maybe something that everyone just assumes nowadays.  I<br>\ndon't know about those other first-order reasoning<br>\nAutomated_theorem_provers, or why folks don't use them.</p>\n</blockquote>\n<p>Possible reasons include:</p>\n<p>1. FOL isn't expressive enough for their problems. It might technically<br>\n   be able to express something, but not nicely.</p>\n<p>2. The automated provers can't solve their problems, at least not<br>\n   without a lot of help, and that help is tedious to give.</p>\n<p>3. Some automated provers don't generate complete explicit proofs, and<br>\n   so have to be trusted; this is harder than trusting a simple proof checker.</p>\n<p>That having been said, I'm under the impression that the world of automated<br>\nproving is always getting better. I don't know much about it because I<br>\ndon't live day-to-day in that world.<br>\nIdeally, interactive provers should only benefit from progress in<br>\nautomation, since automatic tools can be integrated into interactive proof<br>\ndevelopment environments.</p>\n<blockquote>\n<p>My interest<br>\nin proof assistants (HOL Light, Isabelle, Coq) is that Tom Hales is<br>\nusing them to formalize his Kepler conjecture proof.</p>\n<p>it tends to puzzle mathematicians with an interest in foundations<br>\n  who have been taught that everything rests on FOL and ZFC.</p>\n<p>Tjark, you understand my confusion!  Is something written about this?<br>\nI do contend that it's true what mathematicians are taught, but it may<br>\nnot appear to be true at the technical level that proof assistants<br>\noperate on.  That's of course fine, but I need to see the underlying<br>\nFOL and ZFC, even if the proof assistants aren't coded that way.<br>\n</p>\n</blockquote>\n<p>It's not just a matter of how the proof assistant is coded. The underlying<br>\nlogic of Isabelle/HOL is not FOL. (There is, of course, Isabelle/ZF, which<br>\ndoes use FOL and the ZF axioms.)<br>\nThe piece of writing I think you might find enlightening is Andy Pitts's<br>\ndocument on the semantics of HOL.<br>\nIt is the \"Logic\" manual available here<br>\n<a href=\"http://hol.sourceforge.net/documentation.html\">http://hol.sourceforge.net/documentation.html</a>.<br>\nNote it is for the HOL4 system, not Isabelle/HOL, but since it's mainly<br>\nabout the logic, HOL, itself, that those proof assistants basically share,<br>\nthis shouldn't matter too much.<br>\nIt gives a precise description of the syntax and semantics of HOL. The<br>\nsemantics is given in terms of set-theoretic models, with which you're<br>\nprobably more familiar.<br>\nI'll be happy to answer any questions about it. I was thinking of giving<br>\nyou syntax and semantics of FOL and then of HOL so you could see them<br>\ncompared, but that document is better presented than what I would have<br>\nwritten.<br>\n(By the way, FOL formulas can be embedded in HOL.)</p>\n<blockquote>\n<p>--<br>\nBest,<br>\nBill</p>\n</blockquote>",
        "id": 294162893,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853800
    },
    {
        "content": "<p>From: Slawomir Kolodynski &lt;<a href=\"mailto:skokodyn@yahoo.com\">skokodyn@yahoo.com</a>&gt;</p>\n<blockquote>\n<p>There is, of course, Isabelle/ZF, which does use FOL and the ZF axioms</p>\n</blockquote>\n<p>Is there a deep reason to code geometry axioms inside HOL? It seems to me it would be more natural to build Tarski geometry logic based on FOL, in the similar way like ZF logic is built on FOL. </p>\n<p>slawekk</p>\n<p><a href=\"http://savannah.nongnu.org/projects/isarmathlib\">http://savannah.nongnu.org/projects/isarmathlib</a><br>\nLibrary of Formalized Mathematics for Isabelle/Isar (ZF Logic)</p>",
        "id": 294163165,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660853934
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Sun, Jun 3, 2012 at 12:53 AM, Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a></p>\n<blockquote>\n<p>wrote:</p>\n</blockquote>\n<blockquote>\n<p>I'm trying to use my math skills to get into the proof assistant game.<br>\nI know all of you are much better than I am at CS, and I would think<br>\nthat you would all be better than I at mathematical logic as well.<br>\nAnd maybe you are, but I think I understand something that nobody ever<br>\nwrites, so I wonder if folks do understand this.<br>\n</p>\n</blockquote>\n<p>I think you'll find that people who use computerised proof technology often<br>\ndo already have a good understanding of mathematical logic (and<br>\n\"metamathematics\"), including Gödel's theorems.</p>\n<blockquote>\n<p>Mathematical logic studies what you can and can't prove axiomatically<br>\nin first order logic (FOL).</p>\n</blockquote>\n<p>I would contend that the field goes further and looks at other logics as<br>\nwell, including extensions like second-order and higher-order logic, as<br>\nwell as \"restrictions\" on first-order logic like non-classical logics<br>\n(linear, intuistionistic, modal, ...). Wikipedia has more info:<br>\n<a href=\"http://en.wikipedia.org/wiki/Mathematical_logic\">http://en.wikipedia.org/wiki/Mathematical_logic</a>.</p>\n<blockquote>\n<p>The Goedel Completeness Theorem<br>\n<a href=\"http://mathworld.wolfram.com/GoedelsCompletenessTheorem.html\">http://mathworld.wolfram.com/GoedelsCompletenessTheorem.html</a> says<br>\ntruth in every model implies an axiomatic proof, and the Goedel<br>\nIncompleteness Theorem says you can't write a computer program that<br>\nwill print out all theorems of a model of the natural numbers:<br>\n<a href=\"http://mathworld.wolfram.com/GoedelsFirstIncompletenessTheorem.html\">http://mathworld.wolfram.com/GoedelsFirstIncompletenessTheorem.html</a></p>\n</blockquote>\n<p>The phrase \"all theorems of a model of the natural numbers\" would perhaps<br>\nbetter read \"all and only true statements about the natural numbers\".<br>\nTo me, theorems are statements with proofs, and models of a statement or a<br>\ntheory are structures that make that statement or theory true.</p>\n<p>The Completeness Theorem says that if a statement is true in every<br>\nstructure (i.e. every structure models the statement), then the statement<br>\nhas a proof.<br>\n(Implicitly, we first fix a first-order theory, i.e. a set of axioms and a<br>\nsignature, then only consider statements in the language of that signature,<br>\nstructures over that signature, and proofs over those axioms. The<br>\nCompleteness Theorem holds no matter what theory we choose.)<br>\nIf the set of axioms can be generated by a computer, then all (and only)<br>\nthe provable statements of a theory can also be generated by a computer.<br>\nThis is why first-order logic is \"semidecidable\".</p>\n<p>The First Incompleteness Theorem says that if we fix a theory whose axioms<br>\ncan be generated by a computer, whose signature allows the natural numbers<br>\nas a structure, and which proves various statements about the natural<br>\nnumbers (e.g. Peano's axioms) but doesn't prove every statement (i.e. it is<br>\nconsistent), then there exists some statement which is true in the natural<br>\nnumbers but not provable.<br>\nNotes: Since the theory proves Peano's axioms but is consistent, the<br>\nnatural numbers must be a model of this theory. But by the Completeness<br>\nTheorem, the unprovable statement cannot be true in all models of this<br>\ntheory. Therefore the theory must have another \"non-standard\" model where<br>\nthe unprovable statement is false.</p>\n<p>What you said about a computer program not being able to print all theorems<br>\nis not a limitation of computer programs (because a program can always<br>\nprint out all theorems of a first order theory). It's a limitation of<br>\nfirst-order theories to capture the natural numbers: they always end up<br>\nalso being true of non-standard models that differ from the natural numbers<br>\nbut the theory can't tell.</p>\n<blockquote>\n<p>There's a simpler related result I don't know the name of, which says<br>\nthat given any nice set of FOL axioms, you can write a computer<br>\nprogram to print out all the theorems that follow from them,<br>\ni.e. theorems which have axiomatic FOL proofs using these axioms.<br>\n</p>\n</blockquote>\n<p>Right. I'm not sure this result has any particular name. The \"nice set\" of<br>\nFOL axioms means a \"recursively enumerable set\".</p>\n<blockquote>\n<p>Mathematicians basically restrict themselves to the FOL ZFC set theory<br>\naxioms, and so we can write a computer program that will print out (if<br>\nit runs indefinitely) every theorem that mathematicians well ever<br>\nprove (unless they adopt new axioms). Turing's proof of the Halting<br>\nproblem (you can't write a infinite-loop checker) is just a<br>\nrestatement of the Goedel incompleteness theorem.</p>\n</blockquote>\n<p>The Lambda Calculus comes out of math logic, as it gives a definition of a</p>\n<blockquote>\n<p>recursive<br>\nfunction that's equivalent to Turing-machine definable.</p>\n<p>The whole point of proof assistants is to make this math logic work!<br>\nNobody's gonna run the simple program that prints out all the theorems<br>\nthat follow from the FOL ZFC axioms and wait for a good theorem to pop<br>\nup.  But you folks have written lots of smart proof assistants which<br>\ndo great work on today's incredibly fast machines.<br>\n</p>\n</blockquote>\n<p>A bit of clarification: proof assistants usually consist of a proof<br>\nchecking part and a proof development part. The proof checking part simply<br>\nchecks that proofs are valid proofs, i.e. they come from the axioms via<br>\ninference rules. The proof development part may include tools for<br>\nstructuring theories and tools for generating proofs automatically or<br>\nsemi-automatically.</p>\n<blockquote>\n<p>So what do proof assistants (Coq, Isabelle, HOL Light) do?  I would<br>\nassume they all start with some FOL axioms and then deduce axiomatic<br>\nFOL proofs as one discusses in math logic.  I contend that the proof<br>\nassistants must do that, because (by math logic) they can't do<br>\nanything else!  And the mathematicians can't do anything else either!<br>\n</p>\n</blockquote>\n<p>No it's not true, because neither proof assistants nor mathematicians are<br>\nrestricted to FOL.<br>\nAlso, none of the proof systems really do any proving (unless you count the<br>\nautomated components); rather, they enable you to construct a formal proof,<br>\nwhile checking all the time that what you're doing is valid.<br>\nIn HOL Light and Isabelle/HOL (Isabelle itself is a logical framework that<br>\ncan be instantiated at many different logics) let you conclude statements<br>\nthat are either HOL axioms or derived from other theorems via HOL rules of<br>\ninference. The Wikipedia page has a list of the inference rules for HOL<br>\nLight <a href=\"http://en.wikipedia.org/wiki/HOL_Light\">http://en.wikipedia.org/wiki/HOL_Light</a>. These systems don't actually<br>\nconstruct proofs (by default); rather, they construct \"theorem\" objects,<br>\nand limit the methods for constructing theorems to exactly the rules of<br>\ninference, thereby ensuring that whenever you have a theorem object, you<br>\nknow a proof of it must exist (it was created ephemerally and dynamically<br>\nin the object's creation). This is the so-called \"LCF approach\".<br>\nCoq, on the other hand, does construct proofs by default, but in another<br>\nlogic again: dependent type theory. In this logic, the proofs and the<br>\nstatements live in the same language.<br>\nI'm sure others will be able to fill in more details here if you're<br>\ninterested...</p>\n<blockquote>\n<p>But I'm puzzled because almost nobody talks this way in the proof<br>\nassistant world.  Mizar (and Freek's miz3 port to HOL Light) seems<br>\nreasonably close to FOL axiomatic proofs.  Although I don't know<br>\nexactly how close.  I have this vague idea that Mizar does axiomatic<br>\nFOL proofs with a lot of the tedium automated away, e.g. manually<br>\nsubstituting variables.  But I don't know.  The things that folks<br>\nactually do---HOL, Isar, Pure---I don't understand.  I would need to<br>\nhave them explained in terms of Goedel's field of math logic,<br>\ni.e. axiomatic FOL proofs. So I propose that if someone knows the answer,<br>\nthey tell me, and if nobody knows the<br>\nanswer, let's run a thread on math logic which will eventually explain<br>\nhow HOL, Isar, Pure etc relate to Goedel's FOL.  I have very little to<br>\ncontribute to such a thread beyond the note on the LC Y combinator and<br>\nGoedel incompleteness below.<br>\n</p>\n</blockquote>\n<p>Well, perhaps we can continue after you've read about the syntax and<br>\nsemantics of HOL and let's see if you have more specific questions then.</p>\n<blockquote>\n<p>--<br>\nBest,<br>\nBill</p>\n<p>We can understand Odifreddi's [p 80--1] startling remark that the Y<br>\ncombinator \"embodies the argument used in Russell's paradox\" from<br>\nBoolos &amp; Jeffries [Ch 14-15].</p>\n<p>That is, I'll show how the Lambda Calculus Y combinator comes from<br>\nGoedel Incompleteness, and how Goedel I sort of comes from Russell's<br>\nparadox.  In particular, B&amp;J's treatment of the Goedel fixed point<br>\ntheorem is much clearer than Barendregt's [Thm (Goedel), sec 6.7].</p>\n<p><strong>*</strong><strong>* Goedel's fixed point thm =&gt; Y combinator </strong><strong>*</strong>*</p>\n<p>For any expression B(y) of number theory, B&amp;J [Lem 2, p 173] show<br>\nthere exists an expression F(x) such that for any expression M(x),</p>\n<p>Q |-   F( #M ) &lt;--&gt; B( #M(#M) )</p>\n<p>where Q is the minimal axiom set for number theory [B&amp;J Ch 14], s.t. a<br>\npartial function N ---&gt; N is representable in Q iff it's<br>\nrecursive.  I'm denoting Goedel numbers by #.</p>\n<p>Then letting G = F(#F) and plugging in, we have Goedel's result</p>\n<p>Q |-  G &lt;--&gt; B( #G )</p>\n<p>Well, that gives us the Y combinator, just take out the #s and the<br>\nQs.  We want</p>\n<p>(F M) = (B (M M))</p>\n<p>for all M, so we let</p>\n<p>F = \\m. B (m m)<br>\n         G = F F<br>\nthen<br>\n         G = B G</p>\n<p>giving us the fixed point for B, which we encode as the Y combinator</p>\n<p>Y = \\b. (\\f. f f) (\\m. b (m m))</p>\n<p>That's the only reasonable motivation I've ever seen for the Y<br>\ncombinator.  And maybe that explains that LC_v requires LC: as you<br>\nsay, LC_v is for programming, LC is for Math logic.  But we need Y in<br>\norder to be able to derive the harder Y_v.</p>\n<p><strong>*</strong><strong>* Goedel fixed point thm =&gt; Goedel I </strong><strong>*</strong>*</p>\n<p>Let E be the expression of number theory, E_0 the closed expressions,<br>\nor statements.  Let Th(N) be the statements that are true in the<br>\nstandard model of N.  We'll write, for statements f in E_0,</p>\n<p>|= f</p>\n<p>if f in Th(N).</p>\n<p>Goedel proved that Th(N) is not decidable, meaning there is no<br>\nexpression B(x) in E such that for any statement f in E_0,</p>\n<p>|=  f   if   Q |-  B(#f)<br>\n|= -f   if   Q |- -B(#f)</p>\n<p>But this statement implies the more tractable sounding</p>\n<p>|= f <br>\n[message truncated]</p>\n</blockquote>",
        "id": 294163289,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854003
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nIs there a deep reason to code geometry axioms inside HOL? It seems<br>\n   to me it would be more natural to build Tarski geometry logic based<br>\n   on FOL, in the similar way like ZF logic is built on FOL.</p>\n<p>That make sense, Slawomir, especially for Tarksi's axioms.  On hol<br>\ninfo John Harrison has been helping me to code up my Hilbert axiom<br>\npaper using set theory you can do in HOL Light.</p>\n<p>Thanks, Ramana, for demonstrating that you understand math logic at<br>\nleast as well as I do.  So I suppose we can assume that folks here in<br>\ngeneral understand math logic.  I feel that you mainly answered my<br>\nquestion (about the mathematicians's belief of FOL/ZFC primacy) by<br>\nrecommending Konrad's The HOL System LOGIC manual.</p>\n<p>Well, perhaps we can continue after you've read about the syntax and<br>\n   semantics of HOL and let's see if you have more specific questions then.</p>\n<p>Yes, I'll book up and get back to you!  I need to learn HOL anyway,<br>\nand this manual seems like a good place to understand the foundations.</p>",
        "id": 294163356,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854039
    },
    {
        "content": "<p>From: <a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a><br>\nDefine a system of logic as a language with rules of inference to <br>\ninterpret the language.</p>\n<p>Define a language as a set of symbols with a set of rules for combining <br>\nthe symbols.</p>\n<p>Additionally, there is the meta-language which is used to describe and <br>\ndefine the object-language.</p>\n<p>Let the choices of the meta-language be Isabelle/FOL or Isabelle/HOL, <br>\nand let the object-language be Tarski Geometry.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Tarski's_axioms\">http://en.wikipedia.org/wiki/Tarski's_axioms</a></p>\n<p>The question becomes this: Can either of these be used as a <br>\nmeta-language to implement the object-language of Tarski Geometry?</p>\n<p>To answer that question we can ask these questions:<br>\n       1) Do these object-languages have the symbols we need for<br>\n          Tarski Geometry, and let us combine them in the proper way<br>\n          to create the language of Tarski Geometry.<br>\n       2) Do these object-languages have rules of inference that allow<br>\n          us to interpret the language correctly.</p>\n<p>Isabelle/HOL has the standard set of logical connectives and <br>\nquantifiers, and it has natural deduction rules of inference. The syntax <br>\nit forces on you appears to be compatible with Tarski Geometry. It looks <br>\nlike Isabelle/HOL can work as a meta-language to describe, define, and <br>\nuse Tarski Geometry.</p>\n<p>But I drop back concerning FOL.</p>\n<p>Slawomir, you say that ZF is built on FOL. But the language of <br>\nfirst-order logic is a family of languages. Zermelo-Frankael sets isn't <br>\nbuilt on a language of FOL, it is a first-order language, that is, a <br>\nlanguage of first-order logic. Conceptually, Isabelle/FOL + Isabelle/ZF <br>\nis the first-order language of Zermelo-Frankael sets.</p>\n<p>[pg.19, Language, Proof, and Logic, Barwise &amp; Etchemendy]<br>\n    ...we talked about FOL as though it were a single language.<br>\n    Actually, it is more like a family of languages, all having a<br>\n    similar grammar and sharing certain important vocabulary items,<br>\n    known as the connectives and quantifiers. Languages in this family<br>\n    can differ, however, in the specific vocabulary used to form their<br>\n    most basic sentences, the so-called atomic sentences.</p>\n<p>Please refer to Bilaniuk's free book \"A Problem Course in Mathematical <br>\nLogic\", Def.5.1 Symbols pg.24, Def.5.2 Terms pg. 26, and Def.5.3 <br>\nFormulas pg.27, though a friendlier definition of the symbols would give <br>\nus the full set of logical connectives and both the quantifiers.</p>\n<p><a href=\"http://euclid.trentu.ca/math/sb/pcml/pcml.html\">http://euclid.trentu.ca/math/sb/pcml/pcml.html</a></p>\n<p>Every first-order language must meet the requirements of the logical <br>\nsymbols, which are Definition 5.1 items 1 to 5; it's the non-logical <br>\nsymbols that allow them to be unique, Definition 5.1 items 6 to 8.</p>\n<p>For the non-logical symbols, ZF has no constant or function symbols, and <br>\nit has membership as the one predicate symbol.</p>\n<p>Now I switch to Tarski Geometry. I look at the wiki page, and it tells <br>\nme that it can formulated as a first-order language with the predicates <br>\n\"betweenness\" and \"congruence\".</p>\n<p>Okay, but to elaborate on question 2 above, can Isabelle/FOL provide the <br>\npredicate \"betweenness\" to the first-order language of Tarski Geometry?</p>\n<p>I go out on a limb now, and I say that first-order languages can only be <br>\ngiven predicates; that is, one language of FOL acting as a meta-language <br>\ncan't create new predicates when creating a new language of FOL.</p>\n<p>I could be wrong in my last paragraph. Regardless, if you're creating <br>\npredicates for Tarski Geometry, where the logic you're using is <br>\nIsabelle/FOL, aren't you really operating in the realm of \"functional <br>\nprogramming\"/\"Isabelle's meta-logic\"/ML/HOL/etc..</p>\n<p>Regardless again, Isabelle/HOL appears to have the necessary ingredients <br>\nto act as a meta-language for any FOL object-language. When different <br>\nlogics can be cleanly used as a meta-language to implement a particular <br>\nobject-language, can it not be a case of \"six of one, or a half dozen of <br>\nthe other\"?</p>\n<p>There is the issue of minimalism. But if you only had to import <br>\nsrc/HOL/HOL.thy to implement Tarski Geometry, that would be pretty minimal.</p>\n<p>I stop here. These have been the comments of a novice speaking from the <br>\npeanut gallery.</p>\n<p>--GB</p>",
        "id": 294163377,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854052
    },
    {
        "content": "<p>From: Jens Doll &lt;<a href=\"mailto:jd@cococo.de\">jd@cococo.de</a>&gt;<br>\nHello Bill, Ramana and all,</p>\n<p>having printed out your opus as of June/4 and reading it byte by byte, <br>\nI'm still struggling with several propositions. The most important one <br>\nis the (allegation of a) diagonalization function</p>\n<p>Has anyone seen a constructive version of the diagonalization function, <br>\ni.e. is (e.g. Cantor's) diagonalization function computable?</p>\n<p>Heavy Reasoning,<br>\nJens</p>",
        "id": 294163444,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854080
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI certainly do not want to get dragged into these interminable discussions. However, as a general remark: there is nothing mysterious about diagonalization functions. For example, the one for Russell's paradox is simply {X. X notin X}. Here, of course, the notion of computable is irrelevant, but it's certainly easily defined.</p>\n<p>For proving undecidability of the halting problem, the definition is equally simple and it is computable if you assume the halting test itself to be computable, which is the point of the theorem.</p>\n<p>Larry</p>",
        "id": 294163447,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854082
    },
    {
        "content": "<p>From: Freek Wiedijk &lt;<a href=\"mailto:freek@cs.ru.nl\">freek@cs.ru.nl</a>&gt;<br>\nJens:</p>\n<p>It is certainly possible to prove in Coq (= constructively,<br>\nI hope)  that there is no surjection from a set to its<br>\npowerset.  I am not a regular Coq user so my proof probably<br>\nis twice as long as is necessary, and also it feels rather<br>\nstrange to post a Coq script to an Isabelle mailing list,<br>\nbut something like</p>\n<p>Lemma diagonal : forall A : Type,<br>\n    ~(exists F : A -&gt; (A -&gt; Prop), forall f, exists x, f = F x).<br>\n  unfold not. intros A [F H]. set (f := fun x =&gt; not (F x x)).<br>\n  elim (H f). clear H. intros x H. assert (H' : f x &lt;-&gt; F x x).<br>\n  rewrite H. tauto. unfold f in H'. tauto.<br>\n  Qed.</p>\n<p>seems to work.</p>\n<p>Freek</p>",
        "id": 294163468,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854094
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nRamana, I've been discussing the issue with Freek, who I'm very<br>\nimpressed with, as miz3 is holding up very well under the torture<br>\ntesting my 1300 lines of Hilbert axiomatic geometry code<br>\n<a href=\"http://www.math.northwestern.edu/~richter/OpenIntervalHilbertAxiom.ml\">http://www.math.northwestern.edu/~richter/OpenIntervalHilbertAxiom.ml</a>.<br>\nThe issue is almost entirely a matter of terminology.  I say that the<br>\nproof assistant (PA) world ought to explain how to translate the<br>\nlanguage of mathematical logic books (e.g. Enderton's) into PA<br>\nterminology.  In particular there's the vexing issue of the term FOL.</p>\n<p>I'm really happy with your understanding of Goedel Incompleteness:</p>\n<p>The First Incompleteness Theorem says that if we fix a theory whose<br>\n   axioms can be generated by a computer,[...] </p>\n<p>Yes!  And in math logic books, this is called FOL, and the infinite<br>\nset of axioms in ZFC fit into what they call axiom schemes.  You<br>\nunderstand the infinite axiom biz quite well, as we see again here:</p>\n<p>If the set of axioms can be generated by a computer, then all (and<br>\n   only) the provable statements of a theory can also be generated by<br>\n   a computer.  This is why first-order logic [FOL] is \"semidecidable\".</p>\n<p>Great!  That's my meaning of FOL, which you used again here:</p>\n<p>Right. I'm not sure this result has any particular name. The \"nice set\" of<br>\n   FOL axioms means a \"recursively enumerable set\".</p>\n<p>But now you mystify me by disagreeing with me at the end:</p>\n<blockquote>\n<p>So what do proof assistants (Coq, Isabelle, HOL Light) do?  I<br>\nwould assume they all start with some FOL axioms and then deduce<br>\naxiomatic FOL proofs as one discusses in math logic.  I contend<br>\nthat the proof assistants must do that, because (by math logic)<br>\nthey can't do anything else!  And the mathematicians can't do<br>\nanything else either!</p>\n</blockquote>\n<p>No it's not true, because neither proof assistants nor<br>\n   mathematicians are restricted to FOL.</p>\n<p>Now I think you switched over to to the (apparently more restrictive)<br>\nPA meaning of FOL.  I contend that what I said is true, in the<br>\nfollowing sense explained commonly in set theory books: Every theorem<br>\nproved today by mainstream mathematicians (let's forget large cardinal<br>\naxioms) has an FOL proof in ZFC.  Of course it would be extremely<br>\ninconvenient for mathematicians to write up FOL ZFC proofs!  Are we<br>\narguing about what's convenient?  I just want to see the big picture<br>\nright now, how PAs relate to the FOL math logic which I only<br>\nunderstand at a big picture level anyway.</p>",
        "id": 294163936,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854272
    },
    {
        "content": "<p>From: Bill Richter &lt;<a href=\"mailto:richter@math.northwestern.edu\">richter@math.northwestern.edu</a>&gt;<br>\nMakarius, I don't care for the way I wrote last time, and it took me<br>\nthis long to come up with a nicer way to say it, which is:</p>\n<p>I'm trying to use my math skills to get into the proof assistant game.<br>\nI know all of you are much better than I am at CS, and I would think<br>\nthat you would all be better than I at mathematical logic as well.<br>\nAnd maybe you are, but I think I understand something that nobody ever<br>\nwrites, so I wonder if folks do understand this.  </p>\n<p>Mathematical logic studies what you can and can't prove axiomatically<br>\nin first order logic (FOL). The Goedel Completeness Theorem<br>\n<a href=\"http://mathworld.wolfram.com/GoedelsCompletenessTheorem.html\">http://mathworld.wolfram.com/GoedelsCompletenessTheorem.html</a> says<br>\ntruth in every model implies an axiomatic proof, and the Goedel<br>\nIncompleteness Theorem says you can't write a computer program that<br>\nwill print out all theorems of a model of the natural numbers:<br>\n<a href=\"http://mathworld.wolfram.com/GoedelsFirstIncompletenessTheorem.html\">http://mathworld.wolfram.com/GoedelsFirstIncompletenessTheorem.html</a><br>\nThere's a simpler related result I don't know the name of, which says<br>\nthat given any nice set of FOL axioms, you can write a computer<br>\nprogram to print out all the theorems that follow from them,<br>\ni.e. theorems which have axiomatic FOL proofs using these axioms.<br>\nMathematicians basically restrict themselves to the FOL ZFC set theory<br>\naxioms, and so we can write a computer program that will print out (if<br>\nit runs indefinitely) every theorem that mathematicians well ever<br>\nprove (unless they adopt new axioms).  Turing's proof of the Halting<br>\nproblem (you can't write a infinite-loop checker) is just a<br>\nrestatement of the Goedel incompleteness theorem.  The Lambda Calculus<br>\ncomes out of math logic, as it gives a definition of a recursive<br>\nfunction that's equivalent to Turing-machine definable.</p>\n<p>The whole point of proof assistants is to make this math logic work!<br>\nNobody's gonna run the simple program that prints out all the theorems<br>\nthat follow from the FOL ZFC axioms and wait for a good theorem to pop<br>\nup.  But you folks have written lots of smart proof assistants which<br>\ndo great work on today's incredibly fast machines.</p>\n<p>So what do proof assistants (Coq, Isabelle, HOL Light) do?  I would<br>\nassume they all start with some FOL axioms and then deduce axiomatic<br>\nFOL proofs as one discusses in math logic.  I contend that the proof<br>\nassistants must do that, because (by math logic) they can't do<br>\nanything else!  And the mathematicians can't do anything else either!</p>\n<p>But I'm puzzled because almost nobody talks this way in the proof<br>\nassistant world.  Mizar (and Freek's miz3 port to HOL Light) seems<br>\nreasonably close to FOL axiomatic proofs.  Although I don't know<br>\nexactly how close.  I have this vague idea that Mizar does axiomatic<br>\nFOL proofs with a lot of the tedium automated away, e.g. manually<br>\nsubstituting variables.  But I don't know.  The things that folks<br>\nactually do---HOL, Isar, Pure---I don't understand.  I would need to<br>\nhave them explained in terms of Goedel's field of math logic,<br>\ni.e. axiomatic FOL proofs. So I propose that </p>\n<p>if someone knows the answer, they tell me, and if nobody knows the<br>\nanswer, let's run a thread on math logic which will eventually explain<br>\nhow HOL, Isar, Pure etc relate to Goedel's FOL.  I have very little to<br>\ncontribute to such a thread beyond the note on the LC Y combinator and<br>\nGoedel incompleteness below.</p>",
        "id": 294165169,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660854472
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nIt's lemma A1', not just A1.  Its purpose is to turn axiom A1, which is<br>\na sentence, into something more useful, with schematic variables that<br>\ncan be instantiated.  I think I figured out later that A1 [rule_format]<br>\nwould achieve the same thing, without having to prove lemma A1' separately.</p>\n<p>Sorry; it's taken me an awfully long time to get around to this, and<br>\nperhaps it's already been answered, but perhaps my answer will be useful<br>\nfor someone.</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/y-wCHMUHLzCSi1auswdb08vM/signature.asc\">signature.asc</a></p>",
        "id": 294224136,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899083
    },
    {
        "content": "<p>From: \"Tim (McKenzie) Makarios\" &lt;<a href=\"mailto:tjm1983@gmail.com\">tjm1983@gmail.com</a>&gt;<br>\nTarski's axiom of continuity comes in two versions: a first-order axiom<br>\nschema, or a single higher-order axiom.  If you use the higher-order<br>\naxiom, his axiom system is categorical.  So, yes, there is a good reason<br>\nfor using HOL for Tarski's axioms.</p>\n<p>Again, sorry for taking so long to make this point.</p>\n<p>Tim<br>\n&lt;&gt;&lt;<br>\n<a href=\"/user_uploads/14278/uraghhffgWYSykHvRmW36tkf/signature.asc\">signature.asc</a></p>",
        "id": 294224138,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660899087
    }
]