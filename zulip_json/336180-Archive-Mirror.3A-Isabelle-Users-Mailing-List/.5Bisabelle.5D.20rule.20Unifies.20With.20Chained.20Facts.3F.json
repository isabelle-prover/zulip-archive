[
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThe treatment of chained facts by \"rule\" is inherent in the way how Isar <br>\nreally works.  Part of the confusion stems from the very liberal language <br>\ndesign which also admits many \"improper\" elements in the same language.</p>\n<p>If you really want to understand structure Isar proofs, not proof scripts, <br>\nyou need to become acquainted with Isar rule composition.</p>\n<p>Makarius</p>",
        "id": 294134012,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843777
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 3 Apr 2011, Jun Inoue wrote:</p>\n<blockquote>\n<p>I was trying \"by (-, rule foo)\", but now I see why that was no good. <br>\n:)</p>\n<p>For the record, if anyone reads this in the archives: \"by - (rule foo)\" <br>\nperforms two separate method calls, a no-op and (rule foo), which <br>\nautomatically induces a \"stick assumptions into the premises\" step in <br>\nbetween, whereas \"by (-, rule foo)\" performs one call to a single, <br>\ncomposite method which does nothing special in between the no-op and <br>\n(rule foo).</p>\n</blockquote>\n<p>Yes, the initial proof method of 'by' is just one big expressen, where <br>\nevery participant receives the same facts.  You often see this mistake in <br>\nthe sources:</p>\n<p>by (method1, method2)</p>\n<p>where it really should be</p>\n<p>by method1 method2</p>\n<p>e.g.</p>\n<p>by cases auto</p>\n<blockquote>\n<blockquote>\n<p>It is also a bit inconvenient that there is no single method that has <br>\nthe \"insert chained facts, then apply a rule\" behavior; but at least <br>\nthere is an easy workaround with \"-\" followed by \"rule\".</p>\n</blockquote>\n</blockquote>\n<p>Isar is about structure, but here it would get lost in the dark goal <br>\nstate.  You can use rule_tac as workaround, but then you are really <br>\nstepping outside proper Isar.</p>\n<blockquote>\n<p>but if the authors of the Isabelle Tutorial ever see this, please <br>\nconsider making a little note of this behavior of \"rule\" in Section 5.7 <br>\n(or maybe in the \"Structured Proofs in Isar/HOL\" document).  Clearly <br>\npointing out the general difference between assumptions and premises <br>\ncould be even better...</p>\n</blockquote>\n<p>The manuals are not really up to date.  I hope to be able to work again on <br>\na proper Isar tutorial for structured proofs.</p>\n<p>I did not understand what you mean by \"general difference between <br>\nassumptions and premises\".</p>\n<p>Probably there is again a confusion by taking the printed goal state too <br>\nseriously -- which is very confusion indeed.</p>\n<p>Makarius</p>",
        "id": 294134033,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843782
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\n\"by blast\" and \"by - blast\" should be always the same.</p>\n<p>Since blast is a \"simple method\" it first uses \"insert\" to dump the facts <br>\ninto the goal state and then tries its luck on the result.</p>\n<p>Makarius</p>",
        "id": 294134059,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843789
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nActually you can have a difference if the goal state has &gt; 1 subgoals, <br>\ne.g. like this:</p>\n<p>notepad<br>\nbegin<br>\n   assume B<br>\n   then have \"A --&gt; A\" and B by - blast<br>\nend</p>\n<p>Here the \"dumping\" of facts is only weakly structured: all subgoals are <br>\naugmented uniformly.  The \"blast\" then solves the first, while the other <br>\nis implicitly closed as trivial in the end.</p>\n<p>The defaults of the Isar language attempt to maximize proof structure, <br>\ne.g. one should not attempt to escape from that without good reasons.</p>\n<p>Makarius</p>",
        "id": 294134089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843801
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Mon, Apr 4, 2011 at 1:27 AM, Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt; wrote:</p>\n<blockquote>\n<p>On Sun, 3 Apr 2011, Jun Inoue wrote:</p>\n<blockquote>\n<p>I was trying \"by (-, rule foo)\", but now I see why that was no good. :)</p>\n<p>For the record, if anyone reads this in the archives: \"by - (rule foo)\"<br>\nperforms two separate method calls, a no-op and (rule foo), which<br>\nautomatically induces a \"stick assumptions into the premises\" step in<br>\nbetween, whereas \"by (-, rule foo)\" performs one call to a single, composite<br>\nmethod which does nothing special in between the no-op and (rule foo).</p>\n</blockquote>\n<p>Yes, the initial proof method of 'by' is just one big expressen, where every<br>\nparticipant receives the same facts.</p>\n</blockquote>\n<p>By anyone's standard, I would be considered an \"expert\" Isabelle<br>\nuser... and in my years of experience with Isar I never knew this! How<br>\ndid that happen?</p>\n<blockquote>\n<p>You often see this mistake in the<br>\nsources:</p>\n<p>by (method1, method2)</p>\n<p>where it really should be</p>\n<p>by method1 method2</p>\n</blockquote>\n<p>Now that I think about it, I can remember many situations where I had<br>\nwritten something like</p>\n<p>by (method1, rule foo, method 2)</p>\n<p>and it failed for some reason that I didn't understand. Now it makes sense.</p>\n<p>Unfortunately, my usual first reaction was to rewrite this as</p>\n<p>apply - by (method1, rule foo, method 2)</p>\n<p>making it <em>less</em> structured, instead of as</p>\n<p>by method1 (rule foo, method 2)</p>\n<p>which I suppose would be considered more \"proper\".</p>\n<p>How are average users expected to learn these things?</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294134144,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843807
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Mon, 4 Apr 2011, Brian Huffman wrote:</p>\n<blockquote>\n<p>By anyone's standard, I would be considered an \"expert\" Isabelle user... <br>\nand in my years of experience with Isar I never knew this! How did that <br>\nhappen?</p>\n</blockquote>\n<p>There is no problem with that.  In general there are many very delicate <br>\npoints in Isar, but it is partly successful since it can be used without <br>\ngoing to the bottom of every detail.  Instead, the usual way is to imitate <br>\n\"best-style\" proofs.  Unfortunately, not all examples in the libraries are <br>\ngood ones.</p>\n<blockquote>\n<p>How are average users expected to learn these things?</p>\n</blockquote>\n<p>By being lucky in the selection of manuals or chosing the teacher.  This <br>\nvery issue of \"initial method\" vs. \"terminal method\" should also have been <br>\nmentioned quite often on the mailing list.</p>\n<p>Since a couple of years, my tendency is to make the system guide users <br>\nmore explicitly (e.g. in the Prover IDE), although I can also foresee lots <br>\nof complaints about such tutelage ...</p>\n<p>Makarius</p>",
        "id": 294134165,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843813
    },
    {
        "content": "<p>From: Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt;<br>\nHi, I'm having trouble understanding how the rule/erule method interacts<br>\nwith the subtle difference between `this' and ==&gt;.  Given an<br>\nintroduction rule</p>\n<p>P<br>\n  -<br>\n  Q</p>\n<p>and a goal state with a chained fact</p>\n<p>(* call this state 1 *)<br>\n  using this:<br>\n    R<br>\n  goal:<br>\n    Q</p>\n<p>the tutorial says the rule method unifies only the Q's, but it appears<br>\nto be matching P to R as well, failing if they don't match.  But if the<br>\ngoal state were</p>\n<p>(* call this state 2 *)<br>\n  (`this' is empty)<br>\n  goal:<br>\n    R ==&gt; Q</p>\n<p>then no matching seems to happen between P and R, and the method<br>\nsucceeds.  I'm including a minimal concrete example below.  A similar,<br>\nbut opposite, thing seems to happen with erule, which appears to<br>\n(sometimes?  always?) neglect chained facts when it searches for<br>\nformulas to consume.</p>\n<p>So exactly which combinations of formulas do rule and erule unify?<br>\nWhere could I have found this information?</p>\n<p>When I have state 1, how do I massage it into state 2 so that I can<br>\ninvoke rule without unifying the rule's premises to anything, or erule<br>\nwith unification to `this'?  Why wouldn't Isabelle do this massaging for<br>\nme?</p>\n<p>(* Example: P = \"n \\&lt;le&gt; 1\", Q = \"n \\&lt;noteq&gt; 2\", and R = \"n = 0\".  *)<br>\nlemma the_rule_assm:<br>\n  fixes n :: int<br>\n  assumes \"n \\&lt;le&gt; 1\"<br>\n    shows \"n \\&lt;noteq&gt; 2\"<br>\nusing assms by arith</p>\n<p>(* The way the rule is declared makes no difference, as expected. *)<br>\nlemma the_rule_imp:<br>\n  fixes n :: int<br>\n  shows \"n \\&lt;le&gt; 1 \\&lt;Longrightarrow&gt; n \\&lt;noteq&gt; 2\"<br>\nby arith</p>\n<p>(* The way the theorem to prove with the rule is declared does make<br>\n   a difference, as is highly unexpected.  *)<br>\ntheorem test_assm:<br>\n  fixes n :: int<br>\n  assumes \"n = 0\"<br>\n    shows \"n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\n(* Unification fails using either of the rules defined above,<br>\n   apparently trying to match n \\&lt;le&gt; 1 with n = 0\". *)<br>\n(<em>apply (rule the_rule_assm) (</em> Clash: HOL.eq =/= Orderings.ord_class.less_eq <em>)</em>)<br>\n(* apply (rule the_rule_imp) (* Clash: HOL.eq =/= Orderings.ord_class.less_eq <em>)</em>)<br>\noops</p>\n<p>(* The same rules work, apparently without trying to<br>\n   unify n \\&lt;le&gt; 1 with n = 0, if the lemmas are stated<br>\n   this way.  *)<br>\ntheorem test_imp:<br>\n  fixes n :: int<br>\n  shows \"n = 0 \\&lt;Longrightarrow&gt; n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\napply (rule the_rule_assm)          (* works *)<br>\noops</p>\n<p>theorem test'':<br>\n  fixes n :: int<br>\n  shows \"n = 0 \\&lt;Longrightarrow&gt; n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\napply (rule the_rule_imp)          (* works *)<br>\noops</p>",
        "id": 294134483,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843905
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Fri, Apr 1, 2011 at 10:09 AM, Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>(* call this state 1 *)<br>\n using this:<br>\n   R<br>\n goal:<br>\n   Q<br>\n[...]<br>\n (* call this state 2 *)<br>\n (<code>this' is empty)\n goal:\n   R ==&gt; Q\n[...]\nWhen I have state 1, how do I massage it into state 2 so that I can\ninvoke rule without unifying the rule's premises to anything, or erule\nwith unification to </code>this'?</p>\n</blockquote>\n<p>Hi Jun,</p>\n<p>This particular question, at least, has an easy answer: just use<br>\n\"apply -\", i.e. use the method whose name is just a single hyphen. Its<br>\nonly effect is to add any chained facts to the goal as ordinary<br>\nassumptions. It is often used in structured proofs with \"proof -\",<br>\nwhere it is usually a no-op. Another pattern that you can find in the<br>\nsources is \"by - (rule foo, simp)\" or similar. I have also used \"by -<br>\n(rule exI)\" in several places in HOLCF where \"by (rule exI)\" fails for<br>\nsome reason.</p>\n<p>It is a bit confusing how \"rule\" treats chained facts in a special<br>\nway, when nearly all other methods start by adding any chained facts<br>\ninto the goal as premises before continuing with their normal<br>\nbehavior. It is also a bit inconvenient that there is no single method<br>\nthat has the \"insert chained facts, then apply a rule\" behavior; but<br>\nat least there is an easy workaround with \"-\" followed by \"rule\".</p>\n<blockquote>\n<p>(* The way the theorem to prove with the rule is declared does make<br>\n  a difference, as is highly unexpected.  *)<br>\ntheorem test_assm:<br>\n fixes n :: int<br>\n assumes \"n = 0\"<br>\n   shows \"n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\n(* Unification fails using either of the rules defined above,<br>\n  apparently trying to match n \\&lt;le&gt; 1 with n = 0\". *)<br>\n(<em>apply (rule the_rule_assm) (</em> Clash: HOL.eq =/= Orderings.ord_class.less_eq <em>)</em>)<br>\n(* apply (rule the_rule_imp) (* Clash: HOL.eq =/= Orderings.ord_class.less_eq <em>)</em>)<br>\noops</p>\n<p>(* The same rules work, apparently without trying to<br>\n  unify n \\&lt;le&gt; 1 with n = 0, if the lemmas are stated<br>\n  this way.  *)<br>\ntheorem test_imp:<br>\n fixes n :: int<br>\n shows \"n = 0 \\&lt;Longrightarrow&gt; n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\napply (rule the_rule_assm)          (* works *)<br>\noops</p>\n<p>theorem test'':<br>\n fixes n :: int<br>\n shows \"n = 0 \\&lt;Longrightarrow&gt; n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\napply (rule the_rule_imp)          (* works *)<br>\noops</p>\n</blockquote>\n<p>The theorem list \"assms\" only includes propositions listed in<br>\n\"assumes\" clauses. Since there are no \"assumes\" clauses in either of<br>\nthe last two theorems, \"assms\" is actually empty, so there are no<br>\nchained facts, and \"rule\" doesn't try to unify with any assumptions.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294134738,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660843973
    },
    {
        "content": "<p>From: Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt;<br>\nBrian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt; writes:</p>\n<blockquote>\n<p>On Fri, Apr 1, 2011 at 10:09 AM, Jun Inoue &lt;<a href=\"mailto:jun.lambda@gmail.com\">jun.lambda@gmail.com</a>&gt; wrote:</p>\n<blockquote>\n<p>(* call this state 1 *)<br>\n using this:<br>\n   R<br>\n goal:<br>\n   Q<br>\n[...]<br>\n (* call this state 2 *)<br>\n (<code>this' is empty)\n goal:\n   R ==&gt; Q\n[...]\nWhen I have state 1, how do I massage it into state 2 so that I can\ninvoke rule without unifying the rule's premises to anything, or erule\nwith unification to </code>this'?</p>\n</blockquote>\n<p>Hi Jun,</p>\n<p>This particular question, at least, has an easy answer: just use<br>\n\"apply -\", i.e. use the method whose name is just a single hyphen. Its<br>\nonly effect is to add any chained facts to the goal as ordinary<br>\nassumptions. It is often used in structured proofs with \"proof -\",<br>\nwhere it is usually a no-op. Another pattern that you can find in the<br>\nsources is \"by - (rule foo, simp)\" or similar. I have also used \"by -<br>\n(rule exI)\" in several places in HOLCF where \"by (rule exI)\" fails for<br>\nsome reason.</p>\n</blockquote>\n<p>Hi Brian, thanks for the tip!  I was trying \"by (-, rule foo)\", but now<br>\nI see why that was no good.  :)</p>\n<p>For the record, if anyone reads this in the archives: \"by - (rule foo)\"<br>\nperforms two separate method calls, a no-op and (rule foo), which<br>\nautomatically induces a \"stick assumptions into the premises\" step in<br>\nbetween, whereas \"by (-, rule foo)\" performs one call to a single,<br>\ncomposite method which does nothing special in between the no-op and<br>\n(rule foo).</p>\n<blockquote>\n<p>It is a bit confusing how \"rule\" treats chained facts in a special<br>\nway, when nearly all other methods start by adding any chained facts<br>\ninto the goal as premises before continuing with their normal<br>\nbehavior. It is also a bit inconvenient that there is no single method<br>\nthat has the \"insert chained facts, then apply a rule\" behavior; but<br>\nat least there is an easy workaround with \"-\" followed by \"rule\".</p>\n</blockquote>\n<p>I tripped over this separation between assumptions before, when I found<br>\nthat \"show\" doesn't unify exported premises with any pending goal's<br>\npremises but only assumptions with goals' premises.  Why does Isar have<br>\nthis (IMHO idiosyncratic) distinction between assumptions and premises?<br>\nI suppose it's there for a reason, but to me it seems like Isar would be<br>\nmore streamlined and novice-friendly if the two notions are identified,<br>\nor always automatically bridged.</p>\n<p>PS.  Not to be too nosy here, but if the authors of the Isabelle<br>\nTutorial ever see this, please consider making a little note of this<br>\nbehavior of \"rule\" in Section 5.7 (or maybe in the \"Structured Proofs in<br>\nIsar/HOL\" document).  Clearly pointing out the general difference<br>\nbetween assumptions and premises could be even better...</p>\n<blockquote>\n<blockquote>\n<p>(* The way the theorem to prove with the rule is declared does make<br>\n  a difference, as is highly unexpected.  *)<br>\ntheorem test_assm:<br>\n fixes n :: int<br>\n assumes \"n = 0\"<br>\n   shows \"n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\n(* Unification fails using either of the rules defined above,<br>\n  apparently trying to match n \\&lt;le&gt; 1 with n = 0\". *)<br>\n(<em>apply (rule the_rule_assm) (</em> Clash: HOL.eq =/= Orderings.ord_class.less_eq <em>)</em>)<br>\n(* apply (rule the_rule_imp) (* Clash: HOL.eq =/= Orderings.ord_class.less_eq <em>)</em>)<br>\noops</p>\n<p>(* The same rules work, apparently without trying to<br>\n  unify n \\&lt;le&gt; 1 with n = 0, if the lemmas are stated<br>\n  this way.  *)<br>\ntheorem test_imp:<br>\n fixes n :: int<br>\n shows \"n = 0 \\&lt;Longrightarrow&gt; n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\napply (rule the_rule_assm)          (* works *)<br>\noops</p>\n<p>theorem test'':<br>\n fixes n :: int<br>\n shows \"n = 0 \\&lt;Longrightarrow&gt; n \\&lt;noteq&gt; 2\"<br>\nusing assms<br>\napply (rule the_rule_imp)          (* works *)<br>\noops</p>\n</blockquote>\n<p>The theorem list \"assms\" only includes propositions listed in<br>\n\"assumes\" clauses. Since there are no \"assumes\" clauses in either of<br>\nthe last two theorems, \"assms\" is actually empty, so there are no<br>\nchained facts, and \"rule\" doesn't try to unify with any assumptions.</p>\n<ul>\n<li>Brian<br>\n</li>\n</ul>\n</blockquote>",
        "id": 294135196,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844108
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:rafalk@cse.unsw.edu.au\">rafalk@cse.unsw.edu.au</a>&gt;<br>\nI agree. At the very least, this is non-obvious. I still get caught by <br>\nthis occasionally. I've trained myself that rule/erule/drule and <br>\nassumption require the use of - first, while auto and (clar)simp do not. <br>\nI still remain surprised whenever I have to replace \"by blast\" with \"by </p>\n<ul>\n<li>blast\". As for fastsimp, force and metis... I just don't remember.</li>\n</ul>\n<p>While I suppose I could just go around using auto and metis everywhere, <br>\nI don't think that's necessarily a good idea, as it miscommunicates to <br>\nthe reader/maintainer how involved the proof step is. I will use <br>\nassumption when that's all that's needed, blast when there's no <br>\nsimplification needed, and prefer simp over auto.</p>\n<p>Anyway, my proposal would be to add an implicit \"-\" to blast and any <br>\nofficial tactic that can finish a proof, and document in the tutorial <br>\nand reference the fact that rule/erule/drule (and whatever else) don't <br>\ndo this, like Jun suggested.</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294135442,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844175
    }
]