[
    {
        "content": "<p>From: Amarin Phaosawasdi &lt;<a href=\"mailto:phaosaw2@illinois.edu\">phaosaw2@illinois.edu</a>&gt;<br>\nHi all,</p>\n<p>I've been using the book Concrete Semantics <br>\n(<a href=\"http://www21.in.tum.de/~nipkow/Concrete-Semantics/\">http://www21.in.tum.de/~nipkow/Concrete-Semantics/</a>) as a tutorial.</p>\n<p>Currently, I'm trying to prove the following.<br>\n\"⟦(WHILE b DO c,s)⇒t⟧⟹(WHILE b DO (c;;IF b THEN c ELSE SKIP),s)⇒t\"</p>\n<p>In other words, I want to prove that I can unroll the loop and end up in <br>\nthe same final state.</p>\n<p>At some point in the proof, I'm in a \"subtree\" (also another WHILE loop) <br>\nof the original WHILE b DO c. I want to be able to apply the induction <br>\nhypothesis and get an unrolled loop for that subtree.</p>\n<p>I looked at some examples of rule induction on the web and in the <br>\nProgramming and Proving book. I tried structuring the proofs that way <br>\nand also used cases, but am still stuck.</p>\n<p>The version of the theory that I'm sending here uses \"proof -\". It helps <br>\nme being explicit what I'm trying to do since I'm new to Isabelle.</p>\n<p>I've laid out the whole proof and skipped the parts where I needed the <br>\ninduction hypothesis with \"sorry\".</p>\n<p>Would anybody mind taking a look, please?</p>\n<p>The code is below. I've marked the places that I need help with \"(* NEED <br>\nINDUCTION HYPOTHESIS *)\".</p>\n<p>Thank you,<br>\nAmarin</p>\n<p>========================<br>\nSemantics.thy<br>\n========================<br>\ntheory Semantics imports Main begin</p>\n<p>type_synonym vname = string<br>\ntype_synonym val = int<br>\ntype_synonym state = \"vname ⇒ val\"</p>\n<p>datatype aexp = N int | V vname<br>\nfun aval :: \"aexp ⇒ state ⇒ val\" where<br>\n\"aval (N n) s = n\" |<br>\n\"aval (V x) s = s x\"</p>\n<p>datatype bexp = Bc bool<br>\nfun bval :: \"bexp ⇒ state ⇒ bool\" where<br>\n\"bval (Bc v) s = v\"</p>\n<p>datatype<br>\n   com = SKIP<br>\n       | Assign vname aexp       (\"_ ::= _\" [1000, 61] 61)<br>\n       | Seq    com  com         (\"_;;/ _\"  [60, 61] 60)<br>\n       | If     bexp com com     (\"(IF _/ THEN _/ ELSE _)\"  [0, 0, 61] 61)<br>\n       | While  bexp com         (\"(WHILE _/ DO _)\"  [0, 61] 61)</p>\n<p>inductive<br>\n   big_step :: \"com × state ⇒ state ⇒ bool\" (infix \"⇒\" 55)<br>\nwhere<br>\nSkip: \"(SKIP,s) ⇒ s\" |<br>\nAssign: \"(x ::= a,s) ⇒ s(x := aval a s)\" |<br>\nSeq: \"⟦ (c1,s1) ⇒ s2;  (c2,s2) ⇒ s3 ⟧ ⟹ (c1;;c2, s1) ⇒ s3\" |<br>\nIfTrue: \"⟦ bval b s;  (c1,s) ⇒ t ⟧ ⟹ (IF b THEN c1 ELSE c2, s) ⇒ t\" |<br>\nIfFalse: \"⟦ ¬bval b s;  (c2,s) ⇒ t ⟧ ⟹ (IF b THEN c1 ELSE c2, s) ⇒ t\" |<br>\nWhileFalse: \"⟦¬bval b s⟧ ⟹ (WHILE b DO c,s) ⇒ s\" |<br>\nWhileTrue: \"⟦ bval b s1;  (c,s1) ⇒ s2;  (WHILE b DO c,s2) ⇒ s3 ⟧<br>\n   ⟹ (WHILE b DO c, s1) ⇒ s3\"</p>\n<p>declare big_step.intros [intro]<br>\nlemmas big_step_induct = big_step.induct[split_format(complete)]<br>\ninductive_cases SkipE[elim!]: \"(SKIP,s) ⇒ t\"<br>\ninductive_cases AssignE[elim!]: \"(x ::= a,s) ⇒ t\"<br>\ninductive_cases SeqE[elim!]: \"(c1;;c2,s1) ⇒ s3\"<br>\ninductive_cases IfE[elim!]: \"(IF b THEN c1 ELSE c2,s) ⇒ t\"<br>\ninductive_cases WhileE[elim]: \"(WHILE b DO c,s) ⇒ t\"</p>\n<p>theorem big_step_determ: \"⟦ (c,s) ⇒ t; (c,s) ⇒ u ⟧ ⟹ u = t\"<br>\n   by (induction arbitrary: u as3 rule: big_step_induct) blast+</p>\n<p>lemma unroll_while:<br>\n\"⟦(WHILE b DO c,s)⇒t⟧⟹(WHILE b DO (c;;IF b THEN c ELSE SKIP),s)⇒t\"<br>\nproof -<br>\n   fix b s c t<br>\n   assume assms: \"(WHILE b DO c,s)⇒t\"<br>\n   let ?thesis = \"(WHILE b DO (c;;IF b THEN c ELSE SKIP),s)⇒t\"<br>\n   {<br>\n     assume true1: \"bval b s\"<br>\n     obtain i where i1:\"(c,s)⇒i\" and i2:\"(WHILE b DO c,i)⇒t\" using assms <br>\ntrue1 by auto<br>\n     {<br>\n       assume true2: \"bval b i\"<br>\n       obtain i' where i3:\"(c,i)⇒i'\" and i4:\"(WHILE b DO c,i')⇒t\" using <br>\ni2 true2 by auto<br>\n       have body:\"(c;;IF b THEN c ELSE SKIP,s) ⇒ i'\" using i1 i3 true2 <br>\nby auto<br>\n       have loop:\"(WHILE b DO (c;;IF b THEN c ELSE SKIP),i') ⇒ t\" using i4<br>\n         sorry (* NEED INDUCTION HYPOTHESIS *)<br>\n       have ?thesis using body loop true1 by auto<br>\n     } moreover<br>\n     {<br>\n       assume false2: \"¬bval b i\"<br>\n       have body:\"(c;;IF b THEN c ELSE SKIP,s) ⇒ i\" using i1 false2 by auto<br>\n       have loop:\"(WHILE b DO (c;;IF b THEN c ELSE SKIP),i) ⇒ t\" using i2<br>\n         sorry (* NEED INDUCTION HYPOTHESIS *)<br>\n       have ?thesis using body loop true1 by auto<br>\n     }<br>\n     ultimately have \"(WHILE b DO (c;;IF b THEN c ELSE SKIP),s)⇒t\" by metis<br>\n   } moreover {<br>\n     assume false1: \"¬bval b s\"<br>\n     have final1:\"(WHILE b DO c,s)⇒s\" using false1 by auto<br>\n     have final2:\"(WHILE b DO (c;;IF b THEN c ELSE SKIP),s)⇒s\" using <br>\nfalse1 by auto<br>\n     have eq:\"s=t\" using assms final1 big_step_determ by auto<br>\n     have ?thesis using final2 eq by auto<br>\n   } ultimately show ?thesis by metis<br>\nqed</p>\n<p>end</p>",
        "id": 294307071,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924668
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nDear Amarin,</p>\n<p>That is a nice little puzzle. I had not tried it before and needed some time to<br>\nfind a solution (see below). The fine structure of the proofs remains obscure<br>\nand you may want to spell it out yourself. The main point is however not that<br>\ndifficult: the lemma lem did not drop out of thin air but comes directly from<br>\nlooking at the subgoal in the WhileTrue case. On the techical side it is<br>\nimportant to write the induction in the given form because the proposition you<br>\ninduct on contains other subterms than just variables.</p>\n<p>There may be other slicker ways of proving your goal but I could not see how to<br>\ncomplete your original attempt.</p>\n<p>Tobias</p>\n<p>lemma lem:<br>\n  \"⟦ (WHILE b DO (c;; IF b THEN c ELSE SKIP),s2) ⇒ s3; bval b s1; (c,s1) ⇒ s2 ⟧<br>\n   ⟹ (WHILE b DO (c;; IF b THEN c ELSE SKIP),s1) ⇒ s3\"<br>\napply(induction \"WHILE b DO (c;; IF b THEN c ELSE SKIP)\" s2 s3<br>\n  arbitrary: s1 rule: big_step_induct)<br>\n apply auto<br>\ndone</p>\n<p>lemma \"(WHILE b DO c,s) ⇒ t ⟹ (WHILE b DO (c;; IF b THEN c ELSE SKIP),s) ⇒ t\"<br>\nproof(induction \"WHILE b DO c\" s t rule: big_step_induct)<br>\n  case WhileFalse thus ?case by blast<br>\nnext<br>\n  case WhileTrue thus ?case using lem by blast<br>\nqed</p>",
        "id": 294307089,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924678
    },
    {
        "content": "<p>From: Amarin Phaosawasdi &lt;<a href=\"mailto:phaosaw2@illinois.edu\">phaosaw2@illinois.edu</a>&gt;<br>\nDear Tobias,</p>\n<p>This helped tremendously. I spelled the proof out and it made perfect sense.</p>\n<p>Thank you,<br>\nAmarin</p>",
        "id": 294307150,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660924687
    }
]