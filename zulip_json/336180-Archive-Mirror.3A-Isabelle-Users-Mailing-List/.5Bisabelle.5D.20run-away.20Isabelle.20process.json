[
    {
        "content": "<p>From: \"Elsa L. Gunter\" &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nDear Isabelle Community,<br>\n   I am having grave problems with the execution of Isabelle-2014, and I <br>\nhave not found a thread on this mailing list that seems to address my <br>\nproblem.  Isabelle is taking arbitrarily long in between steps of proof, <br>\nand other things, where arbitrarily long is minutes to hours to <br>\novernight without completing.  And while I suspect that I may be <br>\ncontributing to the problem by there being a rewrite that I have added <br>\nthat has led to a non-confluent system, the system tight now has taken <br>\nmore then an hour to try to do a thin_tac, which should never be <br>\nnon-terminating.  And despite the length of time I have waited, it <br>\nalmost surely will come back, eventually (in the temporal logic sense of <br>\nunbounded eventually). But this is making it really painful to try to <br>\nmake any progress.<br>\n   Some background for anybody who might have an idea how to help me.  <br>\nFirst, my system is a mac running Mac OX X 10.9.5 (maverick, with <br>\npatches); processor is a 2.8 GHz Intel Core 17 with 4 cores (1 <br>\nprocessor), 16 GB 1600 MHz DDR3 Memory.  I am running Isabelle 2014 with <br>\na fairly recent version of the Archive of Formal Proofs.  My preferences <br>\nfile is quite minimal, and makes no mention of threads.   My code <br>\ndepends on the List-Infinite and JinjaThreads.  I have a collection of <br>\ntwelve locally developed theories upon which I also depend.   The local <br>\ntheories accumulate to something more than 10000 loc. I have previously <br>\nbuilt a heap containing the AFP theories, and I start form that heap.  I <br>\nthought I might reduce the problem by building a heap containing the all <br>\nthe local theories upon which I depend, but that build never terminated <br>\n(I let it run overnight, ~10 hours).  I found that strange, since it <br>\ntakes about 10 minutes for it to build the local theories upon which I <br>\nam depending when I am interactively loading the desired theory from a <br>\nbase containing just the AFP stuff I need.  I've tried it twice, but it <br>\nis a time-consuming, unproductive exercise.<br>\n   When Isabelle is semi-non-responsive, it usually colors all of the <br>\ntext grey (not purple).  I haven't been able to tell which of the greys <br>\nit is.   Just now, while writing this message, the thin_tac I requested <br>\ncan back (correctly), and then I deleted the line after it, causing the <br>\ncursor to be again immediately after the thin_tac.  The text was greyed <br>\nout again, and then after a couple of minutes it became clear with the <br>\nthin_tac line yellow, but it is failing to display the output.  I <br>\npresume it will in a little while.   I have had problems along these <br>\nlines, but less severe ever since switching to jEdit from Proof General, <br>\nwith the problem seeming to grow some since the beginning of the <br>\nsemester (January), but with it getting an order of magnitude worse in <br>\nthe last week.  The problem's getting worse seemed to be temporally <br>\ncorrelated with my doing a proof that involved a term that was about 40 <br>\nlines long (the term, that is).  Other than that, I'm not using metis or <br>\nsmt, and rarely auto or force or blast.  simp and clarsimp get used a <br>\nfair amount, so nonterminating rewrites might have something to do with <br>\nmy problem, except I would expect it to just always fail to come back, <br>\nwhich is not its behavior.  There are a few bits of orange (warnings) in <br>\nsome of the files upon which I depend, but I have removed them all from <br>\nthe current file.  I have observed that ambiguous parses, where only one <br>\nis type correct, slow Isabelle down very considerably.  My proofs ar a <br>\nmix of Isar style and old apply style, with most of the recent additions <br>\nbeing in the old apply style.    I do have a fairly large number of <br>\nlocales I'm working with, and doing a print_locale! is just out of the <br>\nquestion.   Each time the evaluation has to go through the creation of a <br>\nnew layer of locale by combining specialized versions of previous one, <br>\ntogether with additions, that is always a choke point in the <br>\ncomputation.  I can't  think of any other observations I have made that <br>\nmight be relevant.<br>\n   This matter is rather urgent to me. I am teaching a course this <br>\nsemester based on the use of Isabelle, with students working on a large <br>\ncombined project, each with his or her own part.  I need to be helping <br>\nthem fairly regularly, in part by giving them extra lemmas about the <br>\ncore infrastructure that groups of them need to overcome various hurdles <br>\nthey face in their subprojects.  I have told them lemma statements to <br>\nadd to their code with a sorry, and they are proceeding with these, but <br>\nthe course ends next week, and it would be a great pity not to be able <br>\nto provide them with a sense of closure from having all theorems really <br>\nand truly proved.  Also, so far the students do not seem to be <br>\nstruggling with Isabelle delays to the extent I am, but if they suddenly <br>\nstart having the same problems, I can not feasibly ask them to continue <br>\ntheir work, with would definitely leave them with a lack of closure.  I <br>\nwould appreciate any help anyone can give to improve this situation.<br>\n---Elsa</p>",
        "id": 294639741,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161593
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 3 May 2015, Elsa L. Gunter wrote:</p>\n<blockquote>\n<p>I am having grave problems with the execution of Isabelle-2014, and I <br>\nhave not found a thread on this mailing list that seems to address my <br>\nproblem.</p>\n</blockquote>\n<p>It generally sounds like a situation close to the proverbial \"concrete <br>\nwall\" of system resource limits.  Only black holes and national debts can <br>\ngrow indefinitely, and for black holes it is not yet sure.</p>\n<p>Below are some hints how to stretch resource paramaters a bit, and thus <br>\npostpone the imminent meltdown.</p>\n<blockquote>\n<p>Isabelle is taking arbitrarily long in between steps of proof, and other <br>\nthings, where arbitrarily long is minutes to hours to overnight without <br>\ncompleting.</p>\n</blockquote>\n<p>In such situations it is important to get an idea which part of Isabelle <br>\nis busy.  There are two sides: Isabelle/ML and Isabelle/Scala, <br>\ncorresponding to two run-time system processes: poly and java.  With \"top <br>\n-o cpu\" on the command-line of Mac OS X it should be possible to see a bit <br>\nmore.</p>\n<p>Moreover, a Java process can be analyzed by jconsole, to get an idea about <br>\nheap size, threads etc.  This tool is part of the bundled JDK of Isabelle <br>\nin $JAVA_HOME/bin -- you can find that out as follows inside Isabelle:</p>\n<p>ML {* getenv \"JAVA_HOME\" *}</p>\n<blockquote>\n<p>And while I suspect that I may be contributing to the problem by there <br>\nbeing a rewrite that I have added that has led to a non-confluent <br>\nsystem, the system tight now has taken more then an hour to try to do a <br>\nthin_tac, which should never be non-terminating.</p>\n</blockquote>\n<p>Non-termination alone should not be a problem: you get deep-purple <br>\nfeedback in the Prover IDE, and should be able to delete the material to <br>\nrecover.  Serious problems are usually caused by:</p>\n<p>(a) Massive amounts of \"potentially useful tracing information\" that<br>\n       tool implementors sometimes leave in by default (which is very bad<br>\n       programming style).  That is the easyiest way to bomb the front-end.</p>\n<p>(b) Really huge intermediate goal states that are printed, either<br>\n       accidentally or on purpose, e.g. via print_tac. It occasionally<br>\n       helps to reduce output size like this:</p>\n<p>declare [[goals_limit = 1, show_markup = false]]</p>\n<blockquote>\n<p>My code depends on the List-Infinite and JinjaThreads.  I have a <br>\ncollection of twelve locally developed theories upon which I also <br>\ndepend.  The local theories accumulate to something more than 10000 loc.</p>\n</blockquote>\n<p>This is already quite substantial material.  JinjaThreads is always at <br>\n120% of system resources, no matter how much are available.</p>\n<blockquote>\n<p>I have previously built a heap containing the AFP theories, and I start <br>\nform that heap.  I thought I might reduce the problem by building a heap <br>\ncontaining the all the local theories upon which I depend, but that <br>\nbuild never terminated (I let it run overnight, ~10 hours).  I found <br>\nthat strange, since it takes about 10 minutes for it to build the local <br>\ntheories upon which I am depending when I am interactively loading the <br>\ndesired theory from a base containing just the AFP stuff I need.</p>\n</blockquote>\n<p>Here I suspect that the JVM default heap is too small for this amount of <br>\nsources.  Try something like this in $ISABELLE_HOME_USER/etc/settings:</p>\n<p>ISABELLE_BUILD_JAVA_OPTIONS=\"-Djava.awt.headless=true -Xms1024m -Xmx4096m -Xss4m\"</p>\n<p>Using a suitable base image can significantly reduce the resource <br>\nrequirements of the Prover IDE.  Note that the build of the selected base <br>\nsession of the Prover IDE actually uses the JVM parameters of <br>\nIsabelle/jEdit.  The above only applies to \"isabelle build\" on the <br>\ncommand-line.</p>\n<blockquote>\n<p>When Isabelle is semi-non-responsive, it usually colors all of the text <br>\ngrey (not purple).  I haven't been able to tell which of the greys it <br>\nis.</p>\n</blockquote>\n<p>That could be outdated_color.  You can change the color value in Plugin <br>\nOptions / Isabelle / Rendering to check this hypothesis.</p>\n<blockquote>\n<p>Just now, while writing this message, the thin_tac I requested can back <br>\n(correctly), and then I deleted the line after it, causing the cursor to <br>\nbe again immediately after the thin_tac.  The text was greyed out again, <br>\nand then after a couple of minutes it became clear with the thin_tac <br>\nline yellow, but it is failing to display the output.  I presume it will <br>\nin a little while.</p>\n</blockquote>\n<p>Here it is again important to know if poly or java is busy, or both. For <br>\nexample, it could be a rather long garbage collection of Poly/ML, which is <br>\nnormal with JinjaThreads in the back.  To amend this, you should use <br>\nPoly/ML in 64bit mode like this in $ISABELLE_HOME_USER/etc/settings:</p>\n<p>ML_PLATFORM=\"$ISABELLE_PLATFORM64\"<br>\n   ML_HOME=\"$ML_HOME/../$ML_PLATFORM\"</p>\n<p>Another possibility is JVM heap space.  You can enlarge that for the <br>\nProver IDE in the .app bundle Info.plist in its &lt;key&gt;JVMOptions&lt;/key&gt; <br>\nentry.  For the command-line version of \"isabelle jedit\" the same <br>\ninformation is in $ISABELLE_HOME_USER/etc/settings e.g.:</p>\n<p>JEDIT_JAVA_OPTIONS=\"-Xms1024m -Xmx4096m -Xss4m\"</p>\n<p>In both situations, you need to \"reboot\" the application.</p>\n<blockquote>\n<p>The problem's getting worse seemed to be temporally correlated with my <br>\ndoing a proof that involved a term that was about 40 lines long (the <br>\nterm, that is).</p>\n</blockquote>\n<blockquote>\n<p>I have observed that ambiguous parses, where only one is type correct, <br>\nslow Isabelle down very considerably.</p>\n</blockquote>\n<p>Ambiguous grammars or input can cause exponential blowup of parse trees. <br>\nWith rather large terms, this can be a real problem.</p>\n<blockquote>\n<p>I do have a fairly large number of locales I'm working with, and doing a <br>\nprint_locale! is just out of the question.  Each time the evaluation has <br>\nto go through the creation of a new layer of locale by combining <br>\nspecialized versions of previous one, together with additions, that is <br>\nalways a choke point in the computation.</p>\n</blockquote>\n<p>JinjaThreads is already stretching locales and locale interpretation <br>\nbeyond feasibilty.  If you build on top of some very big locales of that <br>\nsession, it is likely to cause problems.</p>\n<p>Makarius</p>",
        "id": 294639869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161661
    },
    {
        "content": "<p>From: \"Elsa L. Gunter\" &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nOn 5/3/15 2:22 PM, Makarius wrote:</p>\n<blockquote>\n<p>On Sun, 3 May 2015, Elsa L. Gunter wrote:</p>\n<blockquote>\n<p>I am having grave problems with the execution of Isabelle-2014, and I <br>\nhave not found a thread on this mailing list that seems to address my <br>\nproblem.</p>\n</blockquote>\n<p>It generally sounds like a situation close to the proverbial \"concrete <br>\nwall\" of system resource limits.  Only black holes and national debts <br>\ncan grow indefinitely, and for black holes it is not yet sure.</p>\n<p>Below are some hints how to stretch resource paramaters a bit, and <br>\nthus postpone the imminent meltdown.</p>\n<blockquote>\n<p>Isabelle is taking arbitrarily long in between steps of proof, and <br>\nother things, where arbitrarily long is minutes to hours to overnight <br>\nwithout completing.</p>\n</blockquote>\n<p>In such situations it is important to get an idea which part of <br>\nIsabelle is busy.  There are two sides: Isabelle/ML and <br>\nIsabelle/Scala, corresponding to two run-time system processes: poly <br>\nand java.  With \"top -o cpu\" on the command-line of Mac OS X it should <br>\nbe possible to see a bit more.<br>\nUsing the Activity monitor, it is primarily poly that is primary <br>\nresource hog.  It is running at ~ 400% - 450~ cpu.  If I run top -o cpu  <br>\nfor a second or two and redirect the output to a file, poly will always <br>\nexactly occur once near the top:</p>\n</blockquote>\n<p>\u001b[11d659   poly\u001b[11;20H403.8 81:49:39 14/4 0    28    12133  12G+ 12G-   0B</p>\n<p>and JavaAppLaunc occurs repeatedly, lower down:</p>\n<p>\u001b[19d623   JavaAppLaunc 0.1   19:47.99 65   7    333   2179   280M+ <br>\n307M+  0B</p>\n<blockquote>\n<p>Moreover, a Java process can be analyzed by jconsole, to get an idea <br>\nabout heap size, threads etc.  This tool is part of the bundled JDK of <br>\nIsabelle in $JAVA_HOME/bin -- you can find that out as follows inside <br>\nIsabelle:</p>\n<p>ML {* getenv \"JAVA_HOME\" *}</p>\n<p>I can't do that right now (unless I kill my Isabelle process and <br>\nrestart) because Isabelle isn't paying any attention to me right now, <br>\nfor the last half hour.</p>\n<blockquote>\n<p>And while I suspect that I may be contributing to the problem by <br>\nthere being a rewrite that I have added that has led to a <br>\nnon-confluent system, the system tight now has taken more then an <br>\nhour to try to do a thin_tac, which should never be non-terminating.</p>\n</blockquote>\n<p>Non-termination alone should not be a problem: you get deep-purple <br>\nfeedback in the Prover IDE, and should be able to delete the material <br>\nto recover.  Serious problems are usually caused by:</p>\n<p>(a) Massive amounts of \"potentially useful tracing information\" that<br>\n      tool implementors sometimes leave in by default (which is very bad<br>\n      programming style).  That is the easyiest way to bomb the <br>\nfront-end.<br>\nshow_types is off, and I'm not tracing anything (although I would like <br>\nto if I dared).</p>\n<p>(b) Really huge intermediate goal states that are printed, either<br>\n      accidentally or on purpose, e.g. via print_tac. It occasionally<br>\n      helps to reduce output size like this:</p>\n<p>declare [[goals_limit = 1, show_markup = false]]<br>\nI can do that, although mostly the size of each step is not that big.  <br>\nThe thing it is currently stuck on is only one goal that is 20 lines <br>\nlong with 6 short assumptions that are only one line a piece.</p>\n<blockquote>\n<p>My code depends on the List-Infinite and JinjaThreads.  I have a <br>\ncollection of twelve locally developed theories upon which I also <br>\ndepend.  The local theories accumulate to something more than 10000 loc.</p>\n</blockquote>\n<p>This is already quite substantial material.  JinjaThreads is always at <br>\n120% of system resources, no matter how much are available.</p>\n<p>I'm not actually taking all of JinjaThreads, but cherry picking the <br>\nconcurrency parts, since I'm not actually doing anything with Jinja/Java <br>\nin this project (although I am in another).</p>\n<blockquote>\n<p>I have previously built a heap containing the AFP theories, and I <br>\nstart form that heap.  I thought I might reduce the problem by <br>\nbuilding a heap containing the all the local theories upon which I <br>\ndepend, but that build never terminated (I let it run overnight, ~10 <br>\nhours).  I found that strange, since it takes about 10 minutes for it <br>\nto build the local theories upon which I am depending when I am <br>\ninteractively loading the desired theory from a base containing just <br>\nthe AFP stuff I need.</p>\n</blockquote>\n<p>Here I suspect that the JVM default heap is too small for this amount <br>\nof sources.  Try something like this in $ISABELLE_HOME_USER/etc/settings:</p>\n<p>ISABELLE_BUILD_JAVA_OPTIONS=\"-Djava.awt.headless=true -Xms1024m <br>\n-Xmx4096m -Xss4m\"<br>\nI will try adding this to my settings.</p>\n<p>Using a suitable base image can significantly reduce the resource <br>\nrequirements of the Prover IDE.  Note that the build of the selected <br>\nbase session of the Prover IDE actually uses the JVM parameters of <br>\nIsabelle/jEdit.  The above only applies to \"isabelle build\" on the <br>\ncommand-line.</p>\n<p>I've been building my heaps via isabelle jEdit -d &lt;&lt;path to ROOT, <br>\ntypically .&gt;&gt; -l &lt;&lt;heap name&gt;&gt; instead of using isabelle build, because <br>\nI was having trouble with isabelle build and I thought you said you <br>\nalways went through a command-line call to isabelle jEdit.</p>\n<blockquote>\n<p>When Isabelle is semi-non-responsive, it usually colors all of the <br>\ntext grey (not purple).  I haven't been able to tell which of the <br>\ngreys it is.</p>\n</blockquote>\n<p>That could be outdated_color.  You can change the color value in <br>\nPlugin Options / Isabelle / Rendering to check this hypothesis.</p>\n<p>Which field should I change?  There are several greys, and my eyes <br>\naren't good enough to tell them apart.</p>\n<blockquote>\n<p>Just now, while writing this message, the thin_tac I requested can <br>\nback (correctly), and then I deleted the line after it, causing the <br>\ncursor to be again immediately after the thin_tac.  The text was <br>\ngreyed out again, and then after a couple of minutes it became clear <br>\nwith the thin_tac line yellow, but it is failing to display the <br>\noutput.  I presume it will in a little while.</p>\n</blockquote>\n<p>Here it is again important to know if poly or java is busy, or both. <br>\nFor example, it could be a rather long garbage collection of Poly/ML, <br>\nwhich is normal with JinjaThreads in the back.  To amend this, you <br>\nshould use Poly/ML in 64bit mode like this in <br>\n$ISABELLE_HOME_USER/etc/settings:</p>\n<p>ML_PLATFORM=\"$ISABELLE_PLATFORM64\"<br>\n  ML_HOME=\"$ML_HOME/../$ML_PLATFORM\"<br>\nI am using Isabelle is 64 bit mode, as per an earlier suggestion you <br>\nmade to me.  My setting file contains extactly:</p>\n</blockquote>\n<p>ML_PLATFORM=\"$ISABELLE_PLATFORM64\"<br>\nML_HOME=\"$POLYML_HOME/$ML_PLATFORM\"<br>\nML_OPTIONS=\"--minheap 2000 --maxheap 12000\"</p>\n<blockquote>\n<p>Another possibility is JVM heap space.  You can enlarge that for the <br>\nProver IDE in the .app bundle Info.plist in its &lt;key&gt;JVMOptions&lt;/key&gt; <br>\nentry.  For the command-line version of \"isabelle jedit\" the same <br>\ninformation is in $ISABELLE_HOME_USER/etc/settings e.g.:</p>\n<p>JEDIT_JAVA_OPTIONS=\"-Xms1024m -Xmx4096m -Xss4m\"<br>\nI will add this too, and try rebooting the application.  And I will run <br>\nit from the command-line, at least unitl that proves not to work as well.</p>\n<p>In both situations, you need to \"reboot\" the application.</p>\n<blockquote>\n<p>The problem's getting worse seemed to be temporally correlated with <br>\nmy doing a proof that involved a term that was about 40 lines long <br>\n(the term, that is).</p>\n</blockquote>\n<blockquote>\n<p>I have observed that ambiguous parses, where only one is type <br>\ncorrect, slow Isabelle down very considerably.</p>\n</blockquote>\n<p>Ambiguous grammars or input can cause exponential blowup of parse <br>\ntrees. With rather large terms, this can be a real problem.</p>\n<p>The term was not ambiguous, and because I have observed the grief <br>\nambiguous terms cause, I have removed most mixfix syntax from my input <br>\ncode.  I would be useful if I could shut off the pretty printing for <br>\nmixfix as well so that isabelle could parse what it prints.  I have shut <br>\noff abbreviations, but i have not found a flag for the mixfix.</p>\n<blockquote>\n<p>I do have a fairly large number of locales I'm working with, and <br>\ndoing a print_locale! is just out of the question.  Each time the <br>\nevaluation has to go through the creation of a new layer of locale by <br>\ncombining specialized versions of previous one, together with <br>\nadditions, that is always a choke point in the computation.</p>\n</blockquote>\n<p>JinjaThreads is already stretching locales and locale interpretation <br>\nbeyond feasibilty.  If you build on top of some very big locales of <br>\nthat session, it is likely to cause problems.</p>\n<p>We are only borrowing the theory of bisimulation from JinjaThreads, not <br>\nthe whole Jinja concurrent semantics.  bisimulation alone is big, but I <br>\nthought it was less than a quarter of all of JinjaThreads.  I could be <br>\nwrong, but I think the total code I'm adding on top of bisimulation is <br>\nless than the amount I have left out of JinjaThreads.</p>\n<p>Makarius<br>\nThank you for your attempt to help me.  If the changes to the settings <br>\nhelps, I will let you know.<br>\n---Elsa</p>\n</blockquote>",
        "id": 294640211,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161795
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 3 May 2015, Elsa L. Gunter wrote:</p>\n<blockquote>\n<p>Using the Activity monitor, it is primarily poly that is primary resource <br>\nhog.  It is running at ~ 400% - 450~ cpu.  If I run top -o cpu  for a second <br>\nor two and redirect the output to a file, poly will always exactly occur once <br>\nnear the top:</p>\n<p>\u001b[11d659   poly\u001b[11;20H403.8 81:49:39 14/4 0    28    12133  12G+ 12G-   0B</p>\n</blockquote>\n<p>Here we see 12G already, which means Poly/ML is practically at the maximum <br>\nof your 16GB machine.</p>\n<blockquote>\n<p>and JavaAppLaunc occurs repeatedly, lower down:</p>\n<p>\u001b[19d623   JavaAppLaunc 0.1   19:47.99 65   7    333   2179   280M+ 307M+ <br>\n0B</p>\n</blockquote>\n<p>I can't say on the spot if this is the actual JVM run-time system.  It <br>\nmight be just the launcher, and a second big \"java\" process is elsewhere. <br>\nNormally the Prover IDE requires a few GB for such big things.</p>\n<blockquote>\n<p>I'm not actually taking all of JinjaThreads, but cherry picking the <br>\nconcurrency parts, since I'm not actually doing anything with Jinja/Java in <br>\nthis project (although I am in another).</p>\n</blockquote>\n<p>OK.  Do you have all that base material in the base heap image?  Or is it <br>\nloaded into the Prover IDE interactively?</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>When Isabelle is semi-non-responsive, it usually colors all of the text <br>\n grey (not purple).  I haven't been able to tell which of the greys it <br>\n is.</p>\n</blockquote>\n<p>That could be outdated_color.  You can change the color value in Plugin<br>\n Options / Isabelle / Rendering to check this hypothesis.</p>\n<p>Which field should I change?  There are several greys, and my eyes aren't <br>\ngood enough to tell them apart.</p>\n</blockquote>\n</blockquote>\n<p>The left column has all colors in alphabetical order.  There should be an <br>\nentry \"Outdated color\" with some pinkish grey.</p>\n<blockquote>\n<p>I would be useful if I could shut off the pretty printing for mixfix as <br>\nwell so that isabelle could parse what it prints.  I have shut off <br>\nabbreviations, but i have not found a flag for the mixfix.</p>\n</blockquote>\n<p>If it is your own mixfix syntax, you could specify an explicit print mode <br>\nand turn that on/off on demand.  But I don't think that is needed: doing <br>\nmixfix syntax right, without ambiguities, it should parse and print <br>\nnicely.</p>\n<blockquote>\n<p>We are only borrowing the theory of bisimulation from JinjaThreads, not <br>\nthe whole Jinja concurrent semantics.  bisimulation alone is big, but I <br>\nthought it was less than a quarter of all of JinjaThreads.  I could be <br>\nwrong, but I think the total code I'm adding on top of bisimulation is <br>\nless than the amount I have left out of JinjaThreads.</p>\n</blockquote>\n<p>This sounds quite reasonable.  JinjaThreads contains many interesting <br>\nthings, well-hidden to potentially interested parties.</p>\n<p>If you want, you can send me your development privately, so that I can <br>\nexperiment with it a bit on my modest 12 core, 32 GB machine.</p>\n<p>Makarius</p>",
        "id": 294640619,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161930
    },
    {
        "content": "<p>From: \"Elsa L. Gunter\" &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nDear Makarius,<br>\n   Your previous message got me enough wiggle room to get the immediate <br>\ntheorm I was working on to go through.</p>\n<p>On 5/3/15 3:48 PM, Makarius wrote:</p>\n<blockquote>\n<p>On Sun, 3 May 2015, Elsa L. Gunter wrote:</p>\n<blockquote>\n<p>Using the Activity monitor, it is primarily poly that is primary <br>\nresource hog.  It is running at ~ 400% - 450~ cpu.  If I run top -o <br>\ncpu  for a second or two and redirect the output to a file, poly will <br>\nalways exactly occur once near the top:</p>\n<p>\u001b[11d659   poly\u001b[11;20H403.8 81:49:39 14/4 0    28    12133 12G+ <br>\n12G-   0B</p>\n</blockquote>\n<p>Here we see 12G already, which means Poly/ML is practically at the <br>\nmaximum of your 16GB machine.</p>\n<blockquote>\n<p>and JavaAppLaunc occurs repeatedly, lower down:</p>\n<p>\u001b[19d623   JavaAppLaunc 0.1   19:47.99 65   7    333   2179 280M+ <br>\n307M+ 0B</p>\n</blockquote>\n<p>I can't say on the spot if this is the actual JVM run-time system.  It <br>\nmight be just the launcher, and a second big \"java\" process is <br>\nelsewhere. Normally the Prover IDE requires a few GB for such big things.<br>\nI don't see java itself showing up.  I think polyml is the hog.</p>\n<blockquote>\n<p>I'm not actually taking all of JinjaThreads, but cherry picking the <br>\nconcurrency parts, since I'm not actually doing anything with <br>\nJinja/Java in this project (although I am in another).</p>\n</blockquote>\n<p>OK.  Do you have all that base material in the base heap image? Or is <br>\nit loaded into the Prover IDE interactively?<br>\nAlmost.  There is a in List-Inifinite that needs to be included because <br>\nof some reorganizing of the AFP entry.  Everything I need from <br>\nJinjaThreads is in my precompiled heap.</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>When Isabelle is semi-non-responsive, it usually colors all of <br>\nthe text &gt; grey (not purple).  I haven't been able to tell which of <br>\nthe greys it &gt;  is.</p>\n</blockquote>\n<p>That could be outdated_color.  You can change the color value in <br>\nPlugin<br>\n Options / Isabelle / Rendering to check this hypothesis.</p>\n<p>Which field should I change?  There are several greys, and my eyes <br>\naren't good enough to tell them apart.</p>\n</blockquote>\n</blockquote>\n<p>The left column has all colors in alphabetical order.  There should be <br>\nan entry \"Outdated color\" with some pinkish grey.</p>\n<p>OK.  I have changed it to a kind of light lime green that I think I will <br>\nnot confuse with anything else.  Since it isn't choking yet (although it <br>\nstill runs at 200% CPU with over 8 GB of memory when I have not <br>\nrequested it to do anything), I cn't tell it tha tis the color of a choke.</p>\n</blockquote>\n<p>Just what is Isabelle (polyml) doing when the cursor is sitting at the <br>\nend of a fully successfully completed proof?  I would have expected it <br>\nto be waiting for user input before doing anything else, but it keeps <br>\nrunning something. The energy impact of Isabelle is over ten times more <br>\nthan everything else on my system combined, and I'm lazy about leaving <br>\nstuff around.</p>\n<blockquote>\n<blockquote>\n<p>It would be useful if I could shut off the pretty printing for mixfix <br>\nas well so that isabelle could parse what it prints.  I have shut off <br>\nabbreviations, but i have not found a flag for the mixfix.</p>\n</blockquote>\n<p>If it is your own mixfix syntax, you could specify an explicit print <br>\nmode and turn that on/off on demand.  But I don't think that is <br>\nneeded: doing mixfix syntax right, without ambiguities, it should <br>\nparse and print nicely.<br>\nI have not found all the sources of the ambiguities, but loading two <br>\ndifferent theories that sue syntax that is unambiguous in itself can <br>\nlead to ambiguous syntax.  Since there are no checks the mixfix syntax <br>\nhas been done right, it would be nice to have a way of pretty printing <br>\nthat was guaranteed to parse.  Shutting off mixfix I believe would do that.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>We are only borrowing the theory of bisimulation from JinjaThreads, <br>\nnot the whole Jinja concurrent semantics.  bisimulation alone is big, <br>\nbut I thought it was less than a quarter of all of JinjaThreads.  I <br>\ncould be wrong, but I think the total code I'm adding on top of <br>\nbisimulation is less than the amount I have left out of JinjaThreads.</p>\n</blockquote>\n<p>This sounds quite reasonable.  JinjaThreads contains many interesting <br>\nthings, well-hidden to potentially interested parties.</p>\n<p>If you want, you can send me your development privately, so that I can <br>\nexperiment with it a bit on my modest 12 core, 32 GB machine.</p>\n</blockquote>\n<blockquote>\n<p>Makarius</p>\n<p>Thank you for your help and your offer for more.  I hope/think I can now <br>\nlimp through the next week.  However, this has caused me to wonder how I <br>\ncan continue to use Isabelle for the project on which I am embarked.  I <br>\nam only at the beginning and if I am running out of resources now, I'm <br>\nnot sure how I could hope to carry my project to completion.<br>\n---Elsa</p>\n</blockquote>",
        "id": 294641796,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162409
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:thomas.sewell@nicta.com.au\">thomas.sewell@nicta.com.au</a>&gt;<br>\nHello Elsa.</p>\n<p>I'm not completely sure about this, but I have taken the following<br>\nactions a couple of times and I <em>think</em> they might have reduced polyML's<br>\nmemory footprint.</p>\n<p>1) Restart Isabelle if polyML is getting too big. I am anecdotally<br>\nconvinced that sometimes polyML's heap size drifts upwards over time,<br>\nand that a restart can reset this.</p>\n<p>2) Try enabling \"skip-proofs\" during the reset while rebuilding up to<br>\nwhere you were before. You can find an option for skipping proofs in<br>\nIsabelle's options panel: jEdit menu Plugins-&gt;Plugin Options, pick<br>\nIsabelle-&gt;General, find the skip proofs setting. This will not only save<br>\ntime, it will cause polyML to build less proof-related objects<br>\ninternally, which may save memory.</p>\n<p>Caveat emptor ; all of the above may simply be a superstitious ritual I<br>\ngo through as a result of confirmation bias.</p>\n<p>Good luck,<br>\n     Thomas.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294642127,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162544
    },
    {
        "content": "<p>From: \"Elsa L. Gunter\" &lt;<a href=\"mailto:egunter@illinois.edu\">egunter@illinois.edu</a>&gt;<br>\nThank you, Thomas.  I will add these to my set of options.<br>\n---Elsa</p>",
        "id": 294642266,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162612
    },
    {
        "content": "<p>From: Matthew Fernandez &lt;<a href=\"mailto:matthew.fernandez@nicta.com.au\">matthew.fernandez@nicta.com.au</a>&gt;<br>\nAnother strategy I find useful is processing the following line when you're running very low on<br>\navailable memory, which I believe forces a garbage collection.</p>\n<p>ML {* PolyML.fullGC () *}</p>\n<p>Forcing a garbage collection in a managed language seems rather silly, but I have found it is<br>\nsometimes the only way to regain a responsive system.</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294642293,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162636
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Sun, 3 May 2015, Elsa L. Gunter wrote:</p>\n<blockquote>\n<p>Since it isn't choking yet (although it still runs at 200% CPU with over <br>\n8 GB of memory when I have not requested it to do anything), I cn't tell <br>\nit tha tis the color of a choke.</p>\n<p>Just what is Isabelle (polyml) doing when the cursor is sitting at the <br>\nend of a fully successfully completed proof?  I would have expected it <br>\nto be waiting for user input before doing anything else, but it keeps <br>\nrunning something. The energy impact of Isabelle is over ten times more <br>\nthan everything else on my system combined, and I'm lazy about leaving <br>\nstuff around.</p>\n</blockquote>\n<p>Isabelle/PIDE is no longer based on a TTY loop, so it is not really <br>\nwaiting for the next user input.  Rather the editor is continously <br>\nstreaming edits towards the prover, and the prover continously streaming <br>\nresults towards the editor.  In practice, this eventually converges, and <br>\nboth sides can become mostly idle, except for a few percent of CPU time.</p>\n<p>If you see 200% CPU usage of poly, despite nothing really going on, it is <br>\nsomething to be investigated.  E.g. there could be a bit too much garbage <br>\ncollection due to excessive use of heap space.  Or there could be \"auto <br>\ntools\" that did not terminate and could not be canceled properly, or even <br>\njust long-running tasks to print proof states after scrolling in the <br>\neditor.</p>\n<p>Isabelle/jEdit also has a Monitor panel to inspect certain aspects of the <br>\nML run-time system.</p>\n<blockquote>\n<p>I hope/think I can now limp through the next week.  However, this has <br>\ncaused me to wonder how I can continue to use Isabelle for the project <br>\non which I am embarked.  I am only at the beginning and if I am running <br>\nout of resources now, I'm not sure how I could hope to carry my project <br>\nto completion.</p>\n</blockquote>\n<p>Looking in just the right corners of big projects usually helps to get a <br>\nfactor 2 improvement concerning resource usage.</p>\n<p>Moreover, I have already some ideas to reduce the ML heap space <br>\nrequirements once again, but not for this release of Isabelle2015. The <br>\nquestion is how long we can hold out in 32bit address space, without <br>\nhaving to move to 64bit and thus practically into the cloud, e.g. see the <br>\nsketches on my blog <br>\n<a href=\"http://sketis.net/2015/proposal-remote-prover-connectivity-for-isabellepide\">http://sketis.net/2015/proposal-remote-prover-connectivity-for-isabellepide</a></p>\n<p>Makarius</p>",
        "id": 294642468,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162698
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is a rather drastic way to reclaim a lot of heap space by maximal <br>\nsharing of equal data structures:</p>\n<p>ML \"ML_System.share_common_data ()\"</p>\n<p>It can take minutes, but can shrink the heap by a factor of 2-3, or more. <br>\nThis is normally used when dumping heap images.</p>\n<p>A limited form of that is also used in normal operation of the Poly/ML <br>\nruntime-system.  It is the reason why most applications still work within <br>\nthe tiny 32bit address space.</p>\n<p>David Matthews can say more about the various GC phases of Poly/ML.</p>\n<p>The \"Monitor\" dockable in Isabelle/jEdit also has a heap section, which <br>\nhelps to get some idea about resource usage, and the effect of the above <br>\noperations.  Note that while the run-time system is busy doing such jobs, <br>\nthere is no update of the statistics, because the ML user space is <br>\ninactive.</p>\n<p>Makarius</p>",
        "id": 294642870,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162862
    },
    {
        "content": "<p>From: David Matthews &lt;<a href=\"mailto:dm@prolingua.co.uk\">dm@prolingua.co.uk</a>&gt;<br>\nThe garbage collector isn't just a simple case of: run out of heap; <br>\nperform GC; resume.  Or at least it hasn't been for a very long time. <br>\nThe GC code has to decide whether to run a cheap, but incomplete minor <br>\ncollection; a full but more expensive major collection; increase or <br>\nsometimes decrease the size of the heap or run the very expensive data <br>\nsharing pass that Makarius mentions.  There's no easy answer to this <br>\nbecause it depends on the pattern of allocations and the kind of data <br>\nstructures being built.  Indeed the best choice would really depend on <br>\nwhat happens AFTER the collection; the application may be just on the <br>\npoint of completing when the GC decides to start an expensive operation.</p>\n<p>The GC has heuristics to help decide what to do and uses the results of <br>\nprevious choices to guide the next choice.  For example, if a sharing <br>\npass was run and found lots of sharing it may be worth running it sooner <br>\nrather than later.  Much of the tuning was done by looking at large <br>\nIsabelle problems and JinjaThreads was the archetypal example.</p>\n<p>I'm very happy to look at this and see whether the tuning can be <br>\nimproved or indeed if garbage collection is the issue or not.  It may be <br>\nthat there needs to be some extra hints to the GC that can be given as <br>\ncommand line arguments in situations where a user is approaching the <br>\nlimits on their machine.  One suggestion I'd make is to increase the <br>\nvalue of --maxheap closer to the memory available on your machine (e.g. <br>\n--maxheap 14000).  It's not a good idea to increase it above the <br>\nphysical memory size since that can introduce thrashing but if you're <br>\nclose to the limit it could be better to tolerate a bit of it.</p>\n<p>David</p>",
        "id": 294643013,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661162915
    }
]