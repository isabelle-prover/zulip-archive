[
    {
        "content": "<p>From: Matthias Schmalz &lt;<a href=\"mailto:Matthias.Schmalz@inf.ethz.ch\">Matthias.Schmalz@inf.ethz.ch</a>&gt;<br>\nHi,</p>\n<p>I am trying to use the scala library Pure.jar to communicate with the <br>\nIsabelle process. A typical use case is to send a theory snipped like <br>\nthe following and to check whether the proof attempt succeeds:</p>\n<p>theory Test imports Main begin</p>\n<p>lemma foo:<br>\nfixes x :: bool<br>\nassumes \"x = True\"<br>\nshows \"x | x\"<br>\nusing assms<br>\nby simp</p>\n<p>I have already discovered the Isabelle_System.init method and I am aware <br>\nof the classes \"Isabelle_Process\" and \"Session\". My attempts to <br>\ncommunicate the above snippet to an Isabelle_Process failed due to my <br>\nunawareness of the input format of Isabelle_Process.input. (Perhaps, <br>\nthis is not the intended interface anyway?)<br>\nI also tried to use Session.init_node, but I am not sure how to choose <br>\nthe parameters and how to receive the result.</p>\n<p>I would appreciate any help on this very much!</p>\n<p>Best,<br>\nMatthias</p>",
        "id": 294152658,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849892
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFirst let's fix the Isabelle version for this thread: the latest release <br>\nIsabelle2011-1.  It does not make sense to use an older Isabelle version <br>\nwith Isabelle/Scala, due to the many substantial improvements of the same <br>\nthat went into Isabelle2011-1.</p>\n<p>Direct use of Isabelle_Process.input connects you with the protocol <br>\ninterpreter on the other side.  It is theoretically possible to extend its <br>\nset of protocol commands in user space, but that would mean to produce <br>\nyour own protocol implementation, which is a bit challenging to get really <br>\nright.</p>\n<p>It is better to use the official Isabelle/Scala document model, even <br>\nthough its API in Isabelle2011-1 is still a bit rough, and there are more <br>\ndetails of the mechanics of the underlying interaction model still visible <br>\nthan I would like to have after 4 years working on that.</p>\n<p>Attached is an example for doing the initial startup of the session <br>\ntogether with the theory context; see also <br>\n<a href=\"https://bitbucket.org/pide/pide_examples/src/2a4cfab96b3e/ex.scala\">https://bitbucket.org/pide/pide_examples/src/2a4cfab96b3e/ex.scala</a> (that <br>\nrepository might evolve further).</p>\n<p>This is how to build and run it with Isabelle2011-1:</p>\n<p>shell&gt; isabelle scalac ex.scala<br>\n   shell&gt; isabelle scala<br>\n   scala&gt; val session = PIDE_examples.Ex.Theory_Session()</p>\n<p>The Theory_Session.apply() function has some further optional arguments; <br>\ne.g. verbose = true gives you all the low-level protocol messages.</p>\n<p>What makes the implementation a bit delicate is the bias of Session <br>\ntowards the current main application in the Isabelle/jEdit Prover IDE. <br>\nHere the user throws edits at the prover, which in turn answers them <br>\nincrementally in an fully asynchronous manner.  There is never a point <br>\nwhere a finished execution of some command transaction is enforced. I have <br>\nrecovered the latter in the above Theory_Session for the first half of the <br>\nproblem: prover startup and processing the theory header.</p>\n<p>So you will get synchrous errors on the command line if anything fails <br>\nhere, say giving a bad logic image or imports.  If you have your own GUI, <br>\nyou might reconsider asynchronous startup, see also <br>\n~~/src/Tools/jEdit/src/plugin.scala which should give an idea about the <br>\nspecific wiring with the main jEdit event bus.</p>\n<p>What is still missing in the above ex.scala is the part about emitting the <br>\nstatement and proof, and inspecting its results.  This requires some extra <br>\ncare due to potential non-termination of that part of the document.</p>\n<p>We can discuss in further detail what your application really requires.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/8Yq1vHBXOz7jLDB5lQfHDKux/ex.scala\">ex.scala</a></p>",
        "id": 294152717,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849911
    },
    {
        "content": "<p>From: Matthias Schmalz &lt;<a href=\"mailto:Matthias.Schmalz@inf.ethz.ch\">Matthias.Schmalz@inf.ethz.ch</a>&gt;</p>\n<blockquote>\n<p>First let's fix the Isabelle version for this thread: the latest release<br>\nIsabelle2011-1. It does not make sense to use an older Isabelle version<br>\nwith Isabelle/Scala, due to the many substantial improvements of the<br>\nsame that went into Isabelle2011-1.</p>\n</blockquote>\n<p>Sure.</p>\n<blockquote>\n<p>Attached is an example for doing the initial startup of the session<br>\ntogether with the theory context; see also<br>\n<a href=\"https://bitbucket.org/pide/pide_examples/src/2a4cfab96b3e/ex.scala\">https://bitbucket.org/pide/pide_examples/src/2a4cfab96b3e/ex.scala</a> (that<br>\nrepository might evolve further).</p>\n</blockquote>\n<p>Thanks for this example. It clarifies the situation a lot. So new output <br>\nby the Isabelle process is announced through the commands_changed bus <br>\nand the details on the new document state can be queried with the <br>\nsnapshot method. I still have difficulties understanding what kind of <br>\ninformation a snapshot provides.</p>\n<p>My current view is the following; feel free to correct any <br>\nmisinterpretations:</p>\n<ul>\n<li>A Document.Node is somehow the counterpart of a text buffer in jEdit.</li>\n<li>A Document.Snapshot is the response of the system to a Document.Node.</li>\n<li>\n<p>The Document.Snapshot.command_state field indicates the response to a <br>\ngiven Isar command within the document node.</p>\n</li>\n<li>\n<p>The Command.State.results field indicates what is usually displayed in <br>\nthe Output Window of jEdit.</p>\n</li>\n<li>\n<p>The Command.State.status field gives the annotations displayed with <br>\njEdit's theory buffer.</p>\n</li>\n</ul>\n<blockquote>\n<p>What makes the implementation a bit delicate is the bias of Session<br>\ntowards the current main application in the Isabelle/jEdit Prover IDE.<br>\nHere the user throws edits at the prover, which in turn answers them<br>\nincrementally in an fully asynchronous manner. There is never a point<br>\nwhere a finished execution of some command transaction is enforced. I<br>\nhave recovered the latter in the above Theory_Session for the first half<br>\nof the problem: prover startup and processing the theory header.</p>\n</blockquote>\n<p>Synchronizing input and output is one of the main challenges in my <br>\napplication.</p>\n<blockquote>\n<p>What is still missing in the above ex.scala is the part about emitting<br>\nthe statement and proof, and inspecting its results. This requires some<br>\nextra care due to potential non-termination of that part of the document.</p>\n</blockquote>\n<p>Sure.</p>\n<blockquote>\n<p>We can discuss in further detail what your application really requires.</p>\n</blockquote>\n<p>There is much more to say and I would appreciate to discuss this, but I <br>\nhave a deadline for next weekend. I will come back to you after this.</p>\n<p>Best,<br>\nMatthias</p>",
        "id": 294152869,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849966
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nDocument.Node identifies each document node in a semi-abstract manner. <br>\nIt is indeed modeled after editor text buffers, can be used in other ways <br>\nas well.  In the example, I've identified the fresh theory node by some <br>\nsomething like /dummy-42/Theory.thy</p>\n<p>Document.Snapshot is the main access point of the totality of a collection <br>\nof document nodes in a document version, with semantic markup attached <br>\n(via the internal Command.State components).  This is the main programming <br>\ninterface to access results.  It provides a defined point in space and <br>\ntime of the ongoing process of continous checking of the sources.  The key <br>\noperation is Snapshot.select_markup, but in the present example I have <br>\nuses more low-level status and results fields from individual command <br>\nstates.</p>\n<p>Command.State.results and Command.State.status are special cases of the <br>\nprimary \"markup\" component of accumulated state information.  In fact, <br>\nafter Isabelle2011-1 the focus is shifting further to that general markup <br>\ntree, and result messages and status information might have to be <br>\nretrieved via <a href=\"http://Snapshot.select\">Snapshot.select</a> and some further variants of it.</p>\n<p>Makarius</p>",
        "id": 294152890,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660849978
    },
    {
        "content": "<p>From: Holger Gast &lt;<a href=\"mailto:gast@informatik.uni-tuebingen.de\">gast@informatik.uni-tuebingen.de</a>&gt;<br>\nHi Matthias,</p>\n<p>since similar questions have popped up now and then on the list, I<br>\nhave taken a closer look at your request on the basis of the implementation<br>\nof the I3P interface (see my web-page), because in principle<br>\nit already offers the required API to do \"background proving\".</p>\n<p>To explain: as desirable for user interface software (see the MVC pattern),<br>\nthe functionality of I3P is implemented entirely in a self-contained<br>\ninfrastructure layer that is independent of the Netbeans interface<br>\nthat happens to access that functionality now.<br>\nAs a result, extended unit tests can be run against the functionality<br>\n(which have greatly helped in maintainance and debugging through<br>\nthe different Isabelle releases of the past 2 years) and the bulk of the<br>\nsoftware becomes portable (e.g. to Eclipse, as done prototypically<br>\nin a bachelor thesis in Tübingen). For a fuller motivation and<br>\narchitecture description, see my UITP '10 paper.</p>\n<p>In principle, the infrastructure layer thus enables running Isabelle<br>\nas a background prover directly, analogously to the existing unit tests<br>\nof the Isabelle driver module. At the core, the it provides a simple<br>\nexecute/revoke model for commands (based on two methods of<br>\nCommandState), while I3P takes care of sending<br>\nappropriate Isabelle commands, interrupt signals, etc. as necessary.<br>\n(I3P even keeps sending INT until the command stops executing.)</p>\n<p>However, the abstractions built into the architecture lead to some<br>\nboilerplate code (see the @Before methods of the tests) that is not nice<br>\nfor the specific application.</p>\n<p>I have now added a small IsabelleFacade class (in module APIAccess;<br>\nfor Facade see Gamma et al. \"Design Patterns\", 1995),<br>\nwhich hopefully makes the procedure straightforward. The attachment<br>\ncontains a demonstration of the following features:</p>\n<ul>\n<li>start &amp; stop the prover</li>\n<li>\n<p>execute theories / individual commands and</p>\n<ul>\n<li>check for sucess, failure, or non-termination</li>\n<li>access the command's results</li>\n<li>\n<p>interrupt (explicit or automatic) looping commands after<br>\n  some specified timeout.</p>\n</li>\n<li>\n<p>bulk proof of several proof attempts in different theories,<br>\n  with automatic switching between theories.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>The SyncExec wrapper adapts the overall asynchronous<br>\n  architecture of I3P to the requirement of synchronous processing<br>\n  as necessary for testing or background proving. Its (straightforward)<br>\n  implementation shows how to work with the signalling mechanisms<br>\n  about changes in the processing state of some command in order to<br>\n  wait for the completion of processing.</p>\n</li>\n</ul>\n<p>The new facade, as well as the most important API classes of the<br>\ninfrastructure module IAPP, have JavaDoc explanations attached. Please<br>\nget back to me if I omitted some lazily, such that I can supply them lazily.</p>\n<p>Hope this helps,</p>\n<p>Holger<br>\n<a href=\"/user_uploads/14278/oqJmtmif0wHLCrAWMHd9vlUT/RunningTheoriesTest.java\">RunningTheoriesTest.java</a></p>",
        "id": 294153101,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660850056
    }
]