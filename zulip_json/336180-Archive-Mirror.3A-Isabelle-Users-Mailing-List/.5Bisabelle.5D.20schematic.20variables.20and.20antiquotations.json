[
    {
        "content": "<p>From: Lucas Dixon &lt;<a href=\"mailto:ldixon@inf.ed.ac.uk\">ldixon@inf.ed.ac.uk</a>&gt;<br>\nHello,</p>\n<p>I'm trying to do some experiments with Isabelle 2009 - I'm writing a <br>\nfunction to \"zip-to\" a particular subterm. I would like specify the <br>\nsubterm in a way that can involve schematic variables, much like the <br>\nfind feature which lets schematic variables be used to find theorems <br>\nmatching a pattern.</p>\n<p>So here's what I'm doing...</p>\n<p>(<strong> START </strong>)<br>\ntheory norm<br>\nimports Main<br>\nuses \"tools.ML\"<br>\nbegin</p>\n<p>local_setup {* ProofContext.set_mode ProofContext.mode_schematic *}</p>\n<p>ML {*<br>\nval x = zip_to_matching_subterm @{context} [] @{term \"?x + ?y\"} 0 @{term <br>\n\"1 + 2 + 3 + 4\"};<br>\n*}<br>\n(<strong> END </strong>)</p>\n<p>but here I get:</p>\n<p>*** Unbound schematic variable: ?x<br>\n*** At command \"ML\".</p>\n<p>Can I get the antiquotation to read schematic terms? Should I create a <br>\nnew kind of antiquotation? (is that easy?) Suggestions very welcome,</p>\n<p>cheers,<br>\nlucas</p>",
        "id": 294080140,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830369
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 10 Jul 2009, Lucas Dixon wrote:</p>\n<blockquote>\n<p>I'm trying to do some experiments with Isabelle 2009 - I'm writing a <br>\nfunction to \"zip-to\" a particular subterm. I would like specify the <br>\nsubterm in a way that can involve schematic variables, much like the <br>\nfind feature which lets schematic variables be used to find theorems <br>\nmatching a pattern.</p>\n<p>So here's what I'm doing...</p>\n<p>(<strong> START </strong>)<br>\ntheory norm<br>\nimports Main<br>\nuses \"tools.ML\"<br>\nbegin</p>\n<p>local_setup {* ProofContext.set_mode ProofContext.mode_schematic *}</p>\n<p>ML {*<br>\nval x = zip_to_matching_subterm @{context} [] @{term \"?x + ?y\"} 0 @{term \"1 + <br>\n2 + 3 + 4\"};<br>\n*}<br>\n(<strong> END </strong>)</p>\n<p>but here I get:</p>\n<p>*** Unbound schematic variable: ?x<br>\n*** At command \"ML\".</p>\n</blockquote>\n<p>Note that regular Isar text is always fully determined, and variables with <br>\nquestion marks refer to bindings introduced via is/let abbreviations.</p>\n<p>While the ProofContext.mode_schematic indeed switches to a special mode <br>\nwhere \"term patterns\" can be processed instead (with slightly different <br>\nrules for type-inference), it is a rather bad idea to enable it globally.</p>\n<p>Luckly the 'local_setup' did work out, indicating that this is the wrong <br>\napproach anyway. (Incidently, the reason for that is that a local theory <br>\noperation merely sees the \"auxiliary context\", essentially a sandbox to <br>\nproduce specifications to go into the \"target context\".  After finishing <br>\nthe 'local_setup' command, the toplevel resets the state to the <br>\n(unchanged) target context.  A permanent change of the local theory target <br>\nwould require proper LocalTheory operations, not ProofContext ones.)</p>\n<p>Since you have mentioned patterns in 'find_theorems' already, a brief look <br>\nat the sources reveals that it uses ProofContext.read_term_pattern to <br>\nprocess its input, and a check of its implementation shows the usual way <br>\nof changing these modes temporarily.</p>\n<blockquote>\n<p>Can I get the antiquotation to read schematic terms? Should I create a <br>\nnew kind of antiquotation? (is that easy?)</p>\n</blockquote>\n<p>Yes, defining antiquotation is a regular user-space operation, just like <br>\ndefining methods or attributes.  For Isabelle2009 I have cleaned up all <br>\nthese interfaces, to regain the clarity lost in 1999 when I was in a hurry <br>\nimplementing syntax for attributes and methods \"somehow\".</p>\n<p>OK, so let's go to src/Pure/ML/ml_antiquote.ML and study examples such as <br>\n@{term} or simular for 10-15 minutes.  This is the outcome:</p>\n<p>ML {*<br>\n   ML_Antiquote.inline \"term_pat\"<br>\n     (Args.context -- Scan.lift Args.name_source &gt;&gt;<br>\n       (fn (ctxt, s) =&gt;<br>\n         let val t = ProofContext.read_term_pattern ctxt s<br>\n         in ML_Syntax.atomic (ML_Syntax.print_term t) end))<br>\n*}</p>\n<p>ML {* @{term_pat \"?x + ?y\"} *}</p>\n<p>Note that we provide predefined antiquotations in Isabelle/Pure very <br>\nsparingly, because they essentially affect the Isabelle/ML language <br>\nitself.  So one needs to be 120% sure about it; any later changes will <br>\nhurt existing applications more than the usual fine-tuning and renaming of <br>\nlibrary functions.</p>\n<p>Makarius</p>",
        "id": 294080322,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830442
    }
]