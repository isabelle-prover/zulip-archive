[
    {
        "content": "<p>From: Mamoun FILALI-AMINE &lt;<a href=\"mailto:filali@irit.fr\">filali@irit.fr</a>&gt;<br>\nHello,</p>\n<p>I wonder if it is possible to instantiate schematic variables<br>\nafter unfolding (see example below).<br>\nthanks</p>\n<p>Mamoun</p>\n<hr>\n<p>definition \"ref P Q = (\\&lt;forall&gt; s. P s \\&lt;longrightarrow&gt; Q s)\"</p>\n<p>theorem<br>\n   assumes r1: \"ref A A'\"<br>\n   assumes r2: \"ref B B'\"<br>\nshows \"ref (A \\&lt;union&gt; B) (A' \\&lt;union&gt; B')\"<br>\nproof -<br>\n   have \"?thesis\" unfolding ref_def (* is \"\\&lt;forall&gt; s. ?L s <br>\n\\&lt;longrightarrow&gt; ?R s\" *)<br>\n<a href=\"/user_uploads/14278/T0lkinDGMazpyxdjy_Bg2-QB/filali.vcf\">filali.vcf</a></p>",
        "id": 294142198,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846230
    },
    {
        "content": "<p>From: Sascha Boehme &lt;<a href=\"mailto:boehmes@in.tum.de\">boehmes@in.tum.de</a>&gt;<br>\nHello Mamoun,</p>\n<p>Your example does not contain schematic variables after unfolding with<br>\nref_def.  Instead, the goal looks as follows:</p>\n<p>\\&lt;forall&gt;s. (A \\&lt;union&gt; B) s \\&lt;longrightarrow&gt; (A' \\&lt;union&gt; B') s</p>\n<p>The most common form to instantiate schematic variables in facts is<br>\nvia the \"of\" attribute, for example as follows:</p>\n<p>thm refl  (* is \"?t = ?t\" *)</p>\n<p>thm refl[of x]  (* is \"x = x\" *)</p>\n<p>This can also be applied to intermediate steps in a proof:</p>\n<p>lemma \"\\&lt;exists&gt;n::nat. n \\&lt;ge&gt; 0\"<br>\n  proof -<br>\n    {<br>\n      fix n :: nat<br>\n      have \"n \\&lt;ge&gt; 0\" by simp<br>\n    }<br>\n    (* we proved \"?n \\&lt;ge&gt; 0\" *)<br>\n    note this[of \"1 :: nat\"]  (* is \"1 \\&lt;ge&gt; 0\" *)<br>\n    then show ?thesis ..<br>\n  qed</p>\n<p>A different form of this proof introduces schematic variables into the<br>\ngoal, but in most cases it's best to let some tactic instantiate<br>\nthese variables automatically:</p>\n<p>lemma \"\\&lt;exists&gt;n::nat. n \\&lt;ge&gt; 0\"<br>\n    apply (rule exI)  (* the goal is now \"?n \\&lt;ge&gt; 0\" *)<br>\n    apply simp  (* instantiates \"?n\" appropriately and solves the goal *)<br>\n    done</p>\n<p>Cheers,<br>\nSascha</p>\n<p>Mamoun FILALI-AMINE wrote:</p>",
        "id": 294142222,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846242
    },
    {
        "content": "<p>From: Mamoun FILALI-AMINE &lt;<a href=\"mailto:filali@irit.fr\">filali@irit.fr</a>&gt;<br>\nHello,</p>\n<p>After discussing with Sascha Boehme, it seems to be technically<br>\n   impossible to match a goal against a pattern after unfolding with<br>\n   some rewrite rule:</p>\n<p>definition \"foo x = bar x x\"</p>\n<p>...</p>\n<p>have \"foo (f x)\" (is \"foo ?X\")       [pattern is possible]<br>\n       unfolding foo_def (is \"bar ?X _\")  [pattern is not possible]</p>\n<p>However, according to Sascha, most of the time proofs can be<br>\n   restructured to avoid this need or Isabelle's proof methods (e.g.,<br>\n   simp or auto) can collapse relevant proof steps such that these<br>\n   patterns are not necessary.</p>\n<p>Mamoun<br>\n<a href=\"/user_uploads/14278/mmkB9shsUhg0__eBjFS30sAr/filali.vcf\">filali.vcf</a></p>",
        "id": 294142356,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846298
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nStrictly speaking it is not <em>technically</em> impossible, merely outside the <br>\nscope of the structured proof language of Isar. Structure emerges by <br>\nrestricting low-level technical operations to something that conforms to <br>\ncertain higher concepts.  Take ML as programming language for example: it <br>\nallows much less operations than machine language, and is thus far more <br>\npowerful -- the compiler and runtime system can do smart things for you.</p>\n<p>One of the key principles of Isar is the distinction of the proof text and <br>\nthe proof state.  Information may flow only from text to state, not the <br>\nother way round.</p>\n<p>Anyway, your example reminds me of the Ltac tactic definition language of <br>\nCoq, with matching against the goal state.  After so many years, Isar <br>\nstill lacks a structured proof method definition language.  You have to <br>\nuse plain ML for that (via the 'method_setup' command, which is not really <br>\ndifficult).</p>\n<p>When drafting the first versions of the Isar proof language, I was aware <br>\nof this omission of a method definition language.  It made certain things <br>\neasier, and the quality of proofs (readability and maintainability) has <br>\nactually improved by making the language more restrictive.</p>\n<p>Structured proof method definition languages are still an interesting area <br>\nof research, but I see more potential for the future in sophisticated <br>\nediting support of Isar text in the Prover IDE.  (The current <br>\nIsabelle/jEdit implementation is a very modest beginning in that <br>\ndirection.)</p>\n<p>This can be illustrated by looking again at what Coq has to offer.  Since <br>\nI am myself located in France, I have the privilege to discuss with many <br>\nCoq users first-hand.  I see two main movements of power-users at the <br>\nmoment:</p>\n<p>(1) Hardcore Ltac scripting according Chlipala.<br>\n       (This reminds me a lot of a tactical style that was popular in<br>\n       Isabelle/HOL in the late 1990-ies, e.g. see HOL/Bali or<br>\n       HOL/Hoare_Parallel).</p>\n<p>(2) Quick in-place tactic composition via ssreflect, according to<br>\n       Gonthier.  His language assigns a meaning to almost every character<br>\n       in the ASCII set, to make typing as efficient as possible.  This<br>\n       wins more and more converts, and recent versions of Matita seem to<br>\n       have adopted it as well.</p>\n<p>Instead of imitating any of the above, I would eventually like to see a <br>\nProver IDE that allows very quick proof composition, but producing proper <br>\nIsar proof text instead of recording the keystrokes in the script.  This <br>\nwould be analogous to a typical Java IDE: a relatively weak language (here <br>\nIsar) is composed and maintained by relatively strong tooling.</p>\n<p>Makarius</p>",
        "id": 294142403,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846316
    }
]