[
    {
        "content": "<p>From: Christopher L Conway &lt;<a href=\"mailto:cconway@cs.nyu.edu\">cconway@cs.nyu.edu</a>&gt;<br>\nI'm working through the Isabelle tutorial and I'm a little mystified by<br>\nsome behavior I'm seeing in my solution to Exercise 3.4.1.<br>\nPreliminaries: a and b are values of a two mutually recursive datatype<br>\nrepresenting, respectively, arithmetic and boolean expressions; norma<br>\nand normif are mutually recursive normalization functions over those<br>\ndatatypes; \"evala expr env\" does what one would expect. (Full source<br>\ncode is included below.)</p>\n<p>The following proof goes through with no problem:</p>\n<p>lemma [simp]:<br>\n  \"evala (norma a) env = evala a env &amp;<br>\n   (! t e . evala (normif b t e) env = evala (IF b t e) env )\"<br>\napply (induct_tac a and b, simp_all)<br>\ndone</p>\n<p>The following proof fails with:<br>\n*** empty result sequence -- proof command failed<br>\n*** At command \"apply\".</p>\n<p>lemma [simp]:<br>\n  \"! t e . (evala (norma a) env = evala a env &amp;<br>\n    evala (normif b t e) env = evala (IF b t e) env)\"<br>\napply (induct_tac a and b, simp_all)<br>\ndone</p>\n<p>Note the only difference between the two is the scope of the quantifier.<br>\nAlso note that t and e do not appear free in the first line. What's<br>\ngoing on here?</p>\n<p>Thanks,<br>\nChris</p>\n<p>Source code:</p>\n<p>theory Expr<br>\nimports Main<br>\nbegin</p>\n<p>datatype 'a aexp =<br>\n  IF \"'a bexp\" \"'a aexp\" \"'a aexp\"<br>\n  | Sum \"'a aexp\" \"'a aexp\"<br>\n  | Diff \"'a aexp\" \"'a aexp\"<br>\n  | Var 'a<br>\n  | Num nat<br>\nand 'a bexp =<br>\n  Less \"'a aexp\" \"'a aexp\"<br>\n  | And \"'a bexp\" \"'a bexp\"<br>\n  | Neg \"'a bexp\"</p>\n<p>consts<br>\n  evala :: \"'a aexp =&gt; ('a =&gt; nat) =&gt; nat\"<br>\n  evalb :: \"'a bexp =&gt; ('a =&gt; nat) =&gt; bool\"</p>\n<p>primrec<br>\n  \"evala (IF b a1 a2) env =<br>\n     (if evalb b env then evala a1 env else evala a2 env)\"<br>\n  \"evala (Sum a1 a2) env = evala a1 env + evala a2 env\"<br>\n  \"evala (Diff a1 a2) env = evala a1 env - evala a2 env\"<br>\n  \"evala (Var v) env = env v\"<br>\n  \"evala (Num n) env = n\"</p>\n<p>\"evalb (Less a1 a2) env = (evala a1 env &lt; evala a2 env)\"<br>\n  \"evalb (And b1 b2) env = (evalb b1 env &amp; evalb b2 env)\"<br>\n  \"evalb (Neg b) env = (~evalb b env)\"</p>\n<p>consts<br>\n  norma :: \"'a aexp =&gt; 'a aexp\"<br>\n  normif :: \"'a bexp ^ 'a aexp ^ 'a aexp ^ 'a aexp\"</p>\n<p>primrec<br>\n  \"norma (IF b a1 a2) = normif b (norma a1) (norma a2)\"<br>\n  \"norma (Sum a1 a2)  = Sum (norma a1) (norma a2)\"<br>\n  \"norma (Diff a1 a2) = Diff (norma a1) (norma a2)\"<br>\n  \"norma (Var v) = Var v\"<br>\n  \"norma (Num n) = Num n\"</p>\n<p>\"normif (Less a1 a2) t e = IF (Less (norma a1) (norma a2)) t e\"<br>\n  \"normif (And b1 b2) t e = normif b1 (normif b2 t e) e\"<br>\n  \"normif (Neg b) t e = normif b e t\"</p>\n<p>done</p>",
        "id": 294042721,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660816014
    }
]