[
    {
        "content": "<p>From: barzan stefania &lt;<a href=\"mailto:stefania_barzan@yahoo.com\">stefania_barzan@yahoo.com</a>&gt;<br>\nDear list members,</p>\n<p>I try to define the smallest divisor of a number by the following:<br>\n definition :: \"nat=&gt; nat\" where<br>\n \"sdiv e == if ((\\&lt;not&gt; prime e) \\&lt;and&gt; (\\&lt;not&gt; e=1)) then (LEAST e1. prime e1 \\&lt;and&gt; e1 dvd e) else e\"</p>\n<p>My experiences showed me that the most hardest lemmas to prove are the one that follow direct from the definitions.</p>\n<p>For example now i try to prove: lemma sdiv_le: \"e1 dvd e==&gt; prime e1 ==&gt; (sdiv e) &lt;= e1\" <br>\n                                lemma sdiv_dvd: \"(sdiv e) dvd e\"<br>\nand i dont figure out how to do it. </p>\n<p>Can someone give me some hints?</p>\n<p>Thank you,<br>\nStefania</p>",
        "id": 294078832,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829983
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nlemma sdiv_le: \"e1 dvd e==&gt; prime e1 ==&gt; (sdiv e) &lt;= e1\"<br>\napply(auto simp:sdiv_def)<br>\napply(metis COMBC_def Collect_conj_eq Collect_def diff_diff_cancel<br>\neq_imp_le inter_code less_imp_diff_less less_le_not_le nat_le_linear<br>\nnot_less_Least)<br>\napply (metis eq_imp_le nat_one_not_prime prime_nat_def)</p>\n<p>The two metis calls were generated automatically by sledgehammer for me.<br>\nThe first step was to help sledgehammer a little bit because I knew the<br>\ndefinition of sdiv needs to be expanded.</p>\n<p>For the other lemma it didn't work - a proof was found (using amongst<br>\nother things LeastI and nat_prime_factor) but metis takes too long on it.</p>\n<p>Tobias</p>\n<p>barzan stefania schrieb:</p>",
        "id": 294078843,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660829989
    },
    {
        "content": "<p>From: Johannes HÃ¶lzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nAm Montag, den 29.06.2009, 02:14 -0700 schrieb barzan stefania:</p>\n<blockquote>\n<p>Dear list members,</p>\n<p>I try to define the smallest divisor of a number by the following:<br>\n definition :: \"nat=&gt; nat\" where<br>\n \"sdiv e == if ((\\&lt;not&gt; prime e) \\&lt;and&gt; (\\&lt;not&gt; e=1)) then (LEAST e1. prime e1 \\&lt;and&gt; e1 dvd e) else e\"</p>\n<p>My experiences showed me that the most hardest lemmas to prove are the one that follow direct from the definitions.</p>\n<p>For example now i try to prove: lemma sdiv_le: \"e1 dvd e ==&gt; prime e1 ==&gt; (sdiv e) &lt;= e1\" <br>\n                                lemma sdiv_dvd: \"(sdiv e) dvd e\"<br>\nand i dont figure out how to do it. </p>\n</blockquote>\n<blockquote>\n<p>Can someone give me some hints?</p>\n</blockquote>\n<p>If you know how to efficiently search lemmas in Isabelle they are easy<br>\nto solve. When you type &lt;&lt; C-c C-f &gt;&gt; in ProofGeneral you can write<br>\npatterns and search for lemmas. For example:</p>\n<p>When you write \"(LEAST x. _) \\&lt;le&gt; ?a\" (you also need to write the \"s,<br>\nthe _ and ?a are wildcards) it yields Least_le, which can be used as an<br>\nintroduction rule.</p>\n<p>To unfold sdiv we can use \"unfolding sdiv_def\". Each definition provides<br>\nsuchs lemma as &lt;&lt;name&gt;&gt;_def. Often it is enough to unfold the constant<br>\nand run the auto tactic. Sometimes we need also to specify some<br>\nintroduction rules and/or rewrite rules. Instad of using &lt;&lt;unfolding&gt;&gt;<br>\nyou could also add it as rewrite rule with &lt;&lt; simp add: sdiv_def &gt;&gt;.</p>\n<p>To see where the auto tactic stops just use &lt;&lt; proof auto &gt;&gt; and it<br>\nshows the current state. </p>\n<p>--- 8&lt; ---------------------------</p>\n<p>lemma sdiv_le: \"e1 dvd e ==&gt; prime e1 ==&gt; (sdiv e) &lt;= e1\"<br>\n  (* First you need to unfold the constant (the name of the lemma is .._def): *)<br>\n  unfolding sdiv_def</p>\n<p>(* proof auto -- auto knows enough about If that it can split it into two new goals *)</p>\n<p>(* proof (auto intro!: Least_le) -- We need to tell it how to handle \"LEAST ... \\&lt;le&gt; ...\",<br>\n                                      here we have the introduction rule Least_le *)</p>\n<p>by (auto intro!: Least_le<br>\n           simp add: prime_nat_def) (* To solve it we need also the definition of prime numbers *)</p>\n<p>lemma sdiv_dvd: \"(sdiv e) dvd e\"<br>\n  (* This works similar *)<br>\n  by (auto intro!: LeastI2_ex[where Q=\"% x. x dvd e\"]<br>\n           simp add: nat_prime_factor[of \"e\"])</p>\n<p>--- 8&lt; ---------------------------</p>\n<p>Of course in most cases the auto tactic does not solve the goal<br>\nimmediately. Then it is better to write Isar proofs, introducing new<br>\nrules and finally invoking auto with this new rules. </p>\n<p>Hope this helped.</p>\n<p>Johannes</p>\n<blockquote>\n<p>Thank you,<br>\nStefania</p>\n</blockquote>",
        "id": 294078900,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660830002
    }
]