[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:igbi@gmx.com\">igbi@gmx.com</a>&gt;<br>\nAs to what kind of tableaux it really is, that is questionable.</p>\n<p>Please consider this formula:</p>\n<p>(A &amp; B) --&gt; C ==&gt; ~A --&gt; D ==&gt;  B --&gt; (C | D).</p>\n<p>Has it been in your wildest dreams to do the following?<br>\n   (a) negate the conclusion of that formula,<br>\n   (b) then expand it into 6 negated chains of conjunctions,<br>\n   (c) then convert that into a formula that only uses Trueprop, ==&gt;, <br>\nFalse, and bool variables,<br>\n   (d) and then prove that expression with auto, auto needing none of <br>\nthis to be done.</p>\n<p>It went like this:</p>\n<p>(1) I became aware that Larry's blast is used by auto, the word <br>\n\"tableau\" being involved, by necessity implicating that French guy, <br>\nThomas Voeckler.</p>\n<p>(2) From looking at a combination of Reeves &amp; Clarke's free logic book, <br>\n[1], and the chapter on analytic tableaux in Smullyan, [2], I worked up <br>\nsome notation to implement the tree of a tableaux for the formula above, <br>\nfrom [1] page 76.</p>\n<p>(3) I tried to automate building the binary tree in Isabelle, but <br>\naborted that due to lack of programming skills.</p>\n<p>(4) I switched to trying to expand the formula in just the right way, to <br>\nget the chains that correspond to the tree.</p>\n<p>(5) I stumbled on the right combination of rules needed, at least for <br>\nthat formula, which is enough for now.</p>\n<p>Can we not agree, that ==&gt; is the Isabelle mother-of-all-meta-logic <br>\noperators? However, though mothers are very important, even mothers, at <br>\ntimes, need a little help from their children to arrive at the desired <br>\nlocation.</p>\n<p>I included the source and attached the THY. Even a true artiste must <br>\ncontinually experiment with notation to find something which meet many, <br>\nmany needs. Over and over again, initial choices are refined or abandoned.</p>\n<p>This will be part of my voluminous work, \"The Logic of a True Artiste - <br>\nIn All Its Majestic Fame and Glory - Alonso Church, You and Haskell <br>\nCurry Would be Proud - Donald Knuth, One Word, LaTeX - Mike Gordon, You <br>\nAre Absent from This Mailing List, Three Letters, HOL - Robin Milner, <br>\nIt's Enough to Say Your Name.\"</p>\n<p>Regards,<br>\nGB</p>\n<p>[1] Logic for Computer Science, <a href=\"http://www.cs.waikato.ac.nz/~stever/LCS.html\">http://www.cs.waikato.ac.nz/~stever/LCS.html</a><br>\n[2] First-order logic, <br>\n<a href=\"http://www.amazon.com/First-Order-Logic-Dover-Books-Mathematics/dp/0486683702\">http://www.amazon.com/First-Order-Logic-Dover-Books-Mathematics/dp/0486683702</a></p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\ntheory i140309aa__semantab<br>\nimports Complex_Main (<em>\"../../iHelp/i\"</em>) (*\"../../IsaN/work/IsaN\" *)<br>\nbegin</p>\n<p>(*( \\&lt;turnstile&gt; ): Turnstile to shorten the notation for <br>\nmeta-implication.*)<br>\nno_notation ==&gt; (infixr \"\\&lt;turnstile&gt;\" 4)<br>\nabbreviation mimp_turn :: \"prop \\&lt;Rightarrow&gt; prop \\&lt;Rightarrow&gt; prop\" where<br>\n   \"mimp_turn P Q == (PROP P \\&lt;Longrightarrow&gt; PROP Q)\"<br>\n   notation mimp_turn (infixr \"\\&lt;turnstile&gt;\" 4)</p>\n<p>(*( \\&lt;cedilla&gt; ): Cedilla, to act as a comma, for formulas such as <br>\nP\\&lt;cedilla&gt; Q \\&lt;turnstile&gt; R.*)<br>\nnotation (input) ==&gt; (infixr \"\\&lt;cedilla&gt;\" 4)</p>\n<p>(*( \\&lt;bottom&gt; ): False, to shorten the notation. The output is bold for <br>\nvisibility.*)<br>\nnotation (input) False (\"\\&lt;bottom&gt;\")<br>\nnotation (output) False (\"\\&lt;^bold&gt;\\&lt;bottom&gt;\")</p>\n<p>(<em>( \\&lt;cdot&gt;~\\&lt;cdot&gt; ): notP, PROP not.</em>)<br>\nabbreviation notP :: \"prop \\&lt;Rightarrow&gt; prop\" where<br>\n   \"notP P == (PROP P \\&lt;Longrightarrow&gt; False)\"<br>\n   notation notP (\"\\&lt;cdot&gt;~\\&lt;cdot&gt;'(_')\") (* \\&lt;cdot&gt;~\\&lt;cdot&gt; *)</p>\n<p>(*( \\&lt;or&gt;\\&lt;^sub&gt;p ): orP, PROP disjunction.*)<br>\n(<em>PROP or: orP</em>)<br>\nabbreviation orP :: \"prop \\&lt;Rightarrow&gt; prop \\&lt;Rightarrow&gt; prop\" where<br>\n   \"orP P Q == ((PROP P \\&lt;Longrightarrow&gt; False) \\&lt;Longrightarrow&gt; PROP Q)\"<br>\nnotation<br>\n   orP (infixr \"(\\&lt;or&gt;\\&lt;^sub&gt;p)\" 4)</p>\n<p>(*( \\&lt;and&gt;\\&lt;^sub&gt;p ): andP, PROP conjunction.*)<br>\nabbreviation andP :: \"prop \\&lt;Rightarrow&gt; prop \\&lt;Rightarrow&gt; prop\" where<br>\n   \"andP P Q == ((PROP P \\&lt;Longrightarrow&gt; PROP Q \\&lt;Longrightarrow&gt; <br>\nFalse) \\&lt;Longrightarrow&gt; False)\"<br>\nnotation<br>\n   andP (infixr \"(\\&lt;and&gt;\\&lt;^sub&gt;p)\" 4)</p>\n<p>(*( \\&lt;and&gt;\\&lt;^sub&gt;4 ): and4, bool conjunction with the same priority as <br>\nandP. For conversions<br>\n   from bool to PROP, to ensure that the same parenthesizing applies.*)<br>\nabbreviation (input) and4 :: \"bool \\&lt;Rightarrow&gt; bool \\&lt;Rightarrow&gt; <br>\nbool\" where<br>\n   \"and4 P Q == (P \\&lt;and&gt; Q)\"<br>\nnotation<br>\n   and4 (infixr \"(\\&lt;and&gt;\\&lt;^sub&gt;4)\" 4)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>*)<br>\n(* LOGIC RULES <strong>*</strong><strong>*</strong><strong>*</strong>**)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>*)</p>\n<p>lemma mimp2in_to_3and_mimps_False:<br>\n   \"P\\&lt;cedilla&gt; Q \\&lt;turnstile&gt; R == P \\&lt;and&gt;\\&lt;^sub&gt;4 Q \\&lt;and&gt;\\&lt;^sub&gt;4 <br>\n\\&lt;not&gt;R \\&lt;turnstile&gt; False\"<br>\nby(rule equal_intr_rule, auto)</p>\n<p>lemma or6_mimps_False_to_6andP_of_notPs:<br>\n   \"P\\&lt;^sub&gt;1 \\&lt;or&gt; P\\&lt;^sub&gt;2 \\&lt;or&gt; P\\&lt;^sub&gt;3 \\&lt;or&gt; P\\&lt;^sub&gt;4 \\&lt;or&gt; <br>\nP\\&lt;^sub&gt;5 \\&lt;or&gt; P\\&lt;^sub&gt;6 \\&lt;turnstile&gt; False<br>\n     == \\&lt;cdot&gt;~\\&lt;cdot&gt;(P\\&lt;^sub&gt;1) \\&lt;and&gt;\\&lt;^sub&gt;p <br>\n\\&lt;cdot&gt;~\\&lt;cdot&gt;(P\\&lt;^sub&gt;2) \\&lt;and&gt;\\&lt;^sub&gt;p \\&lt;cdot&gt;~\\&lt;cdot&gt;(P\\&lt;^sub&gt;3) <br>\n\\&lt;and&gt;\\&lt;^sub&gt;p \\&lt;cdot&gt;~\\&lt;cdot&gt;(P\\&lt;^sub&gt;4) \\&lt;and&gt;\\&lt;^sub&gt;p <br>\n\\&lt;cdot&gt;~\\&lt;cdot&gt;(P\\&lt;^sub&gt;5) \\&lt;and&gt;\\&lt;^sub&gt;p \\&lt;cdot&gt;~\\&lt;cdot&gt;(P\\&lt;^sub&gt;6)\"<br>\nby(rule equal_intr_rule, auto)</p>\n<p>lemma and_eq_andP:<br>\n   \"Trueprop(P \\&lt;and&gt; Q) == P \\&lt;and&gt;\\&lt;^sub&gt;p Q\"<br>\nby(rule equal_intr_rule, auto)</p>\n<p>lemma not_eq_notP:<br>\n   \"Trueprop(\\&lt;not&gt;P) == \\&lt;cdot&gt;~\\&lt;cdot&gt;(P)\"<br>\nby(rule equal_intr_rule, auto)</p>\n<p>lemmas semantab_bool_expansion =<br>\n   simp_thms(1)<br>\n   imp_conv_disj<br>\n   de_Morgan_conj<br>\n   de_Morgan_disj<br>\n   conj_comms<br>\n   conj_disj_distribL<br>\n   disj_assoc</p>\n<p>lemmas semantab_bool_to_prop =<br>\n   and_eq_andP<br>\n   not_eq_notP</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>*)<br>\n(* THEOREM <strong>*</strong><strong>*</strong><strong>*</strong>*)<br>\n(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>*)</p>\n<p>notation Trueprop (\"_\\&lt;Colon&gt;\\&lt;^sub&gt;T\" [1000] 1000)<br>\ndeclare[[show_sorts=false, show_types=false, show_brackets=true]]</p>\n<p>lemma<br>\n   \"(A \\&lt;and&gt; B) \\&lt;longrightarrow&gt; C\\&lt;cedilla&gt; \\&lt;not&gt;A \\&lt;longrightarrow&gt; <br>\nD \\&lt;turnstile&gt; B \\&lt;longrightarrow&gt; (C \\&lt;or&gt; D)\"<br>\n   unfolding mimp2in_to_3and_mimps_False<br>\n   unfolding semantab_bool_expansion<br>\n   unfolding or6_mimps_False_to_6andP_of_notPs<br>\n   unfolding semantab_bool_to_prop<br>\nby(auto)</p>\n<p>lemma<br>\n   \"(A \\&lt;and&gt; B) \\&lt;longrightarrow&gt; C\\&lt;cedilla&gt; \\&lt;not&gt;A \\&lt;longrightarrow&gt; <br>\nD \\&lt;turnstile&gt; B \\&lt;longrightarrow&gt; (C \\&lt;or&gt; D)\"<br>\n(*|Negate the conclusion and convert it to a 3-bool-and that mimps False.<br>\n   The notation for (P \\&lt;turnstile&gt; False) is \\&lt;cdot&gt;~\\&lt;cdot&gt;(P). <br>\nBecause of requirements due to Trueprop<br>\n   and other low priorities, notP needs to be in parentheses.|*)<br>\n   unfolding mimp2in_to_3and_mimps_False</p>\n<p>(*|Expand the bool formulas. The result will be a 6-bool-or that is <br>\nnested to<br>\n   the left, and that mimps False.|*)<br>\n   unfolding<br>\n     simp_thms(1)<br>\n     imp_conv_disj<br>\n     de_Morgan_conj<br>\n     de_Morgan_disj<br>\n     conj_comms<br>\n     conj_disj_distribL</p>\n<p>(<em>|Nest the 6-bool-or to the right.|</em>)<br>\n   unfolding disj_assoc</p>\n<p>(<em>|Convert the 6-bool-or to 6 chains of andP-ands that each mimp False.|</em>)<br>\n   unfolding or6_mimps_False_to_6andP_of_notPs</p>\n<p>(<em>|Convert the bool-nots and bool-ands to notP-nots and andP-ands.|</em>)<br>\n   unfolding and_eq_andP<br>\n   unfolding not_eq_notP</p>\n<p>(*Now, there is no use of HOL in the formula except for the use of Trueprop<br>\n   and False. This can be seen by the fact that all of A, B, C, and D <br>\nare being<br>\n   coerced by Trueprop. To turn the Trueprop printing off, change <br>\nnotation above<br>\n   to no_notation.*)<br>\n   using[[show_sorts=false, show_types=false, show_brackets=false]]</p>\n<p>(*The definition is shown as follows, from HOL.thy:</p>\n<p>defs<br>\n     True_def:     \"True      == ((%x::bool. x) = (%x. x))\"<br>\n     All_def:      \"All(P)    == (P = (%x. True))\"<br>\n     Ex_def:       \"Ex(P)     == !Q. (!x. P x --&gt; Q) --&gt; Q\"<br>\n     False_def:    \"False     == (!P. P)\"</p>\n<p>It's defined using only All and True, however, obviously, it's <br>\ntotally tied<br>\n   into the logic of HOL. But then, that's what makes auto work by magic <br>\nwhen<br>\n   used above, and below.</p>\n<p>Of course, auto doesn't need any of this to be done for this theorem, <br>\nbut<br>\n   it could be that auto will be grateful someday. On the other hand, <br>\nit's more<br>\n   likely that auto is an emotionless automaton, who doesn't care <br>\nwhether I live<br>\n   or die. In that case, it will be me who is grateful someday.*)<br>\nby(auto)</p>\n<p>(<strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong><strong>*</strong>***)<br>\nend<br>\n<a href=\"/user_uploads/14278/LX0TGiT80sMyhHNHJ8fsO1Ft/i140309aa__semantab.thy\">i140309aa__semantab.thy</a></p>",
        "id": 294272296,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660917600
    }
]