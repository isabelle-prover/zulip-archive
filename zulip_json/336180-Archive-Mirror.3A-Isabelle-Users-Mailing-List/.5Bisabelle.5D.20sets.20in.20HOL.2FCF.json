[
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Thu, Sep 2, 2010 at 2:49 AM, Joachim Breitner<br>\n&lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt; wrote:</p>\n<blockquote>\n<p>Dear Isabelle community,</p>\n<p>I am exploring HOLCF at the moment. As a starting point, I tried to<br>\ndefine this function with fixrec:<br>\n       f :: nat → nat set<br>\n       f b = {b} ∪ f b<br>\nI’d expect to find that \"f b = {b}\".<br>\n[...]<br>\nBut I’m wondering: Why can I not write:</p>\n<hr>\n<p>fixrec f :: \"int lift → int set\" where<br>\n \"f⋅b = (case b of ⊥ ⇒ ⊥ | Def a ⇒ {a} ∪ (f⋅b)\"<br>\ndeclare f.simps[simp del]</p>\n<hr>\n<p>The error message<br>\n*** Type unification failed: No type arity bool :: cpo<br>\nseems to indicate that fixrec has a problem with me using \"int set\" as a<br>\npcpo. I assume the reason is that \"int set\" is just an abbreviation for<br>\n\"int ⇒ bool\", therefore my above work-around. But I’m missing the<br>\nconvenient syntax of sets in Isabelle.</p>\n<p>Is this really the correct way to work with sets in HOL/CF or am I just<br>\noverlooking something?</p>\n<p>Thank you,<br>\nJoachim</p>\n</blockquote>\n<p>Hi Joachim,</p>\n<p>If you want to be able to define a function of type \"nat -&gt; nat set\"<br>\nwith fixrec, it turns out that fixrec can do it, but it requires you<br>\nto do some work to set things up first.</p>\n<p>The first requirement is that the return type \"nat set\" needs to be in<br>\nthe pcpo class. As you pointed out, \"nat set\" is an abbreviation<br>\nfor \"nat =&gt; bool\", so this means you will need an instance bool ::<br>\npcpo. For \\sqsubseteq to coincide with the subset relation on sets,<br>\nyou will need to define \\sqsubseteq as implication on booleans. (I've<br>\npasted a copy of the necessary proof scripts at the end of this<br>\nemail.)</p>\n<p>The standard HOLCF library doesn't define this pcpo instance for type<br>\nbool, because in many cases HOL types make more sense with a discrete<br>\nordering, and I didn't want to prevent users from defining bool as a<br>\ndiscrete cpo. The bool :: pcpo instance might be a good thing to put<br>\nin HOLCF/Library though, so users can import it if they want to.</p>\n<p>To write a continuous function type like \"nat -&gt; nat set\", the<br>\nargument type \"nat\" also needs to be in class cpo. The easiest way to<br>\ndo this is to define a discrete ordering on type nat, and prove an<br>\ninstance of the \"discrete_cpo\" class. It might be useful to put this<br>\ndefinition in another theory in HOLCF/Library.</p>\n<p>The next requirement for fixrec is that it needs to be able to prove<br>\ncontinuity. In this case the body of your function uses \"union\" and<br>\n\"insert\", so you will need to prove continuity for those, at least.<br>\n(Proofs below)</p>\n<p>If you'd like to see a theory in HOLCF/Library that configures HOLCF<br>\nto work better with set types, I would welcome any suggestions that<br>\nyou may have.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>\n<hr>\n<p>instantiation bool :: finite_po<br>\nbegin</p>\n<p>definition<br>\n  \"x \\&lt;sqsubseteq&gt; y \\&lt;longleftrightarrow&gt; (x \\&lt;longrightarrow&gt; y)\"</p>\n<p>instance<br>\nby (default, unfold below_bool_def, fast+)</p>\n<p>end</p>\n<p>instance bool :: pcpo<br>\nproof<br>\n  have \"\\&lt;forall&gt;y. False \\&lt;sqsubseteq&gt; y\" by (simp add: below_bool_def)<br>\n  thus \"\\&lt;exists&gt;x::bool. \\&lt;forall&gt;y. x \\&lt;sqsubseteq&gt; y\" ..<br>\nqed</p>\n<p>lemma bottom_eq_False: \"\\&lt;bottom&gt; = False\"<br>\napply (rule below_antisym [OF minimal])<br>\napply (simp add: below_bool_def)<br>\ndone</p>\n<p>lemma cont2cont_disj [simp, cont2cont]:<br>\n  assumes f: \"cont (\\&lt;lambda&gt;x. f x)\" and g: \"cont (\\&lt;lambda&gt;x. g x)\"<br>\n  shows \"cont (\\&lt;lambda&gt;x. f x \\&lt;or&gt; g x)\"<br>\napply (rule cont_apply [OF f])<br>\napply (rule chfindom_monofun2cont)<br>\napply (rule monofunI, simp add: below_bool_def)<br>\napply (rule cont_compose [OF _ g])<br>\napply (rule chfindom_monofun2cont)<br>\napply (rule monofunI, simp add: below_bool_def)<br>\ndone</p>\n<p>lemma cont2cont_Collect [simp, cont2cont]:<br>\n  assumes \"\\&lt;And&gt;y. cont (\\&lt;lambda&gt;x. f x y)\"<br>\n  shows \"cont (\\&lt;lambda&gt;x. {y. f x y})\"<br>\nunfolding Collect_def using assms<br>\nby (rule cont2cont_lambda)</p>\n<p>lemma cont2cont_mem [simp, cont2cont]:<br>\n  assumes \"cont (\\&lt;lambda&gt;x. f x)\"<br>\n  shows \"cont (\\&lt;lambda&gt;x. y \\&lt;in&gt; f x)\"<br>\nunfolding mem_def using assms<br>\nby (rule cont2cont_fun)</p>\n<p>lemma cont2cont_union [simp, cont2cont]:<br>\n  \"cont (\\&lt;lambda&gt;x. f x) \\&lt;Longrightarrow&gt; cont (\\&lt;lambda&gt;x. g x)<br>\n\\&lt;Longrightarrow&gt; cont (\\&lt;lambda&gt;x. f x \\&lt;union&gt; g x)\"<br>\nunfolding Un_def by simp</p>\n<p>lemma cont2cont_insert [simp, cont2cont]:<br>\n  assumes \"cont (\\&lt;lambda&gt;x. f x)\"<br>\n  shows \"cont (\\&lt;lambda&gt;x. insert y (f x))\"<br>\nunfolding insert_def using assms<br>\nby (intro cont2cont)</p>\n<p>instantiation nat :: discrete_cpo<br>\nbegin</p>\n<p>definition<br>\n  [simp]: \"(x::nat) \\&lt;sqsubseteq&gt; y \\&lt;longleftrightarrow&gt; x = y\"</p>\n<p>instance<br>\nby default simp</p>\n<p>end</p>\n<p>fixrec<br>\n  f :: \"nat \\&lt;rightarrow&gt; nat set\"<br>\nwhere<br>\n  [simp del]: \"f\\&lt;cdot&gt;b = {b} \\&lt;union&gt; f\\&lt;cdot&gt;b\"</p>\n<p>lemma \"f\\&lt;cdot&gt;b = {b}\"<br>\napply (subst f.simps)<br>\napply (rule f.induct)<br>\napply (rule adm_eq, simp, simp)<br>\napply (simp add: subset_eq Ball_def mem_def bottom_eq_False)<br>\napply simp<br>\ndone</p>",
        "id": 294115584,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838190
    },
    {
        "content": "<p>From: Alexander Krauss &lt;<a href=\"mailto:krauss@in.tum.de\">krauss@in.tum.de</a>&gt;<br>\nBrian Huffman wrote:<br>\nA related remark: A recursive function that returns a set can also be <br>\ndefined using the inductive(_set) package. You have to rephrase the <br>\ndefinition using introduction rules, and manually derive the recursive <br>\nequations afterwards, but that is usually straightforward.</p>\n<p>Alex</p>",
        "id": 294116401,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838441
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nActually, Lukas's newly introduced \"inductive_simps\" command makes it easier than ever to derive recursive equations from inductive definitions. I think it's in Isabelle2009-2. I'm not aware of any documentation (beyond a few uses in Isabelle theories, which you can grep for) but it works pretty much like \"inductive_cases\".</p>\n<p>Jasmin</p>",
        "id": 294116498,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838468
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:mail@joachim-breitner.de\">mail@joachim-breitner.de</a>&gt;<br>\nDear Isabelle community,</p>\n<p>I am exploring HOLCF at the moment. As a starting point, I tried to<br>\ndefine this function with fixrec:<br>\n    f :: nat → nat set<br>\n        f b = {b} ∪ f b<br>\nI’d expect to find that \"f b = {b}\".</p>\n<p>This approach worked:</p>\n<hr>\n<p>fixrec f :: \"int lift → (int ⇒ one)\" where<br>\n  \"f⋅b = (case b of ⊥ ⇒ ⊥ | Def a ⇒ (f⋅b) (a := ONE))\"<br>\ndeclare f.simps[simp del]</p>\n<p>lemma \"f⋅(Def b) = (λ c. if b = c then ONE else ⊥)\"<br>\napply (rule ext)<br>\napply auto<br>\napply (subst f.unfold)<br>\napply simp<br>\napply(induct rule:f.induct)<br>\napply auto<br>\ndone</p>\n<hr>\n<p>But I’m wondering: Why can I not write:</p>\n<hr>\n<p>fixrec f :: \"int lift → int set\" where<br>\n  \"f⋅b = (case b of ⊥ ⇒ ⊥ | Def a ⇒ {a} ∪ (f⋅b)\"<br>\ndeclare f.simps[simp del]</p>\n<hr>\n<p>The error message<br>\n*** Type unification failed: No type arity bool :: cpo<br>\nseems to indicate that fixrec has a problem with me using \"int set\" as a<br>\npcpo. I assume the reason is that \"int set\" is just an abbreviation for<br>\n\"int ⇒ bool\", therefore my above work-around. But I’m missing the<br>\nconvenient syntax of sets in Isabelle.</p>\n<p>Is this really the correct way to work with sets in HOL/CF or am I just<br>\noverlooking something?</p>\n<p>Thank you,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/5BGJIQTdZAN-WhGslo4TjpzN/signature.asc\">signature.asc</a></p>",
        "id": 294116973,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838596
    }
]