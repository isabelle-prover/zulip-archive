[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@gmail.com\">viorel.preoteasa@gmail.com</a>&gt;<br>\nHello,</p>\n<p>I need new types of signed and unsigned words with operations (+, -, ...) identical with the operations on words, but with a new operation:</p>\n<p>overflow_add a b which is defined differently for signed and unsigned words.</p>\n<p>Basically I need the two types to be instantiations of the following class:</p>\n<p>class overflow = plus + <br>\n  fixes overflow_add::  \"'a ⇒ 'a ⇒ bool\"</p>\n<p>I tried something inspired from the AFP entry \"Finite Machine Word Library\":</p>\n<p>type_synonym 'a sword = \"'a signed word\"<br>\ntype_synonym 'a uword = \"'a usigned word\"</p>\n<p>consts to_int :: \"'a word ⇒ int\"</p>\n<p>overloading  <br>\n  to_int_sword ≡ \"to_int:: 'a sword ⇒ int\" <br>\n  to_int_uword ≡ \"to_int::'a uword ⇒ int\"<br>\nbegin  <br>\n  definition \"to_int_sword (a:: 'a::len sword) = sint a\"<br>\n  definition \"to_int_uword (a:: 'a::len uword) = uint a\"<br>\nend</p>\n<p>instantiation  word :: (len0)  overflow<br>\nbegin<br>\n  definition \"overflow_add a b = (to_int (a::'a word) + to_int b = to_int (a + b))\"<br>\ninstance ..<br>\nend</p>\n<p>this seems to work, but I don't know how to get code generation for overflow_add:</p>\n<p>value \"overflow_add (-2::4 sword) (-3)\"</p>\n<p>gives the error:</p>\n<p>No code equations for to_int</p>\n<p>Any help would be appreciated.</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294750771,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195365
    },
    {
        "content": "<p>From: \"Thiemann, René\" &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nDear Viorel,</p>\n<p>it is difficult to test your problem, since the “signed” and “usigned” types are something that I do neither find in the distribution nor in the AFP.</p>\n<p>Hence, I can only blindly guess:</p>\n<p>There might be a problem in your definition of “overflow_add” which uses the generic “to_int”, not a specific implementation.<br>\nThis will work if “to_int” is defined as a class-constant (class some_name = fixes to_int :: …), but I’m not sure whether your approach via “consts to_int” is supported with code-generation.</p>\n<p>So, you might try to reformulate the definition of to_int via class and instantiation.</p>\n<p>Best regards,<br>\nRené<br>\n<a href=\"/user_uploads/14278/ZPRPWeNiMFUvPGUeW4ISAd9M/signature.asc\">signature.asc</a></p>",
        "id": 294751107,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195496
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@gmail.com\">viorel.preoteasa@gmail.com</a>&gt;<br>\nDear René,</p>\n<p>Thank you for your message.</p>\n<p>On 18/02/2019 15.18, Thiemann, René wrote:</p>\n<blockquote>\n<p>Dear Viorel,</p>\n<p>it is difficult to test your problem, since the “signed” and “usigned” types are something that I do neither find in the distribution nor in the AFP.</p>\n</blockquote>\n<p>The definition of the signed type is here:</p>\n<p><a href=\"https://www.isa-afp.org/browser_info/current/AFP/Word_Lib/Signed_Words.html\">https://www.isa-afp.org/browser_info/current/AFP/Word_Lib/Signed_Words.html</a></p>\n<p>and the definition of unsigned is identical.</p>\n<blockquote>\n<p>Hence, I can only blindly guess:</p>\n<p>There might be a problem in your definition of “overflow_add” which uses the generic “to_int”, not a specific implementation.<br>\nThis will work if “to_int” is defined as a class-constant (class some_name = fixes to_int :: …), but I’m not sure whether your approach via “consts to_int” is supported with code-generation.</p>\n<p>So, you might try to reformulate the definition of to_int via class and instantiation.</p>\n</blockquote>\n<p>This was my first attempt, but I did not manage the instantiation  of <br>\nclass overflow as 'a signed word .</p>\n<p>Now I have implemented a different solution. I created a new copy of the <br>\ntype 'a word:</p>\n<p>typedef (overloaded) 'a::len sword = \"UNIV::'a word set\"<br>\n   morphisms sword_to_word word_to_sword by auto</p>\n<p>and I lifted all operations from word to sword. This seems to work, but <br>\nI am interested to find the best possible solution.</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<blockquote>\n<p>Best regards,<br>\nRené</p>\n<blockquote>\n<p>I need new types of signed and unsigned words with operations (+, -, ...) identical with the operations on words, but with a new operation:</p>\n<p>overflow_add a b which is defined differently for signed and unsigned words.</p>\n<p>Basically I need the two types to be instantiations of the following class:</p>\n<p>class overflow = plus +<br>\n  fixes overflow_add::  \"'a ⇒ 'a ⇒ bool\"</p>\n<p>I tried something inspired from the AFP entry \"Finite Machine Word Library\":</p>\n<p>type_synonym 'a sword = \"'a signed word\"<br>\ntype_synonym 'a uword = \"'a usigned word\"</p>\n<p>consts to_int :: \"'a word ⇒ int\"</p>\n<p>overloading<br>\n  to_int_sword ≡ \"to_int:: 'a sword ⇒ int\"<br>\n  to_int_uword ≡ \"to_int::'a uword ⇒ int\"<br>\nbegin<br>\n  definition \"to_int_sword (a:: 'a::len sword) = sint a\"<br>\n  definition \"to_int_uword (a:: 'a::len uword) = uint a\"<br>\nend</p>\n<p>instantiation  word :: (len0)  overflow<br>\nbegin<br>\n  definition \"overflow_add a b = (to_int (a::'a word) + to_int b = to_int (a + b))\"<br>\ninstance ..<br>\nend</p>\n<p>this seems to work, but I don't know how to get code generation for overflow_add:</p>\n<p>value \"overflow_add (-2::4 sword) (-3)\"</p>\n<p>gives the error:</p>\n<p>No code equations for to_int</p>\n</blockquote>\n</blockquote>",
        "id": 294751160,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195520
    },
    {
        "content": "<p>From: Thomas Sewell &lt;<a href=\"mailto:sewell@chalmers.se\">sewell@chalmers.se</a>&gt;<br>\nI recall the addition of the signed words, and maybe I can add some information.</p>\n<p>I think that \"'a signed word\" and \"'a word\" are equivalent for all key operations. The signed variant was added as part of an adjustment of the C-to-Isabelle parser, so that in the resulting code it was possible to tell whether the variables were designated signed or unsigned in C. Note that most arithmetic is exactly the same.</p>\n<p>Also note that the outer type constructor is word, that is, \"32 signed word\" is an instance of \"'a word\" where the length parameter is \"32 signed\". To make use of this, I think you want to define some kind of is_signed class with a class constant of type bool, and ensure that \"32 signed\" is signed, and that each numeral type counts as unsigned. Finally, you can lift that to a query on the outer word type.</p>\n<p>I think that all might work, but I haven't tried any of it.</p>\n<p>Cheers,</p>\n<p>Thomas.</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> &lt;<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; on behalf of Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@gmail.com\">viorel.preoteasa@gmail.com</a>&gt;<br>\nSent: Tuesday, February 19, 2019 10:40:26 AM<br>\nTo: Thiemann, René<br>\nCc: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nSubject: Re: [isabelle] signed and unsigned words</p>\n<p>Dear René,</p>\n<p>Thank you for your message.</p>\n<p>On 18/02/2019 15.18, Thiemann, René wrote:</p>\n<blockquote>\n<p>Dear Viorel,</p>\n<p>it is difficult to test your problem, since the “signed” and “usigned” types are something that I do neither find in the distribution nor in the AFP.</p>\n</blockquote>\n<p>The definition of the signed type is here:</p>\n<p><a href=\"https://www.isa-afp.org/browser_info/current/AFP/Word_Lib/Signed_Words.html\">https://www.isa-afp.org/browser_info/current/AFP/Word_Lib/Signed_Words.html</a></p>\n<p>and the definition of unsigned is identical.</p>\n<blockquote>\n<p>Hence, I can only blindly guess:</p>\n<p>There might be a problem in your definition of “overflow_add” which uses the generic “to_int”, not a specific implementation.<br>\nThis will work if “to_int” is defined as a class-constant (class some_name = fixes to_int :: …), but I’m not sure whether your approach via “consts to_int” is supported with code-generation.</p>\n<p>So, you might try to reformulate the definition of to_int via class and instantiation.</p>\n</blockquote>\n<p>This was my first attempt, but I did not manage the instantiation  of<br>\nclass overflow as 'a signed word .</p>\n<p>Now I have implemented a different solution. I created a new copy of the<br>\ntype 'a word:</p>\n<p>typedef (overloaded) 'a::len sword = \"UNIV::'a word set\"<br>\n   morphisms sword_to_word word_to_sword by auto</p>\n<p>and I lifted all operations from word to sword. This seems to work, but<br>\nI am interested to find the best possible solution.</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<blockquote>\n<p>Best regards,<br>\nRené</p>\n<blockquote>\n<p>I need new types of signed and unsigned words with operations (+, -, ...) identical with the operations on words, but with a new operation:</p>\n<p>overflow_add a b which is defined differently for signed and unsigned words.</p>\n<p>Basically I need the two types to be instantiations of the following class:</p>\n<p>class overflow = plus +<br>\n  fixes overflow_add::  \"'a ⇒ 'a ⇒ bool\"</p>\n<p>I tried something inspired from the AFP entry \"Finite Machine Word Library\":</p>\n<p>type_synonym 'a sword = \"'a signed word\"<br>\ntype_synonym 'a uword = \"'a usigned word\"</p>\n<p>consts to_int :: \"'a word ⇒ int\"</p>\n<p>overloading<br>\n  to_int_sword ≡ \"to_int:: 'a sword ⇒ int\"<br>\n  to_int_uword ≡ \"to_int::'a uword ⇒ int\"<br>\nbegin<br>\n  definition \"to_int_sword (a:: 'a::len sword) = sint a\"<br>\n  definition \"to_int_uword (a:: 'a::len uword) = uint a\"<br>\nend</p>\n<p>instantiation  word :: (len0)  overflow<br>\nbegin<br>\n  definition \"overflow_add a b = (to_int (a::'a word) + to_int b = to_int (a + b))\"<br>\ninstance ..<br>\nend</p>\n<p>this seems to work, but I don't know how to get code generation for overflow_add:</p>\n<p>value \"overflow_add (-2::4 sword) (-3)\"</p>\n<p>gives the error:</p>\n<p>No code equations for to_int</p>\n</blockquote>\n</blockquote>",
        "id": 294751226,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195535
    },
    {
        "content": "<p>From: <a href=\"mailto:viorel.preoteasa@gmail.com\">viorel.preoteasa@gmail.com</a><br>\nHi Thomas,</p>\n<p>Than you for your message. I know that most operations are the same, </p>\n<p>but the overflow conditions are different. I need the signed and unsigned words </p>\n<p>to be different (data)types such that I can instantiate differently a class overflow. </p>\n<p>In the end I created a new copy of ‘a word as I mentioned in my previous message with lifting of definitions. </p>\n<p>This gives me exactly what I need, but I don’t know if it adds overhead, especially when reasoning with the elements of the new type.</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<p>From: Thomas Sewell &lt;<a href=\"mailto:sewell@chalmers.se\">sewell@chalmers.se</a>&gt; <br>\nSent: Tuesday, February 19, 2019 3:15 PM<br>\nTo: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@gmail.com\">viorel.preoteasa@gmail.com</a>&gt;; Thiemann, René &lt;<a href=\"mailto:Rene.Thiemann@uibk.ac.at\">Rene.Thiemann@uibk.ac.at</a>&gt;<br>\nCc: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a><br>\nSubject: Re: [isabelle] signed and unsigned words</p>\n<p>I recall the addition of the signed words, and maybe I can add some information.</p>\n<p>I think that \"'a signed word\" and \"'a word\" are equivalent for all key operations. The signed variant was added as part of an adjustment of the C-to-Isabelle parser, so that in the resulting code it was possible to tell whether the variables were designated signed or unsigned in C. Note that most arithmetic is exactly the same.</p>\n<p>Also note that the outer type constructor is word, that is, \"32 signed word\" is an instance of \"'a word\" where the length parameter is \"32 signed\". To make use of this, I think you want to define some kind of is_signed class with a class constant of type bool, and ensure that \"32 signed\" is signed, and that each numeral type counts as unsigned. Finally, you can lift that to a query on the outer word type.</p>\n<p>I think that all might work, but I haven't tried any of it.</p>\n<p>Cheers,</p>\n<p>Thomas.</p>\n<hr>\n<p>From: <a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> &lt;mailto:<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt;  &lt;<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a> &lt;mailto:<a href=\"mailto:cl-isabelle-users-bounces@lists.cam.ac.uk\">cl-isabelle-users-bounces@lists.cam.ac.uk</a>&gt; &gt; on behalf of Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@gmail.com\">viorel.preoteasa@gmail.com</a> &lt;mailto:<a href=\"mailto:viorel.preoteasa@gmail.com\">viorel.preoteasa@gmail.com</a>&gt; &gt;<br>\nSent: Tuesday, February 19, 2019 10:40:26 AM<br>\nTo: Thiemann, René<br>\nCc: <a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a> &lt;mailto:<a href=\"mailto:cl-isabelle-users@lists.cam.ac.uk\">cl-isabelle-users@lists.cam.ac.uk</a>&gt; <br>\nSubject: Re: [isabelle] signed and unsigned words </p>\n<p>Dear René,</p>\n<p>Thank you for your message.</p>\n<p>On 18/02/2019 15.18, Thiemann, René wrote:</p>\n<blockquote>\n<p>Dear Viorel,</p>\n<p>it is difficult to test your problem, since the “signed” and “usigned” types are something that I do neither find in the distribution nor in the AFP.</p>\n</blockquote>\n<p>The definition of the signed type is here:</p>\n<p><a href=\"https://www.isa-afp.org/browser_info/current/AFP/Word_Lib/Signed_Words.html\">https://www.isa-afp.org/browser_info/current/AFP/Word_Lib/Signed_Words.html</a></p>\n<p>and the definition of unsigned is identical.</p>\n<blockquote>\n<p>Hence, I can only blindly guess:</p>\n<p>There might be a problem in your definition of “overflow_add” which uses the generic “to_int”, not a specific implementation.<br>\nThis will work if “to_int” is defined as a class-constant (class some_name = fixes to_int :: …), but I’m not sure whether your approach via “consts to_int” is supported with code-generation.</p>\n<p>So, you might try to reformulate the definition of to_int via class and instantiation.</p>\n</blockquote>\n<p>This was my first attempt, but I did not manage the instantiation  of <br>\nclass overflow as 'a signed word .</p>\n<p>Now I have implemented a different solution. I created a new copy of the <br>\ntype 'a word:</p>\n<p>typedef (overloaded) 'a::len sword = \"UNIV::'a word set\"<br>\n   morphisms sword_to_word word_to_sword by auto</p>\n<p>and I lifted all operations from word to sword. This seems to work, but <br>\nI am interested to find the best possible solution.</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<blockquote>\n<p>Best regards,<br>\nRené</p>\n<blockquote>\n<p>I need new types of signed and unsigned words with operations (+, -, ...) identical with the operations on words, but with a new operation:</p>\n<p>overflow_add a b which is defined differently for signed and unsigned words.</p>\n<p>Basically I need the two types to be instantiations of the following class:</p>\n<p>class overflow = plus +<br>\n  fixes overflow_add::  \"'a ⇒ 'a ⇒ bool\"</p>\n<p>I tried something inspired from the AFP entry \"Finite Machine Word Library\":</p>\n<p>type_synonym 'a sword = \"'a signed word\"<br>\ntype_synonym 'a uword = \"'a usigned word\"</p>\n<p>consts to_int :: \"'a word ⇒ int\"</p>\n<p>overloading<br>\n  to_int_sword ≡ \"to_int:: 'a sword ⇒ int\"<br>\n  to_int_uword ≡ \"to_int::'a uword ⇒ int\"<br>\nbegin<br>\n  definition \"to_int_sword (a:: 'a::len sword) = sint a\"<br>\n  definition \"to_int_uword (a:: 'a::len uword) = uint a\"<br>\nend</p>\n<p>instantiation  word :: (len0)  overflow<br>\nbegin<br>\n  definition \"overflow_add a b = (to_int (a::'a word) + to_int b = to_int (a + b))\"<br>\ninstance ..<br>\nend</p>\n<p>this seems to work, but I don't know how to get code generation for overflow_add:</p>\n<p>value \"overflow_add (-2::4 sword) (-3)\"</p>\n<p>gives the error:</p>\n<p>No code equations for to_int</p>\n</blockquote>\n</blockquote>",
        "id": 294751297,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195575
    }
]