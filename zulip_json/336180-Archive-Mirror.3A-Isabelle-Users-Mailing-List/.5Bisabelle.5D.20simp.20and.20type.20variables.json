[
    {
        "content": "<p>From: Elsa L Gunter &lt;<a href=\"mailto:egunter@cs.uiuc.edu\">egunter@cs.uiuc.edu</a>&gt;<br>\nDear Isabelle Users,<br>\n  Is there a way in Isabelle to specialize the type variables in a <br>\ntheorem to type expressions using the type variables of a goal context?  <br>\nAnd in particular, can this be combined with simp?  I have a frequently <br>\narising situation where I have a set of theorems of the form  \"e1('a) = <br>\ne2('a, 'b)\" and I wish to rewrite using these.   That is, I have <br>\nequations where there are more type variables on the right than on the <br>\nleft  (think \"True = \\&lt;all&gt; x. x = x\").  simp will not use the equations <br>\nas rewrites.  As a result I am forced to use fairly low level reasoning <br>\nwith ssubst (or at least I seem to be).  However, often times, I want to <br>\nuse a specialization of my equation to \"e1(('c,'d)tyc) = e2(('c,'d)tyc, <br>\n'c)\".  This equation would be accepted by simp.  But the only way I know <br>\nof creating this lemma is by using \"lemma\" and proving it separately.  <br>\nBut I have many different such specializations, each of which will like <br>\nbe used only once.  This seems to me to be just where you want to use <br>\n[of ... ] or the like to inline the specialization into an ongoing <br>\nproof.  Since I can see no way of doing so, I thought I should ask if I <br>\nam missing something.<br>\n---Elsa</p>",
        "id": 294056181,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821675
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nYou could try sledgehammer, which doesn't care about the orientation  <br>\nof equations. Of course, it doesn't simplify: you get either a full  <br>\nproof or nothing.<br>\nLarry</p>",
        "id": 294056208,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821684
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nQuoting Elsa L Gunter &lt;<a href=\"mailto:egunter@cs.uiuc.edu\">egunter@cs.uiuc.edu</a>&gt;:</p>\n<p>The \"of\" theorem attribute can only instantiate schematic term  <br>\nvariables. But the \"where\" attribute can be used to instantiate either  <br>\ntype variables or term variables. For example:</p>\n<p>lemma foo: \"True = (ALL x. x = x)\"<br>\nby simp</p>\n<p>If you type \"thm foo\" with the \"show types\" option enabled, you'll see  <br>\nthat there is a schematic type variable in this theorem:<br>\nTrue = (ALL x::?'a. x = x)</p>\n<p>Now, if you type \"thm foo [where 'a=nat]\" you will get the  <br>\ninstantiated version:<br>\nTrue = (ALL x::nat. x = x)</p>\n<p>You can also instantiate a schematic type variable with a specific  <br>\nfree type variable (which may be mentioned in your proof context). For  <br>\nexample, \"thm foo [where'a='b]\" gives \"True = (ALL x::'b. x = x)\"  <br>\n(notice that 'b is fixed, not a schematic variable, since it lacks a  <br>\nquestion mark)</p>\n<p>You should be able to use an instantiated version as a simp rule, as in:<br>\napply (simp only: foo [where 'a=nat])</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294056220,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821691
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIndeed, a relative of \"of\", \"where\", does the job: if your fact is <br>\ncalled th and the type variables are flexible (ie ?'a, not 'a), then <br>\njust write th[where 'b = \"...\"] to instantiate ?'b.</p>\n<p>Tobias</p>\n<p>Elsa L Gunter schrieb:</p>",
        "id": 294056232,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821699
    },
    {
        "content": "<p>From: Elsa L Gunter &lt;<a href=\"mailto:egunter@cs.uiuc.edu\">egunter@cs.uiuc.edu</a>&gt;<br>\nDear Brian and Tobias,<br>\n  Thank you for your very prompt reply.   Your suggestion of using where <br>\nwas a little surprising to me, since where is specifically not context <br>\nsensitive in the midst of goal proving, for (universally quantified) <br>\nterm variables.  (Also, I didn't see in the documentation that where <br>\ncould be used with type variables.)    I gather type variables (even <br>\nthose generated by unification) are treated as \"user supplied\" free <br>\nvariables and not universally quantified variables).  I know HOL does <br>\nnot have explicit type quantification, but I have thought of type <br>\nvariables (especially those generated from unification) as if they were <br>\nuniversally quantified at the top most level, which would indicate that <br>\nthey were out of scope for where.  Anyway, your reply has enlightened me <br>\nand saved my lots of grief.  Again I thank you both.<br>\n---Elsa</p>\n<p>Brian Huffman wrote:</p>",
        "id": 294056239,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660821703
    }
]