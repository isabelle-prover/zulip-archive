[
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nHi,</p>\n<p>I'm trying to add a simp rule, but it doesn't do any matching unless, <br>\nfor subsequent theorems, I name my variables in a certain, lexicographic <br>\norder.</p>\n<p>I set up the syntax and theorem as next shown, where I've converted <br>\n\\&lt;lbrace&gt; and \\&lt;rbrace&gt; to \"{\" and \"}\", except in the syntax command.</p>\n<p>syntax \"_paS\" :: \"sT =&gt; sT =&gt; sT\" (\"(\\&lt;lbrace&gt;(_,_)\\&lt;rbrace&gt;)\")<br>\n   translations<br>\n   \"\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;\" == \"CONST paS r s\"</p>\n<p>theorem lrbrace_notation [simp]:<br>\n   \"{{r,s},{p,p}} = {{p,p},{r,s}}\"<br>\n   sorry</p>\n<p>The simp rule works for the following:</p>\n<p>theorem \"{{f,d},{e,e}} = z\"<br>\n   apply simp<br>\n   --\"Output: {{e,e},{f,d}} = z\"<br>\n   oops</p>\n<p>However, if I replace \"f\" with anything lexicographically less than \"f\", <br>\nit doesn't match, and doesn't simplify the goal, such as for the following:</p>\n<p>theorem \"{{a,d},{e,e}} = z\"<br>\n   apply simp<br>\n   oops</p>\n<p>In the theory, I replace \"f\" with variables named from \"a\" to \"e\", and <br>\nit doesn't match, but when I get to \"f\", it matches.</p>\n<p>I attach theory, and I include it below.</p>\n<p>Thanks,<br>\nGB</p>\n<p>theory simp_pair_singleton_switch_alphabet_dependent</p>\n<p>imports Complex_Main<br>\nbegin<br>\ntypedecl sT<br>\nconsts paS :: \"sT =&gt; sT =&gt; sT\"</p>\n<p>syntax \"_paS\" :: \"sT =&gt; sT =&gt; sT\" (\"(\\&lt;lbrace&gt;(_,_)\\&lt;rbrace&gt;)\")<br>\n   translations<br>\n   \"\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;\" == \"CONST paS r s\"</p>\n<p>theorem lrbrace_notation [simp]:<br>\n   \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;,\\&lt;lbrace&gt;p,p\\&lt;rbrace&gt;\\&lt;rbrace&gt; = <br>\n\\&lt;lbrace&gt;\\&lt;lbrace&gt;p,p\\&lt;rbrace&gt;,\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;\\&lt;rbrace&gt;\"<br>\n   sorry</p>\n<p>theorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;f,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt; = z\"<br>\n   apply simp<br>\n   --\"Output: <br>\n\\&lt;lbrace&gt;\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;,\\&lt;lbrace&gt;f,d\\&lt;rbrace&gt;\\&lt;rbrace&gt; = z\"<br>\n   oops</p>\n<p>theorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;a,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt; = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;b,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt; = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;c,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt; = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;d,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt; = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;e,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt; = z\"<br>\n   apply simp<br>\n   oops</p>\n<p>theorem regular_braces [simp]:<br>\n   \"{{r,s},{p}} = {{p},{r,s}}\"<br>\n   sorry<br>\ntheorem \"{{a,d},{e,e}} = z\"<br>\n   apply simp<br>\n   --\"Output: {{e}, {a, d}} = z\"<br>\n   oops<br>\nend<br>\n<a href=\"/user_uploads/14278/uTG3kNK_zSbAjN_a_XmpVbaK/simp_pair_singleton_switch_alphabet_dependent.thy\">simp_pair_singleton_switch_alphabet_dependent.thy</a></p>",
        "id": 294233638,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903726
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nYes. You have discovered a feature called \"ordered rewriting\". It is described<br>\nin the Tutorial \"Isabelle/HOL - A Proof Assistant for Higher-Order Logic\" in<br>\n9.1.1 under Permutative Rewrite Rules.</p>\n<p>Regards<br>\nTobias</p>",
        "id": 294233654,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903740
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nOn 2/12/2013 1:26 PM, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>Yes. You have discovered a feature called \"ordered rewriting\". It is described<br>\nin the Tutorial \"Isabelle/HOL - A Proof Assistant for Higher-Order Logic\" in<br>\n9.1.1 under Permutative Rewrite Rules.</p>\n</blockquote>\n<p>Tobias,</p>\n<p>Thanks for the help. That opened up lots more possibilities that hadn't <br>\neven occurred to me, and that I was neglecting.</p>\n<p>I implemented about two forms each of the associativity and <br>\nleft-commutativity rules, like it said to do in the book, and then some <br>\nother rules. I wouldn't even have thought about the left-commutative rule.</p>\n<p>The rewriting seems to put priority on the associativity and <br>\ncommutativity rules; I put a rule before them that simplified things, <br>\nbut then it wasn't used for a simple test case, and the other rules <br>\nexpanded something I tried to eliminate.</p>\n<p>It all works out though, for now. I got finite sets with no repetitions <br>\nand equality in about 8 hours instead of two months or never. I thought <br>\nI would have to dig through Sets.thy to figure all that out.</p>\n<p>When I do a command \"apply simp\", is there a command to tell me what <br>\nrules it applied for that command? All I know about is \"print_simpset\". <br>\nA great debugger tool would be able to single step through the simp <br>\nrules for an \"apply simp\".</p>\n<p>I attach a screenshot at 22Kbytes of a big, gnarly, nested set equality <br>\nwith repetitions that's proved by simp.</p>\n<p>Thanks again,<br>\nGB</p>\n<blockquote>\n<p>Regards<br>\nTobias</p>\n<p>Am 12/02/2013 19:48, schrieb Gottfried Barrow:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I'm trying to add a simp rule, but it doesn't do any matching unless, for<br>\nsubsequent theorems, I name my variables in a certain, lexicographic order.</p>\n<p>I set up the syntax and theorem as next shown, where I've converted \\&lt;lbrace&gt;<br>\nand \\&lt;rbrace&gt;  to \"{\" and \"}\", except in the syntax command.</p>\n<p>syntax \"_paS\" :: \"sT =&gt;  sT =&gt;  sT\" (\"(\\&lt;lbrace&gt;(_,_)\\&lt;rbrace&gt;)\")<br>\n   translations<br>\n   \"\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;\" == \"CONST paS r s\"</p>\n<p>theorem lrbrace_notation [simp]:<br>\n   \"{{r,s},{p,p}} = {{p,p},{r,s}}\"<br>\n   sorry</p>\n<p>The simp rule works for the following:</p>\n<p>theorem \"{{f,d},{e,e}} = z\"<br>\n   apply simp<br>\n   --\"Output: {{e,e},{f,d}} = z\"<br>\n   oops</p>\n<p>However, if I replace \"f\" with anything lexicographically less than \"f\", it<br>\ndoesn't match, and doesn't simplify the goal, such as for the following:</p>\n<p>theorem \"{{a,d},{e,e}} = z\"<br>\n   apply simp<br>\n   oops</p>\n<p>In the theory, I replace \"f\" with variables named from \"a\" to \"e\", and it<br>\ndoesn't match, but when I get to \"f\", it matches.</p>\n<p>I attach theory, and I include it below.</p>\n<p>Thanks,<br>\nGB</p>\n<p>theory simp_pair_singleton_switch_alphabet_dependent</p>\n<p>imports Complex_Main<br>\nbegin<br>\ntypedecl sT<br>\nconsts paS :: \"sT =&gt;  sT =&gt;  sT\"</p>\n<p>syntax \"_paS\" :: \"sT =&gt;  sT =&gt;  sT\" (\"(\\&lt;lbrace&gt;(_,_)\\&lt;rbrace&gt;)\")<br>\n   translations<br>\n   \"\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;\" == \"CONST paS r s\"</p>\n<p>theorem lrbrace_notation [simp]:<br>\n   \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;,\\&lt;lbrace&gt;p,p\\&lt;rbrace&gt;\\&lt;rbrace&gt;  =<br>\n\\&lt;lbrace&gt;\\&lt;lbrace&gt;p,p\\&lt;rbrace&gt;,\\&lt;lbrace&gt;r,s\\&lt;rbrace&gt;\\&lt;rbrace&gt;\"<br>\n   sorry</p>\n<p>theorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;f,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt;  = z\"<br>\n   apply simp<br>\n   --\"Output: \\&lt;lbrace&gt;\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;,\\&lt;lbrace&gt;f,d\\&lt;rbrace&gt;\\&lt;rbrace&gt;  = z\"<br>\n   oops</p>\n<p>theorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;a,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt;  = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;b,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt;  = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;c,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt;  = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;d,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt;  = z\"<br>\n   apply simp<br>\n   oops<br>\ntheorem \"\\&lt;lbrace&gt;\\&lt;lbrace&gt;e,d\\&lt;rbrace&gt;,\\&lt;lbrace&gt;e,e\\&lt;rbrace&gt;\\&lt;rbrace&gt;  = z\"<br>\n   apply simp<br>\n   oops</p>\n<p>theorem regular_braces [simp]:<br>\n   \"{{r,s},{p}} = {{p},{r,s}}\"<br>\n   sorry<br>\ntheorem \"{{a,d},{e,e}} = z\"<br>\n   apply simp<br>\n   --\"Output: {{e}, {a, d}} = z\"<br>\n   oops<br>\nend<br>\n</p>\n</blockquote>\n<p><a href=\"/user_uploads/14278/ZPP9ki9omWFJCHFnkRFUYXfw/Gnarly_nested_set_ordered.png\">Gnarly_nested_set_ordered.png</a></p>\n</blockquote>",
        "id": 294233685,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903758
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nSuch a tool is in the making. For the time being you can prefix your \"apply<br>\nsimp\" by \"using [[simp_trace]]\". This gives you a very detailed trace, probably<br>\nmuch more than what you want.</p>\n<p>Tobias</p>",
        "id": 294233696,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903763
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nNo, \"using [[simp_trace]]\" works perfect for simple test cases. Using a <br>\nfancy debugger wouldn't be any easier. Figuring out where to set the <br>\nbreak points for a debugger can be no easy task, not I've used a <br>\ndebugger much, or any, because it's easier to just print to screen, and <br>\nthen prompt the user, than learn how to use a debugger.</p>\n<p>So reducing a formula down more and more can serve the purpose of single <br>\nstepping or setting break points.</p>\n<p>But, I was wanting to confirm whether this sentence, page 178,</p>\n<p>\"Permutative rewrite rules can be turned into simpli<br>\ncation rules in<br>\n    the usual manner via the simp attribute; the simplifer recognizes<br>\n    their special status automatically.\"</p>\n<p>means it does the permutative rewrite rules first, and it does mean <br>\nthat. The commutative and left-commutative rules end up doing together <br>\nwhat I had as one rule.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294233966,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660903898
    }
]