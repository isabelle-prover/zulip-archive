[
    {
        "content": "<p>From: Ian Lynagh &lt;<a href=\"mailto:igloo@earth.li\">igloo@earth.li</a>&gt;<br>\nHi all,</p>\n<p>I'm trying to write a simple proof in Isabelle, but I'm a little lost. I<br>\nwonder if anyone can help me please? I've attached the script I have so<br>\nfar.</p>\n<p>At the point at which I am stuck, I have<br>\n    using this:<br>\n        (EBool bool_, t) : STyping<br>\nand I want to show that \"t = TBool\", which must be true as<br>\n    STypingBool: \"forall (b :: bool) ==&gt; STyping (EBool b, TBool)\"<br>\nis the only constructor matching that pattern. My best guess was<br>\n    proof (cases this)<br>\nbut that says<br>\n    *** empty result sequence -- proof command failed<br>\n    *** At command \"proof\".<br>\nCan anyone give me a pointer in the right direction please?</p>\n<p>I'm also not sure why I can't do<br>\n    apply simpl<br>\nimmediately after<br>\n    case EBool<br>\n? My goal here was to try to get \"principalType (EBool bool)\" to reduce.</p>\n<p>Finally, I'd also be very interested to know if the general structure<br>\nlooks sensible, or if there would be a more sensible way to write this<br>\nsort of proof.</p>\n<p>Thanks<br>\nIan<br>\n<a href=\"/user_uploads/14278/JLgP7Vjfmf_Zsk0To323h1N1/simple.thy\">simple.thy</a></p>",
        "id": 294114099,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837736
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nIan Lynagh schrieb:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>I'm trying to write a simple proof in Isabelle, but I'm a little lost. I<br>\nwonder if anyone can help me please? I've attached the script I have so<br>\nfar.</p>\n<p>At the point at which I am stuck, I have<br>\n    using this:<br>\n        (EBool bool_, t) : STyping<br>\nand I want to show that \"t = TBool\", which must be true as<br>\n    STypingBool: \"forall (b :: bool) ==&gt; STyping (EBool b, TBool)\"</p>\n</blockquote>\n<p>For a start, your \"forall (b :: bool) ==&gt;\" is a bit weird. Isabelle<br>\naccepted it but had to interpret \"forall\" as a free function variable to<br>\nmake sense of it. Probably not what you meant. Note that \"forall\" is not<br>\n Isabelle speak, and that outermost universal quantifiers can and should<br>\nbe dropped. Just write \"STyping (EBool b, TBool)\".</p>\n<p>Now the proof.</p>\n<blockquote>\n<p>is the only constructor matching that pattern. My best guess was<br>\n    proof (cases this)</p>\n</blockquote>\n<p>You cannot do a case distintinction on a theorem (\"this\") but only on a<br>\nterm. This suggests</p>\n<p>proof (cases t)</p>\n<p>Although this step works, it does not get you anywhere. Before you start<br>\nthe whole proof you should deduce some elimination rules that allow you<br>\nto move from \"(EBool b, t) : STyping\" to \"t = TBool\". This can be done<br>\nautomatically:</p>\n<p>inductive_cases STypingE[elim!]:<br>\n  \"STyping (EBool b, t)\"</p>\n<p>The resulting lemma STypingE is what you need. The magic \"[elim!]\" tells<br>\nauto and blast and friends to apply this rule eagerly. Now your proof<br>\nshould just be</p>\n<p>from this have \"t = TBool\" by auto</p>\n<p>Important: you will have to extend STypingE with other cases, at least</p>\n<p>inductive_cases STypingE[elim!]:<br>\n  \"STyping (EBool b, t)\"<br>\n  \"STyping (EInt n, t)\"</p>\n<p>Tobias</p>\n<blockquote>\n<p>but that says<br>\n    *** empty result sequence -- proof command failed<br>\n    *** At command \"proof\".<br>\nCan anyone give me a pointer in the right direction please?</p>\n<p>I'm also not sure why I can't do<br>\n    apply simpl<br>\nimmediately after<br>\n    case EBool<br>\n? My goal here was to try to get \"principalType (EBool bool)\" to reduce.</p>\n<p>Finally, I'd also be very interested to know if the general structure<br>\nlooks sensible, or if there would be a more sensible way to write this<br>\nsort of proof.</p>\n<p>Thanks<br>\nIan</p>\n</blockquote>",
        "id": 294114148,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837754
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nMy mistake: I didn't run it. Your mistake: you had phrased the theorem<br>\nas \"... : STyping\" but the rules as \"STyping ...\". Don't mix the two<br>\nnotations, it complicates your life. Either set or predicate. And if<br>\npredicate, then it is usually better to curry it.</p>\n<p>Concerning your overall proof strategy, I recommend rule induction on<br>\nSTyping:</p>\n<p>proof(induct rule: STyping.induct)</p>\n<p>That takes care of all the case distinctins you were going to do by hand.</p>\n<p>Tobias</p>\n<p>Ian Lynagh schrieb:</p>",
        "id": 294114190,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837766
    },
    {
        "content": "<p>From: Ian Lynagh &lt;<a href=\"mailto:igloo@earth.li\">igloo@earth.li</a>&gt;<br>\nHi Tobias,</p>\n<p>On Fri, Aug 13, 2010 at 09:42:23AM +0200, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>outermost universal quantifiers can and should<br>\nbe dropped. Just write \"STyping (EBool b, TBool)\".</p>\n</blockquote>\n<p>Aha, thanks!</p>\n<blockquote>\n<p>inductive_cases STypingE[elim!]:<br>\n  \"STyping (EBool b, t)\"</p>\n<p>The resulting lemma STypingE is what you need. The magic \"[elim!]\" tells<br>\nauto and blast and friends to apply this rule eagerly. Now your proof<br>\nshould just be</p>\n<p>from this have \"t = TBool\" by auto</p>\n</blockquote>\n<p>Do you mean like this?:</p>\n<p>lemma \"((e, t) \\&lt;in&gt; STyping) ==&gt; (principalType e = Some t)\"<br>\nproof (induct e)<br>\n    case EBool<br>\n        from this have \"t = TBool\" by auto</p>\n<p>If so, the \"by auto\" fails with:</p>\n<p>*** Failed to finish proof<br>\n    *** At command \"by\".</p>\n<p>Thanks<br>\nIan</p>",
        "id": 294114367,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837809
    },
    {
        "content": "<p>From: Ian Lynagh &lt;<a href=\"mailto:igloo@earth.li\">igloo@earth.li</a>&gt;<br>\nOn Fri, Aug 13, 2010 at 01:37:12PM +0200, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>My mistake: I didn't run it. Your mistake: you had phrased the theorem<br>\nas \"... : STyping\" but the rules as \"STyping ...\". Don't mix the two<br>\nnotations, it complicates your life. Either set or predicate.</p>\n</blockquote>\n<p>Aha, thanks!</p>\n<blockquote>\n<p>Concerning your overall proof strategy, I recommend rule induction on<br>\nSTyping:</p>\n<p>proof(induct rule: STyping.induct)</p>\n<p>That takes care of all the case distinctins you were going to do by hand.</p>\n</blockquote>\n<p>Hmm, that gives me:</p>\n<ol>\n<li>!!b. principalType e = Some t</li>\n</ol>\n<p>which doesn't look provable to me. And there's also:</p>\n<ol start=\"3\">\n<li>!!guard exprTrue ta exprFalse.<br>\n       [| STyping (guard, TBool); principalType e = Some t;<br>\n          STyping (exprTrue, ta); principalType e = Some t;<br>\n          STyping (exprFalse, ta); principalType e = Some t |]<br>\n       ==&gt; principalType e = Some t</li>\n</ol>\n<p>but the t's shouldn't all be the same.</p>\n<p>Thanks<br>\nIan</p>",
        "id": 294114388,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837815
    }
]