[
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nThis is a thing I've always wondered about:</p>\n<p>Is there a formal reason why dependent type theory and constructive <br>\nlogic tend to come together (e.g., difficulties in soundly integrating <br>\nthe LEM or something),<br>\nor is that more of a community thing, i.e., the people who like type <br>\ntheory just happen to also like constructive math?</p>\n<p>Best wishes,<br>\nDominque.</p>",
        "id": 294751584,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195678
    },
    {
        "content": "<p>From: Freek Wiedijk &lt;<a href=\"mailto:freek@cs.ru.nl\">freek@cs.ru.nl</a>&gt;<br>\nHi Dominique,</p>\n<p>There certainly are also type theories for classical math<br>\n(\"lambda-bar mu mu-tilde\" comes to mind :-)), but they are<br>\nmore complicated and less trivially computational than the<br>\nnormal type theories, which correspond to constructive math.<br>\nSo it's not just a community thing, I think.</p>\n<p>Basically, throwing an exception corresponds to the<br>\nex-falso rule, and catching it corresponds to LEM, or<br>\nrather to elim-style rule \"(~A ==&gt; B) ==&gt; (A ==&gt; B) ==&gt; B\",<br>\nwhich amounts to the same thing.  In other words,<br>\nconstructivists only get half of the exception mechanism:<br>\nthey can throw, but can't catch.</p>\n<p>However you can take an exception and run with it, so to<br>\nimplement this in an implementation, you really need to<br>\nsave the full state of the system (including the stack and<br>\nheap and everything) in an exception.  For Lisp this is the<br>\n\"call-with-current-continuation\" function.</p>\n<p>So constructive math is functional programming without<br>\nexceptions.  And using an exception monad instead of built-in<br>\nexceptions corresponds to the double negation translation :-)</p>\n<p>Freek</p>",
        "id": 294751605,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195686
    },
    {
        "content": "<p>From: Dominique Unruh &lt;<a href=\"mailto:unruh@ut.ee\">unruh@ut.ee</a>&gt;<br>\nHi,</p>\n<p>I have to admit that I didn't really get the connection between <br>\nexceptions and LEM.</p>\n<p>But it seems to me what you explained is why it is problematic to give <br>\ncomputational meaning to a theory with LEM, right? That much I get.</p>\n<p>But I don't see why dependent type theories have to necessarily come <br>\nwith a computational meaning. (It could again be a community thing: <br>\npeople doing types like computation.)</p>\n<p>Basically, as I see it, the idea in classical math is that we do not <br>\ncare about a computational meaning of our formulas. (While <br>\nconstructivism does.)</p>\n<p>So, my question would be: is there an inherent reason why dependent type <br>\ntheory is more difficult if we want LEM and do not care about computability?</p>\n<p>Best wishes,</p>\n<p>Dominique.</p>",
        "id": 294751655,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195705
    },
    {
        "content": "<p>From: Johannes Hölzl &lt;<a href=\"mailto:johannes.hoelzl@gmx.de\">johannes.hoelzl@gmx.de</a>&gt;<br>\nAm Montag, den 25.02.2019, 18:13 +0200 schrieb Dominique Unruh:</p>\n<blockquote>\n<p>Hi,</p>\n<p>I have to admit that I didn't really get the connection between <br>\nexceptions and LEM.</p>\n<p>But it seems to me what you explained is why it is problematic to give <br>\ncomputational meaning to a theory with LEM, right? That much I get.</p>\n</blockquote>\n<p>Yes, LEM breaks computation, as it is a axiom without a computational<br>\nrule.</p>\n<p>And this is a distinction which is usually done in dependent type<br>\ntheory, but not in HOL: axioms and computational rules. In HOL there<br>\nare no computation rules besides alpha and eta equivalence and beta<br>\nreduction. While in DTT a lot of people prefer not to have any<br>\nconstants which do not have a computation rule associated with them,<br>\nbut often do not have a problem with introducing complex type formers<br>\nas long as one can compute with it.</p>\n<p>HOL:<br>\n  oh is is a small logic, only AC+LEM+funext+propext+typedef+...<br>\n  and then we derive (co)datatypes</p>\n<p>DDT:<br>\n  oh it is a small logic, no \"axioms\" but a powerful datatype formers<br>\n  so we can do a lot of (constructive) mathematics.</p>\n<p>But in many cases both approaches can be merged, in Coq you can use the<br>\nAxiom of Choice. And in Lean we use it by default. On the other hand,<br>\nif you want to go to HoTT you can't use Axiom of Choice on arbitrary<br>\ntypes (but still on the HOL subset of HoTT)</p>\n<blockquote>\n<p>But I don't see why dependent type theories have to necessarily come <br>\nwith a computational meaning. (It could again be a community thing: <br>\npeople doing types like computation.)</p>\n</blockquote>\n<p>Yes, this is usually the case. The advantage of using a limited logic<br>\nis that one gets additional properties for free. When you write down a<br>\nfunction in HoTT (without classical axioms) you get a continuous<br>\nfunction, where continuity is for free.</p>\n<blockquote>\n<p>Basically, as I see it, the idea in classical math is that we do not <br>\ncare about a computational meaning of our formulas. (While <br>\nconstructivism does.)</p>\n</blockquote>\n<p>Yes. </p>\n<blockquote>\n<p>So, my question would be: is there an inherent reason why dependent type <br>\ntheory is more difficult if we want LEM and do not care about computability?</p>\n</blockquote>\n<p>I would not say that dependent type theory is more difficult with LEM.<br>\nIt is as difficult as HOL.</p>\n<p>What you miss if you don't enjoy computability of your constants is<br>\npowerful unification/definitional equality! For example, a lot of proof<br>\nsteps where the simplifier is used in Isabelle are just application of<br>\none rule in Lean. Mind: definitional equality breaks abstraction (often<br>\nthe definition should not be part of an module interface), but for many<br>\nbasic constants this is a huge bon. ssreflect and mathcomp uses it a<br>\nlot.</p>\n<p>So, yes it gets more difficult: one needs a powerful rewrite engine<br>\nlike in Isabelle.</p>\n<ul>\n<li>Johannes</li>\n</ul>\n<blockquote>\n<p>Best wishes,</p>\n<p>Dominique.</p>\n<p>On 2/25/19 1:42 PM, Freek Wiedijk wrote:</p>\n<blockquote>\n<p>Hi Dominique,</p>\n<blockquote>\n<p>Is there a formal reason why dependent type theory and<br>\nconstructive logic tend to come together (e.g., difficulties<br>\nin soundly integrating the LEM or something), or is that<br>\nmore of a community thing, i.e., the people who like type<br>\ntheory just happen to also like constructive math?<br>\nThere certainly are also type theories for classical math<br>\n(\"lambda-bar mu mu-tilde\" comes to mind :-)), but they are<br>\nmore complicated and less trivially computational than the<br>\nnormal type theories, which correspond to constructive math.<br>\nSo it's not just a community thing, I think.</p>\n</blockquote>\n<p>Basically, throwing an exception corresponds to the<br>\nex-falso rule, and catching it corresponds to LEM, or<br>\nrather to elim-style rule \"(~A ==&gt; B) ==&gt; (A ==&gt; B) ==&gt; B\",<br>\nwhich amounts to the same thing.  In other words,<br>\nconstructivists only get half of the exception mechanism:<br>\nthey can throw, but can't catch.</p>\n<p>However you can take an exception and run with it, so to<br>\nimplement this in an implementation, you really need to<br>\nsave the full state of the system (including the stack and<br>\nheap and everything) in an exception.  For Lisp this is the<br>\n\"call-with-current-continuation\" function.</p>\n<p>So constructive math is functional programming without<br>\nexceptions.  And using an exception monad instead of built-in<br>\nexceptions corresponds to the double negation translation :-)</p>\n<p>Freek</p>\n</blockquote>\n</blockquote>",
        "id": 294751686,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195717
    },
    {
        "content": "<p>From: José Manuel Rodríguez Caballero &lt;<a href=\"mailto:josephcmac@gmail.com\">josephcmac@gmail.com</a>&gt;</p>\n<blockquote>\n<p>Dominique wrote:<br>\nIs there a formal reason why dependent type theory and constructive<br>\nlogic tend to come together (e.g., difficulties in soundly integrating<br>\nthe LEM or something),<br>\nor is that more of a community thing, i.e., the people who like type<br>\ntheory just happen to also like constructive math?</p>\n</blockquote>\n<p>I quote from nlab: <a href=\"https://ncatlab.org/nlab/show/Boolean+topos\">https://ncatlab.org/nlab/show/Boolean+topos</a></p>\n<p>The internal logic of a Boolean topos with natural numbers object can serve</p>\n<blockquote>\n<p>as foundations for \"ordinary\" mathematics, except for that which relies on<br>\nthe axiom of choice. If you add the axiom of choice, then you get (an<br>\ninternal version of) ETCS [Elementary Theory of the Category of Sets];<br>\nconversely, if you use an arbitrary topos, then you get constructive<br>\nmathematics.</p>\n</blockquote>\n<p>Dependent type theory corresponds to the internal logic of an arbitrary<br>\ntopos. The particular case of a dependent type theory, in which the LEM was<br>\naccepted, corresponds to the internal logic of a Boolean topos. Reference<br>\nabout the relationship between topos theory and dependent type theory:<br>\n<a href=\"http://www.math.mcgill.ca/rags/LCCC/LCCC.pdf\">http://www.math.mcgill.ca/rags/LCCC/LCCC.pdf</a></p>\n<p>A concrete example.</p>\n<p>On the one hand, the topos to formalize the Birkhoff -von Neumann quantum<br>\nlogic is a Boolean topos, because it is just classical mathematics (it is<br>\nnatural to formalize it in Isabelle/HOL). On the other hand, the topos used<br>\nto formalize the \"intuitionistic\" version of Birkhoff -von Neumann quantum<br>\nlogic (in which LEM does not hold, but the distributive property holds) is<br>\nthe Bohr topos (this is not a Boolean topos). Some references:<br>\nnlab: <a href=\"https://ncatlab.org/nlab/show/Bohr+topos\">https://ncatlab.org/nlab/show/Bohr+topos</a><br>\nvideo-lecture: <a href=\"https://youtu.be/bNPNiEHXYPM\">https://youtu.be/bNPNiEHXYPM</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"bNPNiEHXYPM\" href=\"https://youtu.be/bNPNiEHXYPM\"><img src=\"https://uploads.zulipusercontent.net/a3ebdb47f8b76b0718288d93de2dc3a6a0ae5498/68747470733a2f2f692e7974696d672e636f6d2f76692f624e504e6945485859504d2f64656661756c742e6a7067\"></a></div><p>In which proof assistant a formalization of the theory of Bohr topos is<br>\nmore natural? I doubt that the dependent type theory of Coq (CIC)<br>\ncorresponds to the internal logic of a Bohr topos. I guess that such a<br>\nproof assistant does not exist yet.</p>\n<p>Kind Regards,<br>\nJosé M.</p>",
        "id": 294751697,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661195723
    }
]