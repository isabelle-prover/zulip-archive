[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>The simps_of_case conversion function does not seem to like records. Consider the <br>\nfollowing minimal example:</p>\n<p>record foo = foo :: nat</p>\n<p>definition f :: \"foo ⇒ nat × nat ⇒ nat\"<br>\n   where \"f s xy = (case xy of (x, y) ⇒ foo s + x + y)\"</p>\n<p>simps_of_case f_def</p>\n<p>In this example, simps_of_case raises an exception THM, because unification of \"TERM _\"<br>\nand \"⟦?Q ⟷ ?P; ?Q⟧ ⟹ ?P\" has failed in line 315 in drule.ML. This error occurs only if one <br>\nof the parameters of the function is a record.</p>\n<p>Is this a general limitation of simps_of_case?</p>\n<p>Background on my use case: I want to a function with many cases. Using fun with nested <br>\npattern matching is too slow because the internal splitting procedure creates several <br>\nhundred disambiguiations and the internal constructions then take too long. However, it <br>\nworks nicely with a case expression on the right hand side. So I'd like to get the simp <br>\nrules back with simps_of_case. Any suggestions on this are welcome.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294644705,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163574
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThe problem is that \"#splits o Ctr_Sugar.ctr_sugar_of ctxt\" returns<br>\nDrule.dummy_thm for records, which has not the expected format for a<br>\nsplit rule.</p>\n<p>See <a href=\"http://isabelle.in.tum.de/testboard/Isabelle/rev/ccafd7d193e7\">http://isabelle.in.tum.de/testboard/Isabelle/rev/ccafd7d193e7</a> for a<br>\npatch which ignores these rules.</p>\n<p>-- Lars</p>",
        "id": 294644882,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163642
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nHi Lars, Andreas,</p>\n<p>Lars wrote:</p>\n<p>This immediately points to a workaround for Andreas:</p>\n<p>free_constructors foo_ext for foo_ext<br>\n      by (erule foo.cases_scheme) (rule foo.ext_inject)</p>\n<p>will update the “Ctr_Sugar” entry for your record type so that it works with “simps_of_case”.</p>\n<p>This of course raises the question of whether we can/should integrate records better with the emerging “free constructor” architecture. This is mostly an engineering or design issue. Records and datatypes have some obvious conceptual overlap: A plain (non-extended) record is like a nonrecursive single-constructor datatype. Also, for extended records, there is no single constant that acts as a constructor, so the “free constructor” architecture would have to be extended to cope with that. Hence, right now we do the minimum automatically and let users invoke “free_constructors” if they want to go further. If this is too much of an annoyance, we could at least derive the split rule automatically from “foo.cases_scheme\".</p>\n<p>Jasmin</p>",
        "id": 294645028,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163713
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jasmin and Lars,</p>\n<p>Thanks for your input. After Lars' explanations, I found another workaround, namely <br>\nexplicitly listing the relevant split rules using (splits: ...).</p>\n<p>Of course, I'd appreciate a better integration of record with the other packages. This <br>\nwould, e.g., allow to pattern-match on records in function definitions, as in</p>\n<p>record foo = foo :: nat<br>\n   record bar = foo + bar :: int</p>\n<p>free_constructors foo_ext for foo_ext by (fact foo.cases_scheme foo.ext_inject)+<br>\n   free_constructors bar_ext for bar_ext by (meson bar.ext_surjective)(fact bar.ext_inject)</p>\n<p>fun f :: \"'a bar_scheme ⇒ int\" where \"f (|foo = x, bar = y, … = z|) = int x + y\"</p>\n<p>Though, I do not see why the free constructor architecture would have to be extended. An <br>\nextended extensible record like 'a bar_scheme just abbreviates \"'a bar_ext foo_ext\" and <br>\nthe functions foo_ext and bar_ext can serve as constructors for foo_ext and bar_ext, <br>\nrespectively. That is, we just have nested types with free constructors. What am I missing?</p>\n<p>Unfortunately, the record package is still completely unlocalised. That's probably the <br>\nbigger hurdle.</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294645216,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163782
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@inria.fr\">jasmin.blanchette@inria.fr</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>Though, I do not see why the free constructor architecture would have to be extended. An extended extensible record like 'a bar_scheme just abbreviates \"'a bar_ext foo_ext\" and the functions foo_ext and bar_ext can serve as constructors for foo_ext and bar_ext, respectively. That is, we just have nested types with free constructors. What am I missing?</p>\n</blockquote>\n<p>Some of the architecture doesn’t like complex types like “‘a bar_ext foo_ext” — e.g. lookup is performed on a type name. That’s the main problem IIRC. It might be easy to fix. I thought there was also an issue with the “bar_ext” constant being an abbreviation, but I apparently remembered this wrong.</p>\n<p>Another worry I have is just the naming and wealth of theorems. Automatically performing what you do when you manually do “free_constructors” yields quite a few theorems coming from two worlds. It seems like the prefixes keep things apart, e.g. “foo.splits” (generated by record) vs. “foo_ext.splits” (generated by “free_constructors”) — but the situation is still not entirely satisfactory IMO. Hence, I would rather tread carefully here, and perhaps wait one more iteration of Isabelle and new datatypes before doing more “reforms”.</p>\n<p>I’m also not sure all infrastructure will be equally happy to have two views on records — the records one and the “ctr_sugar” one (which has largely displaced the old datatype one here and there). This is a minor issue that can be addressed one tool at a time (Nitpick, Quickcheck, etc.), but it might require some weeks before all problems have been identified and solved.</p>\n<p>Finally, this would enable the datatype plugins on records — generation of a size function etc. Again, this is not completely impact-free, if nothing else on the number of theorems/constants/etc. generated and hence on the performance of the prover. This is another reason why I’m inclined to wait.</p>\n<p>All this having been said, I believe that records belong in “ctr_sugar” and that the convenience of having them in there by default would be appreciated by many users. If anybody is willing to jump in and make it happen faster than I’m likely going to, they’re welcome. ;)</p>\n<blockquote>\n<p>Unfortunately, the record package is still completely unlocalised. That's probably the bigger hurdle.</p>\n</blockquote>\n<p>I think that’s fine as far as “Ctr_Sugar” goes, thanks to the “generic data” abstraction. “Ctr_Sugar” can also deal with old-style datatypes, after all.</p>\n<p>Cheers,</p>\n<p>Jasmin</p>",
        "id": 294645404,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661163850
    }
]