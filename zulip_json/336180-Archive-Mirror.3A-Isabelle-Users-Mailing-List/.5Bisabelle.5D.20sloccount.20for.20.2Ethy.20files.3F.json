[
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:xs@xaph.net\">xs@xaph.net</a>&gt;<br>\nDear Isabelle Users,</p>\n<p>We need something like sloccount (count lines of code in a file with <br>\ncomments removed) for Isabelle. It seems I have to hack up such a tool, <br>\nbut I worry that trying to do so quickly may result in not getting it <br>\nright. I would much rather piggyback on a tool written by someone else <br>\nalready.</p>\n<p>Does anyone know of such a tool, or a hackable approximation of one?</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294217302,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895591
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nI don't know any approximations, only the official Isabelle functions for <br>\nthat.  (According to Isabelle2012.)</p>\n<p>This is how it works in Isabelle/Scala, e.g. with the \"isabelle scala\" <br>\ntoplevel loop:</p>\n<p>val syntax = isabelle.Outer_Syntax.empty<br>\n   syntax.scan(\"theory (* (* \\n *) <em>) A {</em> *}\")</p>\n<p>You can then walk through the token list and remove comments, count <br>\nnewlines etc.</p>\n<p>Note that the empty outer syntax does not know about any keywords, but <br>\nthat should be OK in this application.</p>\n<p>There are also similar operations in src/Pure/Thy/thy_syntax.ML, but <br>\nIsabelle/ML system programming is a bit old-fashioned.  It is worth <br>\nspending a little time getting acquainted with Isabelle/Scala; such an <br>\ninvestment will pay off rather quickly for other projects.</p>\n<p>Makarius</p>",
        "id": 294217325,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895603
    },
    {
        "content": "<p>From: \"C. Diekmann\" &lt;<a href=\"mailto:diekmann@in.tum.de\">diekmann@in.tum.de</a>&gt;<br>\nHi,</p>\n<blockquote>\n<p>[...] or a hackable approximation of one?</p>\n</blockquote>\n<p>$ cat <em>.thy | awk '/\\(\\</em>/,/\\*\\)/{ next } 1' | wc -l</p>\n<p>Removes all (* <em>) blocks and counts the lines. Empty lines, text {</em> *}<br>\nblocks and --\"\" comments are not stripped.</p>\n<p>With kind regards,<br>\nCornelius</p>",
        "id": 294217348,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660895615
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis threads appear to be inconclusive.  Did you prefer awk or Scala?</p>\n<p>Anyway, here is a little toy for isabelle scala (as of Isabelle2012), <br>\nwhich can be run on its toplevel loop:</p>\n<p>import isabelle._</p>\n<p>def lines_without_comments(text: String): Int =<br>\n{<br>\n   val newlines =<br>\n     for {<br>\n       token &lt;- Outer_Syntax.empty.scan(text).iterator<br>\n       if !token.is_comment<br>\n       c &lt;- token.source.iterator<br>\n       if c == '\\n'<br>\n     } yield 1<br>\n   val n = (0 /: newlines)(_ + _)<br>\n   if (text.endsWith(\"\\n\")) n else n + 1<br>\n}</p>\n<p>To get the text of a file, you can use <a href=\"http://scala.io\">scala.io</a> like this:</p>\n<p>val text = scala.io.fromFile(\"A.thy\").mkString</p>\n<p>Next time there will be more Isabelle-ish I/O operations.</p>\n<p>Makarius</p>",
        "id": 294218703,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660896278
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:xs@xaph.net\">xs@xaph.net</a>&gt;<br>\nOn 01/08/12 06:53, Makarius wrote:</p>\n<blockquote>\n<p>On Wed, 25 Jul 2012, Rafal Kolanski wrote:</p>\n<blockquote>\n<p>We need something like sloccount (count lines of code in a file with<br>\ncomments removed) for Isabelle.</p>\n</blockquote>\n<p>This threads appear to be inconclusive.  Did you prefer awk or Scala?</p>\n<p>Anyway, here is a little toy for isabelle scala (as of Isabelle2012),<br>\nwhich can be run on its toplevel loop:</p>\n</blockquote>\n<p>I have ran your program on the attached Scratch.thy, and got back the <br>\nresult \"19\", which is identical to the result of wc -l. That can't be <br>\nright! Any thoughts? I have just started learning scala today in order <br>\nto understand this snippet, and I don't yet see what's wrong.</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>\n<blockquote>\n<p>import isabelle._</p>\n<p>def lines_without_comments(text: String): Int =<br>\n{<br>\n   val newlines =<br>\n     for {<br>\n       token &lt;- Outer_Syntax.empty.scan(text).iterator<br>\n       if !token.is_comment<br>\n       c &lt;- token.source.iterator<br>\n       if c == '\\n'<br>\n     } yield 1<br>\n   val n = (0 /: newlines)(_ + _)<br>\n   if (text.endsWith(\"\\n\")) n else n + 1<br>\n}</p>\n<p>To get the text of a file, you can use <a href=\"http://scala.io\">scala.io</a> like this:</p>\n<p>val text = scala.io.fromFile(\"A.thy\").mkString</p>\n<p>Next time there will be more Isabelle-ish I/O operations.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/zIVz5pBZ4ahxpQxJ0RN7l8gS/Scratch.thy\">Scratch.thy</a></p>\n</blockquote>",
        "id": 294221526,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897752
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c-sterna@jaist.ac.jp\">c-sterna@jaist.ac.jp</a>&gt;<br>\nDear Rafal,</p>\n<p>Scala's \"for\" is more or less like Haskell's list comprehension. The <br>\nabove for-expression does the following:</p>\n<ul>\n<li>iterate over all tokens,</li>\n<li>omit comment tokens</li>\n<li>for every other token, iterate through its characters</li>\n<li>only consider newline characters</li>\n</ul>\n<p>Furthermore, I think there is a typo in the script, the last <br>\nif-then-else should have swapped branches, i.e., add 1 if the file ends <br>\nwith a newline character.</p>\n<p>After correcting the typo, the script counts all newlines that are not <br>\npart of comments. Your attached Scratch.thy had 20 lines. It contains <br>\nonly a single comment (at least what _.is_comment considers as comment), <br>\nnamely (* more comments\\n  *), which just contains a single new-line, <br>\nthus the script is right.</p>\n<p>To see how the different tokens are categorized you can do the following:</p>\n<p>$ isabelle scala<br>\nimport isabelle._<br>\nval text = scala.io.Source.fromFile(\"Scratch.thy\").mkString<br>\nval tokens = Outer_Syntax.empty.scan(text).toList<br>\ntokens.foreach { x =&gt; print(x.toString + \"\\n\") }</p>\n<p>hope this helps</p>\n<p>chris</p>",
        "id": 294221684,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897817
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 1 Aug 2012, Christian Sternagel wrote:</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>} yield 1<br>\n   val n = (0 /: newlines)(_ + _)<br>\n   if (text.endsWith(\"\\n\")) n else n + 1<br>\n}</p>\n</blockquote>\n</blockquote>\n<p>Furthermore, I think there is a typo in the script, the last if-then-else <br>\nshould have swapped branches, i.e., add 1 if the file ends with a newline <br>\ncharacter.</p>\n</blockquote>\n<p>My idea was to count the lines independently of the termination of the <br>\nlast line.  If the text ends with \"\\n\" it had already been counted as part <br>\nof the tokens.  The example Scratch.thy has 20 lines but \\n newline <br>\ncharacters.</p>\n<p>Anyway, this is just a toy.  It shows that there are fine points that <br>\nmight need to be addressed, so a decent programming language helps.</p>\n<blockquote>\n<p>import isabelle._<br>\nval text = scala.io.Source.fromFile(\"Scratch.thy\").mkString<br>\nval tokens = Outer_Syntax.empty.scan(text).toList<br>\ntokens.foreach { x =&gt; print(x.toString + \"\\n\") }</p>\n</blockquote>\n<p>Thanks for the correction of scala.io.Source.fromFile.</p>\n<p>The last line can be done like this:</p>\n<p>tokens foreach println</p>\n<p>Makarius</p>",
        "id": 294221795,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897885
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nYour example contains various Isar markup commands like this:</p>\n<p>section {* ... *}<br>\n   text {* ... *}</p>\n<p>These are not comments, they are part of the formal text (and they consist <br>\nof more than one token anyway).</p>\n<p>You could filter out both (* ... <em>) and {</em> ... *} tokens like this:</p>\n<p>if !(token.is_comment || token.kind == Token.Kind.VERBATIM)</p>\n<p>Although that is not very precise, since verbatim tokens can occur in <br>\nother non-markup commands as well, say 'ML' or 'method_setup'.</p>\n<p>It requires a little bit of outer syntax parsing to detect</p>\n<p>MARKUP_COMMAND VERBATIM_TOKEN</p>\n<p>separated by whitespace or comments (or tags).  See <br>\nsrc/Pure/Thy/thy_output.ML:present_thy/markup for the fully precise way to <br>\ndetect that form.</p>\n<p>To discriminate markup command tokens in Scala you need information from <br>\nthe outer syntax taken from the prover session, lets say from <br>\nIsabelle/Pure or HOL as approximation (assuming that the application does <br>\nnot introduce its own markup commands).  The following table has been <br>\nguessed from a a search for Outer_Syntax.markup_command on the ML sources:</p>\n<p>val markup_command =<br>\n     Set(<br>\n       \"header\",<br>\n       \"chapter\",<br>\n       \"section\",<br>\n       \"subsection\",<br>\n       \"subsubsection\",<br>\n       \"text\",<br>\n       \"text_raw\",<br>\n       \"sect\",<br>\n       \"subsect\",<br>\n       \"subsubsect\",<br>\n       \"txt\",<br>\n       \"txt_raw\")</p>\n<p>This set can then be used like a predicate in Scala, with normal <br>\napplication notation:</p>\n<p>token.is_command &amp;&amp; markup_command(token.content)</p>\n<p>Then you probably want to use parser combinators from the Scala library to <br>\nwork out some structure of the Isar token list.  See also <br>\nsrc/Pure/Isar/parse.scala and some other places that use that Parse <br>\nmodule.</p>\n<p>Moreover, you probably also want to take care of vacous lines after the <br>\nstripping.</p>\n<p>It depends what you want to count and to achieve in the end, how much <br>\nprecision you want to apply.</p>\n<p>Makarius</p>",
        "id": 294221940,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660897952
    },
    {
        "content": "<p>From: Rafal Kolanski &lt;<a href=\"mailto:xs@xaph.net\">xs@xaph.net</a>&gt;<br>\nThank you very much. This gives me a very solid basis to start with,<br>\neven with my knowledge of scala at a day-old level. It also prevents me<br>\nfrom having to write yet another parser. Perhaps the resulting script<br>\n(after being tuned) will be of use to somebody. Once I have it, I will<br>\nshare.</p>\n<p>Sincerely,</p>\n<p>Rafal Kolanski.</p>",
        "id": 294222203,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660898088
    }
]