[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear all,</p>\n<p>I use coinduction rules of the format as in the following example:</p>\n<p>typedecl foo<br>\nconsts unfoo :: \"foo =&gt; foo\"</p>\n<p>lemma foo_coinduct[consumes 1, case_names foo]:<br>\n   fixes f g :: \"'a =&gt; foo\"<br>\n   assumes \"P x\"<br>\n   \"!!x. P x ==&gt;<br>\n     (EX x'. unfoo (f x) = f x' &amp; unfoo (g x) = g x' &amp; P x')<br>\n     | unfoo (f x) = unfoo (g x)\"<br>\n   shows \"f x = g x\"<br>\nsorry</p>\n<p>With the rule, I show equality of two functions are equal on some set <br>\nspecified by the coinduction invariant predicate P. The second premise <br>\nexpresses that P is actually an invariant under the destructors.</p>\n<p>Frequently, the functions f and g depend on multiple parameters. To that <br>\nend, I derive from foo_coinduct one rule where x is split into two <br>\nparameters. I found that split_format (complete) almost does that:</p>\n<p>lemmas foo_coinduct2 =<br>\n   foo_coinduct[where x=\"(a, b)\", split_format (complete)]</p>\n<p>[| P a b;<br>\n    !!a b. P a b<br>\n    ==&gt; (EX x'. unfoo (f a b) = (case x' of (x, xa) =&gt; f x xa) &amp;<br>\n                unfoo (g a b) = (case x' of (x, xa) =&gt; g x xa) &amp;<br>\n                (case x' of (x, xa) =&gt; P x xa))<br>\n        | unfoo (f a b) = unfoo (g a b) |]<br>\n     ==&gt; f a b = g a b</p>\n<p>The ugly thing about this are the \"case x' of (x, xa) =&gt;\" bits. If <br>\nsplit_format (complete) would split the EX quantifier, too, they would <br>\nbe gone. Of course, I can so do manually as follows, but this looses the <br>\nconsumes and case_names declarations:</p>\n<p>lemmas foo_coinduct2 =<br>\n   foo_coinduct[where x=\"(a, b)\", split_format (complete),<br>\n                unfolded split_paired_Ex prod.cases]</p>\n<p>Are there better ways to achieve my goal? Would it be sensible to extend <br>\nsplit_format such that it also splits EX and ALL quantifiers if needed? <br>\nThese ugly case splits for EX and ALL happen also when there is free <br>\nuncurried function variable as in</p>\n<p>notepad begin<br>\n   { fix f :: \"('a * 'b) =&gt; bool\"<br>\n     have \"EX x. f x\" sorry }<br>\n   thm this[split_format (complete)]<br>\nend</p>\n<p>If there is consent that EX and ALL should also be split, I could try to <br>\nadapt split_format accordingly. A quick grep across the distribution and <br>\nthe AFP shows that split_format (complete) is so far only used for a few <br>\ninduction rules.</p>\n<p>Any opinions?</p>\n<p>Andreas</p>",
        "id": 294237835,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905573
    }
]