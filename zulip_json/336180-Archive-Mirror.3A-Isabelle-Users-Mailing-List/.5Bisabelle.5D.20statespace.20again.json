[
    {
        "content": "<p>From: Nils Jähnig &lt;<a href=\"mailto:jaehnig@mi.fu-berlin.de\">jaehnig@mi.fu-berlin.de</a>&gt;<br>\nHello Norbert,</p>\n<p>We recently asked a question about state spaces on the mailing list<br>\nthat you kindly answered, but still questions arise :-)</p>\n<p>We are working on a formalization of a low-level language with a proof<br>\ncalculus in Isabelle/HOL. So far this formalization was defined<br>\nconcrete, i.e. the operational semantics were defined as inductive<br>\nfunction of type \"record =&gt; instruction =&gt; record =&gt; bool\". Currently<br>\nit is our goal to make the formalization more abstract, i.e. as an<br>\nabstract base function \" 's =&gt; instruction =&gt;' s =&gt; bool\" and to<br>\ndefine the concrete semantics of a command (e.g. \"s (add VX VY VZ) t\")<br>\nby reducing to the abstract definition (rather like in Simpl, e.g. \"s<br>\n(Basic f) t\"). We still want to use statespace construct.</p>\n<p>The problem we're facing now is how we can quantify over variables<br>\nwithin a specific statespace environment (e.g. statespace st = VX::nat<br>\nVY::nat VZ::nat) . For example, if we want to show the lemma (in st)<br>\n\"Opsem s (add VX VY VZ) t\", we want to reduce the semantics of add to<br>\nthe general rule that represents the relationship between the states s<br>\nand t (the equivalent of [ta = sb + sc ] ==&gt; Opsem s (add a b c) t).<br>\nAs variables in statespace are distinguished according to their<br>\nabstract names, we could not come up with a solution. It seems as if<br>\nthis happens in Simpl in the ML code. do we have to learn ML to do<br>\nthis?</p>\n<p>For ideas or suggestions where we might find this a starting point, we<br>\nwould be very grateful.</p>\n<p>Thank you and best regards,<br>\nNils and Björn</p>",
        "id": 294122301,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840213
    },
    {
        "content": "<p>From: Norbert Schirmer &lt;<a href=\"mailto:schirmer@in.tum.de\">schirmer@in.tum.de</a>&gt;<br>\nHi Nils and Björn,</p>\n<p>well it depends. The art of HOL style theorem proving is a lot about choice. And this is especially true for Isabelle / HOL. There are a lot of choices: </p>\n<ul>\n<li>shallow vs. deep embedding,</li>\n<li>abstract (e.g. using locales) vs. concrete definitions (e.g. using records)</li>\n<li>an general theorem vs. solving instances on the fly in ML.</li>\n</ul>\n<p>And which choice to take depends on what you want to achieve with your theory. Is it biased towards meta-theory of a language or is it creating a tool to prove properties about a concrete program in that language. </p>\n<p>To be more concrete in your example what do you want to prove about \"add VX VY VZ\" and how do you want to further use the result within the theorem prover? Do you want to use the result at all, or is this already the final result?</p>\n<p>For example in your case you could aim at:<br>\n(1) \"forall sates s where I have three distinct variables vx, vy, vz, then in state t we have vz t = vx t + vy t ...\"<br>\n(2) symbolic evaluation of a concrete program which happens to have those three variables among others, and continue 'calculation' to prove something about the outcome in the end</p>\n<p>The good thing about using locales and statespaces here in particular is that you can get both:<br>\nYou prove the concrete (in an abstract context -- the statespace) and Isabelle gives you the generalized version for free.</p>\n<p>While being inside of the statespace / locale you just have those 3 distinct fixed variables with the 'obvious' properties and can easily prove or symbolically evaluate your programs.<br>\nBut under the hood you also get a generalized version of the theorem which you can use outside of the statespace / locale.</p>\n<p>This theorem basically states:<br>\nFor all states which have at least 3 distinct variables say vx, vy,vz we have ...</p>\n<p>So in theory this is all you need. The question is how handy these theorems are for you to use in practice for your further theory development. Maybe the locale / statespace infrastructure already provides the tools you need (e.g. merging locales). But maybe there are obvious extensions that you (and probably others) would like to have. Thats where you should start using ML and try to develop the tools that other will enjoy to use.</p>\n<p>I suggest to start with the locale documentation, understanding the difference of being 'inside the locale' and outside. Look at the theorems that are generated after proving a lemma, the internal variant and the generalized variant. Think about how you could use those theorems.</p>\n<p>Hope this helps,</p>\n<p>Norbert</p>",
        "id": 294122360,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840229
    }
]