[
    {
        "content": "<p>From: Bianca Lutz &lt;<a href=\"mailto:bianca.lutz@gmx.net\">bianca.lutz@gmx.net</a>&gt;<br>\nHello,<br>\nI have some problems concerning customized induction schemes in<br>\nconjunction with structured induction proofs using the induct method.</p>\n<p>Consider the following two datatypes:<br>\nterm = T1 term | T2 term | ...<br>\nvar = string</p>\n<p>a primrec function op :: [term, var] =&gt; term</p>\n<p>and an inductively defined relation<br>\nR :: [term, term] =&gt; bool<br>\nwhere<br>\n  R1: [[ ALL x. Q x --&gt; R (op t1 x) (op t2 x) ]] ==&gt; R (T1 t1) (T1 t2)<br>\n| R2: [[ ALL x. Q x --&gt; R (op t1 x) (op t2 x) ]] ==&gt; R (T2 t1) (T2 t2)<br>\n| ...</p>\n<p>whereas Q is a rather long statement concerning elements of type var.</p>\n<p>The induction scheme R.induct has the following shape:<br>\n[[ R t1 t2;<br>\n /\\t1 t2. [[ALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; ?P (op t1 x) (op t2 x)]]<br>\n                 ==&gt; ?P (T1 t1) (T1 t2);<br>\n /\\t1 t2. [[ALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; ?P (op t1 x) (op t2 x)]]<br>\n                 ==&gt; ?P (T2 t1) (T2 t2);<br>\n ...<br>\n]] ==&gt; ?P t1 t2</p>\n<p>Usually there is some predicate P2 t1 t2 following from<br>\nALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; P (op t1 x) (op t2 x)<br>\nthat solves both R1 and R2.</p>\n<p>Therefore, I proved the following customized induction scheme<br>\nlemma R_induct:<br>\n[[ R t1 t2;<br>\n /\\t1 t2. [[?P2 t1 t2]] ==&gt; ?P1 (T1 t1) (T1 t2);<br>\n /\\t1 t2. [[?P2 t1 t2]] ==&gt; ?P1 (T2 t1) (T2 t2);<br>\n /\\t1 t2. [[ALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; ?P1 (op t1 x) (op t2 x)]]<br>\n                 ==&gt; ?P2 t1 t2;<br>\n ...<br>\n]] ==&gt; ?P1 t1 t2</p>\n<p>Unfortunately, when I use this as shown below Isabelle fails at the last line:<br>\n*** Illegal schematic variable(s) in case \"2\"<br>\n*** at command \"case\"</p>\n<p>although there is no schematic variable in case \"2\" (at least<br>\naccording to Isabelle-&gt;Show me...-&gt;cases), since I instantiated ?P2<br>\nwith some appropriate predicate beforehand ...</p>\n<p>lemma<br>\n assumes \"R t1 t2\"<br>\n shows \"P1 t1 t2\"<br>\n proof (induct rule: R_induct[of t1 t2 P2 P1])<br>\n  case 1 thus ?case by (simp add: assms)  (* R t1 t2 *)<br>\n next<br>\n  case 2</p>\n<p>I have no idea how to avoid this. Any suggestions?</p>\n<p>Thanks,<br>\nBianca.</p>",
        "id": 294098915,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833164
    },
    {
        "content": "<p>From: Johannes HÃ¶lzl &lt;<a href=\"mailto:hoelzl@in.tum.de\">hoelzl@in.tum.de</a>&gt;<br>\nHi Bianca,</p>\n<p>Am Dienstag, den 26.01.2010, 16:35 +0100 schrieb Bianca Lutz:<br>\n[..]</p>\n<blockquote>\n<p>The induction scheme R.induct has the following shape:<br>\n[[ R t1 t2;<br>\n /\\t1 t2. [[ALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; ?P (op t1 x) (op t2 x)]]<br>\n                 ==&gt; ?P (T1 t1) (T1 t2);<br>\n /\\t1 t2. [[ALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; ?P (op t1 x) (op t2 x)]]<br>\n                 ==&gt; ?P (T2 t1) (T2 t2);<br>\n ...<br>\n]] ==&gt; ?P t1 t2</p>\n</blockquote>\n<p>Here ?P is an quantified variable which can be arbitrary instantiated<br>\nwhen R.induct is used.</p>\n<blockquote>\n<p>Usually there is some predicate P2 t1 t2 following from<br>\nALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; P (op t1 x) (op t2 x)<br>\nthat solves both R1 and R2.</p>\n<p>Therefore, I proved the following customized induction scheme<br>\nlemma R_induct:<br>\n[[ R t1 t2;<br>\n /\\t1 t2. [[?P2 t1 t2]] ==&gt; ?P1 (T1 t1) (T1 t2);<br>\n /\\t1 t2. [[?P2 t1 t2]] ==&gt; ?P1 (T2 t1) (T2 t2);<br>\n /\\t1 t2. [[ALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; ?P1 (op t1 x) (op t2 x)]]<br>\n                 ==&gt; ?P2 t1 t2;<br>\n ...<br>\n]] ==&gt; ?P1 t1 t2</p>\n</blockquote>\n<p>When Isabelle reads variables with question marks in theorems they are<br>\ninterpreted as existentially quantified variables. Just don't write them<br>\nwith question marks, Isabelle interprets each identifier which is not<br>\ndefined as constant as all quantified variable. </p>\n<p>So write:</p>\n<p>lemma R_induct:<br>\n\"[[ R t1 t2;<br>\n    /\\t1 t2. [[P2 t1 t2]] ==&gt; P1 (T1 t1) (T1 t2);<br>\n    /\\t1 t2. [[P2 t1 t2]] ==&gt; P1 (T2 t1) (T2 t2);<br>\n    /\\t1 t2. [[ALL x. Q x --&gt; R (op t1 x) (op t2 x) &amp; ?P1 (op t1 x) (op t2 x)]]<br>\n                 ==&gt; P2 t1 t2;<br>\n    ...<br>\n ]] ==&gt; P1 t1 t2\"</p>\n<p>unfortunately when Isabelle writes theorems (like \"thm R_induct\") the<br>\nall quantified variables are shown with question marks.</p>\n<p>By the way you can provide names to the cases with:</p>\n<p>lemma R_induct[case_names Name1 Name2 Name3]:<br>\n   ....</p>\n<blockquote>\n<p>Unfortunately, when I use this as shown below Isabelle fails at the last line:<br>\n*** Illegal schematic variable(s) in case \"2\"<br>\n*** at command \"case\"</p>\n</blockquote>\n<p>I hope this solves your problem,</p>\n<p>Johannes</p>",
        "id": 294100974,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660833765
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@kit.edu\">andreas.lochbihler@kit.edu</a>&gt;<br>\nHi Bianca,</p>\n<p>unfortunately, I am not able to reproduce your error, but here are some <br>\nmore hints on using the induct method:</p>\n<ol>\n<li>The generated induction rules for inductive predicates \"consume\" the <br>\npremise for the inductive predicate. By passing this fact to the induct <br>\nmethod, it normally selects the right induction rule automatically.<br>\nMoreover, you do not have to show the inductive predicate goal any more.<br>\nIf you want the same effect for your custom induction rule, use the <br>\nattribute \"consumes n\" where n is the number of facts to consume, usually 1.</li>\n</ol>\n<p>In your example:<br>\nlemma R_induct[consumes 1]: ...</p>\n<p>lemma R_lc:<br>\n   fixes t1 t2<br>\n   assumes \"R t1 t2\"<br>\n   shows \"lc t1 &amp; lc t2\"<br>\nusing assms<br>\nproof (induct rule: R_induct)</p>\n<p>If you combine this with the case_names attribute, use consumes first. <br>\nConsumed assumptions are not counted when providing names.</p>\n<p>In your example:<br>\nlemma R_induct[consumes 1, case_names P1_T1 P1_T2 ...]</p>\n<ol start=\"2\">\n<li>Usually, you do not have to instantiate the parameters that appear in <br>\nthe conclusion. In particular, ?P1 in R_induct is automatically unified <br>\nwith \"%t1 t2. lc t1 &amp; lc t2\" in your example. If induct has trouble to <br>\nfigure out the right instantiation, you can provide the arguments to P1 <br>\nexplicitly:</li>\n</ol>\n<p>...<br>\nusing assms<br>\nproof (induct t1 t2 rule: R_induct)</p>\n<ol start=\"3\">\n<li>Your induction rule R_induct involves the free variable P2 that does <br>\nnot occur in the conclusion nor in the consumed facts. This is usually <br>\nthe cause for your error message \"unbound schematic variable(s) in case 2\".<br>\nRather than manually instantiating P2 in the induction rule, the induct <br>\nmethod provides the \"taking\" specification:</li>\n</ol>\n<p>...<br>\nusing assms<br>\nproof (induct t1 t2<br>\n         taking: \"%t1 t2. (ALL x. Q x --&gt; lc (op t1 x) &amp; lc (op t2 x))\"<br>\n         rule: R_induct)</p>\n<p>You can find more documentation on the induct method in the <br>\nIsabelle/Isar Reference Manual, Sec. 6.6.</p>\n<p>I hope this helps.</p>\n<p>Regards,<br>\nAndreas</p>",
        "id": 294102125,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660834098
    }
]