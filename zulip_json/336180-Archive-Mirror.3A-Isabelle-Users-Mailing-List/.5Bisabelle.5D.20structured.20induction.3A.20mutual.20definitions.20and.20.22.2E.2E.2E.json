[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nConsider the following example (in Main of isabelle 2011).</p>\n<p>datatype foo = F1 | F2 bar and bar = B1 | B2 foo</p>\n<p>inductive fooEq::\"foo \\&lt;Rightarrow&gt; foo \\&lt;Rightarrow&gt; bool\"   (infix \"~f\" 100)<br>\n  and barEq::\"bar \\&lt;Rightarrow&gt; bar \\&lt;Rightarrow&gt; bool\"       (infix \"~b\" 100)<br>\nwhere<br>\n  fe1:\"F1 ~f F1\"<br>\n| fe2:\"b1 ~b b2 \\&lt;Longrightarrow&gt; F2 b1 ~f F2 b2\"<br>\n| be1:\"B1 ~b B1\"<br>\n| be2:\"f1 ~f f2 \\&lt;Longrightarrow&gt; B2 f1 ~b B2 f2\"</p>\n<p>I want to prove that fooEq and barEq are transitive</p>\n<p>lemma<br>\n  shows feTrn: \"\\&lt;lbrakk&gt;f1 ~f f2; f2 ~f f3\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt; f1 ~f f3\"<br>\n    and beTrn: \"\\&lt;lbrakk&gt;b1 ~b b2; b2 ~b b3\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt; b1 ~b b3\"</p>\n<p>The proof is by simultaneous induction on the first premise and<br>\ninversion on the second premise.  The first case (fe1) is solved by<br>\n\"force\"</p>\n<p>proof (induct rule: fooEq_barEq.inducts, force)</p>\n<p>consider the second case:</p>\n<p>case (fe2 b1a b2a)<br>\n  have j0:\"F2 b2a ~f f3\"<br>\n    and j1:\"b1a ~b b2a\"<br>\n    and j2:\"b2a ~b b3 \\&lt;Longrightarrow&gt; b1a ~b b3\" by fact+</p>\n<p>This is clearly wrong; we need to generalize over f3 and b3 so that j2<br>\nis parametric in b3.  Try using \"arbitrary\":</p>\n<p>proof (induct arbitrary: f3 b3 rule: fooEq_barEq.inducts, force)<br>\n  case (fe2 b1a b2a f3a)<br>\n  have j0:\"F2 b2a ~f f3a\"<br>\n    and j1:\"b1a ~b b2a\"<br>\n    and j2:\"b2a ~b b3 \\&lt;Longrightarrow&gt; b1a ~b b3\" by fact+</p>\n<p>What happened?  The occurrence of b3 in j2 was not generalized<br>\nalthough a new variable \"f3a\" has appeared in j0.</p>\n<p>How can this proof be done?</p>\n<p>Thanks,<br>\nRandy</p>",
        "id": 294137458,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844813
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Tue, May 31, 2011 at 6:08 PM, Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>Consider the following example (in Main of isabelle 2011).</p>\n<p>datatype foo = F1 | F2 bar and bar = B1 | B2 foo</p>\n<p>inductive fooEq::\"foo \\&lt;Rightarrow&gt; foo \\&lt;Rightarrow&gt; bool\"   (infix \"~f\" 100)<br>\n and barEq::\"bar \\&lt;Rightarrow&gt; bar \\&lt;Rightarrow&gt; bool\"       (infix \"~b\" 100)<br>\nwhere<br>\n fe1:\"F1 ~f F1\"<br>\n| fe2:\"b1 ~b b2 \\&lt;Longrightarrow&gt; F2 b1 ~f F2 b2\"<br>\n| be1:\"B1 ~b B1\"<br>\n| be2:\"f1 ~f f2 \\&lt;Longrightarrow&gt; B2 f1 ~b B2 f2\"</p>\n<p>I want to prove that fooEq and barEq are transitive</p>\n</blockquote>\n<p>Hi Randy,</p>\n<p>Here is a proof that works:</p>\n<p>inductive_cases fe2_elim [elim!]: \"F2 b1 ~f f2\"<br>\ninductive_cases be2_elim [elim!]: \"B2 f1 ~b b2\"</p>\n<p>lemma<br>\n shows feTrn: \"\\&lt;lbrakk&gt;f1 ~f f2; f2 ~f f3\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt; f1 ~f f3\"<br>\n   and beTrn: \"\\&lt;lbrakk&gt;b1 ~b b2; b2 ~b b3\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt; b1 ~b b3\"<br>\nby (induct arbitrary: f3 and b3 rule: fooEq_barEq.inducts, auto intro:<br>\nfooEq_barEq.intros)</p>\n<p>OR:</p>\n<p>by (induct arbitrary: f3 and b3 set: fooEq barEq, auto intro:<br>\nfooEq_barEq.intros)</p>\n<p>The important thing is the \"and\" in \"arbitrary: f3 and b3\". This tells<br>\ninduct to generalize over \"f3\" in the first goal, and over \"b3\" in the<br>\nsecond.</p>\n<p>Simply saying \"arbitrary: f3 b3\" generalizes over both variables in<br>\nthe first goal, but does not generalize the second one at all. Or<br>\nactually, the \"b3\" seems to be totally ignored, since there is no<br>\nvariable with that name in the first goal. It seems like there ought<br>\nto be a warning message in that case, if you tell \"induct\" to<br>\ngeneralize over a non-existent variable.</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>\n<blockquote>\n<p>lemma<br>\n shows feTrn: \"\\&lt;lbrakk&gt;f1 ~f f2; f2 ~f f3\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt; f1 ~f f3\"<br>\n   and beTrn: \"\\&lt;lbrakk&gt;b1 ~b b2; b2 ~b b3\\&lt;rbrakk&gt;\\&lt;Longrightarrow&gt; b1 ~b b3\"</p>\n<p>The proof is by simultaneous induction on the first premise and<br>\ninversion on the second premise.  The first case (fe1) is solved by<br>\n\"force\"</p>\n<p>proof (induct rule: fooEq_barEq.inducts, force)</p>\n<p>consider the second case:</p>\n<p>case (fe2 b1a b2a)<br>\n have j0:\"F2 b2a ~f f3\"<br>\n   and j1:\"b1a ~b b2a\"<br>\n   and j2:\"b2a ~b b3 \\&lt;Longrightarrow&gt; b1a ~b b3\" by fact+</p>\n<p>This is clearly wrong; we need to generalize over f3 and b3 so that j2<br>\nis parametric in b3.  Try using \"arbitrary\":</p>\n<p>proof (induct arbitrary: f3 b3 rule: fooEq_barEq.inducts, force)<br>\n case (fe2 b1a b2a f3a)<br>\n have j0:\"F2 b2a ~f f3a\"<br>\n   and j1:\"b1a ~b b2a\"<br>\n   and j2:\"b2a ~b b3 \\&lt;Longrightarrow&gt; b1a ~b b3\" by fact+</p>\n<p>What happened?  The occurrence of b3 in j2 was not generalized<br>\nalthough a new variable \"f3a\" has appeared in j0.</p>\n<p>How can this proof be done?</p>\n<p>Thanks,<br>\nRandy</p>\n</blockquote>",
        "id": 294137628,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660844881
    }
]