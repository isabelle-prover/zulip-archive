[
    {
        "content": "<p>From: Ian Lynagh &lt;<a href=\"mailto:igloo@earth.li\">igloo@earth.li</a>&gt;<br>\nHi all,</p>\n<p>I'm stuck on a proof of<br>\n    lemma \"(principalType e = Some t) ==&gt; (STyping e t)\"<br>\n(details in attachment). I've managed to solve the EBool case with<br>\n    apply_end simp<br>\n    from \"STypingBool\"<br>\n    show \"!!b. STyping (EBool b) TBool\"<br>\n        apply simp .<br>\nbut I don't think this is a good proof: I'm sure using \"apply_end simp\"<br>\nis bad style, and I don't think I should be copy/pasting<br>\n\"!!b. STyping (EBool b) TBool\" from the proof state. Even \"apply simp\"<br>\nI'm not sure is good style.</p>\n<p>I've therefore tried to write a better proof for the EInt case, but got<br>\nnowhere. The attached script shows some of my meanderings.</p>\n<p>Has anyone got any hints, please?</p>\n<p>I'm also not sure what's going to happen when I get to a recursive case.<br>\nI suspect \"proof (cases e)\" is not sufficient for the recursive case,<br>\nbut \"proof (induct e)\" doesn't look like it's generating the right goal<br>\nfor the recursive case (as t doesn't vary), and<br>\n\"proof (induct rule: SExpr.induct)\" has the same problem. Again, can<br>\nanyone point me in the right direction please?</p>\n<p>Incidentally, in proof general, the \"Isabelle/Show me .../Facts\" menu<br>\nsays \"C-c C-a &lt;h&gt; &lt;f&gt;\" next to it, but after typing just \"ctrl-c ctrl-a h\"<br>\nemacs says \"C-c C-a h is undefined\". Any idea what's wrong?</p>\n<p>Thanks<br>\nIan<br>\n<a href=\"/user_uploads/14278/RZD8DCWYpWGnmMKcu_aDTbWv/q.thy\">q.thy</a></p>",
        "id": 294114538,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837864
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nlemma \"(principalType e = Some t) ==&gt; (STyping e t)\"<br>\napply (induct e arbitrary: t)<br>\napply (auto simp: STyping.intros split:option.splits SType.splits)<br>\ndone</p>\n<p>split: ... instructs auto (or simp) to split case expressions for<br>\ncertain types automatically.</p>\n<p>Tobias</p>\n<p>Ian Lynagh schrieb:</p>",
        "id": 294114568,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837873
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis looks like a problem of Proof General, and should go to <br>\n<a href=\"http://proofgeneral.inf.ed.ac.uk/trac/\">http://proofgeneral.inf.ed.ac.uk/trac/</a></p>\n<p>Since David Aspinall is working on the next major release PG 4.0 right <br>\nnow, it is especially important to report any remaining issues there.</p>\n<p>Makarius</p>",
        "id": 294114602,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837882
    },
    {
        "content": "<p>From: Ian Lynagh &lt;<a href=\"mailto:igloo@earth.li\">igloo@earth.li</a>&gt;<br>\nDone: <a href=\"http://proofgeneral.inf.ed.ac.uk/trac/ticket/337\">http://proofgeneral.inf.ed.ac.uk/trac/ticket/337</a></p>\n<p>Thanks<br>\nIan</p>",
        "id": 294114663,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837901
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nI reported it yesterday and latest tarball is already fixed.</p>",
        "id": 294114688,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837907
    },
    {
        "content": "<p>From: Ian Lynagh &lt;<a href=\"mailto:igloo@earth.li\">igloo@earth.li</a>&gt;<br>\nThanks, but this isn't the sort of proof I'm hoping to end up with.</p>\n<p>My hope is to have a proof that a Haskell programmer can read,<br>\nunderstand and ideally even adapt; i.e. I want a machine-checked proof,<br>\nrather than a machine proof. For example, if I add an IfThenElse<br>\nconstruct, then the proof now leaves me with an unsolved goal:</p>\n<p>goal (1 subgoal):</p>\n<ol>\n<li>!!e1 e2 e3 t aa ab.<br>\n       [| !!t. TBool = t ==&gt; STyping e1 TBool; !!t. aa = t ==&gt; STyping e2 t;<br>\n          !!t. ab = t ==&gt; STyping e3 t; principalType e1 = Some TBool;<br>\n          principalType e2 = Some aa; principalType e3 = Some ab;<br>\n          (if aa = ab then Some aa else None) = Some t |]<br>\n       ==&gt; STyping (EIfThenElse e1 e2 e3) t</li>\n</ol>\n<p>for which the solution is not clear, because the proof is opaque to<br>\nnon-Isabellers.</p>\n<p>My understanding was that Isar is more like coq's C-zar (or more<br>\naccurately, I guess, C-zar is like Isar). With C-zar I am optimistic<br>\nthat readable, and not /too/ verbose, proofs would be possible.<br>\nUnfortunately, due to C-zar bugs, writing the proofs is not currently<br>\npossible, and C-zar seems to be largely dead, but the beginning of a<br>\nproof looks like this:</p>\n<p>Lemma typingIsPrincipalType : forall (e : SExpr)<br>\n                                         (t : SType)<br>\n                                         (typing : STyping e t),<br>\n                                  principalType e = Some t.<br>\n    proof.<br>\n        let e, t be such that typing : (STyping e t).<br>\n        per induction on typing.<br>\n            suppose it is (STypingBool b).<br>\n                hence thesis by principalType.<br>\n            suppose it is (STypingInt n).<br>\n                hence thesis by principalType.</p>\n<p>Thanks<br>\nIan</p>",
        "id": 294114852,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837950
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Thu, 19 Aug 2010, Ian Lynagh wrote:</p>\n<blockquote>\n<p>On Tue, Aug 17, 2010 at 10:07:53AM +0200, Tobias Nipkow wrote:</p>\n<blockquote>\n<p>lemma \"(principalType e = Some t) ==&gt; (STyping e t)\"<br>\napply (induct e arbitrary: t)<br>\napply (auto simp: STyping.intros split:option.splits SType.splits)<br>\ndone</p>\n<p>split: ... instructs auto (or simp) to split case expressions for<br>\ncertain types automatically.</p>\n</blockquote>\n<p>Thanks, but this isn't the sort of proof I'm hoping to end up with.</p>\n<p>My hope is to have a proof that a Haskell programmer can read, <br>\nunderstand and ideally even adapt; i.e. I want a machine-checked proof, <br>\nrather than a machine proof. For example, if I add an IfThenElse <br>\nconstruct, then the proof now leaves me with an unsolved goal:</p>\n</blockquote>\n<p>This is exactly the purpose of structured Isar proofs: you write down the <br>\nreasoning in a way that is usable both for the machine and the user -- and <br>\nalso maintainable in the end.  Getting started with Isar proofs is a bit <br>\nchallanging, because the interaction model of Proof General is working <br>\nagainst it.  But once you have some proof working, it is easy to extend, <br>\ngeneralize, beatify etc.</p>\n<p>Included is my result of playing a little with your theory.  I have <br>\nstarted with the 2-liner by Tobias and tried to reconstruct the reasing <br>\nbehind it.  (One could rightly ask, if the system could be more helpful to <br>\nconstruct this reasoning in the first place).</p>\n<p>In the attached Simple.thy there are 3 Isar proofs of increasing detail.</p>\n<p>The smallest possible Isar proof is \"by (induct ...) (auto ...)\" -- this <br>\ndouble method invocation (initial followed by terminal one) marks the <br>\ntransition from apply scripts to Isar proofs.  (BTW, it is a common <br>\nmistake to put a \",\" for sequential method composition in between.)</p>\n<p>lemma \"principalType e = Some t ==&gt; STyping e t\"<br>\n     by (induct e arbitrary: t)<br>\n       (auto simp: STyping.intros split: option.splits SType.splits)</p>\n<p>The second proof merely expands the outermost induction skeleton, and <br>\n\"optimizes\" the terminal justifications, to narrow down the automation by <br>\nreducing the given facts and tools in question, e.g. plain \"simp\" instead <br>\nof \"auto\" (which is relatively strong).</p>\n<p>lemma \"principalType e = Some t ==&gt; STyping e t\"<br>\n   proof (induct e arbitrary: t)<br>\n     case (EBool b)<br>\n     then show ?case<br>\n       by (simp add: STyping.intros)<br>\n   next<br>\n     case (EInt n)<br>\n     then show ?case<br>\n       by (simp add: STyping.intros)<br>\n   next<br>\n     case (EGreaterThan lhs rhs)<br>\n     then show ?case<br>\n       by (auto simp: STyping.intros split: option.splits SType.splits)<br>\n   qed</p>\n<p>The last version expands on the induction cases a little:</p>\n<p>lemma \"principalType e = Some t ==&gt; STyping e t\"<br>\nproof (induct e arbitrary: t)<br>\n   case (EBool b)<br>\n   then have \"t = TBool\" by simp<br>\n   also have \"STyping (EBool b) TBool\" ..<br>\n   finally show \"STyping (EBool b) t\" .<br>\nnext<br>\n   case (EInt n)<br>\n   then have \"t = TInt\" by simp<br>\n   also have \"STyping (EInt n) TInt\" ..<br>\n   finally show \"STyping (EInt n) t\" .<br>\nnext<br>\n   case (EGreaterThan lhs rhs)<br>\n   have *: \"principalType (EGreaterThan lhs rhs) = Some t\" by fact<br>\n   show \"STyping (EGreaterThan lhs rhs) t\"<br>\n   proof (cases t)<br>\n     case TBool<br>\n     have \"STyping lhs TInt\"<br>\n     proof (rule EGreaterThan.hyps)<br>\n       from TBool and * show \"principalType lhs = Some TInt\"<br>\n         by (simp split: option.splits SType.splits)<br>\n     qed<br>\n     moreover<br>\n     have \"STyping rhs TInt\"<br>\n     proof (rule EGreaterThan.hyps)<br>\n       from TBool and * show \"principalType rhs = Some TInt\"<br>\n         by (simp split: option.splits SType.splits)<br>\n     qed<br>\n     ultimately have \"STyping (EGreaterThan lhs rhs) TBool\" ..<br>\n     then show ?thesis by (simp only: TBool)<br>\n   next<br>\n     case TInt<br>\n     with * have False by (simp split: option.splits SType.splits)<br>\n     then show ?thesis ..<br>\n   qed<br>\nqed</p>\n<p>There are many possibilities here.  Of course, I did not write this down <br>\non the spot, although it is constructed in a somewhat canonical way <br>\nwithout two much elaboration.</p>\n<p>To explore a certain situation with various facts being locally available, <br>\nyou can either use plain rule composition, e.g.</p>\n<p>thm r1 [OF t2]</p>\n<p>or experiment with the effect of simplification, e.g.</p>\n<p>from my_facts have XXX apply simp</p>\n<p>Here the \"XXX\" is a literal variable, which the simplifier usually keeps <br>\nunchanged, while the concrete my_facts are normalized.  This usually gives <br>\nimportant clues about proper concrete conclusions:</p>\n<p>from my_facts have my_prop by simp</p>\n<p>This forward simplification in the context of the Isar text works better <br>\nthan tinkering with 'apply_end' on goal states.</p>\n<blockquote>\n<p>My understanding was that Isar is more like coq's C-zar (or more <br>\naccurately, I guess, C-zar is like Isar). With C-zar I am optimistic <br>\nthat readable, and not /too/ verbose, proofs would be possible. <br>\nUnfortunately, due to C-zar bugs, writing the proofs is not currently <br>\npossible, and C-zar seems to be largely dead, ...</p>\n</blockquote>\n<p>In fact, C-zar is more like te \"Mizar mode for HOL\" by John Harrison from <br>\n1995, and it seems to share its \"experimental\" nature.  I know myself only <br>\ntoo well how difficult it is to get beyond that stage.</p>\n<p>Makarius<br>\n<a href=\"/user_uploads/14278/Z72_n6wrSrzEddTRsusEXYhs/Simple.thy\">Simple.thy</a></p>",
        "id": 294114971,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660837993
    },
    {
        "content": "<p>From: Ian Lynagh &lt;<a href=\"mailto:igloo@earth.li\">igloo@earth.li</a>&gt;<br>\nFantastic, thanks! I'll have a play with it.</p>\n<p>Thanks<br>\nIan</p>",
        "id": 294114995,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660838005
    }
]