[
    {
        "content": "<p>From: Revantha Ramanayake &lt;<a href=\"mailto:revantha@rsise.anu.edu.au\">revantha@rsise.anu.edu.au</a>&gt;<br>\nHi.</p>\n<p>Is the subset relation defined in the obvious way for multisets? I.e. <br>\nhow do I write<br>\nN is a sub-multiset of M.</p>\n<p>I know that I can define: N is a sub-multiset of M as (ALL b. count N b <br>\n&lt;= count M b)<br>\nbut then I will have to prove a host of properties for the sub-multiset <br>\nrelation.<br>\nI was wondering if the relation is already defined somewhere?</p>\n<p>Thanks,</p>\n<p>Revantha.</p>",
        "id": 294050248,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819127
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nMultiset.thy defines the relation mset_le as you describe.</p>\n<p>It also overloads &lt;= with the much stronger multiset ordering, which  <br>\nis described in a classic paper:</p>\n<p>Nachum Dershowitz, Zohar Manna: Proving Termination with Multiset  <br>\nOrderings. Commun. ACM 22(8): 465-476 (1979)</p>\n<p>Larry</p>",
        "id": 294050487,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819243
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:peter.lammich@uni-muenster.de\">peter.lammich@uni-muenster.de</a>&gt;<br>\nI use the following additional lemmas when working with mset_le:</p>\n<p>subsubsection {* Pointwise ordering *}<br>\n  interpretation mset_le: partial_order[\"\\&lt;lambda&gt;x y. (x\\&lt;le&gt;#y)\"] by<br>\n(auto intro: partial_order.intro mset_le_refl mset_le_antisym mset_le_trans)</p>\n<p>lemma mset_empty_minimal[simp, intro!]: \"{#} \\&lt;le&gt;# c\" by (unfold<br>\nmset_le_def, auto)<br>\n  lemma mset_empty_least[simp]: \"c \\&lt;le&gt;# {#} = (c={#})\" by (unfold<br>\nmset_le_def, auto iff add: multiset_eq_conv_count_eq)<br>\n  lemma mset_empty_leastI[intro!]: \"c={#} \\&lt;Longrightarrow&gt; c \\&lt;le&gt;#<br>\n{#}\" by (simp only: mset_empty_least)</p>\n<p>lemma mset_le_add_left: \"a\\&lt;le&gt;#b \\&lt;Longrightarrow&gt; a\\&lt;le&gt;#b+c\" using<br>\nmset_le_mono_add[of a b \"{#}\" c, simplified] .<br>\n  lemma mset_le_add_right: \"a\\&lt;le&gt;#b \\&lt;Longrightarrow&gt; a\\&lt;le&gt;#c+b\" using<br>\nmset_le_add_left by (auto simp add: union_commute)<br>\n  lemmas mset_le_add = mset_le_add_left mset_le_add_right</p>\n<p>lemma mset_le_single_conv[simp]: \"({#e#}\\&lt;le&gt;#M) = (e:#M)\" by (unfold<br>\nmset_le_def) auto</p>\n<p>lemma mset_le_trans_elem: \"\\&lt;lbrakk&gt;e :# c; c \\&lt;le&gt;# c'\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; e :# c'\" using mset_le_trans[of \"{#e#}\" c c',<br>\nsimplified] by assumption</p>\n<p>lemma mset_le_subtract: \"A\\&lt;le&gt;#B \\&lt;Longrightarrow&gt; A-C \\&lt;le&gt;# B-C\"<br>\n    apply (unfold mset_le_def)<br>\n    apply auto<br>\n    apply (subgoal_tac \"count A a \\&lt;le&gt; count B a\")<br>\n    apply arith<br>\n    apply simp<br>\n    done</p>\n<p>lemma mset_le_subtract_left: \"A+B \\&lt;le&gt;# V+W \\&lt;Longrightarrow&gt; B<br>\n\\&lt;le&gt;# V+W-A\" by (auto dest: mset_le_subtract[of \"A+B\" \"V+W\" \"A\"])<br>\n  lemma mset_le_subtract_right: \"A+B \\&lt;le&gt;# V+W \\&lt;Longrightarrow&gt; A<br>\n\\&lt;le&gt;# V+W-B\" by (auto dest: mset_le_subtract[of \"A+B\" \"V+W\" \"B\"])</p>\n<p>lemma mset_2dist2_cases:<br>\n    assumes A: \"{#a#}+{#b#} \\&lt;le&gt;# A+B\"<br>\n    assumes CASES: \"{#a#}+{#b#} \\&lt;le&gt;# A \\&lt;Longrightarrow&gt; P\"<br>\n\"{#a#}+{#b#} \\&lt;le&gt;# B \\&lt;Longrightarrow&gt; P\" \"\\&lt;lbrakk&gt;a :# A; b :#<br>\nB\\&lt;rbrakk&gt; \\&lt;Longrightarrow&gt; P\" \"\\&lt;lbrakk&gt;a :# B; b :# A\\&lt;rbrakk&gt;<br>\n\\&lt;Longrightarrow&gt; P\"<br>\n    shows \"P\"<br>\n  proof -<br>\n    { assume C: \"a :# A\" \"b :# A-{#a#}\"<br>\n      with mset_le_mono_add[of \"{#a#}\" \"{#a#}\" \"{#b#}\" \"A-{#a#}\"] have<br>\n\"{#a#}+{#b#} \\&lt;le&gt;# A\" by auto<br>\n    } moreover {<br>\n      assume C: \"a :# A\" \"\\&lt;not&gt; (b :# A-{#a#})\"<br>\n      with A have \"b:#B\" by (unfold mset_le_def) (auto split: split_if_asm)<br>\n    } moreover {<br>\n      assume C: \"\\&lt;not&gt; (a :# A)\" \"b :# B-{#a#}\"<br>\n      with A have \"a :# B\" by (unfold mset_le_def) (auto split:<br>\nsplit_if_asm)<br>\n      with C mset_le_mono_add[of \"{#a#}\" \"{#a#}\" \"{#b#}\" \"B-{#a#}\"] have<br>\n\"{#a#}+{#b#} \\&lt;le&gt;# B\" by auto<br>\n    } moreover {<br>\n      assume C: \"\\&lt;not&gt; (a :# A)\" \"\\&lt;not&gt; (b :# B-{#a#})\"<br>\n      with A have \"a:#B \\&lt;and&gt; b:#A\" by (unfold mset_le_def) (auto<br>\nsplit: split_if_asm)<br>\n    } ultimately show P using CASES by blast<br>\n  qed</p>\n<p>lemma mset_union_subset: \"A+B \\&lt;le&gt;# C \\&lt;Longrightarrow&gt; A\\&lt;le&gt;#C<br>\n\\&lt;and&gt; B\\&lt;le&gt;# C\"<br>\n    apply (unfold mset_le_def)<br>\n    apply auto<br>\n    apply (subgoal_tac \"count A a + count B a \\&lt;le&gt; count C a\", arith,<br>\nsimp)+<br>\n    done</p>\n<p>lemma mset_union_subset_s: \"{#a#}+B \\&lt;le&gt;# C \\&lt;Longrightarrow&gt; a :# C<br>\n\\&lt;and&gt; B \\&lt;le&gt;# C\" by (auto dest: mset_union_subset)</p>\n<p>maybe that helps</p>\n<p>-- Peter</p>",
        "id": 294050495,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660819250
    }
]