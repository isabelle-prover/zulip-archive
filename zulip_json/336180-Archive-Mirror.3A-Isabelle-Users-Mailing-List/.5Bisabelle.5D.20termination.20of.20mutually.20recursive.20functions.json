[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello,</p>\n<p>I have the following recursive function definitions:</p>\n<p>consts const_a:: \"'a\"</p>\n<p>function<br>\n   A_fun :: \"nat =&gt; 'b\"<br>\n   and B_fun :: \"int =&gt; 'd\"<br>\n   and C_fun :: \"bool =&gt; 'f\"<br>\n   and D_fun :: \"bool =&gt; 'g\"<br>\n   and E_fun :: \"nat =&gt; 'j\"<br>\n   where<br>\n   \"A_fun x = const_a\" |<br>\n   \"B_fun y = const_a\" |<br>\n   \"C_fun y = const_a\" |<br>\n   \"D_fun y = const_a\" |<br>\n   \"E_fun y = const_a\"</p>\n<p>apply pat_completeness<br>\nby auto<br>\ntermination<br>\n   apply (relation \"test_rel\")<br>\n   sorry</p>\n<p>function<br>\n   A_f :: \"nat =&gt; 'b\"<br>\n   and B_f :: \"int =&gt; 'd\"<br>\n   and C_f :: \"bool =&gt; 'f\"<br>\n   where<br>\n   \"A_f x = const_a\" |<br>\n   \"B_f y = const_a\" |<br>\n   \"C_f y = const_a\"</p>\n<p>apply pat_completeness<br>\nby auto<br>\ntermination<br>\n   apply (relation \"test_rel\")<br>\n   sorry</p>\n<p>The first collection of functions needs a termination relation of the type<br>\n     (((nat + int) + bool + bool + nat) * ((nat + int) + bool + bool + <br>\nnat)) set<br>\nand the second collection  needs a termination relation of the type<br>\n((nat + int + bool) * (nat + int + bool)) set</p>\n<p>The question is why in the first case the first two types (nat and int) <br>\nare grouped<br>\ntogether  and in the second case they are not? What is the general rule<br>\nfor type of the termination relation?</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294143830,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846800
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Wed, Sep 7, 2011 at 6:17 AM, Viorel Preoteasa<br>\n&lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt; wrote:</p>\n<blockquote>\n<p>consts const_a:: \"'a\"</p>\n<p>function<br>\n A_fun :: \"nat =&gt; 'b\"<br>\n and B_fun :: \"int =&gt; 'd\"<br>\n and C_fun :: \"bool =&gt; 'f\"<br>\n and D_fun :: \"bool =&gt; 'g\"<br>\n and E_fun :: \"nat =&gt; 'j\"<br>\n where<br>\n \"A_fun x = const_a\" |<br>\n \"B_fun y = const_a\" |<br>\n \"C_fun y = const_a\" |<br>\n \"D_fun y = const_a\" |<br>\n \"E_fun y = const_a\"<br>\n[...]<br>\nThe first collection of functions needs a termination relation of the type<br>\n   (((nat + int) + bool + bool + nat) * ((nat + int) + bool + bool + nat))<br>\nset<br>\nand the second collection  needs a termination relation of the type<br>\n((nat + int + bool) * (nat + int + bool)) set</p>\n<p>The question is why in the first case the first two types (nat and int) are<br>\ngrouped<br>\ntogether  and in the second case they are not? What is the general rule<br>\nfor type of the termination relation?</p>\n</blockquote>\n<p>It seems that the \"+\" type constructors are grouped in such a way as<br>\nto make a balanced binary tree. (This is much more evident if you go<br>\nto 8 or 16 functions, which gives you a perfectly balanced tree of sum<br>\ntypes.) I suppose there must be an efficiency reason for doing this.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294143892,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660846806
    }
]