[
    {
        "content": "<p>From: Salomon Sickert &lt;<a href=\"mailto:sickert@in.tum.de\">sickert@in.tum.de</a>&gt;<br>\nDear transfer / lifting / quotient-experts,</p>\n<p>for my project I've started to work with the new quotient package and <br>\nnow I'm stuck with some<br>\n(hopefully easy to solve) problems.</p>\n<p>To keep everything small and compact I created a little example to <br>\nillustrate my problems.<br>\nIn this example, all trees are grouped by their size and then the <br>\n\"increase\" function is lifted<br>\nfrom the raw to the abstract type.</p>\n<hr>\n<p>theory QuotientTypeTests<br>\n   imports Main<br>\nbegin</p>\n<p>datatype tree = leaf \"nat\"<br>\n               | node \"tree\" \"tree\"</p>\n<p>(*<br>\n   Question 1:</p>\n<p>If I try to generalize nat to 'a, I get the following error from the <br>\nquotient_type command:</p>\n<p>Generation of a parametrized correspondence relation failed.<br>\n     Reason:<br>\n       No relator for the type \"QuotientTypeTests.tree\"<br>\n         found.</p>\n<p>Looking at the quotient examples didn't help me to figure out, what <br>\nto prove or define to fix this.<br>\n   What do I have to do? Or can I simply ignore it?<br>\n*)</p>\n<p>definition tree_equivp :: \"tree ⇒ tree ⇒ bool\" (infix \"∼\" 60)<br>\nwhere<br>\n   \"t⇩1 ∼ t⇩2 ≡ size t⇩1 = size t⇩2\"</p>\n<p>lemma tree_equiv_reflp:<br>\n   \"reflp (op ∼)\"<br>\n   by (simp add: tree_equivp_def reflp_def)</p>\n<p>lemma tree_equiv_symp:<br>\n   \"symp (op ∼)\"<br>\n   by (simp add: tree_equivp_def symp_def)</p>\n<p>lemma tree_equiv_transp:<br>\n   \"transp (op ∼)\"<br>\n   by (simp add: tree_equivp_def transp_def)</p>\n<p>lemma tree_equivp:<br>\n   \"equivp (op ∼)\"<br>\n   by (auto intro: equivpI simp add: tree_equiv_reflp tree_equiv_symp <br>\ntree_equiv_transp)</p>\n<p>fun increase :: \"tree ⇒ tree\"<br>\nwhere<br>\n   \"increase (leaf a) = node (leaf a) (leaf 0)\"<br>\n| \"increase (node t1 t2) = node (node t1 t2) (leaf 0)\"</p>\n<p>lemma increase_correct:<br>\n   \"size (increase t) = (Suc (size t))\"<br>\n   by (induction t) simp+</p>\n<p>lemma increase_respects_tree_equivp:<br>\n   \"t1 ∼ t2 ⟹ increase t1 ∼ increase t2\"<br>\n   unfolding tree_equivp_def using increase_correct by simp</p>\n<p>quotient_type same_size_tree = \"tree\" / \"op ∼\"<br>\n   morphisms Rep Abs<br>\n   by (simp add: tree_equivp)</p>\n<p>lemma \"size (leaf 1) = 0\"<br>\n   by eval</p>\n<p>lemma \"size (Rep (Abs (leaf 1))) = 0\"<br>\n   nitpick<br>\n   by (metis Quotient3_rep_abs Quotient3_same_size_tree tree.size(3) <br>\ntree_equivp_def)</p>\n<p>(*<br>\n   Question 2:</p>\n<p>Why does nitpick report a counterexample (Empty assignment),<br>\n   while sledgehammer finds a proof?<br>\n*)</p>\n<p>lift_definition increase_abs :: \"same_size_tree ⇒ same_size_tree\" is <br>\nincrease<br>\n   by (simp add: increase_respects_tree_equivp)</p>\n<p>value \"increase_abs (Abs (leaf 3))\"</p>\n<p>(* Great, this works! *)</p>\n<p>value \"Abs (leaf 0) = Abs (leaf 1)\"</p>\n<p>(*<br>\n   Question 3:</p>\n<p>The command fails with:</p>\n<p>Wellsortedness error:<br>\n     Type same_size_tree not of sort equal<br>\n     No type arity same_size_tree :: equal</p>\n<p>Is there something I can do about this?<br>\n   Will this cause issues, if I want to generate code?<br>\n*)</p>\n<hr>\n<p>Best,<br>\nSalomon</p>",
        "id": 294279467,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919857
    },
    {
        "content": "<p>From: Ondřej Kunčar &lt;<a href=\"mailto:kuncar@in.tum.de\">kuncar@in.tum.de</a>&gt;<br>\nHi Salomon.</p>\n<p>First of all, it's not an error but a warning. You can ignore it if you <br>\ndon't want to nest your types during lifting (and transfer), for <br>\nexample, when you don't want to work with \"'a tree tree\". If you want to <br>\nwork with such types (or want to remove the warning for esthetic <br>\nreasons), then you have to provide a certain structure to your type. See <br>\nfor example HOL/Lifting_Option: in the most general case, you need all <br>\nthe corresponding theorems from the section \"Relator and predicator <br>\nproperties\" and \"Quotient theorem for the Lifting package\".</p>\n<p>Note that in the coming release - Isabelle 2014 (released hopefully this <br>\nsummer) -  all these theorems are proved (and registred) automatically <br>\nif you define your type with datatype_new.</p>\n<p>The other two question don't have probably much to do with Lifting and<br>\nTransfer. Mayber more knowledgeable experts can comment on them.</p>\n<p>Best,<br>\nOndrej Kuncar</p>",
        "id": 294279475,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919864
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Salomon,</p>\n<p>Equality is executable only on types with an instance of the equal type class (similar to <br>\nHaskell's Eq type class). The command datatype automatically makes new types instances of <br>\nequal. Since same_size_tree has been defined by other means (the quotient package), you <br>\nhave to do the instantiation manually. Something along the following lines should work <br>\n(not tested!).</p>\n<p>instantiation same_size_tree :: equal begin<br>\nlift_definition equal_same_size_tree :: \"tree =&gt; tree =&gt; bool\"<br>\n   is \"%t1 t2. size t1 = size t2\"<br>\n   &lt;proof&gt;</p>\n<p>instance by intro_classes(transfer, simp add: tree_equivp_def)<br>\nend</p>\n<p>Andreas</p>\n<p>PS: I leave the Nitpick question to nitpick experts.</p>",
        "id": 294279492,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660919869
    }
]