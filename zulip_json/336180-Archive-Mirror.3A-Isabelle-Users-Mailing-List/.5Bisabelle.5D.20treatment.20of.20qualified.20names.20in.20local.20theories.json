[
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nWhy can't I define two constants with the same base-name (but<br>\ndifferent qualifiers) in the same local theory? The following code,<br>\nwhich tries to define \"<a href=\"http://one.foo\">one.foo</a> == True\" and \"<a href=\"http://two.foo\">two.foo</a> == False\", gives<br>\na \"Duplicate fixed variable(s)\" error message. It works just fine if I<br>\nsplit it into two separate local_setup commands, however.</p>\n<p>local_setup {*<br>\nfn lthy =&gt;<br>\n  let<br>\n    val qual = Binding.qualify true<br>\n    val ((t1, (s1, thm1)), lthy) = lthy |&gt;<br>\n      Local_Theory.define<br>\n        ((qual \"one\" @{binding foo}, NoSyn),<br>\n         ((qual \"one\" @{binding foo_def}, []), @{term \"True\"}))<br>\n    val ((t2, (s2, thm2)), lthy) = lthy |&gt;<br>\n      Local_Theory.define<br>\n        ((qual \"two\" @{binding foo}, NoSyn),<br>\n         ((qual \"two\" @{binding foo_def}, []), @{term \"False\"}))<br>\n  in<br>\n    lthy<br>\n  end<br>\n*}</p>\n<p>I should explain why I want to do this: The reason is that I (along<br>\nwith a few other people) am working on a tool for importing Haskell<br>\ndatatype definitions into Isabelle. We are using a form of \"soft<br>\ntyping\", so type constructors are defined as Isabelle constants, along<br>\nwith the data constructors. The problem is that in Haskell, type names<br>\nand constructor names are in separate name spaces, and it is quite<br>\ncommon for a Haskell type and its data constructor to have the same<br>\nname, e.g.</p>\n<p>data MyBool = MyBool Bool</p>\n<p>I want to add qualifiers to distinguish these in Isabelle, something<br>\nlike \"type.MyBool\" and \"term.MyBool\". However, since the<br>\nimplementation of the tool uses local theories (which as I understand<br>\nis the recommended programming practice), it runs into the \"Duplicate<br>\nfixed variable\" error I mentioned above.</p>\n<p>Will local theories in a later version of Isabelle be able to use<br>\nqualifiers to distinguish names?</p>\n<p>While I am still using Isabelle2011, is there a workaround that will<br>\nlet me avoid the error, while still generating the top-level qualified<br>\nconstant names that I want? Or will I have to \"un-localize\" the tool<br>\nso that it uses top-level theories directly instead of local theories?</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294138847,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845176
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Wed, 29 Jun 2011, Brian Huffman wrote:</p>\n<blockquote>\n<p>Why can't I define two constants with the same base-name (but different <br>\nqualifiers) in the same local theory? The following code, which tries to <br>\ndefine \"<a href=\"http://one.foo\">one.foo</a> == True\" and \"<a href=\"http://two.foo\">two.foo</a> == False\", gives a \"Duplicate <br>\nfixed variable(s)\" error message. It works just fine if I split it into <br>\ntwo separate local_setup commands, however.</p>\n<p>local_setup {*<br>\nfn lthy =&gt;<br>\n let<br>\n   val qual = Binding.qualify true<br>\n   val ((t1, (s1, thm1)), lthy) = lthy |&gt;<br>\n     Local_Theory.define<br>\n       ((qual \"one\" @{binding foo}, NoSyn),<br>\n        ((qual \"one\" @{binding foo_def}, []), @{term \"True\"}))<br>\n   val ((t2, (s2, thm2)), lthy) = lthy |&gt;<br>\n     Local_Theory.define<br>\n       ((qual \"two\" @{binding foo}, NoSyn),<br>\n        ((qual \"two\" @{binding foo_def}, []), @{term \"False\"}))<br>\n in<br>\n   lthy<br>\n end<br>\n*}</p>\n</blockquote>\n<p>This is according to the specifications.  The auxiliary context of the <br>\nlocal theory target presents newly defined terms as fixed variables, but <br>\nthese cannot be qualified.  (There are no kernel checks for that for <br>\nperformance reasons, but the overall system will make problems when the <br>\nprinciple \"consts: qualified, fixes: unqualified\" is violated.)</p>\n<p>The restriction holds only as long as the aux. context is active, i.e. you <br>\ncan introduce artificial boundaries as workaround, using <br>\nLocal_Theory.init/exit or reinit operations in a way that I cannot tell on <br>\nthe spot, without some study of the current state of the sources.</p>\n<blockquote>\n<p>data MyBool = MyBool Bool</p>\n<p>I want to add qualifiers to distinguish these in Isabelle, something <br>\nlike \"type.MyBool\" and \"term.MyBool\".</p>\n</blockquote>\n<p>It is probably easier to avoid this clash by using the conventional <br>\nIsabelle naming scheme in such situations: terms are called \"foo\", types <br>\nare called \"foo_type\".  A suffix will always be orthogonal to name spaces <br>\nprefixes and qualifiers.</p>\n<p>If you do not want to present it like that to the end user, you can <br>\nadditionally augment the global const name space afterwards using <br>\nSign.const_alias etc. -- this looks to be the least intrusive workaround <br>\nat the moment.</p>\n<blockquote>\n<p>Will local theories in a later version of Isabelle be able to use <br>\nqualifiers to distinguish names?</p>\n</blockquote>\n<p>Depends if I manage to localize HOL/datatype and record without it. <br>\nRecords have their own small qualifiers with potential duplication of base <br>\nnames, but it is possible that one can somehow avoid getting into the same <br>\ntrouble as above.  If not, I not to devise some tricks to overcome the <br>\nlimitation somehow.</p>\n<blockquote>\n<p>While I am still using Isabelle2011, is there a workaround that will let <br>\nme avoid the error, while still generating the top-level qualified <br>\nconstant names that I want? Or will I have to \"un-localize\" the tool so <br>\nthat it uses top-level theories directly instead of local theories?</p>\n</blockquote>\n<p>This is also possible, see Inductive.add_inductive_global, for example. <br>\n(Operations called \"global\" are generally considered a bit fashioned, <br>\npotentially being discontinued when localization has advanced further.)</p>\n<p>Makarius</p>",
        "id": 294138946,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845200
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nThanks for the suggestion; I will have a closer look at the alias<br>\noperations on name spaces. My original plan was to maintain separate<br>\nname_space values for my embedded types and terms, with syntax rules<br>\nthat would select the appropriate one based on context (similar to the<br>\nsystem currently used for parsing/printing Isabelle type expressions).<br>\nHowever, I was under the (mistaken) impression that<br>\nName_Space.intern/extern were only able to fill in/hide qualifiers; I<br>\ndidn't know about the support for aliases. It looks like I should be<br>\nable to use aliases with name suffixes to get everything to work with<br>\nlocal theories.</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294139067,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660845231
    }
]