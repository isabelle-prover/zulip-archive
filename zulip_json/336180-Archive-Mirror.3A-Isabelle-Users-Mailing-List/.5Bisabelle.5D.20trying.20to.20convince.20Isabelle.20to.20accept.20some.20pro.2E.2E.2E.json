[
    {
        "content": "<p>From: Andrei Popescu &lt;<a href=\"mailto:uuomul@yahoo.com\">uuomul@yahoo.com</a>&gt;<br>\nHello, </p>\n<p>I have proved the consistency of specialized theorem prover <br>\nin Isabelle, but when I am trying to use it, I find serious problems <br>\nwith \"executing\"/simplifying some functions that initally looked to me <br>\nvery amenable to simplification.&nbsp; </p>\n<p>Particularly, I have the following problems: <br>\n-- Isabelle won't simplify underneath&nbsp; existential quantifiers, and would loop <br>\nif I try to simplify after replacing the existentially quantified variables <br>\nwith schematic variables (via existential introduction) or if try <br>\nto enforce an \"under-exists\" simplification rule<br>\n-- in cases when simplification does<br>\n what I wish (using auto<br>\n for some <br>\ntrivial FOL<br>\n arrangements to help<br>\n simplification), it takes too much time (I think <br>\nauto tries to hard) </p>\n<p>I have tried to capture these problems with the following small example, <br>\nwhere: <br>\n-- a term is either a basic term \"Bas n\" or a compound term \"Cpd Ts\"; <br>\n-- a rule deduces terms (conclusions) from lists of terms (hypotheses); <br>\n-- there are only five rules: R1, R2, R1', R1'', R2'; <br>\n-- the function mdr mathes a term against these rules constructing <br>\n&nbsp;&nbsp; backwards a proof subject to some constraints (that the term is the <br>\n&nbsp;&nbsp; conclusion of the rule and its immediate <br>\n&nbsp;&nbsp; subterms are less or equal to (le) the hypotheses of the rule -- I <br>\n&nbsp;&nbsp; have added this complication with \"le\" so that I do not have <br>\n&nbsp;&nbsp; unique proofs). </p>\n<p>Here is the theory (I am also attaching it as a thy file):&nbsp; </p>\n<hr>\n<p>datatype trm = Bas nat | Cpd \"trm list\"</p>\n<p>record rule =</p>\n<p>&nbsp; hyps :: \"trm list\"<br>\n&nbsp; cnc :: \"trm\" </p>\n<p>constdefs<br>\nR1 :: \"rule\"&nbsp; <br>\n\"R1 == (| hyps = [Bas 1, Cpd[Bas 2, Bas 3]], <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; cnc = Cpd [Bas 1, Cpd[Bas 2, Bas 3]] |)\"<br>\nR2 :: \"rule\"&nbsp; <br>\n\"R2 == (|hyps = [Bas 2, Cpd[Bas 3, Bas 4]], <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnc = Cpd [Bas 1, Cpd[Bas 2, Bas 3]] |)\"&nbsp; <br>\nR1' :: \"rule\"&nbsp; <br>\n\"R1' == (|hyps = [Bas 2, Bas 3], <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; cnc = Cpd [Bas 2, Bas 3] |)\"<br>\nR1'' :: \"rule\"&nbsp; <br>\n\"R1'' == (|hyps = [Bas 3, Bas 4], <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; cnc = Cpd [Bas 2, Bas 3] |)\"<br>\nR2' :: \"rule\"&nbsp; <br>\n\"R2' == (|hyps = [Bas 4, Bas 5], <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; cnc = Cpd [Bas 3, Bas 4] |)\"</p>\n<p>constdefs Rls :: \"rule<br>\n set\"<br>\n\"Rls == {R1, R2, R1', R1'', R2'}\"</p>\n<p>consts le :: \"trm =&gt; rm =&gt; bool\"<br>\naxioms le_simps_Bas:<br>\n\"ge (Bas n) T' = True\"</p>\n<p>axioms le_simps_Ind: <br>\n\"le (Cpd Ts) T' = <br>\n&nbsp; (case T' of Bas n' =&gt; False <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |Cpd Ts' =&gt; length Ts = length Ts' /\\ <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ALL i &lt; length Ts. le (Ts!i) (Ts'!i)))\"<br>\nlemmas le_simps = le_simps_Bas le_simps_Ind<br>\ndeclare le_simps [simp]</p>\n<p>lemmas rules_defs = Rls_def R1_def R2_def R1'_def R1''_def R2'_def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>\ndeclare rules_defs [simp]<br>\n&nbsp;<br>\nconsts mdr :: \"trm =&gt; rule set\" <br>\naxioms mdr_simps_Bas: <br>\n\"mdr (Bas n) = {(| hyps = [Bas n], cnc = Bas n<br>\n |)}\" </p>\n<p>axioms mdr_simps_Cpd: <br>\n\"mdr (Cpd Ts) = <br>\n&nbsp; {(|hyps = concat (map hyps drls), <br>\n&nbsp;&nbsp;&nbsp;&nbsp; cnc = Cpd Ts |) <br>\n&nbsp;&nbsp; |rl drls.&nbsp; <br>\n&nbsp;&nbsp;&nbsp; rl: Rls /\\ <br>\n&nbsp;&nbsp;&nbsp; cnc rl = Cpd Ts /\\ <br>\n&nbsp;&nbsp;&nbsp; length (hyps rl) = length Ts /\\ <br>\n&nbsp;&nbsp;&nbsp; length drls = length Ts /\\<br>\n&nbsp;&nbsp;&nbsp; (ALL i &lt; length Ts. le (Ts ! i) (hyps rl ! i) /\\<br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; drls!i : mdr (hyps rl ! i))}\"</p>\n<p>lemmas mdr_simps = mdr_simps_Bas mdr_simps_Cpd<br>\ndeclare mdr_simps [simp]</p>\n<hr>\n<p>I would like to be able to execute mdr, so that I always obtain, for example, <br>\ninstead <br>\nof \"x : mdr(Cpd [Bas 1, Cpd[Bas 2, Bas 3]])\", a disjunction of 6 facts <br>\n(according to the six<br>\n possible decompositions), where, for example, one of the dijuncts would be </p>\n<p>\"x = (| hyps = [Bas (Suc 0), Bas 2, Bas 3], <br>\n&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; cnc = Cpd [Bas (Suc 0), Cpd [Bas 2, Bas 3]]&nbsp; |)\"</p>\n<p>In order to achieve this, I try to help the engine by adding the following simplification rules: <br>\n&nbsp;</p>\n<hr>\n<p>lemma help_map0[simp]:<br>\n\"length xs = 0 ==&gt; map f xs = []\"<br>\nsorry </p>\n<p>lemma help_map1[simp]: <br>\n&nbsp;\"length xs = Suc n ==&gt; <br>\n&nbsp; map f xs = map f (butlast xs) @ [f(xs ! n)]\" <br>\nsorry</p>\n<p>lemma help_butlast[simp]:<br>\n\"i &lt; length xs ==&gt; butlast xs ! i = xs ! i\"<br>\nsorry </p>\n<p>lemma help_finite_pred[simp]:<br>\n\"(ALL j &lt; Suc n. phi j) = ((ALL j &lt; n. phi j) /\\ phi n)\"<br>\nsorry </p>\n<hr>\n<p>With these, auto is able to reduce a goal like</p>\n<p>\"mdr(Cpd [Bas 1, Cpd[Bas 2, Bas 3]]) &lt;= X\"</p>\n<p>to six goals having conclusions of the form \"rl : X\" for <br>\neach of the six elements rl of \"mdr(Cpd [Bas 1, Cpd[Bas 2, Bas 3]])\", <br>\nwhich is satisfactory, although the reduction is quite slow for this <br>\nsmall example already. </p>\n<p>The above reduction is clearly safe, which would make me hope for the possibility of a dual reduction to a disjunction.&nbsp; However, if I place <br>\n\"mdr(Cpd [Bas 1, Cpd[Bas 2, Bas 3]])\" on a positive position <br>\nin a goal, as in \"x : mdr(Cpd [Bas 1, Cpd[Bas 2, Bas 3]])\",<br>\nI am not able to decompose the goal into a disjunction no matter how I try.&nbsp; <br>\nFor instance, if I try (adding a seemingly useful distributive law) </p>\n<p>lemma \"x : mdr(Cpd [Bas 1, Cpd[Bas 2, Bas 3]])\"<br>\napply (auto simp add: conj_disj_distribR)</p>\n<p>it will not apply the needed simplifications.&nbsp; </p>\n<p>If I try (at&nbsp; the same lemma),&nbsp;</p>\n<p>apply (auto simp add: conj_disj_distribR, rule exI, rule exI, auto) </p>\n<p>it will loop, </p>\n<p>and also if I add the further lemma </p>\n<p>lemma simp_inside_EX:<br>\n\"(!! x y. P x y = Q x y) ==&gt; (EX x y. P x y) = (EX x y. Q x y)\"<br>\nby blast</p>\n<p>and then try </p>\n<p>apply (auto simp add: conj_disj_distribR, <br>\n&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; simp add: simp_inside_EX)</p>\n<p>it will loop again. </p>\n<p>So my question is: do I need to write my own rewrite engine/tactical, or <br>\nwould a proper use of existing ones in Isabelle solve my problems regarding the <br>\npossibility of decomposition and its computational complexity ? </p>\n<p>Many thanks in advance for any advice regarding this matter, <br>\n&nbsp;&nbsp;&nbsp; Andrei Popescu<br>\n<a href=\"/user_uploads/14278/PwoxiNVGum3pwJiQ3lBUsRkm/miniTest.thy\">miniTest.thy</a></p>",
        "id": 294062319,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660824176
    }
]