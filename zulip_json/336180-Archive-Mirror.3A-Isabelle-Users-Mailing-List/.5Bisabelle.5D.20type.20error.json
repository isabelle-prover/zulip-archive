[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nHello,</p>\n<p>I have the following theory. At theorem test I get the following error:</p>\n<p>*** Type unification failed: Clash of types \"fun\" and \"bool\"<br>\n*** Type error in application: Incompatible operand type</p>\n<hr>\n<p>*** Operator:  Trueprop :: bool =&gt; prop<br>\n*** Operand:   disjunctive (R::??'d::type itself) :: (??'a::type =&gt; <br>\n??'b::complete_lattice =&gt; ??'c::complete_lattice) =&gt; bool</p>\n<hr>\n<p>*** At command \"theorem\".</p>\n<p>Could someone help me?</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<p>theory Test<br>\nimports Main Lattice_Syntax<br>\nbegin</p>\n<p>abbreviation<br>\n   SUP1_syntax :: \"('a =&gt; 'b::complete_lattice) =&gt; 'b\"  (\"(SUP _)\" <br>\n[1000] 1000)<br>\n   where \"SUP P == SUPR UNIV P\"</p>\n<p>definition apply_fun::\"('a=&gt;'b=&gt;'c)=&gt;('a=&gt;'b)=&gt;'a=&gt;'c\" (infixl \"..\" 5) <br>\nwhere<br>\n   \"(A .. B) = (% x . (A x) (B x))\";</p>\n<p>definition<br>\n   \"(disjunctive R) = (! P . (R .. (SUP P)) =  (SUP (% w . (R .. (P <br>\nw)))))\";</p>\n<p>theorem test: \"disjunctive R\";</p>",
        "id": 294122057,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840152
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@abo.fi\">viorel.preoteasa@abo.fi</a>&gt;<br>\nOn 11/18/2010 4:13 PM, Lawrence Paulson wrote:</p>\n<blockquote>\n<p>The following warning should alert you to the problem:</p>\n<h3>Additional type variable(s) in specification of disjunctive: 'd</h3>\n<p>Thank you for your answer. I have figured it out myself finally. I had this<br>\nproblem before, but I forgot about it.</p>\n</blockquote>\n<p>Wouldn't be better is Isabelle would give an error already when<br>\ndefining something which depends on an additional type variable?</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>\n<blockquote>\n<p>For more information, switch on â€œshow types\" and you can locate the occurrence of 'd</p>\n<p>Test.disjunctive_def:<br>\n   disjunctive TYPE(?'d) (?R::?'a =&gt;  ?'b =&gt;  ?'c) =<br>\n   (ALL P::?'d =&gt;  ?'a =&gt;  ?'b. (?R .. SUP P) = SUP (%w::?'d. ?R .. P w))</p>\n<p>An implicit type parameter has been generated in order to ensure that this definition is sound. Probably you should make the right hand side of your definition more specific.</p>\n<p>Larry Paulson</p>\n<p>On 18 Nov 2010, at 13:28, Viorel Preoteasa wrote:</p>\n<blockquote>\n<p>Hello,</p>\n<p>I have the following theory. At theorem test I get the following error:</p>\n<p>*** Type unification failed: Clash of types \"fun\" and \"bool\"<br>\n*** Type error in application: Incompatible operand type</p>\n<hr>\n<p>*** Operator:  Trueprop :: bool =&gt;  prop<br>\n*** Operand:   disjunctive (R::??'d::type itself) :: (??'a::type =&gt;  ??'b::complete_lattice =&gt;  ??'c::complete_lattice) =&gt;  bool</p>\n<hr>\n<p>*** At command \"theorem\".</p>\n<p>Could someone help me?</p>\n<p>Best regards,</p>\n<p>Viorel</p>\n<p>theory Test<br>\nimports Main Lattice_Syntax<br>\nbegin</p>\n<p>abbreviation<br>\n  SUP1_syntax :: \"('a =&gt;  'b::complete_lattice) =&gt;  'b\"  (\"(SUP _)\" [1000] 1000)<br>\n  where \"SUP P == SUPR UNIV P\"</p>\n<p>definition apply_fun::\"('a=&gt;'b=&gt;'c)=&gt;('a=&gt;'b)=&gt;'a=&gt;'c\" (infixl \"..\" 5) where<br>\n  \"(A .. B) = (% x . (A x) (B x))\";</p>\n<p>definition<br>\n  \"(disjunctive R) = (! P . (R .. (SUP P)) =  (SUP (% w . (R .. (P w)))))\";</p>\n<p>theorem test: \"disjunctive R\";</p>\n</blockquote>\n</blockquote>",
        "id": 294122106,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840164
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis problem of \"hidden polymorphism\" is notorious since very early <br>\nversions of Gordon-style HOL.  After several years of spurious crashes in <br>\nIsabelle, we are now in the state where the infrastructure is able to <br>\ntreat it robustly in most situations, despite remaining surprises as <br>\nexperienced above.</p>\n<p>The deeper problem here is that it depends on the context of a <br>\nspecification if a locally fixed type variable is really \"polymorphic\" and <br>\nthus leads to extra TYPE arguments, or not.  In general it is not an error.</p>\n<p>Warnings are traditionally hardly visible in Proof General interaction. <br>\nThis is about to improve very soon in the editor view.</p>\n<p>Makarius</p>",
        "id": 294122407,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660840244
    }
]