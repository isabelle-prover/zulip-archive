[
    {
        "content": "<p>From: Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt;<br>\nI've been using locales, but this is my first foray into Isabelle<br>\ntypeclasses.</p>\n<p>This example is in completely standard Isabelle2009-1: December 2009</p>\n<p>Here is a cut-down example of a typeclass for types of object-level<br>\nterms (here using \"nat\" for the type of object-level variables) and<br>\nsubstitution.  These are first order terms with no binding.</p>\n<p>types<br>\n   var = nat<br>\n   'a sbstTyp = \"var =&gt; 'a\"              (* type of substitutions on 'a *)<br>\n   'a SbstTyp = \"'a =&gt; 'a sbstTyp =&gt; 'a\" (* type of subst operation *)</p>\n<p>(<strong> a typeclass for terms with substitution </strong>)<br>\n class trmCl =<br>\n   fixes tvar :: \"'a sbstTyp\"     (* inject variables into terms *)<br>\n   and FV :: \"'a =&gt; var set\"      (* set of free vars in a term *)<br>\n   and Sbst :: \"'a SbstTyp\"       (* operation of substitution *)<br>\n   assumes S3 : \"\\&lt;forall&gt;x \\&lt;in&gt; FV t. thet1 x = thet2 x ==&gt;<br>\n                Sbst t thet1 = Sbst t thet2\"<br>\n   and S5 : \"FV (tvar x) = {x}\"</p>\n<p>Now, an actual datatype of first-order terms with its free variable<br>\nand substitution operations</p>\n<p>(<strong> a first-order type of terms  </strong>)<br>\n datatype trm =<br>\n     lPar var<br>\n   | lApp trm trm   (\"_ # _\"  [100,100] 100)</p>\n<p>(* actual free variable function of trm *)<br>\n primrec GV :: \"trm =&gt; var set\"<br>\n where<br>\n   \"GV (lPar X) = {X}\"<br>\n | \"GV (lApp t1 t2) = (GV t1) Un (GV t2)\"</p>\n<p>(* actual substitution operation *)<br>\n primrec trm_Sbst :: \"trm SbstTyp\"    (\"_[[_]]\")<br>\n where<br>\n   \"(lPar X)[[thta]] = thta X\"<br>\n | \"(M1 # M2)[[thta]] = (M1[[thta]]) # (M2[[thta]])\"</p>\n<p>The punchline is that my attempt to instantiate trmCl with trm fails<br>\nwith two problems I don't understand.</p>\n<p>instantiation trm :: trmCl<br>\n begin</p>\n<p>definition tvar_def: \"tvar = lPar\"<br>\n definition FV_def: \"FV = GV\"<br>\n definition Sbst_def: \"Sbst = trm_Sbst\"</p>\n<p>instance proof<br>\n   fix t::trm and thet1 thet2 :: \"trm sbstTyp\"<br>\n   show \"\\&lt;forall&gt;x\\&lt;in&gt;FV t. thet1 x = thet2 x ==&gt; Sbst t thet1 = Sbst t thet2\"<br>\n     by (induct t rule:trm.induct, auto simp add: FV_def Sbst_def)</p>\n<p>I receive the message </p>\n<p>Successful attempt to solve goal by exported rule:<br>\n  ∀x∈FV ?t2. ?thet1.2 x = ?thet2.2 x ==&gt;<br>\n  Sbst ?t2 ?thet1.2 = Sbst ?t2 ?thet2.2</p>\n<p>BUT a residual goal is still there</p>\n<p>next</p>\n<p>goal (2 subgoals):</p>\n<ol>\n<li>/\\ t thet1 thet2. ∀x∈FV t. thet1 x = thet2 x ==&gt; ∀x∈FV t. thet1 x = thet2 x</li>\n<li>/\\x. FV (tvar x) = {x}</li>\n</ol>\n<p>OK, skip goal 1. and try to solve goal 2.</p>\n<p>fix x::var show \"FV (tvar x) = {x}\"</p>\n<p>*** Local statement will fail to refine any pending goal<br>\n*** Failed attempt to solve goal by exported rule:<br>\n***   FV (tvar ?x3) = {?x3}<br>\n*** At command \"show\".</p>\n<p>I'm stumped.</p>\n<p>Thanks for any help,<br>\nRandy</p>",
        "id": 294097609,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832786
    },
    {
        "content": "<p>From: Brian Huffman &lt;<a href=\"mailto:brianh@cs.pdx.edu\">brianh@cs.pdx.edu</a>&gt;<br>\nOn Tue, Dec 22, 2009 at 5:46 AM, Randy Pollack &lt;<a href=\"mailto:rpollack@inf.ed.ac.uk\">rpollack@inf.ed.ac.uk</a>&gt; wrote:</p>\n<blockquote>\n<p>types<br>\n  var = nat<br>\n  'a sbstTyp = \"var =&gt; 'a\"              (* type of substitutions on 'a *)<br>\n  'a SbstTyp = \"'a =&gt; 'a sbstTyp =&gt; 'a\" (* type of subst operation *)</p>\n<p>(<strong> a typeclass for terms with substitution </strong>)<br>\n class trmCl =<br>\n  fixes tvar :: \"'a sbstTyp\"     (* inject variables into terms *)<br>\n  and FV :: \"'a =&gt; var set\"      (* set of free vars in a term *)<br>\n  and Sbst :: \"'a SbstTyp\"       (* operation of substitution *)<br>\n  assumes S3 : \"\\&lt;forall&gt;x \\&lt;in&gt; FV t. thet1 x = thet2 x ==&gt;<br>\n                               Sbst t thet1 = Sbst t thet2\"<br>\n  and S5 : \"FV (tvar x) = {x}\"<br>\n...<br>\n instance proof<br>\n  fix t::trm and thet1 thet2 :: \"trm sbstTyp\"<br>\n  show \"\\&lt;forall&gt;x\\&lt;in&gt;FV t. thet1 x = thet2 x ==&gt; Sbst t thet1 = Sbst t thet2\"<br>\n    by (induct t rule:trm.induct, auto simp add: FV_def Sbst_def)</p>\n<p>I receive the message</p>\n<p>Successful attempt to solve goal by exported rule:<br>\n ∀x∈FV ?t2. ?thet1.2 x = ?thet2.2 x ==&gt;<br>\n Sbst ?t2 ?thet1.2 = Sbst ?t2 ?thet2.2</p>\n<p>BUT a residual goal is still there</p>\n<p>next</p>\n<p>goal (2 subgoals):<br>\n 1. /\\ t thet1 thet2. ∀x∈FV t. thet1 x = thet2 x ==&gt; ∀x∈FV t. thet1 x = thet2 x<br>\n 2. /\\x. FV (tvar x) = {x}</p>\n</blockquote>\n<p>This is just how the Isar proof language works when you use a<br>\nmeta-implication (==&gt;) in a \"show\" command. When you use \"show<br>\n&lt;prop&gt;\", it is as if you had proved \"lemma foo: &lt;prop&gt;\" separately,<br>\nand then done \"apply (rule foo)\" to the current proof state (Isabelle<br>\nwill apply the rule to the first subgoal that matches).</p>\n<p>For example, if you have a proof state with subgoals \"A1 ==&gt; A\" and<br>\n\"B1 ==&gt; B\", and then do 'show \"C ==&gt; B\"', Isabelle will apply the rule<br>\n\"C ==&gt; B\" to the second subgoal, and the new proof state will have<br>\nsubgoals \"A1 ==&gt; A\" and \"B1 ==&gt; C\".</p>\n<p>At the end of your proof script, any remaining subgoals of the form \"A<br>\n==&gt; A\" will be solved by assumption by \"qed\". This is the case with<br>\nyour proof; if you can discharge the second subgoal, the first goal<br>\n(which is solvable by assumption) will be handled by qed.</p>\n<p>If you find this behavior to be confusing, it is best to simply avoid<br>\nusing \"==&gt;\" with \"show\". Just use \"assumes\" instead.</p>\n<blockquote>\n<p>OK, skip goal 1. and try to solve goal 2.</p>\n<p>fix x::var show \"FV (tvar x) = {x}\"</p>\n<p>*** Local statement will fail to refine any pending goal<br>\n*** Failed attempt to solve goal by exported rule:<br>\n***   FV (tvar ?x3) = {?x3}<br>\n*** At command \"show\".</p>\n</blockquote>\n<p>It looks like you need a type annotation here. Since \"FV\" and \"tvar\"<br>\nare both overloaded constants, Isabelle can't tell what the return<br>\ntype of \"tvar\" should be. (Turn on \"show consts\" to see the inferred<br>\ntype; it probably introduces a new free type variable.) Try this<br>\ninstead:</p>\n<p>fix x::var show \"FV (tvar x :: trm) = {x}\"</p>\n<p>(Note to Isabelle developers: Introducing a new type variable in the<br>\nmiddle of a proof like this is not something users usually do on<br>\npurpose. Would it be possible to print a warning message when this<br>\nhappens?)</p>\n<p>Hope this helps,</p>\n<ul>\n<li>Brian</li>\n</ul>",
        "id": 294097627,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832792
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>If you find this behavior to be confusing, it is best to simply avoid<br>\nusing \"==&gt;\" with \"show\". Just use \"assumes\" instead.</p>\n</blockquote>\n<p>It is only confusing if you have multiple subgoals. With a single<br>\nsubgoal ==&gt; works fine and avoids some noise in case of inductions ---<br>\notherwise the assume-show style is simpler.</p>\n<p>Tobias</p>\n<blockquote>\n<blockquote>\n<p>OK, skip goal 1. and try to solve goal 2.</p>\n<p>fix x::var show \"FV (tvar x) = {x}\"</p>\n<p>*** Local statement will fail to refine any pending goal<br>\n*** Failed attempt to solve goal by exported rule:<br>\n***   FV (tvar ?x3) = {?x3}<br>\n*** At command \"show\".</p>\n</blockquote>\n<p>It looks like you need a type annotation here. Since \"FV\" and \"tvar\"<br>\nare both overloaded constants, Isabelle can't tell what the return<br>\ntype of \"tvar\" should be. (Turn on \"show consts\" to see the inferred<br>\ntype; it probably introduces a new free type variable.) Try this<br>\ninstead:</p>\n<p>fix x::var show \"FV (tvar x :: trm) = {x}\"</p>\n<p>(Note to Isabelle developers: Introducing a new type variable in the<br>\nmiddle of a proof like this is not something users usually do on<br>\npurpose. Would it be possible to print a warning message when this<br>\nhappens?)</p>\n<p>Hope this helps,<br>\n- Brian</p>\n</blockquote>",
        "id": 294097648,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660832802
    }
]