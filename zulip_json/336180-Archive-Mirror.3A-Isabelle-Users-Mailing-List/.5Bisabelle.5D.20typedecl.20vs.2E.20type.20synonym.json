[
    {
        "content": "<p>From: Matthias Perner &lt;<a href=\"mailto:perner@cs.tu-darmstadt.de\">perner@cs.tu-darmstadt.de</a>&gt;<br>\nHi,</p>\n<p>I currently have two formalizations of the same pen and paper model in<br>\nIsabelle.  In one of the formalizations type variables are used<br>\nextensively to formalize \"underspecified sets\" from the pen &amp; paper<br>\nmodel.  In the other formalization the \"underspecified sets\" are<br>\nformalized with typedecl.</p>\n<p>Now I try to get an idea what the advantages of the two approaches are,<br>\nbut I cannot find a suitable starting point for this in the Isabelle<br>\ndocumentation.  Any hints?  A short reply when to use which style would<br>\nalso be very welcome.</p>\n<p>Thanks,<br>\nMatthias</p>",
        "id": 294714095,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183171
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi Matthias,</p>\n<p>that's more of an open question, really.</p>\n<p>First, to clarify, \"type synonyms\" are just syntactic abbreviations.<br>\nThey don't exist inside the logic and are not useful to abstract over<br>\nanything.</p>\n<p>\"typedecl\" are unspecified types. It's impossible to \"instantiate\" them<br>\nlater. If you want to assume anything non-trivial on them, you're going<br>\nto need \"axiomatization\". There's no tooling in Isabelle that will make<br>\nyou prove that your assumptions are consistent. However, type<br>\ndeclarations can be polymorphic; i.e., it is possible to declare a<br>\npolymorphic type and axiomatize polymorphic constants.</p>\n<p>However, if you fix a type variable in a locale or some other context,<br>\nit is monomorphic. This point is rather subtle. For example, you can't<br>\nabstract over the \"map\" function of functors in HOL, because it would<br>\nrequire a variable type constructor. On the other hand, the advantage is<br>\nthat you can in fact instantiate locales later on and can give a proof<br>\nthat the assumptions are consistent.</p>\n<p>For locales in particular, see the tutorial:<br>\n&lt;<a href=\"https://isabelle.in.tum.de/dist/Isabelle2016-1/doc/locales.pdf\">https://isabelle.in.tum.de/dist/Isabelle2016-1/doc/locales.pdf</a>&gt;.</p>\n<p>Hope that helps.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294714100,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183173
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear Matthias,</p>\n<p>Here's my experience on this. The choice basically depends on what you want to use your <br>\nformalisation for. If it's just about a stand-alone formalisation that does not involve <br>\ncode generation and is not supposed to be re-used by others, then typedecl can make your <br>\nlife a bit easier, for two reasons:</p>\n<ol>\n<li>You do not have to drag all those type variables around, i.e., your types get smaller <br>\nand easier to read. In particular, Isabelle has a bad habit of normalising the names of <br>\ntype variables. So even if you define your function f with meaningful type variable names,</li>\n</ol>\n<p>f :: 'string =&gt; 'number =&gt; 'output</p>\n<p>type inference will just use 'a, 'b, 'c, etc. in your theorem statements (and accordingly <br>\nin the error messages when type checking fails).</p>\n<ol start=\"2\">\n<li>Type constructors declared with typedecl can be polymorphic. That is, you can have <br>\nfamilies of unspecified sets indexed by types. With type variables, you need one type <br>\nvariable for every instance you need.</li>\n</ol>\n<p>Conversely, typedecl also has some drawbacks. First, code generation (and value and <br>\nquickcheck, too) do not work for typedecl's, except for very special cases with a careful <br>\nmanual setup of the code generator. Moreover, if you ever want to apply your theorem to a <br>\nparticular case, in which the sets are not unspecified any more, you cannot do this within <br>\nthe Isabelle/HOL logic.</p>\n<p>Andreas</p>",
        "id": 294714113,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661183180
    }
]