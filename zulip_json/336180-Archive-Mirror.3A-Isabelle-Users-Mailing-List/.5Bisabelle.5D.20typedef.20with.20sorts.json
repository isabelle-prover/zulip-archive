[
    {
        "content": "<p>From: Manuel Eberl &lt;<a href=\"mailto:eberlm@in.tum.de\">eberlm@in.tum.de</a>&gt;<br>\nHallo,</p>\n<p>I just noticed the following behaviour that I found a bit puzzling at first:</p>\n<p>typedef 'a foo = \"if finite (UNIV :: 'a :: finite set) then (UNIV :: 'a <br>\nset) else {}\"<br>\n   by auto</p>\n<p>term \"undefined :: nat foo\"</p>\n<p>Essentially, I define a type copy 'a foo for any finite type 'a; <br>\nhowever, Isabelle does not prevent me from using the type copy with an <br>\ninfinite type like nat. I first thought that this must surely be <br>\ninconsistent, because I defined 'a foo to be empty for infinite types, <br>\nbut to my relief, I found that all the lemmas generated by typedef are <br>\nannotated with the proper sort constraints, so it seems that \"nat foo\" <br>\nis logically /not/ an empty type, but more like a completely arbitrary <br>\n(non-empty) type that I know nothing about.</p>\n<p>My question now is this: is it possible to make writing \"nat foo\" a type <br>\nerror? Or, perhaps, is it possible to add the sort constraint 'a :: <br>\nfinite to the context if 'a foo appears anywhere?</p>\n<p>My use case is that I use Fraction_Field from HOL-Library, which demands <br>\nits type parameter to be an idom, but whenever I have lemmas using 'a <br>\nfraction, I have to annotate 'a :: idom manually, which is annoying.</p>\n<p>Cheers,</p>\n<p>Manuel</p>",
        "id": 294660237,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169634
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nNo.  Sorts do not affect the well-formedness of type-expressions, only the <br>\nlogical meaning.</p>\n<p>Makarius</p>",
        "id": 294660300,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661169652
    }
]