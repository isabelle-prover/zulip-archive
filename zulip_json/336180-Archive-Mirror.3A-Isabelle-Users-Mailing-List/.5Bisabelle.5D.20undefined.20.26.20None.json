[
    {
        "content": "<p>From: Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;<br>\nHi all,</p>\n<p>I try to discover where the undefined value is ... defined. I could not find any undefined_def lemma or axiom.</p>\n<p>In particular, is it polymorphic ? What are its properties ? What are the mathematical foundations and consequences of how it has been defined ?</p>\n<p>I also wonder why the \"None\" option types constructor does not point to undefined in some way or another. Furthermore, I do not understand whether None is typed of not. </p>\n<p>This all sounds rather simple questions but I am a little ill at ease with using a keyword without its precise semantics in mind !</p>\n<p>Thanks in advance<br>\nH.</p>",
        "id": 294245192,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908617
    },
    {
        "content": "<p>From: Stephan Merz &lt;<a href=\"mailto:Stephan.Merz@loria.fr\">Stephan.Merz@loria.fr</a>&gt;<br>\nHenri,</p>\n<p>On Jul 13, 2013, at 11:17 PM, Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt; wrote:</p>\n<blockquote>\n<p>I try to discover where the undefined value is ... defined. I could not find any undefined_def lemma or axiom.</p>\n<p>In particular, is it polymorphic ? What are its properties ? What are the mathematical foundations and consequences of how it has been defined ?</p>\n</blockquote>\n<p>grepping for undefined in src/HOL yields</p>\n<p>HOL.thy:axiomatization undefined :: 'a</p>\n<p>As you can see, the constant is not defined but declared as a polymorphic constant for arbitrary type. This is logically unproblematic because types in HOL must be non-empty. The value denotes some unspecified value of arbitrary type, this is sometimes useful when no particular property of the value is required.</p>\n<p>Note that in theory Hilbert_Choice one could actually define</p>\n<p>definition undefined where \"(undefined::'a) = Some (x::'a). True\"</p>\n<blockquote>\n<p>I also wonder why the \"None\" option types constructor does not point to undefined in some way or another. Furthermore, I do not understand whether None is typed of not. </p>\n</blockquote>\n<p>Since \"undefined\" is polymorphic, it exists for any option type. Defining \"undefined :: 'a option\" to be None would be more specific than what is required.</p>\n<p>Hope this helps,</p>\n<p>Stephan</p>",
        "id": 294245229,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908630
    },
    {
        "content": "<p>From: Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;<br>\nHi Stephan,</p>\n<p>Thanks a lot for your clear answer. Just to be sure: I suppose you mean SOME ?</p>\n<p>==&gt; \"(undefined::'a) = SOME (x::'a). True\") ?</p>\n<p>H.</p>",
        "id": 294245244,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908636
    },
    {
        "content": "<p>From: Stephan Merz &lt;<a href=\"mailto:Stephan.Merz@loria.fr\">Stephan.Merz@loria.fr</a>&gt;<br>\nOops, of course! -s</p>",
        "id": 294245256,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908642
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nOn 13.07.2013 23:17, Henri DEBRAT wrote:</p>\n<blockquote>\n<p>I try to discover where the undefined value is ... defined. I could not find any undefined_def lemma or axiom.</p>\n<p>In particular, is it polymorphic ? What are its properties ? What are the mathematical foundations and consequences of how it has been defined ?</p>\n</blockquote>\n<p>You can see whether a term is polymorphic or not by simply printing it <br>\nwith \"term\" -- iff its type contains type variables, it is polymorphic <br>\n(in the global context).</p>\n<p>\"undefined :: 'a\" has exactly those properties any value of type 'a has.</p>\n<blockquote>\n<p>I also wonder why the \"None\" option types constructor does not point to undefined in some way or another. Furthermore, I do not understand whether None is typed of not.</p>\n</blockquote>\n<p>Every value in Isabelle has exactly one concrete type, so None is <br>\n\"typed\". A polymorphic constant like None can be used to refer to <br>\nvarious values, depending on its type.</p>\n<p>I.e., you can have e.g. \"None :: nat option\" and \"None :: int option\"<br>\nbut if you write \"(None :: nat option) = (None :: int option)\" you get<br>\na type error.</p>\n<p>-- Lars</p>",
        "id": 294245269,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908648
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nThat would be an equivalent definition, as would be</p>\n<p>\"SOME x. False\" or \"THE x. x = x\".</p>\n<p>However, mind that we cannot prove \"undefined :: 'a\" and \"SOME x :: 'a. <br>\nTrue\" to be equal (except for 'a = unit, of course).</p>\n<p>-- Lars</p>",
        "id": 294245282,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908656
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nStephan alerted me that \"equivalent\" is misleading here: They are <br>\n\"equivalent\" in the sense that both can fill the same role, i.e., they <br>\nrepresent an arbitrary value of type 'a. They are not \"equivalent\" in <br>\nthat we cannot prove any relation between \"undefined :: 'a\" and \"SOME (x <br>\n:: 'a). True.</p>\n<p>-- Lars</p>",
        "id": 294245293,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908660
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nFurther to Stephan's response...</p>\n<p>The type of \"None\" is \"T option\", for any type T. Suppose T has elements {a,b,c,d}. Then \"T option\" will contain the elements {None, Some a, Some b, Some c, Some d}. \"None\" is just an extra element added to the type.</p>\n<p>\"None\" is often used when defining partial functions: an input is sent to \"None\" when the partial function is not defined for that input. But otherwise \"None\" and the special \"undefined\" constant are completely unrelated.</p>\n<p>There are other uses of \"None\", unrelated to definedness. For instance, None could represent an error in a calculation. A division function might return \"Some 10\" when asked to divide 50 by 5, and \"None\" when a division-by-zero is attempted. Another use is to represent natural-numbers-with-infinity. The type \"nat\" only includes finite numbers, but if you use \"nat option\" then you can use \"None\" to stand for infinity.</p>\n<p>In short, None is just an extra element added to an existing type.</p>\n<p>john</p>",
        "id": 294245313,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908669
    },
    {
        "content": "<p>From: Henri Debrat &lt;<a href=\"mailto:henri.debrat@loria.fr\">henri.debrat@loria.fr</a>&gt;<br>\nHi all,</p>\n<p>Sorry if I come back to this topic quite late. Why undefined and None must be different things is still not clear to me.</p>\n<p>First, taken from Stephan's answer:<br>\n(1) what do you mean when saying: Defining \"undefined :: 'a option\" to be None would be more specific than what is required.<br>\nMore precisely, I do not understand why the actual definition is more general (in what meaning ?) and indeed, I do not understand what /is/ required on what purpose.</p>\n<p>(2) Let's say that Isabelle do not define \"undefined\" thanks to the axiomatization command, but with Hilbert's Choice operator, as you suggest. Would it make no difference ? Does it mean that using a type variable already makes the Hilbert's Choice operator implicitly admitted ? Then, I suppose that such a construction is then inherently linked to classical logic (since Hilbert's Choice makes the logic classical according to Diaconescu, cf hop-logic.pdf page 8) ?</p>\n<p>Then, answering to John who said: otherwise \"None\" and the special \"undefined\" constant are completely unrelated.</p>\n<p>My question is: why aren't they related more closely ? It appears to me that every usage of None you describe would remain possible if None was related to undefined as in (1).</p>\n<p>H.</p>\n<p>Le 14 juil. 2013 à 12:18, John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt; a écrit :</p>\n<p>Further to Stephan's response...</p>\n<p>The type of \"None\" is \"T option\", for any type T. Suppose T has elements {a,b,c,d}. Then \"T option\" will contain the elements {None, Some a, Some b, Some c, Some d}. \"None\" is just an extra element added to the type.</p>\n<p>\"None\" is often used when defining partial functions: an input is sent to \"None\" when the partial function is not defined for that input. But otherwise \"None\" and the special \"undefined\" constant are completely unrelated.</p>\n<p>There are other uses of \"None\", unrelated to definedness. For instance, None could represent an error in a calculation. A division function might return \"Some 10\" when asked to divide 50 by 5, and \"None\" when a division-by-zero is attempted. Another use is to represent natural-numbers-with-infinity. The type \"nat\" only includes finite numbers, but if you use \"nat option\" then you can use \"None\" to stand for infinity.</p>\n<p>In short, None is just an extra element added to an existing type.</p>\n<p>john</p>\n<p>On 14 Jul 2013, at 10:22, Stephan Merz wrote:</p>\n<p>Henri,</p>\n<blockquote>\n<p>On Jul 13, 2013, at 11:17 PM, Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt; wrote:</p>\n</blockquote>\n<blockquote>\n<p>I try to discover where the undefined value is ... defined. I could not find any undefined_def lemma or axiom.</p>\n</blockquote>\n<blockquote>\n<p>In particular, is it polymorphic ? What are its properties ? What are the mathematical foundations and consequences of how it has been defined ?</p>\n</blockquote>\n<p>grepping for undefined in src/HOL yields</p>\n<p>HOL.thy:axiomatization undefined :: 'a</p>\n<p>As you can see, the constant is not defined but declared as a polymorphic constant for arbitrary type. This is logically unproblematic because types in HOL must be non-empty. The value denotes some unspecified value of arbitrary type, this is sometimes useful when no particular property of the value is required.</p>\n<p>Note that in theory Hilbert_Choice one could actually define</p>\n<p>definition undefined where \"(undefined::'a) = Some (x::'a). True\"</p>\n<blockquote>\n<p>I also wonder why the \"None\" option types constructor does not point to undefined in some way or another. Furthermore, I do not understand whether None is typed of not. </p>\n</blockquote>\n<p>Since \"undefined\" is polymorphic, it exists for any option type. Defining \"undefined :: 'a option\" to be None would be more specific than what is required.</p>\n<p>Hope this helps,</p>\n<p>Stephan</p>",
        "id": 294248503,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909866
    },
    {
        "content": "<p>From: Stephan Merz &lt;<a href=\"mailto:stephan.merz@loria.fr\">stephan.merz@loria.fr</a>&gt;<br>\nHenri,</p>\n<p>I'm sorry if the replies were not clear for you. Let me try again.</p>\n<p>The purpose of the constant \"undefined\" is to have a name for an element of the underlying type for which you have no other information than just that it denotes an unspecified value of that type. Giving any definition (such as it being equal to None when we are talking about an option type or defining it using Hilbert's epsilon or a definite description) gives you more equalities for the value than you care to have.</p>\n<p>Similarly, when John says undefined and None are unrelated he really meant to say that we have no way to know if there is a relationship between these values. Obviously, any usage of an unspecified value remains possible for a more specified one, but the purpose is to keep \"undefined\" as far apart from known values as possible.</p>\n<p>Hope this will be clearer.</p>\n<p>Regards,<br>\nStephan</p>",
        "id": 294248510,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909869
    },
    {
        "content": "<p>From: John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt;<br>\nHi Henri,</p>\n<p>If I may donate a few more words to this interesting topic...</p>\n<p>HOL is a logic of total functions. Whenever you have a function, say f :: nat =&gt; bool, then f corresponds to a particular function. If you say</p>\n<p>definition \"f :: nat =&gt; bool\" where \"f 5 == True\" </p>\n<p>then, at least in my head, f becomes a particular function, with a boolean value for every nat, but the only thing we <em>know</em> about the function is that it maps 5 to True.</p>\n<p>Pushing this idea to its limits, \"undefined\" is a term we know <em>nothing</em> about.</p>\n<p>Then \"None\" is a completely different kettle of fish. It's often handy to extend a set by one extra element, say to add infinity to the set of naturals, or to add a special \"undefined\" return value. This is done in Isabelle using the option type. \"None\" is the extra element you add to the set, and you prepend all the other elements in the set with the tag \"Some\" in order to make sure that they are all different from \"None\".</p>\n<p>John</p>",
        "id": 294248526,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909876
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Henri,</p>\n<p>You can use the type 'a option such that None models undefinedness, but there are other <br>\nuses, too. Take, e.g., a type foo with an order &lt;=. Then, you can lift this order to \"foo <br>\noption\" and make None the least or greatest element in \"foo option\". And there are <br>\nhundreds of other uses of \"'a option\" that you could imagine. Now, for all these uses, it <br>\nwould be fairly unnatural to require that undefined always denotes the largest / smallest <br>\nelement or whatever specific element.</p>\n<p>A long time ago (before Isabelle2009), \"undefined\" was called \"arbitrary\", and \"arbitrary\" <br>\nreflected the specification of the element better: it was some element of the type. <br>\nHowever, as definitional packages (and some users) used undefined for cases when the <br>\ndesired specification of a constant did not say anything, it got renamed to undefined. But <br>\nlogically, it still is just an arbitrary element of the type. And None would be a very <br>\nspecial element of that type.</p>\n<p>Hope this helps,<br>\nAndreas</p>",
        "id": 294248543,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909882
    },
    {
        "content": "<p>From: Ramana Kumar &lt;<a href=\"mailto:rk436@cam.ac.uk\">rk436@cam.ac.uk</a>&gt;<br>\nOn Mon, Sep 30, 2013 at 3:39 PM, Andreas Lochbihler &lt;<br>\n<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt; wrote:</p>\n<blockquote>\n<p>Take, e.g., a type foo with an order &lt;=. Then, you can lift this order to<br>\n\"foo option\" and make None the least or greatest element in \"foo option\".<br>\nAnd there are hundreds of other uses of \"'a option\" that you could imagine.<br>\nNow, for all these uses, it would be fairly unnatural to require that<br>\nundefined always denotes the largest / smallest element or whatever<br>\nspecific element.<br>\n</p>\n</blockquote>\n<p>Indeed, it would actually be impossible to use undefined for that purpose,<br>\nsince undefined might not be the largest / smallest element - it might be<br>\nequal to some element in the middle (but not provably so).</p>\n<blockquote>\n<p>On 30/09/13 16:15, Henri Debrat wrote:</p>\n<blockquote>\n<p>Hi all,</p>\n<p>Sorry if I come back to this topic quite late. Why undefined and None<br>\nmust be different things is still not clear to me.</p>\n<p>First, taken from Stephan's answer:<br>\n(1) what do you mean when saying: Defining \"undefined :: 'a option\" to be<br>\nNone would be more specific than what is required.<br>\nMore precisely, I do not understand why the actual definition is more<br>\ngeneral (in what meaning ?) and indeed, I do not understand what /is/<br>\nrequired on what purpose.</p>\n<p>(2) Let's say that Isabelle do not define \"undefined\" thanks to the<br>\naxiomatization command, but with Hilbert's Choice operator, as you suggest.<br>\nWould it make no difference ? Does it mean that using a type variable<br>\nalready makes the Hilbert's Choice operator implicitly admitted ? Then, I<br>\nsuppose that such a construction is then inherently linked to classical<br>\nlogic (since Hilbert's Choice makes the logic classical according to<br>\nDiaconescu, cf hop-logic.pdf page 8) ?</p>\n<p>Then, answering to John who said: otherwise \"None\" and the special<br>\n\"undefined\" constant are completely unrelated.</p>\n<p>My question is: why aren't they related more closely ? It appears to me<br>\nthat every usage of None you describe would remain possible if None was<br>\nrelated to undefined as in (1).</p>\n<p>H.</p>\n<p>Le 14 juil. 2013 à 12:18, John Wickerson &lt;<a href=\"mailto:johnwickerson@cantab.net\">johnwickerson@cantab.net</a>&gt; a<br>\nécrit :</p>\n<p>Further to Stephan's response...</p>\n<p>The type of \"None\" is \"T option\", for any type T. Suppose T has elements<br>\n{a,b,c,d}. Then \"T option\" will contain the elements {None, Some a, Some b,<br>\nSome c, Some d}. \"None\" is just an extra element added to the type.</p>\n<p>\"None\" is often used when defining partial functions: an input is sent to<br>\n\"None\" when the partial function is not defined for that input. But<br>\notherwise \"None\" and the special \"undefined\" constant are completely<br>\nunrelated.</p>\n<p>There are other uses of \"None\", unrelated to definedness. For instance,<br>\nNone could represent an error in a calculation. A division function might<br>\nreturn \"Some 10\" when asked to divide 50 by 5, and \"None\" when a<br>\ndivision-by-zero is attempted. Another use is to represent<br>\nnatural-numbers-with-infinity. The type \"nat\" only includes finite numbers,<br>\nbut if you use \"nat option\" then you can use \"None\" to stand for infinity.</p>\n<p>In short, None is just an extra element added to an existing type.</p>\n<p>john</p>\n</blockquote>\n<p>On 14 Jul 2013, at 10:22, Stephan Merz wrote:</p>\n<blockquote>\n<p>Henri,</p>\n<p>On Jul 13, 2013, at 11:17 PM, Henri DEBRAT &lt;<a href=\"mailto:Henri.Debrat@loria.fr\">Henri.Debrat@loria.fr</a>&gt;</p>\n<blockquote>\n<p>wrote:<br>\n</p>\n</blockquote>\n<p>I try to discover where the undefined value is ... defined. I could not</p>\n<blockquote>\n<p>find any undefined_def lemma or axiom.<br>\n</p>\n</blockquote>\n<p>In particular, is it polymorphic ? What are its properties ? What are</p>\n<blockquote>\n<p>the mathematical foundations and consequences of how it has been defined ?<br>\n</p>\n</blockquote>\n<p>grepping for undefined in src/HOL yields</p>\n<p>HOL.thy:axiomatization undefined :: 'a</p>\n<p>As you can see, the constant is not defined but declared as a polymorphic<br>\nconstant for arbitrary type. This is logically unproblematic because types<br>\nin HOL must be non-empty. The value denotes some unspecified value of<br>\narbitrary type, this is sometimes useful when no particular property of the<br>\nvalue is required.</p>\n<p>Note that in theory Hilbert_Choice one could actually define</p>\n<p>definition undefined where \"(undefined::'a) = Some (x::'a). True\"</p>\n<p>I also wonder why the \"None\" option types constructor does not point to</p>\n<blockquote>\n<p>undefined in some way or another. Furthermore, I do not understand whether<br>\nNone is typed of not.<br>\n</p>\n</blockquote>\n<p>Since \"undefined\" is polymorphic, it exists for any option type. Defining<br>\n\"undefined :: 'a option\" to be None would be more specific than what is<br>\nrequired.</p>\n<p>Hope this helps,</p>\n<p>Stephan</p>\n</blockquote>\n</blockquote>",
        "id": 294248569,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909894
    },
    {
        "content": "<p>From: Henri Debrat &lt;<a href=\"mailto:henri.debrat@loria.fr\">henri.debrat@loria.fr</a>&gt;<br>\nThanks for all your answers !</p>\n<p>I understand it better now, I believe. To sum it up :</p>\n<ul>\n<li>\"None\" is <em>known</em> to be different from any other element (constructed with Some) in an option type.</li>\n<li>It <em>might</em> be (yet, nobody knows) that undefined = None, or undefined = Some y, ... only there is just no information about it.</li>\n</ul>\n<p>Hence, I think I understand in which meaning \"None\" is of a different usage than \"undefined\".</p>\n<p>However, focusing on what Andreas says, because undefined is polymorphic, I do not see why it would be a problem to state that, for some specific type the user defines, \"undefined\" is such that so additional constraints hold. And we could say that, in an option type, undefined is such that any other element is different from all the others.</p>\n<p>What I suggest here is not to make \"undefined\" and \"None\" be one and the same, but to define \"None\" as being a peculiar case of \"undefined\", by adding a constraint to \"undefined\" when considering an option type so that it's always different from any \"Some y\".</p>\n<p>I hope I am not being boring by going further in this discussion...</p>\n<p>H.</p>\n<p>----- Mail original -----</p>",
        "id": 294248595,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909900
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nI like to say that too. At the same time, it is worth pointing out that<br>\nwe do know certain (trivial) things about \"undefined\": for instance,<br>\n\"undefined = undefined\".</p>\n<p>Best,<br>\nTjark</p>",
        "id": 294248610,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909906
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nThe renaming from \"arbitrary\" to \"undefined\" was very unfortunate. Perhaps it's not too late to rename it one last time, to \"unspecified\". What do you think?</p>\n<p>Jasmin</p>",
        "id": 294248622,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909912
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI agree that the renaming was unfortunate, but I'm not convinced that a further renaming would be that useful.</p>\n<p>Although it would be easier than changing from sets to predicates and back again :-)</p>\n<p>We just need to be very clear about what this constant actually denotes.</p>\n<p>Larry</p>",
        "id": 294248648,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909922
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nMy experience is that it's much easier to explain what something is when its name is not positively confusing.</p>\n<p>Imagine you need to name a constant for the color green. There are three levels of naming:</p>\n<p>Good naming: green<br>\n    Neutral naming: kijani [*]<br>\n    Confusing naming: red</p>\n<p>It's easy to train one's brain to map \"kijani\" to \"green\", but having to teach the whole world that \"red\" means \"green\" just adds one layer of obfuscation.</p>\n<p>If it was possible to muster the courage to perform such an unfortunate renaming in the first place, surely it shouldn't be too hard to do it again in favor of a good name -- and I would be happy to actually perform the renaming.</p>\n<p>Jasmin</p>\n<p>[*] unless you know Swahili, in which case this becomes a good name</p>",
        "id": 294248692,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909924
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Henri,</p>\n<blockquote>\n<p>However, focusing on what Andreas says, because undefined is polymorphic, I do not see why it would be a problem to state that, for some specific type the user defines, \"undefined\" is such that so additional constraints hold.<br>\nAnd we could say that, in an option type, undefined is such that any other element is different from all the others.<br>\nYou can do that in your own theories by asserting the appropriate axioms. The simplest way <br>\nto do so is:</p>\n</blockquote>\n<p>lemma undefined_my_type_option: \"undefined :: my_type option = None\"<br>\nsorry</p>\n<blockquote>\n<p>What I suggest here is not to make \"undefined\" and \"None\" be one and the same, but to define \"None\" as being a peculiar case of \"undefined\", by adding a constraint to \"undefined\" when considering an option type so that it's always different from any \"Some y\".<br>\nBut then they are the same. HOL has equality for every type, and you can do case <br>\ndistinctions about every option type. Thus: From \"!!x. undefined ~= Some x\", you can <br>\nderive \"undefined = None\".</p>\n</blockquote>\n<p>Inside Isabelle, there would be no problem with saying that None and undefined are the <br>\nsame, the logic would still be consistent. But take a step back and think about what you <br>\nare doing in Isabelle: You create mathematical descriptions of the real world by <br>\nspecifying appropriate constants, and then you prove properties about your model. Now, <br>\nthese theorems apply to every real-world instance that satisfies the specification of your <br>\nconstants, i.e., if you make your specifications stronger, your theorems apply to less <br>\ninstances.</p>\n<p>10-15 years ago, when there were only few definitional packages available, many people <br>\naxiomatized the model rather than defined them. Often, one just dealt with underspecified <br>\nfunctions. However, one always runs the risk of introducing logical inconsistencies this <br>\nway. So, nowadays, it is more popular to define your constants (and types) in terms of <br>\nexisting constants (this is the definitional principle in the HOL community). Then, you <br>\nprove lemmas that your constants meet the specification that you care about; and ideally, <br>\nyour theorems only use the specifications lemmas. But Isabelle will not stop you from <br>\nexploiting all the properties that your definitional method accidentially has introduced. <br>\nSo, in general, nowadays, the theorems that we prove apply to less real-world instances <br>\nthan in the old days, but we can be sure that at least there are no logical <br>\ninconsistencies in our specifications.</p>\n<p>The constant undefined is one of the cases where we still care about \"relaxing the <br>\nspecification as far as possible\". Undefined is used by many packages internally, and it <br>\nis important from a modelling perspective that it remains this way. Consider, for example, <br>\nthe function nth from List (written infix as !): xs ! n returns the n-th element of the <br>\nlist xs. If n is greater than the length of xs, xs ! n returns \"undefined n\", i.e, an <br>\narbitrary value of the right type, but that might be different for every list index. And <br>\nthis captures fairly well what you would get when you interpret lists as arrays and nth as <br>\narray access: If you access a cell outside the bounds of the array, you might get a <br>\ndifferent value for every index (assuming that your imperative language does not enforce <br>\nrange checks).</p>\n<p>Some time ago, undefined had a constraint for function types: !!x. undefined x = undefined<br>\nThis meant that an unspecified function is a constant function. I myself was not happy <br>\nwhen this constraint was removed, because it allowed all sorts of short-cuts in my proofs. <br>\nBut in the end, I am happy that it no longer is there: it has unnecessarily reduced the <br>\nfaithfulness of many models. And the same would happen if \"undefined :: 'a option\" would <br>\nbe constrained to None. For example, you could prove that the head of the empty list <br>\nalways is None, but that might be a realistic assumption.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294248705,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909931
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Jasmin,</p>\n<p>I agree that undefined is unfortunate, and unspecified would probably be a better name.<br>\nBut before you set out to rename it, let's first discuss it in a larger context.</p>\n<p>The NEWS file describes the replacement as follows:</p>\n<blockquote>\n<ul>\n<li>Constants \"undefined\" and \"default\" replace \"arbitrary\".  Usually<br>\n\"undefined\" is the right choice to replace \"arbitrary\", though<br>\nlogically there is no difference.  INCOMPATIBILITY.</li>\n</ul>\n</blockquote>\n<p>So there are actually two constants: undefined and default. And actually, there is quire <br>\nsome difference between them: \"undefined\" is frequently used by packages (primrec, <br>\nfunction, partial_function) in cases where the user has not given a full specification of <br>\na constant. Moreover, some Isabelle users use it in their own definitions when they need <br>\ndon't care or an arbitrary value. There are also some instances where you just need some <br>\nvalue in some proof and it's easier to use undefined instead of obtaining one via \"obtain <br>\nx :: my_type\".</p>\n<p>In contrast, default is a parameter of the type class default. As there are hardly any <br>\ninstances of default (see <br>\n<a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-June/msg00044.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-June/msg00044.html</a> for a <br>\nbrief discussion), regular Isabelle users hardly ever come across it.</p>\n<p>In my latest AFP entry (which will be accessible only after the release), I heavily use <br>\nundefined to model partially specified API functions of the target languages of the code <br>\ngenerator. Here, soundness relies on \"undefined\" really being an unspecified value of the <br>\nright type.</p>\n<p>What I have described so far would fit into the proposed renaming: unspecified captures <br>\nthe intent better than undefined.</p>\n<p>But maybe other people know of further usages for undefined.</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294248725,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909937
    },
    {
        "content": "<p>From: Lawrence Paulson &lt;<a href=\"mailto:lp15@cam.ac.uk\">lp15@cam.ac.uk</a>&gt;<br>\nI would argue that \"undefined\" and \"unspecified\" mean essentially the same thing, and it would be a bit like renaming \"azure\" to \"blue\". It is only a problem for people who imagine that \"undefined\" designates some sort of magical nothingness. There is no such thing in mathematics.</p>\n<p>Larry</p>",
        "id": 294248739,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909943
    },
    {
        "content": "<p>From: Jasmin Blanchette &lt;<a href=\"mailto:jasmin.blanchette@gmail.com\">jasmin.blanchette@gmail.com</a>&gt;<br>\nBut it's better style, and hardly more typing, to write the following:</p>\n<p>axiomatization where<br>\n    undefined_my_type_option: \"(undefined :: my_type option) = None\"</p>\n<p>Then you make your intentions clear, and tools like Nitpick will work correctly:</p>\n<p>lemma \"f (undefined :: my_type option) = f None\"<br>\n    nitpick</p>\n<p>Nitpick found no counterexample.</p>\n<p>Jasmin</p>",
        "id": 294248749,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909949
    },
    {
        "content": "<p>From: Michael Fourman &lt;<a href=\"mailto:Michael.Fourman@ed.ac.uk\">Michael.Fourman@ed.ac.uk</a>&gt;<br>\nThere are however non-terminating programs that can give rise to terms that have no denotation. </p>\n<p>Sent from my iPhone</p>",
        "id": 294248775,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909961
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nI was not happy when \"arbitrary\" was changed to \"undefined\" because I saw the<br>\nconfusion this would cause. I would support a new name (after the release) and<br>\n\"unspecified\" seems a good candidate.</p>\n<p>Concerning Larry's nothingness: just like Michael Fourman I have to point out<br>\nthat there are many approaches to logics with partial functions where terms may<br>\nsimply not denote. In fact, that is how many mathematicians would explain 1/0.</p>\n<p>Tobias</p>",
        "id": 294250497,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910529
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nIndeed the maior issue was the introduction of a separate »default«<br>\nbeside »arbitrary«, where »default« is a type class parameter.  It seems<br>\nthat only proof extraction does really use »default«, so this might<br>\ncount as argument ot move »default« to Extraction.thy.</p>\n<p>Concerning the naming of the constant now named »undefined«, my opinion<br>\nis just unspecified ;-).</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/3pRA43zOnxna3j1URjcDWpfR/signature.asc\">signature.asc</a></p>",
        "id": 294250729,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910626
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nAFAIR this (and similar formulations) is due to Alex Krauss.</p>\n<p>Florian<br>\n<a href=\"/user_uploads/14278/SgX1ZsxV_Y7z5-2cA-AZJtz1/signature.asc\">signature.asc</a></p>",
        "id": 294250743,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910631
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nOn Mon, 2013-09-30 at 18:06 +0200, Andreas Lochbihler wrote:</p>\n<blockquote>\n<p>I agree that undefined is unfortunate, and unspecified would probably<br>\nbe a better name.</p>\n</blockquote>\n<p>+1</p>\n<blockquote>\n<p>\"undefined\" is frequently used by packages (primrec, function,<br>\npartial_function) in cases where the user has not given a full<br>\nspecification of a constant.</p>\n</blockquote>\n<p>I am not sure how widespread this usage still is in Isabelle. But where<br>\nit happens, I consider it a (minor) shortcoming, because it leads to<br>\nspurious equations: the user arguably never intended to specify that,<br>\ne.g., \"hd [] = last []\".</p>\n<p>Best,<br>\nTjark</p>",
        "id": 294252268,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911207
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nHowever, this comes in handy in some cases. Consider, e.g., the<br>\nfollowing lemma:</p>\n<p>lemma map_eq_nth_eq:<br>\n  assumes A: \"map f l = map f l'\" <br>\n  shows \"f (l!i) = f (l'!i)\"</p>\n<p>without knowing that nth is undefined if the index is out of bounds,<br>\nthis lemma would have a precondition (i&lt;length l) which makes it harder<br>\nto be used by the simplifier.</p>",
        "id": 294252978,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911485
    },
    {
        "content": "<p>From: Tjark Weber &lt;<a href=\"mailto:webertj@in.tum.de\">webertj@in.tum.de</a>&gt;<br>\nObviously, stronger assumptions allow us to prove stronger theorems. But<br>\nthe real issue is whether our models are still sound.</p>\n<p>Best,<br>\nTjark</p>",
        "id": 294253133,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911551
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThis is an important observation.  In a system like HOL, where most <br>\nspecifications are actually definitions, \"not specified\" and \"not defined\" <br>\nmeans essentially the same.</p>\n<p>It is computer-science that has changed the literal meaning of \"undefined\" <br>\nand introduced a bias to mean something like \"crash\" or \"NPE\".</p>\n<p>HOL as a total logic has its own traditions to make creative use with <br>\nseemingly \"undefined\" things.  1/0 was mentioned already, but without an <br>\nexplanation of the theories built around it, notably by John Harrison. <br>\nThis greatly simplifies many proofs, at the cost of semantic confusion <br>\nabout what specifications mean.  Subtraction on nat is handled similarly.</p>\n<p>In 1996, when \"undefined\" was still called \"arbitrary\" someone giving a <br>\ntalk about an Isabelle/HOL formalization had it on one of the introductory <br>\nslides about the logic.  Since the audience was not HOL-istic that started <br>\na very long discussion about what it really means, and it was hard to get <br>\nto the main topic of the talk.  That incident has become one of the many <br>\nIsabelle in-jokes, until it was replaced by this formal one by Florian <br>\nHaftmann around 2005:</p>\n<p>if arbitrary = undefined then SOME x. True else SOME x. False</p>\n<p>Makarius</p>",
        "id": 294253482,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911686
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nHere is a vaguely related thread on the Scala internals mailing list:</p>\n<p><a href=\"https://groups.google.com/forum/#!topic/scala-internals/VkIVISmaxFQ/discussion[1-25-false]\">https://groups.google.com/forum/#!topic/scala-internals/VkIVISmaxFQ/discussion[1-25-false]</a></p>\n<p>Odersky ultimately calls his version of \"undefined\" with the symbolic name <br>\n\"???\".  Semantically it is of the \"crash\" / \"NPE\" kind, since this is <br>\nprogramming, not logic.</p>\n<p>Makarius</p>",
        "id": 294253810,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911821
    },
    {
        "content": "<p>From: Joachim Breitner &lt;<a href=\"mailto:breitner@kit.edu\">breitner@kit.edu</a>&gt;<br>\nHi,</p>\n<p>I can confirm this observation from a few weeks ago, when I talked about<br>\na Isabelle formalization of mine to a group that work on the same<br>\nproofs, but without a proof assistant. I think I got the idea behind<br>\nundefined across, but I’m not sure about that, and it certainly did not<br>\nmake a good impression on the audience.</p>\n<p>I sometimes wish for better support for partially defined things, where<br>\nI have the vague idea that when, for example, I write \"a ⊔ b\" somewhere,<br>\nthen the compatibility of a and b in their order either comes as an<br>\nimplicit fact, or an implicit proof obligation. But I’m not even sure<br>\nhow to detect which of the two I want...</p>\n<p>Greetings,<br>\nJoachim<br>\n<a href=\"/user_uploads/14278/rfyPPiNovrhntbI-a7XJvXvM/signature.asc\">signature.asc</a></p>",
        "id": 294253970,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660911889
    }
]