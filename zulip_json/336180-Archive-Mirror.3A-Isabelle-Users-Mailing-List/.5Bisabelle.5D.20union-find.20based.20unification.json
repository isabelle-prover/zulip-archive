[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear all,</p>\n<p>is anybody aware of an Isabelle/HOL (or even better Imperative_HOL) <br>\nformalization of a union-find data structure for which also code can be <br>\ngenerated? I found</p>\n<p><a href=\"http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml\">http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml</a></p>\n<p>which mentions union-find trees in the introduction, but by skimming <br>\nover the theory names nothing immediately jumped at me ;)</p>\n<p>The reason I ask is for an efficient (code generatable) formalization, <br>\nusing union-find,  of a first-order unification algorithm. Anybody aware <br>\nthat this was already done?</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294237022,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905242
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nHi Christian,</p>\n<p>I have an efficient first-order unification algorithm in Imperative HOL <br>\nin my shelf (from back in 2009).<br>\nI was mainly interested in using Imperative HOL and what the problems in <br>\nlarger developments are with the Imperative HOL framework.<br>\nAlso, we used that as case study for the partial function prototype in 2010.</p>\n<p>However, I never found time to polish the proofs and make that work <br>\npublicly available.<br>\nIf you are interested, we can discuss if the unpolished development is <br>\nof any use for you.</p>\n<p>Lukas</p>",
        "id": 294237070,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905249
    },
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Lukas,</p>\n<p>I vaguely remember that we already talked about this and well, I am <br>\ninterested ;)</p>\n<p>(If possible, I would like to improve the generated code for IsaFoR, <br>\nhowever, after some recent improvements by René, this might no longer be <br>\nnecessary, let's see.)</p>\n<p>In principle I'm also interested in using Imperative HOL for algorithm <br>\nrefinement prior to code generation (at the moment it's not clear to me <br>\nwhether this is possible at all, i.e., for some pure function \"f\", prove <br>\nthat an Imperative HOL function \"g\" is a faithful implementation... if I <br>\nunderstand correctly, \"g\" will always have its result type wrapped in <br>\n\"Heap\" and thus we cannot prove a code equation between \"f\" and \"g\"... <br>\nbut maybe I'm wrong).</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294237102,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905261
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;</p>\n<blockquote>\n<p><a href=\"http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml\">http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml</a></p>\n</blockquote>\n<p>The union-find structures are in the examples folder in<br>\nExamples/Union_Find.thy.</p>\n<p>However, someone seems to have messed up ROOT.ML when porting to<br>\nIsabelle2013, such that this file is not compiled any more!</p>\n<p>I'll check whether Union_Find still compiles under 2013, and send a<br>\npatch here if it does not.</p>\n<p>Best, and thanks for pointing to the problem,<br>\n  Peter</p>\n<blockquote>\n<p>which mentions union-find trees in the introduction, but by skimming <br>\nover the theory names nothing immediately jumped at me ;)</p>\n<p>The reason I ask is for an efficient (code generatable) formalization, <br>\nusing union-find,  of a first-order unification algorithm. Anybody aware <br>\nthat this was already done?</p>\n<p>cheers</p>\n<p>chris</p>\n</blockquote>",
        "id": 294237162,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905291
    },
    {
        "content": "<p>From: Lukas Bulwahn &lt;<a href=\"mailto:bulwahn@in.tum.de\">bulwahn@in.tum.de</a>&gt;<br>\nHi Christian,</p>\n<p>On 03/22/2013 08:21 AM, Christian Sternagel wrote:</p>\n<blockquote>\n<p>Dear Lukas,</p>\n<p>I vaguely remember that we already talked about this and well, I am <br>\ninterested ;)</p>\n<p>I will send you the sources. If you have time to polish it, we can <br>\nsubmit it to the AFP.<br>\n(If possible, I would like to improve the generated code for IsaFoR, <br>\nhowever, after some recent improvements by René, this might no longer <br>\nbe necessary, let's see.)</p>\n<p>I believe that the functional implementation of unification based on a <br>\nefficient functional Map implementation is only a minor constant factor <br>\nslower than the imperative implementation.<br>\nThen you would not even have to consider the Imperative HOL setting.</p>\n</blockquote>\n<blockquote>\n<p>In principle I'm also interested in using Imperative HOL for algorithm <br>\nrefinement prior to code generation (at the moment it's not clear to <br>\nme whether this is possible at all, i.e., for some pure function \"f\", <br>\nprove that an Imperative HOL function \"g\" is a faithful <br>\nimplementation... if I understand correctly, \"g\" will always have its <br>\nresult type wrapped in \"Heap\" and thus we cannot prove a code equation <br>\nbetween \"f\" and \"g\"... but maybe I'm wrong).</p>\n<p>I have an argument how to define escaping this monad and set up code <br>\ngeneration in a sound way by extending the code generation specialities <br>\nfor Imperative HOL even more.<br>\nHowever, I would rather want to see that the monad remains in the whole <br>\nprogram.</p>\n</blockquote>\n<p>I was always hoping that the newly developed Lifting package could <br>\nautomate the tedious task of lifting all purely functional parts into <br>\nthe monad, but I never tried that.</p>\n<p>Lukas</p>\n<blockquote>\n<p>cheers</p>\n<p>chris</p>\n<p>On 03/22/2013 02:48 PM, Lukas Bulwahn wrote:</p>\n<blockquote>\n<p>Hi Christian,</p>\n<p>I have an efficient first-order unification algorithm in Imperative HOL<br>\nin my shelf (from back in 2009).<br>\nI was mainly interested in using Imperative HOL and what the problems in<br>\nlarger developments are with the Imperative HOL framework.<br>\nAlso, we used that as case study for the partial function prototype in<br>\n2010.</p>\n<p>However, I never found time to polish the proofs and make that work<br>\npublicly available.<br>\nIf you are interested, we can discuss if the unpolished development is<br>\nof any use for you.</p>\n<p>Lukas</p>\n</blockquote>\n<p>On 03/22/2013 06:03 AM, Christian Sternagel wrote:</p>\n<blockquote>\n<blockquote>\n<p>Dear all,</p>\n<p>is anybody aware of an Isabelle/HOL (or even better Imperative_HOL)<br>\nformalization of a union-find data structure for which also code can<br>\nbe generated? I found</p>\n<p><a href=\"http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml\">http://afp.sourceforge.net/entries/Separation_Logic_Imperative_HOL.shtml</a> </p>\n<p>which mentions union-find trees in the introduction, but by skimming<br>\nover the theory names nothing immediately jumped at me ;)</p>\n<p>The reason I ask is for an efficient (code generatable) formalization,<br>\nusing union-find,  of a first-order unification algorithm. Anybody<br>\naware that this was already done?</p>\n<p>cheers</p>\n<p>chris</p>\n</blockquote>\n</blockquote>\n</blockquote>",
        "id": 294237170,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905297
    },
    {
        "content": "<p>From: Peter Lammich &lt;<a href=\"mailto:lammich@in.tum.de\">lammich@in.tum.de</a>&gt;<br>\nIf you want to invest some manual work in the algorithm refinement, you<br>\ncan see examples how to do that in the Separation_Logic_Imperative_HOL<br>\nentry. For example, the Union_Find data structures are first formalized<br>\nand proved correct on functional lists, and then refined to<br>\nImperative/HOL.</p>\n<p>Currently, I'm working on a more automatic way to refine (monadic, using<br>\nthe refinement monad) programs to Imperative/HOL, but there is nothing<br>\nto show yet.</p>",
        "id": 294237191,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905305
    },
    {
        "content": "<p>From: Gerwin Klein &lt;<a href=\"mailto:Gerwin.Klein@nicta.com.au\">Gerwin.Klein@nicta.com.au</a>&gt;<br>\nThis seems to be my fault. It's now back in and online again.</p>\n<p>Cheers,<br>\nGerwin</p>\n<hr>\n<p>The information in this e-mail may be confidential and subject to legal professional privilege and/or copyright. National ICT Australia Limited accepts no liability for any damage caused by this email or its attachments.</p>",
        "id": 294237225,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905316
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nThat is a very interesting observation.</p>\n<p>Just yesterday, I've attended a talk by a Coq person who made substantial <br>\ninvestments to include monadic imperative programming to the Coq code <br>\nextraction mechanism.  He had exactly the same example, so there is <br>\nprobably just that one :-)  I was also wondering how much you get in <br>\nreturn for adding such impurity Coq.  (The approach was also somehow <br>\nbiased towards sequential execution, which is a bit anachronistic for code <br>\noptimization.)</p>\n<p>So maybe I should point him to this mail thread, to join the discussion.</p>\n<p>Makarius</p>",
        "id": 294237251,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660905328
    }
]