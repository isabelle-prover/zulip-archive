[
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nHello,</p>\n<p>I am interested in using Isabelle to simplify a formula based on a<br>\nspecific theory.</p>\n<p>If I would use the Isabelle/jEdit interface I would create a dummy theory</p>\n<p>theory MySimp imports BaseTheory<br>\nbegin</p>\n<p>lemma \"expression to simplify = A\"<br>\n  apply simp</p>\n<p>At this point the result that I am interested is<br>\nthe left hand-side of the current goal.</p>\n<p>How can this be done programmatically? Should I use<br>\n\"isabelle_process\" or \"isabelle console\"?</p>\n<p>Best regards,</p>\n<p>Viorel Preoteasa</p>",
        "id": 294638400,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161092
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>How can this be done programmatically? Should I use<br>\n\"isabelle_process\" or \"isabelle console\"?</p>\n</blockquote>\n<p>First of all, there's 'Simplifier.rewrite':</p>\n<p>ML‹Simplifier.rewrite @{context} @{cterm \"rev []\"}›</p>\n<p>... which results in</p>\n<p>val it = \"rev [] ≡ []\": thm</p>\n<p>This should be an easy-enough interface to perform just what you need.</p>\n<p>Second, there's the question how to invoke just this bit. I think<br>\n'isabelle console' is out – quoting from the system manual:</p>\n<p>\"Interaction works via the raw ML toplevel loop: this is neither<br>\nIsabelle/Isar nor Isabelle/ML within the usual formal context. Some<br>\nuseful ML commands at this stage are cd, pwd, use, use_thy, use_thys.\"</p>\n<p>'isabelle_process' is even more low-level.</p>\n<p>In which environment do you intend to invoke the simplifier? In some<br>\nprogram of yours? Via bash? Something else? Repeatedly, or just one-off?</p>\n<p>Cheers<br>\nLars<br>\n<a href=\"/user_uploads/14278/9p8igj2fz2jYx4CL1sN0Up6I/smime.p7s\">smime.p7s</a></p>",
        "id": 294638408,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161096
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nOn 04/09/2015 04:46 PM, Lars Hupel wrote:</p>\n<blockquote>\n<blockquote>\n<p>How can this be done programmatically? Should I use<br>\n\"isabelle_process\" or \"isabelle console\"?<br>\nFirst of all, there's 'Simplifier.rewrite':</p>\n</blockquote>\n<p>ML‹Simplifier.rewrite @{context} @{cterm \"rev []\"}›<br>\nThe function Simplifier.rewrite seem to be available in isabelle_process,<br>\nbut I don't know how to get the context, and the term in the right<br>\nform. The actual simplifying command contains also<br>\nsome lemmas that I do not necessarily want as simplification<br>\nrules.</p>\n</blockquote>\n<p>I noticed also that there is a function for parsing terms, but it also<br>\nrequires a context parameter. It seems that what I should do is:</p>\n<p>context = ...<br>\nT = Simplifier.rewrite context (Syntax.parse_term context \"...\")<br>\nresult =  Syntax.string_of_term context (the right hand side term of T)</p>\n<blockquote>\n<p>... which results in</p>\n<p>val it = \"rev [] ≡ []\": thm</p>\n<p>This should be an easy-enough interface to perform just what you need.</p>\n<p>Second, there's the question how to invoke just this bit. I think<br>\n'isabelle console' is out – quoting from the system manual:</p>\n<p>\"Interaction works via the raw ML toplevel loop: this is neither<br>\nIsabelle/Isar nor Isabelle/ML within the usual formal context. Some<br>\nuseful ML commands at this stage are cd, pwd, use, use_thy, use_thys.\"</p>\n<p>'isabelle_process' is even more low-level.</p>\n<p>In which environment do you intend to invoke the simplifier? In some<br>\nprogram of yours? Via bash? Something else? Repeatedly, or just one-off?<br>\nI need to perform this operation from within a Python program.<br>\nI use Python to produce some terms based on some specification,<br>\nand I need them simplified using Isabelle. The terms are using<br>\ndefinitions from the supporting theory.</p>\n</blockquote>\n<p>Viorel</p>",
        "id": 294638417,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161103
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;</p>\n<blockquote>\n<p>Second, there's the question how to invoke just this bit. I think<br>\n'isabelle console' is out – quoting from the system manual:</p>\n</blockquote>\n<p>This assessment was wrong. It is possible with 'isabelle console':</p>\n<p>$ bin/isabelle console</p>\n<blockquote>\n<p>val commit = fn: unit -&gt; bool<br>\nval it = (): unit<br>\nML&gt; val thy = Thy_Info.get_theory \"Main\";<br>\nval thy = ...: theory</p>\n</blockquote>\n<blockquote>\n<p>From there on, you can obtain a context:</p>\n</blockquote>\n<p>ML&gt; val ctxt = Proof_Context.init_global thy;<br>\nval ctxt = &lt;context&gt;: Proof.context</p>\n<p>Now you can read a term (not just parse!):</p>\n<p>ML&gt; val t = Syntax.read_term ctxt \"rev []\";<br>\nval t =<br>\n   Const (\"List.rev\", \"'a List.list =&gt; 'a List.list\") $<br>\n     Const (\"List.list.Nil\", \"'a List.list\"): term</p>\n<p>... and rewrite:</p>\n<p>ML&gt; Simplifier.rewrite ctxt (cterm_of thy t) |&gt; Thm.rhs_of;<br>\nval it = \"[]\": cterm</p>\n<p>Does that help?</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294638422,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161108
    },
    {
        "content": "<p>From: Lars Noschinski &lt;<a href=\"mailto:noschinl@in.tum.de\">noschinl@in.tum.de</a>&gt;<br>\nLars has already written something about how to acquire a context.<br>\nDepending on what you do with the terms in your program, it might be a<br>\ngood idea to use the YXML format to pass terms between Isabelle and your<br>\nprogram. There have been some discussions on that subject in the past.</p>",
        "id": 294638439,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161121
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nIf you are free to choose the language of your tool, may I suggest to<br>\nconsider Java or Scala: For the JVM, there is the possibility to<br>\ncommunicate with the prover in a canonical way (i.e.<br>\nstarting/stopping/sending messages to the prover can be done with<br>\nregular function calls, instead of performing low-level process<br>\noperations and I/O).</p>",
        "id": 294638448,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161127
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nThank you Lars,</p>\n<p>This is exactly what I need. I tested it with both<br>\nisabelle console and isabelle_process, and it works<br>\nin the same way.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294638459,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161133
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nThis is a good point. Thank you. We will use the simplified<br>\nexpressions to generate some other Isabelle file, so for this<br>\npurpose we do not need the xml format.</p>\n<p>Best regards,</p>\n<p>Viorel</p>",
        "id": 294638473,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161139
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nFor me a console is a device where a human is sitting to connect to the <br>\ncomputer.  A tty is something similar, but from the Unix world (actually a <br>\nbrand name of a particular device).</p>\n<p>\"Programmatically\" probably refers to batch mode, so the raw <br>\nisabelle_process is the most elementary way to do it.</p>\n<p>The examples so far on this thread where using the cold and naked toplevel <br>\nof the underlying ML system -- working there is possible, but might become <br>\na bit awkward.  Isabelle/ML normally runs within the Isabelle environment, <br>\ne.g. with a theory that is loaded via use_thy from outside.</p>\n<p>Much more possibilities of \"programmatic\" use of Isabelle are thinkable, <br>\ne.g. taling to Isabelle/Scala as already explained by Lars Hupel.  In may <br>\napplications one might even want to talk directly within the PIDE to the <br>\nIsabelle process, depending on user interaction result.</p>\n<p>There are many possiblities beyond 1970-TTY-mode.  It all depends on the <br>\napplication what is the best way.</p>\n<p>Makarius</p>",
        "id": 294638488,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161145
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nGenerating Isabelle sources sounds a bit odd.  Depending on the actual <br>\napplication, it might be easier to put the \"programmatic\" part into <br>\nIsabelle itself, as a small Isabelle/ML tool that reads the input and <br>\ndrives the system in the intended way, then outputs the results somewhere <br>\nelse.  But you did not explain the intention so far.</p>\n<p>Makarius</p>",
        "id": 294638497,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161151
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nOn 04/09/2015 11:17 PM, Makarius wrote:</p>\n<blockquote>\n<p>On Thu, 9 Apr 2015, Viorel Preoteasa wrote:</p>\n<blockquote>\n<p>How can this be done programmatically? Should I use<br>\n\"isabelle_process\" or \"isabelle console\"?</p>\n</blockquote>\n<p>For me a console is a device where a human is sitting to connect to<br>\nthe computer.  A tty is something similar, but from the Unix world<br>\n(actually a brand name of a particular device).<br>\nHere, I just meant the option \"console\" available for the bin/isabelle<br>\ncommand. Ideally I would need an API<br>\navailable in Python which does what I need: Simplifies a term based on a<br>\nspecific theory. I understand<br>\nnow that this API is available for Scala, and of course for SML, so in<br>\nthe future I may use Scala.</p>\n</blockquote>\n<p>On the other hand, even if using SML, getting started with it does not<br>\nseem easy. I tried to find the right<br>\nfunctions for this job before posting the question to the mailing list.</p>\n<blockquote>\n<p>\"Programmatically\" probably refers to batch mode, so the raw<br>\nisabelle_process is the most elementary way to do it.<br>\nYou are right, maybe batch mode is more appropriate term.</p>\n</blockquote>\n<p>Thank you,</p>\n<p>Viorel</p>",
        "id": 294638515,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161157
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nDo you mean SML as a language, or Isabelle/ML as a language + library?</p>\n<p>Getting started with Standard ML should be easy, using resources on the <br>\nweb or text books.</p>\n<p>Getting started with Isabelle/ML should be easy as well, since the <br>\nIsabelle Prover IDE allows to explore whatever you see, down to its actual <br>\ndefinition.  Tools are defined in Isabelle/ML, so the standard PIDE <br>\ncontrol-hover-click over Isar commands, methods, attributes etc. will show <br>\nthe relevant ML definitions.</p>\n<p>Reading and understanding that needs some practice and some guidance, <br>\nthough. The \"implementation\" provides many explanations of many things, <br>\nbut it is not a quick-and-dirty HOWTO guide.</p>\n<p>Depending on what you ultimately want to achieve, some decent Isabelle/ML <br>\ncould work out easier and more robust than tinkering with scripting <br>\nlanguages, processes, generated sources etc.</p>\n<p>Makarius</p>",
        "id": 294638537,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161170
    },
    {
        "content": "<p>From: Viorel Preoteasa &lt;<a href=\"mailto:viorel.preoteasa@aalto.fi\">viorel.preoteasa@aalto.fi</a>&gt;<br>\nOn 04/10/2015 11:58 AM, Makarius wrote:</p>\n<blockquote>\n<p>On Fri, 10 Apr 2015, Viorel Preoteasa wrote:</p>\n<blockquote>\n<p>Ideally I would need an API available in Python which does what I<br>\nneed: Simplifies a term based on a specific theory. I understand now<br>\nthat this API is available for Scala, and of course for SML, so in<br>\nthe future I may use Scala.</p>\n<p>On the other hand, even if using SML, getting started with it does<br>\nnot seem easy. I tried to find the right functions for this job<br>\nbefore posting the question to the mailing list.</p>\n</blockquote>\n<p>Do you mean SML as a language, or Isabelle/ML as a language + library?<br>\nI mean Isabelle/ML as a language + library.</p>\n<p>Getting started with Standard ML should be easy, using resources on<br>\nthe web or text books.</p>\n<p>Getting started with Isabelle/ML should be easy as well, since the<br>\nIsabelle Prover IDE allows to explore whatever you see, down to its<br>\nactual definition.  Tools are defined in Isabelle/ML, so the standard<br>\nPIDE control-hover-click over Isar commands, methods, attributes etc.<br>\nwill show the relevant ML definitions.<br>\nGetting started was a bit difficult because I could not find an example<br>\nwhich<br>\nwas self contained and small.</p>\n</blockquote>\n<p>After asking on the mailing list, the answer by Lars, was very helpful<br>\n(ML‹Simplifier.rewrite @{context} @{cterm \"rev []\"}›), but it was working<br>\nwithin an Isabelle theory only, and not as standalone Isabelle/ML program.<br>\nThe final Isabelle/ML program which does what I need is the following:</p>\n<p>use_thy \"AutoSimp\";<br>\nval thy = Thy_Info.get_theory \"AutoSimp\";<br>\nfun term_to_string ctxt t =<br>\n  let<br>\n    val ctxt' = Config.put show_markup false ctxt;<br>\n    in Print_Mode.setmp [] (Syntax.string_of_term ctxt') t end;</p>\n<p>val ctxt = Proof_Context.init_global thy;<br>\nval t = Syntax.read_term ctxt \"rel (ExampleA0) (si_f) (d,so_f)\";<br>\nval simp_term_a = Simplifier.rewrite ctxt (cterm_of thy t) |&gt; Thm.rhs_of;<br>\nval simp_term_b = term_of simp_term_a;<br>\nval result = term_to_string ctxt simp_term_b;<br>\nwriteln result;</p>\n<p>It is conceptually very simple, but figuring out all these functions<br>\nwas not that simple. I could do it only with the help of the answers<br>\nfrom the mailing list.</p>\n<p>For example figuring out how to use Syntax.string_of_term was also<br>\nnot easy. I found this way of using Syntax.string_of_term in an old message<br>\nfor the mailing list. I do not understand it fully, but it seems it does<br>\nwhat<br>\nI need.</p>\n<p>It is not clear to me if it is better to use this program as such or embed<br>\nas ML{<em>...</em>} into a theory file. In the end I am only interested in the<br>\nstring from the variable result.</p>\n<blockquote>\n<p>Reading and understanding that needs some practice and some guidance,<br>\nthough. The \"implementation\" provides many explanations of many<br>\nthings, but it is not a quick-and-dirty HOWTO guide.<br>\nThe main problem was getting started.</p>\n<p>Depending on what you ultimately want to achieve, some decent<br>\nIsabelle/ML could work out easier and more robust than tinkering with<br>\nscripting languages, processes, generated sources etc.<br>\nMy use case is very simple now, and it is mainly exploratory. Using<br>\nScala can be a good<br>\nsolution, however Python is also a convenient language. Isabelle/ML can<br>\nalso be a<br>\nsolution, but the problem remains the same, figuring out the right<br>\nfunctions for<br>\nsolving the problem.</p>\n</blockquote>\n<p>Passing strings from one program to another does not seem such a big<br>\nproblem,<br>\nand Python has a simple API for working with external programs.</p>\n<p>By the way, how is the communication between Scala and Isabelle/ML done?<br>\nI assume it is also by having the Isabelle/ML process running in the<br>\nbackground,<br>\nand by sending and receiving strings via pipes.</p>\n<p>Viorel</p>",
        "id": 294638556,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161176
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nThat's almost correct. Communication between the processes works via<br>\nsockets these days, and the strings which are passed back and forth are<br>\nactually represent XML documents. Both Isabelle/Scala and Isabelle/ML<br>\noffer combinators for encoding (and decoding) arbitrary data to (and<br>\nfrom) XML.</p>\n<p>The major advantage in using Isabelle/Scala is that someone else takes<br>\ncare of implementing resource control, session management, thread<br>\npooling, ... and offer a nice high-level API for that. Using this API is<br>\nmuch more robust as compared to forking out processes by hand,<br>\nespecially for serious applications.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294638598,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161194
    },
    {
        "content": "<p>From: Makarius &lt;<a href=\"mailto:makarius@sketis.net\">makarius@sketis.net</a>&gt;<br>\nOn Fri, 10 Apr 2015, Viorel Preoteasa wrote:</p>\n<blockquote>\n<p>After asking on the mailing list, the answer by Lars, was very helpful<br>\n(ML‹Simplifier.rewrite @{context} @{cterm \"rev []\"}›), but it was working<br>\nwithin an Isabelle theory only, and not as standalone Isabelle/ML program.</p>\n</blockquote>\n<p>Isabelle/ML always runs in such a formal context, i.e. inside a theory or <br>\na more deeply nested context that is built up by other means.  In such a <br>\nsituation the ML antiquotation @{context} provides the all-important <br>\ncontext at compile time.  When you implement your own tools, say a command <br>\nor proof method, you get the context at runtime from the system <br>\ninfrastructure -- that is in fact the normal situation.</p>\n<blockquote>\n<p>The final Isabelle/ML program which does what I need is the following:</p>\n<p>use_thy \"AutoSimp\";<br>\nval thy = Thy_Info.get_theory \"AutoSimp\";<br>\nfun term_to_string ctxt t =<br>\n let<br>\n   val ctxt' = Config.put show_markup false ctxt;<br>\n   in Print_Mode.setmp [] (Syntax.string_of_term ctxt') t end;</p>\n<p>val ctxt = Proof_Context.init_global thy;<br>\nval t = Syntax.read_term ctxt \"rel (ExampleA0) (si_f) (d,so_f)\";<br>\nval simp_term_a = Simplifier.rewrite ctxt (cterm_of thy t) |&gt; Thm.rhs_of;<br>\nval simp_term_b = term_of simp_term_a;<br>\nval result = term_to_string ctxt simp_term_b;<br>\nwriteln result;</p>\n</blockquote>\n<p>This is not an Isabelle/ML program, but raw SML outside of the Isabelle <br>\nenvironment.  You won't get very far for non-trivial things.  E.g. the <br>\nwhole Isabelle/HOL modules and tools are not accessible -- in fact the <br>\naccessibility of Isabelle/Pure outside the normal Isabelle environment is <br>\nmerely an artifact of bootstrapping.</p>\n<p>As the system manual points out, use_thy is the main thing you can do in <br>\nthis raw ML bootstrap environment, i.e. to get into some theory context to <br>\ndo the actual work.</p>\n<blockquote>\n<p>It is not clear to me if it is better to use this program as such or embed<br>\nas ML{<em>...</em>} into a theory file. In the end I am only interested in the<br>\nstring from the variable result.</p>\n</blockquote>\n<p>ML {<em>...</em>} is always better, unless there is a very special situation. <br>\nML_file is the same and useful for bigger text files, also with more<br>\nsupport in the editor.</p>\n<blockquote>\n<p>Scala can be a good solution, however Python is also a convenient <br>\nlanguage. Isabelle/ML can also be a solution, but the problem remains <br>\nthe same, figuring out the right functions for solving the problem.</p>\n</blockquote>\n<p>Many years ago, I was considering Python as Isabelle system programming <br>\nlanguage, but it later became Scala.  Today, you can do a fair amount of <br>\nsystem programming both in Isabelle/Scala and Isabelle/ML, and it is<br>\ninitially hard to tell which side is better for an application.  There are <br>\nalso applications on both sides, which requires some bilingual fluency. <br>\nBut the Isabelle/Scala and Isabelle/ML conventions and libraries are as <br>\nclose to each other as feasible.</p>\n<p>E.g. there is Isabelle_System.bash to invoke an external process running a <br>\nshell script both in Isabelle/ML and Isabelle/Scala.</p>\n<blockquote>\n<p>Passing strings from one program to another does not seem such a big <br>\nproblem, and Python has a simple API for working with external programs.</p>\n<p>By the way, how is the communication between Scala and Isabelle/ML done? <br>\nI assume it is also by having the Isabelle/ML process running in the <br>\nbackground, and by sending and receiving strings via pipes.</p>\n</blockquote>\n<p>That is a very crude model, and the reality with something that actually <br>\nworks robustly and efficiently came out a bit different than I anticipated <br>\n7 or 8 years ago.  My ITP 2014 paper has a small section on PIDE <br>\narchitecture and protocol layers: <br>\n<a href=\"http://www4.in.tum.de/~wenzelm/papers/itp-pide.pdf\">http://www4.in.tum.de/~wenzelm/papers/itp-pide.pdf</a> -- another version of <br>\nthat aspect is explained here for Coq (!) <a href=\"http://arxiv.org/abs/1304.6626\">http://arxiv.org/abs/1304.6626</a></p>\n<p>So Isabelle/PIDE solves that prover connectivity problem.  It just needs <br>\nto be reused.  The usual errors and mistakes don't have to be repeated.</p>\n<p>Makarius</p>",
        "id": 294638615,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661161201
    }
]