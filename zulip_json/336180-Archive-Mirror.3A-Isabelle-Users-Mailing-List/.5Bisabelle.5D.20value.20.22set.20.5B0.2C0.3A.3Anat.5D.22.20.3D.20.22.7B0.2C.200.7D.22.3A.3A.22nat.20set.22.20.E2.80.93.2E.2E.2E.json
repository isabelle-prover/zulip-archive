[
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\nDear Isabelle developers,</p>\n<p>in Isabelle2013 the expression</p>\n<p>value \"set [0,0::nat]\"</p>\n<p>evaluates to</p>\n<p>\"{0, 0}\"<br>\n  :: \"nat set\"</p>\n<p>Looks like a bug to me.  Even more so because</p>\n<p>value \"{0, 0}::(nat set)\"</p>\n<p>yields</p>\n<p>\"{0}\"<br>\n  :: \"nat set\"</p>\n<p>as expected.</p>\n<p>Cheers, and have a nice weekend,</p>\n<p>Christoph</p>",
        "id": 294247623,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909527
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nChristoph,</p>\n<p>Duplication of elements is allowed in sets.</p>\n<p>theorem<br>\n   \"set [0,0::nat] = {0} &amp;<br>\n    {0::nat} = {0,0,0,0,0}\"<br>\nby(simp)</p>\n<p>From List.thy:</p>\n<p>primrec set :: \"'a list =&gt; 'a set\" where<br>\n\"set [] = {}\" |<br>\n\"set (x # xs) = insert x (set xs)\"</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294247638,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909532
    },
    {
        "content": "<p>From: Tobias Nipkow &lt;<a href=\"mailto:nipkow@in.tum.de\">nipkow@in.tum.de</a>&gt;<br>\nAm 03/09/2013 20:26, schrieb Makarius:</p>\n<blockquote>\n<p>On Fri, 30 Aug 2013, Christoph LANGE wrote:</p>\n<blockquote>\n<p>in Isabelle2013 the expression</p>\n<p>value \"set [0,0::nat]\"</p>\n<p>evaluates to</p>\n<p>\"{0, 0}\"<br>\n :: \"nat set\"</p>\n<p>Looks like a bug to me.  Even more so because</p>\n<p>value \"{0, 0}::(nat set)\"</p>\n<p>yields</p>\n<p>\"{0}\"<br>\n :: \"nat set\"</p>\n<p>as expected.</p>\n</blockquote>\n</blockquote>\n<p>Sigh. Let me clarify this a little. If value \"set [0,0::nat]\" had returned, for<br>\nexample, \"{1,1}\", I would agree with Christoph that it's a bug, and a highly<br>\nembarrassing one: value is meant to return a term that is equal to the start<br>\nterm. Since there are three different evaluation engines for the value command<br>\nand there is also the simp proof method, you can obtain different results in<br>\ndifferent situations. But in all cases you should get an equality. Christoph<br>\nalso expected some kind of normal form. You should get this for ground terms of<br>\ntypes that have normal forms (like lists), but sets do not have normal forms.</p>\n<p>Tobias</p>\n<blockquote>\n<p>Someone who understands the details of the Isabelle/HOL code generator setup<br>\nneeds to say if this is right or wrong, desirable or undesirable etc.  I can<br>\nonly make some general remarks.</p>\n<p>To the constant amusement of the two Isabelle mailing list, the word \"bug\" has<br>\nlost any meaning to me many years ago.  I don't even remember when it was still<br>\nin my vocabulary.  You just don't walk out in the street of a city like e.g.<br>\nLondon, Paris, Rome, see old and beautiful buildings, maybe with some parts in<br>\nneed of cleaning or some repair and say \"bug\" or \"needs to be fixed\".  Beyond a<br>\ncertain complexity of a system it simple does not make any sense to pretend that<br>\nthere are individual small bits to be exterminated, in order to make it better.</p>\n<p>Whenever there is an incident of surprise or unexpected behaviour by the user<br>\none has to ask the canonical questions, (1) if the system needs to be changed to<br>\nmeet user's expectations, (2) the user needs to change his expectations, or (3)<br>\nthe system needs to change its way of presenting its results such that they look<br>\nexpectedly to the user.</p>\n<p>More to the point of this particular example.  I am sensing here an expectation<br>\nof a universal normal form of expressions in Isabelle/HOL. This concept exists<br>\nin some schools of Type Theory, but not in HOL nor mathematical logic nor<br>\nmathematics in general.  (HOL is also not a programming language that you could<br>\nrun deterministically to get \"the\" result.)  Instead there are just logical<br>\nterms to start with (with some mathematical meaning, potentially more than one<br>\nway), and tools operating on that representation symbolically.</p>\n<p>For example, the proof method \"simp\" uses the Isabelle Simplifier to produce<br>\nnormal forms wrt. a given term rewriting system in the context, according to<br>\ncertain strategies and add-on tools (simprocs).</p>\n<p>In contrast, the 'value' command uses Isabelle/HOL code generator +<br>\nNormalization by Evaluation to produce certain normal forms of ML datatypes that<br>\nare then printed again as terms.  This you get the illusion that there is some<br>\n\"executable fragment\" of HOL that evaluates efficiently (with the help of the<br>\nunderlying Isabelle/ML system).</p>\n<p>There is no necessity of any such tools to agree on the result, both<br>\nconceptually and accidentally due to different tool setups. This non-uniformity<br>\nof tools is sometimes bad, but I think it is generally a good thing in not<br>\ninsisting in one grand unified logical environment that determines everything<br>\nfrom the start.  Thus new ideas and techniques may get implemented over time<br>\n(here we need to think in terms of 20-30 years of the current generation of<br>\nproof assistants).</p>\n<p>Makarius<br>\n</p>\n</blockquote>",
        "id": 294247832,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660909618
    },
    {
        "content": "<p>From: Christoph LANGE &lt;<a href=\"mailto:math.semantic.web@gmail.com\">math.semantic.web@gmail.com</a>&gt;<br>\n2013-08-30 17:35 Gottfried Barrow:</p>\n<blockquote>\n<p>Duplication of elements is allowed in sets.</p>\n</blockquote>\n<p>Thanks, Gottfried, for explaining.  Still seems odd to me, but I'm sure<br>\nthere are good reasons, e.g. in terms of efficiency.</p>\n<p>Cheers,</p>\n<p>Christoph</p>",
        "id": 294249256,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910121
    },
    {
        "content": "<p>From: Gottfried Barrow &lt;<a href=\"mailto:gottfried.barrow@gmx.com\">gottfried.barrow@gmx.com</a>&gt;<br>\nI assume it's just because they don't go the extra step to simplify the <br>\nanswer. I don't do a lot of computation, but I've seen that what \"value\" <br>\nreturns and what \"simp\" returns is frequently not identical. I guess it <br>\nall depends on how \"value\" uses the simp rules, or it's own custom rules.</p>\n<p>Examples:</p>\n<p>(<em>1</em>)<br>\nvalue \"set [0::nat, 1, 0]\"<br>\n   (* Output: \"{0, 1, 0}\" *)</p>\n<p>(<em>2</em>)<br>\nvalue \"{0::nat, 1, 0}\"<br>\n   (* Output: \"{1, 0}\" *)</p>\n<p>(<em>3</em>)<br>\ndeclare[[simp_trace=true]]<br>\ntheorem \"{0::nat, 1, 0} = z\"<br>\napply(simp)<br>\n   (* Output: {0, Suc 0, 0} = z *)<br>\noops</p>\n<p>(<em>4</em>)<br>\ntheorem \"{0::nat, 0, 1} = z\"<br>\napply(simp)<br>\n   (* Output: {0, Suc 0} = z<br>\n   Partial Trace:<br>\n     [1]Applying instance of rewrite rule \"Set.insert_absorb2\":<br>\n     insert ?x1 (insert ?x1 ?A1) ≡ insert ?x1 ?A1 *)<br>\noops</p>\n<p>(<em>5</em>)<br>\ntheorem \"{0::nat, 1, 0} = {0::nat, 0, 1}\"<br>\napply(simp)<br>\n   (* Output: {0, Suc 0, 0} = {0, Suc 0} *)<br>\napply(auto)<br>\n   (* Partial Trace:<br>\n     [1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\n     {0, Suc 0, 0} = {0, Suc 0}<br>\n     [1]SIMPLIFIER INVOKED ON THE FOLLOWING TERM:<br>\n     ⋀x. x = 0 ⟹ x ∉ {} ⟹ 0 &lt; x ⟹ x = Suc 0 *)<br>\ndone</p>\n<p>\"Bug\" is a risky word to use for the logic. I usually just describe the <br>\nbehaviour, imply that it could be a bug, and then let someone tell me <br>\nit's a feature.</p>\n<p><a href=\"https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-February/msg00169.html\">https://lists.cam.ac.uk/mailman/htdig/cl-isabelle-users/2013-February/msg00169.html</a></p>\n<p>The lesson about permutative rewrite rules could apply here also. In <br>\n(<em>3</em>), they don't order the set with a simp rule, so rule <br>\nSet.insert_absorb2 can't be used as it is in (<em>4</em>).</p>\n<p>In (<em>2</em>), \"value\" is eliminating the duplicate without ordering the set.</p>\n<p>In (<em>5</em>), \"simp\" alone can't simplify it. They resort to expanding <br>\nsomething when I use \"auto\". I can't find where the finite set braces is <br>\ndefined, so I can conveniently give up for now.</p>\n<p>It's six of one, or a half dozen of the other.</p>\n<p>Regards,<br>\nGB</p>",
        "id": 294249467,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660910188
    }
]