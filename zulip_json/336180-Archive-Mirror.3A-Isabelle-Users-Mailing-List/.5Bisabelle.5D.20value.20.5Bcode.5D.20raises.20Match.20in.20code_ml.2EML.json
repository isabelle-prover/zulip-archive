[
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nDear experts on the code generator,</p>\n<p>I want to map a HOL type to a built-in type of the target languages using code_type and <br>\ncode_const. For evaluation with the simplifier, however, I want to implement the type by a <br>\npseudo-constructor that has no analogue in the target language, i.e., there is no simple <br>\ncode_const translation for the function declared with code_datatype. The following MWE <br>\nillustrates the setting:</p>\n<p>typedecl foo<br>\nconsts Foo :: foo<br>\ncode_datatype Foo (* constructor for value [simp] *)<br>\ndefinition \"bar = Foo\"<br>\ndefinition \"foobar = bar\"</p>\n<p>value [code] foobar</p>\n<p>code_type foo (SML \"<a href=\"http://IntInf.int\">IntInf.int</a>\")<br>\ncode_const bar (SML \"0\")</p>\n<p>export_code foobar in SML file - (* works *)<br>\nvalue [code] foobar (* fails with Match *)</p>\n<p>code_const Foo (SML \"0\")</p>\n<p>value [code] foobar</p>\n<p>Here, Foo is the constructor that value [simp] uses. After I have declared the adaptations <br>\nfor the type foo and the constant bar, I can still export code for foobar, but \"value <br>\n[code] foobar\" now raises a Match exception in code_ml.ML  (l. 240 in Isabelle2013). If I <br>\nadd any translation for the code_datatype constructor Foo (it seems as if it does not <br>\nmatter what), value [code] works again. The same exception occurs if I export code for <br>\nsomething that uses Foo directly:</p>\n<p>definition \"foo = Foo\"<br>\nexport_code foo in SML file - (* fails if placed between code_type and code_const Foo *)</p>\n<p>For value [code] foobar, I would have expected no error at all.<br>\nFor export_code foo, I would have expected some sensible error message saying that an <br>\nadaptation for Foo is missing.</p>\n<p>My problem is now that I cannot provide a sensible code_const declaration for Foo (other <br>\nthan raise an error at run-time, but I would prefer to get an error message at code <br>\ngeneration if my code uses Foo directly) and I am not allowed to prove a HOL code equation <br>\nfor Foo either (because Foo is a code_datatype constructor), but I have to do something to <br>\nget value [code] working. What is the recommended solution here?</p>\n<p>Best,<br>\nAndreas</p>",
        "id": 294243207,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660907863
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nHi Andreas,</p>\n<blockquote>\n<p>I want to map a HOL type to a built-in type of the target languages<br>\nusing code_type and code_const. For evaluation with the simplifier,<br>\nhowever, I want to implement the type by a pseudo-constructor that has<br>\nno analogue in the target language, i.e., there is no simple code_const<br>\ntranslation for the function declared with code_datatype. The following<br>\nMWE illustrates the setting:</p>\n<p>typedecl foo<br>\nconsts Foo :: foo<br>\ncode_datatype Foo (* constructor for value [simp] *)<br>\ndefinition \"bar = Foo\"<br>\ndefinition \"foobar = bar\"</p>\n<p>value [code] foobar</p>\n<p>code_type foo (SML \"<a href=\"http://IntInf.int\">IntInf.int</a>\")<br>\ncode_const bar (SML \"0\")</p>\n<p>export_code foobar in SML file - (* works *)<br>\nvalue [code] foobar (* fails with Match *)</p>\n</blockquote>\n<p>the reason for the failure is that value [code] always involves a<br>\nsuitable term_of expression.  You have to add a reasonable</p>\n<p>code_const \"Code_Evaluation.term_of :: … foo …\" (Eval …)</p>\n<p>to regain it.</p>\n<blockquote>\n<p>My problem is now that I cannot provide a sensible code_const<br>\ndeclaration for Foo (other than raise an error at run-time, but I would<br>\nprefer to get an error message at code generation if my code uses Foo<br>\ndirectly).</p>\n</blockquote>\n<p>Abstract datatype constructors are explicitly checked for absence.<br>\nMaybe it is possible to tweak your application accordingly.</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/GqDYaSd3IzJV4GxHFP8ydDCe/signature.asc\">signature.asc</a></p>",
        "id": 294243575,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908005
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<blockquote>\n<p>the reason for the failure is that value [code] always involves a<br>\nsuitable term_of expression.<br>\nThanks for the hint with term_of.</p>\n</blockquote>\n<blockquote>\n<p>You have to add a reasonable</p>\n<p>code_const \"Code_Evaluation.term_of :: … foo …\" (Eval …)</p>\n<p>to regain it.<br>\nIn my concrete case, it suffices to declare an appropriate code equation for term_of, <br>\nbecause my type foo is just a typedef foo = \"UNIV :: ...\", so I have a representation <br>\nfunction Rep_foo, i.e., my code equation looks as follows:</p>\n</blockquote>\n<p>term_of_class.term_of x =<br>\nCode_Evaluation.App<br>\n    (Code_Evaluation.Const (STR ''Scratch.Abs_foo'')<br>\n       (typerep.Typerep (STR ''fun'') [..., typerep.Typerep (STR ''<a href=\"http://Scratch.foo\">Scratch.foo</a>'') []]))<br>\n    (term_of_class.term_of (Rep_foo x))</p>\n<p>I am not happy about writing long Isabelle constant names and type names explicity. In ML, <br>\nthere are nice @{type_name} and @{const_name} to generate and check these representations. <br>\nIs there some similar mechanism for these strings. I had a look at Code_Evaluation, but I <br>\nhaven't found anything.</p>\n<blockquote>\n<blockquote>\n<p>My problem is now that I cannot provide a sensible code_const<br>\ndeclaration for Foo (other than raise an error at run-time, but I would<br>\nprefer to get an error message at code generation if my code uses Foo<br>\ndirectly).</p>\n</blockquote>\n<p>Abstract datatype constructors are explicitly checked for absence.<br>\nMaybe it is possible to tweak your application accordingly.<br>\nAbstract datatypes are a good idea, and it is possible in my case. I can also get rid of <br>\nthe code_const for the abstraction function (Abs_foo for the typedef, Foo in the original <br>\nexample). Unfortunately, I am then stuck with the representation function Rep_foo, for example</p>\n</blockquote>\n<p>definition test where \"test = Rep_foo bar\"</p>\n<p>If I declare a code equation for Rep_foo, code generation works for test, but code_simp <br>\nloops. My current solution is to have another identical representation function Rep_foo' <br>\nand a code equation for the Rep_foo' and the canonical \"Rep_foo (Abs_foo x) = x\" for <br>\ncode_simp. Functions then have to use Rep_foo' (except for equations declared as code <br>\nabstract) - if they use Rep_foo directly, I am back at the exception Match when generating <br>\ncode. It would be great if there was a more informative error message.</p>\n<p>Cheers,<br>\nAndreas</p>",
        "id": 294243609,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908017
    },
    {
        "content": "<p>From: Florian Haftmann &lt;<a href=\"mailto:florian.haftmann@informatik.tu-muenchen.de\">florian.haftmann@informatik.tu-muenchen.de</a>&gt;<br>\nI am not sure whether I understand properly.  If Abs_foo is an abstract<br>\nconstructor, the code equation</p>\n<p>Rep_foo (Abs_foo x) = x</p>\n<p>is implicit.  I admit the system allows, pointlessly, to override this,<br>\nbut this should be considered a feature aka bug.  So what is your exact<br>\nsetup?</p>\n<p>Cheers,<br>\n    Florian<br>\n<a href=\"/user_uploads/14278/auRgcxRjhdaxuu6QWmqWPeJS/signature.asc\">signature.asc</a></p>",
        "id": 294243630,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908023
    },
    {
        "content": "<p>From: Andreas Lochbihler &lt;<a href=\"mailto:andreas.lochbihler@inf.ethz.ch\">andreas.lochbihler@inf.ethz.ch</a>&gt;<br>\nHi Florian,</p>\n<p>I have precisely tried to overwrite this code equation. Here's the simplified setup (for <br>\nIsabelle 2cfe6656d6d6, backporting the example to Isabelle2013 does not seem to be worth <br>\nthe effort; I omitted a few tweaks that improve performance):</p>\n<p>typedef uint32 = \"{_ :: 32 word. True}\" by simp<br>\n   (* I do not use UNIV to trick setup_lifting into setting<br>\n      up code generation for an abstract datatype instead of<br>\n      using Abs_foo as the free datatype constructor *)<br>\nsetup_lifting type_definition_uint32</p>\n<p>(* transfer all the type class instantiations for 32 word to uint32<br>\n    using lift_definition (neg_numeral, comm_ring, equal, bits, ...) *)</p>\n<p>code_printing<br>\n   type_constructor uint32 =&gt;<br>\n   (SML) \"Word32.word\" and<br>\n| constant \"0 :: uint32\" =&gt;<br>\n   (SML) \"(Word32.fromInt 0)\" and<br>\n| ...</p>\n<p>lemma [code, code del]: \"term_of_class.term_of = (term_of_class.term_of :: uint32 =&gt; _)\"<br>\n..</p>\n<p>definition Rep_uint32' where [simp]: \"Rep_uint32' = Rep_uint32\"</p>\n<p>lemma Rep_uint32'_code [code]: \"Rep_uint32' x = (BITS n. x !! n)\"<br>\nunfolding Rep_uint32'_def by transfer simp</p>\n<p>(* Implement term reconstruction for uint32 in terms of 32 word. *)<br>\nlemma term_of_uint32_code [code]:<br>\n   defines \"TR == typerep.Typerep\" and \"bit0 == STR ''Numeral_Type.bit0''\"<br>\n   shows<br>\n   \"term_of_class.term_of x =<br>\n    Code_Evaluation.App (Code_Evaluation.Const (STR ''Uint32.Abs_uint32'') (TR (STR <br>\n''fun'') [TR (STR ''Word.word'') [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR <br>\n''Numeral_Type.num1'') []]]]]]], TR (STR ''Uint32.uint32'') []]))<br>\n        (term_of_class.term_of (Rep_uint32' x))\"<br>\nby(simp add: term_of_anything)</p>\n<p>Note that in the last line of lemma term_of_uint32_code, I now use Rep_uint32' and not <br>\nRep_uint32. If I use Rep_uint32 instead, I get into trouble: every value [code] command <br>\nthen generates ML code that contains the definition</p>\n<p>fun rep_uint32 (... x) = x</p>\n<p>where ... is the serialisation of Abs_uint32. Without custom serialisation for Abs_uint32, <br>\nI only got various exceptions in the code generator. But I cannot give any serialisation <br>\nthat would fit into that position, because there is no ML constructor to pattern match on. <br>\nSo I thought I should derive my own code equation for Rep_uint32:</p>\n<p>lemma Rep_uint32_code [code]: \"Rep_uint32 x = (BITS n. x !! n)\" by transfer simp</p>\n<p>Then, value [code] works perfectly fine and I don't even need to give a serialisation for <br>\nAbs_uint32. :-) Unfortunately, value [simp] \"Rep_uint32 5\" loops, because value [simp] is <br>\nnot aware of all the code_printing (code_const/code_type/...) adaptations. I have not been <br>\nable to trace the simplifier for value [simp] because [[simp_trace]] first outputs all the <br>\ncode_unfold preprocessing steps and that trace alone has more than 300000 lines which <br>\nfreezes jEdit and crashes PG). Do you know a way to trace value [simp]?</p>\n<p>So I thought that the following might happen (without being able to verify this):</p>\n<ul>\n<li>5 is represented as \"numeral (num.Bit1 (num.Bit0 num.One))\"</li>\n<li>\n<p>I have a setup that implements uint32 numerals in terms of integer<br>\n   in the generated code via a coercion function Uint32 :: integer =&gt; uint32, i.e.,<br>\n   we are evaluating the following:<br>\n   Rep_uint32 (Uint32 (numeral (num.Bit1 (num.Bit0 num.One))))</p>\n</li>\n<li>\n<p>Uint32 has a code equation of the form<br>\n   Uint32_code: \"Rep_uint32 (Uint32 n) = word_of_int (int_of_integer n)\"</p>\n</li>\n<li>\n<p>So the simplfier now has two options, either rewrite with Rep_uint32_code<br>\n   or with Uint32_code. Unfortunately, it seems to pick the wrong Rep_uint32_code, so we<br>\n   get<br>\n   BITS n. Uint32 ... !! n</p>\n</li>\n<li>\n<p>Now, the code equation for op !! kicks in: i !! n = Rep_uint32 i !! n</p>\n</li>\n<li>And now, there is another Rep_uint32 waiting to be rewritten to with Rep_uint32_code.<br>\n   This closes the loop.</li>\n</ul>\n<p>Is this understanding correct?</p>\n<p>The code equation Rep_uint32 has not caused any problems in the generated code (both with <br>\nexport_code and value [code]), because the code generator eliminates all these Rep_uint32 <br>\noccurrences (except for the one in term_of_uint32_code, but that's fine.</p>\n<p>My solution at the moment is to define this second destructor Rep_uint32' and implement it <br>\nwith BITS and keep Rep_uint32 as it is for code_simp. There's only one downside with this <br>\nso far. If I use Rep_uint32 in a position where the transformation for abstract datatypes <br>\ndoes not eliminate it, e.g., in value [code] \"Rep_uint32 5\", I get a Match exception in <br>\ncode_ml.ML. If I add a serialisation for Abs_uint32, code generation succeeds, but the ML <br>\ncompiler rejects it because ... in the following cannot be a constructor:</p>\n<p>fun Rep_uint32 (... n) = n</p>\n<p>I would prefer if the code generator raises a more sensible error message than Match here.</p>\n<p>What do you think of my setup? Is this going the right way?</p>\n<p>Andreas</p>",
        "id": 294243650,
        "sender_full_name": "Email Gateway",
        "timestamp": 1660908035
    }
]