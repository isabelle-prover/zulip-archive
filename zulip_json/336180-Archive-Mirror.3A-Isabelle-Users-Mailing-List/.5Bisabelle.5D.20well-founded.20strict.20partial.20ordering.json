[
    {
        "content": "<p>From: Christian Sternagel &lt;<a href=\"mailto:c.sternagel@gmail.com\">c.sternagel@gmail.com</a>&gt;<br>\nDear Sophie,</p>\n<p>I required both well-founded partial orders and the possibility to<br>\nobtain minimal elements in the past.</p>\n<p>Which is why there are at least two further places you could consult:</p>\n<p>(1) Well-founded Partial Orders<br>\n===============================</p>\n<p>I formalized predicates \"po_on\" (for partial orders) and \"wfp_on\" (for<br>\nwell-founded relations) in</p>\n<p><a href=\"https://www.isa-afp.org/browser_info/current/AFP/Open_Induction/Restricted_Predicates.html\">https://www.isa-afp.org/browser_info/current/AFP/Open_Induction/Restricted_Predicates.html</a></p>\n<p>where the \"p\" in \"wfp_on\" refers to the fact that I am using the<br>\n\"predicate\" version of relations, namely:</p>\n<p>'a =&gt; 'a =&gt; bool</p>\n<p>instead of</p>\n<p>('a * 'a) set</p>\n<p>and \"_on\" refers to the fact that there is a specific carrier set.</p>\n<p>(2) Minimal Elements<br>\n=====================</p>\n<p>There is the locale \"minimal_element\" in</p>\n<p><a href=\"https://www.isa-afp.org/browser_info/current/AFP/Well_Quasi_Orders/Minimal_Elements.html\">https://www.isa-afp.org/browser_info/current/AFP/Well_Quasi_Orders/Minimal_Elements.html</a></p>\n<p>which captures well-founded partial orders and provides a constant<br>\n\"min_elt B\" that yields some minimal element from a given set \"B\"<br>\ntogether with some facts about it.</p>\n<p>cheers</p>\n<p>chris</p>",
        "id": 294742842,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661192258
    },
    {
        "content": "<p>From: Sophie Tourret &lt;<a href=\"mailto:stourret@mpi-inf.mpg.de\">stourret@mpi-inf.mpg.de</a>&gt;<br>\nHello,</p>\n<p>I would like to know if there exist a generic well-founded strict <br>\npartial ordering available somewhere in Isabelle/HOL.</p>\n<p>In more details:</p>\n<p>I need to use a well-founded strict partial ordering in some <br>\nisabelle/HOL proof I am currently working on. I found the wellorder <br>\nclass and could use it to some extend but it is build on a total <br>\nordering and I really need the ordering to be partial (and strict and <br>\nwell-founded). In particular, I need to be able to obtain minimal <br>\nelements verifying some properties and reason on them.</p>\n<p>I have taken a look around and my current plan is to extend the preorder <br>\nclass with well-foundedness (and prove the existence of minimal elements <br>\nand needed properties by myself).</p>\n<p>This looks like a lot of work (at least for someone relatively new to <br>\nIsabelle like me), thus before I start I would like to know if I have <br>\nmissed something that does what I need (and suggestions of better plans <br>\nare also welcome). Here is where I looked and why I think it is not <br>\nexactly what I need.</p>\n<p>Anything about lattices is out because I want no supremum at all and no <br>\nunique infimum.</p>\n<p>[Main] HOL.Orderings.thy - where the classes wellorder and preorder are, <br>\nI didn't find a partial strict well-founded order there.<br>\n[Main] HOL.Wellfounded.thy - deals with binary relations, not with <br>\norderings. Maybe I could use it but is looks trickier than my plan.</p>\n<p>[IsaFOR] Quasi_Order.thy - maybe the class wf_order does what I want but <br>\nI am not sure and I don't see how I can use it to get a minimal element. <br>\nAgain, it doesn't look better than my plan to me.</p>\n<p>Best,<br>\n Â  Sophie<br>\n<a href=\"/user_uploads/14278/5ooF846zVOiGva4XKAJ55OzS/smime.p7s\">smime.p7s</a></p>",
        "id": 294745263,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661193182
    }
]