[
    {
        "content": "<p>From: michel levy &lt;<a href=\"mailto:michel.levy@imag.fr\">michel.levy@imag.fr</a>&gt;<br>\nI am an french beginner in Isabelle. I prove (as an exercise) the<br>\nfollowing lemma<br>\nlemma \"∀ y. P y ⟹ P (f a)\"<br>\n  apply (erule_tac x=\"f a\" in allE)<br>\n  apply (assumption)<br>\n  done<br>\nBut why am I obliged to use x in instantiating the quantifier (x = \"f a\").<br>\nIf I use y = \"f a\" to instantiate the quantifier, I have a message \"no<br>\nsuch variable in theorem\".</p>",
        "id": 294657521,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168665
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nDear Michel,<br>\nyou can have a look at the theorem using the command \"thm allE\". The<br>\nsystem will print:</p>\n<p>∀x. ?P x ⟹ (?P ?x ⟹ ?R) ⟹ ?R</p>\n<p>As you can see, the theorem itself uses the variable \"x\". When<br>\ninstantiating rules like \"x1 = t1\", \"x2 = t2\", ... the variables on the<br>\nleft-hand side must occur in the theorem you're instantiating.</p>\n<p>(I think this also answers your other question.)</p>\n<p>Cheers<br>\nLars</p>\n<p>PS: Proof methods ending with \"_tac\" are considered \"legacy\" and should<br>\nonly be used if you know what you're doing. If you're a beginner, I<br>\nwould strongly recommend sticking to modern Isar-style proofs.</p>",
        "id": 294657541,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168670
    },
    {
        "content": "<p>From: Lars Hupel &lt;<a href=\"mailto:hupel@in.tum.de\">hupel@in.tum.de</a>&gt;<br>\nHi,</p>\n<blockquote>\n<p>I have started with the document <em>tutorial.pdf</em> which uses mainly<br>\napply(method)  in Chapter 5 to build proofs.</p>\n</blockquote>\n<p>the tutorial, while still accurate, is somewhat outdated in some<br>\nrespects. I recommend the newer book \"Programming and Proving in<br>\nIsabelle/HOL\":</p>\n<p>&lt;<a href=\"https://isabelle.in.tum.de/dist/Isabelle2015/doc/prog-prove.pdf\">https://isabelle.in.tum.de/dist/Isabelle2015/doc/prog-prove.pdf</a>&gt;</p>\n<blockquote>\n<p>1) type problem<br>\nlemma \"⟦ALL y. P y ; Q b ⟧ ⟹ P a\"<br>\napply(erule_tac x=\"b\" in allE)<br>\nvariable 'b not of of sort type<br>\nI don't understand this message. Clearly my method is not leading to a<br>\nproof (I must choose x = \"a\").<br>\nBut I don't understand why the instantiation of the schematic ?x by \"b\"<br>\nis rejected.</p>\n</blockquote>\n<p>In Isabelle, types can have sorts. In almost all cases, at least the<br>\nsort \"type\" is required to do anything useful. Usually, this sort will<br>\nbe automatically inserted by type inference. There are corner cases<br>\nthough for which that doesn't work. You ran into one of these. According<br>\nto another thread on this list, this happens \"if the type of a variable<br>\nis fully unconstrained\"<br>\n(&lt;<a href=\"https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2014-August/msg00166.html\">https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2014-August/msg00166.html</a>&gt;).</p>\n<blockquote>\n<p>2) representation of natural deduction in Isabelle<br>\nHow the rule allI  !!x. ?P x ==&gt; !x. P x implements the <em>proviso</em> x not<br>\nfree in the hypotheses of A in the rule A / !x. A<br>\nClearly I have the same question for the rule exE.</p>\n</blockquote>\n<p>I'm not quite sure whether this proviso is required for these rules in<br>\nIsabelle, since the variable \"x\" is still quantified in the premise.<br>\nThere is however a primitive inference rule in the underlying proof<br>\nkernel which allows to generalize variables, and there, these checks<br>\nhappen. But these rules are usually not exposed to the user.</p>\n<p>Cheers<br>\nLars</p>",
        "id": 294657672,
        "sender_full_name": "Email Gateway",
        "timestamp": 1661168720
    }
]